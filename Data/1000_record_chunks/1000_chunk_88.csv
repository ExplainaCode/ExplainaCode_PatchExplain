record_number,buggy_code,fixed_code,code_similarity
87001,"public Passphrase getPassphraseForEnvironment(Context context,Environment environment){
  if (id > 0) {
    if (environment.getId() <= 0) {
      environment=Environment.getBareboneEnvironment(context,environment.getName());
    }
    Cursor passwordCursor=context.getContentResolver().query(UsersEntry.buildUserUriWithIdEnvironmentAndPassword(id,environment.getId()),null,null,null,null);
    if (passwordCursor.moveToFirst()) {
      Passphrase returnPassphrase=Passphrase.getPassphraseFromCursor(passwordCursor);
      passwordCursor.close();
      return returnPassphrase;
    }
    Log.w(LOG_TAG,""String_Node_Str"");
    return null;
  }
  Log.w(LOG_TAG,""String_Node_Str"");
  return null;
}","public Passphrase getPassphraseForEnvironment(Context context,Environment environment){
  if (id > 0) {
    if (environment.getId() <= 0) {
      environment=Environment.getBareboneEnvironment(context,environment.getName());
    }
    Cursor passwordCursor=context.getContentResolver().query(UsersEntry.buildUserUriWithIdEnvironmentAndPassword(id,environment.getId()),null,null,null,null);
    if (passwordCursor != null && passwordCursor.moveToFirst()) {
      Passphrase returnPassphrase=Passphrase.getPassphraseFromCursor(passwordCursor);
      passwordCursor.close();
      return returnPassphrase;
    }
    Log.w(LOG_TAG,""String_Node_Str"");
    return null;
  }
  Log.w(LOG_TAG,""String_Node_Str"");
  return null;
}",0.9816124469589816
87002,"/** 
 * Changes the environment variable values (id, enabled) of an environment to new specified values, updates in the db.
 * @param enabledColumnName
 * @param newEnabledValue
 * @param idColumnName
 * @param newId
 * @param environmentId
 * @param db
 * @return The id of the variable before the environment was updated
 */
private long changeEnvironmentVariableValue(String enabledColumnName,int newEnabledValue,String idColumnName,long newId,long environmentId,SQLiteDatabase db){
  long variableId;
  Cursor environmentCursor=query(EnvironmentEntry.buildEnvironmentUriWithId(environmentId),null,null,null,null);
  if (environmentCursor.moveToFirst()) {
    variableId=environmentCursor.getLong(environmentCursor.getColumnIndex(idColumnName));
    ContentValues environmentUpdateValues=new ContentValues();
    environmentUpdateValues.put(enabledColumnName,newEnabledValue);
    if (newEnabledValue == 1) {
      environmentUpdateValues.put(idColumnName,newId);
    }
 else {
      environmentUpdateValues.put(idColumnName,(String)null);
    }
    String environmentSelection=EnvironmentEntry._ID + ""String_Node_Str"";
    String[] environmentSelectionArgs=new String[]{String.valueOf(environmentId)};
    db.update(EnvironmentEntry.TABLE_NAME,environmentUpdateValues,environmentSelection,environmentSelectionArgs);
  }
 else {
    Log.e(LOG_TAG,""String_Node_Str"" + environmentId);
    environmentCursor.close();
    throw new IllegalArgumentException(""String_Node_Str"" + environmentId);
  }
  environmentCursor.close();
  return variableId;
}","/** 
 * Changes the environment variable values (id, enabled) of an environment to new specified values, updates in the db.
 * @param enabledColumnName Name of column which stores whether the Environment Variable is enabled.
 * @param newEnabledValue Current enabled status
 * @param idColumnName Name of column which stores the environment variable id.
 * @param newId New id of the environment variable. Pass anything if its not enabled
 * @param environmentId Id of the environment to be modified
 * @param db An instance of the SQLiteDatabase representing environment.db
 * @return The id of the variable before the environment was updated
 */
private long changeEnvironmentVariableValue(String enabledColumnName,int newEnabledValue,String idColumnName,long newId,long environmentId,SQLiteDatabase db){
  long variableId;
  Cursor environmentCursor=query(EnvironmentEntry.buildEnvironmentUriWithId(environmentId),null,null,null,null);
  if (environmentCursor.moveToFirst()) {
    try {
      variableId=environmentCursor.getLong(environmentCursor.getColumnIndex(idColumnName));
    }
 catch (    Exception e) {
      variableId=-1;
    }
    ContentValues environmentUpdateValues=new ContentValues();
    environmentUpdateValues.put(enabledColumnName,newEnabledValue);
    if (newEnabledValue == 1) {
      environmentUpdateValues.put(idColumnName,newId);
    }
 else {
      environmentUpdateValues.put(idColumnName,(String)null);
    }
    String environmentSelection=EnvironmentEntry._ID + ""String_Node_Str"";
    String[] environmentSelectionArgs=new String[]{String.valueOf(environmentId)};
    db.update(EnvironmentEntry.TABLE_NAME,environmentUpdateValues,environmentSelection,environmentSelectionArgs);
  }
 else {
    Log.e(LOG_TAG,""String_Node_Str"" + environmentId);
    environmentCursor.close();
    throw new IllegalArgumentException(""String_Node_Str"" + environmentId);
  }
  environmentCursor.close();
  return variableId;
}",0.8872956696300545
87003,"@Override public Uri insert(Uri uri,ContentValues values){
  SQLiteDatabase db=mEnvironmentDbHelper.getWritableDatabase();
  long _id;
  Uri returnUri;
switch (sUriMatcher.match(uri)) {
case GEOFENCE:
    _id=db.insert(GeoFenceEntry.TABLE_NAME,null,values);
  if (_id > 0) {
    returnUri=GeoFenceEntry.buildGeofenceUriWithId(_id);
  }
 else {
    Log.e(LOG_TAG,""String_Node_Str"" + uri);
    throw new SQLiteException(""String_Node_Str"" + uri);
  }
break;
case ENVIRONMENT:
_id=db.insert(EnvironmentEntry.TABLE_NAME,null,values);
if (_id > 0) {
returnUri=EnvironmentEntry.buildEnvironmentUriWithId(_id);
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case ENVIRONMENT_WITH_ID_AND_GEOFENCES:
_id=insertEnvironmentLocation(uri,db,values);
if (_id > 0) {
returnUri=EnvironmentEntry.buildEnvironmentUriWithId(Long.parseLong(uri.getPathSegments().get(1)));
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case WIFI_NETWORK:
_id=db.insert(WiFiNetworksEntry.TABLE_NAME,null,values);
if (_id > 0) {
returnUri=WiFiNetworksEntry.buildWiFiUriWithId(_id);
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case ENVIRONMENT_WITH_ID_AND_WIFI_NETWORKS:
_id=insertEnvironmentWifiNetwork(uri,db,values);
if (_id > 0) {
returnUri=EnvironmentEntry.buildEnvironmentUriWithId(Long.parseLong(uri.getPathSegments().get(1)));
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case BLUETOOTH_DEVICE:
_id=db.insert(BluetoothDevicesEntry.TABLE_NAME,null,values);
if (_id > 0) {
returnUri=BluetoothDevicesEntry.buildBluetoothUriWithId(_id);
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case ENVIRONMENT_WITH_ID_AND_BLUETOOTH_DEVICES:
_id=insertEnvironmentBluetoothDevice(uri,db,values);
if (_id > 0) {
returnUri=EnvironmentEntry.buildEnvironmentUriWithId(Long.parseLong(uri.getPathSegments().get(1)));
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case USER:
_id=db.insert(UsersEntry.TABLE_NAME,null,values);
if (_id > 0) {
returnUri=UsersEntry.buildUserUriWithId(_id);
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case USER_WITH_ID_AND_APP_WHITELIST:
String userIdString=uri.getPathSegments().get(1);
if (values.get(AppWhitelistEntry.COLUMN_USER_ID) == null) {
values.put(AppWhitelistEntry.COLUMN_USER_ID,userIdString);
}
_id=db.insert(AppWhitelistEntry.TABLE_NAME,null,values);
if (_id > 0) {
returnUri=UsersEntry.buildUserUriWithId(Long.valueOf(userIdString));
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case USER_WITH_ID_ENVIRONMENT_AND_PASSWORD:
_id=insertPassword(uri,db,values);
if (_id > 0) {
returnUri=UsersEntry.buildUserUriWithId(Long.parseLong(uri.getPathSegments().get(1)));
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + uri);
}
getContext().getContentResolver().notifyChange(uri,null);
return returnUri;
}","@Override public Uri insert(Uri uri,ContentValues values){
  SQLiteDatabase db=mEnvironmentDbHelper.getWritableDatabase();
  long _id;
  Uri returnUri;
switch (sUriMatcher.match(uri)) {
case GEOFENCE:
    _id=db.insert(GeoFenceEntry.TABLE_NAME,null,values);
  if (_id > 0) {
    returnUri=GeoFenceEntry.buildGeofenceUriWithId(_id);
  }
 else {
    Log.e(LOG_TAG,""String_Node_Str"" + uri);
    throw new SQLiteException(""String_Node_Str"" + uri);
  }
break;
case ENVIRONMENT:
_id=db.insert(EnvironmentEntry.TABLE_NAME,null,values);
if (_id > 0) {
returnUri=EnvironmentEntry.buildEnvironmentUriWithId(_id);
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case ENVIRONMENT_WITH_ID_AND_GEOFENCES:
_id=insertEnvironmentLocation(uri,db,values)[1];
if (_id > 0) {
returnUri=EnvironmentEntry.buildEnvironmentUriWithId(Long.parseLong(uri.getPathSegments().get(1)));
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case WIFI_NETWORK:
_id=db.insert(WiFiNetworksEntry.TABLE_NAME,null,values);
if (_id > 0) {
returnUri=WiFiNetworksEntry.buildWiFiUriWithId(_id);
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case ENVIRONMENT_WITH_ID_AND_WIFI_NETWORKS:
_id=insertEnvironmentWifiNetwork(uri,db,values)[1];
if (_id > 0) {
returnUri=EnvironmentEntry.buildEnvironmentUriWithId(Long.parseLong(uri.getPathSegments().get(1)));
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case BLUETOOTH_DEVICE:
_id=db.insert(BluetoothDevicesEntry.TABLE_NAME,null,values);
if (_id > 0) {
returnUri=BluetoothDevicesEntry.buildBluetoothUriWithId(_id);
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case ENVIRONMENT_WITH_ID_AND_BLUETOOTH_DEVICES:
_id=insertEnvironmentBluetoothDevice(uri,db,values);
if (_id > 0) {
returnUri=EnvironmentEntry.buildEnvironmentUriWithId(Long.parseLong(uri.getPathSegments().get(1)));
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case USER:
_id=db.insert(UsersEntry.TABLE_NAME,null,values);
if (_id > 0) {
returnUri=UsersEntry.buildUserUriWithId(_id);
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case USER_WITH_ID_AND_APP_WHITELIST:
String userIdString=uri.getPathSegments().get(1);
if (values.get(AppWhitelistEntry.COLUMN_USER_ID) == null) {
values.put(AppWhitelistEntry.COLUMN_USER_ID,userIdString);
}
_id=db.insert(AppWhitelistEntry.TABLE_NAME,null,values);
if (_id > 0) {
returnUri=UsersEntry.buildUserUriWithId(Long.valueOf(userIdString));
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
case USER_WITH_ID_ENVIRONMENT_AND_PASSWORD:
_id=insertPassword(uri,db,values);
if (_id > 0) {
returnUri=UsersEntry.buildUserUriWithId(Long.parseLong(uri.getPathSegments().get(1)));
}
 else {
Log.e(LOG_TAG,""String_Node_Str"" + uri);
throw new SQLiteException(""String_Node_Str"" + uri);
}
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + uri);
}
getContext().getContentResolver().notifyChange(uri,null);
return returnUri;
}",0.9991023339317774
87004,"@Override public int update(Uri uri,ContentValues values,String selection,String[] selectionArgs){
  int returnValue;
  SQLiteDatabase db=mEnvironmentDbHelper.getWritableDatabase();
switch (sUriMatcher.match(uri)) {
case ENVIRONMENT_WITH_ID:
    selection=EnvironmentEntry._ID + ""String_Node_Str"";
  selectionArgs=new String[]{getIdFromUriAsString(uri)};
case ENVIRONMENT:
returnValue=db.update(EnvironmentEntry.TABLE_NAME,values,selection,selectionArgs);
break;
case ENVIRONMENT_WITH_ID_AND_GEOFENCES:
long environmentId=Long.parseLong(uri.getPathSegments().get(1));
long newGeofenceId=db.insert(GeoFenceEntry.TABLE_NAME,null,values);
long oldGeofenceId=changeEnvironmentVariableValue(EnvironmentEntry.COLUMN_IS_LOCATION_ENABLED,1,EnvironmentEntry.COLUMN_GEOFENCE_ID,newGeofenceId,environmentId,db);
selection=GeoFenceEntry._ID + ""String_Node_Str"";
selectionArgs=new String[]{String.valueOf(oldGeofenceId)};
returnValue=(newGeofenceId != oldGeofenceId) ? 1 : 0;
returnValue+=deleteEnvironmentVariableWithUsageSearch(EnvironmentEntry.COLUMN_GEOFENCE_ID,GeoFenceEntry._ID,GeoFenceEntry.TABLE_NAME,selection,selectionArgs,db);
break;
case ENVIRONMENT_WITH_ID_AND_WIFI_NETWORKS:
environmentId=Long.parseLong(uri.getPathSegments().get(1));
long newWifiId=db.insert(WiFiNetworksEntry.TABLE_NAME,null,values);
long oldWifiId=changeEnvironmentVariableValue(EnvironmentEntry.COLUMN_IS_WIFI_ENABLED,1,EnvironmentEntry.COLUMN_WIFI_ID,newWifiId,environmentId,db);
selection=WiFiNetworksEntry._ID + ""String_Node_Str"";
selectionArgs=new String[]{String.valueOf(oldWifiId)};
returnValue=(newWifiId != oldWifiId) ? 1 : 0;
returnValue+=deleteEnvironmentVariableWithUsageSearch(EnvironmentEntry.COLUMN_WIFI_ID,WiFiNetworksEntry._ID,WiFiNetworksEntry.TABLE_NAME,selection,selectionArgs,db);
break;
case USER_WITH_ID_ENVIRONMENT_AND_PASSWORD:
returnValue=updatePasswordForUserAndEnvironment(db,uri,values);
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + uri);
}
getContext().getContentResolver().notifyChange(uri,null);
return returnValue;
}","@Override public int update(Uri uri,ContentValues values,String selection,String[] selectionArgs){
  int returnValue;
  SQLiteDatabase db=mEnvironmentDbHelper.getWritableDatabase();
switch (sUriMatcher.match(uri)) {
case ENVIRONMENT_WITH_ID:
    selection=EnvironmentEntry._ID + ""String_Node_Str"";
  selectionArgs=new String[]{getIdFromUriAsString(uri)};
case ENVIRONMENT:
returnValue=db.update(EnvironmentEntry.TABLE_NAME,values,selection,selectionArgs);
break;
case ENVIRONMENT_WITH_ID_AND_GEOFENCES:
long[] geofenceIds=insertEnvironmentLocation(uri,db,values);
long newGeofenceId=geofenceIds[1];
long oldGeofenceId=geofenceIds[0];
selection=GeoFenceEntry._ID + ""String_Node_Str"";
selectionArgs=new String[]{String.valueOf(oldGeofenceId)};
returnValue=(newGeofenceId != oldGeofenceId) ? 1 : 0;
returnValue+=deleteEnvironmentVariableWithUsageSearch(EnvironmentEntry.COLUMN_GEOFENCE_ID,GeoFenceEntry._ID,GeoFenceEntry.TABLE_NAME,selection,selectionArgs,db);
break;
case ENVIRONMENT_WITH_ID_AND_WIFI_NETWORKS:
long[] wifiIds=insertEnvironmentWifiNetwork(uri,db,values);
long newWifiId=wifiIds[1];
long oldWifiId=wifiIds[0];
selection=WiFiNetworksEntry._ID + ""String_Node_Str"";
selectionArgs=new String[]{String.valueOf(oldWifiId)};
returnValue=(newWifiId != oldWifiId) ? 1 : 0;
returnValue+=deleteEnvironmentVariableWithUsageSearch(EnvironmentEntry.COLUMN_WIFI_ID,WiFiNetworksEntry._ID,WiFiNetworksEntry.TABLE_NAME,selection,selectionArgs,db);
break;
case USER_WITH_ID_ENVIRONMENT_AND_PASSWORD:
returnValue=updatePasswordForUserAndEnvironment(db,uri,values);
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + uri);
}
getContext().getContentResolver().notifyChange(uri,null);
return returnValue;
}",0.5267620561738209
87005,"private long insertEnvironmentLocation(Uri uri,SQLiteDatabase db,ContentValues values){
  long environmentId=Long.parseLong(uri.getPathSegments().get(1));
  String geofenceSelection=GeoFenceEntry.COLUMN_LOCATION_NAME + ""String_Node_Str"";
  String[] geofenceSelectionArgs=new String[]{values.getAsString(GeoFenceEntry.COLUMN_LOCATION_NAME)};
  Cursor geofenceCursor=db.query(GeoFenceEntry.TABLE_NAME,null,geofenceSelection,geofenceSelectionArgs,null,null,null);
  long geofenceId;
  if (!geofenceCursor.moveToFirst()) {
    String receivedValues=values.getAsString(GeoFenceEntry.COLUMN_COORD_LAT) + ""String_Node_Str"" + values.getAsString(GeoFenceEntry.COLUMN_COORD_LONG)+ ""String_Node_Str""+ values.getAsString(GeoFenceEntry.COLUMN_RADIUS);
    Log.d(LOG_TAG,""String_Node_Str"" + receivedValues);
    geofenceId=db.insert(GeoFenceEntry.TABLE_NAME,null,values);
  }
 else {
    geofenceId=geofenceCursor.getLong(geofenceCursor.getColumnIndex(GeoFenceEntry._ID));
  }
  if (geofenceId == -1) {
    geofenceCursor.close();
    return -1;
  }
  ContentValues environmentContentValues=new ContentValues();
  environmentContentValues.put(EnvironmentEntry.COLUMN_IS_LOCATION_ENABLED,1);
  environmentContentValues.put(EnvironmentEntry.COLUMN_GEOFENCE_ID,geofenceId);
  geofenceCursor.close();
  return db.update(EnvironmentEntry.TABLE_NAME,environmentContentValues,EnvironmentEntry._ID + ""String_Node_Str"",new String[]{String.valueOf(environmentId)});
}","private long[] insertEnvironmentLocation(Uri uri,SQLiteDatabase db,ContentValues values){
  long environmentId=Long.parseLong(uri.getPathSegments().get(1));
  String geofenceSelection=GeoFenceEntry.COLUMN_LOCATION_NAME + ""String_Node_Str"";
  String[] geofenceSelectionArgs=new String[]{values.getAsString(GeoFenceEntry.COLUMN_LOCATION_NAME)};
  Cursor geofenceCursor=db.query(GeoFenceEntry.TABLE_NAME,null,geofenceSelection,geofenceSelectionArgs,null,null,null);
  long geofenceId;
  if (!geofenceCursor.moveToFirst()) {
    String receivedValues=values.getAsString(GeoFenceEntry.COLUMN_COORD_LAT) + ""String_Node_Str"" + values.getAsString(GeoFenceEntry.COLUMN_COORD_LONG)+ ""String_Node_Str""+ values.getAsString(GeoFenceEntry.COLUMN_RADIUS);
    Log.d(LOG_TAG,""String_Node_Str"" + receivedValues);
    geofenceId=db.insert(GeoFenceEntry.TABLE_NAME,null,values);
  }
 else {
    boolean isLatEqual=isEqual(values.getAsDouble(GeoFenceEntry.COLUMN_COORD_LAT),geofenceCursor.getDouble(geofenceCursor.getColumnIndex(GeoFenceEntry.COLUMN_COORD_LAT))), isLongEqual=isEqual(values.getAsDouble(GeoFenceEntry.COLUMN_COORD_LONG),geofenceCursor.getDouble(geofenceCursor.getColumnIndex(GeoFenceEntry.COLUMN_COORD_LONG))), isRadiusEqual=values.getAsInteger(GeoFenceEntry.COLUMN_RADIUS) == geofenceCursor.getInt(geofenceCursor.getColumnIndex(GeoFenceEntry.COLUMN_RADIUS));
    if (isLatEqual && isLongEqual && isRadiusEqual) {
      geofenceId=geofenceCursor.getLong(geofenceCursor.getColumnIndex(GeoFenceEntry._ID));
    }
 else {
      Cursor environmentCursor=query(EnvironmentEntry.buildEnvironmentUriWithId(environmentId),null,null,null,null);
      if (!environmentCursor.moveToFirst()) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      String newLocationName=geofenceSelectionArgs[0] + ""String_Node_Str"" + environmentCursor.getString(environmentCursor.getColumnIndex(EnvironmentEntry.COLUMN_NAME));
      values.remove(GeoFenceEntry.COLUMN_LOCATION_NAME);
      values.put(GeoFenceEntry.COLUMN_LOCATION_NAME,newLocationName);
      geofenceId=db.insert(GeoFenceEntry.TABLE_NAME,null,values);
      environmentCursor.close();
    }
  }
  geofenceCursor.close();
  if (geofenceId == -1) {
    return new long[]{-1,-1};
  }
  Long oldGeofenceId=changeEnvironmentVariableValue(EnvironmentEntry.COLUMN_IS_LOCATION_ENABLED,1,EnvironmentEntry.COLUMN_GEOFENCE_ID,geofenceId,environmentId,db);
  return new long[]{oldGeofenceId,geofenceId};
}",0.486777920410783
87006,"private long insertEnvironmentWifiNetwork(Uri uri,SQLiteDatabase db,ContentValues values){
  long environmentId=Long.parseLong(uri.getPathSegments().get(1));
  String wifiSelection=WiFiNetworksEntry.COLUMN_SSID + ""String_Node_Str"" + WiFiNetworksEntry.COLUMN_ENCRYPTION_TYPE+ ""String_Node_Str"";
  String[] wifiSelectionArgs=new String[]{values.getAsString(WiFiNetworksEntry.COLUMN_SSID),values.getAsString(WiFiNetworksEntry.COLUMN_ENCRYPTION_TYPE)};
  Cursor wifiCursor=db.query(WiFiNetworksEntry.TABLE_NAME,new String[]{WiFiNetworksEntry._ID},wifiSelection,wifiSelectionArgs,null,null,null);
  long wifiId;
  if (wifiCursor.getCount() == 0) {
    wifiId=db.insert(WiFiNetworksEntry.TABLE_NAME,null,values);
  }
 else {
    wifiCursor.moveToFirst();
    wifiId=wifiCursor.getLong(wifiCursor.getColumnIndex(WiFiNetworksEntry._ID));
  }
  if (wifiId == -1) {
    wifiCursor.close();
    return -1;
  }
  ContentValues environmentContentValues=new ContentValues();
  environmentContentValues.put(EnvironmentEntry.COLUMN_IS_WIFI_ENABLED,1);
  environmentContentValues.put(EnvironmentEntry.COLUMN_WIFI_ID,wifiId);
  wifiCursor.close();
  return db.update(EnvironmentEntry.TABLE_NAME,environmentContentValues,EnvironmentEntry._ID + ""String_Node_Str"",new String[]{String.valueOf(environmentId)});
}","private long[] insertEnvironmentWifiNetwork(Uri uri,SQLiteDatabase db,ContentValues values){
  long environmentId=Long.parseLong(uri.getPathSegments().get(1));
  String wifiSelection=WiFiNetworksEntry.COLUMN_SSID + ""String_Node_Str"" + WiFiNetworksEntry.COLUMN_ENCRYPTION_TYPE+ ""String_Node_Str"";
  String[] wifiSelectionArgs=new String[]{values.getAsString(WiFiNetworksEntry.COLUMN_SSID),values.getAsString(WiFiNetworksEntry.COLUMN_ENCRYPTION_TYPE)};
  Cursor wifiCursor=db.query(WiFiNetworksEntry.TABLE_NAME,new String[]{WiFiNetworksEntry._ID},wifiSelection,wifiSelectionArgs,null,null,null);
  long wifiId;
  if (wifiCursor.getCount() == 0) {
    wifiId=db.insert(WiFiNetworksEntry.TABLE_NAME,null,values);
  }
 else {
    wifiCursor.moveToFirst();
    wifiId=wifiCursor.getLong(wifiCursor.getColumnIndex(WiFiNetworksEntry._ID));
  }
  wifiCursor.close();
  if (wifiId == -1) {
    return new long[]{-1,-1};
  }
  long oldWifiId=changeEnvironmentVariableValue(EnvironmentEntry.COLUMN_IS_WIFI_ENABLED,1,EnvironmentEntry.COLUMN_WIFI_ID,wifiId,environmentId,db);
  return new long[]{oldWifiId,wifiId};
}",0.7366220735785953
87007,"private boolean checkForAllBluetoothDevices(List<BluetoothEnvironmentVariable> variables){
  for (  BluetoothEnvironmentVariable variable : variables) {
    if (!BluetoothReceiver.getCurrentlyConnectedBluetoothDevices().contains(variable)) {
      return false;
    }
  }
  return true;
}","private boolean checkForAllBluetoothDevices(List<BluetoothEnvironmentVariable> variables){
  if (Utility.checkForNullAndWarn(BluetoothReceiver.getCurrentlyConnectedBluetoothDevices(),LOG_TAG)) {
    return false;
  }
  for (  BluetoothEnvironmentVariable variable : variables) {
    if (Utility.checkForNullAndWarn(variable,LOG_TAG)) {
      continue;
    }
    if (!BluetoothReceiver.getCurrentlyConnectedBluetoothDevices().contains(variable)) {
      return false;
    }
  }
  return true;
}",0.4916773367477592
87008,"public static Environment detectCurrentEnvironment(Context context){
  try {
    return (new EnvironmentDetectorAsyncTask()).execute(context).get();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    return null;
  }
catch (  ExecutionException e) {
    e.printStackTrace();
    return null;
  }
}","/** 
 * Detects the current environment based on the current values of the environment variables.
 * @param context Activity/service context
 */
public void detectCurrentEnvironment(Context context,EnvironmentDetectedCallback callback){
  Utility.checkForNullAndThrowException(context);
  Utility.checkForNullAndThrowException(callback);
  this.callback=callback;
  new EnvironmentDetectorAsyncTask().execute(context);
}",0.2802721088435374
87009,"@Override protected Environment doInBackground(Context... params){
  if (params.length == 0 || params[0] == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Context context=params[0];
  String logText=""String_Node_Str"";
  if (GeoFenceIntentService.getCurrentGeofences() != null && !GeoFenceIntentService.getCurrentGeofences().isEmpty()) {
    for (    LocationEnvironmentVariable variable : GeoFenceIntentService.getCurrentGeofences()) {
      logText+=variable.getLocationName() + ""String_Node_Str"";
    }
  }
 else {
    logText+=""String_Node_Str"";
  }
  logText+=""String_Node_Str"";
  if (BluetoothReceiver.getCurrentlyConnectedBluetoothDevices() != null && !BluetoothReceiver.getCurrentlyConnectedBluetoothDevices().isEmpty()) {
    for (    BluetoothEnvironmentVariable variable : BluetoothReceiver.getCurrentlyConnectedBluetoothDevices()) {
      logText+=variable.getDeviceName() + ""String_Node_Str"";
    }
  }
 else {
    logText+=""String_Node_Str"";
  }
  logText+=""String_Node_Str"";
  if (WifiReceiver.getCurrentWifiNetwork() != null) {
    logText+=WifiReceiver.getCurrentWifiNetwork().getSSID();
  }
 else {
    logText+=""String_Node_Str"";
  }
  Log.d(LOG_TAG,logText);
  List<Environment> currentEnvironments=new ArrayList<Environment>();
  manageEnvironmentDetectionCriticalSection.acquireUninterruptibly();
  for (  LocationEnvironmentVariable location : GeoFenceIntentService.getCurrentGeofences()) {
    List<Environment> potentialEnvironments=Environment.getAllEnvironmentBarebonesForLocation(context,location);
    currentEnvironments.addAll(checkWifiAndBluetoothOfPotentialEnvironments(context,potentialEnvironments));
  }
  List<Environment> potentialEnvironments=Environment.getAllnvironmentBarebonesWithoutLocation(context);
  currentEnvironments.addAll(checkWifiAndBluetoothOfPotentialEnvironments(context,potentialEnvironments));
  manageEnvironmentDetectionCriticalSection.release();
  if (currentEnvironments.size() > 1) {
    Log.w(LOG_TAG,""String_Node_Str"" + currentEnvironments.toString());
  }
  if (currentEnvironments.size() == 0) {
    Log.v(LOG_TAG,""String_Node_Str"");
    return null;
  }
  return currentEnvironments.get(0);
}","/** 
 * The function which is run in background. Checks for the stored environment which matches the current variable values
 * @param params Activity/service context
 * @return The detected environment
 */
@Override protected Environment doInBackground(Context... params){
  if (params.length == 0 || params[0] == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Context context=params[0];
  String logText=""String_Node_Str"";
  if (GeoFenceIntentService.getCurrentGeofences() != null && !GeoFenceIntentService.getCurrentGeofences().isEmpty()) {
    for (    LocationEnvironmentVariable variable : GeoFenceIntentService.getCurrentGeofences()) {
      logText+=variable.getLocationName() + ""String_Node_Str"";
    }
  }
 else {
    logText+=""String_Node_Str"";
  }
  logText+=""String_Node_Str"";
  if (BluetoothReceiver.getCurrentlyConnectedBluetoothDevices() != null && !BluetoothReceiver.getCurrentlyConnectedBluetoothDevices().isEmpty()) {
    for (    BluetoothEnvironmentVariable variable : BluetoothReceiver.getCurrentlyConnectedBluetoothDevices()) {
      logText+=variable.getDeviceName() + ""String_Node_Str"";
    }
  }
 else {
    logText+=""String_Node_Str"";
  }
  logText+=""String_Node_Str"";
  if (WifiReceiver.getCurrentWifiNetwork() != null) {
    logText+=WifiReceiver.getCurrentWifiNetwork().getSSID();
  }
 else {
    logText+=""String_Node_Str"";
  }
  Log.d(LOG_TAG,logText);
  List<Environment> currentEnvironments=new ArrayList<Environment>();
  manageEnvironmentDetectionCriticalSection.acquireUninterruptibly();
  for (  LocationEnvironmentVariable location : GeoFenceIntentService.getCurrentGeofences()) {
    List<Environment> potentialEnvironments=Environment.getAllEnvironmentBarebonesForLocation(context,location);
    if (potentialEnvironments != null && !potentialEnvironments.isEmpty()) {
      currentEnvironments.addAll(checkWifiAndBluetoothOfPotentialEnvironments(context,potentialEnvironments));
    }
  }
  List<Environment> potentialEnvironments=Environment.getAllnvironmentBarebonesWithoutLocation(context);
  if (potentialEnvironments != null && !potentialEnvironments.isEmpty()) {
    currentEnvironments.addAll(checkWifiAndBluetoothOfPotentialEnvironments(context,potentialEnvironments));
  }
  manageEnvironmentDetectionCriticalSection.release();
  if (currentEnvironments.size() > 1) {
    Log.w(LOG_TAG,""String_Node_Str"" + currentEnvironments.toString());
  }
  if (currentEnvironments.size() == 0) {
    Log.v(LOG_TAG,""String_Node_Str"");
    return null;
  }
  return currentEnvironments.get(0);
}",0.9213577904279991
87010,"private List<Environment> checkWifiAndBluetoothOfPotentialEnvironments(Context context,List<Environment> potentialEnvironments){
  ArrayList<Environment> currentEnvironments=new ArrayList<Environment>();
  for (  Environment e : potentialEnvironments) {
    Environment environment=Environment.getFullEnvironment(context,e.getName());
    if (environment.hasBluetoothDevices && environment.getBluetoothEnvironmentVariables() != null) {
      if (environment.isBluetoothAllOrAny()) {
        if (!checkForAllBluetoothDevices(environment.getBluetoothEnvironmentVariables())) {
          continue;
        }
      }
 else {
        if (!checkForAnyBluetoothDevices(environment.getBluetoothEnvironmentVariables())) {
          continue;
        }
      }
    }
    if (environment.hasWiFiNetwork) {
      if (WifiReceiver.getCurrentWifiNetwork() == null || !WifiReceiver.getCurrentWifiNetwork().equals(environment.getWiFiEnvironmentVariable())) {
        continue;
      }
    }
    Log.d(LOG_TAG,""String_Node_Str"" + e.getName());
    currentEnvironments.add(e);
  }
  return currentEnvironments;
}","/** 
 * Checks whether the passed environments match the current bluetooth and wifi variables
 * @param context Activity/service context
 * @param potentialEnvironments The environments for which matching is to be done
 * @return the list of environments whose Bluetooth/Wifi variables match the current variables
 */
private List<Environment> checkWifiAndBluetoothOfPotentialEnvironments(Context context,List<Environment> potentialEnvironments){
  ArrayList<Environment> currentEnvironments=new ArrayList<Environment>();
  for (  Environment e : potentialEnvironments) {
    Environment environment=Environment.getFullEnvironment(context,e.getName());
    if (Utility.checkForNullAndWarn(environment,LOG_TAG)) {
      continue;
    }
    if (environment.hasBluetoothDevices && environment.getBluetoothEnvironmentVariables() != null) {
      if (environment.isBluetoothAllOrAny()) {
        if (!checkForAllBluetoothDevices(environment.getBluetoothEnvironmentVariables())) {
          continue;
        }
      }
 else {
        if (!checkForAnyBluetoothDevices(environment.getBluetoothEnvironmentVariables())) {
          continue;
        }
      }
    }
    if (environment.hasWiFiNetwork && environment.getWiFiEnvironmentVariable() != null) {
      if (WifiReceiver.getCurrentWifiNetwork() == null || !WifiReceiver.getCurrentWifiNetwork().equals(environment.getWiFiEnvironmentVariable())) {
        continue;
      }
    }
    Log.d(LOG_TAG,""String_Node_Str"" + e.getName());
    currentEnvironments.add(e);
  }
  return currentEnvironments;
}",0.8287878787878787
87011,"private boolean checkForAnyBluetoothDevices(List<BluetoothEnvironmentVariable> variables){
  for (  BluetoothEnvironmentVariable variable : variables) {
    if (BluetoothReceiver.getCurrentlyConnectedBluetoothDevices().contains(variable)) {
      return true;
    }
  }
  return false;
}","private boolean checkForAnyBluetoothDevices(List<BluetoothEnvironmentVariable> variables){
  if (Utility.checkForNullAndWarn(BluetoothReceiver.getCurrentlyConnectedBluetoothDevices(),LOG_TAG)) {
    return false;
  }
  for (  BluetoothEnvironmentVariable variable : variables) {
    if (Utility.checkForNullAndWarn(variable,LOG_TAG)) {
      continue;
    }
    if (BluetoothReceiver.getCurrentlyConnectedBluetoothDevices().contains(variable)) {
      return true;
    }
  }
  return false;
}",0.5006418485237484
87012,"/** 
 * Update the environment entry in database. Old name of the environment should be passed if name has changed. If oldName is null, current name of the environment is taken and used for finding the records to update
 * @param context activity/service context
 * @param oldName The name of the environment to be modified
 * @return success code
 */
public boolean updateInDatabase(Context context,String oldName){
  if (oldName == null || oldName.isEmpty()) {
    oldName=getName();
  }
  Environment oldEnvironment=getFullEnvironment(context,oldName);
  if (oldEnvironment == null)   return false;
  ContentValues environmentValues=new ContentValues();
  environmentValues.put(EnvironmentEntry.COLUMN_NAME,getName());
  environmentValues.put(EnvironmentEntry.COLUMN_BLUETOOTH_ALL_OR_ANY,isBluetoothAllOrAny() ? 1 : 0);
  environmentValues.put(EnvironmentEntry.COLUMN_IS_ENABLED,isEnabled() ? 1 : 0);
  environmentValues.put(EnvironmentEntry.COLUMN_ENVIRONMENT_HINT,getHint());
  if (hasNoiseLevel && getNoiseLevelEnvironmentVariable() != null) {
    environmentValues.put(EnvironmentEntry.COLUMN_IS_MAX_NOISE_ENABLED,getNoiseLevelEnvironmentVariable().hasUpperLimit);
    environmentValues.put(EnvironmentEntry.COLUMN_IS_MIN_NOISE_ENABLED,getNoiseLevelEnvironmentVariable().hasLowerLimit);
    environmentValues.put(EnvironmentEntry.COLUMN_MAX_NOISE_LEVEL,getNoiseLevelEnvironmentVariable().getUpperLimit());
    environmentValues.put(EnvironmentEntry.COLUMN_MIN_NOISE_LEVEL,getNoiseLevelEnvironmentVariable().getLowerLimit());
  }
 else {
    environmentValues.put(EnvironmentEntry.COLUMN_IS_MAX_NOISE_ENABLED,false);
    environmentValues.put(EnvironmentEntry.COLUMN_IS_MIN_NOISE_ENABLED,false);
  }
  context.getContentResolver().update(EnvironmentEntry.buildEnvironmentUriWithId(oldEnvironment.id),environmentValues,null,null);
  if (oldEnvironment.hasLocation) {
    if (hasLocation && !oldEnvironment.locationEnvironmentVariable.equals(locationEnvironmentVariable)) {
      int updatedEntries=context.getContentResolver().update(EnvironmentEntry.buildEnvironmentUriWithIdAndLocation(oldEnvironment.id),locationEnvironmentVariable.getContentValues(),null,null);
      if (updatedEntries > 1) {
        Intent intentToRemoveOldGeofenceMonitor=BaseService.getServiceIntent(context,null,BaseService.ACTION_REMOVE_GEOFENCES);
        ArrayList<String> geofencesToRemove=new ArrayList<String>();
        geofencesToRemove.add(String.valueOf(oldEnvironment.getLocationEnvironmentVariable().getId()));
        intentToRemoveOldGeofenceMonitor.putExtra(BaseService.EXTRA_GEOFENCE_IDS_TO_REMOVE,geofencesToRemove);
        context.startService(intentToRemoveOldGeofenceMonitor);
      }
    }
 else     if (!hasLocation) {
      context.getContentResolver().delete(EnvironmentEntry.buildEnvironmentUriWithIdAndLocation(oldEnvironment.id),null,null);
    }
  }
 else   if (hasLocation) {
    context.getContentResolver().insert(EnvironmentEntry.buildEnvironmentUriWithIdAndLocation(oldEnvironment.id),locationEnvironmentVariable.getContentValues());
  }
  if (oldEnvironment.hasWiFiNetwork) {
    if (hasWiFiNetwork && !oldEnvironment.wiFiEnvironmentVariable.equals(wiFiEnvironmentVariable)) {
      context.getContentResolver().update(EnvironmentEntry.buildEnvironmentUriWithIdAndWifi(oldEnvironment.id),wiFiEnvironmentVariable.getContentValues(),null,null);
    }
 else     if (!hasWiFiNetwork) {
      context.getContentResolver().delete(EnvironmentEntry.buildEnvironmentUriWithIdAndWifi(oldEnvironment.id),null,null);
    }
  }
 else   if (hasWiFiNetwork) {
    context.getContentResolver().insert(EnvironmentEntry.buildEnvironmentUriWithIdAndWifi(oldEnvironment.id),wiFiEnvironmentVariable.getContentValues());
  }
  context.getContentResolver().delete(EnvironmentEntry.buildEnvironmentUriWithIdAndBluetooth(oldEnvironment.id),null,null);
  if (hasBluetoothDevices && getBluetoothEnvironmentVariables() != null && !getBluetoothEnvironmentVariables().isEmpty()) {
    Vector<BluetoothEnvironmentVariable> bluetoothEnvironmentVariables=getBluetoothEnvironmentVariables();
    Uri insertUri=EnvironmentEntry.buildEnvironmentUriWithIdAndBluetooth(oldEnvironment.id);
    for (    BluetoothEnvironmentVariable variable : bluetoothEnvironmentVariables) {
      ContentValues bluetoothValues=variable.getContentValues();
      context.getContentResolver().insert(insertUri,bluetoothValues);
    }
  }
  return true;
}","/** 
 * Update the environment entry in database. Old name of the environment should be passed if name has changed. If oldName is null, current name of the environment is taken and used for finding the records to update
 * @param context activity/service context
 * @param oldName The name of the environment to be modified
 * @return success code
 */
public boolean updateInDatabase(Context context,String oldName){
  if (oldName == null || oldName.isEmpty()) {
    oldName=getName();
  }
  Environment oldEnvironment=getFullEnvironment(context,oldName);
  if (oldEnvironment == null)   return false;
  ContentValues environmentValues=new ContentValues();
  environmentValues.put(EnvironmentEntry.COLUMN_NAME,getName());
  environmentValues.put(EnvironmentEntry.COLUMN_BLUETOOTH_ALL_OR_ANY,isBluetoothAllOrAny() ? 1 : 0);
  environmentValues.put(EnvironmentEntry.COLUMN_IS_ENABLED,isEnabled() ? 1 : 0);
  environmentValues.put(EnvironmentEntry.COLUMN_ENVIRONMENT_HINT,getHint());
  if (hasNoiseLevel && getNoiseLevelEnvironmentVariable() != null) {
    environmentValues.put(EnvironmentEntry.COLUMN_IS_MAX_NOISE_ENABLED,getNoiseLevelEnvironmentVariable().hasUpperLimit);
    environmentValues.put(EnvironmentEntry.COLUMN_IS_MIN_NOISE_ENABLED,getNoiseLevelEnvironmentVariable().hasLowerLimit);
    environmentValues.put(EnvironmentEntry.COLUMN_MAX_NOISE_LEVEL,getNoiseLevelEnvironmentVariable().getUpperLimit());
    environmentValues.put(EnvironmentEntry.COLUMN_MIN_NOISE_LEVEL,getNoiseLevelEnvironmentVariable().getLowerLimit());
  }
 else {
    environmentValues.put(EnvironmentEntry.COLUMN_IS_MAX_NOISE_ENABLED,false);
    environmentValues.put(EnvironmentEntry.COLUMN_IS_MIN_NOISE_ENABLED,false);
  }
  context.getContentResolver().update(EnvironmentEntry.buildEnvironmentUriWithId(oldEnvironment.id),environmentValues,null,null);
  if (oldEnvironment.hasLocation) {
    if (hasLocation && !oldEnvironment.locationEnvironmentVariable.equals(locationEnvironmentVariable)) {
      int updatedEntries=context.getContentResolver().update(EnvironmentEntry.buildEnvironmentUriWithIdAndLocation(oldEnvironment.id),locationEnvironmentVariable.getContentValues(),null,null);
      if (updatedEntries > 1) {
        removeFromCurrentGeofences(oldEnvironment.getLocationEnvironmentVariable(),context);
      }
    }
 else     if (!hasLocation) {
      int deletedEntries=context.getContentResolver().delete(EnvironmentEntry.buildEnvironmentUriWithIdAndLocation(oldEnvironment.id),null,null);
      if (deletedEntries > 1) {
        removeFromCurrentGeofences(oldEnvironment.getLocationEnvironmentVariable(),context);
      }
    }
  }
 else   if (hasLocation) {
    context.getContentResolver().insert(EnvironmentEntry.buildEnvironmentUriWithIdAndLocation(oldEnvironment.id),locationEnvironmentVariable.getContentValues());
  }
  if (oldEnvironment.hasWiFiNetwork) {
    if (hasWiFiNetwork && !oldEnvironment.wiFiEnvironmentVariable.equals(wiFiEnvironmentVariable)) {
      context.getContentResolver().update(EnvironmentEntry.buildEnvironmentUriWithIdAndWifi(oldEnvironment.id),wiFiEnvironmentVariable.getContentValues(),null,null);
    }
 else     if (!hasWiFiNetwork) {
      context.getContentResolver().delete(EnvironmentEntry.buildEnvironmentUriWithIdAndWifi(oldEnvironment.id),null,null);
    }
  }
 else   if (hasWiFiNetwork) {
    context.getContentResolver().insert(EnvironmentEntry.buildEnvironmentUriWithIdAndWifi(oldEnvironment.id),wiFiEnvironmentVariable.getContentValues());
  }
  context.getContentResolver().delete(EnvironmentEntry.buildEnvironmentUriWithIdAndBluetooth(oldEnvironment.id),null,null);
  if (hasBluetoothDevices && getBluetoothEnvironmentVariables() != null && !getBluetoothEnvironmentVariables().isEmpty()) {
    Vector<BluetoothEnvironmentVariable> bluetoothEnvironmentVariables=getBluetoothEnvironmentVariables();
    Uri insertUri=EnvironmentEntry.buildEnvironmentUriWithIdAndBluetooth(oldEnvironment.id);
    for (    BluetoothEnvironmentVariable variable : bluetoothEnvironmentVariables) {
      ContentValues bluetoothValues=variable.getContentValues();
      context.getContentResolver().insert(insertUri,bluetoothValues);
    }
  }
  return true;
}",0.8847272304292195
87013,"/** 
 * Function to delete an environment from the database
 * @param context Activity/ service context
 * @param environmentName Name of the environment to be deleted
 */
public static void deleteEnvironmentFromDatabase(Context context,String environmentName){
  Environment e=getFullEnvironment(context,environmentName);
  if (e != null) {
    context.getContentResolver().delete(EnvironmentEntry.buildEnvironmentUriWithIdAndBluetooth(e.id),null,null);
    context.getContentResolver().delete(EnvironmentEntry.buildEnvironmentUriWithIdAndWifi(e.id),null,null);
    int deletedEntries=context.getContentResolver().delete(EnvironmentEntry.buildEnvironmentUriWithIdAndLocation(e.id),null,null);
    context.getContentResolver().delete(EnvironmentEntry.buildEnvironmentUriWithId(e.id),null,null);
    if (deletedEntries > 0) {
      Intent intentToRemoveOldGeofenceMonitor=BaseService.getServiceIntent(context,null,BaseService.ACTION_REMOVE_GEOFENCES);
      ArrayList<String> geofencesToRemove=new ArrayList<String>();
      geofencesToRemove.add(String.valueOf(e.getLocationEnvironmentVariable().getId()));
      intentToRemoveOldGeofenceMonitor.putExtra(BaseService.EXTRA_GEOFENCE_IDS_TO_REMOVE,geofencesToRemove);
      context.startService(intentToRemoveOldGeofenceMonitor);
    }
  }
}","/** 
 * Function to delete an environment from the database
 * @param context Activity/ service context
 * @param environmentName Name of the environment to be deleted
 */
public static void deleteEnvironmentFromDatabase(Context context,String environmentName){
  Environment e=getFullEnvironment(context,environmentName);
  if (e != null) {
    context.getContentResolver().delete(EnvironmentEntry.buildEnvironmentUriWithIdAndBluetooth(e.id),null,null);
    context.getContentResolver().delete(EnvironmentEntry.buildEnvironmentUriWithIdAndWifi(e.id),null,null);
    int deletedEntries=context.getContentResolver().delete(EnvironmentEntry.buildEnvironmentUriWithIdAndLocation(e.id),null,null);
    context.getContentResolver().delete(EnvironmentEntry.buildEnvironmentUriWithId(e.id),null,null);
    if (deletedEntries > 0) {
      removeFromCurrentGeofences(e.getLocationEnvironmentVariable(),context);
    }
  }
}",0.7852927825692237
87014,"public static LocationEnvironmentVariable getLocationEnvironmentVariableFromAndroidGeofence(Context context,Geofence geofence){
  Cursor locationCursor=context.getContentResolver().query(GeoFenceEntry.buildGeofenceUriWithId(Long.parseLong(geofence.getRequestId())),null,null,null,null);
  List<EnvironmentVariable> locationVariables=getLocationEnvironmentVariablesFromCursor(locationCursor);
  locationCursor.close();
  if (locationVariables == null || locationVariables.isEmpty()) {
    Log.e(LOG_TAG,""String_Node_Str"");
  }
  return (LocationEnvironmentVariable)locationVariables.get(0);
}","public static LocationEnvironmentVariable getLocationEnvironmentVariableFromAndroidGeofence(Context context,Geofence geofence){
  Cursor locationCursor=context.getContentResolver().query(GeoFenceEntry.buildGeofenceUriWithId(Long.parseLong(geofence.getRequestId())),null,null,null,null);
  List<EnvironmentVariable> locationVariables=getLocationEnvironmentVariablesFromCursor(locationCursor);
  locationCursor.close();
  if (locationVariables == null || locationVariables.isEmpty()) {
    Log.e(LOG_TAG,""String_Node_Str"" + geofence.getRequestId());
    return null;
  }
  return (LocationEnvironmentVariable)locationVariables.get(0);
}",0.9648979591836736
87015,"@Override public boolean equals(Object o){
  EnvironmentVariable e=(EnvironmentVariable)o;
  if (!getVariableType().equals(e.getVariableType()))   return false;
  if (isStringValuesSupported()) {
    if (!e.isStringValuesSupported() || stringValues.length != e.stringValues.length)     return false;
    for (int i=0; i < stringValues.length; i++) {
      if (!stringValues[i].equals(e.stringValues[i])) {
        return false;
      }
    }
  }
  if (isFloatValuesSupported()) {
    if (!e.isFloatValuesSupported() || floatValues.length != e.floatValues.length)     return false;
    for (int i=0; i < floatValues.length; i++) {
      if (!(floatValues[i] == e.floatValues[i])) {
        return false;
      }
    }
  }
  return true;
}","@Override public boolean equals(Object o){
  if (o == null) {
    return false;
  }
  Class<?> oClass=o.getClass();
  if (!oClass.getSuperclass().getSimpleName().equals(EnvironmentVariable.class.getSimpleName()) && !oClass.getSimpleName().equals(EnvironmentVariable.class.getSimpleName())) {
    return false;
  }
  EnvironmentVariable e=(EnvironmentVariable)o;
  if (!getVariableType().equals(e.getVariableType()))   return false;
  if (isStringValuesSupported()) {
    if (!e.isStringValuesSupported() || stringValues == null || e.stringValues == null || stringValues.length != e.stringValues.length)     return false;
    for (int i=0; i < stringValues.length; i++) {
      if (!stringValues[i].equals(e.stringValues[i])) {
        return false;
      }
    }
  }
  if (isFloatValuesSupported()) {
    if (!e.isFloatValuesSupported() || floatValues == null || e.floatValues == null || floatValues.length != e.floatValues.length)     return false;
    for (int i=0; i < floatValues.length; i++) {
      if (!(floatValues[i] == e.floatValues[i])) {
        return false;
      }
    }
  }
  return true;
}",0.7997829625610418
87016,"public EnvironmentVariable(String variableType,double[] floatValues,String[] stringValues){
  boolean isValid=checkTypeValidity(variableType) && !isInitialized;
  if (!isValid) {
    Log.e(LOG_TAG,""String_Node_Str"" + variableType);
    throw new IllegalArgumentException(""String_Node_Str"" + variableType);
  }
  if (isValid) {
    isInitialized=true;
    this.variableType=variableType;
    setFloatValues(floatValues);
    setStringValues(stringValues);
  }
}","public EnvironmentVariable(String variableType,double[] floatValues,String[] stringValues){
  Utility.checkForNullAndThrowException(variableType);
  boolean isValid=checkTypeValidity(variableType) && !isInitialized;
  if (!isValid) {
    Log.e(LOG_TAG,""String_Node_Str"" + variableType);
    throw new IllegalArgumentException(""String_Node_Str"" + variableType);
  }
  if (isValid) {
    isInitialized=true;
    this.variableType=variableType;
    setFloatValues(floatValues);
    setStringValues(stringValues);
  }
}",0.9435897435897436
87017,"@Override public boolean equals(Object o){
  EnvironmentVariable e=(EnvironmentVariable)o;
  if (stringValues.length != e.stringValues.length)   return false;
  if (floatValues.length != e.floatValues.length)   return false;
  if (isStringValuesSupported()) {
    for (int i=0; i < stringValues.length; i++) {
      if (!stringValues[i].equals(e.stringValues[i])) {
        return false;
      }
    }
  }
  if (isFloatValuesSupported()) {
    for (int i=0; i < floatValues.length; i++) {
      if (!(floatValues[i] == e.floatValues[i])) {
        return false;
      }
    }
  }
  return true;
}","@Override public boolean equals(Object o){
  EnvironmentVariable e=(EnvironmentVariable)o;
  if (!getVariableType().equals(e.getVariableType()))   return false;
  if (isStringValuesSupported()) {
    if (!e.isStringValuesSupported() || stringValues.length != e.stringValues.length)     return false;
    for (int i=0; i < stringValues.length; i++) {
      if (!stringValues[i].equals(e.stringValues[i])) {
        return false;
      }
    }
  }
  if (isFloatValuesSupported()) {
    if (!e.isFloatValuesSupported() || floatValues.length != e.floatValues.length)     return false;
    for (int i=0; i < floatValues.length; i++) {
      if (!(floatValues[i] == e.floatValues[i])) {
        return false;
      }
    }
  }
  return true;
}",0.5146286571642911
87018,"private void setUpLocationElements(){
  enableLocationCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      if (isChecked) {
        setLocationItemsEnabled(true);
        storedLocations=LocationEnvironmentVariable.getLocationEnvironmentVariables(getActivity());
        mSelectedLocationItem=-1;
      }
 else {
        setLocationItemsEnabled(false);
      }
    }
  }
);
  selectLocationTextView.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      Log.v(LOG_TAG,""String_Node_Str"");
      Intent intent=new Intent(getActivity(),SelectLocation.class);
      LocationEnvironmentVariable location=environment.getLocationEnvironmentVariable();
      Bundle bundle=new Bundle();
      bundle.putDouble(SelectLocation.INTENT_EXTRA_SELECTED_LATITUDE,location.getLatitude());
      bundle.putDouble(SelectLocation.INTENT_EXTRA_SELECTED_LONGITUDE,location.getLongitude());
      intent.putExtras(bundle);
      Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      getActivity().startActivityForResult(intent,REQUEST_LOCATION_SELECT);
    }
  }
);
  selectStoredLocationTextView.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      String[] locationNames=new String[storedLocations.size()];
      for (int i=0; i < storedLocations.size(); i++) {
        locationNames[i]=((LocationEnvironmentVariable)storedLocations.get(i)).getLocationName();
      }
      AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
      builder.setTitle(R.string.dialog_pick_wifi_connection);
      builder.setSingleChoiceItems(locationNames,mSelectedLocationItem,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          mSelectedLocationItem=which;
          mSelectedLocation=(LocationEnvironmentVariable)storedLocations.get(which);
        }
      }
);
      builder.setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          if (mSelectedLocationItem != -1) {
            nameLocationEditText.setText(mSelectedLocation.getLocationName());
            latLocationEditText.setText(""String_Node_Str"" + mSelectedLocation.getLatitude());
            lonLocationEditText.setText(""String_Node_Str"" + mSelectedLocation.getLongitude());
            radLocationEditText.setText(""String_Node_Str"" + mSelectedLocation.getRadius());
          }
        }
      }
);
      AlertDialog alert=builder.create();
      alert.show();
    }
  }
);
}","private void setUpLocationElements(){
  enableLocationCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      if (isChecked) {
        setLocationItemsEnabled(true);
        storedLocations=LocationEnvironmentVariable.getLocationEnvironmentVariables(getActivity());
        mSelectedLocationItem=-1;
      }
 else {
        setLocationItemsEnabled(false);
      }
    }
  }
);
  selectLocationTextView.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      Log.v(LOG_TAG,""String_Node_Str"");
      Intent intent=new Intent(getActivity(),SelectLocation.class);
      if (environment.hasLocation) {
        LocationEnvironmentVariable location=environment.getLocationEnvironmentVariable();
        Bundle bundle=new Bundle();
        bundle.putDouble(SelectLocation.INTENT_EXTRA_SELECTED_LATITUDE,location.getLatitude());
        bundle.putDouble(SelectLocation.INTENT_EXTRA_SELECTED_LONGITUDE,location.getLongitude());
        intent.putExtras(bundle);
      }
      Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      getActivity().startActivityForResult(intent,REQUEST_LOCATION_SELECT);
    }
  }
);
  selectStoredLocationTextView.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      String[] locationNames=new String[storedLocations.size()];
      for (int i=0; i < storedLocations.size(); i++) {
        locationNames[i]=((LocationEnvironmentVariable)storedLocations.get(i)).getLocationName();
      }
      AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
      builder.setTitle(R.string.dialog_pick_wifi_connection);
      builder.setSingleChoiceItems(locationNames,mSelectedLocationItem,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          mSelectedLocationItem=which;
          mSelectedLocation=(LocationEnvironmentVariable)storedLocations.get(which);
        }
      }
);
      builder.setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          if (mSelectedLocationItem != -1) {
            nameLocationEditText.setText(mSelectedLocation.getLocationName());
            latLocationEditText.setText(""String_Node_Str"" + mSelectedLocation.getLatitude());
            lonLocationEditText.setText(""String_Node_Str"" + mSelectedLocation.getLongitude());
            radLocationEditText.setText(""String_Node_Str"" + mSelectedLocation.getRadius());
          }
        }
      }
);
      AlertDialog alert=builder.create();
      alert.show();
    }
  }
);
}",0.990152193375112
87019,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_select_location);
  intent=getIntent();
  setUpActionBar();
  setUpGoogleMap();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_select_location);
  intent=getIntent();
  setUpActionBar();
  setUpGoogleMap();
  locationSuggestTask=new LocationSuggestTask();
  setUpGeocoder();
}",0.864
87020,"public void setLocationItemsEnabled(boolean flag){
  nameLocationEditText.setEnabled(flag);
  latLocationEditText.setEnabled(flag);
  lonLocationEditText.setEnabled(flag);
  radLocationEditText.setEnabled(flag);
  selectLocationTextView.setEnabled(flag);
}","public void setLocationItemsEnabled(boolean flag){
  nameLocationEditText.setEnabled(flag);
  latLocationEditText.setEnabled(flag);
  lonLocationEditText.setEnabled(flag);
  radLocationEditText.setEnabled(flag);
  selectLocationTextView.setEnabled(flag);
  selectStoredLocationTextView.setEnabled(flag);
}",0.9126559714795008
87021,"@Override public void onCheckedChanged(CompoundButton buttonView,boolean isChecked){
  if (isChecked) {
    setLocationItemsEnabled(true);
  }
 else {
    setLocationItemsEnabled(false);
  }
}","@Override public void onCheckedChanged(CompoundButton buttonView,boolean isChecked){
  if (isChecked) {
    setLocationItemsEnabled(true);
    storedLocations=LocationEnvironmentVariable.getLocationEnvironmentVariables(getActivity());
    mSelectedLocationItem=-1;
  }
 else {
    setLocationItemsEnabled(false);
  }
}",0.7529411764705882
87022,"public void setUpLocationElements(){
  setLocationItemsEnabled(false);
  enableLocationCheckBox.setChecked(false);
  enableLocationCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      if (isChecked) {
        setLocationItemsEnabled(true);
      }
 else {
        setLocationItemsEnabled(false);
      }
    }
  }
);
  selectLocationTextView.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      Log.v(LOG_TAG,""String_Node_Str"");
      Intent intent=new Intent(getActivity(),SelectLocation.class);
      getActivity().startActivityForResult(intent,REQUEST_LOCATION_SELECT);
    }
  }
);
}","public void setUpLocationElements(){
  setLocationItemsEnabled(false);
  enableLocationCheckBox.setChecked(false);
  enableLocationCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      if (isChecked) {
        setLocationItemsEnabled(true);
        storedLocations=LocationEnvironmentVariable.getLocationEnvironmentVariables(getActivity());
        mSelectedLocationItem=-1;
      }
 else {
        setLocationItemsEnabled(false);
      }
    }
  }
);
  selectLocationTextView.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      Log.v(LOG_TAG,""String_Node_Str"");
      Intent intent=new Intent(getActivity(),SelectLocation.class);
      getActivity().startActivityForResult(intent,REQUEST_LOCATION_SELECT);
    }
  }
);
  selectStoredLocationTextView.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      String[] locationNames=new String[storedLocations.size()];
      for (int i=0; i < storedLocations.size(); i++) {
        locationNames[i]=((LocationEnvironmentVariable)storedLocations.get(i)).getLocationName();
      }
      AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
      builder.setTitle(R.string.dialog_pick_wifi_connection);
      builder.setSingleChoiceItems(locationNames,mSelectedLocationItem,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          mSelectedLocationItem=which;
          mSelectedLocation=(LocationEnvironmentVariable)storedLocations.get(which);
        }
      }
);
      builder.setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          if (mSelectedLocationItem != -1) {
            nameLocationEditText.setText(mSelectedLocation.getLocationName());
            latLocationEditText.setText(""String_Node_Str"" + mSelectedLocation.getLatitude());
            lonLocationEditText.setText(""String_Node_Str"" + mSelectedLocation.getLongitude());
            radLocationEditText.setText(""String_Node_Str"" + mSelectedLocation.getRadius());
          }
        }
      }
);
      AlertDialog alert=builder.create();
      alert.show();
    }
  }
);
}",0.4814582023884349
87023,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View rootView=inflater.inflate(R.layout.fragment_add_environment,container,false);
  environmentNameEditText=(EditText)rootView.findViewById(R.id.edit_text_environment_name);
  environmentHintEditText=(EditText)rootView.findViewById(R.id.edit_text_environment_hint);
  enableBluetoothCheckBox=(CheckBox)rootView.findViewById(R.id.checkbox_enable_bluetooth);
  selectBluetoothDevicesTextView=(TextView)rootView.findViewById(R.id.text_view_bluetooth_devices_select);
  bluetoothAllCheckbox=(CheckBox)rootView.findViewById(R.id.checkbox_bluetooth_all);
  enableWiFiCheckBox=(CheckBox)rootView.findViewById(R.id.checkbox_enable_wifi);
  selectWiFiConnectionTextView=(TextView)rootView.findViewById(R.id.text_view_wifi_connection_select);
  enableLocationCheckBox=(CheckBox)rootView.findViewById(R.id.checkbox_enable_location);
  nameLocationEditText=(EditText)rootView.findViewById(R.id.edit_text_location_name);
  latLocationEditText=(EditText)rootView.findViewById(R.id.edit_text_location_lat);
  lonLocationEditText=(EditText)rootView.findViewById(R.id.edit_text_location_lon);
  radLocationEditText=(EditText)rootView.findViewById(R.id.edit_text_location_rad);
  selectLocationTextView=(TextView)rootView.findViewById(R.id.text_view_select_location);
  setUpBluetoothElements();
  setUpWiFiElements();
  setUpLocationElements();
  setUpActionBar();
  return rootView;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View rootView=inflater.inflate(R.layout.fragment_add_environment,container,false);
  environmentNameEditText=(EditText)rootView.findViewById(R.id.edit_text_environment_name);
  environmentHintEditText=(EditText)rootView.findViewById(R.id.edit_text_environment_hint);
  enableBluetoothCheckBox=(CheckBox)rootView.findViewById(R.id.checkbox_enable_bluetooth);
  selectBluetoothDevicesTextView=(TextView)rootView.findViewById(R.id.text_view_bluetooth_devices_select);
  bluetoothAllCheckbox=(CheckBox)rootView.findViewById(R.id.checkbox_bluetooth_all);
  enableWiFiCheckBox=(CheckBox)rootView.findViewById(R.id.checkbox_enable_wifi);
  selectWiFiConnectionTextView=(TextView)rootView.findViewById(R.id.text_view_wifi_connection_select);
  enableLocationCheckBox=(CheckBox)rootView.findViewById(R.id.checkbox_enable_location);
  nameLocationEditText=(EditText)rootView.findViewById(R.id.edit_text_location_name);
  latLocationEditText=(EditText)rootView.findViewById(R.id.edit_text_location_lat);
  lonLocationEditText=(EditText)rootView.findViewById(R.id.edit_text_location_lon);
  radLocationEditText=(EditText)rootView.findViewById(R.id.edit_text_location_rad);
  selectLocationTextView=(TextView)rootView.findViewById(R.id.text_view_select_location);
  selectStoredLocationTextView=(TextView)rootView.findViewById(R.id.text_view_select_stored_location);
  setUpBluetoothElements();
  setUpWiFiElements();
  setUpLocationElements();
  setUpActionBar();
  return rootView;
}",0.9663288656423668
87024,"private long insertEnvironmentLocation(Uri uri,SQLiteDatabase db,ContentValues values){
  long environmentId=Long.parseLong(uri.getPathSegments().get(1));
  String geofenceSelection=GeoFenceEntry.COLUMN_COORD_LAT + ""String_Node_Str"" + GeoFenceEntry.COLUMN_COORD_LONG+ ""String_Node_Str""+ GeoFenceEntry.COLUMN_RADIUS+ ""String_Node_Str"";
  String[] geofenceSelectionArgs=new String[]{values.getAsString(GeoFenceEntry.COLUMN_COORD_LAT),values.getAsString(GeoFenceEntry.COLUMN_COORD_LONG),values.getAsString(GeoFenceEntry.COLUMN_RADIUS)};
  Cursor geofenceCursor=db.query(GeoFenceEntry.TABLE_NAME,new String[]{GeoFenceEntry._ID},geofenceSelection,geofenceSelectionArgs,null,null,null);
  long geofenceId;
  if (geofenceCursor.getCount() == 0) {
    geofenceId=db.insert(GeoFenceEntry.TABLE_NAME,null,values);
  }
 else {
    geofenceCursor.moveToFirst();
    geofenceId=geofenceCursor.getLong(geofenceCursor.getColumnIndex(GeoFenceEntry._ID));
  }
  if (geofenceId == -1) {
    return -1;
  }
  ContentValues environmentContentValues=new ContentValues();
  environmentContentValues.put(EnvironmentEntry.COLUMN_IS_LOCATION_ENABLED,1);
  environmentContentValues.put(EnvironmentEntry.COLUMN_GEOFENCE_ID,geofenceId);
  return db.update(EnvironmentEntry.TABLE_NAME,environmentContentValues,EnvironmentEntry._ID + ""String_Node_Str"",new String[]{String.valueOf(environmentId)});
}","private long insertEnvironmentLocation(Uri uri,SQLiteDatabase db,ContentValues values){
  long environmentId=Long.parseLong(uri.getPathSegments().get(1));
  String geofenceSelection=GeoFenceEntry.COLUMN_LOCATION_NAME + ""String_Node_Str"";
  String[] geofenceSelectionArgs=new String[]{values.getAsString(GeoFenceEntry.COLUMN_LOCATION_NAME)};
  Cursor geofenceCursor=db.query(GeoFenceEntry.TABLE_NAME,null,geofenceSelection,geofenceSelectionArgs,null,null,null);
  long geofenceId;
  if (!geofenceCursor.moveToFirst()) {
    String receivedValues=values.getAsString(GeoFenceEntry.COLUMN_COORD_LAT) + ""String_Node_Str"" + values.getAsString(GeoFenceEntry.COLUMN_COORD_LONG)+ ""String_Node_Str""+ values.getAsString(GeoFenceEntry.COLUMN_RADIUS);
    Log.d(LOG_TAG,""String_Node_Str"" + receivedValues);
    geofenceId=db.insert(GeoFenceEntry.TABLE_NAME,null,values);
  }
 else {
    geofenceId=geofenceCursor.getLong(geofenceCursor.getColumnIndex(GeoFenceEntry._ID));
  }
  if (geofenceId == -1) {
    return -1;
  }
  ContentValues environmentContentValues=new ContentValues();
  environmentContentValues.put(EnvironmentEntry.COLUMN_IS_LOCATION_ENABLED,1);
  environmentContentValues.put(EnvironmentEntry.COLUMN_GEOFENCE_ID,geofenceId);
  return db.update(EnvironmentEntry.TABLE_NAME,environmentContentValues,EnvironmentEntry._ID + ""String_Node_Str"",new String[]{String.valueOf(environmentId)});
}",0.331399564902103
87025,"public static Environment getFullEnvironment(Context context,String environmentName){
  String selection=EnvironmentEntry.COLUMN_NAME + ""String_Node_Str"";
  String[] selectionArgs=new String[]{environmentName};
  Cursor envCursor=context.getContentResolver().query(EnvironmentEntry.CONTENT_URI,null,selection,selectionArgs,null);
  Environment e;
  if (envCursor.moveToFirst()) {
    long environmentId=envCursor.getLong(envCursor.getColumnIndex(EnvironmentEntry._ID));
    Cursor bluetoothCursor=context.getContentResolver().query(EnvironmentEntry.buildEnvironmentUriWithIdAndBluetooth(environmentId),null,null,null,null), wifiCursor=context.getContentResolver().query(EnvironmentEntry.buildEnvironmentUriWithIdAndWifi(environmentId),null,null,null,null), locationCursor=context.getContentResolver().query(EnvironmentEntry.buildEnvironmentUriWithIdAndLocation(environmentId),null,null,null,null);
    List<EnvironmentVariable> environmentVariables=DatabaseToObjectMapper.getBluetoothEnvironmentVariablesFromCursor(bluetoothCursor);
    environmentVariables.addAll(DatabaseToObjectMapper.getLocationEnvironmentVariablesFromCursor(locationCursor));
    environmentVariables.addAll(DatabaseToObjectMapper.getWiFiEnvironmentVariablesFromCursor(wifiCursor));
    environmentVariables.addAll(DatabaseToObjectMapper.getNoiseLevelEnvironmentVariablesFromCursor(envCursor));
    e=new Environment(environmentName,environmentVariables);
    e.setBluetoothAllOrAny(envCursor.getInt(envCursor.getColumnIndex(EnvironmentEntry.COLUMN_BLUETOOTH_ALL_OR_ANY)) == 1);
    e.setHint(envCursor.getString(envCursor.getColumnIndex(EnvironmentEntry.COLUMN_ENVIRONMENT_HINT)));
  }
 else {
    return null;
  }
  return e;
}","public static Environment getFullEnvironment(Context context,String environmentName){
  String selection=EnvironmentEntry.COLUMN_NAME + ""String_Node_Str"";
  String[] selectionArgs=new String[]{environmentName};
  Cursor envCursor=context.getContentResolver().query(EnvironmentEntry.CONTENT_URI,null,selection,selectionArgs,null);
  Environment e;
  if (envCursor.moveToFirst()) {
    long environmentId=envCursor.getLong(envCursor.getColumnIndex(EnvironmentEntry._ID));
    Cursor bluetoothCursor=context.getContentResolver().query(EnvironmentEntry.buildEnvironmentUriWithIdAndBluetooth(environmentId),null,null,null,null), wifiCursor=context.getContentResolver().query(EnvironmentEntry.buildEnvironmentUriWithIdAndWifi(environmentId),null,null,null,null), locationCursor=context.getContentResolver().query(EnvironmentEntry.buildEnvironmentUriWithIdAndLocation(environmentId),null,null,null,null);
    List<EnvironmentVariable> environmentVariables=DatabaseToObjectMapper.getBluetoothEnvironmentVariablesFromCursor(bluetoothCursor);
    environmentVariables.addAll(DatabaseToObjectMapper.getLocationEnvironmentVariablesFromCursor(locationCursor));
    environmentVariables.addAll(DatabaseToObjectMapper.getWiFiEnvironmentVariablesFromCursor(wifiCursor));
    environmentVariables.addAll(DatabaseToObjectMapper.getNoiseLevelEnvironmentVariablesFromCursor(envCursor));
    e=new Environment(environmentName,environmentVariables);
    e.setBluetoothAllOrAny(envCursor.getInt(envCursor.getColumnIndex(EnvironmentEntry.COLUMN_BLUETOOTH_ALL_OR_ANY)) == 1);
    e.setHint(envCursor.getString(envCursor.getColumnIndex(EnvironmentEntry.COLUMN_ENVIRONMENT_HINT)));
    e.setEnabled(envCursor.getInt(envCursor.getColumnIndex(EnvironmentEntry.COLUMN_IS_ENABLED)) == 1);
  }
 else {
    return null;
  }
  return e;
}",0.9706134094151212
87026,"public static List<EnvironmentVariable> getNoiseLevelEnvironmentVariablesFromCursor(Cursor environmentCursor){
  ArrayList<EnvironmentVariable> environmentVariables=new ArrayList<EnvironmentVariable>();
  try {
    if (environmentCursor.moveToFirst()) {
      for (; !environmentCursor.isAfterLast(); environmentCursor.moveToNext()) {
        boolean minNoiseEnabled=environmentCursor.getInt(environmentCursor.getColumnIndex(EnvironmentEntry.COLUMN_IS_MIN_NOISE_ENABLED)) == 1, maxNoiseEnabled=environmentCursor.getInt(environmentCursor.getColumnIndex(EnvironmentEntry.COLUMN_IS_MAX_NOISE_ENABLED)) == 1;
        if (minNoiseEnabled || maxNoiseEnabled) {
          environmentVariables.add(new NoiseLevelEnvironmentVariable(minNoiseEnabled,maxNoiseEnabled));
        }
      }
    }
  }
 catch (  Exception e) {
    Log.w(LOG_TAG,e + ""String_Node_Str"" + e.getMessage());
  }
  return environmentVariables;
}","public static List<EnvironmentVariable> getNoiseLevelEnvironmentVariablesFromCursor(Cursor environmentCursor){
  int initialCursorPosition=environmentCursor.getPosition();
  ArrayList<EnvironmentVariable> environmentVariables=new ArrayList<EnvironmentVariable>();
  try {
    if (environmentCursor.moveToFirst()) {
      for (; !environmentCursor.isAfterLast(); environmentCursor.moveToNext()) {
        boolean minNoiseEnabled=environmentCursor.getInt(environmentCursor.getColumnIndex(EnvironmentEntry.COLUMN_IS_MIN_NOISE_ENABLED)) == 1, maxNoiseEnabled=environmentCursor.getInt(environmentCursor.getColumnIndex(EnvironmentEntry.COLUMN_IS_MAX_NOISE_ENABLED)) == 1;
        if (minNoiseEnabled || maxNoiseEnabled) {
          environmentVariables.add(new NoiseLevelEnvironmentVariable(minNoiseEnabled,maxNoiseEnabled));
        }
      }
    }
  }
 catch (  Exception e) {
    Log.w(LOG_TAG,e + ""String_Node_Str"" + e.getMessage());
  }
  environmentCursor.moveToFirst();
  environmentCursor.move(initialCursorPosition);
  return environmentVariables;
}",0.9259826442062276
87027,"@Override public boolean handleMessage(Message msg){
switch (msg.what) {
case MSG_SERVICE_CONNECTED:
    mView.setVisibility(View.VISIBLE);
  mWindowManager.addView(mView,(LayoutParams)msg.obj);
return true;
case MSG_SERVICE_DISCONNECTED:
mView.setVisibility(View.GONE);
mWindowManager.removeView(mView);
return true;
case MSG_CANCEL:
if (mCallback != null) {
try {
mCallback.cancel();
}
 catch (RemoteException e) {
e.printStackTrace();
}
}
return true;
case MSG_ENABLE:
mPicturePassword.reset();
mPicturePassword.setShowNumbers(true,true);
mPicturePassword.setEnabled(true);
return true;
}
return false;
}","@Override public boolean handleMessage(Message msg){
switch (msg.what) {
case MSG_SERVICE_CONNECTED:
    mView.setVisibility(View.VISIBLE);
  mWindowManager.addView(mView,(LayoutParams)msg.obj);
return true;
case MSG_SERVICE_DISCONNECTED:
if (mView != null) {
mView.setVisibility(View.GONE);
mWindowManager.removeView(mView);
}
return true;
case MSG_CANCEL:
if (mCallback != null) {
try {
mCallback.cancel();
}
 catch (RemoteException e) {
e.printStackTrace();
}
}
return true;
case MSG_ENABLE:
mPicturePassword.reset();
mPicturePassword.setShowNumbers(true,true);
mPicturePassword.setEnabled(true);
return true;
}
return false;
}",0.9814066289409864
87028,"public FaceLockService(){
  binder=new Stub(){
    @Override public void startUi(    IBinder windowToken,    int x,    int y,    int w,    int h,    boolean useLiveliness) throws RemoteException {
      LayoutParams p=new LayoutParams(LayoutParams.TYPE_APPLICATION_PANEL);
      p.flags=LayoutParams.FLAG_HARDWARE_ACCELERATED | LayoutParams.FLAG_NOT_FOCUSABLE;
      p.token=windowToken;
      p.x=x;
      p.y=y;
      p.width=w;
      p.height=h;
      p.gravity=8388659;
      FaceLockService.this.mLayoutParams=p;
      FaceLockService.this.mHandler.obtainMessage(MSG_SERVICE_CONNECTED,p).sendToTarget();
      if (PicturePasswordUtils.getLockedOut(FaceLockService.this)) {
        lockOut(false);
      }
    }
    @Override public void stopUi() throws RemoteException {
      FaceLockService.this.mHandler.sendEmptyMessage(MSG_SERVICE_DISCONNECTED);
    }
    @Override public void registerCallback(    IFaceLockCallback callback) throws RemoteException {
      FaceLockService.this.mCallback=callback;
    }
    @Override public void unregisterCallback(    IFaceLockCallback callback) throws RemoteException {
      FaceLockService.this.mCallback=null;
    }
  }
;
}","public FaceLockService(){
  binder=new Stub(){
    @Override public void startUi(    IBinder windowToken,    int x,    int y,    int w,    int h,    boolean useLiveliness) throws RemoteException {
      DisplayMetrics metrics=new DisplayMetrics();
      mWindowManager.getDefaultDisplay().getRealMetrics(metrics);
      Log.d(""String_Node_Str"",""String_Node_Str"" + (y + h));
      if (y + h > metrics.heightPixels)       return;
      LayoutParams p=new LayoutParams(LayoutParams.TYPE_APPLICATION_PANEL);
      p.flags=LayoutParams.FLAG_HARDWARE_ACCELERATED | LayoutParams.FLAG_NOT_FOCUSABLE;
      p.token=windowToken;
      p.x=x;
      p.y=y;
      p.width=w;
      p.height=h;
      p.gravity=8388659;
      FaceLockService.this.mLayoutParams=p;
      FaceLockService.this.mHandler.obtainMessage(MSG_SERVICE_CONNECTED,p).sendToTarget();
      if (PicturePasswordUtils.getLockedOut(FaceLockService.this)) {
        lockOut(false);
      }
    }
    @Override public void stopUi() throws RemoteException {
      FaceLockService.this.mHandler.sendEmptyMessage(MSG_SERVICE_DISCONNECTED);
    }
    @Override public void registerCallback(    IFaceLockCallback callback) throws RemoteException {
      FaceLockService.this.mCallback=callback;
    }
    @Override public void unregisterCallback(    IFaceLockCallback callback) throws RemoteException {
      FaceLockService.this.mCallback=null;
    }
  }
;
}",0.910360884749709
87029,"@Override public void startUi(IBinder windowToken,int x,int y,int w,int h,boolean useLiveliness) throws RemoteException {
  LayoutParams p=new LayoutParams(LayoutParams.TYPE_APPLICATION_PANEL);
  p.flags=LayoutParams.FLAG_HARDWARE_ACCELERATED | LayoutParams.FLAG_NOT_FOCUSABLE;
  p.token=windowToken;
  p.x=x;
  p.y=y;
  p.width=w;
  p.height=h;
  p.gravity=8388659;
  FaceLockService.this.mLayoutParams=p;
  FaceLockService.this.mHandler.obtainMessage(MSG_SERVICE_CONNECTED,p).sendToTarget();
  if (PicturePasswordUtils.getLockedOut(FaceLockService.this)) {
    lockOut(false);
  }
}","@Override public void startUi(IBinder windowToken,int x,int y,int w,int h,boolean useLiveliness) throws RemoteException {
  DisplayMetrics metrics=new DisplayMetrics();
  mWindowManager.getDefaultDisplay().getRealMetrics(metrics);
  Log.d(""String_Node_Str"",""String_Node_Str"" + (y + h));
  if (y + h > metrics.heightPixels)   return;
  LayoutParams p=new LayoutParams(LayoutParams.TYPE_APPLICATION_PANEL);
  p.flags=LayoutParams.FLAG_HARDWARE_ACCELERATED | LayoutParams.FLAG_NOT_FOCUSABLE;
  p.token=windowToken;
  p.x=x;
  p.y=y;
  p.width=w;
  p.height=h;
  p.gravity=8388659;
  FaceLockService.this.mLayoutParams=p;
  FaceLockService.this.mHandler.obtainMessage(MSG_SERVICE_CONNECTED,p).sendToTarget();
  if (PicturePasswordUtils.getLockedOut(FaceLockService.this)) {
    lockOut(false);
  }
}",0.8469905728788978
87030,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (!mShowNumbers)   return;
  mPaint.setAlpha((int)(mScale * (mHighlight ? 64 : 255)));
  final float cellSize=(canvas.getWidth() / mGridSize) * (mScale * 0.4f + 0.6f);
  final float xOffset=(1.0f - (mScale * 0.4f + 0.6f)) * canvas.getWidth() / 2;
  final float yOffset=(1.0f - (mScale * 0.4f + 0.6f)) * canvas.getWidth() / 2;
  float drawX=-cellSize / 1.5F + xOffset;
  for (int x=-1; x < mGridSize + 1; x++) {
    float drawY=-mTextBounds.bottom + cellSize / 1.5F - cellSize + yOffset;
    for (int y=-1; y < mGridSize + 1; y++) {
      if (DEBUG) {
        if (x == -1 || y == -1 || x == mGridSize || y == mGridSize) {
          mPaint.setColor(Color.RED);
        }
 else {
          mPaint.setColor(Color.WHITE);
        }
      }
      int cellX=(int)(x - mScrollX / cellSize);
      int cellY=(int)(y - mScrollY / cellSize);
      if (mScrollX / cellSize <= 0 && cellX != 0)       cellX--;
      if (mScrollY / cellSize <= 0 && cellY != 0)       cellY--;
      if (mHighlight && mHighlightX == cellX && mHighlightY == cellY) {
        mPaint.setAlpha((int)mScale * 255);
        Log.d(""String_Node_Str"",""String_Node_Str"" + cellX + ""String_Node_Str""+ cellY);
      }
      Integer number=getNumberForXY(cellX,cellY);
      canvas.drawText(number.toString(),drawX + mScrollX % cellSize,drawY + mScrollY % cellSize,mPaint);
      if (mHighlight && mHighlightX == cellX && mHighlightY == cellY) {
        mPaint.setAlpha((int)mScale * 64);
      }
      drawY+=cellSize;
    }
    drawX+=cellSize;
  }
  if (DEBUG) {
    canvas.drawText(mScrollX / cellSize + ""String_Node_Str"" + mScrollY / cellSize,0,mTextBounds.bottom * 26.5f,mPaint);
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (!mShowNumbers)   return;
  mPaint.setAlpha((int)(mScale * (mHighlight ? 64 : 255)));
  final float cellSize=(canvas.getWidth() / (float)mGridSize) * (mScale * 0.4f + 0.6f);
  final float xOffset=(1.0f - (mScale * 0.4f + 0.6f)) * canvas.getWidth() / 2;
  final float yOffset=(1.0f - (mScale * 0.4f + 0.6f)) * canvas.getWidth() / 2;
  float drawX=-cellSize / 1.5F + xOffset;
  for (int x=-1; x < mGridSize + 1; x++) {
    float drawY=-mTextBounds.bottom + cellSize / 1.5F - cellSize + yOffset;
    for (int y=-1; y < mGridSize + 1; y++) {
      if (DEBUG) {
        if (x == -1 || y == -1 || x == mGridSize || y == mGridSize) {
          mPaint.setColor(Color.RED);
        }
 else {
          mPaint.setColor(Color.WHITE);
        }
      }
      int cellX=(int)(x - Math.floor(mScrollX / cellSize));
      int cellY=(int)(y - Math.floor(mScrollY / cellSize));
      if (mScrollX / cellSize <= 0 && cellX != 0 && mScrollX != 0)       cellX--;
      if (mScrollY / cellSize <= 0 && cellY != 0 && mScrollY != 0)       cellY--;
      if (mHighlight && mHighlightX == cellX && mHighlightY == cellY) {
        mPaint.setAlpha((int)mScale * 255);
      }
      Integer number=getNumberForXY(cellX,cellY);
      canvas.drawText(number.toString(),drawX + mScrollX % cellSize,drawY + mScrollY % cellSize,mPaint);
      if (mHighlight && mHighlightX == cellX && mHighlightY == cellY) {
        mPaint.setAlpha((int)mScale * 64);
      }
      drawY+=cellSize;
    }
    drawX+=cellSize;
  }
  if (DEBUG) {
    canvas.drawText(mScrollX / cellSize + ""String_Node_Str"" + mScrollY / cellSize,0,mTextBounds.bottom * 26.5f,mPaint);
  }
}",0.9555295494441194
87031,"protected TriplePatternFragment createTriplePatternFragment(final Model triples,final long totalSize,final boolean isLastPage){
  return new TriplePatternFragmentImpl(triples,totalSize,request.getFragmentURL(),request.getDatasetURL(),request.getPageNumber(),isLastPage);
}","protected TriplePatternFragment createTriplePatternFragment(final Model triples,final long totalSize,final boolean isLastPage){
  final long pageNumber;
  if (request.isPageRequest())   pageNumber=request.getPageNumber();
 else   pageNumber=1L;
  return new TriplePatternFragmentImpl(triples,totalSize,request.getFragmentURL(),request.getDatasetURL(),pageNumber,isLastPage);
}",0.7685185185185185
87032,"/** 
 * Setup the multicast facilities.
 * @throws java.io.IOException
 */
public void setupNetworking() throws IOException {
  if (NetworkUtil.getNetworkInterface() == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  try {
    if (!NetworkUtil.getNetworkInterface().supportsMulticast()) {
      LOG.error(""String_Node_Str"");
      return;
    }
  }
 catch (  SocketException ex) {
    LOG.error(""String_Node_Str"",ex);
    return;
  }
  try {
    if (NetworkUtil.getNetworkInterface() == null || !NetworkUtil.getNetworkInterface().isUp()) {
      LOG.error(""String_Node_Str"");
      return;
    }
  }
 catch (  SocketException ex) {
    LOG.error(""String_Node_Str"",ex);
    return;
  }
  socket=new MulticastSocket(multicastPort);
  socket.setReuseAddress(true);
  socket.setTimeToLive(multicastTtl);
  group=InetAddress.getByName(multicastGroup);
  socket.joinGroup(new InetSocketAddress(group,multicastPort),NetworkUtil.getNetworkInterface());
  LOG.info(""String_Node_Str"");
  try {
    GossipMessage message=new GossipMessage(me.getIp(),me.getGossipPort(),me.getDataPort());
    message.setMillisecondsSinceMidnight(TimeUtil.getMillisecondsSinceMidnight());
    message.getTags().putAll(me.getTags());
    message.getMembers().add(MemberKey.getKey(me));
    message.getClock().add(me.getSequence().incrementAndGet());
    message.setPublicKey(me.getPublicKey());
    sendMessage(message);
  }
 catch (  IOException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
}","/** 
 * Setup the multicast facilities.
 * @throws java.io.IOException
 */
public void setupNetworking() throws IOException {
  if (NetworkUtil.getNetworkInterface() == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  try {
    if (!NetworkUtil.getNetworkInterface().supportsMulticast()) {
      LOG.error(""String_Node_Str"");
      return;
    }
  }
 catch (  SocketException ex) {
    LOG.error(""String_Node_Str"",ex);
    return;
  }
  try {
    if (NetworkUtil.getNetworkInterface() == null || !NetworkUtil.getNetworkInterface().isUp()) {
      LOG.error(""String_Node_Str"");
      return;
    }
  }
 catch (  SocketException ex) {
    LOG.error(""String_Node_Str"",ex);
    return;
  }
  socket=new MulticastSocket(multicastPort);
  socket.setReuseAddress(true);
  socket.setTimeToLive(multicastTtl);
  group=InetAddress.getByName(multicastGroup);
switch (Parameters.INSTANCE.currentOS()) {
case MAC_64:
case MAC_32:
    socket.joinGroup(new InetSocketAddress(group,multicastPort),NetworkUtil.getNetworkInterface());
  break;
case WIN_64:
case WIN_32:
case LINUX_64:
case LINUX_32:
default :
socket.joinGroup(group);
break;
}
LOG.info(""String_Node_Str"");
try {
GossipMessage message=new GossipMessage(me.getIp(),me.getGossipPort(),me.getDataPort());
message.setMillisecondsSinceMidnight(TimeUtil.getMillisecondsSinceMidnight());
message.getTags().putAll(me.getTags());
message.getMembers().add(MemberKey.getKey(me));
message.getClock().add(me.getSequence().incrementAndGet());
message.setPublicKey(me.getPublicKey());
sendMessage(message);
}
 catch (IOException ex) {
LOG.error(""String_Node_Str"",ex);
}
}",0.9294954721862873
87033,"/** 
 * Setup the multicast facilities.
 * @throws java.io.IOException
 */
public void setupNetworking() throws IOException {
  if (NetworkUtil.getNetworkInterface() == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  try {
    if (!NetworkUtil.getNetworkInterface().supportsMulticast()) {
      LOG.error(""String_Node_Str"");
      return;
    }
  }
 catch (  SocketException ex) {
    LOG.error(""String_Node_Str"",ex);
    return;
  }
  try {
    if (NetworkUtil.getNetworkInterface() == null || !NetworkUtil.getNetworkInterface().isUp()) {
      LOG.error(""String_Node_Str"");
      return;
    }
  }
 catch (  SocketException ex) {
    LOG.error(""String_Node_Str"",ex);
    return;
  }
  socket=new MulticastSocket(multicastPort);
  socket.setReuseAddress(true);
  socket.setTimeToLive(multicastTtl);
  group=InetAddress.getByName(multicastGroup);
switch (Parameters.INSTANCE.currentOS()) {
case MAC_64:
case MAC_32:
    socket.joinGroup(new InetSocketAddress(group,multicastPort),NetworkUtil.getNetworkInterface());
  break;
case WIN_64:
case WIN_32:
case LINUX_64:
case LINUX_32:
default :
socket.joinGroup(group);
break;
}
try {
GossipMessage message=new GossipMessage(me.getIp(),me.getGossipPort(),me.getDataPort());
message.setMillisecondsSinceMidnight(TimeUtil.getMillisecondsSinceMidnight());
message.getTags().putAll(me.getTags());
message.getMembers().add(MemberKey.getKey(me));
message.getClock().add(me.getSequence().incrementAndGet());
message.setPublicKey(me.getPublicKey());
sendMessage(message);
}
 catch (IOException ex) {
LOG.error(""String_Node_Str"",ex);
}
}","/** 
 * Setup the multicast facilities.
 * @throws java.io.IOException
 */
public void setupNetworking() throws IOException {
  if (NetworkUtil.getNetworkInterface() == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  try {
    if (!NetworkUtil.getNetworkInterface().supportsMulticast()) {
      LOG.error(""String_Node_Str"");
      return;
    }
  }
 catch (  SocketException ex) {
    LOG.error(""String_Node_Str"",ex);
    return;
  }
  try {
    if (NetworkUtil.getNetworkInterface() == null || !NetworkUtil.getNetworkInterface().isUp()) {
      LOG.error(""String_Node_Str"");
      return;
    }
  }
 catch (  SocketException ex) {
    LOG.error(""String_Node_Str"",ex);
    return;
  }
  socket=new MulticastSocket(multicastPort);
  socket.setReuseAddress(true);
  socket.setTimeToLive(multicastTtl);
  group=InetAddress.getByName(multicastGroup);
switch (Parameters.INSTANCE.currentOS()) {
case MAC_64:
case MAC_32:
case WIN_64:
case WIN_32:
case LINUX_64:
case LINUX_32:
default :
    socket.joinGroup(new InetSocketAddress(group,multicastPort),NetworkUtil.getNetworkInterface());
  break;
}
try {
GossipMessage message=new GossipMessage(me.getIp(),me.getGossipPort(),me.getDataPort());
message.setMillisecondsSinceMidnight(TimeUtil.getMillisecondsSinceMidnight());
message.getTags().putAll(me.getTags());
message.getMembers().add(MemberKey.getKey(me));
message.getClock().add(me.getSequence().incrementAndGet());
message.setPublicKey(me.getPublicKey());
sendMessage(message);
}
 catch (IOException ex) {
LOG.error(""String_Node_Str"",ex);
}
}",0.9356687898089172
87034,"@BeforeClass public static void init() throws InterruptedException {
  speaker1=Starter.bootstrap();
  speaker2=Starter.bootstrap();
  speaker2.addListener(""String_Node_Str"",listener);
  Thread.sleep(1000l);
}","@BeforeClass public static void init() throws InterruptedException {
  speaker1=Starter.bootstrap();
  speaker2=Starter.bootstrap();
  speaker2.addListener(""String_Node_Str"",listener);
  Thread.sleep(2000l);
}",0.9952153110047848
87035,"@BeforeClass public static void init() throws InterruptedException {
  Parameters.INSTANCE.setProperty(ClusterService.PROTOCOL_PROPERTY,""String_Node_Str"");
  speaker1=Starter.bootstrap();
  speaker2=Starter.bootstrap();
  speaker2.addListener(""String_Node_Str"",listener);
  speaker2.addListener(""String_Node_Str"",delayedListener);
  Thread.sleep(1000l);
}","@BeforeClass public static void init() throws InterruptedException {
  Parameters.INSTANCE.setProperty(ClusterService.PROTOCOL_PROPERTY,""String_Node_Str"");
  speaker1=Starter.bootstrap();
  speaker2=Starter.bootstrap();
  speaker2.addListener(""String_Node_Str"",listener);
  speaker2.addListener(""String_Node_Str"",delayedListener);
  Thread.sleep(2000l);
}",0.9971830985915492
87036,"/** 
 * Perform the transformation.
 * @param clazz the class.
 * @param signatures the set of field signatures.
 * @param pool the class pool.
 */
public static final void transform(CtClass clazz,Map<String,String> signatures,ClassPool pool){
  CtField[] fields=clazz.getDeclaredFields();
  try {
    clazz.addInterface(pool.getCtClass(""String_Node_Str""));
  }
 catch (  NotFoundException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
  CtField msgPackField;
  CtMethod decodeValueMethod;
  CtMethod decodeUnpackerMethod;
  CtMethod decodeBytesMethod;
  CtMethod encodeMethod;
  CtMethod encodeListMethod;
  CtMethod encodeBooleanArrayMethod;
  CtMethod encodeByteArrayMethod;
  CtMethod encodeShortArrayMethod;
  CtMethod encodeIntArrayMethod;
  CtMethod encodeFloatArrayMethod;
  CtMethod encodeLongArrayMethod;
  CtMethod encodeDoubleArrayMethod;
  CtMethod encodeStringArrayMethod;
  CtMethod encodeMapMethod;
  StringBuilder decodeBuff=new StringBuilder();
  decodeBuff.append(""String_Node_Str"");
  decodeBuff.append(""String_Node_Str"");
  decodeBuff.append(""String_Node_Str"");
  StringBuilder encodeBuff=new StringBuilder();
  encodeBuff.append(""String_Node_Str"");
  encodeBuff.append(""String_Node_Str"");
  encodeBuff.append(""String_Node_Str"");
  for (  CtField field : fields) {
    try {
      if (field.getType().subclassOf(pool.get(""String_Node_Str""))) {
        String type=getType(signatures.get(field.getName()));
        encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
switch (type) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
          decodeBuff.append(field.getName()).append(""String_Node_Str"");
        decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
      break;
default :
    decodeBuff.append(field.getName()).append(""String_Node_Str"");
  decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
break;
}
}
 else if (field.getType().subclassOf(pool.get(""String_Node_Str""))) {
String type=getType(signatures.get(field.getName()));
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
switch (type) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
decodeBuff.append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
break;
default :
decodeBuff.append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
break;
}
}
 else if (field.getType().subclassOf(pool.get(""String_Node_Str""))) {
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"");
}
 else if (field.getType().hasAnnotation(Class.forName(""String_Node_Str""))) {
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"");
}
 else {
switch (field.getType().getName()) {
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
}
}
}
 catch (NotFoundException ex) {
LOG.error(""String_Node_Str"",ex);
}
catch (ClassNotFoundException ex) {
LOG.error(""String_Node_Str"",ex);
}
}
decodeBuff.append(""String_Node_Str"");
decodeBuff.append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"");
try {
msgPackField=CtField.make(""String_Node_Str"",clazz);
clazz.addField(msgPackField);
int modifiers=clazz.getModifiers();
CtMethod tmpMethod=CtNewMethod.abstractMethod(CtClass.voidType,""String_Node_Str"",new CtClass[]{pool.get(""String_Node_Str""),pool.get(""String_Node_Str""),pool.get(""String_Node_Str"")},new CtClass[]{pool.get(""String_Node_Str"")},clazz);
clazz.addMethod(tmpMethod);
encodeBooleanArrayMethod=CtMethod.make(encodeBooleanArraySrc,clazz);
clazz.addMethod(encodeBooleanArrayMethod);
encodeByteArrayMethod=CtMethod.make(encodeByteArraySrc,clazz);
clazz.addMethod(encodeByteArrayMethod);
encodeShortArrayMethod=CtMethod.make(encodeShortArraySrc,clazz);
clazz.addMethod(encodeShortArrayMethod);
encodeIntArrayMethod=CtMethod.make(encodeIntArraySrc,clazz);
clazz.addMethod(encodeIntArrayMethod);
encodeFloatArrayMethod=CtMethod.make(encodeFloatArraySrc,clazz);
clazz.addMethod(encodeFloatArrayMethod);
encodeLongArrayMethod=CtMethod.make(encodeLongArraySrc,clazz);
clazz.addMethod(encodeLongArrayMethod);
encodeDoubleArrayMethod=CtMethod.make(encodeDoubleArraySrc,clazz);
clazz.addMethod(encodeDoubleArrayMethod);
encodeStringArrayMethod=CtMethod.make(encodeStringArraySrc,clazz);
clazz.addMethod(encodeStringArrayMethod);
encodeListMethod=CtMethod.make(encodeListSrc,clazz);
clazz.addMethod(encodeListMethod);
clazz.removeMethod(tmpMethod);
clazz.setModifiers(modifiers);
encodeMapMethod=CtMethod.make(encodeMapSrc,clazz);
clazz.addMethod(encodeMapMethod);
decodeValueMethod=CtMethod.make(decodeValueSrc,clazz);
clazz.addMethod(decodeValueMethod);
decodeUnpackerMethod=CtMethod.make(decodeUnpackerSrc,clazz);
clazz.addMethod(decodeUnpackerMethod);
decodeBytesMethod=CtMethod.make(decodeBuff.toString(),clazz);
encodeMethod=CtMethod.make(encodeBuff.toString(),clazz);
clazz.addMethod(encodeMethod);
clazz.addMethod(decodeBytesMethod);
}
 catch (CannotCompileException ex) {
LOG.error(""String_Node_Str"",ex);
}
catch (NotFoundException ex) {
LOG.error(""String_Node_Str"",ex);
}
}","/** 
 * Perform the transformation.
 * @param clazz the class.
 * @param signatures the set of field signatures.
 * @param pool the class pool.
 */
public static final void transform(CtClass clazz,Map<String,String> signatures,ClassPool pool){
  CtField[] fields=clazz.getDeclaredFields();
  try {
    clazz.addInterface(pool.getCtClass(""String_Node_Str""));
  }
 catch (  NotFoundException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
  CtField msgPackField;
  CtMethod decodeValueMethod;
  CtMethod decodeUnpackerMethod;
  CtMethod decodeBytesMethod;
  CtMethod encodeMethod;
  CtMethod encodeListMethod;
  CtMethod encodeBooleanArrayMethod;
  CtMethod encodeByteArrayMethod;
  CtMethod encodeShortArrayMethod;
  CtMethod encodeIntArrayMethod;
  CtMethod encodeFloatArrayMethod;
  CtMethod encodeLongArrayMethod;
  CtMethod encodeDoubleArrayMethod;
  CtMethod encodeStringArrayMethod;
  CtMethod encodeMapMethod;
  StringBuilder decodeBuff=new StringBuilder();
  decodeBuff.append(""String_Node_Str"");
  decodeBuff.append(""String_Node_Str"");
  if (fields.length > 0) {
    decodeBuff.append(""String_Node_Str"");
  }
  StringBuilder encodeBuff=new StringBuilder();
  encodeBuff.append(""String_Node_Str"");
  encodeBuff.append(""String_Node_Str"");
  encodeBuff.append(""String_Node_Str"");
  for (  CtField field : fields) {
    try {
      if (field.getType().subclassOf(pool.get(""String_Node_Str""))) {
        String type=getType(signatures.get(field.getName()));
        encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
switch (type) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
          decodeBuff.append(field.getName()).append(""String_Node_Str"");
        decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
      break;
default :
    decodeBuff.append(field.getName()).append(""String_Node_Str"");
  decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
break;
}
}
 else if (field.getType().subclassOf(pool.get(""String_Node_Str""))) {
String type=getType(signatures.get(field.getName()));
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
switch (type) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
decodeBuff.append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
break;
default :
decodeBuff.append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
break;
}
}
 else if (field.getType().subclassOf(pool.get(""String_Node_Str""))) {
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"");
}
 else if (field.getType().hasAnnotation(Class.forName(""String_Node_Str""))) {
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"");
}
 else {
switch (field.getType().getName()) {
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
}
}
}
 catch (NotFoundException ex) {
LOG.error(""String_Node_Str"",ex);
}
catch (ClassNotFoundException ex) {
LOG.error(""String_Node_Str"",ex);
}
}
if (fields.length > 0) {
decodeBuff.append(""String_Node_Str"");
}
decodeBuff.append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"");
try {
msgPackField=CtField.make(""String_Node_Str"",clazz);
clazz.addField(msgPackField);
int modifiers=clazz.getModifiers();
CtMethod tmpMethod=CtNewMethod.abstractMethod(CtClass.voidType,""String_Node_Str"",new CtClass[]{pool.get(""String_Node_Str""),pool.get(""String_Node_Str""),pool.get(""String_Node_Str"")},new CtClass[]{pool.get(""String_Node_Str"")},clazz);
clazz.addMethod(tmpMethod);
encodeBooleanArrayMethod=CtMethod.make(encodeBooleanArraySrc,clazz);
clazz.addMethod(encodeBooleanArrayMethod);
encodeByteArrayMethod=CtMethod.make(encodeByteArraySrc,clazz);
clazz.addMethod(encodeByteArrayMethod);
encodeShortArrayMethod=CtMethod.make(encodeShortArraySrc,clazz);
clazz.addMethod(encodeShortArrayMethod);
encodeIntArrayMethod=CtMethod.make(encodeIntArraySrc,clazz);
clazz.addMethod(encodeIntArrayMethod);
encodeFloatArrayMethod=CtMethod.make(encodeFloatArraySrc,clazz);
clazz.addMethod(encodeFloatArrayMethod);
encodeLongArrayMethod=CtMethod.make(encodeLongArraySrc,clazz);
clazz.addMethod(encodeLongArrayMethod);
encodeDoubleArrayMethod=CtMethod.make(encodeDoubleArraySrc,clazz);
clazz.addMethod(encodeDoubleArrayMethod);
encodeStringArrayMethod=CtMethod.make(encodeStringArraySrc,clazz);
clazz.addMethod(encodeStringArrayMethod);
encodeListMethod=CtMethod.make(encodeListSrc,clazz);
clazz.addMethod(encodeListMethod);
clazz.removeMethod(tmpMethod);
clazz.setModifiers(modifiers);
encodeMapMethod=CtMethod.make(encodeMapSrc,clazz);
clazz.addMethod(encodeMapMethod);
decodeValueMethod=CtMethod.make(decodeValueSrc,clazz);
clazz.addMethod(decodeValueMethod);
decodeUnpackerMethod=CtMethod.make(decodeUnpackerSrc,clazz);
clazz.addMethod(decodeUnpackerMethod);
decodeBytesMethod=CtMethod.make(decodeBuff.toString(),clazz);
encodeMethod=CtMethod.make(encodeBuff.toString(),clazz);
clazz.addMethod(encodeMethod);
clazz.addMethod(decodeBytesMethod);
}
 catch (CannotCompileException ex) {
LOG.error(""String_Node_Str"",ex);
}
catch (NotFoundException ex) {
LOG.error(""String_Node_Str"",ex);
}
}",0.9972388403129314
87037,"public void testMessage() throws Exception {
  failed=false;
  speaker1.send(""String_Node_Str"",new EmptyMessage());
  EmptyMessage m=queue.poll(2000l,TimeUnit.MILLISECONDS);
  assertNotNull(m);
  if (failed) {
    fail();
  }
  speaker1.send(""String_Node_Str"",new EmptyMessage());
  m=queue.poll(500l,TimeUnit.MILLISECONDS);
  assertNull(m);
  queue.clear();
}","@Test public void testMessage() throws Exception {
  failed=false;
  speaker1.send(""String_Node_Str"",new EmptyMessage());
  EmptyMessage m=queue.poll(2000l,TimeUnit.MILLISECONDS);
  assertNotNull(m);
  if (failed) {
    fail();
  }
  speaker1.send(""String_Node_Str"",new EmptyMessage());
  m=queue.poll(500l,TimeUnit.MILLISECONDS);
  assertNull(m);
  queue.clear();
}",0.9917355371900828
87038,"private static void findNIC(){
  try {
    String networkInterfaceName=Parameters.INSTANCE.getProperty(NETWORK_INTERFACE_PROPETY);
    if (networkInterfaceName == null || ""String_Node_Str"".equals(networkInterfaceName)) {
switch (Parameters.INSTANCE.currentOS()) {
case WIN_64:
case WIN_32:
        networkInterfaceName=""String_Node_Str"";
      break;
case LINUX_64:
case LINUX_32:
    networkInterfaceName=""String_Node_Str"";
  break;
case MAC_64:
case MAC_32:
networkInterfaceName=""String_Node_Str"";
break;
default :
LOG.error(""String_Node_Str"");
}
}
nic=NetworkInterface.getByName(networkInterfaceName);
if (nic != null && !nic.isUp()) {
LOG.error(""String_Node_Str"" + networkInterfaceName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}
if (nic != null) {
Enumeration e=nic.getInetAddresses();
while (e.hasMoreElements()) {
InetAddress i=(InetAddress)e.nextElement();
String address=i.getHostAddress();
if (!address.contains(""String_Node_Str"")) {
inetAddress=i;
ip=address;
break;
}
}
}
 else {
LOG.error(""String_Node_Str"" + networkInterfaceName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}
}
 catch (SocketException ex) {
LOG.error(""String_Node_Str"",ex);
nic=null;
}
}","private static void findNIC(){
  try {
    String networkInterfaceName=Parameters.INSTANCE.getProperty(NETWORK_INTERFACE_PROPETY);
    if (networkInterfaceName == null || ""String_Node_Str"".equals(networkInterfaceName)) {
switch (Parameters.INSTANCE.currentOS()) {
case WIN_64:
case WIN_32:
        networkInterfaceName=""String_Node_Str"";
      break;
case LINUX_64:
case LINUX_32:
    networkInterfaceName=""String_Node_Str"";
  break;
case MAC_64:
case MAC_32:
networkInterfaceName=""String_Node_Str"";
break;
default :
LOG.error(""String_Node_Str"");
}
}
 else {
networkInterfaceName=networkInterfaceName.trim();
}
nic=NetworkInterface.getByName(networkInterfaceName);
if (nic != null && !nic.isUp()) {
LOG.error(""String_Node_Str"" + networkInterfaceName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}
if (nic != null) {
Enumeration e=nic.getInetAddresses();
while (e.hasMoreElements()) {
InetAddress i=(InetAddress)e.nextElement();
String address=i.getHostAddress();
if (!address.contains(""String_Node_Str"")) {
inetAddress=i;
ip=address;
break;
}
}
}
 else {
LOG.error(""String_Node_Str"" + networkInterfaceName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}
}
 catch (SocketException ex) {
LOG.error(""String_Node_Str"",ex);
nic=null;
}
}",0.9763593380614656
87039,"public static final void transform(CtClass clazz,Map<String,String> signatures,ClassPool pool){
  CtField[] fields=clazz.getDeclaredFields();
  try {
    clazz.addInterface(pool.getCtClass(""String_Node_Str""));
  }
 catch (  NotFoundException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
  CtField msgPackField;
  CtMethod decodeValueMethod;
  CtMethod decodeBytesMethod;
  CtMethod encodeMethod;
  CtMethod encodeListMethod;
  CtMethod encodeMapMethod;
  StringBuilder decodeBuff=new StringBuilder();
  decodeBuff.append(""String_Node_Str"");
  decodeBuff.append(""String_Node_Str"");
  decodeBuff.append(""String_Node_Str"");
  StringBuilder encodeBuff=new StringBuilder();
  encodeBuff.append(""String_Node_Str"");
  encodeBuff.append(""String_Node_Str"");
  encodeBuff.append(""String_Node_Str"");
  for (  CtField field : fields) {
    try {
      if (field.getType().subclassOf(pool.get(""String_Node_Str""))) {
        String type=getType(signatures.get(field.getName()));
switch (type) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
          encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
        decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
      break;
default :
    encodeBuff.append(""String_Node_Str"");
  encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
break;
}
}
 else if (field.getType().subclassOf(pool.get(""String_Node_Str""))) {
String type=getType(signatures.get(field.getName()));
switch (type) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
break;
default :
encodeBuff.append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
break;
}
}
 else if (field.getType().subclassOf(pool.get(""String_Node_Str""))) {
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"");
}
 else if (field.getType().hasAnnotation(Class.forName(""String_Node_Str""))) {
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"");
}
 else {
switch (field.getType().getName()) {
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
}
}
}
 catch (NotFoundException ex) {
LOG.error(""String_Node_Str"",ex);
}
catch (ClassNotFoundException ex) {
LOG.error(""String_Node_Str"",ex);
}
}
decodeBuff.append(""String_Node_Str"");
decodeBuff.append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"");
try {
msgPackField=CtField.make(""String_Node_Str"",clazz);
clazz.addField(msgPackField);
int modifiers=clazz.getModifiers();
CtMethod tmpMethod=CtNewMethod.abstractMethod(CtClass.voidType,""String_Node_Str"",new CtClass[]{pool.get(""String_Node_Str""),pool.get(""String_Node_Str""),pool.get(""String_Node_Str"")},new CtClass[]{pool.get(""String_Node_Str"")},clazz);
clazz.addMethod(tmpMethod);
encodeListMethod=CtMethod.make(encodeListSrc,clazz);
clazz.addMethod(encodeListMethod);
clazz.removeMethod(tmpMethod);
clazz.setModifiers(modifiers);
encodeMapMethod=CtMethod.make(encodeMapSrc,clazz);
clazz.addMethod(encodeMapMethod);
decodeValueMethod=CtMethod.make(decodeValueSrc,clazz);
clazz.addMethod(decodeValueMethod);
decodeBytesMethod=CtMethod.make(decodeBuff.toString(),clazz);
encodeMethod=CtMethod.make(encodeBuff.toString(),clazz);
clazz.addMethod(encodeMethod);
clazz.addMethod(decodeBytesMethod);
}
 catch (CannotCompileException ex) {
LOG.error(""String_Node_Str"",ex);
}
catch (NotFoundException ex) {
LOG.error(""String_Node_Str"",ex);
}
}","public static final void transform(CtClass clazz,Map<String,String> signatures,ClassPool pool){
  CtField[] fields=clazz.getDeclaredFields();
  try {
    clazz.addInterface(pool.getCtClass(""String_Node_Str""));
  }
 catch (  NotFoundException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
  CtField msgPackField;
  CtMethod decodeValueMethod;
  CtMethod decodeBytesMethod;
  CtMethod encodeMethod;
  CtMethod encodeListMethod;
  CtMethod encodeMapMethod;
  StringBuilder decodeBuff=new StringBuilder();
  decodeBuff.append(""String_Node_Str"");
  decodeBuff.append(""String_Node_Str"");
  decodeBuff.append(""String_Node_Str"");
  StringBuilder encodeBuff=new StringBuilder();
  encodeBuff.append(""String_Node_Str"");
  encodeBuff.append(""String_Node_Str"");
  encodeBuff.append(""String_Node_Str"");
  for (  CtField field : fields) {
    try {
      if (field.getType().subclassOf(pool.get(""String_Node_Str""))) {
        String type=getType(signatures.get(field.getName()));
switch (type) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
          encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
        decodeBuff.append(field.getName()).append(""String_Node_Str"");
      decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
    break;
default :
  encodeBuff.append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
break;
}
}
 else if (field.getType().subclassOf(pool.get(""String_Node_Str""))) {
String type=getType(signatures.get(field.getName()));
switch (type) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
break;
default :
encodeBuff.append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(type).append(""String_Node_Str"");
break;
}
}
 else if (field.getType().subclassOf(pool.get(""String_Node_Str""))) {
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"");
}
 else if (field.getType().hasAnnotation(Class.forName(""String_Node_Str""))) {
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"").append(field.getType().getName()).append(""String_Node_Str"");
}
 else {
switch (field.getType().getName()) {
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
case ""String_Node_Str"":
encodeBuff.append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
decodeBuff.append(field.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
break;
}
}
}
 catch (NotFoundException ex) {
LOG.error(""String_Node_Str"",ex);
}
catch (ClassNotFoundException ex) {
LOG.error(""String_Node_Str"",ex);
}
}
decodeBuff.append(""String_Node_Str"");
decodeBuff.append(""String_Node_Str"");
encodeBuff.append(""String_Node_Str"");
try {
msgPackField=CtField.make(""String_Node_Str"",clazz);
clazz.addField(msgPackField);
int modifiers=clazz.getModifiers();
CtMethod tmpMethod=CtNewMethod.abstractMethod(CtClass.voidType,""String_Node_Str"",new CtClass[]{pool.get(""String_Node_Str""),pool.get(""String_Node_Str""),pool.get(""String_Node_Str"")},new CtClass[]{pool.get(""String_Node_Str"")},clazz);
clazz.addMethod(tmpMethod);
encodeListMethod=CtMethod.make(encodeListSrc,clazz);
clazz.addMethod(encodeListMethod);
clazz.removeMethod(tmpMethod);
clazz.setModifiers(modifiers);
encodeMapMethod=CtMethod.make(encodeMapSrc,clazz);
clazz.addMethod(encodeMapMethod);
decodeValueMethod=CtMethod.make(decodeValueSrc,clazz);
clazz.addMethod(decodeValueMethod);
decodeBytesMethod=CtMethod.make(decodeBuff.toString(),clazz);
encodeMethod=CtMethod.make(encodeBuff.toString(),clazz);
clazz.addMethod(encodeMethod);
clazz.addMethod(decodeBytesMethod);
}
 catch (CannotCompileException ex) {
LOG.error(""String_Node_Str"",ex);
}
catch (NotFoundException ex) {
LOG.error(""String_Node_Str"",ex);
}
}",0.9864357262103506
87040,"@Test public void testMessage() throws Exception {
  failed=false;
  List<List<Double>> doubles=new ArrayList<>();
  for (int i=0; i < 6; ++i) {
    List<Double> value=new ArrayList<>();
    for (int j=0; j < 6; ++j) {
      value.add(Math.random());
    }
    doubles.add(value);
  }
  LOG.info(""String_Node_Str"");
  speaker1.send(""String_Node_Str"",new MyMessage(MESSAGE + ""String_Node_Str"",doubles));
  MyMessage m=queue.poll(2000l,TimeUnit.MILLISECONDS);
  assertNotNull(m);
  assertEquals(m.getMessage(),MESSAGE + ""String_Node_Str"");
  List<List<Double>> received=m.cov.a;
  for (int i=0; i < 6; ++i) {
    List<Double> value=doubles.get(i);
    List<Double> receivedValue=received.get(i);
    for (int j=0; j < 6; ++j) {
      LOG.info(""String_Node_Str"" + i + ""String_Node_Str""+ j+ ""String_Node_Str""+ value.get(j)+ ""String_Node_Str""+ receivedValue.get(j));
      assertEquals(value.get(j),receivedValue.get(j),0.0001);
    }
  }
}","@Test public void testMessage() throws Exception {
  failed=false;
  List<List<Double>> doubles=new ArrayList<>();
  for (int i=0; i < 6; ++i) {
    List<Double> value=new ArrayList<>();
    for (int j=0; j < 6; ++j) {
      value.add(Math.random());
    }
    doubles.add(value);
  }
  speaker1.send(""String_Node_Str"",new MyMessage(MESSAGE + ""String_Node_Str"",doubles));
  MyMessage m=queue.poll(2000l,TimeUnit.MILLISECONDS);
  assertNotNull(m);
  assertEquals(m.getMessage(),MESSAGE + ""String_Node_Str"");
  List<List<Double>> received=m.cov.a;
  for (int i=0; i < 6; ++i) {
    List<Double> value=doubles.get(i);
    List<Double> receivedValue=received.get(i);
    for (int j=0; j < 6; ++j) {
      LOG.info(""String_Node_Str"" + i + ""String_Node_Str""+ j+ ""String_Node_Str""+ value.get(j)+ ""String_Node_Str""+ receivedValue.get(j));
      assertEquals(value.get(j),receivedValue.get(j),0.0001);
    }
  }
}",0.9831430125067973
87041,"@Test public void testFailMessage() throws Exception {
  failed=false;
  List<List<Double>> doubles=new ArrayList<>();
  for (int i=0; i < 6; ++i) {
    List<Double> value=new ArrayList<>();
    for (int j=0; j < 6; ++j) {
      value.add(Math.random());
    }
    doubles.add(value);
  }
  LOG.info(""String_Node_Str"");
  speaker1.send(""String_Node_Str"",new FailMessage(MESSAGE + ""String_Node_Str"",doubles));
  FailMessage m=failQueue.poll(2000l,TimeUnit.MILLISECONDS);
  assertNotNull(m);
  assertEquals(m.getMessage(),MESSAGE + ""String_Node_Str"");
  List<List<Double>> received=m.cov.a;
  for (int i=0; i < 6; ++i) {
    List<Double> value=doubles.get(i);
    List<Double> receivedValue=received.get(i);
    for (int j=0; j < 6; ++j) {
      LOG.info(""String_Node_Str"" + i + ""String_Node_Str""+ j+ ""String_Node_Str""+ value.get(j)+ ""String_Node_Str""+ receivedValue.get(j));
      assertEquals(value.get(j),receivedValue.get(j),0.0001);
    }
  }
}","@Test public void testFailMessage() throws Exception {
  failed=false;
  List<List<Double>> doubles=new ArrayList<>();
  for (int i=0; i < 6; ++i) {
    List<Double> value=new ArrayList<>();
    for (int j=0; j < 6; ++j) {
      value.add(Math.random());
    }
    doubles.add(value);
  }
  speaker1.send(""String_Node_Str"",new FailMessage(MESSAGE + ""String_Node_Str"",doubles));
  FailMessage m=failQueue.poll(2000l,TimeUnit.MILLISECONDS);
  assertNotNull(m);
  assertEquals(m.getMessage(),MESSAGE + ""String_Node_Str"");
  List<List<Double>> received=m.cov.a;
  for (int i=0; i < 6; ++i) {
    List<Double> value=doubles.get(i);
    List<Double> receivedValue=received.get(i);
    for (int j=0; j < 6; ++j) {
      assertEquals(value.get(j),receivedValue.get(j),0.0001);
    }
  }
}",0.903300521134916
87042,"/** 
 * Shutdown communication objects.
 */
public void shutdown(){
  shuttingDown=true;
  gossiper.shutdown();
  try {
    multicast.shutdown();
  }
 catch (  InterruptedException ex) {
    LOG.warn(""String_Node_Str"",ex);
  }
  for (  Member member : memberHolder.getAllMembers()) {
    ((AbstractMember)member).shutdown();
  }
  memberHolder.clear();
}","/** 
 * Shutdown communication objects.
 */
public void shutdown(){
  shuttingDown=true;
  gossiper.shutdown();
  multicast.shutdown();
  for (  Member member : memberHolder.getAllMembers()) {
    ((AbstractMember)member).shutdown();
  }
  memberHolder.clear();
}",0.4538087520259319
87043,"/** 
 * Shutdown the discovery service.
 */
public void shutdown(){
  if (isEnabled() && workerGroup != null) {
    workerGroup.shutdownGracefully();
    try {
      join();
    }
 catch (    InterruptedException ex) {
      LOG.error(""String_Node_Str"",ex);
    }
  }
}","/** 
 * Shutdown the discovery service.
 */
public void shutdown(){
  if (isEnabled() && workerGroup != null) {
    workerGroup.shutdownGracefully();
    try {
      join();
    }
 catch (    InterruptedException ex) {
      LOG.warn(""String_Node_Str"",ex);
    }
  }
}",0.9832402234636872
87044,"private void handleGossipMessage(GossipMessage message){
  if (shuttingDown) {
    return;
  }
  String senderKey=MemberKey.getKey(message);
  boolean updateTags=false;
  for (int i=0; i < message.getMembers().size(); ++i) {
    String key=message.getMembers().get(i);
    Member m=memberHolder.getMember(key);
    if (m == null) {
      String protocol=Parameters.INSTANCE.getProperty(PROTOCOL_PROPERTY,DEFAULT_PROTOCOL);
      if (protocol.equalsIgnoreCase(""String_Node_Str"")) {
        if (LOG.isTraceEnabled()) {
          LOG.trace(new StringBuilder().append(MemberKey.getKey(me)).append(""String_Node_Str"").append(message.getIp()).append(""String_Node_Str"").append(message.getGossipPort()).append(""String_Node_Str"").append(message.getDataPort()).toString());
        }
        m=new RemoteMemberUDP(memberHolder);
      }
 else {
        if (LOG.isTraceEnabled()) {
          LOG.trace(new StringBuilder().append(MemberKey.getKey(me)).append(""String_Node_Str"").append(message.getIp()).append(""String_Node_Str"").append(message.getGossipPort()).append(""String_Node_Str"").append(message.getDataPort()).toString());
        }
        m=new RemoteMemberTCP(memberHolder);
      }
      String[] values=key.split(""String_Node_Str"");
      m.setIp(values[0]);
      m.setGossipPort(Integer.parseInt(values[1]));
      m.setDataPort(Integer.parseInt(values[2]));
      ((AbstractMember)m).initialize();
    }
    memberHolder.updateMemberStatus(m);
    int memberClock=message.getClock().get(i);
    int knownMemberClock=m.getSequence().get();
    if (memberClock > knownMemberClock) {
      if (key.equals(senderKey)) {
        updateTags=true;
      }
      m.getSequence().set(memberClock);
      List<String> topics=message.getListeners().get(key);
      if (topics == null) {
        topics=Collections.emptyList();
      }
      List<Registration> toRemove=new ArrayList<>();
      for (      Registration reg : registry.getAllRegistrations()) {
        if (reg.getMember().equals(m)) {
          if (!topics.contains(TopicUtils.getTopicString(reg.getTopic(),reg.getPartition().pattern()))) {
            toRemove.add(reg);
          }
        }
      }
      registry.removeRegistrations(toRemove);
      for (      String topicString : topics) {
        String topic=TopicUtils.getTopic(topicString);
        String partition=TopicUtils.getPartition(topicString);
        if (!registry.getRegisteredMembers(topic).contains(m)) {
          registry.registerMemberForTopic(topic,partition,m);
        }
      }
    }
  }
  if (updateTags) {
    Member m=memberHolder.getMember(senderKey);
    m.getTags().clear();
    m.getTags().putAll(message.getTags());
  }
}","private void handleGossipMessage(GossipMessage message){
  if (shuttingDown) {
    return;
  }
  String senderKey=MemberKey.getKey(message);
  boolean updateTags=false;
  for (int i=0; i < message.getMembers().size(); ++i) {
    String key=message.getMembers().get(i);
    Member m=memberHolder.getMember(key);
    if (m == null) {
      String protocol=Parameters.INSTANCE.getProperty(PROTOCOL_PROPERTY,DEFAULT_PROTOCOL);
      if (protocol.equalsIgnoreCase(""String_Node_Str"")) {
        if (LOG.isTraceEnabled()) {
          LOG.trace(new StringBuilder().append(MemberKey.getKey(me)).append(""String_Node_Str"").append(message.getIp()).append(""String_Node_Str"").append(message.getGossipPort()).append(""String_Node_Str"").append(message.getDataPort()).toString());
        }
        m=new RemoteMemberUDP(memberHolder);
      }
 else {
        if (LOG.isTraceEnabled()) {
          LOG.trace(new StringBuilder().append(MemberKey.getKey(me)).append(""String_Node_Str"").append(message.getIp()).append(""String_Node_Str"").append(message.getGossipPort()).append(""String_Node_Str"").append(message.getDataPort()).toString());
        }
        m=new RemoteMemberTCP(memberHolder);
      }
      String[] values=key.split(""String_Node_Str"");
      m.setIp(values[0]);
      m.setGossipPort(Integer.parseInt(values[1]));
      m.setDataPort(Integer.parseInt(values[2]));
      ((AbstractMember)m).initialize();
    }
    memberHolder.updateMemberStatus(m);
    int memberClock=message.getClock().get(i);
    int knownMemberClock=m.getSequence().get();
    if (memberClock > knownMemberClock) {
      if (key.equals(senderKey)) {
        updateTags=true;
      }
      m.getSequence().set(memberClock);
      List<String> topics=message.getListeners().get(key);
      if (topics == null) {
        topics=Collections.emptyList();
      }
      List<Registration> toRemove=new ArrayList<>();
      for (      Registration reg : registry.getAllRegistrations()) {
        if (reg.getMember().equals(m)) {
          if (!topics.contains(TopicUtils.getTopicString(reg.getTopic(),reg.getPartition()))) {
            toRemove.add(reg);
          }
        }
      }
      registry.removeRegistrations(toRemove);
      for (      String topicString : topics) {
        String topic=TopicUtils.getTopic(topicString);
        String partition=TopicUtils.getPartition(topicString);
        if (!registry.getRegisteredMembers(topic).contains(m)) {
          registry.registerMemberForTopic(topic,partition,m);
        }
      }
    }
  }
  if (updateTags) {
    Member m=memberHolder.getMember(senderKey);
    m.getTags().clear();
    m.getTags().putAll(message.getTags());
  }
}",0.9981195938322678
87045,"public void removeRegistrations(List<Registration> regs){
  map.remove(regs);
}","public void removeRegistrations(List<Registration> regs){
  for (  Map<String,List<Registration>> allRegs : map.values()) {
    if (allRegs != null) {
      for (      String key : allRegs.keySet()) {
        allRegs.get(key).removeAll(regs);
      }
    }
  }
}",0.4574780058651026
87046,"public List<Member> getRegisteredMembers(String topic){
  List<Member> ret=new ArrayList<>();
  List<Registration> members=map.query(topic);
  for (  Registration reg : members) {
    ret.add(reg.getMember());
  }
  return ret;
}","public List<Member> getRegisteredMembers(String topic){
  List<Member> ret=new ArrayList<>();
  for (  Member member : map.keySet()) {
    Map<String,List<Registration>> allRegs=map.get(member);
    if (allRegs != null) {
      for (      String key : allRegs.keySet()) {
        if (key.equals(topic)) {
          ret.add(member);
        }
      }
    }
  }
  return ret;
}",0.5397350993377483
87047,"public void removeAllLocalListeners(String topic){
  List<Registration> regs=map.query(me,topic);
  if (!regs.isEmpty()) {
    LOG.trace(""String_Node_Str"" + regs.size() + ""String_Node_Str"");
    reactor.getConsumerRegistry().unregister(topic);
    map.remove(regs);
  }
 else {
    LOG.trace(""String_Node_Str"" + topic);
  }
}","public void removeAllLocalListeners(String topic){
  Map<String,List<Registration>> allRegs=map.get(me);
  if (allRegs != null) {
    List<Registration> regs=allRegs.get(topic);
    if (regs != null) {
      LOG.trace(""String_Node_Str"" + regs.size() + ""String_Node_Str"");
      reactor.getConsumerRegistry().unregister(topic);
      regs.clear();
    }
 else {
      LOG.trace(""String_Node_Str"" + topic);
    }
  }
}",0.7314439946018894
87048,"protected synchronized void registerMemberForTopic(String topic,String partition,Member member){
  Pattern pattern=Pattern.compile(partition);
  List<Registration> regs=map.query(member,topic,pattern);
  if (regs.isEmpty()) {
    Registration reg=new Registration(member,topic,pattern);
    map.add(reg);
    if (LOG.isTraceEnabled()) {
      LOG.trace(new StringBuilder().append(""String_Node_Str"").append(MemberKey.getKey(member)).append(""String_Node_Str"").append(topic).append(""String_Node_Str"").append(partition).append(""String_Node_Str"").toString());
    }
  }
}","protected synchronized void registerMemberForTopic(String topic,String partition,Member member){
  if (map.get(member) == null) {
    map.put(member,new HashMap<String,List<Registration>>());
  }
  if (map.get(member).get(topic) == null) {
    map.get(member).put(topic,new ArrayList<Registration>());
  }
  boolean found=false;
  for (  Registration reg : map.get(member).get(topic)) {
    if (topic.equals(reg.getTopic()) && partition.equals(reg.getPartition()) && member.equals(reg.getMember())) {
      found=true;
      break;
    }
  }
  if (!found) {
    Registration reg=new Registration(member,topic,partition);
    map.get(member).get(topic).add(reg);
    if (LOG.isTraceEnabled()) {
      LOG.trace(new StringBuilder().append(MemberKey.getKey(me)).append(""String_Node_Str"").append(MemberKey.getKey(member)).append(""String_Node_Str"").append(topic).append(""String_Node_Str"").append(partition).append(""String_Node_Str"").toString());
    }
  }
}",0.546772068511199
87049,"public List<Registration> getAllRegistrations(){
  return map.query();
}","public List<Registration> getAllRegistrations(){
  List<Registration> ret=new ArrayList<>();
  for (  Map<String,List<Registration>> allRegs : map.values()) {
    if (allRegs != null) {
      for (      String key : allRegs.keySet()) {
        ret.addAll(allRegs.get(key));
      }
    }
  }
  return ret;
}",0.3324538258575198
87050,"public <T>void addLocalListener(String topic,String partition,final MessageListener<T> listener){
  Consumer<Event<Envelope>> consumer=new Consumer<Event<Envelope>>(){
    @Override public void accept(    Event<Envelope> m){
      try {
        listener.receive((T)m.getData().getMessage());
      }
 catch (      Throwable ex) {
        LOG.error(""String_Node_Str"",ex);
      }
    }
  }
;
  reactor.on(Selectors.regex(TopicUtils.getTopicString(topic,partition)),consumer);
  List<Registration> regs=map.query(me,topic);
  if (!regs.isEmpty()) {
    regs.get(0).setConsumer(consumer);
    regs.get(0).setListener(listener);
  }
 else {
    LOG.warn(""String_Node_Str"");
  }
}","public <T>void addLocalListener(String topic,String partition,final MessageListener<T> listener){
  Consumer<Event<Envelope>> consumer=new Consumer<Event<Envelope>>(){
    @Override public void accept(    Event<Envelope> m){
      try {
        listener.receive((T)m.getData().getMessage());
      }
 catch (      Throwable ex) {
        LOG.error(""String_Node_Str"",ex);
      }
    }
  }
;
  reactor.on(Selectors.regex(TopicUtils.getTopicString(topic,partition)),consumer);
}",0.8271068635968722
87051,"/** 
 * @return the partition 
 */
public Pattern getPartition(){
  return partition;
}","/** 
 * @return the partition 
 */
public String getPartition(){
  return partition;
}",0.9595375722543352
87052,"/** 
 * @param partition the partition to set
 */
public void setPartition(Pattern partition){
  this.partition=partition;
}","/** 
 * @param partition the partition to set
 */
public void setPartition(String partition){
  this.partition=partition;
}",0.97165991902834
87053,"public Registration(Member member,String topic,Pattern partition){
  this.member=member;
  this.topic=topic;
  this.partition=partition;
}","public Registration(Member member,String topic,String partition){
  this.member=member;
  this.topic=topic;
  this.partition=partition;
}",0.9745454545454544
87054,"@Override public void receive(SimpleMessage message){
  if (messageCount >= throwAway && !warmedUp) {
    LOG.info(""String_Node_Str"");
    warmedUp=true;
    messageCount=0;
    time=System.currentTimeMillis();
  }
  ++messageCount;
  if (messageCount > maxMessages) {
    running=false;
    LOG.info(""String_Node_Str"");
  }
}","@Override public void receive(SimpleMessage message){
  if (messageCount >= throwAway && !warmedUp) {
    LOG.info(""String_Node_Str"");
    warmedUp=true;
    messageCount=0;
    memThread.start();
    time=System.currentTimeMillis();
  }
  ++messageCount;
  if (messageCount > maxMessages) {
    running=false;
    LOG.info(""String_Node_Str"");
  }
}",0.965925925925926
87055,"@PostConstruct public void go(){
  String role=Parameters.INSTANCE.getProperty(""String_Node_Str"",""String_Node_Str"");
  if (role.equals(""String_Node_Str"")) {
    LOG.info(""String_Node_Str"");
    speaker.addListener(""String_Node_Str"",new MessageListener<SimpleMessage>(){
      @Override public void receive(      SimpleMessage message){
        if (messageCount >= throwAway && !warmedUp) {
          LOG.info(""String_Node_Str"");
          warmedUp=true;
          messageCount=0;
          memThread.start();
          time=System.currentTimeMillis();
        }
        ++messageCount;
        if (messageCount > maxMessages) {
          running=false;
          LOG.info(""String_Node_Str"");
        }
        try {
          if (running) {
            speaker.send(""String_Node_Str"",m);
          }
        }
 catch (        Exception ex) {
          LOG.error(""String_Node_Str"",ex);
        }
      }
    }
);
    injectThread.start();
  }
 else   if (role.equals(""String_Node_Str"")) {
    LOG.info(""String_Node_Str"");
    speaker.addListener(""String_Node_Str"",new MessageListener<SimpleMessage>(){
      @Override public void receive(      SimpleMessage message){
        if (messageCount >= throwAway && !warmedUp) {
          LOG.info(""String_Node_Str"");
          warmedUp=true;
          messageCount=0;
          memThread.start();
          time=System.currentTimeMillis();
        }
        ++messageCount;
        if (messageCount > maxMessages) {
          running=false;
          LOG.info(""String_Node_Str"");
        }
        try {
          if (running) {
            speaker.send(""String_Node_Str"",m);
          }
        }
 catch (        Exception ex) {
          LOG.error(""String_Node_Str"",ex);
        }
      }
    }
);
  }
 else {
    LOG.info(""String_Node_Str"");
    speaker.addListener(""String_Node_Str"",new MessageListener<SimpleMessage>(){
      @Override public void receive(      SimpleMessage message){
        if (messageCount >= throwAway && !warmedUp) {
          LOG.info(""String_Node_Str"");
          warmedUp=true;
          messageCount=0;
          time=System.currentTimeMillis();
        }
        ++messageCount;
        if (messageCount > maxMessages) {
          running=false;
          LOG.info(""String_Node_Str"");
        }
      }
    }
);
    localThread.start();
  }
}","@PostConstruct public void go(){
  String role=Parameters.INSTANCE.getProperty(""String_Node_Str"",""String_Node_Str"");
  if (role.equals(""String_Node_Str"")) {
    LOG.info(""String_Node_Str"");
    speaker.addListener(""String_Node_Str"",new MessageListener<SimpleMessage>(){
      @Override public void receive(      SimpleMessage message){
        if (messageCount >= throwAway && !warmedUp) {
          LOG.info(""String_Node_Str"");
          warmedUp=true;
          messageCount=0;
          memThread.start();
          time=System.currentTimeMillis();
        }
        ++messageCount;
        if (messageCount > maxMessages) {
          running=false;
          LOG.info(""String_Node_Str"");
        }
        try {
          if (running) {
            speaker.send(""String_Node_Str"",m);
          }
        }
 catch (        Exception ex) {
          LOG.error(""String_Node_Str"",ex);
        }
      }
    }
);
    injectThread.start();
  }
 else   if (role.equals(""String_Node_Str"")) {
    LOG.info(""String_Node_Str"");
    speaker.addListener(""String_Node_Str"",new MessageListener<SimpleMessage>(){
      @Override public void receive(      SimpleMessage message){
        if (messageCount >= throwAway && !warmedUp) {
          LOG.info(""String_Node_Str"");
          warmedUp=true;
          messageCount=0;
          memThread.start();
          time=System.currentTimeMillis();
        }
        ++messageCount;
        if (messageCount > maxMessages) {
          running=false;
          LOG.info(""String_Node_Str"");
        }
        try {
          if (running) {
            speaker.send(""String_Node_Str"",m);
          }
        }
 catch (        Exception ex) {
          LOG.error(""String_Node_Str"",ex);
        }
      }
    }
);
  }
 else {
    LOG.info(""String_Node_Str"");
    speaker.addListener(""String_Node_Str"",new MessageListener<SimpleMessage>(){
      @Override public void receive(      SimpleMessage message){
        if (messageCount >= throwAway && !warmedUp) {
          LOG.info(""String_Node_Str"");
          warmedUp=true;
          messageCount=0;
          memThread.start();
          time=System.currentTimeMillis();
        }
        ++messageCount;
        if (messageCount > maxMessages) {
          running=false;
          LOG.info(""String_Node_Str"");
        }
      }
    }
);
    System.gc();
    try {
      Thread.sleep(1000l);
    }
 catch (    InterruptedException ex) {
    }
    localThread.start();
  }
}",0.9668763102725368
87056,"private void buildDependencyGraph(){
  components.addAll(reflections.getTypesAnnotatedWith(Component.class));
  injections.addAll(reflections.getFieldsAnnotatedWith(Inject.class));
  initializations.addAll(reflections.getMethodsAnnotatedWith(PostConstruct.class));
  initializations.addAll(reflections.getMethodsAnnotatedWith(Initialize.class));
  for (  Field inject : injections) {
    if (inject.getType().isAssignableFrom(List.class)) {
      if (multipleDependencies.get(inject.getDeclaringClass()) == null) {
        multipleDependencies.put(inject.getDeclaringClass(),new ArrayList<Field>());
      }
      multipleDependencies.get(inject.getDeclaringClass()).add(inject);
    }
 else {
      if (dependencies.get(inject.getDeclaringClass()) == null) {
        dependencies.put(inject.getDeclaringClass(),new ArrayList<Field>());
      }
      dependencies.get(inject.getDeclaringClass()).add(inject);
    }
  }
}","private void buildDependencyGraph(){
  components.addAll(reflections.getTypesAnnotatedWith(Component.class));
  injections.addAll(reflections.getFieldsAnnotatedWith(Inject.class));
  for (  Method init : reflections.getMethodsAnnotatedWith(PostConstruct.class)) {
    initializations.put(init.getDeclaringClass(),init);
  }
  for (  Method init : reflections.getMethodsAnnotatedWith(Initialize.class)) {
    initializations.put(init.getDeclaringClass(),init);
  }
  for (  Field inject : injections) {
    if (inject.getType().isAssignableFrom(List.class)) {
      if (multipleDependencies.get(inject.getDeclaringClass()) == null) {
        multipleDependencies.put(inject.getDeclaringClass(),new ArrayList<Field>());
      }
      multipleDependencies.get(inject.getDeclaringClass()).add(inject);
    }
 else {
      if (dependencies.get(inject.getDeclaringClass()) == null) {
        dependencies.put(inject.getDeclaringClass(),new ArrayList<Field>());
      }
      dependencies.get(inject.getDeclaringClass()).add(inject);
    }
  }
}",0.7997957099080695
87057,"private void loadJars(){
  List<URL> urls=new ArrayList<>();
  FileSystem fileSystem=FileSystems.getDefault();
  Path componentPath=fileSystem.getPath(componentDir);
  Path binPath=fileSystem.getPath(binDir);
  try (DirectoryStream<Path> directoryStream=Files.newDirectoryStream(binPath)){
    for (    Path path : directoryStream) {
      urls.add(path.toUri().toURL());
    }
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"" + binPath + ""String_Node_Str"");
  }
  try (DirectoryStream<Path> directoryStream=Files.newDirectoryStream(componentPath)){
    for (    Path path : directoryStream) {
      LOG.info(""String_Node_Str"" + path);
      urls.add(path.toUri().toURL());
    }
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"" + componentPath + ""String_Node_Str"");
  }
  Configuration config=new ConfigurationBuilder().setUrls(urls).setScanners(new TypeAnnotationsScanner(),new FieldAnnotationsScanner(),new MethodAnnotationsScanner());
  reflections=new Reflections(config);
}","private void loadJars(){
  List<URL> urls=new ArrayList<>();
  FileSystem fileSystem=FileSystems.getDefault();
  Path componentPath=fileSystem.getPath(componentDir);
  Path binPath=fileSystem.getPath(binDir);
  try (DirectoryStream<Path> directoryStream=Files.newDirectoryStream(binPath)){
    for (    Path path : directoryStream) {
      urls.add(path.toUri().toURL());
    }
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"" + binPath + ""String_Node_Str"");
  }
  try (DirectoryStream<Path> directoryStream=Files.newDirectoryStream(componentPath)){
    for (    Path path : directoryStream) {
      urls.add(path.toUri().toURL());
    }
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"" + componentPath + ""String_Node_Str"");
  }
  Configuration config=new ConfigurationBuilder().setUrls(urls).setScanners(new TypeAnnotationsScanner(),new FieldAnnotationsScanner(),new MethodAnnotationsScanner());
  reflections=new Reflections(config);
}",0.9787018255578094
87058,"private void instantiateTree(Class<?> clazz){
  if (instances.get(clazz) == null) {
    try {
      instances.put(clazz,clazz.newInstance());
    }
 catch (    InstantiationException ex) {
      LOG.error(""String_Node_Str"" + clazz.getName(),ex);
    }
catch (    IllegalAccessException ex) {
      LOG.error(""String_Node_Str"",ex);
    }
  }
 else {
    return;
  }
  if (dependencies.containsKey(clazz)) {
    for (    Field field : dependencies.get(clazz)) {
      for (      Class<?> cl : components) {
        LOG.info(cl.getName() + ""String_Node_Str"" + field.getType().getName()+ ""String_Node_Str""+ field.getType().isAssignableFrom(cl));
        if (field.getType().isAssignableFrom(cl)) {
          LOG.info(""String_Node_Str"" + cl.getName());
          instantiateTree(cl);
        }
      }
    }
  }
  if (multipleDependencies.containsKey(clazz)) {
    for (    Field field : multipleDependencies.get(clazz)) {
      ParameterizedType listType=(ParameterizedType)field.getGenericType();
      Class<?> listClass=(Class<?>)listType.getActualTypeArguments()[0];
      for (      Class<?> cl : components) {
        if (listClass.isAssignableFrom(cl)) {
          instantiateTree(cl);
        }
      }
    }
  }
}","private void instantiateTree(Class<?> clazz){
  if (instances.get(clazz) == null) {
    try {
      instances.put(clazz,clazz.newInstance());
    }
 catch (    InstantiationException ex) {
      LOG.error(""String_Node_Str"" + clazz.getName(),ex);
    }
catch (    IllegalAccessException ex) {
      LOG.error(""String_Node_Str"",ex);
    }
  }
 else {
    return;
  }
  if (dependencies.containsKey(clazz)) {
    for (    Field field : dependencies.get(clazz)) {
      for (      Class<?> cl : components) {
        if (field.getType().isAssignableFrom(cl)) {
          instantiateTree(cl);
        }
      }
    }
  }
  if (multipleDependencies.containsKey(clazz)) {
    for (    Field field : multipleDependencies.get(clazz)) {
      ParameterizedType listType=(ParameterizedType)field.getGenericType();
      Class<?> listClass=(Class<?>)listType.getActualTypeArguments()[0];
      for (      Class<?> cl : components) {
        if (listClass.isAssignableFrom(cl)) {
          instantiateTree(cl);
        }
      }
    }
  }
}",0.8917594654788419
87059,"public void scan(){
  loadProperties();
  loadJars();
  buildDependencyGraph();
  instantiateComponents();
  inject();
  initialize();
}","public void scan(){
  loadProperties();
  loadJars();
  buildDependencyGraph();
  instantiateComponents();
  inject();
}",0.9375
87060,"private void inject(){
  for (  Class<?> parent : dependencies.keySet()) {
    for (    Field field : dependencies.get(parent)) {
      for (      Object obj : instances.values()) {
        if (field.getType().isAssignableFrom(obj.getClass())) {
          try {
            if (instances.get(parent) != null) {
              field.setAccessible(true);
              field.set(instances.get(parent),obj);
            }
          }
 catch (          IllegalArgumentException ex) {
            LOG.error(""String_Node_Str"",ex);
          }
catch (          IllegalAccessException ex) {
            LOG.error(""String_Node_Str"",ex);
          }
        }
      }
    }
  }
  for (  Class<?> parent : multipleDependencies.keySet()) {
    for (    Field field : multipleDependencies.get(parent)) {
      for (      Object obj : instances.values()) {
        ParameterizedType listType=(ParameterizedType)field.getGenericType();
        Class<?> listClass=(Class<?>)listType.getActualTypeArguments()[0];
        if (listClass.isAssignableFrom(obj.getClass())) {
          try {
            if (instances.get(parent) != null) {
              field.setAccessible(true);
              if (field.get(instances.get(parent)) == null) {
                field.set(instances.get(parent),new ArrayList());
              }
              Method addMethod=ArrayList.class.getMethod(""String_Node_Str"",Object.class);
              addMethod.invoke(field.get(instances.get(parent)),obj);
            }
          }
 catch (          NoSuchMethodException ex) {
            LOG.error(""String_Node_Str"",ex);
          }
catch (          IllegalAccessException ex) {
            LOG.error(""String_Node_Str"",ex);
          }
catch (          IllegalArgumentException ex) {
            LOG.error(""String_Node_Str"",ex);
          }
catch (          InvocationTargetException ex) {
            LOG.error(""String_Node_Str"",ex);
          }
        }
      }
    }
  }
}","private void inject(){
  for (  Class<?> parent : dependencies.keySet()) {
    inject(parent);
  }
  for (  Class<?> parent : multipleDependencies.keySet()) {
    for (    Field field : multipleDependencies.get(parent)) {
      for (      Object obj : instances.values()) {
        ParameterizedType listType=(ParameterizedType)field.getGenericType();
        Class<?> listClass=(Class<?>)listType.getActualTypeArguments()[0];
        if (listClass.isAssignableFrom(obj.getClass())) {
          try {
            if (instances.get(parent) != null) {
              field.setAccessible(true);
              if (field.get(instances.get(parent)) == null) {
                field.set(instances.get(parent),new ArrayList());
              }
              Method addMethod=ArrayList.class.getMethod(""String_Node_Str"",Object.class);
              addMethod.invoke(field.get(instances.get(parent)),obj);
            }
          }
 catch (          NoSuchMethodException ex) {
            LOG.error(""String_Node_Str"",ex);
          }
catch (          IllegalAccessException ex) {
            LOG.error(""String_Node_Str"",ex);
          }
catch (          IllegalArgumentException ex) {
            LOG.error(""String_Node_Str"",ex);
          }
catch (          InvocationTargetException ex) {
            LOG.error(""String_Node_Str"",ex);
          }
        }
      }
    }
  }
}",0.8225317989097517
87061,"public GossipServerThread(){
  gossipBossGroup=new NioEventLoopGroup(GOSSIP_BOSS_THREADS);
  gossipWorkerGroup=new NioEventLoopGroup(GOSSIP_WORKER_THREADS);
  try {
    ServerBootstrap b=new ServerBootstrap();
    b.group(gossipBossGroup,gossipWorkerGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>(){
      @Override public void initChannel(      SocketChannel ch) throws Exception {
        ch.config().setAllocator(new PooledByteBufAllocator());
        ch.pipeline().addLast(new GossipMessageDecoder());
        ch.pipeline().addLast(""String_Node_Str"",new ByteArrayEncoder());
        ch.pipeline().addLast(""String_Node_Str"",new ByteArrayDecoder());
        ch.pipeline().addLast(new GossipMessageHandler());
        if (LOG.isTraceEnabled()) {
          ch.pipeline().addLast(new LoggingHandler(LogLevel.TRACE));
        }
      }
      @Override public void exceptionCaught(      ChannelHandlerContext ctx,      Throwable cause) throws Exception {
        LOG.error(""String_Node_Str"",cause);
      }
    }
).option(ChannelOption.SO_BACKLOG,128).childOption(ChannelOption.SO_KEEPALIVE,true);
    f=b.bind(getIp(),getGossipPort()).sync();
  }
 catch (  InterruptedException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
}","public GossipServerThread(){
  gossipBossGroup=new NioEventLoopGroup(GOSSIP_BOSS_THREADS);
  gossipWorkerGroup=new NioEventLoopGroup(GOSSIP_WORKER_THREADS);
  try {
    ServerBootstrap b=new ServerBootstrap();
    b.group(gossipBossGroup,gossipWorkerGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>(){
      @Override public void initChannel(      SocketChannel ch) throws Exception {
        ch.config().setAllocator(UnpooledByteBufAllocator.DEFAULT);
        ch.pipeline().addLast(new GossipMessageDecoder());
        ch.pipeline().addLast(""String_Node_Str"",new ByteArrayEncoder());
        ch.pipeline().addLast(""String_Node_Str"",new ByteArrayDecoder());
        ch.pipeline().addLast(new GossipMessageHandler());
        if (LOG.isTraceEnabled()) {
          ch.pipeline().addLast(new LoggingHandler(LogLevel.TRACE));
        }
      }
      @Override public void exceptionCaught(      ChannelHandlerContext ctx,      Throwable cause) throws Exception {
        LOG.error(""String_Node_Str"",cause);
      }
    }
).option(ChannelOption.SO_BACKLOG,128).childOption(ChannelOption.SO_KEEPALIVE,true);
    f=b.bind(getIp(),getGossipPort()).sync();
  }
 catch (  InterruptedException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
}",0.9929411764705882
87062,"@Override public void initChannel(DatagramChannel ch) throws Exception {
  ch.config().setAllocator(new PooledByteBufAllocator());
  ch.pipeline().addLast(new DataMessageHandler());
  if (LOG.isTraceEnabled()) {
    ch.pipeline().addLast(new LoggingHandler(LogLevel.TRACE));
  }
}","@Override public void initChannel(DatagramChannel ch) throws Exception {
  ch.config().setAllocator(UnpooledByteBufAllocator.DEFAULT);
  ch.pipeline().addLast(new DataMessageHandler());
  if (LOG.isTraceEnabled()) {
    ch.pipeline().addLast(new LoggingHandler(LogLevel.TRACE));
  }
}",0.9680851063829788
87063,"public DataServerThread(){
  dataBossGroup=new NioEventLoopGroup(DATA_BOSS_THREADS);
  dataWorkerGroup=new NioEventLoopGroup(DATA_WORKER_THREADS);
  try {
    Bootstrap b=new Bootstrap();
    b.group(dataWorkerGroup).channelFactory(new ChannelFactory<Channel>(){
      @Override public Channel newChannel(){
        return new NioDatagramChannel(InternetProtocolFamily.IPv4);
      }
      @Override public String toString(){
        return NioDatagramChannel.class.getSimpleName() + ""String_Node_Str"";
      }
    }
).handler(new ChannelInitializer<DatagramChannel>(){
      @Override public void initChannel(      DatagramChannel ch) throws Exception {
        ch.config().setAllocator(new PooledByteBufAllocator());
        ch.pipeline().addLast(new DataMessageHandler());
        if (LOG.isTraceEnabled()) {
          ch.pipeline().addLast(new LoggingHandler(LogLevel.TRACE));
        }
      }
      @Override public void exceptionCaught(      ChannelHandlerContext ctx,      Throwable cause) throws Exception {
        LOG.error(""String_Node_Str"",cause);
      }
    }
);
    f=b.bind(getIp(),getDataPort()).sync();
    LOG.debug(""String_Node_Str"");
  }
 catch (  InterruptedException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
}","public DataServerThread(){
  dataBossGroup=new NioEventLoopGroup(DATA_BOSS_THREADS);
  dataWorkerGroup=new NioEventLoopGroup(DATA_WORKER_THREADS);
  try {
    Bootstrap b=new Bootstrap();
    b.group(dataWorkerGroup).channelFactory(new ChannelFactory<Channel>(){
      @Override public Channel newChannel(){
        return new NioDatagramChannel(InternetProtocolFamily.IPv4);
      }
      @Override public String toString(){
        return NioDatagramChannel.class.getSimpleName() + ""String_Node_Str"";
      }
    }
).handler(new ChannelInitializer<DatagramChannel>(){
      @Override public void initChannel(      DatagramChannel ch) throws Exception {
        ch.config().setAllocator(UnpooledByteBufAllocator.DEFAULT);
        ch.pipeline().addLast(new DataMessageHandler());
        if (LOG.isTraceEnabled()) {
          ch.pipeline().addLast(new LoggingHandler(LogLevel.TRACE));
        }
      }
      @Override public void exceptionCaught(      ChannelHandlerContext ctx,      Throwable cause) throws Exception {
        LOG.error(""String_Node_Str"",cause);
      }
    }
);
    f=b.bind(getIp(),getDataPort()).sync();
  }
 catch (  InterruptedException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
}",0.9387254901960784
87064,"@Override public void decode(ChannelHandlerContext ctx,DatagramPacket packet,List<Object> out){
  ByteBuf buff=packet.content();
  byte[] bytes=new byte[2];
  buff.readBytes(bytes,0,2);
  int size=(bytes[0] & 0xFF) << 8 | (bytes[1] & 0xFF);
  bytes=new byte[size];
  buff.readBytes(bytes,0,size);
  decoderReactor.notify(Event.wrap(bytes));
}","@Override public void decode(ChannelHandlerContext ctx,DatagramPacket packet,List<Object> out){
  ByteBuf buff=packet.content();
  byte[] bytes=new byte[2];
  buff.readBytes(bytes,0,2);
  int size=(bytes[0] & 0xFF) << 8 | (bytes[1] & 0xFF);
  bytes=new byte[size];
  buff.readBytes(bytes,0,size);
  decoderReactor.notify(DECODE_TOPIC,Event.wrap(bytes));
}",0.981348637015782
87065,"@Override public void shutdown(){
  gossipBossGroup.shutdownGracefully();
  gossipWorkerGroup.shutdownGracefully();
  dataBossGroup.shutdownGracefully();
  dataWorkerGroup.shutdownGracefully();
}","@Override public void shutdown(){
  if (gossipBossGroup != null) {
    gossipBossGroup.shutdownGracefully();
  }
  if (gossipWorkerGroup != null) {
    gossipWorkerGroup.shutdownGracefully();
  }
  if (dataBossGroup != null) {
    dataBossGroup.shutdownGracefully();
  }
  if (dataWorkerGroup != null) {
    dataWorkerGroup.shutdownGracefully();
  }
}",0.7106227106227107
87066,"@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  if (msg instanceof byte[]) {
    byte[] bytes=(byte[])msg;
    try {
      GossipMessage message=GossipDecoder.decode(bytes);
      reactor.notify(Event.wrap(message));
    }
 catch (    IOException ex) {
      LOG.error(""String_Node_Str"",ex);
    }
 finally {
      ReferenceCountUtil.release(msg);
    }
  }
 else {
    LOG.trace(msg.getClass().getName());
    ReferenceCountUtil.release(msg);
  }
}","@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  if (msg instanceof byte[]) {
    byte[] bytes=(byte[])msg;
    try {
      GossipMessage message=GossipDecoder.decode(bytes);
      reactor.notify(GOSSIP_TOPIC,Event.wrap(message));
    }
 catch (    IOException ex) {
      LOG.error(""String_Node_Str"",ex);
    }
 finally {
      ReferenceCountUtil.release(msg);
    }
  }
 else {
    LOG.trace(msg.getClass().getName());
    ReferenceCountUtil.release(msg);
  }
}",0.9865284974093264
87067,"@Override public void initChannel(DatagramChannel ch) throws Exception {
  ch.pipeline().addLast(""String_Node_Str"",new ByteArrayEncoder());
  ch.pipeline().addLast(""String_Node_Str"",new ByteArrayDecoder());
  ch.pipeline().addLast(new DataExceptionHandler());
  if (LOG.isTraceEnabled()) {
    ch.pipeline().addLast(new LoggingHandler(LogLevel.TRACE));
  }
}","@Override public void initChannel(DatagramChannel ch) throws Exception {
  ch.config().setAllocator(UnpooledByteBufAllocator.DEFAULT);
  ch.pipeline().addLast(""String_Node_Str"",new ByteArrayEncoder());
  ch.pipeline().addLast(""String_Node_Str"",new ByteArrayDecoder());
  ch.pipeline().addLast(new DataExceptionHandler());
  if (LOG.isTraceEnabled()) {
    ch.pipeline().addLast(new LoggingHandler(LogLevel.TRACE));
  }
}",0.9203084832904884
87068,"private void initializeGossipClient(){
  LOG.debug(""String_Node_Str"");
  gossipWorkerGroup=new NioEventLoopGroup(GOSSIP_WORKER_THREADS);
  Bootstrap b=new Bootstrap();
  b.group(gossipWorkerGroup);
  b.channel(NioSocketChannel.class);
  b.option(ChannelOption.SO_KEEPALIVE,true);
  b.option(ChannelOption.CONNECT_TIMEOUT_MILLIS,timeout);
  b.handler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel ch) throws Exception {
      ch.config().setAllocator(new PooledByteBufAllocator());
      ch.pipeline().addLast(""String_Node_Str"",new ByteArrayEncoder());
      ch.pipeline().addLast(""String_Node_Str"",new ByteArrayDecoder());
      ch.pipeline().addLast(new GossipExceptionHandler());
      if (LOG.isTraceEnabled()) {
        ch.pipeline().addLast(new LoggingHandler(LogLevel.TRACE));
      }
    }
    @Override public void exceptionCaught(    ChannelHandlerContext ctx,    Throwable cause) throws Exception {
      LOG.error(""String_Node_Str"",cause);
      ctx.close();
    }
  }
);
  ChannelFuture future=b.connect(getIp(),getGossipPort()).awaitUninterruptibly();
  if (future.isCancelled()) {
    gossipChannel=null;
  }
 else   if (!future.isSuccess()) {
    gossipChannel=null;
    retryGossipConnection();
  }
 else {
    gossipChannel=future.channel();
    setStatus(MemberStatus.Alive);
    updateMember();
  }
}","private void initializeGossipClient(){
  LOG.trace(""String_Node_Str"");
  gossipWorkerGroup=new NioEventLoopGroup(GOSSIP_WORKER_THREADS);
  Bootstrap b=new Bootstrap();
  b.group(gossipWorkerGroup);
  b.channel(NioSocketChannel.class);
  b.option(ChannelOption.SO_KEEPALIVE,true);
  b.option(ChannelOption.CONNECT_TIMEOUT_MILLIS,timeout);
  b.handler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel ch) throws Exception {
      ch.config().setAllocator(UnpooledByteBufAllocator.DEFAULT);
      ch.pipeline().addLast(""String_Node_Str"",new ByteArrayEncoder());
      ch.pipeline().addLast(""String_Node_Str"",new ByteArrayDecoder());
      ch.pipeline().addLast(new GossipExceptionHandler());
      if (LOG.isTraceEnabled()) {
        ch.pipeline().addLast(new LoggingHandler(LogLevel.TRACE));
      }
    }
    @Override public void exceptionCaught(    ChannelHandlerContext ctx,    Throwable cause) throws Exception {
      LOG.error(""String_Node_Str"",cause);
      ctx.close();
    }
  }
);
  ChannelFuture future=b.connect(getIp(),getGossipPort()).awaitUninterruptibly();
  if (future.isCancelled()) {
    gossipChannel=null;
  }
 else   if (!future.isSuccess()) {
    gossipChannel=null;
    retryGossipConnection();
  }
 else {
    gossipChannel=future.channel();
    setStatus(MemberStatus.Alive);
    updateMember();
  }
}",0.9897959183673468
87069,"@Override public void gossip(final GossipMessage message) throws IOException {
  byte[] bytes=GossipEncoder.encode(message);
  if (gossipChannel != null) {
    gossipChannel.writeAndFlush(bytes);
  }
}","@Override public void gossip(final GossipMessage message) throws IOException {
  byte[] bytes=GossipEncoder.encode(message);
  if (LOG.isTraceEnabled()) {
    gossipSizeStat.push(bytes.length);
  }
  if (gossipChannel != null) {
    gossipChannel.writeAndFlush(bytes);
  }
}",0.8463157894736842
87070,"@Override public void send(final Envelope message) throws IOException {
  byte[] bytes=EnvelopeEncoder.encode(message);
  if (dataChannel != null) {
    dataChannel.writeAndFlush(new DatagramPacket(Unpooled.wrappedBuffer(bytes),address));
  }
}","@Override public void send(final Envelope message) throws IOException {
  byte[] bytes=EnvelopeEncoder.encode(message);
  if (LOG.isTraceEnabled()) {
    dataSizeStat.push(bytes.length);
  }
  if (dataChannel != null) {
    dataChannel.writeAndFlush(new DatagramPacket(Unpooled.wrappedBuffer(bytes),address));
  }
}",0.8729874776386404
87071,"@Override public void shutdown(){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + getIp() + ""String_Node_Str""+ getGossipPort()+ ""String_Node_Str""+ getDataPort());
  }
  if (gossipWorkerGroup != null) {
    gossipWorkerGroup.shutdownGracefully();
  }
  if (dataWorkerGroup != null) {
    dataWorkerGroup.shutdownGracefully();
  }
}","@Override public void shutdown(){
  if (LOG.isTraceEnabled()) {
    LOG.trace(""String_Node_Str"" + getIp() + ""String_Node_Str""+ getGossipPort()+ ""String_Node_Str""+ getDataPort());
  }
  if (gossipWorkerGroup != null) {
    gossipWorkerGroup.shutdownGracefully();
  }
  if (dataWorkerGroup != null) {
    dataWorkerGroup.shutdownGracefully();
  }
  if (LOG.isTraceEnabled()) {
    LOG.trace(""String_Node_Str"" + gossipSizeStat.mean() + ""String_Node_Str""+ gossipSizeStat.numSamples()+ ""String_Node_Str"");
    LOG.trace(""String_Node_Str"" + dataSizeStat.mean() + ""String_Node_Str""+ dataSizeStat.numSamples()+ ""String_Node_Str"");
  }
}",0.6899383983572895
87072,"private void initializeDataClient(){
  LOG.debug(""String_Node_Str"");
  dataWorkerGroup=new NioEventLoopGroup(DATA_WORKER_THREADS);
  Bootstrap b=new Bootstrap();
  b.group(dataWorkerGroup).channelFactory(new ChannelFactory<Channel>(){
    @Override public Channel newChannel(){
      return new NioDatagramChannel(InternetProtocolFamily.IPv4);
    }
    @Override public String toString(){
      return NioDatagramChannel.class.getSimpleName() + ""String_Node_Str"";
    }
  }
).handler(new ChannelInitializer<DatagramChannel>(){
    @Override public void initChannel(    DatagramChannel ch) throws Exception {
      ch.pipeline().addLast(""String_Node_Str"",new ByteArrayEncoder());
      ch.pipeline().addLast(""String_Node_Str"",new ByteArrayDecoder());
      ch.pipeline().addLast(new DataExceptionHandler());
      if (LOG.isTraceEnabled()) {
        ch.pipeline().addLast(new LoggingHandler(LogLevel.TRACE));
      }
    }
    @Override public void exceptionCaught(    ChannelHandlerContext ctx,    Throwable cause) throws Exception {
      LOG.error(""String_Node_Str"",cause);
      ctx.close();
    }
  }
);
  ChannelFuture future=b.connect(getIp(),getDataPort()).awaitUninterruptibly();
  if (future.isCancelled()) {
    dataChannel=null;
  }
 else   if (!future.isSuccess()) {
    dataChannel=null;
    retryDataConnection();
  }
 else {
    dataChannel=(DatagramChannel)future.channel();
    try {
      dataChannel.closeFuture().sync();
    }
 catch (    InterruptedException ex) {
      LOG.warn(""String_Node_Str"",ex);
    }
  }
}","private void initializeDataClient(){
  LOG.trace(""String_Node_Str"");
  dataWorkerGroup=new NioEventLoopGroup(DATA_WORKER_THREADS);
  Bootstrap b=new Bootstrap();
  b.group(dataWorkerGroup).channelFactory(new ChannelFactory<Channel>(){
    @Override public Channel newChannel(){
      return new NioDatagramChannel(InternetProtocolFamily.IPv4);
    }
    @Override public String toString(){
      return NioDatagramChannel.class.getSimpleName() + ""String_Node_Str"";
    }
  }
).handler(new ChannelInitializer<DatagramChannel>(){
    @Override public void initChannel(    DatagramChannel ch) throws Exception {
      ch.config().setAllocator(UnpooledByteBufAllocator.DEFAULT);
      ch.pipeline().addLast(""String_Node_Str"",new ByteArrayEncoder());
      ch.pipeline().addLast(""String_Node_Str"",new ByteArrayDecoder());
      ch.pipeline().addLast(new DataExceptionHandler());
      if (LOG.isTraceEnabled()) {
        ch.pipeline().addLast(new LoggingHandler(LogLevel.TRACE));
      }
    }
    @Override public void exceptionCaught(    ChannelHandlerContext ctx,    Throwable cause) throws Exception {
      LOG.error(""String_Node_Str"",cause);
      ctx.close();
    }
  }
);
  ChannelFuture future=b.connect(getIp(),getDataPort()).awaitUninterruptibly();
  if (future.isCancelled()) {
    dataChannel=null;
  }
 else   if (!future.isSuccess()) {
    dataChannel=null;
    retryDataConnection();
  }
 else {
    dataChannel=(DatagramChannel)future.channel();
    try {
      dataChannel.closeFuture().sync();
    }
 catch (    InterruptedException ex) {
      LOG.warn(""String_Node_Str"",ex);
    }
  }
}",0.975780752071383
87073,"/** 
 * Get the set of relations containing the specified key.
 * @param key a key.
 * @param index the index of the key.
 * @return the collection of keys containing the specified key.
 */
private List<R> get(Object key,int index){
  if (distinct && !(key instanceof Range)) {
    index=classes.indexOf(key.getClass());
  }
  Class sup=key.getClass().getSuperclass();
  while (index == -1 && sup != null) {
    index=classes.indexOf(sup);
    sup=sup.getSuperclass();
  }
  if (key instanceof Range && index == -1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (index < 0 || mapping.get(index) == null) {
    return Collections.emptyList();
  }
  if (mapping.get(index).get(key) == null && !(key instanceof Range)) {
    return Collections.emptyList();
  }
  if (key instanceof Range) {
    Range range=(Range)key;
    ArrayList ret=new ArrayList();
    for (    Object number : mapping.get(index).keySet()) {
      if (number instanceof Number) {
        if (range.contains((Number)number)) {
          ret.addAll(mapping.get(index).get(number));
        }
      }
    }
    return ret;
  }
 else {
    return new ArrayList(mapping.get(index).get(key));
  }
}","/** 
 * Get the set of relations containing the specified key.
 * @param key a key.
 * @param index the index of the key.
 * @return the collection of keys containing the specified key.
 */
private List<R> get(Object key,int index){
  if (distinct && !(key instanceof Range)) {
    index=classes.indexOf(key.getClass());
  }
  Class sup=key.getClass().getSuperclass();
  while (index == -1 && sup != null) {
    index=classes.indexOf(sup);
    sup=sup.getSuperclass();
  }
  if (key instanceof Range && index == -1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (index < 0 || mapping.get(index) == null) {
    return Collections.emptyList();
  }
  if (mapping.get(index).get(key) == null && !(key instanceof Range)) {
    return Collections.emptyList();
  }
  if (key instanceof Range) {
    Range range=(Range)key;
    List ret=Collections.synchronizedList(new ArrayList());
    for (    Object number : mapping.get(index).keySet()) {
      if (number instanceof Number) {
        if (range.contains((Number)number)) {
          ret.addAll(mapping.get(index).get(number));
        }
      }
    }
    return ret;
  }
 else {
    return Collections.synchronizedList(new ArrayList(mapping.get(index).get(key)));
  }
}",0.9616494845360825
87074,"@Override public void visitEnd(){
  if (!clinitFound) {
    MethodVisitor mv=cv.visitMethod(ACC_STATIC,""String_Node_Str"",""String_Node_Str"",null,null);
    mv.visitCode();
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitFieldInsn(PUTSTATIC,currentClass,""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(RETURN);
    mv.visitMaxs(2,0);
    mv.visitEnd();
  }
  if (isMessage) {
    MethodVisitor mv=cv.visitMethod(ACC_PUBLIC,""String_Node_Str"",""String_Node_Str"",null,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    mv.visitCode();
    mv.visitInsn(ACONST_NULL);
    mv.visitVarInsn(ASTORE,3);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitFieldInsn(GETSTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    Label l0=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l0);
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,4);
    mv.visitInsn(ICONST_0);
    mv.visitVarInsn(ISTORE,5);
    Label l1=new Label();
    mv.visitLabel(l1);
    mv.visitFrame(Opcodes.F_APPEND,3,new Object[]{""String_Node_Str"",""String_Node_Str"",Opcodes.INTEGER},0,null);
    mv.visitVarInsn(ILOAD,5);
    mv.visitVarInsn(ALOAD,4);
    mv.visitInsn(ARRAYLENGTH);
    Label l2=new Label();
    mv.visitJumpInsn(IF_ICMPGE,l2);
    mv.visitVarInsn(ALOAD,3);
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ALOAD,0);
    mv.visitVarInsn(ALOAD,4);
    mv.visitVarInsn(ILOAD,5);
    mv.visitInsn(AALOAD);
    mv.visitVarInsn(ALOAD,2);
    mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitIincInsn(5,1);
    mv.visitJumpInsn(GOTO,l1);
    mv.visitLabel(l2);
    mv.visitFrame(Opcodes.F_CHOP,2,null,0,null);
    Label l3=new Label();
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l0);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitFieldInsn(GETSTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    Label l4=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l4);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l4);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitFieldInsn(GETSTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    Label l5=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l5);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    Label l6=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l6);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l6);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    mv.visitJumpInsn(IF_ACMPNE,l3);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l5);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitFieldInsn(GETSTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    Label l7=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l7);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    Label l8=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l8);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l8);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    Label l9=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l9);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l9);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    Label l10=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l10);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l10);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    mv.visitJumpInsn(IF_ACMPNE,l3);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l7);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitFieldInsn(GETSTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    Label l11=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l11);
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,4);
    mv.visitVarInsn(ALOAD,4);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,5);
    Label l12=new Label();
    mv.visitLabel(l12);
    mv.visitFrame(Opcodes.F_APPEND,2,new Object[]{""String_Node_Str"",""String_Node_Str""},0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    Label l13=new Label();
    mv.visitJumpInsn(IFEQ,l13);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ASTORE,6);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ASTORE,7);
    mv.visitVarInsn(ALOAD,3);
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ALOAD,0);
    mv.visitVarInsn(ALOAD,6);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ALOAD,0);
    mv.visitVarInsn(ALOAD,7);
    mv.visitVarInsn(ALOAD,2);
    mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l12);
    mv.visitLabel(l13);
    mv.visitFrame(Opcodes.F_CHOP,2,null,0,null);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l11);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitFieldInsn(GETSTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    Label l14=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l14);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    Label l15=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l15);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l15);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,2);
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(""String_Node_Str"");
    mv.visitInsn(ICONST_1);
    mv.visitTypeInsn(ANEWARRAY,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitInsn(ICONST_0);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    mv.visitInsn(AASTORE);
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ALOAD,3);
    mv.visitInsn(ICONST_1);
    mv.visitTypeInsn(ANEWARRAY,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitInsn(ICONST_0);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(AASTORE);
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l14);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitLdcInsn(""String_Node_Str"");
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(ATHROW);
    mv.visitLabel(l3);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,3);
    mv.visitInsn(ARETURN);
    mv.visitMaxs(6,8);
    mv.visitEnd();
    mv=cv.visitMethod(ACC_PRIVATE,""String_Node_Str"",""String_Node_Str"",null,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    mv.visitCode();
    mv.visitVarInsn(ALOAD,2);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,4);
    l0=new Label();
    mv.visitLabel(l0);
    mv.visitFrame(Opcodes.F_APPEND,1,new Object[]{""String_Node_Str""},0,null);
    mv.visitVarInsn(ALOAD,4);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    l1=new Label();
    mv.visitJumpInsn(IFEQ,l1);
    mv.visitVarInsn(ALOAD,4);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,5);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l2=new Label();
    mv.visitJumpInsn(IFEQ,l2);
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,6);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitVarInsn(ALOAD,0);
    mv.visitVarInsn(ALOAD,6);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ALOAD,3);
    mv.visitMethodInsn(INVOKESPECIAL,currentClass,""String_Node_Str"",""String_Node_Str"");
    l3=new Label();
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l2);
    mv.visitFrame(Opcodes.F_APPEND,1,new Object[]{""String_Node_Str""},0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l4=new Label();
    mv.visitJumpInsn(IFEQ,l4);
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,6);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitVarInsn(ALOAD,0);
    mv.visitVarInsn(ALOAD,6);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ALOAD,3);
    mv.visitMethodInsn(INVOKESPECIAL,currentClass,""String_Node_Str"",""String_Node_Str"");
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l4);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l5=new Label();
    mv.visitJumpInsn(IFEQ,l5);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l5);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l6=new Label();
    mv.visitJumpInsn(IFEQ,l6);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l6);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l7=new Label();
    mv.visitJumpInsn(IFEQ,l7);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l7);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l8=new Label();
    mv.visitJumpInsn(IFEQ,l8);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l8);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l9=new Label();
    mv.visitJumpInsn(IFEQ,l9);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l9);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l10=new Label();
    mv.visitJumpInsn(IFEQ,l10);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l10);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l11=new Label();
    mv.visitJumpInsn(IFEQ,l11);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l11);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l12=new Label();
    mv.visitJumpInsn(IFEQ,l12);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l12);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,3);
    mv.visitLdcInsn(""String_Node_Str"");
    mv.visitInsn(ICONST_0);
    mv.visitTypeInsn(ANEWARRAY,""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ALOAD,5);
    mv.visitInsn(ICONST_0);
    mv.visitTypeInsn(ANEWARRAY,""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitLabel(l3);
    mv.visitFrame(Opcodes.F_CHOP,1,null,0,null);
    mv.visitJumpInsn(GOTO,l0);
    mv.visitLabel(l1);
    mv.visitFrame(Opcodes.F_CHOP,1,null,0,null);
    mv.visitInsn(RETURN);
    mv.visitMaxs(4,7);
    mv.visitEnd();
    mv=cv.visitMethod(ACC_PRIVATE,""String_Node_Str"",""String_Node_Str"",null,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    mv.visitCode();
    mv.visitVarInsn(ALOAD,2);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,4);
    l0=new Label();
    mv.visitLabel(l0);
    mv.visitFrame(Opcodes.F_APPEND,1,new Object[]{""String_Node_Str""},0,null);
    mv.visitVarInsn(ALOAD,4);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    l1=new Label();
    mv.visitJumpInsn(IFEQ,l1);
    mv.visitVarInsn(ALOAD,4);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,5);
    mv.visitVarInsn(ALOAD,2);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,6);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l2=new Label();
    mv.visitJumpInsn(IFEQ,l2);
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,7);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,7);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitVarInsn(ALOAD,0);
    mv.visitVarInsn(ALOAD,7);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ALOAD,3);
    mv.visitMethodInsn(INVOKESPECIAL,currentClass,""String_Node_Str"",""String_Node_Str"");
    l3=new Label();
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l2);
    mv.visitFrame(Opcodes.F_APPEND,2,new Object[]{""String_Node_Str"",""String_Node_Str""},0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l4=new Label();
    mv.visitJumpInsn(IFEQ,l4);
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,7);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,7);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitVarInsn(ALOAD,0);
    mv.visitVarInsn(ALOAD,7);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ALOAD,3);
    mv.visitMethodInsn(INVOKESPECIAL,currentClass,""String_Node_Str"",""String_Node_Str"");
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l4);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l5=new Label();
    mv.visitJumpInsn(IFEQ,l5);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l5);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l6=new Label();
    mv.visitJumpInsn(IFEQ,l6);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l6);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l7=new Label();
    mv.visitJumpInsn(IFEQ,l7);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l7);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l8=new Label();
    mv.visitJumpInsn(IFEQ,l8);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l8);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l9=new Label();
    mv.visitJumpInsn(IFEQ,l9);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l9);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l10=new Label();
    mv.visitJumpInsn(IFEQ,l10);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l10);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l11=new Label();
    mv.visitJumpInsn(IFEQ,l11);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l11);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l12=new Label();
    mv.visitJumpInsn(IFEQ,l12);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l12);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,3);
    mv.visitLdcInsn(""String_Node_Str"");
    mv.visitInsn(ICONST_0);
    mv.visitTypeInsn(ANEWARRAY,""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ALOAD,6);
    mv.visitInsn(ICONST_0);
    mv.visitTypeInsn(ANEWARRAY,""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitLabel(l3);
    mv.visitFrame(Opcodes.F_CHOP,2,null,0,null);
    mv.visitJumpInsn(GOTO,l0);
    mv.visitLabel(l1);
    mv.visitFrame(Opcodes.F_CHOP,1,null,0,null);
    mv.visitInsn(RETURN);
    mv.visitMaxs(5,8);
    mv.visitEnd();
    mv=cv.visitMethod(ACC_PUBLIC,""String_Node_Str"",""String_Node_Str"",null,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    mv.visitCode();
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,1);
    mv.visitFieldInsn(GETSTATIC,currentClass,""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,2);
    for (    Tuple tuple : fields) {
      String sig;
switch (tuple.getType()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
        mv.visitVarInsn(ALOAD,2);
      mv.visitVarInsn(ALOAD,0);
    mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
  mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType() + ""String_Node_Str"");
mv.visitInsn(POP);
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,2);
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,2);
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
case ""String_Node_Str"":
sig=getType(tuple.getSignature());
switch (sig) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,2);
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
default :
mv.visitTypeInsn(NEW,""String_Node_Str"");
mv.visitInsn(DUP);
mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitVarInsn(ASTORE,4);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,4);
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitLdcInsn(Type.getType(sig));
mv.visitMethodInsn(INVOKESPECIAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitVarInsn(ALOAD,2);
mv.visitVarInsn(ALOAD,4);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
}
break;
case ""String_Node_Str"":
sig=getType(tuple.getSignature());
switch (sig) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,2);
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
default :
mv.visitTypeInsn(NEW,""String_Node_Str"");
mv.visitInsn(DUP);
mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitVarInsn(ASTORE,6);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,6);
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitLdcInsn(Type.getType(sig));
mv.visitMethodInsn(INVOKESPECIAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitVarInsn(ALOAD,2);
mv.visitVarInsn(ALOAD,6);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
}
break;
default :
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitMethodInsn(INVOKEVIRTUAL,tuple.getType(),""String_Node_Str"",""String_Node_Str"");
mv.visitVarInsn(ASTORE,3);
mv.visitVarInsn(ALOAD,2);
mv.visitVarInsn(ALOAD,3);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
}
}
mv.visitVarInsn(ALOAD,1);
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(ARETURN);
mv.visitMaxs(4,8);
mv.visitEnd();
mv=cv.visitMethod(ACC_PUBLIC,""String_Node_Str"",""String_Node_Str"",null,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
mv.visitCode();
mv.visitFieldInsn(GETSTATIC,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitVarInsn(ALOAD,1);
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitVarInsn(ASTORE,2);
for (Tuple tuple : fields) {
String sig;
switch (tuple.getType()) {
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitLdcInsn(Type.getType(tuple.getType()));
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
sig=getType(tuple.getSignature());
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(sig));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
case ""String_Node_Str"":
sig=getType(tuple.getSignature());
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(sig));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
break;
default :
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(tuple.getType()));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,tuple.getType().substring(1,tuple.getType().length() - 1));
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
}
}
mv.visitInsn(RETURN);
mv.visitMaxs(4,3);
mv.visitEnd();
}
cv.visitEnd();
}","@Override public void visitEnd(){
  if (isMessage && !clinitFound) {
    if (!msgPackDefined) {
      FieldVisitor fv=cv.visitField(ACC_PRIVATE + ACC_FINAL + ACC_STATIC,""String_Node_Str"",""String_Node_Str"",null,null);
      fv.visitEnd();
      msgPackDefined=true;
    }
    MethodVisitor mv=cv.visitMethod(ACC_STATIC,""String_Node_Str"",""String_Node_Str"",null,null);
    mv.visitCode();
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitFieldInsn(PUTSTATIC,currentClass,""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(RETURN);
    mv.visitMaxs(2,0);
    mv.visitEnd();
  }
  if (isMessage) {
    MethodVisitor mv=cv.visitMethod(ACC_PUBLIC,""String_Node_Str"",""String_Node_Str"",null,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    mv.visitCode();
    mv.visitInsn(ACONST_NULL);
    mv.visitVarInsn(ASTORE,3);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitFieldInsn(GETSTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    Label l0=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l0);
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,4);
    mv.visitInsn(ICONST_0);
    mv.visitVarInsn(ISTORE,5);
    Label l1=new Label();
    mv.visitLabel(l1);
    mv.visitFrame(Opcodes.F_APPEND,3,new Object[]{""String_Node_Str"",""String_Node_Str"",Opcodes.INTEGER},0,null);
    mv.visitVarInsn(ILOAD,5);
    mv.visitVarInsn(ALOAD,4);
    mv.visitInsn(ARRAYLENGTH);
    Label l2=new Label();
    mv.visitJumpInsn(IF_ICMPGE,l2);
    mv.visitVarInsn(ALOAD,3);
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ALOAD,0);
    mv.visitVarInsn(ALOAD,4);
    mv.visitVarInsn(ILOAD,5);
    mv.visitInsn(AALOAD);
    mv.visitVarInsn(ALOAD,2);
    mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitIincInsn(5,1);
    mv.visitJumpInsn(GOTO,l1);
    mv.visitLabel(l2);
    mv.visitFrame(Opcodes.F_CHOP,2,null,0,null);
    Label l3=new Label();
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l0);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitFieldInsn(GETSTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    Label l4=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l4);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l4);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitFieldInsn(GETSTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    Label l5=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l5);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    Label l6=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l6);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l6);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    mv.visitJumpInsn(IF_ACMPNE,l3);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l5);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitFieldInsn(GETSTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    Label l7=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l7);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    Label l8=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l8);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l8);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    Label l9=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l9);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l9);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    Label l10=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l10);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l10);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    mv.visitJumpInsn(IF_ACMPNE,l3);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l7);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitFieldInsn(GETSTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    Label l11=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l11);
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,4);
    mv.visitVarInsn(ALOAD,4);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,5);
    Label l12=new Label();
    mv.visitLabel(l12);
    mv.visitFrame(Opcodes.F_APPEND,2,new Object[]{""String_Node_Str"",""String_Node_Str""},0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    Label l13=new Label();
    mv.visitJumpInsn(IFEQ,l13);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ASTORE,6);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ASTORE,7);
    mv.visitVarInsn(ALOAD,3);
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ALOAD,0);
    mv.visitVarInsn(ALOAD,6);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ALOAD,0);
    mv.visitVarInsn(ALOAD,7);
    mv.visitVarInsn(ALOAD,2);
    mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l12);
    mv.visitLabel(l13);
    mv.visitFrame(Opcodes.F_CHOP,2,null,0,null);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l11);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitFieldInsn(GETSTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    Label l14=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l14);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    Label l15=new Label();
    mv.visitJumpInsn(IF_ACMPNE,l15);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l15);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,2);
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,3);
    mv.visitVarInsn(ALOAD,2);
    mv.visitLdcInsn(""String_Node_Str"");
    mv.visitInsn(ICONST_1);
    mv.visitTypeInsn(ANEWARRAY,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitInsn(ICONST_0);
    mv.visitLdcInsn(Type.getType(""String_Node_Str""));
    mv.visitInsn(AASTORE);
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ALOAD,3);
    mv.visitInsn(ICONST_1);
    mv.visitTypeInsn(ANEWARRAY,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitInsn(ICONST_0);
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(AASTORE);
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l14);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitLdcInsn(""String_Node_Str"");
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(ATHROW);
    mv.visitLabel(l3);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,3);
    mv.visitInsn(ARETURN);
    mv.visitMaxs(6,8);
    mv.visitEnd();
    mv=cv.visitMethod(ACC_PRIVATE,""String_Node_Str"",""String_Node_Str"",null,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    mv.visitCode();
    mv.visitVarInsn(ALOAD,2);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,4);
    l0=new Label();
    mv.visitLabel(l0);
    mv.visitFrame(Opcodes.F_APPEND,1,new Object[]{""String_Node_Str""},0,null);
    mv.visitVarInsn(ALOAD,4);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    l1=new Label();
    mv.visitJumpInsn(IFEQ,l1);
    mv.visitVarInsn(ALOAD,4);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,5);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l2=new Label();
    mv.visitJumpInsn(IFEQ,l2);
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,6);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitVarInsn(ALOAD,0);
    mv.visitVarInsn(ALOAD,6);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ALOAD,3);
    mv.visitMethodInsn(INVOKESPECIAL,currentClass,""String_Node_Str"",""String_Node_Str"");
    l3=new Label();
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l2);
    mv.visitFrame(Opcodes.F_APPEND,1,new Object[]{""String_Node_Str""},0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l4=new Label();
    mv.visitJumpInsn(IFEQ,l4);
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,6);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitVarInsn(ALOAD,0);
    mv.visitVarInsn(ALOAD,6);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ALOAD,3);
    mv.visitMethodInsn(INVOKESPECIAL,currentClass,""String_Node_Str"",""String_Node_Str"");
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l4);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l5=new Label();
    mv.visitJumpInsn(IFEQ,l5);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l5);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l6=new Label();
    mv.visitJumpInsn(IFEQ,l6);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l6);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l7=new Label();
    mv.visitJumpInsn(IFEQ,l7);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l7);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l8=new Label();
    mv.visitJumpInsn(IFEQ,l8);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l8);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l9=new Label();
    mv.visitJumpInsn(IFEQ,l9);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l9);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l10=new Label();
    mv.visitJumpInsn(IFEQ,l10);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l10);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l11=new Label();
    mv.visitJumpInsn(IFEQ,l11);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l11);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,5);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l12=new Label();
    mv.visitJumpInsn(IFEQ,l12);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l12);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,3);
    mv.visitLdcInsn(""String_Node_Str"");
    mv.visitInsn(ICONST_0);
    mv.visitTypeInsn(ANEWARRAY,""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ALOAD,5);
    mv.visitInsn(ICONST_0);
    mv.visitTypeInsn(ANEWARRAY,""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitLabel(l3);
    mv.visitFrame(Opcodes.F_CHOP,1,null,0,null);
    mv.visitJumpInsn(GOTO,l0);
    mv.visitLabel(l1);
    mv.visitFrame(Opcodes.F_CHOP,1,null,0,null);
    mv.visitInsn(RETURN);
    mv.visitMaxs(4,7);
    mv.visitEnd();
    mv=cv.visitMethod(ACC_PRIVATE,""String_Node_Str"",""String_Node_Str"",null,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    mv.visitCode();
    mv.visitVarInsn(ALOAD,2);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,4);
    l0=new Label();
    mv.visitLabel(l0);
    mv.visitFrame(Opcodes.F_APPEND,1,new Object[]{""String_Node_Str""},0,null);
    mv.visitVarInsn(ALOAD,4);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    l1=new Label();
    mv.visitJumpInsn(IFEQ,l1);
    mv.visitVarInsn(ALOAD,4);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,5);
    mv.visitVarInsn(ALOAD,2);
    mv.visitVarInsn(ALOAD,5);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,6);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l2=new Label();
    mv.visitJumpInsn(IFEQ,l2);
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,7);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,7);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitVarInsn(ALOAD,0);
    mv.visitVarInsn(ALOAD,7);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ALOAD,3);
    mv.visitMethodInsn(INVOKESPECIAL,currentClass,""String_Node_Str"",""String_Node_Str"");
    l3=new Label();
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l2);
    mv.visitFrame(Opcodes.F_APPEND,2,new Object[]{""String_Node_Str"",""String_Node_Str""},0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l4=new Label();
    mv.visitJumpInsn(IFEQ,l4);
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,7);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,7);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitVarInsn(ALOAD,0);
    mv.visitVarInsn(ALOAD,7);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitVarInsn(ALOAD,3);
    mv.visitMethodInsn(INVOKESPECIAL,currentClass,""String_Node_Str"",""String_Node_Str"");
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l4);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l5=new Label();
    mv.visitJumpInsn(IFEQ,l5);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l5);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l6=new Label();
    mv.visitJumpInsn(IFEQ,l6);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l6);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l7=new Label();
    mv.visitJumpInsn(IFEQ,l7);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l7);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l8=new Label();
    mv.visitJumpInsn(IFEQ,l8);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l8);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l9=new Label();
    mv.visitJumpInsn(IFEQ,l9);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l9);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l10=new Label();
    mv.visitJumpInsn(IFEQ,l10);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l10);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l11=new Label();
    mv.visitJumpInsn(IFEQ,l11);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l11);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,6);
    mv.visitTypeInsn(INSTANCEOF,""String_Node_Str"");
    l12=new Label();
    mv.visitJumpInsn(IFEQ,l12);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,6);
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitJumpInsn(GOTO,l3);
    mv.visitLabel(l12);
    mv.visitFrame(Opcodes.F_SAME,0,null,0,null);
    mv.visitVarInsn(ALOAD,1);
    mv.visitVarInsn(ALOAD,5);
    mv.visitVarInsn(ALOAD,3);
    mv.visitLdcInsn(""String_Node_Str"");
    mv.visitInsn(ICONST_0);
    mv.visitTypeInsn(ANEWARRAY,""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ALOAD,6);
    mv.visitInsn(ICONST_0);
    mv.visitTypeInsn(ANEWARRAY,""String_Node_Str"");
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
    mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitInsn(POP);
    mv.visitLabel(l3);
    mv.visitFrame(Opcodes.F_CHOP,2,null,0,null);
    mv.visitJumpInsn(GOTO,l0);
    mv.visitLabel(l1);
    mv.visitFrame(Opcodes.F_CHOP,1,null,0,null);
    mv.visitInsn(RETURN);
    mv.visitMaxs(5,8);
    mv.visitEnd();
    mv=cv.visitMethod(ACC_PUBLIC,""String_Node_Str"",""String_Node_Str"",null,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    mv.visitCode();
    mv.visitTypeInsn(NEW,""String_Node_Str"");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,1);
    mv.visitFieldInsn(GETSTATIC,currentClass,""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ALOAD,1);
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    mv.visitVarInsn(ASTORE,2);
    for (    Tuple tuple : fields) {
      String sig;
switch (tuple.getType()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
        mv.visitVarInsn(ALOAD,2);
      mv.visitVarInsn(ALOAD,0);
    mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
  mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType() + ""String_Node_Str"");
mv.visitInsn(POP);
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,2);
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,2);
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
case ""String_Node_Str"":
sig=getType(tuple.getSignature());
switch (sig) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,2);
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
default :
mv.visitTypeInsn(NEW,""String_Node_Str"");
mv.visitInsn(DUP);
mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitVarInsn(ASTORE,4);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,4);
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitLdcInsn(Type.getType(sig));
mv.visitMethodInsn(INVOKESPECIAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitVarInsn(ALOAD,2);
mv.visitVarInsn(ALOAD,4);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
}
break;
case ""String_Node_Str"":
sig=getType(tuple.getSignature());
switch (sig) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,2);
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
default :
mv.visitTypeInsn(NEW,""String_Node_Str"");
mv.visitInsn(DUP);
mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitVarInsn(ASTORE,6);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,6);
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitLdcInsn(Type.getType(sig));
mv.visitMethodInsn(INVOKESPECIAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitVarInsn(ALOAD,2);
mv.visitVarInsn(ALOAD,6);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
}
break;
default :
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitMethodInsn(INVOKEVIRTUAL,tuple.getType(),""String_Node_Str"",""String_Node_Str"");
mv.visitVarInsn(ASTORE,3);
mv.visitVarInsn(ALOAD,2);
mv.visitVarInsn(ALOAD,3);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
}
}
mv.visitVarInsn(ALOAD,1);
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(ARETURN);
mv.visitMaxs(4,8);
mv.visitEnd();
mv=cv.visitMethod(ACC_PUBLIC,""String_Node_Str"",""String_Node_Str"",null,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
mv.visitCode();
mv.visitFieldInsn(GETSTATIC,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitVarInsn(ALOAD,1);
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitVarInsn(ASTORE,2);
for (Tuple tuple : fields) {
String sig;
switch (tuple.getType()) {
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(""String_Node_Str""));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitLdcInsn(Type.getType(tuple.getType()));
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,tuple.getType());
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
case ""String_Node_Str"":
sig=getType(tuple.getSignature());
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(sig));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitInsn(POP);
break;
case ""String_Node_Str"":
sig=getType(tuple.getSignature());
mv.visitVarInsn(ALOAD,0);
mv.visitFieldInsn(GETFIELD,currentClass,tuple.getName(),tuple.getType());
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(sig));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,""String_Node_Str"");
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
break;
default :
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,0);
mv.visitVarInsn(ALOAD,2);
mv.visitMethodInsn(INVOKEINTERFACE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
mv.visitLdcInsn(Type.getType(tuple.getType()));
mv.visitMethodInsn(INVOKEVIRTUAL,currentClass,""String_Node_Str"",""String_Node_Str"");
mv.visitTypeInsn(CHECKCAST,tuple.getType().substring(1,tuple.getType().length() - 1));
mv.visitFieldInsn(PUTFIELD,currentClass,tuple.getName(),tuple.getType());
break;
}
}
mv.visitInsn(RETURN);
mv.visitMaxs(4,3);
mv.visitEnd();
}
cv.visitEnd();
}",0.9972044884213812
87075,"@Override public void visit(int version,int access,String name,String signature,String superName,String[] interfaces){
  currentClass=name;
  isMessage=false;
  msgPackDefined=false;
  if (superName.equals(""String_Node_Str"")) {
    if (!name.startsWith(""String_Node_Str"") && !name.startsWith(""String_Node_Str"") && !name.startsWith(""String_Node_Str"")&& !name.startsWith(""String_Node_Str"")) {
      isEnum=true;
    }
  }
  cv.visit(version,access,name,signature,superName,interfaces);
}","@Override public void visit(int version,int access,String name,String signature,String superName,String[] interfaces){
  currentClass=name;
  isMessage=false;
  msgPackDefined=false;
  if (superName.equals(""String_Node_Str"")) {
    if (!name.startsWith(""String_Node_Str"") && !name.startsWith(""String_Node_Str"") && !name.startsWith(""String_Node_Str"")&& !name.startsWith(""String_Node_Str"")&& !name.startsWith(""String_Node_Str"")) {
      isEnum=true;
    }
  }
  cv.visit(version,access,name,signature,superName,interfaces);
}",0.9623015873015872
87076,"public static void main(String[] args) throws Exception {
  ConfigurableApplicationContext context=SpringApplication.run(Starter.class,args);
}","public static void main(String[] args) throws Exception {
  Parameters.INSTANCE.currentOS();
  ConfigurableApplicationContext context=SpringApplication.run(Starter.class,args);
}",0.8909657320872274
87077,"public PyxlLexerAdapter(){
  super(new PyxlLexer());
}","public PyxlLexerAdapter(){
  super(new PyxlLexer((Reader)null));
}",0.9
87078,"/** 
 * Parse a pyxl tag.
 */
private void parsePyxlTag(){
  final PsiBuilder.Marker pyxl=myBuilder.mark();
  myBuilder.advanceLexer();
  IElementType token=myBuilder.getTokenType();
  if (!parsePyxlTagName()) {
    myBuilder.error(""String_Node_Str"");
    pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
    return;
  }
  parsePyxlAttributes();
  token=myBuilder.getTokenType();
  if (token == PyxlTokenTypes.TAGENDANDCLOSE) {
    myBuilder.advanceLexer();
  }
 else   if (token == PyxlTokenTypes.TAGEND) {
    myBuilder.advanceLexer();
    while ((token=myBuilder.getTokenType()) != PyxlTokenTypes.TAGCLOSE) {
      try {
        if (parsePyxlEmbed()) {
          continue;
        }
      }
 catch (      PyxlParsingException e) {
        pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
        return;
      }
      if (token == PyxlTokenTypes.TAGBEGIN) {
        parsePyxlTag();
      }
 else       if (token == PyxlTokenTypes.STRING) {
        myBuilder.advanceLexer();
      }
 else {
        myBuilder.error(""String_Node_Str"" + token.toString());
        pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
        return;
      }
    }
    myBuilder.advanceLexer();
    if (!parsePyxlTagName()) {
      myBuilder.error(""String_Node_Str"");
      pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
      return;
    }
    if (myBuilder.getTokenType() == PyxlTokenTypes.TAGEND) {
      myBuilder.advanceLexer();
    }
 else {
      myBuilder.error(""String_Node_Str"");
    }
  }
  pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
}","/** 
 * Parse a pyxl tag.
 */
private void parsePyxlTag(){
  final PsiBuilder.Marker pyxl=myBuilder.mark();
  myBuilder.advanceLexer();
  IElementType token=myBuilder.getTokenType();
  if (!parsePyxlTagName()) {
    myBuilder.error(""String_Node_Str"");
    pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
    return;
  }
  parsePyxlAttributes();
  token=myBuilder.getTokenType();
  if (token == PyxlTokenTypes.TAGENDANDCLOSE) {
    myBuilder.advanceLexer();
  }
 else   if (token == PyxlTokenTypes.TAGEND) {
    myBuilder.advanceLexer();
    while ((token=myBuilder.getTokenType()) != PyxlTokenTypes.TAGCLOSE) {
      try {
        if (parsePyxlEmbed()) {
          continue;
        }
      }
 catch (      PyxlParsingException e) {
        pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
        return;
      }
      if (token == PyxlTokenTypes.TAGBEGIN) {
        parsePyxlTag();
      }
 else       if (token == PyxlTokenTypes.STRING) {
        myBuilder.advanceLexer();
      }
 else {
        myBuilder.error(String.format(""String_Node_Str"",token));
        pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
        return;
      }
    }
    myBuilder.advanceLexer();
    if (!parsePyxlTagName()) {
      myBuilder.error(""String_Node_Str"");
      pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
      return;
    }
    if (myBuilder.getTokenType() == PyxlTokenTypes.TAGEND) {
      myBuilder.advanceLexer();
    }
 else {
      myBuilder.error(""String_Node_Str"");
    }
  }
  pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
}",0.9874005305039788
87079,"@NonNull public String getTagName(){
  return String.format(""String_Node_Str"",text);
}","@NotNull public String getTagName(){
  return String.format(""String_Node_Str"",text);
}",0.9883720930232558
87080,"/** 
 * Parse as many attribute=""value"" pairs as possible.
 */
private void parsePyxlAttributes(){
  if (myBuilder.getTokenType() == PyxlTokenTypes.ATTRNAME) {
    final PsiBuilder.Marker attr=myBuilder.mark();
    myBuilder.advanceLexer();
    if (myBuilder.getTokenType() == PyTokenTypes.EQ) {
      myBuilder.advanceLexer();
      if (parsePyxlEmbed()) {
        attr.done(PyElementTypes.KEYWORD_ARGUMENT_EXPRESSION);
        parsePyxlAttributes();
        return;
      }
    }
    myBuilder.error(""String_Node_Str"");
    attr.done(PyElementTypes.KEYWORD_ARGUMENT_EXPRESSION);
  }
}","/** 
 * Parse as many attribute=""value"" pairs as possible.
 */
private void parsePyxlAttributes(){
  if (myBuilder.getTokenType() == PyxlTokenTypes.ATTRNAME) {
    final PsiBuilder.Marker attr=myBuilder.mark();
    myBuilder.advanceLexer();
    if (myBuilder.getTokenType() == PyTokenTypes.EQ) {
      myBuilder.advanceLexer();
      if (parsePyxlEmbed() || myBuilder.getTokenType() == PyxlTokenTypes.ATTRVALUE) {
        if (myBuilder.getTokenType() == PyxlTokenTypes.ATTRVALUE) {
          myBuilder.advanceLexer();
        }
        attr.done(PyElementTypes.KEYWORD_ARGUMENT_EXPRESSION);
        parsePyxlAttributes();
        return;
      }
    }
    myBuilder.error(""String_Node_Str"");
    attr.done(PyElementTypes.KEYWORD_ARGUMENT_EXPRESSION);
  }
}",0.8733233979135618
87081,"/** 
 * Parse the current pyxl tag.
 */
private void parsePyxlTag(){
  final PsiBuilder.Marker pyxl=myBuilder.mark();
  myBuilder.advanceLexer();
  if (myBuilder.getTokenType() == PyxlTokenTypes.TAGNAME) {
    consumeTokenAsPyxlTag();
  }
  parsePyxlAttributes();
  if (myBuilder.getTokenType() == PyxlTokenTypes.TAGENDANDCLOSE) {
    myBuilder.advanceLexer();
    pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
    return;
  }
 else   if (myBuilder.getTokenType() == PyxlTokenTypes.TAGEND) {
    myBuilder.advanceLexer();
    while (!myBuilder.eof()) {
      if (parsePyxlEmbed() == null) {
        break;
      }
      if (myBuilder.getTokenType() == PyxlTokenTypes.STRING) {
        myBuilder.advanceLexer();
      }
 else       if (PYXL_BEGIN_TOKENS.contains(myBuilder.getTokenType())) {
        parsePyxlTag();
      }
 else       if (PYXL_CLOSE_TOKENS.contains(myBuilder.getTokenType())) {
        consumeTokenAsPyxlTag();
        pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
        return;
      }
 else {
        myBuilder.advanceLexer();
      }
    }
  }
  myBuilder.error(""String_Node_Str"");
  pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
}","/** 
 * Parse the current pyxl tag.
 */
private void parsePyxlTag(){
  final PsiBuilder.Marker pyxl=myBuilder.mark();
  myBuilder.advanceLexer();
  IElementType token=myBuilder.getTokenType();
  if (!parsePyxlTagName()) {
    myBuilder.error(""String_Node_Str"");
    pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
    return;
  }
  parsePyxlAttributes();
  token=myBuilder.getTokenType();
  if (token == PyxlTokenTypes.TAGENDANDCLOSE) {
    myBuilder.advanceLexer();
  }
 else   if (token == PyxlTokenTypes.TAGEND) {
    myBuilder.advanceLexer();
    while ((token=myBuilder.getTokenType()) != PyxlTokenTypes.TAGCLOSE) {
      if (parsePyxlEmbed() == null) {
        pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
        return;
      }
      token=myBuilder.getTokenType();
      if (token == PyxlTokenTypes.TAGBEGIN) {
        parsePyxlTag();
      }
 else       if (token == PyxlTokenTypes.STRING) {
        myBuilder.advanceLexer();
      }
 else {
        myBuilder.error(""String_Node_Str"" + token.toString());
        pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
        return;
      }
    }
    myBuilder.advanceLexer();
    if (!parsePyxlTagName()) {
      myBuilder.error(""String_Node_Str"");
      pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
      return;
    }
    if (myBuilder.getTokenType() == PyxlTokenTypes.TAGEND) {
      myBuilder.advanceLexer();
    }
 else {
      myBuilder.error(""String_Node_Str"");
    }
  }
  pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
}",0.3559969442322384
87082,"public boolean parsePrimaryExpression(boolean isTargetExpression){
  boolean match=super.parsePrimaryExpression(isTargetExpression);
  if (!match) {
    if (PYXL_BEGIN_TOKENS.contains(myBuilder.getTokenType())) {
      parsePyxlTag();
      return true;
    }
  }
  return match;
}","public boolean parsePrimaryExpression(boolean isTargetExpression){
  boolean match=super.parsePrimaryExpression(isTargetExpression);
  if (!match) {
    if (myBuilder.getTokenType() == PyxlTokenTypes.TAGBEGIN) {
      parsePyxlTag();
      return true;
    }
  }
  return match;
}",0.8342245989304813
87083,"/** 
 * Parse the current pyxl tag.
 */
private void parsePyxlTag(){
  final PsiBuilder.Marker pyxl=myBuilder.mark();
  consumeTokenAsPyxlTag();
  parsePyxlAttributes();
  if (myBuilder.getTokenType() == PyxlTokenTypes.TAGENDANDCLOSE) {
    myBuilder.advanceLexer();
    pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
    return;
  }
 else   if (myBuilder.getTokenType() == PyxlTokenTypes.TAGEND) {
    consumeTokenAsPyxlTag();
    while (!myBuilder.eof()) {
      if (!parsePyxlEmbed()) {
        break;
      }
      if (myBuilder.getTokenType() == PyxlTokenTypes.STRING) {
        myBuilder.advanceLexer();
      }
 else       if (myBuilder.getTokenType() == PyxlTokenTypes.TAGBEGIN) {
        parsePyxlTag();
      }
 else       if (myBuilder.getTokenType() == PyxlTokenTypes.TAGCLOSE) {
        consumeTokenAsPyxlTag();
        pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
        return;
      }
 else {
        myBuilder.advanceLexer();
      }
    }
  }
  myBuilder.error(""String_Node_Str"");
  pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
}","/** 
 * Parse the current pyxl tag.
 */
private void parsePyxlTag(){
  final PsiBuilder.Marker pyxl=myBuilder.mark();
  consumeTokenAsPyxlTag();
  parsePyxlAttributes();
  if (myBuilder.getTokenType() == PyxlTokenTypes.TAGENDANDCLOSE) {
    myBuilder.advanceLexer();
    pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
    return;
  }
 else   if (myBuilder.getTokenType() == PyxlTokenTypes.TAGEND) {
    myBuilder.advanceLexer();
    while (!myBuilder.eof()) {
      if (!parsePyxlEmbed()) {
        break;
      }
      if (myBuilder.getTokenType() == PyxlTokenTypes.STRING) {
        myBuilder.advanceLexer();
      }
 else       if (myBuilder.getTokenType() == PyxlTokenTypes.TAGBEGIN) {
        parsePyxlTag();
      }
 else       if (myBuilder.getTokenType() == PyxlTokenTypes.TAGCLOSE) {
        consumeTokenAsPyxlTag();
        pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
        return;
      }
 else {
        myBuilder.advanceLexer();
      }
    }
  }
  myBuilder.error(""String_Node_Str"");
  pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
}",0.9803545759463344
87084,"/** 
 * Parse the current pyxl tag.
 */
private void parsePyxlTag(){
  final PsiBuilder.Marker pyxl=myBuilder.mark();
  myBuilder.advanceLexer();
  IElementType token=myBuilder.getTokenType();
  if (!parsePyxlTagName()) {
    myBuilder.error(""String_Node_Str"");
    pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
    return;
  }
  parsePyxlAttributes();
  token=myBuilder.getTokenType();
  if (token == PyxlTokenTypes.TAGENDANDCLOSE) {
    myBuilder.advanceLexer();
  }
 else   if (token == PyxlTokenTypes.TAGEND) {
    myBuilder.advanceLexer();
    while ((token=myBuilder.getTokenType()) != PyxlTokenTypes.TAGCLOSE) {
      if (parsePyxlEmbed() == null) {
        pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
        return;
      }
      token=myBuilder.getTokenType();
      if (token == PyxlTokenTypes.TAGBEGIN) {
        parsePyxlTag();
      }
 else       if (token == PyxlTokenTypes.STRING) {
        myBuilder.advanceLexer();
      }
 else {
        myBuilder.error(""String_Node_Str"" + token.toString());
        pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
        return;
      }
    }
    myBuilder.advanceLexer();
    if (!parsePyxlTagName()) {
      myBuilder.error(""String_Node_Str"");
      pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
      return;
    }
    if (myBuilder.getTokenType() == PyxlTokenTypes.TAGEND) {
      myBuilder.advanceLexer();
    }
 else {
      myBuilder.error(""String_Node_Str"");
    }
  }
  pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
}","/** 
 * Parse the current pyxl tag.
 */
private void parsePyxlTag(){
  final PsiBuilder.Marker pyxl=myBuilder.mark();
  myBuilder.advanceLexer();
  IElementType token=myBuilder.getTokenType();
  if (!parsePyxlTagName()) {
    myBuilder.error(""String_Node_Str"");
    pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
    return;
  }
  parsePyxlAttributes();
  token=myBuilder.getTokenType();
  if (token == PyxlTokenTypes.TAGENDANDCLOSE) {
    myBuilder.advanceLexer();
  }
 else   if (token == PyxlTokenTypes.TAGEND) {
    myBuilder.advanceLexer();
    while ((token=myBuilder.getTokenType()) != PyxlTokenTypes.TAGCLOSE) {
      Integer parsedEmbed=parsePyxlEmbed();
      if (parsedEmbed == null) {
        pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
        return;
      }
 else       if (parsedEmbed == 1) {
        continue;
      }
      if (token == PyxlTokenTypes.TAGBEGIN) {
        parsePyxlTag();
      }
 else       if (token == PyxlTokenTypes.STRING) {
        myBuilder.advanceLexer();
      }
 else {
        myBuilder.error(""String_Node_Str"" + token.toString());
        pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
        return;
      }
    }
    myBuilder.advanceLexer();
    if (!parsePyxlTagName()) {
      myBuilder.error(""String_Node_Str"");
      pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
      return;
    }
    if (myBuilder.getTokenType() == PyxlTokenTypes.TAGEND) {
      myBuilder.advanceLexer();
    }
 else {
      myBuilder.error(""String_Node_Str"");
    }
  }
  pyxl.done(PyxlElementTypes.PYXL_STATEMENT);
}",0.95108153078203
87085,"public PyxlIndentingLexer(){
  super(new PythonPyxlLexer((Reader)null),TokenSet.EMPTY);
}","public PyxlIndentingLexer(){
  super(new PyxlLexer((Reader)null),TokenSet.EMPTY);
}",0.9651162790697676
87086,"/** 
 * Parse the current pyxl tag.
 */
private void parsePyxlTag(){
  final PsiBuilder.Marker pyxl=myBuilder.mark();
  myBuilder.advanceLexer();
  parsePyxlAttributes();
  if (myBuilder.getTokenType() == PyxlTokenTypes.TAGENDANDCLOSE) {
    myBuilder.advanceLexer();
    pyxl.done(PyElementTypes.STRING_LITERAL_EXPRESSION);
    return;
  }
 else   if (myBuilder.getTokenType() == PyxlTokenTypes.TAGEND) {
    myBuilder.advanceLexer();
    while (!myBuilder.eof()) {
      if (myBuilder.getTokenType() == PyxlTokenTypes.STRING) {
        myBuilder.advanceLexer();
      }
 else       if (myBuilder.getTokenType() == PyxlTokenTypes.TAGBEGIN) {
        parsePyxlTag();
      }
 else       if (myBuilder.getTokenType() == PyxlTokenTypes.TAGCLOSE) {
        pyxl.done(PyElementTypes.STRING_LITERAL_EXPRESSION);
        return;
      }
 else {
        myBuilder.advanceLexer();
      }
    }
  }
  myBuilder.error(""String_Node_Str"");
  pyxl.done(PyElementTypes.STRING_LITERAL_EXPRESSION);
}","/** 
 * Parse the current pyxl tag.
 */
private void parsePyxlTag(){
  final PsiBuilder.Marker pyxl=myBuilder.mark();
  myBuilder.advanceLexer();
  parsePyxlAttributes();
  if (myBuilder.getTokenType() == PyxlTokenTypes.TAGENDANDCLOSE) {
    myBuilder.advanceLexer();
    pyxl.done(PyElementTypes.CALL_EXPRESSION);
    return;
  }
 else   if (myBuilder.getTokenType() == PyxlTokenTypes.TAGEND) {
    myBuilder.advanceLexer();
    while (!myBuilder.eof()) {
      if (myBuilder.getTokenType() == PyxlTokenTypes.STRING) {
        myBuilder.advanceLexer();
      }
 else       if (myBuilder.getTokenType() == PyxlTokenTypes.TAGBEGIN) {
        parsePyxlTag();
      }
 else       if (myBuilder.getTokenType() == PyxlTokenTypes.TAGCLOSE) {
        myBuilder.advanceLexer();
        pyxl.done(PyElementTypes.CALL_EXPRESSION);
        return;
      }
 else {
        myBuilder.advanceLexer();
      }
    }
  }
  myBuilder.error(""String_Node_Str"");
  pyxl.done(PyElementTypes.CALL_EXPRESSION);
}",0.3566362715298885
87087,"/** 
 * Parse as many attribute=""value"" pairs as possible.
 */
private void parsePyxlAttributes(){
  if (myBuilder.getTokenType() == PyxlTokenTypes.ATTRNAME) {
    myBuilder.advanceLexer();
    if (myBuilder.getTokenType() == PyTokenTypes.EQ) {
      myBuilder.advanceLexer();
      if (myBuilder.getTokenType() == PyxlTokenTypes.ATTRVALUE) {
        myBuilder.advanceLexer();
        parsePyxlAttributes();
        return;
      }
    }
    myBuilder.error(""String_Node_Str"");
  }
}","/** 
 * Parse as many attribute=""value"" pairs as possible.
 */
private void parsePyxlAttributes(){
  if (myBuilder.getTokenType() == PyxlTokenTypes.ATTRNAME) {
    final PsiBuilder.Marker attr=myBuilder.mark();
    myBuilder.advanceLexer();
    if (myBuilder.getTokenType() == PyTokenTypes.EQ) {
      myBuilder.advanceLexer();
      if (myBuilder.getTokenType() == PyxlTokenTypes.ATTRVALUE) {
        myBuilder.advanceLexer();
        attr.done(PyElementTypes.KEYWORD_ARGUMENT_EXPRESSION);
        parsePyxlAttributes();
        return;
      }
    }
    myBuilder.error(""String_Node_Str"");
  }
}",0.8944444444444445
87088,"private void initFiles(){
  IPath templatePrjRoot=libraryRoot.append(""String_Node_Str"");
  if (version == null) {
    return;
  }
  Version v=Version.valueOf(version);
  String prjDirVar=TEMPLATEVAR_PRJ_DIR_3_0;
  String pbxProjVar=TEMPLATEVAR_PBXPROJ_3_0;
  if (v.compareWithBuildsTo(VERSION_3_3_0) > 0) {
    prjDirVar=TEMPLATEVAR_PRJ_DIR_3_4;
    pbxProjVar=TEMPLATEVAR_PBXPROJ_3_4;
  }
  if (v.equals(VERSION_3_0_0)) {
    files.put(new Path(""String_Node_Str""),getEngineFile(libraryRoot.append(""String_Node_Str"")));
  }
 else {
    files.put(new Path(""String_Node_Str""),getEngineFile(libraryRoot.append(""String_Node_Str"")));
  }
  files.put(new Path(""String_Node_Str""),getEngineFile(libraryRoot.append(""String_Node_Str"")));
  files.put(new Path(VAR_APP_NAME),getEngineFile(templatePrjRoot.append(prjDirVar)));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str"" + VAR_APP_NAME+ ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",prjDirVar))));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str"" + VAR_APP_NAME+ ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",prjDirVar))));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",pbxProjVar))));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",prjDirVar))));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",prjDirVar))));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",prjDirVar))));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",prjDirVar))));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",prjDirVar))));
  files.put(new Path(""String_Node_Str""),getEngineFile(libraryRoot.append(""String_Node_Str"")));
  files.put(PATH_CORDOVA_JS,getEngineFile(libraryRoot.append(""String_Node_Str"").append(PATH_CORDOVA_JS)));
}","private void initFiles(){
  IPath templatePrjRoot=libraryRoot.append(""String_Node_Str"");
  if (version == null) {
    return;
  }
  Version v=Version.valueOf(version);
  String prjDirVar=TEMPLATEVAR_PRJ_DIR_3_0;
  String pbxProjVar=TEMPLATEVAR_PBXPROJ_3_0;
  if (v.compareWithBuildsTo(VERSION_4_0_1) > 0) {
    prjDirVar=TEMPLATEVAR_PRJ_DIR_3_4;
    pbxProjVar=TEMPLATEVAR_PBXPROJ_4_1;
  }
 else   if (v.compareWithBuildsTo(VERSION_3_3_0) > 0) {
    prjDirVar=TEMPLATEVAR_PRJ_DIR_3_4;
    pbxProjVar=TEMPLATEVAR_PBXPROJ_3_4;
  }
  if (v.equals(VERSION_3_0_0)) {
    files.put(new Path(""String_Node_Str""),getEngineFile(libraryRoot.append(""String_Node_Str"")));
  }
 else {
    files.put(new Path(""String_Node_Str""),getEngineFile(libraryRoot.append(""String_Node_Str"")));
  }
  if (v.compareWithBuildsTo(VERSION_4_0_1) > 0) {
    files.put(new Path(""String_Node_Str""),getEngineFile(libraryRoot.append(""String_Node_Str"")));
  }
 else {
    files.put(new Path(""String_Node_Str""),getEngineFile(libraryRoot.append(""String_Node_Str"")));
  }
  files.put(new Path(VAR_APP_NAME),getEngineFile(templatePrjRoot.append(prjDirVar)));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str"" + VAR_APP_NAME+ ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",prjDirVar))));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str"" + VAR_APP_NAME+ ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",prjDirVar))));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",pbxProjVar))));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",prjDirVar))));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",prjDirVar))));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",prjDirVar))));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",prjDirVar))));
  files.put(new Path(VAR_APP_NAME + ""String_Node_Str""),getEngineFile(templatePrjRoot.append(NLS.bind(""String_Node_Str"",prjDirVar))));
  files.put(new Path(""String_Node_Str""),getEngineFile(libraryRoot.append(""String_Node_Str"")));
  files.put(PATH_CORDOVA_JS,getEngineFile(libraryRoot.append(""String_Node_Str"").append(PATH_CORDOVA_JS)));
}",0.9303030303030304
87089,"@Test public void testSetUpMerchant() throws InstantiationException, IllegalAccessException, SignException {
  String keyAlias=""String_Node_Str"" + config.getMerchantID() + ""String_Node_Str"";
  X509Certificate x509Cert=Mockito.mock(X509Certificate.class);
  Principal principal=Mockito.mock(Principal.class);
  PrivateKey pkey=Mockito.mock(PrivateKey.class);
  Logger logger=Mockito.mock(Logger.class);
  Mockito.when(x509Cert.getSubjectDN()).thenReturn(principal);
  Mockito.when(principal.getName()).thenReturn(keyAlias);
  Identity identity=new Identity(config,x509Cert,pkey,logger);
  assertEquals(identity.getName(),config.getMerchantID());
  assertEquals(identity.getSerialNumber(),""String_Node_Str"");
  assertNotNull(identity.getPrivateKey());
}","@Test public void testSetUpMerchant() throws InstantiationException, IllegalAccessException, SignException, ConfigException {
  File p12file=Mockito.mock(File.class);
  MerchantConfig mc=Mockito.mock(MerchantConfig.class);
  String keyAlias=""String_Node_Str"" + mc.getMerchantID() + ""String_Node_Str"";
  X509Certificate x509Cert=Mockito.mock(X509Certificate.class);
  Principal principal=Mockito.mock(Principal.class);
  PrivateKey pkey=Mockito.mock(PrivateKey.class);
  Logger logger=Mockito.mock(Logger.class);
  Mockito.when(x509Cert.getSubjectDN()).thenReturn(principal);
  Mockito.when(principal.getName()).thenReturn(keyAlias);
  Mockito.when(mc.getKeyFile()).thenReturn(p12file);
  Identity identity=new Identity(mc,x509Cert,pkey,logger);
  assertEquals(identity.getName(),mc.getMerchantID());
  assertEquals(identity.getSerialNumber(),""String_Node_Str"");
  assertNotNull(identity.getPrivateKey());
}",0.8847314423657212
87090,"/** 
 * Entry point.
 * @param args it takes the kind of transaction that has to  be run. For ex- auth, sale
 */
public static void main(String[] args){
  String argument=args[0];
  Properties props=readCybsProperty();
  String requestID;
  String decision;
  Document authReply;
  Document captureReply;
  int choice=sample.enum_exist(argument);
switch (choice) {
case 0:
    authReply=runAuth(props,""String_Node_Str"");
  if (authReply == null)   break;
requestID=getRequestID(authReply);
decision=getDecisonCode(authReply);
break;
case 1:
authReply=runAuth(props,""String_Node_Str"");
if (authReply == null) break;
requestID=getRequestID(authReply);
decision=getDecisonCode(authReply);
if (!((""String_Node_Str"".equals(requestID)) && (decision.equalsIgnoreCase(""String_Node_Str"")))) {
runCapture(props,requestID,""String_Node_Str"");
}
break;
case 2:
authReply=runAuthEMV(props,""String_Node_Str"");
if (authReply == null) break;
requestID=getRequestID(authReply);
decision=getDecisonCode(authReply);
break;
case 3:
authReply=runAuth(props,""String_Node_Str"");
if (authReply == null) break;
requestID=getRequestID(authReply);
decision=getDecisonCode(authReply);
captureReply=runCapture(props,requestID,""String_Node_Str"");
requestID=getRequestID(captureReply);
decision=getDecisonCode(captureReply);
if (!((""String_Node_Str"".equals(requestID)) && (""String_Node_Str"".equalsIgnoreCase(decision)))) runCredit(props,requestID,""String_Node_Str"");
break;
case 4:
authReply=runAuth(props,""String_Node_Str"");
if (authReply=null) break;
requestID=getRequestID(authReply);
decision=getDecisonCode(authReply);
if (!((""String_Node_Str"".equals(requestID)) && ""String_Node_Str"".equalsIgnoreCase(decision))) runAuthReversal(props,requestID,""String_Node_Str"");
break;
case 5:
runSale(props,""String_Node_Str"");
break;
case -1:
System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
break;
default :
break;
}
}","/** 
 * Entry point.
 * @param args it takes the kind of transaction that has to  be run. For ex- auth, sale
 */
public static void main(String[] args){
  String argument=args[0];
  Properties props=readCybsProperty();
  String requestID;
  String decision;
  Document authReply;
  Document captureReply;
  int choice=sample.enum_exist(argument);
switch (choice) {
case 0:
    authReply=runAuth(props,""String_Node_Str"");
  if (authReply == null)   break;
requestID=getRequestID(authReply);
decision=getDecisonCode(authReply);
break;
case 1:
authReply=runAuth(props,""String_Node_Str"");
if (authReply == null) break;
requestID=getRequestID(authReply);
decision=getDecisonCode(authReply);
if (!((""String_Node_Str"".equals(requestID)) && (decision.equalsIgnoreCase(""String_Node_Str"")))) {
runCapture(props,requestID,""String_Node_Str"");
}
break;
case 2:
authReply=runAuthEMV(props,""String_Node_Str"");
if (authReply == null) break;
requestID=getRequestID(authReply);
decision=getDecisonCode(authReply);
break;
case 3:
authReply=runAuth(props,""String_Node_Str"");
if (authReply == null) break;
requestID=getRequestID(authReply);
decision=getDecisonCode(authReply);
captureReply=runCapture(props,requestID,""String_Node_Str"");
requestID=getRequestID(captureReply);
decision=getDecisonCode(captureReply);
if (!((""String_Node_Str"".equals(requestID)) && (""String_Node_Str"".equalsIgnoreCase(decision)))) runCredit(props,requestID,""String_Node_Str"");
break;
case 4:
authReply=runAuth(props,""String_Node_Str"");
if (authReply == null) break;
requestID=getRequestID(authReply);
decision=getDecisonCode(authReply);
if (!((""String_Node_Str"".equals(requestID)) && ""String_Node_Str"".equalsIgnoreCase(decision))) runAuthReversal(props,requestID,""String_Node_Str"");
break;
case 5:
runSale(props,""String_Node_Str"");
break;
case -1:
System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
break;
default :
break;
}
}",0.9987415051598288
87091,"void postDocument(Document request) throws IOException, TransformerConfigurationException, TransformerException, MalformedURLException, ProtocolException {
  HttpClient httpClient=new HttpClient();
  setTimeout(httpClient,mc.getTimeout() * 1000);
  setProxy(httpClient);
  String serverURL=mc.getEffectiveServerURL();
  postMethod=new PostMethod(serverURL);
  postMethod.getParams().setParameter(HttpMethodParams.RETRY_HANDLER,new MyRetryHandler());
  String requestString=documentToString(request);
  logger.log(Logger.LT_INFO,""String_Node_Str"" + requestString.length() + ""String_Node_Str""+ serverURL);
  postMethod.setRequestEntity(new StringRequestEntity(requestString,null,""String_Node_Str""));
  httpClient.executeMethod(postMethod);
}","void postDocument(Document request) throws IOException, TransformerConfigurationException, TransformerException, MalformedURLException, ProtocolException {
  HttpClient httpClient=new HttpClient(new SimpleHttpConnectionManager(true));
  setTimeout(httpClient,mc.getTimeout() * 1000);
  setProxy(httpClient);
  String serverURL=mc.getEffectiveServerURL();
  postMethod=new PostMethod(serverURL);
  postMethod.getParams().setParameter(HttpMethodParams.RETRY_HANDLER,new MyRetryHandler());
  String requestString=documentToString(request);
  logger.log(Logger.LT_INFO,""String_Node_Str"" + requestString.length() + ""String_Node_Str""+ serverURL);
  postMethod.setRequestEntity(new StringRequestEntity(requestString,null,""String_Node_Str""));
  httpClient.executeMethod(postMethod);
}",0.9755775577557756
87092,"private String getRRDPath(String host){
  return rrdpath + (host != null ? host : ""String_Node_Str"");
}","private String getRRDPath(String host) throws AnkushException {
  return rrdpath + (host != null ? getRRDHostPath(host) : ""String_Node_Str"");
}",0.8373983739837398
87093,"/** 
 * DIGITAL SIGNATURES 
 */
public static final boolean sign(byte[] v,byte[] h,byte[] x,byte[] s){
  byte[] tmp1=new byte[65];
  byte[] tmp2=new byte[33];
  int w;
  int i;
  for (i=0; i < 32; i++)   v[i]=0;
  i=mula_small(v,x,0,h,32,-1);
  mula_small(v,v,0,ORDER,32,(15 - v[31]) / 16);
  mula32(tmp1,v,s,32,1);
  divmod(tmp2,tmp1,64,ORDER,32);
  for (w=0, i=0; i < 32; i++)   w|=v[i]=tmp1[i];
  return w != 0;
}","/** 
 * DIGITAL SIGNATURES 
 */
public static final boolean sign(byte[] v,byte[] h,byte[] x,byte[] s){
  int w, i;
  byte[] h1=new byte[32], x1=new byte[32];
  byte[] tmp1=new byte[64];
  byte[] tmp2=new byte[64];
  cpy32(h1,h);
  cpy32(x1,x);
  byte[] tmp3=new byte[32];
  divmod(tmp3,h1,32,ORDER,32);
  divmod(tmp3,x1,32,ORDER,32);
  mula_small(v,x1,0,h1,32,-1);
  mula_small(v,v,0,ORDER,32,1);
  mula32(tmp1,v,s,32,1);
  divmod(tmp2,tmp1,64,ORDER,32);
  for (w=0, i=0; i < 32; i++)   w|=v[i]=tmp1[i];
  return w != 0;
}",0.4072494669509595
87094,"/** 
 * DIGITAL SIGNATURES 
 */
public static final boolean sign(byte[] v,byte[] h,byte[] x,byte[] s){
  byte[] tmp1=new byte[65];
  byte[] tmp2=new byte[33];
  int w;
  int i;
  for (i=0; i < 32; i++)   v[i]=0;
  i=mula_small(v,x,0,h,32,-1);
  mula_small(v,v,0,ORDER,32,(15 - v[31]) / 16);
  mula32(tmp1,v,s,32,1);
  divmod(tmp2,tmp1,64,ORDER,32);
  for (w=0, i=0; i < 32; i++)   w|=v[i]=tmp1[i];
  return w != 0;
}","/** 
 * DIGITAL SIGNATURES 
 */
public static final boolean sign(byte[] v,byte[] h,byte[] x,byte[] s){
  int w, i;
  byte[] h1=new byte[32], x1=new byte[32];
  byte[] tmp1=new byte[64];
  byte[] tmp2=new byte[64];
  cpy32(h1,h);
  cpy32(x1,x);
  byte[] tmp3=new byte[32];
  divmod(tmp3,h1,32,ORDER,32);
  divmod(tmp3,x1,32,ORDER,32);
  mula_small(v,x1,0,h1,32,-1);
  mula_small(v,v,0,ORDER,32,1);
  mula32(tmp1,v,s,32,1);
  divmod(tmp2,tmp1,64,ORDER,32);
  for (w=0, i=0; i < 32; i++)   w|=v[i]=tmp1[i];
  return w != 0;
}",0.4072494669509595
87095,"@Override public ItemStack slotClick(int slotNum,int mouseButton,int modifier,EntityPlayer player){
  return super.slotClick(slotNum,mouseButton,modifier,player);
}","@Override public ItemStack slotClick(int slotNum,int mouseButton,int modifier,EntityPlayer player){
  if (modifier == 2) {
    Slot slot1=(Slot)this.inventorySlots.get(slotNum);
    ItemStack stack2=player.inventory.getStackInSlot(mouseButton);
    if (stack2 != null && !slot1.isItemValid(stack2))     return slot1.getStack();
  }
  return super.slotClick(slotNum,mouseButton,modifier,player);
}",0.5857142857142857
87096,"public static ItemStack insertStackIntoInventory(ItemStack itemStack,IInventory inventory){
  return TileEntityHopper.func_145889_a(inventory,itemStack,ForgeDirection.UNKNOWN.ordinal());
}","public static ItemStack insertStackIntoInventory(ItemStack itemStack,IInventory inventory,ForgeDirection direction){
  return TileEntityHopper.func_145889_a(inventory,itemStack,direction.ordinal());
}",0.8556701030927835
87097,"/** 
 * Only fill a maximum of one slot
 * @return The remainder
 */
public static ItemStack insertStackIntoInventoryOnce(ItemStack itemStack,IInventory inventory){
  int originalStackSize=itemStack.stackSize;
  for (int l=0; l < inventory.getSizeInventory(); ++l) {
    try {
      itemStack=(ItemStack)hopperInsertIntoInventory.invoke(null,inventory,itemStack,l,ForgeDirection.UNKNOWN.ordinal());
    }
 catch (    RuntimeException e) {
      throw e;
    }
catch (    Exception e) {
      e.printStackTrace();
    }
    if (itemStack == null || itemStack.stackSize != originalStackSize)     break;
  }
  if (itemStack != null && itemStack.stackSize == 0) {
    itemStack=null;
  }
  return itemStack;
}","/** 
 * Only fill a maximum of one slot
 * @return The remainder
 */
public static ItemStack insertStackIntoInventoryOnce(ItemStack itemStack,IInventory inventory,ForgeDirection direction){
  int originalStackSize=itemStack.stackSize;
  for (int l=0; l < inventory.getSizeInventory(); ++l) {
    try {
      itemStack=(ItemStack)hopperInsertIntoInventory.invoke(null,inventory,itemStack,l,direction.ordinal());
    }
 catch (    RuntimeException e) {
      throw e;
    }
catch (    Exception e) {
      e.printStackTrace();
    }
    if (itemStack == null || itemStack.stackSize != originalStackSize)     break;
  }
  if (itemStack != null && itemStack.stackSize == 0) {
    itemStack=null;
  }
  return itemStack;
}",0.960618846694796
87098,"public static void setRoundingMode(){
  for (  RoundingMode roundingMode : RoundingMode.values()) {
    if (roundingMode.id.equals(FOOD_HUNGER_ROUNDING_MODE_STRING.toLowerCase())) {
      FOOD_HUNGER_ROUNDING_MODE=roundingMode;
      break;
    }
  }
  if (FOOD_HUNGER_ROUNDING_MODE == null) {
    ModSpiceOfLife.Log.warn(""String_Node_Str"" + FOOD_HUNGER_ROUNDING_MODE_STRING + ""String_Node_Str"");
    FOOD_HUNGER_ROUNDING_MODE_STRING=""String_Node_Str"";
    FOOD_HUNGER_ROUNDING_MODE=RoundingMode.ROUND;
  }
}","public static void setRoundingMode(){
  for (  RoundingMode roundingMode : RoundingMode.values()) {
    if (roundingMode.id.equals(FOOD_HUNGER_ROUNDING_MODE_STRING.toLowerCase(Locale.ROOT))) {
      FOOD_HUNGER_ROUNDING_MODE=roundingMode;
      break;
    }
  }
  if (FOOD_HUNGER_ROUNDING_MODE == null) {
    ModSpiceOfLife.Log.warn(""String_Node_Str"" + FOOD_HUNGER_ROUNDING_MODE_STRING + ""String_Node_Str"");
    FOOD_HUNGER_ROUNDING_MODE_STRING=""String_Node_Str"";
    FOOD_HUNGER_ROUNDING_MODE=RoundingMode.ROUND;
  }
}",0.9892891918208374
87099,"@Override public boolean equals(Object obj){
  return buf.equals(obj);
}","@Override public boolean equals(Object obj){
  if (super.equals(obj))   return true;
 else   if (obj instanceof ByteIONetty)   return buf.equals(((ByteIONetty)obj).buf);
 else   return false;
}",0.5433962264150943
87100,"public static FoodQueue getNewFoodQueue(){
  if (ModConfig.USE_HUNGER_QUEUE)   return new FixedHungerQueue(ModConfig.FOOD_HISTORY_LENGTH);
 else   if (ModConfig.USE_TIME_QUEUE)   return new FixedTimeQueue(ModConfig.FOOD_HISTORY_LENGTH * MiscHelper.TICKS_PER_DAY);
 else   return new FixedSizeQueue(ModConfig.FOOD_HISTORY_LENGTH);
}","public static FoodQueue getNewFoodQueue(){
  if (ModConfig.USE_HUNGER_QUEUE)   return new FixedHungerQueue(ModConfig.FOOD_HISTORY_LENGTH);
 else   if (ModConfig.USE_TIME_QUEUE)   return new FixedTimeQueue((long)ModConfig.FOOD_HISTORY_LENGTH * MiscHelper.TICKS_PER_DAY);
 else   return new FixedSizeQueue(ModConfig.FOOD_HISTORY_LENGTH);
}",0.9910179640718564
87101,"public void addItemFromString(String itemString,boolean isBaseItem){
  String[] itemStringParts=itemString.split(""String_Node_Str"");
  if (itemStringParts.length > 1) {
    Item item=GameRegistry.findItem(itemStringParts[0],itemStringParts[1]);
    if (item != null) {
      boolean exactMetadata=itemStringParts.length > 2 && itemStringParts[2] != ""String_Node_Str"";
      int metadata=itemStringParts.length > 2 && exactMetadata ? Integer.parseInt(itemStringParts[2]) : 0;
      addFood(new ItemStack(item,1,metadata),exactMetadata,isBaseItem);
    }
  }
}","public void addItemFromString(String itemString,boolean isBaseItem){
  String[] itemStringParts=itemString.split(""String_Node_Str"");
  if (itemStringParts.length > 1) {
    Item item=GameRegistry.findItem(itemStringParts[0],itemStringParts[1]);
    if (item != null) {
      boolean exactMetadata=itemStringParts.length > 2 && !itemStringParts[2].equals(""String_Node_Str"");
      int metadata=itemStringParts.length > 2 && exactMetadata ? Integer.parseInt(itemStringParts[2]) : 0;
      addFood(new ItemStack(item,1,metadata),exactMetadata,isBaseItem);
    }
  }
}",0.9875222816399288
87102,"public static void writeExampleFoodGroup(File configDirectory){
  final String exampleFoodGroupFileName=""String_Node_Str"";
  final String exampleFoodGroupRelativePath=""String_Node_Str"" + exampleFoodGroupFileName;
  File exampleFoodGroupDest=new File(configDirectory,exampleFoodGroupFileName);
  try {
    boolean shouldOverwrite=shouldOverwriteExampleFoodGroup(exampleFoodGroupDest);
    if (ModSpiceOfLife.instance.sourceFile.isDirectory()) {
      File sourceFile=new File(ModSpiceOfLife.instance.sourceFile,exampleFoodGroupRelativePath);
      FileHelper.copyFile(sourceFile,exampleFoodGroupDest,shouldOverwrite);
    }
 else {
      InputStream exampleFoodGroupInputStream=FoodGroupConfig.class.getClassLoader().getResourceAsStream(exampleFoodGroupRelativePath);
      FileHelper.copyFile(exampleFoodGroupInputStream,exampleFoodGroupDest,shouldOverwrite);
      exampleFoodGroupInputStream.close();
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public static void writeExampleFoodGroup(File configDirectory){
  final String exampleFoodGroupFileName=""String_Node_Str"";
  final String exampleFoodGroupRelativePath=""String_Node_Str"" + exampleFoodGroupFileName;
  File exampleFoodGroupDest=new File(configDirectory,exampleFoodGroupFileName);
  try {
    boolean shouldOverwrite=shouldOverwriteExampleFoodGroup(exampleFoodGroupDest);
    if (ModSpiceOfLife.instance.sourceFile != null && ModSpiceOfLife.instance.sourceFile.isDirectory()) {
      File sourceFile=new File(ModSpiceOfLife.instance.sourceFile,exampleFoodGroupRelativePath);
      FileHelper.copyFile(sourceFile,exampleFoodGroupDest,shouldOverwrite);
    }
 else {
      InputStream exampleFoodGroupInputStream=FoodGroupConfig.class.getClassLoader().getResourceAsStream(exampleFoodGroupRelativePath);
      FileHelper.copyFile(exampleFoodGroupInputStream,exampleFoodGroupDest,shouldOverwrite);
      exampleFoodGroupInputStream.close();
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9768378650553876
87103,"public static void load(){
  for (  File configFile : configFiles) {
    try {
      FileReader reader=new FileReader(configFile);
      FoodGroup foodGroup=gson.fromJson(reader,FoodGroup.class);
      if (foodGroup != null && foodGroup.enabled) {
        foodGroup.identifier=FilenameUtils.removeExtension(configFile.getName());
        foodGroup.initFromConfig();
        FoodGroupRegistry.addFoodGroup(foodGroup);
      }
      reader.close();
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
catch (    IOException e) {
      e.printStackTrace();
    }
  }
}","public static void load(){
  for (  File configFile : configFiles) {
    InputStreamReader reader=null;
    try {
      reader=new InputStreamReader(new FileInputStream(configFile),""String_Node_Str"");
      FoodGroup foodGroup=gson.fromJson(reader,FoodGroup.class);
      if (foodGroup != null && foodGroup.enabled) {
        foodGroup.identifier=FilenameUtils.removeExtension(configFile.getName());
        foodGroup.initFromConfig();
        FoodGroupRegistry.addFoodGroup(foodGroup);
      }
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
catch (    IOException e) {
      e.printStackTrace();
    }
 finally {
      MiscHelper.tryCloseStream(reader);
    }
  }
}",0.8385093167701864
87104,"public static void setup(File configDirectory){
  File modConfigDirectory=new File(configDirectory,ModInfo.MODID);
  if (!modConfigDirectory.exists()) {
    modConfigDirectory.mkdirs();
  }
  writeExampleFoodGroup(modConfigDirectory);
  configFiles=modConfigDirectory.listFiles();
}","public static void setup(File configDirectory){
  File modConfigDirectory=new File(configDirectory,ModInfo.MODID);
  if (modConfigDirectory.exists() || modConfigDirectory.mkdirs()) {
    writeExampleFoodGroup(modConfigDirectory);
    configFiles=modConfigDirectory.listFiles();
  }
}",0.8707964601769912
87105,"public static boolean shouldOverwriteExampleFoodGroup(File exampleFoodGroup) throws IOException {
  FileInputStream exampleFoodGroupStream;
  try {
    exampleFoodGroupStream=new FileInputStream(exampleFoodGroup);
  }
 catch (  FileNotFoundException e) {
    return true;
  }
  BufferedReader exampleFoodGroupReader=new BufferedReader(new InputStreamReader(exampleFoodGroupStream));
  String firstLine=exampleFoodGroupReader.readLine();
  exampleFoodGroupReader.close();
  return firstLine == null || !firstLine.equals(""String_Node_Str"" + ModInfo.VERSION);
}","public static boolean shouldOverwriteExampleFoodGroup(File exampleFoodGroup) throws IOException {
  FileInputStream exampleFoodGroupStream;
  try {
    exampleFoodGroupStream=new FileInputStream(exampleFoodGroup);
  }
 catch (  FileNotFoundException e) {
    return true;
  }
  BufferedReader exampleFoodGroupReader=null;
  try {
    exampleFoodGroupReader=new BufferedReader(new InputStreamReader(exampleFoodGroupStream,""String_Node_Str""));
    String firstLine=exampleFoodGroupReader.readLine();
    return firstLine == null || !firstLine.equals(""String_Node_Str"" + ModInfo.VERSION);
  }
 catch (  IOException e) {
    throw e;
  }
 finally {
    MiscHelper.tryCloseStream(exampleFoodGroupReader);
  }
}",0.8234362628661916
87106,"public GuiFoodContainer(InventoryPlayer playerInventory,IInventory foodContainerInventory,ItemStack itemStack){
  super(new ContainerFoodContainer(playerInventory,foodContainerInventory,itemStack));
  this.inventory=foodContainerInventory;
  this.playerInventory=playerInventory;
  this.ySize=133;
}","public GuiFoodContainer(InventoryPlayer playerInventory,FoodContainerInventory foodContainerInventory){
  super(new ContainerFoodContainer(playerInventory,foodContainerInventory));
  this.inventory=foodContainerInventory;
  this.playerInventory=playerInventory;
  this.ySize=133;
}",0.9241379310344828
87107,"public Object getSidedGuiElement(boolean isClientSide,int guiId,EntityPlayer player,World world,int x,int y,int z){
switch (GuiIds.values()[guiId]) {
case FOOD_CONTAINER:
    ItemStack heldItem=player.getHeldItem();
  if (heldItem != null && heldItem.getItem() instanceof ItemFoodContainer) {
    IInventory foodContainerInventory=((ItemFoodContainer)heldItem.getItem()).getInventory(heldItem);
    return isClientSide ? new GuiFoodContainer(player.inventory,foodContainerInventory,heldItem) : new ContainerFoodContainer(player.inventory,foodContainerInventory,heldItem);
  }
break;
default :
break;
}
return null;
}","public Object getSidedGuiElement(boolean isClientSide,int guiId,EntityPlayer player,World world,int x,int y,int z){
switch (GuiIds.values()[guiId]) {
case FOOD_CONTAINER:
    ItemStack heldItem=player.getHeldItem();
  if (heldItem != null && heldItem.getItem() instanceof ItemFoodContainer) {
    FoodContainerInventory foodContainerInventory=((ItemFoodContainer)heldItem.getItem()).getInventory(heldItem);
    return isClientSide ? new GuiFoodContainer(player.inventory,foodContainerInventory) : new ContainerFoodContainer(player.inventory,foodContainerInventory);
  }
break;
default :
break;
}
return null;
}",0.9738988580750408
87108,"@Override public void onContainerClosed(EntityPlayer player){
  if (player.worldObj.isRemote) {
    itemStack=findFoodContainerWithUUID(getUUID());
  }
  if (itemStack != null)   ((ItemFoodContainer)itemStack.getItem()).setIsOpen(itemStack,false);
  super.onContainerClosed(player);
}","@Override public void onContainerClosed(EntityPlayer player){
  if (player.worldObj.isRemote) {
    setFoodContainerItemStack(findFoodContainerWithUUID(getUUID()));
  }
  if (getItemStack() != null)   ((ItemFoodContainer)getItemStack().getItem()).setIsOpen(getItemStack(),false);
  super.onContainerClosed(player);
}",0.93
87109,"public ItemStack findFoodContainerWithUUID(UUID uuid){
  for (  Object inventorySlotObj : this.inventorySlots) {
    Slot inventorySlot=(Slot)inventorySlotObj;
    ItemStack itemStack=inventorySlot.getStack();
    if (itemStack != null && itemStack.getItem() instanceof ItemFoodContainer) {
      if (((ItemFoodContainer)itemStack.getItem()).getUUID(itemStack).equals(uuid))       return itemStack;
    }
  }
  return null;
}","public ItemStack findFoodContainerWithUUID(UUID uuid){
  for (  Object inventorySlotObj : this.inventorySlots) {
    Slot inventorySlot=(Slot)inventorySlotObj;
    ItemStack itemStack=inventorySlot.getStack();
    if (isFoodContainerWithUUID(itemStack,uuid)) {
      return itemStack;
    }
  }
  return null;
}",0.779891304347826
87110,"public UUID getUUID(){
  return ((ItemFoodContainer)itemStack.getItem()).getUUID(itemStack);
}","public UUID getUUID(){
  return ((ItemFoodContainer)getItemStack().getItem()).getUUID(getItemStack());
}",0.9292929292929292
87111,"public ContainerFoodContainer(InventoryPlayer playerInventory,IInventory foodContainerInventory,ItemStack itemStack){
  super(foodContainerInventory);
  this.itemStack=itemStack;
  slotsX=(int)(GuiHelper.STANDARD_GUI_WIDTH / 2f - (inventory.getSizeInventory() * GuiHelper.STANDARD_SLOT_WIDTH / 2f));
  slotsY=19;
  this.addSlotsOfType(SlotFiltered.class,inventory,slotsX,slotsY);
  this.addPlayerInventorySlots(playerInventory,51);
}","public ContainerFoodContainer(InventoryPlayer playerInventory,FoodContainerInventory foodContainerInventory){
  super(foodContainerInventory);
  this.foodContainerInventory=foodContainerInventory;
  slotsX=(int)(GuiHelper.STANDARD_GUI_WIDTH / 2f - (inventory.getSizeInventory() * GuiHelper.STANDARD_SLOT_WIDTH / 2f));
  slotsY=19;
  this.addSlotsOfType(SlotFiltered.class,inventory,slotsX,slotsY);
  this.addPlayerInventorySlots(playerInventory,51);
}",0.8190045248868778
87112,"public static boolean isDirectlyEdible(ItemStack itemStack){
  return !(itemStack.getItem() == Item.cake || isFoodContainer(itemStack));
}","public static boolean isDirectlyEdible(ItemStack itemStack){
  return !(itemStack.getItem() == Items.cake || isFoodContainer(itemStack));
}",0.9963898916967509
87113,"@Override public byte[] transform(String name,String transformedName,byte[] bytes){
  if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    boolean isObfuscated=name.equals(""String_Node_Str"");
    ModSpiceOfLife.Log.info(""String_Node_Str"");
    ClassNode classNode=readClassFromBytes(bytes);
    MethodNode methodNode=findMethodNodeOfClass(classNode,isObfuscated ? ""String_Node_Str"" : ""String_Node_Str"",isObfuscated ? ""String_Node_Str"" : ""String_Node_Str"");
    if (methodNode != null) {
      addOnEatenHook(methodNode,Hooks.class,""String_Node_Str"",""String_Node_Str"");
      return writeClassToBytes(classNode);
    }
  }
  if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    boolean isObfuscated=name.equals(""String_Node_Str"");
    ModSpiceOfLife.Log.info(""String_Node_Str"");
    ClassNode classNode=readClassFromBytes(bytes);
    MethodNode methodNode=findMethodNodeOfClass(classNode,isObfuscated ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"");
    if (methodNode != null) {
      addFoodStatsHook(methodNode,Hooks.class,""String_Node_Str"",""String_Node_Str"");
      return writeClassToBytes(classNode);
    }
  }
  if (name.equals(""String_Node_Str"")) {
    ModSpiceOfLife.Log.info(""String_Node_Str"");
    ClassNode classNode=readClassFromBytes(bytes);
    MethodNode methodNode=findMethodNodeOfClass(classNode,""String_Node_Str"",""String_Node_Str"");
    if (methodNode == null)     methodNode=findMethodNodeOfClass(classNode,""String_Node_Str"",""String_Node_Str"");
    if (methodNode != null) {
      addFoodStatsHook(methodNode,Hooks.class,""String_Node_Str"",""String_Node_Str"");
      return writeClassToBytes(classNode);
    }
 else {
      ModSpiceOfLife.Log.warning(""String_Node_Str"");
    }
  }
  if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    boolean isObfuscated=name.equals(""String_Node_Str"");
    ModSpiceOfLife.Log.info(""String_Node_Str"");
    ClassNode classNode=readClassFromBytes(bytes);
    MethodNode methodNode=findMethodNodeOfClass(classNode,""String_Node_Str"",isObfuscated ? ""String_Node_Str"" : ""String_Node_Str"");
    if (methodNode != null) {
      addDrawHoveringTextHook(methodNode,Hooks.class,""String_Node_Str"",""String_Node_Str"",isObfuscated);
      return writeClassToBytes(classNode);
    }
 else {
      ModSpiceOfLife.Log.warning(""String_Node_Str"");
    }
  }
  if (name.equals(""String_Node_Str"")) {
    ModSpiceOfLife.Log.info(""String_Node_Str"");
    ClassNode classNode=readClassFromBytes(bytes);
    MethodNode methodNode=findMethodNodeOfClass(classNode,""String_Node_Str"",""String_Node_Str"");
    if (methodNode != null) {
      addCodeChickenDrawHoveringTextHook(methodNode,Hooks.class,""String_Node_Str"",""String_Node_Str"");
      return writeClassToBytes(classNode);
    }
 else {
      ModSpiceOfLife.Log.warning(""String_Node_Str"");
    }
  }
  if (name.equals(""String_Node_Str"")) {
    ModSpiceOfLife.Log.info(""String_Node_Str"");
    ClassNode classNode=readClassFromBytes(bytes);
    MethodNode methodNode=findMethodNodeOfClass(classNode,""String_Node_Str"",""String_Node_Str"");
    if (methodNode != null) {
      addDrawHoveringTextHook(methodNode,Hooks.class,""String_Node_Str"",""String_Node_Str"",false);
      return writeClassToBytes(classNode);
    }
 else {
      ModSpiceOfLife.Log.warning(""String_Node_Str"");
    }
  }
  return bytes;
}","@Override public byte[] transform(String name,String transformedName,byte[] bytes){
  if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    boolean isObfuscated=name.equals(""String_Node_Str"");
    ModSpiceOfLife.Log.info(""String_Node_Str"");
    ClassNode classNode=readClassFromBytes(bytes);
    MethodNode methodNode=findMethodNodeOfClass(classNode,isObfuscated ? ""String_Node_Str"" : ""String_Node_Str"",isObfuscated ? ""String_Node_Str"" : ""String_Node_Str"");
    if (methodNode != null) {
      addOnEatenHook(methodNode,Hooks.class,""String_Node_Str"",""String_Node_Str"");
      return writeClassToBytes(classNode);
    }
  }
  if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    boolean isObfuscated=name.equals(""String_Node_Str"");
    ModSpiceOfLife.Log.info(""String_Node_Str"");
    ClassNode classNode=readClassFromBytes(bytes);
    MethodNode methodNode=findMethodNodeOfClass(classNode,isObfuscated ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"");
    if (methodNode != null) {
      addFoodStatsHook(methodNode,Hooks.class,""String_Node_Str"",""String_Node_Str"");
      return writeClassToBytes(classNode);
    }
  }
  if (name.equals(""String_Node_Str"")) {
    ModSpiceOfLife.Log.info(""String_Node_Str"");
    ClassNode classNode=readClassFromBytes(bytes);
    MethodNode methodNode=findMethodNodeOfClass(classNode,""String_Node_Str"",""String_Node_Str"");
    if (methodNode == null)     methodNode=findMethodNodeOfClass(classNode,""String_Node_Str"",""String_Node_Str"");
    if (methodNode != null) {
      addFoodStatsHook(methodNode,Hooks.class,""String_Node_Str"",""String_Node_Str"");
      patchIguanaFoodStats(methodNode);
      return writeClassToBytes(classNode);
    }
 else {
      ModSpiceOfLife.Log.warning(""String_Node_Str"");
    }
  }
  if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    boolean isObfuscated=name.equals(""String_Node_Str"");
    ModSpiceOfLife.Log.info(""String_Node_Str"");
    ClassNode classNode=readClassFromBytes(bytes);
    MethodNode methodNode=findMethodNodeOfClass(classNode,""String_Node_Str"",isObfuscated ? ""String_Node_Str"" : ""String_Node_Str"");
    if (methodNode != null) {
      addDrawHoveringTextHook(methodNode,Hooks.class,""String_Node_Str"",""String_Node_Str"",isObfuscated);
      return writeClassToBytes(classNode);
    }
 else {
      ModSpiceOfLife.Log.warning(""String_Node_Str"");
    }
  }
  if (name.equals(""String_Node_Str"")) {
    ModSpiceOfLife.Log.info(""String_Node_Str"");
    ClassNode classNode=readClassFromBytes(bytes);
    MethodNode methodNode=findMethodNodeOfClass(classNode,""String_Node_Str"",""String_Node_Str"");
    if (methodNode != null) {
      addCodeChickenDrawHoveringTextHook(methodNode,Hooks.class,""String_Node_Str"",""String_Node_Str"");
      return writeClassToBytes(classNode);
    }
 else {
      ModSpiceOfLife.Log.warning(""String_Node_Str"");
    }
  }
  if (name.equals(""String_Node_Str"")) {
    ModSpiceOfLife.Log.info(""String_Node_Str"");
    ClassNode classNode=readClassFromBytes(bytes);
    MethodNode methodNode=findMethodNodeOfClass(classNode,""String_Node_Str"",""String_Node_Str"");
    if (methodNode != null) {
      addDrawHoveringTextHook(methodNode,Hooks.class,""String_Node_Str"",""String_Node_Str"",false);
      return writeClassToBytes(classNode);
    }
 else {
      ModSpiceOfLife.Log.warning(""String_Node_Str"");
    }
  }
  return bytes;
}",0.9940758293838864
87114,"public void addFoodStatsHook(MethodNode method,Class<?> hookClass,String hookMethod,String hookDesc){
  AbstractInsnNode targetNode=findFirstInstructionOfType(method,ALOAD);
  InsnList toInject=new InsnList();
  LabelNode varStartLabel=new LabelNode();
  LabelNode end=findEndLabel(method);
  LocalVariableNode localVar=new LocalVariableNode(""String_Node_Str"",""String_Node_Str"",null,varStartLabel,end,method.maxLocals);
  method.maxLocals+=1;
  method.localVariables.add(localVar);
  toInject.add(new VarInsnNode(ALOAD,0));
  toInject.add(new VarInsnNode(ILOAD,1));
  toInject.add(new VarInsnNode(FLOAD,2));
  toInject.add(new MethodInsnNode(INVOKESTATIC,hookClass.getName().replace('.','/'),hookMethod,hookDesc));
  toInject.add(new VarInsnNode(ASTORE,localVar.index));
  toInject.add(varStartLabel);
  toInject.add(new VarInsnNode(ALOAD,localVar.index));
  toInject.add(new FieldInsnNode(GETFIELD,FoodValues.class.getName().replace('.','/'),""String_Node_Str"",""String_Node_Str""));
  toInject.add(new VarInsnNode(ISTORE,1));
  toInject.add(new VarInsnNode(ALOAD,localVar.index));
  toInject.add(new FieldInsnNode(GETFIELD,FoodValues.class.getName().replace('.','/'),""String_Node_Str"",""String_Node_Str""));
  toInject.add(new VarInsnNode(FSTORE,2));
  method.instructions.insertBefore(targetNode,toInject);
  ModSpiceOfLife.Log.info(""String_Node_Str"" + method.name);
}","public void addFoodStatsHook(MethodNode method,Class<?> hookClass,String hookMethod,String hookDesc){
  AbstractInsnNode targetNode=findFirstInstructionOfType(method,ALOAD);
  InsnList toInject=new InsnList();
  LabelNode varStartLabel=new LabelNode();
  LabelNode end=findEndLabel(method);
  LocalVariableNode localVar=new LocalVariableNode(""String_Node_Str"",""String_Node_Str"",null,varStartLabel,end,method.maxLocals);
  method.maxLocals+=1;
  method.localVariables.add(localVar);
  toInject.add(new VarInsnNode(ALOAD,0));
  toInject.add(new VarInsnNode(ILOAD,1));
  toInject.add(new VarInsnNode(FLOAD,2));
  toInject.add(new MethodInsnNode(INVOKESTATIC,hookClass.getName().replace('.','/'),hookMethod,hookDesc));
  toInject.add(new VarInsnNode(ASTORE,localVar.index));
  toInject.add(varStartLabel);
  toInject.add(new VarInsnNode(ALOAD,localVar.index));
  toInject.add(new FieldInsnNode(GETFIELD,FoodValues.class.getName().replace('.','/'),""String_Node_Str"",""String_Node_Str""));
  toInject.add(new VarInsnNode(ISTORE,1));
  toInject.add(new VarInsnNode(ALOAD,localVar.index));
  toInject.add(new FieldInsnNode(GETFIELD,FoodValues.class.getName().replace('.','/'),""String_Node_Str"",""String_Node_Str""));
  toInject.add(new VarInsnNode(FSTORE,2));
  method.instructions.insertBefore(targetNode,toInject);
  ModSpiceOfLife.Log.info(""String_Node_Str"" + hookMethod + ""String_Node_Str""+ method.name);
}",0.9884225759768452
87115,"public static FoodValues getModifiedFoodValues(ItemFood itemFood){
  try {
    boolean wasRegenHealthEnabled=foodRegensHealth.getBoolean(null);
    foodRegensHealth.setBoolean(null,false);
    dummyFoodStats.setFoodLevel(0);
    dummyFoodStats.setFoodSaturationLevel(0);
    dummyFoodStats.addStats(itemFood);
    int hunger=dummyFoodStats.getFoodLevel();
    dummyFoodStats.setFoodLevel(20);
    dummyFoodStats.setFoodSaturationLevel(0);
    dummyFoodStats.addStats(itemFood);
    float saturationModifier=FoodValues.getSaturationModifierFromIncrement(dummyFoodStats.getSaturationLevel(),hunger);
    foodRegensHealth.setBoolean(null,wasRegenHealthEnabled);
    return new FoodValues(hunger,saturationModifier);
  }
 catch (  Exception e) {
    return new FoodValues(0,0);
  }
}","public static FoodValues getModifiedFoodValues(ItemFood itemFood){
  try {
    dummyFoodStats.setFoodLevel(0);
    dummyFoodStats.setFoodSaturationLevel(0);
    dummyFoodStats.addStats(itemFood);
    int hunger=dummyFoodStats.getFoodLevel();
    dummyFoodStats.setFoodLevel(20);
    dummyFoodStats.setFoodSaturationLevel(0);
    dummyFoodStats.addStats(itemFood);
    float saturationModifier=FoodValues.getSaturationModifierFromIncrement(dummyFoodStats.getSaturationLevel(),hunger);
    return new FoodValues(hunger,saturationModifier);
  }
 catch (  Exception e) {
    return new FoodValues(0,0);
  }
}",0.8734634851771511
87116,"public static boolean downloadFile(final URL url,final File dest,final JProgressBar bar,final JProgressBar fullBar,JLabel speedLabel){
  bar.setIndeterminate(true);
  FileOutputStream fos=null;
  BufferedReader reader=null;
  try {
    URI uri=new URI(url.getProtocol(),url.getUserInfo(),url.getHost(),url.getPort(),url.getPath(),url.getQuery(),url.getRef());
    URL url2=uri.toURL();
    URLConnection connection=url2.openConnection();
    int fileLength=connection.getContentLength();
    if (fileLength == -1) {
      System.out.println(""String_Node_Str"");
      return false;
    }
 else {
      bar.setMaximum(fileLength);
    }
    InputStream in=connection.getInputStream();
    reader=new BufferedReader(new InputStreamReader(in));
    fos=new FileOutputStream(dest);
    long downloadStartTime=System.currentTimeMillis();
    int downloadedAmount=0;
    byte[] buff=new byte[1024];
    bar.setValue(0);
    bar.setIndeterminate(false);
    int n;
    while ((n=in.read(buff)) != -1) {
      fos.write(buff,0,n);
      bar.setValue(bar.getValue() + n);
      fullBar.setValue(fullBar.getValue() + n);
      downloadedAmount+=n;
      long timeLapse=System.currentTimeMillis() - downloadStartTime;
      if (timeLapse >= 1000L) {
        float downloadSpeed=downloadedAmount / (float)timeLapse;
        downloadedAmount=0;
        downloadStartTime+=1000L;
        DecimalFormat df=new DecimalFormat();
        df.setMaximumFractionDigits(2);
        if (downloadSpeed > 1000.0F) {
          speedLabel.setText(""String_Node_Str"" + String.valueOf(df.format(downloadSpeed / 1024F)) + ""String_Node_Str"");
        }
 else {
          speedLabel.setText(""String_Node_Str"" + String.valueOf(df.format(downloadSpeed)) + ""String_Node_Str"");
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    return false;
  }
 finally {
    try {
      fos.flush();
      fos.close();
      reader.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
      return false;
    }
  }
  return true;
}","public static boolean downloadFile(final URL url,final File dest,final JProgressBar bar,final JProgressBar fullBar,JLabel speedLabel){
  bar.setIndeterminate(true);
  FileOutputStream fos=null;
  BufferedReader reader=null;
  try {
    URI uri=new URI(url.getProtocol(),url.getUserInfo(),url.getHost(),url.getPort(),url.getPath(),url.getQuery(),url.getRef());
    URL url2=uri.toURL();
    URLConnection connection=url2.openConnection();
    int fileLength=connection.getContentLength();
    if (fileLength == -1) {
      System.err.println(""String_Node_Str"");
      return false;
    }
 else {
      bar.setMaximum(fileLength);
    }
    InputStream in=connection.getInputStream();
    reader=new BufferedReader(new InputStreamReader(in));
    fos=new FileOutputStream(dest);
    long downloadStartTime=System.currentTimeMillis();
    int downloadedAmount=0;
    byte[] buff=new byte[1024];
    bar.setValue(0);
    bar.setIndeterminate(false);
    int n;
    while ((n=in.read(buff)) != -1) {
      fos.write(buff,0,n);
      bar.setValue(bar.getValue() + n);
      fullBar.setValue(fullBar.getValue() + n);
      downloadedAmount+=n;
      long timeLapse=System.currentTimeMillis() - downloadStartTime;
      if (timeLapse >= 1000L) {
        float downloadSpeed=downloadedAmount / (float)timeLapse;
        downloadedAmount=0;
        downloadStartTime+=1000L;
        DecimalFormat df=new DecimalFormat();
        df.setMaximumFractionDigits(2);
        if (downloadSpeed > 1000.0F) {
          speedLabel.setText(""String_Node_Str"" + String.valueOf(df.format(downloadSpeed / 1024F)) + ""String_Node_Str"");
        }
 else {
          speedLabel.setText(""String_Node_Str"" + String.valueOf(df.format(downloadSpeed)) + ""String_Node_Str"");
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    return false;
  }
 finally {
    try {
      fos.flush();
      fos.close();
      reader.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
      return false;
    }
  }
  return true;
}",0.9985214391325776
87117,"public static void unpackLibrary(File output,byte[] data) throws IOException {
  if (output.exists()) {
    output.delete();
  }
  byte[] decompressed=readFully(new XZInputStream(new ByteArrayInputStream(data)));
  String end=new String(decompressed,decompressed.length - 4,4);
  if (!end.equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + end);
    return;
  }
  int x=decompressed.length;
  int len=((decompressed[x - 8] & 0xFF)) | ((decompressed[x - 7] & 0xFF) << 8) | ((decompressed[x - 6] & 0xFF) << 16)| ((decompressed[x - 5] & 0xFF) << 24);
  byte[] checksums=Arrays.copyOfRange(decompressed,decompressed.length - len - 8,decompressed.length - 8);
  FileOutputStream jarBytes=new FileOutputStream(output);
  JarOutputStream jos=new JarOutputStream(jarBytes);
  Pack200.newUnpacker().unpack(new ByteArrayInputStream(decompressed),jos);
  jos.putNextEntry(new JarEntry(""String_Node_Str""));
  jos.write(checksums);
  jos.closeEntry();
  jos.close();
  jarBytes.close();
}","public static void unpackLibrary(File output,byte[] data) throws IOException {
  if (output.exists()) {
    output.delete();
  }
  byte[] decompressed=readFully(new XZInputStream(new ByteArrayInputStream(data)));
  String end=new String(decompressed,decompressed.length - 4,4);
  if (!end.equals(""String_Node_Str"")) {
    System.err.println(""String_Node_Str"" + end);
    return;
  }
  int x=decompressed.length;
  int len=((decompressed[x - 8] & 0xFF)) | ((decompressed[x - 7] & 0xFF) << 8) | ((decompressed[x - 6] & 0xFF) << 16)| ((decompressed[x - 5] & 0xFF) << 24);
  byte[] checksums=Arrays.copyOfRange(decompressed,decompressed.length - len - 8,decompressed.length - 8);
  FileOutputStream jarBytes=new FileOutputStream(output);
  JarOutputStream jos=new JarOutputStream(jarBytes);
  Pack200.newUnpacker().unpack(new ByteArrayInputStream(decompressed),jos);
  jos.putNextEntry(new JarEntry(""String_Node_Str""));
  jos.write(checksums);
  jos.closeEntry();
  jos.close();
  jarBytes.close();
}",0.9969879518072288
87118,"public static boolean validateJar(File libPath,byte[] data,List<String> checksums) throws IOException {
  System.out.println(""String_Node_Str"" + libPath.getAbsolutePath() + ""String_Node_Str"");
  HashMap<String,String> files=new HashMap<String,String>();
  String[] hashes=null;
  JarInputStream jar=new JarInputStream(new ByteArrayInputStream(data));
  JarEntry entry=jar.getNextJarEntry();
  while (entry != null) {
    byte[] eData=readFully(jar);
    if (entry.getName().equals(""String_Node_Str"")) {
      hashes=new String(eData,Charset.forName(""String_Node_Str"")).split(""String_Node_Str"");
    }
    if (!entry.isDirectory()) {
      files.put(entry.getName(),Hashing.sha1().hashBytes(eData).toString());
    }
    entry=jar.getNextJarEntry();
  }
  jar.close();
  if (hashes != null) {
    boolean failed=!checksums.contains(files.get(""String_Node_Str""));
    if (failed) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      for (      String hash : hashes) {
        if (hash.trim().equals(""String_Node_Str"") || !hash.contains(""String_Node_Str""))         continue;
        String[] e=hash.split(""String_Node_Str"");
        String validChecksum=e[0];
        String target=e[1];
        String checksum=files.get(target);
        if (!files.containsKey(target) || checksum == null) {
          System.out.println(""String_Node_Str"" + target + ""String_Node_Str"");
          failed=true;
        }
 else         if (!checksum.equals(validChecksum)) {
          System.out.println(""String_Node_Str"" + target + ""String_Node_Str""+ checksum+ ""String_Node_Str""+ validChecksum+ ""String_Node_Str"");
          failed=true;
        }
      }
    }
    if (!failed) {
      System.out.println(""String_Node_Str"");
    }
    return !failed;
  }
 else {
    System.out.println(""String_Node_Str"");
    return false;
  }
}","public static boolean validateJar(File libPath,byte[] data,List<String> checksums) throws IOException {
  System.out.println(""String_Node_Str"" + libPath.getAbsolutePath() + ""String_Node_Str"");
  HashMap<String,String> files=new HashMap<String,String>();
  String[] hashes=null;
  JarInputStream jar=new JarInputStream(new ByteArrayInputStream(data));
  JarEntry entry=jar.getNextJarEntry();
  while (entry != null) {
    byte[] eData=readFully(jar);
    if (entry.getName().equals(""String_Node_Str"")) {
      hashes=new String(eData,Charset.forName(""String_Node_Str"")).split(""String_Node_Str"");
    }
    if (!entry.isDirectory()) {
      files.put(entry.getName(),Hashing.sha1().hashBytes(eData).toString());
    }
    entry=jar.getNextJarEntry();
  }
  jar.close();
  if (hashes != null) {
    boolean failed=!checksums.contains(files.get(""String_Node_Str""));
    if (failed) {
      System.err.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      for (      String hash : hashes) {
        if (hash.trim().equals(""String_Node_Str"") || !hash.contains(""String_Node_Str""))         continue;
        String[] e=hash.split(""String_Node_Str"");
        String validChecksum=e[0];
        String target=e[1];
        String checksum=files.get(target);
        if (!files.containsKey(target) || checksum == null) {
          System.err.println(""String_Node_Str"" + target + ""String_Node_Str"");
          failed=true;
        }
 else         if (!checksum.equals(validChecksum)) {
          System.err.println(""String_Node_Str"" + target + ""String_Node_Str""+ checksum+ ""String_Node_Str""+ validChecksum+ ""String_Node_Str"");
          failed=true;
        }
      }
    }
    if (!failed) {
      System.out.println(""String_Node_Str"");
    }
    return !failed;
  }
 else {
    System.out.println(""String_Node_Str"");
    return false;
  }
}",0.9951845906902088
87119,"public void deleteDeprecated(){
  for (  FileEntry entry : this.fileChecker.outdatedList) {
    File f=new File(modPackDir,entry.getPath());
    if (f.delete()) {
      System.out.println(f.getPath() + ""String_Node_Str"" + entry.getMd5());
    }
 else {
      frame.dispose();
      JOptionPane.showMessageDialog(null,""String_Node_Str"" + f.getPath(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    }
  }
}","public void deleteDeprecated(){
  for (  FileEntry entry : this.fileChecker.outdatedList) {
    File f=new File(modPackDir,entry.getPath());
    if (f.delete()) {
      System.err.println(f.getPath() + ""String_Node_Str"" + entry.getMd5());
    }
 else {
      frame.dispose();
      JOptionPane.showMessageDialog(null,""String_Node_Str"" + f.getPath(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    }
  }
}",0.9926108374384236
87120,"public CreditFrame(Dimension dim){
  this.setTitle(""String_Node_Str"");
  this.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  this.setResizable(false);
  JPanel panel=new JPanel();
  panel.setLayout(new BoxLayout(panel,BoxLayout.Y_AXIS));
  JButton sponsorButton=new JButton(""String_Node_Str"");
  sponsorButton.setAlignmentX(CENTER_ALIGNMENT);
  sponsorButton.setAlignmentY(CENTER_ALIGNMENT);
  sponsorButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      try {
        Desktop.getDesktop().browse(new URI(""String_Node_Str""));
      }
 catch (      Exception ex) {
        JOptionPane.showMessageDialog(CreditFrame.this,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  JPanel sponsorPanel=new JPanel();
  sponsorPanel.setLayout(new BoxLayout(sponsorPanel,BoxLayout.X_AXIS));
  sponsorPanel.setAlignmentX(CENTER_ALIGNMENT);
  sponsorPanel.setAlignmentY(CENTER_ALIGNMENT);
  sponsorPanel.add(sponsorButton);
  JLabel text=new JLabel();
  text.setText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  text.setAlignmentX(CENTER_ALIGNMENT);
  text.setAlignmentY(CENTER_ALIGNMENT);
  panel.add(text);
  panel.add(sponsorPanel);
  this.add(panel);
  this.pack();
  int x=(dim.width / 2) - (this.getSize().width / 2);
  int y=(dim.height / 2) - (this.getSize().height / 2);
  this.setLocation(x,y);
}","public CreditFrame(Dimension dim){
  this.setTitle(""String_Node_Str"");
  this.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  this.setResizable(false);
  JPanel panel=new JPanel();
  panel.setLayout(new BoxLayout(panel,BoxLayout.Y_AXIS));
  JButton sponsorButton=new JButton(""String_Node_Str"");
  sponsorButton.setAlignmentX(CENTER_ALIGNMENT);
  sponsorButton.setAlignmentY(CENTER_ALIGNMENT);
  sponsorButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      try {
        if (Desktop.isDesktopSupported())         Desktop.getDesktop().browse(new URI(""String_Node_Str""));
 else         throw new Exception();
      }
 catch (      Exception ex) {
        JOptionPane.showMessageDialog(CreditFrame.this,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  JPanel sponsorPanel=new JPanel();
  sponsorPanel.setLayout(new BoxLayout(sponsorPanel,BoxLayout.X_AXIS));
  sponsorPanel.setAlignmentX(CENTER_ALIGNMENT);
  sponsorPanel.setAlignmentY(CENTER_ALIGNMENT);
  sponsorPanel.add(sponsorButton);
  JLabel text=new JLabel();
  text.setText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  text.setAlignmentX(CENTER_ALIGNMENT);
  text.setAlignmentY(CENTER_ALIGNMENT);
  panel.add(text);
  panel.add(sponsorPanel);
  this.add(panel);
  this.pack();
  int x=(dim.width / 2) - (this.getSize().width / 2);
  int y=(dim.height / 2) - (this.getSize().height / 2);
  this.setLocation(x,y);
}",0.9737628694785786
87121,"@Override public void actionPerformed(ActionEvent e){
  try {
    Desktop.getDesktop().browse(new URI(""String_Node_Str""));
  }
 catch (  Exception ex) {
    JOptionPane.showMessageDialog(CreditFrame.this,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}","@Override public void actionPerformed(ActionEvent e){
  try {
    if (Desktop.isDesktopSupported())     Desktop.getDesktop().browse(new URI(""String_Node_Str""));
 else     throw new Exception();
  }
 catch (  Exception ex) {
    JOptionPane.showMessageDialog(CreditFrame.this,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}",0.8849270664505673
87122,"public SqlStatementsBuilder insert(String table,JsonArray fields,JsonArray values,String returning){
  if (table != null && !table.trim().isEmpty()) {
    JsonObject statement=new JsonObject().put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",table).put(""String_Node_Str"",fields).put(""String_Node_Str"",values);
    if (returning != null && !returning.trim().isEmpty()) {
      statement.put(""String_Node_Str"",returning);
    }
    statements.add(statement);
  }
  return this;
}","public SqlStatementsBuilder insert(String table,JsonArray fields,JsonArray values,String returning){
  if (table != null && !table.trim().isEmpty() && values != null && !values.isEmpty()) {
    JsonObject statement=new JsonObject().put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",table).put(""String_Node_Str"",fields).put(""String_Node_Str"",values);
    if (returning != null && !returning.trim().isEmpty()) {
      statement.put(""String_Node_Str"",returning);
    }
    statements.add(statement);
  }
  return this;
}",0.5230166503428012
87123,"@Override public void validate(ImportInfos importInfos,final Handler<Either<JsonObject,JsonObject>> handler){
  try {
    JsonObject action=new JsonObject(mapper.writeValueAsString(importInfos)).putString(""String_Node_Str"",""String_Node_Str"");
    eb.send(Directory.FEEDER,action,new Handler<Message<JsonObject>>(){
      @Override public void handle(      Message<JsonObject> res){
        if (""String_Node_Str"".equals(res.body().getString(""String_Node_Str""))) {
          JsonObject r=res.body().getObject(""String_Node_Str"",new JsonObject());
          if (r.getObject(""String_Node_Str"",new JsonObject()).size() > 0) {
            handler.handle(new Either.Left<JsonObject,JsonObject>(r.getObject(""String_Node_Str"")));
          }
 else {
            handler.handle(new Either.Right<JsonObject,JsonObject>(r.getObject(""String_Node_Str"").putObject(""String_Node_Str"",r.getObject(""String_Node_Str""))));
          }
        }
 else {
          handler.handle(new Either.Left<JsonObject,JsonObject>(new JsonObject().putArray(""String_Node_Str"",new JsonArray().addString(res.body().getString(""String_Node_Str"",""String_Node_Str"")))));
        }
      }
    }
);
  }
 catch (  JsonProcessingException e) {
    handler.handle(new Either.Left<JsonObject,JsonObject>(new JsonObject().putArray(""String_Node_Str"",new JsonArray().addString(""String_Node_Str""))));
    log.error(e.getMessage(),e);
  }
}","@Override public void validate(ImportInfos importInfos,final Handler<Either<JsonObject,JsonObject>> handler){
  try {
    JsonObject action=new JsonObject(mapper.writeValueAsString(importInfos)).putString(""String_Node_Str"",""String_Node_Str"");
    eb.send(Directory.FEEDER,action,new Handler<Message<JsonObject>>(){
      @Override public void handle(      Message<JsonObject> res){
        if (""String_Node_Str"".equals(res.body().getString(""String_Node_Str""))) {
          JsonObject r=res.body().getObject(""String_Node_Str"",new JsonObject());
          if (r.getObject(""String_Node_Str"",new JsonObject()).size() > 0) {
            handler.handle(new Either.Left<JsonObject,JsonObject>(r.getObject(""String_Node_Str"")));
          }
 else {
            JsonObject f=r.getObject(""String_Node_Str"");
            if (r.getObject(""String_Node_Str"") != null) {
              f.putObject(""String_Node_Str"",r.getObject(""String_Node_Str""));
            }
            handler.handle(new Either.Right<JsonObject,JsonObject>(f));
          }
        }
 else {
          handler.handle(new Either.Left<JsonObject,JsonObject>(new JsonObject().putArray(""String_Node_Str"",new JsonArray().addString(res.body().getString(""String_Node_Str"",""String_Node_Str"")))));
        }
      }
    }
);
  }
 catch (  JsonProcessingException e) {
    handler.handle(new Either.Left<JsonObject,JsonObject>(new JsonObject().putArray(""String_Node_Str"",new JsonArray().addString(""String_Node_Str""))));
    log.error(e.getMessage(),e);
  }
}",0.9214804565894156
87124,"@Override public void handle(Message<JsonObject> m){
  if (m != null && ""String_Node_Str"".equals(m.body().getString(""String_Node_Str""))) {
    logger.info(m.body().encode());
    if (executePostImport) {
      postImport.execute();
    }
  }
 else {
    Validator.initLogin(neo4j,vertx);
    if (m != null) {
      logger.error(m.body().getString(""String_Node_Str""));
      report.addError(m.body().getString(""String_Node_Str""));
    }
 else     if (report.getResult().getObject(""String_Node_Str"").size() < 1) {
      logger.error(""String_Node_Str"");
      report.addError(""String_Node_Str"");
    }
  }
  report.getResult().putArray(""String_Node_Str"",new JsonArray(importer.getUserImportedExternalId().toArray()));
  h.handle(report);
  logger.info(""String_Node_Str"" + (System.currentTimeMillis() - start) + ""String_Node_Str"");
  importer.clear();
  checkEventQueue();
}","@Override public void handle(Message<JsonObject> m){
  if (m != null && ""String_Node_Str"".equals(m.body().getString(""String_Node_Str""))) {
    logger.info(m.body().encode());
    if (executePostImport) {
      postImport.execute();
    }
  }
 else {
    Validator.initLogin(neo4j,vertx);
    if (m != null) {
      logger.error(m.body().getString(""String_Node_Str""));
      report.addError(m.body().getString(""String_Node_Str""));
    }
 else     if (report.getResult().getObject(""String_Node_Str"").size() < 1) {
      logger.error(""String_Node_Str"");
      report.addError(""String_Node_Str"");
    }
  }
  report.setUsersExternalId(new JsonArray(importer.getUserImportedExternalId().toArray()));
  h.handle(report);
  logger.info(""String_Node_Str"" + (System.currentTimeMillis() - start) + ""String_Node_Str"");
  importer.clear();
  checkEventQueue();
}",0.9662790697674418
87125,"private void doImport(final Message<JsonObject> message,final Feed feed,final Handler<Report> h){
  final String acceptLanguage=message.body().getString(""String_Node_Str"",""String_Node_Str"");
  final String charset=message.body().getString(""String_Node_Str"",""String_Node_Str"");
  final String importPath=message.body().getString(""String_Node_Str"");
  final boolean executePostImport=message.body().getBoolean(""String_Node_Str"",true);
  final Importer importer=Importer.getInstance();
  if (importer.isReady()) {
    final long start=System.currentTimeMillis();
    importer.init(neo4j,feed.getSource(),acceptLanguage,new Handler<Message<JsonObject>>(){
      @Override public void handle(      Message<JsonObject> res){
        if (!""String_Node_Str"".equals(res.body().getString(""String_Node_Str""))) {
          logger.error(res.body().getString(""String_Node_Str""));
          h.handle(new Report(acceptLanguage).addError(""String_Node_Str""));
          importer.clear();
          checkEventQueue();
          return;
        }
        final Report report=importer.getReport();
        try {
          Handler<Message<JsonObject>> handler=new Handler<Message<JsonObject>>(){
            @Override public void handle(            Message<JsonObject> m){
              if (m != null && ""String_Node_Str"".equals(m.body().getString(""String_Node_Str""))) {
                logger.info(m.body().encode());
                if (executePostImport) {
                  postImport.execute();
                }
              }
 else {
                Validator.initLogin(neo4j,vertx);
                if (m != null) {
                  logger.error(m.body().getString(""String_Node_Str""));
                  report.addError(m.body().getString(""String_Node_Str""));
                }
 else                 if (report.getResult().getObject(""String_Node_Str"").size() < 1) {
                  logger.error(""String_Node_Str"");
                  report.addError(""String_Node_Str"");
                }
              }
              report.getResult().putArray(""String_Node_Str"",new JsonArray(importer.getUserImportedExternalId().toArray()));
              h.handle(report);
              logger.info(""String_Node_Str"" + (System.currentTimeMillis() - start) + ""String_Node_Str"");
              importer.clear();
              checkEventQueue();
            }
          }
;
          if (importPath != null && !importPath.trim().isEmpty()) {
            feed.launch(importer,importPath,handler);
          }
 else {
            feed.launch(importer,handler);
          }
        }
 catch (        Exception e) {
          Validator.initLogin(neo4j,vertx);
          importer.clear();
          h.handle(report.addError(""String_Node_Str""));
          logger.error(e.getMessage(),e);
          checkEventQueue();
        }
      }
    }
);
  }
 else {
    eventQueue.add(message);
  }
}","private void doImport(final Message<JsonObject> message,final Feed feed,final Handler<Report> h){
  final String acceptLanguage=message.body().getString(""String_Node_Str"",""String_Node_Str"");
  final String charset=message.body().getString(""String_Node_Str"",""String_Node_Str"");
  final String importPath=message.body().getString(""String_Node_Str"");
  final boolean executePostImport=message.body().getBoolean(""String_Node_Str"",true);
  final Importer importer=Importer.getInstance();
  if (importer.isReady()) {
    final long start=System.currentTimeMillis();
    importer.init(neo4j,feed.getSource(),acceptLanguage,new Handler<Message<JsonObject>>(){
      @Override public void handle(      Message<JsonObject> res){
        if (!""String_Node_Str"".equals(res.body().getString(""String_Node_Str""))) {
          logger.error(res.body().getString(""String_Node_Str""));
          h.handle(new Report(acceptLanguage).addError(""String_Node_Str""));
          importer.clear();
          checkEventQueue();
          return;
        }
        final Report report=importer.getReport();
        try {
          Handler<Message<JsonObject>> handler=new Handler<Message<JsonObject>>(){
            @Override public void handle(            Message<JsonObject> m){
              if (m != null && ""String_Node_Str"".equals(m.body().getString(""String_Node_Str""))) {
                logger.info(m.body().encode());
                if (executePostImport) {
                  postImport.execute();
                }
              }
 else {
                Validator.initLogin(neo4j,vertx);
                if (m != null) {
                  logger.error(m.body().getString(""String_Node_Str""));
                  report.addError(m.body().getString(""String_Node_Str""));
                }
 else                 if (report.getResult().getObject(""String_Node_Str"").size() < 1) {
                  logger.error(""String_Node_Str"");
                  report.addError(""String_Node_Str"");
                }
              }
              report.setUsersExternalId(new JsonArray(importer.getUserImportedExternalId().toArray()));
              h.handle(report);
              logger.info(""String_Node_Str"" + (System.currentTimeMillis() - start) + ""String_Node_Str"");
              importer.clear();
              checkEventQueue();
            }
          }
;
          if (importPath != null && !importPath.trim().isEmpty()) {
            feed.launch(importer,importPath,handler);
          }
 else {
            feed.launch(importer,handler);
          }
        }
 catch (        Exception e) {
          Validator.initLogin(neo4j,vertx);
          importer.clear();
          h.handle(report.addError(""String_Node_Str""));
          logger.error(e.getMessage(),e);
          checkEventQueue();
        }
      }
    }
);
  }
 else {
    eventQueue.add(message);
  }
}",0.9898138391289076
87126,"public static void generateUserExternalId(JsonObject props,String c,Structure structure,long seed){
  String externalId=props.getString(""String_Node_Str"");
  if (externalId != null && !externalId.trim().isEmpty()) {
    return;
  }
  String mapping=structure.getExternalId() + props.getString(""String_Node_Str"",""String_Node_Str"") + props.getString(""String_Node_Str"",""String_Node_Str"")+ props.getString(""String_Node_Str"",""String_Node_Str"")+ props.getString(""String_Node_Str"",""String_Node_Str"")+ props.getString(""String_Node_Str"",""String_Node_Str"")+ props.getString(""String_Node_Str"",""String_Node_Str"")+ props.getString(""String_Node_Str"",""String_Node_Str"")+ c+ seed;
  try {
    props.putString(""String_Node_Str"",Hash.sha1(mapping.getBytes(""String_Node_Str"")));
  }
 catch (  NoSuchAlgorithmException|UnsupportedEncodingException e) {
    log.error(e.getMessage(),e);
  }
}","public static void generateUserExternalId(JsonObject props,String c,Structure structure,long seed){
  String externalId=props.getString(""String_Node_Str"");
  if (externalId != null && !externalId.trim().isEmpty()) {
    return;
  }
  String hash=getHashMapping(props,c,structure,seed);
  if (hash != null) {
    props.putString(""String_Node_Str"",hash);
  }
}",0.4491456468673718
87127,"static void relativeStudentMapping(JsonArray linkStudents,String mapping){
  if (mapping.trim().isEmpty())   return;
  try {
    linkStudents.add(Hash.sha1(mapping.getBytes(""String_Node_Str"")));
  }
 catch (  NoSuchAlgorithmException|UnsupportedEncodingException e) {
    log.error(e.getMessage(),e);
  }
}","private void relativeStudentMapping(JsonArray linkStudents,String mapping){
  if (mapping.trim().isEmpty())   return;
  try {
    String hash=Hash.sha1(mapping.getBytes(""String_Node_Str""));
    linkStudents.add(getOrElse(studentExternalIdMapping.get(hash),hash));
  }
 catch (  NoSuchAlgorithmException|UnsupportedEncodingException e) {
    log.error(e.getMessage(),e);
  }
}",0.7988252569750367
87128,"public void start(final String profile,final Structure structure,String file,String charset,final Importer importer,final Handler<Message<JsonObject>> handler){
  importer.createOrUpdateProfile(STUDENT_PROFILE);
  importer.createOrUpdateProfile(RELATIVE_PROFILE);
  importer.createOrUpdateProfile(PERSONNEL_PROFILE);
  importer.createOrUpdateProfile(TEACHER_PROFILE);
  importer.createOrUpdateProfile(GUEST_PROFILE);
  DefaultFunctions.createOrUpdateFunctions(importer);
  final Validator validator=ManualFeeder.profiles.get(profile);
  try {
    CSVReader csvParser=getCsvReader(file,charset);
    final List<String> columns=new ArrayList<>();
    String[] strings;
    int i=0;
    while ((strings=csvParser.readNext()) != null) {
      if (i == 0) {
        columnsMapper.getColumsNames(strings,columns,handler);
      }
 else       if (!columns.isEmpty()) {
        JsonObject user=new JsonObject();
        user.putArray(""String_Node_Str"",new JsonArray().add(structure.getExternalId()));
        user.putArray(""String_Node_Str"",new JsonArray().add(profile));
        List<String[]> classes=new ArrayList<>();
        for (int j=0; j < strings.length; j++) {
          final String c=columns.get(j);
          final String v=strings[j].trim();
          if ((v.isEmpty() && !""String_Node_Str"".equals(c)) || (v.isEmpty() && ""String_Node_Str"".equals(c) && strings[j + 1].trim().isEmpty()))           continue;
switch (validator.getType(c)) {
case ""String_Node_Str"":
            if (""String_Node_Str"".equals(c)) {
              Matcher m=frenchDatePatter.matcher(v);
              if (m.find()) {
                user.putString(c,m.group(3) + ""String_Node_Str"" + m.group(2)+ ""String_Node_Str""+ m.group(1));
              }
 else {
                user.putString(c,v);
              }
            }
 else {
              user.putString(c,v);
            }
          break;
case ""String_Node_Str"":
        JsonArray a=user.getArray(c);
      if (a == null) {
        a=new JsonArray();
        user.putArray(c,a);
      }
    if ((""String_Node_Str"".equals(c) || ""String_Node_Str"".equals(c) || ""String_Node_Str"".equals(c)) && !v.startsWith(structure.getExternalId() + ""String_Node_Str"")) {
      a.add(structure.getExternalId() + ""String_Node_Str"" + v);
    }
 else {
      a.add(v);
    }
  break;
case ""String_Node_Str"":
user.putBoolean(c,""String_Node_Str"".equals(v.toLowerCase()));
break;
default :
Object o=user.getValue(c);
final String v2;
if (""String_Node_Str"".equals(c) && !v.startsWith(structure.getExternalId() + ""String_Node_Str"")) {
v2=structure.getExternalId() + ""String_Node_Str"" + v;
}
 else {
v2=v;
}
if (o != null) {
if (o instanceof JsonArray) {
((JsonArray)o).add(v2);
}
 else {
JsonArray array=new JsonArray();
array.add(o).add(v2);
user.putArray(c,array);
}
}
 else {
user.putString(c,v2);
}
}
if (""String_Node_Str"".equals(c)) {
String[] cc=v.split(""String_Node_Str"");
if (cc.length == 2 && !cc[1].matches(""String_Node_Str"")) {
final String fosEId=importer.getFieldOfStudy().get(cc[1]);
if (fosEId != null) {
cc[1]=fosEId;
}
}
String eId=structure.getExternalId() + '$' + cc[0];
structure.createClassIfAbsent(eId,cc[0]);
final String[] classId=new String[3];
classId[0]=structure.getExternalId();
classId[1]=eId;
classId[2]=(cc.length == 2) ? cc[1] : ""String_Node_Str"";
classes.add(classId);
}
}
String ca;
long seed;
JsonArray classesA;
Object co=user.getValue(""String_Node_Str"");
if (co != null && co instanceof JsonArray) {
classesA=(JsonArray)co;
}
 else if (co instanceof String) {
classesA=new JsonArray().add(co);
}
 else {
classesA=null;
}
if (""String_Node_Str"".equals(profile) && classesA != null && classesA.size() == 1) {
seed=DEFAULT_STUDENT_SEED;
ca=classesA.get(0);
}
 else {
ca=String.valueOf(i);
seed=System.currentTimeMillis();
}
generateUserExternalId(user,ca,structure,seed);
switch (profile) {
case ""String_Node_Str"":
importer.createOrUpdatePersonnel(user,TEACHER_PROFILE_EXTERNAL_ID,user.getArray(""String_Node_Str""),classes.toArray(new String[classes.size()][2]),null,true,true);
break;
case ""String_Node_Str"":
importer.createOrUpdatePersonnel(user,PERSONNEL_PROFILE_EXTERNAL_ID,user.getArray(""String_Node_Str""),classes.toArray(new String[classes.size()][2]),null,true,true);
break;
case ""String_Node_Str"":
importer.createOrUpdateStudent(user,STUDENT_PROFILE_EXTERNAL_ID,null,null,classes.toArray(new String[classes.size()][2]),null,null,true,true);
break;
case ""String_Node_Str"":
JsonArray linkStudents=new JsonArray();
for (String attr : user.getFieldNames()) {
if (""String_Node_Str"".equals(attr)) {
Object o=user.getValue(attr);
if (o instanceof JsonArray) {
for (Object c : (JsonArray)o) {
linkStudents.add(c);
}
}
 else {
linkStudents.add(o);
}
}
 else if (""String_Node_Str"".equals(attr)) {
Object childUsername=user.getValue(attr);
Object childLastName=user.getValue(""String_Node_Str"");
Object childFirstName=user.getValue(""String_Node_Str"");
Object childClasses=user.getValue(""String_Node_Str"");
if (childUsername instanceof JsonArray && childLastName instanceof JsonArray && childFirstName instanceof JsonArray&& childClasses instanceof JsonArray&& ((JsonArray)childClasses).size() == ((JsonArray)childLastName).size() && ((JsonArray)childFirstName).size() == ((JsonArray)childLastName).size()) {
for (int j=0; j < ((JsonArray)childUsername).size(); j++) {
String mapping=structure.getExternalId() + ((JsonArray)childUsername).<String>get(j).trim() + ((JsonArray)childLastName).<String>get(j).trim()+ ((JsonArray)childFirstName).<String>get(j).trim()+ ((JsonArray)childClasses).<String>get(j).trim()+ CsvFeeder.DEFAULT_STUDENT_SEED;
relativeStudentMapping(linkStudents,mapping);
}
}
 else if (childUsername instanceof String && childLastName instanceof String && childFirstName instanceof String&& childClasses instanceof String) {
String mapping=structure.getExternalId() + childLastName.toString().trim() + childFirstName.toString().trim()+ childClasses.toString().trim()+ CsvFeeder.DEFAULT_STUDENT_SEED;
relativeStudentMapping(linkStudents,mapping);
}
 else {
handler.handle(new ResultMessage().error(""String_Node_Str""));
return;
}
}
 else if (""String_Node_Str"".equals(attr)) {
Object childLastName=user.getValue(attr);
Object childFirstName=user.getValue(""String_Node_Str"");
Object childClasses=user.getValue(""String_Node_Str"");
if (childLastName instanceof JsonArray && childFirstName instanceof JsonArray && childClasses instanceof JsonArray&& ((JsonArray)childClasses).size() == ((JsonArray)childLastName).size() && ((JsonArray)childFirstName).size() == ((JsonArray)childLastName).size()) {
for (int j=0; j < ((JsonArray)childLastName).size(); j++) {
String mapping=structure.getExternalId() + ((JsonArray)childLastName).<String>get(j).trim() + ((JsonArray)childFirstName).<String>get(j).trim()+ ((JsonArray)childClasses).<String>get(j).trim()+ DEFAULT_STUDENT_SEED;
relativeStudentMapping(linkStudents,mapping);
}
}
 else if (childLastName instanceof String && childFirstName instanceof String && childClasses instanceof String) {
String mapping=structure.getExternalId() + childLastName.toString().trim() + childFirstName.toString().trim()+ childClasses.toString().trim()+ DEFAULT_STUDENT_SEED;
relativeStudentMapping(linkStudents,mapping);
}
 else {
handler.handle(new ResultMessage().error(""String_Node_Str""));
return;
}
}
}
importer.createOrUpdateUser(user,linkStudents);
break;
case ""String_Node_Str"":
importer.createOrUpdateGuest(user,classes.toArray(new String[classes.size()][2]));
break;
}
}
i++;
}
switch (profile) {
case ""String_Node_Str"":
importer.getPersEducNat().createAndLinkSubjects(structure.getExternalId());
break;
case ""String_Node_Str"":
importer.linkRelativeToClass(RELATIVE_PROFILE_EXTERNAL_ID);
importer.linkRelativeToStructure(RELATIVE_PROFILE_EXTERNAL_ID);
importer.addRelativeProperties(getSource());
break;
}
}
 catch (Exception e) {
handler.handle(new ResultMessage().error(""String_Node_Str""));
log.error(""String_Node_Str"",e);
}
}","public void start(final String profile,final Structure structure,String file,String charset,final Importer importer,final Handler<Message<JsonObject>> handler){
  importer.createOrUpdateProfile(STUDENT_PROFILE);
  importer.createOrUpdateProfile(RELATIVE_PROFILE);
  importer.createOrUpdateProfile(PERSONNEL_PROFILE);
  importer.createOrUpdateProfile(TEACHER_PROFILE);
  importer.createOrUpdateProfile(GUEST_PROFILE);
  DefaultFunctions.createOrUpdateFunctions(importer);
  final Validator validator=ManualFeeder.profiles.get(profile);
  try {
    CSVReader csvParser=getCsvReader(file,charset);
    final List<String> columns=new ArrayList<>();
    String[] strings;
    int i=0;
    while ((strings=csvParser.readNext()) != null) {
      if (i == 0) {
        columnsMapper.getColumsNames(strings,columns,handler);
      }
 else       if (!columns.isEmpty()) {
        JsonObject user=new JsonObject();
        user.putArray(""String_Node_Str"",new JsonArray().add(structure.getExternalId()));
        user.putArray(""String_Node_Str"",new JsonArray().add(profile));
        List<String[]> classes=new ArrayList<>();
        for (int j=0; j < strings.length; j++) {
          final String c=columns.get(j);
          final String v=strings[j].trim();
          if ((v.isEmpty() && !""String_Node_Str"".equals(c)) || (v.isEmpty() && ""String_Node_Str"".equals(c) && strings[j + 1].trim().isEmpty()))           continue;
switch (validator.getType(c)) {
case ""String_Node_Str"":
            if (""String_Node_Str"".equals(c)) {
              Matcher m=frenchDatePatter.matcher(v);
              if (m.find()) {
                user.putString(c,m.group(3) + ""String_Node_Str"" + m.group(2)+ ""String_Node_Str""+ m.group(1));
              }
 else {
                user.putString(c,v);
              }
            }
 else {
              user.putString(c,v);
            }
          break;
case ""String_Node_Str"":
        JsonArray a=user.getArray(c);
      if (a == null) {
        a=new JsonArray();
        user.putArray(c,a);
      }
    if ((""String_Node_Str"".equals(c) || ""String_Node_Str"".equals(c) || ""String_Node_Str"".equals(c)) && !v.startsWith(structure.getExternalId() + ""String_Node_Str"")) {
      a.add(structure.getExternalId() + ""String_Node_Str"" + v);
    }
 else {
      a.add(v);
    }
  break;
case ""String_Node_Str"":
user.putBoolean(c,""String_Node_Str"".equals(v.toLowerCase()));
break;
default :
Object o=user.getValue(c);
final String v2;
if (""String_Node_Str"".equals(c) && !v.startsWith(structure.getExternalId() + ""String_Node_Str"")) {
v2=structure.getExternalId() + ""String_Node_Str"" + v;
}
 else {
v2=v;
}
if (o != null) {
if (o instanceof JsonArray) {
((JsonArray)o).add(v2);
}
 else {
JsonArray array=new JsonArray();
array.add(o).add(v2);
user.putArray(c,array);
}
}
 else {
user.putString(c,v2);
}
}
if (""String_Node_Str"".equals(c)) {
String[] cc=v.split(""String_Node_Str"");
if (cc.length == 2 && !cc[1].matches(""String_Node_Str"")) {
final String fosEId=importer.getFieldOfStudy().get(cc[1]);
if (fosEId != null) {
cc[1]=fosEId;
}
}
String eId=structure.getExternalId() + '$' + cc[0];
structure.createClassIfAbsent(eId,cc[0]);
final String[] classId=new String[3];
classId[0]=structure.getExternalId();
classId[1]=eId;
classId[2]=(cc.length == 2) ? cc[1] : ""String_Node_Str"";
classes.add(classId);
}
}
String ca;
long seed;
JsonArray classesA;
Object co=user.getValue(""String_Node_Str"");
if (co != null && co instanceof JsonArray) {
classesA=(JsonArray)co;
}
 else if (co instanceof String) {
classesA=new JsonArray().add(co);
}
 else {
classesA=null;
}
if (""String_Node_Str"".equals(profile) && classesA != null && classesA.size() == 1) {
seed=defaultStudentSeed;
ca=classesA.get(0);
}
 else {
ca=String.valueOf(i);
seed=System.currentTimeMillis();
}
generateUserExternalId(user,ca,structure,seed);
if (""String_Node_Str"".equals(profile)) {
studentExternalIdMapping.put(getHashMapping(user,ca,structure,seed),user.getString(""String_Node_Str""));
}
switch (profile) {
case ""String_Node_Str"":
importer.createOrUpdatePersonnel(user,TEACHER_PROFILE_EXTERNAL_ID,user.getArray(""String_Node_Str""),classes.toArray(new String[classes.size()][2]),null,true,true);
break;
case ""String_Node_Str"":
importer.createOrUpdatePersonnel(user,PERSONNEL_PROFILE_EXTERNAL_ID,user.getArray(""String_Node_Str""),classes.toArray(new String[classes.size()][2]),null,true,true);
break;
case ""String_Node_Str"":
importer.createOrUpdateStudent(user,STUDENT_PROFILE_EXTERNAL_ID,null,null,classes.toArray(new String[classes.size()][2]),null,null,true,true);
break;
case ""String_Node_Str"":
JsonArray linkStudents=new JsonArray();
for (String attr : user.getFieldNames()) {
if (""String_Node_Str"".equals(attr)) {
Object o=user.getValue(attr);
if (o instanceof JsonArray) {
for (Object c : (JsonArray)o) {
linkStudents.add(c);
}
}
 else {
linkStudents.add(o);
}
}
 else if (""String_Node_Str"".equals(attr)) {
Object childUsername=user.getValue(attr);
Object childLastName=user.getValue(""String_Node_Str"");
Object childFirstName=user.getValue(""String_Node_Str"");
Object childClasses=user.getValue(""String_Node_Str"");
if (childUsername instanceof JsonArray && childLastName instanceof JsonArray && childFirstName instanceof JsonArray&& childClasses instanceof JsonArray&& ((JsonArray)childClasses).size() == ((JsonArray)childLastName).size() && ((JsonArray)childFirstName).size() == ((JsonArray)childLastName).size()) {
for (int j=0; j < ((JsonArray)childUsername).size(); j++) {
String mapping=structure.getExternalId() + ((JsonArray)childUsername).<String>get(j).trim() + ((JsonArray)childLastName).<String>get(j).trim()+ ((JsonArray)childFirstName).<String>get(j).trim()+ ((JsonArray)childClasses).<String>get(j).trim()+ defaultStudentSeed;
relativeStudentMapping(linkStudents,mapping);
}
}
 else if (childUsername instanceof String && childLastName instanceof String && childFirstName instanceof String&& childClasses instanceof String) {
String mapping=structure.getExternalId() + childLastName.toString().trim() + childFirstName.toString().trim()+ childClasses.toString().trim()+ defaultStudentSeed;
relativeStudentMapping(linkStudents,mapping);
}
 else {
handler.handle(new ResultMessage().error(""String_Node_Str""));
return;
}
}
 else if (""String_Node_Str"".equals(attr) && !user.getFieldNames().contains(""String_Node_Str"")) {
Object childLastName=user.getValue(attr);
Object childFirstName=user.getValue(""String_Node_Str"");
Object childClasses=user.getValue(""String_Node_Str"");
if (childLastName instanceof JsonArray && childFirstName instanceof JsonArray && childClasses instanceof JsonArray&& ((JsonArray)childClasses).size() == ((JsonArray)childLastName).size() && ((JsonArray)childFirstName).size() == ((JsonArray)childLastName).size()) {
for (int j=0; j < ((JsonArray)childLastName).size(); j++) {
String mapping=structure.getExternalId() + ((JsonArray)childLastName).<String>get(j).trim() + ((JsonArray)childFirstName).<String>get(j).trim()+ ((JsonArray)childClasses).<String>get(j).trim()+ defaultStudentSeed;
relativeStudentMapping(linkStudents,mapping);
}
}
 else if (childLastName instanceof String && childFirstName instanceof String && childClasses instanceof String) {
String mapping=structure.getExternalId() + childLastName.toString().trim() + childFirstName.toString().trim()+ childClasses.toString().trim()+ defaultStudentSeed;
relativeStudentMapping(linkStudents,mapping);
}
 else {
handler.handle(new ResultMessage().error(""String_Node_Str""));
return;
}
}
}
importer.createOrUpdateUser(user,linkStudents);
break;
case ""String_Node_Str"":
importer.createOrUpdateGuest(user,classes.toArray(new String[classes.size()][2]));
break;
}
}
i++;
}
switch (profile) {
case ""String_Node_Str"":
importer.getPersEducNat().createAndLinkSubjects(structure.getExternalId());
break;
case ""String_Node_Str"":
importer.linkRelativeToClass(RELATIVE_PROFILE_EXTERNAL_ID);
importer.linkRelativeToStructure(RELATIVE_PROFILE_EXTERNAL_ID);
importer.addRelativeProperties(getSource());
break;
}
}
 catch (Exception e) {
handler.handle(new ResultMessage().error(""String_Node_Str""));
log.error(""String_Node_Str"",e);
}
}",0.95324415551944
87129,"@Override public void launch(final Importer importer,final String path,final Handler<Message<JsonObject>> handler) throws Exception {
  parse(importer,path,handler);
}","@Override public void launch(final Importer importer,final String path,final Handler<Message<JsonObject>> handler) throws Exception {
  studentExternalIdMapping.clear();
  defaultStudentSeed=new Random().nextLong();
  parse(importer,path,handler);
}",0.6730769230769231
87130,"public CsvValidator(Vertx vertx,String acceptLanguage,JsonObject additionnalsMappings){
  super(acceptLanguage);
  this.columnsMapper=new ColumnsMapper(additionnalsMappings);
  this.mappingFinder=new MappingFinder(vertx);
  this.vertx=vertx;
}","public CsvValidator(Vertx vertx,String acceptLanguage,JsonObject additionnalsMappings){
  super(acceptLanguage);
  this.columnsMapper=new ColumnsMapper(additionnalsMappings);
  this.mappingFinder=new MappingFinder(vertx);
  this.vertx=vertx;
  defaultStudentSeed=new Random().nextLong();
}",0.9135338345864662
87131,"private void validateFile(final String path,final String profile,final List<String> columns,final JsonArray existExternalId,final String charset,final Handler<JsonObject> handler){
  final Validator validator=profiles.get(profile);
  getStructure(path.substring(0,path.lastIndexOf(File.separator)),new Handler<Structure>(){
    @Override public void handle(    final Structure structure){
      if (structure == null) {
        addError(profile,""String_Node_Str"");
        handler.handle(result);
        return;
      }
      try {
        CSVReader csvParser=getCsvReader(path,charset,1);
        String[] strings;
        int i=0;
        while ((strings=csvParser.readNext()) != null) {
          final JsonArray classesNames=new JsonArray();
          JsonObject user=new JsonObject();
          user.putArray(""String_Node_Str"",new JsonArray().add(structure.getExternalId()));
          user.putArray(""String_Node_Str"",new JsonArray().add(profile));
          List<String[]> classes=new ArrayList<>();
          for (int j=0; j < strings.length; j++) {
            if (j >= columns.size()) {
              addErrorByFile(profile,""String_Node_Str"",""String_Node_Str"" + i);
              return;
            }
            final String c=columns.get(j);
            final String v=strings[j].trim();
            if ((v.isEmpty() && !""String_Node_Str"".equals(c)) || (v.isEmpty() && ""String_Node_Str"".equals(c) && strings[j + 1].trim().isEmpty()))             continue;
switch (validator.getType(c)) {
case ""String_Node_Str"":
              if (""String_Node_Str"".equals(c)) {
                Matcher m=frenchDatePatter.matcher(v);
                if (m.find()) {
                  user.putString(c,m.group(3) + ""String_Node_Str"" + m.group(2)+ ""String_Node_Str""+ m.group(1));
                }
 else {
                  user.putString(c,v);
                }
              }
 else {
                user.putString(c,v);
              }
            break;
case ""String_Node_Str"":
          JsonArray a=user.getArray(c);
        if (a == null) {
          a=new JsonArray();
          user.putArray(c,a);
        }
      if ((""String_Node_Str"".equals(c) || ""String_Node_Str"".equals(c) || ""String_Node_Str"".equals(c)) && !v.startsWith(structure.getExternalId() + ""String_Node_Str"")) {
        a.add(structure.getExternalId() + ""String_Node_Str"" + v);
      }
 else {
        a.add(v);
      }
    break;
case ""String_Node_Str"":
  user.putBoolean(c,""String_Node_Str"".equals(v.toLowerCase()));
break;
default :
Object o=user.getValue(c);
final String v2;
if (""String_Node_Str"".equals(c) && !v.startsWith(structure.getExternalId() + ""String_Node_Str"")) {
v2=structure.getExternalId() + ""String_Node_Str"" + v;
}
 else {
v2=v;
}
if (o != null) {
if (o instanceof JsonArray) {
((JsonArray)o).add(v2);
}
 else {
JsonArray array=new JsonArray();
array.add(o).add(v2);
user.putArray(c,array);
}
}
 else {
user.putString(c,v2);
}
}
if (""String_Node_Str"".equals(c)) {
String eId=structure.getExternalId() + '$' + v;
String[] classId=new String[2];
classId[0]=structure.getExternalId();
classId[1]=eId;
classes.add(classId);
classesNames.addString(v);
}
}
String ca;
long seed;
JsonArray classesA;
Object co=user.getValue(""String_Node_Str"");
if (co != null && co instanceof JsonArray) {
classesA=(JsonArray)co;
}
 else if (co instanceof String) {
classesA=new JsonArray().add(co);
}
 else {
classesA=null;
}
if (""String_Node_Str"".equals(profile) && classesA != null && classesA.size() == 1) {
seed=CsvFeeder.DEFAULT_STUDENT_SEED;
ca=classesA.get(0);
}
 else {
ca=String.valueOf(i);
seed=System.currentTimeMillis();
}
final State state;
final String externalId=user.getString(""String_Node_Str"");
if (externalId == null || externalId.trim().isEmpty()) {
generateUserExternalId(user,ca,structure,seed);
state=State.NEW;
}
 else {
if (existExternalId.contains(externalId)) {
state=State.UPDATED;
}
 else {
state=State.NEW;
}
}
switch (profile) {
case ""String_Node_Str"":
JsonArray linkStudents=new JsonArray();
user.putArray(""String_Node_Str"",linkStudents);
for (String attr : user.getFieldNames()) {
if (""String_Node_Str"".equals(attr)) {
Object o=user.getValue(attr);
if (o instanceof JsonArray) {
for (Object c : (JsonArray)o) {
linkStudents.add(c);
}
}
 else {
linkStudents.add(o);
}
}
 else if (""String_Node_Str"".equals(attr)) {
Object childUsername=user.getValue(attr);
Object childLastName=user.getValue(""String_Node_Str"");
Object childFirstName=user.getValue(""String_Node_Str"");
Object childClasses=user.getValue(""String_Node_Str"");
if (childUsername instanceof JsonArray && childLastName instanceof JsonArray && childFirstName instanceof JsonArray&& childClasses instanceof JsonArray&& ((JsonArray)childClasses).size() == ((JsonArray)childLastName).size() && ((JsonArray)childFirstName).size() == ((JsonArray)childLastName).size()) {
for (int j=0; j < ((JsonArray)childUsername).size(); j++) {
String mapping=structure.getExternalId() + ((JsonArray)childUsername).<String>get(j).trim() + ((JsonArray)childLastName).<String>get(j).trim()+ ((JsonArray)childFirstName).<String>get(j).trim()+ ((JsonArray)childClasses).<String>get(j).trim()+ CsvFeeder.DEFAULT_STUDENT_SEED;
relativeStudentMapping(linkStudents,mapping);
}
}
 else if (childUsername instanceof String && childLastName instanceof String && childFirstName instanceof String&& childClasses instanceof String) {
String mapping=structure.getExternalId() + childLastName.toString().trim() + childFirstName.toString().trim()+ childClasses.toString().trim()+ CsvFeeder.DEFAULT_STUDENT_SEED;
relativeStudentMapping(linkStudents,mapping);
}
 else {
addError(profile,""String_Node_Str"");
handler.handle(result);
return;
}
}
 else if (""String_Node_Str"".equals(attr) && !user.getFieldNames().contains(""String_Node_Str"")) {
Object childLastName=user.getValue(attr);
Object childFirstName=user.getValue(""String_Node_Str"");
Object childClasses=user.getValue(""String_Node_Str"");
if (childLastName instanceof JsonArray && childFirstName instanceof JsonArray && childClasses instanceof JsonArray&& ((JsonArray)childClasses).size() == ((JsonArray)childLastName).size() && ((JsonArray)childFirstName).size() == ((JsonArray)childLastName).size()) {
for (int j=0; j < ((JsonArray)childLastName).size(); j++) {
String mapping=structure.getExternalId() + ((JsonArray)childLastName).<String>get(j) + ((JsonArray)childFirstName).<String>get(j)+ ((JsonArray)childClasses).<String>get(j)+ CsvFeeder.DEFAULT_STUDENT_SEED;
relativeStudentMapping(linkStudents,mapping);
}
}
 else if (childLastName instanceof String && childFirstName instanceof String && childClasses instanceof String) {
String mapping=structure.getExternalId() + childLastName.toString().trim() + childFirstName.toString().trim()+ childClasses.toString().trim()+ CsvFeeder.DEFAULT_STUDENT_SEED;
relativeStudentMapping(linkStudents,mapping);
}
 else {
addError(profile,""String_Node_Str"");
handler.handle(result);
return;
}
}
}
for (Object o : linkStudents) {
if (!(o instanceof String)) continue;
if (classesNamesMapping.get(o) != null) {
classesNames.addString(classesNamesMapping.get(o));
}
}
break;
}
String error=validator.validate(user,acceptLanguage);
if (error != null) {
log.warn(error);
addError(profile,error);
}
 else {
final String classesStr=Joiner.on(""String_Node_Str"").join(classesNames);
classesNamesMapping.put(user.getString(""String_Node_Str""),classesStr);
addUser(profile,user.putString(""String_Node_Str"",translate(state.name())).putString(""String_Node_Str"",translate(profile)).putString(""String_Node_Str"",classesStr));
}
i++;
}
}
 catch (Exception e) {
addError(profile,""String_Node_Str"");
log.error(""String_Node_Str"",e);
}
handler.handle(result);
}
}
);
}","private void validateFile(final String path,final String profile,final List<String> columns,final JsonArray existExternalId,final String charset,final Handler<JsonObject> handler){
  final Validator validator=profiles.get(profile);
  getStructure(path.substring(0,path.lastIndexOf(File.separator)),new Handler<Structure>(){
    @Override public void handle(    final Structure structure){
      if (structure == null) {
        addError(profile,""String_Node_Str"");
        handler.handle(result);
        return;
      }
      try {
        CSVReader csvParser=getCsvReader(path,charset,1);
        String[] strings;
        int i=0;
        while ((strings=csvParser.readNext()) != null) {
          final JsonArray classesNames=new JsonArray();
          JsonObject user=new JsonObject();
          user.putArray(""String_Node_Str"",new JsonArray().add(structure.getExternalId()));
          user.putArray(""String_Node_Str"",new JsonArray().add(profile));
          List<String[]> classes=new ArrayList<>();
          for (int j=0; j < strings.length; j++) {
            if (j >= columns.size()) {
              addErrorByFile(profile,""String_Node_Str"",""String_Node_Str"" + i);
              return;
            }
            final String c=columns.get(j);
            final String v=strings[j].trim();
            if ((v.isEmpty() && !""String_Node_Str"".equals(c)) || (v.isEmpty() && ""String_Node_Str"".equals(c) && strings[j + 1].trim().isEmpty()))             continue;
switch (validator.getType(c)) {
case ""String_Node_Str"":
              if (""String_Node_Str"".equals(c)) {
                Matcher m=frenchDatePatter.matcher(v);
                if (m.find()) {
                  user.putString(c,m.group(3) + ""String_Node_Str"" + m.group(2)+ ""String_Node_Str""+ m.group(1));
                }
 else {
                  user.putString(c,v);
                }
              }
 else {
                user.putString(c,v);
              }
            break;
case ""String_Node_Str"":
          JsonArray a=user.getArray(c);
        if (a == null) {
          a=new JsonArray();
          user.putArray(c,a);
        }
      if ((""String_Node_Str"".equals(c) || ""String_Node_Str"".equals(c) || ""String_Node_Str"".equals(c)) && !v.startsWith(structure.getExternalId() + ""String_Node_Str"")) {
        a.add(structure.getExternalId() + ""String_Node_Str"" + v);
      }
 else {
        a.add(v);
      }
    break;
case ""String_Node_Str"":
  user.putBoolean(c,""String_Node_Str"".equals(v.toLowerCase()));
break;
default :
Object o=user.getValue(c);
final String v2;
if (""String_Node_Str"".equals(c) && !v.startsWith(structure.getExternalId() + ""String_Node_Str"")) {
v2=structure.getExternalId() + ""String_Node_Str"" + v;
}
 else {
v2=v;
}
if (o != null) {
if (o instanceof JsonArray) {
((JsonArray)o).add(v2);
}
 else {
JsonArray array=new JsonArray();
array.add(o).add(v2);
user.putArray(c,array);
}
}
 else {
user.putString(c,v2);
}
}
if (""String_Node_Str"".equals(c)) {
String eId=structure.getExternalId() + '$' + v;
String[] classId=new String[2];
classId[0]=structure.getExternalId();
classId[1]=eId;
classes.add(classId);
classesNames.addString(v);
}
}
String ca;
long seed;
JsonArray classesA;
Object co=user.getValue(""String_Node_Str"");
if (co != null && co instanceof JsonArray) {
classesA=(JsonArray)co;
}
 else if (co instanceof String) {
classesA=new JsonArray().add(co);
}
 else {
classesA=null;
}
if (""String_Node_Str"".equals(profile) && classesA != null && classesA.size() == 1) {
seed=defaultStudentSeed;
ca=classesA.get(0);
}
 else {
ca=String.valueOf(i);
seed=System.currentTimeMillis();
}
final State state;
final String externalId=user.getString(""String_Node_Str"");
if (externalId == null || externalId.trim().isEmpty()) {
generateUserExternalId(user,ca,structure,seed);
state=State.NEW;
}
 else {
if (existExternalId.contains(externalId)) {
state=State.UPDATED;
studentExternalIdMapping.put(getHashMapping(user,ca,structure,seed),externalId);
}
 else {
state=State.NEW;
}
}
switch (profile) {
case ""String_Node_Str"":
JsonArray linkStudents=new JsonArray();
user.putArray(""String_Node_Str"",linkStudents);
for (String attr : user.getFieldNames()) {
if (""String_Node_Str"".equals(attr)) {
Object o=user.getValue(attr);
if (o instanceof JsonArray) {
for (Object c : (JsonArray)o) {
linkStudents.add(c);
}
}
 else {
linkStudents.add(o);
}
}
 else if (""String_Node_Str"".equals(attr)) {
Object childUsername=user.getValue(attr);
Object childLastName=user.getValue(""String_Node_Str"");
Object childFirstName=user.getValue(""String_Node_Str"");
Object childClasses=user.getValue(""String_Node_Str"");
if (childUsername instanceof JsonArray && childLastName instanceof JsonArray && childFirstName instanceof JsonArray&& childClasses instanceof JsonArray&& ((JsonArray)childClasses).size() == ((JsonArray)childLastName).size() && ((JsonArray)childFirstName).size() == ((JsonArray)childLastName).size()) {
for (int j=0; j < ((JsonArray)childUsername).size(); j++) {
String mapping=structure.getExternalId() + ((JsonArray)childUsername).<String>get(j).trim() + ((JsonArray)childLastName).<String>get(j).trim()+ ((JsonArray)childFirstName).<String>get(j).trim()+ ((JsonArray)childClasses).<String>get(j).trim()+ defaultStudentSeed;
relativeStudentMapping(linkStudents,mapping);
}
}
 else if (childUsername instanceof String && childLastName instanceof String && childFirstName instanceof String&& childClasses instanceof String) {
String mapping=structure.getExternalId() + childLastName.toString().trim() + childFirstName.toString().trim()+ childClasses.toString().trim()+ defaultStudentSeed;
relativeStudentMapping(linkStudents,mapping);
}
 else {
addError(profile,""String_Node_Str"");
handler.handle(result);
return;
}
}
 else if (""String_Node_Str"".equals(attr) && !user.getFieldNames().contains(""String_Node_Str"")) {
Object childLastName=user.getValue(attr);
Object childFirstName=user.getValue(""String_Node_Str"");
Object childClasses=user.getValue(""String_Node_Str"");
if (childLastName instanceof JsonArray && childFirstName instanceof JsonArray && childClasses instanceof JsonArray&& ((JsonArray)childClasses).size() == ((JsonArray)childLastName).size() && ((JsonArray)childFirstName).size() == ((JsonArray)childLastName).size()) {
for (int j=0; j < ((JsonArray)childLastName).size(); j++) {
String mapping=structure.getExternalId() + ((JsonArray)childLastName).<String>get(j) + ((JsonArray)childFirstName).<String>get(j)+ ((JsonArray)childClasses).<String>get(j)+ defaultStudentSeed;
relativeStudentMapping(linkStudents,mapping);
}
}
 else if (childLastName instanceof String && childFirstName instanceof String && childClasses instanceof String) {
String mapping=structure.getExternalId() + childLastName.toString().trim() + childFirstName.toString().trim()+ childClasses.toString().trim()+ defaultStudentSeed;
relativeStudentMapping(linkStudents,mapping);
}
 else {
addError(profile,""String_Node_Str"");
handler.handle(result);
return;
}
}
}
for (Object o : linkStudents) {
if (!(o instanceof String)) continue;
if (classesNamesMapping.get(o) != null) {
classesNames.addString(classesNamesMapping.get(o));
}
}
break;
}
String error=validator.validate(user,acceptLanguage);
if (error != null) {
log.warn(error);
addError(profile,error);
}
 else {
final String classesStr=Joiner.on(""String_Node_Str"").join(classesNames);
classesNamesMapping.put(user.getString(""String_Node_Str""),classesStr);
addUser(profile,user.putString(""String_Node_Str"",translate(state.name())).putString(""String_Node_Str"",translate(profile)).putString(""String_Node_Str"",classesStr));
}
i++;
}
}
 catch (Exception e) {
addError(profile,""String_Node_Str"");
log.error(""String_Node_Str"",e);
}
handler.handle(result);
}
}
);
}",0.9790674926638409
87132,"void addEleve(JsonObject currentEntity){
  final String epj=currentEntity.getString(""String_Node_Str"");
  if (isEmpty(epj)) {
    report.addError(""String_Node_Str"");
    return;
  }
  final String codeGroup=currentEntity.getString(""String_Node_Str"");
  final String codeDiv=currentEntity.getString(""String_Node_Str"");
  JsonArray groups;
  if (isNotEmpty(codeGroup)) {
    JsonObject group=this.groups.get(codeDiv + codeGroup);
    if (group == null) {
      report.addError(""String_Node_Str"");
      return;
    }
    final String name=group.getString(""String_Node_Str"") + ""String_Node_Str"" + group.getString(CODE);
    txXDT.add(STUDENTS_TO_GROUPS,new JsonObject().putString(""String_Node_Str"",epj).putString(""String_Node_Str"",structureExternalId + ""String_Node_Str"" + name).putString(""String_Node_Str"",UDT).putNumber(""String_Node_Str"",importTimestamp).putNumber(""String_Node_Str"",endStudents).putNumber(""String_Node_Str"",importTimestamp));
    groups=group.getArray(""String_Node_Str"");
  }
 else {
    JsonObject classe=classes.get(codeDiv);
    if (classe == null) {
      report.addError(""String_Node_Str"");
      return;
    }
    groups=classe.getArray(""String_Node_Str"");
  }
  if (groups != null) {
    for (    Object o2 : groups) {
      txXDT.add(STUDENTS_TO_GROUPS,new JsonObject().putString(""String_Node_Str"",epj).putString(""String_Node_Str"",structureExternalId + ""String_Node_Str"" + o2.toString()).putString(""String_Node_Str"",UDT).putNumber(""String_Node_Str"",importTimestamp).putNumber(""String_Node_Str"",endStudents).putNumber(""String_Node_Str"",importTimestamp));
    }
  }
}","void addEleve(JsonObject currentEntity){
  final String epj=currentEntity.getString(""String_Node_Str"");
  if (isEmpty(epj)) {
    report.addErrorWithParams(""String_Node_Str"",currentEntity.encode());
    return;
  }
  final String codeGroup=currentEntity.getString(""String_Node_Str"");
  final String codeDiv=currentEntity.getString(""String_Node_Str"");
  JsonArray groups;
  if (isNotEmpty(codeGroup)) {
    JsonObject group=this.groups.get(codeDiv + codeGroup);
    if (group == null) {
      report.addError(""String_Node_Str"");
      return;
    }
    final String name=group.getString(""String_Node_Str"") + ""String_Node_Str"" + group.getString(CODE);
    txXDT.add(STUDENTS_TO_GROUPS,new JsonObject().putString(""String_Node_Str"",epj).putString(""String_Node_Str"",structureExternalId + ""String_Node_Str"" + name).putString(""String_Node_Str"",UDT).putNumber(""String_Node_Str"",importTimestamp).putNumber(""String_Node_Str"",endStudents).putNumber(""String_Node_Str"",importTimestamp));
    groups=group.getArray(""String_Node_Str"");
  }
 else {
    JsonObject classe=classes.get(codeDiv);
    if (classe == null) {
      report.addError(""String_Node_Str"");
      return;
    }
    groups=classe.getArray(""String_Node_Str"");
  }
  if (groups != null) {
    for (    Object o2 : groups) {
      txXDT.add(STUDENTS_TO_GROUPS,new JsonObject().putString(""String_Node_Str"",epj).putString(""String_Node_Str"",structureExternalId + ""String_Node_Str"" + o2.toString()).putString(""String_Node_Str"",UDT).putNumber(""String_Node_Str"",importTimestamp).putNumber(""String_Node_Str"",endStudents).putNumber(""String_Node_Str"",importTimestamp));
    }
  }
}",0.9785113671753348
87133,"private void initPostCreate(final String classId,final JsonArray userIds,final boolean welcomeMessage,final HttpServerRequest request){
  ApplicationUtils.sendModifiedUserGroup(eb,userIds,new Handler<Message<JsonObject>>(){
    @Override public void handle(    Message<JsonObject> message){
      schoolService.getByClassId(classId,new Handler<Either<String,JsonObject>>(){
        @Override public void handle(        Either<String,JsonObject> s){
          if (s.isRight()) {
            JsonObject j=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",s.right().getValue().getString(""String_Node_Str""));
            eb.send(""String_Node_Str"",j);
          }
        }
      }
);
      if (welcomeMessage) {
        JsonObject params=new JsonObject();
        conversationNotification.notify(request,""String_Node_Str"",userIds,null,""String_Node_Str"",""String_Node_Str"",params,new Handler<Either<String,JsonObject>>(){
          @Override public void handle(          Either<String,JsonObject> r){
            if (r.isLeft()) {
              log.error(r.left().getValue());
            }
          }
        }
);
      }
    }
  }
);
}","private void initPostCreate(final String classId,final JsonArray userIds,final boolean welcomeMessage,final HttpServerRequest request){
  ApplicationUtils.sendModifiedUserGroup(eb,userIds,new Handler<Message<JsonObject>>(){
    @Override public void handle(    Message<JsonObject> message){
      schoolService.getByClassId(classId,new Handler<Either<String,JsonObject>>(){
        @Override public void handle(        Either<String,JsonObject> s){
          if (s.isRight()) {
            JsonObject j=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",s.right().getValue().getString(""String_Node_Str""));
            eb.send(""String_Node_Str"",j,new Handler<Message<JsonObject>>(){
              public void handle(              Message<JsonObject> event){
                if (""String_Node_Str"".equals(event.body().getString(""String_Node_Str"",""String_Node_Str""))) {
                  log.error(""String_Node_Str"");
                }
 else                 if (welcomeMessage) {
                  JsonObject params=new JsonObject();
                  conversationNotification.notify(request,""String_Node_Str"",userIds,null,""String_Node_Str"",""String_Node_Str"",params,new Handler<Either<String,JsonObject>>(){
                    public void handle(                    Either<String,JsonObject> r){
                      if (r.isLeft()) {
                        log.error(r.left().getValue());
                      }
                    }
                  }
);
                }
              }
            }
);
          }
        }
      }
);
    }
  }
);
}",0.7463009743774811
87134,"/** 
 * Send daily notification emails for all users.
 * @param dayDelta : When to aggregate, delta from now.
 * @param handler : Handles the results, emails sent / users KO
 */
public void sendDailyMails(int dayDelta,final Handler<Either<String,JsonObject>> handler){
  final HttpServerRequest request=new JsonHttpServerRequest(new JsonObject());
  final AtomicInteger userPagination=new AtomicInteger(0);
  final Calendar dayDate=Calendar.getInstance();
  dayDate.add(Calendar.DAY_OF_MONTH,dayDelta);
  dayDate.set(Calendar.HOUR_OF_DAY,0);
  dayDate.set(Calendar.MINUTE,0);
  dayDate.set(Calendar.SECOND,0);
  dayDate.set(Calendar.MILLISECOND,0);
  final JsonObject results=new JsonObject().putNumber(""String_Node_Str"",0).putNumber(""String_Node_Str"",0);
  final JsonObject notificationsDefaults=new JsonObject();
  final Handler<Boolean> userContinuationHandler=new Handler<Boolean>(){
    private final Handler<Boolean> continuation=this;
    private final Handler<JsonArray> usersHandler=new Handler<JsonArray>(){
      public void handle(      final JsonArray users){
        final int nbUsers=users.size();
        if (nbUsers == 0) {
          continuation.handle(false);
          return;
        }
        final AtomicInteger usersCountdown=new AtomicInteger(nbUsers);
        final VoidHandler usersEndHandler=new VoidHandler(){
          protected void handle(){
            if (usersCountdown.decrementAndGet() <= 0) {
              continuation.handle(nbUsers == USERS_LIMIT);
            }
          }
        }
;
        final JsonArray userIds=new JsonArray();
        for (        Object userObj : users)         userIds.add(((JsonObject)userObj).getString(""String_Node_Str"",""String_Node_Str""));
        getUsersPreferences(userIds,new Handler<JsonArray>(){
          public void handle(          JsonArray preferences){
            int i=0;
            for (            Object userObj : users) {
              final JsonObject user=(JsonObject)userObj;
              final JsonObject userPrefs=(JsonObject)preferences.get(i);
              getUserNotifications(user.getString(""String_Node_Str"",""String_Node_Str""),dayDate.getTime(),new Handler<JsonArray>(){
                public void handle(                JsonArray notifications){
                  if (notifications.size() == 0) {
                    usersEndHandler.handle(null);
                    return;
                  }
                  SimpleDateFormat formatter=new SimpleDateFormat(""String_Node_Str"",Locale.FRANCE);
                  final JsonArray dates=new JsonArray();
                  final JsonArray templates=new JsonArray();
                  for (                  Object notificationObj : notifications) {
                    JsonObject notification=(JsonObject)notificationObj;
                    final String notificationName=notification.getString(""String_Node_Str"",""String_Node_Str"").toLowerCase() + ""String_Node_Str"" + notification.getString(""String_Node_Str"",""String_Node_Str"").toLowerCase();
                    if (notificationsDefaults.getObject(notificationName) == null)                     continue;
                    JsonObject notificationPreference=userPrefs.getObject(""String_Node_Str"",new JsonObject()).getObject(""String_Node_Str"",new JsonObject()).getObject(notificationName,new JsonObject());
                    if (TimelineNotificationsLoader.Frequencies.DAILY.name().equals(notificationPrefsMixin(""String_Node_Str"",notificationPreference,notificationsDefaults.getObject(notificationName))) && !TimelineNotificationsLoader.Restrictions.INTERNAL.name().equals(notificationPrefsMixin(""String_Node_Str"",notificationPreference,notificationsDefaults.getObject(notificationName)))) {
                      templates.add(new JsonObject().putString(""String_Node_Str"",notificationsDefaults.getObject(notificationName,new JsonObject()).getString(""String_Node_Str"",""String_Node_Str"")).putObject(""String_Node_Str"",notification.getObject(""String_Node_Str"",new JsonObject())));
                      dates.add(formatter.format(MongoDb.parseIsoDate(notification.getObject(""String_Node_Str""))));
                    }
                  }
                  if (templates.size() > 0) {
                    JsonObject templateParams=new JsonObject().putArray(""String_Node_Str"",templates).putArray(""String_Node_Str"",dates);
                    processTimelineTemplate(templateParams,""String_Node_Str"",""String_Node_Str"",new Handler<String>(){
                      public void handle(                      final String processedTemplate){
                        final Handler<Message<JsonObject>> completionHandler=new Handler<Message<JsonObject>>(){
                          public void handle(                          Message<JsonObject> event){
                            if (""String_Node_Str"".equals(event.body().getString(""String_Node_Str"",""String_Node_Str""))) {
                              log.error(""String_Node_Str"" + event.body());
                              results.putNumber(""String_Node_Str"",results.getInteger(""String_Node_Str"") + 1);
                            }
 else {
                              results.putNumber(""String_Node_Str"",results.getInteger(""String_Node_Str"") + 1);
                            }
                            usersEndHandler.handle(null);
                          }
                        }
;
                        JsonArray keys=new JsonArray().add(""String_Node_Str"");
                        translateTimeline(keys,""String_Node_Str"",new Handler<JsonArray>(){
                          public void handle(                          JsonArray translations){
                            emailSender.sendEmail(request,user.getString(""String_Node_Str"",""String_Node_Str""),null,null,translations.get(0).toString(),processedTemplate,null,false,completionHandler);
                          }
                        }
);
                      }
                    }
);
                  }
 else {
                    usersEndHandler.handle(null);
                  }
                }
              }
);
            }
          }
        }
);
      }
    }
;
    public void handle(    Boolean continuation){
      if (continuation) {
        getImpactedUsers(userPagination.getAndIncrement(),new Handler<Either<String,JsonArray>>(){
          public void handle(          Either<String,JsonArray> event){
            if (event.isLeft()) {
              log.error(""String_Node_Str"" + event.left().getValue());
              handler.handle(new Either.Left<String,JsonObject>(event.left().getValue()));
            }
 else {
              JsonArray users=event.right().getValue();
              usersHandler.handle(users);
            }
          }
        }
);
      }
 else {
        handler.handle(new Either.Right<String,JsonObject>(results));
      }
    }
  }
;
  getNotificationsDefaults(new Handler<JsonArray>(){
    public void handle(    final JsonArray notifications){
      if (notifications == null) {
        log.error(""String_Node_Str"");
        return;
      }
 else {
        for (        Object notifObj : notifications) {
          final JsonObject notif=(JsonObject)notifObj;
          notificationsDefaults.putObject(notif.getString(""String_Node_Str"",""String_Node_Str""),notif);
        }
        userContinuationHandler.handle(true);
      }
    }
  }
);
}","/** 
 * Send daily notification emails for all users.
 * @param dayDelta : When to aggregate, delta from now.
 * @param handler : Handles the results, emails sent / users KO
 */
public void sendDailyMails(int dayDelta,final Handler<Either<String,JsonObject>> handler){
  final HttpServerRequest request=new JsonHttpServerRequest(new JsonObject());
  final AtomicInteger userPagination=new AtomicInteger(0);
  final Calendar dayDate=Calendar.getInstance();
  dayDate.add(Calendar.DAY_OF_MONTH,dayDelta);
  dayDate.set(Calendar.HOUR_OF_DAY,0);
  dayDate.set(Calendar.MINUTE,0);
  dayDate.set(Calendar.SECOND,0);
  dayDate.set(Calendar.MILLISECOND,0);
  final JsonObject results=new JsonObject().putNumber(""String_Node_Str"",0).putNumber(""String_Node_Str"",0);
  final JsonObject notificationsDefaults=new JsonObject();
  final Handler<Boolean> userContinuationHandler=new Handler<Boolean>(){
    private final Handler<Boolean> continuation=this;
    private final Handler<JsonArray> usersHandler=new Handler<JsonArray>(){
      public void handle(      final JsonArray users){
        final int nbUsers=users.size();
        if (nbUsers == 0) {
          continuation.handle(false);
          return;
        }
        final AtomicInteger usersCountdown=new AtomicInteger(nbUsers);
        final VoidHandler usersEndHandler=new VoidHandler(){
          protected void handle(){
            if (usersCountdown.decrementAndGet() <= 0) {
              continuation.handle(nbUsers == USERS_LIMIT);
            }
          }
        }
;
        final JsonArray userIds=new JsonArray();
        for (        Object userObj : users)         userIds.add(((JsonObject)userObj).getString(""String_Node_Str"",""String_Node_Str""));
        getUsersPreferences(userIds,new Handler<JsonArray>(){
          public void handle(          JsonArray preferences){
            for (            Object userObj : preferences) {
              final JsonObject userPrefs=(JsonObject)userObj;
              getUserNotifications(userPrefs.getString(""String_Node_Str"",""String_Node_Str""),dayDate.getTime(),new Handler<JsonArray>(){
                public void handle(                JsonArray notifications){
                  if (notifications.size() == 0) {
                    usersEndHandler.handle(null);
                    return;
                  }
                  SimpleDateFormat formatter=new SimpleDateFormat(""String_Node_Str"",Locale.FRANCE);
                  final JsonArray dates=new JsonArray();
                  final JsonArray templates=new JsonArray();
                  for (                  Object notificationObj : notifications) {
                    JsonObject notification=(JsonObject)notificationObj;
                    final String notificationName=notification.getString(""String_Node_Str"",""String_Node_Str"").toLowerCase() + ""String_Node_Str"" + notification.getString(""String_Node_Str"",""String_Node_Str"").toLowerCase();
                    if (notificationsDefaults.getObject(notificationName) == null)                     continue;
                    JsonObject notificationPreference=userPrefs.getObject(""String_Node_Str"",new JsonObject()).getObject(""String_Node_Str"",new JsonObject()).getObject(notificationName,new JsonObject());
                    if (TimelineNotificationsLoader.Frequencies.DAILY.name().equals(notificationPrefsMixin(""String_Node_Str"",notificationPreference,notificationsDefaults.getObject(notificationName))) && !TimelineNotificationsLoader.Restrictions.INTERNAL.name().equals(notificationPrefsMixin(""String_Node_Str"",notificationPreference,notificationsDefaults.getObject(notificationName)))) {
                      templates.add(new JsonObject().putString(""String_Node_Str"",notificationsDefaults.getObject(notificationName,new JsonObject()).getString(""String_Node_Str"",""String_Node_Str"")).putObject(""String_Node_Str"",notification.getObject(""String_Node_Str"",new JsonObject())));
                      dates.add(formatter.format(MongoDb.parseIsoDate(notification.getObject(""String_Node_Str""))));
                    }
                  }
                  if (templates.size() > 0) {
                    JsonObject templateParams=new JsonObject().putArray(""String_Node_Str"",templates).putArray(""String_Node_Str"",dates);
                    processTimelineTemplate(templateParams,""String_Node_Str"",""String_Node_Str"",new Handler<String>(){
                      public void handle(                      final String processedTemplate){
                        final Handler<Message<JsonObject>> completionHandler=new Handler<Message<JsonObject>>(){
                          public void handle(                          Message<JsonObject> event){
                            if (""String_Node_Str"".equals(event.body().getString(""String_Node_Str"",""String_Node_Str""))) {
                              log.error(""String_Node_Str"" + event.body());
                              results.putNumber(""String_Node_Str"",results.getInteger(""String_Node_Str"") + 1);
                            }
 else {
                              results.putNumber(""String_Node_Str"",results.getInteger(""String_Node_Str"") + 1);
                            }
                            usersEndHandler.handle(null);
                          }
                        }
;
                        JsonArray keys=new JsonArray().add(""String_Node_Str"");
                        translateTimeline(keys,""String_Node_Str"",new Handler<JsonArray>(){
                          public void handle(                          JsonArray translations){
                            emailSender.sendEmail(request,userPrefs.getString(""String_Node_Str"",""String_Node_Str""),null,null,translations.get(0).toString(),processedTemplate,null,false,completionHandler);
                          }
                        }
);
                      }
                    }
);
                  }
 else {
                    usersEndHandler.handle(null);
                  }
                }
              }
);
            }
          }
        }
);
      }
    }
;
    public void handle(    Boolean continuation){
      if (continuation) {
        getImpactedUsers(userPagination.getAndIncrement(),new Handler<Either<String,JsonArray>>(){
          public void handle(          Either<String,JsonArray> event){
            if (event.isLeft()) {
              log.error(""String_Node_Str"" + event.left().getValue());
              handler.handle(new Either.Left<String,JsonObject>(event.left().getValue()));
            }
 else {
              JsonArray users=event.right().getValue();
              usersHandler.handle(users);
            }
          }
        }
);
      }
 else {
        handler.handle(new Either.Right<String,JsonObject>(results));
      }
    }
  }
;
  getNotificationsDefaults(new Handler<JsonArray>(){
    public void handle(    final JsonArray notifications){
      if (notifications == null) {
        log.error(""String_Node_Str"");
        return;
      }
 else {
        for (        Object notifObj : notifications) {
          final JsonObject notif=(JsonObject)notifObj;
          notificationsDefaults.putObject(notif.getString(""String_Node_Str"",""String_Node_Str""),notif);
        }
        userContinuationHandler.handle(true);
      }
    }
  }
);
}",0.9893682694286302
87135,"/** 
 * Sends weekly notification emails for all users.
 * @param dayDelta : Day from which to aggregate, delta from now.
 * @param handler : Handles the results, emails sent / users KO
 */
public void sendWeeklyMails(int dayDelta,final Handler<Either<String,JsonObject>> handler){
  final HttpServerRequest request=new JsonHttpServerRequest(new JsonObject());
  final AtomicInteger userPagination=new AtomicInteger(0);
  final Calendar weekDate=Calendar.getInstance();
  weekDate.add(Calendar.DAY_OF_MONTH,dayDelta - 6);
  weekDate.set(Calendar.HOUR_OF_DAY,0);
  weekDate.set(Calendar.MINUTE,0);
  weekDate.set(Calendar.SECOND,0);
  weekDate.set(Calendar.MILLISECOND,0);
  final JsonObject results=new JsonObject().putNumber(""String_Node_Str"",0).putNumber(""String_Node_Str"",0);
  final JsonObject notificationsDefaults=new JsonObject();
  final Handler<Boolean> userContinuationHandler=new Handler<Boolean>(){
    private final Handler<Boolean> continuation=this;
    private final Handler<JsonArray> usersHandler=new Handler<JsonArray>(){
      public void handle(      final JsonArray users){
        final int nbUsers=users.size();
        if (nbUsers == 0) {
          continuation.handle(false);
          return;
        }
        final AtomicInteger usersCountdown=new AtomicInteger(nbUsers);
        final VoidHandler usersEndHandler=new VoidHandler(){
          protected void handle(){
            if (usersCountdown.decrementAndGet() <= 0) {
              continuation.handle(nbUsers == USERS_LIMIT);
            }
          }
        }
;
        final JsonArray userIds=new JsonArray();
        for (        Object userObj : users)         userIds.add(((JsonObject)userObj).getString(""String_Node_Str"",""String_Node_Str""));
        getUsersPreferences(userIds,new Handler<JsonArray>(){
          public void handle(          JsonArray preferences){
            int i=0;
            for (            Object userObj : users) {
              final JsonObject user=(JsonObject)userObj;
              final JsonObject userPrefs=(JsonObject)preferences.get(i);
              getAggregatedUserNotifications(user.getString(""String_Node_Str"",""String_Node_Str""),weekDate.getTime(),new Handler<JsonArray>(){
                public void handle(                JsonArray notifications){
                  if (notifications.size() == 0) {
                    usersEndHandler.handle(null);
                    return;
                  }
                  final JsonArray weeklyNotifications=new JsonArray();
                  for (                  Object notificationObj : notifications) {
                    JsonObject notification=(JsonObject)notificationObj;
                    final String notificationName=notification.getString(""String_Node_Str"",""String_Node_Str"").toLowerCase() + ""String_Node_Str"" + notification.getString(""String_Node_Str"",""String_Node_Str"").toLowerCase();
                    if (notificationsDefaults.getObject(notificationName) == null)                     continue;
                    JsonObject notificationPreference=userPrefs.getObject(""String_Node_Str"",new JsonObject()).getObject(""String_Node_Str"",new JsonObject()).getObject(notificationName,new JsonObject());
                    if (TimelineNotificationsLoader.Frequencies.WEEKLY.name().equals(notificationPrefsMixin(""String_Node_Str"",notificationPreference,notificationsDefaults.getObject(notificationName))) && !TimelineNotificationsLoader.Restrictions.INTERNAL.name().equals(notificationPrefsMixin(""String_Node_Str"",notificationPreference,notificationsDefaults.getObject(notificationName)))) {
                      notification.putString(""String_Node_Str"",notificationName);
                      weeklyNotifications.add(notification);
                    }
                  }
                  final JsonObject weeklyNotificationsObj=new JsonObject();
                  final JsonArray weeklyNotificationsGroupedArray=new JsonArray();
                  for (                  Object notif : weeklyNotifications) {
                    JsonObject notification=(JsonObject)notif;
                    if (!weeklyNotificationsObj.containsField(notification.getString(""String_Node_Str"").toLowerCase()))                     weeklyNotificationsObj.putObject(notification.getString(""String_Node_Str"").toLowerCase(),new JsonObject().putString(""String_Node_Str"",notificationsDefaults.getObject(notification.getString(""String_Node_Str"")).getString(""String_Node_Str"",""String_Node_Str"")).putArray(""String_Node_Str"",new JsonArray()));
                    weeklyNotificationsObj.getObject(notification.getString(""String_Node_Str"").toLowerCase()).getArray((""String_Node_Str""),new JsonArray()).add(notification);
                  }
                  for (                  String key : weeklyNotificationsObj.toMap().keySet()) {
                    weeklyNotificationsGroupedArray.add(new JsonObject().putString(""String_Node_Str"",key).putString(""String_Node_Str"",weeklyNotificationsObj.getObject(key).getString(""String_Node_Str"",""String_Node_Str"")).putArray(""String_Node_Str"",weeklyNotificationsObj.getObject(key).getArray(""String_Node_Str"")));
                  }
                  if (weeklyNotifications.size() > 0) {
                    JsonObject templateParams=new JsonObject().putArray(""String_Node_Str"",weeklyNotificationsGroupedArray);
                    processTimelineTemplate(templateParams,""String_Node_Str"",""String_Node_Str"",new Handler<String>(){
                      public void handle(                      final String processedTemplate){
                        final Handler<Message<JsonObject>> completionHandler=new Handler<Message<JsonObject>>(){
                          public void handle(                          Message<JsonObject> event){
                            if (""String_Node_Str"".equals(event.body().getString(""String_Node_Str"",""String_Node_Str""))) {
                              log.error(""String_Node_Str"" + event.body());
                              results.putNumber(""String_Node_Str"",results.getInteger(""String_Node_Str"") + 1);
                            }
 else {
                              results.putNumber(""String_Node_Str"",results.getInteger(""String_Node_Str"") + 1);
                            }
                            usersEndHandler.handle(null);
                          }
                        }
;
                        JsonArray keys=new JsonArray().add(""String_Node_Str"");
                        translateTimeline(keys,""String_Node_Str"",new Handler<JsonArray>(){
                          public void handle(                          JsonArray translations){
                            emailSender.sendEmail(request,user.getString(""String_Node_Str"",""String_Node_Str""),null,null,translations.get(0).toString(),processedTemplate,null,false,completionHandler);
                          }
                        }
);
                      }
                    }
);
                  }
 else {
                    usersEndHandler.handle(null);
                  }
                }
              }
);
            }
          }
        }
);
      }
    }
;
    public void handle(    Boolean continuation){
      if (continuation) {
        getImpactedUsers(userPagination.getAndIncrement(),new Handler<Either<String,JsonArray>>(){
          public void handle(          Either<String,JsonArray> event){
            if (event.isLeft()) {
              log.error(""String_Node_Str"" + event.left().getValue());
              handler.handle(new Either.Left<String,JsonObject>(event.left().getValue()));
            }
 else {
              JsonArray users=event.right().getValue();
              usersHandler.handle(users);
            }
          }
        }
);
      }
 else {
        handler.handle(new Either.Right<String,JsonObject>(results));
      }
    }
  }
;
  getNotificationsDefaults(new Handler<JsonArray>(){
    public void handle(    final JsonArray notifications){
      if (notifications == null) {
        log.error(""String_Node_Str"");
        return;
      }
 else {
        for (        Object notifObj : notifications) {
          final JsonObject notif=(JsonObject)notifObj;
          notificationsDefaults.putObject(notif.getString(""String_Node_Str"",""String_Node_Str""),notif);
        }
        userContinuationHandler.handle(true);
      }
    }
  }
);
}","/** 
 * Sends weekly notification emails for all users.
 * @param dayDelta : Day from which to aggregate, delta from now.
 * @param handler : Handles the results, emails sent / users KO
 */
public void sendWeeklyMails(int dayDelta,final Handler<Either<String,JsonObject>> handler){
  final HttpServerRequest request=new JsonHttpServerRequest(new JsonObject());
  final AtomicInteger userPagination=new AtomicInteger(0);
  final Calendar weekDate=Calendar.getInstance();
  weekDate.add(Calendar.DAY_OF_MONTH,dayDelta - 6);
  weekDate.set(Calendar.HOUR_OF_DAY,0);
  weekDate.set(Calendar.MINUTE,0);
  weekDate.set(Calendar.SECOND,0);
  weekDate.set(Calendar.MILLISECOND,0);
  final JsonObject results=new JsonObject().putNumber(""String_Node_Str"",0).putNumber(""String_Node_Str"",0);
  final JsonObject notificationsDefaults=new JsonObject();
  final Handler<Boolean> userContinuationHandler=new Handler<Boolean>(){
    private final Handler<Boolean> continuation=this;
    private final Handler<JsonArray> usersHandler=new Handler<JsonArray>(){
      public void handle(      final JsonArray users){
        final int nbUsers=users.size();
        if (nbUsers == 0) {
          continuation.handle(false);
          return;
        }
        final AtomicInteger usersCountdown=new AtomicInteger(nbUsers);
        final VoidHandler usersEndHandler=new VoidHandler(){
          protected void handle(){
            if (usersCountdown.decrementAndGet() <= 0) {
              continuation.handle(nbUsers == USERS_LIMIT);
            }
          }
        }
;
        final JsonArray userIds=new JsonArray();
        for (        Object userObj : users)         userIds.add(((JsonObject)userObj).getString(""String_Node_Str"",""String_Node_Str""));
        getUsersPreferences(userIds,new Handler<JsonArray>(){
          public void handle(          JsonArray preferences){
            for (            Object userObj : preferences) {
              final JsonObject userPrefs=(JsonObject)userObj;
              getAggregatedUserNotifications(userPrefs.getString(""String_Node_Str"",""String_Node_Str""),weekDate.getTime(),new Handler<JsonArray>(){
                public void handle(                JsonArray notifications){
                  if (notifications.size() == 0) {
                    usersEndHandler.handle(null);
                    return;
                  }
                  final JsonArray weeklyNotifications=new JsonArray();
                  for (                  Object notificationObj : notifications) {
                    JsonObject notification=(JsonObject)notificationObj;
                    final String notificationName=notification.getString(""String_Node_Str"",""String_Node_Str"").toLowerCase() + ""String_Node_Str"" + notification.getString(""String_Node_Str"",""String_Node_Str"").toLowerCase();
                    if (notificationsDefaults.getObject(notificationName) == null)                     continue;
                    JsonObject notificationPreference=userPrefs.getObject(""String_Node_Str"",new JsonObject()).getObject(""String_Node_Str"",new JsonObject()).getObject(notificationName,new JsonObject());
                    if (TimelineNotificationsLoader.Frequencies.WEEKLY.name().equals(notificationPrefsMixin(""String_Node_Str"",notificationPreference,notificationsDefaults.getObject(notificationName))) && !TimelineNotificationsLoader.Restrictions.INTERNAL.name().equals(notificationPrefsMixin(""String_Node_Str"",notificationPreference,notificationsDefaults.getObject(notificationName)))) {
                      notification.putString(""String_Node_Str"",notificationName);
                      weeklyNotifications.add(notification);
                    }
                  }
                  final JsonObject weeklyNotificationsObj=new JsonObject();
                  final JsonArray weeklyNotificationsGroupedArray=new JsonArray();
                  for (                  Object notif : weeklyNotifications) {
                    JsonObject notification=(JsonObject)notif;
                    if (!weeklyNotificationsObj.containsField(notification.getString(""String_Node_Str"").toLowerCase()))                     weeklyNotificationsObj.putObject(notification.getString(""String_Node_Str"").toLowerCase(),new JsonObject().putString(""String_Node_Str"",notificationsDefaults.getObject(notification.getString(""String_Node_Str"")).getString(""String_Node_Str"",""String_Node_Str"")).putArray(""String_Node_Str"",new JsonArray()));
                    weeklyNotificationsObj.getObject(notification.getString(""String_Node_Str"").toLowerCase()).getArray((""String_Node_Str""),new JsonArray()).add(notification);
                  }
                  for (                  String key : weeklyNotificationsObj.toMap().keySet()) {
                    weeklyNotificationsGroupedArray.add(new JsonObject().putString(""String_Node_Str"",key).putString(""String_Node_Str"",weeklyNotificationsObj.getObject(key).getString(""String_Node_Str"",""String_Node_Str"")).putArray(""String_Node_Str"",weeklyNotificationsObj.getObject(key).getArray(""String_Node_Str"")));
                  }
                  if (weeklyNotifications.size() > 0) {
                    JsonObject templateParams=new JsonObject().putArray(""String_Node_Str"",weeklyNotificationsGroupedArray);
                    processTimelineTemplate(templateParams,""String_Node_Str"",""String_Node_Str"",new Handler<String>(){
                      public void handle(                      final String processedTemplate){
                        final Handler<Message<JsonObject>> completionHandler=new Handler<Message<JsonObject>>(){
                          public void handle(                          Message<JsonObject> event){
                            if (""String_Node_Str"".equals(event.body().getString(""String_Node_Str"",""String_Node_Str""))) {
                              log.error(""String_Node_Str"" + event.body());
                              results.putNumber(""String_Node_Str"",results.getInteger(""String_Node_Str"") + 1);
                            }
 else {
                              results.putNumber(""String_Node_Str"",results.getInteger(""String_Node_Str"") + 1);
                            }
                            usersEndHandler.handle(null);
                          }
                        }
;
                        JsonArray keys=new JsonArray().add(""String_Node_Str"");
                        translateTimeline(keys,""String_Node_Str"",new Handler<JsonArray>(){
                          public void handle(                          JsonArray translations){
                            emailSender.sendEmail(request,userPrefs.getString(""String_Node_Str"",""String_Node_Str""),null,null,translations.get(0).toString(),processedTemplate,null,false,completionHandler);
                          }
                        }
);
                      }
                    }
);
                  }
 else {
                    usersEndHandler.handle(null);
                  }
                }
              }
);
            }
          }
        }
);
      }
    }
;
    public void handle(    Boolean continuation){
      if (continuation) {
        getImpactedUsers(userPagination.getAndIncrement(),new Handler<Either<String,JsonArray>>(){
          public void handle(          Either<String,JsonArray> event){
            if (event.isLeft()) {
              log.error(""String_Node_Str"" + event.left().getValue());
              handler.handle(new Either.Left<String,JsonObject>(event.left().getValue()));
            }
 else {
              JsonArray users=event.right().getValue();
              usersHandler.handle(users);
            }
          }
        }
);
      }
 else {
        handler.handle(new Either.Right<String,JsonObject>(results));
      }
    }
  }
;
  getNotificationsDefaults(new Handler<JsonArray>(){
    public void handle(    final JsonArray notifications){
      if (notifications == null) {
        log.error(""String_Node_Str"");
        return;
      }
 else {
        for (        Object notifObj : notifications) {
          final JsonObject notif=(JsonObject)notifObj;
          notificationsDefaults.putObject(notif.getString(""String_Node_Str"",""String_Node_Str""),notif);
        }
        userContinuationHandler.handle(true);
      }
    }
  }
);
}",0.9894432044398864
87136,"private JsonObject getSessionByUserId(Message<JsonObject> message){
  final String userId=message.body().getString(""String_Node_Str"");
  if (userId == null || userId.trim().isEmpty()) {
    sendError(message,""String_Node_Str"");
    return null;
  }
  LoginInfo info=logins.get(userId);
  if (info == null) {
    sendError(message,""String_Node_Str"");
    return null;
  }
  JsonObject session=unmarshal(sessions.get(info.sessionId));
  if (session == null) {
    sendError(message,""String_Node_Str"");
    return null;
  }
  return session;
}","private JsonObject getSessionByUserId(Message<JsonObject> message){
  final String userId=message.body().getString(""String_Node_Str"");
  if (userId == null || userId.trim().isEmpty()) {
    sendError(message,""String_Node_Str"");
    return null;
  }
  LoginInfo info=logins.get(userId);
  if (info == null) {
    sendError(message,""String_Node_Str"");
    return null;
  }
  JsonObject session=null;
  try {
    session=unmarshal(sessions.get(info.sessionId));
  }
 catch (  HazelcastSerializationException e) {
    logger.error(""String_Node_Str"" + info.sessionId,e);
  }
  if (session == null) {
    sendError(message,""String_Node_Str"");
    return null;
  }
  return session;
}",0.8562037797863599
87137,"private void doFind(final Message<JsonObject> message){
  final String sessionId=message.body().getString(""String_Node_Str"");
  if (sessionId == null || sessionId.trim().isEmpty()) {
    sendError(message,""String_Node_Str"");
    return;
  }
  JsonObject session=unmarshal(sessions.get(sessionId));
  if (session == null) {
    final JsonObject query=new JsonObject().putString(""String_Node_Str"",sessionId);
    mongo.findOne(SESSIONS_COLLECTION,query,new Handler<Message<JsonObject>>(){
      @Override public void handle(      Message<JsonObject> event){
        JsonObject res=event.body().getObject(""String_Node_Str"");
        String userId;
        if (""String_Node_Str"".equals(event.body().getString(""String_Node_Str"")) && res != null && (userId=res.getString(""String_Node_Str"")) != null && !userId.trim().isEmpty()) {
          createSession(userId,sessionId,new Handler<String>(){
            @Override public void handle(            String sId){
              if (sId != null) {
                JsonObject s=unmarshal(sessions.get(sId));
                if (s != null) {
                  sendOK(message,new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putObject(""String_Node_Str"",s));
                }
 else {
                  sendError(message,""String_Node_Str"");
                }
              }
 else {
                sendError(message,""String_Node_Str"");
              }
            }
          }
);
        }
 else {
          sendError(message,""String_Node_Str"");
        }
      }
    }
);
  }
 else {
    sendOK(message,new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putObject(""String_Node_Str"",session));
  }
}","private void doFind(final Message<JsonObject> message){
  final String sessionId=message.body().getString(""String_Node_Str"");
  if (sessionId == null || sessionId.trim().isEmpty()) {
    sendError(message,""String_Node_Str"");
    return;
  }
  JsonObject session=null;
  try {
    session=unmarshal(sessions.get(sessionId));
  }
 catch (  HazelcastSerializationException e) {
    logger.warn(""String_Node_Str"" + sessionId);
    try {
      if (sessions instanceof BaseMap) {
        ((BaseMap)sessions).delete(sessionId);
      }
 else {
        sessions.remove(sessionId);
      }
    }
 catch (    HazelcastSerializationException e1) {
      logger.warn(""String_Node_Str"" + sessionId);
    }
  }
  if (session == null) {
    final JsonObject query=new JsonObject().putString(""String_Node_Str"",sessionId);
    mongo.findOne(SESSIONS_COLLECTION,query,new Handler<Message<JsonObject>>(){
      @Override public void handle(      Message<JsonObject> event){
        JsonObject res=event.body().getObject(""String_Node_Str"");
        String userId;
        if (""String_Node_Str"".equals(event.body().getString(""String_Node_Str"")) && res != null && (userId=res.getString(""String_Node_Str"")) != null && !userId.trim().isEmpty()) {
          final String uId=userId;
          createSession(userId,sessionId,new Handler<String>(){
            @Override public void handle(            String sId){
              if (sId != null) {
                try {
                  JsonObject s=unmarshal(sessions.get(sId));
                  if (s != null) {
                    JsonObject sessionResponse=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putObject(""String_Node_Str"",s);
                    sendOK(message,sessionResponse);
                  }
 else {
                    sendError(message,""String_Node_Str"");
                  }
                }
 catch (                HazelcastSerializationException e) {
                  logger.warn(""String_Node_Str"" + sId);
                  generateSessionInfos(uId,new Handler<JsonObject>(){
                    @Override public void handle(                    JsonObject event){
                      if (event != null) {
                        logger.info(""String_Node_Str"" + event.encode());
                        sendOK(message,new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putObject(""String_Node_Str"",event));
                      }
 else {
                        sendError(message,""String_Node_Str"");
                      }
                    }
                  }
);
                }
              }
 else {
                sendError(message,""String_Node_Str"");
              }
            }
          }
);
        }
 else {
          sendError(message,""String_Node_Str"");
        }
      }
    }
);
  }
 else {
    sendOK(message,new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putObject(""String_Node_Str"",session));
  }
}",0.5285403050108932
87138,"private void doFindByUserId(final Message<JsonObject> message){
  final String userId=message.body().getString(""String_Node_Str"");
  if (userId == null || userId.trim().isEmpty()) {
    sendError(message,""String_Node_Str"");
    return;
  }
  LoginInfo info=logins.get(userId);
  if (info == null && !message.body().getBoolean(""String_Node_Str"",false)) {
    sendError(message,""String_Node_Str"");
    return;
  }
 else   if (info == null) {
    generateSessionInfos(userId,new Handler<JsonObject>(){
      @Override public void handle(      JsonObject infos){
        if (infos != null) {
          sendOK(message,new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putObject(""String_Node_Str"",infos));
        }
 else {
          sendError(message,""String_Node_Str"" + userId);
        }
      }
    }
);
    return;
  }
  JsonObject session=unmarshal(sessions.get(info.sessionId));
  if (session == null) {
    sendError(message,""String_Node_Str"");
    return;
  }
  sendOK(message,new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putObject(""String_Node_Str"",session));
}","private void doFindByUserId(final Message<JsonObject> message){
  final String userId=message.body().getString(""String_Node_Str"");
  if (userId == null || userId.trim().isEmpty()) {
    sendError(message,""String_Node_Str"");
    return;
  }
  LoginInfo info=logins.get(userId);
  if (info == null && !message.body().getBoolean(""String_Node_Str"",false)) {
    sendError(message,""String_Node_Str"");
    return;
  }
 else   if (info == null) {
    generateSessionInfos(userId,new Handler<JsonObject>(){
      @Override public void handle(      JsonObject infos){
        if (infos != null) {
          sendOK(message,new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putObject(""String_Node_Str"",infos));
        }
 else {
          sendError(message,""String_Node_Str"" + userId);
        }
      }
    }
);
    return;
  }
  JsonObject session=null;
  try {
    session=unmarshal(sessions.get(info.sessionId));
  }
 catch (  HazelcastSerializationException e) {
    logger.error(""String_Node_Str"" + info.sessionId,e);
  }
  if (session == null) {
    sendError(message,""String_Node_Str"");
    return;
  }
  sendOK(message,new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putObject(""String_Node_Str"",session));
}",0.9412773253321904
87139,"private void createSession(final String userId,final String sId,final Handler<String> handler){
  final String sessionId=(sId != null) ? sId : UUID.randomUUID().toString();
  generateSessionInfos(userId,new Handler<JsonObject>(){
    @Override public void handle(    JsonObject infos){
      if (infos != null) {
        long timerId=vertx.setTimer(sessionTimeout,new Handler<Long>(){
          public void handle(          Long timerId){
            sessions.remove(sessionId);
            logins.remove(userId);
          }
        }
);
        sessions.put(sessionId,infos.encode());
        logins.put(userId,new LoginInfo(timerId,sessionId));
        final JsonObject now=MongoDb.now();
        if (sId == null) {
          mongo.save(SESSIONS_COLLECTION,new JsonObject().putString(""String_Node_Str"",sessionId).putString(""String_Node_Str"",userId).putObject(""String_Node_Str"",now).putObject(""String_Node_Str"",now));
        }
 else {
          mongo.update(SESSIONS_COLLECTION,new JsonObject().putString(""String_Node_Str"",sessionId),new JsonObject().putObject(""String_Node_Str"",new JsonObject().putObject(""String_Node_Str"",now)));
        }
        handler.handle(sessionId);
      }
 else {
        handler.handle(null);
      }
    }
  }
);
}","private void createSession(final String userId,final String sId,final Handler<String> handler){
  final String sessionId=(sId != null) ? sId : UUID.randomUUID().toString();
  generateSessionInfos(userId,new Handler<JsonObject>(){
    @Override public void handle(    JsonObject infos){
      if (infos != null) {
        long timerId=vertx.setTimer(sessionTimeout,new Handler<Long>(){
          public void handle(          Long timerId){
            logins.remove(userId);
            sessions.remove(sessionId);
          }
        }
);
        try {
          sessions.put(sessionId,infos.encode());
          logins.put(userId,new LoginInfo(timerId,sessionId));
        }
 catch (        HazelcastSerializationException e) {
          logger.error(""String_Node_Str"");
          try {
            if (sessions instanceof IMap) {
              ((IMap)sessions).putAsync(sessionId,infos.encode());
            }
            logins.put(userId,new LoginInfo(timerId,sessionId));
          }
 catch (          HazelcastSerializationException e1) {
            logger.error(""String_Node_Str"",e1);
          }
        }
        final JsonObject now=MongoDb.now();
        if (sId == null) {
          mongo.save(SESSIONS_COLLECTION,new JsonObject().putString(""String_Node_Str"",sessionId).putString(""String_Node_Str"",userId).putObject(""String_Node_Str"",now).putObject(""String_Node_Str"",now));
        }
 else {
          mongo.update(SESSIONS_COLLECTION,new JsonObject().putString(""String_Node_Str"",sessionId),new JsonObject().putObject(""String_Node_Str"",new JsonObject().putObject(""String_Node_Str"",now)));
        }
        handler.handle(sessionId);
      }
 else {
        handler.handle(null);
      }
    }
  }
);
}",0.8279352226720648
87140,"private void updateSessionByUserId(Message<JsonObject> message,JsonObject session){
  final String userId=message.body().getString(""String_Node_Str"");
  if (userId == null || userId.trim().isEmpty()) {
    sendError(message,""String_Node_Str"");
    return;
  }
  LoginInfo info=logins.get(userId);
  if (info == null) {
    sendError(message,""String_Node_Str"");
    return;
  }
  sessions.put(info.sessionId,session.encode());
}","private void updateSessionByUserId(Message<JsonObject> message,JsonObject session){
  final String userId=message.body().getString(""String_Node_Str"");
  if (userId == null || userId.trim().isEmpty()) {
    sendError(message,""String_Node_Str"");
    return;
  }
  LoginInfo info=logins.get(userId);
  if (info == null) {
    sendError(message,""String_Node_Str"");
    return;
  }
  try {
    sessions.put(info.sessionId,session.encode());
  }
 catch (  HazelcastSerializationException e) {
    logger.error(""String_Node_Str"" + info.sessionId,e);
  }
}",0.8758974358974358
87141,"private void doDrop(Message<JsonObject> message){
  String sessionId=message.body().getString(""String_Node_Str"");
  if (sessionId == null || sessionId.trim().isEmpty()) {
    sendError(message,""String_Node_Str"");
    return;
  }
  mongo.delete(SESSIONS_COLLECTION,new JsonObject().putString(""String_Node_Str"",sessionId));
  JsonObject session=unmarshal(sessions.get(sessionId));
  if (session == null) {
    sendError(message,""String_Node_Str"");
    return;
  }
  JsonObject s=unmarshal(sessions.remove(sessionId));
  if (s != null) {
    final String userId=s.getString(""String_Node_Str"");
    LoginInfo info=logins.remove(userId);
    if (config.getBoolean(""String_Node_Str"",false)) {
      eb.send(""String_Node_Str"",new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",userId));
    }
    if (info != null) {
      vertx.cancelTimer(info.timerId);
    }
  }
  sendOK(message,new JsonObject().putString(""String_Node_Str"",""String_Node_Str""));
}","private void doDrop(Message<JsonObject> message){
  String sessionId=message.body().getString(""String_Node_Str"");
  if (sessionId == null || sessionId.trim().isEmpty()) {
    sendError(message,""String_Node_Str"");
    return;
  }
  mongo.delete(SESSIONS_COLLECTION,new JsonObject().putString(""String_Node_Str"",sessionId));
  JsonObject session=null;
  try {
    session=unmarshal(sessions.get(sessionId));
  }
 catch (  HazelcastSerializationException e) {
    try {
      if (sessions instanceof BaseMap) {
        ((BaseMap)sessions).delete(sessionId);
      }
 else {
        sessions.remove(sessionId);
      }
    }
 catch (    HazelcastSerializationException e1) {
      logger.error(""String_Node_Str"" + sessionId,e);
    }
  }
  if (session == null) {
    sendError(message,""String_Node_Str"");
    return;
  }
  JsonObject s=unmarshal(sessions.remove(sessionId));
  if (s != null) {
    final String userId=s.getString(""String_Node_Str"");
    LoginInfo info=logins.remove(userId);
    if (config.getBoolean(""String_Node_Str"",false)) {
      eb.send(""String_Node_Str"",new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",userId));
    }
    if (info != null) {
      vertx.cancelTimer(info.timerId);
    }
  }
  sendOK(message,new JsonObject().putString(""String_Node_Str"",""String_Node_Str""));
}",0.8475452196382429
87142,"@Override protected void prepareUserCas20(User user,String userId,String service,JsonObject data,Document doc,List<Element> additionalAttributes){
  user.setUser(data.getString(principalAttributeName));
  try {
    String queryParams=new URI(service).getQuery();
    String[] pairs;
    if (queryParams != null && queryParams.length() > 0 && (pairs=queryParams.split(""String_Node_Str"")).length > 0) {
      for (      String pair : pairs) {
        String key=pair.substring(0,pair.indexOf('='));
        if (""String_Node_Str"".equals(key)) {
          String value=pair.substring(pair.indexOf('=') + 1);
          additionalAttributes.add(createTextElement(""String_Node_Str"",value,doc));
          for (          Object o : data.getArray(""String_Node_Str"",new JsonArray()).toList()) {
            @SuppressWarnings(""String_Node_Str"") Map<String,Object> structure=((Map<String,Object>)o);
            if (value.equals(structure.get(""String_Node_Str"").toString())) {
              additionalAttributes.add(createTextElement(""String_Node_Str"",structure.get(""String_Node_Str"").toString(),doc));
              break;
            }
          }
          break;
        }
      }
    }
switch (data.getString(""String_Node_Str"")) {
case ""String_Node_Str"":
      additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
    additionalAttributes.add(createTextElement(""String_Node_Str"",data.getString(""String_Node_Str""),doc));
  addStringArray(""String_Node_Str"",""String_Node_Str"",data,doc,additionalAttributes);
addStringArray(""String_Node_Str"",""String_Node_Str"",data,doc,additionalAttributes);
addStringArray(""String_Node_Str"",""String_Node_Str"",data,doc,additionalAttributes);
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
break;
case ""String_Node_Str"":
Element root=createElement(""String_Node_Str"",doc);
root.appendChild(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
root.appendChild(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(root);
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
addStringArray(""String_Node_Str"",""String_Node_Str"",data,doc,additionalAttributes);
addStringArray(""String_Node_Str"",""String_Node_Str"",data,doc,additionalAttributes);
addStringArray(""String_Node_Str"",""String_Node_Str"",data,doc,additionalAttributes);
addStringArray(""String_Node_Str"",""String_Node_Str"",data,doc,additionalAttributes);
break;
case ""String_Node_Str"":
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
break;
case ""String_Node_Str"":
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
break;
}
}
 catch (Exception e) {
log.error(""String_Node_Str"",e);
}
}","@Override protected void prepareUserCas20(User user,String userId,String service,JsonObject data,Document doc,List<Element> additionalAttributes){
  user.setUser(data.getString(principalAttributeName));
  try {
    String queryParams=new URI(service).getQuery();
    String[] pairs;
    if (queryParams != null && queryParams.length() > 0 && (pairs=queryParams.split(""String_Node_Str"")).length > 0) {
      for (      String pair : pairs) {
        String key=pair.substring(0,pair.indexOf('='));
        if (""String_Node_Str"".equals(key)) {
          String value=pair.substring(pair.indexOf('=') + 1);
          additionalAttributes.add(createTextElement(""String_Node_Str"",value,doc));
          for (          Object o : data.getArray(""String_Node_Str"",new JsonArray()).toList()) {
            @SuppressWarnings(""String_Node_Str"") Map<String,Object> structure=((Map<String,Object>)o);
            if (value.equals(structure.get(""String_Node_Str"").toString())) {
              additionalAttributes.add(createTextElement(""String_Node_Str"",structure.get(""String_Node_Str"").toString(),doc));
              break;
            }
          }
          break;
        }
      }
    }
    Element rootProfiles;
switch (data.getString(""String_Node_Str"")) {
case ""String_Node_Str"":
      rootProfiles=createElement(""String_Node_Str"",doc);
    rootProfiles.appendChild(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
  additionalAttributes.add(rootProfiles);
additionalAttributes.add(createTextElement(""String_Node_Str"",data.getString(""String_Node_Str""),doc));
addStringArray(""String_Node_Str"",""String_Node_Str"",data,doc,additionalAttributes);
addObjectArrayProp(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",data,doc,additionalAttributes);
addObjectArrayProp(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",data,doc,additionalAttributes);
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
break;
case ""String_Node_Str"":
rootProfiles=createElement(""String_Node_Str"",doc);
rootProfiles.appendChild(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
rootProfiles.appendChild(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(rootProfiles);
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
addStringArray(""String_Node_Str"",""String_Node_Str"",data,doc,additionalAttributes);
addObjectArrayProp(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",data,doc,additionalAttributes);
addObjectArrayProp(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",data,doc,additionalAttributes);
addStringArray(""String_Node_Str"",""String_Node_Str"",data,doc,additionalAttributes);
break;
case ""String_Node_Str"":
rootProfiles=createElement(""String_Node_Str"",doc);
rootProfiles.appendChild(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(rootProfiles);
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
break;
case ""String_Node_Str"":
rootProfiles=createElement(""String_Node_Str"",doc);
rootProfiles.appendChild(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(rootProfiles);
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
additionalAttributes.add(createTextElement(""String_Node_Str"",""String_Node_Str"",doc));
break;
}
}
 catch (Exception e) {
log.error(""String_Node_Str"",e);
}
}",0.7415891195418755
87143,"private void addStringArray(String casLabel,String entLabel,JsonObject data,Document doc,List<Element> additionalAttributes){
  Element root=createElement(entLabel + ""String_Node_Str"",doc);
  for (  Object item : data.getArray(entLabel)) {
    root.appendChild(createTextElement(casLabel,(String)item,doc));
  }
  additionalAttributes.add(root);
}","private void addStringArray(String casLabel,String entLabel,JsonObject data,Document doc,List<Element> additionalAttributes){
  Element root=createElement(casLabel + ""String_Node_Str"",doc);
  if (data.containsField(entLabel)) {
    for (    Object item : data.getArray(entLabel)) {
      root.appendChild(createTextElement(casLabel,(String)item,doc));
    }
  }
  additionalAttributes.add(root);
}",0.913978494623656
87144,"@Override public void deleteFolder(String folderId,UserInfos user,Handler<Either<String,JsonArray>> result){
  if (validationError(user,result,folderId))   return;
  String retrieveAttachments=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + (maxFolderDepth - 1) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String processMessages=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + (maxFolderDepth - 1) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String gatherAttachmentsToDelete=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String deleteMessages=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String deleteFolders=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + (maxFolderDepth - 1) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  JsonObject params=new JsonObject().putString(""String_Node_Str"",user.getUserId()).putString(""String_Node_Str"",folderId).putBoolean(""String_Node_Str"",true).putString(""String_Node_Str"",""String_Node_Str"");
  StatementsBuilder b=new StatementsBuilder();
  b.add(retrieveAttachments,params);
  b.add(processMessages,params);
  b.add(gatherAttachmentsToDelete,params);
  b.add(deleteMessages,params);
  b.add(deleteFolders,params);
  neo.executeTransaction(b.build(),null,true,validResultsHandler(result));
}","@Override public void deleteFolder(String folderId,UserInfos user,Handler<Either<String,JsonArray>> result){
  if (validationError(user,result,folderId))   return;
  String retrieveAttachments=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + (maxFolderDepth - 1) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String processMessages=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + (maxFolderDepth - 1) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String gatherAttachmentsToDelete=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String deleteMessages=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String deleteFolders=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + (maxFolderDepth - 1) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  JsonObject params=new JsonObject().putString(""String_Node_Str"",user.getUserId()).putString(""String_Node_Str"",folderId).putBoolean(""String_Node_Str"",true).putString(""String_Node_Str"",""String_Node_Str"");
  StatementsBuilder b=new StatementsBuilder();
  b.add(retrieveAttachments,params);
  b.add(processMessages,params);
  b.add(gatherAttachmentsToDelete,params);
  b.add(deleteMessages,params);
  b.add(deleteFolders,params);
  neo.executeTransaction(b.build(),null,true,validResultsHandler(result));
}",0.9668797210923882
87145,"@Override public void delete(List<String> messagesId,UserInfos user,Handler<Either<String,JsonArray>> result){
  if (validationError(user,result))   return;
  final String getMessage=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  final String getMessageWithAttachments=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String prepareMessage=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + (maxFolderDepth - 1) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String getAllAttachments=getMessageWithAttachments + ""String_Node_Str"";
  String deleteAndCollectAttachments=getMessageWithAttachments + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String deleteMessage=getMessage + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  StatementsBuilder b=new StatementsBuilder();
  for (  String id : messagesId) {
    JsonObject params=new JsonObject().putString(""String_Node_Str"",user.getUserId()).putString(""String_Node_Str"",id).putBoolean(""String_Node_Str"",true).putString(""String_Node_Str"",""String_Node_Str"");
    b.add(prepareMessage,params);
    b.add(getAllAttachments,params);
    b.add(deleteAndCollectAttachments,params);
    b.add(deleteMessage,params);
  }
  neo.executeTransaction(b.build(),null,true,validResultsHandler(result));
}","@Override public void delete(List<String> messagesId,UserInfos user,Handler<Either<String,JsonArray>> result){
  if (validationError(user,result))   return;
  final String getMessage=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  final String getMessageWithAttachments=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String prepareMessage=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + (maxFolderDepth - 1) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String getAllAttachments=getMessageWithAttachments + ""String_Node_Str"" + ""String_Node_Str"";
  String deleteAndCollectAttachments=getMessageWithAttachments + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String deleteMessage=getMessage + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  StatementsBuilder b=new StatementsBuilder();
  for (  String id : messagesId) {
    JsonObject params=new JsonObject().putString(""String_Node_Str"",user.getUserId()).putString(""String_Node_Str"",id).putBoolean(""String_Node_Str"",true).putString(""String_Node_Str"",""String_Node_Str"");
    b.add(prepareMessage,params);
    b.add(getAllAttachments,params);
    b.add(deleteAndCollectAttachments,params);
    b.add(deleteMessage,params);
  }
  neo.executeTransaction(b.build(),null,true,validResultsHandler(result));
}",0.99302649930265
87146,"@Override public void removeAttachment(String messageId,String attachmentId,UserInfos user,final Handler<Either<String,JsonObject>> result){
  if (validationParamsError(user,result,messageId,attachmentId))   return;
  String get=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String query=get + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  String q2=get + ""String_Node_Str"" + ""String_Node_Str"";
  String q3=get + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  JsonObject params=new JsonObject().putString(""String_Node_Str"",user.getUserId()).putString(""String_Node_Str"",messageId).putString(""String_Node_Str"",attachmentId).putBoolean(""String_Node_Str"",true);
  StatementsBuilder b=new StatementsBuilder();
  b.add(query,params);
  b.add(q2,params);
  b.add(q3,params);
  neo.executeTransaction(b.build(),null,true,validResultsHandler(new Handler<Either<String,JsonArray>>(){
    @Override public void handle(    Either<String,JsonArray> event){
      if (event.isLeft()) {
        result.handle(new Either.Left<String,JsonObject>(event.left().getValue()));
        return;
      }
      JsonArray result1=(JsonArray)event.right().getValue().get(0);
      JsonArray result3=(JsonArray)event.right().getValue().get(2);
      JsonObject jsonResult=result1.size() > 0 ? (JsonObject)result1.get(0) : new JsonObject();
      jsonResult.putBoolean(""String_Node_Str"",result3.size() > 0 ? ((JsonObject)result3.get(0)).getBoolean(""String_Node_Str"",false) : false);
      result.handle(new Either.Right<String,JsonObject>(jsonResult));
    }
  }
));
}","@Override public void removeAttachment(String messageId,String attachmentId,UserInfos user,final Handler<Either<String,JsonObject>> result){
  if (validationParamsError(user,result,messageId,attachmentId))   return;
  String get=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String query=get + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  String q2=get + ""String_Node_Str"" + ""String_Node_Str"";
  String q3=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  JsonObject params=new JsonObject().putString(""String_Node_Str"",user.getUserId()).putString(""String_Node_Str"",messageId).putString(""String_Node_Str"",attachmentId).putBoolean(""String_Node_Str"",true);
  StatementsBuilder b=new StatementsBuilder();
  b.add(query,params);
  b.add(q2,params);
  b.add(q3,params);
  neo.executeTransaction(b.build(),null,true,validResultsHandler(new Handler<Either<String,JsonArray>>(){
    @Override public void handle(    Either<String,JsonArray> event){
      if (event.isLeft()) {
        result.handle(new Either.Left<String,JsonObject>(event.left().getValue()));
        return;
      }
      JsonArray result1=(JsonArray)event.right().getValue().get(0);
      JsonArray result3=(JsonArray)event.right().getValue().get(2);
      JsonObject jsonResult=result1.size() > 0 ? (JsonObject)result1.get(0) : new JsonObject();
      jsonResult.putBoolean(""String_Node_Str"",result3.size() > 0 ? ((JsonObject)result3.get(0)).getBoolean(""String_Node_Str"",false) : false);
      result.handle(new Either.Right<String,JsonObject>(jsonResult));
    }
  }
));
}",0.994058229352347
87147,"private void send(final String parentMessageId,final String messageId,final UserInfos user,final Handler<Either<String,JsonObject>> result){
  if (validationParamsError(user,result,messageId))   return;
  String attachmentsRetrieval=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  JsonObject params=new JsonObject().putString(""String_Node_Str"",user.getUserId()).putString(""String_Node_Str"",messageId).putString(""String_Node_Str"",State.DRAFT.name()).putBoolean(""String_Node_Str"",true);
  neo.execute(attachmentsRetrieval,params,validUniqueResultHandler(new Handler<Either<String,JsonObject>>(){
    public void handle(    Either<String,JsonObject> event){
      if (event.isLeft() || event.isRight() && event.right().getValue() == null) {
        result.handle(new Either.Left<String,JsonObject>(""String_Node_Str""));
        return;
      }
      JsonArray attachments=event.right().getValue().getArray(""String_Node_Str"",new JsonArray());
      if (attachments.size() < 1) {
        sendWithoutAttachments(parentMessageId,messageId,user,result);
      }
 else {
        sendWithAttachments(parentMessageId,messageId,attachments,user,result);
      }
    }
  }
));
}","private void send(final String parentMessageId,final String messageId,final UserInfos user,final Handler<Either<String,JsonObject>> result){
  if (validationParamsError(user,result,messageId))   return;
  String attachmentsRetrieval=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  JsonObject params=new JsonObject().putString(""String_Node_Str"",user.getUserId()).putString(""String_Node_Str"",messageId).putString(""String_Node_Str"",State.DRAFT.name()).putBoolean(""String_Node_Str"",true);
  neo.execute(attachmentsRetrieval,params,validUniqueResultHandler(new Handler<Either<String,JsonObject>>(){
    public void handle(    Either<String,JsonObject> event){
      if (event.isLeft() || event.isRight() && event.right().getValue() == null) {
        result.handle(new Either.Left<String,JsonObject>(""String_Node_Str""));
        return;
      }
      JsonArray attachments=event.right().getValue().getArray(""String_Node_Str"",new JsonArray());
      if (attachments.size() < 1) {
        sendWithoutAttachments(parentMessageId,messageId,user,result);
      }
 else {
        sendWithAttachments(parentMessageId,messageId,attachments,user,result);
      }
    }
  }
));
}",0.9923602734217932
87148,"@BusAddress(""String_Node_Str"") public void quotaEventBusHandler(final Message<JsonObject> message){
  Handler<Either<String,JsonObject>> responseHandler=new Handler<Either<String,JsonObject>>(){
    @Override public void handle(    Either<String,JsonObject> res){
      if (res.isRight()) {
        message.reply(res.right().getValue());
      }
 else {
        message.reply(new JsonArray());
      }
    }
  }
;
  String userId=message.body().getString(""String_Node_Str"");
switch (message.body().getString(""String_Node_Str"",""String_Node_Str"")) {
case ""String_Node_Str"":
    quotaService.quotaAndUsage(userId,responseHandler);
  break;
case ""String_Node_Str"":
long size=message.body().getLong(""String_Node_Str"");
int threshold=message.body().getInteger(""String_Node_Str"");
quotaService.incrementStorage(userId,size,threshold,responseHandler);
break;
default :
message.reply(new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",""String_Node_Str""));
}
}","@BusAddress(""String_Node_Str"") public void quotaEventBusHandler(final Message<JsonObject> message){
  Handler<Either<String,JsonObject>> responseHandler=new Handler<Either<String,JsonObject>>(){
    @Override public void handle(    Either<String,JsonObject> res){
      if (res.isRight()) {
        message.reply(res.right().getValue());
      }
 else {
        message.reply(new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",res.left().getValue()));
      }
    }
  }
;
  String userId=message.body().getString(""String_Node_Str"");
switch (message.body().getString(""String_Node_Str"",""String_Node_Str"")) {
case ""String_Node_Str"":
    quotaService.quotaAndUsage(userId,responseHandler);
  break;
case ""String_Node_Str"":
long size=message.body().getLong(""String_Node_Str"");
int threshold=message.body().getInteger(""String_Node_Str"");
quotaService.incrementStorage(userId,size,threshold,responseHandler);
break;
default :
message.reply(new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",""String_Node_Str""));
}
}",0.9466602594906296
87149,"@Override public void handle(Either<String,JsonObject> res){
  if (res.isRight()) {
    message.reply(res.right().getValue());
  }
 else {
    message.reply(new JsonArray());
  }
}","@Override public void handle(Either<String,JsonObject> res){
  if (res.isRight()) {
    message.reply(res.right().getValue());
  }
 else {
    message.reply(new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",res.left().getValue()));
  }
}",0.7581699346405228
87150,"public void updateUser(final Message<JsonObject> message){
  final JsonObject user=getMandatoryObject(""String_Node_Str"",message);
  if (user == null)   return;
  final String userId=getMandatoryString(""String_Node_Str"",message);
  if (userId == null)   return;
  String q=""String_Node_Str"" + ""String_Node_Str"";
  neo4j.execute(q,new JsonObject().putString(""String_Node_Str"",userId),new Handler<Message<JsonObject>>(){
    @Override public void handle(    Message<JsonObject> r){
      JsonArray res=r.body().getArray(""String_Node_Str"");
      if (""String_Node_Str"".equals(r.body().getString(""String_Node_Str"")) && res != null && res.size() == 1) {
        String profile=((JsonObject)res.get(0)).getString(""String_Node_Str"");
        Validator v=profiles.get(profile);
        if (v == null) {
          sendError(message,""String_Node_Str"" + profile);
          return;
        }
        final String error=v.modifiableValidate(user);
        if (error != null) {
          logger.error(error);
          sendError(message,error);
        }
 else {
          String query=""String_Node_Str"" + ""String_Node_Str"" + Neo4j.nodeSetPropertiesFromJson(""String_Node_Str"",user) + ""String_Node_Str"";
          JsonObject params=user.putString(""String_Node_Str"",userId);
          neo4j.execute(query,params,new Handler<Message<JsonObject>>(){
            @Override public void handle(            Message<JsonObject> m){
              message.reply(m.body());
            }
          }
);
        }
      }
 else {
        sendError(message,""String_Node_Str"");
      }
    }
  }
);
}","public void updateUser(final Message<JsonObject> message){
  final JsonObject user=getMandatoryObject(""String_Node_Str"",message);
  if (user == null)   return;
  final String userId=getMandatoryString(""String_Node_Str"",message);
  if (userId == null)   return;
  String q=""String_Node_Str"" + ""String_Node_Str"";
  neo4j.execute(q,new JsonObject().putString(""String_Node_Str"",userId),new Handler<Message<JsonObject>>(){
    @Override public void handle(    Message<JsonObject> r){
      JsonArray res=r.body().getArray(""String_Node_Str"");
      if (""String_Node_Str"".equals(r.body().getString(""String_Node_Str"")) && res != null && res.size() > 0) {
        for (        Object o : res) {
          if (!(o instanceof JsonObject))           continue;
          String profile=((JsonObject)o).getString(""String_Node_Str"");
          Validator v=profiles.get(profile);
          if (v == null) {
            sendError(message,""String_Node_Str"" + profile);
            return;
          }
          final String error=v.modifiableValidate(user);
          if (error != null) {
            logger.error(error);
            sendError(message,error);
            return;
          }
        }
        String query=""String_Node_Str"" + ""String_Node_Str"" + Neo4j.nodeSetPropertiesFromJson(""String_Node_Str"",user) + ""String_Node_Str"";
        JsonObject params=user.putString(""String_Node_Str"",userId);
        neo4j.execute(query,params,new Handler<Message<JsonObject>>(){
          @Override public void handle(          Message<JsonObject> m){
            message.reply(m.body());
          }
        }
);
      }
 else {
        sendError(message,""String_Node_Str"");
      }
    }
  }
);
}",0.8809597047062442
87151,"private void sendResetPasswordLink(HttpServerRequest request,String email,String resetCode,final Handler<Boolean> handler){
  if (email == null || resetCode == null || email.trim().isEmpty() || resetCode.trim().isEmpty()) {
    handler.handle(false);
    return;
  }
  JsonObject json=new JsonObject().putString(""String_Node_Str"",container.config().getString(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + resetCode);
  container.logger().debug(json.encode());
  try {
    notification.sendEmail(request,email,container.config().getString(""String_Node_Str"",""String_Node_Str""),null,null,""String_Node_Str"",""String_Node_Str"",json,true,new Handler<Message<JsonObject>>(){
      @Override public void handle(      Message<JsonObject> message){
        handler.handle(""String_Node_Str"".equals(message.body().getString(""String_Node_Str"")));
      }
    }
);
  }
 catch (  IOException e) {
    container.logger().error(""String_Node_Str"",e);
    handler.handle(false);
  }
}","private void sendResetPasswordLink(HttpServerRequest request,String email,String resetCode,final Handler<Boolean> handler){
  if (email == null || resetCode == null || email.trim().isEmpty() || resetCode.trim().isEmpty()) {
    handler.handle(false);
    return;
  }
  JsonObject json=new JsonObject().putString(""String_Node_Str"",container.config().getString(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + resetCode);
  container.logger().debug(json.encode());
  notification.sendEmail(request,email,container.config().getString(""String_Node_Str"",""String_Node_Str""),null,null,""String_Node_Str"",""String_Node_Str"",json,true,new Handler<Message<JsonObject>>(){
    @Override public void handle(    Message<JsonObject> message){
      handler.handle(""String_Node_Str"".equals(message.body().getString(""String_Node_Str"")));
    }
  }
);
}",0.9269632070291048
87152,"public DefaultUserAuthAccount(Vertx vertx,Container container){
  EventBus eb=Server.getEventBus(vertx);
  this.neo=new Neo(eb,container.logger());
  this.vertx=vertx;
  this.container=container;
  notification=new NotificationHelper(eb,container);
}","public DefaultUserAuthAccount(Vertx vertx,Container container){
  EventBus eb=Server.getEventBus(vertx);
  this.neo=new Neo(eb,container.logger());
  this.vertx=vertx;
  this.container=container;
  notification=new NotificationHelper(vertx,eb,container);
}",0.9881422924901184
87153,"@Override public void notifyShare(final HttpServerRequest request,final String blogId,final UserInfos user,final JsonArray sharedArray,final String resourceUri){
  if (sharedArray != null && user != null && blogId != null && request != null && resourceUri != null) {
    QueryBuilder query=QueryBuilder.start(""String_Node_Str"").is(blogId);
    JsonObject keys=new JsonObject().putNumber(""String_Node_Str"",1);
    mongo.findOne(""String_Node_Str"",MongoQueryBuilder.build(query),keys,new Handler<Message<JsonObject>>(){
      @Override public void handle(      final Message<JsonObject> event){
        if (""String_Node_Str"".equals(event.body().getString(""String_Node_Str""))) {
          List<String> shareIds=getSharedIds(sharedArray);
          if (!shareIds.isEmpty()) {
            Map<String,Object> params=new HashMap<>();
            params.put(""String_Node_Str"",user.getUserId());
            neo.send(neoQuery(shareIds),params,new Handler<Message<JsonObject>>(){
              @Override public void handle(              Message<JsonObject> res){
                if (""String_Node_Str"".equals(res.body().getString(""String_Node_Str""))) {
                  JsonObject r=res.body().getObject(""String_Node_Str"");
                  List<String> recipients=new ArrayList<>();
                  for (                  String attr : r.getFieldNames()) {
                    String id=r.getObject(attr).getString(""String_Node_Str"");
                    if (id != null) {
                      recipients.add(id);
                    }
                  }
                  String blogTitle=event.body().getObject(""String_Node_Str"",new JsonObject()).getString(""String_Node_Str"");
                  JsonObject p=new JsonObject().putString(""String_Node_Str"",container.config().getString(""String_Node_Str"") + ""String_Node_Str"" + user.getUserId()+ ""String_Node_Str""+ user.getType()).putString(""String_Node_Str"",user.getUsername()).putString(""String_Node_Str"",blogTitle).putString(""String_Node_Str"",resourceUri);
                  try {
                    notification.notifyTimeline(request,user,NOTIFICATION_TYPE,NOTIFICATION_TYPE + ""String_Node_Str"",recipients,blogId,""String_Node_Str"",p);
                  }
 catch (                  IOException e) {
                    log.error(""String_Node_Str"",e);
                  }
                }
              }
            }
);
          }
        }
      }
    }
);
  }
}","@Override public void notifyShare(final HttpServerRequest request,final String blogId,final UserInfos user,final JsonArray sharedArray,final String resourceUri){
  if (sharedArray != null && user != null && blogId != null && request != null && resourceUri != null) {
    QueryBuilder query=QueryBuilder.start(""String_Node_Str"").is(blogId);
    JsonObject keys=new JsonObject().putNumber(""String_Node_Str"",1);
    mongo.findOne(""String_Node_Str"",MongoQueryBuilder.build(query),keys,new Handler<Message<JsonObject>>(){
      @Override public void handle(      final Message<JsonObject> event){
        if (""String_Node_Str"".equals(event.body().getString(""String_Node_Str""))) {
          List<String> shareIds=getSharedIds(sharedArray);
          if (!shareIds.isEmpty()) {
            Map<String,Object> params=new HashMap<>();
            params.put(""String_Node_Str"",user.getUserId());
            neo.send(neoQuery(shareIds),params,new Handler<Message<JsonObject>>(){
              @Override public void handle(              Message<JsonObject> res){
                if (""String_Node_Str"".equals(res.body().getString(""String_Node_Str""))) {
                  JsonObject r=res.body().getObject(""String_Node_Str"");
                  List<String> recipients=new ArrayList<>();
                  for (                  String attr : r.getFieldNames()) {
                    String id=r.getObject(attr).getString(""String_Node_Str"");
                    if (id != null) {
                      recipients.add(id);
                    }
                  }
                  String blogTitle=event.body().getObject(""String_Node_Str"",new JsonObject()).getString(""String_Node_Str"");
                  JsonObject p=new JsonObject().putString(""String_Node_Str"",container.config().getString(""String_Node_Str"") + ""String_Node_Str"" + user.getUserId()+ ""String_Node_Str""+ user.getType()).putString(""String_Node_Str"",user.getUsername()).putString(""String_Node_Str"",blogTitle).putString(""String_Node_Str"",resourceUri);
                  notification.notifyTimeline(request,user,NOTIFICATION_TYPE,NOTIFICATION_TYPE + ""String_Node_Str"",recipients,blogId,""String_Node_Str"",p);
                }
              }
            }
);
          }
        }
      }
    }
);
  }
}",0.9530546623794212
87154,"@Override public void notifyUpdateBlog(final HttpServerRequest request,final String blogId,final UserInfos user,final String resourceUri){
  if (resourceUri != null && user != null && blogId != null && request != null) {
    QueryBuilder query=QueryBuilder.start(""String_Node_Str"").is(blogId);
    JsonObject keys=new JsonObject().putNumber(""String_Node_Str"",1).putNumber(""String_Node_Str"",1);
    findRecipiants(""String_Node_Str"",query,keys,null,user,new Handler<Map<String,Object>>(){
      @Override public void handle(      Map<String,Object> event){
        if (event != null) {
          List<String> recipients=(List<String>)event.get(""String_Node_Str"");
          JsonObject blog=(JsonObject)event.get(""String_Node_Str"");
          if (recipients != null) {
            JsonObject p=new JsonObject().putString(""String_Node_Str"",container.config().getString(""String_Node_Str"") + ""String_Node_Str"" + user.getUserId()+ ""String_Node_Str""+ user.getType()).putString(""String_Node_Str"",user.getUsername()).putString(""String_Node_Str"",blog.getString(""String_Node_Str"")).putString(""String_Node_Str"",resourceUri);
            try {
              notification.notifyTimeline(request,user,NOTIFICATION_TYPE,NOTIFICATION_TYPE + ""String_Node_Str"",recipients,blogId,""String_Node_Str"",p);
            }
 catch (            IOException e) {
              log.error(""String_Node_Str"",e);
            }
          }
        }
      }
    }
);
  }
}","@Override public void notifyUpdateBlog(final HttpServerRequest request,final String blogId,final UserInfos user,final String resourceUri){
  if (resourceUri != null && user != null && blogId != null && request != null) {
    QueryBuilder query=QueryBuilder.start(""String_Node_Str"").is(blogId);
    JsonObject keys=new JsonObject().putNumber(""String_Node_Str"",1).putNumber(""String_Node_Str"",1);
    findRecipiants(""String_Node_Str"",query,keys,null,user,new Handler<Map<String,Object>>(){
      @Override public void handle(      Map<String,Object> event){
        if (event != null) {
          List<String> recipients=(List<String>)event.get(""String_Node_Str"");
          JsonObject blog=(JsonObject)event.get(""String_Node_Str"");
          if (recipients != null) {
            JsonObject p=new JsonObject().putString(""String_Node_Str"",container.config().getString(""String_Node_Str"") + ""String_Node_Str"" + user.getUserId()+ ""String_Node_Str""+ user.getType()).putString(""String_Node_Str"",user.getUsername()).putString(""String_Node_Str"",blog.getString(""String_Node_Str"")).putString(""String_Node_Str"",resourceUri);
            notification.notifyTimeline(request,user,NOTIFICATION_TYPE,NOTIFICATION_TYPE + ""String_Node_Str"",recipients,blogId,""String_Node_Str"",p);
          }
        }
      }
    }
);
  }
}",0.9354250273622764
87155,"@Override public void notifyPublishPost(final HttpServerRequest request,final String blogId,final String postId,final UserInfos user,final String resourceUri){
  if (resourceUri != null && user != null && blogId != null && request != null) {
    QueryBuilder query=QueryBuilder.start(""String_Node_Str"").is(postId);
    JsonObject keys=new JsonObject().putNumber(""String_Node_Str"",1).putNumber(""String_Node_Str"",1);
    JsonArray fetch=new JsonArray().addString(""String_Node_Str"");
    findRecipiants(""String_Node_Str"",query,keys,fetch,user,new Handler<Map<String,Object>>(){
      @Override public void handle(      Map<String,Object> event){
        if (event != null) {
          List<String> recipients=(List<String>)event.get(""String_Node_Str"");
          JsonObject blog=(JsonObject)event.get(""String_Node_Str"");
          if (recipients != null) {
            JsonObject p=new JsonObject().putString(""String_Node_Str"",container.config().getString(""String_Node_Str"") + ""String_Node_Str"" + user.getUserId()+ ""String_Node_Str""+ user.getType()).putString(""String_Node_Str"",user.getUsername()).putString(""String_Node_Str"",blog.getObject(""String_Node_Str"",new JsonObject()).getString(""String_Node_Str"")).putString(""String_Node_Str"",resourceUri).putString(""String_Node_Str"",blog.getString(""String_Node_Str"")).putString(""String_Node_Str"",resourceUri + ""String_Node_Str"" + postId);
            try {
              notification.notifyTimeline(request,user,NOTIFICATION_TYPE,NOTIFICATION_TYPE + ""String_Node_Str"",recipients,blogId,postId,""String_Node_Str"",p);
            }
 catch (            IOException e) {
              log.error(""String_Node_Str"",e);
            }
          }
        }
      }
    }
);
  }
}","@Override public void notifyPublishPost(final HttpServerRequest request,final String blogId,final String postId,final UserInfos user,final String resourceUri){
  if (resourceUri != null && user != null && blogId != null && request != null) {
    QueryBuilder query=QueryBuilder.start(""String_Node_Str"").is(postId);
    JsonObject keys=new JsonObject().putNumber(""String_Node_Str"",1).putNumber(""String_Node_Str"",1);
    JsonArray fetch=new JsonArray().addString(""String_Node_Str"");
    findRecipiants(""String_Node_Str"",query,keys,fetch,user,new Handler<Map<String,Object>>(){
      @Override public void handle(      Map<String,Object> event){
        if (event != null) {
          List<String> recipients=(List<String>)event.get(""String_Node_Str"");
          JsonObject blog=(JsonObject)event.get(""String_Node_Str"");
          if (recipients != null) {
            JsonObject p=new JsonObject().putString(""String_Node_Str"",container.config().getString(""String_Node_Str"") + ""String_Node_Str"" + user.getUserId()+ ""String_Node_Str""+ user.getType()).putString(""String_Node_Str"",user.getUsername()).putString(""String_Node_Str"",blog.getObject(""String_Node_Str"",new JsonObject()).getString(""String_Node_Str"")).putString(""String_Node_Str"",resourceUri).putString(""String_Node_Str"",blog.getString(""String_Node_Str"")).putString(""String_Node_Str"",resourceUri + ""String_Node_Str"" + postId);
            notification.notifyTimeline(request,user,NOTIFICATION_TYPE,NOTIFICATION_TYPE + ""String_Node_Str"",recipients,blogId,postId,""String_Node_Str"",p);
          }
        }
      }
    }
);
  }
}",0.9461842505320768
87156,"public TimelineHelper(Vertx vertx,EventBus eb,Container container){
  this.eb=eb;
  this.render=new Renders(container);
  this.vertx=vertx;
  loadTimelineI18n();
}","public TimelineHelper(Vertx vertx,EventBus eb,Container container){
  this.eb=eb;
  this.render=new Renders(vertx,container);
  this.vertx=vertx;
  loadTimelineI18n();
}",0.9819277108433736
87157,"public void notifyTimeline(HttpServerRequest request,UserInfos sender,String type,String eventType,List<String> recipients,String resource,String subResource,String template,JsonObject params) throws IOException {
  JsonArray r=new JsonArray();
  for (  String userId : recipients) {
    r.addObject(new JsonObject().putString(""String_Node_Str"",userId).putNumber(""String_Node_Str"",1));
  }
  JsonObject event=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",resource).putString(""String_Node_Str"",type).putString(""String_Node_Str"",eventType).putString(""String_Node_Str"",sender.getUserId()).putString(""String_Node_Str"",render.processTemplate(request,template,params)).putArray(""String_Node_Str"",r);
  if (subResource != null && !subResource.trim().isEmpty()) {
    event.putString(""String_Node_Str"",subResource);
  }
  eb.send(TIMELINE_ADDRESS,event);
}","public void notifyTimeline(HttpServerRequest request,UserInfos sender,String type,final String eventType,List<String> recipients,String resource,String subResource,String template,JsonObject params){
  JsonArray r=new JsonArray();
  for (  String userId : recipients) {
    r.addObject(new JsonObject().putString(""String_Node_Str"",userId).putNumber(""String_Node_Str"",1));
  }
  final JsonObject event=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",resource).putString(""String_Node_Str"",type).putString(""String_Node_Str"",eventType).putString(""String_Node_Str"",sender.getUserId()).putArray(""String_Node_Str"",r);
  if (subResource != null && !subResource.trim().isEmpty()) {
    event.putString(""String_Node_Str"",subResource);
  }
  render.processTemplate(request,template,params,new Handler<String>(){
    @Override public void handle(    String message){
      if (message != null) {
        event.putString(""String_Node_Str"",message);
        eb.send(TIMELINE_ADDRESS,event);
      }
 else {
        log.error(""String_Node_Str"" + eventType + ""String_Node_Str"");
      }
    }
  }
);
}",0.6248146317350469
87158,"private void timelineNotification(HttpServerRequest request,JsonObject sentMessage,UserInfos user){
  log.debug(sentMessage.encode());
  JsonArray r=sentMessage.getArray(""String_Node_Str"");
  String id=sentMessage.getString(""String_Node_Str"");
  String subject=sentMessage.getString(""String_Node_Str"",""String_Node_Str"");
  sentMessage.removeField(""String_Node_Str"");
  sentMessage.removeField(""String_Node_Str"");
  sentMessage.removeField(""String_Node_Str"");
  if (r == null || id == null || user == null) {
    return;
  }
  final JsonObject params=new JsonObject().putString(""String_Node_Str"",container.config().getString(""String_Node_Str"") + ""String_Node_Str"" + user.getUserId()+ ""String_Node_Str""+ user.getType()).putString(""String_Node_Str"",user.getUsername()).putString(""String_Node_Str"",subject).putString(""String_Node_Str"",container.config().getString(""String_Node_Str"",""String_Node_Str"") + pathPrefix + ""String_Node_Str""+ id);
  String type=container.config().getString(""String_Node_Str"",Conversation.class.getSimpleName()).toUpperCase();
  List<String> recipients=new ArrayList<>();
  for (  Object o : r) {
    if (!(o instanceof String))     continue;
    recipients.add((String)o);
  }
  try {
    notification.notifyTimeline(request,user,type,type + ""String_Node_Str"",recipients,id,""String_Node_Str"",params);
  }
 catch (  IOException|MustacheException e) {
    log.error(""String_Node_Str"",e);
  }
}","private void timelineNotification(HttpServerRequest request,JsonObject sentMessage,UserInfos user){
  log.debug(sentMessage.encode());
  JsonArray r=sentMessage.getArray(""String_Node_Str"");
  String id=sentMessage.getString(""String_Node_Str"");
  String subject=sentMessage.getString(""String_Node_Str"",""String_Node_Str"");
  sentMessage.removeField(""String_Node_Str"");
  sentMessage.removeField(""String_Node_Str"");
  sentMessage.removeField(""String_Node_Str"");
  if (r == null || id == null || user == null) {
    return;
  }
  final JsonObject params=new JsonObject().putString(""String_Node_Str"",container.config().getString(""String_Node_Str"") + ""String_Node_Str"" + user.getUserId()+ ""String_Node_Str""+ user.getType()).putString(""String_Node_Str"",user.getUsername()).putString(""String_Node_Str"",subject).putString(""String_Node_Str"",container.config().getString(""String_Node_Str"",""String_Node_Str"") + pathPrefix + ""String_Node_Str""+ id);
  String type=container.config().getString(""String_Node_Str"",Conversation.class.getSimpleName()).toUpperCase();
  List<String> recipients=new ArrayList<>();
  for (  Object o : r) {
    if (!(o instanceof String))     continue;
    recipients.add((String)o);
  }
  notification.notifyTimeline(request,user,type,type + ""String_Node_Str"",recipients,id,""String_Node_Str"",params);
}",0.9636963696369636
87159,"@Override public void start(){
  super.start();
  final Renders render=new Renders(container);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      render.renderView(request,new JsonObject());
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      request.response().putHeader(""String_Node_Str"",""String_Node_Str"");
      request.response().sendFile(request.params().get(""String_Node_Str"") + ""String_Node_Str"");
    }
  }
);
}","@Override public void start(){
  super.start();
  final Renders render=new Renders(vertx,container);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      render.renderView(request,new JsonObject());
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      request.response().putHeader(""String_Node_Str"",""String_Node_Str"");
      request.response().sendFile(request.params().get(""String_Node_Str"") + ""String_Node_Str"");
    }
  }
);
}",0.9949748743718592
87160,"@SecuredAction(""String_Node_Str"") public void export(final HttpServerRequest request){
  String neoRequest=""String_Node_Str"";
  Map<String,Object> params=new HashMap<>();
  if (request.params().get(""String_Node_Str"").equals(""String_Node_Str"")) {
    neoRequest=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
 else   if (request.params().get(""String_Node_Str"") != null) {
    neoRequest=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    params.put(""String_Node_Str"",request.params().get(""String_Node_Str""));
  }
 else {
    notFound(request);
  }
  neo.send(neoRequest,params,new Handler<Message<JsonObject>>(){
    @Override public void handle(    Message<JsonObject> res){
      if (""String_Node_Str"".equals(res.body().getString(""String_Node_Str""))) {
        JsonArray r=Neo.resultToJsonArray(res.body().getObject(""String_Node_Str""));
        String export;
        try {
          export=processTemplate(request,""String_Node_Str"",new JsonObject().putArray(""String_Node_Str"",r));
          request.response().putHeader(""String_Node_Str"",""String_Node_Str"");
          request.response().putHeader(""String_Node_Str"",""String_Node_Str"");
          request.response().end(export);
        }
 catch (        IOException e) {
          renderError(request);
        }
      }
 else {
        renderError(request);
      }
    }
  }
);
}","@SecuredAction(""String_Node_Str"") public void export(final HttpServerRequest request){
  String neoRequest=""String_Node_Str"";
  Map<String,Object> params=new HashMap<>();
  if (request.params().get(""String_Node_Str"").equals(""String_Node_Str"")) {
    neoRequest=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
 else   if (request.params().get(""String_Node_Str"") != null) {
    neoRequest=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    params.put(""String_Node_Str"",request.params().get(""String_Node_Str""));
  }
 else {
    notFound(request);
  }
  neo.send(neoRequest,params,new Handler<Message<JsonObject>>(){
    @Override public void handle(    Message<JsonObject> res){
      if (""String_Node_Str"".equals(res.body().getString(""String_Node_Str""))) {
        JsonArray r=Neo.resultToJsonArray(res.body().getObject(""String_Node_Str""));
        processTemplate(request,""String_Node_Str"",new JsonObject().putArray(""String_Node_Str"",r),new Handler<String>(){
          @Override public void handle(          String export){
            if (export != null) {
              request.response().putHeader(""String_Node_Str"",""String_Node_Str"");
              request.response().putHeader(""String_Node_Str"",""String_Node_Str"");
              request.response().end(export);
            }
 else {
              renderError(request);
            }
          }
        }
);
      }
 else {
        renderError(request);
      }
    }
  }
);
}",0.8069599474720945
87161,"private void notifyTimeline(final HttpServerRequest request,final UserInfos user){
  UserUtils.findUsersCanSeeMe(eb,request,new Handler<JsonArray>(){
    @Override public void handle(    JsonArray users){
      String action=request.params().get(""String_Node_Str"");
      List<String> userIds=new ArrayList<>();
      for (      Object o : users) {
        JsonObject u=(JsonObject)o;
        userIds.add(u.getString(""String_Node_Str""));
      }
      JsonObject params=new JsonObject().putString(""String_Node_Str"",container.config().getString(""String_Node_Str"") + pathPrefix + ""String_Node_Str""+ user.getUserId()+ ""String_Node_Str""+ user.getType()).putString(""String_Node_Str"",user.getUsername()).putString(""String_Node_Str"",request.params().get(""String_Node_Str"")).putString(""String_Node_Str"",request.params().get(""String_Node_Str""));
      try {
        notification.notifyTimeline(request,user,NOTIFICATION_TYPE,NOTIFICATION_TYPE + ""String_Node_Str"" + action.toUpperCase(),userIds,user.getUserId() + System.currentTimeMillis() + action,""String_Node_Str"" + action + ""String_Node_Str"",params);
      }
 catch (      IOException e) {
        log.error(""String_Node_Str"",e);
      }
    }
  }
);
}","private void notifyTimeline(final HttpServerRequest request,final UserInfos user){
  UserUtils.findUsersCanSeeMe(eb,request,new Handler<JsonArray>(){
    @Override public void handle(    JsonArray users){
      String action=request.params().get(""String_Node_Str"");
      List<String> userIds=new ArrayList<>();
      for (      Object o : users) {
        JsonObject u=(JsonObject)o;
        userIds.add(u.getString(""String_Node_Str""));
      }
      JsonObject params=new JsonObject().putString(""String_Node_Str"",container.config().getString(""String_Node_Str"") + pathPrefix + ""String_Node_Str""+ user.getUserId()+ ""String_Node_Str""+ user.getType()).putString(""String_Node_Str"",user.getUsername()).putString(""String_Node_Str"",request.params().get(""String_Node_Str"")).putString(""String_Node_Str"",request.params().get(""String_Node_Str""));
      notification.notifyTimeline(request,user,NOTIFICATION_TYPE,NOTIFICATION_TYPE + ""String_Node_Str"" + action.toUpperCase(),userIds,user.getUserId() + System.currentTimeMillis() + action,""String_Node_Str"" + action + ""String_Node_Str"",params);
    }
  }
);
}",0.9533362407326648
87162,"@Override public void start(){
  super.start();
  neo=new Neo(vertx.eventBus(),log);
  final JsonObject userBookData=new JsonObject(vertx.fileSystem().readFileSync(""String_Node_Str"").toString());
  final JsonArray hobbies=userBookData.getArray(""String_Node_Str"");
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      if (request.params().contains(""String_Node_Str"")) {
        neo.send(""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ userBookData.getString(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str"");
        for (        Object hobby : hobbies) {
          JsonObject jo=(JsonObject)hobby;
          neo.send(""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ jo.getString(""String_Node_Str"")+ ""String_Node_Str"");
        }
      }
      renderView(request,new JsonObject());
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      renderView(request);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String neoRequest=""String_Node_Str"";
      if (request.params().contains(""String_Node_Str"")) {
        neoRequest+=""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"").substring(0,3) + ""String_Node_Str"";
      }
 else       if (request.params().contains(""String_Node_Str"")) {
        neoRequest+=""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str"";
      }
      neoRequest+=""String_Node_Str"" + ""String_Node_Str"";
      neo.send(neoRequest,request.response());
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      if (request.params().contains(""String_Node_Str"")) {
        neo.send(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",request.response());
      }
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      if (request.params().contains(""String_Node_Str"")) {
        neo.send(""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str"",request.response());
      }
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str""));
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
    }
  }
);
}","@Override public void start(){
  super.start();
  neo=new Neo(vertx.eventBus(),log);
  final JsonObject userBookData=new JsonObject(vertx.fileSystem().readFileSync(""String_Node_Str"").toString());
  final JsonArray hobbies=userBookData.getArray(""String_Node_Str"");
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      if (request.params().contains(""String_Node_Str"")) {
        neo.send(""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ userBookData.getString(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str"");
        for (        Object hobby : hobbies) {
          JsonObject jo=(JsonObject)hobby;
          neo.send(""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ jo.getString(""String_Node_Str"")+ ""String_Node_Str"");
        }
      }
      renderView(request,new JsonObject());
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      renderView(request);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String neoRequest=""String_Node_Str"";
      if (request.params().contains(""String_Node_Str"")) {
        neoRequest+=""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"").substring(0,3) + ""String_Node_Str"";
      }
 else       if (request.params().contains(""String_Node_Str"")) {
        neoRequest+=""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str"";
      }
      neoRequest+=""String_Node_Str"" + ""String_Node_Str"";
      neo.send(neoRequest,request.response());
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      if (request.params().contains(""String_Node_Str"")) {
        neo.send(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",request.response());
      }
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      if (request.params().contains(""String_Node_Str"")) {
        neo.send(""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str"",request.response());
      }
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str"")+ ""String_Node_Str"");
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
    }
  }
);
}",0.9940754599314
87163,"@Override public void start(){
  try {
    developerId=vertx.fileSystem().readFileSync(""String_Node_Str"").toString().trim();
    config=getConfig(""String_Node_Str"",""String_Node_Str"");
    super.start();
    neo=new Neo(vertx.eventBus(),log);
    deployApps();
  }
 catch (  Exception ex) {
    log.equals(ex.getMessage());
  }
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    public void handle(    HttpServerRequest request){
      renderView(request);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    public void handle(    final HttpServerRequest request){
      neo.send(request);
    }
  }
);
}","@Override public void start(){
  try {
    developerId=vertx.fileSystem().readFileSync(""String_Node_Str"").toString().trim();
    config=getConfig(""String_Node_Str"",""String_Node_Str"");
    super.start();
    neo=new Neo(vertx.eventBus(),log);
    deployApps();
  }
 catch (  Exception ex) {
    log.error(ex.getMessage());
  }
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    public void handle(    HttpServerRequest request){
      renderView(request);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    public void handle(    final HttpServerRequest request){
      neo.send(request);
    }
  }
);
}",0.993006993006993
87164,"@Override public void start() throws Exception {
  super.start();
  neo=new Neo(vertx.eventBus(),log);
  d=new DefaultDictionary(vertx,container,""String_Node_Str"");
  dataMock=new JsonObject(vertx.fileSystem().readFileSync(""String_Node_Str"").toString());
  container.deployModule(""String_Node_Str"");
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      renderView(request,new JsonObject());
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String schoolId=request.params().get(""String_Node_Str"");
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + schoolId + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String classId=request.params().get(""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + classId + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String personId=request.params().get(""String_Node_Str"");
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + personId + ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String classId=request.params().get(""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
      System.out.println(""String_Node_Str"" + classId);
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + classId + ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      JsonObject obj=new JsonObject();
      Map<String,Boolean> params=d.validateFields(request.params());
      if (!params.values().contains(false)) {
        trace.info(""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ request.params().get(""String_Node_Str""));
        neo.send(""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str"",request.response);
      }
 else {
        obj.putString(""String_Node_Str"",""String_Node_Str"");
        for (        Map.Entry<String,Boolean> entry : params.entrySet()) {
          obj.putBoolean(entry.getKey(),entry.getValue());
        }
        renderJson(request,obj);
      }
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String neoRequest=createExportRequest(request.params());
      trace.info(""String_Node_Str"" + request.params().get(""String_Node_Str""));
      neo.send(neoRequest,request.response);
    }
  }
);
}","@Override public void start() throws Exception {
  super.start();
  neo=new Neo(vertx.eventBus(),log);
  d=new DefaultDictionary(vertx,container,""String_Node_Str"");
  dataMock=new JsonObject(vertx.fileSystem().readFileSync(""String_Node_Str"").toString());
  container.deployModule(""String_Node_Str"");
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      renderView(request,new JsonObject());
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String schoolId=request.params().get(""String_Node_Str"");
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + schoolId + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String classId=request.params().get(""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + classId + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String personId=request.params().get(""String_Node_Str"");
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + personId + ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String classId=request.params().get(""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
      System.out.println(""String_Node_Str"" + classId);
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + classId + ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      JsonObject obj=new JsonObject();
      Map<String,Boolean> params=d.validateFields(request.params());
      if (!params.values().contains(false)) {
        trace.info(""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ request.params().get(""String_Node_Str""));
        neo.send(""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str"",request.response);
      }
 else {
        obj.putString(""String_Node_Str"",""String_Node_Str"");
        for (        Map.Entry<String,Boolean> entry : params.entrySet()) {
          if (!entry.getValue()) {
            obj.putBoolean(entry.getKey(),entry.getValue());
          }
        }
        renderJson(request,obj);
      }
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String neoRequest=createExportRequest(request.params());
      trace.info(""String_Node_Str"" + request.params().get(""String_Node_Str""));
      neo.send(neoRequest,request.response);
    }
  }
);
}",0.9936831249194276
87165,"@Override public void start() throws Exception {
  super.start();
  neo=new Neo(vertx.eventBus(),log);
  d=new DefaultDictionary(vertx,container,""String_Node_Str"");
  dataMock=new JsonObject(vertx.fileSystem().readFileSync(""String_Node_Str"").toString());
  container.deployModule(""String_Node_Str"");
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      renderView(request,new JsonObject());
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String schoolId=request.params().get(""String_Node_Str"");
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + schoolId + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String classId=request.params().get(""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + classId + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String personId=request.params().get(""String_Node_Str"");
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + personId + ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String classId=request.params().get(""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
      System.out.println(""String_Node_Str"" + classId);
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + classId + ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      JsonObject obj=new JsonObject();
      Map<String,Boolean> params=d.validateFields(request.params());
      if (!params.values().contains(false)) {
        trace.info(""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ request.params().get(""String_Node_Str""));
        neo.send(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str"",request.response);
      }
 else {
        obj.putString(""String_Node_Str"",""String_Node_Str"");
        for (        Map.Entry<String,Boolean> entry : params.entrySet()) {
          if (!entry.getValue()) {
            obj.putString(entry.getKey(),""String_Node_Str"");
          }
        }
        renderJson(request,obj);
      }
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String neoRequest=createExportRequest(request.params());
      trace.info(""String_Node_Str"" + request.params().get(""String_Node_Str""));
      neo.send(neoRequest,request.response);
    }
  }
);
}","@Override public void start() throws Exception {
  super.start();
  neo=new Neo(vertx.eventBus(),log);
  d=new DefaultDictionary(vertx,container,""String_Node_Str"");
  dataMock=new JsonObject(vertx.fileSystem().readFileSync(""String_Node_Str"").toString());
  container.deployModule(""String_Node_Str"");
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      renderView(request,new JsonObject());
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String schoolId=request.params().get(""String_Node_Str"");
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + schoolId + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String classId=request.params().get(""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + classId + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String personId=request.params().get(""String_Node_Str"");
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + personId + ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String classId=request.params().get(""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
      System.out.println(""String_Node_Str"" + classId);
      neo.send(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + classId + ""String_Node_Str""+ ""String_Node_Str"",request.response);
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      JsonObject obj=new JsonObject();
      Map<String,Boolean> params=d.validateFields(request.params());
      if (!params.values().contains(false)) {
        trace.info(""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ request.params().get(""String_Node_Str""));
        neo.send(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + request.params().get(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ request.params().get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str"",request.response);
      }
 else {
        obj.putString(""String_Node_Str"",""String_Node_Str"");
        for (        Map.Entry<String,Boolean> entry : params.entrySet()) {
          obj.putBoolean(entry.getKey(),entry.getValue());
        }
        renderJson(request,obj);
      }
    }
  }
);
  rm.get(""String_Node_Str"",new Handler<HttpServerRequest>(){
    @Override public void handle(    HttpServerRequest request){
      String neoRequest=createExportRequest(request.params());
      trace.info(""String_Node_Str"" + request.params().get(""String_Node_Str""));
      neo.send(neoRequest,request.response);
    }
  }
);
}",0.9846029173419774
87166,"public void performOperation(AtomicOperation executionOperation,ExecutionEntity execution){
  List<DebugSession> openSessions=debugSessionFactory.getSessions();
  final ExecutionEntity executionEntity=(ExecutionEntity)execution;
  if (openSessions.isEmpty()) {
    if (debugSessionFactory.isSuspend()) {
      debugSessionFactory.waitForOpenSession(new SuspendedExecutionImpl(executionEntity,executionOperation));
    }
 else {
      super.performOperation(executionOperation,executionEntity);
      return;
    }
  }
  DebugSessionImpl currentSession=null;
  BreakPoint breakPoint=null;
  if (NEXT_STEP_BREAK_POINT.get() != null) {
    StepBreakPoint stepBreakPoint=NEXT_STEP_BREAK_POINT.get();
    if (stepBreakPoint.breakOnOperation(executionOperation,executionEntity)) {
      NEXT_STEP_BREAK_POINT.remove();
      breakPoint=stepBreakPoint;
      currentSession=stepBreakPoint.getSession();
    }
  }
 else {
synchronized (DebugSessionFactory.getInstance()) {
      openSessions=debugSessionFactory.getSessions();
      for (      DebugSession debugSession : openSessions) {
        if (execution.getProcessInstanceId().equals(debugSession.getProcessInstanceId())) {
          currentSession=(DebugSessionImpl)debugSession;
          try {
            breakPoint=findBreakPoint(debugSession,executionOperation,executionEntity);
          }
 catch (          RuntimeException e) {
            currentSession.execption(e,execution,executionOperation);
            throw e;
          }
          break;
        }
 else         if (debugSession.getProcessInstanceId() == null) {
          if (currentSession == null) {
            try {
              breakPoint=findBreakPoint(debugSession,executionOperation,execution);
            }
 catch (            RuntimeException e) {
              ((DebugSessionImpl)debugSession).execption(e,execution,executionOperation);
              throw e;
            }
            if (breakPoint != null) {
              currentSession=(DebugSessionImpl)debugSession;
            }
          }
        }
      }
    }
  }
  boolean isSuspended=false;
  if (currentSession != null && breakPoint != null) {
    if (currentSession.getProcessInstanceId() == null) {
      currentSession.setProcessInstanceId(execution.getProcessInstanceId());
    }
    isSuspended=true;
    SuspendedExecutionImpl suspendedExecution=new SuspendedExecutionImpl((ExecutionEntity)execution,executionOperation,breakPoint);
    currentSession.suspend(suspendedExecution);
    if (suspendedExecution.isStep) {
      NEXT_STEP_BREAK_POINT.set(new StepBreakPoint(BEFORE_ACTIVITY.equals(breakPoint.getBreakPointSpec()) ? AFTER_ACTIVITY : BEFORE_ACTIVITY,currentSession));
    }
  }
  try {
    super.performOperation(executionOperation,execution);
    if (currentSession != null) {
      ExecutionEntity processInstance=execution.getProcessInstance();
      if (processInstance.isEnded()) {
        currentSession.setProcessInstanceId(null);
      }
    }
  }
 catch (  RuntimeException e) {
    if (isSuspended) {
      currentSession.execption(e,execution,executionOperation);
    }
    throw e;
  }
}","public void performOperation(AtomicOperation executionOperation,ExecutionEntity execution,boolean async){
  List<DebugSession> openSessions=debugSessionFactory.getSessions();
  final ExecutionEntity executionEntity=(ExecutionEntity)execution;
  if (openSessions.isEmpty()) {
    if (debugSessionFactory.isSuspend()) {
      debugSessionFactory.waitForOpenSession(new SuspendedExecutionImpl(executionEntity,executionOperation));
    }
 else {
      super.performOperation(executionOperation,executionEntity,async);
      return;
    }
  }
  DebugSessionImpl currentSession=null;
  BreakPoint breakPoint=null;
  if (NEXT_STEP_BREAK_POINT.get() != null) {
    StepBreakPoint stepBreakPoint=NEXT_STEP_BREAK_POINT.get();
    if (stepBreakPoint.breakOnOperation(executionOperation,executionEntity)) {
      NEXT_STEP_BREAK_POINT.remove();
      breakPoint=stepBreakPoint;
      currentSession=stepBreakPoint.getSession();
    }
  }
 else {
synchronized (DebugSessionFactory.getInstance()) {
      openSessions=debugSessionFactory.getSessions();
      for (      DebugSession debugSession : openSessions) {
        if (execution.getProcessInstanceId().equals(debugSession.getProcessInstanceId())) {
          currentSession=(DebugSessionImpl)debugSession;
          try {
            breakPoint=findBreakPoint(debugSession,executionOperation,executionEntity);
          }
 catch (          RuntimeException e) {
            currentSession.execption(e,execution,executionOperation);
            throw e;
          }
          break;
        }
 else         if (debugSession.getProcessInstanceId() == null) {
          if (currentSession == null) {
            try {
              breakPoint=findBreakPoint(debugSession,executionOperation,execution);
            }
 catch (            RuntimeException e) {
              ((DebugSessionImpl)debugSession).execption(e,execution,executionOperation);
              throw e;
            }
            if (breakPoint != null) {
              currentSession=(DebugSessionImpl)debugSession;
            }
          }
        }
      }
    }
  }
  boolean isSuspended=false;
  if (currentSession != null && breakPoint != null) {
    if (currentSession.getProcessInstanceId() == null) {
      currentSession.setProcessInstanceId(execution.getProcessInstanceId());
    }
    isSuspended=true;
    SuspendedExecutionImpl suspendedExecution=new SuspendedExecutionImpl((ExecutionEntity)execution,executionOperation,breakPoint);
    currentSession.suspend(suspendedExecution);
    if (suspendedExecution.isStep) {
      NEXT_STEP_BREAK_POINT.set(new StepBreakPoint(BEFORE_ACTIVITY.equals(breakPoint.getBreakPointSpec()) ? AFTER_ACTIVITY : BEFORE_ACTIVITY,currentSession));
    }
  }
  try {
    super.performOperation(executionOperation,execution,async);
    if (currentSession != null) {
      ExecutionEntity processInstance=execution.getProcessInstance();
      if (processInstance.isEnded()) {
        currentSession.setProcessInstanceId(null);
      }
    }
  }
 catch (  RuntimeException e) {
    if (isSuspended) {
      currentSession.execption(e,execution,executionOperation);
    }
    throw e;
  }
}",0.9958373358949728
87167,"public boolean breakOnOperation(AtomicOperation operation,ExecutionEntity execution){
  boolean shouldBreak=true;
  shouldBreak&=processDefinitionId.equals(execution.getProcessDefinitionId());
  if (AT_TRANSITION.equals(breakPointSpec)) {
    shouldBreak&=transitionId.equals(execution.getTransitionBeingTaken().getId());
  }
 else {
    shouldBreak&=activityId.equals(execution.getActivityId());
  }
  shouldBreak&=breakPointSpec.breakOnOperation(operation);
  if (shouldBreak && condition != null) {
    shouldBreak&=condition.evaluate(execution);
  }
  return shouldBreak;
}","public boolean breakOnOperation(AtomicOperation operation,ExecutionEntity execution){
  boolean shouldBreak=true;
  shouldBreak&=processDefinitionId.equals(execution.getProcessDefinitionId());
  if (AT_TRANSITION.equals(breakPointSpec)) {
    shouldBreak&=transitionId.equals(execution.getCurrentTransitionId());
  }
 else {
    shouldBreak&=activityId.equals(execution.getActivityId());
  }
  shouldBreak&=breakPointSpec.breakOnOperation(operation);
  if (shouldBreak && condition != null) {
    shouldBreak&=condition.evaluate(execution);
  }
  return shouldBreak;
}",0.616593886462882
87168,"public boolean breakOnOperation(AtomicOperation operation,ExecutionEntity execution){
  boolean shouldBreak=true;
  shouldBreak&=processDefinitionId.equals(execution.getProcessDefinitionId());
  if (AT_TRANSITION.equals(breakPointSpec)) {
    shouldBreak&=transitionId.equals(execution.getTransitionBeingTaken().getId());
  }
 else {
    shouldBreak&=activityId.equals(execution.getActivityId());
  }
  shouldBreak&=breakPointSpec.breakOnOperation(operation);
  if (condition != null) {
    shouldBreak&=condition.evaluate(execution);
  }
  return shouldBreak;
}","public boolean breakOnOperation(AtomicOperation operation,ExecutionEntity execution){
  boolean shouldBreak=true;
  shouldBreak&=processDefinitionId.equals(execution.getProcessDefinitionId());
  if (AT_TRANSITION.equals(breakPointSpec)) {
    shouldBreak&=transitionId.equals(execution.getTransitionBeingTaken().getId());
  }
 else {
    shouldBreak&=activityId.equals(execution.getActivityId());
  }
  shouldBreak&=breakPointSpec.breakOnOperation(operation);
  if (shouldBreak && condition != null) {
    shouldBreak&=condition.evaluate(execution);
  }
  return shouldBreak;
}",0.9868305531167691
87169,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseStatus(value=HttpStatus.OK) public void generateBlogViews() throws Exception {
  log.debug(""String_Node_Str"");
  long threeMonthsAgo=DateTime.now().minusMonths(3).getMillis();
  blogViewWriteRepository.clear(threeMonthsAgo);
  List<Blog> blogs=blogReadRepository.findAfterTime(threeMonthsAgo);
  long now=DateTime.now().getMillis();
  List<BlogView> blogViews=Lists.newArrayList();
  for (  Blog blog : blogs) {
    Long blogId=blog.getId();
    Long blogTime=blog.getTime();
    int preView=blog.getView();
    String link=blog.getLink();
    int total=DbaUtil.isCsdn(link) ? csdnFetcher.fetchView(link) : iteyeFetcher.fetchView(link);
    int increment=blogViewReadRepository.findByBlogId(blogId).isEmpty() ? total : (total - preView);
    blogViews.add(new BlogView(blogId,total,increment,blogTime,now));
  }
  log.debug(format(""String_Node_Str"",blogViews));
  blogViewWriteRepository.save(blogViews);
  log.debug(""String_Node_Str"");
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseStatus(value=HttpStatus.OK) public void generateBlogViews() throws Exception {
  log.debug(""String_Node_Str"");
  long threeMonthsAgo=DateTime.now().minusMonths(3).getMillis();
  blogViewWriteRepository.clear(threeMonthsAgo);
  List<Blog> blogs=blogReadRepository.findAfterTime(threeMonthsAgo);
  long now=DateTime.now().getMillis();
  List<BlogView> blogViews=Lists.newArrayList();
  for (  Blog blog : blogs) {
    Long blogId=blog.getId();
    Long blogTime=blog.getTime();
    int preView=blog.getView();
    String link=blog.getLink();
    int total=DbaUtil.isCsdn(link) ? csdnFetcher.fetchView(link) : iteyeFetcher.fetchView(link);
    if (total == -1)     continue;
    int increment=blogViewReadRepository.findByBlogId(blogId).isEmpty() ? total : (total - preView);
    blogViews.add(new BlogView(blogId,total,increment,blogTime,now));
  }
  log.debug(format(""String_Node_Str"",blogViews));
  blogViewWriteRepository.save(blogViews);
  log.debug(""String_Node_Str"");
}",0.9830179524502668
87170,"public int fetchView(String url) throws Exception {
  Document doc=fetchUrlDoc(url);
  return fetchNumber(doc.select(""String_Node_Str"").get(0).text());
}","public int fetchView(String url) throws Exception {
  Document doc=fetchUrlDoc(url);
  if (doc == null)   return -1;
  return fetchNumber(doc.select(""String_Node_Str"").get(0).text());
}",0.9053254437869822
87171,"private BatchBlogs fetchPage(String url) throws Exception {
  Document doc=fetchUrlDoc(url);
  BatchBlogs batchBlogs=new BatchBlogs();
  batchBlogs.addAllBatchBlogs(fetchBlogs(doc,""String_Node_Str""));
  batchBlogs.addAllBatchBlogs(fetchBlogs(doc,""String_Node_Str""));
  return batchBlogs;
}","private BatchBlogs fetchPage(String url) throws Exception {
  Document doc=fetchUrlDoc(url);
  if (doc == null)   return new BatchBlogs();
  BatchBlogs batchBlogs=new BatchBlogs();
  batchBlogs.addAllBatchBlogs(fetchBlogs(doc,""String_Node_Str""));
  batchBlogs.addAllBatchBlogs(fetchBlogs(doc,""String_Node_Str""));
  return batchBlogs;
}",0.9262820512820512
87172,"private int getTotalPage(String url) throws Exception {
  Document doc=fetchUrlDoc(url);
  Elements statistics=doc.select(""String_Node_Str"");
  int total=0;
  for (int i=0; i <= 2; i++) {
    total+=fetchNumber(statistics.get(i).text());
  }
  return (int)Math.ceil(total / CSDN_PAGE_COUNT);
}","private int getTotalPage(String url) throws Exception {
  Document doc=fetchUrlDoc(url);
  if (doc == null)   return 1;
  Elements statistics=doc.select(""String_Node_Str"");
  int total=0;
  for (int i=0; i <= 2; i++) {
    total+=fetchNumber(statistics.get(i).text());
  }
  return (int)Math.ceil(total / CSDN_PAGE_COUNT);
}",0.9497568881685576
87173,"public int fetchView(String url) throws Exception {
  Document doc=fetchUrlDoc(url);
  return fetchNumber(doc.select(""String_Node_Str"").get(1).text());
}","public int fetchView(String url) throws Exception {
  Document doc=fetchUrlDoc(url);
  if (doc == null)   return -1;
  return fetchNumber(doc.select(""String_Node_Str"").get(1).text());
}",0.9053254437869822
87174,"private BatchBlogs fetchBlogs(String url) throws Exception {
  BatchBlogs batchBlogs=new BatchBlogs();
  Document doc=fetchUrlDoc(url);
  Elements blogs=doc.select(""String_Node_Str"");
  log.debug(""String_Node_Str"" + blogs.size());
  for (  Element blogElement : blogs) {
    Element titleElement=blogElement.select(""String_Node_Str"").get(0);
    String title=fetchTitle(titleElement);
    String link=url.substring(0,url.lastIndexOf(""String_Node_Str"")) + titleElement.attr(""String_Node_Str"");
    log.debug(format(""String_Node_Str"",link));
    String blogId=fetchBlogId(link);
    long time=parseIteyeTime(blogElement.select(""String_Node_Str"").get(0).text());
    int view=fetchNumber(blogElement.select(""String_Node_Str"").get(1).text());
    int comment=fetchNumber(blogElement.select(""String_Node_Str"").get(2).text());
    Elements tags=blogElement.select(""String_Node_Str"");
    Author author=authorService.fetchAuthor(tags);
    Blog blog=new Blog(title,link,view,comment,time,author,blogId,ITEYE_KEY_WORD);
    Blog result=blogReadRepository.findByBlogIdAndWebsite(blogId,ITEYE_KEY_WORD);
    if (result != null) {
      blog.setId(result.getId());
      batchBlogs.addUpdateBlogs(blog);
      continue;
    }
    batchBlogs.addInsertBlogs(blog);
  }
  return batchBlogs;
}","private BatchBlogs fetchBlogs(String url) throws Exception {
  BatchBlogs batchBlogs=new BatchBlogs();
  Document doc=fetchUrlDoc(url);
  if (doc == null)   return new BatchBlogs();
  Elements blogs=doc.select(""String_Node_Str"");
  log.debug(""String_Node_Str"" + blogs.size());
  for (  Element blogElement : blogs) {
    Element titleElement=blogElement.select(""String_Node_Str"").get(0);
    String title=fetchTitle(titleElement);
    String link=url.substring(0,url.lastIndexOf(""String_Node_Str"")) + titleElement.attr(""String_Node_Str"");
    log.debug(format(""String_Node_Str"",link));
    String blogId=fetchBlogId(link);
    long time=parseIteyeTime(blogElement.select(""String_Node_Str"").get(0).text());
    int view=fetchNumber(blogElement.select(""String_Node_Str"").get(1).text());
    int comment=fetchNumber(blogElement.select(""String_Node_Str"").get(2).text());
    Elements tags=blogElement.select(""String_Node_Str"");
    Author author=authorService.fetchAuthor(tags);
    Blog blog=new Blog(title,link,view,comment,time,author,blogId,ITEYE_KEY_WORD);
    Blog result=blogReadRepository.findByBlogIdAndWebsite(blogId,ITEYE_KEY_WORD);
    if (result != null) {
      blog.setId(result.getId());
      batchBlogs.addUpdateBlogs(blog);
      continue;
    }
    batchBlogs.addInsertBlogs(blog);
  }
  return batchBlogs;
}",0.9823212913143736
87175,"private int getTotalPage(String url) throws Exception {
  Document doc=fetchUrlDoc(url);
  int total=fetchNumber(doc.select(""String_Node_Str"").get(0).text());
  return (int)Math.ceil(total / ITEYE_PAGE_COUNT);
}","private int getTotalPage(String url) throws Exception {
  Document doc=fetchUrlDoc(url);
  if (doc == null)   return 1;
  int total=fetchNumber(doc.select(""String_Node_Str"").get(0).text());
  return (int)Math.ceil(total / ITEYE_PAGE_COUNT);
}",0.9315673289183224
87176,"public static Document fetchUrlDoc(String url) throws IOException {
  return Jsoup.connect(url).userAgent(""String_Node_Str"").get();
}","public static Document fetchUrlDoc(String url) throws IOException {
  try {
    return Jsoup.connect(url).userAgent(""String_Node_Str"").get();
  }
 catch (  Exception e) {
    log.debug(format(""String_Node_Str"",url,e.getMessage()));
    return null;
  }
}",0.6873385012919897
87177,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseStatus(value=HttpStatus.OK) public void generateBlogViews() throws Exception {
  log.debug(""String_Node_Str"");
  long threeMonthsAgo=DateTime.now().minusMonths(3).getMillis();
  blogViewWriteRepository.clear(threeMonthsAgo);
  List<Blog> blogs=blogReadRepository.findAfterTime(threeMonthsAgo);
  long now=DateTime.now().getMillis();
  List<BlogView> blogViews=Lists.newArrayList();
  for (  Blog blog : blogs) {
    Long blogId=blog.getId();
    Long blogTime=blog.getTime();
    int preView=blog.getView();
    String link=blog.getLink();
    int total=DbaUtil.isCsdn(link) ? csdnFetcher.fetchView(link) : iteyeFetcher.fetchView(link);
    if (total == -1)     continue;
    int increment=blogViewReadRepository.findByBlogId(blogId).isEmpty() ? total : (total - preView);
    blogViews.add(new BlogView(blogId,total,increment,blogTime,now));
  }
  log.debug(format(""String_Node_Str"",blogViews));
  blogViewWriteRepository.save(blogViews);
  log.debug(""String_Node_Str"");
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseStatus(value=HttpStatus.OK) public void generateBlogViews() throws Exception {
  log.debug(""String_Node_Str"");
  long threeMonthsAgo=DateTime.now().minusMonths(3).getMillis();
  blogViewWriteRepository.clear(threeMonthsAgo);
  List<Blog> blogs=blogReadRepository.findAfterTime(threeMonthsAgo);
  long now=DateTime.now().getMillis();
  List<BlogView> blogViews=Lists.newArrayList();
  for (  Blog blog : blogs) {
    Long blogId=blog.getId();
    Long blogTime=blog.getTime();
    String link=blog.getLink();
    int total=DbaUtil.isCsdn(link) ? csdnFetcher.fetchView(link) : iteyeFetcher.fetchView(link);
    if (total == -1)     continue;
    List<BlogView> existBlogViews=blogViewReadRepository.findByBlogId(blogId);
    int increment=existBlogViews.isEmpty() ? total : total - existBlogViews.get(existBlogViews.size() - 1).getTotal();
    log.debug(format(""String_Node_Str"",blogId,total,increment));
    blogViews.add(new BlogView(blogId,total,increment,blogTime,now));
  }
  log.debug(format(""String_Node_Str"",blogViews));
  blogViewWriteRepository.save(blogViews);
  log.debug(""String_Node_Str"");
}",0.7762803234501348
87178,"private BatchBlogs fetchBlogs(Document doc,String elementId) throws Exception {
  BatchBlogs batchBlogs=new BatchBlogs();
  Elements blogs=doc.select(format(""String_Node_Str"",elementId));
  log.debug(""String_Node_Str"" + blogs.size());
  for (  Element blogElement : blogs) {
    Element titleLink=blogElement.select(""String_Node_Str"").get(0);
    String link=String.format(""String_Node_Str"",CSDN_INDEX,titleLink.attr(""String_Node_Str""));
    log.debug(format(""String_Node_Str"",link));
    String title=fetchTitle(titleLink);
    String blogId=fetchBlogId(link);
    long time=parseTimeStringToLong(blogElement.select(""String_Node_Str"").get(0).text());
    int view=fetchNumber(blogElement.select(""String_Node_Str"").get(0).text());
    int comment=fetchNumber(blogElement.select(""String_Node_Str"").get(0).text());
    Document detailDoc=fetchUrlDoc(link);
    Elements tags=detailDoc.select(""String_Node_Str"");
    Author author=authorService.fetchAuthor(tags);
    Blog blog=new Blog(title,link,view,comment,time,author,blogId,CSDN_KEY_WORD);
    Blog result=blogReadRepository.findByBlogIdAndWebsite(blogId,CSDN_KEY_WORD);
    if (result != null) {
      blog.setId(result.getId());
      batchBlogs.addUpdateBlogs(blog);
      continue;
    }
    batchBlogs.addInsertBlogs(blog);
  }
  return batchBlogs;
}","private BatchBlogs fetchBlogs(Document doc,String elementId) throws Exception {
  BatchBlogs batchBlogs=new BatchBlogs();
  Elements blogs=doc.select(format(""String_Node_Str"",elementId));
  log.debug(""String_Node_Str"" + blogs.size());
  for (  Element blogElement : blogs) {
    Element titleLink=blogElement.select(""String_Node_Str"").get(0);
    String link=String.format(""String_Node_Str"",CSDN_INDEX,titleLink.attr(""String_Node_Str""));
    log.debug(format(""String_Node_Str"",link));
    String title=fetchTitle(titleLink);
    String blogId=fetchBlogId(link);
    long time=parseTimeStringToLong(blogElement.select(""String_Node_Str"").get(0).text());
    int view=fetchNumber(blogElement.select(""String_Node_Str"").get(0).text());
    int comment=fetchNumber(blogElement.select(""String_Node_Str"").get(0).text());
    Document detailDoc=fetchUrlDoc(link);
    if (detailDoc == null)     continue;
    Elements tags=detailDoc.select(""String_Node_Str"");
    Author author=authorService.fetchAuthor(tags);
    Blog blog=new Blog(title,link,view,comment,time,author,blogId,CSDN_KEY_WORD);
    Blog result=blogReadRepository.findByBlogIdAndWebsite(blogId,CSDN_KEY_WORD);
    if (result != null) {
      blog.setId(result.getId());
      batchBlogs.addUpdateBlogs(blog);
      continue;
    }
    batchBlogs.addInsertBlogs(blog);
  }
  return batchBlogs;
}",0.9845690628528416
87179,"private List<Top> encapsulateResult(long afterTime){
  List<Top> tops=Lists.newArrayList();
  List<DepGroup> groups=depGroupReadRepository.findAll();
  groups.add(new DepGroup(""String_Node_Str"",Author.UNKNOWN));
  for (  DepGroup group : groups) {
    log.debug(format(""String_Node_Str"",group));
    String groupName=group.getName();
    List<Blog> blogs=blogReadRepository.topDetail(afterTime,groupName);
    for (    Blog blog : blogs) {
      List<BlogView> blogViews=blogViewReadRepository.findByBlogId(blog.getId());
      blog.statisticsViewByBlogViews(blogViews);
    }
    Top top=new Top(groupName,blogs.size(),blogs);
    top.calcView();
    tops.add(top);
  }
  sortTopsByView(tops);
  return tops;
}","private List<Top> encapsulateResult(long afterTime){
  List<Top> tops=Lists.newArrayList();
  List<DepGroup> groups=depGroupReadRepository.findAll();
  for (  DepGroup group : groups) {
    log.debug(format(""String_Node_Str"",group));
    String groupName=group.getName();
    List<Blog> blogs=blogReadRepository.topDetail(afterTime,groupName);
    for (    Blog blog : blogs) {
      List<BlogView> blogViews=blogViewReadRepository.findByBlogId(blog.getId());
      blog.statisticsViewByBlogViews(blogViews);
    }
    Top top=new Top(groupName,blogs.size(),blogs);
    top.calcView();
    tops.add(top);
  }
  sortTopsByView(tops);
  return tops;
}",0.3073529411764706
87180,"public void sendMailDirectly(MailInfo mailInfo){
  SaeMail mail=createSaeMailInstance();
  mail.setTo(StringUtils.split(mailInfo.getTo(),""String_Node_Str""));
  mail.setSubject(mailInfo.getSubject());
  mail.setContent(mailInfo.getContent());
  log.debug(format(""String_Node_Str"",mailInfo.getContent()));
  if (!mail.send()) {
    log.debug(""String_Node_Str"");
  }
}","public void sendMailDirectly(MailInfo mailInfo){
  SaeMail mail=createSaeMailInstance();
  mail.setTo(StringUtils.split(mailInfo.getTo(),""String_Node_Str""));
  mail.setSubject(mailInfo.getSubject());
  mail.setContent(mailInfo.getContent());
  log.debug(format(""String_Node_Str"",mailInfo.getTo(),mailInfo.getSubject(),mailInfo.getContent()));
  if (!mail.send()) {
    log.debug(""String_Node_Str"");
  }
}",0.9492847854356308
87181,"public Author fetchAuthor(Elements tags){
  if (tags.size() == 0)   return Author.defaultAuthor();
  String tag=tags.get(tags.size() - 1).text();
  if (Strings.isNullOrEmpty(tag))   return Author.defaultAuthor();
  String[] texts=tag.split(""String_Node_Str"");
  if (texts.length != 2)   return Author.defaultAuthor();
  DepGroup group=depGroupReadRepository.findByGroupShort(texts[0]);
  String groupName=group != null ? group.getName() : ""String_Node_Str"";
  DepMember member=depMemberReadRepository.findByMemberShort(texts[1],texts[0]);
  String memberName=member != null ? member.getName() : ""String_Node_Str"";
  return new Author(groupName,memberName);
}","public Author fetchAuthor(Elements tags){
  if (tags.size() == 0)   return Author.defaultAuthor();
  String tag=tags.get(tags.size() - 1).text();
  if (Strings.isNullOrEmpty(tag))   return Author.defaultAuthor();
  String[] texts=tag.toUpperCase().split(""String_Node_Str"");
  if (texts.length != 2)   return Author.defaultAuthor();
  DepGroup group=depGroupReadRepository.findByGroupShort(texts[0]);
  String groupName=group != null ? group.getName() : ""String_Node_Str"";
  DepMember member=depMemberReadRepository.findByMemberShort(texts[1],texts[0]);
  String memberName=member != null ? member.getName() : ""String_Node_Str"";
  return new Author(groupName,memberName);
}",0.9894736842105264
87182,"private void fetchBlogs(Document doc,String url) throws Exception {
  Elements blogs=doc.select(""String_Node_Str"");
  log.debug(""String_Node_Str"" + blogs.size());
  for (  Element blog : blogs) {
    Element titleElement=blog.select(""String_Node_Str"").get(0);
    String title=fetchTitle(titleElement);
    String link=url + titleElement.attr(""String_Node_Str"");
    log.debug(format(""String_Node_Str"",link));
    String blogId=fetchBlogId(link);
    Elements tags=blog.select(""String_Node_Str"");
    Author author=authorService.fetchAuthor(tags);
    String time=DbaUtil.parseIteyeTime(blog.select(""String_Node_Str"").get(0).text());
    int view=fetchNumber(blog.select(""String_Node_Str"").get(1).text());
    int comment=fetchNumber(blog.select(""String_Node_Str"").get(2).text());
    Blog result=blogRepository.findByBlogIdAndWebsite(blogId,ITEYE_KEY_WORD);
    if (result != null) {
      blogRepository.updateBlogFor(result.getId(),title,view,comment,author.getGroupName(),author.getName());
      continue;
    }
    blogRepository.save(new Blog(title,link,view,comment,time,author,blogId,ITEYE_KEY_WORD));
  }
}","private void fetchBlogs(Document doc,String url) throws Exception {
  Elements blogs=doc.select(""String_Node_Str"");
  log.debug(""String_Node_Str"" + blogs.size());
  for (  Element blog : blogs) {
    Element titleElement=blog.select(""String_Node_Str"").get(0);
    String title=fetchTitle(titleElement);
    String link=url.substring(0,url.lastIndexOf(""String_Node_Str"")) + titleElement.attr(""String_Node_Str"");
    log.debug(format(""String_Node_Str"",link));
    String blogId=fetchBlogId(link);
    Elements tags=blog.select(""String_Node_Str"");
    Author author=authorService.fetchAuthor(tags);
    String time=DbaUtil.parseIteyeTime(blog.select(""String_Node_Str"").get(0).text());
    int view=fetchNumber(blog.select(""String_Node_Str"").get(1).text());
    int comment=fetchNumber(blog.select(""String_Node_Str"").get(2).text());
    Blog result=blogRepository.findByBlogIdAndWebsite(blogId,ITEYE_KEY_WORD);
    if (result != null) {
      blogRepository.updateBlogFor(result.getId(),title,view,comment,author.getGroupName(),author.getName());
      continue;
    }
    blogRepository.save(new Blog(title,link,view,comment,time,author,blogId,ITEYE_KEY_WORD));
  }
}",0.9789473684210528
87183,"private static JsonNode executeCommand(JsonNode currentNode,String command){
  JsonNode newNode=null;
  if (currentNode != null) {
    System.out.println(""String_Node_Str"" + currentNode);
    String argument=command.substring(4,command.length() - 1);
    if (command.startsWith(""String_Node_Str"")) {
      int index=Integer.parseInt(argument);
      newNode=currentNode.get(index);
    }
 else {
      newNode=currentNode.get(command);
    }
    System.out.println(""String_Node_Str"" + newNode);
  }
  return newNode;
}","private static JsonNode executeCommand(JsonNode currentNode,String command){
  JsonNode newNode=null;
  if (currentNode != null) {
    System.out.println(""String_Node_Str"" + currentNode);
    if (isGet(command)) {
      String argument=command.substring(4,command.length() - 1);
      int index=Integer.parseInt(argument);
      newNode=currentNode.get(index);
    }
 else {
      newNode=currentNode.get(command);
    }
    System.out.println(""String_Node_Str"" + newNode);
  }
  return newNode;
}",0.5812807881773399
87184,"@Override public Node create(final Cluster cluster,final Ping ping){
  final UUID id=UUID.randomUUID();
  final List<String> tags=jdbc.queryForList(""String_Node_Str"" + ""String_Node_Str"",String.class,cluster.getClusterId());
  jdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    final Connection conn) throws SQLException {
      final PreparedStatement ps=conn.prepareStatement(INSERT[0]);
      ps.setObject(1,id);
      ps.setObject(2,cluster.getClusterId());
      ps.setString(3,ping.hostname);
      ps.setString(4,ping.ipAddr);
      ps.setArray(5,conn.createArrayOf(""String_Node_Str"",tags.toArray()));
      return ps;
    }
  }
);
  jdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    final Connection conn) throws SQLException {
      final PreparedStatement ps=conn.prepareStatement(INSERT[1]);
      ps.setObject(1,id);
      ps.setInt(2,ping.hw.physicalCpus);
      ps.setInt(3,ping.hw.logicalCpus);
      ps.setInt(4,ping.hw.totalRamMb);
      ps.setInt(5,ping.hw.freeRamMb);
      ps.setInt(6,ping.hw.totalSwapMb);
      ps.setInt(7,ping.hw.freeSwapMb);
      ps.setLong(8,ping.bootTime * 1000);
      ps.setString(9,ping.hw.cpuModel);
      ps.setString(10,ping.hw.platform);
      if (!PlowUtils.isValid(ping.hw.load)) {
        ps.setArray(11,conn.createArrayOf(""String_Node_Str"",new Float[]{0.0f,0.0f,0.0f}));
      }
 else {
        ps.setArray(11,conn.createArrayOf(""String_Node_Str"",ping.hw.load.toArray()));
      }
      return ps;
    }
  }
);
  final int memMb=getBookableMemory(ping.hw.totalRamMb);
  jdbc.update(INSERT[2],id,ping.hw.physicalCpus,ping.hw.physicalCpus,memMb,memMb);
  NodeE node=new NodeE();
  node.setNodeId(id);
  node.setClusterId(cluster.getClusterId());
  node.setName(ping.hostname);
  return node;
}","@Override public Node create(final Cluster cluster,final Ping ping){
  final UUID id=UUID.randomUUID();
  final List<String> tags=jdbc.queryForList(""String_Node_Str"" + ""String_Node_Str"",String.class,cluster.getClusterId());
  jdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    final Connection conn) throws SQLException {
      final PreparedStatement ps=conn.prepareStatement(INSERT[0]);
      ps.setObject(1,id);
      ps.setObject(2,cluster.getClusterId());
      ps.setString(3,ping.hostname);
      ps.setString(4,ping.ipAddr);
      ps.setArray(5,conn.createArrayOf(""String_Node_Str"",tags.toArray()));
      return ps;
    }
  }
);
  jdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    final Connection conn) throws SQLException {
      final PreparedStatement ps=conn.prepareStatement(INSERT[1]);
      ps.setObject(1,id);
      ps.setInt(2,ping.hw.physicalCpus);
      ps.setInt(3,ping.hw.logicalCpus);
      ps.setInt(4,ping.hw.totalRamMb);
      ps.setInt(5,ping.hw.freeRamMb);
      ps.setInt(6,ping.hw.totalSwapMb);
      ps.setInt(7,ping.hw.freeSwapMb);
      ps.setLong(8,ping.bootTime * 1000);
      ps.setString(9,ping.hw.cpuModel);
      ps.setString(10,ping.hw.platform);
      if (!PlowUtils.isValid(ping.hw.load)) {
        ps.setArray(11,conn.createArrayOf(""String_Node_Str"",new Float[]{0.0f,0.0f,0.0f}));
      }
 else {
        ps.setArray(11,conn.createArrayOf(""String_Node_Str"",ping.hw.load.toArray()));
      }
      return ps;
    }
  }
);
  final int memMb=ping.hw.totalRamMb - PlowUtils.getReservedRam(ping.hw.totalRamMb);
  jdbc.update(INSERT[2],id,ping.hw.physicalCpus,ping.hw.physicalCpus,memMb,memMb);
  NodeE node=new NodeE();
  node.setNodeId(id);
  node.setClusterId(cluster.getClusterId());
  node.setName(ping.hostname);
  return node;
}",0.9840425531914894
87185,"@Test public void freeResources(){
  Ping ping=getTestNodePing();
  Cluster cluster=clusterDao.create(""String_Node_Str"",TAGS);
  Node node=nodeDao.create(cluster,ping);
  nodeDao.allocate(node,1,1024);
  nodeDao.free(node,1,1024);
  assertEquals(ping.hw.physicalCpus,simpleJdbcTemplate.queryForInt(""String_Node_Str"",node.getNodeId()));
  assertEquals(ping.hw.totalRamMb - Defaults.NODE_RESERVE_MEMORY,simpleJdbcTemplate.queryForInt(""String_Node_Str"",node.getNodeId()));
}","@Test public void freeResources(){
  Ping ping=getTestNodePing();
  Cluster cluster=clusterDao.create(""String_Node_Str"",TAGS);
  Node node=nodeDao.create(cluster,ping);
  nodeDao.allocate(node,1,1024);
  nodeDao.free(node,1,1024);
  assertEquals(ping.hw.physicalCpus,simpleJdbcTemplate.queryForInt(""String_Node_Str"",node.getNodeId()));
  assertEquals(ping.hw.totalRamMb - PlowUtils.getReservedRam(ping.hw.totalRamMb),simpleJdbcTemplate.queryForInt(""String_Node_Str"",node.getNodeId()));
}",0.931106471816284
87186,"@Test public void allocateResources(){
  Ping ping=getTestNodePing();
  Cluster cluster=clusterDao.create(""String_Node_Str"",TAGS);
  Node node=nodeDao.create(cluster,ping);
  nodeDao.allocate(node,1,1024);
  assertEquals(ping.hw.physicalCpus - 1,simpleJdbcTemplate.queryForInt(""String_Node_Str"",node.getNodeId()));
  assertEquals(ping.hw.totalRamMb - 1024 - Defaults.NODE_RESERVE_MEMORY,simpleJdbcTemplate.queryForInt(""String_Node_Str"",node.getNodeId()));
}","@Test public void allocateResources(){
  Ping ping=getTestNodePing();
  Cluster cluster=clusterDao.create(""String_Node_Str"",TAGS);
  Node node=nodeDao.create(cluster,ping);
  int reserved=PlowUtils.getReservedRam(ping.hw.totalRamMb);
  assertEquals(ping.hw.totalRamMb - reserved,simpleJdbcTemplate.queryForInt(""String_Node_Str"",node.getNodeId()));
  nodeDao.allocate(node,1,1024);
  assertEquals(ping.hw.physicalCpus - 1,simpleJdbcTemplate.queryForInt(""String_Node_Str"",node.getNodeId()));
  assertEquals(ping.hw.totalRamMb - 1024 - reserved,simpleJdbcTemplate.queryForInt(""String_Node_Str"",node.getNodeId()));
}",0.8026192703461179
87187,"@Test public void testAllocateSingleResourceProc(){
  nodeService.setNodeSlotMode(node,SlotMode.SINGLE,2,4096);
  node=dispatchService.getDispatchNode(node.getName());
  assertTrue(dispatchService.reserveTask(tasks.get(0)));
  DispatchProc proc=dispatchService.allocateProc(node,tasks.get(0));
  assertEquals(2,proc.getCores());
  assertEquals(8096 - Defaults.NODE_RESERVE_MEMORY,proc.getRam());
}","@Test public void testAllocateSingleResourceProc(){
  nodeService.setNodeSlotMode(node,SlotMode.SINGLE,2,4096);
  node=dispatchService.getDispatchNode(node.getName());
  assertTrue(dispatchService.reserveTask(tasks.get(0)));
  DispatchProc proc=dispatchService.allocateProc(node,tasks.get(0));
  assertEquals(2,proc.getCores());
  assertEquals(8096 - Defaults.NODE_RESERVE_MEMORY_MAX,proc.getRam());
}",0.9949874686716792
87188,"@Test public void testAllocateRuntSlotProc(){
  nodeService.setNodeSlotMode(node,SlotMode.SLOTS,1,4000);
  node=dispatchService.getDispatchNode(node.getName());
  assertTrue(dispatchService.reserveTask(tasks.get(0)));
  DispatchProc proc=dispatchService.allocateProc(node,tasks.get(0));
  assertEquals(1,proc.getCores());
  assertEquals(4000,proc.getRam());
  node.allocate(1,4000);
  assertTrue(dispatchService.reserveTask(tasks.get(1)));
  proc=dispatchService.allocateProc(node,tasks.get(1));
  assertEquals(1,proc.getCores());
  assertEquals(3584,proc.getRam());
}","@Test public void testAllocateRuntSlotProc(){
  nodeService.setNodeSlotMode(node,SlotMode.SLOTS,1,4000);
  node=dispatchService.getDispatchNode(node.getName());
  assertTrue(dispatchService.reserveTask(tasks.get(0)));
  DispatchProc proc=dispatchService.allocateProc(node,tasks.get(0));
  assertEquals(1,proc.getCores());
  assertEquals(4000,proc.getRam());
  node.allocate(1,4000);
  assertTrue(dispatchService.reserveTask(tasks.get(1)));
  proc=dispatchService.allocateProc(node,tasks.get(1));
  assertEquals(1,proc.getCores());
  assertEquals(3712,proc.getRam());
}",0.9947183098591548
87189,"protected void dispatchFailed(DispatchResult result,DispatchProc proc,DispatchTask task,String message){
  logger.error(""String_Node_Str"",new Object[]{proc,task,message});
  if (task != null) {
    if (task.started) {
      dispatchService.stopTask(task,TaskState.WAITING,ExitStatus.FAIL,Signal.ABORTED_TASK);
    }
 else {
      dispatchService.unreserveTask(task);
    }
  }
  dispatchService.unassignProc(proc);
  dispatchService.markAsDeallocated(proc);
  if (result != null) {
    result.continueDispatch=false;
  }
}","protected void dispatchFailed(DispatchResult result,DispatchProc proc,DispatchTask task,String message){
  logger.error(""String_Node_Str"",new Object[]{proc,task,message});
  if (task != null) {
    if (task.started) {
      dispatchService.stopTask(task,TaskState.WAITING,ExitStatus.FAIL,Signal.ABORTED_TASK);
    }
 else {
      dispatchService.unreserveTask(task);
    }
  }
  if (proc != null) {
    dispatchService.unassignAndMarkForDeallocation(proc);
  }
  if (result != null) {
    result.continueDispatch=false;
  }
}",0.830945558739255
87190,"@Override public boolean unassign(Proc proc){
  return jdbc.update(UNASSIGN,proc.getProcId()) == 1;
}","@Override public boolean unassign(Proc proc){
  if (proc == null) {
    return false;
  }
  return jdbc.update(UNASSIGN,proc.getProcId()) == 1;
}",0.8211382113821138
87191,"@Override public boolean updateProcRuntimeStats(final RunningTask task){
  return jdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    final Connection conn) throws SQLException {
      final float cores_used=task.cpuPercent / 100.0f;
      final Long[] io_stats={task.diskIO.readCount,task.diskIO.writeCount,task.diskIO.readBytes,task.diskIO.writeBytes};
      final PreparedStatement ret=conn.prepareStatement(UPDATE_RUNTIME);
      ret.setInt(1,task.rssMb);
      ret.setInt(2,task.rssMb);
      ret.setInt(3,(int)Math.min(100,Math.round(task.progress)));
      ret.setFloat(4,cores_used);
      ret.setFloat(5,cores_used);
      ret.setString(6,task.lastLog);
      ret.setArray(7,conn.createArrayOf(""String_Node_Str"",io_stats));
      ret.setObject(8,UUID.fromString(task.procId));
      ret.setObject(9,UUID.fromString(task.taskId));
      return ret;
    }
  }
) == 1;
}","@Override public boolean updateProcRuntimeStats(final RunningTask task){
  return jdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    final Connection conn) throws SQLException {
      final float cores_used=task.cpuPercent / 100.0f;
      final Long[] io_stats=new Long[]{0L,0L,0L,0L};
      if (task.diskIO != null) {
        io_stats[0]=task.diskIO.readCount;
        io_stats[1]=task.diskIO.writeCount;
        io_stats[2]=task.diskIO.readBytes;
        io_stats[3]=task.diskIO.writeBytes;
        ;
      }
      final PreparedStatement ret=conn.prepareStatement(UPDATE_RUNTIME);
      ret.setInt(1,task.rssMb);
      ret.setInt(2,task.rssMb);
      ret.setInt(3,(int)Math.min(100,Math.round(task.progress)));
      ret.setFloat(4,cores_used);
      ret.setFloat(5,cores_used);
      ret.setString(6,task.lastLog);
      ret.setArray(7,conn.createArrayOf(""String_Node_Str"",io_stats));
      ret.setObject(8,UUID.fromString(task.procId));
      ret.setObject(9,UUID.fromString(task.taskId));
      return ret;
    }
  }
) == 1;
}",0.9185989146521952
87192,"@Override public PreparedStatement createPreparedStatement(final Connection conn) throws SQLException {
  final float cores_used=task.cpuPercent / 100.0f;
  final Long[] io_stats={task.diskIO.readCount,task.diskIO.writeCount,task.diskIO.readBytes,task.diskIO.writeBytes};
  final PreparedStatement ret=conn.prepareStatement(UPDATE_RUNTIME);
  ret.setInt(1,task.rssMb);
  ret.setInt(2,task.rssMb);
  ret.setInt(3,(int)Math.min(100,Math.round(task.progress)));
  ret.setFloat(4,cores_used);
  ret.setFloat(5,cores_used);
  ret.setString(6,task.lastLog);
  ret.setArray(7,conn.createArrayOf(""String_Node_Str"",io_stats));
  ret.setObject(8,UUID.fromString(task.procId));
  ret.setObject(9,UUID.fromString(task.taskId));
  return ret;
}","@Override public PreparedStatement createPreparedStatement(final Connection conn) throws SQLException {
  final float cores_used=task.cpuPercent / 100.0f;
  final Long[] io_stats=new Long[]{0L,0L,0L,0L};
  if (task.diskIO != null) {
    io_stats[0]=task.diskIO.readCount;
    io_stats[1]=task.diskIO.writeCount;
    io_stats[2]=task.diskIO.readBytes;
    io_stats[3]=task.diskIO.writeBytes;
    ;
  }
  final PreparedStatement ret=conn.prepareStatement(UPDATE_RUNTIME);
  ret.setInt(1,task.rssMb);
  ret.setInt(2,task.rssMb);
  ret.setInt(3,(int)Math.min(100,Math.round(task.progress)));
  ret.setFloat(4,cores_used);
  ret.setFloat(5,cores_used);
  ret.setString(6,task.lastLog);
  ret.setArray(7,conn.createArrayOf(""String_Node_Str"",io_stats));
  ret.setObject(8,UUID.fromString(task.procId));
  ret.setObject(9,UUID.fromString(task.taskId));
  return ret;
}",0.9138906348208674
87193,"@Override public List<TaskT> getTasks(TaskFilterT filter){
  final List<String> where=Lists.newArrayList();
  final List<Object> values=Lists.newArrayList();
  if (PlowUtils.isValid(filter.jobId)) {
    where.add(""String_Node_Str"");
    values.add(UUID.fromString(filter.jobId));
  }
  if (PlowUtils.isValid(filter.layerIds)) {
    where.add(JdbcUtils.In(""String_Node_Str"",filter.layerIds.size()));
    values.addAll(filter.layerIds);
  }
  if (PlowUtils.isValid(filter.nodeIds)) {
    where.add(JdbcUtils.In(""String_Node_Str"",filter.nodeIds.size()));
    values.addAll(filter.nodeIds);
  }
  if (PlowUtils.isValid(filter.taskIds)) {
    where.add(JdbcUtils.In(""String_Node_Str"",filter.taskIds.size()));
    values.addAll(filter.taskIds);
  }
  if (where.isEmpty()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (filter.getLastUpdateTime() > 0) {
    where.add(""String_Node_Str"");
    values.add(filter.getLastUpdateTime());
  }
  if (PlowUtils.isValid(filter.states)) {
    where.add(JdbcUtils.In(""String_Node_Str"",filter.states.size()));
    for (    TaskState state : filter.states) {
      values.add(state.ordinal());
    }
  }
  final StringBuilder sb=new StringBuilder(512);
  sb.append(GET);
  sb.append(""String_Node_Str"");
  sb.append(StringUtils.join(where,""String_Node_Str""));
  sb.append(""String_Node_Str"");
  return jdbc.query(sb.toString(),MAPPER,values.toArray());
}","@Override public List<TaskT> getTasks(TaskFilterT filter){
  final List<String> where=Lists.newArrayList();
  final List<Object> values=Lists.newArrayList();
  if (PlowUtils.isValid(filter.jobId)) {
    where.add(""String_Node_Str"");
    values.add(UUID.fromString(filter.jobId));
  }
  if (PlowUtils.isValid(filter.layerIds)) {
    where.add(JdbcUtils.In(""String_Node_Str"",filter.layerIds.size(),""String_Node_Str""));
    values.addAll(filter.layerIds);
  }
  if (PlowUtils.isValid(filter.nodeIds)) {
    where.add(JdbcUtils.In(""String_Node_Str"",filter.nodeIds.size(),""String_Node_Str""));
    values.addAll(filter.nodeIds);
  }
  if (PlowUtils.isValid(filter.taskIds)) {
    where.add(JdbcUtils.In(""String_Node_Str"",filter.taskIds.size(),""String_Node_Str""));
    values.addAll(filter.taskIds);
  }
  if (where.isEmpty()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (filter.getLastUpdateTime() > 0) {
    where.add(""String_Node_Str"");
    values.add(filter.getLastUpdateTime());
  }
  if (PlowUtils.isValid(filter.states)) {
    where.add(JdbcUtils.In(""String_Node_Str"",filter.states.size()));
    for (    TaskState state : filter.states) {
      values.add(state.ordinal());
    }
  }
  final StringBuilder sb=new StringBuilder(512);
  sb.append(GET);
  sb.append(""String_Node_Str"");
  sb.append(StringUtils.join(where,""String_Node_Str""));
  sb.append(""String_Node_Str"");
  return jdbc.query(sb.toString(),MAPPER,values.toArray());
}",0.9810393258426966
87194,"@Override public FilterableJob create(final Project project,final JobSpecT spec,final boolean isPostJob){
  final UUID jobId=UUID.randomUUID();
  final String name=createJobName(spec,isPostJob);
  jdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    final Connection conn) throws SQLException {
      final PreparedStatement ret=conn.prepareStatement(INSERT[0]);
      boolean paused=spec.isPaused();
      if (isPostJob) {
        paused=false;
      }
      ret.setObject(1,jobId);
      ret.setObject(2,project.getProjectId());
      ret.setString(3,name);
      ret.setString(4,name);
      ret.setString(5,spec.username);
      ret.setInt(6,spec.getUid());
      ret.setInt(7,JobState.INITIALIZE.ordinal());
      ret.setBoolean(8,paused);
      ret.setString(9,String.format(""String_Node_Str"",spec.logPath,name));
      ret.setObject(10,spec.attrs);
      ret.setObject(11,spec.env);
      ret.setBoolean(12,isPostJob);
      return ret;
    }
  }
);
  jdbc.update(""String_Node_Str"",jobId);
  jdbc.update(""String_Node_Str"",jobId);
  jdbc.update(""String_Node_Str"",jobId);
  try {
    final TSerializer serializer=new TSerializer(new TJSONProtocol.Factory());
    final String json=serializer.toString(spec);
    jdbc.update(""String_Node_Str"",json,jobId);
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + e,e);
  }
  final FilterableJob job=new FilterableJob();
  job.setJobId(jobId);
  job.setProjectId(project.getProjectId());
  job.setFolderId(null);
  job.setName(name);
  job.username=spec.username;
  job.attrs=spec.attrs;
  return job;
}","@Override public FilterableJob create(final Project project,final JobSpecT spec,final boolean isPostJob){
  final UUID jobId=UUID.randomUUID();
  final String name=createJobName(spec,isPostJob);
  jdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    final Connection conn) throws SQLException {
      final PreparedStatement ret=conn.prepareStatement(INSERT[0]);
      boolean paused=spec.isPaused();
      if (isPostJob) {
        paused=false;
      }
      ret.setObject(1,jobId);
      ret.setObject(2,project.getProjectId());
      ret.setString(3,name);
      ret.setString(4,name);
      ret.setString(5,spec.username);
      ret.setInt(6,spec.getUid());
      ret.setInt(7,JobState.INITIALIZE.ordinal());
      ret.setBoolean(8,paused);
      ret.setString(9,spec.logPath);
      ret.setObject(10,spec.attrs);
      ret.setObject(11,spec.env);
      ret.setBoolean(12,isPostJob);
      return ret;
    }
  }
);
  jdbc.update(""String_Node_Str"",jobId);
  jdbc.update(""String_Node_Str"",jobId);
  jdbc.update(""String_Node_Str"",jobId);
  try {
    final TSerializer serializer=new TSerializer(new TJSONProtocol.Factory());
    final String json=serializer.toString(spec);
    jdbc.update(""String_Node_Str"",json,jobId);
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + e,e);
  }
  final FilterableJob job=new FilterableJob();
  job.setJobId(jobId);
  job.setProjectId(project.getProjectId());
  job.setFolderId(null);
  job.setName(name);
  job.username=spec.username;
  job.attrs=spec.attrs;
  return job;
}",0.9881472239550844
87195,"@Override public boolean startTask(DispatchTask task,DispatchProc proc){
  if (dispatchTaskDao.start(task,proc)) {
    logger.info(""String_Node_Str"",task);
    DispatchStats.taskStartedCount.incrementAndGet();
    return true;
  }
  DispatchStats.taskStartedFailureCount.incrementAndGet();
  return false;
}","@Override public boolean startTask(DispatchTask task,DispatchProc proc){
  if (dispatchTaskDao.start(task,proc)) {
    logger.info(""String_Node_Str"",task);
    task.started=true;
    DispatchStats.taskStartedCount.incrementAndGet();
    return true;
  }
  DispatchStats.taskStartedFailureCount.incrementAndGet();
  return false;
}",0.9638932496075352
87196,"public void dispatch(DispatchResult result,DispatchNode node,DispatchTask task){
  if (!dispatchService.reserveTask(task)) {
    return;
  }
  DispatchProc proc=null;
  try {
    proc=dispatchService.allocateProc(node,task);
    if (dispatchService.startTask(task,proc)) {
      RunTaskCommand command=dispatchService.getRuntaskCommand(task);
      if (!result.isTest) {
        RndClient client=new RndClient(node.getName());
        client.runProcess(command);
      }
      result.dispatched(proc,task);
    }
 else {
      dispatchFailed(result,proc,null,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + node.getName() + ""String_Node_Str""+ e,e);
    dispatchFailed(result,proc,task,e.getMessage());
  }
}","public void dispatch(DispatchResult result,DispatchNode node,DispatchTask task){
  if (!dispatchService.reserveTask(task)) {
    return;
  }
  DispatchProc proc=null;
  try {
    proc=dispatchService.allocateProc(node,task);
    if (dispatchService.startTask(task,proc)) {
      RunTaskCommand command=dispatchService.getRuntaskCommand(task);
      if (!result.isTest) {
        RndClient client=new RndClient(node.getName());
        client.runProcess(command);
      }
      result.dispatched(proc,task);
    }
 else {
      dispatchFailed(result,proc,task,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + node.getName() + ""String_Node_Str""+ e,e);
    dispatchFailed(result,proc,task,e.getMessage());
  }
}",0.9946666666666668
87197,"public void dispatchFailed(DispatchResult result,DispatchProc proc,DispatchTask task,String message){
  logger.info(""String_Node_Str"",new Object[]{proc,task,message});
  result.dispatch=false;
  dispatchService.deallocateProc(proc,message);
  if (task != null) {
    dispatchService.stopTask(task,TaskState.WAITING,ExitStatus.FAIL,Signal.ABORTED_TASK);
  }
}","public void dispatchFailed(DispatchResult result,DispatchProc proc,DispatchTask task,String message){
  logger.info(""String_Node_Str"",new Object[]{proc,task,message});
  result.dispatch=false;
  dispatchService.deallocateProc(proc,message);
  if (task != null) {
    if (task.started) {
      dispatchService.stopTask(task,TaskState.WAITING,ExitStatus.FAIL,Signal.ABORTED_TASK);
    }
 else {
      dispatchService.unreserveTask(task);
    }
  }
}",0.8894409937888199
87198,"@Override public void dispatchFailed(DispatchResult result,DispatchProc resource,DispatchTask task,String message){
  logger.info(""String_Node_Str"",new Object[]{resource,task,message});
  dispatchService.deallocateProc(resource,message);
  if (task != null) {
    dispatchService.stopTask(task,TaskState.WAITING,ExitStatus.FAIL,Signal.ABORTED_TASK);
  }
  result.dispatch=false;
}","@Override public void dispatchFailed(DispatchResult result,DispatchProc resource,DispatchTask task,String message){
  logger.info(""String_Node_Str"",new Object[]{resource,task,message});
  dispatchService.deallocateProc(resource,message);
  if (task != null) {
    if (task.started) {
      dispatchService.stopTask(task,TaskState.WAITING,ExitStatus.FAIL,Signal.ABORTED_TASK);
    }
 else {
      dispatchService.unreserveTask(task);
    }
  }
  result.dispatch=false;
}",0.8951707891637221
87199,"@Override public void update(Node node,Ping ping){
  jdbc.update(""String_Node_Str"" + ""String_Node_Str"",node.getNodeId());
  jdbc.update(FULL_UPDATE,ping.hw.physicalCpus,ping.hw.logicalCpus,ping.hw.totalRamMb,ping.hw.freeRamMb,ping.hw.totalSwapMb,ping.hw.freeSwapMb,ping.bootTime,ping.hw.cpuModel,ping.hw.platform,node.getNodeId());
}","@Override public void update(Node node,Ping ping){
  jdbc.update(""String_Node_Str"" + ""String_Node_Str"",node.getNodeId());
  jdbc.update(""String_Node_Str"" + ""String_Node_Str"",NodeState.UP.ordinal(),node.getNodeId(),NodeState.DOWN.ordinal());
  jdbc.update(FULL_UPDATE,ping.hw.physicalCpus,ping.hw.logicalCpus,ping.hw.totalRamMb,ping.hw.freeRamMb,ping.hw.totalSwapMb,ping.hw.freeSwapMb,ping.bootTime,ping.hw.cpuModel,ping.hw.platform,node.getNodeId());
}",0.8484076433121019
87200,"@Async(value=""String_Node_Str"") public void eatTasks(final TaskFilterT filter){
  if (PlowUtils.isValid(filter.jobId)) {
    throw new PlowException(""String_Node_Str"");
  }
  stateChangeExecutor.execute(new Runnable(){
    @Override public void run(){
      final List<Task> tasks=jobService.getTasks(filter);
      logger.info(""String_Node_Str"",Thread.currentThread().getName(),tasks.size());
      if (tasks.isEmpty()) {
        return;
      }
      for (      final Task t : tasks) {
        eatTask(t,false);
      }
      Job job=jobService.getJob(UUID.fromString(filter.jobId));
      if (jobService.isFinished(job)) {
        shutdownJob(job);
      }
    }
  }
);
}","@Async(value=""String_Node_Str"") public void eatTasks(final TaskFilterT filter){
  if (PlowUtils.isValid(filter.jobId)) {
    throw new PlowException(""String_Node_Str"");
  }
  stateChangeExecutor.execute(new Runnable(){
    @Override public void run(){
      final List<Task> tasks=jobService.getTasks(filter);
      logger.info(""String_Node_Str"",Thread.currentThread().getName(),tasks.size());
      if (tasks.isEmpty()) {
        return;
      }
      Set<UUID> jobIds=Sets.newHashSet();
      for (      final Task t : tasks) {
        eatTask(t,false);
        jobIds.add(t.getJobId());
      }
      for (      UUID jobId : jobIds) {
        Job job=jobService.getJob(jobId);
        if (jobService.isFinished(job)) {
          shutdownJob(job);
        }
      }
    }
  }
);
}",0.7307692307692307
87201,"@Async(value=""String_Node_Str"") public void eatTasks(TaskFilterT filter){
  final List<Task> tasks=jobService.getTasks(filter);
  logger.info(""String_Node_Str"",Thread.currentThread().getName(),tasks.size());
  for (  final Task t : tasks) {
    stateChangeExecutor.execute(new Runnable(){
      @Override public void run(){
        eatTask(t);
      }
    }
);
  }
}","@Async(value=""String_Node_Str"") public void eatTasks(final TaskFilterT filter){
  if (PlowUtils.isValid(filter.jobId)) {
    throw new PlowException(""String_Node_Str"");
  }
  stateChangeExecutor.execute(new Runnable(){
    @Override public void run(){
      final List<Task> tasks=jobService.getTasks(filter);
      logger.info(""String_Node_Str"",Thread.currentThread().getName(),tasks.size());
      if (tasks.isEmpty()) {
        return;
      }
      for (      final Task t : tasks) {
        eatTask(t,false);
      }
      Job job=jobService.getJob(UUID.fromString(filter.jobId));
      if (jobService.isFinished(job)) {
        shutdownJob(job);
      }
    }
  }
);
}",0.3846153846153846
87202,"public void eatTask(Task task){
  logger.info(""String_Node_Str"",Thread.currentThread().getName(),task.getTaskId());
  if (dispatchService.stopTask(task,TaskState.EATEN,ExitStatus.FAIL,Signal.MANUAL_KILL)) {
    killProc(task,false);
  }
 else {
    jobService.setTaskState(task,TaskState.EATEN);
  }
}","public void eatTask(Task task,boolean checkFinished){
  logger.info(""String_Node_Str"",Thread.currentThread().getName(),task.getTaskId());
  if (dispatchService.stopTask(task,TaskState.EATEN,ExitStatus.FAIL,Signal.MANUAL_KILL)) {
    killProc(task,false);
  }
 else {
    jobService.setTaskState(task,TaskState.EATEN);
  }
  if (checkFinished) {
    Job job=jobService.getJob(task.getJobId());
    if (jobService.isFinished(job)) {
      shutdownJob(job);
    }
  }
}",0.7848761408083442
87203,"/** 
 * Apply defaults for unset layer values.
 * @param layer
 */
private void prepLayer(LayerSpecT layer){
  if (!PlowUtils.isValid(layer.getServ())) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_SERVICE);
    layer.setServ(Defaults.DEFAULT_SERVICE);
  }
  ServiceFull service=serviceDao.getServiceFull(layer.getServ());
  if (service != null) {
    if (service.isSetMinCores() && !layer.isSetMinCores()) {
      layer.setMinCores(service.getMinCores());
    }
    if (service.isSetMaxCores() && !layer.isSetMaxCores()) {
      layer.setMaxCores(service.getMaxCores());
    }
    if (service.isSetMaxRam() && !layer.isSetMaxRam()) {
      layer.setMaxRam(service.getMaxRam());
    }
    if (service.isSetMinRam() && !layer.isSetMinRam()) {
      layer.setMinRam(service.getMinRam());
    }
    if (service.isSetMaxRetries() && !layer.isSetMaxRetries()) {
      layer.setMaxRetries(service.getMaxRetries());
    }
    if (service.isSetTags() && !layer.isSetTags()) {
      layer.setTags(layer.getTags());
    }
    if (service.isSetThreadable() && !layer.isSetThreadable()) {
      layer.setThreadable(layer.isThreadable());
    }
  }
  if (!layer.isSetMaxCores()) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_MAX_CORES);
    layer.setMaxCores(Defaults.DEFAULT_MAX_CORES);
  }
  if (!layer.isSetMinCores()) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_MIN_CORES);
    layer.setMinCores(Defaults.DEFAULT_MIN_CORES);
  }
  if (!layer.isSetMinRam()) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_MIN_RAM);
    layer.setMinRam(Defaults.DEFAULT_MIN_RAM);
  }
  if (!layer.isSetMaxRam()) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_MAX_RAM);
    layer.setMaxRam(Defaults.DEFAULT_MAX_RAM);
  }
  if (!layer.isSetMaxRetries()) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_MAX_RETRIES);
    layer.setMaxRetries(Defaults.DEFAULT_MAX_RETRIES);
  }
  if (!layer.isSetThreadable()) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_THREADABLE);
    layer.setThreadable(Defaults.DEFAULT_THREADABLE);
  }
  if (!layer.isSetTags()) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_TAGS);
    layer.setTags(Defaults.DEFAULT_TAGS);
  }
}","/** 
 * Apply defaults for unset layer values.
 * @param layer
 */
private void prepLayer(LayerSpecT layer){
  if (!PlowUtils.isValid(layer.getServ())) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_SERVICE);
    layer.setServ(Defaults.DEFAULT_SERVICE);
  }
  ServiceFull service=serviceDao.getServiceFull(layer.getServ());
  if (service != null) {
    if (service.isSetMinCores() && !layer.isSetMinCores()) {
      layer.setMinCores(service.getMinCores());
    }
    if (service.isSetMaxCores() && !layer.isSetMaxCores()) {
      layer.setMaxCores(service.getMaxCores());
    }
    if (service.isSetMaxRam() && !layer.isSetMaxRam()) {
      layer.setMaxRam(service.getMaxRam());
    }
    if (service.isSetMinRam() && !layer.isSetMinRam()) {
      layer.setMinRam(service.getMinRam());
    }
    if (service.isSetMaxRetries() && !layer.isSetMaxRetries()) {
      layer.setMaxRetries(service.getMaxRetries());
    }
    if (service.isSetTags() && !layer.isSetTags()) {
      layer.setTags(service.getTags());
    }
    if (service.isSetThreadable() && !layer.isSetThreadable()) {
      layer.setThreadable(service.isThreadable());
    }
  }
  if (!layer.isSetMaxCores()) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_MAX_CORES);
    layer.setMaxCores(Defaults.DEFAULT_MAX_CORES);
  }
  if (!layer.isSetMinCores()) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_MIN_CORES);
    layer.setMinCores(Defaults.DEFAULT_MIN_CORES);
  }
  if (!layer.isSetMinRam()) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_MIN_RAM);
    layer.setMinRam(Defaults.DEFAULT_MIN_RAM);
  }
  if (!layer.isSetMaxRam()) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_MAX_RAM);
    layer.setMaxRam(Defaults.DEFAULT_MAX_RAM);
  }
  if (!layer.isSetMaxRetries()) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_MAX_RETRIES);
    layer.setMaxRetries(Defaults.DEFAULT_MAX_RETRIES);
  }
  if (!layer.isSetThreadable()) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_THREADABLE);
    layer.setThreadable(Defaults.DEFAULT_THREADABLE);
  }
  if (!layer.isSetTags()) {
    logger.info(""String_Node_Str"",layer.name,Defaults.DEFAULT_TAGS);
    layer.setTags(Defaults.DEFAULT_TAGS);
  }
}",0.9946996466431096
87204,"public void setTags(List<String> tags){
  this.tags=tags;
}","public void setTags(List<String> tags){
  setTags=true;
  this.tags=tags;
}",0.8805970149253731
87205,"@Override public DispatchProc allocateProc(DispatchNode node,DispatchableTask task){
  logger.info(""String_Node_Str"",node);
  if (!quotaDao.check(node,task,task.minCores)) {
    throw new PlowDispatcherException(""String_Node_Str"" + node.getName() + ""String_Node_Str"");
  }
  try {
    nodeDao.allocate(node,task.minCores,task.minRam);
    quotaDao.allocate(node,task,task.minCores);
    DispatchProc proc=procDao.create(node,task);
    dispatchDao.incrementDispatchTotals(proc);
    return proc;
  }
 catch (  Exception e) {
    throw new PlowDispatcherException(""String_Node_Str"" + node.getName() + ""String_Node_Str""+ e,e);
  }
}","@Override public DispatchProc allocateProc(DispatchNode node,DispatchableTask task){
  logger.info(""String_Node_Str"",node);
  if (!quotaDao.check(node,task,task.minCores)) {
    throw new PlowDispatcherException(""String_Node_Str"" + node.getName() + ""String_Node_Str"");
  }
  try {
    nodeDao.allocate(node,task.minCores,task.minRam);
    quotaDao.allocate(node,task,task.minCores);
    DispatchProc proc=procDao.create(node,task);
    dispatchDao.incrementDispatchTotals(proc);
    node.allocate(task.minCores,task.minRam);
    return proc;
  }
 catch (  Exception e) {
    throw new PlowDispatcherException(""String_Node_Str"" + node.getName() + ""String_Node_Str""+ e,e);
  }
}",0.9647779479326188
87206,"public void dispatch(DispatchResult result,DispatchNode node,DispatchableTask task){
  if (!dispatchService.reserveTask(task)) {
    return;
  }
  DispatchProc proc=null;
  try {
    proc=dispatchService.allocateProc(node,task);
    if (dispatchService.startTask(node.getName(),task)) {
      RunTaskCommand command=dispatchService.getRuntaskCommand(task);
      if (!result.isTest) {
        RndClient client=new RndClient(node.getName());
        client.runProcess(command);
      }
      result.dispatched(proc);
    }
 else {
      cleanup(result,proc,task,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + node.getName() + ""String_Node_Str""+ e,e);
    cleanup(result,proc,task,e.getMessage());
  }
}","public void dispatch(DispatchResult result,DispatchNode node,DispatchableTask task){
  if (!dispatchService.reserveTask(task)) {
    return;
  }
  DispatchProc proc=null;
  try {
    proc=dispatchService.allocateProc(node,task);
    if (dispatchService.startTask(node.getName(),task)) {
      RunTaskCommand command=dispatchService.getRuntaskCommand(task);
      if (!result.isTest) {
        RndClient client=new RndClient(node.getName());
        client.runProcess(command);
      }
      result.dispatched(proc,task);
    }
 else {
      cleanup(result,proc,task,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + node.getName() + ""String_Node_Str""+ e,e);
    cleanup(result,proc,task,e.getMessage());
  }
}",0.9966555183946488
87207,"@Override public void allocate(int cores,int ram){
  this.cores=this.cores - cores;
  this.memory=this.memory - memory;
}","@Override public void allocate(int cores,int ram){
  this.cores=this.cores - cores;
  this.memory=this.memory - ram;
}",0.9707112970711296
87208,"/** 
 * Check if the given resource can still be dispatched.
 * @return
 */
public boolean continueDispatching(){
  if (procs.size() >= maxProcs) {
    return false;
  }
  if (cores >= maxCores) {
    return false;
  }
  if (procs.size() >= DispatchConfig.MAX_PROCS_PER_JOB) {
    return false;
  }
  if (resource.getIdleCores() < 1) {
    return false;
  }
  if (resource.getIdleRam() <= 0) {
    return false;
  }
  return dispatch;
}","/** 
 * Check if the given resource can still be dispatched.
 * @return
 */
public boolean continueDispatching(){
  if (procs.size() >= maxProcs) {
    logger.info(""String_Node_Str"",procs.size(),maxProcs);
    return false;
  }
  if (cores >= maxCores) {
    logger.info(""String_Node_Str"",cores,maxCores);
  }
  if (procs.size() >= DispatchConfig.MAX_PROCS_PER_JOB) {
    logger.info(""String_Node_Str"",procs.size(),DispatchConfig.MAX_PROCS_PER_JOB);
    return false;
  }
  if (resource.getIdleCores() < 1) {
    logger.info(""String_Node_Str"",resource.getIdleCores());
    return false;
  }
  if (resource.getIdleRam() <= 0) {
    logger.info(""String_Node_Str"",resource.getIdleRam());
    return false;
  }
  return dispatch;
}",0.7291487532244196
87209,"public void dispatched(DispatchProc proc){
  cores+=proc.getIdleCores();
  ram+=proc.getIdleRam();
  procs.add(proc);
  resource.allocate(proc.getIdleCores(),proc.getIdleRam());
  logger.info(""String_Node_Str"",new Object[]{proc.getHostname(),resource.getIdleCores(),resource.getIdleRam()});
}","public void dispatched(DispatchProc proc,DispatchableTask task){
  cores+=task.minCores;
  ram+=task.minRam;
  procs.add(proc);
  logger.info(""String_Node_Str"",new Object[]{proc.getHostname(),resource.getIdleCores(),resource.getIdleRam()});
}",0.6966292134831461
87210,"public boolean canDispatch(DispatchableTask task){
  if (resource.getIdleCores() < task.minCores) {
    return false;
  }
  if (resource.getIdleRam() < task.minRam) {
    return false;
  }
  return true;
}","public boolean canDispatch(DispatchableTask task){
  if (resource.getIdleCores() < task.minCores) {
    logger.info(""String_Node_Str"",resource.getIdleCores(),task.minCores);
    return false;
  }
  if (resource.getIdleRam() < task.minRam) {
    logger.info(""String_Node_Str"",resource.getIdleRam(),task.minRam);
    return false;
  }
  return true;
}",0.740072202166065
87211,"@Override public DispatchProc allocateProc(DispatchNode node,DispatchTask task){
  logger.info(""String_Node_Str"",node);
  if (!quotaDao.check(node,task,task.minCores)) {
    throw new PlowDispatcherException(""String_Node_Str"" + node.getName() + ""String_Node_Str"");
  }
  try {
    nodeDao.allocate(node,task.minCores,task.minRam);
    quotaDao.allocate(node,task,task.minCores);
    DispatchProc proc=procDao.create(node,task);
    dispatchDao.incrementDispatchTotals(proc);
    return proc;
  }
 catch (  Exception e) {
    throw new PlowDispatcherException(""String_Node_Str"" + node.getName() + ""String_Node_Str""+ e,e);
  }
}","@Override public DispatchProc allocateProc(DispatchNode node,DispatchTask task){
  logger.info(""String_Node_Str"",node);
  if (!quotaDao.check(node,task,task.minCores)) {
    throw new PlowDispatcherException(""String_Node_Str"" + node.getName() + ""String_Node_Str"");
  }
  try {
    DispatchProc proc=procDao.create(node,task);
    nodeDao.allocate(node,task.minCores,task.minRam);
    quotaDao.allocate(node,task,task.minCores);
    dispatchDao.incrementDispatchTotals(proc);
    return proc;
  }
 catch (  Exception e) {
    throw new PlowDispatcherException(""String_Node_Str"" + node.getName() + ""String_Node_Str""+ e,e);
  }
}",0.9217252396166136
87212,"public void dispatch(DispatchResult result,DispatchNode node,DispatchTask task){
  if (!dispatchService.reserveTask(task)) {
    return;
  }
  DispatchProc proc=null;
  try {
    proc=dispatchService.allocateProc(node,task);
    if (dispatchService.startTask(node.getName(),task)) {
      RunTaskCommand command=dispatchService.getRuntaskCommand(task);
      if (!result.isTest) {
        RndClient client=new RndClient(node.getName());
        client.runProcess(command);
      }
      result.dispatched(proc,task);
    }
 else {
      cleanup(result,proc,task,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + node.getName() + ""String_Node_Str""+ e,e);
    cleanup(result,proc,task,e.getMessage());
  }
}","public void dispatch(DispatchResult result,DispatchNode node,DispatchTask task){
  if (!dispatchService.reserveTask(task)) {
    return;
  }
  DispatchProc proc=null;
  try {
    proc=dispatchService.allocateProc(node,task);
    if (dispatchService.startTask(node.getName(),task)) {
      RunTaskCommand command=dispatchService.getRuntaskCommand(task);
      if (!result.isTest) {
        RndClient client=new RndClient(node.getName());
        client.runProcess(command);
      }
      result.dispatched(proc,task);
    }
 else {
      dispatchFailed(result,proc,null,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + node.getName() + ""String_Node_Str""+ e,e);
    dispatchFailed(result,proc,task,e.getMessage());
  }
}",0.949535192563081
87213,"public void dispatch(DispatchResult result,DispatchProc proc,DispatchTask task){
  if (!dispatchService.reserveTask(task)) {
    return;
  }
  try {
    dispatchService.assignProc(proc,task);
    if (dispatchService.startTask(proc.getHostname(),task)) {
      RunTaskCommand command=dispatchService.getRuntaskCommand(task);
      RndClient client=new RndClient(proc.getHostname());
      client.runProcess(command);
      result.dispatched(proc,task);
      result.dispatch=false;
    }
 else {
      cleanup(result,proc,task,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + e);
    cleanup(result,proc,task,e.getMessage());
  }
}","@Override public void dispatch(DispatchResult result,DispatchProc resource,DispatchJob job){
}",0.1906005221932115
87214,"@Override public void run(){
  final DispatchResult result=new DispatchResult(proc);
  dispatcher.dispatch(result,proc);
}","@Override public void run(){
  final DispatchResult result=new DispatchResult(proc);
  dispatcher.dispatch(result,proc);
  if (result.procs.isEmpty()) {
    dispatcher.dispatchFailed(result,proc,null,""String_Node_Str"");
  }
}",0.7031700288184438
87215,"@Override public boolean reserve(Task task){
  try {
    jdbc.queryForObject(""String_Node_Str"",String.class,task.getTaskId());
    return jdbc.update(""String_Node_Str"" + ""String_Node_Str"",task.getTaskId()) == 1;
  }
 catch (  Exception e) {
    return false;
  }
}","@Override public boolean reserve(Task task){
  try {
    jdbc.queryForObject(""String_Node_Str"",String.class,task.getTaskId(),TaskState.WAITING.ordinal());
    return jdbc.update(""String_Node_Str"" + ""String_Node_Str"",task.getTaskId(),TaskState.WAITING.ordinal()) == 1;
  }
 catch (  Exception e) {
    return false;
  }
}",0.9041095890410958
87216,"@Override public DispatchProc allocateProc(DispatchNode node,DispatchableTask task){
  logger.info(""String_Node_Str"",node);
  if (!quotaDao.check(node,task,task.minCores)) {
    throw new PlowDispatcherException(""String_Node_Str"" + node.getName() + ""String_Node_Str"");
  }
  try {
    nodeDao.allocate(node,task.minCores,task.minRam);
    quotaDao.allocate(node,task,task.minCores);
    DispatchProc proc=procDao.create(node,task);
    dispatchDao.incrementDispatchTotals(proc);
    node.allocate(task.minCores,task.minRam);
    return proc;
  }
 catch (  Exception e) {
    throw new PlowDispatcherException(""String_Node_Str"" + node.getName() + ""String_Node_Str""+ e,e);
  }
}","@Override public DispatchProc allocateProc(DispatchNode node,DispatchableTask task){
  logger.info(""String_Node_Str"",node);
  if (!quotaDao.check(node,task,task.minCores)) {
    throw new PlowDispatcherException(""String_Node_Str"" + node.getName() + ""String_Node_Str"");
  }
  try {
    nodeDao.allocate(node,task.minCores,task.minRam);
    quotaDao.allocate(node,task,task.minCores);
    DispatchProc proc=procDao.create(node,task);
    dispatchDao.incrementDispatchTotals(proc);
    return proc;
  }
 catch (  Exception e) {
    throw new PlowDispatcherException(""String_Node_Str"" + node.getName() + ""String_Node_Str""+ e,e);
  }
}",0.9647779479326188
87217,"public void dispatched(DispatchProc proc,DispatchableTask task){
  cores+=task.minCores;
  ram+=task.minRam;
  procs.add(proc);
  logger.info(""String_Node_Str"",new Object[]{proc.getHostname(),resource.getIdleCores(),resource.getIdleRam()});
}","public void dispatched(DispatchProc proc,DispatchableTask task){
  cores+=task.minCores;
  ram+=task.minRam;
  procs.add(proc);
  resource.allocate(task.minCores,task.minRam);
  logger.info(""String_Node_Str"",new Object[]{proc.getHostname(),resource.getIdleCores(),resource.getIdleRam()});
}",0.9097744360902256
87218,"@Override public boolean check(Cluster cluster,Project project,int cores){
  return jdbc.queryForInt(QUOTA_CHECK,cluster.getClusterId(),project.getProjectId(),cores) == 1;
}","@Override public boolean check(Cluster cluster,Project project,int cores){
  return jdbc.queryForInt(QUOTA_CHECK,project.getProjectId(),cluster.getClusterId(),cores) == 1;
}",0.8670520231213873
87219,"@Override public Job create(final Project project,final JobSpecT spec){
  final UUID jobId=UUID.randomUUID();
  jdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    final Connection conn) throws SQLException {
      final PreparedStatement ret=conn.prepareStatement(INSERT[0]);
      ret.setObject(1,jobId);
      ret.setObject(2,project.getProjectId());
      ret.setString(3,spec.getName());
      ret.setString(4,spec.getName());
      ret.setString(5,spec.username);
      ret.setInt(6,spec.getUid());
      ret.setInt(7,JobState.INITIALIZE.ordinal());
      ret.setBoolean(8,spec.isPaused());
      ret.setString(9,String.format(""String_Node_Str"",spec.logPath,spec.name));
      ret.setObject(10,spec.attrs);
      return ret;
    }
  }
);
  jdbc.update(""String_Node_Str"",jobId);
  jdbc.update(""String_Node_Str"",jobId);
  jdbc.update(""String_Node_Str"",jobId);
  final JobE job=new JobE();
  job.setJobId(jobId);
  job.setProjectId(project.getProjectId());
  job.setFolderId(null);
  return job;
}","@Override public Job create(final Project project,final JobSpecT spec){
  final UUID jobId=UUID.randomUUID();
  jdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    final Connection conn) throws SQLException {
      final PreparedStatement ret=conn.prepareStatement(INSERT[0]);
      ret.setObject(1,jobId);
      ret.setObject(2,project.getProjectId());
      ret.setString(3,spec.getName());
      ret.setString(4,spec.getName());
      ret.setString(5,spec.username);
      ret.setInt(6,spec.getUid());
      ret.setInt(7,JobState.INITIALIZE.ordinal());
      ret.setBoolean(8,spec.isPaused());
      ret.setString(9,String.format(""String_Node_Str"",spec.logPath,spec.name));
      ret.setObject(10,spec.attrs);
      return ret;
    }
  }
);
  jdbc.update(""String_Node_Str"",jobId);
  jdbc.update(""String_Node_Str"",jobId);
  jdbc.update(""String_Node_Str"",jobId);
  final JobE job=new JobE();
  job.setJobId(jobId);
  job.setProjectId(project.getProjectId());
  job.setFolderId(null);
  job.setName(spec.getName());
  return job;
}",0.9855746859004187
87220,"@Override public Layer create(final Job job,final LayerSpecT layer,final int order){
  final UUID id=UUID.randomUUID();
  jdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    final Connection conn) throws SQLException {
      final PreparedStatement ret=conn.prepareStatement(INSERT);
      ret.setObject(1,id);
      ret.setObject(2,job.getJobId());
      ret.setString(3,layer.getName());
      ret.setString(4,layer.getRange());
      ret.setArray(5,conn.createArrayOf(""String_Node_Str"",layer.getCommand().toArray()));
      ret.setArray(6,conn.createArrayOf(""String_Node_Str"",layer.getTags().toArray()));
      ret.setInt(7,layer.getChunk());
      ret.setInt(8,order);
      ret.setInt(9,layer.getMinCores());
      ret.setInt(10,layer.getMaxCores());
      ret.setInt(11,layer.getMinRamMb());
      ret.setBoolean(12,layer.isThreadable());
      return ret;
    }
  }
);
  jdbc.update(""String_Node_Str"",id);
  jdbc.update(""String_Node_Str"",id);
  jdbc.update(""String_Node_Str"",id);
  final LayerE result=new LayerE();
  result.setLayerId(id);
  result.setJobId(job.getJobId());
  return result;
}","@Override public Layer create(final Job job,final LayerSpecT layer,final int order){
  final UUID id=UUID.randomUUID();
  jdbc.update(new PreparedStatementCreator(){
    @Override public PreparedStatement createPreparedStatement(    final Connection conn) throws SQLException {
      final PreparedStatement ret=conn.prepareStatement(INSERT);
      ret.setObject(1,id);
      ret.setObject(2,job.getJobId());
      ret.setString(3,layer.getName());
      ret.setString(4,layer.getRange());
      ret.setArray(5,conn.createArrayOf(""String_Node_Str"",layer.getCommand().toArray()));
      ret.setArray(6,conn.createArrayOf(""String_Node_Str"",layer.getTags().toArray()));
      ret.setInt(7,layer.getChunk());
      ret.setInt(8,order);
      ret.setInt(9,layer.getMinCores());
      ret.setInt(10,layer.getMaxCores());
      ret.setInt(11,layer.getMinRamMb());
      ret.setBoolean(12,layer.isThreadable());
      return ret;
    }
  }
);
  jdbc.update(""String_Node_Str"",id);
  jdbc.update(""String_Node_Str"",id);
  jdbc.update(""String_Node_Str"",id);
  final LayerE result=new LayerE();
  result.setLayerId(id);
  result.setJobId(job.getJobId());
  result.setName(layer.getName());
  return result;
}",0.9851380042462844
87221,"@Override public Task create(Layer layer,String name,int number,int taskOrder,int layerOrder){
  final UUID id=UUID.randomUUID();
  jdbc.update(INSERT,id,layer.getLayerId(),layer.getJobId(),name,number,taskOrder,layerOrder,TaskState.INITIALIZE.ordinal());
  jdbc.update(""String_Node_Str"",id);
  TaskE task=new TaskE();
  task.setTaskId(id);
  task.setLayerId(layer.getLayerId());
  task.setJobId(layer.getJobId());
  return task;
}","@Override public Task create(Layer layer,String name,int number,int taskOrder,int layerOrder){
  final UUID id=UUID.randomUUID();
  jdbc.update(INSERT,id,layer.getLayerId(),layer.getJobId(),name,number,taskOrder,layerOrder,TaskState.INITIALIZE.ordinal());
  jdbc.update(""String_Node_Str"",id);
  TaskE task=new TaskE();
  task.setTaskId(id);
  task.setLayerId(layer.getLayerId());
  task.setJobId(layer.getJobId());
  task.setName(name);
  return task;
}",0.9751131221719456
87222,"@Override public void deallocateProc(DispatchProc proc,String why){
  if (proc == null) {
    return;
  }
  logger.info(""String_Node_Str"",proc.getProcId(),why);
  final Quota quota=quotaDao.getQuota(proc);
  quotaDao.freeResources(quota,proc.getIdleCores());
  final Node node=nodeDao.get(proc.getNodeId());
  nodeDao.freeResources(node,proc.getIdleCores(),proc.getIdleRam());
  dispatchDao.decrementDispatchTotals(proc);
  if (!procDao.delete(proc)) {
    logger.warn(""String_Node_Str"",proc.getProcId());
  }
  eventManager.post(new ProcDeallocatedEvent(proc));
}","@Override public void deallocateProc(DispatchProc proc,String why){
  if (proc == null) {
    return;
  }
  logger.info(""String_Node_Str"",proc.getProcId(),why);
  final Quota quota=quotaDao.getQuota(proc);
  final Node node=nodeDao.get(proc.getNodeId());
  if (procDao.delete(proc)) {
    quotaDao.freeResources(quota,proc.getIdleCores());
    nodeDao.freeResources(node,proc.getIdleCores(),proc.getIdleRam());
    dispatchDao.decrementDispatchTotals(proc);
  }
 else {
    logger.warn(""String_Node_Str"",proc.getProcId());
  }
  eventManager.post(new ProcDeallocatedEvent(proc));
}",0.7563318777292577
87223,"@Override public DispatchProc allocateProc(DispatchNode node,DispatchableTask task){
  final Quota quota=quotaDao.getQuota(node,task);
  if (!quotaDao.allocateResources(quota,task.minCores)) {
    logger.info(""String_Node_Str"");
    return null;
  }
  if (!nodeDao.allocateResources(node,task.minCores,task.minRam)) {
    logger.info(""String_Node_Str"" + node.getName());
    return null;
  }
  DispatchProc proc=procDao.create(node,task);
  dispatchDao.incrementDispatchTotals(proc);
  eventManager.post(new ProcAllocatedEvent(proc));
  return proc;
}","@Override public DispatchProc allocateProc(DispatchNode node,DispatchableTask task){
  DispatchProc proc=procDao.create(node,task);
  final Quota quota=quotaDao.getQuota(node,task);
  if (!quotaDao.allocateResources(quota,task.minCores)) {
    logger.info(""String_Node_Str"");
    return null;
  }
  if (!nodeDao.allocateResources(node,task.minCores,task.minRam)) {
    logger.info(""String_Node_Str"" + node.getName());
    return null;
  }
  dispatchDao.incrementDispatchTotals(proc);
  eventManager.post(new ProcAllocatedEvent(proc));
  return proc;
}",0.9147005444646098
87224,"@Override public boolean allocateResources(Node node,int cores,int memory){
  if (jdbc.update(ALLOCATE_RESOURCES,cores,memory,cores,memory,node.getNodeId()) != 1) {
    return true;
  }
  return false;
}","@Override public boolean allocateResources(Node node,int cores,int memory){
  if (jdbc.update(ALLOCATE_RESOURCES,cores,memory,cores,memory,node.getNodeId()) == 1) {
    return true;
  }
  return false;
}",0.9950738916256158
87225,"@Override public void incrementDispatchTotals(DispatchProc proc){
  jdbc.update(""String_Node_Str"" + ""String_Node_Str"",proc.getIdleCores(),proc.getJobId());
  jdbc.update(""String_Node_Str"",proc.getIdleCores(),proc.getJobId());
  jdbc.update(""String_Node_Str"",""String_Node_Str"",proc.getIdleCores(),proc.getTaskId());
}","@Override public void incrementDispatchTotals(DispatchProc proc){
  jdbc.update(""String_Node_Str"" + ""String_Node_Str"",proc.getIdleCores(),proc.getJobId());
  jdbc.update(""String_Node_Str"",proc.getIdleCores(),proc.getJobId());
  jdbc.update(""String_Node_Str"" + ""String_Node_Str"",proc.getIdleCores(),proc.getTaskId());
}",0.9936908517350158
87226,"@Override public void decrementDispatchTotals(DispatchProc proc){
  jdbc.update(""String_Node_Str"" + ""String_Node_Str"",proc.getIdleCores(),proc.getJobId());
  jdbc.update(""String_Node_Str"",proc.getIdleCores(),proc.getJobId());
  jdbc.update(""String_Node_Str"",""String_Node_Str"",proc.getIdleCores(),proc.getTaskId());
}","@Override public void decrementDispatchTotals(DispatchProc proc){
  jdbc.update(""String_Node_Str"" + ""String_Node_Str"",proc.getIdleCores(),proc.getJobId());
  jdbc.update(""String_Node_Str"",proc.getIdleCores(),proc.getJobId());
  jdbc.update(""String_Node_Str"" + ""String_Node_Str"",proc.getIdleCores(),proc.getTaskId());
}",0.9936908517350158
87227,"@Override public RunTaskCommand mapRow(ResultSet rs,int rowNum) throws SQLException {
  RunTaskCommand task=new RunTaskCommand();
  task.jobId=rs.getString(""String_Node_Str"");
  task.taskId=rs.getString(""String_Node_Str"");
  task.layerId=rs.getString(""String_Node_Str"");
  task.procId=rs.getString(""String_Node_Str"");
  task.cores=rs.getInt(""String_Node_Str"");
  task.logFile=String.format(""String_Node_Str"",rs.getString(""String_Node_Str""),rs.getString(""String_Node_Str""),rs.getInt(""String_Node_Str""));
  task.uid=rs.getInt(""String_Node_Str"");
  task.username=rs.getString(""String_Node_Str"");
  task.command=Arrays.asList((String[])rs.getArray(""String_Node_Str"").getArray());
  for (int i=0; i < task.command.size(); i++) {
    String part=task.command.get(i);
    part=part.replace(""String_Node_Str"",String.valueOf(rs.getInt(""String_Node_Str"")));
    part=part.replace(""String_Node_Str"",rs.getString(""String_Node_Str""));
    task.command.set(i,part);
  }
  task.env=Maps.newHashMap();
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  return task;
}","@Override public RunTaskCommand mapRow(ResultSet rs,int rowNum) throws SQLException {
  RunTaskCommand task=new RunTaskCommand();
  task.jobId=rs.getString(""String_Node_Str"");
  task.taskId=rs.getString(""String_Node_Str"");
  task.layerId=rs.getString(""String_Node_Str"");
  task.logFile=String.format(""String_Node_Str"",rs.getString(""String_Node_Str""),rs.getString(""String_Node_Str""),rs.getInt(""String_Node_Str""));
  task.uid=rs.getInt(""String_Node_Str"");
  task.username=rs.getString(""String_Node_Str"");
  task.command=Arrays.asList((String[])rs.getArray(""String_Node_Str"").getArray());
  for (int i=0; i < task.command.size(); i++) {
    String part=task.command.get(i);
    part=part.replace(""String_Node_Str"",String.valueOf(rs.getInt(""String_Node_Str"")));
    part=part.replace(""String_Node_Str"",rs.getString(""String_Node_Str""));
    task.command.set(i,part);
  }
  task.env=Maps.newHashMap();
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  task.env.put(""String_Node_Str"",rs.getString(""String_Node_Str""));
  return task;
}",0.9507373705679322
87228,"@Test public void testGetDispatchNode(){
}","@Test public void testGetDispatchNode(){
  DispatchNode dnode=dispatchDao.getDispatchNode(node.getName());
}",0.56
87229,"@Test public void testGetDispatchFolder(){
  Folder folder=folderDao.getDefaultFolder(TEST_PROJECT);
  DispatchFolder dfolder=dispatchDao.getDispatchFolder(folder.getFolderId());
  assertEquals(folder.getFolderId(),dfolder.getFolderId());
  assertEquals(0,dfolder.getRunCores());
  assertEquals(-1,dfolder.getMinCores());
  assertEquals(-1,dfolder.getMaxCores());
}","@Test public void testGetDispatchFolder(){
  Folder folder=folderDao.getDefaultFolder(TEST_PROJECT);
  DispatchableFolder dfolder=dispatchDao.getDispatchableFolder(folder.getFolderId());
}",0.650994575045208
87230,"@Test public void testSortedProjects(){
  List<DispatchProject> projects=dispatchDao.getSortedProjectList(node);
  for (  DispatchProject project : projects) {
    logger.info(project.getProjectId());
  }
  assertEquals(1,projects.size());
}","@Test public void testSortedProjects(){
  List<DispatchProject> projects=dispatchDao.getSortedProjectList(node);
  assertEquals(1,projects.size());
}",0.764102564102564
87231,"@Test public void testGetDispatchProc(){
}","@Test public void testGetDispatchProc(){
  DispatchResult result=new DispatchResult(node);
  result.isTest=true;
  nodeDispatcher.dispatch(result,node);
  for (  DispatchProc proc : result.procs) {
    DispatchProc dbProc=dispatchDao.getDispatchProc(proc.getProcId());
    assertEquals(proc.getProcId(),dbProc.getProcId());
    assertEquals(proc.getJobId(),dbProc.getJobId());
    assertEquals(proc.getNodeId(),dbProc.getNodeId());
    assertEquals(proc.getTaskId(),dbProc.getTaskId());
    assertEquals(proc.getIdleCores(),proc.getIdleCores());
    assertEquals(proc.getIdleRam(),proc.getIdleRam());
  }
}",0.1296296296296296
87232,"@Override public DispatchProc create(DispatchNode node,DispatchableTask task){
  DispatchProc proc=new DispatchProc();
  proc.setProcId(UUID.randomUUID());
  proc.setJobId(task.jobId);
  proc.setTaskId(task.taskId);
  proc.setHostname(node.getName());
  proc.setNodeId(node.getNodeId());
  proc.setAllocated(true);
  proc.setTags(node.getTags());
  proc.setCores(task.minCores);
  proc.setMemory(task.minRam);
  jdbc.update(INSERT,proc.getProcId(),node.getNodeId(),task.jobId,task.taskId,task.minCores,task.minRam);
  return proc;
}","@Override public DispatchProc create(DispatchNode node,DispatchableTask task){
  DispatchProc proc=new DispatchProc();
  proc.setProcId(UUID.randomUUID());
  proc.setJobId(task.jobId);
  proc.setTaskId(task.taskId);
  proc.setHostname(node.getName());
  proc.setNodeId(node.getNodeId());
  proc.setAllocated(true);
  proc.setTags(node.getTags());
  proc.setCores(task.minCores);
  proc.setMemory(task.minRam);
  jdbc.update(INSERT,proc.getProcId(),node.getNodeId(),task.taskId,task.jobId,task.minCores,task.minRam);
  return proc;
}",0.9774436090225564
87233,"@Override public Quota getQuota(Proc proc){
  return jdbc.queryForObject(GET_BY_TASK,MAPPER,proc.getTaskId(),proc.getNodeId());
}","@Override public Quota getQuota(Proc proc){
  return jdbc.queryForObject(GET_BY_PROC,MAPPER,proc.getJobId(),proc.getNodeId());
}",0.9416342412451362
87234,"@Override public boolean allocateResources(Quota quota,int cores){
  return jdbc.update(ALLOCATE_RESOURCE,cores,quota.getQuotaId()) == 1;
}","@Override public boolean allocateResources(Quota quota,int cores){
  Preconditions.checkNotNull(quota);
  return jdbc.update(ALLOCATE_RESOURCE,cores,quota.getQuotaId(),cores) == 1;
}",0.8660436137071651
87235,"public void taskComplete(RunTaskResult result){
  Task task=jobService.getTask(result.taskId);
  DispatchJob job=frontEndDispatcher.getJob(task.getJobId());
  DispatchProc proc=dispatchService.getDispatchProc(result.procId);
  TaskState newState;
  if (result.exitStatus == 0) {
    newState=TaskState.SUCCEEDED;
  }
 else {
    newState=TaskState.DEAD;
  }
  logger.info(""String_Node_Str"",new Object[]{proc.getHostname(),proc.getTaskName(),result.exitStatus});
  logger.info(""String_Node_Str"",newState.toString());
  if (dispatchService.stopTask(task,newState)) {
    dispatchService.unassignProc(proc);
    jobStateManager.satisfyDependsOn(task);
    final Layer layer=new LayerE(task);
    if (jobService.isLayerComplete(layer)) {
      jobStateManager.satisfyDependsOn(layer);
    }
  }
 else {
    logger.warn(""String_Node_Str"",proc.getTaskName());
    return;
  }
  if (jobService.isJobPaused(job)) {
    dispatchService.unbookProc(proc,""String_Node_Str"" + job.getJobId());
  }
 else   if (jobService.isFinished(job)) {
    dispatchService.unbookProc(proc,""String_Node_Str"" + job.getJobId());
    jobStateManager.shutdown(job);
  }
 else {
    dispatchPool.execute(new DispatchProcToJob(proc,job,frontEndDispatcher));
  }
}","public void taskComplete(RunTaskResult result){
  Task task=jobService.getTask(result.taskId);
  DispatchJob job=frontEndDispatcher.getJob(task.getJobId());
  DispatchProc proc=dispatchService.getDispatchProc(result.procId);
  TaskState newState;
  if (result.exitStatus == 0) {
    newState=TaskState.SUCCEEDED;
  }
 else {
    newState=TaskState.DEAD;
  }
  logger.info(""String_Node_Str"",new Object[]{proc.getHostname(),proc.getTaskName(),result.exitStatus});
  logger.info(""String_Node_Str"",newState.toString());
  if (dispatchService.stopTask(task,newState)) {
    dispatchService.unassignProc(proc);
    if (newState.equals(TaskState.SUCCEEDED)) {
      jobStateManager.satisfyDependsOn(task);
      final Layer layer=new LayerE(task);
      if (jobService.isLayerComplete(layer)) {
        jobStateManager.satisfyDependsOn(layer);
      }
    }
  }
 else {
    logger.warn(""String_Node_Str"",proc.getTaskName());
    return;
  }
  if (jobService.isJobPaused(job)) {
    dispatchService.unbookProc(proc,""String_Node_Str"" + job.getJobId());
  }
 else   if (jobService.isFinished(job)) {
    dispatchService.unbookProc(proc,""String_Node_Str"" + job.getJobId());
    jobStateManager.shutdownJob(job);
  }
 else {
    dispatchPool.execute(new DispatchProcToJob(proc,job,frontEndDispatcher));
  }
}",0.9734653465346534
87236,"@Override public DispatchProc createProc(DispatchNode node,DispatchTask task){
  final Quota quota=quotaDao.getQuota(node,task);
  final DispatchProc proc=new DispatchProc();
  proc.setTaskId(task.getTaskId());
  proc.setNodeId(node.getNodeId());
  proc.setQuotaId(quota.getQuotaId());
  proc.setCores(task.getMinCores());
  proc.setTaskName(task.getName());
  proc.setHostname(node.getName());
  proc.setJobId(task.getJobId());
  proc.setLayerId(task.getLayerId());
  proc.setTags(task.getTags());
  procDao.create(proc);
  nodeDao.allocateResources(node,task.getMinCores(),task.getMinMemory());
  quotaDao.allocateResources(quota,task.getMinCores());
  dispatchDao.addToDispatchTotals(proc);
  node.decrement(task.getMinCores(),task.getMinMemory());
  return proc;
}","@Override public DispatchProc createProc(DispatchNode node,DispatchTask task){
  final Quota quota=quotaDao.getQuota(node,task);
  final DispatchProc proc=new DispatchProc();
  proc.setTaskId(task.getTaskId());
  proc.setNodeId(node.getNodeId());
  proc.setQuotaId(quota.getQuotaId());
  proc.setCores(task.getMinCores());
  proc.setMemory(task.getMinMemory());
  proc.setTaskName(task.getName());
  proc.setHostname(node.getName());
  proc.setJobId(task.getJobId());
  proc.setLayerId(task.getLayerId());
  proc.setTags(task.getTags());
  procDao.create(proc);
  nodeDao.allocateResources(node,task.getMinCores(),task.getMinMemory());
  quotaDao.allocateResources(quota,task.getMinCores());
  dispatchDao.addToDispatchTotals(proc);
  node.decrement(task.getMinCores(),task.getMinMemory());
  return proc;
}",0.9752380952380952
87237,"@Override public void unbookProc(DispatchProc proc,String why){
  if (proc == null) {
    logger.info(""String_Node_Str"");
    return;
  }
  if (!proc.isAllocated()) {
    logger.warn(""String_Node_Str"",proc.getProcId(),why);
    return;
  }
  logger.info(""String_Node_Str"",proc.getProcId(),why);
  if (procDao.delete(proc)) {
    logger.info(""String_Node_Str"",proc.getProcId());
    final Quota quota=quotaDao.get(proc.getQuotaId());
    final Node node=nodeDao.get(proc.getNodeId());
    nodeDao.freeResources(node,proc.getCores(),proc.getMemory());
    quotaDao.freeResources(quota,proc.getCores());
    dispatchDao.subtractFromDispatchTotals(proc);
    proc.setAllocated(false);
    eventManager.post(new JobUnbookedEvent(proc));
  }
 else {
    logger.warn(""String_Node_Str"",proc.getProcId());
  }
}","@Override public void unbookProc(DispatchProc proc,String why){
  if (proc == null) {
    logger.info(""String_Node_Str"");
    return;
  }
  if (!proc.isAllocated()) {
    logger.warn(""String_Node_Str"",proc.getProcId(),why);
    return;
  }
  logger.info(""String_Node_Str"",proc.getProcId(),why);
  if (procDao.delete(proc)) {
    logger.info(""String_Node_Str"",proc.getProcId());
    logger.info(""String_Node_Str"",proc.getCores(),proc.getMemory());
    final Quota quota=quotaDao.get(proc.getQuotaId());
    final Node node=nodeDao.get(proc.getNodeId());
    nodeDao.freeResources(node,proc.getCores(),proc.getMemory());
    quotaDao.freeResources(quota,proc.getCores());
    dispatchDao.subtractFromDispatchTotals(proc);
    proc.setAllocated(false);
    eventManager.post(new JobUnbookedEvent(proc));
  }
 else {
    logger.warn(""String_Node_Str"",proc.getProcId());
  }
}",0.958756724447101
87238,"public boolean killJob(Job job,String reason){
  final boolean killResult=jobService.shutdown(job);
  if (killResult) {
    processManager.killProcs(job,reason);
  }
  return killResult;
}","public boolean killJob(Job job,String reason){
  final boolean killResult=shutdownJob(job);
  if (killResult) {
    processManager.killProcs(job,reason);
  }
  return killResult;
}",0.9619565217391304
87239,"@Override public List<NodeT> getNodes(NodeFilterT filter) throws PlowException, TException {
  return null;
}","@Override public List<NodeT> getNodes(NodeFilterT filter) throws PlowException, TException {
  return thriftNodeDao.getNodes(filter);
}",0.8688524590163934
87240,"@Test public void testGetTasks(){
  JobSpecT spec=getTestJobSpec();
  jobService.launch(spec);
  @SuppressWarnings(""String_Node_Str"") UUID id=simpleJdbcTemplate.queryForObject(""String_Node_Str"",UUID.class);
  List<TaskT> task=thriftTaskDao.getTasks(id);
  assertTrue(task.size() > 0);
}","@Test public void testGetTasks(){
  JobSpecT spec=getTestJobSpec();
  JobLaunchEvent event=jobService.launch(spec);
  TaskFilterT filter=new TaskFilterT();
  filter.jobId=event.getJob().getJobId().toString();
  List<TaskT> task=thriftTaskDao.getTasks(filter);
  assertTrue(task.size() > 0);
}",0.370242214532872
87241,"@Subscribe public void handleJobUnbookedEvent(JobUnbookedEvent event){
  DispatchJob job=jobIndex.get(event.getProc().getJobId());
  if (job == null) {
    return;
  }
  DispatchProc proc=event.getProc();
synchronized (job) {
    job.decrementCores(proc.getCores());
  }
  DispatchFolder folder=folderIndex.get(job.getFolderId());
synchronized (folder) {
    folder.decrementCores(proc.getCores());
  }
}","@Subscribe public void handleJobUnbookedEvent(JobUnbookedEvent event){
  final DispatchJob job=jobIndex.get(event.getProc().getJobId());
  if (job == null) {
    logger.info(""String_Node_Str"");
    return;
  }
  final DispatchFolder folder=folderIndex.get(job.getFolderId());
  logger.info(""String_Node_Str"",job.getRunCores(),folder.getRunCores());
  DispatchProc proc=event.getProc();
synchronized (job) {
    job.decrementCores(proc.getCores());
  }
synchronized (folder) {
    folder.decrementCores(proc.getCores());
  }
  logger.info(""String_Node_Str"",job.getRunCores(),folder.getRunCores());
}",0.6806387225548902
87242,"@Subscribe public void handleJobBookedEvent(JobBookedEvent event){
  DispatchJob job=jobIndex.get(event.getTask().getJobId());
  if (job == null) {
    return;
  }
  DispatchProc proc=event.getProc();
synchronized (job) {
    job.incrementCores(proc.getCores());
  }
  DispatchFolder folder=folderIndex.get(job.getFolderId());
synchronized (folder) {
    folder.incrementCores(proc.getCores());
  }
}","@Subscribe public void handleJobBookedEvent(JobBookedEvent event){
  DispatchJob job=jobIndex.get(event.getTask().getJobId());
  if (job == null) {
    logger.info(""String_Node_Str"");
    return;
  }
  final DispatchFolder folder=folderIndex.get(job.getFolderId());
  logger.info(""String_Node_Str"",job.getRunCores(),folder.getRunCores());
  DispatchProc proc=event.getProc();
synchronized (job) {
    job.incrementCores(proc.getCores());
  }
synchronized (folder) {
    folder.incrementCores(proc.getCores());
  }
  logger.info(""String_Node_Str"",job.getRunCores(),folder.getRunCores());
}",0.6821862348178138
87243,"private void addNewJobs(){
  int count=0;
  while (true) {
    DispatchJob job=addJobs.poll();
    if (job == null) {
      logger.info(""String_Node_Str"");
      break;
    }
    count++;
    if (!activeJobs.containsKey(job.getProjectId())) {
      activeJobs.put(job.getProjectId(),new ArrayList<DispatchJob>());
    }
    activeJobs.get(job.getProjectId()).add(job);
  }
  logger.info(""String_Node_Str"" + count + ""String_Node_Str"");
}","private void addNewJobs(){
  int count=0;
  while (true) {
    DispatchJob job=addJobs.poll();
    if (job == null) {
      break;
    }
 else {
      count++;
      if (!activeJobs.containsKey(job.getProjectId())) {
        activeJobs.put(job.getProjectId(),new ArrayList<DispatchJob>());
      }
      activeJobs.get(job.getProjectId()).add(job);
    }
  }
  logger.info(""String_Node_Str"" + count + ""String_Node_Str"");
}",0.4102564102564102
87244,"@Subscribe public void handleJobUnbookedEvent(JobUnbookedEvent event){
  final DispatchJob job=jobIndex.get(event.getProc().getJobId());
  if (job == null) {
    logger.info(""String_Node_Str"");
    return;
  }
  final DispatchFolder folder=folderIndex.get(job.getFolderId());
  logger.info(""String_Node_Str"",job.getRunCores(),folder.getRunCores());
  DispatchProc proc=event.getProc();
synchronized (job) {
    job.decrementCores(proc.getCores());
  }
synchronized (folder) {
    folder.decrementCores(proc.getCores());
  }
  logger.info(""String_Node_Str"",job.getRunCores(),folder.getRunCores());
}","@Subscribe public void handleJobUnbookedEvent(JobUnbookedEvent event){
  DispatchJob job=jobIndex.get(event.getProc().getJobId());
  if (job == null) {
    return;
  }
  DispatchProc proc=event.getProc();
synchronized (job) {
    job.decrementCores(proc.getCores());
  }
  DispatchFolder folder=folderIndex.get(job.getFolderId());
synchronized (folder) {
    folder.decrementCores(proc.getCores());
  }
}",0.5049900199600799
87245,"@Subscribe public void handleJobBookedEvent(JobBookedEvent event){
  DispatchJob job=jobIndex.get(event.getTask().getJobId());
  if (job == null) {
    logger.info(""String_Node_Str"");
    return;
  }
  final DispatchFolder folder=folderIndex.get(job.getFolderId());
  logger.info(""String_Node_Str"",job.getRunCores(),folder.getRunCores());
  DispatchProc proc=event.getProc();
synchronized (job) {
    job.incrementCores(proc.getCores());
  }
synchronized (folder) {
    folder.incrementCores(proc.getCores());
  }
  logger.info(""String_Node_Str"",job.getRunCores(),folder.getRunCores());
}","@Subscribe public void handleJobBookedEvent(JobBookedEvent event){
  DispatchJob job=jobIndex.get(event.getTask().getJobId());
  if (job == null) {
    return;
  }
  DispatchProc proc=event.getProc();
synchronized (job) {
    job.incrementCores(proc.getCores());
  }
  DispatchFolder folder=folderIndex.get(job.getFolderId());
synchronized (folder) {
    folder.incrementCores(proc.getCores());
  }
}",0.5040485829959515
87246,"public void taskComplete(RunTaskResult result){
  Task task=jobService.getTask(result.taskId);
  DispatchJob job=frontEndDispatcher.getJob(task.getJobId());
  DispatchProc proc=dispatchService.getDispatchProc(result.procId);
  TaskState newState;
  if (result.exitStatus == 0) {
    newState=TaskState.SUCCEEDED;
  }
 else {
    newState=TaskState.DEAD;
  }
  logger.info(""String_Node_Str"",new Object[]{proc.getNodeName(),proc.getTaskName(),result.exitStatus});
  logger.info(""String_Node_Str"",newState.toString());
  if (!jobService.stopTask(task,newState)) {
    logger.warn(""String_Node_Str"",proc.getTaskName());
    return;
  }
 else {
    dispatchService.unassignProc(proc);
  }
  if (!jobService.hasPendingFrames(job)) {
    jobService.shutdown(job);
    return;
  }
  dispatchPool.execute(new DispatchProcToJob(proc,job,frontEndDispatcher));
}","public void taskComplete(RunTaskResult result){
  Task task=jobService.getTask(result.taskId);
  DispatchJob job=frontEndDispatcher.getJob(task.getJobId());
  DispatchProc proc=dispatchService.getDispatchProc(result.procId);
  TaskState newState;
  if (result.exitStatus == 0) {
    newState=TaskState.SUCCEEDED;
  }
 else {
    newState=TaskState.DEAD;
  }
  logger.info(""String_Node_Str"",new Object[]{proc.getNodeName(),proc.getTaskName(),result.exitStatus});
  logger.info(""String_Node_Str"",newState.toString());
  if (!jobService.stopTask(task,newState)) {
    logger.warn(""String_Node_Str"",proc.getTaskName());
    return;
  }
 else {
    dispatchService.unassignProc(proc);
  }
  if (!jobService.hasPendingFrames(job)) {
    jobService.shutdown(job);
    dispatchService.unbookProc(proc);
  }
  dispatchPool.execute(new DispatchProcToJob(proc,job,frontEndDispatcher));
}",0.977983777520278
87247,"public void book(DispatchNode node,DispatchTask task){
  if (!dispatchService.reserveTask(task)) {
    logger.warn(""String_Node_Str"",task.getName());
    return;
  }
  DispatchProc proc=null;
  try {
    proc=dispatchService.allocateDispatchProc(node,task);
    if (jobService.startTask(task,proc)) {
      dispatchSupport.runRndTask(task,proc);
    }
  }
 catch (  DispatchProcAllocationException e) {
    logger.warn(""String_Node_Str"",new Object[]{task.getMinCores(),task.getMinMemory(),node.getName()});
    node.setDispatchable(false);
  }
catch (  RndClientExecuteException e) {
    logger.warn(""String_Node_Str"" + node.getName());
    jobService.unreserveTask(task);
    dispatchService.cleanupFailedDispatch(proc);
    node.setDispatchable(false);
  }
catch (  Exception e) {
    logger.warn(""String_Node_Str"" + e);
    jobService.unreserveTask(task);
    dispatchService.cleanupFailedDispatch(proc);
    node.setDispatchable(false);
  }
}","public void book(DispatchNode node,DispatchTask task){
  if (!dispatchService.reserveTask(task)) {
    logger.warn(""String_Node_Str"",task.getName());
    return;
  }
  DispatchProc proc=null;
  try {
    proc=dispatchService.allocateDispatchProc(node,task);
    if (jobService.startTask(task,proc)) {
      dispatchSupport.runRndTask(task,proc);
    }
  }
 catch (  DispatchProcAllocationException e) {
    logger.warn(""String_Node_Str"",new Object[]{task.getMinCores(),task.getMinMemory(),node.getName()});
    node.setDispatchable(false);
  }
catch (  RndClientExecuteException e) {
    logger.warn(""String_Node_Str"" + node.getName());
    jobService.unreserveTask(task);
    dispatchService.unbookProc(proc);
    node.setDispatchable(false);
  }
catch (  Exception e) {
    logger.warn(""String_Node_Str"" + e);
    jobService.unreserveTask(task);
    dispatchService.unbookProc(proc);
    node.setDispatchable(false);
  }
}",0.9475935828877006
87248,"public boolean dispatch(DispatchProc proc,DispatchTask task){
  if (!dispatchService.reserveTask(task)) {
    logger.warn(""String_Node_Str"",task.getName());
    return false;
  }
  try {
    dispatchService.assignProc(proc,task);
    if (jobService.startTask(task,proc)) {
      dispatchSupport.runRndTask(task,proc);
      return true;
    }
  }
 catch (  RndClientExecuteException e) {
    logger.warn(""String_Node_Str"" + proc.getNodeName());
    jobService.unreserveTask(task);
    dispatchService.cleanupFailedDispatch(proc);
  }
catch (  Exception e) {
    logger.warn(""String_Node_Str"" + e);
    jobService.unreserveTask(task);
    dispatchService.cleanupFailedDispatch(proc);
  }
  return false;
}","public boolean dispatch(DispatchProc proc,DispatchTask task){
  if (!dispatchService.reserveTask(task)) {
    logger.warn(""String_Node_Str"",task.getName());
    return false;
  }
  try {
    dispatchService.assignProc(proc,task);
    if (jobService.startTask(task,proc)) {
      dispatchSupport.runRndTask(task,proc);
      return true;
    }
  }
 catch (  RndClientExecuteException e) {
    logger.warn(""String_Node_Str"" + proc.getNodeName());
    jobService.unreserveTask(task);
    dispatchService.unbookProc(proc);
  }
catch (  Exception e) {
    logger.warn(""String_Node_Str"" + e);
    jobService.unreserveTask(task);
    dispatchService.unbookProc(proc);
  }
  return false;
}",0.9552669552669552
87249,"@Override public JobT mapRow(ResultSet rs,int rowNum) throws SQLException {
  JobT job=new JobT();
  job.id=rs.getString(""String_Node_Str"");
  job.name=rs.getString(""String_Node_Str"");
  job.paused=rs.getBoolean(""String_Node_Str"");
  job.maxCores=rs.getInt(""String_Node_Str"");
  job.maxCores=rs.getInt(""String_Node_Str"");
  job.startTime=rs.getLong(""String_Node_Str"");
  job.stopTime=rs.getLong(""String_Node_Str"");
  job.state=JobState.findByValue(rs.getInt(""String_Node_Str""));
  job.totalTaskCount=rs.getInt(""String_Node_Str"");
  job.succeededTaskCount=rs.getInt(""String_Node_Str"");
  job.runningTaskCount=rs.getInt(""String_Node_Str"");
  job.deadTaskCount=rs.getInt(""String_Node_Str"");
  job.eatenTaskCount=rs.getInt(""String_Node_Str"");
  job.waitingTaskCount=rs.getInt(""String_Node_Str"");
  job.dependTaskCount=rs.getInt(""String_Node_Str"");
  return job;
}","@Override public JobT mapRow(ResultSet rs,int rowNum) throws SQLException {
  JobT job=new JobT();
  job.id=rs.getString(""String_Node_Str"");
  job.name=rs.getString(""String_Node_Str"");
  job.paused=rs.getBoolean(""String_Node_Str"");
  job.maxCores=rs.getInt(""String_Node_Str"");
  job.minCores=rs.getInt(""String_Node_Str"");
  job.startTime=rs.getLong(""String_Node_Str"");
  job.stopTime=rs.getLong(""String_Node_Str"");
  job.state=JobState.findByValue(rs.getInt(""String_Node_Str""));
  job.totalTaskCount=rs.getInt(""String_Node_Str"");
  job.succeededTaskCount=rs.getInt(""String_Node_Str"");
  job.runningTaskCount=rs.getInt(""String_Node_Str"");
  job.deadTaskCount=rs.getInt(""String_Node_Str"");
  job.eatenTaskCount=rs.getInt(""String_Node_Str"");
  job.waitingTaskCount=rs.getInt(""String_Node_Str"");
  job.dependTaskCount=rs.getInt(""String_Node_Str"");
  return job;
}",0.9976717112922002
87250,"@Override public Task mapRow(ResultSet rs,int rowNum) throws SQLException {
  TaskE frame=new TaskE();
  frame.setTaskId(UUID.fromString(rs.getString(1)));
  frame.setLayerId(UUID.fromString(rs.getString(2)));
  return frame;
}","@Override public Task mapRow(ResultSet rs,int rowNum) throws SQLException {
  TaskE frame=new TaskE();
  frame.setTaskId(UUID.fromString(rs.getString(1)));
  frame.setLayerId(UUID.fromString(rs.getString(2)));
  frame.setJobId((UUID)rs.getObject(3));
  return frame;
}",0.9171717171717172
87251,"@Override public Task create(Layer layer,int number,int taskOrder,int layerOrder){
  final UUID id=UUID.randomUUID();
  jdbc.update(INSERT,id,layer.getLayerId(),null,number,taskOrder,TaskState.INITIALIZE.ordinal());
  TaskE task=new TaskE();
  task.setTaskId(id);
  task.setLayerId(layer.getLayerId());
  return task;
}","@Override public Task create(Layer layer,int number,int taskOrder,int layerOrder){
  final UUID id=UUID.randomUUID();
  jdbc.update(INSERT,id,layer.getLayerId(),null,number,taskOrder,TaskState.INITIALIZE.ordinal());
  TaskE task=new TaskE();
  task.setTaskId(id);
  task.setLayerId(layer.getLayerId());
  task.setJobId(layer.getJobId());
  return task;
}",0.9479940564635958
87252,"@Override public Node createNode(Ping ping){
  Cluster cluster=clusterDao.getCluster(""String_Node_Str"");
  return nodeDao.create(cluster,ping);
}","@Override public Node createNode(Ping ping){
  Cluster cluster=clusterDao.getCluster(UUID.fromString(""String_Node_Str""));
  return nodeDao.create(cluster,ping);
}",0.9446254071661238
87253,"public List<DispatchProject> getSortedProjectList(final DispatchNode node){
  List<DispatchProject> result=jdbc.query(GET_SORTED_PROJECTS,DPROJECT_MAPPER,node.getClusterId());
  Collections.sort(result,new Comparator<DispatchProject>(){
    @Override public int compare(    DispatchProject o1,    DispatchProject o2){
      return Floats.compare(o1.getTier(),o2.getTier());
    }
  }
);
  return result;
}","@Override public List<DispatchProject> getSortedProjectList(final Node node){
  List<DispatchProject> result=jdbc.query(GET_SORTED_PROJECTS,DPROJECT_MAPPER,node.getClusterId());
  Collections.sort(result,new Comparator<DispatchProject>(){
    @Override public int compare(    DispatchProject o1,    DispatchProject o2){
      return Floats.compare(o1.getTier(),o2.getTier());
    }
  }
);
  return result;
}",0.9778325123152708
87254,"@Override public boolean OnInflateProperty(String nameSpace,String attrName,String attrValue){
  String value=null;
  if (NAMESPACE_ANDROID.equals(nameSpace)) {
    if (ATTRIBUTE_SRC.equals(attrName)) {
      src=IFlaterTools.getDrawableLocal(attrValue,getContext());
    }
  }
 else {
    if ((NAMESPACE_ANDROID + ""String_Node_Str"" + ATTRIBUTE_SRC).equals(attrName)) {
      src=IFlaterTools.getDrawableLocal(attrValue,getContext());
    }
  }
  return false;
}","@Override public boolean OnInflateProperty(String nameSpace,String attrName,String attrValue){
  String value=null;
  if (NAMESPACE_ANDROID.equals(nameSpace)) {
    if (ATTRIBUTE_SRC.equals(attrName)) {
      if (attrValue.startsWith(""String_Node_Str"")) {
        src=IFlaterTools.getBackgroundColor(attrValue,getContext());
      }
 else       if (attrValue.startsWith(""String_Node_Str"")) {
        imageSrcuri=IFlaterTools.getDrawableInternet(attrValue);
      }
 else {
        src=IFlaterTools.getDrawableLocal(attrValue,getContext());
      }
    }
  }
 else {
    if ((NAMESPACE_ANDROID + ""String_Node_Str"" + ATTRIBUTE_SRC).equals(attrName)) {
      if (attrValue.startsWith(""String_Node_Str"")) {
        src=IFlaterTools.getBackgroundColor(attrValue,getContext());
      }
 else       if (attrValue.startsWith(""String_Node_Str"")) {
        imageSrcuri=IFlaterTools.getDrawableInternet(attrValue);
      }
 else {
        src=IFlaterTools.getDrawableLocal(attrValue,getContext());
      }
    }
  }
  return false;
}",0.6226415094339622
87255,"@Override public void onFinishLayout(View lay){
  ImageView layout=(ImageView)lay;
  if (null != imageuri) {
    imageLoader.displayImage(imageuri,layout,options,animateFirstListener);
  }
}","@Override public void onFinishLayout(View lay){
  ImageView layout=(ImageView)lay;
  if (null != imageSrcuri) {
    imageLoader.displayImage(imageSrcuri,layout,options,animateFirstListener);
  }
}",0.9844559585492229
87256,"public static int px2dip(Context context,float pxValue){
  int px=(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,pxValue,context.getResources().getDisplayMetrics());
  return px;
}","public static int px2dip(Context context,float pxValue){
  if (NONE_FLOAT == scale) {
    scale=context.getResources().getDisplayMetrics().density;
  }
  return (int)(pxValue / scale + 0.5f);
}",0.6597402597402597
87257,"public void finishIFlate(final View layout){
  layout.setPadding(paddingLeft == NONE_INT ? 0 : paddingLeft,paddingTop == NONE_INT ? 0 : paddingTop,paddingRight == NONE_INT ? 0 : paddingRight,paddingBottom == NONE_INT ? 0 : paddingBottom);
  if (NONE_INT != backgroundColor)   layout.setBackgroundColor(backgroundColor);
  if (NONE_INT != background)   layout.setBackgroundResource(background);
  if (NONE_INT != id)   layout.setId(id);
  if (null != imageuri) {
    imageLoader.loadImage(imageuri,options,new SimpleImageLoadingListener(){
      @Override public void onLoadingComplete(      String imageUri,      View view,      Bitmap loadedImage,      String filePath){
        try {
          Debug.dLog(""String_Node_Str"" + filePath);
          layout.setBackground(new BitmapDrawable(loadedImage));
          layout.postInvalidate();
        }
 catch (        Exception e) {
          Debug.dLog(e);
        }
        super.onLoadingComplete(imageUri,view,loadedImage,filePath);
      }
    }
);
  }
  onFinishIFlate(layout);
}","public void finishIFlate(final View layout){
  layout.setPadding(paddingLeft == NONE_INT ? 0 : paddingLeft,paddingTop == NONE_INT ? 0 : paddingTop,paddingRight == NONE_INT ? 0 : paddingRight,paddingBottom == NONE_INT ? 0 : paddingBottom);
  if (NONE_INT != backgroundColor)   layout.setBackgroundColor(backgroundColor);
  if (NONE_INT != background)   layout.setBackgroundResource(background);
  if (NONE_INT != id)   layout.setId(id);
  if (null != imageuri) {
    imageLoader.loadImage(imageuri,options,new SimpleImageLoadingListener(){
      @Override public void onLoadingComplete(      String imageUri,      View view,      Bitmap loadedImage,      String filePath){
        try {
          Debug.dLog(""String_Node_Str"" + filePath);
          layout.setBackgroundDrawable(new BitmapDrawable(loadedImage));
          layout.postInvalidate();
        }
 catch (        Exception e) {
          Debug.dLog(e);
        }
        super.onLoadingComplete(imageUri,view,loadedImage,filePath);
      }
    }
);
  }
  onFinishIFlate(layout);
}",0.996135265700483
87258,"@Override public void onLoadingComplete(String imageUri,View view,Bitmap loadedImage,String filePath){
  try {
    Debug.dLog(""String_Node_Str"" + filePath);
    layout.setBackground(new BitmapDrawable(loadedImage));
    layout.postInvalidate();
  }
 catch (  Exception e) {
    Debug.dLog(e);
  }
  super.onLoadingComplete(imageUri,view,loadedImage,filePath);
}","@Override public void onLoadingComplete(String imageUri,View view,Bitmap loadedImage,String filePath){
  try {
    Debug.dLog(""String_Node_Str"" + filePath);
    layout.setBackgroundDrawable(new BitmapDrawable(loadedImage));
    layout.postInvalidate();
  }
 catch (  Exception e) {
    Debug.dLog(e);
  }
  super.onLoadingComplete(imageUri,view,loadedImage,filePath);
}",0.989041095890411
87259,"protected DistributedLockService(DistributedDataStructureFactory distributedDataStructureFactory){
  if (distributedDataStructureFactory == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.distributedDataStructureFactory=distributedDataStructureFactory;
  this.nodeId=distributedDataStructureFactory.getNodeId();
  this.nodesToExclusiveLocks=distributedDataStructureFactory.getMultiMap(getLockMapName());
  this.lockServiceLock=distributedDataStructureFactory.getLock(getServiceLockName());
  this.iAmCleanUpNode=lockServiceLock.tryLock();
}","protected DistributedLockService(DistributedDataStructureFactory distributedDataStructureFactory){
  if (distributedDataStructureFactory == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.distributedDataStructureFactory=distributedDataStructureFactory;
  this.nodeId=distributedDataStructureFactory.getNodeId();
  this.nodesToExclusiveLocks=distributedDataStructureFactory.getMultiMap(getLockMapName());
  this.lockServiceLock=distributedDataStructureFactory.getLock(getServiceLockName());
}",0.9550870760769936
87260,"@Override public void memberRemoved(final String uuid){
  iAmCleanUpNode=lockServiceLock.tryLock();
  if (iAmCleanUpNode) {
    executorService.submit(new Runnable(){
      @Override public void run(){
        releaseLocks(uuid);
      }
    }
);
  }
}","@Override public void memberRemoved(final String uuid){
  if (lockServiceLock.tryLock()) {
    try {
      executorService.submit(new Runnable(){
        @Override public void run(){
          releaseLocks(uuid);
        }
      }
);
    }
  finally {
      lockServiceLock.unlock();
    }
  }
}",0.7568555758683729
87261,"public void test(){
  Config standardConfig;
  if (crashProcess) {
    standardConfig=new ClasspathXmlConfig(""String_Node_Str"");
  }
 else {
    standardConfig=new ClasspathXmlConfig(""String_Node_Str"");
  }
  grid=Hazelcast.newHazelcastInstance(standardConfig);
  latch=grid.getCountDownLatch(""String_Node_Str"");
  latch.trySetCount(2);
  Locker locker=new Locker();
  new Thread(locker).run();
}","public void test(){
  Config standardConfig;
  if (crashProcess) {
    standardConfig=new ClasspathXmlConfig(""String_Node_Str"");
  }
 else {
    standardConfig=new ClasspathXmlConfig(""String_Node_Str"");
  }
  standardConfig.setProperty(""String_Node_Str"",""String_Node_Str"");
  grid=Hazelcast.newHazelcastInstance(standardConfig);
  latch=grid.getCountDownLatch(""String_Node_Str"");
  latch.trySetCount(2);
  Locker locker=new Locker();
  new Thread(locker).run();
}",0.9220023282887078
87262,"@Override public void run(){
  DistributedLockService lockService=DistributedLockService.newHazelcastLockService(grid);
  try {
    ReadWriteLock lock1, lock2, lock3, lock4;
    lock1=lockService.getReentrantReadWriteLock(LOCK1);
    lock2=lockService.getReentrantReadWriteLock(LOCK2);
    lock3=lockService.getReentrantReadWriteLock(LOCK3);
    lock4=lockService.getReentrantReadWriteLock(LOCK4);
    if (crashProcess) {
      System.out.println(""String_Node_Str"");
      lock1.readLock().lock();
      lock2.readLock().lock();
      lock3.writeLock().lock();
      lock4.writeLock().lock();
      System.out.println(""String_Node_Str"");
      latch.countDown();
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      latch.await(20000,TimeUnit.MILLISECONDS);
      System.out.println(""String_Node_Str"");
      throw new NullPointerException();
    }
 else {
      System.out.println(""String_Node_Str"");
      latch.countDown();
      System.out.println(""String_Node_Str"");
      latch.await(20000,TimeUnit.MILLISECONDS);
      lock1.readLock().lock();
      lock2.readLock().lock();
      lock3.readLock().lock();
      lock4.readLock().lock();
      System.out.println(""String_Node_Str"");
      lock1.readLock().unlock();
      lock2.readLock().unlock();
      lock3.readLock().unlock();
      lock4.readLock().unlock();
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
}","@Override public void run(){
  DistributedLockService lockService=DistributedLockService.newHazelcastLockService(grid);
  try {
    ReadWriteLock lock1, lock2, lock3, lock4;
    lock1=lockService.getReentrantReadWriteLock(LOCK1);
    lock2=lockService.getReentrantReadWriteLock(LOCK2);
    lock3=lockService.getReentrantReadWriteLock(LOCK3);
    lock4=lockService.getReentrantReadWriteLock(LOCK4);
    if (crashProcess) {
      System.out.println(""String_Node_Str"");
      lock1.readLock().lock();
      lock2.readLock().lock();
      lock3.writeLock().lock();
      lock4.writeLock().lock();
      System.out.println(""String_Node_Str"");
      latch.countDown();
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      latch.await(20000,TimeUnit.MILLISECONDS);
      System.out.println(""String_Node_Str"");
      System.exit(1);
    }
 else {
      System.out.println(""String_Node_Str"");
      latch.countDown();
      System.out.println(""String_Node_Str"");
      latch.await(20000,TimeUnit.MILLISECONDS);
      System.out.println(""String_Node_Str"");
      lock1.readLock().lock();
      lock2.readLock().lock();
      System.out.println(""String_Node_Str"");
      lock3.readLock().lock();
      lock4.writeLock().lock();
      System.out.println(""String_Node_Str"");
      lock1.readLock().unlock();
      lock2.readLock().unlock();
      lock3.readLock().unlock();
      lock4.writeLock().unlock();
      System.out.println(""String_Node_Str"");
      lockService.shutdown();
      grid.getLifecycleService().shutdown();
      System.exit(0);
    }
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
}",0.9295333542123396
87263,"/** 
 * Release a read or write lock.
 * @throws IllegalMonitorStateException if the current thread holds no locks
 */
void release(){
  monitor.lock();
  try {
    if (holds.get().tryDecrement() == 0) {
      numberOfThreads--;
      writeLockedBy.set(NONE);
      lockAvailable.signalAll();
    }
  }
  finally {
    monitor.unlock();
  }
}","/** 
 * Release a read or write lock.
 * @throws IllegalMonitorStateException if the current thread holds no locks
 */
void release(){
  monitor.lock();
  try {
    if (holds.get().tryDecrement() == 0) {
      numberOfThreads--;
      writeLockedBy=NONE;
      isWriteLocked.set(FALSE);
      holds.remove();
      lockAvailable.signalAll();
    }
  }
  finally {
    monitor.unlock();
  }
}",0.9195088676671214
87264,"/** 
 * Acquire a read lock.
 * @throws InterruptedException if the current thread is interrupted
 */
void acquireShared() throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  monitor.lockInterruptibly();
  try {
    if (holds.get().count > 0) {
      holds.get().count++;
    }
 else {
      while (!(writeCount.get() == 0 && writeLockedBy.get() == NONE)) {
        lockAvailable.await();
      }
      holds.get().count=1;
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
}","/** 
 * Acquire a read lock.
 * @throws InterruptedException if the current thread is interrupted
 */
void acquireShared() throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  monitor.lockInterruptibly();
  try {
    if (holds.get().count > 0) {
      holds.get().count++;
    }
 else {
      while (!(writersWaiting.get() == 0 && isWriteLocked.get() == FALSE)) {
        lockAvailable.await();
      }
      holds.get().count=1;
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
}",0.9755213055303718
87265,"/** 
 * Try and acquire an exclusive lock if it can be done in the time allowed.
 * @param l timeout amount
 * @param timeUnit timeout units
 * @return true if lock acquired; false o/w or if timeout is <= 0
 * @throws InterruptedException
 */
boolean tryAcquireExclusive(final long l,final TimeUnit timeUnit) throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  if (l <= 0)   return false;
  final ElapsedTimer timer=new ElapsedTimer(timeUnit.toMillis(l));
  if (!monitor.tryLock(timer.remainingMillis(),TimeUnit.MILLISECONDS))   return false;
  try {
    final long tid=getThread().getId();
    if (writeLockedBy.get() == tid) {
      holds.get().count++;
    }
 else {
      writeCount.incrementAndGet();
      while (numberOfThreads > 0) {
        try {
          if (!lockAvailable.await(timer.remainingMillis(),TimeUnit.MILLISECONDS)) {
            writeCount.decrementAndGet();
            return false;
          }
        }
 catch (        InterruptedException e) {
          writeCount.decrementAndGet();
          throw e;
        }
      }
      writeCount.decrementAndGet();
      holds.get().count=1;
      writeLockedBy.set(tid);
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
  return true;
}","/** 
 * Try and acquire an exclusive lock if it can be done in the time allowed.
 * @param l timeout amount
 * @param timeUnit timeout units
 * @return true if lock acquired; false o/w or if timeout is <= 0
 * @throws InterruptedException
 */
boolean tryAcquireExclusive(final long l,final TimeUnit timeUnit) throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  if (l <= 0)   return false;
  final ElapsedTimer timer=new ElapsedTimer(timeUnit.toMillis(l));
  if (!monitor.tryLock(timer.remainingMillis(),TimeUnit.MILLISECONDS))   return false;
  try {
    final long tid=getThread().getId();
    if (writeLockedBy == tid) {
      holds.get().count++;
    }
 else {
      writersWaiting.incrementAndGet();
      while (numberOfThreads > 0) {
        try {
          if (!lockAvailable.await(timer.remainingMillis(),TimeUnit.MILLISECONDS)) {
            writersWaiting.decrementAndGet();
            return false;
          }
        }
 catch (        InterruptedException e) {
          writersWaiting.decrementAndGet();
          throw e;
        }
      }
      writersWaiting.decrementAndGet();
      holds.get().count=1;
      writeLockedBy=tid;
      isWriteLocked.set(TRUE);
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
  return true;
}",0.9600307455803228
87266,"/** 
 * @return whether the current thread owns the write lock
 */
public boolean isHeldByCurrentThread(){
  return lockImpl.writeLockedBy.get() == getThread().getId();
}","/** 
 * @return whether the current thread owns the write lock
 */
public boolean isHeldByCurrentThread(){
  return lockImpl.isWriteLocked.get() == getThread().getId();
}",0.9823529411764704
87267,"/** 
 * @return true if anyone has the write lock.
 */
public boolean isWriteLocked(){
  return (lockImpl.writeLockedBy.get() != LockImpl.NONE);
}","/** 
 * @return true if anyone has the write lock.
 */
public boolean isWriteLocked(){
  return (lockImpl.isWriteLocked.get() != LockImpl.NONE);
}",0.9794520547945206
87268,"/** 
 * Acquire a write lock.
 * @throws InterruptedException if the current thread is interrupted
 */
void acquireExclusive() throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  monitor.lockInterruptibly();
  try {
    final long tid=getThread().getId();
    if (writeLockedBy.get() == tid) {
      holds.get().count++;
    }
 else {
      writeCount.incrementAndGet();
      while (numberOfThreads > 0) {
        try {
          lockAvailable.await();
        }
 catch (        InterruptedException e) {
          writeCount.decrementAndGet();
          throw e;
        }
      }
      writeCount.decrementAndGet();
      holds.get().count=1;
      writeLockedBy.set(tid);
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
}","/** 
 * Acquire a write lock.
 * @throws InterruptedException if the current thread is interrupted
 */
void acquireExclusive() throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  monitor.lockInterruptibly();
  try {
    final long tid=getThread().getId();
    if (writeLockedBy == tid) {
      holds.get().count++;
    }
 else {
      writersWaiting.incrementAndGet();
      while (numberOfThreads > 0) {
        try {
          lockAvailable.await();
        }
 catch (        InterruptedException e) {
          writersWaiting.decrementAndGet();
          throw e;
        }
      }
      writersWaiting.decrementAndGet();
      holds.get().count=1;
      writeLockedBy=tid;
      isWriteLocked.set(TRUE);
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
}",0.944920440636475
87269,"LockImpl(final DistributedDataStructureFactory grid,final String lockName){
  this.monitor=grid.getLock(lockName + ""String_Node_Str"");
  this.lockAvailable=grid.getCondition(monitor,lockName + ""String_Node_Str"");
  this.writeCount=grid.getAtomicLong(lockName + ""String_Node_Str"");
  this.writeLockedBy=grid.getAtomicLong(lockName + ""String_Node_Str"");
}","LockImpl(final DistributedDataStructureFactory grid,final String lockName){
  this.monitor=grid.getLock(lockName + ""String_Node_Str"");
  this.lockAvailable=grid.getCondition(monitor,lockName + ""String_Node_Str"");
  this.writersWaiting=grid.getAtomicLong(lockName + ""String_Node_Str"");
  this.isWriteLocked=grid.getAtomicLong(lockName + ""String_Node_Str"");
}",0.943661971830986
87270,"/** 
 * Acquire a shared lock only if it can be done in the given time.
 * @param l timeout amount
 * @param timeUnit timeout units
 * @return true if the exclusive lock was acquired; false o/w or if timeout was <= 0
 * @throws InterruptedException if the thread is interrupted
 */
boolean tryAcquireShared(final long l,final TimeUnit timeUnit) throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  if (l <= 0)   return false;
  final ElapsedTimer timer=new ElapsedTimer(timeUnit.toMillis(l));
  if (!monitor.tryLock(timer.remainingMillis(),TimeUnit.MILLISECONDS))   return false;
  try {
    if (holds.get().count > 0) {
      holds.get().count++;
    }
 else {
      while (!(writeCount.get() == 0 && writeLockedBy.get() == NONE)) {
        if (!lockAvailable.await(timer.remainingMillis(),TimeUnit.MILLISECONDS)) {
          return false;
        }
      }
      holds.get().count=1;
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
  return true;
}","/** 
 * Acquire a shared lock only if it can be done in the given time.
 * @param l timeout amount
 * @param timeUnit timeout units
 * @return true if the exclusive lock was acquired; false o/w or if timeout was <= 0
 * @throws InterruptedException if the thread is interrupted
 */
boolean tryAcquireShared(final long l,final TimeUnit timeUnit) throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  if (l <= 0)   return false;
  final ElapsedTimer timer=new ElapsedTimer(timeUnit.toMillis(l));
  if (!monitor.tryLock(timer.remainingMillis(),TimeUnit.MILLISECONDS))   return false;
  try {
    if (holds.get().count > 0) {
      holds.get().count++;
    }
 else {
      while (!(writersWaiting.get() == 0 && isWriteLocked.get() == FALSE)) {
        if (!lockAvailable.await(timer.remainingMillis(),TimeUnit.MILLISECONDS)) {
          return false;
        }
      }
      holds.get().count=1;
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
  return true;
}",0.9868613138686132
87271,"/** 
 * Acquire a read lock.
 * @throws InterruptedException if the current thread is interrupted
 */
void acquireShared() throws InterruptedException {
  monitor.lockInterruptibly();
  try {
    if (holds.get().count > 0) {
      holds.get().count++;
    }
 else {
      while (!(writeCount.get() == 0 && writeLockedBy.get() == NONE)) {
        lockAvailable.await();
      }
      holds.get().count=1;
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
}","/** 
 * Acquire a read lock.
 * @throws InterruptedException if the current thread is interrupted
 */
void acquireShared() throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  monitor.lockInterruptibly();
  try {
    if (holds.get().count > 0) {
      holds.get().count++;
    }
 else {
      while (!(writeCount.get() == 0 && writeLockedBy.get() == NONE)) {
        lockAvailable.await();
      }
      holds.get().count=1;
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
}",0.9308666017526775
87272,"/** 
 * Try and acquire an exclusive lock if it can be done in the time allowed.
 * @param l timeout amount
 * @param timeUnit timeout units
 * @return true if lock acquired; false o/w or if timeout is <= 0
 * @throws InterruptedException
 */
boolean tryAcquireExclusive(final long l,final TimeUnit timeUnit) throws InterruptedException {
  if (l <= 0)   return false;
  final ElapsedTimer timer=new ElapsedTimer(timeUnit.toMillis(l));
  if (!monitor.tryLock(timer.remainingMillis(),TimeUnit.MILLISECONDS))   return false;
  try {
    final long tid=getThread().getId();
    if (writeLockedBy.get() == tid) {
      holds.get().count++;
    }
 else {
      writeCount.incrementAndGet();
      while (numberOfThreads > 0) {
        if (!lockAvailable.await(timer.remainingMillis(),TimeUnit.MILLISECONDS)) {
          writeCount.decrementAndGet();
          return false;
        }
      }
      writeCount.decrementAndGet();
      holds.get().count=1;
      writeLockedBy.set(tid);
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
  return true;
}","/** 
 * Try and acquire an exclusive lock if it can be done in the time allowed.
 * @param l timeout amount
 * @param timeUnit timeout units
 * @return true if lock acquired; false o/w or if timeout is <= 0
 * @throws InterruptedException
 */
boolean tryAcquireExclusive(final long l,final TimeUnit timeUnit) throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  if (l <= 0)   return false;
  final ElapsedTimer timer=new ElapsedTimer(timeUnit.toMillis(l));
  if (!monitor.tryLock(timer.remainingMillis(),TimeUnit.MILLISECONDS))   return false;
  try {
    final long tid=getThread().getId();
    if (writeLockedBy.get() == tid) {
      holds.get().count++;
    }
 else {
      writeCount.incrementAndGet();
      while (numberOfThreads > 0) {
        try {
          if (!lockAvailable.await(timer.remainingMillis(),TimeUnit.MILLISECONDS)) {
            writeCount.decrementAndGet();
            return false;
          }
        }
 catch (        InterruptedException e) {
          writeCount.decrementAndGet();
          throw e;
        }
      }
      writeCount.decrementAndGet();
      holds.get().count=1;
      writeLockedBy.set(tid);
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
  return true;
}",0.8996598639455783
87273,"/** 
 * Acquire a write lock.
 * @throws InterruptedException if the current thread is interrupted
 */
void acquireExclusive() throws InterruptedException {
  monitor.lockInterruptibly();
  try {
    final long tid=getThread().getId();
    if (writeLockedBy.get() == tid) {
      holds.get().count++;
    }
 else {
      writeCount.incrementAndGet();
      while (numberOfThreads > 0) {
        lockAvailable.await();
      }
      writeCount.decrementAndGet();
      holds.get().count=1;
      writeLockedBy.set(tid);
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
}","/** 
 * Acquire a write lock.
 * @throws InterruptedException if the current thread is interrupted
 */
void acquireExclusive() throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  monitor.lockInterruptibly();
  try {
    final long tid=getThread().getId();
    if (writeLockedBy.get() == tid) {
      holds.get().count++;
    }
 else {
      writeCount.incrementAndGet();
      while (numberOfThreads > 0) {
        try {
          lockAvailable.await();
        }
 catch (        InterruptedException e) {
          writeCount.decrementAndGet();
          throw e;
        }
      }
      writeCount.decrementAndGet();
      holds.get().count=1;
      writeLockedBy.set(tid);
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
}",0.8507890961262554
87274,"/** 
 * Acquire a shared lock only if it can be done in the given time.
 * @param l timeout amount
 * @param timeUnit timeout units
 * @return true if the exclusive lock was acquired; false o/w or if timeout was <= 0
 * @throws InterruptedException if the thread is interrupted
 */
boolean tryAcquireShared(final long l,final TimeUnit timeUnit) throws InterruptedException {
  if (l <= 0)   return false;
  final ElapsedTimer timer=new ElapsedTimer(timeUnit.toMillis(l));
  if (!monitor.tryLock(timer.remainingMillis(),TimeUnit.MILLISECONDS))   return false;
  try {
    if (holds.get().count > 0) {
      holds.get().count++;
    }
 else {
      while (!(writeCount.get() == 0 && writeLockedBy.get() == NONE)) {
        if (!lockAvailable.await(timer.remainingMillis(),TimeUnit.MILLISECONDS)) {
          return false;
        }
      }
      holds.get().count=1;
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
  return true;
}","/** 
 * Acquire a shared lock only if it can be done in the given time.
 * @param l timeout amount
 * @param timeUnit timeout units
 * @return true if the exclusive lock was acquired; false o/w or if timeout was <= 0
 * @throws InterruptedException if the thread is interrupted
 */
boolean tryAcquireShared(final long l,final TimeUnit timeUnit) throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  if (l <= 0)   return false;
  final ElapsedTimer timer=new ElapsedTimer(timeUnit.toMillis(l));
  if (!monitor.tryLock(timer.remainingMillis(),TimeUnit.MILLISECONDS))   return false;
  try {
    if (holds.get().count > 0) {
      holds.get().count++;
    }
 else {
      while (!(writeCount.get() == 0 && writeLockedBy.get() == NONE)) {
        if (!lockAvailable.await(timer.remainingMillis(),TimeUnit.MILLISECONDS)) {
          return false;
        }
      }
      holds.get().count=1;
      numberOfThreads++;
    }
  }
  finally {
    monitor.unlock();
  }
  return true;
}",0.9641232945932288
87275,"@Override public void lockInterruptibly() throws InterruptedException {
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public void lockInterruptibly() throws InterruptedException {
  addToQueuedThreads();
  try {
    lockImpl.acquireExclusive();
    writeHolds.get().count++;
  }
  finally {
    removeFromQueuedThreads();
  }
}",0.4576271186440678
87276,"public long remainingMillis(){
  return completedMillis - System.currentTimeMillis();
}","public long remainingMillis(){
  long remainingMillis=completedMillis - System.currentTimeMillis();
  return remainingMillis >= 0 ? remainingMillis : 0;
}",0.6887966804979253
87277,"/** 
 * Release a read or write lock.
 * @throws IllegalMonitorStateException if the current thread holds no locks
 */
void release(){
  monitor.lock();
  try {
    if (holds.get().tryDecrement() == 0) {
      numberOfThreads--;
      writeLockedBy=NONE;
      isWriteLocked.set(FALSE);
      holds.remove();
      lockAvailable.signalAll();
    }
  }
  finally {
    monitor.unlock();
  }
}","/** 
 * Release a read or write lock.
 * @throws IllegalMonitorStateException if the current thread holds no locks
 */
void release(){
  monitor.lock();
  try {
    if (holds.get().tryDecrement() == 0) {
      numberOfThreads.decrementAndGet();
      writeLockedBy=NONE;
      isWriteLocked.set(FALSE);
      holds.remove();
      lockAvailable.signalAll();
    }
  }
  finally {
    monitor.unlock();
  }
}",0.974937343358396
87278,"/** 
 * Acquire a read lock.
 * @throws InterruptedException if the current thread is interrupted
 */
void acquireShared() throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  monitor.lockInterruptibly();
  if (holds.get().count > 0) {
    holds.get().count++;
  }
 else {
    while (!(writersWaiting.get() == 0 && isWriteLocked.get() == FALSE)) {
      lockAvailable.await();
    }
    holds.get().count=1;
    numberOfThreads++;
  }
  monitor.unlock();
}","/** 
 * Acquire a read lock.
 * @throws InterruptedException if the current thread is interrupted
 */
void acquireShared() throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  monitor.lockInterruptibly();
  if (holds.get().count > 0) {
    holds.get().count++;
  }
 else {
    while (!(writersWaiting.get() == 0 && isWriteLocked.get() == FALSE)) {
      lockAvailable.await();
    }
    holds.get().count=1;
    numberOfThreads.incrementAndGet();
  }
  monitor.unlock();
}",0.980544747081712
87279,"/** 
 * Try and acquire an exclusive lock if it can be done in the time allowed.
 * @param l timeout amount
 * @param timeUnit timeout units
 * @return true if lock acquired; false o/w or if timeout is <= 0
 * @throws InterruptedException
 */
boolean tryAcquireExclusive(final long l,final TimeUnit timeUnit) throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  if (l <= 0)   return false;
  final ElapsedTimer timer=new ElapsedTimer(timeUnit.toMillis(l));
  if (!monitor.tryLock(timer.remainingMillis(),TimeUnit.MILLISECONDS))   return false;
  final long tid=getThread().getId();
  if (writeLockedBy == tid) {
    holds.get().count++;
  }
 else {
    writersWaiting.incrementAndGet();
    while (numberOfThreads > 0) {
      try {
        if (!lockAvailable.await(timer.remainingMillis(),TimeUnit.MILLISECONDS)) {
          writersWaiting.decrementAndGet();
          monitor.unlock();
          return false;
        }
      }
 catch (      InterruptedException e) {
        writersWaiting.decrementAndGet();
        throw e;
      }
    }
    writersWaiting.decrementAndGet();
    holds.get().count=1;
    writeLockedBy=tid;
    isWriteLocked.set(TRUE);
    numberOfThreads++;
  }
  monitor.unlock();
  return true;
}","/** 
 * Try and acquire an exclusive lock if it can be done in the time allowed.
 * @param l timeout amount
 * @param timeUnit timeout units
 * @return true if lock acquired; false o/w or if timeout is <= 0
 * @throws InterruptedException
 */
boolean tryAcquireExclusive(final long l,final TimeUnit timeUnit) throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  if (l <= 0)   return false;
  final ElapsedTimer timer=new ElapsedTimer(timeUnit.toMillis(l));
  if (!monitor.tryLock(timer.remainingMillis(),TimeUnit.MILLISECONDS))   return false;
  final long tid=getThread().getId();
  if (writeLockedBy == tid) {
    holds.get().count++;
  }
 else {
    writersWaiting.incrementAndGet();
    while (numberOfThreads.get() > 0) {
      try {
        if (!lockAvailable.await(timer.remainingMillis(),TimeUnit.MILLISECONDS)) {
          writersWaiting.decrementAndGet();
          monitor.unlock();
          return false;
        }
      }
 catch (      InterruptedException e) {
        writersWaiting.decrementAndGet();
        throw e;
      }
    }
    writersWaiting.decrementAndGet();
    holds.get().count=1;
    writeLockedBy=tid;
    isWriteLocked.set(TRUE);
    numberOfThreads.incrementAndGet();
  }
  monitor.unlock();
  return true;
}",0.9898595943837754
87280,"/** 
 * Acquire a write lock.
 * @throws InterruptedException if the current thread is interrupted
 */
void acquireExclusive() throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  monitor.lockInterruptibly();
  final long tid=getThread().getId();
  if (writeLockedBy == tid) {
    holds.get().count++;
  }
 else {
    writersWaiting.incrementAndGet();
    while (numberOfThreads > 0) {
      try {
        lockAvailable.await();
      }
 catch (      InterruptedException e) {
        writersWaiting.decrementAndGet();
        throw e;
      }
    }
    writersWaiting.decrementAndGet();
    holds.get().count=1;
    writeLockedBy=tid;
    isWriteLocked.set(TRUE);
    numberOfThreads++;
  }
  monitor.unlock();
}","/** 
 * Acquire a write lock.
 * @throws InterruptedException if the current thread is interrupted
 */
void acquireExclusive() throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  monitor.lockInterruptibly();
  final long tid=getThread().getId();
  if (writeLockedBy == tid) {
    holds.get().count++;
  }
 else {
    writersWaiting.incrementAndGet();
    while (numberOfThreads.get() > 0) {
      try {
        lockAvailable.await();
      }
 catch (      InterruptedException e) {
        writersWaiting.decrementAndGet();
        throw e;
      }
    }
    writersWaiting.decrementAndGet();
    holds.get().count=1;
    writeLockedBy=tid;
    isWriteLocked.set(TRUE);
    numberOfThreads.incrementAndGet();
  }
  monitor.unlock();
}",0.9832041343669252
87281,"void forceUnlock(){
  monitor.lock();
  try {
    isWriteLocked.set(FALSE);
    lockAvailable.signalAll();
  }
  finally {
    monitor.unlock();
  }
}","void forceUnlock(){
  monitor.lock();
  try {
    isWriteLocked.set(FALSE);
    numberOfThreads.decrementAndGet();
    lockAvailable.signalAll();
  }
  finally {
    monitor.unlock();
  }
}",0.8849557522123894
87282,"LockImpl(final DistributedDataStructureFactory grid,final String lockName){
  this.monitor=grid.getLock(getMonitorName(lockName));
  this.lockAvailable=grid.getCondition(monitor,getConditionName(lockName));
  this.writersWaiting=grid.getAtomicLong(getWritersWaitingName(lockName));
  this.isWriteLocked=grid.getAtomicLong(getIsWriteLockedName(lockName));
}","LockImpl(final DistributedDataStructureFactory grid,final String lockName){
  this.monitor=grid.getLock(getMonitorName(lockName));
  this.lockAvailable=grid.getCondition(monitor,getConditionName(lockName));
  this.writersWaiting=grid.getAtomicLong(getWritersWaitingName(lockName));
  this.isWriteLocked=grid.getAtomicLong(getIsWriteLockedName(lockName));
  this.numberOfThreads=grid.getAtomicLong(getNumberOfThreadsName(lockName));
}",0.9024081115335868
87283,"/** 
 * Acquire a shared lock only if it can be done in the given time.
 * @param l timeout amount
 * @param timeUnit timeout units
 * @return true if the exclusive lock was acquired; false o/w or if timeout was <= 0
 * @throws InterruptedException if the thread is interrupted
 */
boolean tryAcquireShared(final long l,final TimeUnit timeUnit) throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  if (l <= 0)   return false;
  final ElapsedTimer timer=new ElapsedTimer(timeUnit.toMillis(l));
  if (!monitor.tryLock(timer.remainingMillis(),TimeUnit.MILLISECONDS))   return false;
  if (holds.get().count > 0) {
    holds.get().count++;
  }
 else {
    while (!(writersWaiting.get() == 0 && isWriteLocked.get() == FALSE)) {
      if (!lockAvailable.await(timer.remainingMillis(),TimeUnit.MILLISECONDS)) {
        monitor.unlock();
        return false;
      }
    }
    holds.get().count=1;
    numberOfThreads++;
  }
  monitor.unlock();
  return true;
}","/** 
 * Acquire a shared lock only if it can be done in the given time.
 * @param l timeout amount
 * @param timeUnit timeout units
 * @return true if the exclusive lock was acquired; false o/w or if timeout was <= 0
 * @throws InterruptedException if the thread is interrupted
 */
boolean tryAcquireShared(final long l,final TimeUnit timeUnit) throws InterruptedException {
  if (getThread().isInterrupted())   throw new InterruptedException();
  if (l <= 0)   return false;
  final ElapsedTimer timer=new ElapsedTimer(timeUnit.toMillis(l));
  if (!monitor.tryLock(timer.remainingMillis(),TimeUnit.MILLISECONDS))   return false;
  if (holds.get().count > 0) {
    holds.get().count++;
  }
 else {
    while (!(writersWaiting.get() == 0 && isWriteLocked.get() == FALSE)) {
      if (!lockAvailable.await(timer.remainingMillis(),TimeUnit.MILLISECONDS)) {
        monitor.unlock();
        return false;
      }
    }
    holds.get().count=1;
    numberOfThreads.incrementAndGet();
  }
  monitor.unlock();
  return true;
}",0.9901185770750988
87284,"/** 
 * Sets the opacity of the blurred View
 * @param opacity	Specifies the opacity the blurred View should be set to. Range between 0f and 1f.
 */
public void setBlurOpacity(float opacity){
  if (mBlurredBitmap == null) {
    mBlurredBitmap=applyBlur();
    mBlurImageView.setImageBitmap(mBlurredBitmap);
  }
  if (opacity < 0f)   opacity=0f;
 else   if (opacity > 1f)   opacity=1f;
  mBlurImageView.clearAnimation();
  ViewHelper.setAlpha(mBlurImageView,opacity);
  if (opacity == 0f)   resetBlur();
}","/** 
 * Sets the opacity of the blurred View
 * @param opacity	Specifies the opacity the blurred View should be set to. Range between 0f and 1f.
 */
public void setBlurOpacity(float opacity){
  if (mBlurredBitmap == null) {
    mBlurredBitmap=applyBlur();
    mBlurImageView.setImageBitmap(mBlurredBitmap);
  }
  if (opacity < 0f)   opacity=0f;
 else   if (opacity > 1f)   opacity=1f;
  mBlurImageView.clearAnimation();
  ViewHelper.setAlpha(mBlurImageView,opacity);
  if (opacity == 0f)   reset();
}",0.99601593625498
87285,"/** 
 * Applies the blur
 */
private Bitmap applyBlur(){
  mOriginalView.buildDrawingCache();
  Bitmap originalBitmap=mOriginalView.getDrawingCache().copy(Config.ARGB_8888,true);
  mOriginalView.destroyDrawingCache();
  Bitmap resultBitmap=Bitmap.createScaledBitmap(originalBitmap,originalBitmap.getWidth() / mScaleSize,originalBitmap.getHeight() / mScaleSize,true);
  if (mBlurRadius > 0f) {
    RenderScript renderScript=RenderScript.create(mContext);
    final Allocation input=Allocation.createFromBitmap(renderScript,resultBitmap,Allocation.MipmapControl.MIPMAP_NONE,Allocation.USAGE_SHARED);
    final Allocation output=Allocation.createFromBitmap(renderScript,resultBitmap,Allocation.MipmapControl.MIPMAP_NONE,Allocation.USAGE_SHARED);
    final ScriptIntrinsicBlur script=ScriptIntrinsicBlur.create(renderScript,Element.U8_4(renderScript));
    script.setRadius(mBlurRadius);
    script.setInput(input);
    script.forEach(output);
    renderScript.finish();
    output.copyTo(resultBitmap);
    renderScript.destroy();
    renderScript=null;
  }
  return resultBitmap;
}","/** 
 * Applies the blur
 */
private Bitmap applyBlur(){
  Bitmap resultBitmap=null;
  try {
    System.gc();
    mOriginalView.buildDrawingCache();
    Bitmap originalBitmap=mOriginalView.getDrawingCache().copy(Config.ARGB_8888,true);
    mOriginalView.destroyDrawingCache();
    resultBitmap=Bitmap.createScaledBitmap(originalBitmap,originalBitmap.getWidth() / mScaleSize,originalBitmap.getHeight() / mScaleSize,true);
    originalBitmap.recycle();
    originalBitmap=null;
    if (mBlurRadius > 0f) {
      RenderScript renderScript=RenderScript.create(mContext);
      final Allocation input=Allocation.createFromBitmap(renderScript,resultBitmap,Allocation.MipmapControl.MIPMAP_NONE,Allocation.USAGE_SHARED);
      final Allocation output=Allocation.createFromBitmap(renderScript,resultBitmap,Allocation.MipmapControl.MIPMAP_NONE,Allocation.USAGE_SHARED);
      final ScriptIntrinsicBlur script=ScriptIntrinsicBlur.create(renderScript,Element.U8_4(renderScript));
      script.setRadius(mBlurRadius);
      script.setInput(input);
      script.forEach(output);
      renderScript.finish();
      output.copyTo(resultBitmap);
      renderScript.destroy();
      renderScript=null;
    }
  }
 catch (  OutOfMemoryError e) {
    e.printStackTrace();
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  System.gc();
  return resultBitmap;
}",0.8672712283594394
87286,"/** 
 * Sets the opacity of the blurred View with an animation
 * @param opacity	Specifies the opacity the blurred View should be set to. Range between 0f and 1f.
 * @param duration	Specifies the duration of the animation (in milliseconds)
 */
public void animateBlurOpacity(float opacity,long duration){
  if (mBlurredBitmap == null) {
    mBlurredBitmap=applyBlur();
    mBlurImageView.setImageBitmap(mBlurredBitmap);
  }
  if (opacity < 0f)   opacity=0f;
 else   if (opacity > 1f)   opacity=1f;
  AlphaAnimation alphaAnimation=new AlphaAnimation(ViewHelper.getAlpha(mBlurImageView),opacity);
  alphaAnimation.setDuration(duration);
  alphaAnimation.setFillAfter(true);
  ViewHelper.setAlpha(mBlurImageView,1f);
  mBlurImageView.clearAnimation();
  mBlurImageView.startAnimation(alphaAnimation);
  if (opacity == 0f)   resetBlur();
}","/** 
 * Sets the opacity of the blurred View with an animation
 * @param opacity	Specifies the opacity the blurred View should be set to. Range between 0f and 1f.
 * @param duration	Specifies the duration of the animation (in milliseconds)
 */
public void animateBlurOpacity(float opacity,long duration){
  if (mBlurredBitmap == null) {
    mBlurredBitmap=applyBlur();
    mBlurImageView.setImageBitmap(mBlurredBitmap);
  }
  if (opacity < 0f)   opacity=0f;
 else   if (opacity > 1f)   opacity=1f;
  AlphaAnimation alphaAnimation=new AlphaAnimation(ViewHelper.getAlpha(mBlurImageView),opacity);
  alphaAnimation.setDuration(duration);
  alphaAnimation.setFillAfter(true);
  ViewHelper.setAlpha(mBlurImageView,1f);
  mBlurImageView.clearAnimation();
  mBlurImageView.startAnimation(alphaAnimation);
  if (opacity == 0f)   reset();
}",0.9975990396158464
87287,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_pip_test);
  Intent intent=getIntent();
  SAMPLE=intent.getStringExtra(Constant.FILE_MSG);
  mSurfaceView=(SurfaceView)findViewById(R.id.surfaceView);
  mSurfaceView.getHolder().addCallback(callback);
  mSettingUtil=new SettingUtil(this);
  mHWCodecEnable=mSettingUtil.isHWCodecEnable();
  mMediaPlayer=new MediaPlayer(this,mHWCodecEnable == 1);
  setupView();
  setupLisenner();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_pip_test);
  Intent intent=getIntent();
  SAMPLE=intent.getStringExtra(Constant.FILE_MSG);
  mSettingUtil=new SettingUtil(this);
  mHWCodecEnable=mSettingUtil.isHWCodecEnable();
  mMediaPlayer=new MediaPlayer(this,mHWCodecEnable == 1);
  setupView();
  setupLisenner();
}",0.8806941431670282
87288,"private void setupView(){
  mCtlPanel=(LinearLayout)findViewById(R.id.control_panel);
  mCtlPanel.setVisibility(View.VISIBLE);
  mCtlBar=(RelativeLayout)findViewById(R.id.control_bar);
  mCtlBar.setVisibility(View.VISIBLE);
  mPauseButton=(ImageButton)findViewById(R.id.btn_pause);
  mNextButton=(ImageButton)findViewById(R.id.btn_next);
  mInfoButton=(ImageButton)findViewById(R.id.btn_info);
  mRatioButton=(ImageButton)findViewById(R.id.btn_ratio);
  mSeekBarProgress=(SeekBar)findViewById(R.id.seekbar_time);
  mTextViewCurTime=(TextView)findViewById(R.id.txt_cur);
  mTextViewDuration=(TextView)findViewById(R.id.txt_dur);
  mTextViewInfo=(TextView)findViewById(R.id.txt_info);
  mImageViewSub=(ImageView)findViewById(R.id.iv_sub);
  mImageViewSub.setVisibility(View.VISIBLE);
  DisplayMetrics displayMetrics=new DisplayMetrics();
  getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);
  mScreenWidth=displayMetrics.widthPixels;
  mScreenHeight=displayMetrics.heightPixels;
}","private void setupView(){
  mSurfaceView=(SurfaceView)findViewById(R.id.surfaceView);
  mSurfaceView.getHolder().addCallback(callback);
  mCtlPanel=(LinearLayout)findViewById(R.id.control_panel);
  mCtlPanel.setVisibility(View.VISIBLE);
  mCtlBar=(RelativeLayout)findViewById(R.id.control_bar);
  mCtlBar.setVisibility(View.VISIBLE);
  mPauseButton=(ImageButton)findViewById(R.id.btn_pause);
  mNextButton=(ImageButton)findViewById(R.id.btn_next);
  mInfoButton=(ImageButton)findViewById(R.id.btn_info);
  mRatioButton=(ImageButton)findViewById(R.id.btn_ratio);
  mSeekBarProgress=(SeekBar)findViewById(R.id.seekbar_time);
  mTextViewCurTime=(TextView)findViewById(R.id.txt_cur);
  mTextViewDuration=(TextView)findViewById(R.id.txt_dur);
  mTextViewInfo=(TextView)findViewById(R.id.txt_info);
  mImageViewSub=(ImageView)findViewById(R.id.iv_sub);
  mImageViewSub.setVisibility(View.VISIBLE);
  DisplayMetrics displayMetrics=new DisplayMetrics();
  getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);
  mScreenWidth=displayMetrics.widthPixels;
  mScreenHeight=displayMetrics.heightPixels;
}",0.9475691134413728
87289,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_pip_test);
  mSurfaceView=(SurfaceView)findViewById(R.id.surfaceView);
  mSurfaceView.getHolder().addCallback(callback);
  mMediaPlayer=new MediaPlayer(this,true);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_pip_test);
  Intent intent=getIntent();
  SAMPLE=intent.getStringExtra(Constant.FILE_MSG);
  mSurfaceView=(SurfaceView)findViewById(R.id.surfaceView);
  mSurfaceView.getHolder().addCallback(callback);
  mMediaPlayer=new MediaPlayer(this,true);
}",0.8823529411764706
87290,"public void beginToPlayer(Context cr,String uri,String name,int type){
  Intent intent=new Intent();
  intent.putExtra(Constant.FILE_MSG,uri);
  intent.putExtra(Constant.FILE_TYPE,type);
  intent.putExtra(Constant.MEIDA_NAME_STR,name);
  intent.setClass(cr,VideoPlayerActivity.class);
  cr.startActivity(intent);
}","public void beginToPlayer(Context cr,String uri,String name,int type){
  Intent intent=new Intent();
  intent.putExtra(Constant.FILE_MSG,uri);
  intent.putExtra(Constant.FILE_TYPE,type);
  intent.putExtra(Constant.MEIDA_NAME_STR,name);
  intent.setClass(cr,PipTestActivity.class);
  cr.startActivity(intent);
}",0.8942307692307693
87291,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.file_browser);
  mListView=(ListView)findViewById(R.id.filebrowser_listview);
  mList=new ArrayList<Map<String,Object>>();
  if (mCurrentPath != null) {
    File file=new File(mCurrentPath);
    if (!file.exists())     mCurrentPath=ROOT;
  }
 else {
    mCurrentPath=ROOT;
  }
  mList=new ArrayList<Map<String,Object>>();
  mListView.setOnItemClickListener(new OnItemClickListener(){
    public void onItemClick(    AdapterView<?> parent,    View view,    int pos,    long id){
      Map<String,Object> item=(Map<String,Object>)parent.getItemAtPosition(pos);
      String mPath=(String)item.get(FILEINFO_KEY_PATH);
      File mFile=new File(mPath);
      if (!mFile.exists()) {
        return;
      }
      if (Intent.ACTION_GET_CONTENT.equalsIgnoreCase(FileBrowserActivity.this.getIntent().getAction())) {
        if (mFile.isDirectory()) {
          mCurrentPath=mPath;
          mListView.setAdapter(getFileListAdapterSorted(mCurrentPath,mSortType));
        }
 else {
          FileBrowserActivity.this.setResult(Activity.RESULT_OK,new Intent(null,Uri.fromFile(mFile)));
          FileBrowserActivity.this.finish();
        }
      }
 else {
        if (mFile.isDirectory()) {
          mCurrentPath=mPath;
          mListView.setAdapter(getFileListAdapterSorted(mCurrentPath,mSortType));
        }
 else {
          openFile(mFile);
        }
        mItemSelected=mListView.getSelectedItemPosition();
        mItemFirst=mListView.getFirstVisiblePosition();
        mItemLast=mListView.getLastVisiblePosition();
        View mView=mListView.getChildAt(mItemSelected - mItemFirst);
        if (mView != null) {
          mItemTop=mView.getTop();
        }
      }
    }
  }
);
  Button btn_home=(Button)findViewById(R.id.btn_home);
  btn_home.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      if (mCurrentPath.equals(ROOT))       return;
      mCurrentPath=ROOT;
      DeviceScan();
    }
  }
);
  Button btn_back=(Button)findViewById(R.id.btn_back);
  btn_back.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      if (!mCurrentPath.equals(ROOT)) {
        File file=new File(mCurrentPath);
        String parent_path=file.getParent();
        if (isDeviceFile(mCurrentPath)) {
          mCurrentPath=ROOT;
          DeviceScan();
        }
 else {
          mCurrentPath=parent_path;
          mListView.setAdapter(getFileListAdapterSorted(parent_path,mSortType));
        }
      }
    }
  }
);
  Button btn_style=(Button)findViewById(R.id.btn_style);
  btn_style.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      Log.i(TAG,""String_Node_Str"");
    }
  }
);
  Button btn_search=(Button)findViewById(R.id.btn_search);
  boolean isEnableSearch=false;
  if (!isEnableSearch)   btn_search.setVisibility(View.GONE);
  btn_search.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      Log.i(TAG,""String_Node_Str"");
    }
  }
);
  Button btn_about=(Button)findViewById(R.id.btn_about);
  btn_about.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      Log.i(TAG,""String_Node_Str"");
    }
  }
);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.file_browser);
  Log.i(TAG,""String_Node_Str"");
  mListView=(ListView)findViewById(R.id.filebrowser_listview);
  if (mCurrentPath != null) {
    File file=new File(mCurrentPath);
    if (!file.exists())     mCurrentPath=ROOT;
  }
 else {
    mCurrentPath=ROOT;
  }
  mListView.setOnItemClickListener(new OnItemClickListener(){
    public void onItemClick(    AdapterView<?> parent,    View view,    int pos,    long id){
      Map<String,Object> item=(Map<String,Object>)parent.getItemAtPosition(pos);
      String mPath=(String)item.get(FILEINFO_KEY_PATH);
      File mFile=new File(mPath);
      if (!mFile.exists()) {
        return;
      }
      if (Intent.ACTION_GET_CONTENT.equalsIgnoreCase(FileBrowserActivity.this.getIntent().getAction())) {
        if (mFile.isDirectory()) {
          mCurrentPath=mPath;
          mListView.setAdapter(getFileListAdapterSorted(mCurrentPath,mSortType));
        }
 else {
          FileBrowserActivity.this.setResult(Activity.RESULT_OK,new Intent(null,Uri.fromFile(mFile)));
          FileBrowserActivity.this.finish();
        }
      }
 else {
        if (mFile.isDirectory()) {
          mCurrentPath=mPath;
          mListView.setAdapter(getFileListAdapterSorted(mCurrentPath,mSortType));
        }
 else {
          openFile(mFile);
        }
        mItemSelected=mListView.getSelectedItemPosition();
        mItemFirst=mListView.getFirstVisiblePosition();
        mItemLast=mListView.getLastVisiblePosition();
        View mView=mListView.getChildAt(mItemSelected - mItemFirst);
        if (mView != null) {
          mItemTop=mView.getTop();
        }
      }
    }
  }
);
  Button btn_home=(Button)findViewById(R.id.btn_home);
  btn_home.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      if (mCurrentPath.equals(ROOT))       return;
      mCurrentPath=ROOT;
      DeviceScan();
    }
  }
);
  Button btn_back=(Button)findViewById(R.id.btn_back);
  btn_back.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      if (!mCurrentPath.equals(ROOT)) {
        File file=new File(mCurrentPath);
        String parent_path=file.getParent();
        if (isDeviceFile(mCurrentPath)) {
          mCurrentPath=ROOT;
          DeviceScan();
        }
 else {
          mCurrentPath=parent_path;
          mListView.setAdapter(getFileListAdapterSorted(parent_path,mSortType));
        }
      }
    }
  }
);
  Button btn_style=(Button)findViewById(R.id.btn_style);
  btn_style.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      Log.i(TAG,""String_Node_Str"");
    }
  }
);
  Button btn_search=(Button)findViewById(R.id.btn_search);
  boolean isEnableSearch=false;
  if (!isEnableSearch)   btn_search.setVisibility(View.GONE);
  btn_search.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      Log.i(TAG,""String_Node_Str"");
    }
  }
);
  Button btn_about=(Button)findViewById(R.id.btn_about);
  btn_about.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      Log.i(TAG,""String_Node_Str"");
    }
  }
);
}",0.9812423124231242
87292,"@Override public void onPause(){
  super.onPause();
  mLoadCancel=true;
  SharedPreferences settings=getSharedPreferences(""String_Node_Str"",Activity.MODE_PRIVATE);
  SharedPreferences.Editor editor=settings.edit();
  editor.putString(""String_Node_Str"",mCurrentPath);
  editor.commit();
  if (mListLoaded)   mListLoaded=false;
}","@Override public void onPause(){
  super.onPause();
  Log.i(TAG,""String_Node_Str"");
  mLoadCancel=true;
  SharedPreferences settings=getSharedPreferences(""String_Node_Str"",Activity.MODE_PRIVATE);
  SharedPreferences.Editor editor=settings.edit();
  editor.putString(""String_Node_Str"",mCurrentPath);
  editor.commit();
  if (mListLoaded)   mListLoaded=false;
}",0.9533527696793004
87293,"@Override public void onResume(){
  super.onResume();
  mProgressHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
      super.handleMessage(msg);
switch (msg.what) {
case FILEBROWSER_MESSAGE_UPDATE_LIST:
        if (mListLoaded == false) {
          break;
        }
      mListView.setAdapter(getFileListAdapterSorted(mCurrentPath,mSortType));
    mListLoaded=false;
  break;
default :
break;
}
}
}
;
if (mListLoaded == true) {
mListLoaded=false;
}
if (mCurrentPath.equals(ROOT)) {
DeviceScan();
}
 else {
mListView.setAdapter(getFileListAdapterSorted(mCurrentPath,mSortType));
}
mListView.setSelectionFromTop(mItemSelected,mItemTop);
}","@Override public void onResume(){
  super.onResume();
  mLoadCancel=false;
  Log.i(TAG,""String_Node_Str"");
  if (mCurrentPath.equals(ROOT)) {
    mListView.setAdapter(getDeviceListAdapter());
  }
 else {
    mListView.setAdapter(getFileListAdapterSorted(mCurrentPath,mSortType));
  }
  mListView.setSelectionFromTop(mItemSelected,mItemTop);
}",0.4886251236399604
87294,"private List<Map<String,Object>> getFileListDataSorted(String path,int sort_type){
  updatePathShow(path);
  if (!mListLoaded) {
    mListLoaded=true;
    final String ppath=path;
    final int ssort_type=sort_type;
    new Thread(""String_Node_Str""){
      @Override public void run(){
        mList=getFileListDataSortedAsync(ppath,ssort_type);
        if (null != mProgressHandler) {
          mProgressHandler.sendMessage(Message.obtain(mProgressHandler,FILEBROWSER_MESSAGE_UPDATE_LIST));
        }
      }
    }
.start();
    return new ArrayList<Map<String,Object>>();
  }
 else {
    return mList;
  }
}","private List<Map<String,Object>> getFileListDataSorted(String path,int sort_type){
  updatePathShow(path);
  return getFileListDataSortedAsync(path,sort_type);
}",0.4155844155844156
87295,"@Override public void onPrepared(DtPlayer mp){
  Log.i(Constant.LOGTAG,""String_Node_Str"");
  mState=PLAYER_PREPARED;
  dtPlayer.start();
  mState=PLAYER_RUNNING;
  int duration=mp.getDuration();
  if (duration > 0) {
    mTextViewDuration.setText(TimesUtil.getTime(duration));
    mSeekBarProgress.setMax(duration);
  }
  startTimerTask();
}","@Override public void onPrepared(DtPlayer mp){
  Log.i(TAG,""String_Node_Str"");
  mState=PLAYER_PREPARED;
  dtPlayer.start();
  mState=PLAYER_RUNNING;
  int duration=mp.getDuration();
  if (duration > 0) {
    mTextViewDuration.setText(TimesUtil.getTime(duration));
    mSeekBarProgress.setMax(duration);
  }
  startTimerTask();
}",0.982089552238806
87296,"private void handlePausePlay(){
  try {
    if (dtPlayer.isPlaying()) {
      dtPlayer.pause();
      pauseBtn.setBackgroundResource(R.drawable.btn_mu_pause);
    }
 else {
      dtPlayer.start();
      pauseBtn.setBackgroundResource(R.drawable.btn_mu_play);
    }
  }
 catch (  IllegalStateException e) {
  }
catch (  Exception e) {
  }
}","private void handlePausePlay(){
  try {
    if (dtPlayer.isPlaying()) {
      dtPlayer.pause();
      pauseBtn.setBackgroundResource(R.drawable.btn_mu_pause);
    }
 else {
      dtPlayer.pause();
      pauseBtn.setBackgroundResource(R.drawable.btn_mu_play);
    }
  }
 catch (  IllegalStateException e) {
  }
catch (  Exception e) {
  }
}",0.9852507374631267
87297,"@Override public R sync() throws Exception {
  SynchronousListener<R> syncListener=new SynchronousListener<R>();
  this.addListener(syncListener);
  return syncListener.sync();
}","public R sync(boolean canInterrupt) throws Exception {
  SynchronousListener<R> syncListener=new SynchronousListener<R>();
  this.addListener(syncListener);
  return syncListener.sync(canInterrupt);
}",0.8888888888888888
87298,"private void waitUntilFinished() throws InterruptedException {
  while (state == WaitState.UNFINISHED) {
    try {
      peopleWaiting++;
      localMonitor.wait(WAIT_TIMEOUT);
    }
 catch (    InterruptedException ie) {
    }
 finally {
      peopleWaiting--;
    }
  }
}","private void waitUntilFinished(boolean canInterrupt) throws InterruptedException {
  while (state == WaitState.UNFINISHED) {
    try {
      peopleWaiting++;
      localMonitor.wait(WAIT_TIMEOUT);
    }
 catch (    InterruptedException ie) {
      if (canInterrupt)       throw new InterruptedException();
    }
 finally {
      peopleWaiting--;
    }
  }
}",0.8666666666666667
87299,"@Override public ResponseMessage sendAndReceive(Envelope e) throws PEException {
  e.from(getReplyAddress());
  send(e);
  return receive();
}","@Override public ResponseMessage sendAndReceive(Envelope msg) throws PEException {
  SMQEnvelope env=(SMQEnvelope)msg;
  env.from(getReplyAddress());
  send(env);
  try {
    return env.sync(true);
  }
 catch (  InterruptedException ie) {
    markForTermination();
    throw new PEException(""String_Node_Str"",ie);
  }
catch (  PEException e) {
    throw e;
  }
catch (  Exception e) {
    if (e.getCause() instanceof PEException)     throw (PEException)e.getCause();
 else     throw new PEException(e);
  }
}",0.3876923076923076
87300,"@Override public void returnResponse(Envelope requestEnvelope,ResponseMessage resp) throws PEException {
  SMQEnvelope env=(SMQEnvelope)requestEnvelope;
  if (env.getFromAddress() != null) {
    try {
      SMQEnvelope retEnv=new SMQEnvelope(env,resp);
      retEnv.to(env.getFromAddress()).from(getAddress());
      retEnv.setExceptionFrame(env.getExceptionFrame());
      agentMap.get(retEnv.getToAddress()).put(retEnv);
      if (loggerDebug)       try {
        logger.debug(retEnv.display(new StringBuilder(theAgent.getName()).append(""String_Node_Str"")));
      }
 catch (      Throwable t) {
        logger.fatal(""String_Node_Str"" + requestEnvelope + ""String_Node_Str""+ retEnv,t);
      }
    }
 catch (    InterruptedException e1) {
      markForTermination();
      throw new PEException(""String_Node_Str"",e1);
    }
  }
}","@Override public void returnResponse(Envelope requestEnvelope,ResponseMessage resp) throws PEException {
  SMQEnvelope env=(SMQEnvelope)requestEnvelope;
  env.deliverResponse(resp);
}",0.3435340572556762
87301,"public void cmd_merge_corpus(Scanner scanner) throws Throwable {
  final File corpusFile=scanFile(scanner,""String_Node_Str"");
  final MultiMap<Class<?>,File> varargs=scanFilesByTypeOptionalMulti(scanner,Collections.<Class<?>>singleton(DbAnalyzerCorpus.class));
  final Collection<File> mergedCorpusFiles=varargs.values();
  if (mergedCorpusFiles.size() < 2) {
    throw new PEException(""String_Node_Str"");
  }
  final Map<String,HasStatement> nonDmlPopulations=new HashMap<String,HasStatement>();
  final Map<String,HasStatement> dmlPopulations=new HashMap<String,HasStatement>();
  final StringBuilder description=new StringBuilder();
  for (  final File cf : mergedCorpusFiles) {
    final DbAnalyzerCorpus input=PEXmlUtils.unmarshalJAXB(cf,DbAnalyzerCorpus.class);
    countCorpusStatements(input,nonDmlPopulations,dmlPopulations);
    if (description.length() > 0) {
      description.append(""String_Node_Str"");
    }
 else {
      description.append(""String_Node_Str"");
    }
    description.append(input.getDescription());
  }
  final DbAnalyzerCorpus output=new DbAnalyzerCorpus();
  output.getNonDml().addAll((Collection<? extends StatementNonDMLType>)nonDmlPopulations.values());
  output.getPopulation().addAll((Collection<? extends StatementPopulationType>)dmlPopulations.values());
  output.setDescription(description.toString());
  final String corpusString=PEXmlUtils.marshalJAXB(output);
  writeToFileOrScreen(corpusFile,corpusString);
}","public void cmd_merge_corpus(Scanner scanner) throws Throwable {
  final File corpusFile=scanFile(scanner,""String_Node_Str"");
  final MultiMap<Class<?>,File> varargs=scanFilesByTypeOptionalMulti(scanner,Collections.<Class<?>>singleton(DbAnalyzerCorpus.class));
  final Collection<File> mergedCorpusFiles=varargs.values();
  if (mergedCorpusFiles.size() < 2) {
    throw new PEException(""String_Node_Str"");
  }
  final Map<String,StatementNonDMLType> nonDmlPopulations=new HashMap<String,StatementNonDMLType>();
  final Map<String,StatementPopulationType> dmlPopulations=new HashMap<String,StatementPopulationType>();
  final StringBuilder description=new StringBuilder();
  for (  final File cf : mergedCorpusFiles) {
    final DbAnalyzerCorpus input=PEXmlUtils.unmarshalJAXB(cf,DbAnalyzerCorpus.class);
    countCorpusStatements(input,nonDmlPopulations,dmlPopulations);
    if (description.length() > 0) {
      description.append(""String_Node_Str"");
    }
 else {
      description.append(""String_Node_Str"");
    }
    description.append(input.getDescription());
  }
  final DbAnalyzerCorpus output=new DbAnalyzerCorpus();
  output.getNonDml().addAll(nonDmlPopulations.values());
  output.getPopulation().addAll(dmlPopulations.values());
  output.setDescription(description.toString());
  final String corpusString=PEXmlUtils.marshalJAXB(output);
  writeToFileOrScreen(corpusFile,corpusString);
}",0.3887719298245614
87302,"private static <T extends HasStatement>void countFrequencies(final List<T> stmts,final Map<String,HasStatement> container){
  for (  final T entry : stmts) {
    bumpFrequency(entry,container);
  }
}","private static <T extends HasStatement>void countFrequencies(final List<T> stmts,final Map<String,T> container){
  for (  final T entry : stmts) {
    bumpFrequency(entry,container);
  }
}",0.96640826873385
87303,"private static void countCorpusStatements(final DbAnalyzerCorpus corpus,final Map<String,HasStatement> nonDml,final Map<String,HasStatement> dml){
  countFrequencies(corpus.getNonDml(),nonDml);
  countFrequencies(corpus.getPopulation(),dml);
}","private static void countCorpusStatements(final DbAnalyzerCorpus corpus,final Map<String,StatementNonDMLType> nonDmlPopulations,final Map<String,StatementPopulationType> dmlPopulations){
  countFrequencies(corpus.getNonDml(),nonDmlPopulations);
  countFrequencies(corpus.getPopulation(),dmlPopulations);
}",0.7992700729927007
87304,"public boolean sendInsert(WorkerGroup.MappingSolution mappingSolution,MyBinaryResultRow binRow) throws PEException {
  if (alreadyFailed)   return false;
  Collection<RedistTargetSite> allTargetSites=chooseTargetSites(mappingSolution);
  boolean flushedOne=false;
  for (  RedistTargetSite siteCtx : allTargetSites) {
    flushedOne=flushedOne || siteCtx.append(binRow);
    if (!siteCtx.willAcceptMoreRows()) {
      blockedTargetSites.put(siteCtx,siteCtx);
    }
  }
  if (!blockedTargetSites.isEmpty()) {
    pauseSourceStreams();
  }
  return flushedOne;
}","public boolean sendInsert(WorkerGroup.MappingSolution mappingSolution,MyBinaryResultRow binRow) throws PEException {
  if (alreadyFailed || alreadyClosed)   return false;
  Collection<RedistTargetSite> allTargetSites=chooseTargetSites(mappingSolution);
  boolean flushedOne=false;
  for (  RedistTargetSite siteCtx : allTargetSites) {
    flushedOne=flushedOne || siteCtx.append(binRow);
  }
  return flushedOne;
}",0.7720739219712526
87305,"public RedistTargetSet(WorkerGroup targetWG,RedistTargetSite.InsertWatcher watcher,RedistTargetSite.InsertPolicy policy,RedistTargetSite.SourceControl sourceControl) throws PEException {
  this.targetWG=targetWG;
  this.watcher=watcher;
  this.policy=policy;
  this.sourceControl=sourceControl;
  Collection<Worker> targetWorkers=targetWG.getTargetWorkers(WorkerGroup.MappingSolution.AllWorkers);
  for (  Worker targetWorker : targetWorkers) {
    CommandChannel directChannel=targetWorker.getDirectChannel();
    StorageSite site=directChannel.getStorageSite();
    RedistTargetSite siteCtx=new RedistTargetSite(this,directChannel,this);
    siteCtxBySite.put(site,siteCtx);
  }
}","public RedistTargetSet(WorkerGroup targetWG,RedistTargetSite.InsertWatcher watcher,RedistTargetSite.InsertPolicy policy,FlowControl sourceControl) throws PEException {
  this.targetWG=targetWG;
  this.watcher=watcher;
  this.policy=policy;
  siteFlowControl.setUpstreamControl(sourceControl);
  Collection<Worker> targetWorkers=targetWG.getTargetWorkers(WorkerGroup.MappingSolution.AllWorkers);
  for (  Worker targetWorker : targetWorkers) {
    CommandChannel directChannel=targetWorker.getDirectChannel();
    StorageSite site=directChannel.getStorageSite();
    RedistTargetSite siteCtx=new RedistTargetSite(this,directChannel,this);
    siteFlowControl.register(siteCtx);
    siteCtxBySite.put(site,siteCtx);
  }
}",0.913633119200571
87306,"public void close(){
  for (  RedistTargetSite siteCtx : siteCtxBySite.values()) {
    siteCtx.close();
  }
}","public void close(){
  for (  RedistTargetSite siteCtx : siteCtxBySite.values()) {
    siteCtx.close();
    siteFlowControl.unregister(siteCtx);
  }
  alreadyClosed=true;
}",0.7758007117437722
87307,"@Override public void insertOK(RedistTargetSite siteCtx,MyOKResponse okPacket){
  if (alreadyFailed)   return;
  long affectedRows=okPacket.getAffectedRows();
  try {
    int rowCount=(int)affectedRows;
    insertedRows+=rowCount;
  }
  finally {
    checkIfSitesAreUnblocked();
    watcher.insertOK(siteCtx,okPacket);
  }
}","@Override public void insertOK(RedistTargetSite siteCtx,MyOKResponse okPacket){
  if (alreadyFailed || alreadyClosed)   return;
  long affectedRows=okPacket.getAffectedRows();
  try {
    int rowCount=(int)affectedRows;
    insertedRows+=rowCount;
  }
  finally {
    watcher.insertOK(siteCtx,okPacket);
  }
}",0.9225908372827804
87308,"public void flush(){
  final BufferedExecute buffersToFlush=this.bufferedExecute;
  if (!buffersToFlush.isEmpty()) {
    final int rowsToFlush=this.totalQueuedRows;
    this.pendingFlush=this.bufferedExecute;
    this.bufferedExecute=new BufferedExecute();
    this.totalQueuedRows=0;
    this.totalQueuedBytes=0;
    if (rowsToFlush > 0) {
      this.pendingStatementCount.incrementAndGet();
      int bufferedRowCount=buffersToFlush.size();
      final int flushTupleCount=Math.min(bufferedRowCount,maximumRowsToBuffer);
      if (flushTupleCount != bufferedRowCount) {
        throw new PECodingException(String.format(""String_Node_Str"",bufferedRowCount,flushTupleCount));
      }
      if (this.pstmtId >= 0 && flushTupleCount != this.pstmtTupleCount) {
        this.closeActivePreparedStatement();
      }
      if (RedistTargetSite.this.pstmtId < 0) {
        SQLCommand insertCommand=null;
        try {
          insertCommand=policy.buildInsertStatement(flushTupleCount);
        }
 catch (        PEException e) {
          throw new RuntimeException(e);
        }
        MysqlPrepareStatementCollector prepareCollector1=new MysqlPrepareStatementCollector(){
          long stmtID;
          int paramCount;
          int columnCount;
          @Override void consumeHeader(          MyPrepareOKResponse prepareOK){
            this.stmtID=prepareOK.getStmtId();
            this.paramCount=prepareOK.getNumParams();
            this.columnCount=prepareOK.getNumColumns();
            super.consumeHeader(prepareOK);
            if (this.paramCount == 0 && this.columnCount == 0) {
              prepareFinished(stmtID,flushTupleCount);
              executePendingInsert();
            }
          }
          @Override void consumeParamDefEOF(          MyEOFPktResponse myEof){
            super.consumeParamDefEOF(myEof);
            if (this.columnCount == 0) {
              prepareFinished(stmtID,flushTupleCount);
              executePendingInsert();
            }
          }
          @Override void consumeColDefEOF(          MyEOFPktResponse colEof){
            super.consumeColDefEOF(colEof);
            prepareFinished(stmtID,flushTupleCount);
            executePendingInsert();
          }
          @Override void consumeError(          MyErrorResponse error) throws PESQLStateException {
            prepareFailed(error);
          }
        }
;
        MysqlMessage message=MSPComPrepareStmtRequestMessage.newMessage(insertCommand.getSQL(),this.channel.lookupCurrentConnectionCharset());
        MysqlStmtPrepareCommand prepareCmd=new MysqlStmtPrepareCommand(this.channel,insertCommand.getSQL(),prepareCollector1,new PEDefaultPromise<Boolean>());
        this.waitingForPrepare=true;
        this.channel.writeAndFlush(message,prepareCmd);
      }
 else {
        executePendingInsert();
      }
    }
 else {
      this.queuedRowSetCount.addAndGet(-1 * buffersToFlush.size());
    }
  }
}","public void flush(){
  final BufferedExecute buffersToFlush=this.bufferedExecute;
  if (!buffersToFlush.isEmpty()) {
    final int rowsToFlush=this.totalQueuedRows;
    this.pendingFlush=this.bufferedExecute;
    this.bufferedExecute=new BufferedExecute();
    this.totalQueuedRows=0;
    this.totalQueuedBytes=0;
    if (rowsToFlush > 0) {
      this.pendingStatementCount.incrementAndGet();
      int bufferedRowCount=buffersToFlush.size();
      final int flushTupleCount=Math.min(bufferedRowCount,maximumRowsToBuffer);
      if (flushTupleCount != bufferedRowCount) {
        throw new PECodingException(String.format(""String_Node_Str"",bufferedRowCount,flushTupleCount));
      }
      if (this.pstmtId >= 0 && flushTupleCount != this.pstmtTupleCount) {
        this.closeActivePreparedStatement();
      }
      if (RedistTargetSite.this.pstmtId < 0) {
        SQLCommand insertCommand=null;
        try {
          insertCommand=policy.buildInsertStatement(flushTupleCount);
        }
 catch (        PEException e) {
          throw new RuntimeException(e);
        }
        MysqlPrepareStatementCollector prepareCollector1=new MysqlPrepareStatementCollector(){
          long stmtID;
          int paramCount;
          int columnCount;
          @Override void consumeHeader(          MyPrepareOKResponse prepareOK){
            this.stmtID=prepareOK.getStmtId();
            this.paramCount=prepareOK.getNumParams();
            this.columnCount=prepareOK.getNumColumns();
            super.consumeHeader(prepareOK);
            if (this.paramCount == 0 && this.columnCount == 0) {
              prepareFinished(stmtID,flushTupleCount);
              executePendingInsert();
            }
          }
          @Override void consumeParamDefEOF(          MyEOFPktResponse myEof){
            super.consumeParamDefEOF(myEof);
            if (this.columnCount == 0) {
              prepareFinished(stmtID,flushTupleCount);
              executePendingInsert();
            }
          }
          @Override void consumeColDefEOF(          MyEOFPktResponse colEof){
            super.consumeColDefEOF(colEof);
            prepareFinished(stmtID,flushTupleCount);
            executePendingInsert();
          }
          @Override void consumeError(          MyErrorResponse error) throws PESQLStateException {
            prepareFailed(error);
          }
        }
;
        MysqlMessage message=MSPComPrepareStmtRequestMessage.newMessage(insertCommand.getSQL(),this.channel.lookupCurrentConnectionCharset());
        MysqlStmtPrepareCommand prepareCmd=new MysqlStmtPrepareCommand(this.channel,insertCommand.getSQL(),prepareCollector1,new PEDefaultPromise<Boolean>());
        shouldPauseInput();
        this.channel.writeAndFlush(message,prepareCmd);
      }
 else {
        executePendingInsert();
      }
    }
 else {
      this.queuedRowSetCount.addAndGet(-1 * buffersToFlush.size());
    }
  }
}",0.9926281501800104
87309,"protected void prepareFinished(long stmtID,int tupleCount){
  this.waitingForPrepare=false;
  this.pstmtId=(int)stmtID;
  this.pstmtTupleCount=tupleCount;
}","protected void prepareFinished(long stmtID,int tupleCount){
  this.pstmtId=(int)stmtID;
  this.pstmtTupleCount=tupleCount;
  shouldResumeInput();
}",0.8184818481848185
87310,"protected void prepareFailed(MyErrorResponse error){
  this.waitingForPrepare=false;
  watcher.insertFailed(this,error);
}","protected void prepareFailed(MyErrorResponse error){
  watcher.insertFailed(this,error);
  shouldResumeInput();
}",0.7659574468085106
87311,"private void executePendingInsert(){
  BufferedExecute buffersToFlush=pendingFlush;
  int currentStatementID=this.pstmtId;
  buffersToFlush.setStmtID(currentStatementID);
  buffersToFlush.setNeedsNewParams(true);
  buffersToFlush.setColumnsPerTuple(columnsPerTuple);
  int rowsWritten=buffersToFlush.size();
  this.channel.writeAndFlush(buffersToFlush,constructInsertHandler());
  this.pendingFlush=null;
  this.queuedRowSetCount.getAndAdd(-rowsWritten);
}","private void executePendingInsert(){
  BufferedExecute buffersToFlush=pendingFlush;
  int currentStatementID=this.pstmtId;
  buffersToFlush.setStmtID(currentStatementID);
  buffersToFlush.setNeedsNewParams(true);
  buffersToFlush.setColumnsPerTuple(columnsPerTuple);
  int rowsWritten=buffersToFlush.size();
  this.channel.writeAndFlush(buffersToFlush,constructInsertHandler());
  this.pendingFlush=null;
  this.queuedRowSetCount.getAndAdd(-rowsWritten);
  shouldResumeInput();
}",0.9754010695187164
87312,"private MysqlCommandResultsProcessor constructInsertHandler(){
  return new MysqlCommandResultsProcessor(){
    @Override public void active(    ChannelHandlerContext ctx){
    }
    @Override public boolean processPacket(    ChannelHandlerContext ctx,    MyMessage message) throws PEException {
      if (message instanceof MyOKResponse) {
        RedistTargetSite.this.pendingStatementCount.decrementAndGet();
        watcher.insertOK(RedistTargetSite.this,(MyOKResponse)message);
      }
 else       if (message instanceof MyErrorResponse) {
        RedistTargetSite.this.pendingStatementCount.decrementAndGet();
        watcher.insertFailed(RedistTargetSite.this,(MyErrorResponse)message);
      }
 else {
        Exception weirdPacket=new PEException(""String_Node_Str"" + (message == null ? ""String_Node_Str"" : message.getClass().getSimpleName()));
        watcher.insertFailed(RedistTargetSite.this,weirdPacket);
      }
      return false;
    }
    @Override public void packetStall(    ChannelHandlerContext ctx) throws PEException {
    }
    @Override public void failure(    Exception e){
      watcher.insertFailed(RedistTargetSite.this,e);
    }
    @Override public void end(    ChannelHandlerContext ctx){
    }
  }
;
}","private MysqlCommandResultsProcessor constructInsertHandler(){
  return new MysqlCommandResultsProcessor(){
    @Override public void active(    ChannelHandlerContext ctx){
    }
    @Override public boolean processPacket(    ChannelHandlerContext ctx,    MyMessage message) throws PEException {
      if (message instanceof MyOKResponse) {
        RedistTargetSite.this.pendingStatementCount.decrementAndGet();
        watcher.insertOK(RedistTargetSite.this,(MyOKResponse)message);
      }
 else       if (message instanceof MyErrorResponse) {
        RedistTargetSite.this.pendingStatementCount.decrementAndGet();
        watcher.insertFailed(RedistTargetSite.this,(MyErrorResponse)message);
      }
 else {
        Exception weirdPacket=new PEException(""String_Node_Str"" + (message == null ? ""String_Node_Str"" : message.getClass().getSimpleName()));
        watcher.insertFailed(RedistTargetSite.this,weirdPacket);
      }
      return false;
    }
    @Override public void packetStall(    ChannelHandlerContext ctx) throws PEException {
    }
    @Override public void failure(    Exception e){
      shouldResumeInput();
      watcher.insertFailed(RedistTargetSite.this,e);
    }
    @Override public void end(    ChannelHandlerContext ctx){
    }
  }
;
}",0.9891783567134268
87313,"@Override public void failure(Exception e){
  watcher.insertFailed(RedistTargetSite.this,e);
}","@Override public void failure(Exception e){
  shouldResumeInput();
  watcher.insertFailed(RedistTargetSite.this,e);
}",0.8909952606635071
87314,"@Override public void pauseSourceStreams(){
  sourcePaused=true;
  for (  ChannelHandlerContext ctx : sourceSites.keySet()) {
    StreamValve.pipelinePause(ctx.pipeline());
  }
}","@Override public void pauseSourceStreams(){
  if (!(lastPacketSent || failedRedist))   upstreamSet.pauseSourceStreams();
}",0.4733333333333333
87315,"@Override public void resumeSourceStreams(){
  if (sourcePaused) {
    sourcePaused=false;
    for (    ChannelHandlerContext ctx : sourceSites.keySet()) {
      StreamValve.pipelineResume(ctx.pipeline());
    }
  }
}","@Override public void resumeSourceStreams(){
  upstreamSet.resumeSourceStreams();
}",0.4466666666666666
87316,"public void sourceActive(ChannelHandlerContext ctx){
  if (sourceSites.get(ctx) == null) {
    sourceSites.put(ctx,ctx);
    if (sourcePaused) {
      StreamValve.pipelinePause(ctx.pipeline());
    }
  }
}","public void sourceActive(ChannelHandlerContext ctx){
  upstreamSet.register(ctx);
}",0.4652777777777778
87317,"public void emitTableInstance(SchemaContext sc,TableInstance tr,StringBuilder buf,TableInstanceContext context){
  Table<?> tab=tr.getTable();
  if (tab == null) {
    buf.append(tr.getSpecifiedAs(sc).getSQL());
  }
 else   if (tab instanceof PEAbstractTable) {
    PEAbstractTable<?> pet=(PEAbstractTable<?>)tab;
    Database<?> curDb=sc.getCurrentDatabase(false);
    Database<?> tblDb=pet.getDatabase(sc);
    if (context != TableInstanceContext.COLUMN) {
      if ((curDb == null && tblDb != null) || ((curDb != null && tblDb != null) && (curDb.getId() != tblDb.getId()))) {
        if (getOptions() == null || !getOptions().isCatalog()) {
          int offset=buf.length();
          String toAdd=pet.getDatabase(sc).getName().getUnqualified().getSQL();
          buf.append(toAdd).append(""String_Node_Str"");
          builder.withDBName(offset,toAdd);
        }
 else {
          buf.append(pet.getDatabase(sc).getName().getUnqualified().getSQL()).append(""String_Node_Str"");
        }
      }
    }
    boolean prohibitAlias=false;
    if (pet.isTempTable()) {
      int offset=buf.length();
      String toAdd=pet.getName(sc).getSQL();
      buf.append(toAdd);
      builder.withTempTable(offset,toAdd,(TempTable)pet);
      prohibitAlias=true;
    }
 else {
      if ((context == TableInstanceContext.COLUMN || context == TableInstanceContext.NAKED) && tr.getAlias() != null) {
        buf.append(tr.getAlias().getSQL());
      }
 else {
        if (pet.getPEDatabase(sc).getMTMode() == MultitenantMode.ADAPTIVE) {
          buf.append(tr.getTable().getName(sc).getSQL());
        }
 else {
          buf.append(tr.getSpecifiedAs(sc).getQuotedName().getSQL());
        }
      }
    }
    if (context == TableInstanceContext.COLUMN || prohibitAlias || context == TableInstanceContext.NAKED) {
    }
 else     if (tr.getAlias() != null) {
      buf.append(""String_Node_Str"").append(tr.getAlias().getSQL());
    }
  }
 else   if (tab instanceof InformationSchemaTable) {
    if (context == TableInstanceContext.COLUMN && tr.getAlias() != null) {
      buf.append(tr.getAlias().getSQL());
    }
 else {
      buf.append(tr.getTable().getName().getSQL());
    }
    if (context == TableInstanceContext.TABLE_FACTOR && tr.getAlias() != null)     buf.append(""String_Node_Str"").append(tr.getAlias().getSQL());
  }
 else {
    if (context == TableInstanceContext.COLUMN && tr.getAlias() != null) {
      buf.append(tr.getAlias().getSQL());
    }
 else {
      buf.append(tr.getTable().getName().getSQL());
    }
    if (context == TableInstanceContext.TABLE_FACTOR && tr.getAlias() != null)     buf.append(""String_Node_Str"").append(tr.getAlias().getSQL());
  }
}","public void emitTableInstance(SchemaContext sc,TableInstance tr,StringBuilder buf,TableInstanceContext context){
  Table<?> tab=tr.getTable();
  if (tab == null) {
    buf.append(tr.getSpecifiedAs(sc).getSQL());
  }
 else   if (tab instanceof PEAbstractTable) {
    PEAbstractTable<?> pet=(PEAbstractTable<?>)tab;
    Database<?> curDb=sc.getCurrentDatabase(false);
    Database<?> tblDb=pet.getDatabase(sc);
    if (context == TableInstanceContext.TABLE_FACTOR) {
      if ((curDb == null && tblDb != null) || ((curDb != null && tblDb != null) && (curDb.getId() != tblDb.getId()))) {
        if (getOptions() == null || !getOptions().isCatalog()) {
          int offset=buf.length();
          String toAdd=pet.getDatabase(sc).getName().getUnqualified().getSQL();
          buf.append(toAdd).append(""String_Node_Str"");
          builder.withDBName(offset,toAdd);
        }
 else {
          buf.append(pet.getDatabase(sc).getName().getUnqualified().getSQL()).append(""String_Node_Str"");
        }
      }
    }
    boolean prohibitAlias=false;
    if (pet.isTempTable()) {
      int offset=buf.length();
      String toAdd=pet.getName(sc).getSQL();
      buf.append(toAdd);
      builder.withTempTable(offset,toAdd,(TempTable)pet);
      prohibitAlias=true;
    }
 else {
      if ((context == TableInstanceContext.COLUMN || context == TableInstanceContext.NAKED) && tr.getAlias() != null) {
        buf.append(tr.getAlias().getSQL());
      }
 else {
        if (pet.getPEDatabase(sc).getMTMode() == MultitenantMode.ADAPTIVE) {
          buf.append(tr.getTable().getName(sc).getSQL());
        }
 else {
          buf.append(tr.getSpecifiedAs(sc).getQuotedName().getSQL());
        }
      }
    }
    if (context == TableInstanceContext.COLUMN || prohibitAlias || context == TableInstanceContext.NAKED) {
    }
 else     if (tr.getAlias() != null) {
      buf.append(""String_Node_Str"").append(tr.getAlias().getSQL());
    }
  }
 else   if (tab instanceof InformationSchemaTable) {
    if (context == TableInstanceContext.COLUMN && tr.getAlias() != null) {
      buf.append(tr.getAlias().getSQL());
    }
 else {
      buf.append(tr.getTable().getName().getSQL());
    }
    if (context == TableInstanceContext.TABLE_FACTOR && tr.getAlias() != null)     buf.append(""String_Node_Str"").append(tr.getAlias().getSQL());
  }
 else {
    if (context == TableInstanceContext.COLUMN && tr.getAlias() != null) {
      buf.append(tr.getAlias().getSQL());
    }
 else {
      buf.append(tr.getTable().getName().getSQL());
    }
    if (context == TableInstanceContext.TABLE_FACTOR && tr.getAlias() != null)     buf.append(""String_Node_Str"").append(tr.getAlias().getSQL());
  }
}",0.4551594746716698
87318,"private void handleSetVariableExpression(SchemaContext pc,SetVariableExpression sve,VariableManager vm,ExecutionSequence es) throws PEException {
  VariableInstance vi=sve.getVariable();
  List<ExpressionNode> value=sve.getValue();
  ExpressionNode rhs=value.get(0);
  VariableValueSource nva=getRHSSource(pc,rhs);
  if (nva != null) {
    final String variableName=vi.getVariableName().get();
    if (nva.isConstant()) {
      final VariableHandler<?> vh=vm.lookup(variableName);
      if ((vh != null) && vh.getMetadata().isNumeric() && PEStringUtils.isQuoted(String.valueOf(sve.getVariableExpr()))) {
        throw new PESQLStateException(1232,""String_Node_Str"",""String_Node_Str"" + variableName + ""String_Node_Str"");
      }
    }
    es.append(new SetVariableExecutionStep(vi.getScope(),variableName,nva,pc.getPersistentGroup()));
  }
 else {
    handleComplexSetVariableExpression(pc,vi,rhs,es);
  }
}","private void handleSetVariableExpression(SchemaContext pc,SetVariableExpression sve,VariableManager vm,ExecutionSequence es) throws PEException {
  VariableInstance vi=sve.getVariable();
  List<ExpressionNode> value=sve.getValue();
  ExpressionNode rhs=value.get(0);
  VariableValueSource nva=getRHSSource(pc,rhs);
  if (nva != null) {
    final String variableName=vi.getVariableName().get();
    if (nva.isConstant()) {
      final VariableHandler<?> vh=vm.lookup(variableName);
      if ((vh != null) && vh.getMetadata().isNumeric() && PEStringUtils.isQuoted(String.valueOf(sve.getVariableExpr()))) {
        throw new SchemaException(new ErrorInfo(DVEErrors.WRONG_TYPE_FOR_VARIABLE,variableName));
      }
    }
    es.append(new SetVariableExecutionStep(vi.getScope(),variableName,nva,pc.getPersistentGroup()));
  }
 else {
    handleComplexSetVariableExpression(pc,vi,rhs,es);
  }
}",0.7101449275362319
87319,"@Override public Boolean convertToInternal(String varName,String in) throws PEException {
  String lc=in.trim().toLowerCase();
  if (trueMap.contains(lc))   return true;
  if (falseMap.contains(lc))   return false;
  throw new PEException(String.format(""String_Node_Str"",in,varName));
}","@Override public Boolean convertToInternal(String varName,String in) throws PEException {
  String lc=in.trim().toLowerCase();
  if (trueMap.contains(lc))   return true;
  if (falseMap.contains(lc))   return false;
  throw new SchemaException(new ErrorInfo(DVEErrors.WRONG_VALUE_FOR_VARIABLE,varName,lc));
}",0.8499156829679595
87320,"@Override public E convertToInternal(String varName,String in) throws PEException {
  String deq=PEStringUtils.dequote(in);
  E any=universe.get(deq);
  if (any == null)   throw new PEException(""String_Node_Str"" + varName + ""String_Node_Str""+ StringUtils.join(universe.keySet(),""String_Node_Str"")+ ""String_Node_Str"");
  return any;
}","@Override public E convertToInternal(String varName,String in) throws PEException {
  String deq=PEStringUtils.dequote(in);
  E any=universe.get(deq);
  if (any == null) {
    throw new SchemaException(new ErrorInfo(DVEErrors.WRONG_VALUE_FOR_VARIABLE,varName,deq));
  }
  return any;
}",0.6504854368932039
87321,"@Override public Double convertToInternal(String varName,String in) throws PEException {
  try {
    return Double.valueOf(in);
  }
 catch (  NumberFormatException nfe) {
    throw new PEException(""String_Node_Str"" + ""String_Node_Str"");
  }
}","@Override public Double convertToInternal(String varName,String in) throws PEException {
  try {
    return Double.valueOf(in);
  }
 catch (  final NumberFormatException nfe) {
    throw new SchemaException(new ErrorInfo(DVEErrors.WRONG_TYPE_FOR_VARIABLE,varName));
  }
}",0.7680311890838206
87322,"@Override public Long convertToInternal(String varName,String in) throws PEException {
  if (in == null)   return null;
  try {
    return Long.parseLong(in);
  }
 catch (  NumberFormatException nfe) {
    throw new PEException(""String_Node_Str"" + in + ""String_Node_Str"");
  }
}","@Override public Long convertToInternal(String varName,String in) throws PEException {
  if (in == null)   return null;
  try {
    return Long.parseLong(in);
  }
 catch (  final NumberFormatException nfe) {
    throw new SchemaException(new ErrorInfo(DVEErrors.WRONG_TYPE_FOR_VARIABLE,varName));
  }
}",0.7862068965517242
87323,"public Type toInternal(String in) throws PEException {
  if (in == null || NULL_VALUE.equals(in)) {
    if (options.contains(VariableOption.NULLABLE))     return null;
    throw new PEException(String.format(""String_Node_Str"",getName()));
  }
  return getMetadata().convertToInternal(getName(),in);
}","public Type toInternal(String in) throws PEException {
  if (in == null || NULL_VALUE.equals(in)) {
    if (options.contains(VariableOption.NULLABLE))     return null;
    throw new SchemaException(new ErrorInfo(DVEErrors.WRONG_VALUE_FOR_VARIABLE,this.getName(),""String_Node_Str""));
  }
  return getMetadata().convertToInternal(getName(),in);
}",0.6739130434782609
87324,"@Test public void testTemplateModes() throws Throwable {
  try {
    conn.execute(SchemaTest.buildAlterTemplateModeStmt(TemplateMode.OPTIONAL));
    conn.execute(SchemaTest.buildAlterTemplateModeStmt(TemplateMode.REQUIRED));
    conn.execute(SchemaTest.buildAlterTemplateModeStmt(TemplateMode.STRICT));
    new ExpectedExceptionTester(){
      @Override public void test() throws Throwable {
        conn.execute(""String_Node_Str"" + VariableConstants.TEMPLATE_MODE_NAME + ""String_Node_Str"");
      }
    }
.assertException(PEException.class,""String_Node_Str"");
  }
  finally {
    conn.execute(SchemaTest.buildAlterTemplateModeStmt(TemplateMode.REQUIRED));
  }
}","@Test public void testTemplateModes() throws Throwable {
  try {
    conn.execute(SchemaTest.buildAlterTemplateModeStmt(TemplateMode.OPTIONAL));
    conn.execute(SchemaTest.buildAlterTemplateModeStmt(TemplateMode.REQUIRED));
    conn.execute(SchemaTest.buildAlterTemplateModeStmt(TemplateMode.STRICT));
    new ExpectedSqlErrorTester(){
      @Override public void test() throws Throwable {
        conn.execute(""String_Node_Str"" + VariableConstants.TEMPLATE_MODE_NAME + ""String_Node_Str"");
      }
    }
.assertError(SchemaException.class,MySQLErrors.wrongValueForVariable,VariableConstants.TEMPLATE_MODE_NAME,""String_Node_Str"");
  }
  finally {
    conn.execute(SchemaTest.buildAlterTemplateModeStmt(TemplateMode.REQUIRED));
  }
}",0.9124820659971306
87325,"@Test public void testPE1603() throws Throwable {
  assertTimestampValue(2,null);
  conn.execute(""String_Node_Str"");
  assertTimestampValue(2,10l);
  conn.execute(""String_Node_Str"");
  assertTimestampValue(2,null);
  conn.execute(""String_Node_Str"");
  assertTimestampValue(2,300000000l);
  conn.execute(""String_Node_Str"");
  assertTimestampValue(2,null);
  new ExpectedExceptionTester(){
    @Override public void test() throws Throwable {
      conn.execute(""String_Node_Str"");
    }
  }
.assertException(PESQLStateException.class,""String_Node_Str"");
  new ExpectedExceptionTester(){
    @Override public void test() throws Throwable {
      conn.execute(""String_Node_Str"");
    }
  }
.assertException(PESQLStateException.class,""String_Node_Str"");
}","@Test public void testPE1603() throws Throwable {
  assertTimestampValue(2,null);
  conn.execute(""String_Node_Str"");
  assertTimestampValue(2,10l);
  conn.execute(""String_Node_Str"");
  assertTimestampValue(2,null);
  conn.execute(""String_Node_Str"");
  assertTimestampValue(2,300000000l);
  conn.execute(""String_Node_Str"");
  assertTimestampValue(2,null);
  new ExpectedSqlErrorTester(){
    @Override public void test() throws Throwable {
      conn.execute(""String_Node_Str"");
    }
  }
.assertError(SchemaException.class,MySQLErrors.wrongTypeForVariable,""String_Node_Str"");
  new ExpectedSqlErrorTester(){
    @Override public void test() throws Throwable {
      conn.execute(""String_Node_Str"");
    }
  }
.assertError(SchemaException.class,MySQLErrors.wrongTypeForVariable,""String_Node_Str"");
}",0.8656330749354005
87326,"@Test public void testStorageEngines() throws Throwable {
  testCreateWithStorageEngine(""String_Node_Str"");
  testCreateWithStorageEngine(""String_Node_Str"");
  testCreateWithStorageEngine(""String_Node_Str"");
  testCreateWithStorageEngine(""String_Node_Str"");
  testCreateWithStorageEngine(""String_Node_Str"");
  new ExpectedExceptionTester(){
    @Override public void test() throws Throwable {
      testCreateWithStorageEngine(""String_Node_Str"");
    }
  }
.assertException(PEException.class,""String_Node_Str"");
  new ExpectedExceptionTester(){
    @Override public void test() throws Throwable {
      testCreateWithStorageEngine(""String_Node_Str"");
    }
  }
.assertException(PEException.class,""String_Node_Str"");
}","@Test public void testStorageEngines() throws Throwable {
  testCreateWithStorageEngine(""String_Node_Str"");
  testCreateWithStorageEngine(""String_Node_Str"");
  testCreateWithStorageEngine(""String_Node_Str"");
  testCreateWithStorageEngine(""String_Node_Str"");
  testCreateWithStorageEngine(""String_Node_Str"");
  new ExpectedSqlErrorTester(){
    @Override public void test() throws Throwable {
      testCreateWithStorageEngine(""String_Node_Str"");
    }
  }
.assertError(SchemaException.class,MySQLErrors.wrongValueForVariable,""String_Node_Str"",""String_Node_Str"");
  new ExpectedSqlErrorTester(){
    @Override public void test() throws Throwable {
      testCreateWithStorageEngine(""String_Node_Str"");
    }
  }
.assertError(SchemaException.class,MySQLErrors.wrongValueForVariable,""String_Node_Str"",""String_Node_Str"");
}",0.87890625
87327,"/** 
 * PE-1128 
 */
@Test public void setAutocommit() throws Throwable {
  assertEquals(Boolean.TRUE,KnownVariables.AUTOCOMMIT.getSessionValue(ssConnection));
  KnownVariables.AUTOCOMMIT.setSessionValue(ssConnection,""String_Node_Str"");
  assertEquals(Boolean.FALSE,KnownVariables.AUTOCOMMIT.getSessionValue(ssConnection));
  KnownVariables.AUTOCOMMIT.setSessionValue(ssConnection,""String_Node_Str"");
  assertEquals(Boolean.TRUE,KnownVariables.AUTOCOMMIT.getSessionValue(ssConnection));
  KnownVariables.AUTOCOMMIT.setSessionValue(ssConnection,""String_Node_Str"");
  assertEquals(Boolean.FALSE,KnownVariables.AUTOCOMMIT.getSessionValue(ssConnection));
  new ExpectedExceptionTester(){
    @Override public void test() throws Throwable {
      KnownVariables.AUTOCOMMIT.setSessionValue(ssConnection,null);
    }
  }
.assertException(PEException.class,""String_Node_Str"");
  new ExpectedExceptionTester(){
    @Override public void test() throws Throwable {
      KnownVariables.AUTOCOMMIT.setSessionValue(ssConnection,""String_Node_Str"");
    }
  }
.assertException(PEException.class,""String_Node_Str"");
  new ExpectedExceptionTester(){
    @Override public void test() throws Throwable {
      KnownVariables.AUTOCOMMIT.setSessionValue(ssConnection,""String_Node_Str"");
    }
  }
.assertException(PEException.class,""String_Node_Str"");
}","/** 
 * PE-1128 
 */
@Test public void setAutocommit() throws Throwable {
  assertEquals(Boolean.TRUE,KnownVariables.AUTOCOMMIT.getSessionValue(ssConnection));
  KnownVariables.AUTOCOMMIT.setSessionValue(ssConnection,""String_Node_Str"");
  assertEquals(Boolean.FALSE,KnownVariables.AUTOCOMMIT.getSessionValue(ssConnection));
  KnownVariables.AUTOCOMMIT.setSessionValue(ssConnection,""String_Node_Str"");
  assertEquals(Boolean.TRUE,KnownVariables.AUTOCOMMIT.getSessionValue(ssConnection));
  KnownVariables.AUTOCOMMIT.setSessionValue(ssConnection,""String_Node_Str"");
  assertEquals(Boolean.FALSE,KnownVariables.AUTOCOMMIT.getSessionValue(ssConnection));
  new ExpectedSqlErrorTester(){
    @Override public void test() throws Throwable {
      KnownVariables.AUTOCOMMIT.setSessionValue(ssConnection,null);
    }
  }
.assertError(SchemaException.class,MySQLErrors.wrongValueForVariable,""String_Node_Str"",""String_Node_Str"");
  new ExpectedSqlErrorTester(){
    @Override public void test() throws Throwable {
      KnownVariables.AUTOCOMMIT.setSessionValue(ssConnection,""String_Node_Str"");
    }
  }
.assertError(SchemaException.class,MySQLErrors.wrongValueForVariable,""String_Node_Str"",""String_Node_Str"");
  new ExpectedSqlErrorTester(){
    @Override public void test() throws Throwable {
      KnownVariables.AUTOCOMMIT.setSessionValue(ssConnection,""String_Node_Str"");
    }
  }
.assertError(SchemaException.class,MySQLErrors.wrongValueForVariable,""String_Node_Str"",""String_Node_Str"");
}",0.8881789137380192
87328,"public void startTableCleanup(){
  if (tableCleanupInterval > 0) {
    tgc=new TableGarbageCollector(tableCleanupInterval);
    tgc.start();
  }
}","public void startTableCleanup(){
  if (tableCleanupInterval > 0) {
    if (tgc != null)     tgc.stopTableCleanup();
    tgc=new TableGarbageCollector(tableCleanupInterval);
    tgc.startTableCleanup();
  }
}",0.5155807365439093
87329,"private void stopTableCleanup(){
  if (tgc != null) {
    tgc.interrupt();
    try {
      tgc.join();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}","private void stopTableCleanup(){
  if (tgc != null)   tgc.stopTableCleanup();
}",0.5
87330,"public TableGarbageCollector(int cleanupInterval){
  super(""String_Node_Str"");
  setDaemon(true);
  persistentConnection=null;
  request=new AtomicInteger(1);
  interval=new AtomicInteger(cleanupInterval);
}","public TableGarbageCollector(int cleanupInterval){
  persistentConnection=null;
  request=new AtomicInteger(1);
  interval=new AtomicInteger(cleanupInterval);
}",0.8719346049046321
87331,"@Override public void run(){
  logger.info(""String_Node_Str"" + interval.get());
  boolean running=true;
  while (running) {
    try {
      sleep(interval.get());
      doCleanup();
      if (Thread.currentThread().isInterrupted())       running=false;
    }
 catch (    InterruptedException e) {
      running=false;
    }
catch (    Throwable t) {
      logger.error(""String_Node_Str"",t);
    }
    if (!running)     logger.info(""String_Node_Str"");
  }
  try {
    closeConnection();
  }
 catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
  }
}","@Override public void run(){
  logger.info(""String_Node_Str"" + interval.get());
  while (isActiveThread(Thread.currentThread())) {
    try {
      Thread.sleep(interval.get());
      doCleanup();
    }
 catch (    InterruptedException e) {
    }
catch (    Error td) {
      logger.error(""String_Node_Str"",td);
      throw td;
    }
catch (    Throwable t) {
      logger.error(""String_Node_Str"",t);
    }
  }
  logger.info(""String_Node_Str"");
  try {
    closeConnection();
  }
 catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
  }
}",0.4336043360433604
87332,"@Override public void unmarshallMessage(ByteBuf cb){
  binaryLogVersion=cb.readShort();
  serverVersion=MysqlAPIUtils.readBytesAsString(cb,ST_SERVER_VER_LEN,CharsetUtil.UTF_8);
  createTime=cb.readUnsignedInt();
  int eventTypeLength=cb.readableBytes();
switch (MyBinLogVerType.fromByte((byte)binaryLogVersion)) {
case MySQL_5_0:
    for (int i=1; i <= eventTypeLength; i++) {
      eventTypeValues.put(MyLogEventType.fromByte((byte)i),cb.readByte());
    }
  break;
default :
logger.error(""String_Node_Str"");
}
}","@Override public void unmarshallMessage(ByteBuf cb){
  binaryLogVersion=cb.readShort();
  serverVersion=MysqlAPIUtils.readBytesAsString(cb,ST_SERVER_VER_LEN,CharsetUtil.UTF_8);
  createTime=cb.readUnsignedInt();
  int eventTypeLength=cb.readUnsignedByte();
switch (MyBinLogVerType.fromByte((byte)binaryLogVersion)) {
case MySQL_5_0:
    for (int i=1; i <= eventTypeLength; i++) {
      eventTypeValues.put(MyLogEventType.fromByte((byte)i),cb.readByte());
    }
  break;
default :
logger.error(""String_Node_Str"");
}
}",0.979591836734694
87333,"private void closeActivePreparedStatement(){
  if (this.pstmtId >= 0) {
    MSPComStmtCloseRequestMessage closeRequestMessage=MSPComStmtCloseRequestMessage.newMessage((byte)0,this.pstmtId);
    this.ctx.write(closeRequestMessage);
    this.pstmtId=-1;
    this.pstmtTupleCount=-1;
    this.needsNewParam=true;
  }
}","private void closeActivePreparedStatement(){
  if (this.pstmtId >= 0) {
    MSPComStmtCloseRequestMessage closeRequestMessage=MSPComStmtCloseRequestMessage.newMessage((byte)0,this.pstmtId);
    this.ctx.write(closeRequestMessage);
    this.pstmtId=-1;
    this.pstmtTupleCount=-1;
  }
}",0.951747088186356
87334,"private void executePendingInsert(){
  BufferedExecute buffersToFlush=pendingFlush;
  int currentStatementID=this.pstmtId;
  buffersToFlush.setStmtID(currentStatementID);
  buffersToFlush.setNeedsNewParams(this.needsNewParam);
  buffersToFlush.setRowSetMetadata(policy.getRowsetMetadata());
  buffersToFlush.setColumnsPerTuple(columnsPerTuple);
  int rowsWritten=buffersToFlush.size();
  this.ctx.channel().writeAndFlush(new WrappedExecuteCommand(buffersToFlush,builder));
  this.pendingFlush=null;
  this.queuedRowSetCount.getAndAdd(-rowsWritten);
  this.needsNewParam=false;
}","private void executePendingInsert(){
  BufferedExecute buffersToFlush=pendingFlush;
  int currentStatementID=this.pstmtId;
  buffersToFlush.setStmtID(currentStatementID);
  buffersToFlush.setNeedsNewParams(true);
  buffersToFlush.setRowSetMetadata(policy.getRowsetMetadata());
  buffersToFlush.setColumnsPerTuple(columnsPerTuple);
  int rowsWritten=buffersToFlush.size();
  this.ctx.channel().writeAndFlush(new WrappedExecuteCommand(buffersToFlush,builder));
  this.pendingFlush=null;
  this.queuedRowSetCount.getAndAdd(-rowsWritten);
}",0.9569120287253142
87335,"protected void pauseSourceStreams(){
  if (!sourcePaused) {
    sourcePaused=true;
    for (    ChannelHandlerContext ctx : sourceSites.keySet()) {
      StreamValve.pipelinePause(ctx.pipeline());
    }
  }
}","protected void pauseSourceStreams(){
  sourcePaused=true;
  for (  ChannelHandlerContext ctx : sourceSites.keySet()) {
    StreamValve.pipelinePause(ctx.pipeline());
  }
}",0.9023746701846964
87336,"private boolean processTargetPacket(ChannelHandlerContext ctx,MyMessage message){
  RedistTargetSite siteCtx=siteCtxByChannel.get(ctx.channel());
  if (!isProcessingComplete(siteCtx)) {
    try {
      if (message instanceof MyOKResponse) {
        if (!isProcessingComplete(siteCtx) && !completionPromise.isFulfilled()) {
          int rowCount=(int)((MyOKResponse)message).getAffectedRows();
          updatedRowsCount+=rowCount;
        }
      }
 else {
        MyErrorResponse err=(MyErrorResponse)message;
        failure(err.asException());
      }
    }
  finally {
      siteCtx.handleAck(message);
      blockedTargetSites.remove(siteCtx);
      if (blockedTargetSites.isEmpty())       resumeSourceStreams();
    }
  }
  testRedistributionComplete();
  return isProcessingComplete(siteCtx);
}","private boolean processTargetPacket(ChannelHandlerContext ctx,MyMessage message){
  RedistTargetSite siteCtx=siteCtxByChannel.get(ctx.channel());
  if (!isProcessingComplete(siteCtx)) {
    try {
      if (message instanceof MyOKResponse) {
        if (!isProcessingComplete(siteCtx) && !completionPromise.isFulfilled()) {
          int rowCount=(int)((MyOKResponse)message).getAffectedRows();
          updatedRowsCount+=rowCount;
        }
      }
 else {
        MyErrorResponse err=(MyErrorResponse)message;
        failure(err.asException());
      }
    }
  finally {
      siteCtx.handleAck(message);
      if (!siteCtx.hasPendingFlush())       blockedTargetSites.remove(siteCtx);
      if (blockedTargetSites.isEmpty())       resumeSourceStreams();
    }
  }
  testRedistributionComplete();
  return isProcessingComplete(siteCtx);
}",0.976857490864799
87337,"public void processSourcePacket(MappingSolution mappingSolution,MyBinaryResultRow binRow,int fieldCount,ColumnSet columnSet,long[] autoIncrBlocks) throws PEException {
  if (!receivingSourcePackets)   receivingSourcePackets=true;
  if (mappingSolution == MappingSolution.AllWorkers || mappingSolution == MappingSolution.AllWorkersSerialized) {
    for (    RedistTargetSite siteCtx : siteCtxBySite.values())     handleSourceRow(binRow,(autoIncrBlocks == null) ? null : new long[]{autoIncrBlocks[0]},siteCtx);
  }
 else   if (mappingSolution == MappingSolution.AnyWorker || mappingSolution == MappingSolution.AnyWorkerSerialized) {
    handleSourceRow(binRow,autoIncrBlocks,PECollectionUtils.selectRandom(siteCtxBySite.values()));
  }
 else {
    StorageSite executionSite=targetWG.resolveSite(mappingSolution.getSite());
    handleSourceRow(binRow,autoIncrBlocks,siteCtxBySite.get(executionSite));
  }
  if (!blockedTargetSites.isEmpty()) {
    pauseSourceStreams();
  }
}","public void processSourcePacket(MappingSolution mappingSolution,MyBinaryResultRow binRow,int fieldCount,ColumnSet columnSet,long[] autoIncrBlocks) throws PEException {
  if (mappingSolution == MappingSolution.AllWorkers || mappingSolution == MappingSolution.AllWorkersSerialized) {
    for (    RedistTargetSite siteCtx : siteCtxBySite.values())     handleSourceRow(binRow,(autoIncrBlocks == null) ? null : new long[]{autoIncrBlocks[0]},siteCtx);
  }
 else   if (mappingSolution == MappingSolution.AnyWorker || mappingSolution == MappingSolution.AnyWorkerSerialized) {
    handleSourceRow(binRow,autoIncrBlocks,PECollectionUtils.selectRandom(siteCtxBySite.values()));
  }
 else {
    StorageSite executionSite=targetWG.resolveSite(mappingSolution.getSite());
    handleSourceRow(binRow,autoIncrBlocks,siteCtxBySite.get(executionSite));
  }
  if (!blockedTargetSites.isEmpty()) {
    pauseSourceStreams();
  }
}",0.967056323060574
87338,"public void sourceActive(ChannelHandlerContext ctx){
  if (sourceSites.get(ctx) == null) {
    sourceSites.put(ctx,ctx);
    if (receivingSourcePackets && sourcePaused) {
      StreamValve.pipelinePause(ctx.pipeline());
    }
  }
}","public void sourceActive(ChannelHandlerContext ctx){
  if (sourceSites.get(ctx) == null) {
    sourceSites.put(ctx,ctx);
    if (sourcePaused) {
      StreamValve.pipelinePause(ctx.pipeline());
    }
  }
}",0.9403669724770642
87339,"public static WorkerGroup newInstance(SSConnection ssCon,StorageGroup sg,PersistentDatabase ctxDB) throws PEException {
  WorkerGroup wg=workerGroupPool.get(sg,ssCon.getUserAuthentication());
  Channel channel=ssCon.getChannel();
  EventLoop eventLoop=channel == null ? null : channel.eventLoop();
  if (wg == null) {
    wg=new WorkerGroup(sg).provision(ssCon,ssCon,ssCon.getUserAuthentication(),eventLoop);
  }
 else {
    wg.bindToClientThread(eventLoop);
  }
  try {
    if (ctxDB != null)     wg.setDatabase(ssCon,ctxDB);
    wg.assureSessionVariables(ssCon);
  }
 catch (  PEException e) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + wg);
    wg.releaseWorkers(ssCon);
    throw e;
  }
  if (wg.workerMap == null)   throw new PECodingException(""String_Node_Str"");
  return wg;
}","public static WorkerGroup newInstance(SSConnection ssCon,StorageGroup sg,PersistentDatabase ctxDB) throws PEException {
  WorkerGroup wg=workerGroupPool.get(sg,ssCon.getUserAuthentication());
  Channel channel=ssCon.getChannel();
  EventLoop eventLoop=channel == null ? null : channel.eventLoop();
  if (wg == null) {
    wg=new WorkerGroup(sg).provision(ssCon,ssCon,ssCon.getUserAuthentication(),eventLoop);
  }
 else {
    wg.bindToClientThread(eventLoop);
  }
  try {
    if (ctxDB != null)     wg.setDatabase(ssCon,ctxDB);
    wg.assureSessionVariables(ssCon);
  }
 catch (  PEException e) {
    e.printStackTrace(System.out);
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"" + wg);
    wg.releaseWorkers(ssCon);
    throw e;
  }
  if (wg.workerMap == null)   throw new PECodingException(""String_Node_Str"");
  return wg;
}",0.9788519637462236
87340,"private void submitWork(final Worker w,final WorkerRequest req,final DBResultConsumer resultConsumer,final CompletionHandle<Worker> workerComplete){
  final long reqStartTime=System.currentTimeMillis();
  final CompletionHandle<Boolean> promise=new PEDefaultPromise<Boolean>(){
    @Override public void success(    Boolean returnValue){
      try {
        w.sendStatistics(req,System.currentTimeMillis() - reqStartTime);
        workerComplete.success(w);
      }
 catch (      PEException e) {
        this.failure(e);
      }
    }
    @Override public void failure(    Exception t){
      try {
        w.setLastException(t);
        if (t instanceof PEException && ((PEException)t).hasCause(PECommunicationsException.class)) {
          markForPurge();
        }
      }
  finally {
        workerComplete.failure(t);
      }
    }
  }
;
  try {
    w.getConnectionId();
  }
 catch (  PESQLException e) {
  }
  clientEventLoop.submit(new Callable<Worker>(){
    @Override public Worker call() throws Exception {
      req.executeRequest(w,resultConsumer,promise);
      return w;
    }
  }
);
}","private void submitWork(final Worker w,final WorkerRequest req,final DBResultConsumer resultConsumer,final CompletionHandle<Worker> workerComplete){
  final long reqStartTime=System.currentTimeMillis();
  final CompletionHandle<Boolean> promise=new PEDefaultPromise<Boolean>(){
    @Override public void success(    Boolean returnValue){
      try {
        w.sendStatistics(req,System.currentTimeMillis() - reqStartTime);
        workerComplete.success(w);
      }
 catch (      PEException e) {
        this.failure(e);
      }
    }
    @Override public void failure(    Exception t){
      try {
        w.setLastException(t);
        if (t instanceof PEException && ((PEException)t).hasCause(PECommunicationsException.class)) {
          markForPurge();
        }
      }
  finally {
        workerComplete.failure(t);
      }
    }
  }
;
  try {
    w.getConnectionId();
  }
 catch (  Exception e) {
  }
  clientEventLoop.submit(new Callable<Worker>(){
    @Override public Worker call() throws Exception {
      req.executeRequest(w,resultConsumer,promise);
      return w;
    }
  }
);
}",0.9977220956719818
87341,"public SF readStructuredField() throws IOException {
  AfpInputStream afpin=null;
  try {
    afpin=new AfpInputStream(new AfpIn(this));
    return afpin.readStructuredField();
  }
  finally {
    if (afpin != null)     afpin.close();
  }
}","public SF readStructuredField() throws IOException {
  AfpInputStream afpin=null;
  try {
    afpin=new AfpInputStream(new AfpIn(this),leadingLengthBytes);
    SF sf=afpin.readStructuredField();
    if (leadingLengthBytes == -1)     leadingLengthBytes=afpin.getLeadingLengthBytes();
    return sf;
  }
  finally {
    if (afpin != null)     afpin.close();
  }
}",0.7520798668885191
87342,"/** 
 * Reads a new structured field from the input stream. This method is not thread-safe!
 * @return structured field or null if end of input.
 * @throws IOException
 */
public SF readStructuredField() throws IOException {
  int buf=0;
  long thisOffset=offset;
  if (leadingLengthBytes == -1) {
    int leadingLength=0;
    do {
      buf=read();
      offset++;
      leadingLength++;
    }
 while ((buf & 0xff) != 0x5a && buf != -1 && leadingLength < 5);
    if ((buf & 0xff) != 0x5a) {
      has5a=false;
      leadingLength=1;
      offset=2;
      buf=read();
      if ((buf & 0xff) != 0xd3) {
        throw new IOException(""String_Node_Str"");
      }
      offset=0;
    }
    leadingLengthBytes=leadingLength - 1;
  }
 else {
    if (leadingLengthBytes > 0)     read(data,0,leadingLengthBytes);
    if (has5a) {
      buf=read();
      offset++;
    }
  }
  if (buf == -1) {
    return null;
  }
  if (has5a && (buf & 0xff) != 0x5a) {
    throw new IOException(""String_Node_Str"");
  }
  data[0]=0x5a;
  buf=read();
  offset++;
  if (buf == -1 && !has5a) {
    return null;
  }
  if (buf == -1) {
    throw new IOException(""String_Node_Str"");
  }
  data[1]=(byte)(buf & 0xff);
  length=(byte)buf << 8;
  buf=read();
  offset++;
  if (buf == -1)   throw new IOException(""String_Node_Str"");
  data[2]=(byte)(buf & 0xff);
  length|=(byte)buf & 0xff;
  length-=2;
  if (length > data.length)   throw new IOException(""String_Node_Str"" + length);
  int read=read(data,3,length);
  offset+=read;
  if (read < length)   throw new IOException(""String_Node_Str"");
  SF sf=factory.sf(data,0,getLength() + 2);
  sf.setLength(length + 3);
  sf.setOffset(thisOffset);
  sf.setNumber(number++);
  return sf;
}","/** 
 * Reads a new structured field from the input stream. This method is not thread-safe!
 * @return structured field or null if end of input.
 * @throws IOException
 */
public SF readStructuredField() throws IOException {
  int buf=0;
  long thisOffset=offset;
  if (leadingLengthBytes == -1) {
    int leadingLength=0;
    do {
      buf=read();
      offset++;
      leadingLength++;
    }
 while ((buf & 0xff) != 0x5a && buf != -1 && leadingLength < 5);
    if ((buf & 0xff) != 0x5a) {
      has5a=false;
      leadingLength=1;
      offset=2;
      buf=read();
      if (buf == -1)       return null;
      if ((buf & 0xff) != 0xd3) {
        throw new IOException(""String_Node_Str"");
      }
      offset=0;
    }
    leadingLengthBytes=leadingLength - 1;
  }
 else {
    if (leadingLengthBytes > 0)     read(data,0,leadingLengthBytes);
    if (has5a) {
      buf=read();
      offset++;
    }
  }
  if (buf == -1) {
    return null;
  }
  if (has5a && (buf & 0xff) != 0x5a) {
    throw new IOException(""String_Node_Str"");
  }
  data[0]=0x5a;
  buf=read();
  offset++;
  if (buf == -1 && !has5a) {
    return null;
  }
  if (buf == -1) {
    throw new IOException(""String_Node_Str"");
  }
  data[1]=(byte)(buf & 0xff);
  length=(byte)buf << 8;
  buf=read();
  offset++;
  if (buf == -1)   throw new IOException(""String_Node_Str"");
  data[2]=(byte)(buf & 0xff);
  length|=(byte)buf & 0xff;
  length-=2;
  if (length > data.length)   throw new IOException(""String_Node_Str"" + length);
  int read=read(data,3,length);
  offset+=read;
  if (read < length)   throw new IOException(""String_Node_Str"");
  SF sf=factory.sf(data,0,getLength() + 2);
  sf.setLength(length + 3);
  sf.setOffset(thisOffset);
  sf.setNumber(number++);
  return sf;
}",0.9883923389437028
87343,"@Test public void testWrite() throws IOException {
  new File(""String_Node_Str"").mkdirs();
  File testFile=new File(""String_Node_Str"");
  testFile.delete();
  Files.copy(new File(""String_Node_Str"").toPath(),testFile.toPath());
  try (AfpFile file=new AfpFile(testFile,""String_Node_Str"")){
    SF sf;
    sf=file.readStructuredField();
    assertTrue(sf instanceof BRG);
    sf=file.readStructuredField();
    assertTrue(sf instanceof ERG);
    sf=file.readStructuredField();
    assertNull(sf);
    sf=AfplibFactory.eINSTANCE.createNOP();
    ((NOP)sf).setUndfData(new byte[]{1,2,3});
    file.writeStructuredField(sf);
    file.seek(0);
    sf=file.readStructuredField();
    assertTrue(sf instanceof BRG);
    sf=file.readStructuredField();
    assertTrue(sf instanceof ERG);
    sf=file.readStructuredField();
    assertTrue(sf instanceof NOP);
    sf=file.readStructuredField();
    assertNull(sf);
  }
 }","@Test public void testWrite() throws IOException {
  new File(""String_Node_Str"").mkdirs();
  File testFile=new File(""String_Node_Str"");
  testFile.delete();
  Files.copy(new File(""String_Node_Str"").toPath(),testFile.toPath());
  try (AfpFile file=new AfpFile(testFile,""String_Node_Str"")){
    SF sf;
    sf=file.readStructuredField();
    assertTrue(sf instanceof BRG);
    sf=file.readStructuredField();
    assertTrue(sf instanceof ERG);
    sf=AfplibFactory.eINSTANCE.createNOP();
    ((NOP)sf).setUndfData(new byte[]{1,2,3});
    file.writeStructuredField(sf);
    file.seek(0);
    sf=file.readStructuredField();
    assertTrue(sf instanceof BRG);
    sf=file.readStructuredField();
    assertTrue(sf instanceof ERG);
    sf=file.readStructuredField();
    assertTrue(sf instanceof NOP);
  }
 }",0.9355971896955504
87344,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  resultTextView=(TextView)findViewById(R.id.result_text_view);
  Button syncNow=(Button)findViewById(R.id.sync_now_button);
  final TimeSyncProxy sync=TimeSync.get(this,RandomSync.class);
  syncNow.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      sync.sync();
    }
  }
);
  final Button toggle=(Button)findViewById(R.id.toggle_enabled_button);
  toggle.setText(""String_Node_Str"" + (sync.config().enabled() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  toggle.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      sync.edit(enable(!sync.config().enabled()));
      toggle.setText(""String_Node_Str"" + (sync.config().enabled() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
  }
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  resultTextView=(TextView)findViewById(R.id.result_text_view);
  Button syncNow=(Button)findViewById(R.id.sync_now_button);
  Button syncSoon=(Button)findViewById(R.id.sync_soon_button);
  final Button toggle=(Button)findViewById(R.id.toggle_enabled_button);
  final TimeSyncProxy sync=TimeSync.get(this,RandomSync.class);
  syncNow.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      sync.sync();
    }
  }
);
  syncSoon.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      sync.syncInexact();
    }
  }
);
  toggle.setText(""String_Node_Str"" + (sync.config().enabled() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  toggle.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      sync.edit(enable(!sync.config().enabled()));
      toggle.setText(""String_Node_Str"" + (sync.config().enabled() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
  }
);
}",0.7073743541568812
87345,"@Override public void onSync(Context context) throws Exception {
  Thread.sleep(1000);
  long result=random.nextLong();
  if (random.nextInt(5) < 2) {
    Log.d(""String_Node_Str"",""String_Node_Str"" + System.currentTimeMillis());
    throw new Exception();
  }
  Log.d(""String_Node_Str"",""String_Node_Str"" + System.currentTimeMillis());
  Intent intent=new Intent(BROADCAST);
  intent.putExtra(EXTRA_RESULT,result);
  LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
}","@Override public void onSync(Context context) throws Exception {
  long result=random.nextLong();
  Intent intent=new Intent(BROADCAST);
  intent.putExtra(EXTRA_RESULT,result);
  LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
}",0.6758241758241759
87346,"public void selectByVisibleText(Object text){
  log.info(""String_Node_Str"" + this + ""String_Node_Str""+ text+ ""String_Node_Str"");
  locate().selectByVisibleText(text.toString());
  if (!locate().getFirstSelectedOption().getAttribute(""String_Node_Str"").equals(text.toString())) {
    locate().getOptions().stream().filter((    WebElement e) -> e.getText().equals(text.toString())).findFirst().get().click();
  }
}","public void selectByVisibleText(Object text){
  log.info(""String_Node_Str"" + this + ""String_Node_Str""+ text+ ""String_Node_Str"");
  locate().selectByVisibleText(text.toString());
  try {
    if (!locate().getFirstSelectedOption().getAttribute(""String_Node_Str"").equals(text.toString())) {
      locate().getOptions().stream().filter((      WebElement e) -> e.getText().equals(text.toString())).findFirst().get().click();
    }
  }
 catch (  Exception e) {
  }
}",0.9437428243398392
87347,"/** 
 * @return the value of the select radio
 */
public String getValue(){
  return locate(new FirstMatch<>(DISPLAYED.and(CHECKED.and(TRUE))).andThen(GET).andThen(element(PARENT)).andThen(TEXT));
}","/** 
 * @return the value of the select radio
 */
public String getValue(){
  return locate(new FirstMatch<>(DISPLAYED.and(CHECKED.and(TRUE))).andThen(GET).andThen(VALUE));
}",0.9193548387096774
87348,"/** 
 * @param value value to set
 */
public void setValue(Object value){
  locate(new FirstMatch<>(DISPLAYED.and(Locators.<Element>element(PARENT).andThen(TEXT).and(new StringContains(value.toString())))).andThen(GET).andThen(CLICK));
}","/** 
 * @param value value to set
 */
public void setValue(Object value){
  locate(new FirstMatch<>(VALUE.and(new StringContains(value.toString()))).andThen(GET).andThen(CLICK));
}",0.8489208633093526
87349,"default public void save(String title){
  logger.info(""String_Node_Str"",title);
  File scrFile=null;
  try {
    scrFile=this.getSupplier().takeScreenShot(this);
    copyFile(scrFile,new File(""String_Node_Str"" + title + new Date().getTime()+ ""String_Node_Str""));
    scrFile.delete();
  }
 catch (  UnhandledAlertException e) {
    logger.info(""String_Node_Str"",e);
  }
catch (  IOException e) {
    try {
      copyFile(scrFile,new File(""String_Node_Str"" + new Date().getTime() + ""String_Node_Str""));
    }
 catch (    IOException e1) {
      logger.info(""String_Node_Str"",e1);
    }
  }
}","default public void save(String title){
  T webDriver=get();
  if (webDriver instanceof TakesScreenshot) {
    logger.info(""String_Node_Str"",title);
    File scrFile=null;
    try {
      TakesScreenshot camera=(TakesScreenshot)webDriver;
      scrFile=camera.getScreenshotAs(FILE);
      copyFile(scrFile,new File(""String_Node_Str"" + title + new Date().getTime()+ ""String_Node_Str""));
      scrFile.delete();
    }
 catch (    UnhandledAlertException e) {
      logger.info(""String_Node_Str"",e);
    }
catch (    IOException e) {
      try {
        copyFile(scrFile,new File(""String_Node_Str"" + new Date().getTime() + ""String_Node_Str""));
      }
 catch (      IOException e1) {
        logger.info(""String_Node_Str"",e1);
      }
    }
  }
 else {
    logger.info(""String_Node_Str"");
  }
}",0.7979724837074583
87350,"@Test public void testZenkakuHiraganaToHankakuKatakana(){
  this.assertConverted(KanaConverter.OP_ZENKAKU_HIRAGANA_TO_HANKAKU_KATAKANA,""String_Node_Str"",""String_Node_Str"");
  this.assertConverted(KanaConverter.OP_ZENKAKU_HIRAGANA_TO_HANKAKU_KATAKANA,""String_Node_Str"",""String_Node_Str"");
}","@Test public void testZenkakuHiraganaToHankakuKatakana(){
  this.assertConverted(KanaConverter.OP_ZENKAKU_HIRAGANA_TO_HANKAKU_KATAKANA,""String_Node_Str"",""String_Node_Str"");
  this.assertConverted(KanaConverter.OP_ZENKAKU_HIRAGANA_TO_HANKAKU_KATAKANA,""String_Node_Str"",""String_Node_Str"");
  this.assertConverted(KanaConverter.OP_ZENKAKU_HIRAGANA_TO_HANKAKU_KATAKANA,""String_Node_Str"",""String_Node_Str"");
}",0.834054834054834
87351,"@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  final SettingsValues settingsValues=mSettings.getCurrent();
  if ((!settingsValues.mHasHardwareKeyboard || ProductionFlags.IS_HARDWARE_KEYBOARD_SUPPORTED) && mInputLogic.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd)) {
    mKeyboardSwitcher.requestUpdatingShiftState(getCurrentAutoCapsState(),getCurrentRecapitalizeState());
  }
}","@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  final SettingsValues settingsValues=mSettings.getCurrent();
  if ((!settingsValues.mHasHardwareKeyboard || ProductionFlags.IS_HARDWARE_KEYBOARD_SUPPORTED) && mInputLogic.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,settingsValues)) {
    mKeyboardSwitcher.requestUpdatingShiftState(getCurrentAutoCapsState(),getCurrentRecapitalizeState());
  }
}",0.9915014164305948
87352,"/** 
 * Consider an update to the cursor position. Evaluate whether this update has happened as part of normal typing or whether it was an explicit cursor move by the user. In any case, do the necessary adjustments.
 * @param oldSelStart old selection start
 * @param oldSelEnd old selection end
 * @param newSelStart new selection start
 * @param newSelEnd new selection end
 * @return whether the cursor has moved as a result of user interaction.
 */
public boolean onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd){
  if (mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart,oldSelEnd,newSelEnd)) {
    return false;
  }
  mSpaceState=SpaceState.NONE;
  final boolean selectionChangedOrSafeToReset=oldSelStart != newSelStart || oldSelEnd != newSelEnd || !mWordComposer.isComposingWord();
  final boolean hasOrHadSelection=(oldSelStart != oldSelEnd || newSelStart != newSelEnd);
  final int moveAmount=newSelStart - oldSelStart;
  if (hasOrHadSelection || (selectionChangedOrSafeToReset && !mWordComposer.moveCursorByAndReturnIfInsideComposingWord(moveAmount))) {
    resetEntireInputState(newSelStart,newSelEnd,false);
  }
 else {
    mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,false);
  }
  mRecapitalizeStatus.enable();
  mTextDecorator.reset();
  mConnection.removeBackgroundColorFromHighlightedTextIfNecessary();
  mLatinIME.mHandler.postResumeSuggestions(false,true);
  mRecapitalizeStatus.stop();
  return true;
}","/** 
 * Consider an update to the cursor position. Evaluate whether this update has happened as part of normal typing or whether it was an explicit cursor move by the user. In any case, do the necessary adjustments.
 * @param oldSelStart old selection start
 * @param oldSelEnd old selection end
 * @param newSelStart new selection start
 * @param newSelEnd new selection end
 * @param settingsValues the current values of the settings.
 * @return whether the cursor has moved as a result of user interaction.
 */
public boolean onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final SettingsValues settingsValues){
  if (mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart,oldSelEnd,newSelEnd)) {
    return false;
  }
  mSpaceState=SpaceState.NONE;
  final boolean selectionChangedOrSafeToReset=oldSelStart != newSelStart || oldSelEnd != newSelEnd || !mWordComposer.isComposingWord();
  final boolean hasOrHadSelection=(oldSelStart != oldSelEnd || newSelStart != newSelEnd);
  final int moveAmount=newSelStart - oldSelStart;
  if (hasOrHadSelection || !settingsValues.needsToLookupSuggestions() || (selectionChangedOrSafeToReset && !mWordComposer.moveCursorByAndReturnIfInsideComposingWord(moveAmount))) {
    resetEntireInputState(newSelStart,newSelEnd,false);
  }
 else {
    mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,false);
  }
  mRecapitalizeStatus.enable();
  mTextDecorator.reset();
  mConnection.removeBackgroundColorFromHighlightedTextIfNecessary();
  mLatinIME.mHandler.postResumeSuggestions(false,true);
  mRecapitalizeStatus.stop();
  return true;
}",0.9549322407815948
87353,"@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  final SettingsValues settingsValues=mSettings.getCurrent();
  if ((!settingsValues.mHasHardwareKeyboard || ProductionFlags.IS_HARDWARE_KEYBOARD_SUPPORTED) && mInputLogic.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd)) {
    mKeyboardSwitcher.requestUpdatingShiftState(getCurrentAutoCapsState(),getCurrentRecapitalizeState());
  }
}","@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  final SettingsValues settingsValues=mSettings.getCurrent();
  if ((!settingsValues.mHasHardwareKeyboard || ProductionFlags.IS_HARDWARE_KEYBOARD_SUPPORTED) && mInputLogic.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,settingsValues)) {
    mKeyboardSwitcher.requestUpdatingShiftState(getCurrentAutoCapsState(),getCurrentRecapitalizeState());
  }
}",0.9915014164305948
87354,"/** 
 * Consider an update to the cursor position. Evaluate whether this update has happened as part of normal typing or whether it was an explicit cursor move by the user. In any case, do the necessary adjustments.
 * @param oldSelStart old selection start
 * @param oldSelEnd old selection end
 * @param newSelStart new selection start
 * @param newSelEnd new selection end
 * @return whether the cursor has moved as a result of user interaction.
 */
public boolean onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd){
  if (mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart,oldSelEnd,newSelEnd)) {
    return false;
  }
  mSpaceState=SpaceState.NONE;
  final boolean selectionChangedOrSafeToReset=oldSelStart != newSelStart || oldSelEnd != newSelEnd || !mWordComposer.isComposingWord();
  final boolean hasOrHadSelection=(oldSelStart != oldSelEnd || newSelStart != newSelEnd);
  final int moveAmount=newSelStart - oldSelStart;
  if (hasOrHadSelection || (selectionChangedOrSafeToReset && !mWordComposer.moveCursorByAndReturnIfInsideComposingWord(moveAmount))) {
    resetEntireInputState(newSelStart,newSelEnd,false);
  }
 else {
    mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,false);
  }
  mRecapitalizeStatus.enable();
  mTextDecorator.reset();
  mConnection.removeBackgroundColorFromHighlightedTextIfNecessary();
  mLatinIME.mHandler.postResumeSuggestions(false,true);
  mRecapitalizeStatus.stop();
  return true;
}","/** 
 * Consider an update to the cursor position. Evaluate whether this update has happened as part of normal typing or whether it was an explicit cursor move by the user. In any case, do the necessary adjustments.
 * @param oldSelStart old selection start
 * @param oldSelEnd old selection end
 * @param newSelStart new selection start
 * @param newSelEnd new selection end
 * @param settingsValues the current values of the settings.
 * @return whether the cursor has moved as a result of user interaction.
 */
public boolean onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final SettingsValues settingsValues){
  if (mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart,oldSelEnd,newSelEnd)) {
    return false;
  }
  mSpaceState=SpaceState.NONE;
  final boolean selectionChangedOrSafeToReset=oldSelStart != newSelStart || oldSelEnd != newSelEnd || !mWordComposer.isComposingWord();
  final boolean hasOrHadSelection=(oldSelStart != oldSelEnd || newSelStart != newSelEnd);
  final int moveAmount=newSelStart - oldSelStart;
  if (hasOrHadSelection || !settingsValues.needsToLookupSuggestions() || (selectionChangedOrSafeToReset && !mWordComposer.moveCursorByAndReturnIfInsideComposingWord(moveAmount))) {
    resetEntireInputState(newSelStart,newSelEnd,false);
  }
 else {
    mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,false);
  }
  mRecapitalizeStatus.enable();
  mTextDecorator.reset();
  mConnection.removeBackgroundColorFromHighlightedTextIfNecessary();
  mLatinIME.mHandler.postResumeSuggestions(false,true);
  mRecapitalizeStatus.stop();
  return true;
}",0.9549322407815948
87355,"@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  final SettingsValues settingsValues=mSettings.getCurrent();
  if ((!settingsValues.mHasHardwareKeyboard || ProductionFlags.IS_HARDWARE_KEYBOARD_SUPPORTED) && mInputLogic.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd)) {
    mKeyboardSwitcher.requestUpdatingShiftState(getCurrentAutoCapsState(),getCurrentRecapitalizeState());
  }
}","@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  final SettingsValues settingsValues=mSettings.getCurrent();
  if ((!settingsValues.mHasHardwareKeyboard || ProductionFlags.IS_HARDWARE_KEYBOARD_SUPPORTED) && mInputLogic.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,settingsValues)) {
    mKeyboardSwitcher.requestUpdatingShiftState(getCurrentAutoCapsState(),getCurrentRecapitalizeState());
  }
}",0.9915014164305948
87356,"/** 
 * Consider an update to the cursor position. Evaluate whether this update has happened as part of normal typing or whether it was an explicit cursor move by the user. In any case, do the necessary adjustments.
 * @param oldSelStart old selection start
 * @param oldSelEnd old selection end
 * @param newSelStart new selection start
 * @param newSelEnd new selection end
 * @return whether the cursor has moved as a result of user interaction.
 */
public boolean onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd){
  if (mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart,oldSelEnd,newSelEnd)) {
    return false;
  }
  mSpaceState=SpaceState.NONE;
  final boolean selectionChangedOrSafeToReset=oldSelStart != newSelStart || oldSelEnd != newSelEnd || !mWordComposer.isComposingWord();
  final boolean hasOrHadSelection=(oldSelStart != oldSelEnd || newSelStart != newSelEnd);
  final int moveAmount=newSelStart - oldSelStart;
  if (hasOrHadSelection || (selectionChangedOrSafeToReset && !mWordComposer.moveCursorByAndReturnIfInsideComposingWord(moveAmount))) {
    resetEntireInputState(newSelStart,newSelEnd,false);
  }
 else {
    mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,false);
  }
  mRecapitalizeStatus.enable();
  mTextDecorator.reset();
  mConnection.removeBackgroundColorFromHighlightedTextIfNecessary();
  mLatinIME.mHandler.postResumeSuggestions(false,true);
  mRecapitalizeStatus.stop();
  return true;
}","/** 
 * Consider an update to the cursor position. Evaluate whether this update has happened as part of normal typing or whether it was an explicit cursor move by the user. In any case, do the necessary adjustments.
 * @param oldSelStart old selection start
 * @param oldSelEnd old selection end
 * @param newSelStart new selection start
 * @param newSelEnd new selection end
 * @param settingsValues the current values of the settings.
 * @return whether the cursor has moved as a result of user interaction.
 */
public boolean onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final SettingsValues settingsValues){
  if (mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart,oldSelEnd,newSelEnd)) {
    return false;
  }
  mSpaceState=SpaceState.NONE;
  final boolean selectionChangedOrSafeToReset=oldSelStart != newSelStart || oldSelEnd != newSelEnd || !mWordComposer.isComposingWord();
  final boolean hasOrHadSelection=(oldSelStart != oldSelEnd || newSelStart != newSelEnd);
  final int moveAmount=newSelStart - oldSelStart;
  if (hasOrHadSelection || !settingsValues.needsToLookupSuggestions() || (selectionChangedOrSafeToReset && !mWordComposer.moveCursorByAndReturnIfInsideComposingWord(moveAmount))) {
    resetEntireInputState(newSelStart,newSelEnd,false);
  }
 else {
    mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,false);
  }
  mRecapitalizeStatus.enable();
  mTextDecorator.reset();
  mConnection.removeBackgroundColorFromHighlightedTextIfNecessary();
  mLatinIME.mHandler.postResumeSuggestions(false,true);
  mRecapitalizeStatus.stop();
  return true;
}",0.9549322407815948
87357,"/** 
 * Returns the text surrounding the cursor.
 * @param sortedSeparators a sorted array of code points that split words.
 * @param scriptId the script we consider to be writing words, as one of ScriptUtils.SCRIPT_
 * @return a range containing the text surrounding the cursor
 */
public TextRange getWordRangeAtCursor(final int[] sortedSeparators,final int scriptId){
  mIC=mParent.getCurrentInputConnection();
  if (mIC == null) {
    return null;
  }
  final CharSequence before=mIC.getTextBeforeCursor(Constants.EDITOR_CONTENTS_CACHE_SIZE,InputConnection.GET_TEXT_WITH_STYLES);
  final CharSequence after=mIC.getTextAfterCursor(Constants.EDITOR_CONTENTS_CACHE_SIZE,InputConnection.GET_TEXT_WITH_STYLES);
  if (before == null || after == null) {
    return null;
  }
  int startIndexInBefore=before.length();
  while (startIndexInBefore > 0) {
    final int codePoint=Character.codePointBefore(before,startIndexInBefore);
    if (isSeparator(codePoint,sortedSeparators) || !ScriptUtils.isLetterPartOfScript(codePoint,scriptId)) {
      break;
    }
    --startIndexInBefore;
    if (Character.isSupplementaryCodePoint(codePoint)) {
      --startIndexInBefore;
    }
  }
  int endIndexInAfter=-1;
  while (++endIndexInAfter < after.length()) {
    final int codePoint=Character.codePointAt(after,endIndexInAfter);
    if (isSeparator(codePoint,sortedSeparators) || !ScriptUtils.isLetterPartOfScript(codePoint,scriptId)) {
      break;
    }
    if (Character.isSupplementaryCodePoint(codePoint)) {
      ++endIndexInAfter;
    }
  }
  final boolean hasUrlSpans=SpannableStringUtils.hasUrlSpans(before,startIndexInBefore,before.length()) || SpannableStringUtils.hasUrlSpans(after,0,endIndexInAfter);
  return new TextRange(SpannableStringUtils.concatWithNonParagraphSuggestionSpansOnly(before,after),startIndexInBefore,before.length() + endIndexInAfter,before.length(),hasUrlSpans);
}","/** 
 * Returns the text surrounding the cursor.
 * @param spacingAndPunctuations the rules for spacing and punctuation
 * @param scriptId the script we consider to be writing words, as one of ScriptUtils.SCRIPT_
 * @return a range containing the text surrounding the cursor
 */
public TextRange getWordRangeAtCursor(final SpacingAndPunctuations spacingAndPunctuations,final int scriptId){
  mIC=mParent.getCurrentInputConnection();
  if (mIC == null) {
    return null;
  }
  final CharSequence before=mIC.getTextBeforeCursor(Constants.EDITOR_CONTENTS_CACHE_SIZE,InputConnection.GET_TEXT_WITH_STYLES);
  final CharSequence after=mIC.getTextAfterCursor(Constants.EDITOR_CONTENTS_CACHE_SIZE,InputConnection.GET_TEXT_WITH_STYLES);
  if (before == null || after == null) {
    return null;
  }
  int startIndexInBefore=before.length();
  while (startIndexInBefore > 0) {
    final int codePoint=Character.codePointBefore(before,startIndexInBefore);
    if (!isPartOfCompositionForScript(codePoint,spacingAndPunctuations,scriptId)) {
      break;
    }
    --startIndexInBefore;
    if (Character.isSupplementaryCodePoint(codePoint)) {
      --startIndexInBefore;
    }
  }
  int endIndexInAfter=-1;
  while (++endIndexInAfter < after.length()) {
    final int codePoint=Character.codePointAt(after,endIndexInAfter);
    if (!isPartOfCompositionForScript(codePoint,spacingAndPunctuations,scriptId)) {
      break;
    }
    if (Character.isSupplementaryCodePoint(codePoint)) {
      ++endIndexInAfter;
    }
  }
  final boolean hasUrlSpans=SpannableStringUtils.hasUrlSpans(before,startIndexInBefore,before.length()) || SpannableStringUtils.hasUrlSpans(after,0,endIndexInAfter);
  return new TextRange(SpannableStringUtils.concatWithNonParagraphSuggestionSpansOnly(before,after),startIndexInBefore,before.length() + endIndexInAfter,before.length(),hasUrlSpans);
}",0.8838451268357811
87358,"/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 * @param settingsValues the current values of the settings.
 * @param shouldIncludeResumedWordInSuggestions whether to include the word on which we resumesuggestions in the suggestion list.
 */
public void restartSuggestionsOnWordTouchedByCursor(final SettingsValues settingsValues,final boolean shouldIncludeResumedWordInSuggestions,final int currentKeyboardScriptId){
  if (settingsValues.isBrokenByRecorrection() || !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces || !settingsValues.needsToLookupSuggestions()|| mInputLogicHandler.isInBatchInput()|| mConnection.hasSelection()|| mConnection.getExpectedSelectionStart() < 0) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  final int expectedCursorPosition=mConnection.getExpectedSelectionStart();
  if (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations)) {
    mWordComposer.setCapitalizedModeAtStartComposingTime(WordComposer.CAPS_MODE_OFF);
    mLatinIME.mHandler.postUpdateSuggestionStrip(SuggestedWords.INPUT_STYLE_RECORRECTION);
    return;
  }
  final TextRange range=mConnection.getWordRangeAtCursor(settingsValues.mSpacingAndPunctuations.mSortedWordSeparators,currentKeyboardScriptId);
  if (null == range)   return;
  if (range.length() <= 0) {
    mLatinIME.setNeutralSuggestionStrip();
    return;
  }
  if (range.mHasUrlSpans)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > expectedCursorPosition)   return;
  final ArrayList<SuggestedWordInfo> suggestions=new ArrayList<>();
  final String typedWord=range.mWord.toString();
  if (shouldIncludeResumedWordInSuggestions) {
    suggestions.add(new SuggestedWordInfo(typedWord,SuggestedWords.MAX_SUGGESTIONS + 1,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  if (!isResumableWord(settingsValues,typedWord)) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestedWords.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  final int[] codePoints=StringUtils.toCodePointArray(typedWord);
  final PrevWordsInfo prevWordsInfo=getPrevWordsInfoFromNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,0 == numberOfCharsInWordBeforeCursor ? 1 : 2);
  mWordComposer.setComposingWord(codePoints,mLatinIME.getCoordinatesForCurrentKeyboard(codePoints));
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.maybeMoveTheCursorAroundAndRestoreToWorkaroundABug();
  mConnection.setComposingRegion(expectedCursorPosition - numberOfCharsInWordBeforeCursor,expectedCursorPosition + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.size() <= (shouldIncludeResumedWordInSuggestions ? 1 : 0)) {
    mInputLogicHandler.getSuggestedWords(Suggest.SESSION_ID_TYPING,SuggestedWords.NOT_A_SEQUENCE_NUMBER,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1 && !shouldIncludeResumedWordInSuggestions) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWordForRecorrection();
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        mIsAutoCorrectionIndicatorOn=false;
        mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,null,typedWord,false,false,false,SuggestedWords.INPUT_STYLE_RECORRECTION,SuggestedWords.NOT_A_SEQUENCE_NUMBER);
    mIsAutoCorrectionIndicatorOn=false;
    mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
  }
}","/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 * @param settingsValues the current values of the settings.
 * @param shouldIncludeResumedWordInSuggestions whether to include the word on which we resumesuggestions in the suggestion list.
 */
public void restartSuggestionsOnWordTouchedByCursor(final SettingsValues settingsValues,final boolean shouldIncludeResumedWordInSuggestions,final int currentKeyboardScriptId){
  if (settingsValues.isBrokenByRecorrection() || !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces || !settingsValues.needsToLookupSuggestions()|| mInputLogicHandler.isInBatchInput()|| mConnection.hasSelection()|| mConnection.getExpectedSelectionStart() < 0) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  final int expectedCursorPosition=mConnection.getExpectedSelectionStart();
  if (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations)) {
    mWordComposer.setCapitalizedModeAtStartComposingTime(WordComposer.CAPS_MODE_OFF);
    mLatinIME.mHandler.postUpdateSuggestionStrip(SuggestedWords.INPUT_STYLE_RECORRECTION);
    return;
  }
  final TextRange range=mConnection.getWordRangeAtCursor(settingsValues.mSpacingAndPunctuations,currentKeyboardScriptId);
  if (null == range)   return;
  if (range.length() <= 0) {
    mLatinIME.setNeutralSuggestionStrip();
    return;
  }
  if (range.mHasUrlSpans)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > expectedCursorPosition)   return;
  final ArrayList<SuggestedWordInfo> suggestions=new ArrayList<>();
  final String typedWord=range.mWord.toString();
  if (shouldIncludeResumedWordInSuggestions) {
    suggestions.add(new SuggestedWordInfo(typedWord,SuggestedWords.MAX_SUGGESTIONS + 1,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  if (!isResumableWord(settingsValues,typedWord)) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestedWords.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  final int[] codePoints=StringUtils.toCodePointArray(typedWord);
  final PrevWordsInfo prevWordsInfo=getPrevWordsInfoFromNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,0 == numberOfCharsInWordBeforeCursor ? 1 : 2);
  mWordComposer.setComposingWord(codePoints,mLatinIME.getCoordinatesForCurrentKeyboard(codePoints));
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.maybeMoveTheCursorAroundAndRestoreToWorkaroundABug();
  mConnection.setComposingRegion(expectedCursorPosition - numberOfCharsInWordBeforeCursor,expectedCursorPosition + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.size() <= (shouldIncludeResumedWordInSuggestions ? 1 : 0)) {
    mInputLogicHandler.getSuggestedWords(Suggest.SESSION_ID_TYPING,SuggestedWords.NOT_A_SEQUENCE_NUMBER,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1 && !shouldIncludeResumedWordInSuggestions) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWordForRecorrection();
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        mIsAutoCorrectionIndicatorOn=false;
        mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,null,typedWord,false,false,false,SuggestedWords.INPUT_STYLE_RECORRECTION,SuggestedWords.NOT_A_SEQUENCE_NUMBER);
    mIsAutoCorrectionIndicatorOn=false;
    mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
  }
}",0.9974677716390424
87359,"public SpacingAndPunctuations(final Resources res){
  mSortedSymbolsPrecededBySpace=StringUtils.toSortedCodePointArray(res.getString(R.string.symbols_preceded_by_space));
  mSortedSymbolsFollowedBySpace=StringUtils.toSortedCodePointArray(res.getString(R.string.symbols_followed_by_space));
  mSortedSymbolsClusteringTogether=StringUtils.toSortedCodePointArray(res.getString(R.string.symbols_clustering_together));
  mSortedWordConnectors=StringUtils.toSortedCodePointArray(res.getString(R.string.symbols_word_connectors));
  mSortedWordSeparators=StringUtils.toSortedCodePointArray(res.getString(R.string.symbols_word_separators));
  mSentenceSeparator=res.getInteger(R.integer.sentence_separator);
  mSentenceSeparatorAndSpace=new String(new int[]{mSentenceSeparator,Constants.CODE_SPACE},0,2);
  mCurrentLanguageHasSpaces=res.getBoolean(R.bool.current_language_has_spaces);
  final Locale locale=res.getConfiguration().locale;
  mUsesAmericanTypography=Locale.ENGLISH.getLanguage().equals(locale.getLanguage());
  mUsesGermanRules=Locale.GERMAN.getLanguage().equals(locale.getLanguage());
  final String[] suggestPuncsSpec=MoreKeySpec.splitKeySpecs(res.getString(R.string.suggested_punctuations));
  mSuggestPuncList=PunctuationSuggestions.newPunctuationSuggestions(suggestPuncsSpec);
}","@UsedForTesting public SpacingAndPunctuations(final SpacingAndPunctuations model,final int[] overrideSortedWordSeparators){
  mSortedSymbolsPrecededBySpace=model.mSortedSymbolsPrecededBySpace;
  mSortedSymbolsFollowedBySpace=model.mSortedSymbolsFollowedBySpace;
  mSortedSymbolsClusteringTogether=model.mSortedSymbolsClusteringTogether;
  mSortedWordConnectors=model.mSortedWordConnectors;
  mSortedWordSeparators=overrideSortedWordSeparators;
  mSuggestPuncList=model.mSuggestPuncList;
  mSentenceSeparator=model.mSentenceSeparator;
  mSentenceSeparatorAndSpace=model.mSentenceSeparatorAndSpace;
  mCurrentLanguageHasSpaces=model.mCurrentLanguageHasSpaces;
  mUsesAmericanTypography=model.mUsesAmericanTypography;
  mUsesGermanRules=model.mUsesGermanRules;
}",0.0762090864680019
87360,"private void helpTestGetSuggestionSpansAtWord(final int cursorPos){
  final MockInputMethodService mockInputMethodService=new MockInputMethodService();
  final RichInputConnection ic=new RichInputConnection(mockInputMethodService);
  final String[] SUGGESTIONS1={""String_Node_Str"",""String_Node_Str""};
  final String[] SUGGESTIONS2={""String_Node_Str"",""String_Node_Str""};
  SpannableString text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  TextRange r;
  SuggestionSpan[] suggestions;
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),10,16,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,2);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  MoreAsserts.assertEquals(suggestions[1].getSuggestions(),SUGGESTIONS2);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),5,16,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),10,20,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),5,20,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),5,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),5,20,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,0);
}","private void helpTestGetSuggestionSpansAtWord(final int cursorPos){
  final SpacingAndPunctuations SPACE=new SpacingAndPunctuations(mSpacingAndPunctuations,new int[]{Constants.CODE_SPACE});
  final MockInputMethodService mockInputMethodService=new MockInputMethodService();
  final RichInputConnection ic=new RichInputConnection(mockInputMethodService);
  final String[] SUGGESTIONS1={""String_Node_Str"",""String_Node_Str""};
  final String[] SUGGESTIONS2={""String_Node_Str"",""String_Node_Str""};
  SpannableString text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  TextRange r;
  SuggestionSpan[] suggestions;
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),10,16,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,2);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  MoreAsserts.assertEquals(suggestions[1].getSuggestions(),SUGGESTIONS2);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),5,16,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),10,20,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),5,20,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),5,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),5,20,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,0);
}",0.9819846426461902
87361,"public void testGetWordRangeAtCursor(){
  ExtractedText et=new ExtractedText();
  final MockInputMethodService mockInputMethodService=new MockInputMethodService();
  final RichInputConnection ic=new RichInputConnection(mockInputMethodService);
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  et.startOffset=0;
  et.selectionStart=7;
  TextRange r;
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(TAB,ScriptUtils.SCRIPT_LATIN);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"" + SUPPLEMENTARY_CHAR + ""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(StringUtils.toSortedCodePointArray(SUPPLEMENTARY_CHAR),ScriptUtils.SCRIPT_LATIN);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(HIRAGANA_WORD + ""String_Node_Str"",""String_Node_Str"" + GREEK_WORD,et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(StringUtils.toSortedCodePointArray(SUPPLEMENTARY_CHAR),ScriptUtils.SCRIPT_LATIN);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"" + GREEK_WORD,""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(StringUtils.toSortedCodePointArray(SUPPLEMENTARY_CHAR),ScriptUtils.SCRIPT_GREEK);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(GREEK_WORD,r.mWord));
}","public void testGetWordRangeAtCursor(){
  final SpacingAndPunctuations SPACE=new SpacingAndPunctuations(mSpacingAndPunctuations,new int[]{Constants.CODE_SPACE});
  final SpacingAndPunctuations TAB=new SpacingAndPunctuations(mSpacingAndPunctuations,new int[]{Constants.CODE_TAB});
  final int[] SPACE_TAB=StringUtils.toSortedCodePointArray(""String_Node_Str"");
  final String SUPPLEMENTARY_CHAR_STRING=""String_Node_Str"";
  final SpacingAndPunctuations SUPPLEMENTARY_CHAR=new SpacingAndPunctuations(mSpacingAndPunctuations,StringUtils.toSortedCodePointArray(SUPPLEMENTARY_CHAR_STRING));
  final String HIRAGANA_WORD=""String_Node_Str"";
  final String GREEK_WORD=""String_Node_Str"";
  ExtractedText et=new ExtractedText();
  final MockInputMethodService mockInputMethodService=new MockInputMethodService();
  final RichInputConnection ic=new RichInputConnection(mockInputMethodService);
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  et.startOffset=0;
  et.selectionStart=7;
  TextRange r;
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(TAB,ScriptUtils.SCRIPT_LATIN);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"" + SUPPLEMENTARY_CHAR_STRING + ""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(SUPPLEMENTARY_CHAR,ScriptUtils.SCRIPT_LATIN);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(HIRAGANA_WORD + ""String_Node_Str"",""String_Node_Str"" + GREEK_WORD,et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(SUPPLEMENTARY_CHAR,ScriptUtils.SCRIPT_LATIN);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"" + GREEK_WORD,""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(SUPPLEMENTARY_CHAR,ScriptUtils.SCRIPT_GREEK);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(GREEK_WORD,r.mWord));
}",0.8223062381852552
87362,"/** 
 * Returns the text surrounding the cursor.
 * @param sortedSeparators a sorted array of code points that split words.
 * @param scriptId the script we consider to be writing words, as one of ScriptUtils.SCRIPT_
 * @return a range containing the text surrounding the cursor
 */
public TextRange getWordRangeAtCursor(final int[] sortedSeparators,final int scriptId){
  mIC=mParent.getCurrentInputConnection();
  if (mIC == null) {
    return null;
  }
  final CharSequence before=mIC.getTextBeforeCursor(Constants.EDITOR_CONTENTS_CACHE_SIZE,InputConnection.GET_TEXT_WITH_STYLES);
  final CharSequence after=mIC.getTextAfterCursor(Constants.EDITOR_CONTENTS_CACHE_SIZE,InputConnection.GET_TEXT_WITH_STYLES);
  if (before == null || after == null) {
    return null;
  }
  int startIndexInBefore=before.length();
  while (startIndexInBefore > 0) {
    final int codePoint=Character.codePointBefore(before,startIndexInBefore);
    if (isSeparator(codePoint,sortedSeparators) || !ScriptUtils.isLetterPartOfScript(codePoint,scriptId)) {
      break;
    }
    --startIndexInBefore;
    if (Character.isSupplementaryCodePoint(codePoint)) {
      --startIndexInBefore;
    }
  }
  int endIndexInAfter=-1;
  while (++endIndexInAfter < after.length()) {
    final int codePoint=Character.codePointAt(after,endIndexInAfter);
    if (isSeparator(codePoint,sortedSeparators) || !ScriptUtils.isLetterPartOfScript(codePoint,scriptId)) {
      break;
    }
    if (Character.isSupplementaryCodePoint(codePoint)) {
      ++endIndexInAfter;
    }
  }
  final boolean hasUrlSpans=SpannableStringUtils.hasUrlSpans(before,startIndexInBefore,before.length()) || SpannableStringUtils.hasUrlSpans(after,0,endIndexInAfter);
  return new TextRange(SpannableStringUtils.concatWithNonParagraphSuggestionSpansOnly(before,after),startIndexInBefore,before.length() + endIndexInAfter,before.length(),hasUrlSpans);
}","/** 
 * Returns the text surrounding the cursor.
 * @param spacingAndPunctuations the rules for spacing and punctuation
 * @param scriptId the script we consider to be writing words, as one of ScriptUtils.SCRIPT_
 * @return a range containing the text surrounding the cursor
 */
public TextRange getWordRangeAtCursor(final SpacingAndPunctuations spacingAndPunctuations,final int scriptId){
  mIC=mParent.getCurrentInputConnection();
  if (mIC == null) {
    return null;
  }
  final CharSequence before=mIC.getTextBeforeCursor(Constants.EDITOR_CONTENTS_CACHE_SIZE,InputConnection.GET_TEXT_WITH_STYLES);
  final CharSequence after=mIC.getTextAfterCursor(Constants.EDITOR_CONTENTS_CACHE_SIZE,InputConnection.GET_TEXT_WITH_STYLES);
  if (before == null || after == null) {
    return null;
  }
  int startIndexInBefore=before.length();
  while (startIndexInBefore > 0) {
    final int codePoint=Character.codePointBefore(before,startIndexInBefore);
    if (!isPartOfCompositionForScript(codePoint,spacingAndPunctuations,scriptId)) {
      break;
    }
    --startIndexInBefore;
    if (Character.isSupplementaryCodePoint(codePoint)) {
      --startIndexInBefore;
    }
  }
  int endIndexInAfter=-1;
  while (++endIndexInAfter < after.length()) {
    final int codePoint=Character.codePointAt(after,endIndexInAfter);
    if (!isPartOfCompositionForScript(codePoint,spacingAndPunctuations,scriptId)) {
      break;
    }
    if (Character.isSupplementaryCodePoint(codePoint)) {
      ++endIndexInAfter;
    }
  }
  final boolean hasUrlSpans=SpannableStringUtils.hasUrlSpans(before,startIndexInBefore,before.length()) || SpannableStringUtils.hasUrlSpans(after,0,endIndexInAfter);
  return new TextRange(SpannableStringUtils.concatWithNonParagraphSuggestionSpansOnly(before,after),startIndexInBefore,before.length() + endIndexInAfter,before.length(),hasUrlSpans);
}",0.8838451268357811
87363,"/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 * @param settingsValues the current values of the settings.
 * @param shouldIncludeResumedWordInSuggestions whether to include the word on which we resumesuggestions in the suggestion list.
 */
public void restartSuggestionsOnWordTouchedByCursor(final SettingsValues settingsValues,final boolean shouldIncludeResumedWordInSuggestions,final int currentKeyboardScriptId){
  if (settingsValues.isBrokenByRecorrection() || !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces || !settingsValues.needsToLookupSuggestions()|| mInputLogicHandler.isInBatchInput()|| mConnection.hasSelection()|| mConnection.getExpectedSelectionStart() < 0) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  final int expectedCursorPosition=mConnection.getExpectedSelectionStart();
  if (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations)) {
    mWordComposer.setCapitalizedModeAtStartComposingTime(WordComposer.CAPS_MODE_OFF);
    mLatinIME.mHandler.postUpdateSuggestionStrip(SuggestedWords.INPUT_STYLE_RECORRECTION);
    return;
  }
  final TextRange range=mConnection.getWordRangeAtCursor(settingsValues.mSpacingAndPunctuations.mSortedWordSeparators,currentKeyboardScriptId);
  if (null == range)   return;
  if (range.length() <= 0) {
    mLatinIME.setNeutralSuggestionStrip();
    return;
  }
  if (range.mHasUrlSpans)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > expectedCursorPosition)   return;
  final ArrayList<SuggestedWordInfo> suggestions=new ArrayList<>();
  final String typedWord=range.mWord.toString();
  if (shouldIncludeResumedWordInSuggestions) {
    suggestions.add(new SuggestedWordInfo(typedWord,SuggestedWords.MAX_SUGGESTIONS + 1,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  if (!isResumableWord(settingsValues,typedWord)) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestedWords.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  final int[] codePoints=StringUtils.toCodePointArray(typedWord);
  final PrevWordsInfo prevWordsInfo=getPrevWordsInfoFromNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,0 == numberOfCharsInWordBeforeCursor ? 1 : 2);
  mWordComposer.setComposingWord(codePoints,mLatinIME.getCoordinatesForCurrentKeyboard(codePoints));
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.maybeMoveTheCursorAroundAndRestoreToWorkaroundABug();
  mConnection.setComposingRegion(expectedCursorPosition - numberOfCharsInWordBeforeCursor,expectedCursorPosition + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.size() <= (shouldIncludeResumedWordInSuggestions ? 1 : 0)) {
    mInputLogicHandler.getSuggestedWords(Suggest.SESSION_ID_TYPING,SuggestedWords.NOT_A_SEQUENCE_NUMBER,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1 && !shouldIncludeResumedWordInSuggestions) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWordForRecorrection();
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        mIsAutoCorrectionIndicatorOn=false;
        mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,null,typedWord,false,false,false,SuggestedWords.INPUT_STYLE_RECORRECTION,SuggestedWords.NOT_A_SEQUENCE_NUMBER);
    mIsAutoCorrectionIndicatorOn=false;
    mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
  }
}","/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 * @param settingsValues the current values of the settings.
 * @param shouldIncludeResumedWordInSuggestions whether to include the word on which we resumesuggestions in the suggestion list.
 */
public void restartSuggestionsOnWordTouchedByCursor(final SettingsValues settingsValues,final boolean shouldIncludeResumedWordInSuggestions,final int currentKeyboardScriptId){
  if (settingsValues.isBrokenByRecorrection() || !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces || !settingsValues.needsToLookupSuggestions()|| mInputLogicHandler.isInBatchInput()|| mConnection.hasSelection()|| mConnection.getExpectedSelectionStart() < 0) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  final int expectedCursorPosition=mConnection.getExpectedSelectionStart();
  if (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations)) {
    mWordComposer.setCapitalizedModeAtStartComposingTime(WordComposer.CAPS_MODE_OFF);
    mLatinIME.mHandler.postUpdateSuggestionStrip(SuggestedWords.INPUT_STYLE_RECORRECTION);
    return;
  }
  final TextRange range=mConnection.getWordRangeAtCursor(settingsValues.mSpacingAndPunctuations,currentKeyboardScriptId);
  if (null == range)   return;
  if (range.length() <= 0) {
    mLatinIME.setNeutralSuggestionStrip();
    return;
  }
  if (range.mHasUrlSpans)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > expectedCursorPosition)   return;
  final ArrayList<SuggestedWordInfo> suggestions=new ArrayList<>();
  final String typedWord=range.mWord.toString();
  if (shouldIncludeResumedWordInSuggestions) {
    suggestions.add(new SuggestedWordInfo(typedWord,SuggestedWords.MAX_SUGGESTIONS + 1,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  if (!isResumableWord(settingsValues,typedWord)) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestedWords.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  final int[] codePoints=StringUtils.toCodePointArray(typedWord);
  final PrevWordsInfo prevWordsInfo=getPrevWordsInfoFromNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,0 == numberOfCharsInWordBeforeCursor ? 1 : 2);
  mWordComposer.setComposingWord(codePoints,mLatinIME.getCoordinatesForCurrentKeyboard(codePoints));
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.maybeMoveTheCursorAroundAndRestoreToWorkaroundABug();
  mConnection.setComposingRegion(expectedCursorPosition - numberOfCharsInWordBeforeCursor,expectedCursorPosition + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.size() <= (shouldIncludeResumedWordInSuggestions ? 1 : 0)) {
    mInputLogicHandler.getSuggestedWords(Suggest.SESSION_ID_TYPING,SuggestedWords.NOT_A_SEQUENCE_NUMBER,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1 && !shouldIncludeResumedWordInSuggestions) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWordForRecorrection();
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        mIsAutoCorrectionIndicatorOn=false;
        mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,null,typedWord,false,false,false,SuggestedWords.INPUT_STYLE_RECORRECTION,SuggestedWords.NOT_A_SEQUENCE_NUMBER);
    mIsAutoCorrectionIndicatorOn=false;
    mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
  }
}",0.9974677716390424
87364,"public SpacingAndPunctuations(final Resources res){
  mSortedSymbolsPrecededBySpace=StringUtils.toSortedCodePointArray(res.getString(R.string.symbols_preceded_by_space));
  mSortedSymbolsFollowedBySpace=StringUtils.toSortedCodePointArray(res.getString(R.string.symbols_followed_by_space));
  mSortedSymbolsClusteringTogether=StringUtils.toSortedCodePointArray(res.getString(R.string.symbols_clustering_together));
  mSortedWordConnectors=StringUtils.toSortedCodePointArray(res.getString(R.string.symbols_word_connectors));
  mSortedWordSeparators=StringUtils.toSortedCodePointArray(res.getString(R.string.symbols_word_separators));
  mSentenceSeparator=res.getInteger(R.integer.sentence_separator);
  mSentenceSeparatorAndSpace=new String(new int[]{mSentenceSeparator,Constants.CODE_SPACE},0,2);
  mCurrentLanguageHasSpaces=res.getBoolean(R.bool.current_language_has_spaces);
  final Locale locale=res.getConfiguration().locale;
  mUsesAmericanTypography=Locale.ENGLISH.getLanguage().equals(locale.getLanguage());
  mUsesGermanRules=Locale.GERMAN.getLanguage().equals(locale.getLanguage());
  final String[] suggestPuncsSpec=MoreKeySpec.splitKeySpecs(res.getString(R.string.suggested_punctuations));
  mSuggestPuncList=PunctuationSuggestions.newPunctuationSuggestions(suggestPuncsSpec);
}","@UsedForTesting public SpacingAndPunctuations(final SpacingAndPunctuations model,final int[] overrideSortedWordSeparators){
  mSortedSymbolsPrecededBySpace=model.mSortedSymbolsPrecededBySpace;
  mSortedSymbolsFollowedBySpace=model.mSortedSymbolsFollowedBySpace;
  mSortedSymbolsClusteringTogether=model.mSortedSymbolsClusteringTogether;
  mSortedWordConnectors=model.mSortedWordConnectors;
  mSortedWordSeparators=overrideSortedWordSeparators;
  mSuggestPuncList=model.mSuggestPuncList;
  mSentenceSeparator=model.mSentenceSeparator;
  mSentenceSeparatorAndSpace=model.mSentenceSeparatorAndSpace;
  mCurrentLanguageHasSpaces=model.mCurrentLanguageHasSpaces;
  mUsesAmericanTypography=model.mUsesAmericanTypography;
  mUsesGermanRules=model.mUsesGermanRules;
}",0.0762090864680019
87365,"private void helpTestGetSuggestionSpansAtWord(final int cursorPos){
  final MockInputMethodService mockInputMethodService=new MockInputMethodService();
  final RichInputConnection ic=new RichInputConnection(mockInputMethodService);
  final String[] SUGGESTIONS1={""String_Node_Str"",""String_Node_Str""};
  final String[] SUGGESTIONS2={""String_Node_Str"",""String_Node_Str""};
  SpannableString text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  TextRange r;
  SuggestionSpan[] suggestions;
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),10,16,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,2);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  MoreAsserts.assertEquals(suggestions[1].getSuggestions(),SUGGESTIONS2);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),5,16,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),10,20,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),5,20,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),5,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),5,20,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,0);
}","private void helpTestGetSuggestionSpansAtWord(final int cursorPos){
  final SpacingAndPunctuations SPACE=new SpacingAndPunctuations(mSpacingAndPunctuations,new int[]{Constants.CODE_SPACE});
  final MockInputMethodService mockInputMethodService=new MockInputMethodService();
  final RichInputConnection ic=new RichInputConnection(mockInputMethodService);
  final String[] SUGGESTIONS1={""String_Node_Str"",""String_Node_Str""};
  final String[] SUGGESTIONS2={""String_Node_Str"",""String_Node_Str""};
  SpannableString text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  TextRange r;
  SuggestionSpan[] suggestions;
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),10,16,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,2);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  MoreAsserts.assertEquals(suggestions[1].getSuggestions(),SUGGESTIONS2);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),5,16,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),10,20,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),10,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),5,20,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,1);
  MoreAsserts.assertEquals(suggestions[0].getSuggestions(),SUGGESTIONS1);
  text=new SpannableString(""String_Node_Str"");
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS1,0),5,16,0);
  text.setSpan(new SuggestionSpan(Locale.ENGLISH,SUGGESTIONS2,0),5,20,0);
  mockInputMethodService.setInputConnection(new MockConnection(text,cursorPos));
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  suggestions=r.getSuggestionSpansAtWord();
  assertEquals(suggestions.length,0);
}",0.9819846426461902
87366,"public void testGetWordRangeAtCursor(){
  ExtractedText et=new ExtractedText();
  final MockInputMethodService mockInputMethodService=new MockInputMethodService();
  final RichInputConnection ic=new RichInputConnection(mockInputMethodService);
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  et.startOffset=0;
  et.selectionStart=7;
  TextRange r;
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(TAB,ScriptUtils.SCRIPT_LATIN);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"" + SUPPLEMENTARY_CHAR + ""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(StringUtils.toSortedCodePointArray(SUPPLEMENTARY_CHAR),ScriptUtils.SCRIPT_LATIN);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(HIRAGANA_WORD + ""String_Node_Str"",""String_Node_Str"" + GREEK_WORD,et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(StringUtils.toSortedCodePointArray(SUPPLEMENTARY_CHAR),ScriptUtils.SCRIPT_LATIN);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"" + GREEK_WORD,""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(StringUtils.toSortedCodePointArray(SUPPLEMENTARY_CHAR),ScriptUtils.SCRIPT_GREEK);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(GREEK_WORD,r.mWord));
}","public void testGetWordRangeAtCursor(){
  final SpacingAndPunctuations SPACE=new SpacingAndPunctuations(mSpacingAndPunctuations,new int[]{Constants.CODE_SPACE});
  final SpacingAndPunctuations TAB=new SpacingAndPunctuations(mSpacingAndPunctuations,new int[]{Constants.CODE_TAB});
  final int[] SPACE_TAB=StringUtils.toSortedCodePointArray(""String_Node_Str"");
  final String SUPPLEMENTARY_CHAR_STRING=""String_Node_Str"";
  final SpacingAndPunctuations SUPPLEMENTARY_CHAR=new SpacingAndPunctuations(mSpacingAndPunctuations,StringUtils.toSortedCodePointArray(SUPPLEMENTARY_CHAR_STRING));
  final String HIRAGANA_WORD=""String_Node_Str"";
  final String GREEK_WORD=""String_Node_Str"";
  ExtractedText et=new ExtractedText();
  final MockInputMethodService mockInputMethodService=new MockInputMethodService();
  final RichInputConnection ic=new RichInputConnection(mockInputMethodService);
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  et.startOffset=0;
  et.selectionStart=7;
  TextRange r;
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(SPACE,ScriptUtils.SCRIPT_LATIN);
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(TAB,ScriptUtils.SCRIPT_LATIN);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"" + SUPPLEMENTARY_CHAR_STRING + ""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(SUPPLEMENTARY_CHAR,ScriptUtils.SCRIPT_LATIN);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(HIRAGANA_WORD + ""String_Node_Str"",""String_Node_Str"" + GREEK_WORD,et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(SUPPLEMENTARY_CHAR,ScriptUtils.SCRIPT_LATIN);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(""String_Node_Str"",r.mWord));
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"" + GREEK_WORD,""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(SUPPLEMENTARY_CHAR,ScriptUtils.SCRIPT_GREEK);
  ic.endBatchEdit();
  assertTrue(TextUtils.equals(GREEK_WORD,r.mWord));
}",0.8223062381852552
87367,"public static CharSequence getTextWithSuggestionSpan(final Context context,final String pickedWord,final SuggestedWords suggestedWords){
  if (TextUtils.isEmpty(pickedWord) || suggestedWords.isEmpty() || suggestedWords.mIsPrediction|| suggestedWords.isPunctuationSuggestions()) {
    return pickedWord;
  }
  final ArrayList<String> suggestionsList=new ArrayList<>();
  for (int i=0; i < suggestedWords.size(); ++i) {
    if (suggestionsList.size() >= SuggestionSpan.SUGGESTIONS_MAX_SIZE) {
      break;
    }
    final SuggestedWordInfo info=suggestedWords.getInfo(i);
    if (info.isKindOf(SuggestedWordInfo.KIND_PREDICTION)) {
      continue;
    }
    final String word=suggestedWords.getWord(i);
    if (!TextUtils.equals(pickedWord,word)) {
      suggestionsList.add(word.toString());
    }
  }
  final SuggestionSpan suggestionSpan=new SuggestionSpan(context,null,suggestionsList.toArray(new String[suggestionsList.size()]),0,SuggestionSpanPickedNotificationReceiver.class);
  final Spannable spannable=new SpannableString(pickedWord);
  spannable.setSpan(suggestionSpan,0,pickedWord.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  return spannable;
}","public static CharSequence getTextWithSuggestionSpan(final Context context,final String pickedWord,final SuggestedWords suggestedWords){
  if (TextUtils.isEmpty(pickedWord) || suggestedWords.isEmpty() || suggestedWords.isPrediction()|| suggestedWords.isPunctuationSuggestions()) {
    return pickedWord;
  }
  final ArrayList<String> suggestionsList=new ArrayList<>();
  for (int i=0; i < suggestedWords.size(); ++i) {
    if (suggestionsList.size() >= SuggestionSpan.SUGGESTIONS_MAX_SIZE) {
      break;
    }
    final SuggestedWordInfo info=suggestedWords.getInfo(i);
    if (info.isKindOf(SuggestedWordInfo.KIND_PREDICTION)) {
      continue;
    }
    final String word=suggestedWords.getWord(i);
    if (!TextUtils.equals(pickedWord,word)) {
      suggestionsList.add(word.toString());
    }
  }
  final SuggestionSpan suggestionSpan=new SuggestionSpan(context,null,suggestionsList.toArray(new String[suggestionsList.size()]),0,SuggestionSpanPickedNotificationReceiver.class);
  final Spannable spannable=new SpannableString(pickedWord);
  spannable.setSpan(suggestionSpan,0,pickedWord.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
  return spannable;
}",0.9978383052313012
87368,"@Override public void onDisplayCompletions(final CompletionInfo[] applicationSpecifiedCompletions){
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"");
    if (applicationSpecifiedCompletions != null) {
      for (int i=0; i < applicationSpecifiedCompletions.length; i++) {
        Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ applicationSpecifiedCompletions[i]);
      }
    }
  }
  if (!mSettings.getCurrent().isApplicationSpecifiedCompletionsOn()) {
    return;
  }
  mHandler.cancelUpdateSuggestionStrip();
  if (applicationSpecifiedCompletions == null) {
    setNeutralSuggestionStrip();
    return;
  }
  final ArrayList<SuggestedWords.SuggestedWordInfo> applicationSuggestedWords=SuggestedWords.getFromApplicationSpecifiedCompletions(applicationSpecifiedCompletions);
  final SuggestedWords suggestedWords=new SuggestedWords(applicationSuggestedWords,null,false,false,false,false,SuggestedWords.INPUT_STYLE_APPLICATION_SPECIFIED);
  setSuggestedWords(suggestedWords);
}","@Override public void onDisplayCompletions(final CompletionInfo[] applicationSpecifiedCompletions){
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"");
    if (applicationSpecifiedCompletions != null) {
      for (int i=0; i < applicationSpecifiedCompletions.length; i++) {
        Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ applicationSpecifiedCompletions[i]);
      }
    }
  }
  if (!mSettings.getCurrent().isApplicationSpecifiedCompletionsOn()) {
    return;
  }
  mHandler.cancelUpdateSuggestionStrip();
  if (applicationSpecifiedCompletions == null) {
    setNeutralSuggestionStrip();
    return;
  }
  final ArrayList<SuggestedWords.SuggestedWordInfo> applicationSuggestedWords=SuggestedWords.getFromApplicationSpecifiedCompletions(applicationSpecifiedCompletions);
  final SuggestedWords suggestedWords=new SuggestedWords(applicationSuggestedWords,null,false,false,false,SuggestedWords.INPUT_STYLE_APPLICATION_SPECIFIED);
  setSuggestedWords(suggestedWords);
}",0.9969325153374232
87369,"private PunctuationSuggestions(final ArrayList<SuggestedWordInfo> punctuationsList){
  super(punctuationsList,null,false,false,false,false,INPUT_STYLE_NONE);
}","private PunctuationSuggestions(final ArrayList<SuggestedWordInfo> punctuationsList){
  super(punctuationsList,null,false,false,false,INPUT_STYLE_NONE);
}",0.9807692307692308
87370,"private void getSuggestedWordsForNonBatchInput(final WordComposer wordComposer,final PrevWordsInfo prevWordsInfo,final ProximityInfo proximityInfo,final SettingsValuesForSuggestion settingsValuesForSuggestion,final int inputStyle,final boolean isCorrectionEnabled,final int sequenceNumber,final OnGetSuggestedWordsCallback callback){
  final String typedWord=wordComposer.getTypedWord();
  final int trailingSingleQuotesCount=StringUtils.getTrailingSingleQuotesCount(typedWord);
  final String consideredWord=trailingSingleQuotesCount > 0 ? typedWord.substring(0,typedWord.length() - trailingSingleQuotesCount) : typedWord;
  final SuggestionResults suggestionResults=mDictionaryFacilitator.getSuggestionResults(wordComposer,prevWordsInfo,proximityInfo,settingsValuesForSuggestion,SESSION_ID_TYPING);
  final ArrayList<SuggestedWordInfo> suggestionsContainer=getTransformedSuggestedWordInfoList(wordComposer,suggestionResults,trailingSingleQuotesCount);
  final boolean didRemoveTypedWord=SuggestedWordInfo.removeDups(wordComposer.getTypedWord(),suggestionsContainer);
  final String whitelistedWord=getWhitelistedWordOrNull(suggestionsContainer);
  final boolean resultsArePredictions=!wordComposer.isComposingWord();
  final boolean allowsToBeAutoCorrected=(null != whitelistedWord) || (consideredWord.length() > 1 && !didRemoveTypedWord);
  final boolean hasAutoCorrection;
  if (!isCorrectionEnabled || !allowsToBeAutoCorrected || resultsArePredictions|| suggestionResults.isEmpty()|| wordComposer.hasDigits()|| wordComposer.isMostlyCaps()|| wordComposer.isResumed()|| !mDictionaryFacilitator.hasInitializedMainDictionary()|| suggestionResults.first().isKindOf(SuggestedWordInfo.KIND_SHORTCUT)) {
    hasAutoCorrection=false;
  }
 else {
    hasAutoCorrection=AutoCorrectionUtils.suggestionExceedsAutoCorrectionThreshold(suggestionResults.first(),consideredWord,mAutoCorrectionThreshold);
  }
  if (!TextUtils.isEmpty(typedWord)) {
    suggestionsContainer.add(0,new SuggestedWordInfo(typedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  final ArrayList<SuggestedWordInfo> suggestionsList;
  if (DBG && !suggestionsContainer.isEmpty()) {
    suggestionsList=getSuggestionsInfoListWithDebugInfo(typedWord,suggestionsContainer);
  }
 else {
    suggestionsList=suggestionsContainer;
  }
  callback.onGetSuggestedWords(new SuggestedWords(suggestionsList,suggestionResults.mRawSuggestions,!resultsArePredictions && !allowsToBeAutoCorrected,hasAutoCorrection,false,resultsArePredictions,inputStyle,sequenceNumber));
}","private void getSuggestedWordsForNonBatchInput(final WordComposer wordComposer,final PrevWordsInfo prevWordsInfo,final ProximityInfo proximityInfo,final SettingsValuesForSuggestion settingsValuesForSuggestion,final int inputStyleIfNotPrediction,final boolean isCorrectionEnabled,final int sequenceNumber,final OnGetSuggestedWordsCallback callback){
  final String typedWord=wordComposer.getTypedWord();
  final int trailingSingleQuotesCount=StringUtils.getTrailingSingleQuotesCount(typedWord);
  final String consideredWord=trailingSingleQuotesCount > 0 ? typedWord.substring(0,typedWord.length() - trailingSingleQuotesCount) : typedWord;
  final SuggestionResults suggestionResults=mDictionaryFacilitator.getSuggestionResults(wordComposer,prevWordsInfo,proximityInfo,settingsValuesForSuggestion,SESSION_ID_TYPING);
  final ArrayList<SuggestedWordInfo> suggestionsContainer=getTransformedSuggestedWordInfoList(wordComposer,suggestionResults,trailingSingleQuotesCount);
  final boolean didRemoveTypedWord=SuggestedWordInfo.removeDups(wordComposer.getTypedWord(),suggestionsContainer);
  final String whitelistedWord=getWhitelistedWordOrNull(suggestionsContainer);
  final boolean resultsArePredictions=!wordComposer.isComposingWord();
  final boolean allowsToBeAutoCorrected=(null != whitelistedWord) || (consideredWord.length() > 1 && !didRemoveTypedWord);
  final boolean hasAutoCorrection;
  if (!isCorrectionEnabled || !allowsToBeAutoCorrected || resultsArePredictions|| suggestionResults.isEmpty()|| wordComposer.hasDigits()|| wordComposer.isMostlyCaps()|| wordComposer.isResumed()|| !mDictionaryFacilitator.hasInitializedMainDictionary()|| suggestionResults.first().isKindOf(SuggestedWordInfo.KIND_SHORTCUT)) {
    hasAutoCorrection=false;
  }
 else {
    hasAutoCorrection=AutoCorrectionUtils.suggestionExceedsAutoCorrectionThreshold(suggestionResults.first(),consideredWord,mAutoCorrectionThreshold);
  }
  if (!TextUtils.isEmpty(typedWord)) {
    suggestionsContainer.add(0,new SuggestedWordInfo(typedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  final ArrayList<SuggestedWordInfo> suggestionsList;
  if (DBG && !suggestionsContainer.isEmpty()) {
    suggestionsList=getSuggestionsInfoListWithDebugInfo(typedWord,suggestionsContainer);
  }
 else {
    suggestionsList=suggestionsContainer;
  }
  final int inputStyle=resultsArePredictions ? SuggestedWords.INPUT_STYLE_PREDICTION : inputStyleIfNotPrediction;
  callback.onGetSuggestedWords(new SuggestedWords(suggestionsList,suggestionResults.mRawSuggestions,!resultsArePredictions && !allowsToBeAutoCorrected,hasAutoCorrection,false,inputStyle,sequenceNumber));
}",0.9719487274753856
87371,"private void getSuggestedWordsForBatchInput(final WordComposer wordComposer,final PrevWordsInfo prevWordsInfo,final ProximityInfo proximityInfo,final SettingsValuesForSuggestion settingsValuesForSuggestion,final int inputStyle,final int sequenceNumber,final OnGetSuggestedWordsCallback callback){
  final SuggestionResults suggestionResults=mDictionaryFacilitator.getSuggestionResults(wordComposer,prevWordsInfo,proximityInfo,settingsValuesForSuggestion,SESSION_ID_GESTURE);
  final ArrayList<SuggestedWordInfo> suggestionsContainer=new ArrayList<>(suggestionResults);
  final int suggestionsCount=suggestionsContainer.size();
  final boolean isFirstCharCapitalized=wordComposer.wasShiftedNoLock();
  final boolean isAllUpperCase=wordComposer.isAllUpperCase();
  if (isFirstCharCapitalized || isAllUpperCase) {
    for (int i=0; i < suggestionsCount; ++i) {
      final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
      final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,suggestionResults.mLocale,isAllUpperCase,isFirstCharCapitalized,0);
      suggestionsContainer.set(i,transformedWordInfo);
    }
  }
  if (suggestionsContainer.size() > 1 && TextUtils.equals(suggestionsContainer.get(0).mWord,wordComposer.getRejectedBatchModeSuggestion())) {
    final SuggestedWordInfo rejected=suggestionsContainer.remove(0);
    suggestionsContainer.add(1,rejected);
  }
  SuggestedWordInfo.removeDups(null,suggestionsContainer);
  for (int i=suggestionsContainer.size() - 1; i >= 0; --i) {
    if (suggestionsContainer.get(i).mScore < SUPPRESS_SUGGEST_THRESHOLD) {
      suggestionsContainer.remove(i);
    }
  }
  callback.onGetSuggestedWords(new SuggestedWords(suggestionsContainer,suggestionResults.mRawSuggestions,true,false,false,false,inputStyle,sequenceNumber));
}","private void getSuggestedWordsForBatchInput(final WordComposer wordComposer,final PrevWordsInfo prevWordsInfo,final ProximityInfo proximityInfo,final SettingsValuesForSuggestion settingsValuesForSuggestion,final int inputStyle,final int sequenceNumber,final OnGetSuggestedWordsCallback callback){
  final SuggestionResults suggestionResults=mDictionaryFacilitator.getSuggestionResults(wordComposer,prevWordsInfo,proximityInfo,settingsValuesForSuggestion,SESSION_ID_GESTURE);
  final ArrayList<SuggestedWordInfo> suggestionsContainer=new ArrayList<>(suggestionResults);
  final int suggestionsCount=suggestionsContainer.size();
  final boolean isFirstCharCapitalized=wordComposer.wasShiftedNoLock();
  final boolean isAllUpperCase=wordComposer.isAllUpperCase();
  if (isFirstCharCapitalized || isAllUpperCase) {
    for (int i=0; i < suggestionsCount; ++i) {
      final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
      final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,suggestionResults.mLocale,isAllUpperCase,isFirstCharCapitalized,0);
      suggestionsContainer.set(i,transformedWordInfo);
    }
  }
  if (suggestionsContainer.size() > 1 && TextUtils.equals(suggestionsContainer.get(0).mWord,wordComposer.getRejectedBatchModeSuggestion())) {
    final SuggestedWordInfo rejected=suggestionsContainer.remove(0);
    suggestionsContainer.add(1,rejected);
  }
  SuggestedWordInfo.removeDups(null,suggestionsContainer);
  for (int i=suggestionsContainer.size() - 1; i >= 0; --i) {
    if (suggestionsContainer.get(i).mScore < SUPPRESS_SUGGEST_THRESHOLD) {
      suggestionsContainer.remove(i);
    }
  }
  callback.onGetSuggestedWords(new SuggestedWords(suggestionsContainer,suggestionResults.mRawSuggestions,true,false,false,inputStyle,sequenceNumber));
}",0.998337950138504
87372,"public SuggestedWords(final ArrayList<SuggestedWordInfo> suggestedWordInfoList,final ArrayList<SuggestedWordInfo> rawSuggestions,final String typedWord,final boolean typedWordValid,final boolean willAutoCorrect,final boolean isObsoleteSuggestions,final boolean isPrediction,final int inputStyle,final int sequenceNumber){
  mSuggestedWordInfoList=suggestedWordInfoList;
  mRawSuggestions=rawSuggestions;
  mTypedWordValid=typedWordValid;
  mWillAutoCorrect=willAutoCorrect;
  mIsObsoleteSuggestions=isObsoleteSuggestions;
  mIsPrediction=isPrediction;
  mInputStyle=inputStyle;
  mSequenceNumber=sequenceNumber;
  mTypedWord=typedWord;
}","public SuggestedWords(final ArrayList<SuggestedWordInfo> suggestedWordInfoList,final ArrayList<SuggestedWordInfo> rawSuggestions,final String typedWord,final boolean typedWordValid,final boolean willAutoCorrect,final boolean isObsoleteSuggestions,final int inputStyle,final int sequenceNumber){
  mSuggestedWordInfoList=suggestedWordInfoList;
  mRawSuggestions=rawSuggestions;
  mTypedWordValid=typedWordValid;
  mWillAutoCorrect=willAutoCorrect;
  mIsObsoleteSuggestions=isObsoleteSuggestions;
  mInputStyle=inputStyle;
  mSequenceNumber=sequenceNumber;
  mTypedWord=typedWord;
}",0.9531635168447
87373,"public SuggestedWords getSuggestedWordsForLastWordOfPhraseGesture(){
  final ArrayList<SuggestedWordInfo> newSuggestions=new ArrayList<>();
  for (int i=0; i < mSuggestedWordInfoList.size(); ++i) {
    final SuggestedWordInfo info=mSuggestedWordInfoList.get(i);
    final int indexOfLastSpace=info.mWord.lastIndexOf(Constants.CODE_SPACE) + 1;
    final String lastWord=info.mWord.substring(indexOfLastSpace);
    newSuggestions.add(new SuggestedWordInfo(lastWord,info.mScore,info.mKindAndFlags,info.mSourceDict,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  return new SuggestedWords(newSuggestions,null,mTypedWordValid,mWillAutoCorrect,mIsObsoleteSuggestions,mIsPrediction,INPUT_STYLE_TAIL_BATCH);
}","public SuggestedWords getSuggestedWordsForLastWordOfPhraseGesture(){
  final ArrayList<SuggestedWordInfo> newSuggestions=new ArrayList<>();
  for (int i=0; i < mSuggestedWordInfoList.size(); ++i) {
    final SuggestedWordInfo info=mSuggestedWordInfoList.get(i);
    final int indexOfLastSpace=info.mWord.lastIndexOf(Constants.CODE_SPACE) + 1;
    final String lastWord=info.mWord.substring(indexOfLastSpace);
    newSuggestions.add(new SuggestedWordInfo(lastWord,info.mScore,info.mKindAndFlags,info.mSourceDict,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  return new SuggestedWords(newSuggestions,null,mTypedWordValid,mWillAutoCorrect,mIsObsoleteSuggestions,INPUT_STYLE_TAIL_BATCH);
}",0.9902912621359224
87374,"/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 * @param settingsValues the current values of the settings.
 * @param shouldIncludeResumedWordInSuggestions whether to include the word on which we resumesuggestions in the suggestion list.
 */
public void restartSuggestionsOnWordTouchedByCursor(final SettingsValues settingsValues,final boolean shouldIncludeResumedWordInSuggestions,final int currentKeyboardScriptId){
  if (settingsValues.isBrokenByRecorrection() || !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces || !settingsValues.needsToLookupSuggestions()|| mInputLogicHandler.isInBatchInput()|| mConnection.hasSelection()|| mConnection.getExpectedSelectionStart() < 0) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  final int expectedCursorPosition=mConnection.getExpectedSelectionStart();
  if (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations)) {
    mWordComposer.setCapitalizedModeAtStartComposingTime(WordComposer.CAPS_MODE_OFF);
    mLatinIME.mHandler.postUpdateSuggestionStrip(SuggestedWords.INPUT_STYLE_RECORRECTION);
    return;
  }
  final TextRange range=mConnection.getWordRangeAtCursor(settingsValues.mSpacingAndPunctuations.mSortedWordSeparators,currentKeyboardScriptId);
  if (null == range)   return;
  if (range.length() <= 0) {
    mLatinIME.setNeutralSuggestionStrip();
    return;
  }
  if (range.mHasUrlSpans)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > expectedCursorPosition)   return;
  final ArrayList<SuggestedWordInfo> suggestions=new ArrayList<>();
  final String typedWord=range.mWord.toString();
  if (shouldIncludeResumedWordInSuggestions) {
    suggestions.add(new SuggestedWordInfo(typedWord,SuggestedWords.MAX_SUGGESTIONS + 1,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  if (!isResumableWord(settingsValues,typedWord)) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestedWords.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  final int[] codePoints=StringUtils.toCodePointArray(typedWord);
  final PrevWordsInfo prevWordsInfo=getPrevWordsInfoFromNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,0 == numberOfCharsInWordBeforeCursor ? 1 : 2);
  mWordComposer.setComposingWord(codePoints,mLatinIME.getCoordinatesForCurrentKeyboard(codePoints));
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.maybeMoveTheCursorAroundAndRestoreToWorkaroundABug();
  mConnection.setComposingRegion(expectedCursorPosition - numberOfCharsInWordBeforeCursor,expectedCursorPosition + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.size() <= (shouldIncludeResumedWordInSuggestions ? 1 : 0)) {
    mInputLogicHandler.getSuggestedWords(Suggest.SESSION_ID_TYPING,SuggestedWords.NOT_A_SEQUENCE_NUMBER,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1 && !shouldIncludeResumedWordInSuggestions) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord(SuggestedWords.INPUT_STYLE_RECORRECTION);
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        mIsAutoCorrectionIndicatorOn=false;
        mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,null,typedWord,false,false,false,false,SuggestedWords.INPUT_STYLE_RECORRECTION,SuggestedWords.NOT_A_SEQUENCE_NUMBER);
    mIsAutoCorrectionIndicatorOn=false;
    mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
  }
}","/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 * @param settingsValues the current values of the settings.
 * @param shouldIncludeResumedWordInSuggestions whether to include the word on which we resumesuggestions in the suggestion list.
 */
public void restartSuggestionsOnWordTouchedByCursor(final SettingsValues settingsValues,final boolean shouldIncludeResumedWordInSuggestions,final int currentKeyboardScriptId){
  if (settingsValues.isBrokenByRecorrection() || !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces || !settingsValues.needsToLookupSuggestions()|| mInputLogicHandler.isInBatchInput()|| mConnection.hasSelection()|| mConnection.getExpectedSelectionStart() < 0) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  final int expectedCursorPosition=mConnection.getExpectedSelectionStart();
  if (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations)) {
    mWordComposer.setCapitalizedModeAtStartComposingTime(WordComposer.CAPS_MODE_OFF);
    mLatinIME.mHandler.postUpdateSuggestionStrip(SuggestedWords.INPUT_STYLE_RECORRECTION);
    return;
  }
  final TextRange range=mConnection.getWordRangeAtCursor(settingsValues.mSpacingAndPunctuations.mSortedWordSeparators,currentKeyboardScriptId);
  if (null == range)   return;
  if (range.length() <= 0) {
    mLatinIME.setNeutralSuggestionStrip();
    return;
  }
  if (range.mHasUrlSpans)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > expectedCursorPosition)   return;
  final ArrayList<SuggestedWordInfo> suggestions=new ArrayList<>();
  final String typedWord=range.mWord.toString();
  if (shouldIncludeResumedWordInSuggestions) {
    suggestions.add(new SuggestedWordInfo(typedWord,SuggestedWords.MAX_SUGGESTIONS + 1,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  if (!isResumableWord(settingsValues,typedWord)) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestedWords.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  final int[] codePoints=StringUtils.toCodePointArray(typedWord);
  final PrevWordsInfo prevWordsInfo=getPrevWordsInfoFromNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,0 == numberOfCharsInWordBeforeCursor ? 1 : 2);
  mWordComposer.setComposingWord(codePoints,mLatinIME.getCoordinatesForCurrentKeyboard(codePoints));
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.maybeMoveTheCursorAroundAndRestoreToWorkaroundABug();
  mConnection.setComposingRegion(expectedCursorPosition - numberOfCharsInWordBeforeCursor,expectedCursorPosition + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.size() <= (shouldIncludeResumedWordInSuggestions ? 1 : 0)) {
    mInputLogicHandler.getSuggestedWords(Suggest.SESSION_ID_TYPING,SuggestedWords.NOT_A_SEQUENCE_NUMBER,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1 && !shouldIncludeResumedWordInSuggestions) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWordForRecorrection();
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        mIsAutoCorrectionIndicatorOn=false;
        mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,null,typedWord,false,false,false,SuggestedWords.INPUT_STYLE_RECORRECTION,SuggestedWords.NOT_A_SEQUENCE_NUMBER);
    mIsAutoCorrectionIndicatorOn=false;
    mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
  }
}",0.9931350114416476
87375,"@Override public void onGetSuggestedWords(final SuggestedWords suggestedWordsIncludingTypedWord){
  final SuggestedWords suggestedWords;
  if (suggestedWordsIncludingTypedWord.size() > 1 && !shouldIncludeResumedWordInSuggestions) {
    suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord(SuggestedWords.INPUT_STYLE_RECORRECTION);
  }
 else {
    suggestedWords=suggestedWordsIncludingTypedWord;
  }
  mIsAutoCorrectionIndicatorOn=false;
  mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
}","@Override public void onGetSuggestedWords(final SuggestedWords suggestedWordsIncludingTypedWord){
  final SuggestedWords suggestedWords;
  if (suggestedWordsIncludingTypedWord.size() > 1 && !shouldIncludeResumedWordInSuggestions) {
    suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWordForRecorrection();
  }
 else {
    suggestedWords=suggestedWordsIncludingTypedWord;
  }
  mIsAutoCorrectionIndicatorOn=false;
  mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
}",0.9476744186046512
87376,"/** 
 * Make a   {@link com.android.inputmethod.latin.SuggestedWords} object containing a typed wordand obsolete suggestions. See  {@link com.android.inputmethod.latin.SuggestedWords#getTypedWordAndPreviousSuggestions(String,com.android.inputmethod.latin.SuggestedWords)}.
 * @param typedWord The typed word as a string.
 * @param previousSuggestedWords The previously suggested words.
 * @return Obsolete suggestions with the newly typed word.
 */
private SuggestedWords retrieveOlderSuggestions(final String typedWord,final SuggestedWords previousSuggestedWords){
  final SuggestedWords oldSuggestedWords=previousSuggestedWords.isPunctuationSuggestions() ? SuggestedWords.EMPTY : previousSuggestedWords;
  final ArrayList<SuggestedWords.SuggestedWordInfo> typedWordAndPreviousSuggestions=SuggestedWords.getTypedWordAndPreviousSuggestions(typedWord,oldSuggestedWords);
  return new SuggestedWords(typedWordAndPreviousSuggestions,null,false,false,true,false,oldSuggestedWords.mInputStyle);
}","/** 
 * Make a   {@link com.android.inputmethod.latin.SuggestedWords} object containing a typed wordand obsolete suggestions. See  {@link com.android.inputmethod.latin.SuggestedWords#getTypedWordAndPreviousSuggestions(String,com.android.inputmethod.latin.SuggestedWords)}.
 * @param typedWord The typed word as a string.
 * @param previousSuggestedWords The previously suggested words.
 * @return Obsolete suggestions with the newly typed word.
 */
private SuggestedWords retrieveOlderSuggestions(final String typedWord,final SuggestedWords previousSuggestedWords){
  final SuggestedWords oldSuggestedWords=previousSuggestedWords.isPunctuationSuggestions() ? SuggestedWords.EMPTY : previousSuggestedWords;
  final ArrayList<SuggestedWords.SuggestedWordInfo> typedWordAndPreviousSuggestions=SuggestedWords.getTypedWordAndPreviousSuggestions(typedWord,oldSuggestedWords);
  return new SuggestedWords(typedWordAndPreviousSuggestions,null,false,false,true,oldSuggestedWords.mInputStyle);
}",0.9969635627530364
87377,"/** 
 * Handle a functional key event. A functional event is a special key, like delete, shift, emoji, or the settings key. Non-special keys are those that generate a single code point. This includes all letters, digits, punctuation, separators, emoji. It excludes keys that manage keyboard-related stuff like shift, language switch, settings, layout switch, or any key that results in multiple code points like the "".com"" key.
 * @param event The event to handle.
 * @param inputTransaction The transaction in progress.
 */
private void handleFunctionalEvent(final Event event,final InputTransaction inputTransaction,final int currentKeyboardScriptId,final LatinIME.UIHandler handler){
switch (event.mKeyCode) {
case Constants.CODE_DELETE:
    handleBackspaceEvent(event,inputTransaction,currentKeyboardScriptId);
  inputTransaction.setDidAffectContents();
break;
case Constants.CODE_SHIFT:
performRecapitalization(inputTransaction.mSettingsValues);
inputTransaction.requireShiftUpdate(InputTransaction.SHIFT_UPDATE_NOW);
if (mSuggestedWords.mIsPrediction) {
inputTransaction.setRequiresUpdateSuggestions();
}
break;
case Constants.CODE_CAPSLOCK:
break;
case Constants.CODE_SYMBOL_SHIFT:
break;
case Constants.CODE_SWITCH_ALPHA_SYMBOL:
break;
case Constants.CODE_SETTINGS:
onSettingsKeyPressed();
break;
case Constants.CODE_SHORTCUT:
break;
case Constants.CODE_ACTION_NEXT:
performEditorAction(EditorInfo.IME_ACTION_NEXT);
break;
case Constants.CODE_ACTION_PREVIOUS:
performEditorAction(EditorInfo.IME_ACTION_PREVIOUS);
break;
case Constants.CODE_LANGUAGE_SWITCH:
handleLanguageSwitchKey();
break;
case Constants.CODE_EMOJI:
break;
case Constants.CODE_ALPHA_FROM_EMOJI:
break;
case Constants.CODE_SHIFT_ENTER:
final Event tmpEvent=Event.createSoftwareKeypressEvent(Constants.CODE_ENTER,event.mKeyCode,event.mX,event.mY,event.isKeyRepeat());
handleNonSpecialCharacterEvent(tmpEvent,inputTransaction,handler);
inputTransaction.setDidAffectContents();
break;
default :
throw new RuntimeException(""String_Node_Str"" + event.mKeyCode);
}
}","/** 
 * Handle a functional key event. A functional event is a special key, like delete, shift, emoji, or the settings key. Non-special keys are those that generate a single code point. This includes all letters, digits, punctuation, separators, emoji. It excludes keys that manage keyboard-related stuff like shift, language switch, settings, layout switch, or any key that results in multiple code points like the "".com"" key.
 * @param event The event to handle.
 * @param inputTransaction The transaction in progress.
 */
private void handleFunctionalEvent(final Event event,final InputTransaction inputTransaction,final int currentKeyboardScriptId,final LatinIME.UIHandler handler){
switch (event.mKeyCode) {
case Constants.CODE_DELETE:
    handleBackspaceEvent(event,inputTransaction,currentKeyboardScriptId);
  inputTransaction.setDidAffectContents();
break;
case Constants.CODE_SHIFT:
performRecapitalization(inputTransaction.mSettingsValues);
inputTransaction.requireShiftUpdate(InputTransaction.SHIFT_UPDATE_NOW);
if (mSuggestedWords.isPrediction()) {
inputTransaction.setRequiresUpdateSuggestions();
}
break;
case Constants.CODE_CAPSLOCK:
break;
case Constants.CODE_SYMBOL_SHIFT:
break;
case Constants.CODE_SWITCH_ALPHA_SYMBOL:
break;
case Constants.CODE_SETTINGS:
onSettingsKeyPressed();
break;
case Constants.CODE_SHORTCUT:
break;
case Constants.CODE_ACTION_NEXT:
performEditorAction(EditorInfo.IME_ACTION_NEXT);
break;
case Constants.CODE_ACTION_PREVIOUS:
performEditorAction(EditorInfo.IME_ACTION_PREVIOUS);
break;
case Constants.CODE_LANGUAGE_SWITCH:
handleLanguageSwitchKey();
break;
case Constants.CODE_EMOJI:
break;
case Constants.CODE_ALPHA_FROM_EMOJI:
break;
case Constants.CODE_SHIFT_ENTER:
final Event tmpEvent=Event.createSoftwareKeypressEvent(Constants.CODE_ENTER,event.mKeyCode,event.mX,event.mY,event.isKeyRepeat());
handleNonSpecialCharacterEvent(tmpEvent,inputTransaction,handler);
inputTransaction.setDidAffectContents();
break;
default :
throw new RuntimeException(""String_Node_Str"" + event.mKeyCode);
}
}",0.998771196854264
87378,"public void testGetTypedWordInfoOrNull(){
  final String TYPED_WORD=""String_Node_Str"";
  final int NUMBER_OF_ADDED_SUGGESTIONS=5;
  final ArrayList<SuggestedWordInfo> list=new ArrayList<>();
  list.add(createTypedWordInfo(TYPED_WORD));
  for (int i=0; i < NUMBER_OF_ADDED_SUGGESTIONS; ++i) {
    list.add(createCorrectionWordInfo(Integer.toString(i)));
  }
  final SuggestedWords wordsWithTypedWord=new SuggestedWords(list,null,false,false,false,false,SuggestedWords.INPUT_STYLE_NONE);
  final SuggestedWordInfo typedWord=wordsWithTypedWord.getTypedWordInfoOrNull();
  assertNotNull(typedWord);
  assertEquals(TYPED_WORD,typedWord.mWord);
  final SuggestedWords wordsWithoutTypedWord=wordsWithTypedWord.getSuggestedWordsExcludingTypedWord(SuggestedWords.INPUT_STYLE_NONE);
  assertNull(wordsWithoutTypedWord.getTypedWordInfoOrNull());
  assertNull(SuggestedWords.EMPTY.getTypedWordInfoOrNull());
}","public void testGetTypedWordInfoOrNull(){
  final String TYPED_WORD=""String_Node_Str"";
  final int NUMBER_OF_ADDED_SUGGESTIONS=5;
  final ArrayList<SuggestedWordInfo> list=new ArrayList<>();
  list.add(createTypedWordInfo(TYPED_WORD));
  for (int i=0; i < NUMBER_OF_ADDED_SUGGESTIONS; ++i) {
    list.add(createCorrectionWordInfo(Integer.toString(i)));
  }
  final SuggestedWords wordsWithTypedWord=new SuggestedWords(list,null,false,false,false,SuggestedWords.INPUT_STYLE_NONE);
  final SuggestedWordInfo typedWord=wordsWithTypedWord.getTypedWordInfoOrNull();
  assertNotNull(typedWord);
  assertEquals(TYPED_WORD,typedWord.mWord);
  final SuggestedWords wordsWithoutTypedWord=wordsWithTypedWord.getSuggestedWordsExcludingTypedWordForRecorrection();
  assertNull(wordsWithoutTypedWord.getTypedWordInfoOrNull());
  assertNull(SuggestedWords.EMPTY.getTypedWordInfoOrNull());
}",0.9695259593679458
87379,"public void testGetSuggestedWordsExcludingTypedWord(){
  final String TYPED_WORD=""String_Node_Str"";
  final int NUMBER_OF_ADDED_SUGGESTIONS=5;
  final ArrayList<SuggestedWordInfo> list=new ArrayList<>();
  list.add(createTypedWordInfo(TYPED_WORD));
  for (int i=0; i < NUMBER_OF_ADDED_SUGGESTIONS; ++i) {
    list.add(createCorrectionWordInfo(Integer.toString(i)));
  }
  final SuggestedWords words=new SuggestedWords(list,null,false,false,false,false,SuggestedWords.INPUT_STYLE_NONE);
  assertEquals(NUMBER_OF_ADDED_SUGGESTIONS + 1,words.size());
  assertEquals(""String_Node_Str"",words.getWord(0));
  assertTrue(words.getInfo(0).isKindOf(SuggestedWordInfo.KIND_TYPED));
  assertEquals(""String_Node_Str"",words.getWord(1));
  assertTrue(words.getInfo(1).isKindOf(SuggestedWordInfo.KIND_CORRECTION));
  assertEquals(""String_Node_Str"",words.getWord(5));
  assertTrue(words.getInfo(5).isKindOf(SuggestedWordInfo.KIND_CORRECTION));
  final SuggestedWords wordsWithoutTyped=words.getSuggestedWordsExcludingTypedWord(SuggestedWords.INPUT_STYLE_NONE);
  assertEquals(words.size() - 1,wordsWithoutTyped.size());
  assertEquals(""String_Node_Str"",wordsWithoutTyped.getWord(0));
  assertTrue(wordsWithoutTyped.getInfo(0).isKindOf(SuggestedWordInfo.KIND_CORRECTION));
}","public void testGetSuggestedWordsExcludingTypedWord(){
  final String TYPED_WORD=""String_Node_Str"";
  final int NUMBER_OF_ADDED_SUGGESTIONS=5;
  final int KIND_OF_SECOND_CORRECTION=SuggestedWordInfo.KIND_CORRECTION;
  final ArrayList<SuggestedWordInfo> list=new ArrayList<>();
  list.add(createTypedWordInfo(TYPED_WORD));
  for (int i=0; i < NUMBER_OF_ADDED_SUGGESTIONS; ++i) {
    list.add(createCorrectionWordInfo(Integer.toString(i)));
  }
  final SuggestedWords words=new SuggestedWords(list,null,false,false,false,SuggestedWords.INPUT_STYLE_NONE);
  assertEquals(NUMBER_OF_ADDED_SUGGESTIONS + 1,words.size());
  assertEquals(""String_Node_Str"",words.getWord(0));
  assertTrue(words.getInfo(0).isKindOf(SuggestedWordInfo.KIND_TYPED));
  assertEquals(""String_Node_Str"",words.getWord(1));
  assertTrue(words.getInfo(1).isKindOf(KIND_OF_SECOND_CORRECTION));
  assertEquals(""String_Node_Str"",words.getWord(5));
  assertTrue(words.getInfo(5).isKindOf(KIND_OF_SECOND_CORRECTION));
  final SuggestedWords wordsWithoutTyped=words.getSuggestedWordsExcludingTypedWordForRecorrection();
  assertEquals(words.size() - 1,wordsWithoutTyped.size());
  assertEquals(""String_Node_Str"",wordsWithoutTyped.getWord(0));
  assertTrue(wordsWithoutTyped.getInfo(0).isKindOf(KIND_OF_SECOND_CORRECTION));
}",0.9168964159117764
87380,"private static void testingStandardPunctuationSuggestions(final SpacingAndPunctuations sp,final String[] punctuationLabels,final String[] punctuationWords){
  final SuggestedWords suggestedWords=sp.mSuggestPuncList;
  assertFalse(""String_Node_Str"",suggestedWords.mTypedWordValid);
  assertFalse(""String_Node_Str"",suggestedWords.mWillAutoCorrect);
  assertTrue(""String_Node_Str"",suggestedWords.isPunctuationSuggestions());
  assertFalse(""String_Node_Str"",suggestedWords.mIsObsoleteSuggestions);
  assertFalse(""String_Node_Str"",suggestedWords.mIsPrediction);
  assertEquals(""String_Node_Str"",punctuationLabels.length,suggestedWords.size());
  for (int index=0; index < suggestedWords.size(); index++) {
    assertEquals(""String_Node_Str"" + index,punctuationLabels[index],suggestedWords.getLabel(index));
    assertEquals(""String_Node_Str"" + index,punctuationWords[index],suggestedWords.getWord(index));
  }
}","private static void testingStandardPunctuationSuggestions(final SpacingAndPunctuations sp,final String[] punctuationLabels,final String[] punctuationWords){
  final SuggestedWords suggestedWords=sp.mSuggestPuncList;
  assertFalse(""String_Node_Str"",suggestedWords.mTypedWordValid);
  assertFalse(""String_Node_Str"",suggestedWords.mWillAutoCorrect);
  assertTrue(""String_Node_Str"",suggestedWords.isPunctuationSuggestions());
  assertFalse(""String_Node_Str"",suggestedWords.mIsObsoleteSuggestions);
  assertFalse(""String_Node_Str"",suggestedWords.isPrediction());
  assertEquals(""String_Node_Str"",punctuationLabels.length,suggestedWords.size());
  for (int index=0; index < suggestedWords.size(); index++) {
    assertEquals(""String_Node_Str"" + index,punctuationLabels[index],suggestedWords.getLabel(index));
    assertEquals(""String_Node_Str"" + index,punctuationWords[index],suggestedWords.getWord(index));
  }
}",0.9972421400992828
87381,"/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 * @param settingsValues the current values of the settings.
 * @param shouldIncludeResumedWordInSuggestions whether to include the word on which we resumesuggestions in the suggestion list.
 */
public void restartSuggestionsOnWordTouchedByCursor(final SettingsValues settingsValues,final boolean shouldIncludeResumedWordInSuggestions,final int currentKeyboardScriptId){
  if (settingsValues.isBrokenByRecorrection() || !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces || !settingsValues.needsToLookupSuggestions()|| mInputLogicHandler.isInBatchInput()|| mConnection.hasSelection()|| mConnection.getExpectedSelectionStart() < 0) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  final int expectedCursorPosition=mConnection.getExpectedSelectionStart();
  if (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations)) {
    mWordComposer.setCapitalizedModeAtStartComposingTime(WordComposer.CAPS_MODE_OFF);
    mLatinIME.mHandler.postUpdateSuggestionStrip();
    return;
  }
  final TextRange range=mConnection.getWordRangeAtCursor(settingsValues.mSpacingAndPunctuations.mSortedWordSeparators,currentKeyboardScriptId);
  if (null == range)   return;
  if (range.length() <= 0) {
    mLatinIME.setNeutralSuggestionStrip();
    return;
  }
  if (range.mHasUrlSpans)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > expectedCursorPosition)   return;
  final ArrayList<SuggestedWordInfo> suggestions=new ArrayList<>();
  final String typedWord=range.mWord.toString();
  if (shouldIncludeResumedWordInSuggestions) {
    suggestions.add(new SuggestedWordInfo(typedWord,SuggestedWords.MAX_SUGGESTIONS + 1,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  if (!isResumableWord(settingsValues,typedWord)) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestedWords.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  final int[] codePoints=StringUtils.toCodePointArray(typedWord);
  final PrevWordsInfo prevWordsInfo=getPrevWordsInfoFromNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,0 == numberOfCharsInWordBeforeCursor ? 1 : 2);
  mWordComposer.setComposingWord(codePoints,mLatinIME.getCoordinatesForCurrentKeyboard(codePoints));
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.setComposingRegion(expectedCursorPosition - numberOfCharsInWordBeforeCursor,expectedCursorPosition + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.size() <= (shouldIncludeResumedWordInSuggestions ? 1 : 0)) {
    mInputLogicHandler.getSuggestedWords(Suggest.SESSION_TYPING,SuggestedWords.NOT_A_SEQUENCE_NUMBER,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1 && !shouldIncludeResumedWordInSuggestions) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        mIsAutoCorrectionIndicatorOn=false;
        mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,null,typedWord,false,false,false,false,SuggestedWords.NOT_A_SEQUENCE_NUMBER);
    mIsAutoCorrectionIndicatorOn=false;
    mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
  }
}","/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 * @param settingsValues the current values of the settings.
 * @param shouldIncludeResumedWordInSuggestions whether to include the word on which we resumesuggestions in the suggestion list.
 */
public void restartSuggestionsOnWordTouchedByCursor(final SettingsValues settingsValues,final boolean shouldIncludeResumedWordInSuggestions,final int currentKeyboardScriptId){
  if (settingsValues.isBrokenByRecorrection() || !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces || !settingsValues.needsToLookupSuggestions()|| mInputLogicHandler.isInBatchInput()|| mConnection.hasSelection()|| mConnection.getExpectedSelectionStart() < 0) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  final int expectedCursorPosition=mConnection.getExpectedSelectionStart();
  if (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations)) {
    mWordComposer.setCapitalizedModeAtStartComposingTime(WordComposer.CAPS_MODE_OFF);
    mLatinIME.mHandler.postUpdateSuggestionStrip();
    return;
  }
  final TextRange range=mConnection.getWordRangeAtCursor(settingsValues.mSpacingAndPunctuations.mSortedWordSeparators,currentKeyboardScriptId);
  if (null == range)   return;
  if (range.length() <= 0) {
    mLatinIME.setNeutralSuggestionStrip();
    return;
  }
  if (range.mHasUrlSpans)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > expectedCursorPosition)   return;
  final ArrayList<SuggestedWordInfo> suggestions=new ArrayList<>();
  final String typedWord=range.mWord.toString();
  if (shouldIncludeResumedWordInSuggestions) {
    suggestions.add(new SuggestedWordInfo(typedWord,SuggestedWords.MAX_SUGGESTIONS + 1,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  if (!isResumableWord(settingsValues,typedWord)) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestedWords.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  final int[] codePoints=StringUtils.toCodePointArray(typedWord);
  final PrevWordsInfo prevWordsInfo=getPrevWordsInfoFromNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,0 == numberOfCharsInWordBeforeCursor ? 1 : 2);
  mWordComposer.setComposingWord(codePoints,mLatinIME.getCoordinatesForCurrentKeyboard(codePoints));
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.maybeMoveTheCursorAroundAndRestoreToWorkaroundABug();
  mConnection.setComposingRegion(expectedCursorPosition - numberOfCharsInWordBeforeCursor,expectedCursorPosition + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.size() <= (shouldIncludeResumedWordInSuggestions ? 1 : 0)) {
    mInputLogicHandler.getSuggestedWords(Suggest.SESSION_TYPING,SuggestedWords.NOT_A_SEQUENCE_NUMBER,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1 && !shouldIncludeResumedWordInSuggestions) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        mIsAutoCorrectionIndicatorOn=false;
        mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,null,typedWord,false,false,false,false,SuggestedWords.NOT_A_SEQUENCE_NUMBER);
    mIsAutoCorrectionIndicatorOn=false;
    mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
  }
}",0.9919621749408984
87382,"/** 
 * Get sentence suggestions for specified texts in an array of TextInfo. This is taken from SpellCheckerService#onGetSentenceSuggestionsMultiple that we can't use because it's using private variables. The default implementation splits the input text to words and returns  {@link SentenceSuggestionsInfo} which contains suggestions for each word.This function will run on the incoming IPC thread. So, this is not called on the main thread, but will be called in series on another thread.
 * @param textInfos an array of the text metadata
 * @param suggestionsLimit the maximum number of suggestions to be returned
 * @return an array of {@link SentenceSuggestionsInfo} returned by{@link SpellCheckerService.Session#onGetSuggestions(TextInfo,int)}
 */
private SentenceSuggestionsInfo[] splitAndSuggest(TextInfo[] textInfos,int suggestionsLimit){
  if (textInfos == null || textInfos.length == 0) {
    return SentenceLevelAdapter.EMPTY_SENTENCE_SUGGESTIONS_INFOS;
  }
  SentenceLevelAdapter sentenceLevelAdapter;
synchronized (this) {
    sentenceLevelAdapter=mSentenceLevelAdapter;
    if (sentenceLevelAdapter == null) {
      final String localeStr=getLocale();
      if (!TextUtils.isEmpty(localeStr)) {
        sentenceLevelAdapter=new SentenceLevelAdapter(mResources,new Locale(localeStr));
        mSentenceLevelAdapter=sentenceLevelAdapter;
      }
    }
  }
  if (sentenceLevelAdapter == null) {
    return SentenceLevelAdapter.EMPTY_SENTENCE_SUGGESTIONS_INFOS;
  }
  final int infosSize=textInfos.length;
  final SentenceSuggestionsInfo[] retval=new SentenceSuggestionsInfo[infosSize];
  for (int i=0; i < infosSize; ++i) {
    final SentenceLevelAdapter.SentenceTextInfoParams textInfoParams=sentenceLevelAdapter.getSplitWords(textInfos[i]);
    final ArrayList<SentenceLevelAdapter.SentenceWordItem> mItems=textInfoParams.mItems;
    final int itemsSize=mItems.size();
    final TextInfo[] splitTextInfos=new TextInfo[itemsSize];
    for (int j=0; j < itemsSize; ++j) {
      splitTextInfos[j]=mItems.get(j).mTextInfo;
    }
    retval[i]=SentenceLevelAdapter.reconstructSuggestions(textInfoParams,onGetSuggestionsMultiple(splitTextInfos,suggestionsLimit,true));
  }
  return retval;
}","/** 
 * Get sentence suggestions for specified texts in an array of TextInfo. This is taken from SpellCheckerService#onGetSentenceSuggestionsMultiple that we can't use because it's using private variables. The default implementation splits the input text to words and returns  {@link SentenceSuggestionsInfo} which contains suggestions for each word.This function will run on the incoming IPC thread. So, this is not called on the main thread, but will be called in series on another thread.
 * @param textInfos an array of the text metadata
 * @param suggestionsLimit the maximum number of suggestions to be returned
 * @return an array of {@link SentenceSuggestionsInfo} returned by{@link SpellCheckerService.Session#onGetSuggestions(TextInfo,int)}
 */
private SentenceSuggestionsInfo[] splitAndSuggest(TextInfo[] textInfos,int suggestionsLimit){
  if (textInfos == null || textInfos.length == 0) {
    return SentenceLevelAdapter.getEmptySentenceSuggestionsInfo();
  }
  SentenceLevelAdapter sentenceLevelAdapter;
synchronized (this) {
    sentenceLevelAdapter=mSentenceLevelAdapter;
    if (sentenceLevelAdapter == null) {
      final String localeStr=getLocale();
      if (!TextUtils.isEmpty(localeStr)) {
        sentenceLevelAdapter=new SentenceLevelAdapter(mResources,new Locale(localeStr));
        mSentenceLevelAdapter=sentenceLevelAdapter;
      }
    }
  }
  if (sentenceLevelAdapter == null) {
    return SentenceLevelAdapter.getEmptySentenceSuggestionsInfo();
  }
  final int infosSize=textInfos.length;
  final SentenceSuggestionsInfo[] retval=new SentenceSuggestionsInfo[infosSize];
  for (int i=0; i < infosSize; ++i) {
    final SentenceLevelAdapter.SentenceTextInfoParams textInfoParams=sentenceLevelAdapter.getSplitWords(textInfos[i]);
    final ArrayList<SentenceLevelAdapter.SentenceWordItem> mItems=textInfoParams.mItems;
    final int itemsSize=mItems.size();
    final TextInfo[] splitTextInfos=new TextInfo[itemsSize];
    for (int j=0; j < itemsSize; ++j) {
      splitTextInfos[j]=mItems.get(j).mTextInfo;
    }
    retval[i]=SentenceLevelAdapter.reconstructSuggestions(textInfoParams,onGetSuggestionsMultiple(splitTextInfos,suggestionsLimit,true));
  }
  return retval;
}",0.8814175374829623
87383,"/** 
 * Get sentence suggestions for specified texts in an array of TextInfo. This is taken from SpellCheckerService#onGetSentenceSuggestionsMultiple that we can't use because it's using private variables. The default implementation splits the input text to words and returns  {@link SentenceSuggestionsInfo} which contains suggestions for each word.This function will run on the incoming IPC thread. So, this is not called on the main thread, but will be called in series on another thread.
 * @param textInfos an array of the text metadata
 * @param suggestionsLimit the maximum number of suggestions to be returned
 * @return an array of {@link SentenceSuggestionsInfo} returned by{@link SpellCheckerService.Session#onGetSuggestions(TextInfo,int)}
 */
private SentenceSuggestionsInfo[] splitAndSuggest(TextInfo[] textInfos,int suggestionsLimit){
  if (textInfos == null || textInfos.length == 0) {
    return SentenceLevelAdapter.EMPTY_SENTENCE_SUGGESTIONS_INFOS;
  }
  SentenceLevelAdapter sentenceLevelAdapter;
synchronized (this) {
    sentenceLevelAdapter=mSentenceLevelAdapter;
    if (sentenceLevelAdapter == null) {
      final String localeStr=getLocale();
      if (!TextUtils.isEmpty(localeStr)) {
        sentenceLevelAdapter=new SentenceLevelAdapter(mResources,new Locale(localeStr));
        mSentenceLevelAdapter=sentenceLevelAdapter;
      }
    }
  }
  if (sentenceLevelAdapter == null) {
    return SentenceLevelAdapter.EMPTY_SENTENCE_SUGGESTIONS_INFOS;
  }
  final int infosSize=textInfos.length;
  final SentenceSuggestionsInfo[] retval=new SentenceSuggestionsInfo[infosSize];
  for (int i=0; i < infosSize; ++i) {
    final SentenceLevelAdapter.SentenceTextInfoParams textInfoParams=sentenceLevelAdapter.getSplitWords(textInfos[i]);
    final ArrayList<SentenceLevelAdapter.SentenceWordItem> mItems=textInfoParams.mItems;
    final int itemsSize=mItems.size();
    final TextInfo[] splitTextInfos=new TextInfo[itemsSize];
    for (int j=0; j < itemsSize; ++j) {
      splitTextInfos[j]=mItems.get(j).mTextInfo;
    }
    retval[i]=SentenceLevelAdapter.reconstructSuggestions(textInfoParams,onGetSuggestionsMultiple(splitTextInfos,suggestionsLimit,true));
  }
  return retval;
}","/** 
 * Get sentence suggestions for specified texts in an array of TextInfo. This is taken from SpellCheckerService#onGetSentenceSuggestionsMultiple that we can't use because it's using private variables. The default implementation splits the input text to words and returns  {@link SentenceSuggestionsInfo} which contains suggestions for each word.This function will run on the incoming IPC thread. So, this is not called on the main thread, but will be called in series on another thread.
 * @param textInfos an array of the text metadata
 * @param suggestionsLimit the maximum number of suggestions to be returned
 * @return an array of {@link SentenceSuggestionsInfo} returned by{@link SpellCheckerService.Session#onGetSuggestions(TextInfo,int)}
 */
private SentenceSuggestionsInfo[] splitAndSuggest(TextInfo[] textInfos,int suggestionsLimit){
  if (textInfos == null || textInfos.length == 0) {
    return SentenceLevelAdapter.getEmptySentenceSuggestionsInfo();
  }
  SentenceLevelAdapter sentenceLevelAdapter;
synchronized (this) {
    sentenceLevelAdapter=mSentenceLevelAdapter;
    if (sentenceLevelAdapter == null) {
      final String localeStr=getLocale();
      if (!TextUtils.isEmpty(localeStr)) {
        sentenceLevelAdapter=new SentenceLevelAdapter(mResources,new Locale(localeStr));
        mSentenceLevelAdapter=sentenceLevelAdapter;
      }
    }
  }
  if (sentenceLevelAdapter == null) {
    return SentenceLevelAdapter.getEmptySentenceSuggestionsInfo();
  }
  final int infosSize=textInfos.length;
  final SentenceSuggestionsInfo[] retval=new SentenceSuggestionsInfo[infosSize];
  for (int i=0; i < infosSize; ++i) {
    final SentenceLevelAdapter.SentenceTextInfoParams textInfoParams=sentenceLevelAdapter.getSplitWords(textInfos[i]);
    final ArrayList<SentenceLevelAdapter.SentenceWordItem> mItems=textInfoParams.mItems;
    final int itemsSize=mItems.size();
    final TextInfo[] splitTextInfos=new TextInfo[itemsSize];
    for (int j=0; j < itemsSize; ++j) {
      splitTextInfos[j]=mItems.get(j).mTextInfo;
    }
    retval[i]=SentenceLevelAdapter.reconstructSuggestions(textInfoParams,onGetSuggestionsMultiple(splitTextInfos,suggestionsLimit,true));
  }
  return retval;
}",0.8814175374829623
87384,"@Override public Event decodeHardwareKey(final KeyEvent keyEvent){
  final int codePointAndFlags=keyEvent.getUnicodeChar();
  final int keyCode=keyEvent.getKeyCode();
  final boolean isKeyRepeat=(0 != keyEvent.getRepeatCount());
  if (KeyEvent.KEYCODE_DEL == keyCode) {
    return Event.createHardwareKeypressEvent(Event.NOT_A_CODE_POINT,Constants.CODE_DELETE,null,isKeyRepeat);
  }
  if (keyEvent.isPrintingKey() || KeyEvent.KEYCODE_SPACE == keyCode || KeyEvent.KEYCODE_ENTER == keyCode) {
    if (0 != (codePointAndFlags & KeyCharacterMap.COMBINING_ACCENT)) {
      return Event.createDeadEvent(codePointAndFlags & KeyCharacterMap.COMBINING_ACCENT_MASK,keyCode,null);
    }
    if (KeyEvent.KEYCODE_ENTER == keyCode) {
      if (keyEvent.isShiftPressed()) {
        return Event.createHardwareKeypressEvent(Event.NOT_A_CODE_POINT,Constants.CODE_SHIFT_ENTER,null,isKeyRepeat);
      }
 else {
        return Event.createHardwareKeypressEvent(Constants.CODE_ENTER,keyCode,null,isKeyRepeat);
      }
    }
    return Event.createHardwareKeypressEvent(keyCode,codePointAndFlags,null,isKeyRepeat);
  }
  return Event.createNotHandledEvent();
}","@Override public Event decodeHardwareKey(final KeyEvent keyEvent){
  final int codePointAndFlags=keyEvent.getUnicodeChar();
  final int keyCode=keyEvent.getKeyCode();
  final boolean isKeyRepeat=(0 != keyEvent.getRepeatCount());
  if (KeyEvent.KEYCODE_DEL == keyCode) {
    return Event.createHardwareKeypressEvent(Event.NOT_A_CODE_POINT,Constants.CODE_DELETE,null,isKeyRepeat);
  }
  if (keyEvent.isPrintingKey() || KeyEvent.KEYCODE_SPACE == keyCode || KeyEvent.KEYCODE_ENTER == keyCode) {
    if (0 != (codePointAndFlags & KeyCharacterMap.COMBINING_ACCENT)) {
      return Event.createDeadEvent(codePointAndFlags & KeyCharacterMap.COMBINING_ACCENT_MASK,keyCode,null);
    }
    if (KeyEvent.KEYCODE_ENTER == keyCode) {
      if (keyEvent.isShiftPressed()) {
        return Event.createHardwareKeypressEvent(Event.NOT_A_CODE_POINT,Constants.CODE_SHIFT_ENTER,null,isKeyRepeat);
      }
 else {
        return Event.createHardwareKeypressEvent(Constants.CODE_ENTER,keyCode,null,isKeyRepeat);
      }
    }
    return Event.createHardwareKeypressEvent(codePointAndFlags,keyCode,null,isKeyRepeat);
  }
  return Event.createNotHandledEvent();
}",0.9929824561403509
87385,"/** 
 * React to a code input. It may be a code point to insert, or a symbolic value that influences the keyboard behavior. Typically, this is called whenever a key is pressed on the software keyboard. This is not the entry point for gesture input; see the onBatchInput* family of functions for this.
 * @param settingsValues the current settings values.
 * @param event the event to handle.
 * @param keyboardShiftMode the current shift mode of the keyboard, as returned by{@link com.android.inputmethod.keyboard.KeyboardSwitcher#getKeyboardShiftMode()}
 * @return the complete transaction object
 */
public InputTransaction onCodeInput(final SettingsValues settingsValues,final Event event,final int keyboardShiftMode,final LatinIME.UIHandler handler){
  final InputTransaction inputTransaction=new InputTransaction(settingsValues,event,SystemClock.uptimeMillis(),mSpaceState,getActualCapsMode(settingsValues,keyboardShiftMode));
  if (event.mKeyCode != Constants.CODE_DELETE || inputTransaction.mTimestamp > mLastKeyTime + Constants.LONG_PRESS_MILLISECONDS) {
    mDeleteCount=0;
  }
  mLastKeyTime=inputTransaction.mTimestamp;
  mConnection.beginBatchEdit();
  if (!mWordComposer.isComposingWord()) {
    mIsAutoCorrectionIndicatorOn=false;
  }
  if (event.mCodePoint != Constants.CODE_SPACE) {
    cancelDoubleSpacePeriodCountdown();
  }
  boolean didAutoCorrect=false;
  if (Event.NOT_A_KEY_CODE != event.mKeyCode) {
switch (event.mKeyCode) {
case Constants.CODE_DELETE:
      handleBackspace(inputTransaction);
    break;
case Constants.CODE_SHIFT:
  performRecapitalization(inputTransaction.mSettingsValues);
inputTransaction.requireShiftUpdate(InputTransaction.SHIFT_UPDATE_NOW);
if (mSuggestedWords.mIsPrediction) {
inputTransaction.setRequiresUpdateSuggestions();
}
break;
case Constants.CODE_CAPSLOCK:
break;
case Constants.CODE_SYMBOL_SHIFT:
break;
case Constants.CODE_SWITCH_ALPHA_SYMBOL:
break;
case Constants.CODE_SETTINGS:
onSettingsKeyPressed();
break;
case Constants.CODE_SHORTCUT:
break;
case Constants.CODE_ACTION_NEXT:
performEditorAction(EditorInfo.IME_ACTION_NEXT);
break;
case Constants.CODE_ACTION_PREVIOUS:
performEditorAction(EditorInfo.IME_ACTION_PREVIOUS);
break;
case Constants.CODE_LANGUAGE_SWITCH:
handleLanguageSwitchKey();
break;
case Constants.CODE_EMOJI:
break;
case Constants.CODE_ALPHA_FROM_EMOJI:
break;
case Constants.CODE_SHIFT_ENTER:
final Event tmpEvent=Event.createSoftwareKeypressEvent(Constants.CODE_ENTER,event.mKeyCode,event.mX,event.mY,event.isKeyRepeat());
final InputTransaction tmpTransaction=new InputTransaction(inputTransaction.mSettingsValues,tmpEvent,inputTransaction.mTimestamp,inputTransaction.mSpaceState,inputTransaction.mShiftState);
didAutoCorrect=handleNonSpecialCharacter(tmpTransaction,handler);
break;
default :
throw new RuntimeException(""String_Node_Str"" + event.mKeyCode);
}
}
 else {
switch (event.mCodePoint) {
case Constants.CODE_ENTER:
final EditorInfo editorInfo=getCurrentInputEditorInfo();
final int imeOptionsActionId=InputTypeUtils.getImeOptionsActionIdFromEditorInfo(editorInfo);
if (InputTypeUtils.IME_ACTION_CUSTOM_LABEL == imeOptionsActionId) {
performEditorAction(editorInfo.actionId);
}
 else if (EditorInfo.IME_ACTION_NONE != imeOptionsActionId) {
performEditorAction(imeOptionsActionId);
}
 else {
didAutoCorrect=handleNonSpecialCharacter(inputTransaction,handler);
}
break;
default :
didAutoCorrect=handleNonSpecialCharacter(inputTransaction,handler);
break;
}
}
if (!didAutoCorrect && event.mKeyCode != Constants.CODE_SHIFT && event.mKeyCode != Constants.CODE_CAPSLOCK && event.mKeyCode != Constants.CODE_SWITCH_ALPHA_SYMBOL) mLastComposedWord.deactivate();
if (Constants.CODE_DELETE != event.mKeyCode) {
mEnteredText=null;
}
mConnection.endBatchEdit();
return inputTransaction;
}","/** 
 * React to a code input. It may be a code point to insert, or a symbolic value that influences the keyboard behavior. Typically, this is called whenever a key is pressed on the software keyboard. This is not the entry point for gesture input; see the onBatchInput* family of functions for this.
 * @param settingsValues the current settings values.
 * @param event the event to handle.
 * @param keyboardShiftMode the current shift mode of the keyboard, as returned by{@link com.android.inputmethod.keyboard.KeyboardSwitcher#getKeyboardShiftMode()}
 * @return the complete transaction object
 */
public InputTransaction onCodeInput(final SettingsValues settingsValues,final Event event,final int keyboardShiftMode,final LatinIME.UIHandler handler){
  final InputTransaction inputTransaction=new InputTransaction(settingsValues,event,SystemClock.uptimeMillis(),mSpaceState,getActualCapsMode(settingsValues,keyboardShiftMode));
  if (event.mKeyCode != Constants.CODE_DELETE || inputTransaction.mTimestamp > mLastKeyTime + Constants.LONG_PRESS_MILLISECONDS) {
    mDeleteCount=0;
  }
  mLastKeyTime=inputTransaction.mTimestamp;
  mConnection.beginBatchEdit();
  if (!mWordComposer.isComposingWord()) {
    mIsAutoCorrectionIndicatorOn=false;
  }
  if (event.mCodePoint != Constants.CODE_SPACE) {
    cancelDoubleSpacePeriodCountdown();
  }
  boolean didAutoCorrect=false;
  if (event.isFunctionalKeyEvent()) {
switch (event.mKeyCode) {
case Constants.CODE_DELETE:
      handleBackspace(inputTransaction);
    break;
case Constants.CODE_SHIFT:
  performRecapitalization(inputTransaction.mSettingsValues);
inputTransaction.requireShiftUpdate(InputTransaction.SHIFT_UPDATE_NOW);
if (mSuggestedWords.mIsPrediction) {
inputTransaction.setRequiresUpdateSuggestions();
}
break;
case Constants.CODE_CAPSLOCK:
break;
case Constants.CODE_SYMBOL_SHIFT:
break;
case Constants.CODE_SWITCH_ALPHA_SYMBOL:
break;
case Constants.CODE_SETTINGS:
onSettingsKeyPressed();
break;
case Constants.CODE_SHORTCUT:
break;
case Constants.CODE_ACTION_NEXT:
performEditorAction(EditorInfo.IME_ACTION_NEXT);
break;
case Constants.CODE_ACTION_PREVIOUS:
performEditorAction(EditorInfo.IME_ACTION_PREVIOUS);
break;
case Constants.CODE_LANGUAGE_SWITCH:
handleLanguageSwitchKey();
break;
case Constants.CODE_EMOJI:
break;
case Constants.CODE_ALPHA_FROM_EMOJI:
break;
case Constants.CODE_SHIFT_ENTER:
final Event tmpEvent=Event.createSoftwareKeypressEvent(Constants.CODE_ENTER,event.mKeyCode,event.mX,event.mY,event.isKeyRepeat());
final InputTransaction tmpTransaction=new InputTransaction(inputTransaction.mSettingsValues,tmpEvent,inputTransaction.mTimestamp,inputTransaction.mSpaceState,inputTransaction.mShiftState);
didAutoCorrect=handleNonSpecialCharacter(tmpTransaction,handler);
break;
default :
throw new RuntimeException(""String_Node_Str"" + event.mKeyCode);
}
}
 else {
switch (event.mCodePoint) {
case Constants.CODE_ENTER:
final EditorInfo editorInfo=getCurrentInputEditorInfo();
final int imeOptionsActionId=InputTypeUtils.getImeOptionsActionIdFromEditorInfo(editorInfo);
if (InputTypeUtils.IME_ACTION_CUSTOM_LABEL == imeOptionsActionId) {
performEditorAction(editorInfo.actionId);
}
 else if (EditorInfo.IME_ACTION_NONE != imeOptionsActionId) {
performEditorAction(imeOptionsActionId);
}
 else {
didAutoCorrect=handleNonSpecialCharacter(inputTransaction,handler);
}
break;
default :
didAutoCorrect=handleNonSpecialCharacter(inputTransaction,handler);
break;
}
}
if (!didAutoCorrect && event.mKeyCode != Constants.CODE_SHIFT && event.mKeyCode != Constants.CODE_CAPSLOCK && event.mKeyCode != Constants.CODE_SWITCH_ALPHA_SYMBOL) mLastComposedWord.deactivate();
if (Constants.CODE_DELETE != event.mKeyCode) {
mEnteredText=null;
}
mConnection.endBatchEdit();
return inputTransaction;
}",0.993891102257636
87386,"@Override public Event decodeHardwareKey(final KeyEvent keyEvent){
  final int codePointAndFlags=keyEvent.getUnicodeChar();
  final int keyCode=keyEvent.getKeyCode();
  final boolean isKeyRepeat=(0 != keyEvent.getRepeatCount());
  if (KeyEvent.KEYCODE_DEL == keyCode) {
    return Event.createHardwareKeypressEvent(Event.NOT_A_CODE_POINT,Constants.CODE_DELETE,null,isKeyRepeat);
  }
  if (keyEvent.isPrintingKey() || KeyEvent.KEYCODE_SPACE == keyCode || KeyEvent.KEYCODE_ENTER == keyCode) {
    if (0 != (codePointAndFlags & KeyCharacterMap.COMBINING_ACCENT)) {
      return Event.createDeadEvent(codePointAndFlags & KeyCharacterMap.COMBINING_ACCENT_MASK,keyCode,null);
    }
    if (KeyEvent.KEYCODE_ENTER == keyCode) {
      if (keyEvent.isShiftPressed()) {
        return Event.createHardwareKeypressEvent(Event.NOT_A_CODE_POINT,Constants.CODE_SHIFT_ENTER,null,isKeyRepeat);
      }
 else {
        return Event.createHardwareKeypressEvent(Constants.CODE_ENTER,keyCode,null,isKeyRepeat);
      }
    }
    return Event.createHardwareKeypressEvent(keyCode,codePointAndFlags,null,isKeyRepeat);
  }
  return Event.createNotHandledEvent();
}","@Override public Event decodeHardwareKey(final KeyEvent keyEvent){
  final int codePointAndFlags=keyEvent.getUnicodeChar();
  final int keyCode=keyEvent.getKeyCode();
  final boolean isKeyRepeat=(0 != keyEvent.getRepeatCount());
  if (KeyEvent.KEYCODE_DEL == keyCode) {
    return Event.createHardwareKeypressEvent(Event.NOT_A_CODE_POINT,Constants.CODE_DELETE,null,isKeyRepeat);
  }
  if (keyEvent.isPrintingKey() || KeyEvent.KEYCODE_SPACE == keyCode || KeyEvent.KEYCODE_ENTER == keyCode) {
    if (0 != (codePointAndFlags & KeyCharacterMap.COMBINING_ACCENT)) {
      return Event.createDeadEvent(codePointAndFlags & KeyCharacterMap.COMBINING_ACCENT_MASK,keyCode,null);
    }
    if (KeyEvent.KEYCODE_ENTER == keyCode) {
      if (keyEvent.isShiftPressed()) {
        return Event.createHardwareKeypressEvent(Event.NOT_A_CODE_POINT,Constants.CODE_SHIFT_ENTER,null,isKeyRepeat);
      }
 else {
        return Event.createHardwareKeypressEvent(Constants.CODE_ENTER,keyCode,null,isKeyRepeat);
      }
    }
    return Event.createHardwareKeypressEvent(codePointAndFlags,keyCode,null,isKeyRepeat);
  }
  return Event.createNotHandledEvent();
}",0.9929824561403509
87387,"/** 
 * React to a code input. It may be a code point to insert, or a symbolic value that influences the keyboard behavior. Typically, this is called whenever a key is pressed on the software keyboard. This is not the entry point for gesture input; see the onBatchInput* family of functions for this.
 * @param settingsValues the current settings values.
 * @param event the event to handle.
 * @param keyboardShiftMode the current shift mode of the keyboard, as returned by{@link com.android.inputmethod.keyboard.KeyboardSwitcher#getKeyboardShiftMode()}
 * @return the complete transaction object
 */
public InputTransaction onCodeInput(final SettingsValues settingsValues,final Event event,final int keyboardShiftMode,final LatinIME.UIHandler handler){
  final InputTransaction inputTransaction=new InputTransaction(settingsValues,event,SystemClock.uptimeMillis(),mSpaceState,getActualCapsMode(settingsValues,keyboardShiftMode));
  if (event.mKeyCode != Constants.CODE_DELETE || inputTransaction.mTimestamp > mLastKeyTime + Constants.LONG_PRESS_MILLISECONDS) {
    mDeleteCount=0;
  }
  mLastKeyTime=inputTransaction.mTimestamp;
  mConnection.beginBatchEdit();
  if (!mWordComposer.isComposingWord()) {
    mIsAutoCorrectionIndicatorOn=false;
  }
  if (event.mCodePoint != Constants.CODE_SPACE) {
    cancelDoubleSpacePeriodCountdown();
  }
  boolean didAutoCorrect=false;
  if (Event.NOT_A_KEY_CODE != event.mKeyCode) {
switch (event.mKeyCode) {
case Constants.CODE_DELETE:
      handleBackspace(inputTransaction);
    break;
case Constants.CODE_SHIFT:
  performRecapitalization(inputTransaction.mSettingsValues);
inputTransaction.requireShiftUpdate(InputTransaction.SHIFT_UPDATE_NOW);
if (mSuggestedWords.mIsPrediction) {
inputTransaction.setRequiresUpdateSuggestions();
}
break;
case Constants.CODE_CAPSLOCK:
break;
case Constants.CODE_SYMBOL_SHIFT:
break;
case Constants.CODE_SWITCH_ALPHA_SYMBOL:
break;
case Constants.CODE_SETTINGS:
onSettingsKeyPressed();
break;
case Constants.CODE_SHORTCUT:
break;
case Constants.CODE_ACTION_NEXT:
performEditorAction(EditorInfo.IME_ACTION_NEXT);
break;
case Constants.CODE_ACTION_PREVIOUS:
performEditorAction(EditorInfo.IME_ACTION_PREVIOUS);
break;
case Constants.CODE_LANGUAGE_SWITCH:
handleLanguageSwitchKey();
break;
case Constants.CODE_EMOJI:
break;
case Constants.CODE_ALPHA_FROM_EMOJI:
break;
case Constants.CODE_SHIFT_ENTER:
final Event tmpEvent=Event.createSoftwareKeypressEvent(Constants.CODE_ENTER,event.mKeyCode,event.mX,event.mY,event.isKeyRepeat());
final InputTransaction tmpTransaction=new InputTransaction(inputTransaction.mSettingsValues,tmpEvent,inputTransaction.mTimestamp,inputTransaction.mSpaceState,inputTransaction.mShiftState);
didAutoCorrect=handleNonSpecialCharacter(tmpTransaction,handler);
break;
default :
throw new RuntimeException(""String_Node_Str"" + event.mKeyCode);
}
}
 else {
switch (event.mCodePoint) {
case Constants.CODE_ENTER:
final EditorInfo editorInfo=getCurrentInputEditorInfo();
final int imeOptionsActionId=InputTypeUtils.getImeOptionsActionIdFromEditorInfo(editorInfo);
if (InputTypeUtils.IME_ACTION_CUSTOM_LABEL == imeOptionsActionId) {
performEditorAction(editorInfo.actionId);
}
 else if (EditorInfo.IME_ACTION_NONE != imeOptionsActionId) {
performEditorAction(imeOptionsActionId);
}
 else {
didAutoCorrect=handleNonSpecialCharacter(inputTransaction,handler);
}
break;
default :
didAutoCorrect=handleNonSpecialCharacter(inputTransaction,handler);
break;
}
}
if (!didAutoCorrect && event.mKeyCode != Constants.CODE_SHIFT && event.mKeyCode != Constants.CODE_CAPSLOCK && event.mKeyCode != Constants.CODE_SWITCH_ALPHA_SYMBOL) mLastComposedWord.deactivate();
if (Constants.CODE_DELETE != event.mKeyCode) {
mEnteredText=null;
}
mConnection.endBatchEdit();
return inputTransaction;
}","/** 
 * React to a code input. It may be a code point to insert, or a symbolic value that influences the keyboard behavior. Typically, this is called whenever a key is pressed on the software keyboard. This is not the entry point for gesture input; see the onBatchInput* family of functions for this.
 * @param settingsValues the current settings values.
 * @param event the event to handle.
 * @param keyboardShiftMode the current shift mode of the keyboard, as returned by{@link com.android.inputmethod.keyboard.KeyboardSwitcher#getKeyboardShiftMode()}
 * @return the complete transaction object
 */
public InputTransaction onCodeInput(final SettingsValues settingsValues,final Event event,final int keyboardShiftMode,final LatinIME.UIHandler handler){
  final InputTransaction inputTransaction=new InputTransaction(settingsValues,event,SystemClock.uptimeMillis(),mSpaceState,getActualCapsMode(settingsValues,keyboardShiftMode));
  if (event.mKeyCode != Constants.CODE_DELETE || inputTransaction.mTimestamp > mLastKeyTime + Constants.LONG_PRESS_MILLISECONDS) {
    mDeleteCount=0;
  }
  mLastKeyTime=inputTransaction.mTimestamp;
  mConnection.beginBatchEdit();
  if (!mWordComposer.isComposingWord()) {
    mIsAutoCorrectionIndicatorOn=false;
  }
  if (event.mCodePoint != Constants.CODE_SPACE) {
    cancelDoubleSpacePeriodCountdown();
  }
  boolean didAutoCorrect=false;
  if (event.isFunctionalKeyEvent()) {
switch (event.mKeyCode) {
case Constants.CODE_DELETE:
      handleBackspace(inputTransaction);
    break;
case Constants.CODE_SHIFT:
  performRecapitalization(inputTransaction.mSettingsValues);
inputTransaction.requireShiftUpdate(InputTransaction.SHIFT_UPDATE_NOW);
if (mSuggestedWords.mIsPrediction) {
inputTransaction.setRequiresUpdateSuggestions();
}
break;
case Constants.CODE_CAPSLOCK:
break;
case Constants.CODE_SYMBOL_SHIFT:
break;
case Constants.CODE_SWITCH_ALPHA_SYMBOL:
break;
case Constants.CODE_SETTINGS:
onSettingsKeyPressed();
break;
case Constants.CODE_SHORTCUT:
break;
case Constants.CODE_ACTION_NEXT:
performEditorAction(EditorInfo.IME_ACTION_NEXT);
break;
case Constants.CODE_ACTION_PREVIOUS:
performEditorAction(EditorInfo.IME_ACTION_PREVIOUS);
break;
case Constants.CODE_LANGUAGE_SWITCH:
handleLanguageSwitchKey();
break;
case Constants.CODE_EMOJI:
break;
case Constants.CODE_ALPHA_FROM_EMOJI:
break;
case Constants.CODE_SHIFT_ENTER:
final Event tmpEvent=Event.createSoftwareKeypressEvent(Constants.CODE_ENTER,event.mKeyCode,event.mX,event.mY,event.isKeyRepeat());
final InputTransaction tmpTransaction=new InputTransaction(inputTransaction.mSettingsValues,tmpEvent,inputTransaction.mTimestamp,inputTransaction.mSpaceState,inputTransaction.mShiftState);
didAutoCorrect=handleNonSpecialCharacter(tmpTransaction,handler);
break;
default :
throw new RuntimeException(""String_Node_Str"" + event.mKeyCode);
}
}
 else {
switch (event.mCodePoint) {
case Constants.CODE_ENTER:
final EditorInfo editorInfo=getCurrentInputEditorInfo();
final int imeOptionsActionId=InputTypeUtils.getImeOptionsActionIdFromEditorInfo(editorInfo);
if (InputTypeUtils.IME_ACTION_CUSTOM_LABEL == imeOptionsActionId) {
performEditorAction(editorInfo.actionId);
}
 else if (EditorInfo.IME_ACTION_NONE != imeOptionsActionId) {
performEditorAction(imeOptionsActionId);
}
 else {
didAutoCorrect=handleNonSpecialCharacter(inputTransaction,handler);
}
break;
default :
didAutoCorrect=handleNonSpecialCharacter(inputTransaction,handler);
break;
}
}
if (!didAutoCorrect && event.mKeyCode != Constants.CODE_SHIFT && event.mKeyCode != Constants.CODE_CAPSLOCK && event.mKeyCode != Constants.CODE_SWITCH_ALPHA_SYMBOL) mLastComposedWord.deactivate();
if (Constants.CODE_DELETE != event.mKeyCode) {
mEnteredText=null;
}
mConnection.endBatchEdit();
return inputTransaction;
}",0.993891102257636
87388,"@Override public void onConfigurationChanged(final Configuration conf){
  final SettingsValues settingsValues=mSettings.getCurrent();
  if (settingsValues.mDisplayOrientation != conf.orientation) {
    mHandler.startOrientationChanging();
    mInputLogic.finishInput();
  }
  PersonalizationDictionarySessionRegistrar.onConfigurationChanged(this,conf,mDictionaryFacilitator);
  super.onConfigurationChanged(conf);
}","@Override public void onConfigurationChanged(final Configuration conf){
  final SettingsValues settingsValues=mSettings.getCurrent();
  if (settingsValues.mDisplayOrientation != conf.orientation) {
    mHandler.startOrientationChanging();
    if (mInputLogic.mWordComposer.isComposingWord()) {
      mInputLogic.mConnection.beginBatchEdit();
      mInputLogic.commitTyped(mSettings.getCurrent(),LastComposedWord.NOT_A_SEPARATOR);
      mInputLogic.mConnection.endBatchEdit();
    }
  }
  PersonalizationDictionarySessionRegistrar.onConfigurationChanged(this,conf,mDictionaryFacilitator);
  super.onConfigurationChanged(conf);
}",0.7850287907869482
87389,"@Override public void onConfigurationChanged(final Configuration conf){
  final SettingsValues settingsValues=mSettings.getCurrent();
  if (settingsValues.mDisplayOrientation != conf.orientation) {
    mHandler.startOrientationChanging();
    mInputLogic.mConnection.beginBatchEdit();
    mInputLogic.commitTyped(mSettings.getCurrent(),LastComposedWord.NOT_A_SEPARATOR);
    mInputLogic.mConnection.finishComposingText();
    mInputLogic.mConnection.endBatchEdit();
  }
  PersonalizationDictionarySessionRegistrar.onConfigurationChanged(this,conf,mDictionaryFacilitator);
  super.onConfigurationChanged(conf);
}","@Override public void onConfigurationChanged(final Configuration conf){
  final SettingsValues settingsValues=mSettings.getCurrent();
  if (settingsValues.mDisplayOrientation != conf.orientation) {
    mHandler.startOrientationChanging();
    mInputLogic.finishInput();
  }
  PersonalizationDictionarySessionRegistrar.onConfigurationChanged(this,conf,mDictionaryFacilitator);
  super.onConfigurationChanged(conf);
}",0.797270955165692
87390,"/** 
 * Consider an update to the cursor position. Evaluate whether this update has happened as part of normal typing or whether it was an explicit cursor move by the user. In any case, do the necessary adjustments.
 * @param oldSelStart old selection start
 * @param oldSelEnd old selection end
 * @param newSelStart new selection start
 * @param newSelEnd new selection end
 * @return whether the cursor has moved as a result of user interaction.
 */
public boolean onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd){
  if (mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart,oldSelEnd,newSelEnd)) {
    return false;
  }
  mSpaceState=SpaceState.NONE;
  final boolean selectionChangedOrSafeToReset=oldSelStart != newSelStart || oldSelEnd != newSelEnd || !mWordComposer.isComposingWord();
  final boolean hasOrHadSelection=(oldSelStart != oldSelEnd || newSelStart != newSelEnd);
  final int moveAmount=newSelStart - oldSelStart;
  if (selectionChangedOrSafeToReset && (hasOrHadSelection || !mWordComposer.moveCursorByAndReturnIfInsideComposingWord(moveAmount))) {
    resetEntireInputState(newSelStart,newSelEnd,false);
  }
 else {
    mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,false);
  }
  mRecapitalizeStatus.enable();
  mLatinIME.mHandler.postResumeSuggestions();
  mRecapitalizeStatus.stop();
  return true;
}","/** 
 * Consider an update to the cursor position. Evaluate whether this update has happened as part of normal typing or whether it was an explicit cursor move by the user. In any case, do the necessary adjustments.
 * @param oldSelStart old selection start
 * @param oldSelEnd old selection end
 * @param newSelStart new selection start
 * @param newSelEnd new selection end
 * @return whether the cursor has moved as a result of user interaction.
 */
public boolean onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd){
  if (mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart,oldSelEnd,newSelEnd)) {
    return false;
  }
  mSpaceState=SpaceState.NONE;
  final boolean selectionChangedOrSafeToReset=oldSelStart != newSelStart || oldSelEnd != newSelEnd || !mWordComposer.isComposingWord();
  final boolean hasOrHadSelection=(oldSelStart != oldSelEnd || newSelStart != newSelEnd);
  final int moveAmount=newSelStart - oldSelStart;
  if (hasOrHadSelection || (selectionChangedOrSafeToReset && !mWordComposer.moveCursorByAndReturnIfInsideComposingWord(moveAmount))) {
    resetEntireInputState(newSelStart,newSelEnd,false);
  }
 else {
    mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,false);
  }
  mRecapitalizeStatus.enable();
  mLatinIME.mHandler.postResumeSuggestions();
  mRecapitalizeStatus.stop();
  return true;
}",0.9843971631205674
87391,"/** 
 * Retry resetting caches in the rich input connection. When the editor can't be accessed we can't reset the caches, so we schedule a retry. This method handles the retry, and re-schedules a new retry if we still can't access. We only retry up to 5 times before giving up.
 * @param settingsValues the current values of the settings.
 * @param tryResumeSuggestions Whether we should resume suggestions or not.
 * @param remainingTries How many times we may try again before giving up.
 * @return whether true if the caches were successfully reset, false otherwise.
 */
public boolean retryResetCachesAndReturnSuccess(final SettingsValues settingsValues,final boolean tryResumeSuggestions,final int remainingTries,final LatinIME.UIHandler handler){
  if (!mConnection.resetCachesUponCursorMoveAndReturnSuccess(mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),false)) {
    if (0 < remainingTries) {
      handler.postResetCaches(tryResumeSuggestions,remainingTries - 1);
      return false;
    }
  }
  mConnection.tryFixLyingCursorPosition();
  if (tryResumeSuggestions) {
    handler.postResumeSuggestions();
  }
  return true;
}","/** 
 * Retry resetting caches in the rich input connection. When the editor can't be accessed we can't reset the caches, so we schedule a retry. This method handles the retry, and re-schedules a new retry if we still can't access. We only retry up to 5 times before giving up.
 * @param settingsValues the current values of the settings.
 * @param tryResumeSuggestions Whether we should resume suggestions or not.
 * @param remainingTries How many times we may try again before giving up.
 * @return whether true if the caches were successfully reset, false otherwise.
 */
public boolean retryResetCachesAndReturnSuccess(final SettingsValues settingsValues,final boolean tryResumeSuggestions,final int remainingTries,final LatinIME.UIHandler handler){
  final boolean shouldFinishComposition=mConnection.hasSelection() || !mConnection.isCursorPositionKnown();
  if (!mConnection.resetCachesUponCursorMoveAndReturnSuccess(mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),shouldFinishComposition)) {
    if (0 < remainingTries) {
      handler.postResetCaches(tryResumeSuggestions,remainingTries - 1);
      return false;
    }
  }
  mConnection.tryFixLyingCursorPosition();
  if (tryResumeSuggestions) {
    handler.postResumeSuggestions();
  }
  return true;
}",0.9445802770986144
87392,"@Override public void onConfigurationChanged(final Configuration conf){
  final SettingsValues settingsValues=mSettings.getCurrent();
  if (settingsValues.mDisplayOrientation != conf.orientation) {
    mHandler.startOrientationChanging();
    mInputLogic.finishInput();
  }
  PersonalizationDictionarySessionRegistrar.onConfigurationChanged(this,conf,mDictionaryFacilitator);
  super.onConfigurationChanged(conf);
}","@Override public void onConfigurationChanged(final Configuration conf){
  final SettingsValues settingsValues=mSettings.getCurrent();
  if (settingsValues.mDisplayOrientation != conf.orientation) {
    mHandler.startOrientationChanging();
    if (mInputLogic.mWordComposer.isComposingWord()) {
      mInputLogic.mConnection.beginBatchEdit();
      mInputLogic.commitTyped(mSettings.getCurrent(),LastComposedWord.NOT_A_SEPARATOR);
      mInputLogic.mConnection.endBatchEdit();
    }
  }
  PersonalizationDictionarySessionRegistrar.onConfigurationChanged(this,conf,mDictionaryFacilitator);
  super.onConfigurationChanged(conf);
}",0.7850287907869482
87393,"@Override public void onConfigurationChanged(final Configuration conf){
  final SettingsValues settingsValues=mSettings.getCurrent();
  if (settingsValues.mDisplayOrientation != conf.orientation) {
    mHandler.startOrientationChanging();
    mInputLogic.mConnection.beginBatchEdit();
    mInputLogic.commitTyped(mSettings.getCurrent(),LastComposedWord.NOT_A_SEPARATOR);
    mInputLogic.mConnection.finishComposingText();
    mInputLogic.mConnection.endBatchEdit();
  }
  PersonalizationDictionarySessionRegistrar.onConfigurationChanged(this,conf,mDictionaryFacilitator);
  super.onConfigurationChanged(conf);
}","@Override public void onConfigurationChanged(final Configuration conf){
  final SettingsValues settingsValues=mSettings.getCurrent();
  if (settingsValues.mDisplayOrientation != conf.orientation) {
    mHandler.startOrientationChanging();
    mInputLogic.finishInput();
  }
  PersonalizationDictionarySessionRegistrar.onConfigurationChanged(this,conf,mDictionaryFacilitator);
  super.onConfigurationChanged(conf);
}",0.797270955165692
87394,"/** 
 * Consider an update to the cursor position. Evaluate whether this update has happened as part of normal typing or whether it was an explicit cursor move by the user. In any case, do the necessary adjustments.
 * @param oldSelStart old selection start
 * @param oldSelEnd old selection end
 * @param newSelStart new selection start
 * @param newSelEnd new selection end
 * @return whether the cursor has moved as a result of user interaction.
 */
public boolean onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd){
  if (mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart,oldSelEnd,newSelEnd)) {
    return false;
  }
  mSpaceState=SpaceState.NONE;
  final boolean selectionChangedOrSafeToReset=oldSelStart != newSelStart || oldSelEnd != newSelEnd || !mWordComposer.isComposingWord();
  final boolean hasOrHadSelection=(oldSelStart != oldSelEnd || newSelStart != newSelEnd);
  final int moveAmount=newSelStart - oldSelStart;
  if (selectionChangedOrSafeToReset && (hasOrHadSelection || !mWordComposer.moveCursorByAndReturnIfInsideComposingWord(moveAmount))) {
    resetEntireInputState(newSelStart,newSelEnd,false);
  }
 else {
    mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,false);
  }
  mRecapitalizeStatus.enable();
  mLatinIME.mHandler.postResumeSuggestions();
  mRecapitalizeStatus.stop();
  return true;
}","/** 
 * Consider an update to the cursor position. Evaluate whether this update has happened as part of normal typing or whether it was an explicit cursor move by the user. In any case, do the necessary adjustments.
 * @param oldSelStart old selection start
 * @param oldSelEnd old selection end
 * @param newSelStart new selection start
 * @param newSelEnd new selection end
 * @return whether the cursor has moved as a result of user interaction.
 */
public boolean onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd){
  if (mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart,oldSelEnd,newSelEnd)) {
    return false;
  }
  mSpaceState=SpaceState.NONE;
  final boolean selectionChangedOrSafeToReset=oldSelStart != newSelStart || oldSelEnd != newSelEnd || !mWordComposer.isComposingWord();
  final boolean hasOrHadSelection=(oldSelStart != oldSelEnd || newSelStart != newSelEnd);
  final int moveAmount=newSelStart - oldSelStart;
  if (hasOrHadSelection || (selectionChangedOrSafeToReset && !mWordComposer.moveCursorByAndReturnIfInsideComposingWord(moveAmount))) {
    resetEntireInputState(newSelStart,newSelEnd,false);
  }
 else {
    mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,false);
  }
  mRecapitalizeStatus.enable();
  mLatinIME.mHandler.postResumeSuggestions();
  mRecapitalizeStatus.stop();
  return true;
}",0.9843971631205674
87395,"/** 
 * Retry resetting caches in the rich input connection. When the editor can't be accessed we can't reset the caches, so we schedule a retry. This method handles the retry, and re-schedules a new retry if we still can't access. We only retry up to 5 times before giving up.
 * @param settingsValues the current values of the settings.
 * @param tryResumeSuggestions Whether we should resume suggestions or not.
 * @param remainingTries How many times we may try again before giving up.
 * @return whether true if the caches were successfully reset, false otherwise.
 */
public boolean retryResetCachesAndReturnSuccess(final SettingsValues settingsValues,final boolean tryResumeSuggestions,final int remainingTries,final LatinIME.UIHandler handler){
  if (!mConnection.resetCachesUponCursorMoveAndReturnSuccess(mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),false)) {
    if (0 < remainingTries) {
      handler.postResetCaches(tryResumeSuggestions,remainingTries - 1);
      return false;
    }
  }
  mConnection.tryFixLyingCursorPosition();
  if (tryResumeSuggestions) {
    handler.postResumeSuggestions();
  }
  return true;
}","/** 
 * Retry resetting caches in the rich input connection. When the editor can't be accessed we can't reset the caches, so we schedule a retry. This method handles the retry, and re-schedules a new retry if we still can't access. We only retry up to 5 times before giving up.
 * @param settingsValues the current values of the settings.
 * @param tryResumeSuggestions Whether we should resume suggestions or not.
 * @param remainingTries How many times we may try again before giving up.
 * @return whether true if the caches were successfully reset, false otherwise.
 */
public boolean retryResetCachesAndReturnSuccess(final SettingsValues settingsValues,final boolean tryResumeSuggestions,final int remainingTries,final LatinIME.UIHandler handler){
  final boolean shouldFinishComposition=mConnection.hasSelection() || !mConnection.isCursorPositionKnown();
  if (!mConnection.resetCachesUponCursorMoveAndReturnSuccess(mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),shouldFinishComposition)) {
    if (0 < remainingTries) {
      handler.postResetCaches(tryResumeSuggestions,remainingTries - 1);
      return false;
    }
  }
  mConnection.tryFixLyingCursorPosition();
  if (tryResumeSuggestions) {
    handler.postResumeSuggestions();
  }
  return true;
}",0.9445802770986144
87396,"private void onDownEvent(final int x,final int y,final long eventTime,final KeyDetector keyDetector){
  if (DEBUG_EVENT) {
    printTouchEvent(""String_Node_Str"",x,y,eventTime);
  }
  setKeyDetectorInner(keyDetector);
  final long deltaT=eventTime - mUpTime;
  if (deltaT < sParams.mTouchNoiseThresholdTime) {
    final int distance=getDistance(x,y,mLastX,mLastY);
    if (distance < sParams.mTouchNoiseThresholdDistance) {
      if (DEBUG_MODE)       Log.w(TAG,String.format(""String_Node_Str"" + ""String_Node_Str"",mPointerId,deltaT,distance));
      cancelTrackingForAction();
      return;
    }
  }
  final Key key=getKeyOn(x,y);
  mBogusMoveEventDetector.onActualDownEvent(x,y);
  if (key != null && key.isModifier()) {
    sPointerTrackerQueue.releaseAllPointers(eventTime);
  }
  sPointerTrackerQueue.add(this);
  onDownEventInternal(x,y,eventTime);
  if (!sGestureEnabler.shouldHandleGesture()) {
    return;
  }
  mIsDetectingGesture=(mKeyboard != null) && mKeyboard.mId.isAlphabetKeyboard() && key != null && !key.isModifier();
  if (mIsDetectingGesture) {
    mBatchInputArbiter.addDownEventPoint(x,y,eventTime,sTypingTimeRecorder.getLastLetterTypingTime(),getActivePointerTrackerCount());
    mGestureStrokeDrawingPoints.onDownEvent(x,y,mBatchInputArbiter.getElapsedTimeSinceFirstDown(eventTime));
  }
}","private void onDownEvent(final int x,final int y,final long eventTime,final KeyDetector keyDetector){
  setKeyDetectorInner(keyDetector);
  if (DEBUG_EVENT) {
    printTouchEvent(""String_Node_Str"",x,y,eventTime);
  }
  final long deltaT=eventTime - mUpTime;
  if (deltaT < sParams.mTouchNoiseThresholdTime) {
    final int distance=getDistance(x,y,mLastX,mLastY);
    if (distance < sParams.mTouchNoiseThresholdDistance) {
      if (DEBUG_MODE)       Log.w(TAG,String.format(""String_Node_Str"" + ""String_Node_Str"",mPointerId,deltaT,distance));
      cancelTrackingForAction();
      return;
    }
  }
  final Key key=getKeyOn(x,y);
  mBogusMoveEventDetector.onActualDownEvent(x,y);
  if (key != null && key.isModifier()) {
    sPointerTrackerQueue.releaseAllPointers(eventTime);
  }
  sPointerTrackerQueue.add(this);
  onDownEventInternal(x,y,eventTime);
  if (!sGestureEnabler.shouldHandleGesture()) {
    return;
  }
  mIsDetectingGesture=(mKeyboard != null) && mKeyboard.mId.isAlphabetKeyboard() && key != null && !key.isModifier();
  if (mIsDetectingGesture) {
    mBatchInputArbiter.addDownEventPoint(x,y,eventTime,sTypingTimeRecorder.getLastLetterTypingTime(),getActivePointerTrackerCount());
    mGestureStrokeDrawingPoints.onDownEvent(x,y,mBatchInputArbiter.getElapsedTimeSinceFirstDown(eventTime));
  }
}",0.972560975609756
87397,"/** 
 * Determine what caps mode should be in effect at the current offset in the text. Only the mode bits set in <var>reqModes</var> will be checked. Note that the caps mode flags here are explicitly defined to match those in   {@link InputType}. This code is a straight copy of TextUtils.getCapsMode (modulo namespace and formatting issues). This will change in the future as we simplify the code for our use and fix bugs.
 * @param cs The text that should be checked for caps modes.
 * @param reqModes The modes to be checked: may be any combination of{@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 * @param spacingAndPunctuations The current spacing and punctuations settings.
 * @param hasSpaceBefore Whether we should consider there is a space inserted at the end of cs
 * @return Returns the actual capitalization modes that can be in effectat the current position, which is any combination of {@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 */
public static int getCapsMode(final CharSequence cs,final int reqModes,final SpacingAndPunctuations spacingAndPunctuations,final boolean hasSpaceBefore){
  if ((reqModes & (TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES)) == 0) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  int i;
  if (hasSpaceBefore) {
    i=cs.length() + 1;
  }
 else {
    for (i=cs.length(); i > 0; i--) {
      final char c=cs.charAt(i - 1);
      if (c != Constants.CODE_DOUBLE_QUOTE && c != Constants.CODE_SINGLE_QUOTE && Character.getType(c) != Character.START_PUNCTUATION) {
        break;
      }
    }
  }
  int j=i;
  char prevChar=Constants.CODE_SPACE;
  if (hasSpaceBefore)   --j;
  while (j > 0) {
    prevChar=cs.charAt(j - 1);
    if (!Character.isSpaceChar(prevChar) && prevChar != Constants.CODE_TAB)     break;
    j--;
  }
  if (j <= 0 || Character.isWhitespace(prevChar)) {
    if (spacingAndPunctuations.mUsesGermanRules) {
      boolean hasNewLine=false;
      while (--j >= 0 && Character.isWhitespace(prevChar)) {
        if (Constants.CODE_ENTER == prevChar) {
          hasNewLine=true;
        }
        prevChar=cs.charAt(j);
      }
      if (Constants.CODE_COMMA == prevChar && hasNewLine) {
        return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
      }
    }
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (i == j) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  if ((reqModes & TextUtils.CAP_MODE_SENTENCES) == 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  if (spacingAndPunctuations.mUsesAmericanTypography) {
    for (; j > 0; j--) {
      final char c=cs.charAt(j - 1);
      if (c != Constants.CODE_DOUBLE_QUOTE && c != Constants.CODE_SINGLE_QUOTE && Character.getType(c) != Character.END_PUNCTUATION) {
        break;
      }
    }
  }
  if (j <= 0)   return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  char c=cs.charAt(--j);
  if (c == Constants.CODE_QUESTION_MARK || c == Constants.CODE_EXCLAMATION_MARK) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (!spacingAndPunctuations.isSentenceSeparator(c) || j <= 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  final int START=0;
  final int WORD=1;
  final int PERIOD=2;
  final int LETTER=3;
  final int caps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  final int noCaps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  int state=START;
  while (j > 0) {
    c=cs.charAt(--j);
switch (state) {
case START:
      if (Character.isLetter(c)) {
        state=WORD;
      }
 else       if (Character.isWhitespace(c)) {
        return noCaps;
      }
 else {
        return caps;
      }
    break;
case WORD:
  if (Character.isLetter(c)) {
    state=WORD;
  }
 else   if (spacingAndPunctuations.isSentenceSeparator(c)) {
    state=PERIOD;
  }
 else {
    return caps;
  }
break;
case PERIOD:
if (Character.isLetter(c)) {
state=LETTER;
}
 else {
return caps;
}
break;
case LETTER:
if (Character.isLetter(c)) {
state=LETTER;
}
 else if (spacingAndPunctuations.isSentenceSeparator(c)) {
state=PERIOD;
}
 else {
return noCaps;
}
}
}
return (START == state || LETTER == state) ? noCaps : caps;
}","/** 
 * Determine what caps mode should be in effect at the current offset in the text. Only the mode bits set in <var>reqModes</var> will be checked. Note that the caps mode flags here are explicitly defined to match those in   {@link InputType}. This code is a straight copy of TextUtils.getCapsMode (modulo namespace and formatting issues). This will change in the future as we simplify the code for our use and fix bugs.
 * @param cs The text that should be checked for caps modes.
 * @param reqModes The modes to be checked: may be any combination of{@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 * @param spacingAndPunctuations The current spacing and punctuations settings.
 * @param hasSpaceBefore Whether we should consider there is a space inserted at the end of cs
 * @return Returns the actual capitalization modes that can be in effectat the current position, which is any combination of {@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 */
public static int getCapsMode(final CharSequence cs,final int reqModes,final SpacingAndPunctuations spacingAndPunctuations,final boolean hasSpaceBefore){
  if ((reqModes & (TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES)) == 0) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  int i;
  if (hasSpaceBefore) {
    i=cs.length() + 1;
  }
 else {
    for (i=cs.length(); i > 0; i--) {
      final char c=cs.charAt(i - 1);
      if (!isStartPunctuation(c)) {
        break;
      }
    }
  }
  int j=i;
  char prevChar=Constants.CODE_SPACE;
  if (hasSpaceBefore)   --j;
  while (j > 0) {
    prevChar=cs.charAt(j - 1);
    if (!Character.isSpaceChar(prevChar) && prevChar != Constants.CODE_TAB)     break;
    j--;
  }
  if (j <= 0 || Character.isWhitespace(prevChar)) {
    if (spacingAndPunctuations.mUsesGermanRules) {
      boolean hasNewLine=false;
      while (--j >= 0 && Character.isWhitespace(prevChar)) {
        if (Constants.CODE_ENTER == prevChar) {
          hasNewLine=true;
        }
        prevChar=cs.charAt(j);
      }
      if (Constants.CODE_COMMA == prevChar && hasNewLine) {
        return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
      }
    }
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (i == j) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  if ((reqModes & TextUtils.CAP_MODE_SENTENCES) == 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  if (spacingAndPunctuations.mUsesAmericanTypography) {
    for (; j > 0; j--) {
      final char c=cs.charAt(j - 1);
      if (c != Constants.CODE_DOUBLE_QUOTE && c != Constants.CODE_SINGLE_QUOTE && Character.getType(c) != Character.END_PUNCTUATION) {
        break;
      }
    }
  }
  if (j <= 0)   return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  char c=cs.charAt(--j);
  if (c == Constants.CODE_QUESTION_MARK || c == Constants.CODE_EXCLAMATION_MARK) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (!spacingAndPunctuations.isSentenceSeparator(c) || j <= 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  final int START=0;
  final int WORD=1;
  final int PERIOD=2;
  final int LETTER=3;
  final int NUMBER=4;
  final int caps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  final int noCaps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  int state=START;
  while (j > 0) {
    c=cs.charAt(--j);
switch (state) {
case START:
      if (Character.isLetter(c)) {
        state=WORD;
      }
 else       if (Character.isWhitespace(c)) {
        return noCaps;
      }
 else       if (Character.isDigit(c) && spacingAndPunctuations.mUsesGermanRules) {
        state=NUMBER;
      }
 else {
        return caps;
      }
    break;
case WORD:
  if (Character.isLetter(c)) {
    state=WORD;
  }
 else   if (spacingAndPunctuations.isSentenceSeparator(c)) {
    state=PERIOD;
  }
 else {
    return caps;
  }
break;
case PERIOD:
if (Character.isLetter(c)) {
state=LETTER;
}
 else {
return caps;
}
break;
case LETTER:
if (Character.isLetter(c)) {
state=LETTER;
}
 else if (spacingAndPunctuations.isSentenceSeparator(c)) {
state=PERIOD;
}
 else {
return noCaps;
}
break;
case NUMBER:
if (Character.isLetter(c)) {
state=WORD;
}
 else if (Character.isDigit(c)) {
state=NUMBER;
}
 else {
return noCaps;
}
}
}
return (START == state || LETTER == state) ? noCaps : caps;
}",0.3903289043781311
87398,"/** 
 * Determine what caps mode should be in effect at the current offset in the text. Only the mode bits set in <var>reqModes</var> will be checked. Note that the caps mode flags here are explicitly defined to match those in   {@link InputType}. This code is a straight copy of TextUtils.getCapsMode (modulo namespace and formatting issues). This will change in the future as we simplify the code for our use and fix bugs.
 * @param cs The text that should be checked for caps modes.
 * @param reqModes The modes to be checked: may be any combination of{@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 * @param spacingAndPunctuations The current spacing and punctuations settings.
 * @param hasSpaceBefore Whether we should consider there is a space inserted at the end of cs
 * @return Returns the actual capitalization modes that can be in effectat the current position, which is any combination of {@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 */
public static int getCapsMode(final CharSequence cs,final int reqModes,final SpacingAndPunctuations spacingAndPunctuations,final boolean hasSpaceBefore){
  if ((reqModes & (TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES)) == 0) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  int i;
  if (hasSpaceBefore) {
    i=cs.length() + 1;
  }
 else {
    for (i=cs.length(); i > 0; i--) {
      final char c=cs.charAt(i - 1);
      if (c != Constants.CODE_DOUBLE_QUOTE && c != Constants.CODE_SINGLE_QUOTE && Character.getType(c) != Character.START_PUNCTUATION) {
        break;
      }
    }
  }
  int j=i;
  char prevChar=Constants.CODE_SPACE;
  if (hasSpaceBefore)   --j;
  while (j > 0) {
    prevChar=cs.charAt(j - 1);
    if (!Character.isSpaceChar(prevChar) && prevChar != Constants.CODE_TAB)     break;
    j--;
  }
  if (j <= 0 || Character.isWhitespace(prevChar)) {
    if (spacingAndPunctuations.mUsesGermanRules) {
      boolean hasNewLine=false;
      while (--j >= 0 && Character.isWhitespace(prevChar)) {
        if (Constants.CODE_ENTER == prevChar) {
          hasNewLine=true;
        }
        prevChar=cs.charAt(j);
      }
      if (Constants.CODE_COMMA == prevChar && hasNewLine) {
        return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
      }
    }
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (i == j) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  if ((reqModes & TextUtils.CAP_MODE_SENTENCES) == 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  if (spacingAndPunctuations.mUsesAmericanTypography) {
    for (; j > 0; j--) {
      final char c=cs.charAt(j - 1);
      if (c != Constants.CODE_DOUBLE_QUOTE && c != Constants.CODE_SINGLE_QUOTE && Character.getType(c) != Character.END_PUNCTUATION) {
        break;
      }
    }
  }
  if (j <= 0)   return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  char c=cs.charAt(--j);
  if (c == Constants.CODE_QUESTION_MARK || c == Constants.CODE_EXCLAMATION_MARK) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (!spacingAndPunctuations.isSentenceSeparator(c) || j <= 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  final int START=0;
  final int WORD=1;
  final int PERIOD=2;
  final int LETTER=3;
  final int caps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  final int noCaps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  int state=START;
  while (j > 0) {
    c=cs.charAt(--j);
switch (state) {
case START:
      if (Character.isLetter(c)) {
        state=WORD;
      }
 else       if (Character.isWhitespace(c)) {
        return noCaps;
      }
 else {
        return caps;
      }
    break;
case WORD:
  if (Character.isLetter(c)) {
    state=WORD;
  }
 else   if (spacingAndPunctuations.isSentenceSeparator(c)) {
    state=PERIOD;
  }
 else {
    return caps;
  }
break;
case PERIOD:
if (Character.isLetter(c)) {
state=LETTER;
}
 else {
return caps;
}
break;
case LETTER:
if (Character.isLetter(c)) {
state=LETTER;
}
 else if (spacingAndPunctuations.isSentenceSeparator(c)) {
state=PERIOD;
}
 else {
return noCaps;
}
}
}
return (START == state || LETTER == state) ? noCaps : caps;
}","/** 
 * Determine what caps mode should be in effect at the current offset in the text. Only the mode bits set in <var>reqModes</var> will be checked. Note that the caps mode flags here are explicitly defined to match those in   {@link InputType}. This code is a straight copy of TextUtils.getCapsMode (modulo namespace and formatting issues). This will change in the future as we simplify the code for our use and fix bugs.
 * @param cs The text that should be checked for caps modes.
 * @param reqModes The modes to be checked: may be any combination of{@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 * @param spacingAndPunctuations The current spacing and punctuations settings.
 * @param hasSpaceBefore Whether we should consider there is a space inserted at the end of cs
 * @return Returns the actual capitalization modes that can be in effectat the current position, which is any combination of {@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 */
public static int getCapsMode(final CharSequence cs,final int reqModes,final SpacingAndPunctuations spacingAndPunctuations,final boolean hasSpaceBefore){
  if ((reqModes & (TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES)) == 0) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  int i;
  if (hasSpaceBefore) {
    i=cs.length() + 1;
  }
 else {
    for (i=cs.length(); i > 0; i--) {
      final char c=cs.charAt(i - 1);
      if (!isStartPunctuation(c)) {
        break;
      }
    }
  }
  int j=i;
  char prevChar=Constants.CODE_SPACE;
  if (hasSpaceBefore)   --j;
  while (j > 0) {
    prevChar=cs.charAt(j - 1);
    if (!Character.isSpaceChar(prevChar) && prevChar != Constants.CODE_TAB)     break;
    j--;
  }
  if (j <= 0 || Character.isWhitespace(prevChar)) {
    if (spacingAndPunctuations.mUsesGermanRules) {
      boolean hasNewLine=false;
      while (--j >= 0 && Character.isWhitespace(prevChar)) {
        if (Constants.CODE_ENTER == prevChar) {
          hasNewLine=true;
        }
        prevChar=cs.charAt(j);
      }
      if (Constants.CODE_COMMA == prevChar && hasNewLine) {
        return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
      }
    }
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (i == j) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  if ((reqModes & TextUtils.CAP_MODE_SENTENCES) == 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  if (spacingAndPunctuations.mUsesAmericanTypography) {
    for (; j > 0; j--) {
      final char c=cs.charAt(j - 1);
      if (c != Constants.CODE_DOUBLE_QUOTE && c != Constants.CODE_SINGLE_QUOTE && Character.getType(c) != Character.END_PUNCTUATION) {
        break;
      }
    }
  }
  if (j <= 0)   return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  char c=cs.charAt(--j);
  if (c == Constants.CODE_QUESTION_MARK || c == Constants.CODE_EXCLAMATION_MARK) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (!spacingAndPunctuations.isSentenceSeparator(c) || j <= 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  final int START=0;
  final int WORD=1;
  final int PERIOD=2;
  final int LETTER=3;
  final int NUMBER=4;
  final int caps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  final int noCaps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  int state=START;
  while (j > 0) {
    c=cs.charAt(--j);
switch (state) {
case START:
      if (Character.isLetter(c)) {
        state=WORD;
      }
 else       if (Character.isWhitespace(c)) {
        return noCaps;
      }
 else       if (Character.isDigit(c) && spacingAndPunctuations.mUsesGermanRules) {
        state=NUMBER;
      }
 else {
        return caps;
      }
    break;
case WORD:
  if (Character.isLetter(c)) {
    state=WORD;
  }
 else   if (spacingAndPunctuations.isSentenceSeparator(c)) {
    state=PERIOD;
  }
 else {
    return caps;
  }
break;
case PERIOD:
if (Character.isLetter(c)) {
state=LETTER;
}
 else {
return caps;
}
break;
case LETTER:
if (Character.isLetter(c)) {
state=LETTER;
}
 else if (spacingAndPunctuations.isSentenceSeparator(c)) {
state=PERIOD;
}
 else {
return noCaps;
}
break;
case NUMBER:
if (Character.isLetter(c)) {
state=WORD;
}
 else if (Character.isDigit(c)) {
state=NUMBER;
}
 else {
return noCaps;
}
}
}
return (START == state || LETTER == state) ? noCaps : caps;
}",0.3903289043781311
87399,"/** 
 * Create an combiner chain. The combiner chain takes events as inputs and outputs code points and combining state. For example, if the input language is Japanese, the combining chain will typically perform kana conversion.
 * @param combinerList A list of combiners to be applied in order.
 */
public CombinerChain(final Combiner... combinerList){
  mCombiners=CollectionUtils.newArrayList();
  mCombiners.add(new DeadKeyCombiner());
  for (  final Combiner combiner : combinerList) {
    mCombiners.add(combiner);
  }
  mCombinedText=new StringBuilder();
  mStateFeedback=new SpannableStringBuilder();
}","/** 
 * Create an combiner chain. The combiner chain takes events as inputs and outputs code points and combining state. For example, if the input language is Japanese, the combining chain will typically perform kana conversion. This takes a string for initial text, taken to be present before the cursor: we'll start after this.
 * @param initialText The text that has already been combined so far.
 * @param combinerList A list of combiners to be applied in order.
 */
public CombinerChain(final String initialText,final Combiner... combinerList){
  mCombiners=CollectionUtils.newArrayList();
  mCombiners.add(new DeadKeyCombiner());
  for (  final Combiner combiner : combinerList) {
    mCombiners.add(combiner);
  }
  mCombinedText=new StringBuilder(initialText);
  mStateFeedback=new SpannableStringBuilder();
}",0.8549404344779257
87400,"public WordComposer(){
  mCombinerChain=new CombinerChain();
  mEvents=CollectionUtils.newArrayList();
  mAutoCorrection=null;
  mIsResumed=false;
  mIsBatchMode=false;
  mCursorPositionWithinWord=0;
  mRejectedBatchModeSuggestion=null;
  mPreviousWordForSuggestion=null;
  refreshTypedWordCache();
}","public WordComposer(){
  mCombinerChain=new CombinerChain(""String_Node_Str"");
  mEvents=CollectionUtils.newArrayList();
  mAutoCorrection=null;
  mIsResumed=false;
  mIsBatchMode=false;
  mCursorPositionWithinWord=0;
  mRejectedBatchModeSuggestion=null;
  mPreviousWordForSuggestion=null;
  refreshTypedWordCache();
}",0.9724473257698542
87401,"/** 
 * Initializes the input logic for input in an editor. Call this when input starts or restarts in some editor (typically, in onStartInputView). If the input is starting in the same field as before, set `restarting' to true. This allows the input logic to reset only necessary stuff and save performance. Also, when restarting some things must not be done (for example, the keyboard should not be reset to the alphabetic layout), so do not send false to this just in case.
 * @param restarting whether input is starting in the same field as before. Unused for now.
 * @param editorInfo the editorInfo associated with the editor.
 * @param combiningSpec the combining spec string for this subtype
 */
public void startInput(final boolean restarting,final EditorInfo editorInfo,final String combiningSpec){
  mEnteredText=null;
  mWordComposer.restart(combiningSpec);
  resetComposingState(true);
  mDeleteCount=0;
  mSpaceState=SpaceState.NONE;
  mRecapitalizeStatus.deactivate();
  mCurrentlyPressedHardwareKeys.clear();
  mSuggestedWords=SuggestedWords.EMPTY;
  mConnection.tryFixLyingCursorPosition();
  cancelDoubleSpacePeriodCountdown();
  if (InputLogicHandler.NULL_HANDLER == mInputLogicHandler) {
    mInputLogicHandler=new InputLogicHandler(mLatinIME,this);
  }
 else {
    mInputLogicHandler.reset();
  }
}","/** 
 * Initializes the input logic for input in an editor. Call this when input starts or restarts in some editor (typically, in onStartInputView). If the input is starting in the same field as before, set `restarting' to true. This allows the input logic to reset only necessary stuff and save performance. Also, when restarting some things must not be done (for example, the keyboard should not be reset to the alphabetic layout), so do not send false to this just in case.
 * @param restarting whether input is starting in the same field as before. Unused for now.
 * @param editorInfo the editorInfo associated with the editor.
 * @param combiningSpec the combining spec string for this subtype
 */
public void startInput(final boolean restarting,final EditorInfo editorInfo,final String combiningSpec){
  mEnteredText=null;
  mWordComposer.restartCombining(combiningSpec);
  resetComposingState(true);
  mDeleteCount=0;
  mSpaceState=SpaceState.NONE;
  mRecapitalizeStatus.deactivate();
  mCurrentlyPressedHardwareKeys.clear();
  mSuggestedWords=SuggestedWords.EMPTY;
  mConnection.tryFixLyingCursorPosition();
  cancelDoubleSpacePeriodCountdown();
  if (InputLogicHandler.NULL_HANDLER == mInputLogicHandler) {
    mInputLogicHandler=new InputLogicHandler(mLatinIME,this);
  }
 else {
    mInputLogicHandler.reset();
  }
}",0.9965999244427654
87402,"/** 
 * Call this when the subtype changes.
 * @param combiningSpec the spec string for the combining rules
 */
public void onSubtypeChanged(final String combiningSpec){
  mWordComposer.restart(combiningSpec);
}","/** 
 * Call this when the subtype changes.
 * @param combiningSpec the spec string for the combining rules
 */
public void onSubtypeChanged(final String combiningSpec){
  mWordComposer.restartCombining(combiningSpec);
}",0.9791183294663574
87403,"public CombinerChain(final Combiner... combinerList){
}","public CombinerChain(final String initialText,final Combiner... combinerList){
  mComposingWord=new StringBuilder(initialText);
}",0.5978260869565217
87404,"/** 
 * Create an combiner chain. The combiner chain takes events as inputs and outputs code points and combining state. For example, if the input language is Japanese, the combining chain will typically perform kana conversion.
 * @param combinerList A list of combiners to be applied in order.
 */
public CombinerChain(final Combiner... combinerList){
  mCombiners=CollectionUtils.newArrayList();
  mCombiners.add(new DeadKeyCombiner());
  for (  final Combiner combiner : combinerList) {
    mCombiners.add(combiner);
  }
  mCombinedText=new StringBuilder();
  mStateFeedback=new SpannableStringBuilder();
}","/** 
 * Create an combiner chain. The combiner chain takes events as inputs and outputs code points and combining state. For example, if the input language is Japanese, the combining chain will typically perform kana conversion. This takes a string for initial text, taken to be present before the cursor: we'll start after this.
 * @param initialText The text that has already been combined so far.
 * @param combinerList A list of combiners to be applied in order.
 */
public CombinerChain(final String initialText,final Combiner... combinerList){
  mCombiners=CollectionUtils.newArrayList();
  mCombiners.add(new DeadKeyCombiner());
  for (  final Combiner combiner : combinerList) {
    mCombiners.add(combiner);
  }
  mCombinedText=new StringBuilder(initialText);
  mStateFeedback=new SpannableStringBuilder();
}",0.8549404344779257
87405,"public WordComposer(){
  mCombinerChain=new CombinerChain();
  mEvents=CollectionUtils.newArrayList();
  mAutoCorrection=null;
  mIsResumed=false;
  mIsBatchMode=false;
  mCursorPositionWithinWord=0;
  mRejectedBatchModeSuggestion=null;
  mPreviousWordForSuggestion=null;
  refreshTypedWordCache();
}","public WordComposer(){
  mCombinerChain=new CombinerChain(""String_Node_Str"");
  mEvents=CollectionUtils.newArrayList();
  mAutoCorrection=null;
  mIsResumed=false;
  mIsBatchMode=false;
  mCursorPositionWithinWord=0;
  mRejectedBatchModeSuggestion=null;
  mPreviousWordForSuggestion=null;
  refreshTypedWordCache();
}",0.9724473257698542
87406,"/** 
 * Initializes the input logic for input in an editor. Call this when input starts or restarts in some editor (typically, in onStartInputView). If the input is starting in the same field as before, set `restarting' to true. This allows the input logic to reset only necessary stuff and save performance. Also, when restarting some things must not be done (for example, the keyboard should not be reset to the alphabetic layout), so do not send false to this just in case.
 * @param restarting whether input is starting in the same field as before. Unused for now.
 * @param editorInfo the editorInfo associated with the editor.
 * @param combiningSpec the combining spec string for this subtype
 */
public void startInput(final boolean restarting,final EditorInfo editorInfo,final String combiningSpec){
  mEnteredText=null;
  mWordComposer.restart(combiningSpec);
  resetComposingState(true);
  mDeleteCount=0;
  mSpaceState=SpaceState.NONE;
  mRecapitalizeStatus.deactivate();
  mCurrentlyPressedHardwareKeys.clear();
  mSuggestedWords=SuggestedWords.EMPTY;
  mConnection.tryFixLyingCursorPosition();
  cancelDoubleSpacePeriodCountdown();
  if (InputLogicHandler.NULL_HANDLER == mInputLogicHandler) {
    mInputLogicHandler=new InputLogicHandler(mLatinIME,this);
  }
 else {
    mInputLogicHandler.reset();
  }
}","/** 
 * Initializes the input logic for input in an editor. Call this when input starts or restarts in some editor (typically, in onStartInputView). If the input is starting in the same field as before, set `restarting' to true. This allows the input logic to reset only necessary stuff and save performance. Also, when restarting some things must not be done (for example, the keyboard should not be reset to the alphabetic layout), so do not send false to this just in case.
 * @param restarting whether input is starting in the same field as before. Unused for now.
 * @param editorInfo the editorInfo associated with the editor.
 * @param combiningSpec the combining spec string for this subtype
 */
public void startInput(final boolean restarting,final EditorInfo editorInfo,final String combiningSpec){
  mEnteredText=null;
  mWordComposer.restartCombining(combiningSpec);
  resetComposingState(true);
  mDeleteCount=0;
  mSpaceState=SpaceState.NONE;
  mRecapitalizeStatus.deactivate();
  mCurrentlyPressedHardwareKeys.clear();
  mSuggestedWords=SuggestedWords.EMPTY;
  mConnection.tryFixLyingCursorPosition();
  cancelDoubleSpacePeriodCountdown();
  if (InputLogicHandler.NULL_HANDLER == mInputLogicHandler) {
    mInputLogicHandler=new InputLogicHandler(mLatinIME,this);
  }
 else {
    mInputLogicHandler.reset();
  }
}",0.9965999244427654
87407,"/** 
 * Call this when the subtype changes.
 * @param combiningSpec the spec string for the combining rules
 */
public void onSubtypeChanged(final String combiningSpec){
  mWordComposer.restart(combiningSpec);
}","/** 
 * Call this when the subtype changes.
 * @param combiningSpec the spec string for the combining rules
 */
public void onSubtypeChanged(final String combiningSpec){
  mWordComposer.restartCombining(combiningSpec);
}",0.9791183294663574
87408,"public CombinerChain(final Combiner... combinerList){
}","public CombinerChain(final String initialText,final Combiner... combinerList){
  mComposingWord=new StringBuilder(initialText);
}",0.5978260869565217
87409,"@Override public ArrayList<SuggestedWordInfo> getSuggestionsWithSessionId(final WordComposer composer,final String prevWord,final ProximityInfo proximityInfo,final boolean blockOffensiveWords,final int[] additionalFeaturesOptions,final int sessionId,final float[] inOutLanguageWeight){
  if (!isValidDictionary()) {
    return null;
  }
  Arrays.fill(mInputCodePoints,Constants.NOT_A_CODE);
  final int[] prevWordCodePointArray=(null == prevWord) ? null : StringUtils.toCodePointArray(prevWord);
  final InputPointers inputPointers=composer.getInputPointers();
  final boolean isGesture=composer.isBatchMode();
  final int inputSize;
  if (!isGesture) {
    inputSize=composer.copyCodePointsExceptTrailingSingleQuotesAndReturnCodePointCount(mInputCodePoints,MAX_WORD_LENGTH);
    if (inputSize < 0) {
      return null;
    }
  }
 else {
    inputSize=inputPointers.getPointerSize();
  }
  mNativeSuggestOptions.setIsGesture(isGesture);
  mNativeSuggestOptions.setAdditionalFeaturesOptions(additionalFeaturesOptions);
  if (inOutLanguageWeight != null) {
    mInputOutputLanguageWeight[0]=inOutLanguageWeight[0];
  }
 else {
    mInputOutputLanguageWeight[0]=Dictionary.NOT_A_LANGUAGE_WEIGHT;
  }
  getSuggestionsNative(mNativeDict,proximityInfo.getNativeProximityInfo(),getTraverseSession(sessionId).getSession(),inputPointers.getXCoordinates(),inputPointers.getYCoordinates(),inputPointers.getTimes(),inputPointers.getPointerIds(),mInputCodePoints,inputSize,mNativeSuggestOptions.getOptions(),prevWordCodePointArray,mOutputSuggestionCount,mOutputCodePoints,mOutputScores,mSpaceIndices,mOutputTypes,mOutputAutoCommitFirstWordConfidence,mInputOutputLanguageWeight);
  if (inOutLanguageWeight != null) {
    inOutLanguageWeight[0]=mInputOutputLanguageWeight[0];
  }
  final int count=mOutputSuggestionCount[0];
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  for (int j=0; j < count; ++j) {
    final int start=j * MAX_WORD_LENGTH;
    int len=0;
    while (len < MAX_WORD_LENGTH && mOutputCodePoints[start + len] != 0) {
      ++len;
    }
    if (len > 0) {
      final int flags=mOutputTypes[j] & SuggestedWordInfo.KIND_MASK_FLAGS;
      if (blockOffensiveWords && 0 != (flags & SuggestedWordInfo.KIND_FLAG_POSSIBLY_OFFENSIVE) && 0 == (flags & SuggestedWordInfo.KIND_FLAG_EXACT_MATCH)) {
        continue;
      }
      final int kind=mOutputTypes[j] & SuggestedWordInfo.KIND_MASK_KIND;
      final int score=SuggestedWordInfo.KIND_WHITELIST == kind ? SuggestedWordInfo.MAX_SCORE : mOutputScores[j];
      suggestions.add(new SuggestedWordInfo(new String(mOutputCodePoints,start,len),score,kind,this,mSpaceIndices[j],mOutputAutoCommitFirstWordConfidence[0]));
    }
  }
  return suggestions;
}","@Override public ArrayList<SuggestedWordInfo> getSuggestionsWithSessionId(final WordComposer composer,final String prevWord,final ProximityInfo proximityInfo,final boolean blockOffensiveWords,final int[] additionalFeaturesOptions,final int sessionId,final float[] inOutLanguageWeight){
  if (!isValidDictionary()) {
    return null;
  }
  Arrays.fill(mInputCodePoints,Constants.NOT_A_CODE);
  final int[] prevWordCodePointArray=(null == prevWord) ? null : StringUtils.toCodePointArray(prevWord);
  final InputPointers inputPointers=composer.getInputPointers();
  final boolean isGesture=composer.isBatchMode();
  final int inputSize;
  if (!isGesture) {
    inputSize=composer.copyCodePointsExceptTrailingSingleQuotesAndReturnCodePointCount(mInputCodePoints);
    if (inputSize < 0) {
      return null;
    }
  }
 else {
    inputSize=inputPointers.getPointerSize();
  }
  mNativeSuggestOptions.setIsGesture(isGesture);
  mNativeSuggestOptions.setAdditionalFeaturesOptions(additionalFeaturesOptions);
  if (inOutLanguageWeight != null) {
    mInputOutputLanguageWeight[0]=inOutLanguageWeight[0];
  }
 else {
    mInputOutputLanguageWeight[0]=Dictionary.NOT_A_LANGUAGE_WEIGHT;
  }
  getSuggestionsNative(mNativeDict,proximityInfo.getNativeProximityInfo(),getTraverseSession(sessionId).getSession(),inputPointers.getXCoordinates(),inputPointers.getYCoordinates(),inputPointers.getTimes(),inputPointers.getPointerIds(),mInputCodePoints,inputSize,mNativeSuggestOptions.getOptions(),prevWordCodePointArray,mOutputSuggestionCount,mOutputCodePoints,mOutputScores,mSpaceIndices,mOutputTypes,mOutputAutoCommitFirstWordConfidence,mInputOutputLanguageWeight);
  if (inOutLanguageWeight != null) {
    inOutLanguageWeight[0]=mInputOutputLanguageWeight[0];
  }
  final int count=mOutputSuggestionCount[0];
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  for (int j=0; j < count; ++j) {
    final int start=j * MAX_WORD_LENGTH;
    int len=0;
    while (len < MAX_WORD_LENGTH && mOutputCodePoints[start + len] != 0) {
      ++len;
    }
    if (len > 0) {
      final int flags=mOutputTypes[j] & SuggestedWordInfo.KIND_MASK_FLAGS;
      if (blockOffensiveWords && 0 != (flags & SuggestedWordInfo.KIND_FLAG_POSSIBLY_OFFENSIVE) && 0 == (flags & SuggestedWordInfo.KIND_FLAG_EXACT_MATCH)) {
        continue;
      }
      final int kind=mOutputTypes[j] & SuggestedWordInfo.KIND_MASK_KIND;
      final int score=SuggestedWordInfo.KIND_WHITELIST == kind ? SuggestedWordInfo.MAX_SCORE : mOutputScores[j];
      suggestions.add(new SuggestedWordInfo(new String(mOutputCodePoints,start,len),score,kind,this,mSpaceIndices[j],mOutputAutoCommitFirstWordConfidence[0]));
    }
  }
  return suggestions;
}",0.997060984570169
87410,"/** 
 * Copy the code points in the typed word to a destination array of ints. If the array is too small to hold the code points in the typed word, nothing is copied and -1 is returned.
 * @param destination the array of ints.
 * @param maxSize the size of the array.
 * @return the number of copied code points.
 */
public int copyCodePointsExceptTrailingSingleQuotesAndReturnCodePointCount(final int[] destination,final int maxSize){
  final int i=mTypedWordCache.length() - 1 - trailingSingleQuotesCount();
  if (i < 0) {
    return 0;
  }
  final int codePointSize=Character.codePointCount(mTypedWordCache,0,i);
  if (codePointSize > maxSize) {
    return -1;
  }
  return StringUtils.copyCodePointsAndReturnCodePointCount(destination,mTypedWordCache,0,i + 1,true);
}","/** 
 * Copy the code points in the typed word to a destination array of ints. If the array is too small to hold the code points in the typed word, nothing is copied and -1 is returned.
 * @param destination the array of ints.
 * @return the number of copied code points.
 */
public int copyCodePointsExceptTrailingSingleQuotesAndReturnCodePointCount(final int[] destination){
  final int lastIndex=mTypedWordCache.length() - trailingSingleQuotesCount();
  if (lastIndex <= 0) {
    return 0;
  }
  final int codePointSize=Character.codePointCount(mTypedWordCache,0,lastIndex);
  if (codePointSize > destination.length) {
    return -1;
  }
  return StringUtils.copyCodePointsAndReturnCodePointCount(destination,mTypedWordCache,0,lastIndex,true);
}",0.912442396313364
87411,"@Override public ArrayList<SuggestedWordInfo> getSuggestionsWithSessionId(final WordComposer composer,final String prevWord,final ProximityInfo proximityInfo,final boolean blockOffensiveWords,final int[] additionalFeaturesOptions,final int sessionId,final float[] inOutLanguageWeight){
  if (!isValidDictionary()) {
    return null;
  }
  Arrays.fill(mInputCodePoints,Constants.NOT_A_CODE);
  final int[] prevWordCodePointArray=(null == prevWord) ? null : StringUtils.toCodePointArray(prevWord);
  final InputPointers inputPointers=composer.getInputPointers();
  final boolean isGesture=composer.isBatchMode();
  final int inputSize;
  if (!isGesture) {
    inputSize=composer.copyCodePointsExceptTrailingSingleQuotesAndReturnCodePointCount(mInputCodePoints,MAX_WORD_LENGTH);
    if (inputSize < 0) {
      return null;
    }
  }
 else {
    inputSize=inputPointers.getPointerSize();
  }
  mNativeSuggestOptions.setIsGesture(isGesture);
  mNativeSuggestOptions.setAdditionalFeaturesOptions(additionalFeaturesOptions);
  if (inOutLanguageWeight != null) {
    mInputOutputLanguageWeight[0]=inOutLanguageWeight[0];
  }
 else {
    mInputOutputLanguageWeight[0]=Dictionary.NOT_A_LANGUAGE_WEIGHT;
  }
  getSuggestionsNative(mNativeDict,proximityInfo.getNativeProximityInfo(),getTraverseSession(sessionId).getSession(),inputPointers.getXCoordinates(),inputPointers.getYCoordinates(),inputPointers.getTimes(),inputPointers.getPointerIds(),mInputCodePoints,inputSize,mNativeSuggestOptions.getOptions(),prevWordCodePointArray,mOutputSuggestionCount,mOutputCodePoints,mOutputScores,mSpaceIndices,mOutputTypes,mOutputAutoCommitFirstWordConfidence,mInputOutputLanguageWeight);
  if (inOutLanguageWeight != null) {
    inOutLanguageWeight[0]=mInputOutputLanguageWeight[0];
  }
  final int count=mOutputSuggestionCount[0];
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  for (int j=0; j < count; ++j) {
    final int start=j * MAX_WORD_LENGTH;
    int len=0;
    while (len < MAX_WORD_LENGTH && mOutputCodePoints[start + len] != 0) {
      ++len;
    }
    if (len > 0) {
      final int flags=mOutputTypes[j] & SuggestedWordInfo.KIND_MASK_FLAGS;
      if (blockOffensiveWords && 0 != (flags & SuggestedWordInfo.KIND_FLAG_POSSIBLY_OFFENSIVE) && 0 == (flags & SuggestedWordInfo.KIND_FLAG_EXACT_MATCH)) {
        continue;
      }
      final int kind=mOutputTypes[j] & SuggestedWordInfo.KIND_MASK_KIND;
      final int score=SuggestedWordInfo.KIND_WHITELIST == kind ? SuggestedWordInfo.MAX_SCORE : mOutputScores[j];
      suggestions.add(new SuggestedWordInfo(new String(mOutputCodePoints,start,len),score,kind,this,mSpaceIndices[j],mOutputAutoCommitFirstWordConfidence[0]));
    }
  }
  return suggestions;
}","@Override public ArrayList<SuggestedWordInfo> getSuggestionsWithSessionId(final WordComposer composer,final String prevWord,final ProximityInfo proximityInfo,final boolean blockOffensiveWords,final int[] additionalFeaturesOptions,final int sessionId,final float[] inOutLanguageWeight){
  if (!isValidDictionary()) {
    return null;
  }
  Arrays.fill(mInputCodePoints,Constants.NOT_A_CODE);
  final int[] prevWordCodePointArray=(null == prevWord) ? null : StringUtils.toCodePointArray(prevWord);
  final InputPointers inputPointers=composer.getInputPointers();
  final boolean isGesture=composer.isBatchMode();
  final int inputSize;
  if (!isGesture) {
    inputSize=composer.copyCodePointsExceptTrailingSingleQuotesAndReturnCodePointCount(mInputCodePoints);
    if (inputSize < 0) {
      return null;
    }
  }
 else {
    inputSize=inputPointers.getPointerSize();
  }
  mNativeSuggestOptions.setIsGesture(isGesture);
  mNativeSuggestOptions.setAdditionalFeaturesOptions(additionalFeaturesOptions);
  if (inOutLanguageWeight != null) {
    mInputOutputLanguageWeight[0]=inOutLanguageWeight[0];
  }
 else {
    mInputOutputLanguageWeight[0]=Dictionary.NOT_A_LANGUAGE_WEIGHT;
  }
  getSuggestionsNative(mNativeDict,proximityInfo.getNativeProximityInfo(),getTraverseSession(sessionId).getSession(),inputPointers.getXCoordinates(),inputPointers.getYCoordinates(),inputPointers.getTimes(),inputPointers.getPointerIds(),mInputCodePoints,inputSize,mNativeSuggestOptions.getOptions(),prevWordCodePointArray,mOutputSuggestionCount,mOutputCodePoints,mOutputScores,mSpaceIndices,mOutputTypes,mOutputAutoCommitFirstWordConfidence,mInputOutputLanguageWeight);
  if (inOutLanguageWeight != null) {
    inOutLanguageWeight[0]=mInputOutputLanguageWeight[0];
  }
  final int count=mOutputSuggestionCount[0];
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  for (int j=0; j < count; ++j) {
    final int start=j * MAX_WORD_LENGTH;
    int len=0;
    while (len < MAX_WORD_LENGTH && mOutputCodePoints[start + len] != 0) {
      ++len;
    }
    if (len > 0) {
      final int flags=mOutputTypes[j] & SuggestedWordInfo.KIND_MASK_FLAGS;
      if (blockOffensiveWords && 0 != (flags & SuggestedWordInfo.KIND_FLAG_POSSIBLY_OFFENSIVE) && 0 == (flags & SuggestedWordInfo.KIND_FLAG_EXACT_MATCH)) {
        continue;
      }
      final int kind=mOutputTypes[j] & SuggestedWordInfo.KIND_MASK_KIND;
      final int score=SuggestedWordInfo.KIND_WHITELIST == kind ? SuggestedWordInfo.MAX_SCORE : mOutputScores[j];
      suggestions.add(new SuggestedWordInfo(new String(mOutputCodePoints,start,len),score,kind,this,mSpaceIndices[j],mOutputAutoCommitFirstWordConfidence[0]));
    }
  }
  return suggestions;
}",0.997060984570169
87412,"/** 
 * Copy the code points in the typed word to a destination array of ints. If the array is too small to hold the code points in the typed word, nothing is copied and -1 is returned.
 * @param destination the array of ints.
 * @param maxSize the size of the array.
 * @return the number of copied code points.
 */
public int copyCodePointsExceptTrailingSingleQuotesAndReturnCodePointCount(final int[] destination,final int maxSize){
  final int i=mTypedWordCache.length() - 1 - trailingSingleQuotesCount();
  if (i < 0) {
    return 0;
  }
  final int codePointSize=Character.codePointCount(mTypedWordCache,0,i);
  if (codePointSize > maxSize) {
    return -1;
  }
  return StringUtils.copyCodePointsAndReturnCodePointCount(destination,mTypedWordCache,0,i + 1,true);
}","/** 
 * Copy the code points in the typed word to a destination array of ints. If the array is too small to hold the code points in the typed word, nothing is copied and -1 is returned.
 * @param destination the array of ints.
 * @return the number of copied code points.
 */
public int copyCodePointsExceptTrailingSingleQuotesAndReturnCodePointCount(final int[] destination){
  final int lastIndex=mTypedWordCache.length() - trailingSingleQuotesCount();
  if (lastIndex <= 0) {
    return 0;
  }
  final int codePointSize=Character.codePointCount(mTypedWordCache,0,lastIndex);
  if (codePointSize > destination.length) {
    return -1;
  }
  return StringUtils.copyCodePointsAndReturnCodePointCount(destination,mTypedWordCache,0,lastIndex,true);
}",0.912442396313364
87413,"/** 
 * Handle input of a separator code point.
 * @param inputTransaction The transaction in progress.
 * @param isFromSuggestionStrip whether this code point comes from the suggestion strip.
 * @return whether this caused an auto-correction to happen.
 */
private boolean handleSeparator(final InputTransaction inputTransaction,final boolean isFromSuggestionStrip,final LatinIME.UIHandler handler){
  final int codePoint=inputTransaction.mEvent.mCodePoint;
  boolean didAutoCorrect=false;
  final boolean shouldAvoidSendingCode=Constants.CODE_SPACE == codePoint && !inputTransaction.mSettingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces && mWordComposer.isComposingWord();
  if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
    resetEntireInputState(mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),true);
  }
  if (mWordComposer.isComposingWord()) {
    if (inputTransaction.mSettingsValues.mCorrectionEnabled) {
      final String separator=shouldAvoidSendingCode ? LastComposedWord.NOT_A_SEPARATOR : StringUtils.newSingleCodePointString(codePoint);
      commitCurrentAutoCorrection(inputTransaction.mSettingsValues,separator,handler);
      didAutoCorrect=true;
    }
 else {
      commitTyped(inputTransaction.mSettingsValues,StringUtils.newSingleCodePointString(codePoint));
    }
  }
  final boolean swapWeakSpace=maybeStripSpace(inputTransaction,isFromSuggestionStrip);
  final boolean isInsideDoubleQuoteOrAfterDigit=Constants.CODE_DOUBLE_QUOTE == codePoint && mConnection.isInsideDoubleQuoteOrAfterDigit();
  final boolean needsPrecedingSpace;
  if (SpaceState.PHANTOM != inputTransaction.mSpaceState) {
    needsPrecedingSpace=false;
  }
 else   if (Constants.CODE_DOUBLE_QUOTE == codePoint) {
    needsPrecedingSpace=!isInsideDoubleQuoteOrAfterDigit;
  }
 else {
    needsPrecedingSpace=inputTransaction.mSettingsValues.isUsuallyPrecededBySpace(codePoint);
  }
  if (needsPrecedingSpace) {
    promotePhantomSpace(inputTransaction.mSettingsValues);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    ResearchLogger.latinIME_handleSeparator(codePoint,mWordComposer.isComposingWord());
  }
  if (!shouldAvoidSendingCode) {
    sendKeyCodePoint(inputTransaction.mSettingsValues,codePoint);
  }
  if (Constants.CODE_SPACE == codePoint) {
    if (inputTransaction.mSettingsValues.isSuggestionsRequested()) {
      if (maybeDoubleSpacePeriod(inputTransaction)) {
        inputTransaction.requireShiftUpdate(InputTransaction.SHIFT_UPDATE_NOW);
        mSpaceState=SpaceState.DOUBLE;
      }
 else       if (!mSuggestedWords.isPunctuationSuggestions()) {
        mSpaceState=SpaceState.WEAK;
      }
    }
    startDoubleSpacePeriodCountdown(inputTransaction);
    inputTransaction.setRequiresUpdateSuggestions();
  }
 else {
    if (swapWeakSpace) {
      swapSwapperAndSpace(inputTransaction);
      mSpaceState=SpaceState.SWAP_PUNCTUATION;
    }
 else     if ((SpaceState.PHANTOM == inputTransaction.mSpaceState && inputTransaction.mSettingsValues.isUsuallyFollowedBySpace(codePoint)) || (Constants.CODE_DOUBLE_QUOTE == codePoint && isInsideDoubleQuoteOrAfterDigit)) {
      mSpaceState=SpaceState.PHANTOM;
    }
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
  }
  inputTransaction.requireShiftUpdate(InputTransaction.SHIFT_UPDATE_NOW);
  return didAutoCorrect;
}","/** 
 * Handle input of a separator code point.
 * @param inputTransaction The transaction in progress.
 * @param isFromSuggestionStrip whether this code point comes from the suggestion strip.
 * @return whether this caused an auto-correction to happen.
 */
private boolean handleSeparator(final InputTransaction inputTransaction,final boolean isFromSuggestionStrip,final LatinIME.UIHandler handler){
  final int codePoint=inputTransaction.mEvent.mCodePoint;
  boolean didAutoCorrect=false;
  final boolean shouldAvoidSendingCode=Constants.CODE_SPACE == codePoint && !inputTransaction.mSettingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces && mWordComposer.isComposingWord();
  if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
    resetEntireInputState(mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),true);
  }
  if (mWordComposer.isComposingWord()) {
    if (inputTransaction.mSettingsValues.mCorrectionEnabled) {
      final String separator=shouldAvoidSendingCode ? LastComposedWord.NOT_A_SEPARATOR : StringUtils.newSingleCodePointString(codePoint);
      commitCurrentAutoCorrection(inputTransaction.mSettingsValues,separator,handler);
      didAutoCorrect=true;
    }
 else {
      commitTyped(inputTransaction.mSettingsValues,StringUtils.newSingleCodePointString(codePoint));
    }
  }
  final boolean swapWeakSpace=maybeStripSpace(inputTransaction,isFromSuggestionStrip);
  final boolean isInsideDoubleQuoteOrAfterDigit=Constants.CODE_DOUBLE_QUOTE == codePoint && mConnection.isInsideDoubleQuoteOrAfterDigit();
  final boolean needsPrecedingSpace;
  if (SpaceState.PHANTOM != inputTransaction.mSpaceState) {
    needsPrecedingSpace=false;
  }
 else   if (Constants.CODE_DOUBLE_QUOTE == codePoint) {
    needsPrecedingSpace=!isInsideDoubleQuoteOrAfterDigit;
  }
 else {
    needsPrecedingSpace=inputTransaction.mSettingsValues.isUsuallyPrecededBySpace(codePoint);
  }
  if (needsPrecedingSpace) {
    promotePhantomSpace(inputTransaction.mSettingsValues);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    ResearchLogger.latinIME_handleSeparator(codePoint,mWordComposer.isComposingWord());
  }
  if (!shouldAvoidSendingCode) {
    sendKeyCodePoint(inputTransaction.mSettingsValues,codePoint);
  }
  if (Constants.CODE_SPACE == codePoint) {
    if (maybeDoubleSpacePeriod(inputTransaction)) {
      inputTransaction.requireShiftUpdate(InputTransaction.SHIFT_UPDATE_NOW);
      mSpaceState=SpaceState.DOUBLE;
    }
 else     if (!mSuggestedWords.isPunctuationSuggestions()) {
      mSpaceState=SpaceState.WEAK;
    }
    startDoubleSpacePeriodCountdown(inputTransaction);
    inputTransaction.setRequiresUpdateSuggestions();
  }
 else {
    if (swapWeakSpace) {
      swapSwapperAndSpace(inputTransaction);
      mSpaceState=SpaceState.SWAP_PUNCTUATION;
    }
 else     if ((SpaceState.PHANTOM == inputTransaction.mSpaceState && inputTransaction.mSettingsValues.isUsuallyFollowedBySpace(codePoint)) || (Constants.CODE_DOUBLE_QUOTE == codePoint && isInsideDoubleQuoteOrAfterDigit)) {
      mSpaceState=SpaceState.PHANTOM;
    }
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
  }
  inputTransaction.requireShiftUpdate(InputTransaction.SHIFT_UPDATE_NOW);
  return didAutoCorrect;
}",0.986557921764084
87414,"public void testDoubleSpace(){
  final String[] STRINGS_TO_TYPE=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final String[] EXPECTED_RESULTS=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (int i=0; i < STRINGS_TO_TYPE.length; ++i) {
    mEditText.setText(""String_Node_Str"");
    type(STRINGS_TO_TYPE[i]);
    assertEquals(""String_Node_Str"",EXPECTED_RESULTS[i],mEditText.getText().toString());
  }
}","public void testDoubleSpace(){
  setBooleanPreference(Settings.PREF_KEY_USE_DOUBLE_SPACE_PERIOD,true,true);
  final String[] STRINGS_TO_TYPE=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final String[] EXPECTED_RESULTS=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (int i=0; i < STRINGS_TO_TYPE.length; ++i) {
    mEditText.setText(""String_Node_Str"");
    type(STRINGS_TO_TYPE[i]);
    assertEquals(""String_Node_Str"",EXPECTED_RESULTS[i],mEditText.getText().toString());
  }
}",0.9393223010244288
87415,"@Override protected void tearDown() throws Exception {
  mLatinIME.mHandler.removeAllMessages();
  setBooleanPreference(Settings.PREF_BIGRAM_PREDICTIONS,mPreviousBigramPredictionSettings,true);
  setStringPreference(Settings.PREF_AUTO_CORRECTION_THRESHOLD,mPreviousAutoCorrectSetting,DEFAULT_AUTO_CORRECTION_THRESHOLD);
  setDebugMode(mPreviousDebugSetting);
  super.tearDown();
}","@Override protected void tearDown() throws Exception {
  mLatinIME.mHandler.removeAllMessages();
  setBooleanPreference(Settings.PREF_BIGRAM_PREDICTIONS,mPreviousBigramPredictionSettings,true);
  setStringPreference(Settings.PREF_AUTO_CORRECTION_THRESHOLD,mPreviousAutoCorrectSetting,DEFAULT_AUTO_CORRECTION_THRESHOLD);
  setDebugMode(false);
  super.tearDown();
}",0.9650537634408602
87416,"@Override protected void setUp() throws Exception {
  super.setUp();
  mEditText=new MyEditText(getContext());
  final int inputType=InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_AUTO_CORRECT | InputType.TYPE_TEXT_FLAG_MULTI_LINE;
  mEditText.setInputType(inputType);
  mEditText.setEnabled(true);
  setupService();
  mLatinIME=getService();
  mPreviousDebugSetting=setDebugMode(true);
  mPreviousBigramPredictionSettings=setBooleanPreference(Settings.PREF_BIGRAM_PREDICTIONS,true,true);
  mPreviousAutoCorrectSetting=setStringPreference(Settings.PREF_AUTO_CORRECTION_THRESHOLD,DEFAULT_AUTO_CORRECTION_THRESHOLD,DEFAULT_AUTO_CORRECTION_THRESHOLD);
  mLatinIME.onCreate();
  EditorInfo ei=new EditorInfo();
  final InputConnection ic=mEditText.onCreateInputConnection(ei);
  final LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  final ViewGroup vg=new FrameLayout(getContext());
  mInputView=inflater.inflate(R.layout.input_view,vg);
  ei=enrichEditorInfo(ei);
  mLatinIME.onCreateInputMethodInterface().startInput(ic,ei);
  mLatinIME.setInputView(mInputView);
  mLatinIME.onBindInput();
  mLatinIME.onCreateInputView();
  mLatinIME.onStartInputView(ei,false);
  mInputConnection=ic;
  changeLanguage(""String_Node_Str"");
  sleep(DELAY_TO_WAIT_FOR_PREDICTIONS);
  runMessages();
}","@Override protected void setUp() throws Exception {
  super.setUp();
  mEditText=new MyEditText(getContext());
  final int inputType=InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_AUTO_CORRECT | InputType.TYPE_TEXT_FLAG_MULTI_LINE;
  mEditText.setInputType(inputType);
  mEditText.setEnabled(true);
  setupService();
  mLatinIME=getService();
  setDebugMode(true);
  mPreviousBigramPredictionSettings=setBooleanPreference(Settings.PREF_BIGRAM_PREDICTIONS,true,true);
  mPreviousAutoCorrectSetting=setStringPreference(Settings.PREF_AUTO_CORRECTION_THRESHOLD,DEFAULT_AUTO_CORRECTION_THRESHOLD,DEFAULT_AUTO_CORRECTION_THRESHOLD);
  mLatinIME.onCreate();
  EditorInfo ei=new EditorInfo();
  final InputConnection ic=mEditText.onCreateInputConnection(ei);
  final LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  final ViewGroup vg=new FrameLayout(getContext());
  mInputView=inflater.inflate(R.layout.input_view,vg);
  ei=enrichEditorInfo(ei);
  mLatinIME.onCreateInputMethodInterface().startInput(ic,ei);
  mLatinIME.setInputView(mInputView);
  mLatinIME.onBindInput();
  mLatinIME.onCreateInputView();
  mLatinIME.onStartInputView(ei,false);
  mInputConnection=ic;
  changeLanguage(""String_Node_Str"");
  sleep(DELAY_TO_WAIT_FOR_PREDICTIONS);
  runMessages();
}",0.9917417417417418
87417,"/** 
 * Initializes the input logic for input in an editor. Call this when input starts or restarts in some editor (typically, in onStartInputView). If the input is starting in the same field as before, set `restarting' to true. This allows the input logic to reset only necessary stuff and save performance. Also, when restarting some things must not be done (for example, the keyboard should not be reset to the alphabetic layout), so do not send false to this just in case.
 * @param restarting whether input is starting in the same field as before. Unused for now.
 * @param editorInfo the editorInfo associated with the editor.
 */
public void startInput(final boolean restarting,final EditorInfo editorInfo){
  mEnteredText=null;
  resetComposingState(true);
  mDeleteCount=0;
  mSpaceState=SpaceState.NONE;
  mRecapitalizeStatus.deactivate();
  mCurrentlyPressedHardwareKeys.clear();
  mSuggestedWords=SuggestedWords.EMPTY;
  mConnection.tryFixLyingCursorPosition();
  cancelDoubleSpacePeriodCountdown();
  mInputLogicHandler=new InputLogicHandler(mLatinIME,this);
}","/** 
 * Initializes the input logic for input in an editor. Call this when input starts or restarts in some editor (typically, in onStartInputView). If the input is starting in the same field as before, set `restarting' to true. This allows the input logic to reset only necessary stuff and save performance. Also, when restarting some things must not be done (for example, the keyboard should not be reset to the alphabetic layout), so do not send false to this just in case.
 * @param restarting whether input is starting in the same field as before. Unused for now.
 * @param editorInfo the editorInfo associated with the editor.
 */
public void startInput(final boolean restarting,final EditorInfo editorInfo){
  mEnteredText=null;
  resetComposingState(true);
  mDeleteCount=0;
  mSpaceState=SpaceState.NONE;
  mRecapitalizeStatus.deactivate();
  mCurrentlyPressedHardwareKeys.clear();
  mSuggestedWords=SuggestedWords.EMPTY;
  mConnection.tryFixLyingCursorPosition();
  cancelDoubleSpacePeriodCountdown();
  mInputLogicHandler.destroy();
  mInputLogicHandler=new InputLogicHandler(mLatinIME,this);
}",0.985307621671258
87418,"/** 
 * Create an event interpreter according to a specification. The specification contains information about what to do with events. Typically, it will contain information about the type of keyboards - for example, if hardware keyboard(s) is/are attached, their type will be included here so that the decoder knows what to do with each keypress (a 10-key keyboard is not handled like a qwerty-ish keyboard). It also contains information for combining characters. For example, if the input language is Japanese, the specification will typically request kana conversion. Also note that the specification can be null. This means that we need to create a default interpreter that does no specific combining, and assumes the most common cases.
 * @param specification the specification for event interpretation. null for default.
 * @param latinIme a reference to the ime.
 */
public EventInterpreter(final EventDecoderSpec specification,final LatinIME latinIme){
  mDecoderSpec=null != specification ? specification : new EventDecoderSpec();
  mHardwareEventDecoders=new SparseArray<HardwareEventDecoder>(1);
  mSoftwareEventDecoder=new SoftwareKeyboardEventDecoder();
  mCombiners=CollectionUtils.newArrayList();
  mCombiners.add(new DeadKeyCombiner());
  mLatinIme=latinIme;
}","/** 
 * Create an event interpreter according to a specification. The specification contains information about what to do with events. Typically, it will contain information about the type of keyboards - for example, if hardware keyboard(s) is/are attached, their type will be included here so that the decoder knows what to do with each keypress (a 10-key keyboard is not handled like a qwerty-ish keyboard). It also contains information for combining characters. For example, if the input language is Japanese, the specification will typically request kana conversion. Also note that the specification can be null. This means that we need to create a default interpreter that does no specific combining, and assumes the most common cases.
 * @param specification the specification for event interpretation. null for default.
 */
public EventInterpreter(final EventDecoderSpec specification){
  mDecoderSpec=null != specification ? specification : new EventDecoderSpec();
  mCombiners=CollectionUtils.newArrayList();
  mCombiners.add(new DeadKeyCombiner());
}",0.9075342465753424
87419,"@Override public boolean onKeyDown(final int keyCode,final KeyEvent event){
  if (!ProductionFlag.IS_HARDWARE_KEYBOARD_SUPPORTED)   return super.onKeyDown(keyCode,event);
  if (mInputLogic.mEventInterpreter.onHardwareKeyEvent(event)) {
    final long keyIdentifier=event.getDeviceId() << 32 + event.getKeyCode();
    mInputLogic.mCurrentlyPressedHardwareKeys.add(keyIdentifier);
    return true;
  }
  return super.onKeyDown(keyCode,event);
}","@Override public boolean onKeyDown(final int keyCode,final KeyEvent keyEvent){
  if (!ProductionFlag.IS_HARDWARE_KEYBOARD_SUPPORTED) {
    return super.onKeyDown(keyCode,keyEvent);
  }
  final Event event=getHardwareKeyEventDecoder(keyEvent.getDeviceId()).decodeHardwareKey(keyEvent);
  if (event.isHandled()) {
    mInputLogic.onCodeInput(mSettings.getCurrent(),event,mKeyboardSwitcher.getKeyboardShiftMode(),mHandler);
    return true;
  }
  return super.onKeyDown(keyCode,keyEvent);
}",0.4198062432723358
87420,"public InputLogic(final LatinIME latinIME,final SuggestionStripViewAccessor suggestionStripViewAccessor){
  mLatinIME=latinIME;
  mSuggestionStripViewAccessor=suggestionStripViewAccessor;
  mWordComposer=new WordComposer();
  mEventInterpreter=new EventInterpreter(latinIME);
  mConnection=new RichInputConnection(latinIME);
  mInputLogicHandler=InputLogicHandler.NULL_HANDLER;
}","public InputLogic(final LatinIME latinIME,final SuggestionStripViewAccessor suggestionStripViewAccessor){
  mLatinIME=latinIME;
  mSuggestionStripViewAccessor=suggestionStripViewAccessor;
  mWordComposer=new WordComposer();
  mConnection=new RichInputConnection(latinIME);
  mInputLogicHandler=InputLogicHandler.NULL_HANDLER;
}",0.9263456090651558
87421,"private void getSuggestedWordsForTypingInput(final WordComposer wordComposer,final String prevWordForBigram,final ProximityInfo proximityInfo,final boolean blockOffensiveWords,final boolean isCorrectionEnabled,final int[] additionalFeaturesOptions,final int sequenceNumber,final OnGetSuggestedWordsCallback callback){
  final int trailingSingleQuotesCount=wordComposer.trailingSingleQuotesCount();
  final BoundedTreeSet suggestionsSet=new BoundedTreeSet(sSuggestedWordInfoComparator,SuggestedWords.MAX_SUGGESTIONS);
  final String typedWord=wordComposer.getTypedWord();
  final String consideredWord=trailingSingleQuotesCount > 0 ? typedWord.substring(0,typedWord.length() - trailingSingleQuotesCount) : typedWord;
  LatinImeLogger.onAddSuggestedWord(typedWord,Dictionary.TYPE_USER_TYPED);
  final WordComposer wordComposerForLookup;
  if (trailingSingleQuotesCount > 0) {
    wordComposerForLookup=new WordComposer(wordComposer);
    for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
      wordComposerForLookup.deleteLast();
    }
  }
 else {
    wordComposerForLookup=wordComposer;
  }
  final ArrayList<SuggestedWordInfo> rawSuggestions;
  if (ProductionFlag.INCLUDE_RAW_SUGGESTIONS) {
    rawSuggestions=CollectionUtils.newArrayList();
  }
 else {
    rawSuggestions=null;
  }
  mDictionaryFacilitator.getSuggestions(wordComposerForLookup,prevWordForBigram,proximityInfo,blockOffensiveWords,additionalFeaturesOptions,SESSION_TYPING,suggestionsSet,rawSuggestions);
  final String firstSuggestion;
  final String whitelistedWord;
  if (suggestionsSet.isEmpty()) {
    whitelistedWord=firstSuggestion=null;
  }
 else {
    final SuggestedWordInfo firstSuggestedWordInfo=suggestionsSet.first();
    firstSuggestion=firstSuggestedWordInfo.mWord;
    if (SuggestedWordInfo.KIND_WHITELIST != firstSuggestedWordInfo.mKind) {
      whitelistedWord=null;
    }
 else {
      whitelistedWord=firstSuggestion;
    }
  }
  final boolean isPrediction=!wordComposer.isComposingWord();
  final boolean allowsToBeAutoCorrected=(null != whitelistedWord && !whitelistedWord.equals(consideredWord)) || (consideredWord.length() > 1 && !mDictionaryFacilitator.isValidWord(consideredWord,wordComposer.isFirstCharCapitalized()) && !consideredWord.equals(firstSuggestion));
  final boolean hasAutoCorrection;
  if (!isCorrectionEnabled || !allowsToBeAutoCorrected || isPrediction|| suggestionsSet.isEmpty()|| wordComposer.hasDigits()|| wordComposer.isMostlyCaps()|| wordComposer.isResumed()|| !mDictionaryFacilitator.hasMainDictionary()|| SuggestedWordInfo.KIND_SHORTCUT == suggestionsSet.first().mKind) {
    hasAutoCorrection=false;
  }
 else {
    hasAutoCorrection=AutoCorrectionUtils.suggestionExceedsAutoCorrectionThreshold(suggestionsSet.first(),consideredWord,mAutoCorrectionThreshold);
  }
  final ArrayList<SuggestedWordInfo> suggestionsContainer=CollectionUtils.newArrayList(suggestionsSet);
  final int suggestionsCount=suggestionsContainer.size();
  final boolean isFirstCharCapitalized=wordComposer.isFirstCharCapitalized();
  final boolean isAllUpperCase=wordComposer.isAllUpperCase();
  if (isFirstCharCapitalized || isAllUpperCase || 0 != trailingSingleQuotesCount) {
    for (int i=0; i < suggestionsCount; ++i) {
      final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
      final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,mLocale,isAllUpperCase,isFirstCharCapitalized,trailingSingleQuotesCount);
      suggestionsContainer.set(i,transformedWordInfo);
    }
  }
  for (int i=0; i < suggestionsCount; ++i) {
    final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
    LatinImeLogger.onAddSuggestedWord(wordInfo.mWord.toString(),wordInfo.mSourceDict.mDictType);
  }
  if (!TextUtils.isEmpty(typedWord)) {
    suggestionsContainer.add(0,new SuggestedWordInfo(typedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  SuggestedWordInfo.removeDups(suggestionsContainer);
  final ArrayList<SuggestedWordInfo> suggestionsList;
  if (DBG && !suggestionsContainer.isEmpty()) {
    suggestionsList=getSuggestionsInfoListWithDebugInfo(typedWord,suggestionsContainer);
  }
 else {
    suggestionsList=suggestionsContainer;
  }
  callback.onGetSuggestedWords(new SuggestedWords(suggestionsList,rawSuggestions,!isPrediction && !allowsToBeAutoCorrected,hasAutoCorrection,false,isPrediction,sequenceNumber));
}","private void getSuggestedWordsForTypingInput(final WordComposer wordComposer,final String prevWordForBigram,final ProximityInfo proximityInfo,final boolean blockOffensiveWords,final boolean isCorrectionEnabled,final int[] additionalFeaturesOptions,final int sequenceNumber,final OnGetSuggestedWordsCallback callback){
  final int trailingSingleQuotesCount=wordComposer.trailingSingleQuotesCount();
  final BoundedTreeSet suggestionsSet=new BoundedTreeSet(sSuggestedWordInfoComparator,SuggestedWords.MAX_SUGGESTIONS);
  final String typedWord=wordComposer.getTypedWord();
  final String consideredWord=trailingSingleQuotesCount > 0 ? typedWord.substring(0,typedWord.length() - trailingSingleQuotesCount) : typedWord;
  LatinImeLogger.onAddSuggestedWord(typedWord,Dictionary.TYPE_USER_TYPED);
  final WordComposer wordComposerForLookup;
  if (trailingSingleQuotesCount > 0) {
    wordComposerForLookup=new WordComposer(wordComposer);
    for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
      wordComposerForLookup.deleteLast();
    }
  }
 else {
    wordComposerForLookup=wordComposer;
  }
  final ArrayList<SuggestedWordInfo> rawSuggestions;
  if (ProductionFlag.INCLUDE_RAW_SUGGESTIONS) {
    rawSuggestions=CollectionUtils.newArrayList();
  }
 else {
    rawSuggestions=null;
  }
  mDictionaryFacilitator.getSuggestions(wordComposerForLookup,prevWordForBigram,proximityInfo,blockOffensiveWords,additionalFeaturesOptions,SESSION_TYPING,suggestionsSet,rawSuggestions);
  final boolean isFirstCharCapitalized=wordComposer.isFirstCharCapitalized();
  final boolean isAllUpperCase=wordComposer.isAllUpperCase();
  final String firstSuggestion;
  final String whitelistedWord;
  if (suggestionsSet.isEmpty()) {
    whitelistedWord=firstSuggestion=null;
  }
 else {
    final SuggestedWordInfo firstSuggestedWordInfo=getTransformedSuggestedWordInfo(suggestionsSet.first(),mLocale,isAllUpperCase,isFirstCharCapitalized,trailingSingleQuotesCount);
    firstSuggestion=firstSuggestedWordInfo.mWord;
    if (SuggestedWordInfo.KIND_WHITELIST != firstSuggestedWordInfo.mKind) {
      whitelistedWord=null;
    }
 else {
      whitelistedWord=firstSuggestion;
    }
  }
  final boolean isPrediction=!wordComposer.isComposingWord();
  final boolean allowsToBeAutoCorrected=(null != whitelistedWord && !whitelistedWord.equals(consideredWord)) || (consideredWord.length() > 1 && !mDictionaryFacilitator.isValidWord(consideredWord,wordComposer.isFirstCharCapitalized()) && !consideredWord.equals(firstSuggestion));
  final boolean hasAutoCorrection;
  if (!isCorrectionEnabled || !allowsToBeAutoCorrected || isPrediction|| suggestionsSet.isEmpty()|| wordComposer.hasDigits()|| wordComposer.isMostlyCaps()|| wordComposer.isResumed()|| !mDictionaryFacilitator.hasMainDictionary()|| SuggestedWordInfo.KIND_SHORTCUT == suggestionsSet.first().mKind) {
    hasAutoCorrection=false;
  }
 else {
    hasAutoCorrection=AutoCorrectionUtils.suggestionExceedsAutoCorrectionThreshold(suggestionsSet.first(),consideredWord,mAutoCorrectionThreshold);
  }
  final ArrayList<SuggestedWordInfo> suggestionsContainer=CollectionUtils.newArrayList(suggestionsSet);
  final int suggestionsCount=suggestionsContainer.size();
  if (isFirstCharCapitalized || isAllUpperCase || 0 != trailingSingleQuotesCount) {
    for (int i=0; i < suggestionsCount; ++i) {
      final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
      final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,mLocale,isAllUpperCase,isFirstCharCapitalized,trailingSingleQuotesCount);
      suggestionsContainer.set(i,transformedWordInfo);
    }
  }
  for (int i=0; i < suggestionsCount; ++i) {
    final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
    LatinImeLogger.onAddSuggestedWord(wordInfo.mWord.toString(),wordInfo.mSourceDict.mDictType);
  }
  if (!TextUtils.isEmpty(typedWord)) {
    suggestionsContainer.add(0,new SuggestedWordInfo(typedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  SuggestedWordInfo.removeDups(suggestionsContainer);
  final ArrayList<SuggestedWordInfo> suggestionsList;
  if (DBG && !suggestionsContainer.isEmpty()) {
    suggestionsList=getSuggestionsInfoListWithDebugInfo(typedWord,suggestionsContainer);
  }
 else {
    suggestionsList=suggestionsContainer;
  }
  callback.onGetSuggestedWords(new SuggestedWords(suggestionsList,rawSuggestions,!isPrediction && !allowsToBeAutoCorrected,hasAutoCorrection,false,isPrediction,sequenceNumber));
}",0.9528645545865988
87422,"private void getSuggestedWordsForTypingInput(final WordComposer wordComposer,final String prevWordForBigram,final ProximityInfo proximityInfo,final boolean blockOffensiveWords,final boolean isCorrectionEnabled,final int[] additionalFeaturesOptions,final int sequenceNumber,final OnGetSuggestedWordsCallback callback){
  final int trailingSingleQuotesCount=wordComposer.trailingSingleQuotesCount();
  final BoundedTreeSet suggestionsSet=new BoundedTreeSet(sSuggestedWordInfoComparator,SuggestedWords.MAX_SUGGESTIONS);
  final String typedWord=wordComposer.getTypedWord();
  final String consideredWord=trailingSingleQuotesCount > 0 ? typedWord.substring(0,typedWord.length() - trailingSingleQuotesCount) : typedWord;
  LatinImeLogger.onAddSuggestedWord(typedWord,Dictionary.TYPE_USER_TYPED);
  final WordComposer wordComposerForLookup;
  if (trailingSingleQuotesCount > 0) {
    wordComposerForLookup=new WordComposer(wordComposer);
    for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
      wordComposerForLookup.deleteLast();
    }
  }
 else {
    wordComposerForLookup=wordComposer;
  }
  final ArrayList<SuggestedWordInfo> rawSuggestions;
  if (ProductionFlag.INCLUDE_RAW_SUGGESTIONS) {
    rawSuggestions=CollectionUtils.newArrayList();
  }
 else {
    rawSuggestions=null;
  }
  mDictionaryFacilitator.getSuggestions(wordComposerForLookup,prevWordForBigram,proximityInfo,blockOffensiveWords,additionalFeaturesOptions,SESSION_TYPING,suggestionsSet,rawSuggestions);
  final String firstSuggestion;
  final String whitelistedWord;
  if (suggestionsSet.isEmpty()) {
    whitelistedWord=firstSuggestion=null;
  }
 else {
    final SuggestedWordInfo firstSuggestedWordInfo=suggestionsSet.first();
    firstSuggestion=firstSuggestedWordInfo.mWord;
    if (SuggestedWordInfo.KIND_WHITELIST != firstSuggestedWordInfo.mKind) {
      whitelistedWord=null;
    }
 else {
      whitelistedWord=firstSuggestion;
    }
  }
  final boolean isPrediction=!wordComposer.isComposingWord();
  final boolean allowsToBeAutoCorrected=(null != whitelistedWord && !whitelistedWord.equals(consideredWord)) || (consideredWord.length() > 1 && !mDictionaryFacilitator.isValidWord(consideredWord,wordComposer.isFirstCharCapitalized()) && !consideredWord.equals(firstSuggestion));
  final boolean hasAutoCorrection;
  if (!isCorrectionEnabled || !allowsToBeAutoCorrected || isPrediction|| suggestionsSet.isEmpty()|| wordComposer.hasDigits()|| wordComposer.isMostlyCaps()|| wordComposer.isResumed()|| !mDictionaryFacilitator.hasMainDictionary()|| SuggestedWordInfo.KIND_SHORTCUT == suggestionsSet.first().mKind) {
    hasAutoCorrection=false;
  }
 else {
    hasAutoCorrection=AutoCorrectionUtils.suggestionExceedsAutoCorrectionThreshold(suggestionsSet.first(),consideredWord,mAutoCorrectionThreshold);
  }
  final ArrayList<SuggestedWordInfo> suggestionsContainer=CollectionUtils.newArrayList(suggestionsSet);
  final int suggestionsCount=suggestionsContainer.size();
  final boolean isFirstCharCapitalized=wordComposer.isFirstCharCapitalized();
  final boolean isAllUpperCase=wordComposer.isAllUpperCase();
  if (isFirstCharCapitalized || isAllUpperCase || 0 != trailingSingleQuotesCount) {
    for (int i=0; i < suggestionsCount; ++i) {
      final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
      final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,mLocale,isAllUpperCase,isFirstCharCapitalized,trailingSingleQuotesCount);
      suggestionsContainer.set(i,transformedWordInfo);
    }
  }
  for (int i=0; i < suggestionsCount; ++i) {
    final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
    LatinImeLogger.onAddSuggestedWord(wordInfo.mWord.toString(),wordInfo.mSourceDict.mDictType);
  }
  if (!TextUtils.isEmpty(typedWord)) {
    suggestionsContainer.add(0,new SuggestedWordInfo(typedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  SuggestedWordInfo.removeDups(suggestionsContainer);
  final ArrayList<SuggestedWordInfo> suggestionsList;
  if (DBG && !suggestionsContainer.isEmpty()) {
    suggestionsList=getSuggestionsInfoListWithDebugInfo(typedWord,suggestionsContainer);
  }
 else {
    suggestionsList=suggestionsContainer;
  }
  callback.onGetSuggestedWords(new SuggestedWords(suggestionsList,rawSuggestions,!isPrediction && !allowsToBeAutoCorrected,hasAutoCorrection,false,isPrediction,sequenceNumber));
}","private void getSuggestedWordsForTypingInput(final WordComposer wordComposer,final String prevWordForBigram,final ProximityInfo proximityInfo,final boolean blockOffensiveWords,final boolean isCorrectionEnabled,final int[] additionalFeaturesOptions,final int sequenceNumber,final OnGetSuggestedWordsCallback callback){
  final int trailingSingleQuotesCount=wordComposer.trailingSingleQuotesCount();
  final BoundedTreeSet suggestionsSet=new BoundedTreeSet(sSuggestedWordInfoComparator,SuggestedWords.MAX_SUGGESTIONS);
  final String typedWord=wordComposer.getTypedWord();
  final String consideredWord=trailingSingleQuotesCount > 0 ? typedWord.substring(0,typedWord.length() - trailingSingleQuotesCount) : typedWord;
  LatinImeLogger.onAddSuggestedWord(typedWord,Dictionary.TYPE_USER_TYPED);
  final WordComposer wordComposerForLookup;
  if (trailingSingleQuotesCount > 0) {
    wordComposerForLookup=new WordComposer(wordComposer);
    for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
      wordComposerForLookup.deleteLast();
    }
  }
 else {
    wordComposerForLookup=wordComposer;
  }
  final ArrayList<SuggestedWordInfo> rawSuggestions;
  if (ProductionFlag.INCLUDE_RAW_SUGGESTIONS) {
    rawSuggestions=CollectionUtils.newArrayList();
  }
 else {
    rawSuggestions=null;
  }
  mDictionaryFacilitator.getSuggestions(wordComposerForLookup,prevWordForBigram,proximityInfo,blockOffensiveWords,additionalFeaturesOptions,SESSION_TYPING,suggestionsSet,rawSuggestions);
  final boolean isFirstCharCapitalized=wordComposer.isFirstCharCapitalized();
  final boolean isAllUpperCase=wordComposer.isAllUpperCase();
  final String firstSuggestion;
  final String whitelistedWord;
  if (suggestionsSet.isEmpty()) {
    whitelistedWord=firstSuggestion=null;
  }
 else {
    final SuggestedWordInfo firstSuggestedWordInfo=getTransformedSuggestedWordInfo(suggestionsSet.first(),mLocale,isAllUpperCase,isFirstCharCapitalized,trailingSingleQuotesCount);
    firstSuggestion=firstSuggestedWordInfo.mWord;
    if (SuggestedWordInfo.KIND_WHITELIST != firstSuggestedWordInfo.mKind) {
      whitelistedWord=null;
    }
 else {
      whitelistedWord=firstSuggestion;
    }
  }
  final boolean isPrediction=!wordComposer.isComposingWord();
  final boolean allowsToBeAutoCorrected=(null != whitelistedWord && !whitelistedWord.equals(consideredWord)) || (consideredWord.length() > 1 && !mDictionaryFacilitator.isValidWord(consideredWord,wordComposer.isFirstCharCapitalized()) && !consideredWord.equals(firstSuggestion));
  final boolean hasAutoCorrection;
  if (!isCorrectionEnabled || !allowsToBeAutoCorrected || isPrediction|| suggestionsSet.isEmpty()|| wordComposer.hasDigits()|| wordComposer.isMostlyCaps()|| wordComposer.isResumed()|| !mDictionaryFacilitator.hasMainDictionary()|| SuggestedWordInfo.KIND_SHORTCUT == suggestionsSet.first().mKind) {
    hasAutoCorrection=false;
  }
 else {
    hasAutoCorrection=AutoCorrectionUtils.suggestionExceedsAutoCorrectionThreshold(suggestionsSet.first(),consideredWord,mAutoCorrectionThreshold);
  }
  final ArrayList<SuggestedWordInfo> suggestionsContainer=CollectionUtils.newArrayList(suggestionsSet);
  final int suggestionsCount=suggestionsContainer.size();
  if (isFirstCharCapitalized || isAllUpperCase || 0 != trailingSingleQuotesCount) {
    for (int i=0; i < suggestionsCount; ++i) {
      final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
      final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,mLocale,isAllUpperCase,isFirstCharCapitalized,trailingSingleQuotesCount);
      suggestionsContainer.set(i,transformedWordInfo);
    }
  }
  for (int i=0; i < suggestionsCount; ++i) {
    final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
    LatinImeLogger.onAddSuggestedWord(wordInfo.mWord.toString(),wordInfo.mSourceDict.mDictType);
  }
  if (!TextUtils.isEmpty(typedWord)) {
    suggestionsContainer.add(0,new SuggestedWordInfo(typedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  SuggestedWordInfo.removeDups(suggestionsContainer);
  final ArrayList<SuggestedWordInfo> suggestionsList;
  if (DBG && !suggestionsContainer.isEmpty()) {
    suggestionsList=getSuggestionsInfoListWithDebugInfo(typedWord,suggestionsContainer);
  }
 else {
    suggestionsList=suggestionsContainer;
  }
  callback.onGetSuggestedWords(new SuggestedWords(suggestionsList,rawSuggestions,!isPrediction && !allowsToBeAutoCorrected,hasAutoCorrection,false,isPrediction,sequenceNumber));
}",0.9528645545865988
87423,"private void setupWordViewsTextAndColor(final SuggestedWords suggestedWords,final int countInStrip){
  for (int positionInStrip=0; positionInStrip < countInStrip; ++positionInStrip) {
    mWordViews.get(positionInStrip).setText(null);
    if (SuggestionStripView.DBG) {
      mDebugInfoViews.get(positionInStrip).setText(null);
    }
  }
  final int count=Math.min(suggestedWords.size(),countInStrip);
  for (int indexInSuggestedWords=0; indexInSuggestedWords < count; indexInSuggestedWords++) {
    final int positionInStrip=getPositionInSuggestionStrip(indexInSuggestedWords,suggestedWords);
    final TextView wordView=mWordViews.get(positionInStrip);
    wordView.setTag(indexInSuggestedWords);
    wordView.setText(getStyledSuggestedWord(suggestedWords,indexInSuggestedWords));
    wordView.setTextColor(getSuggestionTextColor(positionInStrip,suggestedWords));
    if (SuggestionStripView.DBG) {
      mDebugInfoViews.get(positionInStrip).setText(suggestedWords.getDebugString(indexInSuggestedWords));
    }
  }
}","private void setupWordViewsTextAndColor(final SuggestedWords suggestedWords,final int countInStrip){
  for (int positionInStrip=0; positionInStrip < countInStrip; ++positionInStrip) {
    mWordViews.get(positionInStrip).setText(null);
    if (SuggestionStripView.DBG) {
      mDebugInfoViews.get(positionInStrip).setText(null);
    }
  }
  final int count=Math.min(suggestedWords.size(),countInStrip);
  for (int indexInSuggestedWords=0; indexInSuggestedWords < count; indexInSuggestedWords++) {
    final int positionInStrip=getPositionInSuggestionStrip(indexInSuggestedWords,suggestedWords);
    final TextView wordView=mWordViews.get(positionInStrip);
    wordView.setTag(indexInSuggestedWords);
    wordView.setText(getStyledSuggestedWord(suggestedWords,indexInSuggestedWords));
    wordView.setTextColor(getSuggestionTextColor(suggestedWords,indexInSuggestedWords));
    if (SuggestionStripView.DBG) {
      mDebugInfoViews.get(positionInStrip).setText(suggestedWords.getDebugString(indexInSuggestedWords));
    }
  }
}",0.9813907933398628
87424,"private int getSuggestionTextColor(final int indexInSuggestedWords,final SuggestedWords suggestedWords){
  final int positionInStrip=getPositionInSuggestionStrip(indexInSuggestedWords,suggestedWords);
  final boolean isSuggested=(indexInSuggestedWords != SuggestedWords.INDEX_OF_TYPED_WORD);
  final int color;
  if (positionInStrip == mCenterPositionInStrip && suggestedWords.mWillAutoCorrect) {
    color=mColorAutoCorrect;
  }
 else   if (positionInStrip == mCenterPositionInStrip && suggestedWords.mTypedWordValid) {
    color=mColorValidTypedWord;
  }
 else   if (isSuggested) {
    color=mColorSuggested;
  }
 else {
    color=mColorTypedWord;
  }
  if (LatinImeLogger.sDBG && suggestedWords.size() > 1) {
    if (positionInStrip == mCenterPositionInStrip && AutoCorrectionUtils.shouldBlockAutoCorrectionBySafetyNet(suggestedWords.getLabel(SuggestedWords.INDEX_OF_AUTO_CORRECTION),suggestedWords.getLabel(SuggestedWords.INDEX_OF_TYPED_WORD))) {
      return 0xFFFF0000;
    }
  }
  if (suggestedWords.mIsObsoleteSuggestions && isSuggested) {
    return applyAlpha(color,mAlphaObsoleted);
  }
  return color;
}","private int getSuggestionTextColor(final SuggestedWords suggestedWords,final int indexInSuggestedWords){
  final int positionInStrip=getPositionInSuggestionStrip(indexInSuggestedWords,suggestedWords);
  final boolean isSuggested=(indexInSuggestedWords != SuggestedWords.INDEX_OF_TYPED_WORD);
  final int color;
  if (positionInStrip == mCenterPositionInStrip && suggestedWords.mWillAutoCorrect) {
    color=mColorAutoCorrect;
  }
 else   if (positionInStrip == mCenterPositionInStrip && suggestedWords.mTypedWordValid) {
    color=mColorValidTypedWord;
  }
 else   if (isSuggested) {
    color=mColorSuggested;
  }
 else {
    color=mColorTypedWord;
  }
  if (LatinImeLogger.sDBG && suggestedWords.size() > 1) {
    if (positionInStrip == mCenterPositionInStrip && AutoCorrectionUtils.shouldBlockAutoCorrectionBySafetyNet(suggestedWords.getLabel(SuggestedWords.INDEX_OF_AUTO_CORRECTION),suggestedWords.getLabel(SuggestedWords.INDEX_OF_TYPED_WORD))) {
      return 0xFFFF0000;
    }
  }
  if (suggestedWords.mIsObsoleteSuggestions && isSuggested) {
    return applyAlpha(color,mAlphaObsoleted);
  }
  return color;
}",0.9748878923766816
87425,"/** 
 * Handle a press on the backspace key.
 * @param settingsValues The current settings values.
 * @param spaceState The space state at start of this batch edit.
 */
private void handleBackspace(final SettingsValues settingsValues,final int spaceState,final LatinIME.UIHandler handler,final KeyboardSwitcher keyboardSwitcher){
  mSpaceState=SpaceState.NONE;
  final int deleteCountAtStart=mDeleteCount;
  mDeleteCount++;
  handler.postUpdateShiftState();
  if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
    resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd());
  }
  if (mWordComposer.isComposingWord()) {
    if (mWordComposer.isBatchMode()) {
      if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
        final String word=mWordComposer.getTypedWord();
        ResearchLogger.latinIME_handleBackspace_batch(word,1);
      }
      final String rejectedSuggestion=mWordComposer.getTypedWord();
      mWordComposer.reset();
      mWordComposer.setRejectedBatchModeSuggestion(rejectedSuggestion);
    }
 else {
      mWordComposer.deleteLast();
    }
    mConnection.setComposingText(getTextWithUnderline(mWordComposer.getTypedWord()),1);
    handler.postUpdateSuggestionStrip();
    if (!mWordComposer.isComposingWord()) {
      keyboardSwitcher.updateShiftState();
    }
  }
 else {
    if (mLastComposedWord.canRevertCommit()) {
      if (settingsValues.mIsInternal) {
        LatinImeLoggerUtils.onAutoCorrectionCancellation();
      }
      revertCommit(settingsValues,handler);
      return;
    }
    if (mEnteredText != null && mConnection.sameAsTextBeforeCursor(mEnteredText)) {
      mConnection.deleteSurroundingText(mEnteredText.length(),0);
      if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
        ResearchLogger.latinIME_handleBackspace_cancelTextInput(mEnteredText);
      }
      mEnteredText=null;
      return;
    }
    if (SpaceState.DOUBLE == spaceState) {
      handler.cancelDoubleSpacePeriodTimer();
      if (mConnection.revertDoubleSpacePeriod()) {
        return;
      }
    }
 else     if (SpaceState.SWAP_PUNCTUATION == spaceState) {
      if (mConnection.revertSwapPunctuation()) {
        return;
      }
    }
    if (mConnection.hasSelection()) {
      final int numCharsDeleted=mConnection.getExpectedSelectionEnd() - mConnection.getExpectedSelectionStart();
      mConnection.setSelection(mConnection.getExpectedSelectionEnd(),mConnection.getExpectedSelectionEnd());
      mConnection.deleteSurroundingText(numCharsDeleted,0);
      if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
        ResearchLogger.latinIME_handleBackspace(numCharsDeleted,false);
      }
    }
 else {
      if (Constants.NOT_A_CURSOR_POSITION == mConnection.getExpectedSelectionEnd()) {
        Log.e(TAG,""String_Node_Str"");
      }
      if (settingsValues.isBeforeJellyBean() || settingsValues.mInputAttributes.isTypeNull()) {
        sendDownUpKeyEvent(KeyEvent.KEYCODE_DEL);
        if (mDeleteCount > Constants.DELETE_ACCELERATE_AT) {
          sendDownUpKeyEvent(KeyEvent.KEYCODE_DEL);
        }
      }
 else {
        final int codePointBeforeCursor=mConnection.getCodePointBeforeCursor();
        if (codePointBeforeCursor == Constants.NOT_A_CODE) {
          mConnection.deleteSurroundingText(1,0);
          return;
        }
        final int lengthToDelete=Character.isSupplementaryCodePoint(codePointBeforeCursor) ? 2 : 1;
        mConnection.deleteSurroundingText(lengthToDelete,0);
        if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
          ResearchLogger.latinIME_handleBackspace(lengthToDelete,true);
        }
        if (mDeleteCount > Constants.DELETE_ACCELERATE_AT) {
          final int codePointBeforeCursorToDeleteAgain=mConnection.getCodePointBeforeCursor();
          if (codePointBeforeCursorToDeleteAgain != Constants.NOT_A_CODE) {
            final int lengthToDeleteAgain=Character.isSupplementaryCodePoint(codePointBeforeCursorToDeleteAgain) ? 2 : 1;
            mConnection.deleteSurroundingText(lengthToDeleteAgain,0);
            if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
              ResearchLogger.latinIME_handleBackspace(lengthToDeleteAgain,true);
            }
          }
        }
      }
    }
    if (settingsValues.isSuggestionStripVisible() && settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces && !mConnection.isCursorFollowedByWordCharacter(settingsValues.mSpacingAndPunctuations)) {
      restartSuggestionsOnWordTouchedByCursor(settingsValues,true);
    }
    keyboardSwitcher.updateShiftState();
  }
}","/** 
 * Handle a press on the backspace key.
 * @param settingsValues The current settings values.
 * @param spaceState The space state at start of this batch edit.
 */
private void handleBackspace(final SettingsValues settingsValues,final int spaceState,final LatinIME.UIHandler handler,final KeyboardSwitcher keyboardSwitcher){
  mSpaceState=SpaceState.NONE;
  final int deleteCountAtStart=mDeleteCount;
  mDeleteCount++;
  handler.postUpdateShiftState();
  if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
    resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),true);
  }
  if (mWordComposer.isComposingWord()) {
    if (mWordComposer.isBatchMode()) {
      if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
        final String word=mWordComposer.getTypedWord();
        ResearchLogger.latinIME_handleBackspace_batch(word,1);
      }
      final String rejectedSuggestion=mWordComposer.getTypedWord();
      mWordComposer.reset();
      mWordComposer.setRejectedBatchModeSuggestion(rejectedSuggestion);
    }
 else {
      mWordComposer.deleteLast();
    }
    mConnection.setComposingText(getTextWithUnderline(mWordComposer.getTypedWord()),1);
    handler.postUpdateSuggestionStrip();
    if (!mWordComposer.isComposingWord()) {
      keyboardSwitcher.updateShiftState();
    }
  }
 else {
    if (mLastComposedWord.canRevertCommit()) {
      if (settingsValues.mIsInternal) {
        LatinImeLoggerUtils.onAutoCorrectionCancellation();
      }
      revertCommit(settingsValues,handler);
      return;
    }
    if (mEnteredText != null && mConnection.sameAsTextBeforeCursor(mEnteredText)) {
      mConnection.deleteSurroundingText(mEnteredText.length(),0);
      if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
        ResearchLogger.latinIME_handleBackspace_cancelTextInput(mEnteredText);
      }
      mEnteredText=null;
      return;
    }
    if (SpaceState.DOUBLE == spaceState) {
      handler.cancelDoubleSpacePeriodTimer();
      if (mConnection.revertDoubleSpacePeriod()) {
        return;
      }
    }
 else     if (SpaceState.SWAP_PUNCTUATION == spaceState) {
      if (mConnection.revertSwapPunctuation()) {
        return;
      }
    }
    if (mConnection.hasSelection()) {
      final int numCharsDeleted=mConnection.getExpectedSelectionEnd() - mConnection.getExpectedSelectionStart();
      mConnection.setSelection(mConnection.getExpectedSelectionEnd(),mConnection.getExpectedSelectionEnd());
      mConnection.deleteSurroundingText(numCharsDeleted,0);
      if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
        ResearchLogger.latinIME_handleBackspace(numCharsDeleted,false);
      }
    }
 else {
      if (Constants.NOT_A_CURSOR_POSITION == mConnection.getExpectedSelectionEnd()) {
        Log.e(TAG,""String_Node_Str"");
      }
      if (settingsValues.isBeforeJellyBean() || settingsValues.mInputAttributes.isTypeNull()) {
        sendDownUpKeyEvent(KeyEvent.KEYCODE_DEL);
        if (mDeleteCount > Constants.DELETE_ACCELERATE_AT) {
          sendDownUpKeyEvent(KeyEvent.KEYCODE_DEL);
        }
      }
 else {
        final int codePointBeforeCursor=mConnection.getCodePointBeforeCursor();
        if (codePointBeforeCursor == Constants.NOT_A_CODE) {
          mConnection.deleteSurroundingText(1,0);
          return;
        }
        final int lengthToDelete=Character.isSupplementaryCodePoint(codePointBeforeCursor) ? 2 : 1;
        mConnection.deleteSurroundingText(lengthToDelete,0);
        if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
          ResearchLogger.latinIME_handleBackspace(lengthToDelete,true);
        }
        if (mDeleteCount > Constants.DELETE_ACCELERATE_AT) {
          final int codePointBeforeCursorToDeleteAgain=mConnection.getCodePointBeforeCursor();
          if (codePointBeforeCursorToDeleteAgain != Constants.NOT_A_CODE) {
            final int lengthToDeleteAgain=Character.isSupplementaryCodePoint(codePointBeforeCursorToDeleteAgain) ? 2 : 1;
            mConnection.deleteSurroundingText(lengthToDeleteAgain,0);
            if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
              ResearchLogger.latinIME_handleBackspace(lengthToDeleteAgain,true);
            }
          }
        }
      }
    }
    if (settingsValues.isSuggestionStripVisible() && settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces && !mConnection.isCursorFollowedByWordCharacter(settingsValues.mSpacingAndPunctuations)) {
      restartSuggestionsOnWordTouchedByCursor(settingsValues,true);
    }
    keyboardSwitcher.updateShiftState();
  }
}",0.9994583468746616
87426,"/** 
 * Resets the whole input state to the starting state. This will clear the composing word, reset the last composed word, clear the suggestion strip and tell the input connection about it so that it can refresh its caches.
 * @param settingsValues the current values of the settings.
 * @param newSelStart the new selection start, in java characters.
 * @param newSelEnd the new selection end, in java characters.
 */
public void resetEntireInputState(final SettingsValues settingsValues,final int newSelStart,final int newSelEnd){
  final boolean shouldFinishComposition=mWordComposer.isComposingWord();
  resetComposingState(true);
  mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
  mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,shouldFinishComposition);
}","/** 
 * Resets the whole input state to the starting state. This will clear the composing word, reset the last composed word, clear the suggestion strip and tell the input connection about it so that it can refresh its caches.
 * @param settingsValues the current values of the settings.
 * @param newSelStart the new selection start, in java characters.
 * @param newSelEnd the new selection end, in java characters.
 * @param clearSuggestionStrip whether this method should clear the suggestion strip.
 */
public void resetEntireInputState(final SettingsValues settingsValues,final int newSelStart,final int newSelEnd,final boolean clearSuggestionStrip){
  final boolean shouldFinishComposition=mWordComposer.isComposingWord();
  resetComposingState(true);
  if (clearSuggestionStrip) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
  }
  mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,shouldFinishComposition);
}",0.9109472490073738
87427,"/** 
 * Handle input of a separator code point.
 * @param settingsValues The current settings values.
 * @param codePoint the code point associated with the key.
 * @param isFromSuggestionStrip whether this code point comes from the suggestion strip.
 * @param spaceState the space state at start of the batch input.
 * @return whether this caused an auto-correction to happen.
 */
private boolean handleSeparator(final SettingsValues settingsValues,final int codePoint,final boolean isFromSuggestionStrip,final int spaceState,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  boolean didAutoCorrect=false;
  final boolean shouldAvoidSendingCode=Constants.CODE_SPACE == codePoint && !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces && mWordComposer.isComposingWord();
  if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
    resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd());
  }
  if (mWordComposer.isComposingWord()) {
    if (settingsValues.mCorrectionEnabled) {
      final String separator=shouldAvoidSendingCode ? LastComposedWord.NOT_A_SEPARATOR : StringUtils.newSingleCodePointString(codePoint);
      commitCurrentAutoCorrection(settingsValues,separator,handler);
      didAutoCorrect=true;
    }
 else {
      commitTyped(settingsValues,StringUtils.newSingleCodePointString(codePoint));
    }
  }
  final boolean swapWeakSpace=maybeStripSpace(settingsValues,codePoint,spaceState,isFromSuggestionStrip);
  final boolean isInsideDoubleQuoteOrAfterDigit=Constants.CODE_DOUBLE_QUOTE == codePoint && mConnection.isInsideDoubleQuoteOrAfterDigit();
  final boolean needsPrecedingSpace;
  if (SpaceState.PHANTOM != spaceState) {
    needsPrecedingSpace=false;
  }
 else   if (Constants.CODE_DOUBLE_QUOTE == codePoint) {
    needsPrecedingSpace=!isInsideDoubleQuoteOrAfterDigit;
  }
 else {
    needsPrecedingSpace=settingsValues.isUsuallyPrecededBySpace(codePoint);
  }
  if (needsPrecedingSpace) {
    promotePhantomSpace(settingsValues);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    ResearchLogger.latinIME_handleSeparator(codePoint,mWordComposer.isComposingWord());
  }
  if (!shouldAvoidSendingCode) {
    sendKeyCodePoint(settingsValues,codePoint);
  }
  if (Constants.CODE_SPACE == codePoint) {
    if (settingsValues.isSuggestionsRequested()) {
      if (maybeDoubleSpacePeriod(settingsValues,handler)) {
        keyboardSwitcher.updateShiftState();
        mSpaceState=SpaceState.DOUBLE;
      }
 else       if (!mSuggestedWords.isPunctuationSuggestions()) {
        mSpaceState=SpaceState.WEAK;
      }
    }
    handler.startDoubleSpacePeriodTimer();
    handler.postUpdateSuggestionStrip();
  }
 else {
    if (swapWeakSpace) {
      swapSwapperAndSpace(keyboardSwitcher);
      mSpaceState=SpaceState.SWAP_PUNCTUATION;
    }
 else     if ((SpaceState.PHANTOM == spaceState && settingsValues.isUsuallyFollowedBySpace(codePoint)) || (Constants.CODE_DOUBLE_QUOTE == codePoint && isInsideDoubleQuoteOrAfterDigit)) {
      mSpaceState=SpaceState.PHANTOM;
    }
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
  }
  keyboardSwitcher.updateShiftState();
  return didAutoCorrect;
}","/** 
 * Handle input of a separator code point.
 * @param settingsValues The current settings values.
 * @param codePoint the code point associated with the key.
 * @param isFromSuggestionStrip whether this code point comes from the suggestion strip.
 * @param spaceState the space state at start of the batch input.
 * @return whether this caused an auto-correction to happen.
 */
private boolean handleSeparator(final SettingsValues settingsValues,final int codePoint,final boolean isFromSuggestionStrip,final int spaceState,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  boolean didAutoCorrect=false;
  final boolean shouldAvoidSendingCode=Constants.CODE_SPACE == codePoint && !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces && mWordComposer.isComposingWord();
  if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
    resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),true);
  }
  if (mWordComposer.isComposingWord()) {
    if (settingsValues.mCorrectionEnabled) {
      final String separator=shouldAvoidSendingCode ? LastComposedWord.NOT_A_SEPARATOR : StringUtils.newSingleCodePointString(codePoint);
      commitCurrentAutoCorrection(settingsValues,separator,handler);
      didAutoCorrect=true;
    }
 else {
      commitTyped(settingsValues,StringUtils.newSingleCodePointString(codePoint));
    }
  }
  final boolean swapWeakSpace=maybeStripSpace(settingsValues,codePoint,spaceState,isFromSuggestionStrip);
  final boolean isInsideDoubleQuoteOrAfterDigit=Constants.CODE_DOUBLE_QUOTE == codePoint && mConnection.isInsideDoubleQuoteOrAfterDigit();
  final boolean needsPrecedingSpace;
  if (SpaceState.PHANTOM != spaceState) {
    needsPrecedingSpace=false;
  }
 else   if (Constants.CODE_DOUBLE_QUOTE == codePoint) {
    needsPrecedingSpace=!isInsideDoubleQuoteOrAfterDigit;
  }
 else {
    needsPrecedingSpace=settingsValues.isUsuallyPrecededBySpace(codePoint);
  }
  if (needsPrecedingSpace) {
    promotePhantomSpace(settingsValues);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    ResearchLogger.latinIME_handleSeparator(codePoint,mWordComposer.isComposingWord());
  }
  if (!shouldAvoidSendingCode) {
    sendKeyCodePoint(settingsValues,codePoint);
  }
  if (Constants.CODE_SPACE == codePoint) {
    if (settingsValues.isSuggestionsRequested()) {
      if (maybeDoubleSpacePeriod(settingsValues,handler)) {
        keyboardSwitcher.updateShiftState();
        mSpaceState=SpaceState.DOUBLE;
      }
 else       if (!mSuggestedWords.isPunctuationSuggestions()) {
        mSpaceState=SpaceState.WEAK;
      }
    }
    handler.startDoubleSpacePeriodTimer();
    handler.postUpdateSuggestionStrip();
  }
 else {
    if (swapWeakSpace) {
      swapSwapperAndSpace(keyboardSwitcher);
      mSpaceState=SpaceState.SWAP_PUNCTUATION;
    }
 else     if ((SpaceState.PHANTOM == spaceState && settingsValues.isUsuallyFollowedBySpace(codePoint)) || (Constants.CODE_DOUBLE_QUOTE == codePoint && isInsideDoubleQuoteOrAfterDigit)) {
      mSpaceState=SpaceState.PHANTOM;
    }
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
  }
  keyboardSwitcher.updateShiftState();
  return didAutoCorrect;
}",0.9992292276861416
87428,"/** 
 * Consider an update to the cursor position. Evaluate whether this update has happened as part of normal typing or whether it was an explicit cursor move by the user. In any case, do the necessary adjustments.
 * @param settingsValues the current settings
 * @param oldSelStart old selection start
 * @param oldSelEnd old selection end
 * @param newSelStart new selection start
 * @param newSelEnd new selection end
 * @param composingSpanStart composing span start
 * @param composingSpanEnd composing span end
 * @return whether the cursor has moved as a result of user interaction.
 */
public boolean onUpdateSelection(final SettingsValues settingsValues,final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  if (mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart,oldSelEnd,newSelEnd)) {
    return false;
  }
  mSpaceState=SpaceState.NONE;
  final boolean selectionChangedOrSafeToReset=oldSelStart != newSelStart || oldSelEnd != newSelEnd || !mWordComposer.isComposingWord();
  final boolean hasOrHadSelection=(oldSelStart != oldSelEnd || newSelStart != newSelEnd);
  final int moveAmount=newSelStart - oldSelStart;
  if (selectionChangedOrSafeToReset && (hasOrHadSelection || !mWordComposer.moveCursorByAndReturnIfInsideComposingWord(moveAmount))) {
    resetEntireInputState(settingsValues,newSelStart,newSelEnd);
  }
 else {
    mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,false);
  }
  mLatinIME.mHandler.postResumeSuggestions();
  mRecapitalizeStatus.deactivate();
  return true;
}","/** 
 * Consider an update to the cursor position. Evaluate whether this update has happened as part of normal typing or whether it was an explicit cursor move by the user. In any case, do the necessary adjustments.
 * @param settingsValues the current settings
 * @param oldSelStart old selection start
 * @param oldSelEnd old selection end
 * @param newSelStart new selection start
 * @param newSelEnd new selection end
 * @param composingSpanStart composing span start
 * @param composingSpanEnd composing span end
 * @return whether the cursor has moved as a result of user interaction.
 */
public boolean onUpdateSelection(final SettingsValues settingsValues,final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  if (mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart,oldSelEnd,newSelEnd)) {
    return false;
  }
  mSpaceState=SpaceState.NONE;
  final boolean selectionChangedOrSafeToReset=oldSelStart != newSelStart || oldSelEnd != newSelEnd || !mWordComposer.isComposingWord();
  final boolean hasOrHadSelection=(oldSelStart != oldSelEnd || newSelStart != newSelEnd);
  final int moveAmount=newSelStart - oldSelStart;
  if (selectionChangedOrSafeToReset && (hasOrHadSelection || !mWordComposer.moveCursorByAndReturnIfInsideComposingWord(moveAmount))) {
    resetEntireInputState(settingsValues,newSelStart,newSelEnd,false);
  }
 else {
    mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,false);
  }
  mLatinIME.mHandler.postResumeSuggestions();
  mRecapitalizeStatus.deactivate();
  return true;
}",0.998159509202454
87429,"/** 
 * Handle inputting a code point to the editor. Non-special keys are those that generate a single code point. This includes all letters, digits, punctuation, separators, emoji. It excludes keys that manage keyboard-related stuff like shift, language switch, settings, layout switch, or any key that results in multiple code points like the "".com"" key.
 * @param settingsValues The current settings values.
 * @param codePoint the code point associated with the key.
 * @param x the x-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param y the y-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param spaceState the space state at start of the batch input.
 * @return whether this caused an auto-correction to happen.
 */
private boolean handleNonSpecialCharacter(final SettingsValues settingsValues,final int codePoint,final int x,final int y,final int spaceState,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  mSpaceState=SpaceState.NONE;
  final boolean didAutoCorrect;
  if (settingsValues.isWordSeparator(codePoint) || Character.getType(codePoint) == Character.OTHER_SYMBOL) {
    didAutoCorrect=handleSeparator(settingsValues,codePoint,Constants.SUGGESTION_STRIP_COORDINATE == x,spaceState,keyboardSwitcher,handler);
    if (settingsValues.mIsInternal) {
      LatinImeLoggerUtils.onSeparator((char)codePoint,x,y);
    }
  }
 else {
    didAutoCorrect=false;
    if (SpaceState.PHANTOM == spaceState) {
      if (settingsValues.mIsInternal) {
        if (mWordComposer.isComposingWord() && mWordComposer.isBatchMode()) {
          LatinImeLoggerUtils.onAutoCorrection(""String_Node_Str"",mWordComposer.getTypedWord(),""String_Node_Str"",mWordComposer);
        }
      }
      if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
        resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd());
      }
 else {
        commitTyped(settingsValues,LastComposedWord.NOT_A_SEPARATOR);
      }
    }
    handleNonSeparator(settingsValues,codePoint,x,y,spaceState,keyboardSwitcher,handler);
  }
  return didAutoCorrect;
}","/** 
 * Handle inputting a code point to the editor. Non-special keys are those that generate a single code point. This includes all letters, digits, punctuation, separators, emoji. It excludes keys that manage keyboard-related stuff like shift, language switch, settings, layout switch, or any key that results in multiple code points like the "".com"" key.
 * @param settingsValues The current settings values.
 * @param codePoint the code point associated with the key.
 * @param x the x-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param y the y-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param spaceState the space state at start of the batch input.
 * @return whether this caused an auto-correction to happen.
 */
private boolean handleNonSpecialCharacter(final SettingsValues settingsValues,final int codePoint,final int x,final int y,final int spaceState,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  mSpaceState=SpaceState.NONE;
  final boolean didAutoCorrect;
  if (settingsValues.isWordSeparator(codePoint) || Character.getType(codePoint) == Character.OTHER_SYMBOL) {
    didAutoCorrect=handleSeparator(settingsValues,codePoint,Constants.SUGGESTION_STRIP_COORDINATE == x,spaceState,keyboardSwitcher,handler);
    if (settingsValues.mIsInternal) {
      LatinImeLoggerUtils.onSeparator((char)codePoint,x,y);
    }
  }
 else {
    didAutoCorrect=false;
    if (SpaceState.PHANTOM == spaceState) {
      if (settingsValues.mIsInternal) {
        if (mWordComposer.isComposingWord() && mWordComposer.isBatchMode()) {
          LatinImeLoggerUtils.onAutoCorrection(""String_Node_Str"",mWordComposer.getTypedWord(),""String_Node_Str"",mWordComposer);
        }
      }
      if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
        resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),true);
      }
 else {
        commitTyped(settingsValues,LastComposedWord.NOT_A_SEPARATOR);
      }
    }
    handleNonSeparator(settingsValues,codePoint,x,y,spaceState,keyboardSwitcher,handler);
  }
  return didAutoCorrect;
}",0.9988566201692202
87430,"public void onStartBatchInput(final SettingsValues settingsValues,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  mInputLogicHandler.onStartBatchInput();
  handler.showGesturePreviewAndSuggestionStrip(SuggestedWords.EMPTY,false);
  handler.cancelUpdateSuggestionStrip();
  mConnection.beginBatchEdit();
  if (mWordComposer.isComposingWord()) {
    if (settingsValues.mIsInternal) {
      if (mWordComposer.isBatchMode()) {
        LatinImeLoggerUtils.onAutoCorrection(""String_Node_Str"",mWordComposer.getTypedWord(),""String_Node_Str"",mWordComposer);
      }
    }
    final int wordComposerSize=mWordComposer.size();
    if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
      resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd());
    }
 else     if (wordComposerSize <= 1) {
      commitCurrentAutoCorrection(settingsValues,LastComposedWord.NOT_A_SEPARATOR,handler);
    }
 else {
      commitTyped(settingsValues,LastComposedWord.NOT_A_SEPARATOR);
    }
  }
  final int codePointBeforeCursor=mConnection.getCodePointBeforeCursor();
  if (Character.isLetterOrDigit(codePointBeforeCursor) || settingsValues.isUsuallyFollowedBySpace(codePointBeforeCursor)) {
    final boolean autoShiftHasBeenOverriden=keyboardSwitcher.getKeyboardShiftMode() != getCurrentAutoCapsState(settingsValues);
    mSpaceState=SpaceState.PHANTOM;
    if (!autoShiftHasBeenOverriden) {
      keyboardSwitcher.updateShiftState();
    }
  }
  mConnection.endBatchEdit();
  mWordComposer.setCapitalizedModeAndPreviousWordAtStartComposingTime(getActualCapsMode(settingsValues,keyboardSwitcher.getKeyboardShiftMode()),getNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,1));
}","public void onStartBatchInput(final SettingsValues settingsValues,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  mInputLogicHandler.onStartBatchInput();
  handler.showGesturePreviewAndSuggestionStrip(SuggestedWords.EMPTY,false);
  handler.cancelUpdateSuggestionStrip();
  mConnection.beginBatchEdit();
  if (mWordComposer.isComposingWord()) {
    if (settingsValues.mIsInternal) {
      if (mWordComposer.isBatchMode()) {
        LatinImeLoggerUtils.onAutoCorrection(""String_Node_Str"",mWordComposer.getTypedWord(),""String_Node_Str"",mWordComposer);
      }
    }
    final int wordComposerSize=mWordComposer.size();
    if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
      resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),true);
    }
 else     if (wordComposerSize <= 1) {
      commitCurrentAutoCorrection(settingsValues,LastComposedWord.NOT_A_SEPARATOR,handler);
    }
 else {
      commitTyped(settingsValues,LastComposedWord.NOT_A_SEPARATOR);
    }
  }
  final int codePointBeforeCursor=mConnection.getCodePointBeforeCursor();
  if (Character.isLetterOrDigit(codePointBeforeCursor) || settingsValues.isUsuallyFollowedBySpace(codePointBeforeCursor)) {
    final boolean autoShiftHasBeenOverriden=keyboardSwitcher.getKeyboardShiftMode() != getCurrentAutoCapsState(settingsValues);
    mSpaceState=SpaceState.PHANTOM;
    if (!autoShiftHasBeenOverriden) {
      keyboardSwitcher.updateShiftState();
    }
  }
  mConnection.endBatchEdit();
  mWordComposer.setCapitalizedModeAndPreviousWordAtStartComposingTime(getActualCapsMode(settingsValues,keyboardSwitcher.getKeyboardShiftMode()),getNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,1));
}",0.9985855728429984
87431,"/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 * @param settingsValues the current values of the settings.
 * @param includeResumedWordInSuggestions whether to include the word on which we resumesuggestions in the suggestion list.
 */
public void restartSuggestionsOnWordTouchedByCursor(final SettingsValues settingsValues,final boolean includeResumedWordInSuggestions){
  if (settingsValues.isBrokenByRecorrection())   return;
  if (!settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces)   return;
  if (!settingsValues.isSuggestionsRequested())   return;
  if (mConnection.hasSelection())   return;
  if (mConnection.getExpectedSelectionStart() < 0)   return;
  final int expectedCursorPosition=mConnection.getExpectedSelectionStart();
  if (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations))   return;
  final TextRange range=mConnection.getWordRangeAtCursor(settingsValues.mSpacingAndPunctuations.mSortedWordSeparators,0);
  if (null == range)   return;
  if (range.length() <= 0)   return;
  if (range.mHasUrlSpans)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > expectedCursorPosition)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final String typedWord=range.mWord.toString();
  if (includeResumedWordInSuggestions) {
    suggestions.add(new SuggestedWordInfo(typedWord,SuggestedWords.MAX_SUGGESTIONS + 1,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  if (!isResumableWord(settingsValues,typedWord))   return;
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestedWords.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  final int[] codePoints=StringUtils.toCodePointArray(typedWord);
  mWordComposer.setComposingWord(codePoints,mLatinIME.getCoordinatesForCurrentKeyboard(codePoints),getNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,0 == numberOfCharsInWordBeforeCursor ? 1 : 2));
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.setComposingRegion(expectedCursorPosition - numberOfCharsInWordBeforeCursor,expectedCursorPosition + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.isEmpty()) {
    mInputLogicHandler.getSuggestedWords(Suggest.SESSION_TYPING,SuggestedWords.NOT_A_SEQUENCE_NUMBER,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1 && !includeResumedWordInSuggestions) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        mIsAutoCorrectionIndicatorOn=false;
        mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,null,typedWord,true,false,false,false,SuggestedWords.NOT_A_SEQUENCE_NUMBER);
    mIsAutoCorrectionIndicatorOn=false;
    mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
  }
}","/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 * @param settingsValues the current values of the settings.
 * @param includeResumedWordInSuggestions whether to include the word on which we resumesuggestions in the suggestion list.
 */
public void restartSuggestionsOnWordTouchedByCursor(final SettingsValues settingsValues,final boolean includeResumedWordInSuggestions){
  if (settingsValues.isBrokenByRecorrection() || !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces || !settingsValues.isSuggestionsRequested()|| mConnection.hasSelection()|| mConnection.getExpectedSelectionStart() < 0) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  final int expectedCursorPosition=mConnection.getExpectedSelectionStart();
  if (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations)) {
    mWordComposer.setCapitalizedModeAndPreviousWordAtStartComposingTime(WordComposer.CAPS_MODE_OFF,getNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,1));
    mLatinIME.mHandler.postUpdateSuggestionStrip();
    return;
  }
  final TextRange range=mConnection.getWordRangeAtCursor(settingsValues.mSpacingAndPunctuations.mSortedWordSeparators,0);
  if (null == range)   return;
  if (range.length() <= 0)   return;
  if (range.mHasUrlSpans)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > expectedCursorPosition)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final String typedWord=range.mWord.toString();
  if (includeResumedWordInSuggestions) {
    suggestions.add(new SuggestedWordInfo(typedWord,SuggestedWords.MAX_SUGGESTIONS + 1,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  if (!isResumableWord(settingsValues,typedWord))   return;
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestedWords.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  final int[] codePoints=StringUtils.toCodePointArray(typedWord);
  mWordComposer.setComposingWord(codePoints,mLatinIME.getCoordinatesForCurrentKeyboard(codePoints),getNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,0 == numberOfCharsInWordBeforeCursor ? 1 : 2));
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.setComposingRegion(expectedCursorPosition - numberOfCharsInWordBeforeCursor,expectedCursorPosition + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.isEmpty()) {
    mInputLogicHandler.getSuggestedWords(Suggest.SESSION_TYPING,SuggestedWords.NOT_A_SEQUENCE_NUMBER,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1 && !includeResumedWordInSuggestions) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        mIsAutoCorrectionIndicatorOn=false;
        mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,null,typedWord,true,false,false,false,SuggestedWords.NOT_A_SEQUENCE_NUMBER);
    mIsAutoCorrectionIndicatorOn=false;
    mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
  }
}",0.9447852760736196
87432,"/** 
 * Handle a non-separator.
 * @param settingsValues The current settings values.
 * @param codePoint the code point associated with the key.
 * @param x the x-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param y the y-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param spaceState the space state at start of the batch input.
 */
private void handleNonSeparator(final SettingsValues settingsValues,final int codePoint,final int x,final int y,final int spaceState,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  boolean isComposingWord=mWordComposer.isComposingWord();
  if (SpaceState.PHANTOM == spaceState && !settingsValues.isWordConnector(codePoint)) {
    if (isComposingWord) {
      throw new RuntimeException(""String_Node_Str"");
    }
    promotePhantomSpace(settingsValues);
  }
  if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
    resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd());
    isComposingWord=false;
  }
  if (!isComposingWord && settingsValues.isWordCodePoint(codePoint) && settingsValues.isSuggestionsRequested()&& (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations) || !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces)) {
    isComposingWord=(Constants.CODE_SINGLE_QUOTE != codePoint && Constants.CODE_DASH != codePoint);
    resetComposingState(false);
  }
  if (isComposingWord) {
    mWordComposer.add(codePoint,x,y);
    if (mWordComposer.size() == 1) {
      mWordComposer.setCapitalizedModeAndPreviousWordAtStartComposingTime(getActualCapsMode(settingsValues,keyboardSwitcher.getKeyboardShiftMode()),getNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,1));
    }
    mConnection.setComposingText(getTextWithUnderline(mWordComposer.getTypedWord()),1);
  }
 else {
    final boolean swapWeakSpace=maybeStripSpace(settingsValues,codePoint,spaceState,Constants.SUGGESTION_STRIP_COORDINATE == x);
    sendKeyCodePoint(settingsValues,codePoint);
    if (swapWeakSpace) {
      swapSwapperAndSpace(keyboardSwitcher);
      mSpaceState=SpaceState.WEAK;
    }
    mSuggestionStripViewAccessor.dismissAddToDictionaryHint();
  }
  handler.postUpdateSuggestionStrip();
  if (settingsValues.mIsInternal) {
    LatinImeLoggerUtils.onNonSeparator((char)codePoint,x,y);
  }
}","/** 
 * Handle a non-separator.
 * @param settingsValues The current settings values.
 * @param codePoint the code point associated with the key.
 * @param x the x-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param y the y-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param spaceState the space state at start of the batch input.
 */
private void handleNonSeparator(final SettingsValues settingsValues,final int codePoint,final int x,final int y,final int spaceState,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  boolean isComposingWord=mWordComposer.isComposingWord();
  if (SpaceState.PHANTOM == spaceState && !settingsValues.isWordConnector(codePoint)) {
    if (isComposingWord) {
      throw new RuntimeException(""String_Node_Str"");
    }
    promotePhantomSpace(settingsValues);
  }
  if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
    resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),true);
    isComposingWord=false;
  }
  if (!isComposingWord && settingsValues.isWordCodePoint(codePoint) && settingsValues.isSuggestionsRequested()&& (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations) || !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces)) {
    isComposingWord=(Constants.CODE_SINGLE_QUOTE != codePoint && Constants.CODE_DASH != codePoint);
    resetComposingState(false);
  }
  if (isComposingWord) {
    mWordComposer.add(codePoint,x,y);
    if (mWordComposer.size() == 1) {
      mWordComposer.setCapitalizedModeAndPreviousWordAtStartComposingTime(getActualCapsMode(settingsValues,keyboardSwitcher.getKeyboardShiftMode()),getNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,1));
    }
    mConnection.setComposingText(getTextWithUnderline(mWordComposer.getTypedWord()),1);
  }
 else {
    final boolean swapWeakSpace=maybeStripSpace(settingsValues,codePoint,spaceState,Constants.SUGGESTION_STRIP_COORDINATE == x);
    sendKeyCodePoint(settingsValues,codePoint);
    if (swapWeakSpace) {
      swapSwapperAndSpace(keyboardSwitcher);
      mSpaceState=SpaceState.WEAK;
    }
    mSuggestionStripViewAccessor.dismissAddToDictionaryHint();
  }
  handler.postUpdateSuggestionStrip();
  if (settingsValues.mIsInternal) {
    LatinImeLoggerUtils.onNonSeparator((char)codePoint,x,y);
  }
}",0.9989718280896566
87433,"/** 
 * Handle a press on the backspace key.
 * @param settingsValues The current settings values.
 * @param spaceState The space state at start of this batch edit.
 */
private void handleBackspace(final SettingsValues settingsValues,final int spaceState,final LatinIME.UIHandler handler,final KeyboardSwitcher keyboardSwitcher){
  mSpaceState=SpaceState.NONE;
  final int deleteCountAtStart=mDeleteCount;
  mDeleteCount++;
  handler.postUpdateShiftState();
  if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
    resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd());
  }
  if (mWordComposer.isComposingWord()) {
    if (mWordComposer.isBatchMode()) {
      if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
        final String word=mWordComposer.getTypedWord();
        ResearchLogger.latinIME_handleBackspace_batch(word,1);
      }
      final String rejectedSuggestion=mWordComposer.getTypedWord();
      mWordComposer.reset();
      mWordComposer.setRejectedBatchModeSuggestion(rejectedSuggestion);
    }
 else {
      mWordComposer.deleteLast();
    }
    mConnection.setComposingText(getTextWithUnderline(mWordComposer.getTypedWord()),1);
    handler.postUpdateSuggestionStrip();
    if (!mWordComposer.isComposingWord()) {
      keyboardSwitcher.updateShiftState();
    }
  }
 else {
    if (mLastComposedWord.canRevertCommit()) {
      if (settingsValues.mIsInternal) {
        LatinImeLoggerUtils.onAutoCorrectionCancellation();
      }
      revertCommit(settingsValues,handler);
      return;
    }
    if (mEnteredText != null && mConnection.sameAsTextBeforeCursor(mEnteredText)) {
      mConnection.deleteSurroundingText(mEnteredText.length(),0);
      if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
        ResearchLogger.latinIME_handleBackspace_cancelTextInput(mEnteredText);
      }
      mEnteredText=null;
      return;
    }
    if (SpaceState.DOUBLE == spaceState) {
      handler.cancelDoubleSpacePeriodTimer();
      if (mConnection.revertDoubleSpacePeriod()) {
        return;
      }
    }
 else     if (SpaceState.SWAP_PUNCTUATION == spaceState) {
      if (mConnection.revertSwapPunctuation()) {
        return;
      }
    }
    if (mConnection.hasSelection()) {
      final int numCharsDeleted=mConnection.getExpectedSelectionEnd() - mConnection.getExpectedSelectionStart();
      mConnection.setSelection(mConnection.getExpectedSelectionEnd(),mConnection.getExpectedSelectionEnd());
      mConnection.deleteSurroundingText(numCharsDeleted,0);
      if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
        ResearchLogger.latinIME_handleBackspace(numCharsDeleted,false);
      }
    }
 else {
      if (Constants.NOT_A_CURSOR_POSITION == mConnection.getExpectedSelectionEnd()) {
        Log.e(TAG,""String_Node_Str"");
      }
      if (settingsValues.isBeforeJellyBean() || settingsValues.mInputAttributes.isTypeNull()) {
        sendDownUpKeyEvent(KeyEvent.KEYCODE_DEL);
        if (mDeleteCount > Constants.DELETE_ACCELERATE_AT) {
          sendDownUpKeyEvent(KeyEvent.KEYCODE_DEL);
        }
      }
 else {
        final int codePointBeforeCursor=mConnection.getCodePointBeforeCursor();
        if (codePointBeforeCursor == Constants.NOT_A_CODE) {
          mConnection.deleteSurroundingText(1,0);
          return;
        }
        final int lengthToDelete=Character.isSupplementaryCodePoint(codePointBeforeCursor) ? 2 : 1;
        mConnection.deleteSurroundingText(lengthToDelete,0);
        if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
          ResearchLogger.latinIME_handleBackspace(lengthToDelete,true);
        }
        if (mDeleteCount > Constants.DELETE_ACCELERATE_AT) {
          final int codePointBeforeCursorToDeleteAgain=mConnection.getCodePointBeforeCursor();
          if (codePointBeforeCursorToDeleteAgain != Constants.NOT_A_CODE) {
            final int lengthToDeleteAgain=Character.isSupplementaryCodePoint(codePointBeforeCursorToDeleteAgain) ? 2 : 1;
            mConnection.deleteSurroundingText(lengthToDeleteAgain,0);
            if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
              ResearchLogger.latinIME_handleBackspace(lengthToDeleteAgain,true);
            }
          }
        }
      }
    }
    if (settingsValues.isSuggestionStripVisible() && settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces && !mConnection.isCursorFollowedByWordCharacter(settingsValues.mSpacingAndPunctuations)) {
      restartSuggestionsOnWordTouchedByCursor(settingsValues,true);
    }
    keyboardSwitcher.updateShiftState();
  }
}","/** 
 * Handle a press on the backspace key.
 * @param settingsValues The current settings values.
 * @param spaceState The space state at start of this batch edit.
 */
private void handleBackspace(final SettingsValues settingsValues,final int spaceState,final LatinIME.UIHandler handler,final KeyboardSwitcher keyboardSwitcher){
  mSpaceState=SpaceState.NONE;
  final int deleteCountAtStart=mDeleteCount;
  mDeleteCount++;
  handler.postUpdateShiftState();
  if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
    resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),true);
  }
  if (mWordComposer.isComposingWord()) {
    if (mWordComposer.isBatchMode()) {
      if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
        final String word=mWordComposer.getTypedWord();
        ResearchLogger.latinIME_handleBackspace_batch(word,1);
      }
      final String rejectedSuggestion=mWordComposer.getTypedWord();
      mWordComposer.reset();
      mWordComposer.setRejectedBatchModeSuggestion(rejectedSuggestion);
    }
 else {
      mWordComposer.deleteLast();
    }
    mConnection.setComposingText(getTextWithUnderline(mWordComposer.getTypedWord()),1);
    handler.postUpdateSuggestionStrip();
    if (!mWordComposer.isComposingWord()) {
      keyboardSwitcher.updateShiftState();
    }
  }
 else {
    if (mLastComposedWord.canRevertCommit()) {
      if (settingsValues.mIsInternal) {
        LatinImeLoggerUtils.onAutoCorrectionCancellation();
      }
      revertCommit(settingsValues,handler);
      return;
    }
    if (mEnteredText != null && mConnection.sameAsTextBeforeCursor(mEnteredText)) {
      mConnection.deleteSurroundingText(mEnteredText.length(),0);
      if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
        ResearchLogger.latinIME_handleBackspace_cancelTextInput(mEnteredText);
      }
      mEnteredText=null;
      return;
    }
    if (SpaceState.DOUBLE == spaceState) {
      handler.cancelDoubleSpacePeriodTimer();
      if (mConnection.revertDoubleSpacePeriod()) {
        return;
      }
    }
 else     if (SpaceState.SWAP_PUNCTUATION == spaceState) {
      if (mConnection.revertSwapPunctuation()) {
        return;
      }
    }
    if (mConnection.hasSelection()) {
      final int numCharsDeleted=mConnection.getExpectedSelectionEnd() - mConnection.getExpectedSelectionStart();
      mConnection.setSelection(mConnection.getExpectedSelectionEnd(),mConnection.getExpectedSelectionEnd());
      mConnection.deleteSurroundingText(numCharsDeleted,0);
      if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
        ResearchLogger.latinIME_handleBackspace(numCharsDeleted,false);
      }
    }
 else {
      if (Constants.NOT_A_CURSOR_POSITION == mConnection.getExpectedSelectionEnd()) {
        Log.e(TAG,""String_Node_Str"");
      }
      if (settingsValues.isBeforeJellyBean() || settingsValues.mInputAttributes.isTypeNull()) {
        sendDownUpKeyEvent(KeyEvent.KEYCODE_DEL);
        if (mDeleteCount > Constants.DELETE_ACCELERATE_AT) {
          sendDownUpKeyEvent(KeyEvent.KEYCODE_DEL);
        }
      }
 else {
        final int codePointBeforeCursor=mConnection.getCodePointBeforeCursor();
        if (codePointBeforeCursor == Constants.NOT_A_CODE) {
          mConnection.deleteSurroundingText(1,0);
          return;
        }
        final int lengthToDelete=Character.isSupplementaryCodePoint(codePointBeforeCursor) ? 2 : 1;
        mConnection.deleteSurroundingText(lengthToDelete,0);
        if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
          ResearchLogger.latinIME_handleBackspace(lengthToDelete,true);
        }
        if (mDeleteCount > Constants.DELETE_ACCELERATE_AT) {
          final int codePointBeforeCursorToDeleteAgain=mConnection.getCodePointBeforeCursor();
          if (codePointBeforeCursorToDeleteAgain != Constants.NOT_A_CODE) {
            final int lengthToDeleteAgain=Character.isSupplementaryCodePoint(codePointBeforeCursorToDeleteAgain) ? 2 : 1;
            mConnection.deleteSurroundingText(lengthToDeleteAgain,0);
            if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
              ResearchLogger.latinIME_handleBackspace(lengthToDeleteAgain,true);
            }
          }
        }
      }
    }
    if (settingsValues.isSuggestionStripVisible() && settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces && !mConnection.isCursorFollowedByWordCharacter(settingsValues.mSpacingAndPunctuations)) {
      restartSuggestionsOnWordTouchedByCursor(settingsValues,true);
    }
    keyboardSwitcher.updateShiftState();
  }
}",0.9994583468746616
87434,"/** 
 * Resets the whole input state to the starting state. This will clear the composing word, reset the last composed word, clear the suggestion strip and tell the input connection about it so that it can refresh its caches.
 * @param settingsValues the current values of the settings.
 * @param newSelStart the new selection start, in java characters.
 * @param newSelEnd the new selection end, in java characters.
 */
public void resetEntireInputState(final SettingsValues settingsValues,final int newSelStart,final int newSelEnd){
  final boolean shouldFinishComposition=mWordComposer.isComposingWord();
  resetComposingState(true);
  mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
  mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,shouldFinishComposition);
}","/** 
 * Resets the whole input state to the starting state. This will clear the composing word, reset the last composed word, clear the suggestion strip and tell the input connection about it so that it can refresh its caches.
 * @param settingsValues the current values of the settings.
 * @param newSelStart the new selection start, in java characters.
 * @param newSelEnd the new selection end, in java characters.
 * @param clearSuggestionStrip whether this method should clear the suggestion strip.
 */
public void resetEntireInputState(final SettingsValues settingsValues,final int newSelStart,final int newSelEnd,final boolean clearSuggestionStrip){
  final boolean shouldFinishComposition=mWordComposer.isComposingWord();
  resetComposingState(true);
  if (clearSuggestionStrip) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
  }
  mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,shouldFinishComposition);
}",0.9109472490073738
87435,"/** 
 * Handle input of a separator code point.
 * @param settingsValues The current settings values.
 * @param codePoint the code point associated with the key.
 * @param isFromSuggestionStrip whether this code point comes from the suggestion strip.
 * @param spaceState the space state at start of the batch input.
 * @return whether this caused an auto-correction to happen.
 */
private boolean handleSeparator(final SettingsValues settingsValues,final int codePoint,final boolean isFromSuggestionStrip,final int spaceState,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  boolean didAutoCorrect=false;
  final boolean shouldAvoidSendingCode=Constants.CODE_SPACE == codePoint && !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces && mWordComposer.isComposingWord();
  if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
    resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd());
  }
  if (mWordComposer.isComposingWord()) {
    if (settingsValues.mCorrectionEnabled) {
      final String separator=shouldAvoidSendingCode ? LastComposedWord.NOT_A_SEPARATOR : StringUtils.newSingleCodePointString(codePoint);
      commitCurrentAutoCorrection(settingsValues,separator,handler);
      didAutoCorrect=true;
    }
 else {
      commitTyped(settingsValues,StringUtils.newSingleCodePointString(codePoint));
    }
  }
  final boolean swapWeakSpace=maybeStripSpace(settingsValues,codePoint,spaceState,isFromSuggestionStrip);
  final boolean isInsideDoubleQuoteOrAfterDigit=Constants.CODE_DOUBLE_QUOTE == codePoint && mConnection.isInsideDoubleQuoteOrAfterDigit();
  final boolean needsPrecedingSpace;
  if (SpaceState.PHANTOM != spaceState) {
    needsPrecedingSpace=false;
  }
 else   if (Constants.CODE_DOUBLE_QUOTE == codePoint) {
    needsPrecedingSpace=!isInsideDoubleQuoteOrAfterDigit;
  }
 else {
    needsPrecedingSpace=settingsValues.isUsuallyPrecededBySpace(codePoint);
  }
  if (needsPrecedingSpace) {
    promotePhantomSpace(settingsValues);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    ResearchLogger.latinIME_handleSeparator(codePoint,mWordComposer.isComposingWord());
  }
  if (!shouldAvoidSendingCode) {
    sendKeyCodePoint(settingsValues,codePoint);
  }
  if (Constants.CODE_SPACE == codePoint) {
    if (settingsValues.isSuggestionsRequested()) {
      if (maybeDoubleSpacePeriod(settingsValues,handler)) {
        keyboardSwitcher.updateShiftState();
        mSpaceState=SpaceState.DOUBLE;
      }
 else       if (!mSuggestedWords.isPunctuationSuggestions()) {
        mSpaceState=SpaceState.WEAK;
      }
    }
    handler.startDoubleSpacePeriodTimer();
    handler.postUpdateSuggestionStrip();
  }
 else {
    if (swapWeakSpace) {
      swapSwapperAndSpace(keyboardSwitcher);
      mSpaceState=SpaceState.SWAP_PUNCTUATION;
    }
 else     if ((SpaceState.PHANTOM == spaceState && settingsValues.isUsuallyFollowedBySpace(codePoint)) || (Constants.CODE_DOUBLE_QUOTE == codePoint && isInsideDoubleQuoteOrAfterDigit)) {
      mSpaceState=SpaceState.PHANTOM;
    }
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
  }
  keyboardSwitcher.updateShiftState();
  return didAutoCorrect;
}","/** 
 * Handle input of a separator code point.
 * @param settingsValues The current settings values.
 * @param codePoint the code point associated with the key.
 * @param isFromSuggestionStrip whether this code point comes from the suggestion strip.
 * @param spaceState the space state at start of the batch input.
 * @return whether this caused an auto-correction to happen.
 */
private boolean handleSeparator(final SettingsValues settingsValues,final int codePoint,final boolean isFromSuggestionStrip,final int spaceState,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  boolean didAutoCorrect=false;
  final boolean shouldAvoidSendingCode=Constants.CODE_SPACE == codePoint && !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces && mWordComposer.isComposingWord();
  if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
    resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),true);
  }
  if (mWordComposer.isComposingWord()) {
    if (settingsValues.mCorrectionEnabled) {
      final String separator=shouldAvoidSendingCode ? LastComposedWord.NOT_A_SEPARATOR : StringUtils.newSingleCodePointString(codePoint);
      commitCurrentAutoCorrection(settingsValues,separator,handler);
      didAutoCorrect=true;
    }
 else {
      commitTyped(settingsValues,StringUtils.newSingleCodePointString(codePoint));
    }
  }
  final boolean swapWeakSpace=maybeStripSpace(settingsValues,codePoint,spaceState,isFromSuggestionStrip);
  final boolean isInsideDoubleQuoteOrAfterDigit=Constants.CODE_DOUBLE_QUOTE == codePoint && mConnection.isInsideDoubleQuoteOrAfterDigit();
  final boolean needsPrecedingSpace;
  if (SpaceState.PHANTOM != spaceState) {
    needsPrecedingSpace=false;
  }
 else   if (Constants.CODE_DOUBLE_QUOTE == codePoint) {
    needsPrecedingSpace=!isInsideDoubleQuoteOrAfterDigit;
  }
 else {
    needsPrecedingSpace=settingsValues.isUsuallyPrecededBySpace(codePoint);
  }
  if (needsPrecedingSpace) {
    promotePhantomSpace(settingsValues);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    ResearchLogger.latinIME_handleSeparator(codePoint,mWordComposer.isComposingWord());
  }
  if (!shouldAvoidSendingCode) {
    sendKeyCodePoint(settingsValues,codePoint);
  }
  if (Constants.CODE_SPACE == codePoint) {
    if (settingsValues.isSuggestionsRequested()) {
      if (maybeDoubleSpacePeriod(settingsValues,handler)) {
        keyboardSwitcher.updateShiftState();
        mSpaceState=SpaceState.DOUBLE;
      }
 else       if (!mSuggestedWords.isPunctuationSuggestions()) {
        mSpaceState=SpaceState.WEAK;
      }
    }
    handler.startDoubleSpacePeriodTimer();
    handler.postUpdateSuggestionStrip();
  }
 else {
    if (swapWeakSpace) {
      swapSwapperAndSpace(keyboardSwitcher);
      mSpaceState=SpaceState.SWAP_PUNCTUATION;
    }
 else     if ((SpaceState.PHANTOM == spaceState && settingsValues.isUsuallyFollowedBySpace(codePoint)) || (Constants.CODE_DOUBLE_QUOTE == codePoint && isInsideDoubleQuoteOrAfterDigit)) {
      mSpaceState=SpaceState.PHANTOM;
    }
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
  }
  keyboardSwitcher.updateShiftState();
  return didAutoCorrect;
}",0.9992292276861416
87436,"/** 
 * Consider an update to the cursor position. Evaluate whether this update has happened as part of normal typing or whether it was an explicit cursor move by the user. In any case, do the necessary adjustments.
 * @param settingsValues the current settings
 * @param oldSelStart old selection start
 * @param oldSelEnd old selection end
 * @param newSelStart new selection start
 * @param newSelEnd new selection end
 * @param composingSpanStart composing span start
 * @param composingSpanEnd composing span end
 * @return whether the cursor has moved as a result of user interaction.
 */
public boolean onUpdateSelection(final SettingsValues settingsValues,final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  if (mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart,oldSelEnd,newSelEnd)) {
    return false;
  }
  mSpaceState=SpaceState.NONE;
  final boolean selectionChangedOrSafeToReset=oldSelStart != newSelStart || oldSelEnd != newSelEnd || !mWordComposer.isComposingWord();
  final boolean hasOrHadSelection=(oldSelStart != oldSelEnd || newSelStart != newSelEnd);
  final int moveAmount=newSelStart - oldSelStart;
  if (selectionChangedOrSafeToReset && (hasOrHadSelection || !mWordComposer.moveCursorByAndReturnIfInsideComposingWord(moveAmount))) {
    resetEntireInputState(settingsValues,newSelStart,newSelEnd);
  }
 else {
    mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,false);
  }
  mLatinIME.mHandler.postResumeSuggestions();
  mRecapitalizeStatus.deactivate();
  return true;
}","/** 
 * Consider an update to the cursor position. Evaluate whether this update has happened as part of normal typing or whether it was an explicit cursor move by the user. In any case, do the necessary adjustments.
 * @param settingsValues the current settings
 * @param oldSelStart old selection start
 * @param oldSelEnd old selection end
 * @param newSelStart new selection start
 * @param newSelEnd new selection end
 * @param composingSpanStart composing span start
 * @param composingSpanEnd composing span end
 * @return whether the cursor has moved as a result of user interaction.
 */
public boolean onUpdateSelection(final SettingsValues settingsValues,final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  if (mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart,oldSelEnd,newSelEnd)) {
    return false;
  }
  mSpaceState=SpaceState.NONE;
  final boolean selectionChangedOrSafeToReset=oldSelStart != newSelStart || oldSelEnd != newSelEnd || !mWordComposer.isComposingWord();
  final boolean hasOrHadSelection=(oldSelStart != oldSelEnd || newSelStart != newSelEnd);
  final int moveAmount=newSelStart - oldSelStart;
  if (selectionChangedOrSafeToReset && (hasOrHadSelection || !mWordComposer.moveCursorByAndReturnIfInsideComposingWord(moveAmount))) {
    resetEntireInputState(settingsValues,newSelStart,newSelEnd,false);
  }
 else {
    mConnection.resetCachesUponCursorMoveAndReturnSuccess(newSelStart,newSelEnd,false);
  }
  mLatinIME.mHandler.postResumeSuggestions();
  mRecapitalizeStatus.deactivate();
  return true;
}",0.998159509202454
87437,"/** 
 * Handle inputting a code point to the editor. Non-special keys are those that generate a single code point. This includes all letters, digits, punctuation, separators, emoji. It excludes keys that manage keyboard-related stuff like shift, language switch, settings, layout switch, or any key that results in multiple code points like the "".com"" key.
 * @param settingsValues The current settings values.
 * @param codePoint the code point associated with the key.
 * @param x the x-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param y the y-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param spaceState the space state at start of the batch input.
 * @return whether this caused an auto-correction to happen.
 */
private boolean handleNonSpecialCharacter(final SettingsValues settingsValues,final int codePoint,final int x,final int y,final int spaceState,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  mSpaceState=SpaceState.NONE;
  final boolean didAutoCorrect;
  if (settingsValues.isWordSeparator(codePoint) || Character.getType(codePoint) == Character.OTHER_SYMBOL) {
    didAutoCorrect=handleSeparator(settingsValues,codePoint,Constants.SUGGESTION_STRIP_COORDINATE == x,spaceState,keyboardSwitcher,handler);
    if (settingsValues.mIsInternal) {
      LatinImeLoggerUtils.onSeparator((char)codePoint,x,y);
    }
  }
 else {
    didAutoCorrect=false;
    if (SpaceState.PHANTOM == spaceState) {
      if (settingsValues.mIsInternal) {
        if (mWordComposer.isComposingWord() && mWordComposer.isBatchMode()) {
          LatinImeLoggerUtils.onAutoCorrection(""String_Node_Str"",mWordComposer.getTypedWord(),""String_Node_Str"",mWordComposer);
        }
      }
      if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
        resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd());
      }
 else {
        commitTyped(settingsValues,LastComposedWord.NOT_A_SEPARATOR);
      }
    }
    handleNonSeparator(settingsValues,codePoint,x,y,spaceState,keyboardSwitcher,handler);
  }
  return didAutoCorrect;
}","/** 
 * Handle inputting a code point to the editor. Non-special keys are those that generate a single code point. This includes all letters, digits, punctuation, separators, emoji. It excludes keys that manage keyboard-related stuff like shift, language switch, settings, layout switch, or any key that results in multiple code points like the "".com"" key.
 * @param settingsValues The current settings values.
 * @param codePoint the code point associated with the key.
 * @param x the x-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param y the y-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param spaceState the space state at start of the batch input.
 * @return whether this caused an auto-correction to happen.
 */
private boolean handleNonSpecialCharacter(final SettingsValues settingsValues,final int codePoint,final int x,final int y,final int spaceState,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  mSpaceState=SpaceState.NONE;
  final boolean didAutoCorrect;
  if (settingsValues.isWordSeparator(codePoint) || Character.getType(codePoint) == Character.OTHER_SYMBOL) {
    didAutoCorrect=handleSeparator(settingsValues,codePoint,Constants.SUGGESTION_STRIP_COORDINATE == x,spaceState,keyboardSwitcher,handler);
    if (settingsValues.mIsInternal) {
      LatinImeLoggerUtils.onSeparator((char)codePoint,x,y);
    }
  }
 else {
    didAutoCorrect=false;
    if (SpaceState.PHANTOM == spaceState) {
      if (settingsValues.mIsInternal) {
        if (mWordComposer.isComposingWord() && mWordComposer.isBatchMode()) {
          LatinImeLoggerUtils.onAutoCorrection(""String_Node_Str"",mWordComposer.getTypedWord(),""String_Node_Str"",mWordComposer);
        }
      }
      if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
        resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),true);
      }
 else {
        commitTyped(settingsValues,LastComposedWord.NOT_A_SEPARATOR);
      }
    }
    handleNonSeparator(settingsValues,codePoint,x,y,spaceState,keyboardSwitcher,handler);
  }
  return didAutoCorrect;
}",0.9988566201692202
87438,"public void onStartBatchInput(final SettingsValues settingsValues,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  mInputLogicHandler.onStartBatchInput();
  handler.showGesturePreviewAndSuggestionStrip(SuggestedWords.EMPTY,false);
  handler.cancelUpdateSuggestionStrip();
  mConnection.beginBatchEdit();
  if (mWordComposer.isComposingWord()) {
    if (settingsValues.mIsInternal) {
      if (mWordComposer.isBatchMode()) {
        LatinImeLoggerUtils.onAutoCorrection(""String_Node_Str"",mWordComposer.getTypedWord(),""String_Node_Str"",mWordComposer);
      }
    }
    final int wordComposerSize=mWordComposer.size();
    if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
      resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd());
    }
 else     if (wordComposerSize <= 1) {
      commitCurrentAutoCorrection(settingsValues,LastComposedWord.NOT_A_SEPARATOR,handler);
    }
 else {
      commitTyped(settingsValues,LastComposedWord.NOT_A_SEPARATOR);
    }
  }
  final int codePointBeforeCursor=mConnection.getCodePointBeforeCursor();
  if (Character.isLetterOrDigit(codePointBeforeCursor) || settingsValues.isUsuallyFollowedBySpace(codePointBeforeCursor)) {
    final boolean autoShiftHasBeenOverriden=keyboardSwitcher.getKeyboardShiftMode() != getCurrentAutoCapsState(settingsValues);
    mSpaceState=SpaceState.PHANTOM;
    if (!autoShiftHasBeenOverriden) {
      keyboardSwitcher.updateShiftState();
    }
  }
  mConnection.endBatchEdit();
  mWordComposer.setCapitalizedModeAndPreviousWordAtStartComposingTime(getActualCapsMode(settingsValues,keyboardSwitcher.getKeyboardShiftMode()),getNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,1));
}","public void onStartBatchInput(final SettingsValues settingsValues,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  mInputLogicHandler.onStartBatchInput();
  handler.showGesturePreviewAndSuggestionStrip(SuggestedWords.EMPTY,false);
  handler.cancelUpdateSuggestionStrip();
  mConnection.beginBatchEdit();
  if (mWordComposer.isComposingWord()) {
    if (settingsValues.mIsInternal) {
      if (mWordComposer.isBatchMode()) {
        LatinImeLoggerUtils.onAutoCorrection(""String_Node_Str"",mWordComposer.getTypedWord(),""String_Node_Str"",mWordComposer);
      }
    }
    final int wordComposerSize=mWordComposer.size();
    if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
      resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),true);
    }
 else     if (wordComposerSize <= 1) {
      commitCurrentAutoCorrection(settingsValues,LastComposedWord.NOT_A_SEPARATOR,handler);
    }
 else {
      commitTyped(settingsValues,LastComposedWord.NOT_A_SEPARATOR);
    }
  }
  final int codePointBeforeCursor=mConnection.getCodePointBeforeCursor();
  if (Character.isLetterOrDigit(codePointBeforeCursor) || settingsValues.isUsuallyFollowedBySpace(codePointBeforeCursor)) {
    final boolean autoShiftHasBeenOverriden=keyboardSwitcher.getKeyboardShiftMode() != getCurrentAutoCapsState(settingsValues);
    mSpaceState=SpaceState.PHANTOM;
    if (!autoShiftHasBeenOverriden) {
      keyboardSwitcher.updateShiftState();
    }
  }
  mConnection.endBatchEdit();
  mWordComposer.setCapitalizedModeAndPreviousWordAtStartComposingTime(getActualCapsMode(settingsValues,keyboardSwitcher.getKeyboardShiftMode()),getNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,1));
}",0.9985855728429984
87439,"/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 * @param settingsValues the current values of the settings.
 * @param includeResumedWordInSuggestions whether to include the word on which we resumesuggestions in the suggestion list.
 */
public void restartSuggestionsOnWordTouchedByCursor(final SettingsValues settingsValues,final boolean includeResumedWordInSuggestions){
  if (settingsValues.isBrokenByRecorrection())   return;
  if (!settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces)   return;
  if (!settingsValues.isSuggestionsRequested())   return;
  if (mConnection.hasSelection())   return;
  if (mConnection.getExpectedSelectionStart() < 0)   return;
  final int expectedCursorPosition=mConnection.getExpectedSelectionStart();
  if (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations))   return;
  final TextRange range=mConnection.getWordRangeAtCursor(settingsValues.mSpacingAndPunctuations.mSortedWordSeparators,0);
  if (null == range)   return;
  if (range.length() <= 0)   return;
  if (range.mHasUrlSpans)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > expectedCursorPosition)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final String typedWord=range.mWord.toString();
  if (includeResumedWordInSuggestions) {
    suggestions.add(new SuggestedWordInfo(typedWord,SuggestedWords.MAX_SUGGESTIONS + 1,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  if (!isResumableWord(settingsValues,typedWord))   return;
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestedWords.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  final int[] codePoints=StringUtils.toCodePointArray(typedWord);
  mWordComposer.setComposingWord(codePoints,mLatinIME.getCoordinatesForCurrentKeyboard(codePoints),getNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,0 == numberOfCharsInWordBeforeCursor ? 1 : 2));
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.setComposingRegion(expectedCursorPosition - numberOfCharsInWordBeforeCursor,expectedCursorPosition + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.isEmpty()) {
    mInputLogicHandler.getSuggestedWords(Suggest.SESSION_TYPING,SuggestedWords.NOT_A_SEQUENCE_NUMBER,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1 && !includeResumedWordInSuggestions) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        mIsAutoCorrectionIndicatorOn=false;
        mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,null,typedWord,true,false,false,false,SuggestedWords.NOT_A_SEQUENCE_NUMBER);
    mIsAutoCorrectionIndicatorOn=false;
    mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
  }
}","/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 * @param settingsValues the current values of the settings.
 * @param includeResumedWordInSuggestions whether to include the word on which we resumesuggestions in the suggestion list.
 */
public void restartSuggestionsOnWordTouchedByCursor(final SettingsValues settingsValues,final boolean includeResumedWordInSuggestions){
  if (settingsValues.isBrokenByRecorrection() || !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces || !settingsValues.isSuggestionsRequested()|| mConnection.hasSelection()|| mConnection.getExpectedSelectionStart() < 0) {
    mSuggestionStripViewAccessor.setNeutralSuggestionStrip();
    return;
  }
  final int expectedCursorPosition=mConnection.getExpectedSelectionStart();
  if (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations)) {
    mWordComposer.setCapitalizedModeAndPreviousWordAtStartComposingTime(WordComposer.CAPS_MODE_OFF,getNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,1));
    mLatinIME.mHandler.postUpdateSuggestionStrip();
    return;
  }
  final TextRange range=mConnection.getWordRangeAtCursor(settingsValues.mSpacingAndPunctuations.mSortedWordSeparators,0);
  if (null == range)   return;
  if (range.length() <= 0)   return;
  if (range.mHasUrlSpans)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > expectedCursorPosition)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final String typedWord=range.mWord.toString();
  if (includeResumedWordInSuggestions) {
    suggestions.add(new SuggestedWordInfo(typedWord,SuggestedWords.MAX_SUGGESTIONS + 1,SuggestedWordInfo.KIND_TYPED,Dictionary.DICTIONARY_USER_TYPED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
  }
  if (!isResumableWord(settingsValues,typedWord))   return;
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestedWords.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  final int[] codePoints=StringUtils.toCodePointArray(typedWord);
  mWordComposer.setComposingWord(codePoints,mLatinIME.getCoordinatesForCurrentKeyboard(codePoints),getNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,0 == numberOfCharsInWordBeforeCursor ? 1 : 2));
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.setComposingRegion(expectedCursorPosition - numberOfCharsInWordBeforeCursor,expectedCursorPosition + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.isEmpty()) {
    mInputLogicHandler.getSuggestedWords(Suggest.SESSION_TYPING,SuggestedWords.NOT_A_SEQUENCE_NUMBER,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1 && !includeResumedWordInSuggestions) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        mIsAutoCorrectionIndicatorOn=false;
        mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,null,typedWord,true,false,false,false,SuggestedWords.NOT_A_SEQUENCE_NUMBER);
    mIsAutoCorrectionIndicatorOn=false;
    mLatinIME.mHandler.showSuggestionStrip(suggestedWords);
  }
}",0.9447852760736196
87440,"/** 
 * Handle a non-separator.
 * @param settingsValues The current settings values.
 * @param codePoint the code point associated with the key.
 * @param x the x-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param y the y-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param spaceState the space state at start of the batch input.
 */
private void handleNonSeparator(final SettingsValues settingsValues,final int codePoint,final int x,final int y,final int spaceState,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  boolean isComposingWord=mWordComposer.isComposingWord();
  if (SpaceState.PHANTOM == spaceState && !settingsValues.isWordConnector(codePoint)) {
    if (isComposingWord) {
      throw new RuntimeException(""String_Node_Str"");
    }
    promotePhantomSpace(settingsValues);
  }
  if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
    resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd());
    isComposingWord=false;
  }
  if (!isComposingWord && settingsValues.isWordCodePoint(codePoint) && settingsValues.isSuggestionsRequested()&& (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations) || !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces)) {
    isComposingWord=(Constants.CODE_SINGLE_QUOTE != codePoint && Constants.CODE_DASH != codePoint);
    resetComposingState(false);
  }
  if (isComposingWord) {
    mWordComposer.add(codePoint,x,y);
    if (mWordComposer.size() == 1) {
      mWordComposer.setCapitalizedModeAndPreviousWordAtStartComposingTime(getActualCapsMode(settingsValues,keyboardSwitcher.getKeyboardShiftMode()),getNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,1));
    }
    mConnection.setComposingText(getTextWithUnderline(mWordComposer.getTypedWord()),1);
  }
 else {
    final boolean swapWeakSpace=maybeStripSpace(settingsValues,codePoint,spaceState,Constants.SUGGESTION_STRIP_COORDINATE == x);
    sendKeyCodePoint(settingsValues,codePoint);
    if (swapWeakSpace) {
      swapSwapperAndSpace(keyboardSwitcher);
      mSpaceState=SpaceState.WEAK;
    }
    mSuggestionStripViewAccessor.dismissAddToDictionaryHint();
  }
  handler.postUpdateSuggestionStrip();
  if (settingsValues.mIsInternal) {
    LatinImeLoggerUtils.onNonSeparator((char)codePoint,x,y);
  }
}","/** 
 * Handle a non-separator.
 * @param settingsValues The current settings values.
 * @param codePoint the code point associated with the key.
 * @param x the x-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param y the y-coordinate of the key press, or Contants.NOT_A_COORDINATE if not applicable.
 * @param spaceState the space state at start of the batch input.
 */
private void handleNonSeparator(final SettingsValues settingsValues,final int codePoint,final int x,final int y,final int spaceState,final KeyboardSwitcher keyboardSwitcher,final LatinIME.UIHandler handler){
  boolean isComposingWord=mWordComposer.isComposingWord();
  if (SpaceState.PHANTOM == spaceState && !settingsValues.isWordConnector(codePoint)) {
    if (isComposingWord) {
      throw new RuntimeException(""String_Node_Str"");
    }
    promotePhantomSpace(settingsValues);
  }
  if (mWordComposer.isCursorFrontOrMiddleOfComposingWord()) {
    resetEntireInputState(settingsValues,mConnection.getExpectedSelectionStart(),mConnection.getExpectedSelectionEnd(),true);
    isComposingWord=false;
  }
  if (!isComposingWord && settingsValues.isWordCodePoint(codePoint) && settingsValues.isSuggestionsRequested()&& (!mConnection.isCursorTouchingWord(settingsValues.mSpacingAndPunctuations) || !settingsValues.mSpacingAndPunctuations.mCurrentLanguageHasSpaces)) {
    isComposingWord=(Constants.CODE_SINGLE_QUOTE != codePoint && Constants.CODE_DASH != codePoint);
    resetComposingState(false);
  }
  if (isComposingWord) {
    mWordComposer.add(codePoint,x,y);
    if (mWordComposer.size() == 1) {
      mWordComposer.setCapitalizedModeAndPreviousWordAtStartComposingTime(getActualCapsMode(settingsValues,keyboardSwitcher.getKeyboardShiftMode()),getNthPreviousWordForSuggestion(settingsValues.mSpacingAndPunctuations,1));
    }
    mConnection.setComposingText(getTextWithUnderline(mWordComposer.getTypedWord()),1);
  }
 else {
    final boolean swapWeakSpace=maybeStripSpace(settingsValues,codePoint,spaceState,Constants.SUGGESTION_STRIP_COORDINATE == x);
    sendKeyCodePoint(settingsValues,codePoint);
    if (swapWeakSpace) {
      swapSwapperAndSpace(keyboardSwitcher);
      mSpaceState=SpaceState.WEAK;
    }
    mSuggestionStripViewAccessor.dismissAddToDictionaryHint();
  }
  handler.postUpdateSuggestionStrip();
  if (settingsValues.mIsInternal) {
    LatinImeLoggerUtils.onNonSeparator((char)codePoint,x,y);
  }
}",0.9989718280896566
87441,"public void setComposingRegion(final int start,final int end){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  final CharSequence textBeforeCursor=getTextBeforeCursor(Constants.EDITOR_CONTENTS_CACHE_SIZE + (end - start),0);
  mCommittedTextBeforeComposingText.setLength(0);
  if (!TextUtils.isEmpty(textBeforeCursor)) {
    final int indexOfStartOfComposingText=Math.max(textBeforeCursor.length() - (end - start),0);
    mComposingText.append(textBeforeCursor.subSequence(indexOfStartOfComposingText,textBeforeCursor.length()));
    mCommittedTextBeforeComposingText.append(textBeforeCursor.subSequence(0,indexOfStartOfComposingText));
  }
  if (null != mIC) {
    mIC.setComposingRegion(start,end);
  }
}","public void setComposingRegion(final int start,final int end){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  final CharSequence textBeforeCursor=getTextBeforeCursor(Constants.EDITOR_CONTENTS_CACHE_SIZE + (end - start),0);
  mCommittedTextBeforeComposingText.setLength(0);
  if (!TextUtils.isEmpty(textBeforeCursor)) {
    final int indexOfStartOfComposingText=Math.max(textBeforeCursor.length() - (mExpectedSelStart - start),0);
    mComposingText.append(textBeforeCursor.subSequence(indexOfStartOfComposingText,textBeforeCursor.length()));
    mCommittedTextBeforeComposingText.append(textBeforeCursor.subSequence(0,indexOfStartOfComposingText));
  }
  if (null != mIC) {
    mIC.setComposingRegion(start,end);
  }
}",0.987012987012987
87442,"public void setComposingRegion(final int start,final int end){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  final CharSequence textBeforeCursor=getTextBeforeCursor(Constants.EDITOR_CONTENTS_CACHE_SIZE + (end - start),0);
  mCommittedTextBeforeComposingText.setLength(0);
  if (!TextUtils.isEmpty(textBeforeCursor)) {
    final int indexOfStartOfComposingText=Math.max(textBeforeCursor.length() - (end - start),0);
    mComposingText.append(textBeforeCursor.subSequence(indexOfStartOfComposingText,textBeforeCursor.length()));
    mCommittedTextBeforeComposingText.append(textBeforeCursor.subSequence(0,indexOfStartOfComposingText));
  }
  if (null != mIC) {
    mIC.setComposingRegion(start,end);
  }
}","public void setComposingRegion(final int start,final int end){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  final CharSequence textBeforeCursor=getTextBeforeCursor(Constants.EDITOR_CONTENTS_CACHE_SIZE + (end - start),0);
  mCommittedTextBeforeComposingText.setLength(0);
  if (!TextUtils.isEmpty(textBeforeCursor)) {
    final int indexOfStartOfComposingText=Math.max(textBeforeCursor.length() - (mExpectedSelStart - start),0);
    mComposingText.append(textBeforeCursor.subSequence(indexOfStartOfComposingText,textBeforeCursor.length()));
    mCommittedTextBeforeComposingText.append(textBeforeCursor.subSequence(0,indexOfStartOfComposingText));
  }
  if (null != mIC) {
    mIC.setComposingRegion(start,end);
  }
}",0.987012987012987
87443,"public void dismissKeyPreview(final Key key,final boolean withAnimation){
  if (key == null) {
    return;
  }
  final TextView previewTextView=mShowingKeyPreviewTextViews.get(key);
  if (previewTextView == null) {
    return;
  }
  final Object tag=previewTextView.getTag();
  if (withAnimation) {
    if (tag instanceof KeyPreviewAnimations) {
      final KeyPreviewAnimations animation=(KeyPreviewAnimations)tag;
      animation.startDismiss();
    }
    return;
  }
  if (tag instanceof Animator) {
    ((Animator)tag).cancel();
  }
  previewTextView.setTag(null);
  previewTextView.setVisibility(View.INVISIBLE);
  mFreeKeyPreviewTextViews.add(previewTextView);
}","public void dismissKeyPreview(final Key key,final boolean withAnimation){
  if (key == null) {
    return;
  }
  final TextView previewTextView=mShowingKeyPreviewTextViews.get(key);
  if (previewTextView == null) {
    return;
  }
  final Object tag=previewTextView.getTag();
  if (withAnimation) {
    if (tag instanceof KeyPreviewAnimations) {
      final KeyPreviewAnimations animation=(KeyPreviewAnimations)tag;
      animation.startDismiss();
      return;
    }
  }
  mShowingKeyPreviewTextViews.remove(key);
  if (tag instanceof Animator) {
    ((Animator)tag).cancel();
  }
  previewTextView.setTag(null);
  previewTextView.setVisibility(View.INVISIBLE);
  mFreeKeyPreviewTextViews.add(previewTextView);
}",0.9500362056480812
87444,"public void dismissKeyPreview(final Key key,final boolean withAnimation){
  if (key == null) {
    return;
  }
  final TextView previewTextView=mShowingKeyPreviewTextViews.get(key);
  if (previewTextView == null) {
    return;
  }
  final Object tag=previewTextView.getTag();
  if (withAnimation) {
    if (tag instanceof KeyPreviewAnimations) {
      final KeyPreviewAnimations animation=(KeyPreviewAnimations)tag;
      animation.startDismiss();
    }
    return;
  }
  if (tag instanceof Animator) {
    ((Animator)tag).cancel();
  }
  previewTextView.setTag(null);
  previewTextView.setVisibility(View.INVISIBLE);
  mFreeKeyPreviewTextViews.add(previewTextView);
}","public void dismissKeyPreview(final Key key,final boolean withAnimation){
  if (key == null) {
    return;
  }
  final TextView previewTextView=mShowingKeyPreviewTextViews.get(key);
  if (previewTextView == null) {
    return;
  }
  final Object tag=previewTextView.getTag();
  if (withAnimation) {
    if (tag instanceof KeyPreviewAnimations) {
      final KeyPreviewAnimations animation=(KeyPreviewAnimations)tag;
      animation.startDismiss();
      return;
    }
  }
  mShowingKeyPreviewTextViews.remove(key);
  if (tag instanceof Animator) {
    ((Animator)tag).cancel();
  }
  previewTextView.setTag(null);
  previewTextView.setVisibility(View.INVISIBLE);
  mFreeKeyPreviewTextViews.add(previewTextView);
}",0.9500362056480812
87445,"public SpacingAndPunctuations(final Resources res){
  mSymbolsPrecededBySpace=StringUtils.toCodePointArray(res.getString(R.string.symbols_preceded_by_space));
  Arrays.sort(mSymbolsPrecededBySpace);
  mSymbolsFollowedBySpace=StringUtils.toCodePointArray(res.getString(R.string.symbols_followed_by_space));
  Arrays.sort(mSymbolsFollowedBySpace);
  mWordConnectors=StringUtils.toCodePointArray(res.getString(R.string.symbols_word_connectors));
  Arrays.sort(mWordConnectors);
  final String[] suggestPuncsSpec=KeySpecParser.splitKeySpecs(res.getString(R.string.suggested_punctuations));
  mSuggestPuncList=createSuggestPuncList(suggestPuncsSpec);
  mWordSeparators=res.getString(R.string.symbols_word_separators);
  mSentenceSeparator=res.getInteger(R.integer.sentence_separator);
  mSentenceSeparatorAndSpace=new String(new int[]{mSentenceSeparator,Constants.CODE_SPACE},0,2);
  mCurrentLanguageHasSpaces=res.getBoolean(R.bool.current_language_has_spaces);
  final Locale locale=res.getConfiguration().locale;
  mUsesAmericanTypography=Locale.ENGLISH.getLanguage().equals(locale.getLanguage());
}","public SpacingAndPunctuations(final Resources res){
  mSymbolsPrecededBySpace=StringUtils.toCodePointArray(res.getString(R.string.symbols_preceded_by_space));
  Arrays.sort(mSymbolsPrecededBySpace);
  mSymbolsFollowedBySpace=StringUtils.toCodePointArray(res.getString(R.string.symbols_followed_by_space));
  Arrays.sort(mSymbolsFollowedBySpace);
  mWordConnectors=StringUtils.toCodePointArray(res.getString(R.string.symbols_word_connectors));
  Arrays.sort(mWordConnectors);
  final String[] suggestPuncsSpec=KeySpecParser.splitKeySpecs(res.getString(R.string.suggested_punctuations));
  mSuggestPuncList=createSuggestPuncList(suggestPuncsSpec);
  mWordSeparators=res.getString(R.string.symbols_word_separators);
  mSentenceSeparator=res.getInteger(R.integer.sentence_separator);
  mSentenceSeparatorAndSpace=new String(new int[]{mSentenceSeparator,Constants.CODE_SPACE},0,2);
  mCurrentLanguageHasSpaces=res.getBoolean(R.bool.current_language_has_spaces);
  final Locale locale=res.getConfiguration().locale;
  mUsesAmericanTypography=Locale.ENGLISH.getLanguage().equals(locale.getLanguage());
  mUsesGermanRules=Locale.GERMAN.getLanguage().equals(locale.getLanguage());
}",0.9660643455266638
87446,"/** 
 * Determine what caps mode should be in effect at the current offset in the text. Only the mode bits set in <var>reqModes</var> will be checked. Note that the caps mode flags here are explicitly defined to match those in   {@link InputType}. This code is a straight copy of TextUtils.getCapsMode (modulo namespace and formatting issues). This will change in the future as we simplify the code for our use and fix bugs.
 * @param cs The text that should be checked for caps modes.
 * @param reqModes The modes to be checked: may be any combination of{@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 * @param spacingAndPunctuations The current spacing and punctuations settings.
 * @param hasSpaceBefore Whether we should consider there is a space inserted at the end of cs
 * @return Returns the actual capitalization modes that can be in effectat the current position, which is any combination of {@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 */
public static int getCapsMode(final CharSequence cs,final int reqModes,final SpacingAndPunctuations spacingAndPunctuations,final boolean hasSpaceBefore){
  if ((reqModes & (TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES)) == 0) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  int i;
  if (hasSpaceBefore) {
    i=cs.length() + 1;
  }
 else {
    for (i=cs.length(); i > 0; i--) {
      final char c=cs.charAt(i - 1);
      if (c != Constants.CODE_DOUBLE_QUOTE && c != Constants.CODE_SINGLE_QUOTE && Character.getType(c) != Character.START_PUNCTUATION) {
        break;
      }
    }
  }
  int j=i;
  char prevChar=Constants.CODE_SPACE;
  if (hasSpaceBefore)   --j;
  while (j > 0) {
    prevChar=cs.charAt(j - 1);
    if (!Character.isSpaceChar(prevChar) && prevChar != Constants.CODE_TAB)     break;
    j--;
  }
  if (j <= 0 || Character.isWhitespace(prevChar)) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (i == j) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  if ((reqModes & TextUtils.CAP_MODE_SENTENCES) == 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  if (spacingAndPunctuations.mUsesAmericanTypography) {
    for (; j > 0; j--) {
      final char c=cs.charAt(j - 1);
      if (c != Constants.CODE_DOUBLE_QUOTE && c != Constants.CODE_SINGLE_QUOTE && Character.getType(c) != Character.END_PUNCTUATION) {
        break;
      }
    }
  }
  if (j <= 0)   return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  char c=cs.charAt(--j);
  if (c == Constants.CODE_QUESTION_MARK || c == Constants.CODE_EXCLAMATION_MARK) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (!spacingAndPunctuations.isSentenceSeparator(c) || j <= 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  final int START=0;
  final int WORD=1;
  final int PERIOD=2;
  final int LETTER=3;
  final int caps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  final int noCaps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  int state=START;
  while (j > 0) {
    c=cs.charAt(--j);
switch (state) {
case START:
      if (Character.isLetter(c)) {
        state=WORD;
      }
 else       if (Character.isWhitespace(c)) {
        return noCaps;
      }
 else {
        return caps;
      }
    break;
case WORD:
  if (Character.isLetter(c)) {
    state=WORD;
  }
 else   if (spacingAndPunctuations.isSentenceSeparator(c)) {
    state=PERIOD;
  }
 else {
    return caps;
  }
break;
case PERIOD:
if (Character.isLetter(c)) {
state=LETTER;
}
 else {
return caps;
}
break;
case LETTER:
if (Character.isLetter(c)) {
state=LETTER;
}
 else if (spacingAndPunctuations.isSentenceSeparator(c)) {
state=PERIOD;
}
 else {
return noCaps;
}
}
}
return (START == state || LETTER == state) ? noCaps : caps;
}","/** 
 * Determine what caps mode should be in effect at the current offset in the text. Only the mode bits set in <var>reqModes</var> will be checked. Note that the caps mode flags here are explicitly defined to match those in   {@link InputType}. This code is a straight copy of TextUtils.getCapsMode (modulo namespace and formatting issues). This will change in the future as we simplify the code for our use and fix bugs.
 * @param cs The text that should be checked for caps modes.
 * @param reqModes The modes to be checked: may be any combination of{@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 * @param spacingAndPunctuations The current spacing and punctuations settings.
 * @param hasSpaceBefore Whether we should consider there is a space inserted at the end of cs
 * @return Returns the actual capitalization modes that can be in effectat the current position, which is any combination of {@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 */
public static int getCapsMode(final CharSequence cs,final int reqModes,final SpacingAndPunctuations spacingAndPunctuations,final boolean hasSpaceBefore){
  if ((reqModes & (TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES)) == 0) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  int i;
  if (hasSpaceBefore) {
    i=cs.length() + 1;
  }
 else {
    for (i=cs.length(); i > 0; i--) {
      final char c=cs.charAt(i - 1);
      if (c != Constants.CODE_DOUBLE_QUOTE && c != Constants.CODE_SINGLE_QUOTE && Character.getType(c) != Character.START_PUNCTUATION) {
        break;
      }
    }
  }
  int j=i;
  char prevChar=Constants.CODE_SPACE;
  if (hasSpaceBefore)   --j;
  while (j > 0) {
    prevChar=cs.charAt(j - 1);
    if (!Character.isSpaceChar(prevChar) && prevChar != Constants.CODE_TAB)     break;
    j--;
  }
  if (j <= 0 || Character.isWhitespace(prevChar)) {
    if (spacingAndPunctuations.mUsesGermanRules) {
      boolean hasNewLine=false;
      while (--j >= 0 && Character.isWhitespace(prevChar)) {
        if (Constants.CODE_ENTER == prevChar) {
          hasNewLine=true;
        }
        prevChar=cs.charAt(j);
      }
      if (Constants.CODE_COMMA == prevChar && hasNewLine) {
        return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
      }
    }
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (i == j) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  if ((reqModes & TextUtils.CAP_MODE_SENTENCES) == 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  if (spacingAndPunctuations.mUsesAmericanTypography) {
    for (; j > 0; j--) {
      final char c=cs.charAt(j - 1);
      if (c != Constants.CODE_DOUBLE_QUOTE && c != Constants.CODE_SINGLE_QUOTE && Character.getType(c) != Character.END_PUNCTUATION) {
        break;
      }
    }
  }
  if (j <= 0)   return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  char c=cs.charAt(--j);
  if (c == Constants.CODE_QUESTION_MARK || c == Constants.CODE_EXCLAMATION_MARK) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (!spacingAndPunctuations.isSentenceSeparator(c) || j <= 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  final int START=0;
  final int WORD=1;
  final int PERIOD=2;
  final int LETTER=3;
  final int caps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  final int noCaps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  int state=START;
  while (j > 0) {
    c=cs.charAt(--j);
switch (state) {
case START:
      if (Character.isLetter(c)) {
        state=WORD;
      }
 else       if (Character.isWhitespace(c)) {
        return noCaps;
      }
 else {
        return caps;
      }
    break;
case WORD:
  if (Character.isLetter(c)) {
    state=WORD;
  }
 else   if (spacingAndPunctuations.isSentenceSeparator(c)) {
    state=PERIOD;
  }
 else {
    return caps;
  }
break;
case PERIOD:
if (Character.isLetter(c)) {
state=LETTER;
}
 else {
return caps;
}
break;
case LETTER:
if (Character.isLetter(c)) {
state=LETTER;
}
 else if (spacingAndPunctuations.isSentenceSeparator(c)) {
state=PERIOD;
}
 else {
return noCaps;
}
}
}
return (START == state || LETTER == state) ? noCaps : caps;
}",0.9501281752505244
87447,"public void testGetCapsMode(){
  final int c=TextUtils.CAP_MODE_CHARACTERS;
  final int w=TextUtils.CAP_MODE_WORDS;
  final int s=TextUtils.CAP_MODE_SENTENCES;
  final RunInLocale<SpacingAndPunctuations> job=new RunInLocale<SpacingAndPunctuations>(){
    @Override protected SpacingAndPunctuations job(    final Resources res){
      return new SpacingAndPunctuations(res);
    }
  }
;
  final Resources res=getContext().getResources();
  SpacingAndPunctuations sp=job.runInLocale(res,Locale.ENGLISH);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c,sp,false);
  allPathsForCaps(""String_Node_Str"",c,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  sp=job.runInLocale(res,Locale.FRENCH);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
}","public void testGetCapsMode(){
  final int c=TextUtils.CAP_MODE_CHARACTERS;
  final int w=TextUtils.CAP_MODE_WORDS;
  final int s=TextUtils.CAP_MODE_SENTENCES;
  final RunInLocale<SpacingAndPunctuations> job=new RunInLocale<SpacingAndPunctuations>(){
    @Override protected SpacingAndPunctuations job(    final Resources res){
      return new SpacingAndPunctuations(res);
    }
  }
;
  final Resources res=getContext().getResources();
  SpacingAndPunctuations sp=job.runInLocale(res,Locale.ENGLISH);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c,sp,false);
  allPathsForCaps(""String_Node_Str"",c,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  sp=job.runInLocale(res,Locale.FRENCH);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  sp=job.runInLocale(res,Locale.GERMAN);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  sp=job.runInLocale(res,Locale.ENGLISH);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
}",0.8665134739920618
87448,"public SpacingAndPunctuations(final Resources res){
  mSymbolsPrecededBySpace=StringUtils.toCodePointArray(res.getString(R.string.symbols_preceded_by_space));
  Arrays.sort(mSymbolsPrecededBySpace);
  mSymbolsFollowedBySpace=StringUtils.toCodePointArray(res.getString(R.string.symbols_followed_by_space));
  Arrays.sort(mSymbolsFollowedBySpace);
  mWordConnectors=StringUtils.toCodePointArray(res.getString(R.string.symbols_word_connectors));
  Arrays.sort(mWordConnectors);
  final String[] suggestPuncsSpec=KeySpecParser.splitKeySpecs(res.getString(R.string.suggested_punctuations));
  mSuggestPuncList=createSuggestPuncList(suggestPuncsSpec);
  mWordSeparators=res.getString(R.string.symbols_word_separators);
  mSentenceSeparator=res.getInteger(R.integer.sentence_separator);
  mSentenceSeparatorAndSpace=new String(new int[]{mSentenceSeparator,Constants.CODE_SPACE},0,2);
  mCurrentLanguageHasSpaces=res.getBoolean(R.bool.current_language_has_spaces);
  final Locale locale=res.getConfiguration().locale;
  mUsesAmericanTypography=Locale.ENGLISH.getLanguage().equals(locale.getLanguage());
}","public SpacingAndPunctuations(final Resources res){
  mSymbolsPrecededBySpace=StringUtils.toCodePointArray(res.getString(R.string.symbols_preceded_by_space));
  Arrays.sort(mSymbolsPrecededBySpace);
  mSymbolsFollowedBySpace=StringUtils.toCodePointArray(res.getString(R.string.symbols_followed_by_space));
  Arrays.sort(mSymbolsFollowedBySpace);
  mWordConnectors=StringUtils.toCodePointArray(res.getString(R.string.symbols_word_connectors));
  Arrays.sort(mWordConnectors);
  final String[] suggestPuncsSpec=KeySpecParser.splitKeySpecs(res.getString(R.string.suggested_punctuations));
  mSuggestPuncList=createSuggestPuncList(suggestPuncsSpec);
  mWordSeparators=res.getString(R.string.symbols_word_separators);
  mSentenceSeparator=res.getInteger(R.integer.sentence_separator);
  mSentenceSeparatorAndSpace=new String(new int[]{mSentenceSeparator,Constants.CODE_SPACE},0,2);
  mCurrentLanguageHasSpaces=res.getBoolean(R.bool.current_language_has_spaces);
  final Locale locale=res.getConfiguration().locale;
  mUsesAmericanTypography=Locale.ENGLISH.getLanguage().equals(locale.getLanguage());
  mUsesGermanRules=Locale.GERMAN.getLanguage().equals(locale.getLanguage());
}",0.9660643455266638
87449,"/** 
 * Determine what caps mode should be in effect at the current offset in the text. Only the mode bits set in <var>reqModes</var> will be checked. Note that the caps mode flags here are explicitly defined to match those in   {@link InputType}. This code is a straight copy of TextUtils.getCapsMode (modulo namespace and formatting issues). This will change in the future as we simplify the code for our use and fix bugs.
 * @param cs The text that should be checked for caps modes.
 * @param reqModes The modes to be checked: may be any combination of{@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 * @param spacingAndPunctuations The current spacing and punctuations settings.
 * @param hasSpaceBefore Whether we should consider there is a space inserted at the end of cs
 * @return Returns the actual capitalization modes that can be in effectat the current position, which is any combination of {@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 */
public static int getCapsMode(final CharSequence cs,final int reqModes,final SpacingAndPunctuations spacingAndPunctuations,final boolean hasSpaceBefore){
  if ((reqModes & (TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES)) == 0) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  int i;
  if (hasSpaceBefore) {
    i=cs.length() + 1;
  }
 else {
    for (i=cs.length(); i > 0; i--) {
      final char c=cs.charAt(i - 1);
      if (c != Constants.CODE_DOUBLE_QUOTE && c != Constants.CODE_SINGLE_QUOTE && Character.getType(c) != Character.START_PUNCTUATION) {
        break;
      }
    }
  }
  int j=i;
  char prevChar=Constants.CODE_SPACE;
  if (hasSpaceBefore)   --j;
  while (j > 0) {
    prevChar=cs.charAt(j - 1);
    if (!Character.isSpaceChar(prevChar) && prevChar != Constants.CODE_TAB)     break;
    j--;
  }
  if (j <= 0 || Character.isWhitespace(prevChar)) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (i == j) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  if ((reqModes & TextUtils.CAP_MODE_SENTENCES) == 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  if (spacingAndPunctuations.mUsesAmericanTypography) {
    for (; j > 0; j--) {
      final char c=cs.charAt(j - 1);
      if (c != Constants.CODE_DOUBLE_QUOTE && c != Constants.CODE_SINGLE_QUOTE && Character.getType(c) != Character.END_PUNCTUATION) {
        break;
      }
    }
  }
  if (j <= 0)   return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  char c=cs.charAt(--j);
  if (c == Constants.CODE_QUESTION_MARK || c == Constants.CODE_EXCLAMATION_MARK) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (!spacingAndPunctuations.isSentenceSeparator(c) || j <= 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  final int START=0;
  final int WORD=1;
  final int PERIOD=2;
  final int LETTER=3;
  final int caps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  final int noCaps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  int state=START;
  while (j > 0) {
    c=cs.charAt(--j);
switch (state) {
case START:
      if (Character.isLetter(c)) {
        state=WORD;
      }
 else       if (Character.isWhitespace(c)) {
        return noCaps;
      }
 else {
        return caps;
      }
    break;
case WORD:
  if (Character.isLetter(c)) {
    state=WORD;
  }
 else   if (spacingAndPunctuations.isSentenceSeparator(c)) {
    state=PERIOD;
  }
 else {
    return caps;
  }
break;
case PERIOD:
if (Character.isLetter(c)) {
state=LETTER;
}
 else {
return caps;
}
break;
case LETTER:
if (Character.isLetter(c)) {
state=LETTER;
}
 else if (spacingAndPunctuations.isSentenceSeparator(c)) {
state=PERIOD;
}
 else {
return noCaps;
}
}
}
return (START == state || LETTER == state) ? noCaps : caps;
}","/** 
 * Determine what caps mode should be in effect at the current offset in the text. Only the mode bits set in <var>reqModes</var> will be checked. Note that the caps mode flags here are explicitly defined to match those in   {@link InputType}. This code is a straight copy of TextUtils.getCapsMode (modulo namespace and formatting issues). This will change in the future as we simplify the code for our use and fix bugs.
 * @param cs The text that should be checked for caps modes.
 * @param reqModes The modes to be checked: may be any combination of{@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 * @param spacingAndPunctuations The current spacing and punctuations settings.
 * @param hasSpaceBefore Whether we should consider there is a space inserted at the end of cs
 * @return Returns the actual capitalization modes that can be in effectat the current position, which is any combination of {@link TextUtils#CAP_MODE_CHARACTERS},   {@link TextUtils#CAP_MODE_WORDS}, and  {@link TextUtils#CAP_MODE_SENTENCES}.
 */
public static int getCapsMode(final CharSequence cs,final int reqModes,final SpacingAndPunctuations spacingAndPunctuations,final boolean hasSpaceBefore){
  if ((reqModes & (TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES)) == 0) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  int i;
  if (hasSpaceBefore) {
    i=cs.length() + 1;
  }
 else {
    for (i=cs.length(); i > 0; i--) {
      final char c=cs.charAt(i - 1);
      if (c != Constants.CODE_DOUBLE_QUOTE && c != Constants.CODE_SINGLE_QUOTE && Character.getType(c) != Character.START_PUNCTUATION) {
        break;
      }
    }
  }
  int j=i;
  char prevChar=Constants.CODE_SPACE;
  if (hasSpaceBefore)   --j;
  while (j > 0) {
    prevChar=cs.charAt(j - 1);
    if (!Character.isSpaceChar(prevChar) && prevChar != Constants.CODE_TAB)     break;
    j--;
  }
  if (j <= 0 || Character.isWhitespace(prevChar)) {
    if (spacingAndPunctuations.mUsesGermanRules) {
      boolean hasNewLine=false;
      while (--j >= 0 && Character.isWhitespace(prevChar)) {
        if (Constants.CODE_ENTER == prevChar) {
          hasNewLine=true;
        }
        prevChar=cs.charAt(j);
      }
      if (Constants.CODE_COMMA == prevChar && hasNewLine) {
        return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
      }
    }
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (i == j) {
    return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  }
  if ((reqModes & TextUtils.CAP_MODE_SENTENCES) == 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  if (spacingAndPunctuations.mUsesAmericanTypography) {
    for (; j > 0; j--) {
      final char c=cs.charAt(j - 1);
      if (c != Constants.CODE_DOUBLE_QUOTE && c != Constants.CODE_SINGLE_QUOTE && Character.getType(c) != Character.END_PUNCTUATION) {
        break;
      }
    }
  }
  if (j <= 0)   return TextUtils.CAP_MODE_CHARACTERS & reqModes;
  char c=cs.charAt(--j);
  if (c == Constants.CODE_QUESTION_MARK || c == Constants.CODE_EXCLAMATION_MARK) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  }
  if (!spacingAndPunctuations.isSentenceSeparator(c) || j <= 0) {
    return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  }
  final int START=0;
  final int WORD=1;
  final int PERIOD=2;
  final int LETTER=3;
  final int caps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS | TextUtils.CAP_MODE_SENTENCES) & reqModes;
  final int noCaps=(TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & reqModes;
  int state=START;
  while (j > 0) {
    c=cs.charAt(--j);
switch (state) {
case START:
      if (Character.isLetter(c)) {
        state=WORD;
      }
 else       if (Character.isWhitespace(c)) {
        return noCaps;
      }
 else {
        return caps;
      }
    break;
case WORD:
  if (Character.isLetter(c)) {
    state=WORD;
  }
 else   if (spacingAndPunctuations.isSentenceSeparator(c)) {
    state=PERIOD;
  }
 else {
    return caps;
  }
break;
case PERIOD:
if (Character.isLetter(c)) {
state=LETTER;
}
 else {
return caps;
}
break;
case LETTER:
if (Character.isLetter(c)) {
state=LETTER;
}
 else if (spacingAndPunctuations.isSentenceSeparator(c)) {
state=PERIOD;
}
 else {
return noCaps;
}
}
}
return (START == state || LETTER == state) ? noCaps : caps;
}",0.9501281752505244
87450,"public void testGetCapsMode(){
  final int c=TextUtils.CAP_MODE_CHARACTERS;
  final int w=TextUtils.CAP_MODE_WORDS;
  final int s=TextUtils.CAP_MODE_SENTENCES;
  final RunInLocale<SpacingAndPunctuations> job=new RunInLocale<SpacingAndPunctuations>(){
    @Override protected SpacingAndPunctuations job(    final Resources res){
      return new SpacingAndPunctuations(res);
    }
  }
;
  final Resources res=getContext().getResources();
  SpacingAndPunctuations sp=job.runInLocale(res,Locale.ENGLISH);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c,sp,false);
  allPathsForCaps(""String_Node_Str"",c,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  sp=job.runInLocale(res,Locale.FRENCH);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
}","public void testGetCapsMode(){
  final int c=TextUtils.CAP_MODE_CHARACTERS;
  final int w=TextUtils.CAP_MODE_WORDS;
  final int s=TextUtils.CAP_MODE_SENTENCES;
  final RunInLocale<SpacingAndPunctuations> job=new RunInLocale<SpacingAndPunctuations>(){
    @Override protected SpacingAndPunctuations job(    final Resources res){
      return new SpacingAndPunctuations(res);
    }
  }
;
  final Resources res=getContext().getResources();
  SpacingAndPunctuations sp=job.runInLocale(res,Locale.ENGLISH);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c,sp,false);
  allPathsForCaps(""String_Node_Str"",c,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  sp=job.runInLocale(res,Locale.FRENCH);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  sp=job.runInLocale(res,Locale.GERMAN);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  sp=job.runInLocale(res,Locale.ENGLISH);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,true);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
  allPathsForCaps(""String_Node_Str"",c | w | s,sp,false);
}",0.8665134739920618
87451,"/** 
 * Add a new keystroke, with the pressed key's code point with the touch point coordinates.
 */
public void add(final int primaryCode,final int keyX,final int keyY){
  final int newIndex=size();
  if (mTransliterationMethod != null) {
    String c=new String(Character.toChars(primaryCode));
    int startPos=mTypedWord.length() > mTransliterationMethod.getMaxKeyLength() ? mTypedWord.length() - mTransliterationMethod.getMaxKeyLength() : 0;
    String input=mTypedWord.substring(startPos) + c;
    String replacement=mTransliterationMethod.transliterate(input,context,false);
    int divIndex=firstDivergence(input,replacement);
    replacement=replacement.substring(divIndex);
    mTypedWord.replace(startPos + divIndex,startPos + divIndex + replacement.length()+ 1,replacement);
    context+=c;
    if (context.length() > mTransliterationMethod.getContextLength()) {
      context=context.substring(context.length() - mTransliterationMethod.getContextLength());
    }
  }
 else {
    mTypedWord.appendCodePoint(primaryCode);
  }
  refreshSize();
  mCursorPositionWithinWord=mCodePointSize;
  if (newIndex < MAX_WORD_LENGTH) {
    mPrimaryKeyCodes[newIndex]=primaryCode >= Constants.CODE_SPACE ? Character.toLowerCase(primaryCode) : primaryCode;
    if (!mIsBatchMode) {
      mInputPointers.addPointer(newIndex,keyX,keyY,0,0);
    }
  }
  mIsFirstCharCapitalized=isFirstCharCapitalized(newIndex,primaryCode,mIsFirstCharCapitalized);
  if (Character.isUpperCase(primaryCode))   mCapsCount++;
  if (Character.isDigit(primaryCode))   mDigitsCount++;
  if (Constants.CODE_SINGLE_QUOTE == primaryCode) {
    ++mTrailingSingleQuotesCount;
  }
 else {
    mTrailingSingleQuotesCount=0;
  }
  mAutoCorrection=null;
}","/** 
 * Add a new keystroke, with the pressed key's code point with the touch point coordinates.
 */
public void add(final int primaryCode,final int keyX,final int keyY){
  final int newIndex=size();
  if (mTransliterationMethod != null) {
    String c=new String(Character.toChars(primaryCode));
    int startPos=mTypedWord.length() > mTransliterationMethod.getMaxKeyLength() ? mTypedWord.length() - mTransliterationMethod.getMaxKeyLength() : 0;
    String input=mTypedWord.substring(startPos) + c;
    String replacement=mTransliterationMethod.transliterate(input,context,false);
    int divIndex=firstDivergence(input,replacement);
    replacement=replacement.substring(divIndex);
    mTypedWord.replace(startPos + divIndex,startPos + divIndex + replacement.length()+ 2,replacement);
    context+=c;
    if (context.length() > mTransliterationMethod.getContextLength()) {
      context=context.substring(context.length() - mTransliterationMethod.getContextLength());
    }
  }
 else {
    mTypedWord.appendCodePoint(primaryCode);
  }
  refreshSize();
  mCursorPositionWithinWord=mCodePointSize;
  if (newIndex < MAX_WORD_LENGTH) {
    mPrimaryKeyCodes[newIndex]=primaryCode >= Constants.CODE_SPACE ? Character.toLowerCase(primaryCode) : primaryCode;
    if (!mIsBatchMode) {
      mInputPointers.addPointer(newIndex,keyX,keyY,0,0);
    }
  }
  mIsFirstCharCapitalized=isFirstCharCapitalized(newIndex,primaryCode,mIsFirstCharCapitalized);
  if (Character.isUpperCase(primaryCode))   mCapsCount++;
  if (Character.isDigit(primaryCode))   mDigitsCount++;
  if (Constants.CODE_SINGLE_QUOTE == primaryCode) {
    ++mTrailingSingleQuotesCount;
  }
 else {
    mTrailingSingleQuotesCount=0;
  }
  mAutoCorrection=null;
}",0.9994172494172494
87452,"/** 
 * Attaches a keyboard to this view. The keyboard can be switched at any time and the view will re-layout itself to accommodate the keyboard.
 * @see Keyboard
 * @see #getKeyboard()
 * @param keyboard the keyboard to display in this view
 */
@Override public void setKeyboard(final Keyboard keyboard){
  mKeyTimerHandler.cancelAllKeyTimers();
  super.setKeyboard(keyboard);
  mKeyDetector.setKeyboard(keyboard,-getPaddingLeft(),-getPaddingTop() + getVerticalCorrection());
  PointerTracker.setKeyDetector(mKeyDetector);
  mMoreKeysKeyboardCache.clear();
  mSpaceKey=keyboard.getKey(Constants.CODE_SPACE);
  mSpacebarIcon=(mSpaceKey != null) ? mSpaceKey.getIcon(keyboard.mIconsSet,Constants.Color.ALPHA_OPAQUE) : null;
  final int keyHeight=keyboard.mMostCommonKeyHeight - keyboard.mVerticalGap;
  mLanguageOnSpacebarTextSize=keyHeight * mLanguageOnSpacebarTextRatio;
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final int orientation=getContext().getResources().getConfiguration().orientation;
    ResearchLogger.mainKeyboardView_setKeyboard(keyboard,orientation);
  }
  AccessibleKeyboardViewProxy.getInstance().setKeyboard();
}","/** 
 * Attaches a keyboard to this view. The keyboard can be switched at any time and the view will re-layout itself to accommodate the keyboard.
 * @see Keyboard
 * @see #getKeyboard()
 * @param keyboard the keyboard to display in this view
 */
@Override public void setKeyboard(final Keyboard keyboard){
  mKeyTimerHandler.cancelLongPressTimers();
  super.setKeyboard(keyboard);
  mKeyDetector.setKeyboard(keyboard,-getPaddingLeft(),-getPaddingTop() + getVerticalCorrection());
  PointerTracker.setKeyDetector(mKeyDetector);
  mMoreKeysKeyboardCache.clear();
  mSpaceKey=keyboard.getKey(Constants.CODE_SPACE);
  mSpacebarIcon=(mSpaceKey != null) ? mSpaceKey.getIcon(keyboard.mIconsSet,Constants.Color.ALPHA_OPAQUE) : null;
  final int keyHeight=keyboard.mMostCommonKeyHeight - keyboard.mVerticalGap;
  mLanguageOnSpacebarTextSize=keyHeight * mLanguageOnSpacebarTextRatio;
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final int orientation=getContext().getResources().getConfiguration().orientation;
    ResearchLogger.mainKeyboardView_setKeyboard(keyboard,orientation);
  }
  AccessibleKeyboardViewProxy.getInstance().setKeyboard();
}",0.9934924078091106
87453,"private void cancelLongPressTimers(){
  removeMessages(MSG_LONGPRESS_KEY);
  removeMessages(MSG_LONGPRESS_SHIFT_KEY);
}","public void cancelLongPressTimers(){
  removeMessages(MSG_LONGPRESS_KEY);
  removeMessages(MSG_LONGPRESS_SHIFT_KEY);
}",0.9620253164556962
87454,"/** 
 * Attaches a keyboard to this view. The keyboard can be switched at any time and the view will re-layout itself to accommodate the keyboard.
 * @see Keyboard
 * @see #getKeyboard()
 * @param keyboard the keyboard to display in this view
 */
@Override public void setKeyboard(final Keyboard keyboard){
  mKeyTimerHandler.cancelAllKeyTimers();
  super.setKeyboard(keyboard);
  mKeyDetector.setKeyboard(keyboard,-getPaddingLeft(),-getPaddingTop() + getVerticalCorrection());
  PointerTracker.setKeyDetector(mKeyDetector);
  mMoreKeysKeyboardCache.clear();
  mSpaceKey=keyboard.getKey(Constants.CODE_SPACE);
  mSpacebarIcon=(mSpaceKey != null) ? mSpaceKey.getIcon(keyboard.mIconsSet,Constants.Color.ALPHA_OPAQUE) : null;
  final int keyHeight=keyboard.mMostCommonKeyHeight - keyboard.mVerticalGap;
  mLanguageOnSpacebarTextSize=keyHeight * mLanguageOnSpacebarTextRatio;
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final int orientation=getContext().getResources().getConfiguration().orientation;
    ResearchLogger.mainKeyboardView_setKeyboard(keyboard,orientation);
  }
  AccessibleKeyboardViewProxy.getInstance().setKeyboard();
}","/** 
 * Attaches a keyboard to this view. The keyboard can be switched at any time and the view will re-layout itself to accommodate the keyboard.
 * @see Keyboard
 * @see #getKeyboard()
 * @param keyboard the keyboard to display in this view
 */
@Override public void setKeyboard(final Keyboard keyboard){
  mKeyTimerHandler.cancelLongPressTimers();
  super.setKeyboard(keyboard);
  mKeyDetector.setKeyboard(keyboard,-getPaddingLeft(),-getPaddingTop() + getVerticalCorrection());
  PointerTracker.setKeyDetector(mKeyDetector);
  mMoreKeysKeyboardCache.clear();
  mSpaceKey=keyboard.getKey(Constants.CODE_SPACE);
  mSpacebarIcon=(mSpaceKey != null) ? mSpaceKey.getIcon(keyboard.mIconsSet,Constants.Color.ALPHA_OPAQUE) : null;
  final int keyHeight=keyboard.mMostCommonKeyHeight - keyboard.mVerticalGap;
  mLanguageOnSpacebarTextSize=keyHeight * mLanguageOnSpacebarTextRatio;
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final int orientation=getContext().getResources().getConfiguration().orientation;
    ResearchLogger.mainKeyboardView_setKeyboard(keyboard,orientation);
  }
  AccessibleKeyboardViewProxy.getInstance().setKeyboard();
}",0.9934924078091106
87455,"private void cancelLongPressTimers(){
  removeMessages(MSG_LONGPRESS_KEY);
  removeMessages(MSG_LONGPRESS_SHIFT_KEY);
}","public void cancelLongPressTimers(){
  removeMessages(MSG_LONGPRESS_KEY);
  removeMessages(MSG_LONGPRESS_SHIFT_KEY);
}",0.9620253164556962
87456,"public LastComposedWord commitWord(final int type,final String committedWord,final String separatorString,final String prevWord){
  final int[] primaryKeyCodes=mPrimaryKeyCodes;
  mPrimaryKeyCodes=new int[MAX_WORD_LENGTH];
  final LastComposedWord lastComposedWord=new LastComposedWord(primaryKeyCodes,mInputPointers,mTypedWord.toString(),committedWord,separatorString,prevWord,mCapitalizedMode);
  mInputPointers.reset();
  if (type != LastComposedWord.COMMIT_TYPE_DECIDED_WORD && type != LastComposedWord.COMMIT_TYPE_MANUAL_PICK) {
    lastComposedWord.deactivate();
  }
  mCapsCount=0;
  mDigitsCount=0;
  mIsBatchMode=false;
  mPreviousWordForSuggestion=mTypedWord.toString();
  mTypedWord.setLength(0);
  mCodePointSize=0;
  mTrailingSingleQuotesCount=0;
  mIsFirstCharCapitalized=false;
  mCapitalizedMode=CAPS_MODE_OFF;
  refreshSize();
  mAutoCorrection=null;
  mCursorPositionWithinWord=0;
  mIsResumed=false;
  mRejectedBatchModeSuggestion=null;
  return lastComposedWord;
}","public LastComposedWord commitWord(final int type,final String committedWord,final String separatorString,final String prevWord){
  final int[] primaryKeyCodes=mPrimaryKeyCodes;
  mPrimaryKeyCodes=new int[MAX_WORD_LENGTH];
  final LastComposedWord lastComposedWord=new LastComposedWord(primaryKeyCodes,mInputPointers,mTypedWord.toString(),committedWord,separatorString,prevWord,mCapitalizedMode);
  mInputPointers.reset();
  if (type != LastComposedWord.COMMIT_TYPE_DECIDED_WORD && type != LastComposedWord.COMMIT_TYPE_MANUAL_PICK) {
    lastComposedWord.deactivate();
  }
  mCapsCount=0;
  mDigitsCount=0;
  mIsBatchMode=false;
  mPreviousWordForSuggestion=committedWord;
  mTypedWord.setLength(0);
  mCodePointSize=0;
  mTrailingSingleQuotesCount=0;
  mIsFirstCharCapitalized=false;
  mCapitalizedMode=CAPS_MODE_OFF;
  refreshSize();
  mAutoCorrection=null;
  mCursorPositionWithinWord=0;
  mIsResumed=false;
  mRejectedBatchModeSuggestion=null;
  return lastComposedWord;
}",0.9826530612244898
87457,"/** 
 * Commits the chosen word to the text field and saves it for later retrieval.
 * @param settingsValues the current values of the settings.
 * @param chosenWord the word we want to commit.
 * @param commitType the type of the commit, as one of LastComposedWord.COMMIT_TYPE_
 * @param separatorString the separator that's causing the commit, or NOT_A_SEPARATOR if none.
 */
public void commitChosenWord(final SettingsValues settingsValues,final String chosenWord,final int commitType,final String separatorString){
  final SuggestedWords suggestedWords=mSuggestedWords;
  mConnection.commitText(SuggestionSpanUtils.getTextWithSuggestionSpan(mLatinIME,chosenWord,suggestedWords),1);
  final String prevWord=mConnection.getNthPreviousWord(settingsValues,2);
  performAdditionToUserHistoryDictionary(settingsValues,chosenWord,prevWord);
  mLastComposedWord=mWordComposer.commitWord(commitType,chosenWord,separatorString,prevWord);
  final boolean shouldDiscardPreviousWordForSuggestion;
  if (0 == StringUtils.codePointCount(separatorString)) {
    shouldDiscardPreviousWordForSuggestion=settingsValues.mCurrentLanguageHasSpaces;
  }
 else {
    shouldDiscardPreviousWordForSuggestion=!StringUtils.containsOnlyWhitespace(separatorString);
  }
  if (shouldDiscardPreviousWordForSuggestion) {
    mWordComposer.discardPreviousWordForSuggestion();
  }
}","/** 
 * Commits the chosen word to the text field and saves it for later retrieval.
 * @param settingsValues the current values of the settings.
 * @param chosenWord the word we want to commit.
 * @param commitType the type of the commit, as one of LastComposedWord.COMMIT_TYPE_
 * @param separatorString the separator that's causing the commit, or NOT_A_SEPARATOR if none.
 */
public void commitChosenWord(final SettingsValues settingsValues,final String chosenWord,final int commitType,final String separatorString){
  final SuggestedWords suggestedWords=mSuggestedWords;
  mConnection.commitText(SuggestionSpanUtils.getTextWithSuggestionSpan(mLatinIME,chosenWord,suggestedWords),1);
  final String prevWord=mConnection.getNthPreviousWord(settingsValues,2);
  performAdditionToUserHistoryDictionary(settingsValues,chosenWord,prevWord);
  mLastComposedWord=mWordComposer.commitWord(commitType,chosenWord,separatorString,prevWord);
  final boolean shouldDiscardPreviousWordForSuggestion;
  if (0 == StringUtils.codePointCount(separatorString)) {
    shouldDiscardPreviousWordForSuggestion=false;
  }
 else {
    shouldDiscardPreviousWordForSuggestion=!StringUtils.containsOnlyWhitespace(separatorString);
  }
  if (shouldDiscardPreviousWordForSuggestion) {
    mWordComposer.discardPreviousWordForSuggestion();
  }
}",0.983127109111361
87458,"private boolean maybeDoubleSpacePeriod(){
  final SettingsValues currentSettingsValues=mSettings.getCurrent();
  if (!currentSettingsValues.mUseDoubleSpacePeriod)   return false;
  if (!mHandler.isAcceptingDoubleSpacePeriod())   return false;
  final CharSequence lastThree=mConnection.getTextBeforeCursor(4,0);
  if (null == lastThree)   return false;
  final int length=lastThree.length();
  if (length < 3)   return false;
  if (lastThree.charAt(length - 1) != Constants.CODE_SPACE)   return false;
  if (lastThree.charAt(length - 2) != Constants.CODE_SPACE)   return false;
  final int firstCodePoint=Character.isSurrogatePair(lastThree.charAt(0),lastThree.charAt(1)) ? Character.codePointAt(lastThree,0) : lastThree.charAt(length - 3);
  if (canBeFollowedByDoubleSpacePeriod(firstCodePoint)) {
    mHandler.cancelDoubleSpacePeriodTimer();
    mConnection.deleteSurroundingText(2,0);
    final String textToInsert=new String(new int[]{currentSettingsValues.mSentenceSeparator,Constants.CODE_SPACE},0,2);
    mConnection.commitText(textToInsert,1);
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.latinIME_maybeDoubleSpacePeriod(textToInsert,false);
    }
    mWordComposer.doubleSpacePeriod();
    mKeyboardSwitcher.updateShiftState();
    return true;
  }
  return false;
}","private boolean maybeDoubleSpacePeriod(){
  final SettingsValues currentSettingsValues=mSettings.getCurrent();
  if (!currentSettingsValues.mUseDoubleSpacePeriod)   return false;
  if (!mHandler.isAcceptingDoubleSpacePeriod())   return false;
  final CharSequence lastThree=mConnection.getTextBeforeCursor(4,0);
  if (null == lastThree)   return false;
  final int length=lastThree.length();
  if (length < 3)   return false;
  if (lastThree.charAt(length - 1) != Constants.CODE_SPACE)   return false;
  if (lastThree.charAt(length - 2) != Constants.CODE_SPACE)   return false;
  final int firstCodePoint=Character.isSurrogatePair(lastThree.charAt(0),lastThree.charAt(1)) ? Character.codePointAt(lastThree,0) : lastThree.charAt(length - 3);
  if (canBeFollowedByDoubleSpacePeriod(firstCodePoint)) {
    mHandler.cancelDoubleSpacePeriodTimer();
    mConnection.deleteSurroundingText(2,0);
    final String textToInsert=new String(new int[]{currentSettingsValues.mSentenceSeparator,Constants.CODE_SPACE},0,2);
    mConnection.commitText(textToInsert,1);
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.latinIME_maybeDoubleSpacePeriod(textToInsert,false);
    }
    mWordComposer.discardPreviousWordForSuggestion();
    mKeyboardSwitcher.updateShiftState();
    return true;
  }
  return false;
}",0.982176715965112
87459,"/** 
 * Commits the chosen word to the text field and saves it for later retrieval.
 */
private void commitChosenWord(final String chosenWord,final int commitType,final String separatorString){
  final SuggestedWords suggestedWords=mSuggestedWords;
  mConnection.commitText(SuggestionSpanUtils.getTextWithSuggestionSpan(this,chosenWord,suggestedWords,mIsMainDictionaryAvailable),1);
  final String prevWord=addToUserHistoryDictionary(chosenWord);
  mLastComposedWord=mWordComposer.commitWord(commitType,chosenWord,separatorString,prevWord);
}","/** 
 * Commits the chosen word to the text field and saves it for later retrieval.
 */
private void commitChosenWord(final String chosenWord,final int commitType,final String separatorString){
  final SuggestedWords suggestedWords=mSuggestedWords;
  mConnection.commitText(SuggestionSpanUtils.getTextWithSuggestionSpan(this,chosenWord,suggestedWords,mIsMainDictionaryAvailable),1);
  final String prevWord=addToUserHistoryDictionary(chosenWord);
  mLastComposedWord=mWordComposer.commitWord(commitType,chosenWord,separatorString,prevWord);
  final boolean shouldDiscardPreviousWordForSuggestion;
  if (0 == StringUtils.codePointCount(separatorString)) {
    shouldDiscardPreviousWordForSuggestion=mSettings.getCurrent().mCurrentLanguageHasSpaces;
  }
 else {
    shouldDiscardPreviousWordForSuggestion=!StringUtils.containsOnlyWhitespace(separatorString);
  }
  if (shouldDiscardPreviousWordForSuggestion) {
    mWordComposer.discardPreviousWordForSuggestion();
  }
}",0.7178807947019867
87460,"private void getSuggestedWords(final int sessionId,final int sequenceNumber,final OnGetSuggestedWordsCallback callback){
  final Keyboard keyboard=mKeyboardSwitcher.getKeyboard();
  final Suggest suggest=mSuggest;
  if (keyboard == null || suggest == null) {
    callback.onGetSuggestedWords(SuggestedWords.EMPTY);
    return;
  }
  final SettingsValues currentSettings=mSettings.getCurrent();
  final int[] additionalFeaturesOptions=currentSettings.mAdditionalFeaturesSettingValues;
  if (DEBUG) {
    if (mWordComposer.isComposingWord() || mWordComposer.isBatchMode()) {
      final String previousWord=mWordComposer.getPreviousWord();
      final String rereadPrevWord=getNthPreviousWordForSuggestion(currentSettings,mWordComposer.isComposingWord() ? 2 : 1);
      if (!TextUtils.equals(previousWord,rereadPrevWord)) {
        throw new RuntimeException(""String_Node_Str"" + previousWord + ""String_Node_Str""+ rereadPrevWord);
      }
    }
  }
  suggest.getSuggestedWords(mWordComposer,mWordComposer.getPreviousWord(),keyboard.getProximityInfo(),currentSettings.mBlockPotentiallyOffensive,currentSettings.mCorrectionEnabled,additionalFeaturesOptions,sessionId,sequenceNumber,callback);
}","private void getSuggestedWords(final int sessionId,final int sequenceNumber,final OnGetSuggestedWordsCallback callback){
  final Keyboard keyboard=mKeyboardSwitcher.getKeyboard();
  final Suggest suggest=mSuggest;
  if (keyboard == null || suggest == null) {
    callback.onGetSuggestedWords(SuggestedWords.EMPTY);
    return;
  }
  final SettingsValues currentSettings=mSettings.getCurrent();
  final int[] additionalFeaturesOptions=currentSettings.mAdditionalFeaturesSettingValues;
  if (DEBUG) {
    if (mWordComposer.isComposingWord() || mWordComposer.isBatchMode()) {
      final String previousWord=mWordComposer.getPreviousWordForSuggestion();
      final String rereadPrevWord=getNthPreviousWordForSuggestion(currentSettings,mWordComposer.isComposingWord() ? 2 : 1);
      if (!TextUtils.equals(previousWord,rereadPrevWord)) {
        throw new RuntimeException(""String_Node_Str"" + previousWord + ""String_Node_Str""+ rereadPrevWord);
      }
    }
  }
  suggest.getSuggestedWords(mWordComposer,mWordComposer.getPreviousWordForSuggestion(),keyboard.getProximityInfo(),currentSettings.mBlockPotentiallyOffensive,currentSettings.mCorrectionEnabled,additionalFeaturesOptions,sessionId,sequenceNumber,callback);
}",0.9891846921797004
87461,"/** 
 * Set the currently composing word to the one passed as an argument. This will register NOT_A_COORDINATE for X and Ys, and use the passed keyboard for proximity.
 * @param word the char sequence to set as the composing word.
 * @param previousWord the previous word, to use as context for suggestions. Can be null ifthe context is nil (typically, at start of text).
 * @param keyboard the keyboard this is typed on, for coordinate info/proximity.
 */
public void setComposingWord(final CharSequence word,final String previousWord,final Keyboard keyboard){
  reset();
  final int length=word.length();
  for (int i=0; i < length; i=Character.offsetByCodePoints(word,i,1)) {
    final int codePoint=Character.codePointAt(word,i);
    addKeyInfo(codePoint,keyboard);
  }
  mIsResumed=true;
  mPreviousWord=previousWord;
}","/** 
 * Set the currently composing word to the one passed as an argument. This will register NOT_A_COORDINATE for X and Ys, and use the passed keyboard for proximity.
 * @param word the char sequence to set as the composing word.
 * @param previousWord the previous word, to use as context for suggestions. Can be null ifthe context is nil (typically, at start of text).
 * @param keyboard the keyboard this is typed on, for coordinate info/proximity.
 */
public void setComposingWord(final CharSequence word,final String previousWord,final Keyboard keyboard){
  reset();
  final int length=word.length();
  for (int i=0; i < length; i=Character.offsetByCodePoints(word,i,1)) {
    final int codePoint=Character.codePointAt(word,i);
    addKeyInfo(codePoint,keyboard);
  }
  mIsResumed=true;
  mPreviousWordForSuggestion=previousWord;
}",0.9921733895243828
87462,"public LastComposedWord commitWord(final int type,final String committedWord,final String separatorString,final String prevWord){
  final int[] primaryKeyCodes=mPrimaryKeyCodes;
  mPrimaryKeyCodes=new int[MAX_WORD_LENGTH];
  final LastComposedWord lastComposedWord=new LastComposedWord(primaryKeyCodes,mInputPointers,mTypedWord.toString(),committedWord,separatorString,prevWord,mCapitalizedMode);
  mInputPointers.reset();
  if (type != LastComposedWord.COMMIT_TYPE_DECIDED_WORD && type != LastComposedWord.COMMIT_TYPE_MANUAL_PICK) {
    lastComposedWord.deactivate();
  }
  mCapsCount=0;
  mDigitsCount=0;
  mIsBatchMode=false;
  final boolean isWhitespace=1 == StringUtils.codePointCount(separatorString) && Character.isWhitespace(separatorString.codePointAt(0));
  mPreviousWord=isWhitespace ? mTypedWord.toString() : null;
  mTypedWord.setLength(0);
  mCodePointSize=0;
  mTrailingSingleQuotesCount=0;
  mIsFirstCharCapitalized=false;
  mCapitalizedMode=CAPS_MODE_OFF;
  refreshSize();
  mAutoCorrection=null;
  mCursorPositionWithinWord=0;
  mIsResumed=false;
  mRejectedBatchModeSuggestion=null;
  return lastComposedWord;
}","public LastComposedWord commitWord(final int type,final String committedWord,final String separatorString,final String prevWord){
  final int[] primaryKeyCodes=mPrimaryKeyCodes;
  mPrimaryKeyCodes=new int[MAX_WORD_LENGTH];
  final LastComposedWord lastComposedWord=new LastComposedWord(primaryKeyCodes,mInputPointers,mTypedWord.toString(),committedWord,separatorString,prevWord,mCapitalizedMode);
  mInputPointers.reset();
  if (type != LastComposedWord.COMMIT_TYPE_DECIDED_WORD && type != LastComposedWord.COMMIT_TYPE_MANUAL_PICK) {
    lastComposedWord.deactivate();
  }
  mCapsCount=0;
  mDigitsCount=0;
  mIsBatchMode=false;
  mPreviousWordForSuggestion=mTypedWord.toString();
  mTypedWord.setLength(0);
  mCodePointSize=0;
  mTrailingSingleQuotesCount=0;
  mIsFirstCharCapitalized=false;
  mCapitalizedMode=CAPS_MODE_OFF;
  refreshSize();
  mAutoCorrection=null;
  mCursorPositionWithinWord=0;
  mIsResumed=false;
  mRejectedBatchModeSuggestion=null;
  return lastComposedWord;
}",0.9176915799432356
87463,"/** 
 * Saves the caps mode and the previous word at the start of composing. WordComposer needs to know about the caps mode for several reasons. The first is, we need to know after the fact what the reason was, to register the correct form into the user history dictionary: if the word was automatically capitalized, we should insert it in all-lower case but if it's a manual pressing of shift, then it should be inserted as is. Also, batch input needs to know about the current caps mode to display correctly capitalized suggestions.
 * @param mode the mode at the time of start
 * @param previousWord the previous word as context for suggestions. May be null if none.
 */
public void setCapitalizedModeAndPreviousWordAtStartComposingTime(final int mode,final String previousWord){
  mCapitalizedMode=mode;
  mPreviousWord=previousWord;
}","/** 
 * Saves the caps mode and the previous word at the start of composing. WordComposer needs to know about the caps mode for several reasons. The first is, we need to know after the fact what the reason was, to register the correct form into the user history dictionary: if the word was automatically capitalized, we should insert it in all-lower case but if it's a manual pressing of shift, then it should be inserted as is. Also, batch input needs to know about the current caps mode to display correctly capitalized suggestions.
 * @param mode the mode at the time of start
 * @param previousWord the previous word as context for suggestions. May be null if none.
 */
public void setCapitalizedModeAndPreviousWordAtStartComposingTime(final int mode,final String previousWord){
  mCapitalizedMode=mode;
  mPreviousWordForSuggestion=previousWord;
}",0.9923122412773506
87464,"public void resumeSuggestionOnLastComposedWord(final LastComposedWord lastComposedWord,final String previousWord){
  mPrimaryKeyCodes=lastComposedWord.mPrimaryKeyCodes;
  mInputPointers.set(lastComposedWord.mInputPointers);
  mTypedWord.setLength(0);
  mTypedWord.append(lastComposedWord.mTypedWord);
  refreshSize();
  mCapitalizedMode=lastComposedWord.mCapitalizedMode;
  mAutoCorrection=null;
  mCursorPositionWithinWord=mCodePointSize;
  mRejectedBatchModeSuggestion=null;
  mIsResumed=true;
  mPreviousWord=previousWord;
}","public void resumeSuggestionOnLastComposedWord(final LastComposedWord lastComposedWord,final String previousWord){
  mPrimaryKeyCodes=lastComposedWord.mPrimaryKeyCodes;
  mInputPointers.set(lastComposedWord.mInputPointers);
  mTypedWord.setLength(0);
  mTypedWord.append(lastComposedWord.mTypedWord);
  refreshSize();
  mCapitalizedMode=lastComposedWord.mCapitalizedMode;
  mAutoCorrection=null;
  mCursorPositionWithinWord=mCodePointSize;
  mRejectedBatchModeSuggestion=null;
  mIsResumed=true;
  mPreviousWordForSuggestion=previousWord;
}",0.9878163074039362
87465,"public WordComposer(final WordComposer source){
  mPrimaryKeyCodes=Arrays.copyOf(source.mPrimaryKeyCodes,source.mPrimaryKeyCodes.length);
  mTypedWord=new StringBuilder(source.mTypedWord);
  mInputPointers.copy(source.mInputPointers);
  mCapsCount=source.mCapsCount;
  mDigitsCount=source.mDigitsCount;
  mIsFirstCharCapitalized=source.mIsFirstCharCapitalized;
  mCapitalizedMode=source.mCapitalizedMode;
  mTrailingSingleQuotesCount=source.mTrailingSingleQuotesCount;
  mIsResumed=source.mIsResumed;
  mIsBatchMode=source.mIsBatchMode;
  mCursorPositionWithinWord=source.mCursorPositionWithinWord;
  mRejectedBatchModeSuggestion=source.mRejectedBatchModeSuggestion;
  mPreviousWord=source.mPreviousWord;
  refreshSize();
}","public WordComposer(final WordComposer source){
  mPrimaryKeyCodes=Arrays.copyOf(source.mPrimaryKeyCodes,source.mPrimaryKeyCodes.length);
  mTypedWord=new StringBuilder(source.mTypedWord);
  mInputPointers.copy(source.mInputPointers);
  mCapsCount=source.mCapsCount;
  mDigitsCount=source.mDigitsCount;
  mIsFirstCharCapitalized=source.mIsFirstCharCapitalized;
  mCapitalizedMode=source.mCapitalizedMode;
  mTrailingSingleQuotesCount=source.mTrailingSingleQuotesCount;
  mIsResumed=source.mIsResumed;
  mIsBatchMode=source.mIsBatchMode;
  mCursorPositionWithinWord=source.mCursorPositionWithinWord;
  mRejectedBatchModeSuggestion=source.mRejectedBatchModeSuggestion;
  mPreviousWordForSuggestion=source.mPreviousWordForSuggestion;
  refreshSize();
}",0.9823369565217392
87466,"/** 
 * Clear out the keys registered so far.
 */
public void reset(){
  mTypedWord.setLength(0);
  mAutoCorrection=null;
  mCapsCount=0;
  mDigitsCount=0;
  mIsFirstCharCapitalized=false;
  mTrailingSingleQuotesCount=0;
  mIsResumed=false;
  mIsBatchMode=false;
  mCursorPositionWithinWord=0;
  mRejectedBatchModeSuggestion=null;
  mPreviousWord=null;
  refreshSize();
}","/** 
 * Clear out the keys registered so far.
 */
public void reset(){
  mTypedWord.setLength(0);
  mAutoCorrection=null;
  mCapsCount=0;
  mDigitsCount=0;
  mIsFirstCharCapitalized=false;
  mTrailingSingleQuotesCount=0;
  mIsResumed=false;
  mIsBatchMode=false;
  mCursorPositionWithinWord=0;
  mRejectedBatchModeSuggestion=null;
  mPreviousWordForSuggestion=null;
  refreshSize();
}",0.9827814569536424
87467,"public void testMoveCursor(){
  final WordComposer wc=new WordComposer();
  final String STR_WITHIN_BMP=""String_Node_Str"";
  final String PREVWORD=""String_Node_Str"";
  wc.setComposingWord(STR_WITHIN_BMP,PREVWORD,null);
  assertEquals(wc.size(),STR_WITHIN_BMP.codePointCount(0,STR_WITHIN_BMP.length()));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  wc.setCursorPositionWithinWord(2);
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(2));
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertEquals(wc.size(),6);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  assertEquals(PREVWORD,wc.getPreviousWord());
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(15));
  wc.reset();
  assertNull(wc.getPreviousWord());
  final String STR_WITH_SUPPLEMENTARY_CHAR=""String_Node_Str"";
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  assertEquals(wc.size(),STR_WITH_SUPPLEMENTARY_CHAR.codePointCount(0,STR_WITH_SUPPLEMENTARY_CHAR.length()));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(6));
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  assertNull(wc.getPreviousWord());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITHIN_BMP,null);
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(7));
  assertEquals(STR_WITHIN_BMP,wc.getPreviousWord());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITH_SUPPLEMENTARY_CHAR,null);
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(7));
  assertEquals(STR_WITH_SUPPLEMENTARY_CHAR,wc.getPreviousWord());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITHIN_BMP,null);
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(-3));
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(-1));
  assertEquals(STR_WITHIN_BMP,wc.getPreviousWord());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  wc.setCursorPositionWithinWord(3);
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(-9));
  assertNull(wc.getPreviousWord());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITH_SUPPLEMENTARY_CHAR,null);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(-10));
  assertEquals(STR_WITH_SUPPLEMENTARY_CHAR,wc.getPreviousWord());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(-11));
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(0));
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  wc.setCursorPositionWithinWord(2);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(0));
}","public void testMoveCursor(){
  final WordComposer wc=new WordComposer();
  final String STR_WITHIN_BMP=""String_Node_Str"";
  final String PREVWORD=""String_Node_Str"";
  wc.setComposingWord(STR_WITHIN_BMP,PREVWORD,null);
  assertEquals(wc.size(),STR_WITHIN_BMP.codePointCount(0,STR_WITHIN_BMP.length()));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  wc.setCursorPositionWithinWord(2);
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(2));
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertEquals(wc.size(),6);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  assertEquals(PREVWORD,wc.getPreviousWordForSuggestion());
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(15));
  wc.reset();
  assertNull(wc.getPreviousWordForSuggestion());
  final String STR_WITH_SUPPLEMENTARY_CHAR=""String_Node_Str"";
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  assertEquals(wc.size(),STR_WITH_SUPPLEMENTARY_CHAR.codePointCount(0,STR_WITH_SUPPLEMENTARY_CHAR.length()));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(6));
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  assertNull(wc.getPreviousWordForSuggestion());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITHIN_BMP,null);
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(7));
  assertEquals(STR_WITHIN_BMP,wc.getPreviousWordForSuggestion());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITH_SUPPLEMENTARY_CHAR,null);
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(7));
  assertEquals(STR_WITH_SUPPLEMENTARY_CHAR,wc.getPreviousWordForSuggestion());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITHIN_BMP,null);
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(-3));
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(-1));
  assertEquals(STR_WITHIN_BMP,wc.getPreviousWordForSuggestion());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  wc.setCursorPositionWithinWord(3);
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(-9));
  assertNull(wc.getPreviousWordForSuggestion());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITH_SUPPLEMENTARY_CHAR,null);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(-10));
  assertEquals(STR_WITH_SUPPLEMENTARY_CHAR,wc.getPreviousWordForSuggestion());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(-11));
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(0));
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  wc.setCursorPositionWithinWord(2);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(0));
}",0.9847103793002058
87468,"private boolean maybeDoubleSpacePeriod(){
  final SettingsValues currentSettingsValues=mSettings.getCurrent();
  if (!currentSettingsValues.mUseDoubleSpacePeriod)   return false;
  if (!mHandler.isAcceptingDoubleSpacePeriod())   return false;
  final CharSequence lastThree=mConnection.getTextBeforeCursor(4,0);
  if (null == lastThree)   return false;
  final int length=lastThree.length();
  if (length < 3)   return false;
  if (lastThree.charAt(length - 1) != Constants.CODE_SPACE)   return false;
  if (lastThree.charAt(length - 2) != Constants.CODE_SPACE)   return false;
  final int firstCodePoint=Character.isSurrogatePair(lastThree.charAt(0),lastThree.charAt(1)) ? Character.codePointAt(lastThree,0) : lastThree.charAt(length - 3);
  if (canBeFollowedByDoubleSpacePeriod(firstCodePoint)) {
    mHandler.cancelDoubleSpacePeriodTimer();
    mConnection.deleteSurroundingText(2,0);
    final String textToInsert=new String(new int[]{currentSettingsValues.mSentenceSeparator,Constants.CODE_SPACE},0,2);
    mConnection.commitText(textToInsert,1);
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.latinIME_maybeDoubleSpacePeriod(textToInsert,false);
    }
    mWordComposer.doubleSpacePeriod();
    mKeyboardSwitcher.updateShiftState();
    return true;
  }
  return false;
}","private boolean maybeDoubleSpacePeriod(){
  final SettingsValues currentSettingsValues=mSettings.getCurrent();
  if (!currentSettingsValues.mUseDoubleSpacePeriod)   return false;
  if (!mHandler.isAcceptingDoubleSpacePeriod())   return false;
  final CharSequence lastThree=mConnection.getTextBeforeCursor(4,0);
  if (null == lastThree)   return false;
  final int length=lastThree.length();
  if (length < 3)   return false;
  if (lastThree.charAt(length - 1) != Constants.CODE_SPACE)   return false;
  if (lastThree.charAt(length - 2) != Constants.CODE_SPACE)   return false;
  final int firstCodePoint=Character.isSurrogatePair(lastThree.charAt(0),lastThree.charAt(1)) ? Character.codePointAt(lastThree,0) : lastThree.charAt(length - 3);
  if (canBeFollowedByDoubleSpacePeriod(firstCodePoint)) {
    mHandler.cancelDoubleSpacePeriodTimer();
    mConnection.deleteSurroundingText(2,0);
    final String textToInsert=new String(new int[]{currentSettingsValues.mSentenceSeparator,Constants.CODE_SPACE},0,2);
    mConnection.commitText(textToInsert,1);
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.latinIME_maybeDoubleSpacePeriod(textToInsert,false);
    }
    mWordComposer.discardPreviousWordForSuggestion();
    mKeyboardSwitcher.updateShiftState();
    return true;
  }
  return false;
}",0.982176715965112
87469,"/** 
 * Commits the chosen word to the text field and saves it for later retrieval.
 */
private void commitChosenWord(final String chosenWord,final int commitType,final String separatorString){
  final SuggestedWords suggestedWords=mSuggestedWords;
  mConnection.commitText(SuggestionSpanUtils.getTextWithSuggestionSpan(this,chosenWord,suggestedWords,mIsMainDictionaryAvailable),1);
  final String prevWord=addToUserHistoryDictionary(chosenWord);
  mLastComposedWord=mWordComposer.commitWord(commitType,chosenWord,separatorString,prevWord);
}","/** 
 * Commits the chosen word to the text field and saves it for later retrieval.
 */
private void commitChosenWord(final String chosenWord,final int commitType,final String separatorString){
  final SuggestedWords suggestedWords=mSuggestedWords;
  mConnection.commitText(SuggestionSpanUtils.getTextWithSuggestionSpan(this,chosenWord,suggestedWords,mIsMainDictionaryAvailable),1);
  final String prevWord=addToUserHistoryDictionary(chosenWord);
  mLastComposedWord=mWordComposer.commitWord(commitType,chosenWord,separatorString,prevWord);
  final boolean shouldDiscardPreviousWordForSuggestion;
  if (0 == StringUtils.codePointCount(separatorString)) {
    shouldDiscardPreviousWordForSuggestion=mSettings.getCurrent().mCurrentLanguageHasSpaces;
  }
 else {
    shouldDiscardPreviousWordForSuggestion=!StringUtils.containsOnlyWhitespace(separatorString);
  }
  if (shouldDiscardPreviousWordForSuggestion) {
    mWordComposer.discardPreviousWordForSuggestion();
  }
}",0.7178807947019867
87470,"private void getSuggestedWords(final int sessionId,final int sequenceNumber,final OnGetSuggestedWordsCallback callback){
  final Keyboard keyboard=mKeyboardSwitcher.getKeyboard();
  final Suggest suggest=mSuggest;
  if (keyboard == null || suggest == null) {
    callback.onGetSuggestedWords(SuggestedWords.EMPTY);
    return;
  }
  final SettingsValues currentSettings=mSettings.getCurrent();
  final int[] additionalFeaturesOptions=currentSettings.mAdditionalFeaturesSettingValues;
  if (DEBUG) {
    if (mWordComposer.isComposingWord() || mWordComposer.isBatchMode()) {
      final String previousWord=mWordComposer.getPreviousWord();
      final String rereadPrevWord=getNthPreviousWordForSuggestion(currentSettings,mWordComposer.isComposingWord() ? 2 : 1);
      if (!TextUtils.equals(previousWord,rereadPrevWord)) {
        throw new RuntimeException(""String_Node_Str"" + previousWord + ""String_Node_Str""+ rereadPrevWord);
      }
    }
  }
  suggest.getSuggestedWords(mWordComposer,mWordComposer.getPreviousWord(),keyboard.getProximityInfo(),currentSettings.mBlockPotentiallyOffensive,currentSettings.mCorrectionEnabled,additionalFeaturesOptions,sessionId,sequenceNumber,callback);
}","private void getSuggestedWords(final int sessionId,final int sequenceNumber,final OnGetSuggestedWordsCallback callback){
  final Keyboard keyboard=mKeyboardSwitcher.getKeyboard();
  final Suggest suggest=mSuggest;
  if (keyboard == null || suggest == null) {
    callback.onGetSuggestedWords(SuggestedWords.EMPTY);
    return;
  }
  final SettingsValues currentSettings=mSettings.getCurrent();
  final int[] additionalFeaturesOptions=currentSettings.mAdditionalFeaturesSettingValues;
  if (DEBUG) {
    if (mWordComposer.isComposingWord() || mWordComposer.isBatchMode()) {
      final String previousWord=mWordComposer.getPreviousWordForSuggestion();
      final String rereadPrevWord=getNthPreviousWordForSuggestion(currentSettings,mWordComposer.isComposingWord() ? 2 : 1);
      if (!TextUtils.equals(previousWord,rereadPrevWord)) {
        throw new RuntimeException(""String_Node_Str"" + previousWord + ""String_Node_Str""+ rereadPrevWord);
      }
    }
  }
  suggest.getSuggestedWords(mWordComposer,mWordComposer.getPreviousWordForSuggestion(),keyboard.getProximityInfo(),currentSettings.mBlockPotentiallyOffensive,currentSettings.mCorrectionEnabled,additionalFeaturesOptions,sessionId,sequenceNumber,callback);
}",0.9891846921797004
87471,"/** 
 * Set the currently composing word to the one passed as an argument. This will register NOT_A_COORDINATE for X and Ys, and use the passed keyboard for proximity.
 * @param word the char sequence to set as the composing word.
 * @param previousWord the previous word, to use as context for suggestions. Can be null ifthe context is nil (typically, at start of text).
 * @param keyboard the keyboard this is typed on, for coordinate info/proximity.
 */
public void setComposingWord(final CharSequence word,final String previousWord,final Keyboard keyboard){
  reset();
  final int length=word.length();
  for (int i=0; i < length; i=Character.offsetByCodePoints(word,i,1)) {
    final int codePoint=Character.codePointAt(word,i);
    addKeyInfo(codePoint,keyboard);
  }
  mIsResumed=true;
  mPreviousWord=previousWord;
}","/** 
 * Set the currently composing word to the one passed as an argument. This will register NOT_A_COORDINATE for X and Ys, and use the passed keyboard for proximity.
 * @param word the char sequence to set as the composing word.
 * @param previousWord the previous word, to use as context for suggestions. Can be null ifthe context is nil (typically, at start of text).
 * @param keyboard the keyboard this is typed on, for coordinate info/proximity.
 */
public void setComposingWord(final CharSequence word,final String previousWord,final Keyboard keyboard){
  reset();
  final int length=word.length();
  for (int i=0; i < length; i=Character.offsetByCodePoints(word,i,1)) {
    final int codePoint=Character.codePointAt(word,i);
    addKeyInfo(codePoint,keyboard);
  }
  mIsResumed=true;
  mPreviousWordForSuggestion=previousWord;
}",0.9921733895243828
87472,"public LastComposedWord commitWord(final int type,final String committedWord,final String separatorString,final String prevWord){
  final int[] primaryKeyCodes=mPrimaryKeyCodes;
  mPrimaryKeyCodes=new int[MAX_WORD_LENGTH];
  final LastComposedWord lastComposedWord=new LastComposedWord(primaryKeyCodes,mInputPointers,mTypedWord.toString(),committedWord,separatorString,prevWord,mCapitalizedMode);
  mInputPointers.reset();
  if (type != LastComposedWord.COMMIT_TYPE_DECIDED_WORD && type != LastComposedWord.COMMIT_TYPE_MANUAL_PICK) {
    lastComposedWord.deactivate();
  }
  mCapsCount=0;
  mDigitsCount=0;
  mIsBatchMode=false;
  final boolean isWhitespace=1 == StringUtils.codePointCount(separatorString) && Character.isWhitespace(separatorString.codePointAt(0));
  mPreviousWord=isWhitespace ? mTypedWord.toString() : null;
  mTypedWord.setLength(0);
  mCodePointSize=0;
  mTrailingSingleQuotesCount=0;
  mIsFirstCharCapitalized=false;
  mCapitalizedMode=CAPS_MODE_OFF;
  refreshSize();
  mAutoCorrection=null;
  mCursorPositionWithinWord=0;
  mIsResumed=false;
  mRejectedBatchModeSuggestion=null;
  return lastComposedWord;
}","public LastComposedWord commitWord(final int type,final String committedWord,final String separatorString,final String prevWord){
  final int[] primaryKeyCodes=mPrimaryKeyCodes;
  mPrimaryKeyCodes=new int[MAX_WORD_LENGTH];
  final LastComposedWord lastComposedWord=new LastComposedWord(primaryKeyCodes,mInputPointers,mTypedWord.toString(),committedWord,separatorString,prevWord,mCapitalizedMode);
  mInputPointers.reset();
  if (type != LastComposedWord.COMMIT_TYPE_DECIDED_WORD && type != LastComposedWord.COMMIT_TYPE_MANUAL_PICK) {
    lastComposedWord.deactivate();
  }
  mCapsCount=0;
  mDigitsCount=0;
  mIsBatchMode=false;
  mPreviousWordForSuggestion=mTypedWord.toString();
  mTypedWord.setLength(0);
  mCodePointSize=0;
  mTrailingSingleQuotesCount=0;
  mIsFirstCharCapitalized=false;
  mCapitalizedMode=CAPS_MODE_OFF;
  refreshSize();
  mAutoCorrection=null;
  mCursorPositionWithinWord=0;
  mIsResumed=false;
  mRejectedBatchModeSuggestion=null;
  return lastComposedWord;
}",0.9176915799432356
87473,"/** 
 * Saves the caps mode and the previous word at the start of composing. WordComposer needs to know about the caps mode for several reasons. The first is, we need to know after the fact what the reason was, to register the correct form into the user history dictionary: if the word was automatically capitalized, we should insert it in all-lower case but if it's a manual pressing of shift, then it should be inserted as is. Also, batch input needs to know about the current caps mode to display correctly capitalized suggestions.
 * @param mode the mode at the time of start
 * @param previousWord the previous word as context for suggestions. May be null if none.
 */
public void setCapitalizedModeAndPreviousWordAtStartComposingTime(final int mode,final String previousWord){
  mCapitalizedMode=mode;
  mPreviousWord=previousWord;
}","/** 
 * Saves the caps mode and the previous word at the start of composing. WordComposer needs to know about the caps mode for several reasons. The first is, we need to know after the fact what the reason was, to register the correct form into the user history dictionary: if the word was automatically capitalized, we should insert it in all-lower case but if it's a manual pressing of shift, then it should be inserted as is. Also, batch input needs to know about the current caps mode to display correctly capitalized suggestions.
 * @param mode the mode at the time of start
 * @param previousWord the previous word as context for suggestions. May be null if none.
 */
public void setCapitalizedModeAndPreviousWordAtStartComposingTime(final int mode,final String previousWord){
  mCapitalizedMode=mode;
  mPreviousWordForSuggestion=previousWord;
}",0.9923122412773506
87474,"public void resumeSuggestionOnLastComposedWord(final LastComposedWord lastComposedWord,final String previousWord){
  mPrimaryKeyCodes=lastComposedWord.mPrimaryKeyCodes;
  mInputPointers.set(lastComposedWord.mInputPointers);
  mTypedWord.setLength(0);
  mTypedWord.append(lastComposedWord.mTypedWord);
  refreshSize();
  mCapitalizedMode=lastComposedWord.mCapitalizedMode;
  mAutoCorrection=null;
  mCursorPositionWithinWord=mCodePointSize;
  mRejectedBatchModeSuggestion=null;
  mIsResumed=true;
  mPreviousWord=previousWord;
}","public void resumeSuggestionOnLastComposedWord(final LastComposedWord lastComposedWord,final String previousWord){
  mPrimaryKeyCodes=lastComposedWord.mPrimaryKeyCodes;
  mInputPointers.set(lastComposedWord.mInputPointers);
  mTypedWord.setLength(0);
  mTypedWord.append(lastComposedWord.mTypedWord);
  refreshSize();
  mCapitalizedMode=lastComposedWord.mCapitalizedMode;
  mAutoCorrection=null;
  mCursorPositionWithinWord=mCodePointSize;
  mRejectedBatchModeSuggestion=null;
  mIsResumed=true;
  mPreviousWordForSuggestion=previousWord;
}",0.9878163074039362
87475,"public WordComposer(final WordComposer source){
  mPrimaryKeyCodes=Arrays.copyOf(source.mPrimaryKeyCodes,source.mPrimaryKeyCodes.length);
  mTypedWord=new StringBuilder(source.mTypedWord);
  mInputPointers.copy(source.mInputPointers);
  mCapsCount=source.mCapsCount;
  mDigitsCount=source.mDigitsCount;
  mIsFirstCharCapitalized=source.mIsFirstCharCapitalized;
  mCapitalizedMode=source.mCapitalizedMode;
  mTrailingSingleQuotesCount=source.mTrailingSingleQuotesCount;
  mIsResumed=source.mIsResumed;
  mIsBatchMode=source.mIsBatchMode;
  mCursorPositionWithinWord=source.mCursorPositionWithinWord;
  mRejectedBatchModeSuggestion=source.mRejectedBatchModeSuggestion;
  mPreviousWord=source.mPreviousWord;
  refreshSize();
}","public WordComposer(final WordComposer source){
  mPrimaryKeyCodes=Arrays.copyOf(source.mPrimaryKeyCodes,source.mPrimaryKeyCodes.length);
  mTypedWord=new StringBuilder(source.mTypedWord);
  mInputPointers.copy(source.mInputPointers);
  mCapsCount=source.mCapsCount;
  mDigitsCount=source.mDigitsCount;
  mIsFirstCharCapitalized=source.mIsFirstCharCapitalized;
  mCapitalizedMode=source.mCapitalizedMode;
  mTrailingSingleQuotesCount=source.mTrailingSingleQuotesCount;
  mIsResumed=source.mIsResumed;
  mIsBatchMode=source.mIsBatchMode;
  mCursorPositionWithinWord=source.mCursorPositionWithinWord;
  mRejectedBatchModeSuggestion=source.mRejectedBatchModeSuggestion;
  mPreviousWordForSuggestion=source.mPreviousWordForSuggestion;
  refreshSize();
}",0.9823369565217392
87476,"/** 
 * Clear out the keys registered so far.
 */
public void reset(){
  mTypedWord.setLength(0);
  mAutoCorrection=null;
  mCapsCount=0;
  mDigitsCount=0;
  mIsFirstCharCapitalized=false;
  mTrailingSingleQuotesCount=0;
  mIsResumed=false;
  mIsBatchMode=false;
  mCursorPositionWithinWord=0;
  mRejectedBatchModeSuggestion=null;
  mPreviousWord=null;
  refreshSize();
}","/** 
 * Clear out the keys registered so far.
 */
public void reset(){
  mTypedWord.setLength(0);
  mAutoCorrection=null;
  mCapsCount=0;
  mDigitsCount=0;
  mIsFirstCharCapitalized=false;
  mTrailingSingleQuotesCount=0;
  mIsResumed=false;
  mIsBatchMode=false;
  mCursorPositionWithinWord=0;
  mRejectedBatchModeSuggestion=null;
  mPreviousWordForSuggestion=null;
  refreshSize();
}",0.9827814569536424
87477,"public void testMoveCursor(){
  final WordComposer wc=new WordComposer();
  final String STR_WITHIN_BMP=""String_Node_Str"";
  final String PREVWORD=""String_Node_Str"";
  wc.setComposingWord(STR_WITHIN_BMP,PREVWORD,null);
  assertEquals(wc.size(),STR_WITHIN_BMP.codePointCount(0,STR_WITHIN_BMP.length()));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  wc.setCursorPositionWithinWord(2);
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(2));
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertEquals(wc.size(),6);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  assertEquals(PREVWORD,wc.getPreviousWord());
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(15));
  wc.reset();
  assertNull(wc.getPreviousWord());
  final String STR_WITH_SUPPLEMENTARY_CHAR=""String_Node_Str"";
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  assertEquals(wc.size(),STR_WITH_SUPPLEMENTARY_CHAR.codePointCount(0,STR_WITH_SUPPLEMENTARY_CHAR.length()));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(6));
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  assertNull(wc.getPreviousWord());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITHIN_BMP,null);
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(7));
  assertEquals(STR_WITHIN_BMP,wc.getPreviousWord());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITH_SUPPLEMENTARY_CHAR,null);
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(7));
  assertEquals(STR_WITH_SUPPLEMENTARY_CHAR,wc.getPreviousWord());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITHIN_BMP,null);
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(-3));
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(-1));
  assertEquals(STR_WITHIN_BMP,wc.getPreviousWord());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  wc.setCursorPositionWithinWord(3);
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(-9));
  assertNull(wc.getPreviousWord());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITH_SUPPLEMENTARY_CHAR,null);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(-10));
  assertEquals(STR_WITH_SUPPLEMENTARY_CHAR,wc.getPreviousWord());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(-11));
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(0));
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  wc.setCursorPositionWithinWord(2);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(0));
}","public void testMoveCursor(){
  final WordComposer wc=new WordComposer();
  final String STR_WITHIN_BMP=""String_Node_Str"";
  final String PREVWORD=""String_Node_Str"";
  wc.setComposingWord(STR_WITHIN_BMP,PREVWORD,null);
  assertEquals(wc.size(),STR_WITHIN_BMP.codePointCount(0,STR_WITHIN_BMP.length()));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  wc.setCursorPositionWithinWord(2);
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(2));
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertEquals(wc.size(),6);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  assertEquals(PREVWORD,wc.getPreviousWordForSuggestion());
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(15));
  wc.reset();
  assertNull(wc.getPreviousWordForSuggestion());
  final String STR_WITH_SUPPLEMENTARY_CHAR=""String_Node_Str"";
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  assertEquals(wc.size(),STR_WITH_SUPPLEMENTARY_CHAR.codePointCount(0,STR_WITH_SUPPLEMENTARY_CHAR.length()));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(6));
  assertTrue(wc.isCursorFrontOrMiddleOfComposingWord());
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(1));
  assertFalse(wc.isCursorFrontOrMiddleOfComposingWord());
  assertNull(wc.getPreviousWordForSuggestion());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITHIN_BMP,null);
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(7));
  assertEquals(STR_WITHIN_BMP,wc.getPreviousWordForSuggestion());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITH_SUPPLEMENTARY_CHAR,null);
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(7));
  assertEquals(STR_WITH_SUPPLEMENTARY_CHAR,wc.getPreviousWordForSuggestion());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITHIN_BMP,null);
  wc.setCursorPositionWithinWord(3);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(-3));
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(-1));
  assertEquals(STR_WITHIN_BMP,wc.getPreviousWordForSuggestion());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  wc.setCursorPositionWithinWord(3);
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(-9));
  assertNull(wc.getPreviousWordForSuggestion());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,STR_WITH_SUPPLEMENTARY_CHAR,null);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(-10));
  assertEquals(STR_WITH_SUPPLEMENTARY_CHAR,wc.getPreviousWordForSuggestion());
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  assertFalse(wc.moveCursorByAndReturnIfInsideComposingWord(-11));
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(0));
  wc.setComposingWord(STR_WITH_SUPPLEMENTARY_CHAR,null,null);
  wc.setCursorPositionWithinWord(2);
  assertTrue(wc.moveCursorByAndReturnIfInsideComposingWord(0));
}",0.9847103793002058
87478,"private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mPrevMainKeyboardWasShiftLocked=mAlphabetShiftState.isShiftLocked();
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchActions.setEmojiKeyboard();
}","private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mRecapitalizeMode=RecapitalizeStatus.NOT_A_RECAPITALIZE_MODE;
  mPrevMainKeyboardWasShiftLocked=mAlphabetShiftState.isShiftLocked();
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchActions.setEmojiKeyboard();
}",0.9015384615384616
87479,"private void setSymbolsKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mSwitchActions.setSymbolsKeyboard();
  mIsAlphabetMode=false;
  mIsSymbolShifted=false;
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchState=SWITCH_STATE_SYMBOL_BEGIN;
}","private void setSymbolsKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mSwitchActions.setSymbolsKeyboard();
  mIsAlphabetMode=false;
  mIsSymbolShifted=false;
  mRecapitalizeMode=RecapitalizeStatus.NOT_A_RECAPITALIZE_MODE;
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchState=SWITCH_STATE_SYMBOL_BEGIN;
}",0.8950819672131147
87480,"private void setSymbolsShiftedKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mSwitchActions.setSymbolsShiftedKeyboard();
  mIsAlphabetMode=false;
  mIsSymbolShifted=true;
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchState=SWITCH_STATE_SYMBOL_BEGIN;
}","private void setSymbolsShiftedKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mSwitchActions.setSymbolsShiftedKeyboard();
  mIsAlphabetMode=false;
  mIsSymbolShifted=true;
  mRecapitalizeMode=RecapitalizeStatus.NOT_A_RECAPITALIZE_MODE;
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchState=SWITCH_STATE_SYMBOL_BEGIN;
}",0.89937106918239
87481,"private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mPrevMainKeyboardWasShiftLocked=mAlphabetShiftState.isShiftLocked();
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchActions.setEmojiKeyboard();
}","private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mRecapitalizeMode=RecapitalizeStatus.NOT_A_RECAPITALIZE_MODE;
  mPrevMainKeyboardWasShiftLocked=mAlphabetShiftState.isShiftLocked();
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchActions.setEmojiKeyboard();
}",0.9015384615384616
87482,"private void setSymbolsKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mSwitchActions.setSymbolsKeyboard();
  mIsAlphabetMode=false;
  mIsSymbolShifted=false;
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchState=SWITCH_STATE_SYMBOL_BEGIN;
}","private void setSymbolsKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mSwitchActions.setSymbolsKeyboard();
  mIsAlphabetMode=false;
  mIsSymbolShifted=false;
  mRecapitalizeMode=RecapitalizeStatus.NOT_A_RECAPITALIZE_MODE;
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchState=SWITCH_STATE_SYMBOL_BEGIN;
}",0.8950819672131147
87483,"private void setSymbolsShiftedKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mSwitchActions.setSymbolsShiftedKeyboard();
  mIsAlphabetMode=false;
  mIsSymbolShifted=true;
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchState=SWITCH_STATE_SYMBOL_BEGIN;
}","private void setSymbolsShiftedKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mSwitchActions.setSymbolsShiftedKeyboard();
  mIsAlphabetMode=false;
  mIsSymbolShifted=true;
  mRecapitalizeMode=RecapitalizeStatus.NOT_A_RECAPITALIZE_MODE;
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchState=SWITCH_STATE_SYMBOL_BEGIN;
}",0.89937106918239
87484,"@Override public void setPosition(int position){
  if (mTrieBuf == null || position < 0 || position > -mTrieBuf.length)   return;
  mTriePos=position;
}","@Override public void setPosition(int position){
  if (mTrieBuf == null || position < 0 || position > mTrieBuf.length)   return;
  mTriePos=position;
}",0.9966996699669968
87485,"static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.capitalizeFirstCodePoint(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  final int quotesToAppend=trailingSingleQuotesCount - (-1 == wordInfo.mWord.indexOf(Constants.CODE_SINGLE_QUOTE) ? 0 : 1);
  for (int i=quotesToAppend - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict,wordInfo.mIndexOfTouchPointOfSecondWord,SuggestedWordInfo.NOT_A_CONFIDENCE);
}","static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.capitalizeFirstCodePoint(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  final int quotesToAppend=trailingSingleQuotesCount - (-1 == wordInfo.mWord.indexOf(Constants.CODE_SINGLE_QUOTE) ? 0 : 1);
  for (int i=quotesToAppend - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict,wordInfo.mIndexOfTouchPointOfSecondWord,wordInfo.mAutoCommitFirstWordConfidence);
}",0.9628832705755784
87486,"private SuggestedWordInfo transformWordInfo(final String info,final int trailingSingleQuotesCount){
  return Suggest.getTransformedSuggestedWordInfo(createWordInfo(info),Locale.ENGLISH,false,false,trailingSingleQuotesCount);
}","private SuggestedWordInfo transformWordInfo(final String info,final int trailingSingleQuotesCount){
  final SuggestedWordInfo suggestedWordInfo=createWordInfo(info);
  final SuggestedWordInfo returnedWordInfo=Suggest.getTransformedSuggestedWordInfo(suggestedWordInfo,Locale.ENGLISH,false,false,trailingSingleQuotesCount);
  assertEquals(suggestedWordInfo.mAutoCommitFirstWordConfidence,returnedWordInfo.mAutoCommitFirstWordConfidence);
  return returnedWordInfo;
}",0.5768115942028985
87487,"private SuggestedWordInfo createWordInfo(final String s){
  return new SuggestedWordInfo(s,100,SuggestedWordInfo.KIND_TYPED,null,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE);
}","private SuggestedWordInfo createWordInfo(final String s){
  return new SuggestedWordInfo(s,100,SuggestedWordInfo.KIND_TYPED,null,SuggestedWordInfo.NOT_AN_INDEX,new Random().nextInt(1000000));
}",0.8593350383631714
87488,"private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mSwitchActions.setEmojiKeyboard();
}","private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mPrevMainKeyboardWasShiftLocked=mAlphabetShiftState.isShiftLocked();
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchActions.setEmojiKeyboard();
}",0.7531914893617021
87489,"static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.capitalizeFirstCodePoint(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  final int quotesToAppend=trailingSingleQuotesCount - (-1 == wordInfo.mWord.indexOf(Constants.CODE_SINGLE_QUOTE) ? 0 : 1);
  for (int i=quotesToAppend - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict,wordInfo.mIndexOfTouchPointOfSecondWord,SuggestedWordInfo.NOT_A_CONFIDENCE);
}","static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.capitalizeFirstCodePoint(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  final int quotesToAppend=trailingSingleQuotesCount - (-1 == wordInfo.mWord.indexOf(Constants.CODE_SINGLE_QUOTE) ? 0 : 1);
  for (int i=quotesToAppend - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict,wordInfo.mIndexOfTouchPointOfSecondWord,wordInfo.mAutoCommitFirstWordConfidence);
}",0.9628832705755784
87490,"private SuggestedWordInfo transformWordInfo(final String info,final int trailingSingleQuotesCount){
  return Suggest.getTransformedSuggestedWordInfo(createWordInfo(info),Locale.ENGLISH,false,false,trailingSingleQuotesCount);
}","private SuggestedWordInfo transformWordInfo(final String info,final int trailingSingleQuotesCount){
  final SuggestedWordInfo suggestedWordInfo=createWordInfo(info);
  final SuggestedWordInfo returnedWordInfo=Suggest.getTransformedSuggestedWordInfo(suggestedWordInfo,Locale.ENGLISH,false,false,trailingSingleQuotesCount);
  assertEquals(suggestedWordInfo.mAutoCommitFirstWordConfidence,returnedWordInfo.mAutoCommitFirstWordConfidence);
  return returnedWordInfo;
}",0.5768115942028985
87491,"private SuggestedWordInfo createWordInfo(final String s){
  return new SuggestedWordInfo(s,100,SuggestedWordInfo.KIND_TYPED,null,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE);
}","private SuggestedWordInfo createWordInfo(final String s){
  return new SuggestedWordInfo(s,100,SuggestedWordInfo.KIND_TYPED,null,SuggestedWordInfo.NOT_AN_INDEX,new Random().nextInt(1000000));
}",0.8593350383631714
87492,"static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.capitalizeFirstCodePoint(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  final int quotesToAppend=trailingSingleQuotesCount - (-1 == wordInfo.mWord.indexOf(Constants.CODE_SINGLE_QUOTE) ? 0 : 1);
  for (int i=quotesToAppend - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict,wordInfo.mIndexOfTouchPointOfSecondWord,SuggestedWordInfo.NOT_A_CONFIDENCE);
}","static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.capitalizeFirstCodePoint(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  final int quotesToAppend=trailingSingleQuotesCount - (-1 == wordInfo.mWord.indexOf(Constants.CODE_SINGLE_QUOTE) ? 0 : 1);
  for (int i=quotesToAppend - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict,wordInfo.mIndexOfTouchPointOfSecondWord,wordInfo.mAutoCommitFirstWordConfidence);
}",0.9628832705755784
87493,"private SuggestedWordInfo transformWordInfo(final String info,final int trailingSingleQuotesCount){
  return Suggest.getTransformedSuggestedWordInfo(createWordInfo(info),Locale.ENGLISH,false,false,trailingSingleQuotesCount);
}","private SuggestedWordInfo transformWordInfo(final String info,final int trailingSingleQuotesCount){
  final SuggestedWordInfo suggestedWordInfo=createWordInfo(info);
  final SuggestedWordInfo returnedWordInfo=Suggest.getTransformedSuggestedWordInfo(suggestedWordInfo,Locale.ENGLISH,false,false,trailingSingleQuotesCount);
  assertEquals(suggestedWordInfo.mAutoCommitFirstWordConfidence,returnedWordInfo.mAutoCommitFirstWordConfidence);
  return returnedWordInfo;
}",0.5768115942028985
87494,"private SuggestedWordInfo createWordInfo(final String s){
  return new SuggestedWordInfo(s,100,SuggestedWordInfo.KIND_TYPED,null,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE);
}","private SuggestedWordInfo createWordInfo(final String s){
  return new SuggestedWordInfo(s,100,SuggestedWordInfo.KIND_TYPED,null,SuggestedWordInfo.NOT_AN_INDEX,new Random().nextInt(1000000));
}",0.8593350383631714
87495,"static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.capitalizeFirstCodePoint(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  final int quotesToAppend=trailingSingleQuotesCount - (-1 == wordInfo.mWord.indexOf(Constants.CODE_SINGLE_QUOTE) ? 0 : 1);
  for (int i=quotesToAppend - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict,wordInfo.mIndexOfTouchPointOfSecondWord,SuggestedWordInfo.NOT_A_CONFIDENCE);
}","static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.capitalizeFirstCodePoint(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  final int quotesToAppend=trailingSingleQuotesCount - (-1 == wordInfo.mWord.indexOf(Constants.CODE_SINGLE_QUOTE) ? 0 : 1);
  for (int i=quotesToAppend - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict,wordInfo.mIndexOfTouchPointOfSecondWord,wordInfo.mAutoCommitFirstWordConfidence);
}",0.9628832705755784
87496,"private SuggestedWordInfo transformWordInfo(final String info,final int trailingSingleQuotesCount){
  return Suggest.getTransformedSuggestedWordInfo(createWordInfo(info),Locale.ENGLISH,false,false,trailingSingleQuotesCount);
}","private SuggestedWordInfo transformWordInfo(final String info,final int trailingSingleQuotesCount){
  final SuggestedWordInfo suggestedWordInfo=createWordInfo(info);
  final SuggestedWordInfo returnedWordInfo=Suggest.getTransformedSuggestedWordInfo(suggestedWordInfo,Locale.ENGLISH,false,false,trailingSingleQuotesCount);
  assertEquals(suggestedWordInfo.mAutoCommitFirstWordConfidence,returnedWordInfo.mAutoCommitFirstWordConfidence);
  return returnedWordInfo;
}",0.5768115942028985
87497,"private SuggestedWordInfo createWordInfo(final String s){
  return new SuggestedWordInfo(s,100,SuggestedWordInfo.KIND_TYPED,null,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE);
}","private SuggestedWordInfo createWordInfo(final String s){
  return new SuggestedWordInfo(s,100,SuggestedWordInfo.KIND_TYPED,null,SuggestedWordInfo.NOT_AN_INDEX,new Random().nextInt(1000000));
}",0.8593350383631714
87498,"static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.capitalizeFirstCodePoint(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  final int quotesToAppend=trailingSingleQuotesCount - (-1 == wordInfo.mWord.indexOf(Constants.CODE_SINGLE_QUOTE) ? 0 : 1);
  for (int i=quotesToAppend - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict,wordInfo.mIndexOfTouchPointOfSecondWord,SuggestedWordInfo.NOT_A_CONFIDENCE);
}","static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.capitalizeFirstCodePoint(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  final int quotesToAppend=trailingSingleQuotesCount - (-1 == wordInfo.mWord.indexOf(Constants.CODE_SINGLE_QUOTE) ? 0 : 1);
  for (int i=quotesToAppend - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict,wordInfo.mIndexOfTouchPointOfSecondWord,wordInfo.mAutoCommitFirstWordConfidence);
}",0.9628832705755784
87499,"private SuggestedWordInfo transformWordInfo(final String info,final int trailingSingleQuotesCount){
  return Suggest.getTransformedSuggestedWordInfo(createWordInfo(info),Locale.ENGLISH,false,false,trailingSingleQuotesCount);
}","private SuggestedWordInfo transformWordInfo(final String info,final int trailingSingleQuotesCount){
  final SuggestedWordInfo suggestedWordInfo=createWordInfo(info);
  final SuggestedWordInfo returnedWordInfo=Suggest.getTransformedSuggestedWordInfo(suggestedWordInfo,Locale.ENGLISH,false,false,trailingSingleQuotesCount);
  assertEquals(suggestedWordInfo.mAutoCommitFirstWordConfidence,returnedWordInfo.mAutoCommitFirstWordConfidence);
  return returnedWordInfo;
}",0.5768115942028985
87500,"private SuggestedWordInfo createWordInfo(final String s){
  return new SuggestedWordInfo(s,100,SuggestedWordInfo.KIND_TYPED,null,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE);
}","private SuggestedWordInfo createWordInfo(final String s){
  return new SuggestedWordInfo(s,100,SuggestedWordInfo.KIND_TYPED,null,SuggestedWordInfo.NOT_AN_INDEX,new Random().nextInt(1000000));
}",0.8593350383631714
87501,"private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mSwitchActions.setEmojiKeyboard();
}","private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mPrevMainKeyboardWasShiftLocked=mAlphabetShiftState.isShiftLocked();
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchActions.setEmojiKeyboard();
}",0.7531914893617021
87502,"private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mSwitchActions.setEmojiKeyboard();
}","private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mPrevMainKeyboardWasShiftLocked=mAlphabetShiftState.isShiftLocked();
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchActions.setEmojiKeyboard();
}",0.7531914893617021
87503,"private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mSwitchActions.setEmojiKeyboard();
}","private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mPrevMainKeyboardWasShiftLocked=mAlphabetShiftState.isShiftLocked();
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchActions.setEmojiKeyboard();
}",0.7531914893617021
87504,"private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mSwitchActions.setEmojiKeyboard();
}","private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mPrevMainKeyboardWasShiftLocked=mAlphabetShiftState.isShiftLocked();
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchActions.setEmojiKeyboard();
}",0.7531914893617021
87505,"private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mSwitchActions.setEmojiKeyboard();
}","private void setEmojiKeyboard(){
  if (DEBUG_ACTION) {
    Log.d(TAG,""String_Node_Str"");
  }
  mIsAlphabetMode=false;
  mIsEmojiMode=true;
  mPrevMainKeyboardWasShiftLocked=mAlphabetShiftState.isShiftLocked();
  mAlphabetShiftState.setShiftLocked(false);
  mSwitchActions.setEmojiKeyboard();
}",0.7531914893617021
87506,"public boolean isShowingMoreKeysPanel(){
  if (isShowingEmojiKeyboard()) {
    return false;
  }
  return mKeyboardView.isShowingMoreKeysPanel();
}","public boolean isShowingMoreKeysPanel(){
  if (isShowingEmojiPalettes()) {
    return false;
  }
  return mKeyboardView.isShowingMoreKeysPanel();
}",0.9523809523809524
87507,"public void saveKeyboardState(){
  if (getKeyboard() != null || isShowingEmojiKeyboard()) {
    mState.onSaveKeyboardState();
  }
}","public void saveKeyboardState(){
  if (getKeyboard() != null || isShowingEmojiPalettes()) {
    mState.onSaveKeyboardState();
  }
}",0.9465648854961832
87508,"public View getVisibleKeyboardView(){
  if (isShowingEmojiKeyboard()) {
    return mEmojiPalettesView;
  }
  return mKeyboardView;
}","public View getVisibleKeyboardView(){
  if (isShowingEmojiPalettes()) {
    return mEmojiPalettesView;
  }
  return mKeyboardView;
}",0.946969696969697
87509,"@Override public void onComputeInsets(final InputMethodService.Insets outInsets){
  super.onComputeInsets(outInsets);
  final View visibleKeyboardView=mKeyboardSwitcher.getVisibleKeyboardView();
  if (visibleKeyboardView == null || mSuggestionStripView == null) {
    return;
  }
  final int adjustedBackingHeight=getAdjustedBackingViewHeight();
  final boolean backingGone=(mKeyPreviewBackingView.getVisibility() == View.GONE);
  final int backingHeight=backingGone ? 0 : adjustedBackingHeight;
  final int extractHeight=isFullscreenMode() ? mExtractArea.getHeight() : 0;
  final int suggestionsHeight=(mSuggestionStripView.getVisibility() == View.GONE) ? 0 : mSuggestionStripView.getHeight();
  final int extraHeight=extractHeight + backingHeight + suggestionsHeight;
  int visibleTopY=extraHeight;
  if (visibleKeyboardView.isShown()) {
    if (mKeyboardSwitcher.isShowingEmojiKeyboard() || mSuggestionStripView.getVisibility() == View.VISIBLE) {
      visibleTopY-=suggestionsHeight;
    }
    final int touchY=mKeyboardSwitcher.isShowingMoreKeysPanel() ? 0 : visibleTopY;
    final int touchWidth=visibleKeyboardView.getWidth();
    final int touchHeight=visibleKeyboardView.getHeight() + extraHeight + EXTENDED_TOUCHABLE_REGION_HEIGHT;
    outInsets.touchableInsets=InputMethodService.Insets.TOUCHABLE_INSETS_REGION;
    outInsets.touchableRegion.set(0,touchY,touchWidth,touchHeight);
  }
  outInsets.contentTopInsets=visibleTopY;
  outInsets.visibleTopInsets=visibleTopY;
}","@Override public void onComputeInsets(final InputMethodService.Insets outInsets){
  super.onComputeInsets(outInsets);
  final View visibleKeyboardView=mKeyboardSwitcher.getVisibleKeyboardView();
  if (visibleKeyboardView == null || mSuggestionStripView == null) {
    return;
  }
  final int adjustedBackingHeight=getAdjustedBackingViewHeight();
  final boolean backingGone=(mKeyPreviewBackingView.getVisibility() == View.GONE);
  final int backingHeight=backingGone ? 0 : adjustedBackingHeight;
  final int extractHeight=isFullscreenMode() ? mExtractArea.getHeight() : 0;
  final int suggestionsHeight=(mSuggestionStripView.getVisibility() == View.GONE) ? 0 : mSuggestionStripView.getHeight();
  final int extraHeight=extractHeight + backingHeight + suggestionsHeight;
  int visibleTopY=extraHeight;
  if (visibleKeyboardView.isShown()) {
    if (mKeyboardSwitcher.isShowingEmojiPalettes() || mSuggestionStripView.getVisibility() == View.VISIBLE) {
      visibleTopY-=suggestionsHeight;
    }
    final int touchY=mKeyboardSwitcher.isShowingMoreKeysPanel() ? 0 : visibleTopY;
    final int touchWidth=visibleKeyboardView.getWidth();
    final int touchHeight=visibleKeyboardView.getHeight() + extraHeight + EXTENDED_TOUCHABLE_REGION_HEIGHT;
    outInsets.touchableInsets=InputMethodService.Insets.TOUCHABLE_INSETS_REGION;
    outInsets.touchableRegion.set(0,touchY,touchWidth,touchHeight);
  }
  outInsets.contentTopInsets=visibleTopY;
  outInsets.visibleTopInsets=visibleTopY;
}",0.9945945945945946
87510,"private void setSuggestionStripShownInternal(final boolean shown,final boolean needsInputViewShown){
  if (onEvaluateInputViewShown() && mSuggestionStripView != null) {
    final MainKeyboardView mainKeyboardView=mKeyboardSwitcher.getMainKeyboardView();
    final boolean inputViewShown=(mainKeyboardView != null) ? mainKeyboardView.isShown() : false;
    final boolean shouldShowSuggestions=shown && (needsInputViewShown ? inputViewShown : true);
    if (isFullscreenMode()) {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.GONE);
    }
 else {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.INVISIBLE);
    }
  }
}","private void setSuggestionStripShownInternal(final boolean shown,final boolean needsInputViewShown){
  if (onEvaluateInputViewShown() && mSuggestionStripView != null) {
    final boolean inputViewShown=mKeyboardSwitcher.isShowingMainKeyboardOrEmojiPalettes();
    final boolean shouldShowSuggestions=shown && (needsInputViewShown ? inputViewShown : true);
    if (isFullscreenMode()) {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.GONE);
    }
 else {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.INVISIBLE);
    }
  }
}",0.8560371517027864
87511,"public boolean isShowingMoreKeysPanel(){
  if (isShowingEmojiKeyboard()) {
    return false;
  }
  return mKeyboardView.isShowingMoreKeysPanel();
}","public boolean isShowingMoreKeysPanel(){
  if (isShowingEmojiPalettes()) {
    return false;
  }
  return mKeyboardView.isShowingMoreKeysPanel();
}",0.9523809523809524
87512,"public void saveKeyboardState(){
  if (getKeyboard() != null || isShowingEmojiKeyboard()) {
    mState.onSaveKeyboardState();
  }
}","public void saveKeyboardState(){
  if (getKeyboard() != null || isShowingEmojiPalettes()) {
    mState.onSaveKeyboardState();
  }
}",0.9465648854961832
87513,"public View getVisibleKeyboardView(){
  if (isShowingEmojiKeyboard()) {
    return mEmojiPalettesView;
  }
  return mKeyboardView;
}","public View getVisibleKeyboardView(){
  if (isShowingEmojiPalettes()) {
    return mEmojiPalettesView;
  }
  return mKeyboardView;
}",0.946969696969697
87514,"@Override public void onComputeInsets(final InputMethodService.Insets outInsets){
  super.onComputeInsets(outInsets);
  final View visibleKeyboardView=mKeyboardSwitcher.getVisibleKeyboardView();
  if (visibleKeyboardView == null || mSuggestionStripView == null) {
    return;
  }
  final int adjustedBackingHeight=getAdjustedBackingViewHeight();
  final boolean backingGone=(mKeyPreviewBackingView.getVisibility() == View.GONE);
  final int backingHeight=backingGone ? 0 : adjustedBackingHeight;
  final int extractHeight=isFullscreenMode() ? mExtractArea.getHeight() : 0;
  final int suggestionsHeight=(mSuggestionStripView.getVisibility() == View.GONE) ? 0 : mSuggestionStripView.getHeight();
  final int extraHeight=extractHeight + backingHeight + suggestionsHeight;
  int visibleTopY=extraHeight;
  if (visibleKeyboardView.isShown()) {
    if (mKeyboardSwitcher.isShowingEmojiKeyboard() || mSuggestionStripView.getVisibility() == View.VISIBLE) {
      visibleTopY-=suggestionsHeight;
    }
    final int touchY=mKeyboardSwitcher.isShowingMoreKeysPanel() ? 0 : visibleTopY;
    final int touchWidth=visibleKeyboardView.getWidth();
    final int touchHeight=visibleKeyboardView.getHeight() + extraHeight + EXTENDED_TOUCHABLE_REGION_HEIGHT;
    outInsets.touchableInsets=InputMethodService.Insets.TOUCHABLE_INSETS_REGION;
    outInsets.touchableRegion.set(0,touchY,touchWidth,touchHeight);
  }
  outInsets.contentTopInsets=visibleTopY;
  outInsets.visibleTopInsets=visibleTopY;
}","@Override public void onComputeInsets(final InputMethodService.Insets outInsets){
  super.onComputeInsets(outInsets);
  final View visibleKeyboardView=mKeyboardSwitcher.getVisibleKeyboardView();
  if (visibleKeyboardView == null || mSuggestionStripView == null) {
    return;
  }
  final int adjustedBackingHeight=getAdjustedBackingViewHeight();
  final boolean backingGone=(mKeyPreviewBackingView.getVisibility() == View.GONE);
  final int backingHeight=backingGone ? 0 : adjustedBackingHeight;
  final int extractHeight=isFullscreenMode() ? mExtractArea.getHeight() : 0;
  final int suggestionsHeight=(mSuggestionStripView.getVisibility() == View.GONE) ? 0 : mSuggestionStripView.getHeight();
  final int extraHeight=extractHeight + backingHeight + suggestionsHeight;
  int visibleTopY=extraHeight;
  if (visibleKeyboardView.isShown()) {
    if (mKeyboardSwitcher.isShowingEmojiPalettes() || mSuggestionStripView.getVisibility() == View.VISIBLE) {
      visibleTopY-=suggestionsHeight;
    }
    final int touchY=mKeyboardSwitcher.isShowingMoreKeysPanel() ? 0 : visibleTopY;
    final int touchWidth=visibleKeyboardView.getWidth();
    final int touchHeight=visibleKeyboardView.getHeight() + extraHeight + EXTENDED_TOUCHABLE_REGION_HEIGHT;
    outInsets.touchableInsets=InputMethodService.Insets.TOUCHABLE_INSETS_REGION;
    outInsets.touchableRegion.set(0,touchY,touchWidth,touchHeight);
  }
  outInsets.contentTopInsets=visibleTopY;
  outInsets.visibleTopInsets=visibleTopY;
}",0.9945945945945946
87515,"private void setSuggestionStripShownInternal(final boolean shown,final boolean needsInputViewShown){
  if (onEvaluateInputViewShown() && mSuggestionStripView != null) {
    final MainKeyboardView mainKeyboardView=mKeyboardSwitcher.getMainKeyboardView();
    final boolean inputViewShown=(mainKeyboardView != null) ? mainKeyboardView.isShown() : false;
    final boolean shouldShowSuggestions=shown && (needsInputViewShown ? inputViewShown : true);
    if (isFullscreenMode()) {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.GONE);
    }
 else {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.INVISIBLE);
    }
  }
}","private void setSuggestionStripShownInternal(final boolean shown,final boolean needsInputViewShown){
  if (onEvaluateInputViewShown() && mSuggestionStripView != null) {
    final boolean inputViewShown=mKeyboardSwitcher.isShowingMainKeyboardOrEmojiPalettes();
    final boolean shouldShowSuggestions=shown && (needsInputViewShown ? inputViewShown : true);
    if (isFullscreenMode()) {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.GONE);
    }
 else {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.INVISIBLE);
    }
  }
}",0.8560371517027864
87516,"public boolean isShowingMoreKeysPanel(){
  if (isShowingEmojiKeyboard()) {
    return false;
  }
  return mKeyboardView.isShowingMoreKeysPanel();
}","public boolean isShowingMoreKeysPanel(){
  if (isShowingEmojiPalettes()) {
    return false;
  }
  return mKeyboardView.isShowingMoreKeysPanel();
}",0.9523809523809524
87517,"public void saveKeyboardState(){
  if (getKeyboard() != null || isShowingEmojiKeyboard()) {
    mState.onSaveKeyboardState();
  }
}","public void saveKeyboardState(){
  if (getKeyboard() != null || isShowingEmojiPalettes()) {
    mState.onSaveKeyboardState();
  }
}",0.9465648854961832
87518,"public View getVisibleKeyboardView(){
  if (isShowingEmojiKeyboard()) {
    return mEmojiPalettesView;
  }
  return mKeyboardView;
}","public View getVisibleKeyboardView(){
  if (isShowingEmojiPalettes()) {
    return mEmojiPalettesView;
  }
  return mKeyboardView;
}",0.946969696969697
87519,"@Override public void onComputeInsets(final InputMethodService.Insets outInsets){
  super.onComputeInsets(outInsets);
  final View visibleKeyboardView=mKeyboardSwitcher.getVisibleKeyboardView();
  if (visibleKeyboardView == null || mSuggestionStripView == null) {
    return;
  }
  final int adjustedBackingHeight=getAdjustedBackingViewHeight();
  final boolean backingGone=(mKeyPreviewBackingView.getVisibility() == View.GONE);
  final int backingHeight=backingGone ? 0 : adjustedBackingHeight;
  final int extractHeight=isFullscreenMode() ? mExtractArea.getHeight() : 0;
  final int suggestionsHeight=(mSuggestionStripView.getVisibility() == View.GONE) ? 0 : mSuggestionStripView.getHeight();
  final int extraHeight=extractHeight + backingHeight + suggestionsHeight;
  int visibleTopY=extraHeight;
  if (visibleKeyboardView.isShown()) {
    if (mKeyboardSwitcher.isShowingEmojiKeyboard() || mSuggestionStripView.getVisibility() == View.VISIBLE) {
      visibleTopY-=suggestionsHeight;
    }
    final int touchY=mKeyboardSwitcher.isShowingMoreKeysPanel() ? 0 : visibleTopY;
    final int touchWidth=visibleKeyboardView.getWidth();
    final int touchHeight=visibleKeyboardView.getHeight() + extraHeight + EXTENDED_TOUCHABLE_REGION_HEIGHT;
    outInsets.touchableInsets=InputMethodService.Insets.TOUCHABLE_INSETS_REGION;
    outInsets.touchableRegion.set(0,touchY,touchWidth,touchHeight);
  }
  outInsets.contentTopInsets=visibleTopY;
  outInsets.visibleTopInsets=visibleTopY;
}","@Override public void onComputeInsets(final InputMethodService.Insets outInsets){
  super.onComputeInsets(outInsets);
  final View visibleKeyboardView=mKeyboardSwitcher.getVisibleKeyboardView();
  if (visibleKeyboardView == null || mSuggestionStripView == null) {
    return;
  }
  final int adjustedBackingHeight=getAdjustedBackingViewHeight();
  final boolean backingGone=(mKeyPreviewBackingView.getVisibility() == View.GONE);
  final int backingHeight=backingGone ? 0 : adjustedBackingHeight;
  final int extractHeight=isFullscreenMode() ? mExtractArea.getHeight() : 0;
  final int suggestionsHeight=(mSuggestionStripView.getVisibility() == View.GONE) ? 0 : mSuggestionStripView.getHeight();
  final int extraHeight=extractHeight + backingHeight + suggestionsHeight;
  int visibleTopY=extraHeight;
  if (visibleKeyboardView.isShown()) {
    if (mKeyboardSwitcher.isShowingEmojiPalettes() || mSuggestionStripView.getVisibility() == View.VISIBLE) {
      visibleTopY-=suggestionsHeight;
    }
    final int touchY=mKeyboardSwitcher.isShowingMoreKeysPanel() ? 0 : visibleTopY;
    final int touchWidth=visibleKeyboardView.getWidth();
    final int touchHeight=visibleKeyboardView.getHeight() + extraHeight + EXTENDED_TOUCHABLE_REGION_HEIGHT;
    outInsets.touchableInsets=InputMethodService.Insets.TOUCHABLE_INSETS_REGION;
    outInsets.touchableRegion.set(0,touchY,touchWidth,touchHeight);
  }
  outInsets.contentTopInsets=visibleTopY;
  outInsets.visibleTopInsets=visibleTopY;
}",0.9945945945945946
87520,"private void setSuggestionStripShownInternal(final boolean shown,final boolean needsInputViewShown){
  if (onEvaluateInputViewShown() && mSuggestionStripView != null) {
    final MainKeyboardView mainKeyboardView=mKeyboardSwitcher.getMainKeyboardView();
    final boolean inputViewShown=(mainKeyboardView != null) ? mainKeyboardView.isShown() : false;
    final boolean shouldShowSuggestions=shown && (needsInputViewShown ? inputViewShown : true);
    if (isFullscreenMode()) {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.GONE);
    }
 else {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.INVISIBLE);
    }
  }
}","private void setSuggestionStripShownInternal(final boolean shown,final boolean needsInputViewShown){
  if (onEvaluateInputViewShown() && mSuggestionStripView != null) {
    final boolean inputViewShown=mKeyboardSwitcher.isShowingMainKeyboardOrEmojiPalettes();
    final boolean shouldShowSuggestions=shown && (needsInputViewShown ? inputViewShown : true);
    if (isFullscreenMode()) {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.GONE);
    }
 else {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.INVISIBLE);
    }
  }
}",0.8560371517027864
87521,"public boolean isShowingMoreKeysPanel(){
  if (isShowingEmojiKeyboard()) {
    return false;
  }
  return mKeyboardView.isShowingMoreKeysPanel();
}","public boolean isShowingMoreKeysPanel(){
  if (isShowingEmojiPalettes()) {
    return false;
  }
  return mKeyboardView.isShowingMoreKeysPanel();
}",0.9523809523809524
87522,"public void saveKeyboardState(){
  if (getKeyboard() != null || isShowingEmojiKeyboard()) {
    mState.onSaveKeyboardState();
  }
}","public void saveKeyboardState(){
  if (getKeyboard() != null || isShowingEmojiPalettes()) {
    mState.onSaveKeyboardState();
  }
}",0.9465648854961832
87523,"public View getVisibleKeyboardView(){
  if (isShowingEmojiKeyboard()) {
    return mEmojiPalettesView;
  }
  return mKeyboardView;
}","public View getVisibleKeyboardView(){
  if (isShowingEmojiPalettes()) {
    return mEmojiPalettesView;
  }
  return mKeyboardView;
}",0.946969696969697
87524,"@Override public void onComputeInsets(final InputMethodService.Insets outInsets){
  super.onComputeInsets(outInsets);
  final View visibleKeyboardView=mKeyboardSwitcher.getVisibleKeyboardView();
  if (visibleKeyboardView == null || mSuggestionStripView == null) {
    return;
  }
  final int adjustedBackingHeight=getAdjustedBackingViewHeight();
  final boolean backingGone=(mKeyPreviewBackingView.getVisibility() == View.GONE);
  final int backingHeight=backingGone ? 0 : adjustedBackingHeight;
  final int extractHeight=isFullscreenMode() ? mExtractArea.getHeight() : 0;
  final int suggestionsHeight=(mSuggestionStripView.getVisibility() == View.GONE) ? 0 : mSuggestionStripView.getHeight();
  final int extraHeight=extractHeight + backingHeight + suggestionsHeight;
  int visibleTopY=extraHeight;
  if (visibleKeyboardView.isShown()) {
    if (mKeyboardSwitcher.isShowingEmojiKeyboard() || mSuggestionStripView.getVisibility() == View.VISIBLE) {
      visibleTopY-=suggestionsHeight;
    }
    final int touchY=mKeyboardSwitcher.isShowingMoreKeysPanel() ? 0 : visibleTopY;
    final int touchWidth=visibleKeyboardView.getWidth();
    final int touchHeight=visibleKeyboardView.getHeight() + extraHeight + EXTENDED_TOUCHABLE_REGION_HEIGHT;
    outInsets.touchableInsets=InputMethodService.Insets.TOUCHABLE_INSETS_REGION;
    outInsets.touchableRegion.set(0,touchY,touchWidth,touchHeight);
  }
  outInsets.contentTopInsets=visibleTopY;
  outInsets.visibleTopInsets=visibleTopY;
}","@Override public void onComputeInsets(final InputMethodService.Insets outInsets){
  super.onComputeInsets(outInsets);
  final View visibleKeyboardView=mKeyboardSwitcher.getVisibleKeyboardView();
  if (visibleKeyboardView == null || mSuggestionStripView == null) {
    return;
  }
  final int adjustedBackingHeight=getAdjustedBackingViewHeight();
  final boolean backingGone=(mKeyPreviewBackingView.getVisibility() == View.GONE);
  final int backingHeight=backingGone ? 0 : adjustedBackingHeight;
  final int extractHeight=isFullscreenMode() ? mExtractArea.getHeight() : 0;
  final int suggestionsHeight=(mSuggestionStripView.getVisibility() == View.GONE) ? 0 : mSuggestionStripView.getHeight();
  final int extraHeight=extractHeight + backingHeight + suggestionsHeight;
  int visibleTopY=extraHeight;
  if (visibleKeyboardView.isShown()) {
    if (mKeyboardSwitcher.isShowingEmojiPalettes() || mSuggestionStripView.getVisibility() == View.VISIBLE) {
      visibleTopY-=suggestionsHeight;
    }
    final int touchY=mKeyboardSwitcher.isShowingMoreKeysPanel() ? 0 : visibleTopY;
    final int touchWidth=visibleKeyboardView.getWidth();
    final int touchHeight=visibleKeyboardView.getHeight() + extraHeight + EXTENDED_TOUCHABLE_REGION_HEIGHT;
    outInsets.touchableInsets=InputMethodService.Insets.TOUCHABLE_INSETS_REGION;
    outInsets.touchableRegion.set(0,touchY,touchWidth,touchHeight);
  }
  outInsets.contentTopInsets=visibleTopY;
  outInsets.visibleTopInsets=visibleTopY;
}",0.9945945945945946
87525,"private void setSuggestionStripShownInternal(final boolean shown,final boolean needsInputViewShown){
  if (onEvaluateInputViewShown() && mSuggestionStripView != null) {
    final MainKeyboardView mainKeyboardView=mKeyboardSwitcher.getMainKeyboardView();
    final boolean inputViewShown=(mainKeyboardView != null) ? mainKeyboardView.isShown() : false;
    final boolean shouldShowSuggestions=shown && (needsInputViewShown ? inputViewShown : true);
    if (isFullscreenMode()) {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.GONE);
    }
 else {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.INVISIBLE);
    }
  }
}","private void setSuggestionStripShownInternal(final boolean shown,final boolean needsInputViewShown){
  if (onEvaluateInputViewShown() && mSuggestionStripView != null) {
    final boolean inputViewShown=mKeyboardSwitcher.isShowingMainKeyboardOrEmojiPalettes();
    final boolean shouldShowSuggestions=shown && (needsInputViewShown ? inputViewShown : true);
    if (isFullscreenMode()) {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.GONE);
    }
 else {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.INVISIBLE);
    }
  }
}",0.8560371517027864
87526,"public boolean isShowingMoreKeysPanel(){
  if (isShowingEmojiKeyboard()) {
    return false;
  }
  return mKeyboardView.isShowingMoreKeysPanel();
}","public boolean isShowingMoreKeysPanel(){
  if (isShowingEmojiPalettes()) {
    return false;
  }
  return mKeyboardView.isShowingMoreKeysPanel();
}",0.9523809523809524
87527,"public void saveKeyboardState(){
  if (getKeyboard() != null || isShowingEmojiKeyboard()) {
    mState.onSaveKeyboardState();
  }
}","public void saveKeyboardState(){
  if (getKeyboard() != null || isShowingEmojiPalettes()) {
    mState.onSaveKeyboardState();
  }
}",0.9465648854961832
87528,"public View getVisibleKeyboardView(){
  if (isShowingEmojiKeyboard()) {
    return mEmojiPalettesView;
  }
  return mKeyboardView;
}","public View getVisibleKeyboardView(){
  if (isShowingEmojiPalettes()) {
    return mEmojiPalettesView;
  }
  return mKeyboardView;
}",0.946969696969697
87529,"@Override public void onComputeInsets(final InputMethodService.Insets outInsets){
  super.onComputeInsets(outInsets);
  final View visibleKeyboardView=mKeyboardSwitcher.getVisibleKeyboardView();
  if (visibleKeyboardView == null || mSuggestionStripView == null) {
    return;
  }
  final int adjustedBackingHeight=getAdjustedBackingViewHeight();
  final boolean backingGone=(mKeyPreviewBackingView.getVisibility() == View.GONE);
  final int backingHeight=backingGone ? 0 : adjustedBackingHeight;
  final int extractHeight=isFullscreenMode() ? mExtractArea.getHeight() : 0;
  final int suggestionsHeight=(mSuggestionStripView.getVisibility() == View.GONE) ? 0 : mSuggestionStripView.getHeight();
  final int extraHeight=extractHeight + backingHeight + suggestionsHeight;
  int visibleTopY=extraHeight;
  if (visibleKeyboardView.isShown()) {
    if (mKeyboardSwitcher.isShowingEmojiKeyboard() || mSuggestionStripView.getVisibility() == View.VISIBLE) {
      visibleTopY-=suggestionsHeight;
    }
    final int touchY=mKeyboardSwitcher.isShowingMoreKeysPanel() ? 0 : visibleTopY;
    final int touchWidth=visibleKeyboardView.getWidth();
    final int touchHeight=visibleKeyboardView.getHeight() + extraHeight + EXTENDED_TOUCHABLE_REGION_HEIGHT;
    outInsets.touchableInsets=InputMethodService.Insets.TOUCHABLE_INSETS_REGION;
    outInsets.touchableRegion.set(0,touchY,touchWidth,touchHeight);
  }
  outInsets.contentTopInsets=visibleTopY;
  outInsets.visibleTopInsets=visibleTopY;
}","@Override public void onComputeInsets(final InputMethodService.Insets outInsets){
  super.onComputeInsets(outInsets);
  final View visibleKeyboardView=mKeyboardSwitcher.getVisibleKeyboardView();
  if (visibleKeyboardView == null || mSuggestionStripView == null) {
    return;
  }
  final int adjustedBackingHeight=getAdjustedBackingViewHeight();
  final boolean backingGone=(mKeyPreviewBackingView.getVisibility() == View.GONE);
  final int backingHeight=backingGone ? 0 : adjustedBackingHeight;
  final int extractHeight=isFullscreenMode() ? mExtractArea.getHeight() : 0;
  final int suggestionsHeight=(mSuggestionStripView.getVisibility() == View.GONE) ? 0 : mSuggestionStripView.getHeight();
  final int extraHeight=extractHeight + backingHeight + suggestionsHeight;
  int visibleTopY=extraHeight;
  if (visibleKeyboardView.isShown()) {
    if (mKeyboardSwitcher.isShowingEmojiPalettes() || mSuggestionStripView.getVisibility() == View.VISIBLE) {
      visibleTopY-=suggestionsHeight;
    }
    final int touchY=mKeyboardSwitcher.isShowingMoreKeysPanel() ? 0 : visibleTopY;
    final int touchWidth=visibleKeyboardView.getWidth();
    final int touchHeight=visibleKeyboardView.getHeight() + extraHeight + EXTENDED_TOUCHABLE_REGION_HEIGHT;
    outInsets.touchableInsets=InputMethodService.Insets.TOUCHABLE_INSETS_REGION;
    outInsets.touchableRegion.set(0,touchY,touchWidth,touchHeight);
  }
  outInsets.contentTopInsets=visibleTopY;
  outInsets.visibleTopInsets=visibleTopY;
}",0.9945945945945946
87530,"private void setSuggestionStripShownInternal(final boolean shown,final boolean needsInputViewShown){
  if (onEvaluateInputViewShown() && mSuggestionStripView != null) {
    final MainKeyboardView mainKeyboardView=mKeyboardSwitcher.getMainKeyboardView();
    final boolean inputViewShown=(mainKeyboardView != null) ? mainKeyboardView.isShown() : false;
    final boolean shouldShowSuggestions=shown && (needsInputViewShown ? inputViewShown : true);
    if (isFullscreenMode()) {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.GONE);
    }
 else {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.INVISIBLE);
    }
  }
}","private void setSuggestionStripShownInternal(final boolean shown,final boolean needsInputViewShown){
  if (onEvaluateInputViewShown() && mSuggestionStripView != null) {
    final boolean inputViewShown=mKeyboardSwitcher.isShowingMainKeyboardOrEmojiPalettes();
    final boolean shouldShowSuggestions=shown && (needsInputViewShown ? inputViewShown : true);
    if (isFullscreenMode()) {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.GONE);
    }
 else {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.INVISIBLE);
    }
  }
}",0.8560371517027864
87531,"public boolean isShowingMoreKeysPanel(){
  if (isShowingEmojiKeyboard()) {
    return false;
  }
  return mKeyboardView.isShowingMoreKeysPanel();
}","public boolean isShowingMoreKeysPanel(){
  if (isShowingEmojiPalettes()) {
    return false;
  }
  return mKeyboardView.isShowingMoreKeysPanel();
}",0.9523809523809524
87532,"public void saveKeyboardState(){
  if (getKeyboard() != null || isShowingEmojiKeyboard()) {
    mState.onSaveKeyboardState();
  }
}","public void saveKeyboardState(){
  if (getKeyboard() != null || isShowingEmojiPalettes()) {
    mState.onSaveKeyboardState();
  }
}",0.9465648854961832
87533,"public View getVisibleKeyboardView(){
  if (isShowingEmojiKeyboard()) {
    return mEmojiPalettesView;
  }
  return mKeyboardView;
}","public View getVisibleKeyboardView(){
  if (isShowingEmojiPalettes()) {
    return mEmojiPalettesView;
  }
  return mKeyboardView;
}",0.946969696969697
87534,"@Override public void onComputeInsets(final InputMethodService.Insets outInsets){
  super.onComputeInsets(outInsets);
  final View visibleKeyboardView=mKeyboardSwitcher.getVisibleKeyboardView();
  if (visibleKeyboardView == null || mSuggestionStripView == null) {
    return;
  }
  final int adjustedBackingHeight=getAdjustedBackingViewHeight();
  final boolean backingGone=(mKeyPreviewBackingView.getVisibility() == View.GONE);
  final int backingHeight=backingGone ? 0 : adjustedBackingHeight;
  final int extractHeight=isFullscreenMode() ? mExtractArea.getHeight() : 0;
  final int suggestionsHeight=(mSuggestionStripView.getVisibility() == View.GONE) ? 0 : mSuggestionStripView.getHeight();
  final int extraHeight=extractHeight + backingHeight + suggestionsHeight;
  int visibleTopY=extraHeight;
  if (visibleKeyboardView.isShown()) {
    if (mKeyboardSwitcher.isShowingEmojiKeyboard() || mSuggestionStripView.getVisibility() == View.VISIBLE) {
      visibleTopY-=suggestionsHeight;
    }
    final int touchY=mKeyboardSwitcher.isShowingMoreKeysPanel() ? 0 : visibleTopY;
    final int touchWidth=visibleKeyboardView.getWidth();
    final int touchHeight=visibleKeyboardView.getHeight() + extraHeight + EXTENDED_TOUCHABLE_REGION_HEIGHT;
    outInsets.touchableInsets=InputMethodService.Insets.TOUCHABLE_INSETS_REGION;
    outInsets.touchableRegion.set(0,touchY,touchWidth,touchHeight);
  }
  outInsets.contentTopInsets=visibleTopY;
  outInsets.visibleTopInsets=visibleTopY;
}","@Override public void onComputeInsets(final InputMethodService.Insets outInsets){
  super.onComputeInsets(outInsets);
  final View visibleKeyboardView=mKeyboardSwitcher.getVisibleKeyboardView();
  if (visibleKeyboardView == null || mSuggestionStripView == null) {
    return;
  }
  final int adjustedBackingHeight=getAdjustedBackingViewHeight();
  final boolean backingGone=(mKeyPreviewBackingView.getVisibility() == View.GONE);
  final int backingHeight=backingGone ? 0 : adjustedBackingHeight;
  final int extractHeight=isFullscreenMode() ? mExtractArea.getHeight() : 0;
  final int suggestionsHeight=(mSuggestionStripView.getVisibility() == View.GONE) ? 0 : mSuggestionStripView.getHeight();
  final int extraHeight=extractHeight + backingHeight + suggestionsHeight;
  int visibleTopY=extraHeight;
  if (visibleKeyboardView.isShown()) {
    if (mKeyboardSwitcher.isShowingEmojiPalettes() || mSuggestionStripView.getVisibility() == View.VISIBLE) {
      visibleTopY-=suggestionsHeight;
    }
    final int touchY=mKeyboardSwitcher.isShowingMoreKeysPanel() ? 0 : visibleTopY;
    final int touchWidth=visibleKeyboardView.getWidth();
    final int touchHeight=visibleKeyboardView.getHeight() + extraHeight + EXTENDED_TOUCHABLE_REGION_HEIGHT;
    outInsets.touchableInsets=InputMethodService.Insets.TOUCHABLE_INSETS_REGION;
    outInsets.touchableRegion.set(0,touchY,touchWidth,touchHeight);
  }
  outInsets.contentTopInsets=visibleTopY;
  outInsets.visibleTopInsets=visibleTopY;
}",0.9945945945945946
87535,"private void setSuggestionStripShownInternal(final boolean shown,final boolean needsInputViewShown){
  if (onEvaluateInputViewShown() && mSuggestionStripView != null) {
    final MainKeyboardView mainKeyboardView=mKeyboardSwitcher.getMainKeyboardView();
    final boolean inputViewShown=(mainKeyboardView != null) ? mainKeyboardView.isShown() : false;
    final boolean shouldShowSuggestions=shown && (needsInputViewShown ? inputViewShown : true);
    if (isFullscreenMode()) {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.GONE);
    }
 else {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.INVISIBLE);
    }
  }
}","private void setSuggestionStripShownInternal(final boolean shown,final boolean needsInputViewShown){
  if (onEvaluateInputViewShown() && mSuggestionStripView != null) {
    final boolean inputViewShown=mKeyboardSwitcher.isShowingMainKeyboardOrEmojiPalettes();
    final boolean shouldShowSuggestions=shown && (needsInputViewShown ? inputViewShown : true);
    if (isFullscreenMode()) {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.GONE);
    }
 else {
      mSuggestionStripView.setVisibility(shouldShowSuggestions ? View.VISIBLE : View.INVISIBLE);
    }
  }
}",0.8560371517027864
87536,"private void onRestoreKeyboardState(){
  final SavedKeyboardState state=mSavedKeyboardState;
  if (DEBUG_EVENT) {
    Log.d(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ this);
  }
  if (!state.mIsValid || state.mIsAlphabetMode) {
    setAlphabetKeyboard();
  }
 else   if (state.mIsEmojiMode) {
    setEmojiKeyboard();
  }
 else {
    if (state.mShiftMode == MANUAL_SHIFT) {
      setSymbolsShiftedKeyboard();
    }
 else {
      setSymbolsKeyboard();
    }
  }
  if (!state.mIsValid)   return;
  state.mIsValid=false;
  if (state.mIsAlphabetMode) {
    setShiftLocked(state.mIsAlphabetShiftLocked);
    if (!state.mIsAlphabetShiftLocked) {
      setShifted(state.mShiftMode);
    }
  }
 else {
    mPrevMainKeyboardWasShiftLocked=state.mIsAlphabetShiftLocked;
  }
}","private void onRestoreKeyboardState(){
  final SavedKeyboardState state=mSavedKeyboardState;
  if (DEBUG_EVENT) {
    Log.d(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ this);
  }
  if (!state.mIsValid || state.mIsAlphabetMode) {
    setAlphabetKeyboard();
  }
 else   if (state.mIsEmojiMode) {
    setEmojiKeyboard();
  }
 else {
    if (state.mShiftMode == MANUAL_SHIFT) {
      setSymbolsShiftedKeyboard();
    }
 else {
      setSymbolsKeyboard();
    }
  }
  if (!state.mIsValid)   return;
  state.mIsValid=false;
  if (state.mIsAlphabetMode) {
    setShiftLocked(state.mIsAlphabetShiftLocked);
    if (!state.mIsAlphabetShiftLocked) {
      setShifted(state.mShiftMode);
    }
    mSwitchActions.requestUpdatingShiftState();
  }
 else {
    mPrevMainKeyboardWasShiftLocked=state.mIsAlphabetShiftLocked;
  }
}",0.9698492462311558
87537,"/** 
 * Retry resetting caches in the rich input connection. When the editor can't be accessed we can't reset the caches, so we schedule a retry. This method handles the retry, and re-schedules a new retry if we still can't access. We only retry up to 5 times before giving up.
 * @param tryResumeSuggestions Whether we should resume suggestions or not.
 * @param remainingTries How many times we may try again before giving up.
 */
private void retryResetCaches(final boolean tryResumeSuggestions,final int remainingTries){
  if (!mConnection.resetCachesUponCursorMoveAndReturnSuccess(mLastSelectionStart,false)) {
    if (0 < remainingTries) {
      mHandler.postResetCaches(tryResumeSuggestions,remainingTries - 1);
    }
    return;
  }
  tryFixLyingCursorPosition();
  if (tryResumeSuggestions)   mHandler.postResumeSuggestions();
}","/** 
 * Retry resetting caches in the rich input connection. When the editor can't be accessed we can't reset the caches, so we schedule a retry. This method handles the retry, and re-schedules a new retry if we still can't access. We only retry up to 5 times before giving up.
 * @param tryResumeSuggestions Whether we should resume suggestions or not.
 * @param remainingTries How many times we may try again before giving up.
 */
private void retryResetCaches(final boolean tryResumeSuggestions,final int remainingTries){
  if (!mConnection.resetCachesUponCursorMoveAndReturnSuccess(mLastSelectionStart,false)) {
    if (0 < remainingTries) {
      mHandler.postResetCaches(tryResumeSuggestions,remainingTries - 1);
    }
    return;
  }
  tryFixLyingCursorPosition();
  mKeyboardSwitcher.updateShiftState();
  if (tryResumeSuggestions)   mHandler.postResumeSuggestions();
}",0.908984830805134
87538,"private void updateBatchInput(final long eventTime){
synchronized (sAggregratedPointers) {
    final GestureStroke stroke=mGestureStrokeWithPreviewPoints;
    stroke.appendIncrementalBatchPoints(sAggregratedPointers);
    final int size=sAggregratedPointers.getPointerSize();
    if (size > sLastRecognitionPointSize && stroke.hasRecognitionTimePast(eventTime,sLastRecognitionTime)) {
      sLastRecognitionPointSize=size;
      sLastRecognitionTime=eventTime;
      if (DEBUG_LISTENER) {
        Log.d(TAG,String.format(""String_Node_Str"",mPointerId,size));
      }
      mTimerProxy.startUpdateBatchInputTimer(this);
      mListener.onUpdateBatchInput(sAggregratedPointers);
    }
  }
}","private void updateBatchInput(final long eventTime){
synchronized (sAggregratedPointers) {
    final GestureStroke stroke=mGestureStrokeWithPreviewPoints;
    stroke.appendIncrementalBatchPoints(sAggregratedPointers);
    final int size=sAggregratedPointers.getPointerSize();
    if (size > sLastRecognitionPointSize && stroke.hasRecognitionTimePast(eventTime,sLastRecognitionTime)) {
      if (DEBUG_LISTENER) {
        Log.d(TAG,String.format(""String_Node_Str"",mPointerId,size));
      }
      mTimerProxy.startUpdateBatchInputTimer(this);
      mListener.onUpdateBatchInput(sAggregratedPointers);
      sLastRecognitionPointSize=sAggregratedPointers.getPointerSize();
      sLastRecognitionTime=eventTime;
    }
  }
}",0.8685145700071073
87539,"private void updateBatchInput(final long eventTime){
synchronized (sAggregratedPointers) {
    final GestureStroke stroke=mGestureStrokeWithPreviewPoints;
    stroke.appendIncrementalBatchPoints(sAggregratedPointers);
    final int size=sAggregratedPointers.getPointerSize();
    if (size > sLastRecognitionPointSize && stroke.hasRecognitionTimePast(eventTime,sLastRecognitionTime)) {
      sLastRecognitionPointSize=size;
      sLastRecognitionTime=eventTime;
      if (DEBUG_LISTENER) {
        Log.d(TAG,String.format(""String_Node_Str"",mPointerId,size));
      }
      mTimerProxy.startUpdateBatchInputTimer(this);
      mListener.onUpdateBatchInput(sAggregratedPointers);
    }
  }
}","private void updateBatchInput(final long eventTime){
synchronized (sAggregratedPointers) {
    final GestureStroke stroke=mGestureStrokeWithPreviewPoints;
    stroke.appendIncrementalBatchPoints(sAggregratedPointers);
    final int size=sAggregratedPointers.getPointerSize();
    if (size > sLastRecognitionPointSize && stroke.hasRecognitionTimePast(eventTime,sLastRecognitionTime)) {
      if (DEBUG_LISTENER) {
        Log.d(TAG,String.format(""String_Node_Str"",mPointerId,size));
      }
      mTimerProxy.startUpdateBatchInputTimer(this);
      mListener.onUpdateBatchInput(sAggregratedPointers);
      sLastRecognitionPointSize=sAggregratedPointers.getPointerSize();
      sLastRecognitionTime=eventTime;
    }
  }
}",0.8685145700071073
87540,"private void onRestoreKeyboardState(){
  final SavedKeyboardState state=mSavedKeyboardState;
  if (DEBUG_EVENT) {
    Log.d(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ this);
  }
  if (!state.mIsValid || state.mIsAlphabetMode) {
    setAlphabetKeyboard();
  }
 else   if (state.mIsEmojiMode) {
    setEmojiKeyboard();
  }
 else {
    if (state.mShiftMode == MANUAL_SHIFT) {
      setSymbolsShiftedKeyboard();
    }
 else {
      setSymbolsKeyboard();
    }
  }
  if (!state.mIsValid)   return;
  state.mIsValid=false;
  if (state.mIsAlphabetMode) {
    setShiftLocked(state.mIsAlphabetShiftLocked);
    if (!state.mIsAlphabetShiftLocked) {
      setShifted(state.mShiftMode);
    }
  }
 else {
    mPrevMainKeyboardWasShiftLocked=state.mIsAlphabetShiftLocked;
  }
}","private void onRestoreKeyboardState(){
  final SavedKeyboardState state=mSavedKeyboardState;
  if (DEBUG_EVENT) {
    Log.d(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ this);
  }
  if (!state.mIsValid || state.mIsAlphabetMode) {
    setAlphabetKeyboard();
  }
 else   if (state.mIsEmojiMode) {
    setEmojiKeyboard();
  }
 else {
    if (state.mShiftMode == MANUAL_SHIFT) {
      setSymbolsShiftedKeyboard();
    }
 else {
      setSymbolsKeyboard();
    }
  }
  if (!state.mIsValid)   return;
  state.mIsValid=false;
  if (state.mIsAlphabetMode) {
    setShiftLocked(state.mIsAlphabetShiftLocked);
    if (!state.mIsAlphabetShiftLocked) {
      setShifted(state.mShiftMode);
    }
    mSwitchActions.requestUpdatingShiftState();
  }
 else {
    mPrevMainKeyboardWasShiftLocked=state.mIsAlphabetShiftLocked;
  }
}",0.9698492462311558
87541,"/** 
 * Retry resetting caches in the rich input connection. When the editor can't be accessed we can't reset the caches, so we schedule a retry. This method handles the retry, and re-schedules a new retry if we still can't access. We only retry up to 5 times before giving up.
 * @param tryResumeSuggestions Whether we should resume suggestions or not.
 * @param remainingTries How many times we may try again before giving up.
 */
private void retryResetCaches(final boolean tryResumeSuggestions,final int remainingTries){
  if (!mConnection.resetCachesUponCursorMoveAndReturnSuccess(mLastSelectionStart,false)) {
    if (0 < remainingTries) {
      mHandler.postResetCaches(tryResumeSuggestions,remainingTries - 1);
    }
    return;
  }
  tryFixLyingCursorPosition();
  if (tryResumeSuggestions)   mHandler.postResumeSuggestions();
}","/** 
 * Retry resetting caches in the rich input connection. When the editor can't be accessed we can't reset the caches, so we schedule a retry. This method handles the retry, and re-schedules a new retry if we still can't access. We only retry up to 5 times before giving up.
 * @param tryResumeSuggestions Whether we should resume suggestions or not.
 * @param remainingTries How many times we may try again before giving up.
 */
private void retryResetCaches(final boolean tryResumeSuggestions,final int remainingTries){
  if (!mConnection.resetCachesUponCursorMoveAndReturnSuccess(mLastSelectionStart,false)) {
    if (0 < remainingTries) {
      mHandler.postResetCaches(tryResumeSuggestions,remainingTries - 1);
    }
    return;
  }
  tryFixLyingCursorPosition();
  mKeyboardSwitcher.updateShiftState();
  if (tryResumeSuggestions)   mHandler.postResumeSuggestions();
}",0.908984830805134
87542,"private void onRestoreKeyboardState(){
  final SavedKeyboardState state=mSavedKeyboardState;
  if (DEBUG_EVENT) {
    Log.d(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ this);
  }
  if (!state.mIsValid || state.mIsAlphabetMode) {
    setAlphabetKeyboard();
  }
 else   if (state.mIsEmojiMode) {
    setEmojiKeyboard();
  }
 else {
    if (state.mShiftMode == MANUAL_SHIFT) {
      setSymbolsShiftedKeyboard();
    }
 else {
      setSymbolsKeyboard();
    }
  }
  if (!state.mIsValid)   return;
  state.mIsValid=false;
  if (state.mIsAlphabetMode) {
    setShiftLocked(state.mIsAlphabetShiftLocked);
    if (!state.mIsAlphabetShiftLocked) {
      setShifted(state.mShiftMode);
    }
  }
 else {
    mPrevMainKeyboardWasShiftLocked=state.mIsAlphabetShiftLocked;
  }
}","private void onRestoreKeyboardState(){
  final SavedKeyboardState state=mSavedKeyboardState;
  if (DEBUG_EVENT) {
    Log.d(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ this);
  }
  if (!state.mIsValid || state.mIsAlphabetMode) {
    setAlphabetKeyboard();
  }
 else   if (state.mIsEmojiMode) {
    setEmojiKeyboard();
  }
 else {
    if (state.mShiftMode == MANUAL_SHIFT) {
      setSymbolsShiftedKeyboard();
    }
 else {
      setSymbolsKeyboard();
    }
  }
  if (!state.mIsValid)   return;
  state.mIsValid=false;
  if (state.mIsAlphabetMode) {
    setShiftLocked(state.mIsAlphabetShiftLocked);
    if (!state.mIsAlphabetShiftLocked) {
      setShifted(state.mShiftMode);
    }
    mSwitchActions.requestUpdatingShiftState();
  }
 else {
    mPrevMainKeyboardWasShiftLocked=state.mIsAlphabetShiftLocked;
  }
}",0.9698492462311558
87543,"/** 
 * Retry resetting caches in the rich input connection. When the editor can't be accessed we can't reset the caches, so we schedule a retry. This method handles the retry, and re-schedules a new retry if we still can't access. We only retry up to 5 times before giving up.
 * @param tryResumeSuggestions Whether we should resume suggestions or not.
 * @param remainingTries How many times we may try again before giving up.
 */
private void retryResetCaches(final boolean tryResumeSuggestions,final int remainingTries){
  if (!mConnection.resetCachesUponCursorMoveAndReturnSuccess(mLastSelectionStart,false)) {
    if (0 < remainingTries) {
      mHandler.postResetCaches(tryResumeSuggestions,remainingTries - 1);
    }
    return;
  }
  tryFixLyingCursorPosition();
  if (tryResumeSuggestions)   mHandler.postResumeSuggestions();
}","/** 
 * Retry resetting caches in the rich input connection. When the editor can't be accessed we can't reset the caches, so we schedule a retry. This method handles the retry, and re-schedules a new retry if we still can't access. We only retry up to 5 times before giving up.
 * @param tryResumeSuggestions Whether we should resume suggestions or not.
 * @param remainingTries How many times we may try again before giving up.
 */
private void retryResetCaches(final boolean tryResumeSuggestions,final int remainingTries){
  if (!mConnection.resetCachesUponCursorMoveAndReturnSuccess(mLastSelectionStart,false)) {
    if (0 < remainingTries) {
      mHandler.postResetCaches(tryResumeSuggestions,remainingTries - 1);
    }
    return;
  }
  tryFixLyingCursorPosition();
  mKeyboardSwitcher.updateShiftState();
  if (tryResumeSuggestions)   mHandler.postResumeSuggestions();
}",0.908984830805134
87544,"private void onRestoreKeyboardState(){
  final SavedKeyboardState state=mSavedKeyboardState;
  if (DEBUG_EVENT) {
    Log.d(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ this);
  }
  if (!state.mIsValid || state.mIsAlphabetMode) {
    setAlphabetKeyboard();
  }
 else   if (state.mIsEmojiMode) {
    setEmojiKeyboard();
  }
 else {
    if (state.mShiftMode == MANUAL_SHIFT) {
      setSymbolsShiftedKeyboard();
    }
 else {
      setSymbolsKeyboard();
    }
  }
  if (!state.mIsValid)   return;
  state.mIsValid=false;
  if (state.mIsAlphabetMode) {
    setShiftLocked(state.mIsAlphabetShiftLocked);
    if (!state.mIsAlphabetShiftLocked) {
      setShifted(state.mShiftMode);
    }
  }
 else {
    mPrevMainKeyboardWasShiftLocked=state.mIsAlphabetShiftLocked;
  }
}","private void onRestoreKeyboardState(){
  final SavedKeyboardState state=mSavedKeyboardState;
  if (DEBUG_EVENT) {
    Log.d(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ this);
  }
  if (!state.mIsValid || state.mIsAlphabetMode) {
    setAlphabetKeyboard();
  }
 else   if (state.mIsEmojiMode) {
    setEmojiKeyboard();
  }
 else {
    if (state.mShiftMode == MANUAL_SHIFT) {
      setSymbolsShiftedKeyboard();
    }
 else {
      setSymbolsKeyboard();
    }
  }
  if (!state.mIsValid)   return;
  state.mIsValid=false;
  if (state.mIsAlphabetMode) {
    setShiftLocked(state.mIsAlphabetShiftLocked);
    if (!state.mIsAlphabetShiftLocked) {
      setShifted(state.mShiftMode);
    }
    mSwitchActions.requestUpdatingShiftState();
  }
 else {
    mPrevMainKeyboardWasShiftLocked=state.mIsAlphabetShiftLocked;
  }
}",0.9698492462311558
87545,"/** 
 * Retry resetting caches in the rich input connection. When the editor can't be accessed we can't reset the caches, so we schedule a retry. This method handles the retry, and re-schedules a new retry if we still can't access. We only retry up to 5 times before giving up.
 * @param tryResumeSuggestions Whether we should resume suggestions or not.
 * @param remainingTries How many times we may try again before giving up.
 */
private void retryResetCaches(final boolean tryResumeSuggestions,final int remainingTries){
  if (!mConnection.resetCachesUponCursorMoveAndReturnSuccess(mLastSelectionStart,false)) {
    if (0 < remainingTries) {
      mHandler.postResetCaches(tryResumeSuggestions,remainingTries - 1);
    }
    return;
  }
  tryFixLyingCursorPosition();
  if (tryResumeSuggestions)   mHandler.postResumeSuggestions();
}","/** 
 * Retry resetting caches in the rich input connection. When the editor can't be accessed we can't reset the caches, so we schedule a retry. This method handles the retry, and re-schedules a new retry if we still can't access. We only retry up to 5 times before giving up.
 * @param tryResumeSuggestions Whether we should resume suggestions or not.
 * @param remainingTries How many times we may try again before giving up.
 */
private void retryResetCaches(final boolean tryResumeSuggestions,final int remainingTries){
  if (!mConnection.resetCachesUponCursorMoveAndReturnSuccess(mLastSelectionStart,false)) {
    if (0 < remainingTries) {
      mHandler.postResetCaches(tryResumeSuggestions,remainingTries - 1);
    }
    return;
  }
  tryFixLyingCursorPosition();
  mKeyboardSwitcher.updateShiftState();
  if (tryResumeSuggestions)   mHandler.postResumeSuggestions();
}",0.908984830805134
87546,"private void onRestoreKeyboardState(){
  final SavedKeyboardState state=mSavedKeyboardState;
  if (DEBUG_EVENT) {
    Log.d(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ this);
  }
  if (!state.mIsValid || state.mIsAlphabetMode) {
    setAlphabetKeyboard();
  }
 else   if (state.mIsEmojiMode) {
    setEmojiKeyboard();
  }
 else {
    if (state.mShiftMode == MANUAL_SHIFT) {
      setSymbolsShiftedKeyboard();
    }
 else {
      setSymbolsKeyboard();
    }
  }
  if (!state.mIsValid)   return;
  state.mIsValid=false;
  if (state.mIsAlphabetMode) {
    setShiftLocked(state.mIsAlphabetShiftLocked);
    if (!state.mIsAlphabetShiftLocked) {
      setShifted(state.mShiftMode);
    }
  }
 else {
    mPrevMainKeyboardWasShiftLocked=state.mIsAlphabetShiftLocked;
  }
}","private void onRestoreKeyboardState(){
  final SavedKeyboardState state=mSavedKeyboardState;
  if (DEBUG_EVENT) {
    Log.d(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ this);
  }
  if (!state.mIsValid || state.mIsAlphabetMode) {
    setAlphabetKeyboard();
  }
 else   if (state.mIsEmojiMode) {
    setEmojiKeyboard();
  }
 else {
    if (state.mShiftMode == MANUAL_SHIFT) {
      setSymbolsShiftedKeyboard();
    }
 else {
      setSymbolsKeyboard();
    }
  }
  if (!state.mIsValid)   return;
  state.mIsValid=false;
  if (state.mIsAlphabetMode) {
    setShiftLocked(state.mIsAlphabetShiftLocked);
    if (!state.mIsAlphabetShiftLocked) {
      setShifted(state.mShiftMode);
    }
    mSwitchActions.requestUpdatingShiftState();
  }
 else {
    mPrevMainKeyboardWasShiftLocked=state.mIsAlphabetShiftLocked;
  }
}",0.9698492462311558
87547,"/** 
 * Retry resetting caches in the rich input connection. When the editor can't be accessed we can't reset the caches, so we schedule a retry. This method handles the retry, and re-schedules a new retry if we still can't access. We only retry up to 5 times before giving up.
 * @param tryResumeSuggestions Whether we should resume suggestions or not.
 * @param remainingTries How many times we may try again before giving up.
 */
private void retryResetCaches(final boolean tryResumeSuggestions,final int remainingTries){
  if (!mConnection.resetCachesUponCursorMoveAndReturnSuccess(mLastSelectionStart,false)) {
    if (0 < remainingTries) {
      mHandler.postResetCaches(tryResumeSuggestions,remainingTries - 1);
    }
    return;
  }
  tryFixLyingCursorPosition();
  if (tryResumeSuggestions)   mHandler.postResumeSuggestions();
}","/** 
 * Retry resetting caches in the rich input connection. When the editor can't be accessed we can't reset the caches, so we schedule a retry. This method handles the retry, and re-schedules a new retry if we still can't access. We only retry up to 5 times before giving up.
 * @param tryResumeSuggestions Whether we should resume suggestions or not.
 * @param remainingTries How many times we may try again before giving up.
 */
private void retryResetCaches(final boolean tryResumeSuggestions,final int remainingTries){
  if (!mConnection.resetCachesUponCursorMoveAndReturnSuccess(mLastSelectionStart,false)) {
    if (0 < remainingTries) {
      mHandler.postResetCaches(tryResumeSuggestions,remainingTries - 1);
    }
    return;
  }
  tryFixLyingCursorPosition();
  mKeyboardSwitcher.updateShiftState();
  if (tryResumeSuggestions)   mHandler.postResumeSuggestions();
}",0.908984830805134
87548,"@Override public PtNodeInfo readPtNode(final int ptNodePos,final FormatOptions options){
  int addressPointer=ptNodePos;
  final int flags=PtNodeReader.readPtNodeOptionFlags(mDictBuffer);
  addressPointer+=FormatSpec.PTNODE_FLAGS_SIZE;
  final int parentAddress=PtNodeReader.readParentAddress(mDictBuffer,options);
  if (BinaryDictIOUtils.supportsDynamicUpdate(options)) {
    addressPointer+=FormatSpec.PARENT_ADDRESS_SIZE;
  }
  final int characters[];
  if (0 != (flags & FormatSpec.FLAG_HAS_MULTIPLE_CHARS)) {
    int index=0;
    int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    while (FormatSpec.INVALID_CHARACTER != character) {
      mCharacterBuffer[index++]=character;
      character=CharEncoding.readChar(mDictBuffer);
      addressPointer+=CharEncoding.getCharSize(character);
    }
    characters=Arrays.copyOfRange(mCharacterBuffer,0,index);
  }
 else {
    final int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    characters=new int[]{character};
  }
  final int frequency;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    frequency=PtNodeReader.readFrequency(mDictBuffer);
    addressPointer+=FormatSpec.PTNODE_FREQUENCY_SIZE;
  }
 else {
    frequency=PtNode.NOT_A_TERMINAL;
  }
  int childrenAddress=PtNodeReader.readChildrenAddress(mDictBuffer,flags,options);
  if (childrenAddress != FormatSpec.NO_CHILDREN_ADDRESS) {
    childrenAddress+=addressPointer;
  }
  addressPointer+=BinaryDictIOUtils.getChildrenAddressSize(flags,options);
  final ArrayList<WeightedString> shortcutTargets;
  if (0 != (flags & FormatSpec.FLAG_HAS_SHORTCUT_TARGETS)) {
    shortcutTargets=new ArrayList<WeightedString>();
    addressPointer+=PtNodeReader.readShortcut(mDictBuffer,shortcutTargets);
  }
 else {
    shortcutTargets=null;
  }
  final ArrayList<PendingAttribute> bigrams;
  if (0 != (flags & FormatSpec.FLAG_HAS_BIGRAMS)) {
    bigrams=new ArrayList<PendingAttribute>();
    addressPointer+=PtNodeReader.readBigramAddresses(mDictBuffer,bigrams,addressPointer);
    if (bigrams.size() >= FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      MakedictLog.d(""String_Node_Str"");
    }
  }
 else {
    bigrams=null;
  }
  return new PtNodeInfo(ptNodePos,addressPointer,flags,characters,frequency,parentAddress,childrenAddress,shortcutTargets,bigrams);
}","@Override public PtNodeInfo readPtNode(final int ptNodePos,final FormatOptions options){
  int addressPointer=ptNodePos;
  final int flags=PtNodeReader.readPtNodeOptionFlags(mDictBuffer);
  addressPointer+=FormatSpec.PTNODE_FLAGS_SIZE;
  final int parentAddress=PtNodeReader.readParentAddress(mDictBuffer,options);
  if (BinaryDictIOUtils.supportsDynamicUpdate(options)) {
    addressPointer+=FormatSpec.PARENT_ADDRESS_SIZE;
  }
  final int characters[];
  if (0 != (flags & FormatSpec.FLAG_HAS_MULTIPLE_CHARS)) {
    int index=0;
    int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    while (FormatSpec.INVALID_CHARACTER != character) {
      mCharacterBuffer[index++]=character;
      character=CharEncoding.readChar(mDictBuffer);
      addressPointer+=CharEncoding.getCharSize(character);
    }
    characters=Arrays.copyOfRange(mCharacterBuffer,0,index);
  }
 else {
    final int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    characters=new int[]{character};
  }
  final int frequency;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    frequency=PtNodeReader.readFrequency(mDictBuffer);
    addressPointer+=FormatSpec.PTNODE_FREQUENCY_SIZE;
  }
 else {
    frequency=PtNode.NOT_A_TERMINAL;
  }
  int childrenAddress=PtNodeReader.readChildrenAddress(mDictBuffer,flags,options);
  if (childrenAddress != FormatSpec.NO_CHILDREN_ADDRESS) {
    childrenAddress+=addressPointer;
  }
  addressPointer+=BinaryDictIOUtils.getChildrenAddressSize(flags,options);
  final ArrayList<WeightedString> shortcutTargets;
  if (0 != (flags & FormatSpec.FLAG_HAS_SHORTCUT_TARGETS)) {
    shortcutTargets=new ArrayList<WeightedString>();
    addressPointer+=PtNodeReader.readShortcut(mDictBuffer,shortcutTargets);
  }
 else {
    shortcutTargets=null;
  }
  final ArrayList<PendingAttribute> bigrams;
  if (0 != (flags & FormatSpec.FLAG_HAS_BIGRAMS)) {
    bigrams=new ArrayList<PendingAttribute>();
    addressPointer+=PtNodeReader.readBigramAddresses(mDictBuffer,bigrams,addressPointer);
    if (bigrams.size() >= FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      throw new RuntimeException(""String_Node_Str"" + bigrams.size() + ""String_Node_Str""+ FormatSpec.MAX_BIGRAMS_IN_A_PTNODE+ ""String_Node_Str"");
    }
  }
 else {
    bigrams=null;
  }
  return new PtNodeInfo(ptNodePos,addressPointer,flags,characters,frequency,parentAddress,childrenAddress,shortcutTargets,bigrams);
}",0.973050812590002
87549,"@Override public PtNodeInfo readPtNode(int ptNodePos,FormatOptions options){
  int addressPointer=ptNodePos;
  final int flags=PtNodeReader.readPtNodeOptionFlags(mDictBuffer);
  addressPointer+=FormatSpec.PTNODE_FLAGS_SIZE;
  final int parentAddress=PtNodeReader.readParentAddress(mDictBuffer,options);
  if (BinaryDictIOUtils.supportsDynamicUpdate(options)) {
    addressPointer+=FormatSpec.PARENT_ADDRESS_SIZE;
  }
  final int characters[];
  if (0 != (flags & FormatSpec.FLAG_HAS_MULTIPLE_CHARS)) {
    int index=0;
    int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    while (FormatSpec.INVALID_CHARACTER != character && index < FormatSpec.MAX_WORD_LENGTH) {
      mCharacterBuffer[index++]=character;
      character=CharEncoding.readChar(mDictBuffer);
      addressPointer+=CharEncoding.getCharSize(character);
    }
    characters=Arrays.copyOfRange(mCharacterBuffer,0,index);
  }
 else {
    final int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    characters=new int[]{character};
  }
  final int terminalId;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    terminalId=PtNodeReader.readTerminalId(mDictBuffer);
    addressPointer+=FormatSpec.PTNODE_TERMINAL_ID_SIZE;
  }
 else {
    terminalId=PtNode.NOT_A_TERMINAL;
  }
  final int frequency;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    frequency=PtNodeReader.readFrequency(mFrequencyBuffer,terminalId);
  }
 else {
    frequency=PtNode.NOT_A_TERMINAL;
  }
  int childrenAddress=PtNodeReader.readChildrenAddress(mDictBuffer,flags,options);
  if (childrenAddress != FormatSpec.NO_CHILDREN_ADDRESS) {
    childrenAddress+=addressPointer;
  }
  addressPointer+=BinaryDictIOUtils.getChildrenAddressSize(flags,options);
  final ArrayList<WeightedString> shortcutTargets;
  if (0 != (flags & FormatSpec.FLAG_HAS_SHORTCUT_TARGETS)) {
    shortcutTargets=new ArrayList<WeightedString>();
    addressPointer+=PtNodeReader.readShortcut(mDictBuffer,shortcutTargets);
  }
 else {
    shortcutTargets=null;
  }
  final ArrayList<PendingAttribute> bigrams;
  if (0 != (flags & FormatSpec.FLAG_HAS_BIGRAMS)) {
    bigrams=new ArrayList<PendingAttribute>();
    final int posOfBigrams=mBigramAddressTable.get(terminalId);
    mBigramBuffer.position(posOfBigrams);
    while (bigrams.size() < FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      final int bigramFlags=mBigramBuffer.readUnsignedByte();
      final int targetTerminalId=mBigramBuffer.readUnsignedInt24();
      mTerminalAddressTableBuffer.position(targetTerminalId * FormatSpec.TERMINAL_ADDRESS_TABLE_ADDRESS_SIZE);
      final int targetAddress=mTerminalAddressTableBuffer.readUnsignedInt24();
      bigrams.add(new PendingAttribute(bigramFlags & FormatSpec.FLAG_BIGRAM_SHORTCUT_ATTR_FREQUENCY,targetAddress));
      if (0 == (bigramFlags & FormatSpec.FLAG_BIGRAM_SHORTCUT_ATTR_HAS_NEXT))       break;
    }
    if (bigrams.size() >= FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      MakedictLog.d(""String_Node_Str"");
    }
  }
 else {
    bigrams=null;
  }
  return new PtNodeInfo(ptNodePos,addressPointer,flags,characters,frequency,parentAddress,childrenAddress,shortcutTargets,bigrams);
}","@Override public PtNodeInfo readPtNode(int ptNodePos,FormatOptions options){
  int addressPointer=ptNodePos;
  final int flags=PtNodeReader.readPtNodeOptionFlags(mDictBuffer);
  addressPointer+=FormatSpec.PTNODE_FLAGS_SIZE;
  final int parentAddress=PtNodeReader.readParentAddress(mDictBuffer,options);
  if (BinaryDictIOUtils.supportsDynamicUpdate(options)) {
    addressPointer+=FormatSpec.PARENT_ADDRESS_SIZE;
  }
  final int characters[];
  if (0 != (flags & FormatSpec.FLAG_HAS_MULTIPLE_CHARS)) {
    int index=0;
    int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    while (FormatSpec.INVALID_CHARACTER != character && index < FormatSpec.MAX_WORD_LENGTH) {
      mCharacterBuffer[index++]=character;
      character=CharEncoding.readChar(mDictBuffer);
      addressPointer+=CharEncoding.getCharSize(character);
    }
    characters=Arrays.copyOfRange(mCharacterBuffer,0,index);
  }
 else {
    final int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    characters=new int[]{character};
  }
  final int terminalId;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    terminalId=PtNodeReader.readTerminalId(mDictBuffer);
    addressPointer+=FormatSpec.PTNODE_TERMINAL_ID_SIZE;
  }
 else {
    terminalId=PtNode.NOT_A_TERMINAL;
  }
  final int frequency;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    frequency=PtNodeReader.readFrequency(mFrequencyBuffer,terminalId);
  }
 else {
    frequency=PtNode.NOT_A_TERMINAL;
  }
  int childrenAddress=PtNodeReader.readChildrenAddress(mDictBuffer,flags,options);
  if (childrenAddress != FormatSpec.NO_CHILDREN_ADDRESS) {
    childrenAddress+=addressPointer;
  }
  addressPointer+=BinaryDictIOUtils.getChildrenAddressSize(flags,options);
  final ArrayList<WeightedString> shortcutTargets;
  if (0 != (flags & FormatSpec.FLAG_HAS_SHORTCUT_TARGETS)) {
    shortcutTargets=new ArrayList<WeightedString>();
    addressPointer+=PtNodeReader.readShortcut(mDictBuffer,shortcutTargets);
  }
 else {
    shortcutTargets=null;
  }
  final ArrayList<PendingAttribute> bigrams;
  if (0 != (flags & FormatSpec.FLAG_HAS_BIGRAMS)) {
    bigrams=new ArrayList<PendingAttribute>();
    final int posOfBigrams=mBigramAddressTable.get(terminalId);
    mBigramBuffer.position(posOfBigrams);
    while (bigrams.size() < FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      final int bigramFlags=mBigramBuffer.readUnsignedByte();
      final int targetTerminalId=mBigramBuffer.readUnsignedInt24();
      mTerminalAddressTableBuffer.position(targetTerminalId * FormatSpec.TERMINAL_ADDRESS_TABLE_ADDRESS_SIZE);
      final int targetAddress=mTerminalAddressTableBuffer.readUnsignedInt24();
      bigrams.add(new PendingAttribute(bigramFlags & FormatSpec.FLAG_BIGRAM_SHORTCUT_ATTR_FREQUENCY,targetAddress));
      if (0 == (bigramFlags & FormatSpec.FLAG_BIGRAM_SHORTCUT_ATTR_HAS_NEXT))       break;
    }
    if (bigrams.size() >= FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      throw new RuntimeException(""String_Node_Str"" + bigrams.size() + ""String_Node_Str""+ FormatSpec.MAX_BIGRAMS_IN_A_PTNODE+ ""String_Node_Str"");
    }
  }
 else {
    bigrams=null;
  }
  return new PtNodeInfo(ptNodePos,addressPointer,flags,characters,frequency,parentAddress,childrenAddress,shortcutTargets,bigrams);
}",0.9800152555301296
87550,"public BinaryDictDecoderEncoderTests(final long seed,final int maxUnigrams){
  super();
  Log.e(TAG,""String_Node_Str"" + seed);
  final Random random=new Random(seed);
  sWords.clear();
  final int[] codePointSet=CodePointUtils.generateCodePointSet(DEFAULT_CODE_POINT_SET_SIZE,random);
  generateWords(maxUnigrams,random,codePointSet);
  for (int i=0; i < sWords.size(); ++i) {
    sChainBigrams.put(i,new ArrayList<Integer>());
    if (i > 0) {
      sChainBigrams.get(i - 1).add(i);
    }
  }
  sStarBigrams.put(0,new ArrayList<Integer>());
  for (int i=1; i < sWords.size(); ++i) {
    sStarBigrams.get(0).add(i);
  }
  sShortcuts.clear();
  for (int i=0; i < NUM_OF_NODES_HAVING_SHORTCUTS; ++i) {
    final int from=Math.abs(random.nextInt()) % sWords.size();
    sShortcuts.put(sWords.get(from),new ArrayList<String>());
    for (int j=0; j < NUM_OF_SHORTCUTS; ++j) {
      final int to=Math.abs(random.nextInt()) % sWords.size();
      sShortcuts.get(sWords.get(from)).add(sWords.get(to));
    }
  }
}","public BinaryDictDecoderEncoderTests(final long seed,final int maxUnigrams){
  super();
  Log.e(TAG,""String_Node_Str"" + seed);
  final Random random=new Random(seed);
  sWords.clear();
  final int[] codePointSet=CodePointUtils.generateCodePointSet(DEFAULT_CODE_POINT_SET_SIZE,random);
  generateWords(maxUnigrams,random,codePointSet);
  for (int i=0; i < sWords.size(); ++i) {
    sChainBigrams.put(i,new ArrayList<Integer>());
    if (i > 0) {
      sChainBigrams.get(i - 1).add(i);
    }
  }
  sStarBigrams.put(0,new ArrayList<Integer>());
  final int maxBigrams=Math.min(sWords.size(),FormatSpec.MAX_BIGRAMS_IN_A_PTNODE - 1);
  for (int i=1; i < maxBigrams; ++i) {
    sStarBigrams.get(0).add(i);
  }
  sShortcuts.clear();
  for (int i=0; i < NUM_OF_NODES_HAVING_SHORTCUTS; ++i) {
    final int from=Math.abs(random.nextInt()) % sWords.size();
    sShortcuts.put(sWords.get(from),new ArrayList<String>());
    for (int j=0; j < NUM_OF_SHORTCUTS; ++j) {
      final int to=Math.abs(random.nextInt()) % sWords.size();
      sShortcuts.get(sWords.get(from)).add(sWords.get(to));
    }
  }
}",0.9475190839694656
87551,"private void updateBatchInput(final long eventTime){
synchronized (sAggregratedPointers) {
    final GestureStroke stroke=mGestureStrokeWithPreviewPoints;
    stroke.appendIncrementalBatchPoints(sAggregratedPointers);
    final int size=sAggregratedPointers.getPointerSize();
    if (size > sLastRecognitionPointSize && stroke.hasRecognitionTimePast(eventTime,sLastRecognitionTime)) {
      sLastRecognitionPointSize=size;
      sLastRecognitionTime=eventTime;
      if (DEBUG_LISTENER) {
        Log.d(TAG,String.format(""String_Node_Str"",mPointerId,size));
      }
      mTimerProxy.startUpdateBatchInputTimer(this);
      mListener.onUpdateBatchInput(sAggregratedPointers);
    }
  }
}","private void updateBatchInput(final long eventTime){
synchronized (sAggregratedPointers) {
    final GestureStroke stroke=mGestureStrokeWithPreviewPoints;
    stroke.appendIncrementalBatchPoints(sAggregratedPointers);
    final int size=sAggregratedPointers.getPointerSize();
    if (size > sLastRecognitionPointSize && stroke.hasRecognitionTimePast(eventTime,sLastRecognitionTime)) {
      if (DEBUG_LISTENER) {
        Log.d(TAG,String.format(""String_Node_Str"",mPointerId,size));
      }
      mTimerProxy.startUpdateBatchInputTimer(this);
      mListener.onUpdateBatchInput(sAggregratedPointers);
      sLastRecognitionPointSize=sAggregratedPointers.getPointerSize();
      sLastRecognitionTime=eventTime;
    }
  }
}",0.8685145700071073
87552,"@Override public PtNodeInfo readPtNode(final int ptNodePos,final FormatOptions options){
  int addressPointer=ptNodePos;
  final int flags=PtNodeReader.readPtNodeOptionFlags(mDictBuffer);
  addressPointer+=FormatSpec.PTNODE_FLAGS_SIZE;
  final int parentAddress=PtNodeReader.readParentAddress(mDictBuffer,options);
  if (BinaryDictIOUtils.supportsDynamicUpdate(options)) {
    addressPointer+=FormatSpec.PARENT_ADDRESS_SIZE;
  }
  final int characters[];
  if (0 != (flags & FormatSpec.FLAG_HAS_MULTIPLE_CHARS)) {
    int index=0;
    int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    while (FormatSpec.INVALID_CHARACTER != character) {
      mCharacterBuffer[index++]=character;
      character=CharEncoding.readChar(mDictBuffer);
      addressPointer+=CharEncoding.getCharSize(character);
    }
    characters=Arrays.copyOfRange(mCharacterBuffer,0,index);
  }
 else {
    final int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    characters=new int[]{character};
  }
  final int frequency;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    frequency=PtNodeReader.readFrequency(mDictBuffer);
    addressPointer+=FormatSpec.PTNODE_FREQUENCY_SIZE;
  }
 else {
    frequency=PtNode.NOT_A_TERMINAL;
  }
  int childrenAddress=PtNodeReader.readChildrenAddress(mDictBuffer,flags,options);
  if (childrenAddress != FormatSpec.NO_CHILDREN_ADDRESS) {
    childrenAddress+=addressPointer;
  }
  addressPointer+=BinaryDictIOUtils.getChildrenAddressSize(flags,options);
  final ArrayList<WeightedString> shortcutTargets;
  if (0 != (flags & FormatSpec.FLAG_HAS_SHORTCUT_TARGETS)) {
    shortcutTargets=new ArrayList<WeightedString>();
    addressPointer+=PtNodeReader.readShortcut(mDictBuffer,shortcutTargets);
  }
 else {
    shortcutTargets=null;
  }
  final ArrayList<PendingAttribute> bigrams;
  if (0 != (flags & FormatSpec.FLAG_HAS_BIGRAMS)) {
    bigrams=new ArrayList<PendingAttribute>();
    addressPointer+=PtNodeReader.readBigramAddresses(mDictBuffer,bigrams,addressPointer);
    if (bigrams.size() >= FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      MakedictLog.d(""String_Node_Str"");
    }
  }
 else {
    bigrams=null;
  }
  return new PtNodeInfo(ptNodePos,addressPointer,flags,characters,frequency,parentAddress,childrenAddress,shortcutTargets,bigrams);
}","@Override public PtNodeInfo readPtNode(final int ptNodePos,final FormatOptions options){
  int addressPointer=ptNodePos;
  final int flags=PtNodeReader.readPtNodeOptionFlags(mDictBuffer);
  addressPointer+=FormatSpec.PTNODE_FLAGS_SIZE;
  final int parentAddress=PtNodeReader.readParentAddress(mDictBuffer,options);
  if (BinaryDictIOUtils.supportsDynamicUpdate(options)) {
    addressPointer+=FormatSpec.PARENT_ADDRESS_SIZE;
  }
  final int characters[];
  if (0 != (flags & FormatSpec.FLAG_HAS_MULTIPLE_CHARS)) {
    int index=0;
    int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    while (FormatSpec.INVALID_CHARACTER != character) {
      mCharacterBuffer[index++]=character;
      character=CharEncoding.readChar(mDictBuffer);
      addressPointer+=CharEncoding.getCharSize(character);
    }
    characters=Arrays.copyOfRange(mCharacterBuffer,0,index);
  }
 else {
    final int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    characters=new int[]{character};
  }
  final int frequency;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    frequency=PtNodeReader.readFrequency(mDictBuffer);
    addressPointer+=FormatSpec.PTNODE_FREQUENCY_SIZE;
  }
 else {
    frequency=PtNode.NOT_A_TERMINAL;
  }
  int childrenAddress=PtNodeReader.readChildrenAddress(mDictBuffer,flags,options);
  if (childrenAddress != FormatSpec.NO_CHILDREN_ADDRESS) {
    childrenAddress+=addressPointer;
  }
  addressPointer+=BinaryDictIOUtils.getChildrenAddressSize(flags,options);
  final ArrayList<WeightedString> shortcutTargets;
  if (0 != (flags & FormatSpec.FLAG_HAS_SHORTCUT_TARGETS)) {
    shortcutTargets=new ArrayList<WeightedString>();
    addressPointer+=PtNodeReader.readShortcut(mDictBuffer,shortcutTargets);
  }
 else {
    shortcutTargets=null;
  }
  final ArrayList<PendingAttribute> bigrams;
  if (0 != (flags & FormatSpec.FLAG_HAS_BIGRAMS)) {
    bigrams=new ArrayList<PendingAttribute>();
    addressPointer+=PtNodeReader.readBigramAddresses(mDictBuffer,bigrams,addressPointer);
    if (bigrams.size() >= FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      throw new RuntimeException(""String_Node_Str"" + bigrams.size() + ""String_Node_Str""+ FormatSpec.MAX_BIGRAMS_IN_A_PTNODE+ ""String_Node_Str"");
    }
  }
 else {
    bigrams=null;
  }
  return new PtNodeInfo(ptNodePos,addressPointer,flags,characters,frequency,parentAddress,childrenAddress,shortcutTargets,bigrams);
}",0.973050812590002
87553,"@Override public PtNodeInfo readPtNode(int ptNodePos,FormatOptions options){
  int addressPointer=ptNodePos;
  final int flags=PtNodeReader.readPtNodeOptionFlags(mDictBuffer);
  addressPointer+=FormatSpec.PTNODE_FLAGS_SIZE;
  final int parentAddress=PtNodeReader.readParentAddress(mDictBuffer,options);
  if (BinaryDictIOUtils.supportsDynamicUpdate(options)) {
    addressPointer+=FormatSpec.PARENT_ADDRESS_SIZE;
  }
  final int characters[];
  if (0 != (flags & FormatSpec.FLAG_HAS_MULTIPLE_CHARS)) {
    int index=0;
    int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    while (FormatSpec.INVALID_CHARACTER != character && index < FormatSpec.MAX_WORD_LENGTH) {
      mCharacterBuffer[index++]=character;
      character=CharEncoding.readChar(mDictBuffer);
      addressPointer+=CharEncoding.getCharSize(character);
    }
    characters=Arrays.copyOfRange(mCharacterBuffer,0,index);
  }
 else {
    final int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    characters=new int[]{character};
  }
  final int terminalId;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    terminalId=PtNodeReader.readTerminalId(mDictBuffer);
    addressPointer+=FormatSpec.PTNODE_TERMINAL_ID_SIZE;
  }
 else {
    terminalId=PtNode.NOT_A_TERMINAL;
  }
  final int frequency;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    frequency=PtNodeReader.readFrequency(mFrequencyBuffer,terminalId);
  }
 else {
    frequency=PtNode.NOT_A_TERMINAL;
  }
  int childrenAddress=PtNodeReader.readChildrenAddress(mDictBuffer,flags,options);
  if (childrenAddress != FormatSpec.NO_CHILDREN_ADDRESS) {
    childrenAddress+=addressPointer;
  }
  addressPointer+=BinaryDictIOUtils.getChildrenAddressSize(flags,options);
  final ArrayList<WeightedString> shortcutTargets;
  if (0 != (flags & FormatSpec.FLAG_HAS_SHORTCUT_TARGETS)) {
    shortcutTargets=new ArrayList<WeightedString>();
    addressPointer+=PtNodeReader.readShortcut(mDictBuffer,shortcutTargets);
  }
 else {
    shortcutTargets=null;
  }
  final ArrayList<PendingAttribute> bigrams;
  if (0 != (flags & FormatSpec.FLAG_HAS_BIGRAMS)) {
    bigrams=new ArrayList<PendingAttribute>();
    final int posOfBigrams=mBigramAddressTable.get(terminalId);
    mBigramBuffer.position(posOfBigrams);
    while (bigrams.size() < FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      final int bigramFlags=mBigramBuffer.readUnsignedByte();
      final int targetTerminalId=mBigramBuffer.readUnsignedInt24();
      mTerminalAddressTableBuffer.position(targetTerminalId * FormatSpec.TERMINAL_ADDRESS_TABLE_ADDRESS_SIZE);
      final int targetAddress=mTerminalAddressTableBuffer.readUnsignedInt24();
      bigrams.add(new PendingAttribute(bigramFlags & FormatSpec.FLAG_BIGRAM_SHORTCUT_ATTR_FREQUENCY,targetAddress));
      if (0 == (bigramFlags & FormatSpec.FLAG_BIGRAM_SHORTCUT_ATTR_HAS_NEXT))       break;
    }
    if (bigrams.size() >= FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      MakedictLog.d(""String_Node_Str"");
    }
  }
 else {
    bigrams=null;
  }
  return new PtNodeInfo(ptNodePos,addressPointer,flags,characters,frequency,parentAddress,childrenAddress,shortcutTargets,bigrams);
}","@Override public PtNodeInfo readPtNode(int ptNodePos,FormatOptions options){
  int addressPointer=ptNodePos;
  final int flags=PtNodeReader.readPtNodeOptionFlags(mDictBuffer);
  addressPointer+=FormatSpec.PTNODE_FLAGS_SIZE;
  final int parentAddress=PtNodeReader.readParentAddress(mDictBuffer,options);
  if (BinaryDictIOUtils.supportsDynamicUpdate(options)) {
    addressPointer+=FormatSpec.PARENT_ADDRESS_SIZE;
  }
  final int characters[];
  if (0 != (flags & FormatSpec.FLAG_HAS_MULTIPLE_CHARS)) {
    int index=0;
    int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    while (FormatSpec.INVALID_CHARACTER != character && index < FormatSpec.MAX_WORD_LENGTH) {
      mCharacterBuffer[index++]=character;
      character=CharEncoding.readChar(mDictBuffer);
      addressPointer+=CharEncoding.getCharSize(character);
    }
    characters=Arrays.copyOfRange(mCharacterBuffer,0,index);
  }
 else {
    final int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    characters=new int[]{character};
  }
  final int terminalId;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    terminalId=PtNodeReader.readTerminalId(mDictBuffer);
    addressPointer+=FormatSpec.PTNODE_TERMINAL_ID_SIZE;
  }
 else {
    terminalId=PtNode.NOT_A_TERMINAL;
  }
  final int frequency;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    frequency=PtNodeReader.readFrequency(mFrequencyBuffer,terminalId);
  }
 else {
    frequency=PtNode.NOT_A_TERMINAL;
  }
  int childrenAddress=PtNodeReader.readChildrenAddress(mDictBuffer,flags,options);
  if (childrenAddress != FormatSpec.NO_CHILDREN_ADDRESS) {
    childrenAddress+=addressPointer;
  }
  addressPointer+=BinaryDictIOUtils.getChildrenAddressSize(flags,options);
  final ArrayList<WeightedString> shortcutTargets;
  if (0 != (flags & FormatSpec.FLAG_HAS_SHORTCUT_TARGETS)) {
    shortcutTargets=new ArrayList<WeightedString>();
    addressPointer+=PtNodeReader.readShortcut(mDictBuffer,shortcutTargets);
  }
 else {
    shortcutTargets=null;
  }
  final ArrayList<PendingAttribute> bigrams;
  if (0 != (flags & FormatSpec.FLAG_HAS_BIGRAMS)) {
    bigrams=new ArrayList<PendingAttribute>();
    final int posOfBigrams=mBigramAddressTable.get(terminalId);
    mBigramBuffer.position(posOfBigrams);
    while (bigrams.size() < FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      final int bigramFlags=mBigramBuffer.readUnsignedByte();
      final int targetTerminalId=mBigramBuffer.readUnsignedInt24();
      mTerminalAddressTableBuffer.position(targetTerminalId * FormatSpec.TERMINAL_ADDRESS_TABLE_ADDRESS_SIZE);
      final int targetAddress=mTerminalAddressTableBuffer.readUnsignedInt24();
      bigrams.add(new PendingAttribute(bigramFlags & FormatSpec.FLAG_BIGRAM_SHORTCUT_ATTR_FREQUENCY,targetAddress));
      if (0 == (bigramFlags & FormatSpec.FLAG_BIGRAM_SHORTCUT_ATTR_HAS_NEXT))       break;
    }
    if (bigrams.size() >= FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      throw new RuntimeException(""String_Node_Str"" + bigrams.size() + ""String_Node_Str""+ FormatSpec.MAX_BIGRAMS_IN_A_PTNODE+ ""String_Node_Str"");
    }
  }
 else {
    bigrams=null;
  }
  return new PtNodeInfo(ptNodePos,addressPointer,flags,characters,frequency,parentAddress,childrenAddress,shortcutTargets,bigrams);
}",0.9800152555301296
87554,"public BinaryDictDecoderEncoderTests(final long seed,final int maxUnigrams){
  super();
  Log.e(TAG,""String_Node_Str"" + seed);
  final Random random=new Random(seed);
  sWords.clear();
  final int[] codePointSet=CodePointUtils.generateCodePointSet(DEFAULT_CODE_POINT_SET_SIZE,random);
  generateWords(maxUnigrams,random,codePointSet);
  for (int i=0; i < sWords.size(); ++i) {
    sChainBigrams.put(i,new ArrayList<Integer>());
    if (i > 0) {
      sChainBigrams.get(i - 1).add(i);
    }
  }
  sStarBigrams.put(0,new ArrayList<Integer>());
  for (int i=1; i < sWords.size(); ++i) {
    sStarBigrams.get(0).add(i);
  }
  sShortcuts.clear();
  for (int i=0; i < NUM_OF_NODES_HAVING_SHORTCUTS; ++i) {
    final int from=Math.abs(random.nextInt()) % sWords.size();
    sShortcuts.put(sWords.get(from),new ArrayList<String>());
    for (int j=0; j < NUM_OF_SHORTCUTS; ++j) {
      final int to=Math.abs(random.nextInt()) % sWords.size();
      sShortcuts.get(sWords.get(from)).add(sWords.get(to));
    }
  }
}","public BinaryDictDecoderEncoderTests(final long seed,final int maxUnigrams){
  super();
  Log.e(TAG,""String_Node_Str"" + seed);
  final Random random=new Random(seed);
  sWords.clear();
  final int[] codePointSet=CodePointUtils.generateCodePointSet(DEFAULT_CODE_POINT_SET_SIZE,random);
  generateWords(maxUnigrams,random,codePointSet);
  for (int i=0; i < sWords.size(); ++i) {
    sChainBigrams.put(i,new ArrayList<Integer>());
    if (i > 0) {
      sChainBigrams.get(i - 1).add(i);
    }
  }
  sStarBigrams.put(0,new ArrayList<Integer>());
  final int maxBigrams=Math.min(sWords.size(),FormatSpec.MAX_BIGRAMS_IN_A_PTNODE - 1);
  for (int i=1; i < maxBigrams; ++i) {
    sStarBigrams.get(0).add(i);
  }
  sShortcuts.clear();
  for (int i=0; i < NUM_OF_NODES_HAVING_SHORTCUTS; ++i) {
    final int from=Math.abs(random.nextInt()) % sWords.size();
    sShortcuts.put(sWords.get(from),new ArrayList<String>());
    for (int j=0; j < NUM_OF_SHORTCUTS; ++j) {
      final int to=Math.abs(random.nextInt()) % sWords.size();
      sShortcuts.get(sWords.get(from)).add(sWords.get(to));
    }
  }
}",0.9475190839694656
87555,"@Override public PtNodeInfo readPtNode(final int ptNodePos,final FormatOptions options){
  int addressPointer=ptNodePos;
  final int flags=PtNodeReader.readPtNodeOptionFlags(mDictBuffer);
  addressPointer+=FormatSpec.PTNODE_FLAGS_SIZE;
  final int parentAddress=PtNodeReader.readParentAddress(mDictBuffer,options);
  if (BinaryDictIOUtils.supportsDynamicUpdate(options)) {
    addressPointer+=FormatSpec.PARENT_ADDRESS_SIZE;
  }
  final int characters[];
  if (0 != (flags & FormatSpec.FLAG_HAS_MULTIPLE_CHARS)) {
    int index=0;
    int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    while (FormatSpec.INVALID_CHARACTER != character) {
      mCharacterBuffer[index++]=character;
      character=CharEncoding.readChar(mDictBuffer);
      addressPointer+=CharEncoding.getCharSize(character);
    }
    characters=Arrays.copyOfRange(mCharacterBuffer,0,index);
  }
 else {
    final int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    characters=new int[]{character};
  }
  final int frequency;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    frequency=PtNodeReader.readFrequency(mDictBuffer);
    addressPointer+=FormatSpec.PTNODE_FREQUENCY_SIZE;
  }
 else {
    frequency=PtNode.NOT_A_TERMINAL;
  }
  int childrenAddress=PtNodeReader.readChildrenAddress(mDictBuffer,flags,options);
  if (childrenAddress != FormatSpec.NO_CHILDREN_ADDRESS) {
    childrenAddress+=addressPointer;
  }
  addressPointer+=BinaryDictIOUtils.getChildrenAddressSize(flags,options);
  final ArrayList<WeightedString> shortcutTargets;
  if (0 != (flags & FormatSpec.FLAG_HAS_SHORTCUT_TARGETS)) {
    shortcutTargets=new ArrayList<WeightedString>();
    addressPointer+=PtNodeReader.readShortcut(mDictBuffer,shortcutTargets);
  }
 else {
    shortcutTargets=null;
  }
  final ArrayList<PendingAttribute> bigrams;
  if (0 != (flags & FormatSpec.FLAG_HAS_BIGRAMS)) {
    bigrams=new ArrayList<PendingAttribute>();
    addressPointer+=PtNodeReader.readBigramAddresses(mDictBuffer,bigrams,addressPointer);
    if (bigrams.size() >= FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      MakedictLog.d(""String_Node_Str"");
    }
  }
 else {
    bigrams=null;
  }
  return new PtNodeInfo(ptNodePos,addressPointer,flags,characters,frequency,parentAddress,childrenAddress,shortcutTargets,bigrams);
}","@Override public PtNodeInfo readPtNode(final int ptNodePos,final FormatOptions options){
  int addressPointer=ptNodePos;
  final int flags=PtNodeReader.readPtNodeOptionFlags(mDictBuffer);
  addressPointer+=FormatSpec.PTNODE_FLAGS_SIZE;
  final int parentAddress=PtNodeReader.readParentAddress(mDictBuffer,options);
  if (BinaryDictIOUtils.supportsDynamicUpdate(options)) {
    addressPointer+=FormatSpec.PARENT_ADDRESS_SIZE;
  }
  final int characters[];
  if (0 != (flags & FormatSpec.FLAG_HAS_MULTIPLE_CHARS)) {
    int index=0;
    int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    while (FormatSpec.INVALID_CHARACTER != character) {
      mCharacterBuffer[index++]=character;
      character=CharEncoding.readChar(mDictBuffer);
      addressPointer+=CharEncoding.getCharSize(character);
    }
    characters=Arrays.copyOfRange(mCharacterBuffer,0,index);
  }
 else {
    final int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    characters=new int[]{character};
  }
  final int frequency;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    frequency=PtNodeReader.readFrequency(mDictBuffer);
    addressPointer+=FormatSpec.PTNODE_FREQUENCY_SIZE;
  }
 else {
    frequency=PtNode.NOT_A_TERMINAL;
  }
  int childrenAddress=PtNodeReader.readChildrenAddress(mDictBuffer,flags,options);
  if (childrenAddress != FormatSpec.NO_CHILDREN_ADDRESS) {
    childrenAddress+=addressPointer;
  }
  addressPointer+=BinaryDictIOUtils.getChildrenAddressSize(flags,options);
  final ArrayList<WeightedString> shortcutTargets;
  if (0 != (flags & FormatSpec.FLAG_HAS_SHORTCUT_TARGETS)) {
    shortcutTargets=new ArrayList<WeightedString>();
    addressPointer+=PtNodeReader.readShortcut(mDictBuffer,shortcutTargets);
  }
 else {
    shortcutTargets=null;
  }
  final ArrayList<PendingAttribute> bigrams;
  if (0 != (flags & FormatSpec.FLAG_HAS_BIGRAMS)) {
    bigrams=new ArrayList<PendingAttribute>();
    addressPointer+=PtNodeReader.readBigramAddresses(mDictBuffer,bigrams,addressPointer);
    if (bigrams.size() >= FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      throw new RuntimeException(""String_Node_Str"" + bigrams.size() + ""String_Node_Str""+ FormatSpec.MAX_BIGRAMS_IN_A_PTNODE+ ""String_Node_Str"");
    }
  }
 else {
    bigrams=null;
  }
  return new PtNodeInfo(ptNodePos,addressPointer,flags,characters,frequency,parentAddress,childrenAddress,shortcutTargets,bigrams);
}",0.973050812590002
87556,"@Override public PtNodeInfo readPtNode(int ptNodePos,FormatOptions options){
  int addressPointer=ptNodePos;
  final int flags=PtNodeReader.readPtNodeOptionFlags(mDictBuffer);
  addressPointer+=FormatSpec.PTNODE_FLAGS_SIZE;
  final int parentAddress=PtNodeReader.readParentAddress(mDictBuffer,options);
  if (BinaryDictIOUtils.supportsDynamicUpdate(options)) {
    addressPointer+=FormatSpec.PARENT_ADDRESS_SIZE;
  }
  final int characters[];
  if (0 != (flags & FormatSpec.FLAG_HAS_MULTIPLE_CHARS)) {
    int index=0;
    int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    while (FormatSpec.INVALID_CHARACTER != character && index < FormatSpec.MAX_WORD_LENGTH) {
      mCharacterBuffer[index++]=character;
      character=CharEncoding.readChar(mDictBuffer);
      addressPointer+=CharEncoding.getCharSize(character);
    }
    characters=Arrays.copyOfRange(mCharacterBuffer,0,index);
  }
 else {
    final int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    characters=new int[]{character};
  }
  final int terminalId;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    terminalId=PtNodeReader.readTerminalId(mDictBuffer);
    addressPointer+=FormatSpec.PTNODE_TERMINAL_ID_SIZE;
  }
 else {
    terminalId=PtNode.NOT_A_TERMINAL;
  }
  final int frequency;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    frequency=PtNodeReader.readFrequency(mFrequencyBuffer,terminalId);
  }
 else {
    frequency=PtNode.NOT_A_TERMINAL;
  }
  int childrenAddress=PtNodeReader.readChildrenAddress(mDictBuffer,flags,options);
  if (childrenAddress != FormatSpec.NO_CHILDREN_ADDRESS) {
    childrenAddress+=addressPointer;
  }
  addressPointer+=BinaryDictIOUtils.getChildrenAddressSize(flags,options);
  final ArrayList<WeightedString> shortcutTargets;
  if (0 != (flags & FormatSpec.FLAG_HAS_SHORTCUT_TARGETS)) {
    shortcutTargets=new ArrayList<WeightedString>();
    addressPointer+=PtNodeReader.readShortcut(mDictBuffer,shortcutTargets);
  }
 else {
    shortcutTargets=null;
  }
  final ArrayList<PendingAttribute> bigrams;
  if (0 != (flags & FormatSpec.FLAG_HAS_BIGRAMS)) {
    bigrams=new ArrayList<PendingAttribute>();
    final int posOfBigrams=mBigramAddressTable.get(terminalId);
    mBigramBuffer.position(posOfBigrams);
    while (bigrams.size() < FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      final int bigramFlags=mBigramBuffer.readUnsignedByte();
      final int targetTerminalId=mBigramBuffer.readUnsignedInt24();
      mTerminalAddressTableBuffer.position(targetTerminalId * FormatSpec.TERMINAL_ADDRESS_TABLE_ADDRESS_SIZE);
      final int targetAddress=mTerminalAddressTableBuffer.readUnsignedInt24();
      bigrams.add(new PendingAttribute(bigramFlags & FormatSpec.FLAG_BIGRAM_SHORTCUT_ATTR_FREQUENCY,targetAddress));
      if (0 == (bigramFlags & FormatSpec.FLAG_BIGRAM_SHORTCUT_ATTR_HAS_NEXT))       break;
    }
    if (bigrams.size() >= FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      MakedictLog.d(""String_Node_Str"");
    }
  }
 else {
    bigrams=null;
  }
  return new PtNodeInfo(ptNodePos,addressPointer,flags,characters,frequency,parentAddress,childrenAddress,shortcutTargets,bigrams);
}","@Override public PtNodeInfo readPtNode(int ptNodePos,FormatOptions options){
  int addressPointer=ptNodePos;
  final int flags=PtNodeReader.readPtNodeOptionFlags(mDictBuffer);
  addressPointer+=FormatSpec.PTNODE_FLAGS_SIZE;
  final int parentAddress=PtNodeReader.readParentAddress(mDictBuffer,options);
  if (BinaryDictIOUtils.supportsDynamicUpdate(options)) {
    addressPointer+=FormatSpec.PARENT_ADDRESS_SIZE;
  }
  final int characters[];
  if (0 != (flags & FormatSpec.FLAG_HAS_MULTIPLE_CHARS)) {
    int index=0;
    int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    while (FormatSpec.INVALID_CHARACTER != character && index < FormatSpec.MAX_WORD_LENGTH) {
      mCharacterBuffer[index++]=character;
      character=CharEncoding.readChar(mDictBuffer);
      addressPointer+=CharEncoding.getCharSize(character);
    }
    characters=Arrays.copyOfRange(mCharacterBuffer,0,index);
  }
 else {
    final int character=CharEncoding.readChar(mDictBuffer);
    addressPointer+=CharEncoding.getCharSize(character);
    characters=new int[]{character};
  }
  final int terminalId;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    terminalId=PtNodeReader.readTerminalId(mDictBuffer);
    addressPointer+=FormatSpec.PTNODE_TERMINAL_ID_SIZE;
  }
 else {
    terminalId=PtNode.NOT_A_TERMINAL;
  }
  final int frequency;
  if (0 != (FormatSpec.FLAG_IS_TERMINAL & flags)) {
    frequency=PtNodeReader.readFrequency(mFrequencyBuffer,terminalId);
  }
 else {
    frequency=PtNode.NOT_A_TERMINAL;
  }
  int childrenAddress=PtNodeReader.readChildrenAddress(mDictBuffer,flags,options);
  if (childrenAddress != FormatSpec.NO_CHILDREN_ADDRESS) {
    childrenAddress+=addressPointer;
  }
  addressPointer+=BinaryDictIOUtils.getChildrenAddressSize(flags,options);
  final ArrayList<WeightedString> shortcutTargets;
  if (0 != (flags & FormatSpec.FLAG_HAS_SHORTCUT_TARGETS)) {
    shortcutTargets=new ArrayList<WeightedString>();
    addressPointer+=PtNodeReader.readShortcut(mDictBuffer,shortcutTargets);
  }
 else {
    shortcutTargets=null;
  }
  final ArrayList<PendingAttribute> bigrams;
  if (0 != (flags & FormatSpec.FLAG_HAS_BIGRAMS)) {
    bigrams=new ArrayList<PendingAttribute>();
    final int posOfBigrams=mBigramAddressTable.get(terminalId);
    mBigramBuffer.position(posOfBigrams);
    while (bigrams.size() < FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      final int bigramFlags=mBigramBuffer.readUnsignedByte();
      final int targetTerminalId=mBigramBuffer.readUnsignedInt24();
      mTerminalAddressTableBuffer.position(targetTerminalId * FormatSpec.TERMINAL_ADDRESS_TABLE_ADDRESS_SIZE);
      final int targetAddress=mTerminalAddressTableBuffer.readUnsignedInt24();
      bigrams.add(new PendingAttribute(bigramFlags & FormatSpec.FLAG_BIGRAM_SHORTCUT_ATTR_FREQUENCY,targetAddress));
      if (0 == (bigramFlags & FormatSpec.FLAG_BIGRAM_SHORTCUT_ATTR_HAS_NEXT))       break;
    }
    if (bigrams.size() >= FormatSpec.MAX_BIGRAMS_IN_A_PTNODE) {
      throw new RuntimeException(""String_Node_Str"" + bigrams.size() + ""String_Node_Str""+ FormatSpec.MAX_BIGRAMS_IN_A_PTNODE+ ""String_Node_Str"");
    }
  }
 else {
    bigrams=null;
  }
  return new PtNodeInfo(ptNodePos,addressPointer,flags,characters,frequency,parentAddress,childrenAddress,shortcutTargets,bigrams);
}",0.9800152555301296
87557,"public BinaryDictDecoderEncoderTests(final long seed,final int maxUnigrams){
  super();
  Log.e(TAG,""String_Node_Str"" + seed);
  final Random random=new Random(seed);
  sWords.clear();
  final int[] codePointSet=CodePointUtils.generateCodePointSet(DEFAULT_CODE_POINT_SET_SIZE,random);
  generateWords(maxUnigrams,random,codePointSet);
  for (int i=0; i < sWords.size(); ++i) {
    sChainBigrams.put(i,new ArrayList<Integer>());
    if (i > 0) {
      sChainBigrams.get(i - 1).add(i);
    }
  }
  sStarBigrams.put(0,new ArrayList<Integer>());
  for (int i=1; i < sWords.size(); ++i) {
    sStarBigrams.get(0).add(i);
  }
  sShortcuts.clear();
  for (int i=0; i < NUM_OF_NODES_HAVING_SHORTCUTS; ++i) {
    final int from=Math.abs(random.nextInt()) % sWords.size();
    sShortcuts.put(sWords.get(from),new ArrayList<String>());
    for (int j=0; j < NUM_OF_SHORTCUTS; ++j) {
      final int to=Math.abs(random.nextInt()) % sWords.size();
      sShortcuts.get(sWords.get(from)).add(sWords.get(to));
    }
  }
}","public BinaryDictDecoderEncoderTests(final long seed,final int maxUnigrams){
  super();
  Log.e(TAG,""String_Node_Str"" + seed);
  final Random random=new Random(seed);
  sWords.clear();
  final int[] codePointSet=CodePointUtils.generateCodePointSet(DEFAULT_CODE_POINT_SET_SIZE,random);
  generateWords(maxUnigrams,random,codePointSet);
  for (int i=0; i < sWords.size(); ++i) {
    sChainBigrams.put(i,new ArrayList<Integer>());
    if (i > 0) {
      sChainBigrams.get(i - 1).add(i);
    }
  }
  sStarBigrams.put(0,new ArrayList<Integer>());
  final int maxBigrams=Math.min(sWords.size(),FormatSpec.MAX_BIGRAMS_IN_A_PTNODE - 1);
  for (int i=1; i < maxBigrams; ++i) {
    sStarBigrams.get(0).add(i);
  }
  sShortcuts.clear();
  for (int i=0; i < NUM_OF_NODES_HAVING_SHORTCUTS; ++i) {
    final int from=Math.abs(random.nextInt()) % sWords.size();
    sShortcuts.put(sWords.get(from),new ArrayList<String>());
    for (int j=0; j < NUM_OF_SHORTCUTS; ++j) {
      final int to=Math.abs(random.nextInt()) % sWords.size();
      sShortcuts.get(sWords.get(from)).add(sWords.get(to));
    }
  }
}",0.9475190839694656
87558,"private void updateBatchInput(final long eventTime){
synchronized (sAggregratedPointers) {
    final GestureStroke stroke=mGestureStrokeWithPreviewPoints;
    stroke.appendIncrementalBatchPoints(sAggregratedPointers);
    final int size=sAggregratedPointers.getPointerSize();
    if (size > sLastRecognitionPointSize && stroke.hasRecognitionTimePast(eventTime,sLastRecognitionTime)) {
      sLastRecognitionPointSize=size;
      sLastRecognitionTime=eventTime;
      if (DEBUG_LISTENER) {
        Log.d(TAG,String.format(""String_Node_Str"",mPointerId,size));
      }
      mTimerProxy.startUpdateBatchInputTimer(this);
      mListener.onUpdateBatchInput(sAggregratedPointers);
    }
  }
}","private void updateBatchInput(final long eventTime){
synchronized (sAggregratedPointers) {
    final GestureStroke stroke=mGestureStrokeWithPreviewPoints;
    stroke.appendIncrementalBatchPoints(sAggregratedPointers);
    final int size=sAggregratedPointers.getPointerSize();
    if (size > sLastRecognitionPointSize && stroke.hasRecognitionTimePast(eventTime,sLastRecognitionTime)) {
      if (DEBUG_LISTENER) {
        Log.d(TAG,String.format(""String_Node_Str"",mPointerId,size));
      }
      mTimerProxy.startUpdateBatchInputTimer(this);
      mListener.onUpdateBatchInput(sAggregratedPointers);
      sLastRecognitionPointSize=sAggregratedPointers.getPointerSize();
      sLastRecognitionTime=eventTime;
    }
  }
}",0.8685145700071073
87559,"private void updateBatchInput(final long eventTime){
synchronized (sAggregratedPointers) {
    final GestureStroke stroke=mGestureStrokeWithPreviewPoints;
    stroke.appendIncrementalBatchPoints(sAggregratedPointers);
    final int size=sAggregratedPointers.getPointerSize();
    if (size > sLastRecognitionPointSize && stroke.hasRecognitionTimePast(eventTime,sLastRecognitionTime)) {
      sLastRecognitionPointSize=size;
      sLastRecognitionTime=eventTime;
      if (DEBUG_LISTENER) {
        Log.d(TAG,String.format(""String_Node_Str"",mPointerId,size));
      }
      mTimerProxy.startUpdateBatchInputTimer(this);
      mListener.onUpdateBatchInput(sAggregratedPointers);
    }
  }
}","private void updateBatchInput(final long eventTime){
synchronized (sAggregratedPointers) {
    final GestureStroke stroke=mGestureStrokeWithPreviewPoints;
    stroke.appendIncrementalBatchPoints(sAggregratedPointers);
    final int size=sAggregratedPointers.getPointerSize();
    if (size > sLastRecognitionPointSize && stroke.hasRecognitionTimePast(eventTime,sLastRecognitionTime)) {
      if (DEBUG_LISTENER) {
        Log.d(TAG,String.format(""String_Node_Str"",mPointerId,size));
      }
      mTimerProxy.startUpdateBatchInputTimer(this);
      mListener.onUpdateBatchInput(sAggregratedPointers);
      sLastRecognitionPointSize=sAggregratedPointers.getPointerSize();
      sLastRecognitionTime=eventTime;
    }
  }
}",0.8685145700071073
87560,"/** 
 * Gets the caps modes we should be in after this specific string. This returns a bit set of TextUtils#CAP_MODE_*, masked by the inputType argument. This method also supports faking an additional space after the string passed in argument, to support cases where a space will be added automatically, like in phantom space state for example. Note that for English, we are using American typography rules (which are not specific to American English, it's just the most common set of rules for English).
 * @param inputType a mask of the caps modes to test for.
 * @param locale what language should be considered.
 * @param hasSpaceBefore if we should consider there should be a space after the string.
 * @return the caps modes that should be on as a set of bits
 */
public int getCursorCapsMode(final int inputType,final Locale locale,final boolean hasSpaceBefore){
  mIC=mParent.getCurrentInputConnection();
  if (null == mIC)   return Constants.TextUtils.CAP_MODE_OFF;
  if (!TextUtils.isEmpty(mComposingText)) {
    if (hasSpaceBefore) {
      return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & inputType;
    }
 else {
      return TextUtils.CAP_MODE_CHARACTERS & inputType;
    }
  }
  if (TextUtils.isEmpty(mCommittedTextBeforeComposingText) && 0 != mExpectedCursorPosition) {
    mCommittedTextBeforeComposingText.append(getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0));
  }
  return CapsModeUtils.getCapsMode(mCommittedTextBeforeComposingText,inputType,locale,hasSpaceBefore);
}","/** 
 * Gets the caps modes we should be in after this specific string. This returns a bit set of TextUtils#CAP_MODE_*, masked by the inputType argument. This method also supports faking an additional space after the string passed in argument, to support cases where a space will be added automatically, like in phantom space state for example. Note that for English, we are using American typography rules (which are not specific to American English, it's just the most common set of rules for English).
 * @param inputType a mask of the caps modes to test for.
 * @param locale what language should be considered.
 * @param hasSpaceBefore if we should consider there should be a space after the string.
 * @return the caps modes that should be on as a set of bits
 */
public int getCursorCapsMode(final int inputType,final Locale locale,final boolean hasSpaceBefore){
  mIC=mParent.getCurrentInputConnection();
  if (null == mIC)   return Constants.TextUtils.CAP_MODE_OFF;
  if (!TextUtils.isEmpty(mComposingText)) {
    if (hasSpaceBefore) {
      return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & inputType;
    }
 else {
      return TextUtils.CAP_MODE_CHARACTERS & inputType;
    }
  }
  if (TextUtils.isEmpty(mCommittedTextBeforeComposingText) && 0 != mExpectedCursorPosition) {
    final CharSequence textBeforeCursor=getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0);
    if (!TextUtils.isEmpty(textBeforeCursor)) {
      mCommittedTextBeforeComposingText.append(textBeforeCursor);
    }
  }
  return CapsModeUtils.getCapsMode(mCommittedTextBeforeComposingText,inputType,locale,hasSpaceBefore);
}",0.9436980166346768
87561,"/** 
 * Gets the caps modes we should be in after this specific string. This returns a bit set of TextUtils#CAP_MODE_*, masked by the inputType argument. This method also supports faking an additional space after the string passed in argument, to support cases where a space will be added automatically, like in phantom space state for example. Note that for English, we are using American typography rules (which are not specific to American English, it's just the most common set of rules for English).
 * @param inputType a mask of the caps modes to test for.
 * @param locale what language should be considered.
 * @param hasSpaceBefore if we should consider there should be a space after the string.
 * @return the caps modes that should be on as a set of bits
 */
public int getCursorCapsMode(final int inputType,final Locale locale,final boolean hasSpaceBefore){
  mIC=mParent.getCurrentInputConnection();
  if (null == mIC)   return Constants.TextUtils.CAP_MODE_OFF;
  if (!TextUtils.isEmpty(mComposingText)) {
    if (hasSpaceBefore) {
      return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & inputType;
    }
 else {
      return TextUtils.CAP_MODE_CHARACTERS & inputType;
    }
  }
  if (TextUtils.isEmpty(mCommittedTextBeforeComposingText) && 0 != mExpectedCursorPosition) {
    mCommittedTextBeforeComposingText.append(getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0));
  }
  return CapsModeUtils.getCapsMode(mCommittedTextBeforeComposingText,inputType,locale,hasSpaceBefore);
}","/** 
 * Gets the caps modes we should be in after this specific string. This returns a bit set of TextUtils#CAP_MODE_*, masked by the inputType argument. This method also supports faking an additional space after the string passed in argument, to support cases where a space will be added automatically, like in phantom space state for example. Note that for English, we are using American typography rules (which are not specific to American English, it's just the most common set of rules for English).
 * @param inputType a mask of the caps modes to test for.
 * @param locale what language should be considered.
 * @param hasSpaceBefore if we should consider there should be a space after the string.
 * @return the caps modes that should be on as a set of bits
 */
public int getCursorCapsMode(final int inputType,final Locale locale,final boolean hasSpaceBefore){
  mIC=mParent.getCurrentInputConnection();
  if (null == mIC)   return Constants.TextUtils.CAP_MODE_OFF;
  if (!TextUtils.isEmpty(mComposingText)) {
    if (hasSpaceBefore) {
      return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & inputType;
    }
 else {
      return TextUtils.CAP_MODE_CHARACTERS & inputType;
    }
  }
  if (TextUtils.isEmpty(mCommittedTextBeforeComposingText) && 0 != mExpectedCursorPosition) {
    final CharSequence textBeforeCursor=getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0);
    if (!TextUtils.isEmpty(textBeforeCursor)) {
      mCommittedTextBeforeComposingText.append(textBeforeCursor);
    }
  }
  return CapsModeUtils.getCapsMode(mCommittedTextBeforeComposingText,inputType,locale,hasSpaceBefore);
}",0.9436980166346768
87562,"/** 
 * Gets the caps modes we should be in after this specific string. This returns a bit set of TextUtils#CAP_MODE_*, masked by the inputType argument. This method also supports faking an additional space after the string passed in argument, to support cases where a space will be added automatically, like in phantom space state for example. Note that for English, we are using American typography rules (which are not specific to American English, it's just the most common set of rules for English).
 * @param inputType a mask of the caps modes to test for.
 * @param locale what language should be considered.
 * @param hasSpaceBefore if we should consider there should be a space after the string.
 * @return the caps modes that should be on as a set of bits
 */
public int getCursorCapsMode(final int inputType,final Locale locale,final boolean hasSpaceBefore){
  mIC=mParent.getCurrentInputConnection();
  if (null == mIC)   return Constants.TextUtils.CAP_MODE_OFF;
  if (!TextUtils.isEmpty(mComposingText)) {
    if (hasSpaceBefore) {
      return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & inputType;
    }
 else {
      return TextUtils.CAP_MODE_CHARACTERS & inputType;
    }
  }
  if (TextUtils.isEmpty(mCommittedTextBeforeComposingText) && 0 != mExpectedCursorPosition) {
    mCommittedTextBeforeComposingText.append(getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0));
  }
  return CapsModeUtils.getCapsMode(mCommittedTextBeforeComposingText,inputType,locale,hasSpaceBefore);
}","/** 
 * Gets the caps modes we should be in after this specific string. This returns a bit set of TextUtils#CAP_MODE_*, masked by the inputType argument. This method also supports faking an additional space after the string passed in argument, to support cases where a space will be added automatically, like in phantom space state for example. Note that for English, we are using American typography rules (which are not specific to American English, it's just the most common set of rules for English).
 * @param inputType a mask of the caps modes to test for.
 * @param locale what language should be considered.
 * @param hasSpaceBefore if we should consider there should be a space after the string.
 * @return the caps modes that should be on as a set of bits
 */
public int getCursorCapsMode(final int inputType,final Locale locale,final boolean hasSpaceBefore){
  mIC=mParent.getCurrentInputConnection();
  if (null == mIC)   return Constants.TextUtils.CAP_MODE_OFF;
  if (!TextUtils.isEmpty(mComposingText)) {
    if (hasSpaceBefore) {
      return (TextUtils.CAP_MODE_CHARACTERS | TextUtils.CAP_MODE_WORDS) & inputType;
    }
 else {
      return TextUtils.CAP_MODE_CHARACTERS & inputType;
    }
  }
  if (TextUtils.isEmpty(mCommittedTextBeforeComposingText) && 0 != mExpectedCursorPosition) {
    final CharSequence textBeforeCursor=getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0);
    if (!TextUtils.isEmpty(textBeforeCursor)) {
      mCommittedTextBeforeComposingText.append(textBeforeCursor);
    }
  }
  return CapsModeUtils.getCapsMode(mCommittedTextBeforeComposingText,inputType,locale,hasSpaceBefore);
}",0.9436980166346768
87563,"/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (!isSuggestionsStripVisible())   return;
  if (!mSettings.getCurrent().mCurrentLanguageHasSpaces)   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  final SettingsValues currentSettings=mSettings.getCurrent();
  if (!mConnection.isCursorTouchingWord(currentSettings))   return;
  final TextRange range=mConnection.getWordRangeAtCursor(currentSettings.mWordSeparators,0);
  if (null == range)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final String typedWord=range.mWord.toString();
  if (!isResumableWord(typedWord,currentSettings))   return;
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.isEmpty()) {
    mInputUpdater.getSuggestedWords(Suggest.SESSION_TYPING,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        unsetIsAutoCorrectionIndicatorOnAndCallShowSuggestionStrip(suggestedWords,typedWord);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
    unsetIsAutoCorrectionIndicatorOnAndCallShowSuggestionStrip(suggestedWords,typedWord);
  }
}","/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (!isSuggestionsStripVisible())   return;
  if (!mSettings.getCurrent().mCurrentLanguageHasSpaces)   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  final SettingsValues currentSettings=mSettings.getCurrent();
  if (!mConnection.isCursorTouchingWord(currentSettings))   return;
  final TextRange range=mConnection.getWordRangeAtCursor(currentSettings.mWordSeparators,0);
  if (null == range)   return;
  if (range.length() <= 0)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final String typedWord=range.mWord.toString();
  if (!isResumableWord(typedWord,currentSettings))   return;
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.isEmpty()) {
    mInputUpdater.getSuggestedWords(Suggest.SESSION_TYPING,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        unsetIsAutoCorrectionIndicatorOnAndCallShowSuggestionStrip(suggestedWords,typedWord);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
    unsetIsAutoCorrectionIndicatorOnAndCallShowSuggestionStrip(suggestedWords,typedWord);
  }
}",0.993075051469212
87564,"/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (!isSuggestionsStripVisible())   return;
  if (!mSettings.getCurrent().mCurrentLanguageHasSpaces)   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  final SettingsValues currentSettings=mSettings.getCurrent();
  if (!mConnection.isCursorTouchingWord(currentSettings))   return;
  final TextRange range=mConnection.getWordRangeAtCursor(currentSettings.mWordSeparators,0);
  if (null == range)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final String typedWord=range.mWord.toString();
  if (!isResumableWord(typedWord,currentSettings))   return;
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.isEmpty()) {
    mInputUpdater.getSuggestedWords(Suggest.SESSION_TYPING,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        unsetIsAutoCorrectionIndicatorOnAndCallShowSuggestionStrip(suggestedWords,typedWord);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
    unsetIsAutoCorrectionIndicatorOnAndCallShowSuggestionStrip(suggestedWords,typedWord);
  }
}","/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (!isSuggestionsStripVisible())   return;
  if (!mSettings.getCurrent().mCurrentLanguageHasSpaces)   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  final SettingsValues currentSettings=mSettings.getCurrent();
  if (!mConnection.isCursorTouchingWord(currentSettings))   return;
  final TextRange range=mConnection.getWordRangeAtCursor(currentSettings.mWordSeparators,0);
  if (null == range)   return;
  if (range.length() <= 0)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final String typedWord=range.mWord.toString();
  if (!isResumableWord(typedWord,currentSettings))   return;
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.DICTIONARY_RESUMED,SuggestedWordInfo.NOT_AN_INDEX,SuggestedWordInfo.NOT_A_CONFIDENCE));
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  if (suggestions.isEmpty()) {
    mInputUpdater.getSuggestedWords(Suggest.SESSION_TYPING,new OnGetSuggestedWordsCallback(){
      @Override public void onGetSuggestedWords(      final SuggestedWords suggestedWordsIncludingTypedWord){
        final SuggestedWords suggestedWords;
        if (suggestedWordsIncludingTypedWord.size() > 1) {
          suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
        }
 else {
          suggestedWords=suggestedWordsIncludingTypedWord;
        }
        unsetIsAutoCorrectionIndicatorOnAndCallShowSuggestionStrip(suggestedWords,typedWord);
      }
    }
);
  }
 else {
    final SuggestedWords suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
    unsetIsAutoCorrectionIndicatorOnAndCallShowSuggestionStrip(suggestedWords,typedWord);
  }
}",0.993075051469212
87565,"private void computeNearestNeighbors(){
  final int defaultWidth=mMostCommonKeyWidth;
  final int keyCount=mKeys.length;
  final int gridSize=mGridNeighbors.length;
  final int threshold=(int)(defaultWidth * SEARCH_DISTANCE);
  final int thresholdSquared=threshold * threshold;
  final int fullGridWidth=mGridWidth * mCellWidth;
  final int fullGridHeight=mGridHeight * mCellHeight;
  final Key[] neighborsFlatBuffer=new Key[gridSize * keyCount];
  final int[] neighborCountPerCell=new int[gridSize];
  final int halfCellWidth=mCellWidth / 2;
  final int halfCellHeight=mCellHeight / 2;
  for (  final Key key : mKeys) {
    if (key.isSpacer())     continue;
    final int keyX=key.getX();
    final int keyY=key.getY();
    final int topPixelWithinThreshold=keyY - threshold;
    final int yDeltaToGrid=topPixelWithinThreshold % mCellHeight;
    final int yMiddleOfTopCell=topPixelWithinThreshold - yDeltaToGrid + halfCellHeight;
    final int yStart=Math.max(halfCellHeight,yMiddleOfTopCell + (yDeltaToGrid <= halfCellHeight ? 0 : mCellHeight));
    final int yEnd=Math.min(fullGridHeight,keyY + key.getHeight() + threshold);
    final int leftPixelWithinThreshold=keyX - threshold;
    final int xDeltaToGrid=leftPixelWithinThreshold % mCellWidth;
    final int xMiddleOfLeftCell=leftPixelWithinThreshold - xDeltaToGrid + halfCellWidth;
    final int xStart=Math.max(halfCellWidth,xMiddleOfLeftCell + (xDeltaToGrid <= halfCellWidth ? 0 : mCellWidth));
    final int xEnd=Math.min(fullGridWidth,keyX + key.getWidth() + threshold);
    int baseIndexOfCurrentRow=(yStart / mCellHeight) * mGridWidth + (xStart / mCellWidth);
    for (int centerY=yStart; centerY <= yEnd; centerY+=mCellHeight) {
      int index=baseIndexOfCurrentRow;
      for (int centerX=xStart; centerX <= xEnd; centerX+=mCellWidth) {
        if (index < neighborCountPerCell.length && key.squaredDistanceToEdge(centerX,centerY) < thresholdSquared) {
          neighborsFlatBuffer[index * keyCount + neighborCountPerCell[index]]=key;
          ++neighborCountPerCell[index];
        }
        ++index;
      }
      baseIndexOfCurrentRow+=mGridWidth;
    }
  }
  for (int i=0; i < gridSize; ++i) {
    final int base=i * keyCount;
    mGridNeighbors[i]=Arrays.copyOfRange(neighborsFlatBuffer,base,base + neighborCountPerCell[i]);
  }
}","private void computeNearestNeighbors(){
  final int defaultWidth=mMostCommonKeyWidth;
  final int keyCount=mKeys.length;
  final int gridSize=mGridNeighbors.length;
  final int threshold=(int)(defaultWidth * SEARCH_DISTANCE);
  final int thresholdSquared=threshold * threshold;
  final int lastPixelXCoordinate=mGridWidth * mCellWidth - 1;
  final int lastPixelYCoordinate=mGridHeight * mCellHeight - 1;
  final Key[] neighborsFlatBuffer=new Key[gridSize * keyCount];
  final int[] neighborCountPerCell=new int[gridSize];
  final int halfCellWidth=mCellWidth / 2;
  final int halfCellHeight=mCellHeight / 2;
  for (  final Key key : mKeys) {
    if (key.isSpacer())     continue;
    final int keyX=key.getX();
    final int keyY=key.getY();
    final int topPixelWithinThreshold=keyY - threshold;
    final int yDeltaToGrid=topPixelWithinThreshold % mCellHeight;
    final int yMiddleOfTopCell=topPixelWithinThreshold - yDeltaToGrid + halfCellHeight;
    final int yStart=Math.max(halfCellHeight,yMiddleOfTopCell + (yDeltaToGrid <= halfCellHeight ? 0 : mCellHeight));
    final int yEnd=Math.min(lastPixelYCoordinate,keyY + key.getHeight() + threshold);
    final int leftPixelWithinThreshold=keyX - threshold;
    final int xDeltaToGrid=leftPixelWithinThreshold % mCellWidth;
    final int xMiddleOfLeftCell=leftPixelWithinThreshold - xDeltaToGrid + halfCellWidth;
    final int xStart=Math.max(halfCellWidth,xMiddleOfLeftCell + (xDeltaToGrid <= halfCellWidth ? 0 : mCellWidth));
    final int xEnd=Math.min(lastPixelXCoordinate,keyX + key.getWidth() + threshold);
    int baseIndexOfCurrentRow=(yStart / mCellHeight) * mGridWidth + (xStart / mCellWidth);
    for (int centerY=yStart; centerY <= yEnd; centerY+=mCellHeight) {
      int index=baseIndexOfCurrentRow;
      for (int centerX=xStart; centerX <= xEnd; centerX+=mCellWidth) {
        if (key.squaredDistanceToEdge(centerX,centerY) < thresholdSquared) {
          neighborsFlatBuffer[index * keyCount + neighborCountPerCell[index]]=key;
          ++neighborCountPerCell[index];
        }
        ++index;
      }
      baseIndexOfCurrentRow+=mGridWidth;
    }
  }
  for (int i=0; i < gridSize; ++i) {
    final int base=i * keyCount;
    mGridNeighbors[i]=Arrays.copyOfRange(neighborsFlatBuffer,base,base + neighborCountPerCell[i]);
  }
}",0.9454703454268956
87566,"private void computeNearestNeighbors(){
  final int defaultWidth=mMostCommonKeyWidth;
  final int keyCount=mKeys.length;
  final int gridSize=mGridNeighbors.length;
  final int threshold=(int)(defaultWidth * SEARCH_DISTANCE);
  final int thresholdSquared=threshold * threshold;
  final int fullGridWidth=mGridWidth * mCellWidth;
  final int fullGridHeight=mGridHeight * mCellHeight;
  final Key[] neighborsFlatBuffer=new Key[gridSize * keyCount];
  final int[] neighborCountPerCell=new int[gridSize];
  final int halfCellWidth=mCellWidth / 2;
  final int halfCellHeight=mCellHeight / 2;
  for (  final Key key : mKeys) {
    if (key.isSpacer())     continue;
    final int keyX=key.getX();
    final int keyY=key.getY();
    final int topPixelWithinThreshold=keyY - threshold;
    final int yDeltaToGrid=topPixelWithinThreshold % mCellHeight;
    final int yMiddleOfTopCell=topPixelWithinThreshold - yDeltaToGrid + halfCellHeight;
    final int yStart=Math.max(halfCellHeight,yMiddleOfTopCell + (yDeltaToGrid <= halfCellHeight ? 0 : mCellHeight));
    final int yEnd=Math.min(fullGridHeight,keyY + key.getHeight() + threshold);
    final int leftPixelWithinThreshold=keyX - threshold;
    final int xDeltaToGrid=leftPixelWithinThreshold % mCellWidth;
    final int xMiddleOfLeftCell=leftPixelWithinThreshold - xDeltaToGrid + halfCellWidth;
    final int xStart=Math.max(halfCellWidth,xMiddleOfLeftCell + (xDeltaToGrid <= halfCellWidth ? 0 : mCellWidth));
    final int xEnd=Math.min(fullGridWidth,keyX + key.getWidth() + threshold);
    int baseIndexOfCurrentRow=(yStart / mCellHeight) * mGridWidth + (xStart / mCellWidth);
    for (int centerY=yStart; centerY <= yEnd; centerY+=mCellHeight) {
      int index=baseIndexOfCurrentRow;
      for (int centerX=xStart; centerX <= xEnd; centerX+=mCellWidth) {
        if (index < neighborCountPerCell.length && key.squaredDistanceToEdge(centerX,centerY) < thresholdSquared) {
          neighborsFlatBuffer[index * keyCount + neighborCountPerCell[index]]=key;
          ++neighborCountPerCell[index];
        }
        ++index;
      }
      baseIndexOfCurrentRow+=mGridWidth;
    }
  }
  for (int i=0; i < gridSize; ++i) {
    final int base=i * keyCount;
    mGridNeighbors[i]=Arrays.copyOfRange(neighborsFlatBuffer,base,base + neighborCountPerCell[i]);
  }
}","private void computeNearestNeighbors(){
  final int defaultWidth=mMostCommonKeyWidth;
  final int keyCount=mKeys.length;
  final int gridSize=mGridNeighbors.length;
  final int threshold=(int)(defaultWidth * SEARCH_DISTANCE);
  final int thresholdSquared=threshold * threshold;
  final int lastPixelXCoordinate=mGridWidth * mCellWidth - 1;
  final int lastPixelYCoordinate=mGridHeight * mCellHeight - 1;
  final Key[] neighborsFlatBuffer=new Key[gridSize * keyCount];
  final int[] neighborCountPerCell=new int[gridSize];
  final int halfCellWidth=mCellWidth / 2;
  final int halfCellHeight=mCellHeight / 2;
  for (  final Key key : mKeys) {
    if (key.isSpacer())     continue;
    final int keyX=key.getX();
    final int keyY=key.getY();
    final int topPixelWithinThreshold=keyY - threshold;
    final int yDeltaToGrid=topPixelWithinThreshold % mCellHeight;
    final int yMiddleOfTopCell=topPixelWithinThreshold - yDeltaToGrid + halfCellHeight;
    final int yStart=Math.max(halfCellHeight,yMiddleOfTopCell + (yDeltaToGrid <= halfCellHeight ? 0 : mCellHeight));
    final int yEnd=Math.min(lastPixelYCoordinate,keyY + key.getHeight() + threshold);
    final int leftPixelWithinThreshold=keyX - threshold;
    final int xDeltaToGrid=leftPixelWithinThreshold % mCellWidth;
    final int xMiddleOfLeftCell=leftPixelWithinThreshold - xDeltaToGrid + halfCellWidth;
    final int xStart=Math.max(halfCellWidth,xMiddleOfLeftCell + (xDeltaToGrid <= halfCellWidth ? 0 : mCellWidth));
    final int xEnd=Math.min(lastPixelXCoordinate,keyX + key.getWidth() + threshold);
    int baseIndexOfCurrentRow=(yStart / mCellHeight) * mGridWidth + (xStart / mCellWidth);
    for (int centerY=yStart; centerY <= yEnd; centerY+=mCellHeight) {
      int index=baseIndexOfCurrentRow;
      for (int centerX=xStart; centerX <= xEnd; centerX+=mCellWidth) {
        if (key.squaredDistanceToEdge(centerX,centerY) < thresholdSquared) {
          neighborsFlatBuffer[index * keyCount + neighborCountPerCell[index]]=key;
          ++neighborCountPerCell[index];
        }
        ++index;
      }
      baseIndexOfCurrentRow+=mGridWidth;
    }
  }
  for (int i=0; i < gridSize; ++i) {
    final int base=i * keyCount;
    mGridNeighbors[i]=Arrays.copyOfRange(neighborsFlatBuffer,base,base + neighborCountPerCell[i]);
  }
}",0.9454703454268956
87567,"private void computeNearestNeighbors(){
  final int defaultWidth=mMostCommonKeyWidth;
  final int keyCount=mKeys.length;
  final int gridSize=mGridNeighbors.length;
  final int threshold=(int)(defaultWidth * SEARCH_DISTANCE);
  final int thresholdSquared=threshold * threshold;
  final int fullGridWidth=mGridWidth * mCellWidth;
  final int fullGridHeight=mGridHeight * mCellHeight;
  final Key[] neighborsFlatBuffer=new Key[gridSize * keyCount];
  final int[] neighborCountPerCell=new int[gridSize];
  final int halfCellWidth=mCellWidth / 2;
  final int halfCellHeight=mCellHeight / 2;
  for (  final Key key : mKeys) {
    if (key.isSpacer())     continue;
    final int keyX=key.getX();
    final int keyY=key.getY();
    final int topPixelWithinThreshold=keyY - threshold;
    final int yDeltaToGrid=topPixelWithinThreshold % mCellHeight;
    final int yMiddleOfTopCell=topPixelWithinThreshold - yDeltaToGrid + halfCellHeight;
    final int yStart=Math.max(halfCellHeight,yMiddleOfTopCell + (yDeltaToGrid <= halfCellHeight ? 0 : mCellHeight));
    final int yEnd=Math.min(fullGridHeight,keyY + key.getHeight() + threshold);
    final int leftPixelWithinThreshold=keyX - threshold;
    final int xDeltaToGrid=leftPixelWithinThreshold % mCellWidth;
    final int xMiddleOfLeftCell=leftPixelWithinThreshold - xDeltaToGrid + halfCellWidth;
    final int xStart=Math.max(halfCellWidth,xMiddleOfLeftCell + (xDeltaToGrid <= halfCellWidth ? 0 : mCellWidth));
    final int xEnd=Math.min(fullGridWidth,keyX + key.getWidth() + threshold);
    int baseIndexOfCurrentRow=(yStart / mCellHeight) * mGridWidth + (xStart / mCellWidth);
    for (int centerY=yStart; centerY <= yEnd; centerY+=mCellHeight) {
      int index=baseIndexOfCurrentRow;
      for (int centerX=xStart; centerX <= xEnd; centerX+=mCellWidth) {
        if (index < neighborCountPerCell.length && key.squaredDistanceToEdge(centerX,centerY) < thresholdSquared) {
          neighborsFlatBuffer[index * keyCount + neighborCountPerCell[index]]=key;
          ++neighborCountPerCell[index];
        }
        ++index;
      }
      baseIndexOfCurrentRow+=mGridWidth;
    }
  }
  for (int i=0; i < gridSize; ++i) {
    final int base=i * keyCount;
    mGridNeighbors[i]=Arrays.copyOfRange(neighborsFlatBuffer,base,base + neighborCountPerCell[i]);
  }
}","private void computeNearestNeighbors(){
  final int defaultWidth=mMostCommonKeyWidth;
  final int keyCount=mKeys.length;
  final int gridSize=mGridNeighbors.length;
  final int threshold=(int)(defaultWidth * SEARCH_DISTANCE);
  final int thresholdSquared=threshold * threshold;
  final int lastPixelXCoordinate=mGridWidth * mCellWidth - 1;
  final int lastPixelYCoordinate=mGridHeight * mCellHeight - 1;
  final Key[] neighborsFlatBuffer=new Key[gridSize * keyCount];
  final int[] neighborCountPerCell=new int[gridSize];
  final int halfCellWidth=mCellWidth / 2;
  final int halfCellHeight=mCellHeight / 2;
  for (  final Key key : mKeys) {
    if (key.isSpacer())     continue;
    final int keyX=key.getX();
    final int keyY=key.getY();
    final int topPixelWithinThreshold=keyY - threshold;
    final int yDeltaToGrid=topPixelWithinThreshold % mCellHeight;
    final int yMiddleOfTopCell=topPixelWithinThreshold - yDeltaToGrid + halfCellHeight;
    final int yStart=Math.max(halfCellHeight,yMiddleOfTopCell + (yDeltaToGrid <= halfCellHeight ? 0 : mCellHeight));
    final int yEnd=Math.min(lastPixelYCoordinate,keyY + key.getHeight() + threshold);
    final int leftPixelWithinThreshold=keyX - threshold;
    final int xDeltaToGrid=leftPixelWithinThreshold % mCellWidth;
    final int xMiddleOfLeftCell=leftPixelWithinThreshold - xDeltaToGrid + halfCellWidth;
    final int xStart=Math.max(halfCellWidth,xMiddleOfLeftCell + (xDeltaToGrid <= halfCellWidth ? 0 : mCellWidth));
    final int xEnd=Math.min(lastPixelXCoordinate,keyX + key.getWidth() + threshold);
    int baseIndexOfCurrentRow=(yStart / mCellHeight) * mGridWidth + (xStart / mCellWidth);
    for (int centerY=yStart; centerY <= yEnd; centerY+=mCellHeight) {
      int index=baseIndexOfCurrentRow;
      for (int centerX=xStart; centerX <= xEnd; centerX+=mCellWidth) {
        if (key.squaredDistanceToEdge(centerX,centerY) < thresholdSquared) {
          neighborsFlatBuffer[index * keyCount + neighborCountPerCell[index]]=key;
          ++neighborCountPerCell[index];
        }
        ++index;
      }
      baseIndexOfCurrentRow+=mGridWidth;
    }
  }
  for (int i=0; i < gridSize; ++i) {
    final int base=i * keyCount;
    mGridNeighbors[i]=Arrays.copyOfRange(neighborsFlatBuffer,base,base + neighborCountPerCell[i]);
  }
}",0.9454703454268956
87568,"public void finishComposingText(){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  mCommittedTextBeforeComposingText.append(mComposingText);
  mExpectedCursorPosition+=mComposingText.length();
  mComposingText.setLength(0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}","public void finishComposingText(){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  mCommittedTextBeforeComposingText.append(mComposingText);
  mComposingText.setLength(0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}",0.9413092550790068
87569,"public void finishComposingText(){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  mCommittedTextBeforeComposingText.append(mComposingText);
  mExpectedCursorPosition+=mComposingText.length();
  mComposingText.setLength(0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}","public void finishComposingText(){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  mCommittedTextBeforeComposingText.append(mComposingText);
  mComposingText.setLength(0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}",0.9413092550790068
87570,"public void finishComposingText(){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  mCommittedTextBeforeComposingText.append(mComposingText);
  mExpectedCursorPosition+=mComposingText.length();
  mComposingText.setLength(0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}","public void finishComposingText(){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  mCommittedTextBeforeComposingText.append(mComposingText);
  mComposingText.setLength(0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}",0.9413092550790068
87571,"private void addOrReplaceDictionaryInternal(final String key,final Dictionary dict){
  if (mOnlyDictionarySetForDebug != null && mOnlyDictionarySetForDebug.contains(key)) {
    Log.w(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
    return;
  }
  addOrReplaceDictionary(mDictionaries,key,dict);
}","private void addOrReplaceDictionaryInternal(final String key,final Dictionary dict){
  if (mOnlyDictionarySetForDebug != null && !mOnlyDictionarySetForDebug.contains(key)) {
    Log.w(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
    return;
  }
  addOrReplaceDictionary(mDictionaries,key,dict);
}",0.9983361064891848
87572,"private void addOrReplaceDictionaryInternal(final String key,final Dictionary dict){
  if (mOnlyDictionarySetForDebug != null && mOnlyDictionarySetForDebug.contains(key)) {
    Log.w(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
    return;
  }
  addOrReplaceDictionary(mDictionaries,key,dict);
}","private void addOrReplaceDictionaryInternal(final String key,final Dictionary dict){
  if (mOnlyDictionarySetForDebug != null && !mOnlyDictionarySetForDebug.contains(key)) {
    Log.w(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
    return;
  }
  addOrReplaceDictionary(mDictionaries,key,dict);
}",0.9983361064891848
87573,"private void addOrReplaceDictionaryInternal(final String key,final Dictionary dict){
  if (mOnlyDictionarySetForDebug != null && mOnlyDictionarySetForDebug.contains(key)) {
    Log.w(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
    return;
  }
  addOrReplaceDictionary(mDictionaries,key,dict);
}","private void addOrReplaceDictionaryInternal(final String key,final Dictionary dict){
  if (mOnlyDictionarySetForDebug != null && !mOnlyDictionarySetForDebug.contains(key)) {
    Log.w(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
    return;
  }
  addOrReplaceDictionary(mDictionaries,key,dict);
}",0.9983361064891848
87574,"/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  final SettingsValues currentSettings=mSettings.getCurrent();
  if (!mConnection.isCursorTouchingWord(currentSettings))   return;
  final TextRange range=mConnection.getWordRangeAtCursor(currentSettings.mWordSeparators,0);
  if (null == range)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final String typedWord=range.mWord.toString();
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.TYPE_RESUMED));
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(numberOfCharsInWordBeforeCursor);
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  final SuggestedWords suggestedWords;
  if (suggestions.isEmpty()) {
    final SuggestedWords suggestedWordsIncludingTypedWord=getSuggestedWords(Suggest.SESSION_TYPING);
    if (suggestedWordsIncludingTypedWord.size() > 1) {
      suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
    }
 else {
      suggestedWords=suggestedWordsIncludingTypedWord;
    }
  }
 else {
    suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
  }
  mIsAutoCorrectionIndicatorOn=false;
  showSuggestionStrip(suggestedWords,typedWord);
}","/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  final SettingsValues currentSettings=mSettings.getCurrent();
  if (!mConnection.isCursorTouchingWord(currentSettings))   return;
  final TextRange range=mConnection.getWordRangeAtCursor(currentSettings.mWordSeparators,0);
  if (null == range)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final String typedWord=range.mWord.toString();
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.TYPE_RESUMED));
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  final SuggestedWords suggestedWords;
  if (suggestions.isEmpty()) {
    final SuggestedWords suggestedWordsIncludingTypedWord=getSuggestedWords(Suggest.SESSION_TYPING);
    if (suggestedWordsIncludingTypedWord.size() > 1) {
      suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
    }
 else {
      suggestedWords=suggestedWordsIncludingTypedWord;
    }
  }
 else {
    suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
  }
  mIsAutoCorrectionIndicatorOn=false;
  showSuggestionStrip(suggestedWords,typedWord);
}",0.9934241427900424
87575,"/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  final SettingsValues currentSettings=mSettings.getCurrent();
  if (!mConnection.isCursorTouchingWord(currentSettings))   return;
  final TextRange range=mConnection.getWordRangeAtCursor(currentSettings.mWordSeparators,0);
  if (null == range)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final String typedWord=range.mWord.toString();
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.TYPE_RESUMED));
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(numberOfCharsInWordBeforeCursor);
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  final SuggestedWords suggestedWords;
  if (suggestions.isEmpty()) {
    final SuggestedWords suggestedWordsIncludingTypedWord=getSuggestedWords(Suggest.SESSION_TYPING);
    if (suggestedWordsIncludingTypedWord.size() > 1) {
      suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
    }
 else {
      suggestedWords=suggestedWordsIncludingTypedWord;
    }
  }
 else {
    suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
  }
  mIsAutoCorrectionIndicatorOn=false;
  showSuggestionStrip(suggestedWords,typedWord);
}","/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  final SettingsValues currentSettings=mSettings.getCurrent();
  if (!mConnection.isCursorTouchingWord(currentSettings))   return;
  final TextRange range=mConnection.getWordRangeAtCursor(currentSettings.mWordSeparators,0);
  if (null == range)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final String typedWord=range.mWord.toString();
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.TYPE_RESUMED));
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  final SuggestedWords suggestedWords;
  if (suggestions.isEmpty()) {
    final SuggestedWords suggestedWordsIncludingTypedWord=getSuggestedWords(Suggest.SESSION_TYPING);
    if (suggestedWordsIncludingTypedWord.size() > 1) {
      suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
    }
 else {
      suggestedWords=suggestedWordsIncludingTypedWord;
    }
  }
 else {
    suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
  }
  mIsAutoCorrectionIndicatorOn=false;
  showSuggestionStrip(suggestedWords,typedWord);
}",0.9934241427900424
87576,"/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  final SettingsValues currentSettings=mSettings.getCurrent();
  if (!mConnection.isCursorTouchingWord(currentSettings))   return;
  final TextRange range=mConnection.getWordRangeAtCursor(currentSettings.mWordSeparators,0);
  if (null == range)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final String typedWord=range.mWord.toString();
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.TYPE_RESUMED));
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(numberOfCharsInWordBeforeCursor);
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  final SuggestedWords suggestedWords;
  if (suggestions.isEmpty()) {
    final SuggestedWords suggestedWordsIncludingTypedWord=getSuggestedWords(Suggest.SESSION_TYPING);
    if (suggestedWordsIncludingTypedWord.size() > 1) {
      suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
    }
 else {
      suggestedWords=suggestedWordsIncludingTypedWord;
    }
  }
 else {
    suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
  }
  mIsAutoCorrectionIndicatorOn=false;
  showSuggestionStrip(suggestedWords,typedWord);
}","/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  final SettingsValues currentSettings=mSettings.getCurrent();
  if (!mConnection.isCursorTouchingWord(currentSettings))   return;
  final TextRange range=mConnection.getWordRangeAtCursor(currentSettings.mWordSeparators,0);
  if (null == range)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final String typedWord=range.mWord.toString();
  int i=0;
  for (  final SuggestionSpan span : range.getSuggestionSpansAtWord()) {
    for (    final String s : span.getSuggestions()) {
      ++i;
      if (!TextUtils.equals(s,typedWord)) {
        suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.TYPE_RESUMED));
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(typedWord.codePointCount(0,numberOfCharsInWordBeforeCursor));
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  final SuggestedWords suggestedWords;
  if (suggestions.isEmpty()) {
    final SuggestedWords suggestedWordsIncludingTypedWord=getSuggestedWords(Suggest.SESSION_TYPING);
    if (suggestedWordsIncludingTypedWord.size() > 1) {
      suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
    }
 else {
      suggestedWords=suggestedWordsIncludingTypedWord;
    }
  }
 else {
    suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
  }
  mIsAutoCorrectionIndicatorOn=false;
  showSuggestionStrip(suggestedWords,typedWord);
}",0.9934241427900424
87577,"public void loadSettings(final Locale locale,final InputAttributes inputAttributes){
  final SharedPreferences prefs=mPrefs;
  final RunInLocale<SettingsValues> job=new RunInLocale<SettingsValues>(){
    @Override protected SettingsValues job(    final Resources res){
      return new SettingsValues(prefs,locale,res,inputAttributes);
    }
  }
;
  mSettingsValues=job.runInLocale(mRes,locale);
}","public void loadSettings(final Locale locale,final InputAttributes inputAttributes){
  mSettingsValuesLock.lock();
  try {
    final SharedPreferences prefs=mPrefs;
    final RunInLocale<SettingsValues> job=new RunInLocale<SettingsValues>(){
      @Override protected SettingsValues job(      final Resources res){
        return new SettingsValues(prefs,locale,res,inputAttributes);
      }
    }
;
    mSettingsValues=job.runInLocale(mRes,locale);
  }
  finally {
    mSettingsValuesLock.unlock();
  }
}",0.8802660753880266
87578,"@Override public void onSharedPreferenceChanged(final SharedPreferences prefs,final String key){
  if (mSettingsValues == null) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  loadSettings(mSettingsValues.mLocale,mSettingsValues.mInputAttributes);
}","@Override public void onSharedPreferenceChanged(final SharedPreferences prefs,final String key){
  mSettingsValuesLock.lock();
  try {
    if (mSettingsValues == null) {
      Log.w(TAG,""String_Node_Str"");
      return;
    }
    loadSettings(mSettingsValues.mLocale,mSettingsValues.mInputAttributes);
  }
  finally {
    mSettingsValuesLock.unlock();
  }
}",0.8071895424836601
87579,"public Builder setIsSpellChecker(final boolean isSpellChecker){
  mParams.mIsSpellChecker=true;
  return this;
}","public Builder setIsSpellChecker(final boolean isSpellChecker){
  mParams.mIsSpellChecker=isSpellChecker;
  return this;
}",0.9316239316239316
87580,"public Builder setIsSpellChecker(final boolean isSpellChecker){
  mParams.mIsSpellChecker=true;
  return this;
}","public Builder setIsSpellChecker(final boolean isSpellChecker){
  mParams.mIsSpellChecker=isSpellChecker;
  return this;
}",0.9316239316239316
87581,"public void loadSettings(final Locale locale,final InputAttributes inputAttributes){
  final SharedPreferences prefs=mPrefs;
  final RunInLocale<SettingsValues> job=new RunInLocale<SettingsValues>(){
    @Override protected SettingsValues job(    final Resources res){
      return new SettingsValues(prefs,locale,res,inputAttributes);
    }
  }
;
  mSettingsValues=job.runInLocale(mRes,locale);
}","public void loadSettings(final Locale locale,final InputAttributes inputAttributes){
  mSettingsValuesLock.lock();
  try {
    final SharedPreferences prefs=mPrefs;
    final RunInLocale<SettingsValues> job=new RunInLocale<SettingsValues>(){
      @Override protected SettingsValues job(      final Resources res){
        return new SettingsValues(prefs,locale,res,inputAttributes);
      }
    }
;
    mSettingsValues=job.runInLocale(mRes,locale);
  }
  finally {
    mSettingsValuesLock.unlock();
  }
}",0.8802660753880266
87582,"@Override public void onSharedPreferenceChanged(final SharedPreferences prefs,final String key){
  if (mSettingsValues == null) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  loadSettings(mSettingsValues.mLocale,mSettingsValues.mInputAttributes);
}","@Override public void onSharedPreferenceChanged(final SharedPreferences prefs,final String key){
  mSettingsValuesLock.lock();
  try {
    if (mSettingsValues == null) {
      Log.w(TAG,""String_Node_Str"");
      return;
    }
    loadSettings(mSettingsValues.mLocale,mSettingsValues.mInputAttributes);
  }
  finally {
    mSettingsValuesLock.unlock();
  }
}",0.8071895424836601
87583,"public void loadSettings(final Locale locale,final InputAttributes inputAttributes){
  final SharedPreferences prefs=mPrefs;
  final RunInLocale<SettingsValues> job=new RunInLocale<SettingsValues>(){
    @Override protected SettingsValues job(    final Resources res){
      return new SettingsValues(prefs,locale,res,inputAttributes);
    }
  }
;
  mSettingsValues=job.runInLocale(mRes,locale);
}","public void loadSettings(final Locale locale,final InputAttributes inputAttributes){
  mSettingsValuesLock.lock();
  try {
    final SharedPreferences prefs=mPrefs;
    final RunInLocale<SettingsValues> job=new RunInLocale<SettingsValues>(){
      @Override protected SettingsValues job(      final Resources res){
        return new SettingsValues(prefs,locale,res,inputAttributes);
      }
    }
;
    mSettingsValues=job.runInLocale(mRes,locale);
  }
  finally {
    mSettingsValuesLock.unlock();
  }
}",0.8802660753880266
87584,"@Override public void onSharedPreferenceChanged(final SharedPreferences prefs,final String key){
  if (mSettingsValues == null) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  loadSettings(mSettingsValues.mLocale,mSettingsValues.mInputAttributes);
}","@Override public void onSharedPreferenceChanged(final SharedPreferences prefs,final String key){
  mSettingsValuesLock.lock();
  try {
    if (mSettingsValues == null) {
      Log.w(TAG,""String_Node_Str"");
      return;
    }
    loadSettings(mSettingsValues.mLocale,mSettingsValues.mInputAttributes);
  }
  finally {
    mSettingsValuesLock.unlock();
  }
}",0.8071895424836601
87585,"public Builder setIsSpellChecker(final boolean isSpellChecker){
  mParams.mIsSpellChecker=true;
  return this;
}","public Builder setIsSpellChecker(final boolean isSpellChecker){
  mParams.mIsSpellChecker=isSpellChecker;
  return this;
}",0.9316239316239316
87586,"@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  final SettingsValues currentSettingsValues=mSettings.getCurrent();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,prefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  final PackageInfo packageInfo=TargetPackageInfoGetterTask.getCachedPackageInfo(editorInfo.packageName);
  mAppWorkAroundsUtils.setPackageInfo(packageInfo);
  if (null == packageInfo) {
    new TargetPackageInfoGetterTask(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean inputTypeChanged=!currentSettingsValues.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    mSubtypeSwitcher.updateParametersOnStartInputView();
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  mEnteredText=null;
  resetComposingState(true);
  if (isDifferentTextField)   mHandler.postResumeSuggestions();
  mDeleteCount=0;
  mSpaceState=SPACE_STATE_NONE;
  mRecapitalizeStatus.deactivate();
  mCurrentlyPressedHardwareKeys.clear();
  final Locale currentLocale=mSubtypeSwitcher.getCurrentSubtypeLocale();
  if (null != mSuggest && null != currentLocale && !currentLocale.equals(mSuggest.mLocale)) {
    initSuggest();
  }
  if (mSuggestionStripView != null) {
    setPunctuationSuggestions();
  }
  mSuggestedWords=SuggestedWords.EMPTY;
  mConnection.resetCachesUponCursorMove(editorInfo.initialSelStart,false);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    if (mSuggest != null && currentSettingsValues.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(currentSettingsValues.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,currentSettingsValues);
  }
 else   if (restarting) {
    switcher.resetKeyboardStateToAlphabet();
    switcher.updateShiftState();
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacePeriodTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(currentSettingsValues.mKeyPreviewPopupOn,currentSettingsValues.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setSlidingKeyInputPreviewEnabled(currentSettingsValues.mSlidingKeyInputPreviewEnabled);
  mainKeyboardView.setGestureHandlingEnabledByUser(currentSettingsValues.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(currentSettingsValues.mGesturePreviewTrailEnabled,currentSettingsValues.mGestureFloatingPreviewTextEnabled);
  if (null != mPositionalInfoForUserDictPendingAddition && mPositionalInfoForUserDictPendingAddition.tryReplaceWithActualWord(mConnection,editorInfo,mLastSelectionEnd,currentLocale)) {
    mPositionalInfoForUserDictPendingAddition=null;
  }
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  SettingsValues currentSettingsValues=mSettings.getCurrent();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,prefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  final PackageInfo packageInfo=TargetPackageInfoGetterTask.getCachedPackageInfo(editorInfo.packageName);
  mAppWorkAroundsUtils.setPackageInfo(packageInfo);
  if (null == packageInfo) {
    new TargetPackageInfoGetterTask(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean inputTypeChanged=!currentSettingsValues.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    mSubtypeSwitcher.updateParametersOnStartInputView();
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  mEnteredText=null;
  resetComposingState(true);
  if (isDifferentTextField)   mHandler.postResumeSuggestions();
  mDeleteCount=0;
  mSpaceState=SPACE_STATE_NONE;
  mRecapitalizeStatus.deactivate();
  mCurrentlyPressedHardwareKeys.clear();
  final Locale currentLocale=mSubtypeSwitcher.getCurrentSubtypeLocale();
  if (null != mSuggest && null != currentLocale && !currentLocale.equals(mSuggest.mLocale)) {
    initSuggest();
  }
  if (mSuggestionStripView != null) {
    setPunctuationSuggestions();
  }
  mSuggestedWords=SuggestedWords.EMPTY;
  mConnection.resetCachesUponCursorMove(editorInfo.initialSelStart,false);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    currentSettingsValues=mSettings.getCurrent();
    if (mSuggest != null && currentSettingsValues.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(currentSettingsValues.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,currentSettingsValues);
  }
 else   if (restarting) {
    switcher.resetKeyboardStateToAlphabet();
    switcher.updateShiftState();
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacePeriodTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(currentSettingsValues.mKeyPreviewPopupOn,currentSettingsValues.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setSlidingKeyInputPreviewEnabled(currentSettingsValues.mSlidingKeyInputPreviewEnabled);
  mainKeyboardView.setGestureHandlingEnabledByUser(currentSettingsValues.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(currentSettingsValues.mGesturePreviewTrailEnabled,currentSettingsValues.mGestureFloatingPreviewTextEnabled);
  if (null != mPositionalInfoForUserDictPendingAddition && mPositionalInfoForUserDictPendingAddition.tryReplaceWithActualWord(mConnection,editorInfo,mLastSelectionEnd,currentLocale)) {
    mPositionalInfoForUserDictPendingAddition=null;
  }
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}",0.9940589857840016
87587,"@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  final SettingsValues currentSettingsValues=mSettings.getCurrent();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,prefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  final PackageInfo packageInfo=TargetPackageInfoGetterTask.getCachedPackageInfo(editorInfo.packageName);
  mAppWorkAroundsUtils.setPackageInfo(packageInfo);
  if (null == packageInfo) {
    new TargetPackageInfoGetterTask(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean inputTypeChanged=!currentSettingsValues.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    mSubtypeSwitcher.updateParametersOnStartInputView();
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  mEnteredText=null;
  resetComposingState(true);
  if (isDifferentTextField)   mHandler.postResumeSuggestions();
  mDeleteCount=0;
  mSpaceState=SPACE_STATE_NONE;
  mRecapitalizeStatus.deactivate();
  mCurrentlyPressedHardwareKeys.clear();
  final Locale currentLocale=mSubtypeSwitcher.getCurrentSubtypeLocale();
  if (null != mSuggest && null != currentLocale && !currentLocale.equals(mSuggest.mLocale)) {
    initSuggest();
  }
  if (mSuggestionStripView != null) {
    setPunctuationSuggestions();
  }
  mSuggestedWords=SuggestedWords.EMPTY;
  mConnection.resetCachesUponCursorMove(editorInfo.initialSelStart,false);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    if (mSuggest != null && currentSettingsValues.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(currentSettingsValues.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,currentSettingsValues);
  }
 else   if (restarting) {
    switcher.resetKeyboardStateToAlphabet();
    switcher.updateShiftState();
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacePeriodTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(currentSettingsValues.mKeyPreviewPopupOn,currentSettingsValues.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setSlidingKeyInputPreviewEnabled(currentSettingsValues.mSlidingKeyInputPreviewEnabled);
  mainKeyboardView.setGestureHandlingEnabledByUser(currentSettingsValues.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(currentSettingsValues.mGesturePreviewTrailEnabled,currentSettingsValues.mGestureFloatingPreviewTextEnabled);
  if (null != mPositionalInfoForUserDictPendingAddition && mPositionalInfoForUserDictPendingAddition.tryReplaceWithActualWord(mConnection,editorInfo,mLastSelectionEnd,currentLocale)) {
    mPositionalInfoForUserDictPendingAddition=null;
  }
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  SettingsValues currentSettingsValues=mSettings.getCurrent();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,prefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  final PackageInfo packageInfo=TargetPackageInfoGetterTask.getCachedPackageInfo(editorInfo.packageName);
  mAppWorkAroundsUtils.setPackageInfo(packageInfo);
  if (null == packageInfo) {
    new TargetPackageInfoGetterTask(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean inputTypeChanged=!currentSettingsValues.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    mSubtypeSwitcher.updateParametersOnStartInputView();
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  mEnteredText=null;
  resetComposingState(true);
  if (isDifferentTextField)   mHandler.postResumeSuggestions();
  mDeleteCount=0;
  mSpaceState=SPACE_STATE_NONE;
  mRecapitalizeStatus.deactivate();
  mCurrentlyPressedHardwareKeys.clear();
  final Locale currentLocale=mSubtypeSwitcher.getCurrentSubtypeLocale();
  if (null != mSuggest && null != currentLocale && !currentLocale.equals(mSuggest.mLocale)) {
    initSuggest();
  }
  if (mSuggestionStripView != null) {
    setPunctuationSuggestions();
  }
  mSuggestedWords=SuggestedWords.EMPTY;
  mConnection.resetCachesUponCursorMove(editorInfo.initialSelStart,false);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    currentSettingsValues=mSettings.getCurrent();
    if (mSuggest != null && currentSettingsValues.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(currentSettingsValues.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,currentSettingsValues);
  }
 else   if (restarting) {
    switcher.resetKeyboardStateToAlphabet();
    switcher.updateShiftState();
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacePeriodTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(currentSettingsValues.mKeyPreviewPopupOn,currentSettingsValues.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setSlidingKeyInputPreviewEnabled(currentSettingsValues.mSlidingKeyInputPreviewEnabled);
  mainKeyboardView.setGestureHandlingEnabledByUser(currentSettingsValues.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(currentSettingsValues.mGesturePreviewTrailEnabled,currentSettingsValues.mGestureFloatingPreviewTextEnabled);
  if (null != mPositionalInfoForUserDictPendingAddition && mPositionalInfoForUserDictPendingAddition.tryReplaceWithActualWord(mConnection,editorInfo,mLastSelectionEnd,currentLocale)) {
    mPositionalInfoForUserDictPendingAddition=null;
  }
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}",0.9940589857840016
87588,"@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  final SettingsValues currentSettingsValues=mSettings.getCurrent();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,prefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  final PackageInfo packageInfo=TargetPackageInfoGetterTask.getCachedPackageInfo(editorInfo.packageName);
  mAppWorkAroundsUtils.setPackageInfo(packageInfo);
  if (null == packageInfo) {
    new TargetPackageInfoGetterTask(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean inputTypeChanged=!currentSettingsValues.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    mSubtypeSwitcher.updateParametersOnStartInputView();
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  mEnteredText=null;
  resetComposingState(true);
  if (isDifferentTextField)   mHandler.postResumeSuggestions();
  mDeleteCount=0;
  mSpaceState=SPACE_STATE_NONE;
  mRecapitalizeStatus.deactivate();
  mCurrentlyPressedHardwareKeys.clear();
  final Locale currentLocale=mSubtypeSwitcher.getCurrentSubtypeLocale();
  if (null != mSuggest && null != currentLocale && !currentLocale.equals(mSuggest.mLocale)) {
    initSuggest();
  }
  if (mSuggestionStripView != null) {
    setPunctuationSuggestions();
  }
  mSuggestedWords=SuggestedWords.EMPTY;
  mConnection.resetCachesUponCursorMove(editorInfo.initialSelStart,false);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    if (mSuggest != null && currentSettingsValues.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(currentSettingsValues.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,currentSettingsValues);
  }
 else   if (restarting) {
    switcher.resetKeyboardStateToAlphabet();
    switcher.updateShiftState();
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacePeriodTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(currentSettingsValues.mKeyPreviewPopupOn,currentSettingsValues.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setSlidingKeyInputPreviewEnabled(currentSettingsValues.mSlidingKeyInputPreviewEnabled);
  mainKeyboardView.setGestureHandlingEnabledByUser(currentSettingsValues.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(currentSettingsValues.mGesturePreviewTrailEnabled,currentSettingsValues.mGestureFloatingPreviewTextEnabled);
  if (null != mPositionalInfoForUserDictPendingAddition && mPositionalInfoForUserDictPendingAddition.tryReplaceWithActualWord(mConnection,editorInfo,mLastSelectionEnd,currentLocale)) {
    mPositionalInfoForUserDictPendingAddition=null;
  }
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  SettingsValues currentSettingsValues=mSettings.getCurrent();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,prefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  final PackageInfo packageInfo=TargetPackageInfoGetterTask.getCachedPackageInfo(editorInfo.packageName);
  mAppWorkAroundsUtils.setPackageInfo(packageInfo);
  if (null == packageInfo) {
    new TargetPackageInfoGetterTask(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean inputTypeChanged=!currentSettingsValues.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    mSubtypeSwitcher.updateParametersOnStartInputView();
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  mEnteredText=null;
  resetComposingState(true);
  if (isDifferentTextField)   mHandler.postResumeSuggestions();
  mDeleteCount=0;
  mSpaceState=SPACE_STATE_NONE;
  mRecapitalizeStatus.deactivate();
  mCurrentlyPressedHardwareKeys.clear();
  final Locale currentLocale=mSubtypeSwitcher.getCurrentSubtypeLocale();
  if (null != mSuggest && null != currentLocale && !currentLocale.equals(mSuggest.mLocale)) {
    initSuggest();
  }
  if (mSuggestionStripView != null) {
    setPunctuationSuggestions();
  }
  mSuggestedWords=SuggestedWords.EMPTY;
  mConnection.resetCachesUponCursorMove(editorInfo.initialSelStart,false);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    currentSettingsValues=mSettings.getCurrent();
    if (mSuggest != null && currentSettingsValues.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(currentSettingsValues.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,currentSettingsValues);
  }
 else   if (restarting) {
    switcher.resetKeyboardStateToAlphabet();
    switcher.updateShiftState();
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacePeriodTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(currentSettingsValues.mKeyPreviewPopupOn,currentSettingsValues.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setSlidingKeyInputPreviewEnabled(currentSettingsValues.mSlidingKeyInputPreviewEnabled);
  mainKeyboardView.setGestureHandlingEnabledByUser(currentSettingsValues.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(currentSettingsValues.mGesturePreviewTrailEnabled,currentSettingsValues.mGestureFloatingPreviewTextEnabled);
  if (null != mPositionalInfoForUserDictPendingAddition && mPositionalInfoForUserDictPendingAddition.tryReplaceWithActualWord(mConnection,editorInfo,mLastSelectionEnd,currentLocale)) {
    mPositionalInfoForUserDictPendingAddition=null;
  }
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}",0.9940589857840016
87589,"UserDictionaryAddWordContents(final View view,final Bundle args){
  mWordEditText=(EditText)view.findViewById(R.id.user_dictionary_add_word_text);
  mShortcutEditText=(EditText)view.findViewById(R.id.user_dictionary_add_shortcut);
  if (!UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    mShortcutEditText.setVisibility(View.GONE);
    view.findViewById(R.id.user_dictionary_add_shortcut_label).setVisibility(View.GONE);
  }
  final String word=args.getString(EXTRA_WORD);
  if (null != word) {
    mWordEditText.setText(word);
    mWordEditText.setSelection(mWordEditText.getText().length());
  }
  final String shortcut;
  if (UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    shortcut=args.getString(EXTRA_SHORTCUT);
    if (null != shortcut && null != mShortcutEditText) {
      mShortcutEditText.setText(shortcut);
    }
    mOldShortcut=args.getString(EXTRA_SHORTCUT);
  }
 else {
    shortcut=null;
    mOldShortcut=null;
  }
  mMode=args.getInt(EXTRA_MODE);
  mOldWord=args.getString(EXTRA_WORD);
  updateLocale(args.getString(EXTRA_LOCALE));
}","UserDictionaryAddWordContents(final View view,final UserDictionaryAddWordContents oldInstanceToBeEdited){
  mWordEditText=(EditText)view.findViewById(R.id.user_dictionary_add_word_text);
  mShortcutEditText=(EditText)view.findViewById(R.id.user_dictionary_add_shortcut);
  mMode=MODE_EDIT;
  mOldWord=oldInstanceToBeEdited.mSavedWord;
  mOldShortcut=oldInstanceToBeEdited.mSavedShortcut;
  updateLocale(mLocale);
}",0.3599458728010825
87590,"int apply(final Context context,final Bundle outParameters){
  if (null != outParameters)   saveStateIntoBundle(outParameters);
  final ContentResolver resolver=context.getContentResolver();
  if (MODE_EDIT == mMode && !TextUtils.isEmpty(mOldWord)) {
    UserDictionarySettings.deleteWord(mOldWord,mOldShortcut,resolver);
  }
  final String newWord=mWordEditText.getText().toString();
  final String newShortcut;
  if (!UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    newShortcut=null;
  }
 else   if (null == mShortcutEditText) {
    newShortcut=null;
  }
 else {
    final String tmpShortcut=mShortcutEditText.getText().toString();
    if (TextUtils.isEmpty(tmpShortcut)) {
      newShortcut=null;
    }
 else {
      newShortcut=tmpShortcut;
    }
  }
  if (TextUtils.isEmpty(newWord)) {
    return CODE_CANCEL;
  }
  if (hasWord(newWord,context))   return CODE_ALREADY_PRESENT;
  UserDictionarySettings.deleteWord(newWord,null,resolver);
  if (!TextUtils.isEmpty(newShortcut)) {
    UserDictionarySettings.deleteWord(newWord,newShortcut,resolver);
  }
  UserDictionaryCompatUtils.addWord(context,newWord.toString(),FREQUENCY_FOR_USER_DICTIONARY_ADDS,newShortcut,TextUtils.isEmpty(mLocale) ? null : LocaleUtils.constructLocaleFromString(mLocale));
  return CODE_WORD_ADDED;
}","int apply(final Context context,final Bundle outParameters){
  if (null != outParameters)   saveStateIntoBundle(outParameters);
  final ContentResolver resolver=context.getContentResolver();
  if (MODE_EDIT == mMode && !TextUtils.isEmpty(mOldWord)) {
    UserDictionarySettings.deleteWord(mOldWord,mOldShortcut,resolver);
  }
  final String newWord=mWordEditText.getText().toString();
  final String newShortcut;
  if (!UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    newShortcut=null;
  }
 else   if (null == mShortcutEditText) {
    newShortcut=null;
  }
 else {
    final String tmpShortcut=mShortcutEditText.getText().toString();
    if (TextUtils.isEmpty(tmpShortcut)) {
      newShortcut=null;
    }
 else {
      newShortcut=tmpShortcut;
    }
  }
  if (TextUtils.isEmpty(newWord)) {
    return CODE_CANCEL;
  }
  mSavedWord=newWord;
  mSavedShortcut=newShortcut;
  if (hasWord(newWord,context))   return CODE_ALREADY_PRESENT;
  UserDictionarySettings.deleteWord(newWord,null,resolver);
  if (!TextUtils.isEmpty(newShortcut)) {
    UserDictionarySettings.deleteWord(newWord,newShortcut,resolver);
  }
  UserDictionaryCompatUtils.addWord(context,newWord.toString(),FREQUENCY_FOR_USER_DICTIONARY_ADDS,newShortcut,TextUtils.isEmpty(mLocale) ? null : LocaleUtils.constructLocaleFromString(mLocale));
  return CODE_WORD_ADDED;
}",0.9801829268292684
87591,"@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  setHasOptionsMenu(true);
}","@Override public void onActivityCreated(final Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  setHasOptionsMenu(true);
  setRetainInstance(true);
}",0.896551724137931
87592,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedState){
  mRootView=inflater.inflate(R.layout.user_dictionary_add_word_fullscreen,null);
  mIsDeleting=false;
  if (null == mContents) {
    mContents=new UserDictionaryAddWordContents(mRootView,getArguments());
  }
  return mRootView;
}","@Override public View onCreateView(final LayoutInflater inflater,final ViewGroup container,final Bundle savedState){
  mRootView=inflater.inflate(R.layout.user_dictionary_add_word_fullscreen,null);
  mIsDeleting=false;
  if (null == mContents) {
    mContents=new UserDictionaryAddWordContents(mRootView,getArguments());
  }
 else {
    mContents=new UserDictionaryAddWordContents(mRootView,mContents);
  }
  return mRootView;
}",0.8465608465608465
87593,"@Override public void onCreateOptionsMenu(Menu menu,MenuInflater inflater){
  final MenuItem actionItemAdd=menu.add(0,OPTIONS_MENU_ADD,0,R.string.user_dict_settings_add_menu_title).setIcon(R.drawable.ic_menu_add);
  actionItemAdd.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
  final MenuItem actionItemDelete=menu.add(0,OPTIONS_MENU_DELETE,0,R.string.user_dict_settings_delete).setIcon(android.R.drawable.ic_menu_delete);
  actionItemDelete.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
}","@Override public void onCreateOptionsMenu(final Menu menu,final MenuInflater inflater){
  final MenuItem actionItemAdd=menu.add(0,OPTIONS_MENU_ADD,0,R.string.user_dict_settings_add_menu_title).setIcon(R.drawable.ic_menu_add);
  actionItemAdd.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
  final MenuItem actionItemDelete=menu.add(0,OPTIONS_MENU_DELETE,0,R.string.user_dict_settings_delete).setIcon(android.R.drawable.ic_menu_delete);
  actionItemDelete.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
}",0.9721739130434782
87594,"UserDictionaryAddWordContents(final View view,final Bundle args){
  mWordEditText=(EditText)view.findViewById(R.id.user_dictionary_add_word_text);
  mShortcutEditText=(EditText)view.findViewById(R.id.user_dictionary_add_shortcut);
  if (!UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    mShortcutEditText.setVisibility(View.GONE);
    view.findViewById(R.id.user_dictionary_add_shortcut_label).setVisibility(View.GONE);
  }
  final String word=args.getString(EXTRA_WORD);
  if (null != word) {
    mWordEditText.setText(word);
    mWordEditText.setSelection(mWordEditText.getText().length());
  }
  final String shortcut;
  if (UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    shortcut=args.getString(EXTRA_SHORTCUT);
    if (null != shortcut && null != mShortcutEditText) {
      mShortcutEditText.setText(shortcut);
    }
    mOldShortcut=args.getString(EXTRA_SHORTCUT);
  }
 else {
    shortcut=null;
    mOldShortcut=null;
  }
  mMode=args.getInt(EXTRA_MODE);
  mOldWord=args.getString(EXTRA_WORD);
  updateLocale(args.getString(EXTRA_LOCALE));
}","UserDictionaryAddWordContents(final View view,final UserDictionaryAddWordContents oldInstanceToBeEdited){
  mWordEditText=(EditText)view.findViewById(R.id.user_dictionary_add_word_text);
  mShortcutEditText=(EditText)view.findViewById(R.id.user_dictionary_add_shortcut);
  mMode=MODE_EDIT;
  mOldWord=oldInstanceToBeEdited.mSavedWord;
  mOldShortcut=oldInstanceToBeEdited.mSavedShortcut;
  updateLocale(mLocale);
}",0.3599458728010825
87595,"int apply(final Context context,final Bundle outParameters){
  if (null != outParameters)   saveStateIntoBundle(outParameters);
  final ContentResolver resolver=context.getContentResolver();
  if (MODE_EDIT == mMode && !TextUtils.isEmpty(mOldWord)) {
    UserDictionarySettings.deleteWord(mOldWord,mOldShortcut,resolver);
  }
  final String newWord=mWordEditText.getText().toString();
  final String newShortcut;
  if (!UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    newShortcut=null;
  }
 else   if (null == mShortcutEditText) {
    newShortcut=null;
  }
 else {
    final String tmpShortcut=mShortcutEditText.getText().toString();
    if (TextUtils.isEmpty(tmpShortcut)) {
      newShortcut=null;
    }
 else {
      newShortcut=tmpShortcut;
    }
  }
  if (TextUtils.isEmpty(newWord)) {
    return CODE_CANCEL;
  }
  if (hasWord(newWord,context))   return CODE_ALREADY_PRESENT;
  UserDictionarySettings.deleteWord(newWord,null,resolver);
  if (!TextUtils.isEmpty(newShortcut)) {
    UserDictionarySettings.deleteWord(newWord,newShortcut,resolver);
  }
  UserDictionaryCompatUtils.addWord(context,newWord.toString(),FREQUENCY_FOR_USER_DICTIONARY_ADDS,newShortcut,TextUtils.isEmpty(mLocale) ? null : LocaleUtils.constructLocaleFromString(mLocale));
  return CODE_WORD_ADDED;
}","int apply(final Context context,final Bundle outParameters){
  if (null != outParameters)   saveStateIntoBundle(outParameters);
  final ContentResolver resolver=context.getContentResolver();
  if (MODE_EDIT == mMode && !TextUtils.isEmpty(mOldWord)) {
    UserDictionarySettings.deleteWord(mOldWord,mOldShortcut,resolver);
  }
  final String newWord=mWordEditText.getText().toString();
  final String newShortcut;
  if (!UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    newShortcut=null;
  }
 else   if (null == mShortcutEditText) {
    newShortcut=null;
  }
 else {
    final String tmpShortcut=mShortcutEditText.getText().toString();
    if (TextUtils.isEmpty(tmpShortcut)) {
      newShortcut=null;
    }
 else {
      newShortcut=tmpShortcut;
    }
  }
  if (TextUtils.isEmpty(newWord)) {
    return CODE_CANCEL;
  }
  mSavedWord=newWord;
  mSavedShortcut=newShortcut;
  if (hasWord(newWord,context))   return CODE_ALREADY_PRESENT;
  UserDictionarySettings.deleteWord(newWord,null,resolver);
  if (!TextUtils.isEmpty(newShortcut)) {
    UserDictionarySettings.deleteWord(newWord,newShortcut,resolver);
  }
  UserDictionaryCompatUtils.addWord(context,newWord.toString(),FREQUENCY_FOR_USER_DICTIONARY_ADDS,newShortcut,TextUtils.isEmpty(mLocale) ? null : LocaleUtils.constructLocaleFromString(mLocale));
  return CODE_WORD_ADDED;
}",0.9801829268292684
87596,"@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  setHasOptionsMenu(true);
}","@Override public void onActivityCreated(final Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  setHasOptionsMenu(true);
  setRetainInstance(true);
}",0.896551724137931
87597,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedState){
  mRootView=inflater.inflate(R.layout.user_dictionary_add_word_fullscreen,null);
  mIsDeleting=false;
  if (null == mContents) {
    mContents=new UserDictionaryAddWordContents(mRootView,getArguments());
  }
  return mRootView;
}","@Override public View onCreateView(final LayoutInflater inflater,final ViewGroup container,final Bundle savedState){
  mRootView=inflater.inflate(R.layout.user_dictionary_add_word_fullscreen,null);
  mIsDeleting=false;
  if (null == mContents) {
    mContents=new UserDictionaryAddWordContents(mRootView,getArguments());
  }
 else {
    mContents=new UserDictionaryAddWordContents(mRootView,mContents);
  }
  return mRootView;
}",0.8465608465608465
87598,"@Override public void onCreateOptionsMenu(Menu menu,MenuInflater inflater){
  final MenuItem actionItemAdd=menu.add(0,OPTIONS_MENU_ADD,0,R.string.user_dict_settings_add_menu_title).setIcon(R.drawable.ic_menu_add);
  actionItemAdd.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
  final MenuItem actionItemDelete=menu.add(0,OPTIONS_MENU_DELETE,0,R.string.user_dict_settings_delete).setIcon(android.R.drawable.ic_menu_delete);
  actionItemDelete.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
}","@Override public void onCreateOptionsMenu(final Menu menu,final MenuInflater inflater){
  final MenuItem actionItemAdd=menu.add(0,OPTIONS_MENU_ADD,0,R.string.user_dict_settings_add_menu_title).setIcon(R.drawable.ic_menu_add);
  actionItemAdd.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
  final MenuItem actionItemDelete=menu.add(0,OPTIONS_MENU_DELETE,0,R.string.user_dict_settings_delete).setIcon(android.R.drawable.ic_menu_delete);
  actionItemDelete.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
}",0.9721739130434782
87599,"UserDictionaryAddWordContents(final View view,final Bundle args){
  mWordEditText=(EditText)view.findViewById(R.id.user_dictionary_add_word_text);
  mShortcutEditText=(EditText)view.findViewById(R.id.user_dictionary_add_shortcut);
  if (!UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    mShortcutEditText.setVisibility(View.GONE);
    view.findViewById(R.id.user_dictionary_add_shortcut_label).setVisibility(View.GONE);
  }
  final String word=args.getString(EXTRA_WORD);
  if (null != word) {
    mWordEditText.setText(word);
    mWordEditText.setSelection(mWordEditText.getText().length());
  }
  final String shortcut;
  if (UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    shortcut=args.getString(EXTRA_SHORTCUT);
    if (null != shortcut && null != mShortcutEditText) {
      mShortcutEditText.setText(shortcut);
    }
    mOldShortcut=args.getString(EXTRA_SHORTCUT);
  }
 else {
    shortcut=null;
    mOldShortcut=null;
  }
  mMode=args.getInt(EXTRA_MODE);
  mOldWord=args.getString(EXTRA_WORD);
  updateLocale(args.getString(EXTRA_LOCALE));
}","UserDictionaryAddWordContents(final View view,final UserDictionaryAddWordContents oldInstanceToBeEdited){
  mWordEditText=(EditText)view.findViewById(R.id.user_dictionary_add_word_text);
  mShortcutEditText=(EditText)view.findViewById(R.id.user_dictionary_add_shortcut);
  mMode=MODE_EDIT;
  mOldWord=oldInstanceToBeEdited.mSavedWord;
  mOldShortcut=oldInstanceToBeEdited.mSavedShortcut;
  updateLocale(mLocale);
}",0.3599458728010825
87600,"int apply(final Context context,final Bundle outParameters){
  if (null != outParameters)   saveStateIntoBundle(outParameters);
  final ContentResolver resolver=context.getContentResolver();
  if (MODE_EDIT == mMode && !TextUtils.isEmpty(mOldWord)) {
    UserDictionarySettings.deleteWord(mOldWord,mOldShortcut,resolver);
  }
  final String newWord=mWordEditText.getText().toString();
  final String newShortcut;
  if (!UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    newShortcut=null;
  }
 else   if (null == mShortcutEditText) {
    newShortcut=null;
  }
 else {
    final String tmpShortcut=mShortcutEditText.getText().toString();
    if (TextUtils.isEmpty(tmpShortcut)) {
      newShortcut=null;
    }
 else {
      newShortcut=tmpShortcut;
    }
  }
  if (TextUtils.isEmpty(newWord)) {
    return CODE_CANCEL;
  }
  if (hasWord(newWord,context))   return CODE_ALREADY_PRESENT;
  UserDictionarySettings.deleteWord(newWord,null,resolver);
  if (!TextUtils.isEmpty(newShortcut)) {
    UserDictionarySettings.deleteWord(newWord,newShortcut,resolver);
  }
  UserDictionaryCompatUtils.addWord(context,newWord.toString(),FREQUENCY_FOR_USER_DICTIONARY_ADDS,newShortcut,TextUtils.isEmpty(mLocale) ? null : LocaleUtils.constructLocaleFromString(mLocale));
  return CODE_WORD_ADDED;
}","int apply(final Context context,final Bundle outParameters){
  if (null != outParameters)   saveStateIntoBundle(outParameters);
  final ContentResolver resolver=context.getContentResolver();
  if (MODE_EDIT == mMode && !TextUtils.isEmpty(mOldWord)) {
    UserDictionarySettings.deleteWord(mOldWord,mOldShortcut,resolver);
  }
  final String newWord=mWordEditText.getText().toString();
  final String newShortcut;
  if (!UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    newShortcut=null;
  }
 else   if (null == mShortcutEditText) {
    newShortcut=null;
  }
 else {
    final String tmpShortcut=mShortcutEditText.getText().toString();
    if (TextUtils.isEmpty(tmpShortcut)) {
      newShortcut=null;
    }
 else {
      newShortcut=tmpShortcut;
    }
  }
  if (TextUtils.isEmpty(newWord)) {
    return CODE_CANCEL;
  }
  mSavedWord=newWord;
  mSavedShortcut=newShortcut;
  if (hasWord(newWord,context))   return CODE_ALREADY_PRESENT;
  UserDictionarySettings.deleteWord(newWord,null,resolver);
  if (!TextUtils.isEmpty(newShortcut)) {
    UserDictionarySettings.deleteWord(newWord,newShortcut,resolver);
  }
  UserDictionaryCompatUtils.addWord(context,newWord.toString(),FREQUENCY_FOR_USER_DICTIONARY_ADDS,newShortcut,TextUtils.isEmpty(mLocale) ? null : LocaleUtils.constructLocaleFromString(mLocale));
  return CODE_WORD_ADDED;
}",0.9801829268292684
87601,"@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  setHasOptionsMenu(true);
}","@Override public void onActivityCreated(final Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  setHasOptionsMenu(true);
  setRetainInstance(true);
}",0.896551724137931
87602,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedState){
  mRootView=inflater.inflate(R.layout.user_dictionary_add_word_fullscreen,null);
  mIsDeleting=false;
  if (null == mContents) {
    mContents=new UserDictionaryAddWordContents(mRootView,getArguments());
  }
  return mRootView;
}","@Override public View onCreateView(final LayoutInflater inflater,final ViewGroup container,final Bundle savedState){
  mRootView=inflater.inflate(R.layout.user_dictionary_add_word_fullscreen,null);
  mIsDeleting=false;
  if (null == mContents) {
    mContents=new UserDictionaryAddWordContents(mRootView,getArguments());
  }
 else {
    mContents=new UserDictionaryAddWordContents(mRootView,mContents);
  }
  return mRootView;
}",0.8465608465608465
87603,"@Override public void onCreateOptionsMenu(Menu menu,MenuInflater inflater){
  final MenuItem actionItemAdd=menu.add(0,OPTIONS_MENU_ADD,0,R.string.user_dict_settings_add_menu_title).setIcon(R.drawable.ic_menu_add);
  actionItemAdd.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
  final MenuItem actionItemDelete=menu.add(0,OPTIONS_MENU_DELETE,0,R.string.user_dict_settings_delete).setIcon(android.R.drawable.ic_menu_delete);
  actionItemDelete.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
}","@Override public void onCreateOptionsMenu(final Menu menu,final MenuInflater inflater){
  final MenuItem actionItemAdd=menu.add(0,OPTIONS_MENU_ADD,0,R.string.user_dict_settings_add_menu_title).setIcon(R.drawable.ic_menu_add);
  actionItemAdd.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
  final MenuItem actionItemDelete=menu.add(0,OPTIONS_MENU_DELETE,0,R.string.user_dict_settings_delete).setIcon(android.R.drawable.ic_menu_delete);
  actionItemDelete.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
}",0.9721739130434782
87604,"/** 
 * When the cursor is moved by the user, we need to update its position. If it falls inside the currently composing word, we don't reset the composition, and only update the cursor position.
 * @param expectedMoveAmount How many java chars to move the cursor. Negative values movethe cursor backward, positive values move the cursor forward.
 * @return true if the cursor is still inside the composing word, false otherwise.
 */
public boolean moveCursorByAndReturnIfInsideComposingWord(final int expectedMoveAmount){
  int actualMoveAmountWithinWord=0;
  int cursorPos=mCursorPositionWithinWord;
  if (expectedMoveAmount >= 0) {
    while (actualMoveAmountWithinWord < expectedMoveAmount && cursorPos < mCodePointSize) {
      actualMoveAmountWithinWord+=Character.charCount(mPrimaryKeyCodes[cursorPos]);
      ++cursorPos;
    }
  }
 else {
    while (actualMoveAmountWithinWord > expectedMoveAmount && cursorPos > 0) {
      --cursorPos;
      actualMoveAmountWithinWord-=Character.charCount(mPrimaryKeyCodes[cursorPos]);
    }
  }
  if (actualMoveAmountWithinWord != expectedMoveAmount)   return false;
  mCursorPositionWithinWord=cursorPos;
  return true;
}","/** 
 * When the cursor is moved by the user, we need to update its position. If it falls inside the currently composing word, we don't reset the composition, and only update the cursor position.
 * @param expectedMoveAmount How many java chars to move the cursor. Negative values movethe cursor backward, positive values move the cursor forward.
 * @return true if the cursor is still inside the composing word, false otherwise.
 */
public boolean moveCursorByAndReturnIfInsideComposingWord(final int expectedMoveAmount){
  int actualMoveAmountWithinWord=0;
  int cursorPos=mCursorPositionWithinWord;
  final int[] codePoints;
  if (mCodePointSize >= MAX_WORD_LENGTH) {
    codePoints=StringUtils.toCodePointArray(mTypedWord.toString());
  }
 else {
    codePoints=mPrimaryKeyCodes;
  }
  if (expectedMoveAmount >= 0) {
    while (actualMoveAmountWithinWord < expectedMoveAmount && cursorPos < mCodePointSize) {
      actualMoveAmountWithinWord+=Character.charCount(codePoints[cursorPos]);
      ++cursorPos;
    }
  }
 else {
    while (actualMoveAmountWithinWord > expectedMoveAmount && cursorPos > 0) {
      --cursorPos;
      actualMoveAmountWithinWord-=Character.charCount(codePoints[cursorPos]);
    }
  }
  if (actualMoveAmountWithinWord != expectedMoveAmount)   return false;
  mCursorPositionWithinWord=cursorPos;
  return true;
}",0.9066985645933014
87605,"/** 
 * When the cursor is moved by the user, we need to update its position. If it falls inside the currently composing word, we don't reset the composition, and only update the cursor position.
 * @param expectedMoveAmount How many java chars to move the cursor. Negative values movethe cursor backward, positive values move the cursor forward.
 * @return true if the cursor is still inside the composing word, false otherwise.
 */
public boolean moveCursorByAndReturnIfInsideComposingWord(final int expectedMoveAmount){
  int actualMoveAmountWithinWord=0;
  int cursorPos=mCursorPositionWithinWord;
  if (expectedMoveAmount >= 0) {
    while (actualMoveAmountWithinWord < expectedMoveAmount && cursorPos < mCodePointSize) {
      actualMoveAmountWithinWord+=Character.charCount(mPrimaryKeyCodes[cursorPos]);
      ++cursorPos;
    }
  }
 else {
    while (actualMoveAmountWithinWord > expectedMoveAmount && cursorPos > 0) {
      --cursorPos;
      actualMoveAmountWithinWord-=Character.charCount(mPrimaryKeyCodes[cursorPos]);
    }
  }
  if (actualMoveAmountWithinWord != expectedMoveAmount)   return false;
  mCursorPositionWithinWord=cursorPos;
  return true;
}","/** 
 * When the cursor is moved by the user, we need to update its position. If it falls inside the currently composing word, we don't reset the composition, and only update the cursor position.
 * @param expectedMoveAmount How many java chars to move the cursor. Negative values movethe cursor backward, positive values move the cursor forward.
 * @return true if the cursor is still inside the composing word, false otherwise.
 */
public boolean moveCursorByAndReturnIfInsideComposingWord(final int expectedMoveAmount){
  int actualMoveAmountWithinWord=0;
  int cursorPos=mCursorPositionWithinWord;
  final int[] codePoints;
  if (mCodePointSize >= MAX_WORD_LENGTH) {
    codePoints=StringUtils.toCodePointArray(mTypedWord.toString());
  }
 else {
    codePoints=mPrimaryKeyCodes;
  }
  if (expectedMoveAmount >= 0) {
    while (actualMoveAmountWithinWord < expectedMoveAmount && cursorPos < mCodePointSize) {
      actualMoveAmountWithinWord+=Character.charCount(codePoints[cursorPos]);
      ++cursorPos;
    }
  }
 else {
    while (actualMoveAmountWithinWord > expectedMoveAmount && cursorPos > 0) {
      --cursorPos;
      actualMoveAmountWithinWord-=Character.charCount(codePoints[cursorPos]);
    }
  }
  if (actualMoveAmountWithinWord != expectedMoveAmount)   return false;
  mCursorPositionWithinWord=cursorPos;
  return true;
}",0.9066985645933014
87606,"/** 
 * When the cursor is moved by the user, we need to update its position. If it falls inside the currently composing word, we don't reset the composition, and only update the cursor position.
 * @param expectedMoveAmount How many java chars to move the cursor. Negative values movethe cursor backward, positive values move the cursor forward.
 * @return true if the cursor is still inside the composing word, false otherwise.
 */
public boolean moveCursorByAndReturnIfInsideComposingWord(final int expectedMoveAmount){
  int actualMoveAmountWithinWord=0;
  int cursorPos=mCursorPositionWithinWord;
  if (expectedMoveAmount >= 0) {
    while (actualMoveAmountWithinWord < expectedMoveAmount && cursorPos < mCodePointSize) {
      actualMoveAmountWithinWord+=Character.charCount(mPrimaryKeyCodes[cursorPos]);
      ++cursorPos;
    }
  }
 else {
    while (actualMoveAmountWithinWord > expectedMoveAmount && cursorPos > 0) {
      --cursorPos;
      actualMoveAmountWithinWord-=Character.charCount(mPrimaryKeyCodes[cursorPos]);
    }
  }
  if (actualMoveAmountWithinWord != expectedMoveAmount)   return false;
  mCursorPositionWithinWord=cursorPos;
  return true;
}","/** 
 * When the cursor is moved by the user, we need to update its position. If it falls inside the currently composing word, we don't reset the composition, and only update the cursor position.
 * @param expectedMoveAmount How many java chars to move the cursor. Negative values movethe cursor backward, positive values move the cursor forward.
 * @return true if the cursor is still inside the composing word, false otherwise.
 */
public boolean moveCursorByAndReturnIfInsideComposingWord(final int expectedMoveAmount){
  int actualMoveAmountWithinWord=0;
  int cursorPos=mCursorPositionWithinWord;
  final int[] codePoints;
  if (mCodePointSize >= MAX_WORD_LENGTH) {
    codePoints=StringUtils.toCodePointArray(mTypedWord.toString());
  }
 else {
    codePoints=mPrimaryKeyCodes;
  }
  if (expectedMoveAmount >= 0) {
    while (actualMoveAmountWithinWord < expectedMoveAmount && cursorPos < mCodePointSize) {
      actualMoveAmountWithinWord+=Character.charCount(codePoints[cursorPos]);
      ++cursorPos;
    }
  }
 else {
    while (actualMoveAmountWithinWord > expectedMoveAmount && cursorPos > 0) {
      --cursorPos;
      actualMoveAmountWithinWord-=Character.charCount(codePoints[cursorPos]);
    }
  }
  if (actualMoveAmountWithinWord != expectedMoveAmount)   return false;
  mCursorPositionWithinWord=cursorPos;
  return true;
}",0.9066985645933014
87607,"public void reset(){
  mStatus=NOT_INITIALIZED;
  mAnimateToStatus=NOT_INITIALIZED;
}","public void reset(final DictionaryListInterfaceState interfaceState){
  mStatus=NOT_INITIALIZED;
  mAnimateToStatus=NOT_INITIALIZED;
  mInterfaceState=interfaceState;
}",0.6719367588932806
87608,"private ViewPropertyAnimator animateButton(final View button,final int direction){
  final float outerX=getWidth();
  final float innerX=button.getX() - button.getTranslationX();
  if (ANIMATION_IN == direction) {
    button.setClickable(true);
    return button.animate().translationX(0);
  }
 else {
    button.setClickable(false);
    return button.animate().translationX(outerX - innerX);
  }
}","private ViewPropertyAnimator animateButton(final View button,final int direction){
  final float outerX=getWidth();
  final float innerX=button.getX() - button.getTranslationX();
  mInterfaceState.removeFromCache((View)getParent());
  if (ANIMATION_IN == direction) {
    button.setClickable(true);
    return button.animate().translationX(0);
  }
 else {
    button.setClickable(false);
    return button.animate().translationX(outerX - innerX);
  }
}",0.9364705882352942
87609,"@Override protected void onBindView(final View view){
  super.onBindView(view);
  ((ViewGroup)view).setLayoutTransition(null);
  final DictionaryDownloadProgressBar progressBar=(DictionaryDownloadProgressBar)view.findViewById(R.id.dictionary_line_progress_bar);
  final TextView status=(TextView)view.findViewById(android.R.id.summary);
  progressBar.setIds(mClientId,mWordlistId);
  progressBar.setMax(mFilesize);
  final boolean showProgressBar=(MetadataDbHelper.STATUS_DOWNLOADING == mStatus);
  status.setVisibility(showProgressBar ? View.INVISIBLE : View.VISIBLE);
  progressBar.setVisibility(showProgressBar ? View.VISIBLE : View.INVISIBLE);
  final ButtonSwitcher buttonSwitcher=(ButtonSwitcher)view.findViewById(R.id.wordlist_button_switcher);
  buttonSwitcher.reset();
  if (mInterfaceState.isOpen(mWordlistId)) {
    final int previousStatus=mInterfaceState.getStatus(mWordlistId);
    buttonSwitcher.setStatusAndUpdateVisuals(getButtonSwitcherStatus(previousStatus));
    if (previousStatus != mStatus) {
      buttonSwitcher.setStatusAndUpdateVisuals(getButtonSwitcherStatus(mStatus));
      mInterfaceState.setOpen(mWordlistId,mStatus);
    }
  }
 else {
    buttonSwitcher.setStatusAndUpdateVisuals(ButtonSwitcher.STATUS_NO_BUTTON);
  }
  buttonSwitcher.setInternalOnClickListener(mActionButtonClickHandler);
  view.setOnClickListener(mPreferenceClickHandler);
}","@Override protected void onBindView(final View view){
  super.onBindView(view);
  ((ViewGroup)view).setLayoutTransition(null);
  final DictionaryDownloadProgressBar progressBar=(DictionaryDownloadProgressBar)view.findViewById(R.id.dictionary_line_progress_bar);
  final TextView status=(TextView)view.findViewById(android.R.id.summary);
  progressBar.setIds(mClientId,mWordlistId);
  progressBar.setMax(mFilesize);
  final boolean showProgressBar=(MetadataDbHelper.STATUS_DOWNLOADING == mStatus);
  status.setVisibility(showProgressBar ? View.INVISIBLE : View.VISIBLE);
  progressBar.setVisibility(showProgressBar ? View.VISIBLE : View.INVISIBLE);
  final ButtonSwitcher buttonSwitcher=(ButtonSwitcher)view.findViewById(R.id.wordlist_button_switcher);
  buttonSwitcher.reset(mInterfaceState);
  if (mInterfaceState.isOpen(mWordlistId)) {
    final int previousStatus=mInterfaceState.getStatus(mWordlistId);
    buttonSwitcher.setStatusAndUpdateVisuals(getButtonSwitcherStatus(previousStatus));
    if (previousStatus != mStatus) {
      buttonSwitcher.setStatusAndUpdateVisuals(getButtonSwitcherStatus(mStatus));
      mInterfaceState.setOpen(mWordlistId,mStatus);
    }
  }
 else {
    buttonSwitcher.setStatusAndUpdateVisuals(ButtonSwitcher.STATUS_NO_BUTTON);
  }
  buttonSwitcher.setInternalOnClickListener(mActionButtonClickHandler);
  view.setOnClickListener(mPreferenceClickHandler);
}",0.9945789663895916
87610,"public void reset(){
  mStatus=NOT_INITIALIZED;
  mAnimateToStatus=NOT_INITIALIZED;
}","public void reset(final DictionaryListInterfaceState interfaceState){
  mStatus=NOT_INITIALIZED;
  mAnimateToStatus=NOT_INITIALIZED;
  mInterfaceState=interfaceState;
}",0.6719367588932806
87611,"private ViewPropertyAnimator animateButton(final View button,final int direction){
  final float outerX=getWidth();
  final float innerX=button.getX() - button.getTranslationX();
  if (ANIMATION_IN == direction) {
    button.setClickable(true);
    return button.animate().translationX(0);
  }
 else {
    button.setClickable(false);
    return button.animate().translationX(outerX - innerX);
  }
}","private ViewPropertyAnimator animateButton(final View button,final int direction){
  final float outerX=getWidth();
  final float innerX=button.getX() - button.getTranslationX();
  mInterfaceState.removeFromCache((View)getParent());
  if (ANIMATION_IN == direction) {
    button.setClickable(true);
    return button.animate().translationX(0);
  }
 else {
    button.setClickable(false);
    return button.animate().translationX(outerX - innerX);
  }
}",0.9364705882352942
87612,"@Override protected void onBindView(final View view){
  super.onBindView(view);
  ((ViewGroup)view).setLayoutTransition(null);
  final DictionaryDownloadProgressBar progressBar=(DictionaryDownloadProgressBar)view.findViewById(R.id.dictionary_line_progress_bar);
  final TextView status=(TextView)view.findViewById(android.R.id.summary);
  progressBar.setIds(mClientId,mWordlistId);
  progressBar.setMax(mFilesize);
  final boolean showProgressBar=(MetadataDbHelper.STATUS_DOWNLOADING == mStatus);
  status.setVisibility(showProgressBar ? View.INVISIBLE : View.VISIBLE);
  progressBar.setVisibility(showProgressBar ? View.VISIBLE : View.INVISIBLE);
  final ButtonSwitcher buttonSwitcher=(ButtonSwitcher)view.findViewById(R.id.wordlist_button_switcher);
  buttonSwitcher.reset();
  if (mInterfaceState.isOpen(mWordlistId)) {
    final int previousStatus=mInterfaceState.getStatus(mWordlistId);
    buttonSwitcher.setStatusAndUpdateVisuals(getButtonSwitcherStatus(previousStatus));
    if (previousStatus != mStatus) {
      buttonSwitcher.setStatusAndUpdateVisuals(getButtonSwitcherStatus(mStatus));
      mInterfaceState.setOpen(mWordlistId,mStatus);
    }
  }
 else {
    buttonSwitcher.setStatusAndUpdateVisuals(ButtonSwitcher.STATUS_NO_BUTTON);
  }
  buttonSwitcher.setInternalOnClickListener(mActionButtonClickHandler);
  view.setOnClickListener(mPreferenceClickHandler);
}","@Override protected void onBindView(final View view){
  super.onBindView(view);
  ((ViewGroup)view).setLayoutTransition(null);
  final DictionaryDownloadProgressBar progressBar=(DictionaryDownloadProgressBar)view.findViewById(R.id.dictionary_line_progress_bar);
  final TextView status=(TextView)view.findViewById(android.R.id.summary);
  progressBar.setIds(mClientId,mWordlistId);
  progressBar.setMax(mFilesize);
  final boolean showProgressBar=(MetadataDbHelper.STATUS_DOWNLOADING == mStatus);
  status.setVisibility(showProgressBar ? View.INVISIBLE : View.VISIBLE);
  progressBar.setVisibility(showProgressBar ? View.VISIBLE : View.INVISIBLE);
  final ButtonSwitcher buttonSwitcher=(ButtonSwitcher)view.findViewById(R.id.wordlist_button_switcher);
  buttonSwitcher.reset(mInterfaceState);
  if (mInterfaceState.isOpen(mWordlistId)) {
    final int previousStatus=mInterfaceState.getStatus(mWordlistId);
    buttonSwitcher.setStatusAndUpdateVisuals(getButtonSwitcherStatus(previousStatus));
    if (previousStatus != mStatus) {
      buttonSwitcher.setStatusAndUpdateVisuals(getButtonSwitcherStatus(mStatus));
      mInterfaceState.setOpen(mWordlistId,mStatus);
    }
  }
 else {
    buttonSwitcher.setStatusAndUpdateVisuals(ButtonSwitcher.STATUS_NO_BUTTON);
  }
  buttonSwitcher.setInternalOnClickListener(mActionButtonClickHandler);
  view.setOnClickListener(mPreferenceClickHandler);
}",0.9945789663895916
87613,"public void reset(){
  mStatus=NOT_INITIALIZED;
  mAnimateToStatus=NOT_INITIALIZED;
}","public void reset(final DictionaryListInterfaceState interfaceState){
  mStatus=NOT_INITIALIZED;
  mAnimateToStatus=NOT_INITIALIZED;
  mInterfaceState=interfaceState;
}",0.6719367588932806
87614,"private ViewPropertyAnimator animateButton(final View button,final int direction){
  final float outerX=getWidth();
  final float innerX=button.getX() - button.getTranslationX();
  if (ANIMATION_IN == direction) {
    button.setClickable(true);
    return button.animate().translationX(0);
  }
 else {
    button.setClickable(false);
    return button.animate().translationX(outerX - innerX);
  }
}","private ViewPropertyAnimator animateButton(final View button,final int direction){
  final float outerX=getWidth();
  final float innerX=button.getX() - button.getTranslationX();
  mInterfaceState.removeFromCache((View)getParent());
  if (ANIMATION_IN == direction) {
    button.setClickable(true);
    return button.animate().translationX(0);
  }
 else {
    button.setClickable(false);
    return button.animate().translationX(outerX - innerX);
  }
}",0.9364705882352942
87615,"@Override protected void onBindView(final View view){
  super.onBindView(view);
  ((ViewGroup)view).setLayoutTransition(null);
  final DictionaryDownloadProgressBar progressBar=(DictionaryDownloadProgressBar)view.findViewById(R.id.dictionary_line_progress_bar);
  final TextView status=(TextView)view.findViewById(android.R.id.summary);
  progressBar.setIds(mClientId,mWordlistId);
  progressBar.setMax(mFilesize);
  final boolean showProgressBar=(MetadataDbHelper.STATUS_DOWNLOADING == mStatus);
  status.setVisibility(showProgressBar ? View.INVISIBLE : View.VISIBLE);
  progressBar.setVisibility(showProgressBar ? View.VISIBLE : View.INVISIBLE);
  final ButtonSwitcher buttonSwitcher=(ButtonSwitcher)view.findViewById(R.id.wordlist_button_switcher);
  buttonSwitcher.reset();
  if (mInterfaceState.isOpen(mWordlistId)) {
    final int previousStatus=mInterfaceState.getStatus(mWordlistId);
    buttonSwitcher.setStatusAndUpdateVisuals(getButtonSwitcherStatus(previousStatus));
    if (previousStatus != mStatus) {
      buttonSwitcher.setStatusAndUpdateVisuals(getButtonSwitcherStatus(mStatus));
      mInterfaceState.setOpen(mWordlistId,mStatus);
    }
  }
 else {
    buttonSwitcher.setStatusAndUpdateVisuals(ButtonSwitcher.STATUS_NO_BUTTON);
  }
  buttonSwitcher.setInternalOnClickListener(mActionButtonClickHandler);
  view.setOnClickListener(mPreferenceClickHandler);
}","@Override protected void onBindView(final View view){
  super.onBindView(view);
  ((ViewGroup)view).setLayoutTransition(null);
  final DictionaryDownloadProgressBar progressBar=(DictionaryDownloadProgressBar)view.findViewById(R.id.dictionary_line_progress_bar);
  final TextView status=(TextView)view.findViewById(android.R.id.summary);
  progressBar.setIds(mClientId,mWordlistId);
  progressBar.setMax(mFilesize);
  final boolean showProgressBar=(MetadataDbHelper.STATUS_DOWNLOADING == mStatus);
  status.setVisibility(showProgressBar ? View.INVISIBLE : View.VISIBLE);
  progressBar.setVisibility(showProgressBar ? View.VISIBLE : View.INVISIBLE);
  final ButtonSwitcher buttonSwitcher=(ButtonSwitcher)view.findViewById(R.id.wordlist_button_switcher);
  buttonSwitcher.reset(mInterfaceState);
  if (mInterfaceState.isOpen(mWordlistId)) {
    final int previousStatus=mInterfaceState.getStatus(mWordlistId);
    buttonSwitcher.setStatusAndUpdateVisuals(getButtonSwitcherStatus(previousStatus));
    if (previousStatus != mStatus) {
      buttonSwitcher.setStatusAndUpdateVisuals(getButtonSwitcherStatus(mStatus));
      mInterfaceState.setOpen(mWordlistId,mStatus);
    }
  }
 else {
    buttonSwitcher.setStatusAndUpdateVisuals(ButtonSwitcher.STATUS_NO_BUTTON);
  }
  buttonSwitcher.setInternalOnClickListener(mActionButtonClickHandler);
  view.setOnClickListener(mPreferenceClickHandler);
}",0.9945789663895916
87616,"private static void reinitializeClientRecordInDictionaryContentProvider(final Context context,final ContentProviderClient client,final String clientId) throws RemoteException {
  final String metadataFileUri=MetadataFileUriGetter.getMetadataUri(context);
  final String metadataAdditionalId=MetadataFileUriGetter.getMetadataAdditionalId(context);
  if (TextUtils.isEmpty(metadataFileUri))   return;
  final Uri metadataContentUri=getProviderUriBuilder(clientId).appendPath(QUERY_PATH_METADATA).appendQueryParameter(QUERY_PARAMETER_PROTOCOL,QUERY_PARAMETER_PROTOCOL_VALUE).build();
  client.delete(metadataContentUri,null,null);
  final ContentValues metadataValues=new ContentValues();
  metadataValues.put(INSERT_METADATA_CLIENT_ID_COLUMN,clientId);
  metadataValues.put(INSERT_METADATA_METADATA_URI_COLUMN,metadataFileUri);
  metadataValues.put(INSERT_METADATA_METADATA_ADDITIONAL_ID_COLUMN,metadataAdditionalId);
  client.insert(metadataContentUri,metadataValues);
  final Uri dictionaryContentUriBase=getProviderUriBuilder(clientId).appendPath(QUERY_PATH_DICT_INFO).appendQueryParameter(QUERY_PARAMETER_PROTOCOL,QUERY_PARAMETER_PROTOCOL_VALUE).build();
  final ArrayList<DictionaryInfo> dictionaryList=DictionaryInfoUtils.getCurrentDictionaryFileNameAndVersionInfo(context);
  final int length=dictionaryList.size();
  for (int i=0; i < length; ++i) {
    final DictionaryInfo info=dictionaryList.get(i);
    client.insert(Uri.withAppendedPath(dictionaryContentUriBase,info.mId),info.toContentValues());
  }
}","private static void reinitializeClientRecordInDictionaryContentProvider(final Context context,final ContentProviderClient client,final String clientId) throws RemoteException {
  final String metadataFileUri=MetadataFileUriGetter.getMetadataUri(context);
  final String metadataAdditionalId=MetadataFileUriGetter.getMetadataAdditionalId(context);
  final Uri metadataContentUri=getProviderUriBuilder(clientId).appendPath(QUERY_PATH_METADATA).appendQueryParameter(QUERY_PARAMETER_PROTOCOL,QUERY_PARAMETER_PROTOCOL_VALUE).build();
  client.delete(metadataContentUri,null,null);
  final ContentValues metadataValues=new ContentValues();
  metadataValues.put(INSERT_METADATA_CLIENT_ID_COLUMN,clientId);
  metadataValues.put(INSERT_METADATA_METADATA_URI_COLUMN,metadataFileUri);
  metadataValues.put(INSERT_METADATA_METADATA_ADDITIONAL_ID_COLUMN,metadataAdditionalId);
  client.insert(metadataContentUri,metadataValues);
  final Uri dictionaryContentUriBase=getProviderUriBuilder(clientId).appendPath(QUERY_PATH_DICT_INFO).appendQueryParameter(QUERY_PARAMETER_PROTOCOL,QUERY_PARAMETER_PROTOCOL_VALUE).build();
  final ArrayList<DictionaryInfo> dictionaryList=DictionaryInfoUtils.getCurrentDictionaryFileNameAndVersionInfo(context);
  final int length=dictionaryList.size();
  for (int i=0; i < length; ++i) {
    final DictionaryInfo info=dictionaryList.get(i);
    client.insert(Uri.withAppendedPath(dictionaryContentUriBase,info.mId),info.toContentValues());
  }
}",0.9825151311365165
87617,"/** 
 * Returns a list of file addresses for a given locale, trying relevant methods in order. Tries to get binary dictionaries from various sources, in order: - Uses a content provider to get a public dictionary set, as per the protocol described in BinaryDictionaryFileDumper. If that fails: - Gets a file name from the built-in dictionary for this locale, if any. If that fails: - Returns null.
 * @return The list of addresses of valid dictionary files, or null.
 */
public static ArrayList<AssetFileAddress> getDictionaryFiles(final Locale locale,final Context context){
  final boolean hasDefaultWordList=DictionaryFactory.isDictionaryAvailable(context,locale);
  if (context.checkCallingOrSelfPermission(android.Manifest.permission.INTERNET) == PackageManager.PERMISSION_GRANTED) {
    BinaryDictionaryFileDumper.cacheWordListsFromContentProvider(locale,context,hasDefaultWordList);
  }
  final File[] cachedWordLists=getCachedWordLists(locale.toString(),context);
  final String mainDictId=DictionaryInfoUtils.getMainDictId(locale);
  final DictPackSettings dictPackSettings=new DictPackSettings(context);
  boolean foundMainDict=false;
  final ArrayList<AssetFileAddress> fileList=CollectionUtils.newArrayList();
  for (  final File f : cachedWordLists) {
    final String wordListId=DictionaryInfoUtils.getWordListIdFromFileName(f.getName());
    final boolean canUse=f.canRead() && hackCanUseDictionaryFile(locale,f);
    if (canUse && DictionaryInfoUtils.isMainWordListId(wordListId)) {
      foundMainDict=true;
    }
    if (!dictPackSettings.isWordListActive(wordListId))     continue;
    if (canUse) {
      fileList.add(AssetFileAddress.makeFromFileName(f.getPath()));
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  if (!foundMainDict && dictPackSettings.isWordListActive(mainDictId)) {
    final int fallbackResId=DictionaryInfoUtils.getMainDictionaryResourceId(context.getResources(),locale);
    final AssetFileAddress fallbackAsset=loadFallbackResource(context,fallbackResId);
    if (null != fallbackAsset) {
      fileList.add(fallbackAsset);
    }
  }
  return fileList;
}","/** 
 * Returns a list of file addresses for a given locale, trying relevant methods in order. Tries to get binary dictionaries from various sources, in order: - Uses a content provider to get a public dictionary set, as per the protocol described in BinaryDictionaryFileDumper. If that fails: - Gets a file name from the built-in dictionary for this locale, if any. If that fails: - Returns null.
 * @return The list of addresses of valid dictionary files, or null.
 */
public static ArrayList<AssetFileAddress> getDictionaryFiles(final Locale locale,final Context context){
  final boolean hasDefaultWordList=DictionaryFactory.isDictionaryAvailable(context,locale);
  BinaryDictionaryFileDumper.cacheWordListsFromContentProvider(locale,context,hasDefaultWordList);
  final File[] cachedWordLists=getCachedWordLists(locale.toString(),context);
  final String mainDictId=DictionaryInfoUtils.getMainDictId(locale);
  final DictPackSettings dictPackSettings=new DictPackSettings(context);
  boolean foundMainDict=false;
  final ArrayList<AssetFileAddress> fileList=CollectionUtils.newArrayList();
  for (  final File f : cachedWordLists) {
    final String wordListId=DictionaryInfoUtils.getWordListIdFromFileName(f.getName());
    final boolean canUse=f.canRead() && hackCanUseDictionaryFile(locale,f);
    if (canUse && DictionaryInfoUtils.isMainWordListId(wordListId)) {
      foundMainDict=true;
    }
    if (!dictPackSettings.isWordListActive(wordListId))     continue;
    if (canUse) {
      fileList.add(AssetFileAddress.makeFromFileName(f.getPath()));
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  if (!foundMainDict && dictPackSettings.isWordListActive(mainDictId)) {
    final int fallbackResId=DictionaryInfoUtils.getMainDictionaryResourceId(context.getResources(),locale);
    final AssetFileAddress fallbackAsset=loadFallbackResource(context,fallbackResId);
    if (null != fallbackAsset) {
      fileList.add(fallbackAsset);
    }
  }
  return fileList;
}",0.9690017085672444
87618,"private static void dispatchBroadcast(final Context context,final Intent intent){
  if (DATE_CHANGED_INTENT_ACTION.equals(intent.getAction())) {
    checkTimeAndMaybeSetupUpdateAlarm(context);
  }
 else   if (DictionaryPackConstants.UPDATE_NOW_INTENT_ACTION.equals(intent.getAction())) {
    UpdateHandler.update(context,false);
  }
 else {
    UpdateHandler.downloadFinished(context,intent);
  }
}","private static void dispatchBroadcast(final Context context,final Intent intent){
  if (DATE_CHANGED_INTENT_ACTION.equals(intent.getAction())) {
    checkTimeAndMaybeSetupUpdateAlarm(context);
  }
 else   if (DictionaryPackConstants.UPDATE_NOW_INTENT_ACTION.equals(intent.getAction())) {
    UpdateHandler.tryUpdate(context,false);
  }
 else {
    UpdateHandler.downloadFinished(context,intent);
  }
}",0.9937421777221528
87619,"/** 
 * Refreshes data if it hasn't been refreshed in a very long time. This will check the last update time, and if it's been more than VERY_LONG_TIME, update metadata now - and possibly take subsequent update actions.
 */
public static void updateNowIfNotUpdatedInAVeryLongTime(final Context context){
  if (!isLastUpdateAtLeastThisOld(context,VERY_LONG_TIME))   return;
  UpdateHandler.update(context,false);
}","/** 
 * Refreshes data if it hasn't been refreshed in a very long time. This will check the last update time, and if it's been more than VERY_LONG_TIME, update metadata now - and possibly take subsequent update actions.
 */
public static void updateNowIfNotUpdatedInAVeryLongTime(final Context context){
  if (!isLastUpdateAtLeastThisOld(context,VERY_LONG_TIME))   return;
  UpdateHandler.tryUpdate(context,false);
}",0.993968636911942
87620,"private void startLoadingAnimation(){
  mLoadingView.setVisibility(View.VISIBLE);
  getView().setVisibility(View.GONE);
  mUpdateNowMenu.setTitle(R.string.cancel);
}","private void startLoadingAnimation(){
  mLoadingView.setVisibility(View.VISIBLE);
  getView().setVisibility(View.GONE);
  if (null != mUpdateNowMenu)   mUpdateNowMenu.setTitle(R.string.cancel);
}",0.9166666666666666
87621,"private void startRefresh(){
  startLoadingAnimation();
  mChangedSettings=true;
  UpdateHandler.registerUpdateEventListener(this);
  final Activity activity=getActivity();
  new Thread(""String_Node_Str""){
    @Override public void run(){
      UpdateHandler.update(activity,true);
    }
  }
.start();
}","private void startRefresh(){
  startLoadingAnimation();
  mChangedSettings=true;
  UpdateHandler.registerUpdateEventListener(this);
  final Activity activity=getActivity();
  new Thread(""String_Node_Str""){
    @Override public void run(){
      if (!UpdateHandler.tryUpdate(activity,true)) {
        stopLoadingAnimation();
      }
    }
  }
.start();
}",0.8567073170731707
87622,"@Override public void onCreateOptionsMenu(final Menu menu,final MenuInflater inflater){
  mUpdateNowMenu=menu.add(Menu.NONE,MENU_UPDATE_NOW,0,R.string.check_for_updates_now);
  mUpdateNowMenu.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
  refreshNetworkState();
}","@Override public void onCreateOptionsMenu(final Menu menu,final MenuInflater inflater){
  final String metadataUri=MetadataDbHelper.getMetadataUriAsString(getActivity(),mClientId);
  if (!TextUtils.isEmpty(metadataUri)) {
    mUpdateNowMenu=menu.add(Menu.NONE,MENU_UPDATE_NOW,0,R.string.check_for_updates_now);
    mUpdateNowMenu.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
    refreshNetworkState();
  }
}",0.788235294117647
87623,"private static void reinitializeClientRecordInDictionaryContentProvider(final Context context,final ContentProviderClient client,final String clientId) throws RemoteException {
  final String metadataFileUri=MetadataFileUriGetter.getMetadataUri(context);
  final String metadataAdditionalId=MetadataFileUriGetter.getMetadataAdditionalId(context);
  if (TextUtils.isEmpty(metadataFileUri))   return;
  final Uri metadataContentUri=getProviderUriBuilder(clientId).appendPath(QUERY_PATH_METADATA).appendQueryParameter(QUERY_PARAMETER_PROTOCOL,QUERY_PARAMETER_PROTOCOL_VALUE).build();
  client.delete(metadataContentUri,null,null);
  final ContentValues metadataValues=new ContentValues();
  metadataValues.put(INSERT_METADATA_CLIENT_ID_COLUMN,clientId);
  metadataValues.put(INSERT_METADATA_METADATA_URI_COLUMN,metadataFileUri);
  metadataValues.put(INSERT_METADATA_METADATA_ADDITIONAL_ID_COLUMN,metadataAdditionalId);
  client.insert(metadataContentUri,metadataValues);
  final Uri dictionaryContentUriBase=getProviderUriBuilder(clientId).appendPath(QUERY_PATH_DICT_INFO).appendQueryParameter(QUERY_PARAMETER_PROTOCOL,QUERY_PARAMETER_PROTOCOL_VALUE).build();
  final ArrayList<DictionaryInfo> dictionaryList=DictionaryInfoUtils.getCurrentDictionaryFileNameAndVersionInfo(context);
  final int length=dictionaryList.size();
  for (int i=0; i < length; ++i) {
    final DictionaryInfo info=dictionaryList.get(i);
    client.insert(Uri.withAppendedPath(dictionaryContentUriBase,info.mId),info.toContentValues());
  }
}","private static void reinitializeClientRecordInDictionaryContentProvider(final Context context,final ContentProviderClient client,final String clientId) throws RemoteException {
  final String metadataFileUri=MetadataFileUriGetter.getMetadataUri(context);
  final String metadataAdditionalId=MetadataFileUriGetter.getMetadataAdditionalId(context);
  final Uri metadataContentUri=getProviderUriBuilder(clientId).appendPath(QUERY_PATH_METADATA).appendQueryParameter(QUERY_PARAMETER_PROTOCOL,QUERY_PARAMETER_PROTOCOL_VALUE).build();
  client.delete(metadataContentUri,null,null);
  final ContentValues metadataValues=new ContentValues();
  metadataValues.put(INSERT_METADATA_CLIENT_ID_COLUMN,clientId);
  metadataValues.put(INSERT_METADATA_METADATA_URI_COLUMN,metadataFileUri);
  metadataValues.put(INSERT_METADATA_METADATA_ADDITIONAL_ID_COLUMN,metadataAdditionalId);
  client.insert(metadataContentUri,metadataValues);
  final Uri dictionaryContentUriBase=getProviderUriBuilder(clientId).appendPath(QUERY_PATH_DICT_INFO).appendQueryParameter(QUERY_PARAMETER_PROTOCOL,QUERY_PARAMETER_PROTOCOL_VALUE).build();
  final ArrayList<DictionaryInfo> dictionaryList=DictionaryInfoUtils.getCurrentDictionaryFileNameAndVersionInfo(context);
  final int length=dictionaryList.size();
  for (int i=0; i < length; ++i) {
    final DictionaryInfo info=dictionaryList.get(i);
    client.insert(Uri.withAppendedPath(dictionaryContentUriBase,info.mId),info.toContentValues());
  }
}",0.9825151311365165
87624,"/** 
 * Returns a list of file addresses for a given locale, trying relevant methods in order. Tries to get binary dictionaries from various sources, in order: - Uses a content provider to get a public dictionary set, as per the protocol described in BinaryDictionaryFileDumper. If that fails: - Gets a file name from the built-in dictionary for this locale, if any. If that fails: - Returns null.
 * @return The list of addresses of valid dictionary files, or null.
 */
public static ArrayList<AssetFileAddress> getDictionaryFiles(final Locale locale,final Context context){
  final boolean hasDefaultWordList=DictionaryFactory.isDictionaryAvailable(context,locale);
  if (context.checkCallingOrSelfPermission(android.Manifest.permission.INTERNET) == PackageManager.PERMISSION_GRANTED) {
    BinaryDictionaryFileDumper.cacheWordListsFromContentProvider(locale,context,hasDefaultWordList);
  }
  final File[] cachedWordLists=getCachedWordLists(locale.toString(),context);
  final String mainDictId=DictionaryInfoUtils.getMainDictId(locale);
  final DictPackSettings dictPackSettings=new DictPackSettings(context);
  boolean foundMainDict=false;
  final ArrayList<AssetFileAddress> fileList=CollectionUtils.newArrayList();
  for (  final File f : cachedWordLists) {
    final String wordListId=DictionaryInfoUtils.getWordListIdFromFileName(f.getName());
    final boolean canUse=f.canRead() && hackCanUseDictionaryFile(locale,f);
    if (canUse && DictionaryInfoUtils.isMainWordListId(wordListId)) {
      foundMainDict=true;
    }
    if (!dictPackSettings.isWordListActive(wordListId))     continue;
    if (canUse) {
      fileList.add(AssetFileAddress.makeFromFileName(f.getPath()));
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  if (!foundMainDict && dictPackSettings.isWordListActive(mainDictId)) {
    final int fallbackResId=DictionaryInfoUtils.getMainDictionaryResourceId(context.getResources(),locale);
    final AssetFileAddress fallbackAsset=loadFallbackResource(context,fallbackResId);
    if (null != fallbackAsset) {
      fileList.add(fallbackAsset);
    }
  }
  return fileList;
}","/** 
 * Returns a list of file addresses for a given locale, trying relevant methods in order. Tries to get binary dictionaries from various sources, in order: - Uses a content provider to get a public dictionary set, as per the protocol described in BinaryDictionaryFileDumper. If that fails: - Gets a file name from the built-in dictionary for this locale, if any. If that fails: - Returns null.
 * @return The list of addresses of valid dictionary files, or null.
 */
public static ArrayList<AssetFileAddress> getDictionaryFiles(final Locale locale,final Context context){
  final boolean hasDefaultWordList=DictionaryFactory.isDictionaryAvailable(context,locale);
  BinaryDictionaryFileDumper.cacheWordListsFromContentProvider(locale,context,hasDefaultWordList);
  final File[] cachedWordLists=getCachedWordLists(locale.toString(),context);
  final String mainDictId=DictionaryInfoUtils.getMainDictId(locale);
  final DictPackSettings dictPackSettings=new DictPackSettings(context);
  boolean foundMainDict=false;
  final ArrayList<AssetFileAddress> fileList=CollectionUtils.newArrayList();
  for (  final File f : cachedWordLists) {
    final String wordListId=DictionaryInfoUtils.getWordListIdFromFileName(f.getName());
    final boolean canUse=f.canRead() && hackCanUseDictionaryFile(locale,f);
    if (canUse && DictionaryInfoUtils.isMainWordListId(wordListId)) {
      foundMainDict=true;
    }
    if (!dictPackSettings.isWordListActive(wordListId))     continue;
    if (canUse) {
      fileList.add(AssetFileAddress.makeFromFileName(f.getPath()));
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  if (!foundMainDict && dictPackSettings.isWordListActive(mainDictId)) {
    final int fallbackResId=DictionaryInfoUtils.getMainDictionaryResourceId(context.getResources(),locale);
    final AssetFileAddress fallbackAsset=loadFallbackResource(context,fallbackResId);
    if (null != fallbackAsset) {
      fileList.add(fallbackAsset);
    }
  }
  return fileList;
}",0.9690017085672444
87625,"private static void dispatchBroadcast(final Context context,final Intent intent){
  if (DATE_CHANGED_INTENT_ACTION.equals(intent.getAction())) {
    checkTimeAndMaybeSetupUpdateAlarm(context);
  }
 else   if (DictionaryPackConstants.UPDATE_NOW_INTENT_ACTION.equals(intent.getAction())) {
    UpdateHandler.update(context,false);
  }
 else {
    UpdateHandler.downloadFinished(context,intent);
  }
}","private static void dispatchBroadcast(final Context context,final Intent intent){
  if (DATE_CHANGED_INTENT_ACTION.equals(intent.getAction())) {
    checkTimeAndMaybeSetupUpdateAlarm(context);
  }
 else   if (DictionaryPackConstants.UPDATE_NOW_INTENT_ACTION.equals(intent.getAction())) {
    UpdateHandler.tryUpdate(context,false);
  }
 else {
    UpdateHandler.downloadFinished(context,intent);
  }
}",0.9937421777221528
87626,"/** 
 * Refreshes data if it hasn't been refreshed in a very long time. This will check the last update time, and if it's been more than VERY_LONG_TIME, update metadata now - and possibly take subsequent update actions.
 */
public static void updateNowIfNotUpdatedInAVeryLongTime(final Context context){
  if (!isLastUpdateAtLeastThisOld(context,VERY_LONG_TIME))   return;
  UpdateHandler.update(context,false);
}","/** 
 * Refreshes data if it hasn't been refreshed in a very long time. This will check the last update time, and if it's been more than VERY_LONG_TIME, update metadata now - and possibly take subsequent update actions.
 */
public static void updateNowIfNotUpdatedInAVeryLongTime(final Context context){
  if (!isLastUpdateAtLeastThisOld(context,VERY_LONG_TIME))   return;
  UpdateHandler.tryUpdate(context,false);
}",0.993968636911942
87627,"private void startLoadingAnimation(){
  mLoadingView.setVisibility(View.VISIBLE);
  getView().setVisibility(View.GONE);
  mUpdateNowMenu.setTitle(R.string.cancel);
}","private void startLoadingAnimation(){
  mLoadingView.setVisibility(View.VISIBLE);
  getView().setVisibility(View.GONE);
  if (null != mUpdateNowMenu)   mUpdateNowMenu.setTitle(R.string.cancel);
}",0.9166666666666666
87628,"private void startRefresh(){
  startLoadingAnimation();
  mChangedSettings=true;
  UpdateHandler.registerUpdateEventListener(this);
  final Activity activity=getActivity();
  new Thread(""String_Node_Str""){
    @Override public void run(){
      UpdateHandler.update(activity,true);
    }
  }
.start();
}","private void startRefresh(){
  startLoadingAnimation();
  mChangedSettings=true;
  UpdateHandler.registerUpdateEventListener(this);
  final Activity activity=getActivity();
  new Thread(""String_Node_Str""){
    @Override public void run(){
      if (!UpdateHandler.tryUpdate(activity,true)) {
        stopLoadingAnimation();
      }
    }
  }
.start();
}",0.8567073170731707
87629,"@Override public void onCreateOptionsMenu(final Menu menu,final MenuInflater inflater){
  mUpdateNowMenu=menu.add(Menu.NONE,MENU_UPDATE_NOW,0,R.string.check_for_updates_now);
  mUpdateNowMenu.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
  refreshNetworkState();
}","@Override public void onCreateOptionsMenu(final Menu menu,final MenuInflater inflater){
  final String metadataUri=MetadataDbHelper.getMetadataUriAsString(getActivity(),mClientId);
  if (!TextUtils.isEmpty(metadataUri)) {
    mUpdateNowMenu=menu.add(Menu.NONE,MENU_UPDATE_NOW,0,R.string.check_for_updates_now);
    mUpdateNowMenu.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
    refreshNetworkState();
  }
}",0.788235294117647
87630,"private static void reinitializeClientRecordInDictionaryContentProvider(final Context context,final ContentProviderClient client,final String clientId) throws RemoteException {
  final String metadataFileUri=MetadataFileUriGetter.getMetadataUri(context);
  final String metadataAdditionalId=MetadataFileUriGetter.getMetadataAdditionalId(context);
  if (TextUtils.isEmpty(metadataFileUri))   return;
  final Uri metadataContentUri=getProviderUriBuilder(clientId).appendPath(QUERY_PATH_METADATA).appendQueryParameter(QUERY_PARAMETER_PROTOCOL,QUERY_PARAMETER_PROTOCOL_VALUE).build();
  client.delete(metadataContentUri,null,null);
  final ContentValues metadataValues=new ContentValues();
  metadataValues.put(INSERT_METADATA_CLIENT_ID_COLUMN,clientId);
  metadataValues.put(INSERT_METADATA_METADATA_URI_COLUMN,metadataFileUri);
  metadataValues.put(INSERT_METADATA_METADATA_ADDITIONAL_ID_COLUMN,metadataAdditionalId);
  client.insert(metadataContentUri,metadataValues);
  final Uri dictionaryContentUriBase=getProviderUriBuilder(clientId).appendPath(QUERY_PATH_DICT_INFO).appendQueryParameter(QUERY_PARAMETER_PROTOCOL,QUERY_PARAMETER_PROTOCOL_VALUE).build();
  final ArrayList<DictionaryInfo> dictionaryList=DictionaryInfoUtils.getCurrentDictionaryFileNameAndVersionInfo(context);
  final int length=dictionaryList.size();
  for (int i=0; i < length; ++i) {
    final DictionaryInfo info=dictionaryList.get(i);
    client.insert(Uri.withAppendedPath(dictionaryContentUriBase,info.mId),info.toContentValues());
  }
}","private static void reinitializeClientRecordInDictionaryContentProvider(final Context context,final ContentProviderClient client,final String clientId) throws RemoteException {
  final String metadataFileUri=MetadataFileUriGetter.getMetadataUri(context);
  final String metadataAdditionalId=MetadataFileUriGetter.getMetadataAdditionalId(context);
  final Uri metadataContentUri=getProviderUriBuilder(clientId).appendPath(QUERY_PATH_METADATA).appendQueryParameter(QUERY_PARAMETER_PROTOCOL,QUERY_PARAMETER_PROTOCOL_VALUE).build();
  client.delete(metadataContentUri,null,null);
  final ContentValues metadataValues=new ContentValues();
  metadataValues.put(INSERT_METADATA_CLIENT_ID_COLUMN,clientId);
  metadataValues.put(INSERT_METADATA_METADATA_URI_COLUMN,metadataFileUri);
  metadataValues.put(INSERT_METADATA_METADATA_ADDITIONAL_ID_COLUMN,metadataAdditionalId);
  client.insert(metadataContentUri,metadataValues);
  final Uri dictionaryContentUriBase=getProviderUriBuilder(clientId).appendPath(QUERY_PATH_DICT_INFO).appendQueryParameter(QUERY_PARAMETER_PROTOCOL,QUERY_PARAMETER_PROTOCOL_VALUE).build();
  final ArrayList<DictionaryInfo> dictionaryList=DictionaryInfoUtils.getCurrentDictionaryFileNameAndVersionInfo(context);
  final int length=dictionaryList.size();
  for (int i=0; i < length; ++i) {
    final DictionaryInfo info=dictionaryList.get(i);
    client.insert(Uri.withAppendedPath(dictionaryContentUriBase,info.mId),info.toContentValues());
  }
}",0.9825151311365165
87631,"/** 
 * Returns a list of file addresses for a given locale, trying relevant methods in order. Tries to get binary dictionaries from various sources, in order: - Uses a content provider to get a public dictionary set, as per the protocol described in BinaryDictionaryFileDumper. If that fails: - Gets a file name from the built-in dictionary for this locale, if any. If that fails: - Returns null.
 * @return The list of addresses of valid dictionary files, or null.
 */
public static ArrayList<AssetFileAddress> getDictionaryFiles(final Locale locale,final Context context){
  final boolean hasDefaultWordList=DictionaryFactory.isDictionaryAvailable(context,locale);
  if (context.checkCallingOrSelfPermission(android.Manifest.permission.INTERNET) == PackageManager.PERMISSION_GRANTED) {
    BinaryDictionaryFileDumper.cacheWordListsFromContentProvider(locale,context,hasDefaultWordList);
  }
  final File[] cachedWordLists=getCachedWordLists(locale.toString(),context);
  final String mainDictId=DictionaryInfoUtils.getMainDictId(locale);
  final DictPackSettings dictPackSettings=new DictPackSettings(context);
  boolean foundMainDict=false;
  final ArrayList<AssetFileAddress> fileList=CollectionUtils.newArrayList();
  for (  final File f : cachedWordLists) {
    final String wordListId=DictionaryInfoUtils.getWordListIdFromFileName(f.getName());
    final boolean canUse=f.canRead() && hackCanUseDictionaryFile(locale,f);
    if (canUse && DictionaryInfoUtils.isMainWordListId(wordListId)) {
      foundMainDict=true;
    }
    if (!dictPackSettings.isWordListActive(wordListId))     continue;
    if (canUse) {
      fileList.add(AssetFileAddress.makeFromFileName(f.getPath()));
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  if (!foundMainDict && dictPackSettings.isWordListActive(mainDictId)) {
    final int fallbackResId=DictionaryInfoUtils.getMainDictionaryResourceId(context.getResources(),locale);
    final AssetFileAddress fallbackAsset=loadFallbackResource(context,fallbackResId);
    if (null != fallbackAsset) {
      fileList.add(fallbackAsset);
    }
  }
  return fileList;
}","/** 
 * Returns a list of file addresses for a given locale, trying relevant methods in order. Tries to get binary dictionaries from various sources, in order: - Uses a content provider to get a public dictionary set, as per the protocol described in BinaryDictionaryFileDumper. If that fails: - Gets a file name from the built-in dictionary for this locale, if any. If that fails: - Returns null.
 * @return The list of addresses of valid dictionary files, or null.
 */
public static ArrayList<AssetFileAddress> getDictionaryFiles(final Locale locale,final Context context){
  final boolean hasDefaultWordList=DictionaryFactory.isDictionaryAvailable(context,locale);
  BinaryDictionaryFileDumper.cacheWordListsFromContentProvider(locale,context,hasDefaultWordList);
  final File[] cachedWordLists=getCachedWordLists(locale.toString(),context);
  final String mainDictId=DictionaryInfoUtils.getMainDictId(locale);
  final DictPackSettings dictPackSettings=new DictPackSettings(context);
  boolean foundMainDict=false;
  final ArrayList<AssetFileAddress> fileList=CollectionUtils.newArrayList();
  for (  final File f : cachedWordLists) {
    final String wordListId=DictionaryInfoUtils.getWordListIdFromFileName(f.getName());
    final boolean canUse=f.canRead() && hackCanUseDictionaryFile(locale,f);
    if (canUse && DictionaryInfoUtils.isMainWordListId(wordListId)) {
      foundMainDict=true;
    }
    if (!dictPackSettings.isWordListActive(wordListId))     continue;
    if (canUse) {
      fileList.add(AssetFileAddress.makeFromFileName(f.getPath()));
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  if (!foundMainDict && dictPackSettings.isWordListActive(mainDictId)) {
    final int fallbackResId=DictionaryInfoUtils.getMainDictionaryResourceId(context.getResources(),locale);
    final AssetFileAddress fallbackAsset=loadFallbackResource(context,fallbackResId);
    if (null != fallbackAsset) {
      fileList.add(fallbackAsset);
    }
  }
  return fileList;
}",0.9690017085672444
87632,"/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  if (!mConnection.isCursorTouchingWord(mSettings.getCurrent()))   return;
  final Range range=mConnection.getWordRangeAtCursor(mSettings.getWordSeparators(),0);
  if (null == range)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final CharSequence word=range.mWord;
  final String typedWord=word.toString();
  if (word instanceof SpannableString) {
    final SpannableString spannableString=(SpannableString)word;
    int i=0;
    for (    Object object : spannableString.getSpans(0,spannableString.length(),SuggestionSpan.class)) {
      SuggestionSpan span=(SuggestionSpan)object;
      for (      String s : span.getSuggestions()) {
        ++i;
        if (!TextUtils.equals(s,typedWord)) {
          suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.TYPE_RESUMED));
        }
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(numberOfCharsInWordBeforeCursor);
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  final SuggestedWords suggestedWords;
  if (suggestions.isEmpty()) {
    final SuggestedWords suggestedWordsIncludingTypedWord=getSuggestedWords(Suggest.SESSION_TYPING);
    if (suggestedWordsIncludingTypedWord.size() > 1) {
      suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
    }
 else {
      suggestedWords=suggestedWordsIncludingTypedWord;
    }
  }
 else {
    suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
  }
  mIsAutoCorrectionIndicatorOn=false;
  showSuggestionStrip(suggestedWords,typedWord);
}","/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  if (!mConnection.isCursorTouchingWord(mSettings.getCurrent()))   return;
  final Range range=mConnection.getWordRangeAtCursor(mSettings.getWordSeparators(),0);
  if (null == range)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final CharSequence word=range.mWord;
  final String typedWord=word.toString();
  if (word instanceof Spanned) {
    final Spanned spanned=(Spanned)word;
    int i=0;
    for (    Object object : spanned.getSpans(0,spanned.length(),SuggestionSpan.class)) {
      SuggestionSpan span=(SuggestionSpan)object;
      for (      String s : span.getSuggestions()) {
        ++i;
        if (!TextUtils.equals(s,typedWord)) {
          suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.TYPE_RESUMED));
        }
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(numberOfCharsInWordBeforeCursor);
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  final SuggestedWords suggestedWords;
  if (suggestions.isEmpty()) {
    final SuggestedWords suggestedWordsIncludingTypedWord=getSuggestedWords(Suggest.SESSION_TYPING);
    if (suggestedWordsIncludingTypedWord.size() > 1) {
      suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
    }
 else {
      suggestedWords=suggestedWordsIncludingTypedWord;
    }
  }
 else {
    suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
  }
  mIsAutoCorrectionIndicatorOn=false;
  showSuggestionStrip(suggestedWords,typedWord);
}",0.9814651368049426
87633,"@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ mLastSelectionStart+ ""String_Node_Str""+ mLastSelectionEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final boolean expectingUpdateSelectionFromLogger=ResearchLogger.getAndClearLatinIMEExpectingUpdateSelection();
    ResearchLogger.latinIME_onUpdateSelection(mLastSelectionStart,mLastSelectionEnd,oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd,mExpectingUpdateSelection,expectingUpdateSelectionFromLogger,mConnection);
    if (expectingUpdateSelectionFromLogger) {
      return;
    }
  }
  final boolean selectionChanged=(newSelStart != composingSpanEnd || newSelEnd != composingSpanEnd) && mLastSelectionStart != newSelStart;
  final boolean noComposingSpan=composingSpanStart == -1 && composingSpanEnd == -1;
  if (isInputViewShown() && !mExpectingUpdateSelection && !mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart)) {
    mSpaceState=SPACE_STATE_NONE;
    if ((!mWordComposer.isComposingWord()) || selectionChanged || noComposingSpan) {
      resetEntireInputState(newSelStart);
    }
    if (isSuggestionsStripVisible()) {
      mHandler.postResumeSuggestions();
    }
    mRecapitalizeStatus.deactivate();
    mKeyboardSwitcher.updateShiftState();
  }
  mExpectingUpdateSelection=false;
  mLastSelectionStart=newSelStart;
  mLastSelectionEnd=newSelEnd;
  mSubtypeState.currentSubtypeUsed();
}","@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ mLastSelectionStart+ ""String_Node_Str""+ mLastSelectionEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final boolean expectingUpdateSelectionFromLogger=ResearchLogger.getAndClearLatinIMEExpectingUpdateSelection();
    ResearchLogger.latinIME_onUpdateSelection(mLastSelectionStart,mLastSelectionEnd,oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd,mExpectingUpdateSelection,expectingUpdateSelectionFromLogger,mConnection);
    if (expectingUpdateSelectionFromLogger) {
      return;
    }
  }
  final boolean selectionChanged=mLastSelectionStart != newSelStart || mLastSelectionEnd != newSelEnd;
  final boolean noComposingSpan=composingSpanStart == -1 && composingSpanEnd == -1;
  if (isInputViewShown() && !mExpectingUpdateSelection && !mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart)) {
    mSpaceState=SPACE_STATE_NONE;
    if ((!mWordComposer.isComposingWord()) || selectionChanged || noComposingSpan) {
      resetEntireInputState(newSelStart);
    }
    if (isSuggestionsStripVisible()) {
      mHandler.postResumeSuggestions();
    }
    mConnection.userMovedCursor(newSelEnd);
    mRecapitalizeStatus.deactivate();
    mKeyboardSwitcher.updateShiftState();
  }
  mExpectingUpdateSelection=false;
  mLastSelectionStart=newSelStart;
  mLastSelectionEnd=newSelEnd;
  mSubtypeState.currentSubtypeUsed();
}",0.9571129707112972
87634,"public void setComposingRegion(final int start,final int end){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  mCurrentCursorPosition=end;
  final CharSequence textBeforeCursor=getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE + (end - start),0);
  mCommittedTextBeforeComposingText.setLength(0);
  if (!TextUtils.isEmpty(textBeforeCursor)) {
    final int indexOfStartOfComposingText=Math.max(textBeforeCursor.length() - (end - start),0);
    mComposingText.append(textBeforeCursor.subSequence(indexOfStartOfComposingText,textBeforeCursor.length()));
    mCommittedTextBeforeComposingText.append(textBeforeCursor.subSequence(0,indexOfStartOfComposingText));
  }
  if (null != mIC) {
    mIC.setComposingRegion(start,end);
  }
}","public void setComposingRegion(final int start,final int end){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  final CharSequence textBeforeCursor=getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE + (end - start),0);
  mCommittedTextBeforeComposingText.setLength(0);
  if (!TextUtils.isEmpty(textBeforeCursor)) {
    final int indexOfStartOfComposingText=Math.max(textBeforeCursor.length() - (end - start),0);
    mComposingText.append(textBeforeCursor.subSequence(indexOfStartOfComposingText,textBeforeCursor.length()));
    mCommittedTextBeforeComposingText.append(textBeforeCursor.subSequence(0,indexOfStartOfComposingText));
  }
  if (null != mIC) {
    mIC.setComposingRegion(start,end);
  }
}",0.9803921568627452
87635,"@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ mLastSelectionStart+ ""String_Node_Str""+ mLastSelectionEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final boolean expectingUpdateSelectionFromLogger=ResearchLogger.getAndClearLatinIMEExpectingUpdateSelection();
    ResearchLogger.latinIME_onUpdateSelection(mLastSelectionStart,mLastSelectionEnd,oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd,mExpectingUpdateSelection,expectingUpdateSelectionFromLogger,mConnection);
    if (expectingUpdateSelectionFromLogger) {
      return;
    }
  }
  final boolean selectionChanged=(newSelStart != composingSpanEnd || newSelEnd != composingSpanEnd) && mLastSelectionStart != newSelStart;
  final boolean noComposingSpan=composingSpanStart == -1 && composingSpanEnd == -1;
  if (isInputViewShown() && !mExpectingUpdateSelection && !mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart)) {
    mSpaceState=SPACE_STATE_NONE;
    if ((!mWordComposer.isComposingWord()) || selectionChanged || noComposingSpan) {
      resetEntireInputState(newSelStart);
    }
    if (isSuggestionsStripVisible()) {
      mHandler.postResumeSuggestions();
    }
    mRecapitalizeStatus.deactivate();
    mKeyboardSwitcher.updateShiftState();
  }
  mExpectingUpdateSelection=false;
  mLastSelectionStart=newSelStart;
  mLastSelectionEnd=newSelEnd;
  mSubtypeState.currentSubtypeUsed();
}","@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ mLastSelectionStart+ ""String_Node_Str""+ mLastSelectionEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final boolean expectingUpdateSelectionFromLogger=ResearchLogger.getAndClearLatinIMEExpectingUpdateSelection();
    ResearchLogger.latinIME_onUpdateSelection(mLastSelectionStart,mLastSelectionEnd,oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd,mExpectingUpdateSelection,expectingUpdateSelectionFromLogger,mConnection);
    if (expectingUpdateSelectionFromLogger) {
      return;
    }
  }
  final boolean selectionChanged=mLastSelectionStart != newSelStart || mLastSelectionEnd != newSelEnd;
  final boolean noComposingSpan=composingSpanStart == -1 && composingSpanEnd == -1;
  if (isInputViewShown() && !mExpectingUpdateSelection && !mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart)) {
    mSpaceState=SPACE_STATE_NONE;
    if ((!mWordComposer.isComposingWord()) || selectionChanged || noComposingSpan) {
      resetEntireInputState(newSelStart);
    }
    if (isSuggestionsStripVisible()) {
      mHandler.postResumeSuggestions();
    }
    mConnection.userMovedCursor(newSelEnd);
    mRecapitalizeStatus.deactivate();
    mKeyboardSwitcher.updateShiftState();
  }
  mExpectingUpdateSelection=false;
  mLastSelectionStart=newSelStart;
  mLastSelectionEnd=newSelEnd;
  mSubtypeState.currentSubtypeUsed();
}",0.9571129707112972
87636,"public void setComposingRegion(final int start,final int end){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  mCurrentCursorPosition=end;
  final CharSequence textBeforeCursor=getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE + (end - start),0);
  mCommittedTextBeforeComposingText.setLength(0);
  if (!TextUtils.isEmpty(textBeforeCursor)) {
    final int indexOfStartOfComposingText=Math.max(textBeforeCursor.length() - (end - start),0);
    mComposingText.append(textBeforeCursor.subSequence(indexOfStartOfComposingText,textBeforeCursor.length()));
    mCommittedTextBeforeComposingText.append(textBeforeCursor.subSequence(0,indexOfStartOfComposingText));
  }
  if (null != mIC) {
    mIC.setComposingRegion(start,end);
  }
}","public void setComposingRegion(final int start,final int end){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  final CharSequence textBeforeCursor=getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE + (end - start),0);
  mCommittedTextBeforeComposingText.setLength(0);
  if (!TextUtils.isEmpty(textBeforeCursor)) {
    final int indexOfStartOfComposingText=Math.max(textBeforeCursor.length() - (end - start),0);
    mComposingText.append(textBeforeCursor.subSequence(indexOfStartOfComposingText,textBeforeCursor.length()));
    mCommittedTextBeforeComposingText.append(textBeforeCursor.subSequence(0,indexOfStartOfComposingText));
  }
  if (null != mIC) {
    mIC.setComposingRegion(start,end);
  }
}",0.9803921568627452
87637,"/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  if (!mConnection.isCursorTouchingWord(mSettings.getCurrent()))   return;
  final Range range=mConnection.getWordRangeAtCursor(mSettings.getWordSeparators(),0);
  if (null == range)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final CharSequence word=range.mWord;
  final String typedWord=word.toString();
  if (word instanceof SpannableString) {
    final SpannableString spannableString=(SpannableString)word;
    int i=0;
    for (    Object object : spannableString.getSpans(0,spannableString.length(),SuggestionSpan.class)) {
      SuggestionSpan span=(SuggestionSpan)object;
      for (      String s : span.getSuggestions()) {
        ++i;
        if (!TextUtils.equals(s,typedWord)) {
          suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.TYPE_RESUMED));
        }
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(numberOfCharsInWordBeforeCursor);
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  final SuggestedWords suggestedWords;
  if (suggestions.isEmpty()) {
    final SuggestedWords suggestedWordsIncludingTypedWord=getSuggestedWords(Suggest.SESSION_TYPING);
    if (suggestedWordsIncludingTypedWord.size() > 1) {
      suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
    }
 else {
      suggestedWords=suggestedWordsIncludingTypedWord;
    }
  }
 else {
    suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
  }
  mIsAutoCorrectionIndicatorOn=false;
  showSuggestionStrip(suggestedWords,typedWord);
}","/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  if (!mConnection.isCursorTouchingWord(mSettings.getCurrent()))   return;
  final Range range=mConnection.getWordRangeAtCursor(mSettings.getWordSeparators(),0);
  if (null == range)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final CharSequence word=range.mWord;
  final String typedWord=word.toString();
  if (word instanceof Spanned) {
    final Spanned spanned=(Spanned)word;
    int i=0;
    for (    Object object : spanned.getSpans(0,spanned.length(),SuggestionSpan.class)) {
      SuggestionSpan span=(SuggestionSpan)object;
      for (      String s : span.getSuggestions()) {
        ++i;
        if (!TextUtils.equals(s,typedWord)) {
          suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.TYPE_RESUMED));
        }
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(numberOfCharsInWordBeforeCursor);
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  final SuggestedWords suggestedWords;
  if (suggestions.isEmpty()) {
    final SuggestedWords suggestedWordsIncludingTypedWord=getSuggestedWords(Suggest.SESSION_TYPING);
    if (suggestedWordsIncludingTypedWord.size() > 1) {
      suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
    }
 else {
      suggestedWords=suggestedWordsIncludingTypedWord;
    }
  }
 else {
    suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
  }
  mIsAutoCorrectionIndicatorOn=false;
  showSuggestionStrip(suggestedWords,typedWord);
}",0.9814651368049426
87638,"/** 
 * The builder of MoreKeysKeyboard.
 * @param context the context of {@link MoreKeysKeyboardView}.
 * @param parentKey the {@link Key} that invokes more keys keyboard.
 * @param parentKeyboardView the {@link KeyboardView} that contains the parentKey.
 * @param keyPreviewDrawParams the parameter to place key preview.
 */
public Builder(final Context context,final Key parentKey,final MainKeyboardView parentKeyboardView,final KeyPreviewDrawParams keyPreviewDrawParams){
  super(context,new MoreKeysKeyboardParams());
  final Keyboard parentKeyboard=parentKeyboardView.getKeyboard();
  load(parentKeyboard.mMoreKeysTemplate,parentKeyboard.mId);
  mParams.mVerticalGap=parentKeyboard.mVerticalGap / 2;
  mParentKey=parentKey;
  final int width, height;
  final boolean singleMoreKeyWithPreview=parentKeyboardView.isKeyPreviewPopupEnabled() && !parentKey.noKeyPreview() && parentKey.mMoreKeys.length == 1;
  if (singleMoreKeyWithPreview) {
    width=keyPreviewDrawParams.mPreviewVisibleWidth;
    height=keyPreviewDrawParams.mPreviewVisibleHeight + mParams.mVerticalGap;
    if (width == 0) {
      throw new IllegalArgumentException(""String_Node_Str"" + parentKey + ""String_Node_Str""+ parentKeyboard.mId);
    }
  }
 else {
    width=getMaxKeyWidth(parentKeyboardView,parentKey,mParams.mDefaultKeyWidth,context.getResources());
    height=parentKeyboard.mMostCommonKeyHeight;
    if (width == 0) {
      throw new IllegalArgumentException(""String_Node_Str"" + parentKey + ""String_Node_Str""+ java.util.Arrays.toString(parentKey.mMoreKeys)+ ""String_Node_Str""+ parentKeyboard.mId);
    }
  }
  final int dividerWidth;
  if (parentKey.needsDividersInMoreKeys()) {
    mDivider=mResources.getDrawable(R.drawable.more_keys_divider);
    dividerWidth=(int)(width * DIVIDER_RATIO);
  }
 else {
    mDivider=null;
    dividerWidth=0;
  }
  mParams.setParameters(parentKey.mMoreKeys.length,parentKey.getMoreKeysColumn(),width,height,parentKey.mX + parentKey.mWidth / 2,parentKeyboardView.getMeasuredWidth(),parentKey.isFixedColumnOrderMoreKeys(),dividerWidth);
}","/** 
 * The builder of MoreKeysKeyboard.
 * @param context the context of {@link MoreKeysKeyboardView}.
 * @param parentKey the {@link Key} that invokes more keys keyboard.
 * @param parentKeyboardView the {@link KeyboardView} that contains the parentKey.
 * @param keyPreviewDrawParams the parameter to place key preview.
 */
public Builder(final Context context,final Key parentKey,final MainKeyboardView parentKeyboardView,final KeyPreviewDrawParams keyPreviewDrawParams){
  super(context,new MoreKeysKeyboardParams());
  final Keyboard parentKeyboard=parentKeyboardView.getKeyboard();
  load(parentKeyboard.mMoreKeysTemplate,parentKeyboard.mId);
  mParams.mVerticalGap=parentKeyboard.mVerticalGap / 2;
  mParentKey=parentKey;
  final int width, height;
  final boolean singleMoreKeyWithPreview=parentKeyboardView.isKeyPreviewPopupEnabled() && !parentKey.noKeyPreview() && parentKey.mMoreKeys.length == 1 && keyPreviewDrawParams.mPreviewVisibleWidth > 0;
  if (singleMoreKeyWithPreview) {
    width=keyPreviewDrawParams.mPreviewVisibleWidth;
    height=keyPreviewDrawParams.mPreviewVisibleHeight + mParams.mVerticalGap;
  }
 else {
    width=getMaxKeyWidth(parentKeyboardView,parentKey,mParams.mDefaultKeyWidth,context.getResources());
    height=parentKeyboard.mMostCommonKeyHeight;
  }
  final int dividerWidth;
  if (parentKey.needsDividersInMoreKeys()) {
    mDivider=mResources.getDrawable(R.drawable.more_keys_divider);
    dividerWidth=(int)(width * DIVIDER_RATIO);
  }
 else {
    mDivider=null;
    dividerWidth=0;
  }
  mParams.setParameters(parentKey.mMoreKeys.length,parentKey.getMoreKeysColumn(),width,height,parentKey.mX + parentKey.mWidth / 2,parentKeyboardView.getMeasuredWidth(),parentKey.isFixedColumnOrderMoreKeys(),dividerWidth);
}",0.895483193277311
87639,"/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  if (!mConnection.isCursorTouchingWord(mSettings.getCurrent()))   return;
  final Range range=mConnection.getWordRangeAtCursor(mSettings.getWordSeparators(),0);
  if (null == range)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final CharSequence word=range.mWord;
  final String typedWord=word.toString();
  if (word instanceof SpannableString) {
    final SpannableString spannableString=(SpannableString)word;
    int i=0;
    for (    Object object : spannableString.getSpans(0,spannableString.length(),SuggestionSpan.class)) {
      SuggestionSpan span=(SuggestionSpan)object;
      for (      String s : span.getSuggestions()) {
        ++i;
        if (!TextUtils.equals(s,typedWord)) {
          suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.TYPE_RESUMED));
        }
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(numberOfCharsInWordBeforeCursor);
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  final SuggestedWords suggestedWords;
  if (suggestions.isEmpty()) {
    final SuggestedWords suggestedWordsIncludingTypedWord=getSuggestedWords(Suggest.SESSION_TYPING);
    if (suggestedWordsIncludingTypedWord.size() > 1) {
      suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
    }
 else {
      suggestedWords=suggestedWordsIncludingTypedWord;
    }
  }
 else {
    suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
  }
  mIsAutoCorrectionIndicatorOn=false;
  showSuggestionStrip(suggestedWords,typedWord);
}","/** 
 * Check if the cursor is touching a word. If so, restart suggestions on this word, else do nothing.
 */
private void restartSuggestionsOnWordTouchedByCursor(){
  if (mAppWorkAroundsUtils.isBrokenByRecorrection())   return;
  if (mLastSelectionStart != mLastSelectionEnd)   return;
  if (mLastSelectionStart < 0)   return;
  if (!mConnection.isCursorTouchingWord(mSettings.getCurrent()))   return;
  final Range range=mConnection.getWordRangeAtCursor(mSettings.getWordSeparators(),0);
  if (null == range)   return;
  final int numberOfCharsInWordBeforeCursor=range.getNumberOfCharsInWordBeforeCursor();
  if (numberOfCharsInWordBeforeCursor > mLastSelectionStart)   return;
  final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
  final CharSequence word=range.mWord;
  final String typedWord=word.toString();
  if (word instanceof Spanned) {
    final Spanned spanned=(Spanned)word;
    int i=0;
    for (    Object object : spanned.getSpans(0,spanned.length(),SuggestionSpan.class)) {
      SuggestionSpan span=(SuggestionSpan)object;
      for (      String s : span.getSuggestions()) {
        ++i;
        if (!TextUtils.equals(s,typedWord)) {
          suggestions.add(new SuggestedWordInfo(s,SuggestionStripView.MAX_SUGGESTIONS - i,SuggestedWordInfo.KIND_RESUMED,Dictionary.TYPE_RESUMED));
        }
      }
    }
  }
  mWordComposer.setComposingWord(typedWord,mKeyboardSwitcher.getKeyboard());
  mWordComposer.setCursorPositionWithinWord(numberOfCharsInWordBeforeCursor);
  mConnection.setComposingRegion(mLastSelectionStart - numberOfCharsInWordBeforeCursor,mLastSelectionEnd + range.getNumberOfCharsInWordAfterCursor());
  final SuggestedWords suggestedWords;
  if (suggestions.isEmpty()) {
    final SuggestedWords suggestedWordsIncludingTypedWord=getSuggestedWords(Suggest.SESSION_TYPING);
    if (suggestedWordsIncludingTypedWord.size() > 1) {
      suggestedWords=suggestedWordsIncludingTypedWord.getSuggestedWordsExcludingTypedWord();
    }
 else {
      suggestedWords=suggestedWordsIncludingTypedWord;
    }
  }
 else {
    suggestedWords=new SuggestedWords(suggestions,true,false,false,false,false);
  }
  mIsAutoCorrectionIndicatorOn=false;
  showSuggestionStrip(suggestedWords,typedWord);
}",0.9814651368049426
87640,"/** 
 * The builder of MoreKeysKeyboard.
 * @param context the context of {@link MoreKeysKeyboardView}.
 * @param parentKey the {@link Key} that invokes more keys keyboard.
 * @param parentKeyboardView the {@link KeyboardView} that contains the parentKey.
 * @param keyPreviewDrawParams the parameter to place key preview.
 */
public Builder(final Context context,final Key parentKey,final MainKeyboardView parentKeyboardView,final KeyPreviewDrawParams keyPreviewDrawParams){
  super(context,new MoreKeysKeyboardParams());
  final Keyboard parentKeyboard=parentKeyboardView.getKeyboard();
  load(parentKeyboard.mMoreKeysTemplate,parentKeyboard.mId);
  mParams.mVerticalGap=parentKeyboard.mVerticalGap / 2;
  mParentKey=parentKey;
  final int width, height;
  final boolean singleMoreKeyWithPreview=parentKeyboardView.isKeyPreviewPopupEnabled() && !parentKey.noKeyPreview() && parentKey.mMoreKeys.length == 1;
  if (singleMoreKeyWithPreview) {
    width=keyPreviewDrawParams.mPreviewVisibleWidth;
    height=keyPreviewDrawParams.mPreviewVisibleHeight + mParams.mVerticalGap;
    if (width == 0) {
      throw new IllegalArgumentException(""String_Node_Str"" + parentKey + ""String_Node_Str""+ parentKeyboard.mId);
    }
  }
 else {
    width=getMaxKeyWidth(parentKeyboardView,parentKey,mParams.mDefaultKeyWidth,context.getResources());
    height=parentKeyboard.mMostCommonKeyHeight;
    if (width == 0) {
      throw new IllegalArgumentException(""String_Node_Str"" + parentKey + ""String_Node_Str""+ java.util.Arrays.toString(parentKey.mMoreKeys)+ ""String_Node_Str""+ parentKeyboard.mId);
    }
  }
  final int dividerWidth;
  if (parentKey.needsDividersInMoreKeys()) {
    mDivider=mResources.getDrawable(R.drawable.more_keys_divider);
    dividerWidth=(int)(width * DIVIDER_RATIO);
  }
 else {
    mDivider=null;
    dividerWidth=0;
  }
  mParams.setParameters(parentKey.mMoreKeys.length,parentKey.getMoreKeysColumn(),width,height,parentKey.mX + parentKey.mWidth / 2,parentKeyboardView.getMeasuredWidth(),parentKey.isFixedColumnOrderMoreKeys(),dividerWidth);
}","/** 
 * The builder of MoreKeysKeyboard.
 * @param context the context of {@link MoreKeysKeyboardView}.
 * @param parentKey the {@link Key} that invokes more keys keyboard.
 * @param parentKeyboardView the {@link KeyboardView} that contains the parentKey.
 * @param keyPreviewDrawParams the parameter to place key preview.
 */
public Builder(final Context context,final Key parentKey,final MainKeyboardView parentKeyboardView,final KeyPreviewDrawParams keyPreviewDrawParams){
  super(context,new MoreKeysKeyboardParams());
  final Keyboard parentKeyboard=parentKeyboardView.getKeyboard();
  load(parentKeyboard.mMoreKeysTemplate,parentKeyboard.mId);
  mParams.mVerticalGap=parentKeyboard.mVerticalGap / 2;
  mParentKey=parentKey;
  final int width, height;
  final boolean singleMoreKeyWithPreview=parentKeyboardView.isKeyPreviewPopupEnabled() && !parentKey.noKeyPreview() && parentKey.mMoreKeys.length == 1 && keyPreviewDrawParams.mPreviewVisibleWidth > 0;
  if (singleMoreKeyWithPreview) {
    width=keyPreviewDrawParams.mPreviewVisibleWidth;
    height=keyPreviewDrawParams.mPreviewVisibleHeight + mParams.mVerticalGap;
  }
 else {
    width=getMaxKeyWidth(parentKeyboardView,parentKey,mParams.mDefaultKeyWidth,context.getResources());
    height=parentKeyboard.mMostCommonKeyHeight;
  }
  final int dividerWidth;
  if (parentKey.needsDividersInMoreKeys()) {
    mDivider=mResources.getDrawable(R.drawable.more_keys_divider);
    dividerWidth=(int)(width * DIVIDER_RATIO);
  }
 else {
    mDivider=null;
    dividerWidth=0;
  }
  mParams.setParameters(parentKey.mMoreKeys.length,parentKey.getMoreKeysColumn(),width,height,parentKey.mX + parentKey.mWidth / 2,parentKeyboardView.getMeasuredWidth(),parentKey.isFixedColumnOrderMoreKeys(),dividerWidth);
}",0.895483193277311
87641,"@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ mLastSelectionStart+ ""String_Node_Str""+ mLastSelectionEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final boolean expectingUpdateSelectionFromLogger=ResearchLogger.getAndClearLatinIMEExpectingUpdateSelection();
    ResearchLogger.latinIME_onUpdateSelection(mLastSelectionStart,mLastSelectionEnd,oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd,mExpectingUpdateSelection,expectingUpdateSelectionFromLogger,mConnection);
    if (expectingUpdateSelectionFromLogger) {
      return;
    }
  }
  final boolean selectionChanged=(newSelStart != composingSpanEnd || newSelEnd != composingSpanEnd) && mLastSelectionStart != newSelStart;
  final boolean noComposingSpan=composingSpanStart == -1 && composingSpanEnd == -1;
  if (isInputViewShown() && !mExpectingUpdateSelection && !mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart)) {
    mSpaceState=SPACE_STATE_NONE;
    if ((!mWordComposer.isComposingWord()) || selectionChanged || noComposingSpan) {
      resetEntireInputState(newSelStart);
    }
    if (isSuggestionsStripVisible()) {
      mHandler.postResumeSuggestions();
    }
    mRecapitalizeStatus.deactivate();
    mKeyboardSwitcher.updateShiftState();
  }
  mExpectingUpdateSelection=false;
  mLastSelectionStart=newSelStart;
  mLastSelectionEnd=newSelEnd;
  mSubtypeState.currentSubtypeUsed();
}","@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ mLastSelectionStart+ ""String_Node_Str""+ mLastSelectionEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final boolean expectingUpdateSelectionFromLogger=ResearchLogger.getAndClearLatinIMEExpectingUpdateSelection();
    ResearchLogger.latinIME_onUpdateSelection(mLastSelectionStart,mLastSelectionEnd,oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd,mExpectingUpdateSelection,expectingUpdateSelectionFromLogger,mConnection);
    if (expectingUpdateSelectionFromLogger) {
      return;
    }
  }
  final boolean selectionChanged=mLastSelectionStart != newSelStart || mLastSelectionEnd != newSelEnd;
  final boolean noComposingSpan=composingSpanStart == -1 && composingSpanEnd == -1;
  if (isInputViewShown() && !mExpectingUpdateSelection && !mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart)) {
    mSpaceState=SPACE_STATE_NONE;
    if ((!mWordComposer.isComposingWord()) || selectionChanged || noComposingSpan) {
      resetEntireInputState(newSelStart);
    }
    if (isSuggestionsStripVisible()) {
      mHandler.postResumeSuggestions();
    }
    mConnection.userMovedCursor(newSelEnd);
    mRecapitalizeStatus.deactivate();
    mKeyboardSwitcher.updateShiftState();
  }
  mExpectingUpdateSelection=false;
  mLastSelectionStart=newSelStart;
  mLastSelectionEnd=newSelEnd;
  mSubtypeState.currentSubtypeUsed();
}",0.9571129707112972
87642,"public void setComposingRegion(final int start,final int end){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  mCurrentCursorPosition=end;
  final CharSequence textBeforeCursor=getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE + (end - start),0);
  mCommittedTextBeforeComposingText.setLength(0);
  if (!TextUtils.isEmpty(textBeforeCursor)) {
    final int indexOfStartOfComposingText=Math.max(textBeforeCursor.length() - (end - start),0);
    mComposingText.append(textBeforeCursor.subSequence(indexOfStartOfComposingText,textBeforeCursor.length()));
    mCommittedTextBeforeComposingText.append(textBeforeCursor.subSequence(0,indexOfStartOfComposingText));
  }
  if (null != mIC) {
    mIC.setComposingRegion(start,end);
  }
}","public void setComposingRegion(final int start,final int end){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  final CharSequence textBeforeCursor=getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE + (end - start),0);
  mCommittedTextBeforeComposingText.setLength(0);
  if (!TextUtils.isEmpty(textBeforeCursor)) {
    final int indexOfStartOfComposingText=Math.max(textBeforeCursor.length() - (end - start),0);
    mComposingText.append(textBeforeCursor.subSequence(indexOfStartOfComposingText,textBeforeCursor.length()));
    mCommittedTextBeforeComposingText.append(textBeforeCursor.subSequence(0,indexOfStartOfComposingText));
  }
  if (null != mIC) {
    mIC.setComposingRegion(start,end);
  }
}",0.9803921568627452
87643,"/** 
 * The builder of MoreKeysKeyboard.
 * @param context the context of {@link MoreKeysKeyboardView}.
 * @param parentKey the {@link Key} that invokes more keys keyboard.
 * @param parentKeyboardView the {@link KeyboardView} that contains the parentKey.
 * @param keyPreviewDrawParams the parameter to place key preview.
 */
public Builder(final Context context,final Key parentKey,final MainKeyboardView parentKeyboardView,final KeyPreviewDrawParams keyPreviewDrawParams){
  super(context,new MoreKeysKeyboardParams());
  final Keyboard parentKeyboard=parentKeyboardView.getKeyboard();
  load(parentKeyboard.mMoreKeysTemplate,parentKeyboard.mId);
  mParams.mVerticalGap=parentKeyboard.mVerticalGap / 2;
  mParentKey=parentKey;
  final int width, height;
  final boolean singleMoreKeyWithPreview=parentKeyboardView.isKeyPreviewPopupEnabled() && !parentKey.noKeyPreview() && parentKey.mMoreKeys.length == 1;
  if (singleMoreKeyWithPreview) {
    width=keyPreviewDrawParams.mPreviewVisibleWidth;
    height=keyPreviewDrawParams.mPreviewVisibleHeight + mParams.mVerticalGap;
    if (width == 0) {
      throw new IllegalArgumentException(""String_Node_Str"" + parentKey + ""String_Node_Str""+ parentKeyboard.mId);
    }
  }
 else {
    width=getMaxKeyWidth(parentKeyboardView,parentKey,mParams.mDefaultKeyWidth,context.getResources());
    height=parentKeyboard.mMostCommonKeyHeight;
    if (width == 0) {
      throw new IllegalArgumentException(""String_Node_Str"" + parentKey + ""String_Node_Str""+ java.util.Arrays.toString(parentKey.mMoreKeys)+ ""String_Node_Str""+ parentKeyboard.mId);
    }
  }
  final int dividerWidth;
  if (parentKey.needsDividersInMoreKeys()) {
    mDivider=mResources.getDrawable(R.drawable.more_keys_divider);
    dividerWidth=(int)(width * DIVIDER_RATIO);
  }
 else {
    mDivider=null;
    dividerWidth=0;
  }
  mParams.setParameters(parentKey.mMoreKeys.length,parentKey.getMoreKeysColumn(),width,height,parentKey.mX + parentKey.mWidth / 2,parentKeyboardView.getMeasuredWidth(),parentKey.isFixedColumnOrderMoreKeys(),dividerWidth);
}","/** 
 * The builder of MoreKeysKeyboard.
 * @param context the context of {@link MoreKeysKeyboardView}.
 * @param parentKey the {@link Key} that invokes more keys keyboard.
 * @param parentKeyboardView the {@link KeyboardView} that contains the parentKey.
 * @param keyPreviewDrawParams the parameter to place key preview.
 */
public Builder(final Context context,final Key parentKey,final MainKeyboardView parentKeyboardView,final KeyPreviewDrawParams keyPreviewDrawParams){
  super(context,new MoreKeysKeyboardParams());
  final Keyboard parentKeyboard=parentKeyboardView.getKeyboard();
  load(parentKeyboard.mMoreKeysTemplate,parentKeyboard.mId);
  mParams.mVerticalGap=parentKeyboard.mVerticalGap / 2;
  mParentKey=parentKey;
  final int width, height;
  final boolean singleMoreKeyWithPreview=parentKeyboardView.isKeyPreviewPopupEnabled() && !parentKey.noKeyPreview() && parentKey.mMoreKeys.length == 1 && keyPreviewDrawParams.mPreviewVisibleWidth > 0;
  if (singleMoreKeyWithPreview) {
    width=keyPreviewDrawParams.mPreviewVisibleWidth;
    height=keyPreviewDrawParams.mPreviewVisibleHeight + mParams.mVerticalGap;
  }
 else {
    width=getMaxKeyWidth(parentKeyboardView,parentKey,mParams.mDefaultKeyWidth,context.getResources());
    height=parentKeyboard.mMostCommonKeyHeight;
  }
  final int dividerWidth;
  if (parentKey.needsDividersInMoreKeys()) {
    mDivider=mResources.getDrawable(R.drawable.more_keys_divider);
    dividerWidth=(int)(width * DIVIDER_RATIO);
  }
 else {
    mDivider=null;
    dividerWidth=0;
  }
  mParams.setParameters(parentKey.mMoreKeys.length,parentKey.getMoreKeysColumn(),width,height,parentKey.mX + parentKey.mWidth / 2,parentKeyboardView.getMeasuredWidth(),parentKey.isFixedColumnOrderMoreKeys(),dividerWidth);
}",0.895483193277311
87644,"UserDictionaryAddWordContents(final View view,final Bundle args){
  mWordEditText=(EditText)view.findViewById(R.id.user_dictionary_add_word_text);
  mShortcutEditText=(EditText)view.findViewById(R.id.user_dictionary_add_shortcut);
  if (!UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    mShortcutEditText.setVisibility(View.GONE);
    view.findViewById(R.id.user_dictionary_add_shortcut_label).setVisibility(View.GONE);
  }
  final String word=args.getString(EXTRA_WORD);
  if (null != word) {
    mWordEditText.setText(word);
    mWordEditText.setSelection(word.length());
  }
  final String shortcut;
  if (UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    shortcut=args.getString(EXTRA_SHORTCUT);
    if (null != shortcut && null != mShortcutEditText) {
      mShortcutEditText.setText(shortcut);
    }
    mOldShortcut=args.getString(EXTRA_SHORTCUT);
  }
 else {
    shortcut=null;
    mOldShortcut=null;
  }
  mMode=args.getInt(EXTRA_MODE);
  mOldWord=args.getString(EXTRA_WORD);
  updateLocale(args.getString(EXTRA_LOCALE));
}","UserDictionaryAddWordContents(final View view,final Bundle args){
  mWordEditText=(EditText)view.findViewById(R.id.user_dictionary_add_word_text);
  mShortcutEditText=(EditText)view.findViewById(R.id.user_dictionary_add_shortcut);
  if (!UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    mShortcutEditText.setVisibility(View.GONE);
    view.findViewById(R.id.user_dictionary_add_shortcut_label).setVisibility(View.GONE);
  }
  final String word=args.getString(EXTRA_WORD);
  if (null != word) {
    mWordEditText.setText(word);
    mWordEditText.setSelection(mWordEditText.getText().length());
  }
  final String shortcut;
  if (UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    shortcut=args.getString(EXTRA_SHORTCUT);
    if (null != shortcut && null != mShortcutEditText) {
      mShortcutEditText.setText(shortcut);
    }
    mOldShortcut=args.getString(EXTRA_SHORTCUT);
  }
 else {
    shortcut=null;
    mOldShortcut=null;
  }
  mMode=args.getInt(EXTRA_MODE);
  mOldWord=args.getString(EXTRA_WORD);
  updateLocale(args.getString(EXTRA_LOCALE));
}",0.9871977240398292
87645,"UserDictionaryAddWordContents(final View view,final Bundle args){
  mWordEditText=(EditText)view.findViewById(R.id.user_dictionary_add_word_text);
  mShortcutEditText=(EditText)view.findViewById(R.id.user_dictionary_add_shortcut);
  if (!UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    mShortcutEditText.setVisibility(View.GONE);
    view.findViewById(R.id.user_dictionary_add_shortcut_label).setVisibility(View.GONE);
  }
  final String word=args.getString(EXTRA_WORD);
  if (null != word) {
    mWordEditText.setText(word);
    mWordEditText.setSelection(word.length());
  }
  final String shortcut;
  if (UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    shortcut=args.getString(EXTRA_SHORTCUT);
    if (null != shortcut && null != mShortcutEditText) {
      mShortcutEditText.setText(shortcut);
    }
    mOldShortcut=args.getString(EXTRA_SHORTCUT);
  }
 else {
    shortcut=null;
    mOldShortcut=null;
  }
  mMode=args.getInt(EXTRA_MODE);
  mOldWord=args.getString(EXTRA_WORD);
  updateLocale(args.getString(EXTRA_LOCALE));
}","UserDictionaryAddWordContents(final View view,final Bundle args){
  mWordEditText=(EditText)view.findViewById(R.id.user_dictionary_add_word_text);
  mShortcutEditText=(EditText)view.findViewById(R.id.user_dictionary_add_shortcut);
  if (!UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    mShortcutEditText.setVisibility(View.GONE);
    view.findViewById(R.id.user_dictionary_add_shortcut_label).setVisibility(View.GONE);
  }
  final String word=args.getString(EXTRA_WORD);
  if (null != word) {
    mWordEditText.setText(word);
    mWordEditText.setSelection(mWordEditText.getText().length());
  }
  final String shortcut;
  if (UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    shortcut=args.getString(EXTRA_SHORTCUT);
    if (null != shortcut && null != mShortcutEditText) {
      mShortcutEditText.setText(shortcut);
    }
    mOldShortcut=args.getString(EXTRA_SHORTCUT);
  }
 else {
    shortcut=null;
    mOldShortcut=null;
  }
  mMode=args.getInt(EXTRA_MODE);
  mOldWord=args.getString(EXTRA_WORD);
  updateLocale(args.getString(EXTRA_LOCALE));
}",0.9871977240398292
87646,"void stop(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"");
  }
  commitCurrentLogUnit();
  try {
    mMainLogBuffer.shiftAndPublishAll();
  }
 catch (  final IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  logStatistics();
  commitCurrentLogUnit();
  mMainLogBuffer.setIsStopping();
  try {
    mMainLogBuffer.shiftAndPublishAll();
  }
 catch (  final IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  mMainResearchLog.blockingClose(RESEARCHLOG_CLOSE_TIMEOUT_IN_MS);
  resetLogBuffers();
}","void stop(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"");
  }
  commitCurrentLogUnit();
  try {
    mMainLogBuffer.shiftAndPublishAll();
  }
 catch (  final IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  logStatistics();
  commitCurrentLogUnit();
  mMainLogBuffer.setIsStopping();
  try {
    mMainLogBuffer.shiftAndPublishAll();
  }
 catch (  final IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  mMainResearchLog.blockingClose(RESEARCHLOG_CLOSE_TIMEOUT_IN_MS);
  resetLogBuffers();
  cancelFeedbackDialog();
}",0.9752380952380952
87647,"public void initSuggest(final Suggest suggest){
  mSuggest=suggest;
  if (mMainLogBuffer != null) {
    stop();
    start();
  }
}","public void initSuggest(final Suggest suggest){
  mSuggest=suggest;
  if (mMainLogBuffer != null) {
    restart();
  }
}",0.944
87648,"/** 
 * Remove leading/trailing whitespace from the considered string.
 */
public void trim(){
  final int len=mStringBefore.length();
  int nonWhitespaceStart=0;
  for (; nonWhitespaceStart < len; nonWhitespaceStart=mStringBefore.offsetByCodePoints(nonWhitespaceStart,1)) {
    final int codePoint=mStringBefore.codePointAt(nonWhitespaceStart);
    if (!Character.isWhitespace(codePoint))     break;
  }
  int nonWhitespaceEnd=len;
  for (; nonWhitespaceEnd > 0; nonWhitespaceEnd=mStringBefore.offsetByCodePoints(nonWhitespaceEnd,-1)) {
    final int codePoint=mStringBefore.codePointBefore(nonWhitespaceEnd);
    if (!Character.isWhitespace(codePoint))     break;
  }
  if (0 != nonWhitespaceStart || len != nonWhitespaceEnd) {
    mCursorEndAfter=mCursorStartBefore + nonWhitespaceEnd;
    mCursorStartBefore=mCursorStartAfter=mCursorStartBefore + nonWhitespaceStart;
    mStringAfter=mStringBefore=mStringBefore.substring(nonWhitespaceStart,nonWhitespaceEnd);
  }
}","/** 
 * Remove leading/trailing whitespace from the considered string.
 */
public void trim(){
  final int len=mStringBefore.length();
  int nonWhitespaceStart=0;
  for (; nonWhitespaceStart < len; nonWhitespaceStart=mStringBefore.offsetByCodePoints(nonWhitespaceStart,1)) {
    final int codePoint=mStringBefore.codePointAt(nonWhitespaceStart);
    if (!Character.isWhitespace(codePoint))     break;
  }
  int nonWhitespaceEnd=len;
  for (; nonWhitespaceEnd > 0; nonWhitespaceEnd=mStringBefore.offsetByCodePoints(nonWhitespaceEnd,-1)) {
    final int codePoint=mStringBefore.codePointBefore(nonWhitespaceEnd);
    if (!Character.isWhitespace(codePoint))     break;
  }
  if ((0 != nonWhitespaceStart || len != nonWhitespaceEnd) && nonWhitespaceStart < nonWhitespaceEnd) {
    mCursorEndAfter=mCursorStartBefore + nonWhitespaceEnd;
    mCursorStartBefore=mCursorStartAfter=mCursorStartBefore + nonWhitespaceStart;
    mStringAfter=mStringBefore=mStringBefore.substring(nonWhitespaceStart,nonWhitespaceEnd);
  }
}",0.9782937910146392
87649,"UserDictionaryAddWordContents(final View view,final Bundle args){
  mWordEditText=(EditText)view.findViewById(R.id.user_dictionary_add_word_text);
  mShortcutEditText=(EditText)view.findViewById(R.id.user_dictionary_add_shortcut);
  if (!UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    mShortcutEditText.setVisibility(View.GONE);
    view.findViewById(R.id.user_dictionary_add_shortcut_label).setVisibility(View.GONE);
  }
  final String word=args.getString(EXTRA_WORD);
  if (null != word) {
    mWordEditText.setText(word);
    mWordEditText.setSelection(word.length());
  }
  final String shortcut;
  if (UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    shortcut=args.getString(EXTRA_SHORTCUT);
    if (null != shortcut && null != mShortcutEditText) {
      mShortcutEditText.setText(shortcut);
    }
    mOldShortcut=args.getString(EXTRA_SHORTCUT);
  }
 else {
    shortcut=null;
    mOldShortcut=null;
  }
  mMode=args.getInt(EXTRA_MODE);
  mOldWord=args.getString(EXTRA_WORD);
  updateLocale(args.getString(EXTRA_LOCALE));
}","UserDictionaryAddWordContents(final View view,final Bundle args){
  mWordEditText=(EditText)view.findViewById(R.id.user_dictionary_add_word_text);
  mShortcutEditText=(EditText)view.findViewById(R.id.user_dictionary_add_shortcut);
  if (!UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    mShortcutEditText.setVisibility(View.GONE);
    view.findViewById(R.id.user_dictionary_add_shortcut_label).setVisibility(View.GONE);
  }
  final String word=args.getString(EXTRA_WORD);
  if (null != word) {
    mWordEditText.setText(word);
    mWordEditText.setSelection(mWordEditText.getText().length());
  }
  final String shortcut;
  if (UserDictionarySettings.IS_SHORTCUT_API_SUPPORTED) {
    shortcut=args.getString(EXTRA_SHORTCUT);
    if (null != shortcut && null != mShortcutEditText) {
      mShortcutEditText.setText(shortcut);
    }
    mOldShortcut=args.getString(EXTRA_SHORTCUT);
  }
 else {
    shortcut=null;
    mOldShortcut=null;
  }
  mMode=args.getInt(EXTRA_MODE);
  mOldWord=args.getString(EXTRA_WORD);
  updateLocale(args.getString(EXTRA_LOCALE));
}",0.9871977240398292
87650,"void stop(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"");
  }
  commitCurrentLogUnit();
  try {
    mMainLogBuffer.shiftAndPublishAll();
  }
 catch (  final IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  logStatistics();
  commitCurrentLogUnit();
  mMainLogBuffer.setIsStopping();
  try {
    mMainLogBuffer.shiftAndPublishAll();
  }
 catch (  final IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  mMainResearchLog.blockingClose(RESEARCHLOG_CLOSE_TIMEOUT_IN_MS);
  resetLogBuffers();
}","void stop(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"");
  }
  commitCurrentLogUnit();
  try {
    mMainLogBuffer.shiftAndPublishAll();
  }
 catch (  final IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  logStatistics();
  commitCurrentLogUnit();
  mMainLogBuffer.setIsStopping();
  try {
    mMainLogBuffer.shiftAndPublishAll();
  }
 catch (  final IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  mMainResearchLog.blockingClose(RESEARCHLOG_CLOSE_TIMEOUT_IN_MS);
  resetLogBuffers();
  cancelFeedbackDialog();
}",0.9752380952380952
87651,"public void initSuggest(final Suggest suggest){
  mSuggest=suggest;
  if (mMainLogBuffer != null) {
    stop();
    start();
  }
}","public void initSuggest(final Suggest suggest){
  mSuggest=suggest;
  if (mMainLogBuffer != null) {
    restart();
  }
}",0.944
87652,"/** 
 * Remove leading/trailing whitespace from the considered string.
 */
public void trim(){
  final int len=mStringBefore.length();
  int nonWhitespaceStart=0;
  for (; nonWhitespaceStart < len; nonWhitespaceStart=mStringBefore.offsetByCodePoints(nonWhitespaceStart,1)) {
    final int codePoint=mStringBefore.codePointAt(nonWhitespaceStart);
    if (!Character.isWhitespace(codePoint))     break;
  }
  int nonWhitespaceEnd=len;
  for (; nonWhitespaceEnd > 0; nonWhitespaceEnd=mStringBefore.offsetByCodePoints(nonWhitespaceEnd,-1)) {
    final int codePoint=mStringBefore.codePointBefore(nonWhitespaceEnd);
    if (!Character.isWhitespace(codePoint))     break;
  }
  if (0 != nonWhitespaceStart || len != nonWhitespaceEnd) {
    mCursorEndAfter=mCursorStartBefore + nonWhitespaceEnd;
    mCursorStartBefore=mCursorStartAfter=mCursorStartBefore + nonWhitespaceStart;
    mStringAfter=mStringBefore=mStringBefore.substring(nonWhitespaceStart,nonWhitespaceEnd);
  }
}","/** 
 * Remove leading/trailing whitespace from the considered string.
 */
public void trim(){
  final int len=mStringBefore.length();
  int nonWhitespaceStart=0;
  for (; nonWhitespaceStart < len; nonWhitespaceStart=mStringBefore.offsetByCodePoints(nonWhitespaceStart,1)) {
    final int codePoint=mStringBefore.codePointAt(nonWhitespaceStart);
    if (!Character.isWhitespace(codePoint))     break;
  }
  int nonWhitespaceEnd=len;
  for (; nonWhitespaceEnd > 0; nonWhitespaceEnd=mStringBefore.offsetByCodePoints(nonWhitespaceEnd,-1)) {
    final int codePoint=mStringBefore.codePointBefore(nonWhitespaceEnd);
    if (!Character.isWhitespace(codePoint))     break;
  }
  if ((0 != nonWhitespaceStart || len != nonWhitespaceEnd) && nonWhitespaceStart < nonWhitespaceEnd) {
    mCursorEndAfter=mCursorStartBefore + nonWhitespaceEnd;
    mCursorStartBefore=mCursorStartAfter=mCursorStartBefore + nonWhitespaceStart;
    mStringAfter=mStringBefore=mStringBefore.substring(nonWhitespaceStart,nonWhitespaceEnd);
  }
}",0.9782937910146392
87653,"/** 
 * Remove leading/trailing whitespace from the considered string.
 */
public void trim(){
  final int len=mStringBefore.length();
  int nonWhitespaceStart=0;
  for (; nonWhitespaceStart < len; nonWhitespaceStart=mStringBefore.offsetByCodePoints(nonWhitespaceStart,1)) {
    final int codePoint=mStringBefore.codePointAt(nonWhitespaceStart);
    if (!Character.isWhitespace(codePoint))     break;
  }
  int nonWhitespaceEnd=len;
  for (; nonWhitespaceEnd > 0; nonWhitespaceEnd=mStringBefore.offsetByCodePoints(nonWhitespaceEnd,-1)) {
    final int codePoint=mStringBefore.codePointBefore(nonWhitespaceEnd);
    if (!Character.isWhitespace(codePoint))     break;
  }
  if (0 != nonWhitespaceStart || len != nonWhitespaceEnd) {
    mCursorEndAfter=mCursorStartBefore + nonWhitespaceEnd;
    mCursorStartBefore=mCursorStartAfter=mCursorStartBefore + nonWhitespaceStart;
    mStringAfter=mStringBefore=mStringBefore.substring(nonWhitespaceStart,nonWhitespaceEnd);
  }
}","/** 
 * Remove leading/trailing whitespace from the considered string.
 */
public void trim(){
  final int len=mStringBefore.length();
  int nonWhitespaceStart=0;
  for (; nonWhitespaceStart < len; nonWhitespaceStart=mStringBefore.offsetByCodePoints(nonWhitespaceStart,1)) {
    final int codePoint=mStringBefore.codePointAt(nonWhitespaceStart);
    if (!Character.isWhitespace(codePoint))     break;
  }
  int nonWhitespaceEnd=len;
  for (; nonWhitespaceEnd > 0; nonWhitespaceEnd=mStringBefore.offsetByCodePoints(nonWhitespaceEnd,-1)) {
    final int codePoint=mStringBefore.codePointBefore(nonWhitespaceEnd);
    if (!Character.isWhitespace(codePoint))     break;
  }
  if ((0 != nonWhitespaceStart || len != nonWhitespaceEnd) && nonWhitespaceStart < nonWhitespaceEnd) {
    mCursorEndAfter=mCursorStartBefore + nonWhitespaceEnd;
    mCursorStartBefore=mCursorStartAfter=mCursorStartBefore + nonWhitespaceStart;
    mStringAfter=mStringBefore=mStringBefore.substring(nonWhitespaceStart,nonWhitespaceEnd);
  }
}",0.9782937910146392
87654,"void stop(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"");
  }
  commitCurrentLogUnit();
  try {
    mMainLogBuffer.shiftAndPublishAll();
  }
 catch (  final IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  logStatistics();
  commitCurrentLogUnit();
  mMainLogBuffer.setIsStopping();
  try {
    mMainLogBuffer.shiftAndPublishAll();
  }
 catch (  final IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  mMainResearchLog.blockingClose(RESEARCHLOG_CLOSE_TIMEOUT_IN_MS);
  resetLogBuffers();
}","void stop(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"");
  }
  commitCurrentLogUnit();
  try {
    mMainLogBuffer.shiftAndPublishAll();
  }
 catch (  final IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  logStatistics();
  commitCurrentLogUnit();
  mMainLogBuffer.setIsStopping();
  try {
    mMainLogBuffer.shiftAndPublishAll();
  }
 catch (  final IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  mMainResearchLog.blockingClose(RESEARCHLOG_CLOSE_TIMEOUT_IN_MS);
  resetLogBuffers();
  cancelFeedbackDialog();
}",0.9752380952380952
87655,"public void initSuggest(final Suggest suggest){
  mSuggest=suggest;
  if (mMainLogBuffer != null) {
    stop();
    start();
  }
}","public void initSuggest(final Suggest suggest){
  mSuggest=suggest;
  if (mMainLogBuffer != null) {
    restart();
  }
}",0.944
87656,"private static double degreeToRadian(final int degree){
  return (double)degree / 180.0d * Math.PI;
}","private static double degreeToRadian(final int degree){
  return degree / 180.0d * Math.PI;
}",0.9587628865979382
87657,"public void appendPreviewStroke(final ResizableIntArray eventTimes,final ResizableIntArray xCoords,final ResizableIntArray yCoords){
  final int length=mPreviewEventTimes.getLength() - mLastPreviewSize;
  if (length <= 0) {
    return;
  }
  eventTimes.append(mPreviewEventTimes,mLastPreviewSize,length);
  xCoords.append(mPreviewXCoordinates,mLastPreviewSize,length);
  yCoords.append(mPreviewYCoordinates,mLastPreviewSize,length);
  mLastPreviewSize=mPreviewEventTimes.getLength();
}","/** 
 * Append sampled preview points.
 * @param eventTimes the event time array of gesture trail to be drawn.
 * @param xCoords the x-coordinates array of gesture trail to be drawn.
 * @param yCoords the y-coordinates array of gesture trail to be drawn.
 * @param types the point types array of gesture trail. This is valid only when{@link GestureTrail#DEBUG_SHOW_POINTS} is true.
 */
public void appendPreviewStroke(final ResizableIntArray eventTimes,final ResizableIntArray xCoords,final ResizableIntArray yCoords,final ResizableIntArray types){
  final int length=mPreviewEventTimes.getLength() - mLastPreviewSize;
  if (length <= 0) {
    return;
  }
  eventTimes.append(mPreviewEventTimes,mLastPreviewSize,length);
  xCoords.append(mPreviewXCoordinates,mLastPreviewSize,length);
  yCoords.append(mPreviewYCoordinates,mLastPreviewSize,length);
  if (GestureTrail.DEBUG_SHOW_POINTS) {
    types.fill(GestureTrail.POINT_TYPE_SAMPLED,types.getLength(),length);
  }
  mLastPreviewSize=mPreviewEventTimes.getLength();
}",0.6449468085106383
87658,"/** 
 * Calculate interpolated points between the last interpolated point and the end of the trail. And return the start index of the last interpolated segment of input arrays because it may need to recalculate the interpolated points in the segment if further segments are added to this stroke.
 * @param lastInterpolatedIndex the start index of the last interpolated segment of<code>eventTimes</code>, <code>xCoords</code>, and <code>yCoords</code>.
 * @param eventTimes the event time array of gesture trail to be drawn.
 * @param xCoords the x-coordinates array of gesture trail to be drawn.
 * @param yCoords the y-coordinates array of gesture trail to be drawn.
 * @return the start index of the last interpolated segment of input arrays.
 */
public int interpolateStrokeAndReturnStartIndexOfLastSegment(final int lastInterpolatedIndex,final ResizableIntArray eventTimes,final ResizableIntArray xCoords,final ResizableIntArray yCoords,final ResizableIntArray types){
  final int size=mPreviewEventTimes.getLength();
  final int[] pt=mPreviewEventTimes.getPrimitiveArray();
  final int[] px=mPreviewXCoordinates.getPrimitiveArray();
  final int[] py=mPreviewYCoordinates.getPrimitiveArray();
  mInterpolator.reset(px,py,0,size);
  int lastInterpolatedDrawIndex=lastInterpolatedIndex;
  int d1=lastInterpolatedIndex;
  for (int p2=mLastInterpolatedPreviewIndex + 1; p2 < size; p2++) {
    final int p1=p2 - 1;
    final int p0=p1 - 1;
    final int p3=p2 + 1;
    mLastInterpolatedPreviewIndex=p1;
    lastInterpolatedDrawIndex=d1;
    mInterpolator.setInterval(p0,p1,p2,p3);
    final double m1=Math.atan2(mInterpolator.mSlope1Y,mInterpolator.mSlope1X);
    final double m2=Math.atan2(mInterpolator.mSlope2Y,mInterpolator.mSlope2X);
    final double deltaAngle=Math.abs(angularDiff(m2,m1));
    final int segmentsByAngle=(int)Math.ceil(deltaAngle / mPreviewParams.mMaxInterpolationAngularThreshold);
    final double deltaDistance=Math.hypot(mInterpolator.mP1X - mInterpolator.mP2X,mInterpolator.mP1Y - mInterpolator.mP2Y);
    final int segmentsByDistance=(int)Math.ceil(deltaDistance / mPreviewParams.mMaxInterpolationDistanceThreshold);
    final int segments=Math.min(mPreviewParams.mMaxInterpolationSegments,Math.max(segmentsByAngle,segmentsByDistance));
    final int t1=eventTimes.get(d1);
    final int dt=pt[p2] - pt[p1];
    d1++;
    for (int i=1; i < segments; i++) {
      final float t=i / (float)segments;
      mInterpolator.interpolate(t);
      eventTimes.add(d1,(int)(dt * t) + t1);
      xCoords.add(d1,(int)mInterpolator.mInterpolatedX);
      yCoords.add(d1,(int)mInterpolator.mInterpolatedY);
      if (GestureTrail.DBG_SHOW_POINTS) {
        types.add(d1,GestureTrail.POINT_TYPE_INTERPOLATED);
      }
      d1++;
    }
    eventTimes.add(d1,pt[p2]);
    xCoords.add(d1,px[p2]);
    yCoords.add(d1,py[p2]);
    if (GestureTrail.DBG_SHOW_POINTS) {
      types.add(d1,GestureTrail.POINT_TYPE_SAMPLED);
    }
  }
  return lastInterpolatedDrawIndex;
}","/** 
 * Calculate interpolated points between the last interpolated point and the end of the trail. And return the start index of the last interpolated segment of input arrays because it may need to recalculate the interpolated points in the segment if further segments are added to this stroke.
 * @param lastInterpolatedIndex the start index of the last interpolated segment of<code>eventTimes</code>, <code>xCoords</code>, and <code>yCoords</code>.
 * @param eventTimes the event time array of gesture trail to be drawn.
 * @param xCoords the x-coordinates array of gesture trail to be drawn.
 * @param yCoords the y-coordinates array of gesture trail to be drawn.
 * @param types the point types array of gesture trail. This is valid only when{@link GestureTrail#DEBUG_SHOW_POINTS} is true.
 * @return the start index of the last interpolated segment of input arrays.
 */
public int interpolateStrokeAndReturnStartIndexOfLastSegment(final int lastInterpolatedIndex,final ResizableIntArray eventTimes,final ResizableIntArray xCoords,final ResizableIntArray yCoords,final ResizableIntArray types){
  final int size=mPreviewEventTimes.getLength();
  final int[] pt=mPreviewEventTimes.getPrimitiveArray();
  final int[] px=mPreviewXCoordinates.getPrimitiveArray();
  final int[] py=mPreviewYCoordinates.getPrimitiveArray();
  mInterpolator.reset(px,py,0,size);
  int lastInterpolatedDrawIndex=lastInterpolatedIndex;
  int d1=lastInterpolatedIndex;
  for (int p2=mLastInterpolatedPreviewIndex + 1; p2 < size; p2++) {
    final int p1=p2 - 1;
    final int p0=p1 - 1;
    final int p3=p2 + 1;
    mLastInterpolatedPreviewIndex=p1;
    lastInterpolatedDrawIndex=d1;
    mInterpolator.setInterval(p0,p1,p2,p3);
    final double m1=Math.atan2(mInterpolator.mSlope1Y,mInterpolator.mSlope1X);
    final double m2=Math.atan2(mInterpolator.mSlope2Y,mInterpolator.mSlope2X);
    final double deltaAngle=Math.abs(angularDiff(m2,m1));
    final int segmentsByAngle=(int)Math.ceil(deltaAngle / mPreviewParams.mMaxInterpolationAngularThreshold);
    final double deltaDistance=Math.hypot(mInterpolator.mP1X - mInterpolator.mP2X,mInterpolator.mP1Y - mInterpolator.mP2Y);
    final int segmentsByDistance=(int)Math.ceil(deltaDistance / mPreviewParams.mMaxInterpolationDistanceThreshold);
    final int segments=Math.min(mPreviewParams.mMaxInterpolationSegments,Math.max(segmentsByAngle,segmentsByDistance));
    final int t1=eventTimes.get(d1);
    final int dt=pt[p2] - pt[p1];
    d1++;
    for (int i=1; i < segments; i++) {
      final float t=i / (float)segments;
      mInterpolator.interpolate(t);
      eventTimes.add(d1,(int)(dt * t) + t1);
      xCoords.add(d1,(int)mInterpolator.mInterpolatedX);
      yCoords.add(d1,(int)mInterpolator.mInterpolatedY);
      if (GestureTrail.DEBUG_SHOW_POINTS) {
        types.add(d1,GestureTrail.POINT_TYPE_INTERPOLATED);
      }
      d1++;
    }
    eventTimes.add(d1,pt[p2]);
    xCoords.add(d1,px[p2]);
    yCoords.add(d1,py[p2]);
    if (GestureTrail.DEBUG_SHOW_POINTS) {
      types.add(d1,GestureTrail.POINT_TYPE_SAMPLED);
    }
  }
  return lastInterpolatedDrawIndex;
}",0.9784645734012822
87659,"private boolean drawGestureTrailLocked(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  outBoundsRect.setEmpty();
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int[] pointTypes=mPointTypes.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine roundedLine=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    final int lastTime=sinceDown - eventTimes[startIndex];
    float r1=getWidth(lastTime,params) / 2.0f;
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float r2=getWidth(elapsedTime,params) / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final float body1=r1 * params.mTrailBodyRatio;
        final float body2=r2 * params.mTrailBodyRatio;
        final Path path=roundedLine.makePath(p1x,p1y,body1,p2x,p2y,body2);
        if (path != null) {
          roundedLine.getBounds(mRoundedLineBounds);
          if (params.mTrailShadowEnabled) {
            final float shadow2=r2 * params.mTrailShadowRatio;
            paint.setShadowLayer(shadow2,0.0f,0.0f,params.mTrailColor);
            final int shadowInset=-(int)Math.ceil(shadow2);
            mRoundedLineBounds.inset(shadowInset,shadowInset);
          }
          outBoundsRect.union(mRoundedLineBounds);
          final int alpha=getAlpha(elapsedTime,params);
          paint.setAlpha(alpha);
          canvas.drawPath(path,paint);
          if (DBG_SHOW_POINTS) {
            if (pointTypes[i] == POINT_TYPE_INTERPOLATED) {
              paint.setColor(Color.RED);
            }
 else             if (pointTypes[i] == POINT_TYPE_SAMPLED) {
              paint.setColor(0xFFA000FF);
            }
 else {
              paint.setColor(Color.GREEN);
            }
            canvas.drawCircle(p1x - 1,p1y - 1,2,paint);
            paint.setColor(params.mTrailColor);
          }
        }
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
    }
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
    if (DBG_SHOW_POINTS) {
      mPointTypes.setLength(newSize);
    }
    mLastInterpolatedDrawIndex=Math.max(mLastInterpolatedDrawIndex - startIndex,0);
  }
  return newSize > 0;
}","private boolean drawGestureTrailLocked(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  outBoundsRect.setEmpty();
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int[] pointTypes=mPointTypes.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine roundedLine=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    final int lastTime=sinceDown - eventTimes[startIndex];
    float r1=getWidth(lastTime,params) / 2.0f;
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float r2=getWidth(elapsedTime,params) / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final float body1=r1 * params.mTrailBodyRatio;
        final float body2=r2 * params.mTrailBodyRatio;
        final Path path=roundedLine.makePath(p1x,p1y,body1,p2x,p2y,body2);
        if (path != null) {
          roundedLine.getBounds(mRoundedLineBounds);
          if (params.mTrailShadowEnabled) {
            final float shadow2=r2 * params.mTrailShadowRatio;
            paint.setShadowLayer(shadow2,0.0f,0.0f,params.mTrailColor);
            final int shadowInset=-(int)Math.ceil(shadow2);
            mRoundedLineBounds.inset(shadowInset,shadowInset);
          }
          outBoundsRect.union(mRoundedLineBounds);
          final int alpha=getAlpha(elapsedTime,params);
          paint.setAlpha(alpha);
          canvas.drawPath(path,paint);
        }
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
    }
    if (DEBUG_SHOW_POINTS) {
      debugDrawPoints(canvas,startIndex,trailSize,paint);
    }
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
      if (DEBUG_SHOW_POINTS) {
        System.arraycopy(pointTypes,startIndex,pointTypes,0,newSize);
      }
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
    if (DEBUG_SHOW_POINTS) {
      mPointTypes.setLength(newSize);
    }
    mLastInterpolatedDrawIndex=Math.max(mLastInterpolatedDrawIndex - startIndex,0);
  }
  return newSize > 0;
}",0.7526413921690491
87660,"public Params(final TypedArray mainKeyboardViewAttr){
  mTrailColor=mainKeyboardViewAttr.getColor(R.styleable.MainKeyboardView_gestureTrailColor,0);
  mTrailStartWidth=mainKeyboardViewAttr.getDimension(R.styleable.MainKeyboardView_gestureTrailStartWidth,0.0f);
  mTrailEndWidth=mainKeyboardViewAttr.getDimension(R.styleable.MainKeyboardView_gestureTrailEndWidth,0.0f);
  final int PERCENTAGE_INT=100;
  mTrailBodyRatio=(float)mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailBodyRatio,PERCENTAGE_INT) / (float)PERCENTAGE_INT;
  final int trailShadowRatioInt=mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailShadowRatio,0);
  mTrailShadowEnabled=(trailShadowRatioInt > 0);
  mTrailShadowRatio=(float)trailShadowRatioInt / (float)PERCENTAGE_INT;
  mFadeoutStartDelay=DBG_SHOW_POINTS ? 2000 : mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailFadeoutStartDelay,0);
  mFadeoutDuration=DBG_SHOW_POINTS ? 200 : mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailFadeoutDuration,0);
  mTrailLingerDuration=mFadeoutStartDelay + mFadeoutDuration;
  mUpdateInterval=mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailUpdateInterval,0);
}","public Params(final TypedArray mainKeyboardViewAttr){
  mTrailColor=mainKeyboardViewAttr.getColor(R.styleable.MainKeyboardView_gestureTrailColor,0);
  mTrailStartWidth=mainKeyboardViewAttr.getDimension(R.styleable.MainKeyboardView_gestureTrailStartWidth,0.0f);
  mTrailEndWidth=mainKeyboardViewAttr.getDimension(R.styleable.MainKeyboardView_gestureTrailEndWidth,0.0f);
  final int PERCENTAGE_INT=100;
  mTrailBodyRatio=(float)mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailBodyRatio,PERCENTAGE_INT) / (float)PERCENTAGE_INT;
  final int trailShadowRatioInt=mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailShadowRatio,0);
  mTrailShadowEnabled=(trailShadowRatioInt > 0);
  mTrailShadowRatio=(float)trailShadowRatioInt / (float)PERCENTAGE_INT;
  mFadeoutStartDelay=DEBUG_SHOW_POINTS ? FADEOUT_START_DELAY_FOR_DEBUG : mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailFadeoutStartDelay,0);
  mFadeoutDuration=DEBUG_SHOW_POINTS ? FADEOUT_DURATION_FOR_DEBUG : mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailFadeoutDuration,0);
  mTrailLingerDuration=mFadeoutStartDelay + mFadeoutDuration;
  mUpdateInterval=mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailUpdateInterval,0);
}",0.9735576923076924
87661,"private void addStrokeLocked(final GestureStrokeWithPreviewPoints stroke,final long downTime){
  final int trailSize=mEventTimes.getLength();
  stroke.appendPreviewStroke(mEventTimes,mXCoordinates,mYCoordinates);
  if (mEventTimes.getLength() == trailSize) {
    return;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int strokeId=stroke.getGestureStrokeId();
  final int lastInterpolatedIndex=(strokeId == mCurrentStrokeId) ? mLastInterpolatedDrawIndex : trailSize;
  mLastInterpolatedDrawIndex=stroke.interpolateStrokeAndReturnStartIndexOfLastSegment(lastInterpolatedIndex,mEventTimes,mXCoordinates,mYCoordinates,mPointTypes);
  if (strokeId != mCurrentStrokeId) {
    final int elapsedTime=(int)(downTime - mCurrentTimeBase);
    for (int i=mTrailStartIndex; i < trailSize; i++) {
      eventTimes[i]-=elapsedTime;
    }
    final int[] xCoords=mXCoordinates.getPrimitiveArray();
    final int downIndex=trailSize;
    xCoords[downIndex]=markAsDownEvent(xCoords[downIndex]);
    mCurrentTimeBase=downTime - eventTimes[downIndex];
    mCurrentStrokeId=strokeId;
  }
}","private void addStrokeLocked(final GestureStrokeWithPreviewPoints stroke,final long downTime){
  final int trailSize=mEventTimes.getLength();
  stroke.appendPreviewStroke(mEventTimes,mXCoordinates,mYCoordinates,mPointTypes);
  if (mEventTimes.getLength() == trailSize) {
    return;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int strokeId=stroke.getGestureStrokeId();
  final int lastInterpolatedIndex=(strokeId == mCurrentStrokeId) ? mLastInterpolatedDrawIndex : trailSize;
  mLastInterpolatedDrawIndex=stroke.interpolateStrokeAndReturnStartIndexOfLastSegment(lastInterpolatedIndex,mEventTimes,mXCoordinates,mYCoordinates,mPointTypes);
  if (strokeId != mCurrentStrokeId) {
    final int elapsedTime=(int)(downTime - mCurrentTimeBase);
    for (int i=mTrailStartIndex; i < trailSize; i++) {
      eventTimes[i]-=elapsedTime;
    }
    final int[] xCoords=mXCoordinates.getPrimitiveArray();
    final int downIndex=trailSize;
    xCoords[downIndex]=markAsDownEvent(xCoords[downIndex]);
    mCurrentTimeBase=downTime - eventTimes[downIndex];
    mCurrentStrokeId=strokeId;
  }
}",0.994535519125683
87662,"private static double degreeToRadian(final int degree){
  return (double)degree / 180.0d * Math.PI;
}","private static double degreeToRadian(final int degree){
  return degree / 180.0d * Math.PI;
}",0.9587628865979382
87663,"public void appendPreviewStroke(final ResizableIntArray eventTimes,final ResizableIntArray xCoords,final ResizableIntArray yCoords){
  final int length=mPreviewEventTimes.getLength() - mLastPreviewSize;
  if (length <= 0) {
    return;
  }
  eventTimes.append(mPreviewEventTimes,mLastPreviewSize,length);
  xCoords.append(mPreviewXCoordinates,mLastPreviewSize,length);
  yCoords.append(mPreviewYCoordinates,mLastPreviewSize,length);
  mLastPreviewSize=mPreviewEventTimes.getLength();
}","/** 
 * Append sampled preview points.
 * @param eventTimes the event time array of gesture trail to be drawn.
 * @param xCoords the x-coordinates array of gesture trail to be drawn.
 * @param yCoords the y-coordinates array of gesture trail to be drawn.
 * @param types the point types array of gesture trail. This is valid only when{@link GestureTrail#DEBUG_SHOW_POINTS} is true.
 */
public void appendPreviewStroke(final ResizableIntArray eventTimes,final ResizableIntArray xCoords,final ResizableIntArray yCoords,final ResizableIntArray types){
  final int length=mPreviewEventTimes.getLength() - mLastPreviewSize;
  if (length <= 0) {
    return;
  }
  eventTimes.append(mPreviewEventTimes,mLastPreviewSize,length);
  xCoords.append(mPreviewXCoordinates,mLastPreviewSize,length);
  yCoords.append(mPreviewYCoordinates,mLastPreviewSize,length);
  if (GestureTrail.DEBUG_SHOW_POINTS) {
    types.fill(GestureTrail.POINT_TYPE_SAMPLED,types.getLength(),length);
  }
  mLastPreviewSize=mPreviewEventTimes.getLength();
}",0.6449468085106383
87664,"/** 
 * Calculate interpolated points between the last interpolated point and the end of the trail. And return the start index of the last interpolated segment of input arrays because it may need to recalculate the interpolated points in the segment if further segments are added to this stroke.
 * @param lastInterpolatedIndex the start index of the last interpolated segment of<code>eventTimes</code>, <code>xCoords</code>, and <code>yCoords</code>.
 * @param eventTimes the event time array of gesture trail to be drawn.
 * @param xCoords the x-coordinates array of gesture trail to be drawn.
 * @param yCoords the y-coordinates array of gesture trail to be drawn.
 * @return the start index of the last interpolated segment of input arrays.
 */
public int interpolateStrokeAndReturnStartIndexOfLastSegment(final int lastInterpolatedIndex,final ResizableIntArray eventTimes,final ResizableIntArray xCoords,final ResizableIntArray yCoords,final ResizableIntArray types){
  final int size=mPreviewEventTimes.getLength();
  final int[] pt=mPreviewEventTimes.getPrimitiveArray();
  final int[] px=mPreviewXCoordinates.getPrimitiveArray();
  final int[] py=mPreviewYCoordinates.getPrimitiveArray();
  mInterpolator.reset(px,py,0,size);
  int lastInterpolatedDrawIndex=lastInterpolatedIndex;
  int d1=lastInterpolatedIndex;
  for (int p2=mLastInterpolatedPreviewIndex + 1; p2 < size; p2++) {
    final int p1=p2 - 1;
    final int p0=p1 - 1;
    final int p3=p2 + 1;
    mLastInterpolatedPreviewIndex=p1;
    lastInterpolatedDrawIndex=d1;
    mInterpolator.setInterval(p0,p1,p2,p3);
    final double m1=Math.atan2(mInterpolator.mSlope1Y,mInterpolator.mSlope1X);
    final double m2=Math.atan2(mInterpolator.mSlope2Y,mInterpolator.mSlope2X);
    final double deltaAngle=Math.abs(angularDiff(m2,m1));
    final int segmentsByAngle=(int)Math.ceil(deltaAngle / mPreviewParams.mMaxInterpolationAngularThreshold);
    final double deltaDistance=Math.hypot(mInterpolator.mP1X - mInterpolator.mP2X,mInterpolator.mP1Y - mInterpolator.mP2Y);
    final int segmentsByDistance=(int)Math.ceil(deltaDistance / mPreviewParams.mMaxInterpolationDistanceThreshold);
    final int segments=Math.min(mPreviewParams.mMaxInterpolationSegments,Math.max(segmentsByAngle,segmentsByDistance));
    final int t1=eventTimes.get(d1);
    final int dt=pt[p2] - pt[p1];
    d1++;
    for (int i=1; i < segments; i++) {
      final float t=i / (float)segments;
      mInterpolator.interpolate(t);
      eventTimes.add(d1,(int)(dt * t) + t1);
      xCoords.add(d1,(int)mInterpolator.mInterpolatedX);
      yCoords.add(d1,(int)mInterpolator.mInterpolatedY);
      if (GestureTrail.DBG_SHOW_POINTS) {
        types.add(d1,GestureTrail.POINT_TYPE_INTERPOLATED);
      }
      d1++;
    }
    eventTimes.add(d1,pt[p2]);
    xCoords.add(d1,px[p2]);
    yCoords.add(d1,py[p2]);
    if (GestureTrail.DBG_SHOW_POINTS) {
      types.add(d1,GestureTrail.POINT_TYPE_SAMPLED);
    }
  }
  return lastInterpolatedDrawIndex;
}","/** 
 * Calculate interpolated points between the last interpolated point and the end of the trail. And return the start index of the last interpolated segment of input arrays because it may need to recalculate the interpolated points in the segment if further segments are added to this stroke.
 * @param lastInterpolatedIndex the start index of the last interpolated segment of<code>eventTimes</code>, <code>xCoords</code>, and <code>yCoords</code>.
 * @param eventTimes the event time array of gesture trail to be drawn.
 * @param xCoords the x-coordinates array of gesture trail to be drawn.
 * @param yCoords the y-coordinates array of gesture trail to be drawn.
 * @param types the point types array of gesture trail. This is valid only when{@link GestureTrail#DEBUG_SHOW_POINTS} is true.
 * @return the start index of the last interpolated segment of input arrays.
 */
public int interpolateStrokeAndReturnStartIndexOfLastSegment(final int lastInterpolatedIndex,final ResizableIntArray eventTimes,final ResizableIntArray xCoords,final ResizableIntArray yCoords,final ResizableIntArray types){
  final int size=mPreviewEventTimes.getLength();
  final int[] pt=mPreviewEventTimes.getPrimitiveArray();
  final int[] px=mPreviewXCoordinates.getPrimitiveArray();
  final int[] py=mPreviewYCoordinates.getPrimitiveArray();
  mInterpolator.reset(px,py,0,size);
  int lastInterpolatedDrawIndex=lastInterpolatedIndex;
  int d1=lastInterpolatedIndex;
  for (int p2=mLastInterpolatedPreviewIndex + 1; p2 < size; p2++) {
    final int p1=p2 - 1;
    final int p0=p1 - 1;
    final int p3=p2 + 1;
    mLastInterpolatedPreviewIndex=p1;
    lastInterpolatedDrawIndex=d1;
    mInterpolator.setInterval(p0,p1,p2,p3);
    final double m1=Math.atan2(mInterpolator.mSlope1Y,mInterpolator.mSlope1X);
    final double m2=Math.atan2(mInterpolator.mSlope2Y,mInterpolator.mSlope2X);
    final double deltaAngle=Math.abs(angularDiff(m2,m1));
    final int segmentsByAngle=(int)Math.ceil(deltaAngle / mPreviewParams.mMaxInterpolationAngularThreshold);
    final double deltaDistance=Math.hypot(mInterpolator.mP1X - mInterpolator.mP2X,mInterpolator.mP1Y - mInterpolator.mP2Y);
    final int segmentsByDistance=(int)Math.ceil(deltaDistance / mPreviewParams.mMaxInterpolationDistanceThreshold);
    final int segments=Math.min(mPreviewParams.mMaxInterpolationSegments,Math.max(segmentsByAngle,segmentsByDistance));
    final int t1=eventTimes.get(d1);
    final int dt=pt[p2] - pt[p1];
    d1++;
    for (int i=1; i < segments; i++) {
      final float t=i / (float)segments;
      mInterpolator.interpolate(t);
      eventTimes.add(d1,(int)(dt * t) + t1);
      xCoords.add(d1,(int)mInterpolator.mInterpolatedX);
      yCoords.add(d1,(int)mInterpolator.mInterpolatedY);
      if (GestureTrail.DEBUG_SHOW_POINTS) {
        types.add(d1,GestureTrail.POINT_TYPE_INTERPOLATED);
      }
      d1++;
    }
    eventTimes.add(d1,pt[p2]);
    xCoords.add(d1,px[p2]);
    yCoords.add(d1,py[p2]);
    if (GestureTrail.DEBUG_SHOW_POINTS) {
      types.add(d1,GestureTrail.POINT_TYPE_SAMPLED);
    }
  }
  return lastInterpolatedDrawIndex;
}",0.9784645734012822
87665,"private boolean drawGestureTrailLocked(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  outBoundsRect.setEmpty();
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int[] pointTypes=mPointTypes.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine roundedLine=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    final int lastTime=sinceDown - eventTimes[startIndex];
    float r1=getWidth(lastTime,params) / 2.0f;
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float r2=getWidth(elapsedTime,params) / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final float body1=r1 * params.mTrailBodyRatio;
        final float body2=r2 * params.mTrailBodyRatio;
        final Path path=roundedLine.makePath(p1x,p1y,body1,p2x,p2y,body2);
        if (path != null) {
          roundedLine.getBounds(mRoundedLineBounds);
          if (params.mTrailShadowEnabled) {
            final float shadow2=r2 * params.mTrailShadowRatio;
            paint.setShadowLayer(shadow2,0.0f,0.0f,params.mTrailColor);
            final int shadowInset=-(int)Math.ceil(shadow2);
            mRoundedLineBounds.inset(shadowInset,shadowInset);
          }
          outBoundsRect.union(mRoundedLineBounds);
          final int alpha=getAlpha(elapsedTime,params);
          paint.setAlpha(alpha);
          canvas.drawPath(path,paint);
          if (DBG_SHOW_POINTS) {
            if (pointTypes[i] == POINT_TYPE_INTERPOLATED) {
              paint.setColor(Color.RED);
            }
 else             if (pointTypes[i] == POINT_TYPE_SAMPLED) {
              paint.setColor(0xFFA000FF);
            }
 else {
              paint.setColor(Color.GREEN);
            }
            canvas.drawCircle(p1x - 1,p1y - 1,2,paint);
            paint.setColor(params.mTrailColor);
          }
        }
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
    }
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
    if (DBG_SHOW_POINTS) {
      mPointTypes.setLength(newSize);
    }
    mLastInterpolatedDrawIndex=Math.max(mLastInterpolatedDrawIndex - startIndex,0);
  }
  return newSize > 0;
}","private boolean drawGestureTrailLocked(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  outBoundsRect.setEmpty();
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int[] pointTypes=mPointTypes.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine roundedLine=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    final int lastTime=sinceDown - eventTimes[startIndex];
    float r1=getWidth(lastTime,params) / 2.0f;
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float r2=getWidth(elapsedTime,params) / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final float body1=r1 * params.mTrailBodyRatio;
        final float body2=r2 * params.mTrailBodyRatio;
        final Path path=roundedLine.makePath(p1x,p1y,body1,p2x,p2y,body2);
        if (path != null) {
          roundedLine.getBounds(mRoundedLineBounds);
          if (params.mTrailShadowEnabled) {
            final float shadow2=r2 * params.mTrailShadowRatio;
            paint.setShadowLayer(shadow2,0.0f,0.0f,params.mTrailColor);
            final int shadowInset=-(int)Math.ceil(shadow2);
            mRoundedLineBounds.inset(shadowInset,shadowInset);
          }
          outBoundsRect.union(mRoundedLineBounds);
          final int alpha=getAlpha(elapsedTime,params);
          paint.setAlpha(alpha);
          canvas.drawPath(path,paint);
        }
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
    }
    if (DEBUG_SHOW_POINTS) {
      debugDrawPoints(canvas,startIndex,trailSize,paint);
    }
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
      if (DEBUG_SHOW_POINTS) {
        System.arraycopy(pointTypes,startIndex,pointTypes,0,newSize);
      }
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
    if (DEBUG_SHOW_POINTS) {
      mPointTypes.setLength(newSize);
    }
    mLastInterpolatedDrawIndex=Math.max(mLastInterpolatedDrawIndex - startIndex,0);
  }
  return newSize > 0;
}",0.7526413921690491
87666,"public Params(final TypedArray mainKeyboardViewAttr){
  mTrailColor=mainKeyboardViewAttr.getColor(R.styleable.MainKeyboardView_gestureTrailColor,0);
  mTrailStartWidth=mainKeyboardViewAttr.getDimension(R.styleable.MainKeyboardView_gestureTrailStartWidth,0.0f);
  mTrailEndWidth=mainKeyboardViewAttr.getDimension(R.styleable.MainKeyboardView_gestureTrailEndWidth,0.0f);
  final int PERCENTAGE_INT=100;
  mTrailBodyRatio=(float)mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailBodyRatio,PERCENTAGE_INT) / (float)PERCENTAGE_INT;
  final int trailShadowRatioInt=mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailShadowRatio,0);
  mTrailShadowEnabled=(trailShadowRatioInt > 0);
  mTrailShadowRatio=(float)trailShadowRatioInt / (float)PERCENTAGE_INT;
  mFadeoutStartDelay=DBG_SHOW_POINTS ? 2000 : mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailFadeoutStartDelay,0);
  mFadeoutDuration=DBG_SHOW_POINTS ? 200 : mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailFadeoutDuration,0);
  mTrailLingerDuration=mFadeoutStartDelay + mFadeoutDuration;
  mUpdateInterval=mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailUpdateInterval,0);
}","public Params(final TypedArray mainKeyboardViewAttr){
  mTrailColor=mainKeyboardViewAttr.getColor(R.styleable.MainKeyboardView_gestureTrailColor,0);
  mTrailStartWidth=mainKeyboardViewAttr.getDimension(R.styleable.MainKeyboardView_gestureTrailStartWidth,0.0f);
  mTrailEndWidth=mainKeyboardViewAttr.getDimension(R.styleable.MainKeyboardView_gestureTrailEndWidth,0.0f);
  final int PERCENTAGE_INT=100;
  mTrailBodyRatio=(float)mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailBodyRatio,PERCENTAGE_INT) / (float)PERCENTAGE_INT;
  final int trailShadowRatioInt=mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailShadowRatio,0);
  mTrailShadowEnabled=(trailShadowRatioInt > 0);
  mTrailShadowRatio=(float)trailShadowRatioInt / (float)PERCENTAGE_INT;
  mFadeoutStartDelay=DEBUG_SHOW_POINTS ? FADEOUT_START_DELAY_FOR_DEBUG : mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailFadeoutStartDelay,0);
  mFadeoutDuration=DEBUG_SHOW_POINTS ? FADEOUT_DURATION_FOR_DEBUG : mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailFadeoutDuration,0);
  mTrailLingerDuration=mFadeoutStartDelay + mFadeoutDuration;
  mUpdateInterval=mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailUpdateInterval,0);
}",0.9735576923076924
87667,"private void addStrokeLocked(final GestureStrokeWithPreviewPoints stroke,final long downTime){
  final int trailSize=mEventTimes.getLength();
  stroke.appendPreviewStroke(mEventTimes,mXCoordinates,mYCoordinates);
  if (mEventTimes.getLength() == trailSize) {
    return;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int strokeId=stroke.getGestureStrokeId();
  final int lastInterpolatedIndex=(strokeId == mCurrentStrokeId) ? mLastInterpolatedDrawIndex : trailSize;
  mLastInterpolatedDrawIndex=stroke.interpolateStrokeAndReturnStartIndexOfLastSegment(lastInterpolatedIndex,mEventTimes,mXCoordinates,mYCoordinates,mPointTypes);
  if (strokeId != mCurrentStrokeId) {
    final int elapsedTime=(int)(downTime - mCurrentTimeBase);
    for (int i=mTrailStartIndex; i < trailSize; i++) {
      eventTimes[i]-=elapsedTime;
    }
    final int[] xCoords=mXCoordinates.getPrimitiveArray();
    final int downIndex=trailSize;
    xCoords[downIndex]=markAsDownEvent(xCoords[downIndex]);
    mCurrentTimeBase=downTime - eventTimes[downIndex];
    mCurrentStrokeId=strokeId;
  }
}","private void addStrokeLocked(final GestureStrokeWithPreviewPoints stroke,final long downTime){
  final int trailSize=mEventTimes.getLength();
  stroke.appendPreviewStroke(mEventTimes,mXCoordinates,mYCoordinates,mPointTypes);
  if (mEventTimes.getLength() == trailSize) {
    return;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int strokeId=stroke.getGestureStrokeId();
  final int lastInterpolatedIndex=(strokeId == mCurrentStrokeId) ? mLastInterpolatedDrawIndex : trailSize;
  mLastInterpolatedDrawIndex=stroke.interpolateStrokeAndReturnStartIndexOfLastSegment(lastInterpolatedIndex,mEventTimes,mXCoordinates,mYCoordinates,mPointTypes);
  if (strokeId != mCurrentStrokeId) {
    final int elapsedTime=(int)(downTime - mCurrentTimeBase);
    for (int i=mTrailStartIndex; i < trailSize; i++) {
      eventTimes[i]-=elapsedTime;
    }
    final int[] xCoords=mXCoordinates.getPrimitiveArray();
    final int downIndex=trailSize;
    xCoords[downIndex]=markAsDownEvent(xCoords[downIndex]);
    mCurrentTimeBase=downTime - eventTimes[downIndex];
    mCurrentStrokeId=strokeId;
  }
}",0.994535519125683
87668,"private static double degreeToRadian(final int degree){
  return (double)degree / 180.0d * Math.PI;
}","private static double degreeToRadian(final int degree){
  return degree / 180.0d * Math.PI;
}",0.9587628865979382
87669,"public void appendPreviewStroke(final ResizableIntArray eventTimes,final ResizableIntArray xCoords,final ResizableIntArray yCoords){
  final int length=mPreviewEventTimes.getLength() - mLastPreviewSize;
  if (length <= 0) {
    return;
  }
  eventTimes.append(mPreviewEventTimes,mLastPreviewSize,length);
  xCoords.append(mPreviewXCoordinates,mLastPreviewSize,length);
  yCoords.append(mPreviewYCoordinates,mLastPreviewSize,length);
  mLastPreviewSize=mPreviewEventTimes.getLength();
}","/** 
 * Append sampled preview points.
 * @param eventTimes the event time array of gesture trail to be drawn.
 * @param xCoords the x-coordinates array of gesture trail to be drawn.
 * @param yCoords the y-coordinates array of gesture trail to be drawn.
 * @param types the point types array of gesture trail. This is valid only when{@link GestureTrail#DEBUG_SHOW_POINTS} is true.
 */
public void appendPreviewStroke(final ResizableIntArray eventTimes,final ResizableIntArray xCoords,final ResizableIntArray yCoords,final ResizableIntArray types){
  final int length=mPreviewEventTimes.getLength() - mLastPreviewSize;
  if (length <= 0) {
    return;
  }
  eventTimes.append(mPreviewEventTimes,mLastPreviewSize,length);
  xCoords.append(mPreviewXCoordinates,mLastPreviewSize,length);
  yCoords.append(mPreviewYCoordinates,mLastPreviewSize,length);
  if (GestureTrail.DEBUG_SHOW_POINTS) {
    types.fill(GestureTrail.POINT_TYPE_SAMPLED,types.getLength(),length);
  }
  mLastPreviewSize=mPreviewEventTimes.getLength();
}",0.6449468085106383
87670,"/** 
 * Calculate interpolated points between the last interpolated point and the end of the trail. And return the start index of the last interpolated segment of input arrays because it may need to recalculate the interpolated points in the segment if further segments are added to this stroke.
 * @param lastInterpolatedIndex the start index of the last interpolated segment of<code>eventTimes</code>, <code>xCoords</code>, and <code>yCoords</code>.
 * @param eventTimes the event time array of gesture trail to be drawn.
 * @param xCoords the x-coordinates array of gesture trail to be drawn.
 * @param yCoords the y-coordinates array of gesture trail to be drawn.
 * @return the start index of the last interpolated segment of input arrays.
 */
public int interpolateStrokeAndReturnStartIndexOfLastSegment(final int lastInterpolatedIndex,final ResizableIntArray eventTimes,final ResizableIntArray xCoords,final ResizableIntArray yCoords,final ResizableIntArray types){
  final int size=mPreviewEventTimes.getLength();
  final int[] pt=mPreviewEventTimes.getPrimitiveArray();
  final int[] px=mPreviewXCoordinates.getPrimitiveArray();
  final int[] py=mPreviewYCoordinates.getPrimitiveArray();
  mInterpolator.reset(px,py,0,size);
  int lastInterpolatedDrawIndex=lastInterpolatedIndex;
  int d1=lastInterpolatedIndex;
  for (int p2=mLastInterpolatedPreviewIndex + 1; p2 < size; p2++) {
    final int p1=p2 - 1;
    final int p0=p1 - 1;
    final int p3=p2 + 1;
    mLastInterpolatedPreviewIndex=p1;
    lastInterpolatedDrawIndex=d1;
    mInterpolator.setInterval(p0,p1,p2,p3);
    final double m1=Math.atan2(mInterpolator.mSlope1Y,mInterpolator.mSlope1X);
    final double m2=Math.atan2(mInterpolator.mSlope2Y,mInterpolator.mSlope2X);
    final double deltaAngle=Math.abs(angularDiff(m2,m1));
    final int segmentsByAngle=(int)Math.ceil(deltaAngle / mPreviewParams.mMaxInterpolationAngularThreshold);
    final double deltaDistance=Math.hypot(mInterpolator.mP1X - mInterpolator.mP2X,mInterpolator.mP1Y - mInterpolator.mP2Y);
    final int segmentsByDistance=(int)Math.ceil(deltaDistance / mPreviewParams.mMaxInterpolationDistanceThreshold);
    final int segments=Math.min(mPreviewParams.mMaxInterpolationSegments,Math.max(segmentsByAngle,segmentsByDistance));
    final int t1=eventTimes.get(d1);
    final int dt=pt[p2] - pt[p1];
    d1++;
    for (int i=1; i < segments; i++) {
      final float t=i / (float)segments;
      mInterpolator.interpolate(t);
      eventTimes.add(d1,(int)(dt * t) + t1);
      xCoords.add(d1,(int)mInterpolator.mInterpolatedX);
      yCoords.add(d1,(int)mInterpolator.mInterpolatedY);
      if (GestureTrail.DBG_SHOW_POINTS) {
        types.add(d1,GestureTrail.POINT_TYPE_INTERPOLATED);
      }
      d1++;
    }
    eventTimes.add(d1,pt[p2]);
    xCoords.add(d1,px[p2]);
    yCoords.add(d1,py[p2]);
    if (GestureTrail.DBG_SHOW_POINTS) {
      types.add(d1,GestureTrail.POINT_TYPE_SAMPLED);
    }
  }
  return lastInterpolatedDrawIndex;
}","/** 
 * Calculate interpolated points between the last interpolated point and the end of the trail. And return the start index of the last interpolated segment of input arrays because it may need to recalculate the interpolated points in the segment if further segments are added to this stroke.
 * @param lastInterpolatedIndex the start index of the last interpolated segment of<code>eventTimes</code>, <code>xCoords</code>, and <code>yCoords</code>.
 * @param eventTimes the event time array of gesture trail to be drawn.
 * @param xCoords the x-coordinates array of gesture trail to be drawn.
 * @param yCoords the y-coordinates array of gesture trail to be drawn.
 * @param types the point types array of gesture trail. This is valid only when{@link GestureTrail#DEBUG_SHOW_POINTS} is true.
 * @return the start index of the last interpolated segment of input arrays.
 */
public int interpolateStrokeAndReturnStartIndexOfLastSegment(final int lastInterpolatedIndex,final ResizableIntArray eventTimes,final ResizableIntArray xCoords,final ResizableIntArray yCoords,final ResizableIntArray types){
  final int size=mPreviewEventTimes.getLength();
  final int[] pt=mPreviewEventTimes.getPrimitiveArray();
  final int[] px=mPreviewXCoordinates.getPrimitiveArray();
  final int[] py=mPreviewYCoordinates.getPrimitiveArray();
  mInterpolator.reset(px,py,0,size);
  int lastInterpolatedDrawIndex=lastInterpolatedIndex;
  int d1=lastInterpolatedIndex;
  for (int p2=mLastInterpolatedPreviewIndex + 1; p2 < size; p2++) {
    final int p1=p2 - 1;
    final int p0=p1 - 1;
    final int p3=p2 + 1;
    mLastInterpolatedPreviewIndex=p1;
    lastInterpolatedDrawIndex=d1;
    mInterpolator.setInterval(p0,p1,p2,p3);
    final double m1=Math.atan2(mInterpolator.mSlope1Y,mInterpolator.mSlope1X);
    final double m2=Math.atan2(mInterpolator.mSlope2Y,mInterpolator.mSlope2X);
    final double deltaAngle=Math.abs(angularDiff(m2,m1));
    final int segmentsByAngle=(int)Math.ceil(deltaAngle / mPreviewParams.mMaxInterpolationAngularThreshold);
    final double deltaDistance=Math.hypot(mInterpolator.mP1X - mInterpolator.mP2X,mInterpolator.mP1Y - mInterpolator.mP2Y);
    final int segmentsByDistance=(int)Math.ceil(deltaDistance / mPreviewParams.mMaxInterpolationDistanceThreshold);
    final int segments=Math.min(mPreviewParams.mMaxInterpolationSegments,Math.max(segmentsByAngle,segmentsByDistance));
    final int t1=eventTimes.get(d1);
    final int dt=pt[p2] - pt[p1];
    d1++;
    for (int i=1; i < segments; i++) {
      final float t=i / (float)segments;
      mInterpolator.interpolate(t);
      eventTimes.add(d1,(int)(dt * t) + t1);
      xCoords.add(d1,(int)mInterpolator.mInterpolatedX);
      yCoords.add(d1,(int)mInterpolator.mInterpolatedY);
      if (GestureTrail.DEBUG_SHOW_POINTS) {
        types.add(d1,GestureTrail.POINT_TYPE_INTERPOLATED);
      }
      d1++;
    }
    eventTimes.add(d1,pt[p2]);
    xCoords.add(d1,px[p2]);
    yCoords.add(d1,py[p2]);
    if (GestureTrail.DEBUG_SHOW_POINTS) {
      types.add(d1,GestureTrail.POINT_TYPE_SAMPLED);
    }
  }
  return lastInterpolatedDrawIndex;
}",0.9784645734012822
87671,"private boolean drawGestureTrailLocked(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  outBoundsRect.setEmpty();
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int[] pointTypes=mPointTypes.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine roundedLine=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    final int lastTime=sinceDown - eventTimes[startIndex];
    float r1=getWidth(lastTime,params) / 2.0f;
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float r2=getWidth(elapsedTime,params) / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final float body1=r1 * params.mTrailBodyRatio;
        final float body2=r2 * params.mTrailBodyRatio;
        final Path path=roundedLine.makePath(p1x,p1y,body1,p2x,p2y,body2);
        if (path != null) {
          roundedLine.getBounds(mRoundedLineBounds);
          if (params.mTrailShadowEnabled) {
            final float shadow2=r2 * params.mTrailShadowRatio;
            paint.setShadowLayer(shadow2,0.0f,0.0f,params.mTrailColor);
            final int shadowInset=-(int)Math.ceil(shadow2);
            mRoundedLineBounds.inset(shadowInset,shadowInset);
          }
          outBoundsRect.union(mRoundedLineBounds);
          final int alpha=getAlpha(elapsedTime,params);
          paint.setAlpha(alpha);
          canvas.drawPath(path,paint);
          if (DBG_SHOW_POINTS) {
            if (pointTypes[i] == POINT_TYPE_INTERPOLATED) {
              paint.setColor(Color.RED);
            }
 else             if (pointTypes[i] == POINT_TYPE_SAMPLED) {
              paint.setColor(0xFFA000FF);
            }
 else {
              paint.setColor(Color.GREEN);
            }
            canvas.drawCircle(p1x - 1,p1y - 1,2,paint);
            paint.setColor(params.mTrailColor);
          }
        }
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
    }
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
    if (DBG_SHOW_POINTS) {
      mPointTypes.setLength(newSize);
    }
    mLastInterpolatedDrawIndex=Math.max(mLastInterpolatedDrawIndex - startIndex,0);
  }
  return newSize > 0;
}","private boolean drawGestureTrailLocked(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  outBoundsRect.setEmpty();
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int[] pointTypes=mPointTypes.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine roundedLine=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    final int lastTime=sinceDown - eventTimes[startIndex];
    float r1=getWidth(lastTime,params) / 2.0f;
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float r2=getWidth(elapsedTime,params) / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final float body1=r1 * params.mTrailBodyRatio;
        final float body2=r2 * params.mTrailBodyRatio;
        final Path path=roundedLine.makePath(p1x,p1y,body1,p2x,p2y,body2);
        if (path != null) {
          roundedLine.getBounds(mRoundedLineBounds);
          if (params.mTrailShadowEnabled) {
            final float shadow2=r2 * params.mTrailShadowRatio;
            paint.setShadowLayer(shadow2,0.0f,0.0f,params.mTrailColor);
            final int shadowInset=-(int)Math.ceil(shadow2);
            mRoundedLineBounds.inset(shadowInset,shadowInset);
          }
          outBoundsRect.union(mRoundedLineBounds);
          final int alpha=getAlpha(elapsedTime,params);
          paint.setAlpha(alpha);
          canvas.drawPath(path,paint);
        }
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
    }
    if (DEBUG_SHOW_POINTS) {
      debugDrawPoints(canvas,startIndex,trailSize,paint);
    }
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
      if (DEBUG_SHOW_POINTS) {
        System.arraycopy(pointTypes,startIndex,pointTypes,0,newSize);
      }
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
    if (DEBUG_SHOW_POINTS) {
      mPointTypes.setLength(newSize);
    }
    mLastInterpolatedDrawIndex=Math.max(mLastInterpolatedDrawIndex - startIndex,0);
  }
  return newSize > 0;
}",0.7526413921690491
87672,"public Params(final TypedArray mainKeyboardViewAttr){
  mTrailColor=mainKeyboardViewAttr.getColor(R.styleable.MainKeyboardView_gestureTrailColor,0);
  mTrailStartWidth=mainKeyboardViewAttr.getDimension(R.styleable.MainKeyboardView_gestureTrailStartWidth,0.0f);
  mTrailEndWidth=mainKeyboardViewAttr.getDimension(R.styleable.MainKeyboardView_gestureTrailEndWidth,0.0f);
  final int PERCENTAGE_INT=100;
  mTrailBodyRatio=(float)mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailBodyRatio,PERCENTAGE_INT) / (float)PERCENTAGE_INT;
  final int trailShadowRatioInt=mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailShadowRatio,0);
  mTrailShadowEnabled=(trailShadowRatioInt > 0);
  mTrailShadowRatio=(float)trailShadowRatioInt / (float)PERCENTAGE_INT;
  mFadeoutStartDelay=DBG_SHOW_POINTS ? 2000 : mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailFadeoutStartDelay,0);
  mFadeoutDuration=DBG_SHOW_POINTS ? 200 : mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailFadeoutDuration,0);
  mTrailLingerDuration=mFadeoutStartDelay + mFadeoutDuration;
  mUpdateInterval=mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailUpdateInterval,0);
}","public Params(final TypedArray mainKeyboardViewAttr){
  mTrailColor=mainKeyboardViewAttr.getColor(R.styleable.MainKeyboardView_gestureTrailColor,0);
  mTrailStartWidth=mainKeyboardViewAttr.getDimension(R.styleable.MainKeyboardView_gestureTrailStartWidth,0.0f);
  mTrailEndWidth=mainKeyboardViewAttr.getDimension(R.styleable.MainKeyboardView_gestureTrailEndWidth,0.0f);
  final int PERCENTAGE_INT=100;
  mTrailBodyRatio=(float)mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailBodyRatio,PERCENTAGE_INT) / (float)PERCENTAGE_INT;
  final int trailShadowRatioInt=mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailShadowRatio,0);
  mTrailShadowEnabled=(trailShadowRatioInt > 0);
  mTrailShadowRatio=(float)trailShadowRatioInt / (float)PERCENTAGE_INT;
  mFadeoutStartDelay=DEBUG_SHOW_POINTS ? FADEOUT_START_DELAY_FOR_DEBUG : mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailFadeoutStartDelay,0);
  mFadeoutDuration=DEBUG_SHOW_POINTS ? FADEOUT_DURATION_FOR_DEBUG : mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailFadeoutDuration,0);
  mTrailLingerDuration=mFadeoutStartDelay + mFadeoutDuration;
  mUpdateInterval=mainKeyboardViewAttr.getInt(R.styleable.MainKeyboardView_gestureTrailUpdateInterval,0);
}",0.9735576923076924
87673,"private void addStrokeLocked(final GestureStrokeWithPreviewPoints stroke,final long downTime){
  final int trailSize=mEventTimes.getLength();
  stroke.appendPreviewStroke(mEventTimes,mXCoordinates,mYCoordinates);
  if (mEventTimes.getLength() == trailSize) {
    return;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int strokeId=stroke.getGestureStrokeId();
  final int lastInterpolatedIndex=(strokeId == mCurrentStrokeId) ? mLastInterpolatedDrawIndex : trailSize;
  mLastInterpolatedDrawIndex=stroke.interpolateStrokeAndReturnStartIndexOfLastSegment(lastInterpolatedIndex,mEventTimes,mXCoordinates,mYCoordinates,mPointTypes);
  if (strokeId != mCurrentStrokeId) {
    final int elapsedTime=(int)(downTime - mCurrentTimeBase);
    for (int i=mTrailStartIndex; i < trailSize; i++) {
      eventTimes[i]-=elapsedTime;
    }
    final int[] xCoords=mXCoordinates.getPrimitiveArray();
    final int downIndex=trailSize;
    xCoords[downIndex]=markAsDownEvent(xCoords[downIndex]);
    mCurrentTimeBase=downTime - eventTimes[downIndex];
    mCurrentStrokeId=strokeId;
  }
}","private void addStrokeLocked(final GestureStrokeWithPreviewPoints stroke,final long downTime){
  final int trailSize=mEventTimes.getLength();
  stroke.appendPreviewStroke(mEventTimes,mXCoordinates,mYCoordinates,mPointTypes);
  if (mEventTimes.getLength() == trailSize) {
    return;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int strokeId=stroke.getGestureStrokeId();
  final int lastInterpolatedIndex=(strokeId == mCurrentStrokeId) ? mLastInterpolatedDrawIndex : trailSize;
  mLastInterpolatedDrawIndex=stroke.interpolateStrokeAndReturnStartIndexOfLastSegment(lastInterpolatedIndex,mEventTimes,mXCoordinates,mYCoordinates,mPointTypes);
  if (strokeId != mCurrentStrokeId) {
    final int elapsedTime=(int)(downTime - mCurrentTimeBase);
    for (int i=mTrailStartIndex; i < trailSize; i++) {
      eventTimes[i]-=elapsedTime;
    }
    final int[] xCoords=mXCoordinates.getPrimitiveArray();
    final int downIndex=trailSize;
    xCoords[downIndex]=markAsDownEvent(xCoords[downIndex]);
    mCurrentTimeBase=downTime - eventTimes[downIndex];
    mCurrentStrokeId=strokeId;
  }
}",0.994535519125683
87674,"@Override protected void onPause(){
  mWelcomeVideoView.stopPlayback();
  super.onPause();
}","@Override protected void onPause(){
  hideAndStopVideo(mWelcomeVideoView);
  super.onPause();
}",0.8342245989304813
87675,"private void updateSetupStepView(){
  final boolean welcomeScreen=(mStepNumber == STEP_WELCOME);
  mWelcomeScreen.setVisibility(welcomeScreen ? View.VISIBLE : View.GONE);
  mSetupScreen.setVisibility(welcomeScreen ? View.GONE : View.VISIBLE);
  if (welcomeScreen) {
    mWelcomeVideoView.setVideoURI(mWelcomeVideoUri);
    mWelcomeVideoView.start();
    return;
  }
  mWelcomeVideoView.stopPlayback();
  final boolean isStepActionAlreadyDone=mStepNumber < determineSetupStepNumber();
  mSetupStepGroup.enableStep(mStepNumber,isStepActionAlreadyDone);
  mActionNext.setVisibility(isStepActionAlreadyDone ? View.VISIBLE : View.GONE);
  mActionFinish.setVisibility((mStepNumber == STEP_3) ? View.VISIBLE : View.GONE);
}","private void updateSetupStepView(){
  final boolean welcomeScreen=(mStepNumber == STEP_WELCOME);
  mWelcomeScreen.setVisibility(welcomeScreen ? View.VISIBLE : View.GONE);
  mSetupScreen.setVisibility(welcomeScreen ? View.GONE : View.VISIBLE);
  if (welcomeScreen) {
    mWelcomeVideoView.setVisibility(View.VISIBLE);
    mWelcomeVideoView.setVideoURI(mWelcomeVideoUri);
    mWelcomeVideoView.start();
    return;
  }
  hideAndStopVideo(mWelcomeVideoView);
  final boolean isStepActionAlreadyDone=mStepNumber < determineSetupStepNumber();
  mSetupStepGroup.enableStep(mStepNumber,isStepActionAlreadyDone);
  mActionNext.setVisibility(isStepActionAlreadyDone ? View.VISIBLE : View.GONE);
  mActionFinish.setVisibility((mStepNumber == STEP_3) ? View.VISIBLE : View.GONE);
}",0.9448183041722744
87676,"@Override protected void onCreate(final Bundle savedInstanceState){
  setTheme(android.R.style.Theme_DeviceDefault_Light_NoActionBar);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.setup_wizard);
  RichInputMethodManager.init(this);
  if (savedInstanceState == null) {
    mStepNumber=determineSetupStepNumber();
    if (mStepNumber == STEP_1 && !mWasLanguageAndInputSettingsInvoked) {
      mStepNumber=STEP_WELCOME;
    }
    if (mStepNumber == STEP_3) {
      invokeSettingsOfThisIme();
      finish();
      return;
    }
  }
 else {
    mStepNumber=savedInstanceState.getInt(STATE_STEP);
  }
  final String applicationName=getResources().getString(getApplicationInfo().labelRes);
  mWelcomeScreen=findViewById(R.id.setup_welcome_screen);
  final TextView welcomeTitle=(TextView)findViewById(R.id.setup_welcome_title);
  welcomeTitle.setText(getString(R.string.setup_welcome_title,applicationName));
  mSetupScreen=findViewById(R.id.setup_steps_screen);
  final TextView stepsTitle=(TextView)findViewById(R.id.setup_title);
  stepsTitle.setText(getString(R.string.setup_steps_title,applicationName));
  final SetupStepIndicatorView indicatorView=(SetupStepIndicatorView)findViewById(R.id.setup_step_indicator);
  mSetupStepGroup=new SetupStepGroup(indicatorView);
  mStep1Bullet=(TextView)findViewById(R.id.setup_step1_bullet);
  mStep1Bullet.setOnClickListener(this);
  final SetupStep step1=new SetupStep(STEP_1,applicationName,mStep1Bullet,findViewById(R.id.setup_step1),R.string.setup_step1_title,R.string.setup_step1_instruction,R.string.setup_step1_finished_instruction,R.drawable.ic_setup_step1,R.string.setup_step1_action);
  step1.setAction(new Runnable(){
    @Override public void run(){
      invokeLanguageAndInputSettings();
      mHandler.startPollingImeSettings();
    }
  }
);
  mSetupStepGroup.addStep(step1);
  final SetupStep step2=new SetupStep(STEP_2,applicationName,(TextView)findViewById(R.id.setup_step2_bullet),findViewById(R.id.setup_step2),R.string.setup_step2_title,R.string.setup_step2_instruction,0,R.drawable.ic_setup_step2,R.string.setup_step2_action);
  step2.setAction(new Runnable(){
    @Override public void run(){
      RichInputMethodManager.getInstance().getInputMethodManager().showInputMethodPicker();
    }
  }
);
  mSetupStepGroup.addStep(step2);
  final SetupStep step3=new SetupStep(STEP_3,applicationName,(TextView)findViewById(R.id.setup_step3_bullet),findViewById(R.id.setup_step3),R.string.setup_step3_title,R.string.setup_step3_instruction,0,R.drawable.ic_setup_step3,R.string.setup_step3_action);
  step3.setAction(new Runnable(){
    @Override public void run(){
      invokeSubtypeEnablerOfThisIme();
    }
  }
);
  mSetupStepGroup.addStep(step3);
  mWelcomeVideoUri=new Uri.Builder().scheme(ContentResolver.SCHEME_ANDROID_RESOURCE).authority(getPackageName()).path(Integer.toString(R.raw.setup_welcome_video)).build();
  mWelcomeVideoView=(VideoView)findViewById(R.id.setup_welcome_video);
  mWelcomeVideoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener(){
    @Override public void onCompletion(    final MediaPlayer mp){
      mp.start();
    }
  }
);
  mWelcomeVideoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener(){
    @Override public void onPrepared(    final MediaPlayer mp){
      mWelcomeVideoView.setBackgroundResource(0);
    }
  }
);
  final ImageView welcomeImageView=(ImageView)findViewById(R.id.setup_welcome_image);
  mWelcomeVideoView.setOnErrorListener(new MediaPlayer.OnErrorListener(){
    @Override public boolean onError(    final MediaPlayer mp,    final int what,    final int extra){
      Log.e(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ extra);
      mWelcomeVideoView.setVisibility(View.GONE);
      welcomeImageView.setImageResource(R.raw.setup_welcome_image);
      welcomeImageView.setVisibility(View.VISIBLE);
      return true;
    }
  }
);
  mActionStart=findViewById(R.id.setup_start_label);
  mActionStart.setOnClickListener(this);
  mActionNext=findViewById(R.id.setup_next);
  mActionNext.setOnClickListener(this);
  mActionFinish=(TextView)findViewById(R.id.setup_finish);
  TextViewCompatUtils.setCompoundDrawablesRelativeWithIntrinsicBounds(mActionFinish,getResources().getDrawable(R.drawable.ic_setup_finish),null,null,null);
  mActionFinish.setOnClickListener(this);
}","@Override protected void onCreate(final Bundle savedInstanceState){
  setTheme(android.R.style.Theme_DeviceDefault_Light_NoActionBar);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.setup_wizard);
  RichInputMethodManager.init(this);
  if (savedInstanceState == null) {
    mStepNumber=determineSetupStepNumber();
    if (mStepNumber == STEP_1 && !mWasLanguageAndInputSettingsInvoked) {
      mStepNumber=STEP_WELCOME;
    }
    if (mStepNumber == STEP_3) {
      invokeSettingsOfThisIme();
      finish();
      return;
    }
  }
 else {
    mStepNumber=savedInstanceState.getInt(STATE_STEP);
  }
  final String applicationName=getResources().getString(getApplicationInfo().labelRes);
  mWelcomeScreen=findViewById(R.id.setup_welcome_screen);
  final TextView welcomeTitle=(TextView)findViewById(R.id.setup_welcome_title);
  welcomeTitle.setText(getString(R.string.setup_welcome_title,applicationName));
  mSetupScreen=findViewById(R.id.setup_steps_screen);
  final TextView stepsTitle=(TextView)findViewById(R.id.setup_title);
  stepsTitle.setText(getString(R.string.setup_steps_title,applicationName));
  final SetupStepIndicatorView indicatorView=(SetupStepIndicatorView)findViewById(R.id.setup_step_indicator);
  mSetupStepGroup=new SetupStepGroup(indicatorView);
  mStep1Bullet=(TextView)findViewById(R.id.setup_step1_bullet);
  mStep1Bullet.setOnClickListener(this);
  final SetupStep step1=new SetupStep(STEP_1,applicationName,mStep1Bullet,findViewById(R.id.setup_step1),R.string.setup_step1_title,R.string.setup_step1_instruction,R.string.setup_step1_finished_instruction,R.drawable.ic_setup_step1,R.string.setup_step1_action);
  step1.setAction(new Runnable(){
    @Override public void run(){
      invokeLanguageAndInputSettings();
      mHandler.startPollingImeSettings();
    }
  }
);
  mSetupStepGroup.addStep(step1);
  final SetupStep step2=new SetupStep(STEP_2,applicationName,(TextView)findViewById(R.id.setup_step2_bullet),findViewById(R.id.setup_step2),R.string.setup_step2_title,R.string.setup_step2_instruction,0,R.drawable.ic_setup_step2,R.string.setup_step2_action);
  step2.setAction(new Runnable(){
    @Override public void run(){
      RichInputMethodManager.getInstance().getInputMethodManager().showInputMethodPicker();
    }
  }
);
  mSetupStepGroup.addStep(step2);
  final SetupStep step3=new SetupStep(STEP_3,applicationName,(TextView)findViewById(R.id.setup_step3_bullet),findViewById(R.id.setup_step3),R.string.setup_step3_title,R.string.setup_step3_instruction,0,R.drawable.ic_setup_step3,R.string.setup_step3_action);
  step3.setAction(new Runnable(){
    @Override public void run(){
      invokeSubtypeEnablerOfThisIme();
    }
  }
);
  mSetupStepGroup.addStep(step3);
  mWelcomeVideoUri=new Uri.Builder().scheme(ContentResolver.SCHEME_ANDROID_RESOURCE).authority(getPackageName()).path(Integer.toString(R.raw.setup_welcome_video)).build();
  mWelcomeVideoView=(VideoView)findViewById(R.id.setup_welcome_video);
  mWelcomeVideoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener(){
    @Override public void onPrepared(    final MediaPlayer mp){
      mWelcomeVideoView.setBackgroundResource(0);
      mp.setLooping(true);
    }
  }
);
  final ImageView welcomeImageView=(ImageView)findViewById(R.id.setup_welcome_image);
  mWelcomeVideoView.setOnErrorListener(new MediaPlayer.OnErrorListener(){
    @Override public boolean onError(    final MediaPlayer mp,    final int what,    final int extra){
      Log.e(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ extra);
      mWelcomeVideoView.setVisibility(View.GONE);
      welcomeImageView.setImageResource(R.raw.setup_welcome_image);
      welcomeImageView.setVisibility(View.VISIBLE);
      return true;
    }
  }
);
  mActionStart=findViewById(R.id.setup_start_label);
  mActionStart.setOnClickListener(this);
  mActionNext=findViewById(R.id.setup_next);
  mActionNext.setOnClickListener(this);
  mActionFinish=(TextView)findViewById(R.id.setup_finish);
  TextViewCompatUtils.setCompoundDrawablesRelativeWithIntrinsicBounds(mActionFinish,getResources().getDrawable(R.drawable.ic_setup_finish),null,null,null);
  mActionFinish.setOnClickListener(this);
}",0.9654199011997178
87677,"@Override public void onPrepared(final MediaPlayer mp){
  mWelcomeVideoView.setBackgroundResource(0);
}","@Override public void onPrepared(final MediaPlayer mp){
  mWelcomeVideoView.setBackgroundResource(0);
  mp.setLooping(true);
}",0.8995633187772926
87678,"/** 
 * Remove LogUnits from the front of the LogBuffer until   {@code numWords} have been removed.If there are less than  {@code numWords} word-containing {@link LogUnit}s, shifts out all   {@code LogUnit}s in the buffer.
 * @param numWords the minimum number of word-containing {@link LogUnit}s to shift out
 * @return the number of actual {@code LogUnit}s shifted out
 */
protected int shiftOutWords(final int numWords){
  int numWordContainingLogUnitsShiftedOut=0;
  for (LogUnit logUnit=shiftOut(); logUnit != null && numWordContainingLogUnitsShiftedOut < numWords; logUnit=shiftOut()) {
    if (logUnit.hasOneOrMoreWords()) {
      numWordContainingLogUnitsShiftedOut+=logUnit.getNumWords();
    }
  }
  return numWordContainingLogUnitsShiftedOut;
}","/** 
 * Remove LogUnits from the front of the LogBuffer until   {@code numWords} have been removed.If there are less than  {@code numWords} in the buffer, shifts out all {@code LogUnit}s.
 * @param numWords the minimum number of words in {@link LogUnit}s to shift out
 * @return the number of actual words LogUnit}s shifted out
 */
protected int shiftOutWords(final int numWords){
  int numWordsShiftedOut=0;
  do {
    final LogUnit logUnit=shiftOut();
    if (logUnit == null)     break;
    numWordsShiftedOut+=logUnit.getNumWords();
  }
 while (numWordsShiftedOut < numWords);
  return numWordsShiftedOut;
}",0.6734992679355783
87679,"@Override protected int shiftOutWords(final int numWords){
  final int numWordContainingLogUnitsShiftedOut=super.shiftOutWords(numWords);
  mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWordContainingLogUnitsShiftedOut);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
  return numWordContainingLogUnitsShiftedOut;
}","@Override protected int shiftOutWords(final int numWords){
  final int numWordsShiftedOut=super.shiftOutWords(numWords);
  mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWordsShiftedOut);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
  return numWordsShiftedOut;
}",0.926829268292683
87680,"protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    mNumWordsUntilSafeToSample=mNumWordsBetweenNGrams;
  }
 else {
    logUnits.clear();
    for (LogUnit logUnit=shiftOut(); logUnit != null && !logUnit.hasOneOrMoreWords(); logUnit=shiftOut()) {
      logUnits.add(logUnit);
    }
    publish(logUnits,false);
  }
}","protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    mNumWordsUntilSafeToSample=mNumWordsBetweenNGrams;
    return;
  }
  logUnits.clear();
  LogUnit logUnit=shiftOut();
  while (logUnit != null) {
    logUnits.add(logUnit);
    final int numWords=logUnit.getNumWords();
    if (numWords > 0) {
      mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWords);
      break;
    }
    logUnit=shiftOut();
  }
  publish(logUnits,false);
}",0.6786678667866787
87681,"protected void shiftOutWords(final int numWords){
  final int targetNumWords=mNumActualWords - numWords;
  final LinkedList<LogUnit> logUnits=getLogUnits();
  while (mNumActualWords > targetNumWords && !logUnits.isEmpty()) {
    shiftOut();
  }
}","/** 
 * Remove LogUnits from the front of the LogBuffer until   {@code numWords} have been removed.If there are less than  {@code numWords} word-containing {@link LogUnit}s, shifts out all   {@code LogUnit}s in the buffer.
 * @param numWords the number of word-containing {@link LogUnit}s to shift out
 * @return the number of actual {@code LogUnit}s shifted out
 */
protected int shiftOutWords(final int numWords){
  int numWordContainingLogUnitsShiftedOut=0;
  for (LogUnit logUnit=shiftOut(); logUnit != null && numWordContainingLogUnitsShiftedOut < numWords; logUnit=shiftOut()) {
    if (logUnit.hasWord()) {
      numWordContainingLogUnitsShiftedOut++;
    }
  }
  return numWordContainingLogUnitsShiftedOut;
}",0.1455301455301455
87682,"@Override protected void shiftOutWords(final int numWords){
  final int oldNumActualWords=getNumActualWords();
  super.shiftOutWords(numWords);
  final int numWordsShifted=oldNumActualWords - getNumActualWords();
  mNumWordsUntilSafeToSample-=numWordsShifted;
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
}","@Override protected int shiftOutWords(final int numWords){
  final int numWordContainingLogUnitsShiftedOut=super.shiftOutWords(numWords);
  mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWordContainingLogUnitsShiftedOut);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
  return numWordContainingLogUnitsShiftedOut;
}",0.4546722454672245
87683,"protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    resetWordCounter();
  }
 else {
    logUnits=peekAtFirstNWords(1);
    publish(logUnits,false);
    shiftOutWords(1);
  }
}","protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    mNumWordsUntilSafeToSample=mNumWordsBetweenNGrams;
  }
 else {
    logUnits=peekAtFirstNWords(1);
    publish(logUnits,false);
    shiftOutWords(1);
  }
}",0.9075862068965516
87684,"/** 
 * Waits for publication requests to finish, closes the JsonWriter, but then deletes the backing output file.
 * @param onAbort run after the abort() operation has completed asynchronously
 */
private synchronized void abort(final Runnable onAbort){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (mHasWrittenData) {
          mJsonWriter.endArray();
          mJsonWriter.close();
          mHasWrittenData=false;
        }
      }
  finally {
        if (mFile != null) {
          mFile.delete();
        }
        if (onAbort != null) {
          onAbort.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}","/** 
 * Waits for publication requests to finish, closes the JsonWriter, but then deletes the backing output file.
 * @param onAbort run after the abort() operation has completed asynchronously
 */
private synchronized void abort(final Runnable onAbort){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (mHasWrittenData) {
          if (!mHasWrittenData) {
            mJsonWriter.beginArray();
          }
          mJsonWriter.endArray();
          mJsonWriter.close();
          mHasWrittenData=false;
        }
      }
  finally {
        if (mFile != null) {
          mFile.delete();
        }
        if (onAbort != null) {
          onAbort.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}",0.9468354430379748
87685,"/** 
 * Waits for any publication requests to finish and closes the   {@link JsonWriter} used foroutput. See class comment for details about  {@code JsonWriter} construction.
 * @param onClosed run after the close() operation has completed asynchronously
 */
private synchronized void close(final Runnable onClosed){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (mHasWrittenData) {
          mJsonWriter.endArray();
          mHasWrittenData=false;
        }
        mJsonWriter.flush();
        mJsonWriter.close();
        if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mFile);
        }
      }
 catch (      Exception e) {
        Log.d(TAG,""String_Node_Str"",e);
      }
 finally {
        if (mFile != null && mFile.exists()) {
          mFile.setWritable(false,false);
        }
        if (onClosed != null) {
          onClosed.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}","/** 
 * Waits for any publication requests to finish and closes the   {@link JsonWriter} used foroutput. See class comment for details about  {@code JsonWriter} construction.
 * @param onClosed run after the close() operation has completed asynchronously
 */
private synchronized void close(final Runnable onClosed){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (!mHasWrittenData) {
          mJsonWriter.beginArray();
        }
        mJsonWriter.endArray();
        mHasWrittenData=false;
        mJsonWriter.flush();
        mJsonWriter.close();
        if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mFile);
        }
      }
 catch (      Exception e) {
        Log.d(TAG,""String_Node_Str"",e);
      }
 finally {
        if (mFile != null && mFile.exists()) {
          mFile.setWritable(false,false);
        }
        if (onClosed != null) {
          onClosed.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}",0.9717568214456678
87686,"/** 
 * Arrange for the UploaderService to be run on a regular basis. Any existing scheduled invocation of UploaderService is removed and optionally rescheduled. This may cause problems if this method is called so often that no scheduled invocation is ever run.  But if the delay is short enough that it will go off when the user is sleeping, then there should be no starvation.
 * @param context {@link Context} object
 * @param needsRescheduling whether to schedule a future intent to be delivered to this service
 */
public static void cancelAndRescheduleUploadingService(final Context context,final boolean needsRescheduling){
  final PendingIntent pendingIntent=getPendingIntentForService(context);
  final AlarmManager alarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  cancelAnyScheduledServiceAlarm(alarmManager,pendingIntent);
  if (needsRescheduling) {
    scheduleServiceAlarm(alarmManager,pendingIntent);
  }
}","/** 
 * Arrange for the UploaderService to be run on a regular basis. Any existing scheduled invocation of UploaderService is removed and optionally rescheduled. This may cause problems if this method is called so often that no scheduled invocation is ever run.  But if the delay is short enough that it will go off when the user is sleeping, then there should be no starvation.
 * @param context {@link Context} object
 * @param needsRescheduling whether to schedule a future intent to be delivered to this service
 */
public static void cancelAndRescheduleUploadingService(final Context context,final boolean needsRescheduling){
  final Intent intent=new Intent(context,UploaderService.class);
  final PendingIntent pendingIntent=PendingIntent.getService(context,0,intent,0);
  final AlarmManager alarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  alarmManager.cancel(pendingIntent);
  if (needsRescheduling) {
    alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,SystemClock.elapsedRealtime() + UploaderService.RUN_INTERVAL,pendingIntent);
  }
}",0.8565795958600295
87687,"private boolean isDevTeamBuild(){
  try {
    final PackageInfo packageInfo;
    packageInfo=mLatinIME.getPackageManager().getPackageInfo(mLatinIME.getPackageName(),0);
    final String versionName=packageInfo.versionName;
    return !(developerBuildRegex.matcher(versionName).find());
  }
 catch (  final NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
}","private boolean isDevTeamBuild(){
  try {
    final PackageInfo packageInfo;
    packageInfo=mLatinIME.getPackageManager().getPackageInfo(mLatinIME.getPackageName(),0);
    final String versionName=packageInfo.versionName;
    return developerBuildRegex.matcher(versionName).find();
  }
 catch (  final NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
}",0.9961587708066582
87688,"/** 
 * Remove LogUnits from the front of the LogBuffer until   {@code numWords} have been removed.If there are less than  {@code numWords} word-containing {@link LogUnit}s, shifts out all   {@code LogUnit}s in the buffer.
 * @param numWords the minimum number of word-containing {@link LogUnit}s to shift out
 * @return the number of actual {@code LogUnit}s shifted out
 */
protected int shiftOutWords(final int numWords){
  int numWordContainingLogUnitsShiftedOut=0;
  for (LogUnit logUnit=shiftOut(); logUnit != null && numWordContainingLogUnitsShiftedOut < numWords; logUnit=shiftOut()) {
    if (logUnit.hasOneOrMoreWords()) {
      numWordContainingLogUnitsShiftedOut+=logUnit.getNumWords();
    }
  }
  return numWordContainingLogUnitsShiftedOut;
}","/** 
 * Remove LogUnits from the front of the LogBuffer until   {@code numWords} have been removed.If there are less than  {@code numWords} in the buffer, shifts out all {@code LogUnit}s.
 * @param numWords the minimum number of words in {@link LogUnit}s to shift out
 * @return the number of actual words LogUnit}s shifted out
 */
protected int shiftOutWords(final int numWords){
  int numWordsShiftedOut=0;
  do {
    final LogUnit logUnit=shiftOut();
    if (logUnit == null)     break;
    numWordsShiftedOut+=logUnit.getNumWords();
  }
 while (numWordsShiftedOut < numWords);
  return numWordsShiftedOut;
}",0.6734992679355783
87689,"@Override protected int shiftOutWords(final int numWords){
  final int numWordContainingLogUnitsShiftedOut=super.shiftOutWords(numWords);
  mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWordContainingLogUnitsShiftedOut);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
  return numWordContainingLogUnitsShiftedOut;
}","@Override protected int shiftOutWords(final int numWords){
  final int numWordsShiftedOut=super.shiftOutWords(numWords);
  mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWordsShiftedOut);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
  return numWordsShiftedOut;
}",0.926829268292683
87690,"protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    mNumWordsUntilSafeToSample=mNumWordsBetweenNGrams;
  }
 else {
    logUnits.clear();
    for (LogUnit logUnit=shiftOut(); logUnit != null && !logUnit.hasOneOrMoreWords(); logUnit=shiftOut()) {
      logUnits.add(logUnit);
    }
    publish(logUnits,false);
  }
}","protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    mNumWordsUntilSafeToSample=mNumWordsBetweenNGrams;
    return;
  }
  logUnits.clear();
  LogUnit logUnit=shiftOut();
  while (logUnit != null) {
    logUnits.add(logUnit);
    final int numWords=logUnit.getNumWords();
    if (numWords > 0) {
      mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWords);
      break;
    }
    logUnit=shiftOut();
  }
  publish(logUnits,false);
}",0.6786678667866787
87691,"@Override protected void onPause(){
  mWelcomeVideoView.stopPlayback();
  super.onPause();
}","@Override protected void onPause(){
  hideAndStopVideo(mWelcomeVideoView);
  super.onPause();
}",0.8342245989304813
87692,"private void updateSetupStepView(){
  final boolean welcomeScreen=(mStepNumber == STEP_WELCOME);
  mWelcomeScreen.setVisibility(welcomeScreen ? View.VISIBLE : View.GONE);
  mSetupScreen.setVisibility(welcomeScreen ? View.GONE : View.VISIBLE);
  if (welcomeScreen) {
    mWelcomeVideoView.setVideoURI(mWelcomeVideoUri);
    mWelcomeVideoView.start();
    return;
  }
  mWelcomeVideoView.stopPlayback();
  final boolean isStepActionAlreadyDone=mStepNumber < determineSetupStepNumber();
  mSetupStepGroup.enableStep(mStepNumber,isStepActionAlreadyDone);
  mActionNext.setVisibility(isStepActionAlreadyDone ? View.VISIBLE : View.GONE);
  mActionFinish.setVisibility((mStepNumber == STEP_3) ? View.VISIBLE : View.GONE);
}","private void updateSetupStepView(){
  final boolean welcomeScreen=(mStepNumber == STEP_WELCOME);
  mWelcomeScreen.setVisibility(welcomeScreen ? View.VISIBLE : View.GONE);
  mSetupScreen.setVisibility(welcomeScreen ? View.GONE : View.VISIBLE);
  if (welcomeScreen) {
    mWelcomeVideoView.setVisibility(View.VISIBLE);
    mWelcomeVideoView.setVideoURI(mWelcomeVideoUri);
    mWelcomeVideoView.start();
    return;
  }
  hideAndStopVideo(mWelcomeVideoView);
  final boolean isStepActionAlreadyDone=mStepNumber < determineSetupStepNumber();
  mSetupStepGroup.enableStep(mStepNumber,isStepActionAlreadyDone);
  mActionNext.setVisibility(isStepActionAlreadyDone ? View.VISIBLE : View.GONE);
  mActionFinish.setVisibility((mStepNumber == STEP_3) ? View.VISIBLE : View.GONE);
}",0.9448183041722744
87693,"@Override protected void onCreate(final Bundle savedInstanceState){
  setTheme(android.R.style.Theme_DeviceDefault_Light_NoActionBar);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.setup_wizard);
  RichInputMethodManager.init(this);
  if (savedInstanceState == null) {
    mStepNumber=determineSetupStepNumber();
    if (mStepNumber == STEP_1 && !mWasLanguageAndInputSettingsInvoked) {
      mStepNumber=STEP_WELCOME;
    }
    if (mStepNumber == STEP_3) {
      invokeSettingsOfThisIme();
      finish();
      return;
    }
  }
 else {
    mStepNumber=savedInstanceState.getInt(STATE_STEP);
  }
  final String applicationName=getResources().getString(getApplicationInfo().labelRes);
  mWelcomeScreen=findViewById(R.id.setup_welcome_screen);
  final TextView welcomeTitle=(TextView)findViewById(R.id.setup_welcome_title);
  welcomeTitle.setText(getString(R.string.setup_welcome_title,applicationName));
  mSetupScreen=findViewById(R.id.setup_steps_screen);
  final TextView stepsTitle=(TextView)findViewById(R.id.setup_title);
  stepsTitle.setText(getString(R.string.setup_steps_title,applicationName));
  final SetupStepIndicatorView indicatorView=(SetupStepIndicatorView)findViewById(R.id.setup_step_indicator);
  mSetupStepGroup=new SetupStepGroup(indicatorView);
  mStep1Bullet=(TextView)findViewById(R.id.setup_step1_bullet);
  mStep1Bullet.setOnClickListener(this);
  final SetupStep step1=new SetupStep(STEP_1,applicationName,mStep1Bullet,findViewById(R.id.setup_step1),R.string.setup_step1_title,R.string.setup_step1_instruction,R.string.setup_step1_finished_instruction,R.drawable.ic_setup_step1,R.string.setup_step1_action);
  step1.setAction(new Runnable(){
    @Override public void run(){
      invokeLanguageAndInputSettings();
      mHandler.startPollingImeSettings();
    }
  }
);
  mSetupStepGroup.addStep(step1);
  final SetupStep step2=new SetupStep(STEP_2,applicationName,(TextView)findViewById(R.id.setup_step2_bullet),findViewById(R.id.setup_step2),R.string.setup_step2_title,R.string.setup_step2_instruction,0,R.drawable.ic_setup_step2,R.string.setup_step2_action);
  step2.setAction(new Runnable(){
    @Override public void run(){
      RichInputMethodManager.getInstance().getInputMethodManager().showInputMethodPicker();
    }
  }
);
  mSetupStepGroup.addStep(step2);
  final SetupStep step3=new SetupStep(STEP_3,applicationName,(TextView)findViewById(R.id.setup_step3_bullet),findViewById(R.id.setup_step3),R.string.setup_step3_title,R.string.setup_step3_instruction,0,R.drawable.ic_setup_step3,R.string.setup_step3_action);
  step3.setAction(new Runnable(){
    @Override public void run(){
      invokeSubtypeEnablerOfThisIme();
    }
  }
);
  mSetupStepGroup.addStep(step3);
  mWelcomeVideoUri=new Uri.Builder().scheme(ContentResolver.SCHEME_ANDROID_RESOURCE).authority(getPackageName()).path(Integer.toString(R.raw.setup_welcome_video)).build();
  mWelcomeVideoView=(VideoView)findViewById(R.id.setup_welcome_video);
  mWelcomeVideoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener(){
    @Override public void onCompletion(    final MediaPlayer mp){
      mp.start();
    }
  }
);
  mWelcomeVideoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener(){
    @Override public void onPrepared(    final MediaPlayer mp){
      mWelcomeVideoView.setBackgroundResource(0);
    }
  }
);
  final ImageView welcomeImageView=(ImageView)findViewById(R.id.setup_welcome_image);
  mWelcomeVideoView.setOnErrorListener(new MediaPlayer.OnErrorListener(){
    @Override public boolean onError(    final MediaPlayer mp,    final int what,    final int extra){
      Log.e(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ extra);
      mWelcomeVideoView.setVisibility(View.GONE);
      welcomeImageView.setImageResource(R.raw.setup_welcome_image);
      welcomeImageView.setVisibility(View.VISIBLE);
      return true;
    }
  }
);
  mActionStart=findViewById(R.id.setup_start_label);
  mActionStart.setOnClickListener(this);
  mActionNext=findViewById(R.id.setup_next);
  mActionNext.setOnClickListener(this);
  mActionFinish=(TextView)findViewById(R.id.setup_finish);
  TextViewCompatUtils.setCompoundDrawablesRelativeWithIntrinsicBounds(mActionFinish,getResources().getDrawable(R.drawable.ic_setup_finish),null,null,null);
  mActionFinish.setOnClickListener(this);
}","@Override protected void onCreate(final Bundle savedInstanceState){
  setTheme(android.R.style.Theme_DeviceDefault_Light_NoActionBar);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.setup_wizard);
  RichInputMethodManager.init(this);
  if (savedInstanceState == null) {
    mStepNumber=determineSetupStepNumber();
    if (mStepNumber == STEP_1 && !mWasLanguageAndInputSettingsInvoked) {
      mStepNumber=STEP_WELCOME;
    }
    if (mStepNumber == STEP_3) {
      invokeSettingsOfThisIme();
      finish();
      return;
    }
  }
 else {
    mStepNumber=savedInstanceState.getInt(STATE_STEP);
  }
  final String applicationName=getResources().getString(getApplicationInfo().labelRes);
  mWelcomeScreen=findViewById(R.id.setup_welcome_screen);
  final TextView welcomeTitle=(TextView)findViewById(R.id.setup_welcome_title);
  welcomeTitle.setText(getString(R.string.setup_welcome_title,applicationName));
  mSetupScreen=findViewById(R.id.setup_steps_screen);
  final TextView stepsTitle=(TextView)findViewById(R.id.setup_title);
  stepsTitle.setText(getString(R.string.setup_steps_title,applicationName));
  final SetupStepIndicatorView indicatorView=(SetupStepIndicatorView)findViewById(R.id.setup_step_indicator);
  mSetupStepGroup=new SetupStepGroup(indicatorView);
  mStep1Bullet=(TextView)findViewById(R.id.setup_step1_bullet);
  mStep1Bullet.setOnClickListener(this);
  final SetupStep step1=new SetupStep(STEP_1,applicationName,mStep1Bullet,findViewById(R.id.setup_step1),R.string.setup_step1_title,R.string.setup_step1_instruction,R.string.setup_step1_finished_instruction,R.drawable.ic_setup_step1,R.string.setup_step1_action);
  step1.setAction(new Runnable(){
    @Override public void run(){
      invokeLanguageAndInputSettings();
      mHandler.startPollingImeSettings();
    }
  }
);
  mSetupStepGroup.addStep(step1);
  final SetupStep step2=new SetupStep(STEP_2,applicationName,(TextView)findViewById(R.id.setup_step2_bullet),findViewById(R.id.setup_step2),R.string.setup_step2_title,R.string.setup_step2_instruction,0,R.drawable.ic_setup_step2,R.string.setup_step2_action);
  step2.setAction(new Runnable(){
    @Override public void run(){
      RichInputMethodManager.getInstance().getInputMethodManager().showInputMethodPicker();
    }
  }
);
  mSetupStepGroup.addStep(step2);
  final SetupStep step3=new SetupStep(STEP_3,applicationName,(TextView)findViewById(R.id.setup_step3_bullet),findViewById(R.id.setup_step3),R.string.setup_step3_title,R.string.setup_step3_instruction,0,R.drawable.ic_setup_step3,R.string.setup_step3_action);
  step3.setAction(new Runnable(){
    @Override public void run(){
      invokeSubtypeEnablerOfThisIme();
    }
  }
);
  mSetupStepGroup.addStep(step3);
  mWelcomeVideoUri=new Uri.Builder().scheme(ContentResolver.SCHEME_ANDROID_RESOURCE).authority(getPackageName()).path(Integer.toString(R.raw.setup_welcome_video)).build();
  mWelcomeVideoView=(VideoView)findViewById(R.id.setup_welcome_video);
  mWelcomeVideoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener(){
    @Override public void onPrepared(    final MediaPlayer mp){
      mWelcomeVideoView.setBackgroundResource(0);
      mp.setLooping(true);
    }
  }
);
  final ImageView welcomeImageView=(ImageView)findViewById(R.id.setup_welcome_image);
  mWelcomeVideoView.setOnErrorListener(new MediaPlayer.OnErrorListener(){
    @Override public boolean onError(    final MediaPlayer mp,    final int what,    final int extra){
      Log.e(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ extra);
      mWelcomeVideoView.setVisibility(View.GONE);
      welcomeImageView.setImageResource(R.raw.setup_welcome_image);
      welcomeImageView.setVisibility(View.VISIBLE);
      return true;
    }
  }
);
  mActionStart=findViewById(R.id.setup_start_label);
  mActionStart.setOnClickListener(this);
  mActionNext=findViewById(R.id.setup_next);
  mActionNext.setOnClickListener(this);
  mActionFinish=(TextView)findViewById(R.id.setup_finish);
  TextViewCompatUtils.setCompoundDrawablesRelativeWithIntrinsicBounds(mActionFinish,getResources().getDrawable(R.drawable.ic_setup_finish),null,null,null);
  mActionFinish.setOnClickListener(this);
}",0.9654199011997178
87694,"@Override public void onPrepared(final MediaPlayer mp){
  mWelcomeVideoView.setBackgroundResource(0);
}","@Override public void onPrepared(final MediaPlayer mp){
  mWelcomeVideoView.setBackgroundResource(0);
  mp.setLooping(true);
}",0.8995633187772926
87695,"/** 
 * Remove LogUnits from the front of the LogBuffer until   {@code numWords} have been removed.If there are less than  {@code numWords} word-containing {@link LogUnit}s, shifts out all   {@code LogUnit}s in the buffer.
 * @param numWords the minimum number of word-containing {@link LogUnit}s to shift out
 * @return the number of actual {@code LogUnit}s shifted out
 */
protected int shiftOutWords(final int numWords){
  int numWordContainingLogUnitsShiftedOut=0;
  for (LogUnit logUnit=shiftOut(); logUnit != null && numWordContainingLogUnitsShiftedOut < numWords; logUnit=shiftOut()) {
    if (logUnit.hasOneOrMoreWords()) {
      numWordContainingLogUnitsShiftedOut+=logUnit.getNumWords();
    }
  }
  return numWordContainingLogUnitsShiftedOut;
}","/** 
 * Remove LogUnits from the front of the LogBuffer until   {@code numWords} have been removed.If there are less than  {@code numWords} in the buffer, shifts out all {@code LogUnit}s.
 * @param numWords the minimum number of words in {@link LogUnit}s to shift out
 * @return the number of actual words LogUnit}s shifted out
 */
protected int shiftOutWords(final int numWords){
  int numWordsShiftedOut=0;
  do {
    final LogUnit logUnit=shiftOut();
    if (logUnit == null)     break;
    numWordsShiftedOut+=logUnit.getNumWords();
  }
 while (numWordsShiftedOut < numWords);
  return numWordsShiftedOut;
}",0.6734992679355783
87696,"@Override protected int shiftOutWords(final int numWords){
  final int numWordContainingLogUnitsShiftedOut=super.shiftOutWords(numWords);
  mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWordContainingLogUnitsShiftedOut);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
  return numWordContainingLogUnitsShiftedOut;
}","@Override protected int shiftOutWords(final int numWords){
  final int numWordsShiftedOut=super.shiftOutWords(numWords);
  mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWordsShiftedOut);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
  return numWordsShiftedOut;
}",0.926829268292683
87697,"protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    mNumWordsUntilSafeToSample=mNumWordsBetweenNGrams;
  }
 else {
    logUnits.clear();
    for (LogUnit logUnit=shiftOut(); logUnit != null && !logUnit.hasOneOrMoreWords(); logUnit=shiftOut()) {
      logUnits.add(logUnit);
    }
    publish(logUnits,false);
  }
}","protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    mNumWordsUntilSafeToSample=mNumWordsBetweenNGrams;
    return;
  }
  logUnits.clear();
  LogUnit logUnit=shiftOut();
  while (logUnit != null) {
    logUnits.add(logUnit);
    final int numWords=logUnit.getNumWords();
    if (numWords > 0) {
      mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWords);
      break;
    }
    logUnit=shiftOut();
  }
  publish(logUnits,false);
}",0.6786678667866787
87698,"/** 
 * Remove LogUnits from the front of the LogBuffer until   {@code numWords} have been removed.If there are less than  {@code numWords} word-containing {@link LogUnit}s, shifts out all   {@code LogUnit}s in the buffer.
 * @param numWords the minimum number of word-containing {@link LogUnit}s to shift out
 * @return the number of actual {@code LogUnit}s shifted out
 */
protected int shiftOutWords(final int numWords){
  int numWordContainingLogUnitsShiftedOut=0;
  for (LogUnit logUnit=shiftOut(); logUnit != null && numWordContainingLogUnitsShiftedOut < numWords; logUnit=shiftOut()) {
    if (logUnit.hasOneOrMoreWords()) {
      numWordContainingLogUnitsShiftedOut+=logUnit.getNumWords();
    }
  }
  return numWordContainingLogUnitsShiftedOut;
}","/** 
 * Remove LogUnits from the front of the LogBuffer until   {@code numWords} have been removed.If there are less than  {@code numWords} in the buffer, shifts out all {@code LogUnit}s.
 * @param numWords the minimum number of words in {@link LogUnit}s to shift out
 * @return the number of actual words LogUnit}s shifted out
 */
protected int shiftOutWords(final int numWords){
  int numWordsShiftedOut=0;
  do {
    final LogUnit logUnit=shiftOut();
    if (logUnit == null)     break;
    numWordsShiftedOut+=logUnit.getNumWords();
  }
 while (numWordsShiftedOut < numWords);
  return numWordsShiftedOut;
}",0.6734992679355783
87699,"@Override protected int shiftOutWords(final int numWords){
  final int numWordContainingLogUnitsShiftedOut=super.shiftOutWords(numWords);
  mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWordContainingLogUnitsShiftedOut);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
  return numWordContainingLogUnitsShiftedOut;
}","@Override protected int shiftOutWords(final int numWords){
  final int numWordsShiftedOut=super.shiftOutWords(numWords);
  mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWordsShiftedOut);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
  return numWordsShiftedOut;
}",0.926829268292683
87700,"protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    mNumWordsUntilSafeToSample=mNumWordsBetweenNGrams;
  }
 else {
    logUnits.clear();
    for (LogUnit logUnit=shiftOut(); logUnit != null && !logUnit.hasOneOrMoreWords(); logUnit=shiftOut()) {
      logUnits.add(logUnit);
    }
    publish(logUnits,false);
  }
}","protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    mNumWordsUntilSafeToSample=mNumWordsBetweenNGrams;
    return;
  }
  logUnits.clear();
  LogUnit logUnit=shiftOut();
  while (logUnit != null) {
    logUnits.add(logUnit);
    final int numWords=logUnit.getNumWords();
    if (numWords > 0) {
      mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWords);
      break;
    }
    logUnit=shiftOut();
  }
  publish(logUnits,false);
}",0.6786678667866787
87701,"@Override protected void onPause(){
  mWelcomeVideoView.stopPlayback();
  super.onPause();
}","@Override protected void onPause(){
  hideAndStopVideo(mWelcomeVideoView);
  super.onPause();
}",0.8342245989304813
87702,"private void updateSetupStepView(){
  final boolean welcomeScreen=(mStepNumber == STEP_WELCOME);
  mWelcomeScreen.setVisibility(welcomeScreen ? View.VISIBLE : View.GONE);
  mSetupScreen.setVisibility(welcomeScreen ? View.GONE : View.VISIBLE);
  if (welcomeScreen) {
    mWelcomeVideoView.setVideoURI(mWelcomeVideoUri);
    mWelcomeVideoView.start();
    return;
  }
  mWelcomeVideoView.stopPlayback();
  final boolean isStepActionAlreadyDone=mStepNumber < determineSetupStepNumber();
  mSetupStepGroup.enableStep(mStepNumber,isStepActionAlreadyDone);
  mActionNext.setVisibility(isStepActionAlreadyDone ? View.VISIBLE : View.GONE);
  mActionFinish.setVisibility((mStepNumber == STEP_3) ? View.VISIBLE : View.GONE);
}","private void updateSetupStepView(){
  final boolean welcomeScreen=(mStepNumber == STEP_WELCOME);
  mWelcomeScreen.setVisibility(welcomeScreen ? View.VISIBLE : View.GONE);
  mSetupScreen.setVisibility(welcomeScreen ? View.GONE : View.VISIBLE);
  if (welcomeScreen) {
    mWelcomeVideoView.setVisibility(View.VISIBLE);
    mWelcomeVideoView.setVideoURI(mWelcomeVideoUri);
    mWelcomeVideoView.start();
    return;
  }
  hideAndStopVideo(mWelcomeVideoView);
  final boolean isStepActionAlreadyDone=mStepNumber < determineSetupStepNumber();
  mSetupStepGroup.enableStep(mStepNumber,isStepActionAlreadyDone);
  mActionNext.setVisibility(isStepActionAlreadyDone ? View.VISIBLE : View.GONE);
  mActionFinish.setVisibility((mStepNumber == STEP_3) ? View.VISIBLE : View.GONE);
}",0.9448183041722744
87703,"@Override protected void onCreate(final Bundle savedInstanceState){
  setTheme(android.R.style.Theme_DeviceDefault_Light_NoActionBar);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.setup_wizard);
  RichInputMethodManager.init(this);
  if (savedInstanceState == null) {
    mStepNumber=determineSetupStepNumber();
    if (mStepNumber == STEP_1 && !mWasLanguageAndInputSettingsInvoked) {
      mStepNumber=STEP_WELCOME;
    }
    if (mStepNumber == STEP_3) {
      invokeSettingsOfThisIme();
      finish();
      return;
    }
  }
 else {
    mStepNumber=savedInstanceState.getInt(STATE_STEP);
  }
  final String applicationName=getResources().getString(getApplicationInfo().labelRes);
  mWelcomeScreen=findViewById(R.id.setup_welcome_screen);
  final TextView welcomeTitle=(TextView)findViewById(R.id.setup_welcome_title);
  welcomeTitle.setText(getString(R.string.setup_welcome_title,applicationName));
  mSetupScreen=findViewById(R.id.setup_steps_screen);
  final TextView stepsTitle=(TextView)findViewById(R.id.setup_title);
  stepsTitle.setText(getString(R.string.setup_steps_title,applicationName));
  final SetupStepIndicatorView indicatorView=(SetupStepIndicatorView)findViewById(R.id.setup_step_indicator);
  mSetupStepGroup=new SetupStepGroup(indicatorView);
  mStep1Bullet=(TextView)findViewById(R.id.setup_step1_bullet);
  mStep1Bullet.setOnClickListener(this);
  final SetupStep step1=new SetupStep(STEP_1,applicationName,mStep1Bullet,findViewById(R.id.setup_step1),R.string.setup_step1_title,R.string.setup_step1_instruction,R.string.setup_step1_finished_instruction,R.drawable.ic_setup_step1,R.string.setup_step1_action);
  step1.setAction(new Runnable(){
    @Override public void run(){
      invokeLanguageAndInputSettings();
      mHandler.startPollingImeSettings();
    }
  }
);
  mSetupStepGroup.addStep(step1);
  final SetupStep step2=new SetupStep(STEP_2,applicationName,(TextView)findViewById(R.id.setup_step2_bullet),findViewById(R.id.setup_step2),R.string.setup_step2_title,R.string.setup_step2_instruction,0,R.drawable.ic_setup_step2,R.string.setup_step2_action);
  step2.setAction(new Runnable(){
    @Override public void run(){
      RichInputMethodManager.getInstance().getInputMethodManager().showInputMethodPicker();
    }
  }
);
  mSetupStepGroup.addStep(step2);
  final SetupStep step3=new SetupStep(STEP_3,applicationName,(TextView)findViewById(R.id.setup_step3_bullet),findViewById(R.id.setup_step3),R.string.setup_step3_title,R.string.setup_step3_instruction,0,R.drawable.ic_setup_step3,R.string.setup_step3_action);
  step3.setAction(new Runnable(){
    @Override public void run(){
      invokeSubtypeEnablerOfThisIme();
    }
  }
);
  mSetupStepGroup.addStep(step3);
  mWelcomeVideoUri=new Uri.Builder().scheme(ContentResolver.SCHEME_ANDROID_RESOURCE).authority(getPackageName()).path(Integer.toString(R.raw.setup_welcome_video)).build();
  mWelcomeVideoView=(VideoView)findViewById(R.id.setup_welcome_video);
  mWelcomeVideoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener(){
    @Override public void onCompletion(    final MediaPlayer mp){
      mp.start();
    }
  }
);
  mWelcomeVideoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener(){
    @Override public void onPrepared(    final MediaPlayer mp){
      mWelcomeVideoView.setBackgroundResource(0);
    }
  }
);
  final ImageView welcomeImageView=(ImageView)findViewById(R.id.setup_welcome_image);
  mWelcomeVideoView.setOnErrorListener(new MediaPlayer.OnErrorListener(){
    @Override public boolean onError(    final MediaPlayer mp,    final int what,    final int extra){
      Log.e(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ extra);
      mWelcomeVideoView.setVisibility(View.GONE);
      welcomeImageView.setImageResource(R.raw.setup_welcome_image);
      welcomeImageView.setVisibility(View.VISIBLE);
      return true;
    }
  }
);
  mActionStart=findViewById(R.id.setup_start_label);
  mActionStart.setOnClickListener(this);
  mActionNext=findViewById(R.id.setup_next);
  mActionNext.setOnClickListener(this);
  mActionFinish=(TextView)findViewById(R.id.setup_finish);
  TextViewCompatUtils.setCompoundDrawablesRelativeWithIntrinsicBounds(mActionFinish,getResources().getDrawable(R.drawable.ic_setup_finish),null,null,null);
  mActionFinish.setOnClickListener(this);
}","@Override protected void onCreate(final Bundle savedInstanceState){
  setTheme(android.R.style.Theme_DeviceDefault_Light_NoActionBar);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.setup_wizard);
  RichInputMethodManager.init(this);
  if (savedInstanceState == null) {
    mStepNumber=determineSetupStepNumber();
    if (mStepNumber == STEP_1 && !mWasLanguageAndInputSettingsInvoked) {
      mStepNumber=STEP_WELCOME;
    }
    if (mStepNumber == STEP_3) {
      invokeSettingsOfThisIme();
      finish();
      return;
    }
  }
 else {
    mStepNumber=savedInstanceState.getInt(STATE_STEP);
  }
  final String applicationName=getResources().getString(getApplicationInfo().labelRes);
  mWelcomeScreen=findViewById(R.id.setup_welcome_screen);
  final TextView welcomeTitle=(TextView)findViewById(R.id.setup_welcome_title);
  welcomeTitle.setText(getString(R.string.setup_welcome_title,applicationName));
  mSetupScreen=findViewById(R.id.setup_steps_screen);
  final TextView stepsTitle=(TextView)findViewById(R.id.setup_title);
  stepsTitle.setText(getString(R.string.setup_steps_title,applicationName));
  final SetupStepIndicatorView indicatorView=(SetupStepIndicatorView)findViewById(R.id.setup_step_indicator);
  mSetupStepGroup=new SetupStepGroup(indicatorView);
  mStep1Bullet=(TextView)findViewById(R.id.setup_step1_bullet);
  mStep1Bullet.setOnClickListener(this);
  final SetupStep step1=new SetupStep(STEP_1,applicationName,mStep1Bullet,findViewById(R.id.setup_step1),R.string.setup_step1_title,R.string.setup_step1_instruction,R.string.setup_step1_finished_instruction,R.drawable.ic_setup_step1,R.string.setup_step1_action);
  step1.setAction(new Runnable(){
    @Override public void run(){
      invokeLanguageAndInputSettings();
      mHandler.startPollingImeSettings();
    }
  }
);
  mSetupStepGroup.addStep(step1);
  final SetupStep step2=new SetupStep(STEP_2,applicationName,(TextView)findViewById(R.id.setup_step2_bullet),findViewById(R.id.setup_step2),R.string.setup_step2_title,R.string.setup_step2_instruction,0,R.drawable.ic_setup_step2,R.string.setup_step2_action);
  step2.setAction(new Runnable(){
    @Override public void run(){
      RichInputMethodManager.getInstance().getInputMethodManager().showInputMethodPicker();
    }
  }
);
  mSetupStepGroup.addStep(step2);
  final SetupStep step3=new SetupStep(STEP_3,applicationName,(TextView)findViewById(R.id.setup_step3_bullet),findViewById(R.id.setup_step3),R.string.setup_step3_title,R.string.setup_step3_instruction,0,R.drawable.ic_setup_step3,R.string.setup_step3_action);
  step3.setAction(new Runnable(){
    @Override public void run(){
      invokeSubtypeEnablerOfThisIme();
    }
  }
);
  mSetupStepGroup.addStep(step3);
  mWelcomeVideoUri=new Uri.Builder().scheme(ContentResolver.SCHEME_ANDROID_RESOURCE).authority(getPackageName()).path(Integer.toString(R.raw.setup_welcome_video)).build();
  mWelcomeVideoView=(VideoView)findViewById(R.id.setup_welcome_video);
  mWelcomeVideoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener(){
    @Override public void onPrepared(    final MediaPlayer mp){
      mWelcomeVideoView.setBackgroundResource(0);
      mp.setLooping(true);
    }
  }
);
  final ImageView welcomeImageView=(ImageView)findViewById(R.id.setup_welcome_image);
  mWelcomeVideoView.setOnErrorListener(new MediaPlayer.OnErrorListener(){
    @Override public boolean onError(    final MediaPlayer mp,    final int what,    final int extra){
      Log.e(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ extra);
      mWelcomeVideoView.setVisibility(View.GONE);
      welcomeImageView.setImageResource(R.raw.setup_welcome_image);
      welcomeImageView.setVisibility(View.VISIBLE);
      return true;
    }
  }
);
  mActionStart=findViewById(R.id.setup_start_label);
  mActionStart.setOnClickListener(this);
  mActionNext=findViewById(R.id.setup_next);
  mActionNext.setOnClickListener(this);
  mActionFinish=(TextView)findViewById(R.id.setup_finish);
  TextViewCompatUtils.setCompoundDrawablesRelativeWithIntrinsicBounds(mActionFinish,getResources().getDrawable(R.drawable.ic_setup_finish),null,null,null);
  mActionFinish.setOnClickListener(this);
}",0.9654199011997178
87704,"@Override public void onPrepared(final MediaPlayer mp){
  mWelcomeVideoView.setBackgroundResource(0);
}","@Override public void onPrepared(final MediaPlayer mp){
  mWelcomeVideoView.setBackgroundResource(0);
  mp.setLooping(true);
}",0.8995633187772926
87705,"@Override protected void onPause(){
  mWelcomeVideoView.stopPlayback();
  super.onPause();
}","@Override protected void onPause(){
  hideAndStopVideo(mWelcomeVideoView);
  super.onPause();
}",0.8342245989304813
87706,"private void updateSetupStepView(){
  final boolean welcomeScreen=(mStepNumber == STEP_WELCOME);
  mWelcomeScreen.setVisibility(welcomeScreen ? View.VISIBLE : View.GONE);
  mSetupScreen.setVisibility(welcomeScreen ? View.GONE : View.VISIBLE);
  if (welcomeScreen) {
    mWelcomeVideoView.setVideoURI(mWelcomeVideoUri);
    mWelcomeVideoView.start();
    return;
  }
  mWelcomeVideoView.stopPlayback();
  final boolean isStepActionAlreadyDone=mStepNumber < determineSetupStepNumber();
  mSetupStepGroup.enableStep(mStepNumber,isStepActionAlreadyDone);
  mActionNext.setVisibility(isStepActionAlreadyDone ? View.VISIBLE : View.GONE);
  mActionFinish.setVisibility((mStepNumber == STEP_3) ? View.VISIBLE : View.GONE);
}","private void updateSetupStepView(){
  final boolean welcomeScreen=(mStepNumber == STEP_WELCOME);
  mWelcomeScreen.setVisibility(welcomeScreen ? View.VISIBLE : View.GONE);
  mSetupScreen.setVisibility(welcomeScreen ? View.GONE : View.VISIBLE);
  if (welcomeScreen) {
    mWelcomeVideoView.setVisibility(View.VISIBLE);
    mWelcomeVideoView.setVideoURI(mWelcomeVideoUri);
    mWelcomeVideoView.start();
    return;
  }
  hideAndStopVideo(mWelcomeVideoView);
  final boolean isStepActionAlreadyDone=mStepNumber < determineSetupStepNumber();
  mSetupStepGroup.enableStep(mStepNumber,isStepActionAlreadyDone);
  mActionNext.setVisibility(isStepActionAlreadyDone ? View.VISIBLE : View.GONE);
  mActionFinish.setVisibility((mStepNumber == STEP_3) ? View.VISIBLE : View.GONE);
}",0.9448183041722744
87707,"@Override protected void onCreate(final Bundle savedInstanceState){
  setTheme(android.R.style.Theme_DeviceDefault_Light_NoActionBar);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.setup_wizard);
  RichInputMethodManager.init(this);
  if (savedInstanceState == null) {
    mStepNumber=determineSetupStepNumber();
    if (mStepNumber == STEP_1 && !mWasLanguageAndInputSettingsInvoked) {
      mStepNumber=STEP_WELCOME;
    }
    if (mStepNumber == STEP_3) {
      invokeSettingsOfThisIme();
      finish();
      return;
    }
  }
 else {
    mStepNumber=savedInstanceState.getInt(STATE_STEP);
  }
  final String applicationName=getResources().getString(getApplicationInfo().labelRes);
  mWelcomeScreen=findViewById(R.id.setup_welcome_screen);
  final TextView welcomeTitle=(TextView)findViewById(R.id.setup_welcome_title);
  welcomeTitle.setText(getString(R.string.setup_welcome_title,applicationName));
  mSetupScreen=findViewById(R.id.setup_steps_screen);
  final TextView stepsTitle=(TextView)findViewById(R.id.setup_title);
  stepsTitle.setText(getString(R.string.setup_steps_title,applicationName));
  final SetupStepIndicatorView indicatorView=(SetupStepIndicatorView)findViewById(R.id.setup_step_indicator);
  mSetupStepGroup=new SetupStepGroup(indicatorView);
  mStep1Bullet=(TextView)findViewById(R.id.setup_step1_bullet);
  mStep1Bullet.setOnClickListener(this);
  final SetupStep step1=new SetupStep(STEP_1,applicationName,mStep1Bullet,findViewById(R.id.setup_step1),R.string.setup_step1_title,R.string.setup_step1_instruction,R.string.setup_step1_finished_instruction,R.drawable.ic_setup_step1,R.string.setup_step1_action);
  step1.setAction(new Runnable(){
    @Override public void run(){
      invokeLanguageAndInputSettings();
      mHandler.startPollingImeSettings();
    }
  }
);
  mSetupStepGroup.addStep(step1);
  final SetupStep step2=new SetupStep(STEP_2,applicationName,(TextView)findViewById(R.id.setup_step2_bullet),findViewById(R.id.setup_step2),R.string.setup_step2_title,R.string.setup_step2_instruction,0,R.drawable.ic_setup_step2,R.string.setup_step2_action);
  step2.setAction(new Runnable(){
    @Override public void run(){
      RichInputMethodManager.getInstance().getInputMethodManager().showInputMethodPicker();
    }
  }
);
  mSetupStepGroup.addStep(step2);
  final SetupStep step3=new SetupStep(STEP_3,applicationName,(TextView)findViewById(R.id.setup_step3_bullet),findViewById(R.id.setup_step3),R.string.setup_step3_title,R.string.setup_step3_instruction,0,R.drawable.ic_setup_step3,R.string.setup_step3_action);
  step3.setAction(new Runnable(){
    @Override public void run(){
      invokeSubtypeEnablerOfThisIme();
    }
  }
);
  mSetupStepGroup.addStep(step3);
  mWelcomeVideoUri=new Uri.Builder().scheme(ContentResolver.SCHEME_ANDROID_RESOURCE).authority(getPackageName()).path(Integer.toString(R.raw.setup_welcome_video)).build();
  mWelcomeVideoView=(VideoView)findViewById(R.id.setup_welcome_video);
  mWelcomeVideoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener(){
    @Override public void onCompletion(    final MediaPlayer mp){
      mp.start();
    }
  }
);
  mWelcomeVideoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener(){
    @Override public void onPrepared(    final MediaPlayer mp){
      mWelcomeVideoView.setBackgroundResource(0);
    }
  }
);
  final ImageView welcomeImageView=(ImageView)findViewById(R.id.setup_welcome_image);
  mWelcomeVideoView.setOnErrorListener(new MediaPlayer.OnErrorListener(){
    @Override public boolean onError(    final MediaPlayer mp,    final int what,    final int extra){
      Log.e(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ extra);
      mWelcomeVideoView.setVisibility(View.GONE);
      welcomeImageView.setImageResource(R.raw.setup_welcome_image);
      welcomeImageView.setVisibility(View.VISIBLE);
      return true;
    }
  }
);
  mActionStart=findViewById(R.id.setup_start_label);
  mActionStart.setOnClickListener(this);
  mActionNext=findViewById(R.id.setup_next);
  mActionNext.setOnClickListener(this);
  mActionFinish=(TextView)findViewById(R.id.setup_finish);
  TextViewCompatUtils.setCompoundDrawablesRelativeWithIntrinsicBounds(mActionFinish,getResources().getDrawable(R.drawable.ic_setup_finish),null,null,null);
  mActionFinish.setOnClickListener(this);
}","@Override protected void onCreate(final Bundle savedInstanceState){
  setTheme(android.R.style.Theme_DeviceDefault_Light_NoActionBar);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.setup_wizard);
  RichInputMethodManager.init(this);
  if (savedInstanceState == null) {
    mStepNumber=determineSetupStepNumber();
    if (mStepNumber == STEP_1 && !mWasLanguageAndInputSettingsInvoked) {
      mStepNumber=STEP_WELCOME;
    }
    if (mStepNumber == STEP_3) {
      invokeSettingsOfThisIme();
      finish();
      return;
    }
  }
 else {
    mStepNumber=savedInstanceState.getInt(STATE_STEP);
  }
  final String applicationName=getResources().getString(getApplicationInfo().labelRes);
  mWelcomeScreen=findViewById(R.id.setup_welcome_screen);
  final TextView welcomeTitle=(TextView)findViewById(R.id.setup_welcome_title);
  welcomeTitle.setText(getString(R.string.setup_welcome_title,applicationName));
  mSetupScreen=findViewById(R.id.setup_steps_screen);
  final TextView stepsTitle=(TextView)findViewById(R.id.setup_title);
  stepsTitle.setText(getString(R.string.setup_steps_title,applicationName));
  final SetupStepIndicatorView indicatorView=(SetupStepIndicatorView)findViewById(R.id.setup_step_indicator);
  mSetupStepGroup=new SetupStepGroup(indicatorView);
  mStep1Bullet=(TextView)findViewById(R.id.setup_step1_bullet);
  mStep1Bullet.setOnClickListener(this);
  final SetupStep step1=new SetupStep(STEP_1,applicationName,mStep1Bullet,findViewById(R.id.setup_step1),R.string.setup_step1_title,R.string.setup_step1_instruction,R.string.setup_step1_finished_instruction,R.drawable.ic_setup_step1,R.string.setup_step1_action);
  step1.setAction(new Runnable(){
    @Override public void run(){
      invokeLanguageAndInputSettings();
      mHandler.startPollingImeSettings();
    }
  }
);
  mSetupStepGroup.addStep(step1);
  final SetupStep step2=new SetupStep(STEP_2,applicationName,(TextView)findViewById(R.id.setup_step2_bullet),findViewById(R.id.setup_step2),R.string.setup_step2_title,R.string.setup_step2_instruction,0,R.drawable.ic_setup_step2,R.string.setup_step2_action);
  step2.setAction(new Runnable(){
    @Override public void run(){
      RichInputMethodManager.getInstance().getInputMethodManager().showInputMethodPicker();
    }
  }
);
  mSetupStepGroup.addStep(step2);
  final SetupStep step3=new SetupStep(STEP_3,applicationName,(TextView)findViewById(R.id.setup_step3_bullet),findViewById(R.id.setup_step3),R.string.setup_step3_title,R.string.setup_step3_instruction,0,R.drawable.ic_setup_step3,R.string.setup_step3_action);
  step3.setAction(new Runnable(){
    @Override public void run(){
      invokeSubtypeEnablerOfThisIme();
    }
  }
);
  mSetupStepGroup.addStep(step3);
  mWelcomeVideoUri=new Uri.Builder().scheme(ContentResolver.SCHEME_ANDROID_RESOURCE).authority(getPackageName()).path(Integer.toString(R.raw.setup_welcome_video)).build();
  mWelcomeVideoView=(VideoView)findViewById(R.id.setup_welcome_video);
  mWelcomeVideoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener(){
    @Override public void onPrepared(    final MediaPlayer mp){
      mWelcomeVideoView.setBackgroundResource(0);
      mp.setLooping(true);
    }
  }
);
  final ImageView welcomeImageView=(ImageView)findViewById(R.id.setup_welcome_image);
  mWelcomeVideoView.setOnErrorListener(new MediaPlayer.OnErrorListener(){
    @Override public boolean onError(    final MediaPlayer mp,    final int what,    final int extra){
      Log.e(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ extra);
      mWelcomeVideoView.setVisibility(View.GONE);
      welcomeImageView.setImageResource(R.raw.setup_welcome_image);
      welcomeImageView.setVisibility(View.VISIBLE);
      return true;
    }
  }
);
  mActionStart=findViewById(R.id.setup_start_label);
  mActionStart.setOnClickListener(this);
  mActionNext=findViewById(R.id.setup_next);
  mActionNext.setOnClickListener(this);
  mActionFinish=(TextView)findViewById(R.id.setup_finish);
  TextViewCompatUtils.setCompoundDrawablesRelativeWithIntrinsicBounds(mActionFinish,getResources().getDrawable(R.drawable.ic_setup_finish),null,null,null);
  mActionFinish.setOnClickListener(this);
}",0.9654199011997178
87708,"@Override public void onPrepared(final MediaPlayer mp){
  mWelcomeVideoView.setBackgroundResource(0);
}","@Override public void onPrepared(final MediaPlayer mp){
  mWelcomeVideoView.setBackgroundResource(0);
  mp.setLooping(true);
}",0.8995633187772926
87709,"protected void shiftOutWords(final int numWords){
  final int targetNumWords=mNumActualWords - numWords;
  final LinkedList<LogUnit> logUnits=getLogUnits();
  while (mNumActualWords > targetNumWords && !logUnits.isEmpty()) {
    shiftOut();
  }
}","/** 
 * Remove LogUnits from the front of the LogBuffer until   {@code numWords} have been removed.If there are less than  {@code numWords} word-containing {@link LogUnit}s, shifts out all   {@code LogUnit}s in the buffer.
 * @param numWords the number of word-containing {@link LogUnit}s to shift out
 * @return the number of actual {@code LogUnit}s shifted out
 */
protected int shiftOutWords(final int numWords){
  int numWordContainingLogUnitsShiftedOut=0;
  for (LogUnit logUnit=shiftOut(); logUnit != null && numWordContainingLogUnitsShiftedOut < numWords; logUnit=shiftOut()) {
    if (logUnit.hasWord()) {
      numWordContainingLogUnitsShiftedOut++;
    }
  }
  return numWordContainingLogUnitsShiftedOut;
}",0.1455301455301455
87710,"@Override protected void shiftOutWords(final int numWords){
  final int oldNumActualWords=getNumActualWords();
  super.shiftOutWords(numWords);
  final int numWordsShifted=oldNumActualWords - getNumActualWords();
  mNumWordsUntilSafeToSample-=numWordsShifted;
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
}","@Override protected int shiftOutWords(final int numWords){
  final int numWordContainingLogUnitsShiftedOut=super.shiftOutWords(numWords);
  mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWordContainingLogUnitsShiftedOut);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
  return numWordContainingLogUnitsShiftedOut;
}",0.4546722454672245
87711,"protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    resetWordCounter();
  }
 else {
    logUnits=peekAtFirstNWords(1);
    publish(logUnits,false);
    shiftOutWords(1);
  }
}","protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    mNumWordsUntilSafeToSample=mNumWordsBetweenNGrams;
  }
 else {
    logUnits=peekAtFirstNWords(1);
    publish(logUnits,false);
    shiftOutWords(1);
  }
}",0.9075862068965516
87712,"protected void shiftOutWords(final int numWords){
  final int targetNumWords=mNumActualWords - numWords;
  final LinkedList<LogUnit> logUnits=getLogUnits();
  while (mNumActualWords > targetNumWords && !logUnits.isEmpty()) {
    shiftOut();
  }
}","/** 
 * Remove LogUnits from the front of the LogBuffer until   {@code numWords} have been removed.If there are less than  {@code numWords} word-containing {@link LogUnit}s, shifts out all   {@code LogUnit}s in the buffer.
 * @param numWords the number of word-containing {@link LogUnit}s to shift out
 * @return the number of actual {@code LogUnit}s shifted out
 */
protected int shiftOutWords(final int numWords){
  int numWordContainingLogUnitsShiftedOut=0;
  for (LogUnit logUnit=shiftOut(); logUnit != null && numWordContainingLogUnitsShiftedOut < numWords; logUnit=shiftOut()) {
    if (logUnit.hasWord()) {
      numWordContainingLogUnitsShiftedOut++;
    }
  }
  return numWordContainingLogUnitsShiftedOut;
}",0.1455301455301455
87713,"@Override protected void shiftOutWords(final int numWords){
  final int oldNumActualWords=getNumActualWords();
  super.shiftOutWords(numWords);
  final int numWordsShifted=oldNumActualWords - getNumActualWords();
  mNumWordsUntilSafeToSample-=numWordsShifted;
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
}","@Override protected int shiftOutWords(final int numWords){
  final int numWordContainingLogUnitsShiftedOut=super.shiftOutWords(numWords);
  mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWordContainingLogUnitsShiftedOut);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
  return numWordContainingLogUnitsShiftedOut;
}",0.4546722454672245
87714,"protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    resetWordCounter();
  }
 else {
    logUnits=peekAtFirstNWords(1);
    publish(logUnits,false);
    shiftOutWords(1);
  }
}","protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    mNumWordsUntilSafeToSample=mNumWordsBetweenNGrams;
  }
 else {
    logUnits=peekAtFirstNWords(1);
    publish(logUnits,false);
    shiftOutWords(1);
  }
}",0.9075862068965516
87715,"private boolean drawGestureTrailLocked(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  outBoundsRect.setEmpty();
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine roundedLine=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    final int lastTime=sinceDown - eventTimes[startIndex];
    float r1=getWidth(lastTime,params) / 2.0f;
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float r2=getWidth(elapsedTime,params) / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final float body1=r1 * params.mTrailBodyRatio;
        final float body2=r2 * params.mTrailBodyRatio;
        final Path path=roundedLine.makePath(p1x,p1y,body1,p2x,p2y,body2);
        if (path != null) {
          roundedLine.getBounds(mRoundedLineBounds);
          if (params.mTrailShadowEnabled) {
            final float shadow2=r2 * params.mTrailShadowRatio;
            paint.setShadowLayer(shadow2,0.0f,0.0f,params.mTrailColor);
            final int shadowInset=-(int)Math.ceil(shadow2);
            mRoundedLineBounds.inset(shadowInset,shadowInset);
          }
          outBoundsRect.union(mRoundedLineBounds);
          final int alpha=getAlpha(elapsedTime,params);
          paint.setAlpha(alpha);
          canvas.drawPath(path,paint);
        }
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
    }
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
      mLastInterpolatedDrawIndex=Math.max(mLastInterpolatedDrawIndex - startIndex,0);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
  }
  return newSize > 0;
}","private boolean drawGestureTrailLocked(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  outBoundsRect.setEmpty();
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine roundedLine=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    final int lastTime=sinceDown - eventTimes[startIndex];
    float r1=getWidth(lastTime,params) / 2.0f;
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float r2=getWidth(elapsedTime,params) / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final float body1=r1 * params.mTrailBodyRatio;
        final float body2=r2 * params.mTrailBodyRatio;
        final Path path=roundedLine.makePath(p1x,p1y,body1,p2x,p2y,body2);
        if (path != null) {
          roundedLine.getBounds(mRoundedLineBounds);
          if (params.mTrailShadowEnabled) {
            final float shadow2=r2 * params.mTrailShadowRatio;
            paint.setShadowLayer(shadow2,0.0f,0.0f,params.mTrailColor);
            final int shadowInset=-(int)Math.ceil(shadow2);
            mRoundedLineBounds.inset(shadowInset,shadowInset);
          }
          outBoundsRect.union(mRoundedLineBounds);
          final int alpha=getAlpha(elapsedTime,params);
          paint.setAlpha(alpha);
          canvas.drawPath(path,paint);
        }
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
    }
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
    mLastInterpolatedDrawIndex=Math.max(mLastInterpolatedDrawIndex - startIndex,0);
  }
  return newSize > 0;
}",0.952983725135624
87716,"@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=mCurrentString.length();
      for (      int i : currentGroup.mChars)       mCurrentString.append(Character.toChars(i));
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0)       return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mPositions.getLast().length);
    }
  }
 while (true);
}","@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=mCurrentString.length();
      for (      int i : currentGroup.mChars) {
        mCurrentString.append(Character.toChars(i));
      }
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        currentPos.length=mCurrentString.length();
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0) {
        return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
      }
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mPositions.getLast().length);
    }
  }
 while (true);
}",0.9606712113266912
87717,"/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String string){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  final int[] codePoints=getCodePoints(string);
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,codePoints[index]);
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (codePoints.length - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < codePoints.length && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != codePoints[newIndex])       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePoints.length) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePoints.length);
  if (index < codePoints.length)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !codePoints.equals(checker.toString()))   return null;
  return currentGroup;
}","/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String string){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  final int[] codePoints=getCodePoints(string);
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,codePoints[index]);
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (codePoints.length - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < codePoints.length && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != codePoints[newIndex])       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePoints.length) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePoints.length);
  if (index < codePoints.length)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !string.equals(checker.toString()))   return null;
  return currentGroup;
}",0.9935897435897436
87718,"@Override public void onDisplayCompletions(final CompletionInfo[] applicationSpecifiedCompletions){
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"");
    if (applicationSpecifiedCompletions != null) {
      for (int i=0; i < applicationSpecifiedCompletions.length; i++) {
        Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ applicationSpecifiedCompletions[i]);
      }
    }
  }
  if (!mSettings.getCurrent().isApplicationSpecifiedCompletionsOn())   return;
  mApplicationSpecifiedCompletions=applicationSpecifiedCompletions;
  if (applicationSpecifiedCompletions == null) {
    clearSuggestionStrip();
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.latinIME_onDisplayCompletions(null);
    }
    return;
  }
  final ArrayList<SuggestedWords.SuggestedWordInfo> applicationSuggestedWords=SuggestedWords.getFromApplicationSpecifiedCompletions(applicationSpecifiedCompletions);
  final SuggestedWords suggestedWords=new SuggestedWords(applicationSuggestedWords,false,false,false,false,false);
  final boolean isAutoCorrection=false;
  setSuggestedWords(suggestedWords,isAutoCorrection);
  setAutoCorrectionIndicator(isAutoCorrection);
  setSuggestionStripShown(true);
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    ResearchLogger.latinIME_onDisplayCompletions(applicationSpecifiedCompletions);
  }
}","@Override public void onDisplayCompletions(final CompletionInfo[] applicationSpecifiedCompletions){
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"");
    if (applicationSpecifiedCompletions != null) {
      for (int i=0; i < applicationSpecifiedCompletions.length; i++) {
        Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ applicationSpecifiedCompletions[i]);
      }
    }
  }
  if (!mSettings.getCurrent().isApplicationSpecifiedCompletionsOn())   return;
  mApplicationSpecifiedCompletions=CompletionInfoUtils.removeNulls(applicationSpecifiedCompletions);
  if (applicationSpecifiedCompletions == null) {
    clearSuggestionStrip();
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.latinIME_onDisplayCompletions(null);
    }
    return;
  }
  final ArrayList<SuggestedWords.SuggestedWordInfo> applicationSuggestedWords=SuggestedWords.getFromApplicationSpecifiedCompletions(applicationSpecifiedCompletions);
  final SuggestedWords suggestedWords=new SuggestedWords(applicationSuggestedWords,false,false,false,false,false);
  final boolean isAutoCorrection=false;
  setSuggestedWords(suggestedWords,isAutoCorrection);
  setAutoCorrectionIndicator(isAutoCorrection);
  setSuggestionStripShown(true);
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    ResearchLogger.latinIME_onDisplayCompletions(applicationSpecifiedCompletions);
  }
}",0.9653158086893028
87719,"public void commitCompletion(final CompletionInfo completionInfo){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  final CharSequence text=completionInfo.getText();
  mCommittedTextBeforeComposingText.append(text);
  mCurrentCursorPosition+=text.length() - mComposingText.length();
  mComposingText.setLength(0);
  if (null != mIC) {
    mIC.commitCompletion(completionInfo);
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.richInputConnection_commitCompletion(completionInfo);
    }
  }
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
}","public void commitCompletion(final CompletionInfo completionInfo){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  CharSequence text=completionInfo.getText();
  if (null == text)   text=""String_Node_Str"";
  mCommittedTextBeforeComposingText.append(text);
  mCurrentCursorPosition+=text.length() - mComposingText.length();
  mComposingText.setLength(0);
  if (null != mIC) {
    mIC.commitCompletion(completionInfo);
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.richInputConnection_commitCompletion(completionInfo);
    }
  }
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
}",0.9573820395738204
87720,"/** 
 * Arrange for the UploaderService to be run on a regular basis. Any existing scheduled invocation of UploaderService is removed and optionally rescheduled. This may cause problems if this method is called so often that no scheduled invocation is ever run.  But if the delay is short enough that it will go off when the user is sleeping, then there should be no starvation.
 * @param context {@link Context} object
 * @param needsRescheduling whether to schedule a future intent to be delivered to this service
 */
public static void cancelAndRescheduleUploadingService(final Context context,final boolean needsRescheduling){
  final PendingIntent pendingIntent=getPendingIntentForService(context);
  final AlarmManager alarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  cancelAnyScheduledServiceAlarm(alarmManager,pendingIntent);
  if (needsRescheduling) {
    scheduleServiceAlarm(alarmManager,pendingIntent);
  }
}","/** 
 * Arrange for the UploaderService to be run on a regular basis. Any existing scheduled invocation of UploaderService is removed and optionally rescheduled. This may cause problems if this method is called so often that no scheduled invocation is ever run.  But if the delay is short enough that it will go off when the user is sleeping, then there should be no starvation.
 * @param context {@link Context} object
 * @param needsRescheduling whether to schedule a future intent to be delivered to this service
 */
public static void cancelAndRescheduleUploadingService(final Context context,final boolean needsRescheduling){
  final Intent intent=new Intent(context,UploaderService.class);
  final PendingIntent pendingIntent=PendingIntent.getService(context,0,intent,0);
  final AlarmManager alarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  alarmManager.cancel(pendingIntent);
  if (needsRescheduling) {
    alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,SystemClock.elapsedRealtime() + UploaderService.RUN_INTERVAL,pendingIntent);
  }
}",0.8565795958600295
87721,"private boolean isDevTeamBuild(){
  try {
    final PackageInfo packageInfo;
    packageInfo=mLatinIME.getPackageManager().getPackageInfo(mLatinIME.getPackageName(),0);
    final String versionName=packageInfo.versionName;
    return !(developerBuildRegex.matcher(versionName).find());
  }
 catch (  final NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
}","private boolean isDevTeamBuild(){
  try {
    final PackageInfo packageInfo;
    packageInfo=mLatinIME.getPackageManager().getPackageInfo(mLatinIME.getPackageName(),0);
    final String versionName=packageInfo.versionName;
    return developerBuildRegex.matcher(versionName).find();
  }
 catch (  final NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
}",0.9961587708066582
87722,"/** 
 * Arrange for the UploaderService to be run on a regular basis. Any existing scheduled invocation of UploaderService is removed and optionally rescheduled. This may cause problems if this method is called so often that no scheduled invocation is ever run.  But if the delay is short enough that it will go off when the user is sleeping, then there should be no starvation.
 * @param context {@link Context} object
 * @param needsRescheduling whether to schedule a future intent to be delivered to this service
 */
public static void cancelAndRescheduleUploadingService(final Context context,final boolean needsRescheduling){
  final PendingIntent pendingIntent=getPendingIntentForService(context);
  final AlarmManager alarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  cancelAnyScheduledServiceAlarm(alarmManager,pendingIntent);
  if (needsRescheduling) {
    scheduleServiceAlarm(alarmManager,pendingIntent);
  }
}","/** 
 * Arrange for the UploaderService to be run on a regular basis. Any existing scheduled invocation of UploaderService is removed and optionally rescheduled. This may cause problems if this method is called so often that no scheduled invocation is ever run.  But if the delay is short enough that it will go off when the user is sleeping, then there should be no starvation.
 * @param context {@link Context} object
 * @param needsRescheduling whether to schedule a future intent to be delivered to this service
 */
public static void cancelAndRescheduleUploadingService(final Context context,final boolean needsRescheduling){
  final Intent intent=new Intent(context,UploaderService.class);
  final PendingIntent pendingIntent=PendingIntent.getService(context,0,intent,0);
  final AlarmManager alarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  alarmManager.cancel(pendingIntent);
  if (needsRescheduling) {
    alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,SystemClock.elapsedRealtime() + UploaderService.RUN_INTERVAL,pendingIntent);
  }
}",0.8565795958600295
87723,"static String getShortDisplayName(final InputMethodSubtype subtype){
  if (SubtypeLocale.isNoLanguage(subtype)) {
    return ""String_Node_Str"";
  }
  final Locale locale=SubtypeLocale.getSubtypeLocale(subtype);
  return StringUtils.capitalizeFirstCharacter(locale.getLanguage(),locale);
}","static String getShortDisplayName(final InputMethodSubtype subtype){
  if (SubtypeLocale.isNoLanguage(subtype)) {
    return ""String_Node_Str"";
  }
  final Locale locale=SubtypeLocale.getSubtypeLocale(subtype);
  return StringUtils.capitalizeFirstCodePoint(locale.getLanguage(),locale);
}",0.9722222222222222
87724,"/** 
 * Apply an auto-caps mode to a string. This intentionally does NOT apply manual caps mode. It only changes the capitalization if the mode is one of the auto-caps modes.
 * @param s The string to capitalize.
 * @param capitalizeMode The mode in which to capitalize.
 * @param locale The locale for capitalizing.
 * @return The capitalized string.
 */
public static String applyAutoCapsMode(final String s,final int capitalizeMode,final Locale locale){
  if (WordComposer.CAPS_MODE_AUTO_SHIFT_LOCKED == capitalizeMode) {
    return s.toUpperCase(locale);
  }
 else   if (WordComposer.CAPS_MODE_AUTO_SHIFTED == capitalizeMode) {
    return StringUtils.toTitleCase(s,locale);
  }
 else {
    return s;
  }
}","/** 
 * Apply an auto-caps mode to a string. This intentionally does NOT apply manual caps mode. It only changes the capitalization if the mode is one of the auto-caps modes.
 * @param s The string to capitalize.
 * @param capitalizeMode The mode in which to capitalize.
 * @param locale The locale for capitalizing.
 * @return The capitalized string.
 */
public static String applyAutoCapsMode(final String s,final int capitalizeMode,final Locale locale){
  if (WordComposer.CAPS_MODE_AUTO_SHIFT_LOCKED == capitalizeMode) {
    return s.toUpperCase(locale);
  }
 else   if (WordComposer.CAPS_MODE_AUTO_SHIFTED == capitalizeMode) {
    return StringUtils.capitalizeFirstCodePoint(s,locale);
  }
 else {
    return s;
  }
}",0.9769392033542976
87725,"private static String getSubtypeDisplayNameInternal(final InputMethodSubtype subtype,final Locale displayLocale){
  final String replacementString=getReplacementString(subtype,displayLocale);
  final int nameResId=subtype.getNameResId();
  final RunInLocale<String> getSubtypeName=new RunInLocale<String>(){
    @Override protected String job(    final Resources res){
      try {
        return res.getString(nameResId,replacementString);
      }
 catch (      Resources.NotFoundException e) {
        Log.w(TAG,""String_Node_Str"" + subtype.getMode() + ""String_Node_Str""+ subtype.getNameResId()+ ""String_Node_Str""+ subtype.getLocale()+ ""String_Node_Str""+ subtype.getExtraValue()+ ""String_Node_Str""+ Utils.getStackTrace());
        return ""String_Node_Str"";
      }
    }
  }
;
  return StringUtils.capitalizeFirstCharacter(getSubtypeName.runInLocale(sResources,displayLocale),displayLocale);
}","private static String getSubtypeDisplayNameInternal(final InputMethodSubtype subtype,final Locale displayLocale){
  final String replacementString=getReplacementString(subtype,displayLocale);
  final int nameResId=subtype.getNameResId();
  final RunInLocale<String> getSubtypeName=new RunInLocale<String>(){
    @Override protected String job(    final Resources res){
      try {
        return res.getString(nameResId,replacementString);
      }
 catch (      Resources.NotFoundException e) {
        Log.w(TAG,""String_Node_Str"" + subtype.getMode() + ""String_Node_Str""+ subtype.getNameResId()+ ""String_Node_Str""+ subtype.getLocale()+ ""String_Node_Str""+ subtype.getExtraValue()+ ""String_Node_Str""+ Utils.getStackTrace());
        return ""String_Node_Str"";
      }
    }
  }
;
  return StringUtils.capitalizeFirstCodePoint(getSubtypeName.runInLocale(sResources,displayLocale),displayLocale);
}",0.9910414333706606
87726,"private static String getSubtypeLocaleDisplayNameInternal(final String localeString,final Locale displayLocale){
  final Integer exceptionalNameResId=sExceptionalLocaleToNameIdsMap.get(localeString);
  final String displayName;
  if (exceptionalNameResId != null) {
    final RunInLocale<String> getExceptionalName=new RunInLocale<String>(){
      @Override protected String job(      final Resources res){
        return res.getString(exceptionalNameResId);
      }
    }
;
    displayName=getExceptionalName.runInLocale(sResources,displayLocale);
  }
 else   if (NO_LANGUAGE.equals(localeString)) {
    return sResources.getString(R.string.subtype_no_language);
  }
 else {
    final Locale locale=LocaleUtils.constructLocaleFromString(localeString);
    displayName=locale.getDisplayName(displayLocale);
  }
  return StringUtils.capitalizeFirstCharacter(displayName,displayLocale);
}","private static String getSubtypeLocaleDisplayNameInternal(final String localeString,final Locale displayLocale){
  final Integer exceptionalNameResId=sExceptionalLocaleToNameIdsMap.get(localeString);
  final String displayName;
  if (exceptionalNameResId != null) {
    final RunInLocale<String> getExceptionalName=new RunInLocale<String>(){
      @Override protected String job(      final Resources res){
        return res.getString(exceptionalNameResId);
      }
    }
;
    displayName=getExceptionalName.runInLocale(sResources,displayLocale);
  }
 else   if (NO_LANGUAGE.equals(localeString)) {
    return sResources.getString(R.string.subtype_no_language);
  }
 else {
    final Locale locale=LocaleUtils.constructLocaleFromString(localeString);
    displayName=locale.getDisplayName(displayLocale);
  }
  return StringUtils.capitalizeFirstCodePoint(displayName,displayLocale);
}",0.9909706546275396
87727,"private static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.toTitleCase(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict);
}","private static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.capitalizeFirstCodePoint(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict);
}",0.976367319378798
87728,"public Result getResults(final int capitalizeType,final Locale locale){
  final String[] gatheredSuggestions;
  final boolean hasRecommendedSuggestions;
  if (0 == mLength) {
    if (null == mBestSuggestion) {
      gatheredSuggestions=null;
      hasRecommendedSuggestions=false;
    }
 else {
      gatheredSuggestions=EMPTY_STRING_ARRAY;
      final float normalizedScore=BinaryDictionary.calcNormalizedScore(mOriginalText,mBestSuggestion,mBestScore);
      hasRecommendedSuggestions=(normalizedScore > mRecommendedThreshold);
    }
  }
 else {
    if (DBG) {
      if (mLength != mSuggestions.size()) {
        Log.e(TAG,""String_Node_Str"");
      }
      for (int i=mLength - 1; i >= 0; --i) {
        Log.i(TAG,""String_Node_Str"" + mScores[i] + ""String_Node_Str""+ mSuggestions.get(i));
      }
    }
    Collections.reverse(mSuggestions);
    StringUtils.removeDupes(mSuggestions);
    if (StringUtils.CAPITALIZE_ALL == capitalizeType) {
      for (int i=0; i < mSuggestions.size(); ++i) {
        mSuggestions.set(i,mSuggestions.get(i).toString().toUpperCase(locale));
      }
    }
 else     if (StringUtils.CAPITALIZE_FIRST == capitalizeType) {
      for (int i=0; i < mSuggestions.size(); ++i) {
        mSuggestions.set(i,StringUtils.toTitleCase(mSuggestions.get(i).toString(),locale));
      }
    }
    gatheredSuggestions=mSuggestions.toArray(EMPTY_STRING_ARRAY);
    final int bestScore=mScores[mLength - 1];
    final String bestSuggestion=mSuggestions.get(0);
    final float normalizedScore=BinaryDictionary.calcNormalizedScore(mOriginalText,bestSuggestion.toString(),bestScore);
    hasRecommendedSuggestions=(normalizedScore > mRecommendedThreshold);
    if (DBG) {
      Log.i(TAG,""String_Node_Str"" + bestSuggestion + ""String_Node_Str""+ bestScore);
      Log.i(TAG,""String_Node_Str"" + normalizedScore + ""String_Node_Str""+ mRecommendedThreshold+ ""String_Node_Str""+ hasRecommendedSuggestions);
    }
  }
  return new Result(gatheredSuggestions,hasRecommendedSuggestions);
}","public Result getResults(final int capitalizeType,final Locale locale){
  final String[] gatheredSuggestions;
  final boolean hasRecommendedSuggestions;
  if (0 == mLength) {
    if (null == mBestSuggestion) {
      gatheredSuggestions=null;
      hasRecommendedSuggestions=false;
    }
 else {
      gatheredSuggestions=EMPTY_STRING_ARRAY;
      final float normalizedScore=BinaryDictionary.calcNormalizedScore(mOriginalText,mBestSuggestion,mBestScore);
      hasRecommendedSuggestions=(normalizedScore > mRecommendedThreshold);
    }
  }
 else {
    if (DBG) {
      if (mLength != mSuggestions.size()) {
        Log.e(TAG,""String_Node_Str"");
      }
      for (int i=mLength - 1; i >= 0; --i) {
        Log.i(TAG,""String_Node_Str"" + mScores[i] + ""String_Node_Str""+ mSuggestions.get(i));
      }
    }
    Collections.reverse(mSuggestions);
    StringUtils.removeDupes(mSuggestions);
    if (StringUtils.CAPITALIZE_ALL == capitalizeType) {
      for (int i=0; i < mSuggestions.size(); ++i) {
        mSuggestions.set(i,mSuggestions.get(i).toString().toUpperCase(locale));
      }
    }
 else     if (StringUtils.CAPITALIZE_FIRST == capitalizeType) {
      for (int i=0; i < mSuggestions.size(); ++i) {
        mSuggestions.set(i,StringUtils.capitalizeFirstCodePoint(mSuggestions.get(i).toString(),locale));
      }
    }
    gatheredSuggestions=mSuggestions.toArray(EMPTY_STRING_ARRAY);
    final int bestScore=mScores[mLength - 1];
    final String bestSuggestion=mSuggestions.get(0);
    final float normalizedScore=BinaryDictionary.calcNormalizedScore(mOriginalText,bestSuggestion.toString(),bestScore);
    hasRecommendedSuggestions=(normalizedScore > mRecommendedThreshold);
    if (DBG) {
      Log.i(TAG,""String_Node_Str"" + bestSuggestion + ""String_Node_Str""+ bestScore);
      Log.i(TAG,""String_Node_Str"" + normalizedScore + ""String_Node_Str""+ mRecommendedThreshold+ ""String_Node_Str""+ hasRecommendedSuggestions);
    }
  }
  return new Result(gatheredSuggestions,hasRecommendedSuggestions);
}",0.9917355371900828
87729,"/** 
 * Helper method to test valid capitalizations of a word. If the ""text"" is lower-case, we test only the exact string. If the ""Text"" is capitalized, we test the exact string ""Text"" and the lower-cased version of it ""text"". If the ""TEXT"" is fully upper case, we test the exact string ""TEXT"", the lower-cased version of it ""text"" and the capitalized version of it ""Text"".
 */
private boolean isInDictForAnyCapitalization(final Dictionary dict,final String text,final int capitalizeType){
  if (dict.isValidWord(text))   return true;
  if (StringUtils.CAPITALIZE_NONE == capitalizeType)   return false;
  final String lowerCaseText=text.toLowerCase(mLocale);
  if (dict.isValidWord(lowerCaseText))   return true;
  if (StringUtils.CAPITALIZE_FIRST == capitalizeType)   return false;
  return dict.isValidWord(StringUtils.toTitleCase(lowerCaseText,mLocale));
}","/** 
 * Helper method to test valid capitalizations of a word. If the ""text"" is lower-case, we test only the exact string. If the ""Text"" is capitalized, we test the exact string ""Text"" and the lower-cased version of it ""text"". If the ""TEXT"" is fully upper case, we test the exact string ""TEXT"", the lower-cased version of it ""text"" and the capitalized version of it ""Text"".
 */
private boolean isInDictForAnyCapitalization(final Dictionary dict,final String text,final int capitalizeType){
  if (dict.isValidWord(text))   return true;
  if (StringUtils.CAPITALIZE_NONE == capitalizeType)   return false;
  final String lowerCaseText=text.toLowerCase(mLocale);
  if (dict.isValidWord(lowerCaseText))   return true;
  if (StringUtils.CAPITALIZE_FIRST == capitalizeType)   return false;
  return dict.isValidWord(StringUtils.capitalizeFirstAndDowncaseRest(lowerCaseText,mLocale));
}",0.9764232317423808
87730,"public void testAllShortDisplayName(){
  for (  final InputMethodSubtype subtype : mSubtypesList) {
    final String subtypeName=SubtypeLocale.getSubtypeDisplayName(subtype);
    final Locale locale=SubtypeLocale.getSubtypeLocale(subtype);
    final String spacebarText=MainKeyboardView.getShortDisplayName(subtype);
    final String languageCode=StringUtils.capitalizeFirstCharacter(locale.getLanguage(),locale);
    if (SubtypeLocale.isNoLanguage(subtype)) {
      assertEquals(subtypeName,""String_Node_Str"",spacebarText);
    }
 else {
      assertEquals(subtypeName,languageCode,spacebarText);
    }
  }
}","public void testAllShortDisplayName(){
  for (  final InputMethodSubtype subtype : mSubtypesList) {
    final String subtypeName=SubtypeLocale.getSubtypeDisplayName(subtype);
    final Locale locale=SubtypeLocale.getSubtypeLocale(subtype);
    final String spacebarText=MainKeyboardView.getShortDisplayName(subtype);
    final String languageCode=StringUtils.capitalizeFirstCodePoint(locale.getLanguage(),locale);
    if (SubtypeLocale.isNoLanguage(subtype)) {
      assertEquals(subtypeName,""String_Node_Str"",spacebarText);
    }
 else {
      assertEquals(subtypeName,languageCode,spacebarText);
    }
  }
}",0.986863711001642
87731,"private boolean isDevTeamBuild(){
  try {
    final PackageInfo packageInfo;
    packageInfo=mLatinIME.getPackageManager().getPackageInfo(mLatinIME.getPackageName(),0);
    final String versionName=packageInfo.versionName;
    return !(developerBuildRegex.matcher(versionName).find());
  }
 catch (  final NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
}","private boolean isDevTeamBuild(){
  try {
    final PackageInfo packageInfo;
    packageInfo=mLatinIME.getPackageManager().getPackageInfo(mLatinIME.getPackageName(),0);
    final String versionName=packageInfo.versionName;
    return developerBuildRegex.matcher(versionName).find();
  }
 catch (  final NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
}",0.9961587708066582
87732,"private boolean drawGestureTrailLocked(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  outBoundsRect.setEmpty();
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine roundedLine=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    final int lastTime=sinceDown - eventTimes[startIndex];
    float r1=getWidth(lastTime,params) / 2.0f;
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float r2=getWidth(elapsedTime,params) / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final float body1=r1 * params.mTrailBodyRatio;
        final float body2=r2 * params.mTrailBodyRatio;
        final Path path=roundedLine.makePath(p1x,p1y,body1,p2x,p2y,body2);
        if (path != null) {
          roundedLine.getBounds(mRoundedLineBounds);
          if (params.mTrailShadowEnabled) {
            final float shadow2=r2 * params.mTrailShadowRatio;
            paint.setShadowLayer(shadow2,0.0f,0.0f,params.mTrailColor);
            final int shadowInset=-(int)Math.ceil(shadow2);
            mRoundedLineBounds.inset(shadowInset,shadowInset);
          }
          outBoundsRect.union(mRoundedLineBounds);
          final int alpha=getAlpha(elapsedTime,params);
          paint.setAlpha(alpha);
          canvas.drawPath(path,paint);
        }
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
    }
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
      mLastInterpolatedDrawIndex=Math.max(mLastInterpolatedDrawIndex - startIndex,0);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
  }
  return newSize > 0;
}","private boolean drawGestureTrailLocked(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  outBoundsRect.setEmpty();
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine roundedLine=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    final int lastTime=sinceDown - eventTimes[startIndex];
    float r1=getWidth(lastTime,params) / 2.0f;
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float r2=getWidth(elapsedTime,params) / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final float body1=r1 * params.mTrailBodyRatio;
        final float body2=r2 * params.mTrailBodyRatio;
        final Path path=roundedLine.makePath(p1x,p1y,body1,p2x,p2y,body2);
        if (path != null) {
          roundedLine.getBounds(mRoundedLineBounds);
          if (params.mTrailShadowEnabled) {
            final float shadow2=r2 * params.mTrailShadowRatio;
            paint.setShadowLayer(shadow2,0.0f,0.0f,params.mTrailColor);
            final int shadowInset=-(int)Math.ceil(shadow2);
            mRoundedLineBounds.inset(shadowInset,shadowInset);
          }
          outBoundsRect.union(mRoundedLineBounds);
          final int alpha=getAlpha(elapsedTime,params);
          paint.setAlpha(alpha);
          canvas.drawPath(path,paint);
        }
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
    }
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
    mLastInterpolatedDrawIndex=Math.max(mLastInterpolatedDrawIndex - startIndex,0);
  }
  return newSize > 0;
}",0.952983725135624
87733,"/** 
 * Waits for publication requests to finish, closes the JsonWriter, but then deletes the backing output file.
 * @param onAbort run after the abort() operation has completed asynchronously
 */
private synchronized void abort(final Runnable onAbort){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (mHasWrittenData) {
          mJsonWriter.endArray();
          mJsonWriter.close();
          mHasWrittenData=false;
        }
      }
  finally {
        if (mFile != null) {
          mFile.delete();
        }
        if (onAbort != null) {
          onAbort.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}","/** 
 * Waits for publication requests to finish, closes the JsonWriter, but then deletes the backing output file.
 * @param onAbort run after the abort() operation has completed asynchronously
 */
private synchronized void abort(final Runnable onAbort){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (mHasWrittenData) {
          if (!mHasWrittenData) {
            mJsonWriter.beginArray();
          }
          mJsonWriter.endArray();
          mJsonWriter.close();
          mHasWrittenData=false;
        }
      }
  finally {
        if (mFile != null) {
          mFile.delete();
        }
        if (onAbort != null) {
          onAbort.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}",0.9468354430379748
87734,"/** 
 * Waits for any publication requests to finish and closes the   {@link JsonWriter} used foroutput. See class comment for details about  {@code JsonWriter} construction.
 * @param onClosed run after the close() operation has completed asynchronously
 */
private synchronized void close(final Runnable onClosed){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (mHasWrittenData) {
          mJsonWriter.endArray();
          mHasWrittenData=false;
        }
        mJsonWriter.flush();
        mJsonWriter.close();
        if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mFile);
        }
      }
 catch (      Exception e) {
        Log.d(TAG,""String_Node_Str"",e);
      }
 finally {
        if (mFile != null && mFile.exists()) {
          mFile.setWritable(false,false);
        }
        if (onClosed != null) {
          onClosed.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}","/** 
 * Waits for any publication requests to finish and closes the   {@link JsonWriter} used foroutput. See class comment for details about  {@code JsonWriter} construction.
 * @param onClosed run after the close() operation has completed asynchronously
 */
private synchronized void close(final Runnable onClosed){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (!mHasWrittenData) {
          mJsonWriter.beginArray();
        }
        mJsonWriter.endArray();
        mHasWrittenData=false;
        mJsonWriter.flush();
        mJsonWriter.close();
        if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mFile);
        }
      }
 catch (      Exception e) {
        Log.d(TAG,""String_Node_Str"",e);
      }
 finally {
        if (mFile != null && mFile.exists()) {
          mFile.setWritable(false,false);
        }
        if (onClosed != null) {
          onClosed.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}",0.9717568214456678
87735,"private boolean drawGestureTrailLocked(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  outBoundsRect.setEmpty();
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine roundedLine=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    final int lastTime=sinceDown - eventTimes[startIndex];
    float r1=getWidth(lastTime,params) / 2.0f;
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float r2=getWidth(elapsedTime,params) / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final float body1=r1 * params.mTrailBodyRatio;
        final float body2=r2 * params.mTrailBodyRatio;
        final Path path=roundedLine.makePath(p1x,p1y,body1,p2x,p2y,body2);
        if (path != null) {
          roundedLine.getBounds(mRoundedLineBounds);
          if (params.mTrailShadowEnabled) {
            final float shadow2=r2 * params.mTrailShadowRatio;
            paint.setShadowLayer(shadow2,0.0f,0.0f,params.mTrailColor);
            final int shadowInset=-(int)Math.ceil(shadow2);
            mRoundedLineBounds.inset(shadowInset,shadowInset);
          }
          outBoundsRect.union(mRoundedLineBounds);
          final int alpha=getAlpha(elapsedTime,params);
          paint.setAlpha(alpha);
          canvas.drawPath(path,paint);
        }
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
    }
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
      mLastInterpolatedDrawIndex=Math.max(mLastInterpolatedDrawIndex - startIndex,0);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
  }
  return newSize > 0;
}","private boolean drawGestureTrailLocked(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  outBoundsRect.setEmpty();
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine roundedLine=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    final int lastTime=sinceDown - eventTimes[startIndex];
    float r1=getWidth(lastTime,params) / 2.0f;
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float r2=getWidth(elapsedTime,params) / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final float body1=r1 * params.mTrailBodyRatio;
        final float body2=r2 * params.mTrailBodyRatio;
        final Path path=roundedLine.makePath(p1x,p1y,body1,p2x,p2y,body2);
        if (path != null) {
          roundedLine.getBounds(mRoundedLineBounds);
          if (params.mTrailShadowEnabled) {
            final float shadow2=r2 * params.mTrailShadowRatio;
            paint.setShadowLayer(shadow2,0.0f,0.0f,params.mTrailColor);
            final int shadowInset=-(int)Math.ceil(shadow2);
            mRoundedLineBounds.inset(shadowInset,shadowInset);
          }
          outBoundsRect.union(mRoundedLineBounds);
          final int alpha=getAlpha(elapsedTime,params);
          paint.setAlpha(alpha);
          canvas.drawPath(path,paint);
        }
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
    }
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
    mLastInterpolatedDrawIndex=Math.max(mLastInterpolatedDrawIndex - startIndex,0);
  }
  return newSize > 0;
}",0.952983725135624
87736,"protected void shiftOutWords(final int numWords){
  final int targetNumWords=mNumActualWords - numWords;
  final LinkedList<LogUnit> logUnits=getLogUnits();
  while (mNumActualWords > targetNumWords && !logUnits.isEmpty()) {
    shiftOut();
  }
}","/** 
 * Remove LogUnits from the front of the LogBuffer until   {@code numWords} have been removed.If there are less than  {@code numWords} word-containing {@link LogUnit}s, shifts out all   {@code LogUnit}s in the buffer.
 * @param numWords the number of word-containing {@link LogUnit}s to shift out
 * @return the number of actual {@code LogUnit}s shifted out
 */
protected int shiftOutWords(final int numWords){
  int numWordContainingLogUnitsShiftedOut=0;
  for (LogUnit logUnit=shiftOut(); logUnit != null && numWordContainingLogUnitsShiftedOut < numWords; logUnit=shiftOut()) {
    if (logUnit.hasWord()) {
      numWordContainingLogUnitsShiftedOut++;
    }
  }
  return numWordContainingLogUnitsShiftedOut;
}",0.1455301455301455
87737,"@Override protected void shiftOutWords(final int numWords){
  final int oldNumActualWords=getNumActualWords();
  super.shiftOutWords(numWords);
  final int numWordsShifted=oldNumActualWords - getNumActualWords();
  mNumWordsUntilSafeToSample-=numWordsShifted;
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
}","@Override protected int shiftOutWords(final int numWords){
  final int numWordContainingLogUnitsShiftedOut=super.shiftOutWords(numWords);
  mNumWordsUntilSafeToSample=Math.max(0,mNumWordsUntilSafeToSample - numWordContainingLogUnitsShiftedOut);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mNumWordsUntilSafeToSample);
  }
  return numWordContainingLogUnitsShiftedOut;
}",0.4546722454672245
87738,"protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    resetWordCounter();
  }
 else {
    logUnits=peekAtFirstNWords(1);
    publish(logUnits,false);
    shiftOutWords(1);
  }
}","protected final void publishLogUnitsAtFrontOfBuffer(){
  ArrayList<LogUnit> logUnits=peekAtFirstNWords(N_GRAM_SIZE);
  if (isSafeNGram(logUnits,N_GRAM_SIZE)) {
    publish(logUnits,true);
    shiftOutWords(N_GRAM_SIZE);
    mNumWordsUntilSafeToSample=mNumWordsBetweenNGrams;
  }
 else {
    logUnits=peekAtFirstNWords(1);
    publish(logUnits,false);
    shiftOutWords(1);
  }
}",0.9075862068965516
87739,"/** 
 * Waits for publication requests to finish, closes the JsonWriter, but then deletes the backing output file.
 * @param onAbort run after the abort() operation has completed asynchronously
 */
private synchronized void abort(final Runnable onAbort){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (mHasWrittenData) {
          mJsonWriter.endArray();
          mJsonWriter.close();
          mHasWrittenData=false;
        }
      }
  finally {
        if (mFile != null) {
          mFile.delete();
        }
        if (onAbort != null) {
          onAbort.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}","/** 
 * Waits for publication requests to finish, closes the JsonWriter, but then deletes the backing output file.
 * @param onAbort run after the abort() operation has completed asynchronously
 */
private synchronized void abort(final Runnable onAbort){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (mHasWrittenData) {
          if (!mHasWrittenData) {
            mJsonWriter.beginArray();
          }
          mJsonWriter.endArray();
          mJsonWriter.close();
          mHasWrittenData=false;
        }
      }
  finally {
        if (mFile != null) {
          mFile.delete();
        }
        if (onAbort != null) {
          onAbort.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}",0.9468354430379748
87740,"/** 
 * Waits for any publication requests to finish and closes the   {@link JsonWriter} used foroutput. See class comment for details about  {@code JsonWriter} construction.
 * @param onClosed run after the close() operation has completed asynchronously
 */
private synchronized void close(final Runnable onClosed){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (mHasWrittenData) {
          mJsonWriter.endArray();
          mHasWrittenData=false;
        }
        mJsonWriter.flush();
        mJsonWriter.close();
        if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mFile);
        }
      }
 catch (      Exception e) {
        Log.d(TAG,""String_Node_Str"",e);
      }
 finally {
        if (mFile != null && mFile.exists()) {
          mFile.setWritable(false,false);
        }
        if (onClosed != null) {
          onClosed.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}","/** 
 * Waits for any publication requests to finish and closes the   {@link JsonWriter} used foroutput. See class comment for details about  {@code JsonWriter} construction.
 * @param onClosed run after the close() operation has completed asynchronously
 */
private synchronized void close(final Runnable onClosed){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (!mHasWrittenData) {
          mJsonWriter.beginArray();
        }
        mJsonWriter.endArray();
        mHasWrittenData=false;
        mJsonWriter.flush();
        mJsonWriter.close();
        if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mFile);
        }
      }
 catch (      Exception e) {
        Log.d(TAG,""String_Node_Str"",e);
      }
 finally {
        if (mFile != null && mFile.exists()) {
          mFile.setWritable(false,false);
        }
        if (onClosed != null) {
          onClosed.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}",0.9717568214456678
87741,"/** 
 * Arrange for the UploaderService to be run on a regular basis. Any existing scheduled invocation of UploaderService is removed and optionally rescheduled. This may cause problems if this method is called so often that no scheduled invocation is ever run.  But if the delay is short enough that it will go off when the user is sleeping, then there should be no starvation.
 * @param context {@link Context} object
 * @param needsRescheduling whether to schedule a future intent to be delivered to this service
 */
public static void cancelAndRescheduleUploadingService(final Context context,final boolean needsRescheduling){
  final PendingIntent pendingIntent=getPendingIntentForService(context);
  final AlarmManager alarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  cancelAnyScheduledServiceAlarm(alarmManager,pendingIntent);
  if (needsRescheduling) {
    scheduleServiceAlarm(alarmManager,pendingIntent);
  }
}","/** 
 * Arrange for the UploaderService to be run on a regular basis. Any existing scheduled invocation of UploaderService is removed and optionally rescheduled. This may cause problems if this method is called so often that no scheduled invocation is ever run.  But if the delay is short enough that it will go off when the user is sleeping, then there should be no starvation.
 * @param context {@link Context} object
 * @param needsRescheduling whether to schedule a future intent to be delivered to this service
 */
public static void cancelAndRescheduleUploadingService(final Context context,final boolean needsRescheduling){
  final Intent intent=new Intent(context,UploaderService.class);
  final PendingIntent pendingIntent=PendingIntent.getService(context,0,intent,0);
  final AlarmManager alarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  alarmManager.cancel(pendingIntent);
  if (needsRescheduling) {
    alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,SystemClock.elapsedRealtime() + UploaderService.RUN_INTERVAL,pendingIntent);
  }
}",0.8565795958600295
87742,"private boolean isDevTeamBuild(){
  try {
    final PackageInfo packageInfo;
    packageInfo=mLatinIME.getPackageManager().getPackageInfo(mLatinIME.getPackageName(),0);
    final String versionName=packageInfo.versionName;
    return !(developerBuildRegex.matcher(versionName).find());
  }
 catch (  final NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
}","private boolean isDevTeamBuild(){
  try {
    final PackageInfo packageInfo;
    packageInfo=mLatinIME.getPackageManager().getPackageInfo(mLatinIME.getPackageName(),0);
    final String versionName=packageInfo.versionName;
    return developerBuildRegex.matcher(versionName).find();
  }
 catch (  final NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
}",0.9961587708066582
87743,"/** 
 * Waits for publication requests to finish, closes the JsonWriter, but then deletes the backing output file.
 * @param onAbort run after the abort() operation has completed asynchronously
 */
private synchronized void abort(final Runnable onAbort){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (mHasWrittenData) {
          mJsonWriter.endArray();
          mJsonWriter.close();
          mHasWrittenData=false;
        }
      }
  finally {
        if (mFile != null) {
          mFile.delete();
        }
        if (onAbort != null) {
          onAbort.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}","/** 
 * Waits for publication requests to finish, closes the JsonWriter, but then deletes the backing output file.
 * @param onAbort run after the abort() operation has completed asynchronously
 */
private synchronized void abort(final Runnable onAbort){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (mHasWrittenData) {
          if (!mHasWrittenData) {
            mJsonWriter.beginArray();
          }
          mJsonWriter.endArray();
          mJsonWriter.close();
          mHasWrittenData=false;
        }
      }
  finally {
        if (mFile != null) {
          mFile.delete();
        }
        if (onAbort != null) {
          onAbort.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}",0.9468354430379748
87744,"/** 
 * Waits for any publication requests to finish and closes the   {@link JsonWriter} used foroutput. See class comment for details about  {@code JsonWriter} construction.
 * @param onClosed run after the close() operation has completed asynchronously
 */
private synchronized void close(final Runnable onClosed){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (mHasWrittenData) {
          mJsonWriter.endArray();
          mHasWrittenData=false;
        }
        mJsonWriter.flush();
        mJsonWriter.close();
        if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mFile);
        }
      }
 catch (      Exception e) {
        Log.d(TAG,""String_Node_Str"",e);
      }
 finally {
        if (mFile != null && mFile.exists()) {
          mFile.setWritable(false,false);
        }
        if (onClosed != null) {
          onClosed.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}","/** 
 * Waits for any publication requests to finish and closes the   {@link JsonWriter} used foroutput. See class comment for details about  {@code JsonWriter} construction.
 * @param onClosed run after the close() operation has completed asynchronously
 */
private synchronized void close(final Runnable onClosed){
  mExecutor.submit(new Callable<Object>(){
    @Override public Object call() throws Exception {
      try {
        if (!mHasWrittenData) {
          mJsonWriter.beginArray();
        }
        mJsonWriter.endArray();
        mHasWrittenData=false;
        mJsonWriter.flush();
        mJsonWriter.close();
        if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mFile);
        }
      }
 catch (      Exception e) {
        Log.d(TAG,""String_Node_Str"",e);
      }
 finally {
        if (mFile != null && mFile.exists()) {
          mFile.setWritable(false,false);
        }
        if (onClosed != null) {
          onClosed.run();
        }
      }
      return null;
    }
  }
);
  removeAnyScheduledFlush();
  mExecutor.shutdown();
}",0.9717568214456678
87745,"private boolean drawGestureTrailLocked(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  outBoundsRect.setEmpty();
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine roundedLine=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    final int lastTime=sinceDown - eventTimes[startIndex];
    float r1=getWidth(lastTime,params) / 2.0f;
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float r2=getWidth(elapsedTime,params) / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final float body1=r1 * params.mTrailBodyRatio;
        final float body2=r2 * params.mTrailBodyRatio;
        final Path path=roundedLine.makePath(p1x,p1y,body1,p2x,p2y,body2);
        if (path != null) {
          roundedLine.getBounds(mRoundedLineBounds);
          if (params.mTrailShadowEnabled) {
            final float shadow2=r2 * params.mTrailShadowRatio;
            paint.setShadowLayer(shadow2,0.0f,0.0f,params.mTrailColor);
            final int shadowInset=-(int)Math.ceil(shadow2);
            mRoundedLineBounds.inset(shadowInset,shadowInset);
          }
          outBoundsRect.union(mRoundedLineBounds);
          final int alpha=getAlpha(elapsedTime,params);
          paint.setAlpha(alpha);
          canvas.drawPath(path,paint);
        }
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
    }
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
      mLastInterpolatedDrawIndex=Math.max(mLastInterpolatedDrawIndex - startIndex,0);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
  }
  return newSize > 0;
}","private boolean drawGestureTrailLocked(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  outBoundsRect.setEmpty();
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine roundedLine=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    final int lastTime=sinceDown - eventTimes[startIndex];
    float r1=getWidth(lastTime,params) / 2.0f;
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float r2=getWidth(elapsedTime,params) / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final float body1=r1 * params.mTrailBodyRatio;
        final float body2=r2 * params.mTrailBodyRatio;
        final Path path=roundedLine.makePath(p1x,p1y,body1,p2x,p2y,body2);
        if (path != null) {
          roundedLine.getBounds(mRoundedLineBounds);
          if (params.mTrailShadowEnabled) {
            final float shadow2=r2 * params.mTrailShadowRatio;
            paint.setShadowLayer(shadow2,0.0f,0.0f,params.mTrailColor);
            final int shadowInset=-(int)Math.ceil(shadow2);
            mRoundedLineBounds.inset(shadowInset,shadowInset);
          }
          outBoundsRect.union(mRoundedLineBounds);
          final int alpha=getAlpha(elapsedTime,params);
          paint.setAlpha(alpha);
          canvas.drawPath(path,paint);
        }
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
    }
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
    mLastInterpolatedDrawIndex=Math.max(mLastInterpolatedDrawIndex - startIndex,0);
  }
  return newSize > 0;
}",0.952983725135624
87746,"@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ mLastSelectionStart+ ""String_Node_Str""+ mLastSelectionEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final boolean expectingUpdateSelectionFromLogger=ResearchLogger.getAndClearLatinIMEExpectingUpdateSelection();
    ResearchLogger.latinIME_onUpdateSelection(mLastSelectionStart,mLastSelectionEnd,oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd,mExpectingUpdateSelection,expectingUpdateSelectionFromLogger,mConnection);
    if (expectingUpdateSelectionFromLogger) {
      return;
    }
  }
  final boolean selectionChanged=(newSelStart != composingSpanEnd || newSelEnd != composingSpanEnd) && mLastSelectionStart != newSelStart;
  final boolean noComposingSpan=composingSpanStart == -1 && composingSpanEnd == -1;
  if (!mExpectingUpdateSelection && !mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart)) {
    mSpaceState=SPACE_STATE_NONE;
    if ((!mWordComposer.isComposingWord()) || selectionChanged || noComposingSpan) {
      resetEntireInputState(newSelStart);
    }
    mHandler.postResumeSuggestions();
    mKeyboardSwitcher.updateShiftState();
  }
  mExpectingUpdateSelection=false;
  mLastSelectionStart=newSelStart;
  mLastSelectionEnd=newSelEnd;
  mSubtypeState.currentSubtypeUsed();
}","@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ mLastSelectionStart+ ""String_Node_Str""+ mLastSelectionEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final boolean expectingUpdateSelectionFromLogger=ResearchLogger.getAndClearLatinIMEExpectingUpdateSelection();
    ResearchLogger.latinIME_onUpdateSelection(mLastSelectionStart,mLastSelectionEnd,oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd,mExpectingUpdateSelection,expectingUpdateSelectionFromLogger,mConnection);
    if (expectingUpdateSelectionFromLogger) {
      return;
    }
  }
  final boolean selectionChanged=(newSelStart != composingSpanEnd || newSelEnd != composingSpanEnd) && mLastSelectionStart != newSelStart;
  final boolean noComposingSpan=composingSpanStart == -1 && composingSpanEnd == -1;
  if (!mExpectingUpdateSelection && !mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart)) {
    mSpaceState=SPACE_STATE_NONE;
    if ((!mWordComposer.isComposingWord()) || selectionChanged || noComposingSpan) {
      resetEntireInputState(newSelStart);
    }
    mHandler.postResumeSuggestions();
    mRecapitalizeStatus=null;
    mKeyboardSwitcher.updateShiftState();
  }
  mExpectingUpdateSelection=false;
  mLastSelectionStart=newSelStart;
  mLastSelectionEnd=newSelEnd;
  mSubtypeState.currentSubtypeUsed();
}",0.9917400881057268
87747,"@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ mLastSelectionStart+ ""String_Node_Str""+ mLastSelectionEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final boolean expectingUpdateSelectionFromLogger=ResearchLogger.getAndClearLatinIMEExpectingUpdateSelection();
    ResearchLogger.latinIME_onUpdateSelection(mLastSelectionStart,mLastSelectionEnd,oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd,mExpectingUpdateSelection,expectingUpdateSelectionFromLogger,mConnection);
    if (expectingUpdateSelectionFromLogger) {
      return;
    }
  }
  final boolean selectionChanged=(newSelStart != composingSpanEnd || newSelEnd != composingSpanEnd) && mLastSelectionStart != newSelStart;
  final boolean noComposingSpan=composingSpanStart == -1 && composingSpanEnd == -1;
  if (!mExpectingUpdateSelection && !mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart)) {
    mSpaceState=SPACE_STATE_NONE;
    if ((!mWordComposer.isComposingWord()) || selectionChanged || noComposingSpan) {
      resetEntireInputState(newSelStart);
    }
    mHandler.postResumeSuggestions();
    mKeyboardSwitcher.updateShiftState();
  }
  mExpectingUpdateSelection=false;
  mLastSelectionStart=newSelStart;
  mLastSelectionEnd=newSelEnd;
  mSubtypeState.currentSubtypeUsed();
}","@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ mLastSelectionStart+ ""String_Node_Str""+ mLastSelectionEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final boolean expectingUpdateSelectionFromLogger=ResearchLogger.getAndClearLatinIMEExpectingUpdateSelection();
    ResearchLogger.latinIME_onUpdateSelection(mLastSelectionStart,mLastSelectionEnd,oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd,mExpectingUpdateSelection,expectingUpdateSelectionFromLogger,mConnection);
    if (expectingUpdateSelectionFromLogger) {
      return;
    }
  }
  final boolean selectionChanged=(newSelStart != composingSpanEnd || newSelEnd != composingSpanEnd) && mLastSelectionStart != newSelStart;
  final boolean noComposingSpan=composingSpanStart == -1 && composingSpanEnd == -1;
  if (!mExpectingUpdateSelection && !mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart)) {
    mSpaceState=SPACE_STATE_NONE;
    if ((!mWordComposer.isComposingWord()) || selectionChanged || noComposingSpan) {
      resetEntireInputState(newSelStart);
    }
    mHandler.postResumeSuggestions();
    mRecapitalizeStatus=null;
    mKeyboardSwitcher.updateShiftState();
  }
  mExpectingUpdateSelection=false;
  mLastSelectionStart=newSelStart;
  mLastSelectionEnd=newSelEnd;
  mSubtypeState.currentSubtypeUsed();
}",0.9917400881057268
87748,"@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ mLastSelectionStart+ ""String_Node_Str""+ mLastSelectionEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final boolean expectingUpdateSelectionFromLogger=ResearchLogger.getAndClearLatinIMEExpectingUpdateSelection();
    ResearchLogger.latinIME_onUpdateSelection(mLastSelectionStart,mLastSelectionEnd,oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd,mExpectingUpdateSelection,expectingUpdateSelectionFromLogger,mConnection);
    if (expectingUpdateSelectionFromLogger) {
      return;
    }
  }
  final boolean selectionChanged=(newSelStart != composingSpanEnd || newSelEnd != composingSpanEnd) && mLastSelectionStart != newSelStart;
  final boolean noComposingSpan=composingSpanStart == -1 && composingSpanEnd == -1;
  if (!mExpectingUpdateSelection && !mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart)) {
    mSpaceState=SPACE_STATE_NONE;
    if ((!mWordComposer.isComposingWord()) || selectionChanged || noComposingSpan) {
      resetEntireInputState(newSelStart);
    }
    mHandler.postResumeSuggestions();
    mKeyboardSwitcher.updateShiftState();
  }
  mExpectingUpdateSelection=false;
  mLastSelectionStart=newSelStart;
  mLastSelectionEnd=newSelEnd;
  mSubtypeState.currentSubtypeUsed();
}","@Override public void onUpdateSelection(final int oldSelStart,final int oldSelEnd,final int newSelStart,final int newSelEnd,final int composingSpanStart,final int composingSpanEnd){
  super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd);
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + oldSelStart + ""String_Node_Str""+ oldSelEnd+ ""String_Node_Str""+ mLastSelectionStart+ ""String_Node_Str""+ mLastSelectionEnd+ ""String_Node_Str""+ newSelStart+ ""String_Node_Str""+ newSelEnd+ ""String_Node_Str""+ composingSpanStart+ ""String_Node_Str""+ composingSpanEnd);
  }
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    final boolean expectingUpdateSelectionFromLogger=ResearchLogger.getAndClearLatinIMEExpectingUpdateSelection();
    ResearchLogger.latinIME_onUpdateSelection(mLastSelectionStart,mLastSelectionEnd,oldSelStart,oldSelEnd,newSelStart,newSelEnd,composingSpanStart,composingSpanEnd,mExpectingUpdateSelection,expectingUpdateSelectionFromLogger,mConnection);
    if (expectingUpdateSelectionFromLogger) {
      return;
    }
  }
  final boolean selectionChanged=(newSelStart != composingSpanEnd || newSelEnd != composingSpanEnd) && mLastSelectionStart != newSelStart;
  final boolean noComposingSpan=composingSpanStart == -1 && composingSpanEnd == -1;
  if (!mExpectingUpdateSelection && !mConnection.isBelatedExpectedUpdate(oldSelStart,newSelStart)) {
    mSpaceState=SPACE_STATE_NONE;
    if ((!mWordComposer.isComposingWord()) || selectionChanged || noComposingSpan) {
      resetEntireInputState(newSelStart);
    }
    mHandler.postResumeSuggestions();
    mRecapitalizeStatus=null;
    mKeyboardSwitcher.updateShiftState();
  }
  mExpectingUpdateSelection=false;
  mLastSelectionStart=newSelStart;
  mLastSelectionEnd=newSelEnd;
  mSubtypeState.currentSubtypeUsed();
}",0.9917400881057268
87749,"@Override public void onDisplayCompletions(final CompletionInfo[] applicationSpecifiedCompletions){
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"");
    if (applicationSpecifiedCompletions != null) {
      for (int i=0; i < applicationSpecifiedCompletions.length; i++) {
        Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ applicationSpecifiedCompletions[i]);
      }
    }
  }
  if (!mSettings.getCurrent().isApplicationSpecifiedCompletionsOn())   return;
  mApplicationSpecifiedCompletions=applicationSpecifiedCompletions;
  if (applicationSpecifiedCompletions == null) {
    clearSuggestionStrip();
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.latinIME_onDisplayCompletions(null);
    }
    return;
  }
  final ArrayList<SuggestedWords.SuggestedWordInfo> applicationSuggestedWords=SuggestedWords.getFromApplicationSpecifiedCompletions(applicationSpecifiedCompletions);
  final SuggestedWords suggestedWords=new SuggestedWords(applicationSuggestedWords,false,false,false,false,false);
  final boolean isAutoCorrection=false;
  setSuggestedWords(suggestedWords,isAutoCorrection);
  setAutoCorrectionIndicator(isAutoCorrection);
  setSuggestionStripShown(true);
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    ResearchLogger.latinIME_onDisplayCompletions(applicationSpecifiedCompletions);
  }
}","@Override public void onDisplayCompletions(final CompletionInfo[] applicationSpecifiedCompletions){
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"");
    if (applicationSpecifiedCompletions != null) {
      for (int i=0; i < applicationSpecifiedCompletions.length; i++) {
        Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ applicationSpecifiedCompletions[i]);
      }
    }
  }
  if (!mSettings.getCurrent().isApplicationSpecifiedCompletionsOn())   return;
  mApplicationSpecifiedCompletions=CompletionInfoUtils.removeNulls(applicationSpecifiedCompletions);
  if (applicationSpecifiedCompletions == null) {
    clearSuggestionStrip();
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.latinIME_onDisplayCompletions(null);
    }
    return;
  }
  final ArrayList<SuggestedWords.SuggestedWordInfo> applicationSuggestedWords=SuggestedWords.getFromApplicationSpecifiedCompletions(applicationSpecifiedCompletions);
  final SuggestedWords suggestedWords=new SuggestedWords(applicationSuggestedWords,false,false,false,false,false);
  final boolean isAutoCorrection=false;
  setSuggestedWords(suggestedWords,isAutoCorrection);
  setAutoCorrectionIndicator(isAutoCorrection);
  setSuggestionStripShown(true);
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    ResearchLogger.latinIME_onDisplayCompletions(applicationSpecifiedCompletions);
  }
}",0.9653158086893028
87750,"public void commitCompletion(final CompletionInfo completionInfo){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  final CharSequence text=completionInfo.getText();
  mCommittedTextBeforeComposingText.append(text);
  mCurrentCursorPosition+=text.length() - mComposingText.length();
  mComposingText.setLength(0);
  if (null != mIC) {
    mIC.commitCompletion(completionInfo);
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.richInputConnection_commitCompletion(completionInfo);
    }
  }
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
}","public void commitCompletion(final CompletionInfo completionInfo){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  CharSequence text=completionInfo.getText();
  if (null == text)   text=""String_Node_Str"";
  mCommittedTextBeforeComposingText.append(text);
  mCurrentCursorPosition+=text.length() - mComposingText.length();
  mComposingText.setLength(0);
  if (null != mIC) {
    mIC.commitCompletion(completionInfo);
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.richInputConnection_commitCompletion(completionInfo);
    }
  }
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
}",0.9573820395738204
87751,"@Override public void onDisplayCompletions(final CompletionInfo[] applicationSpecifiedCompletions){
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"");
    if (applicationSpecifiedCompletions != null) {
      for (int i=0; i < applicationSpecifiedCompletions.length; i++) {
        Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ applicationSpecifiedCompletions[i]);
      }
    }
  }
  if (!mSettings.getCurrent().isApplicationSpecifiedCompletionsOn())   return;
  mApplicationSpecifiedCompletions=applicationSpecifiedCompletions;
  if (applicationSpecifiedCompletions == null) {
    clearSuggestionStrip();
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.latinIME_onDisplayCompletions(null);
    }
    return;
  }
  final ArrayList<SuggestedWords.SuggestedWordInfo> applicationSuggestedWords=SuggestedWords.getFromApplicationSpecifiedCompletions(applicationSpecifiedCompletions);
  final SuggestedWords suggestedWords=new SuggestedWords(applicationSuggestedWords,false,false,false,false,false);
  final boolean isAutoCorrection=false;
  setSuggestedWords(suggestedWords,isAutoCorrection);
  setAutoCorrectionIndicator(isAutoCorrection);
  setSuggestionStripShown(true);
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    ResearchLogger.latinIME_onDisplayCompletions(applicationSpecifiedCompletions);
  }
}","@Override public void onDisplayCompletions(final CompletionInfo[] applicationSpecifiedCompletions){
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"");
    if (applicationSpecifiedCompletions != null) {
      for (int i=0; i < applicationSpecifiedCompletions.length; i++) {
        Log.i(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ applicationSpecifiedCompletions[i]);
      }
    }
  }
  if (!mSettings.getCurrent().isApplicationSpecifiedCompletionsOn())   return;
  mApplicationSpecifiedCompletions=CompletionInfoUtils.removeNulls(applicationSpecifiedCompletions);
  if (applicationSpecifiedCompletions == null) {
    clearSuggestionStrip();
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.latinIME_onDisplayCompletions(null);
    }
    return;
  }
  final ArrayList<SuggestedWords.SuggestedWordInfo> applicationSuggestedWords=SuggestedWords.getFromApplicationSpecifiedCompletions(applicationSpecifiedCompletions);
  final SuggestedWords suggestedWords=new SuggestedWords(applicationSuggestedWords,false,false,false,false,false);
  final boolean isAutoCorrection=false;
  setSuggestedWords(suggestedWords,isAutoCorrection);
  setAutoCorrectionIndicator(isAutoCorrection);
  setSuggestionStripShown(true);
  if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
    ResearchLogger.latinIME_onDisplayCompletions(applicationSpecifiedCompletions);
  }
}",0.9653158086893028
87752,"public void commitCompletion(final CompletionInfo completionInfo){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  final CharSequence text=completionInfo.getText();
  mCommittedTextBeforeComposingText.append(text);
  mCurrentCursorPosition+=text.length() - mComposingText.length();
  mComposingText.setLength(0);
  if (null != mIC) {
    mIC.commitCompletion(completionInfo);
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.richInputConnection_commitCompletion(completionInfo);
    }
  }
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
}","public void commitCompletion(final CompletionInfo completionInfo){
  if (DEBUG_BATCH_NESTING)   checkBatchEdit();
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
  CharSequence text=completionInfo.getText();
  if (null == text)   text=""String_Node_Str"";
  mCommittedTextBeforeComposingText.append(text);
  mCurrentCursorPosition+=text.length() - mComposingText.length();
  mComposingText.setLength(0);
  if (null != mIC) {
    mIC.commitCompletion(completionInfo);
    if (ProductionFlag.USES_DEVELOPMENT_ONLY_DIAGNOSTICS) {
      ResearchLogger.richInputConnection_commitCompletion(completionInfo);
    }
  }
  if (DEBUG_PREVIOUS_TEXT)   checkConsistencyForDebug();
}",0.9573820395738204
87753,"@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=mCurrentString.length();
      for (      int i : currentGroup.mChars)       mCurrentString.append(Character.toChars(i));
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0)       return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mPositions.getLast().length);
    }
  }
 while (true);
}","@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=mCurrentString.length();
      for (      int i : currentGroup.mChars) {
        mCurrentString.append(Character.toChars(i));
      }
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        currentPos.length=mCurrentString.length();
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0) {
        return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
      }
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mPositions.getLast().length);
    }
  }
 while (true);
}",0.9606712113266912
87754,"/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String string){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  final int[] codePoints=getCodePoints(string);
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,codePoints[index]);
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (codePoints.length - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < codePoints.length && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != codePoints[newIndex])       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePoints.length) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePoints.length);
  if (index < codePoints.length)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !codePoints.equals(checker.toString()))   return null;
  return currentGroup;
}","/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String string){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  final int[] codePoints=getCodePoints(string);
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,codePoints[index]);
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (codePoints.length - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < codePoints.length && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != codePoints[newIndex])       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePoints.length) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePoints.length);
  if (index < codePoints.length)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !string.equals(checker.toString()))   return null;
  return currentGroup;
}",0.9935897435897436
87755,"@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=mCurrentString.length();
      for (      int i : currentGroup.mChars)       mCurrentString.append(Character.toChars(i));
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0)       return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mPositions.getLast().length);
    }
  }
 while (true);
}","@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=mCurrentString.length();
      for (      int i : currentGroup.mChars) {
        mCurrentString.append(Character.toChars(i));
      }
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        currentPos.length=mCurrentString.length();
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0) {
        return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
      }
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mPositions.getLast().length);
    }
  }
 while (true);
}",0.9606712113266912
87756,"/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String string){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  final int[] codePoints=getCodePoints(string);
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,codePoints[index]);
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (codePoints.length - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < codePoints.length && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != codePoints[newIndex])       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePoints.length) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePoints.length);
  if (index < codePoints.length)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !codePoints.equals(checker.toString()))   return null;
  return currentGroup;
}","/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String string){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  final int[] codePoints=getCodePoints(string);
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,codePoints[index]);
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (codePoints.length - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < codePoints.length && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != codePoints[newIndex])       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePoints.length) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePoints.length);
  if (index < codePoints.length)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !string.equals(checker.toString()))   return null;
  return currentGroup;
}",0.9935897435897436
87757,"public static int getCapitalizationType(final String text){
  if (!Character.isUpperCase(text.codePointAt(0)))   return CAPITALIZE_NONE;
  final int len=text.length();
  int capsCount=1;
  int letterCount=1;
  for (int i=1; i < len; i=text.offsetByCodePoints(i,1)) {
    if (1 != capsCount && letterCount != capsCount)     break;
    final int codePoint=text.codePointAt(i);
    if (Character.isUpperCase(codePoint)) {
      ++capsCount;
      ++letterCount;
    }
 else     if (Character.isLetter(codePoint)) {
      ++letterCount;
    }
  }
  if (1 == capsCount)   return CAPITALIZE_FIRST;
  return (letterCount == capsCount ? CAPITALIZE_ALL : CAPITALIZE_NONE);
}","public static int getCapitalizationType(final String text){
  final int len=text.length();
  int index=0;
  for (; index < len; index=text.offsetByCodePoints(index,1)) {
    if (Character.isLetter(text.codePointAt(index))) {
      break;
    }
  }
  if (index == len)   return CAPITALIZE_NONE;
  if (!Character.isUpperCase(text.codePointAt(index))) {
    return CAPITALIZE_NONE;
  }
  int capsCount=1;
  int letterCount=1;
  for (index=text.offsetByCodePoints(index,1); index < len; index=text.offsetByCodePoints(index,1)) {
    if (1 != capsCount && letterCount != capsCount)     break;
    final int codePoint=text.codePointAt(index);
    if (Character.isUpperCase(codePoint)) {
      ++capsCount;
      ++letterCount;
    }
 else     if (Character.isLetter(codePoint)) {
      ++letterCount;
    }
  }
  if (1 == capsCount)   return CAPITALIZE_FIRST;
  return (letterCount == capsCount ? CAPITALIZE_ALL : CAPITALIZE_NONE);
}",0.1520100502512562
87758,"public static String toTitleCase(final String s,final Locale locale){
  if (s.length() <= 1) {
    return s;
  }
  return s.toUpperCase(locale).charAt(0) + s.substring(1);
}","public static String toTitleCase(final String s,final Locale locale){
  if (s.length() <= 1) {
    return s;
  }
  final int cutoff=s.offsetByCodePoints(0,1);
  return s.substring(0,cutoff).toUpperCase(locale) + s.substring(cutoff).toLowerCase(locale);
}",0.7213114754098361
87759,"@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=mCurrentString.length();
      for (      int i : currentGroup.mChars)       mCurrentString.append(Character.toChars(i));
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0)       return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mPositions.getLast().length);
    }
  }
 while (true);
}","@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=mCurrentString.length();
      for (      int i : currentGroup.mChars) {
        mCurrentString.append(Character.toChars(i));
      }
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        currentPos.length=mCurrentString.length();
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0) {
        return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
      }
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mPositions.getLast().length);
    }
  }
 while (true);
}",0.9606712113266912
87760,"/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String string){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  final int[] codePoints=getCodePoints(string);
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,codePoints[index]);
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (codePoints.length - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < codePoints.length && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != codePoints[newIndex])       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePoints.length) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePoints.length);
  if (index < codePoints.length)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !codePoints.equals(checker.toString()))   return null;
  return currentGroup;
}","/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String string){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  final int[] codePoints=getCodePoints(string);
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,codePoints[index]);
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (codePoints.length - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < codePoints.length && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != codePoints[newIndex])       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePoints.length) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePoints.length);
  if (index < codePoints.length)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !string.equals(checker.toString()))   return null;
  return currentGroup;
}",0.9935897435897436
87761,"public static int getCapitalizationType(final String text){
  if (!Character.isUpperCase(text.codePointAt(0)))   return CAPITALIZE_NONE;
  final int len=text.length();
  int capsCount=1;
  int letterCount=1;
  for (int i=1; i < len; i=text.offsetByCodePoints(i,1)) {
    if (1 != capsCount && letterCount != capsCount)     break;
    final int codePoint=text.codePointAt(i);
    if (Character.isUpperCase(codePoint)) {
      ++capsCount;
      ++letterCount;
    }
 else     if (Character.isLetter(codePoint)) {
      ++letterCount;
    }
  }
  if (1 == capsCount)   return CAPITALIZE_FIRST;
  return (letterCount == capsCount ? CAPITALIZE_ALL : CAPITALIZE_NONE);
}","public static int getCapitalizationType(final String text){
  final int len=text.length();
  int index=0;
  for (; index < len; index=text.offsetByCodePoints(index,1)) {
    if (Character.isLetter(text.codePointAt(index))) {
      break;
    }
  }
  if (index == len)   return CAPITALIZE_NONE;
  if (!Character.isUpperCase(text.codePointAt(index))) {
    return CAPITALIZE_NONE;
  }
  int capsCount=1;
  int letterCount=1;
  for (index=text.offsetByCodePoints(index,1); index < len; index=text.offsetByCodePoints(index,1)) {
    if (1 != capsCount && letterCount != capsCount)     break;
    final int codePoint=text.codePointAt(index);
    if (Character.isUpperCase(codePoint)) {
      ++capsCount;
      ++letterCount;
    }
 else     if (Character.isLetter(codePoint)) {
      ++letterCount;
    }
  }
  if (1 == capsCount)   return CAPITALIZE_FIRST;
  return (letterCount == capsCount ? CAPITALIZE_ALL : CAPITALIZE_NONE);
}",0.1520100502512562
87762,"public static String toTitleCase(final String s,final Locale locale){
  if (s.length() <= 1) {
    return s;
  }
  return s.toUpperCase(locale).charAt(0) + s.substring(1);
}","public static String toTitleCase(final String s,final Locale locale){
  if (s.length() <= 1) {
    return s;
  }
  final int cutoff=s.offsetByCodePoints(0,1);
  return s.substring(0,cutoff).toUpperCase(locale) + s.substring(cutoff).toLowerCase(locale);
}",0.7213114754098361
87763,"static String getShortDisplayName(final InputMethodSubtype subtype){
  if (SubtypeLocale.isNoLanguage(subtype)) {
    return ""String_Node_Str"";
  }
  final Locale locale=SubtypeLocale.getSubtypeLocale(subtype);
  return StringUtils.capitalizeFirstCharacter(locale.getLanguage(),locale);
}","static String getShortDisplayName(final InputMethodSubtype subtype){
  if (SubtypeLocale.isNoLanguage(subtype)) {
    return ""String_Node_Str"";
  }
  final Locale locale=SubtypeLocale.getSubtypeLocale(subtype);
  return StringUtils.capitalizeFirstCodePoint(locale.getLanguage(),locale);
}",0.9722222222222222
87764,"/** 
 * Apply an auto-caps mode to a string. This intentionally does NOT apply manual caps mode. It only changes the capitalization if the mode is one of the auto-caps modes.
 * @param s The string to capitalize.
 * @param capitalizeMode The mode in which to capitalize.
 * @param locale The locale for capitalizing.
 * @return The capitalized string.
 */
public static String applyAutoCapsMode(final String s,final int capitalizeMode,final Locale locale){
  if (WordComposer.CAPS_MODE_AUTO_SHIFT_LOCKED == capitalizeMode) {
    return s.toUpperCase(locale);
  }
 else   if (WordComposer.CAPS_MODE_AUTO_SHIFTED == capitalizeMode) {
    return StringUtils.toTitleCase(s,locale);
  }
 else {
    return s;
  }
}","/** 
 * Apply an auto-caps mode to a string. This intentionally does NOT apply manual caps mode. It only changes the capitalization if the mode is one of the auto-caps modes.
 * @param s The string to capitalize.
 * @param capitalizeMode The mode in which to capitalize.
 * @param locale The locale for capitalizing.
 * @return The capitalized string.
 */
public static String applyAutoCapsMode(final String s,final int capitalizeMode,final Locale locale){
  if (WordComposer.CAPS_MODE_AUTO_SHIFT_LOCKED == capitalizeMode) {
    return s.toUpperCase(locale);
  }
 else   if (WordComposer.CAPS_MODE_AUTO_SHIFTED == capitalizeMode) {
    return StringUtils.capitalizeFirstCodePoint(s,locale);
  }
 else {
    return s;
  }
}",0.9769392033542976
87765,"private static String getSubtypeDisplayNameInternal(final InputMethodSubtype subtype,final Locale displayLocale){
  final String replacementString=getReplacementString(subtype,displayLocale);
  final int nameResId=subtype.getNameResId();
  final RunInLocale<String> getSubtypeName=new RunInLocale<String>(){
    @Override protected String job(    final Resources res){
      try {
        return res.getString(nameResId,replacementString);
      }
 catch (      Resources.NotFoundException e) {
        Log.w(TAG,""String_Node_Str"" + subtype.getMode() + ""String_Node_Str""+ subtype.getNameResId()+ ""String_Node_Str""+ subtype.getLocale()+ ""String_Node_Str""+ subtype.getExtraValue()+ ""String_Node_Str""+ Utils.getStackTrace());
        return ""String_Node_Str"";
      }
    }
  }
;
  return StringUtils.capitalizeFirstCharacter(getSubtypeName.runInLocale(sResources,displayLocale),displayLocale);
}","private static String getSubtypeDisplayNameInternal(final InputMethodSubtype subtype,final Locale displayLocale){
  final String replacementString=getReplacementString(subtype,displayLocale);
  final int nameResId=subtype.getNameResId();
  final RunInLocale<String> getSubtypeName=new RunInLocale<String>(){
    @Override protected String job(    final Resources res){
      try {
        return res.getString(nameResId,replacementString);
      }
 catch (      Resources.NotFoundException e) {
        Log.w(TAG,""String_Node_Str"" + subtype.getMode() + ""String_Node_Str""+ subtype.getNameResId()+ ""String_Node_Str""+ subtype.getLocale()+ ""String_Node_Str""+ subtype.getExtraValue()+ ""String_Node_Str""+ Utils.getStackTrace());
        return ""String_Node_Str"";
      }
    }
  }
;
  return StringUtils.capitalizeFirstCodePoint(getSubtypeName.runInLocale(sResources,displayLocale),displayLocale);
}",0.9910414333706606
87766,"private static String getSubtypeLocaleDisplayNameInternal(final String localeString,final Locale displayLocale){
  final Integer exceptionalNameResId=sExceptionalLocaleToNameIdsMap.get(localeString);
  final String displayName;
  if (exceptionalNameResId != null) {
    final RunInLocale<String> getExceptionalName=new RunInLocale<String>(){
      @Override protected String job(      final Resources res){
        return res.getString(exceptionalNameResId);
      }
    }
;
    displayName=getExceptionalName.runInLocale(sResources,displayLocale);
  }
 else   if (NO_LANGUAGE.equals(localeString)) {
    return sResources.getString(R.string.subtype_no_language);
  }
 else {
    final Locale locale=LocaleUtils.constructLocaleFromString(localeString);
    displayName=locale.getDisplayName(displayLocale);
  }
  return StringUtils.capitalizeFirstCharacter(displayName,displayLocale);
}","private static String getSubtypeLocaleDisplayNameInternal(final String localeString,final Locale displayLocale){
  final Integer exceptionalNameResId=sExceptionalLocaleToNameIdsMap.get(localeString);
  final String displayName;
  if (exceptionalNameResId != null) {
    final RunInLocale<String> getExceptionalName=new RunInLocale<String>(){
      @Override protected String job(      final Resources res){
        return res.getString(exceptionalNameResId);
      }
    }
;
    displayName=getExceptionalName.runInLocale(sResources,displayLocale);
  }
 else   if (NO_LANGUAGE.equals(localeString)) {
    return sResources.getString(R.string.subtype_no_language);
  }
 else {
    final Locale locale=LocaleUtils.constructLocaleFromString(localeString);
    displayName=locale.getDisplayName(displayLocale);
  }
  return StringUtils.capitalizeFirstCodePoint(displayName,displayLocale);
}",0.9909706546275396
87767,"private static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.toTitleCase(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict);
}","private static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.capitalizeFirstCodePoint(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict);
}",0.976367319378798
87768,"public Result getResults(final int capitalizeType,final Locale locale){
  final String[] gatheredSuggestions;
  final boolean hasRecommendedSuggestions;
  if (0 == mLength) {
    if (null == mBestSuggestion) {
      gatheredSuggestions=null;
      hasRecommendedSuggestions=false;
    }
 else {
      gatheredSuggestions=EMPTY_STRING_ARRAY;
      final float normalizedScore=BinaryDictionary.calcNormalizedScore(mOriginalText,mBestSuggestion,mBestScore);
      hasRecommendedSuggestions=(normalizedScore > mRecommendedThreshold);
    }
  }
 else {
    if (DBG) {
      if (mLength != mSuggestions.size()) {
        Log.e(TAG,""String_Node_Str"");
      }
      for (int i=mLength - 1; i >= 0; --i) {
        Log.i(TAG,""String_Node_Str"" + mScores[i] + ""String_Node_Str""+ mSuggestions.get(i));
      }
    }
    Collections.reverse(mSuggestions);
    StringUtils.removeDupes(mSuggestions);
    if (StringUtils.CAPITALIZE_ALL == capitalizeType) {
      for (int i=0; i < mSuggestions.size(); ++i) {
        mSuggestions.set(i,mSuggestions.get(i).toString().toUpperCase(locale));
      }
    }
 else     if (StringUtils.CAPITALIZE_FIRST == capitalizeType) {
      for (int i=0; i < mSuggestions.size(); ++i) {
        mSuggestions.set(i,StringUtils.toTitleCase(mSuggestions.get(i).toString(),locale));
      }
    }
    gatheredSuggestions=mSuggestions.toArray(EMPTY_STRING_ARRAY);
    final int bestScore=mScores[mLength - 1];
    final String bestSuggestion=mSuggestions.get(0);
    final float normalizedScore=BinaryDictionary.calcNormalizedScore(mOriginalText,bestSuggestion.toString(),bestScore);
    hasRecommendedSuggestions=(normalizedScore > mRecommendedThreshold);
    if (DBG) {
      Log.i(TAG,""String_Node_Str"" + bestSuggestion + ""String_Node_Str""+ bestScore);
      Log.i(TAG,""String_Node_Str"" + normalizedScore + ""String_Node_Str""+ mRecommendedThreshold+ ""String_Node_Str""+ hasRecommendedSuggestions);
    }
  }
  return new Result(gatheredSuggestions,hasRecommendedSuggestions);
}","public Result getResults(final int capitalizeType,final Locale locale){
  final String[] gatheredSuggestions;
  final boolean hasRecommendedSuggestions;
  if (0 == mLength) {
    if (null == mBestSuggestion) {
      gatheredSuggestions=null;
      hasRecommendedSuggestions=false;
    }
 else {
      gatheredSuggestions=EMPTY_STRING_ARRAY;
      final float normalizedScore=BinaryDictionary.calcNormalizedScore(mOriginalText,mBestSuggestion,mBestScore);
      hasRecommendedSuggestions=(normalizedScore > mRecommendedThreshold);
    }
  }
 else {
    if (DBG) {
      if (mLength != mSuggestions.size()) {
        Log.e(TAG,""String_Node_Str"");
      }
      for (int i=mLength - 1; i >= 0; --i) {
        Log.i(TAG,""String_Node_Str"" + mScores[i] + ""String_Node_Str""+ mSuggestions.get(i));
      }
    }
    Collections.reverse(mSuggestions);
    StringUtils.removeDupes(mSuggestions);
    if (StringUtils.CAPITALIZE_ALL == capitalizeType) {
      for (int i=0; i < mSuggestions.size(); ++i) {
        mSuggestions.set(i,mSuggestions.get(i).toString().toUpperCase(locale));
      }
    }
 else     if (StringUtils.CAPITALIZE_FIRST == capitalizeType) {
      for (int i=0; i < mSuggestions.size(); ++i) {
        mSuggestions.set(i,StringUtils.capitalizeFirstCodePoint(mSuggestions.get(i).toString(),locale));
      }
    }
    gatheredSuggestions=mSuggestions.toArray(EMPTY_STRING_ARRAY);
    final int bestScore=mScores[mLength - 1];
    final String bestSuggestion=mSuggestions.get(0);
    final float normalizedScore=BinaryDictionary.calcNormalizedScore(mOriginalText,bestSuggestion.toString(),bestScore);
    hasRecommendedSuggestions=(normalizedScore > mRecommendedThreshold);
    if (DBG) {
      Log.i(TAG,""String_Node_Str"" + bestSuggestion + ""String_Node_Str""+ bestScore);
      Log.i(TAG,""String_Node_Str"" + normalizedScore + ""String_Node_Str""+ mRecommendedThreshold+ ""String_Node_Str""+ hasRecommendedSuggestions);
    }
  }
  return new Result(gatheredSuggestions,hasRecommendedSuggestions);
}",0.9917355371900828
87769,"/** 
 * Helper method to test valid capitalizations of a word. If the ""text"" is lower-case, we test only the exact string. If the ""Text"" is capitalized, we test the exact string ""Text"" and the lower-cased version of it ""text"". If the ""TEXT"" is fully upper case, we test the exact string ""TEXT"", the lower-cased version of it ""text"" and the capitalized version of it ""Text"".
 */
private boolean isInDictForAnyCapitalization(final Dictionary dict,final String text,final int capitalizeType){
  if (dict.isValidWord(text))   return true;
  if (StringUtils.CAPITALIZE_NONE == capitalizeType)   return false;
  final String lowerCaseText=text.toLowerCase(mLocale);
  if (dict.isValidWord(lowerCaseText))   return true;
  if (StringUtils.CAPITALIZE_FIRST == capitalizeType)   return false;
  return dict.isValidWord(StringUtils.toTitleCase(lowerCaseText,mLocale));
}","/** 
 * Helper method to test valid capitalizations of a word. If the ""text"" is lower-case, we test only the exact string. If the ""Text"" is capitalized, we test the exact string ""Text"" and the lower-cased version of it ""text"". If the ""TEXT"" is fully upper case, we test the exact string ""TEXT"", the lower-cased version of it ""text"" and the capitalized version of it ""Text"".
 */
private boolean isInDictForAnyCapitalization(final Dictionary dict,final String text,final int capitalizeType){
  if (dict.isValidWord(text))   return true;
  if (StringUtils.CAPITALIZE_NONE == capitalizeType)   return false;
  final String lowerCaseText=text.toLowerCase(mLocale);
  if (dict.isValidWord(lowerCaseText))   return true;
  if (StringUtils.CAPITALIZE_FIRST == capitalizeType)   return false;
  return dict.isValidWord(StringUtils.capitalizeFirstAndDowncaseRest(lowerCaseText,mLocale));
}",0.9764232317423808
87770,"public void testAllShortDisplayName(){
  for (  final InputMethodSubtype subtype : mSubtypesList) {
    final String subtypeName=SubtypeLocale.getSubtypeDisplayName(subtype);
    final Locale locale=SubtypeLocale.getSubtypeLocale(subtype);
    final String spacebarText=MainKeyboardView.getShortDisplayName(subtype);
    final String languageCode=StringUtils.capitalizeFirstCharacter(locale.getLanguage(),locale);
    if (SubtypeLocale.isNoLanguage(subtype)) {
      assertEquals(subtypeName,""String_Node_Str"",spacebarText);
    }
 else {
      assertEquals(subtypeName,languageCode,spacebarText);
    }
  }
}","public void testAllShortDisplayName(){
  for (  final InputMethodSubtype subtype : mSubtypesList) {
    final String subtypeName=SubtypeLocale.getSubtypeDisplayName(subtype);
    final Locale locale=SubtypeLocale.getSubtypeLocale(subtype);
    final String spacebarText=MainKeyboardView.getShortDisplayName(subtype);
    final String languageCode=StringUtils.capitalizeFirstCodePoint(locale.getLanguage(),locale);
    if (SubtypeLocale.isNoLanguage(subtype)) {
      assertEquals(subtypeName,""String_Node_Str"",spacebarText);
    }
 else {
      assertEquals(subtypeName,languageCode,spacebarText);
    }
  }
}",0.986863711001642
87771,"public static int getCapitalizationType(final String text){
  if (!Character.isUpperCase(text.codePointAt(0)))   return CAPITALIZE_NONE;
  final int len=text.length();
  int capsCount=1;
  int letterCount=1;
  for (int i=1; i < len; i=text.offsetByCodePoints(i,1)) {
    if (1 != capsCount && letterCount != capsCount)     break;
    final int codePoint=text.codePointAt(i);
    if (Character.isUpperCase(codePoint)) {
      ++capsCount;
      ++letterCount;
    }
 else     if (Character.isLetter(codePoint)) {
      ++letterCount;
    }
  }
  if (1 == capsCount)   return CAPITALIZE_FIRST;
  return (letterCount == capsCount ? CAPITALIZE_ALL : CAPITALIZE_NONE);
}","public static int getCapitalizationType(final String text){
  final int len=text.length();
  int index=0;
  for (; index < len; index=text.offsetByCodePoints(index,1)) {
    if (Character.isLetter(text.codePointAt(index))) {
      break;
    }
  }
  if (index == len)   return CAPITALIZE_NONE;
  if (!Character.isUpperCase(text.codePointAt(index))) {
    return CAPITALIZE_NONE;
  }
  int capsCount=1;
  int letterCount=1;
  for (index=text.offsetByCodePoints(index,1); index < len; index=text.offsetByCodePoints(index,1)) {
    if (1 != capsCount && letterCount != capsCount)     break;
    final int codePoint=text.codePointAt(index);
    if (Character.isUpperCase(codePoint)) {
      ++capsCount;
      ++letterCount;
    }
 else     if (Character.isLetter(codePoint)) {
      ++letterCount;
    }
  }
  if (1 == capsCount)   return CAPITALIZE_FIRST;
  return (letterCount == capsCount ? CAPITALIZE_ALL : CAPITALIZE_NONE);
}",0.1520100502512562
87772,"public static String toTitleCase(final String s,final Locale locale){
  if (s.length() <= 1) {
    return s;
  }
  return s.toUpperCase(locale).charAt(0) + s.substring(1);
}","public static String toTitleCase(final String s,final Locale locale){
  if (s.length() <= 1) {
    return s;
  }
  final int cutoff=s.offsetByCodePoints(0,1);
  return s.substring(0,cutoff).toUpperCase(locale) + s.substring(cutoff).toLowerCase(locale);
}",0.7213114754098361
87773,"static String getShortDisplayName(final InputMethodSubtype subtype){
  if (SubtypeLocale.isNoLanguage(subtype)) {
    return ""String_Node_Str"";
  }
  final Locale locale=SubtypeLocale.getSubtypeLocale(subtype);
  return StringUtils.capitalizeFirstCharacter(locale.getLanguage(),locale);
}","static String getShortDisplayName(final InputMethodSubtype subtype){
  if (SubtypeLocale.isNoLanguage(subtype)) {
    return ""String_Node_Str"";
  }
  final Locale locale=SubtypeLocale.getSubtypeLocale(subtype);
  return StringUtils.capitalizeFirstCodePoint(locale.getLanguage(),locale);
}",0.9722222222222222
87774,"/** 
 * Apply an auto-caps mode to a string. This intentionally does NOT apply manual caps mode. It only changes the capitalization if the mode is one of the auto-caps modes.
 * @param s The string to capitalize.
 * @param capitalizeMode The mode in which to capitalize.
 * @param locale The locale for capitalizing.
 * @return The capitalized string.
 */
public static String applyAutoCapsMode(final String s,final int capitalizeMode,final Locale locale){
  if (WordComposer.CAPS_MODE_AUTO_SHIFT_LOCKED == capitalizeMode) {
    return s.toUpperCase(locale);
  }
 else   if (WordComposer.CAPS_MODE_AUTO_SHIFTED == capitalizeMode) {
    return StringUtils.toTitleCase(s,locale);
  }
 else {
    return s;
  }
}","/** 
 * Apply an auto-caps mode to a string. This intentionally does NOT apply manual caps mode. It only changes the capitalization if the mode is one of the auto-caps modes.
 * @param s The string to capitalize.
 * @param capitalizeMode The mode in which to capitalize.
 * @param locale The locale for capitalizing.
 * @return The capitalized string.
 */
public static String applyAutoCapsMode(final String s,final int capitalizeMode,final Locale locale){
  if (WordComposer.CAPS_MODE_AUTO_SHIFT_LOCKED == capitalizeMode) {
    return s.toUpperCase(locale);
  }
 else   if (WordComposer.CAPS_MODE_AUTO_SHIFTED == capitalizeMode) {
    return StringUtils.capitalizeFirstCodePoint(s,locale);
  }
 else {
    return s;
  }
}",0.9769392033542976
87775,"private static String getSubtypeDisplayNameInternal(final InputMethodSubtype subtype,final Locale displayLocale){
  final String replacementString=getReplacementString(subtype,displayLocale);
  final int nameResId=subtype.getNameResId();
  final RunInLocale<String> getSubtypeName=new RunInLocale<String>(){
    @Override protected String job(    final Resources res){
      try {
        return res.getString(nameResId,replacementString);
      }
 catch (      Resources.NotFoundException e) {
        Log.w(TAG,""String_Node_Str"" + subtype.getMode() + ""String_Node_Str""+ subtype.getNameResId()+ ""String_Node_Str""+ subtype.getLocale()+ ""String_Node_Str""+ subtype.getExtraValue()+ ""String_Node_Str""+ Utils.getStackTrace());
        return ""String_Node_Str"";
      }
    }
  }
;
  return StringUtils.capitalizeFirstCharacter(getSubtypeName.runInLocale(sResources,displayLocale),displayLocale);
}","private static String getSubtypeDisplayNameInternal(final InputMethodSubtype subtype,final Locale displayLocale){
  final String replacementString=getReplacementString(subtype,displayLocale);
  final int nameResId=subtype.getNameResId();
  final RunInLocale<String> getSubtypeName=new RunInLocale<String>(){
    @Override protected String job(    final Resources res){
      try {
        return res.getString(nameResId,replacementString);
      }
 catch (      Resources.NotFoundException e) {
        Log.w(TAG,""String_Node_Str"" + subtype.getMode() + ""String_Node_Str""+ subtype.getNameResId()+ ""String_Node_Str""+ subtype.getLocale()+ ""String_Node_Str""+ subtype.getExtraValue()+ ""String_Node_Str""+ Utils.getStackTrace());
        return ""String_Node_Str"";
      }
    }
  }
;
  return StringUtils.capitalizeFirstCodePoint(getSubtypeName.runInLocale(sResources,displayLocale),displayLocale);
}",0.9910414333706606
87776,"private static String getSubtypeLocaleDisplayNameInternal(final String localeString,final Locale displayLocale){
  final Integer exceptionalNameResId=sExceptionalLocaleToNameIdsMap.get(localeString);
  final String displayName;
  if (exceptionalNameResId != null) {
    final RunInLocale<String> getExceptionalName=new RunInLocale<String>(){
      @Override protected String job(      final Resources res){
        return res.getString(exceptionalNameResId);
      }
    }
;
    displayName=getExceptionalName.runInLocale(sResources,displayLocale);
  }
 else   if (NO_LANGUAGE.equals(localeString)) {
    return sResources.getString(R.string.subtype_no_language);
  }
 else {
    final Locale locale=LocaleUtils.constructLocaleFromString(localeString);
    displayName=locale.getDisplayName(displayLocale);
  }
  return StringUtils.capitalizeFirstCharacter(displayName,displayLocale);
}","private static String getSubtypeLocaleDisplayNameInternal(final String localeString,final Locale displayLocale){
  final Integer exceptionalNameResId=sExceptionalLocaleToNameIdsMap.get(localeString);
  final String displayName;
  if (exceptionalNameResId != null) {
    final RunInLocale<String> getExceptionalName=new RunInLocale<String>(){
      @Override protected String job(      final Resources res){
        return res.getString(exceptionalNameResId);
      }
    }
;
    displayName=getExceptionalName.runInLocale(sResources,displayLocale);
  }
 else   if (NO_LANGUAGE.equals(localeString)) {
    return sResources.getString(R.string.subtype_no_language);
  }
 else {
    final Locale locale=LocaleUtils.constructLocaleFromString(localeString);
    displayName=locale.getDisplayName(displayLocale);
  }
  return StringUtils.capitalizeFirstCodePoint(displayName,displayLocale);
}",0.9909706546275396
87777,"private static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.toTitleCase(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict);
}","private static SuggestedWordInfo getTransformedSuggestedWordInfo(final SuggestedWordInfo wordInfo,final Locale locale,final boolean isAllUpperCase,final boolean isFirstCharCapitalized,final int trailingSingleQuotesCount){
  final StringBuilder sb=new StringBuilder(wordInfo.mWord.length());
  if (isAllUpperCase) {
    sb.append(wordInfo.mWord.toUpperCase(locale));
  }
 else   if (isFirstCharCapitalized) {
    sb.append(StringUtils.capitalizeFirstCodePoint(wordInfo.mWord,locale));
  }
 else {
    sb.append(wordInfo.mWord);
  }
  for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
    sb.appendCodePoint(Constants.CODE_SINGLE_QUOTE);
  }
  return new SuggestedWordInfo(sb.toString(),wordInfo.mScore,wordInfo.mKind,wordInfo.mSourceDict);
}",0.976367319378798
87778,"public Result getResults(final int capitalizeType,final Locale locale){
  final String[] gatheredSuggestions;
  final boolean hasRecommendedSuggestions;
  if (0 == mLength) {
    if (null == mBestSuggestion) {
      gatheredSuggestions=null;
      hasRecommendedSuggestions=false;
    }
 else {
      gatheredSuggestions=EMPTY_STRING_ARRAY;
      final float normalizedScore=BinaryDictionary.calcNormalizedScore(mOriginalText,mBestSuggestion,mBestScore);
      hasRecommendedSuggestions=(normalizedScore > mRecommendedThreshold);
    }
  }
 else {
    if (DBG) {
      if (mLength != mSuggestions.size()) {
        Log.e(TAG,""String_Node_Str"");
      }
      for (int i=mLength - 1; i >= 0; --i) {
        Log.i(TAG,""String_Node_Str"" + mScores[i] + ""String_Node_Str""+ mSuggestions.get(i));
      }
    }
    Collections.reverse(mSuggestions);
    StringUtils.removeDupes(mSuggestions);
    if (StringUtils.CAPITALIZE_ALL == capitalizeType) {
      for (int i=0; i < mSuggestions.size(); ++i) {
        mSuggestions.set(i,mSuggestions.get(i).toString().toUpperCase(locale));
      }
    }
 else     if (StringUtils.CAPITALIZE_FIRST == capitalizeType) {
      for (int i=0; i < mSuggestions.size(); ++i) {
        mSuggestions.set(i,StringUtils.toTitleCase(mSuggestions.get(i).toString(),locale));
      }
    }
    gatheredSuggestions=mSuggestions.toArray(EMPTY_STRING_ARRAY);
    final int bestScore=mScores[mLength - 1];
    final String bestSuggestion=mSuggestions.get(0);
    final float normalizedScore=BinaryDictionary.calcNormalizedScore(mOriginalText,bestSuggestion.toString(),bestScore);
    hasRecommendedSuggestions=(normalizedScore > mRecommendedThreshold);
    if (DBG) {
      Log.i(TAG,""String_Node_Str"" + bestSuggestion + ""String_Node_Str""+ bestScore);
      Log.i(TAG,""String_Node_Str"" + normalizedScore + ""String_Node_Str""+ mRecommendedThreshold+ ""String_Node_Str""+ hasRecommendedSuggestions);
    }
  }
  return new Result(gatheredSuggestions,hasRecommendedSuggestions);
}","public Result getResults(final int capitalizeType,final Locale locale){
  final String[] gatheredSuggestions;
  final boolean hasRecommendedSuggestions;
  if (0 == mLength) {
    if (null == mBestSuggestion) {
      gatheredSuggestions=null;
      hasRecommendedSuggestions=false;
    }
 else {
      gatheredSuggestions=EMPTY_STRING_ARRAY;
      final float normalizedScore=BinaryDictionary.calcNormalizedScore(mOriginalText,mBestSuggestion,mBestScore);
      hasRecommendedSuggestions=(normalizedScore > mRecommendedThreshold);
    }
  }
 else {
    if (DBG) {
      if (mLength != mSuggestions.size()) {
        Log.e(TAG,""String_Node_Str"");
      }
      for (int i=mLength - 1; i >= 0; --i) {
        Log.i(TAG,""String_Node_Str"" + mScores[i] + ""String_Node_Str""+ mSuggestions.get(i));
      }
    }
    Collections.reverse(mSuggestions);
    StringUtils.removeDupes(mSuggestions);
    if (StringUtils.CAPITALIZE_ALL == capitalizeType) {
      for (int i=0; i < mSuggestions.size(); ++i) {
        mSuggestions.set(i,mSuggestions.get(i).toString().toUpperCase(locale));
      }
    }
 else     if (StringUtils.CAPITALIZE_FIRST == capitalizeType) {
      for (int i=0; i < mSuggestions.size(); ++i) {
        mSuggestions.set(i,StringUtils.capitalizeFirstCodePoint(mSuggestions.get(i).toString(),locale));
      }
    }
    gatheredSuggestions=mSuggestions.toArray(EMPTY_STRING_ARRAY);
    final int bestScore=mScores[mLength - 1];
    final String bestSuggestion=mSuggestions.get(0);
    final float normalizedScore=BinaryDictionary.calcNormalizedScore(mOriginalText,bestSuggestion.toString(),bestScore);
    hasRecommendedSuggestions=(normalizedScore > mRecommendedThreshold);
    if (DBG) {
      Log.i(TAG,""String_Node_Str"" + bestSuggestion + ""String_Node_Str""+ bestScore);
      Log.i(TAG,""String_Node_Str"" + normalizedScore + ""String_Node_Str""+ mRecommendedThreshold+ ""String_Node_Str""+ hasRecommendedSuggestions);
    }
  }
  return new Result(gatheredSuggestions,hasRecommendedSuggestions);
}",0.9917355371900828
87779,"/** 
 * Helper method to test valid capitalizations of a word. If the ""text"" is lower-case, we test only the exact string. If the ""Text"" is capitalized, we test the exact string ""Text"" and the lower-cased version of it ""text"". If the ""TEXT"" is fully upper case, we test the exact string ""TEXT"", the lower-cased version of it ""text"" and the capitalized version of it ""Text"".
 */
private boolean isInDictForAnyCapitalization(final Dictionary dict,final String text,final int capitalizeType){
  if (dict.isValidWord(text))   return true;
  if (StringUtils.CAPITALIZE_NONE == capitalizeType)   return false;
  final String lowerCaseText=text.toLowerCase(mLocale);
  if (dict.isValidWord(lowerCaseText))   return true;
  if (StringUtils.CAPITALIZE_FIRST == capitalizeType)   return false;
  return dict.isValidWord(StringUtils.toTitleCase(lowerCaseText,mLocale));
}","/** 
 * Helper method to test valid capitalizations of a word. If the ""text"" is lower-case, we test only the exact string. If the ""Text"" is capitalized, we test the exact string ""Text"" and the lower-cased version of it ""text"". If the ""TEXT"" is fully upper case, we test the exact string ""TEXT"", the lower-cased version of it ""text"" and the capitalized version of it ""Text"".
 */
private boolean isInDictForAnyCapitalization(final Dictionary dict,final String text,final int capitalizeType){
  if (dict.isValidWord(text))   return true;
  if (StringUtils.CAPITALIZE_NONE == capitalizeType)   return false;
  final String lowerCaseText=text.toLowerCase(mLocale);
  if (dict.isValidWord(lowerCaseText))   return true;
  if (StringUtils.CAPITALIZE_FIRST == capitalizeType)   return false;
  return dict.isValidWord(StringUtils.capitalizeFirstAndDowncaseRest(lowerCaseText,mLocale));
}",0.9764232317423808
87780,"public void testAllShortDisplayName(){
  for (  final InputMethodSubtype subtype : mSubtypesList) {
    final String subtypeName=SubtypeLocale.getSubtypeDisplayName(subtype);
    final Locale locale=SubtypeLocale.getSubtypeLocale(subtype);
    final String spacebarText=MainKeyboardView.getShortDisplayName(subtype);
    final String languageCode=StringUtils.capitalizeFirstCharacter(locale.getLanguage(),locale);
    if (SubtypeLocale.isNoLanguage(subtype)) {
      assertEquals(subtypeName,""String_Node_Str"",spacebarText);
    }
 else {
      assertEquals(subtypeName,languageCode,spacebarText);
    }
  }
}","public void testAllShortDisplayName(){
  for (  final InputMethodSubtype subtype : mSubtypesList) {
    final String subtypeName=SubtypeLocale.getSubtypeDisplayName(subtype);
    final Locale locale=SubtypeLocale.getSubtypeLocale(subtype);
    final String spacebarText=MainKeyboardView.getShortDisplayName(subtype);
    final String languageCode=StringUtils.capitalizeFirstCodePoint(locale.getLanguage(),locale);
    if (SubtypeLocale.isNoLanguage(subtype)) {
      assertEquals(subtypeName,""String_Node_Str"",spacebarText);
    }
 else {
      assertEquals(subtypeName,languageCode,spacebarText);
    }
  }
}",0.986863711001642
87781,"public static int getCapitalizationType(final String text){
  if (!Character.isUpperCase(text.codePointAt(0)))   return CAPITALIZE_NONE;
  final int len=text.length();
  int capsCount=1;
  int letterCount=1;
  for (int i=1; i < len; i=text.offsetByCodePoints(i,1)) {
    if (1 != capsCount && letterCount != capsCount)     break;
    final int codePoint=text.codePointAt(i);
    if (Character.isUpperCase(codePoint)) {
      ++capsCount;
      ++letterCount;
    }
 else     if (Character.isLetter(codePoint)) {
      ++letterCount;
    }
  }
  if (1 == capsCount)   return CAPITALIZE_FIRST;
  return (letterCount == capsCount ? CAPITALIZE_ALL : CAPITALIZE_NONE);
}","public static int getCapitalizationType(final String text){
  final int len=text.length();
  int index=0;
  for (; index < len; index=text.offsetByCodePoints(index,1)) {
    if (Character.isLetter(text.codePointAt(index))) {
      break;
    }
  }
  if (index == len)   return CAPITALIZE_NONE;
  if (!Character.isUpperCase(text.codePointAt(index))) {
    return CAPITALIZE_NONE;
  }
  int capsCount=1;
  int letterCount=1;
  for (index=text.offsetByCodePoints(index,1); index < len; index=text.offsetByCodePoints(index,1)) {
    if (1 != capsCount && letterCount != capsCount)     break;
    final int codePoint=text.codePointAt(index);
    if (Character.isUpperCase(codePoint)) {
      ++capsCount;
      ++letterCount;
    }
 else     if (Character.isLetter(codePoint)) {
      ++letterCount;
    }
  }
  if (1 == capsCount)   return CAPITALIZE_FIRST;
  return (letterCount == capsCount ? CAPITALIZE_ALL : CAPITALIZE_NONE);
}",0.1520100502512562
87782,"public static String toTitleCase(final String s,final Locale locale){
  if (s.length() <= 1) {
    return s;
  }
  return s.toUpperCase(locale).charAt(0) + s.substring(1);
}","public static String toTitleCase(final String s,final Locale locale){
  if (s.length() <= 1) {
    return s;
  }
  final int cutoff=s.offsetByCodePoints(0,1);
  return s.substring(0,cutoff).toUpperCase(locale) + s.substring(cutoff).toLowerCase(locale);
}",0.7213114754098361
87783,"@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(mCurrentString.length() - currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=currentGroup.mChars.length;
      for (      int i : currentGroup.mChars)       mCurrentString.append(Character.toChars(i));
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0)       return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mCurrentString.length() - mPositions.getLast().length);
    }
  }
 while (true);
}","@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=mCurrentString.length();
      for (      int i : currentGroup.mChars)       mCurrentString.append(Character.toChars(i));
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0)       return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mPositions.getLast().length);
    }
  }
 while (true);
}",0.8171701112877583
87784,"/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String s){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  CharGroup currentGroup;
  final int codePointCountInS=s.codePointCount(0,s.length());
  do {
    int indexOfGroup=findIndexOfChar(node,s.codePointAt(index));
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (s.length() - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < s.length() && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != s.codePointAt(newIndex))       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePointCountInS) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePointCountInS);
  if (index < codePointCountInS)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !s.equals(checker.toString()))   return null;
  return currentGroup;
}","/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String string){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  final int[] codePoints=getCodePoints(string);
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,codePoints[index]);
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (codePoints.length - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < codePoints.length && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != codePoints[newIndex])       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePoints.length) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePoints.length);
  if (index < codePoints.length)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !codePoints.equals(checker.toString()))   return null;
  return currentGroup;
}",0.8491171749598716
87785,"public void testGetTerminalPosition(){
  File file=null;
  try {
    file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",getContext().getCacheDir());
  }
 catch (  IOException e) {
  }
  assertNotNull(file);
  final FusionDictionary dict=new FusionDictionary(new Node(),new FusionDictionary.DictionaryOptions(new HashMap<String,String>(),false,false));
  addUnigrams(sWords.size(),dict,sWords,null);
  timeWritingDictToFile(file,dict,VERSION3_WITH_DYNAMIC_UPDATE);
  final FusionDictionaryBufferInterface buffer=getBuffer(file,USE_BYTE_ARRAY);
  try {
    final String longWord=""String_Node_Str"";
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,longWord));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,null));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,""String_Node_Str""));
  }
 catch (  IOException e) {
  }
catch (  UnsupportedFormatException e) {
  }
  long sum=0;
  for (int i=0; i < sWords.size(); ++i) {
    final long time=runGetTerminalPosition(buffer,sWords.get(i),i,true);
    sum+=time == -1 ? 0 : time;
  }
  Log.d(TAG,""String_Node_Str"" + (((double)sum) / sWords.size() / 1000000));
  final Random random=new Random((int)System.currentTimeMillis());
  for (int i=0; i < 1000; ++i) {
    final String word=generateWord(random.nextInt());
    if (sWords.indexOf(word) != -1)     continue;
    runGetTerminalPosition(buffer,word,i,false);
  }
}","public void testGetTerminalPosition(){
  File file=null;
  try {
    file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",getContext().getCacheDir());
  }
 catch (  IOException e) {
  }
  assertNotNull(file);
  final FusionDictionary dict=new FusionDictionary(new Node(),new FusionDictionary.DictionaryOptions(new HashMap<String,String>(),false,false));
  addUnigrams(sWords.size(),dict,sWords,null);
  timeWritingDictToFile(file,dict,VERSION3_WITH_DYNAMIC_UPDATE);
  final FusionDictionaryBufferInterface buffer=getBuffer(file,USE_BYTE_ARRAY);
  try {
    final String longWord=""String_Node_Str"";
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,longWord));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,null));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,""String_Node_Str""));
  }
 catch (  IOException e) {
  }
catch (  UnsupportedFormatException e) {
  }
  long sum=0;
  for (int i=0; i < sWords.size(); ++i) {
    final long time=runGetTerminalPosition(buffer,sWords.get(i),i,true);
    sum+=time == -1 ? 0 : time;
  }
  Log.d(TAG,""String_Node_Str"" + (((double)sum) / sWords.size() / 1000000));
  final Random random=new Random((int)System.currentTimeMillis());
  for (int i=0; i < 1000; ++i) {
    final String word=generateWord(random);
    if (sWords.indexOf(word) != -1)     continue;
    runGetTerminalPosition(buffer,word,i,false);
  }
}",0.9966329966329966
87786,"public BinaryDictIOTests(){
  super();
  final Random random=new Random(123456);
  sWords.clear();
  generateWords(MAX_UNIGRAMS,random);
  for (int i=0; i < sWords.size(); ++i) {
    sChainBigrams.put(i,new ArrayList<Integer>());
    if (i > 0) {
      sChainBigrams.get(i - 1).add(i);
    }
  }
  sStarBigrams.put(0,new ArrayList<Integer>());
  for (int i=1; i < sWords.size(); ++i) {
    sStarBigrams.get(0).add(i);
  }
}","public BinaryDictIOTests(){
  super();
  final long time=System.currentTimeMillis();
  Log.e(TAG,""String_Node_Str"" + time);
  final Random random=new Random(time);
  sWords.clear();
  generateWords(MAX_UNIGRAMS,random);
  for (int i=0; i < sWords.size(); ++i) {
    sChainBigrams.put(i,new ArrayList<Integer>());
    if (i > 0) {
      sChainBigrams.get(i - 1).add(i);
    }
  }
  sStarBigrams.put(0,new ArrayList<Integer>());
  for (int i=1; i < sWords.size(); ++i) {
    sStarBigrams.get(0).add(i);
  }
}",0.8977395048439182
87787,"/** 
 * Generates a random word.
 */
private String generateWord(final int value){
  final int lengthOfChars=CHARACTERS.length;
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  long lvalue=Math.abs((long)value);
  while (lvalue > 0) {
    builder.append(CHARACTERS[(int)(lvalue % lengthOfChars)]);
    lvalue/=lengthOfChars;
  }
  return builder.toString();
}","/** 
 * Generates a random word.
 */
private String generateWord(final Random random){
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  int count=random.nextInt() % 30;
  while (count > 0) {
    final long r=Math.abs(random.nextInt());
    if (r < 0)     continue;
    builder.appendCodePoint((int)(20 + r % (0x10FFFF - 20)));
    --count;
  }
  return builder.toString();
}",0.5425950196592398
87788,"private void generateWords(final int number,final Random random){
  final Set<String> wordSet=CollectionUtils.newHashSet();
  while (wordSet.size() < number) {
    wordSet.add(generateWord(random.nextInt()));
  }
  sWords.addAll(wordSet);
}","private void generateWords(final int number,final Random random){
  final Set<String> wordSet=CollectionUtils.newHashSet();
  while (wordSet.size() < number) {
    wordSet.add(generateWord(random));
  }
  sWords.addAll(wordSet);
}",0.9787234042553192
87789,"@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(mCurrentString.length() - currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=currentGroup.mChars.length;
      for (      int i : currentGroup.mChars)       mCurrentString.append(Character.toChars(i));
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0)       return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mCurrentString.length() - mPositions.getLast().length);
    }
  }
 while (true);
}","@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=mCurrentString.length();
      for (      int i : currentGroup.mChars)       mCurrentString.append(Character.toChars(i));
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0)       return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mPositions.getLast().length);
    }
  }
 while (true);
}",0.8171701112877583
87790,"/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String s){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  CharGroup currentGroup;
  final int codePointCountInS=s.codePointCount(0,s.length());
  do {
    int indexOfGroup=findIndexOfChar(node,s.codePointAt(index));
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (s.length() - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < s.length() && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != s.codePointAt(newIndex))       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePointCountInS) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePointCountInS);
  if (index < codePointCountInS)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !s.equals(checker.toString()))   return null;
  return currentGroup;
}","/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String string){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  final int[] codePoints=getCodePoints(string);
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,codePoints[index]);
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (codePoints.length - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < codePoints.length && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != codePoints[newIndex])       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePoints.length) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePoints.length);
  if (index < codePoints.length)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !codePoints.equals(checker.toString()))   return null;
  return currentGroup;
}",0.8491171749598716
87791,"public void testGetTerminalPosition(){
  File file=null;
  try {
    file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",getContext().getCacheDir());
  }
 catch (  IOException e) {
  }
  assertNotNull(file);
  final FusionDictionary dict=new FusionDictionary(new Node(),new FusionDictionary.DictionaryOptions(new HashMap<String,String>(),false,false));
  addUnigrams(sWords.size(),dict,sWords,null);
  timeWritingDictToFile(file,dict,VERSION3_WITH_DYNAMIC_UPDATE);
  final FusionDictionaryBufferInterface buffer=getBuffer(file,USE_BYTE_ARRAY);
  try {
    final String longWord=""String_Node_Str"";
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,longWord));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,null));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,""String_Node_Str""));
  }
 catch (  IOException e) {
  }
catch (  UnsupportedFormatException e) {
  }
  long sum=0;
  for (int i=0; i < sWords.size(); ++i) {
    final long time=runGetTerminalPosition(buffer,sWords.get(i),i,true);
    sum+=time == -1 ? 0 : time;
  }
  Log.d(TAG,""String_Node_Str"" + (((double)sum) / sWords.size() / 1000000));
  final Random random=new Random((int)System.currentTimeMillis());
  for (int i=0; i < 1000; ++i) {
    final String word=generateWord(random.nextInt());
    if (sWords.indexOf(word) != -1)     continue;
    runGetTerminalPosition(buffer,word,i,false);
  }
}","public void testGetTerminalPosition(){
  File file=null;
  try {
    file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",getContext().getCacheDir());
  }
 catch (  IOException e) {
  }
  assertNotNull(file);
  final FusionDictionary dict=new FusionDictionary(new Node(),new FusionDictionary.DictionaryOptions(new HashMap<String,String>(),false,false));
  addUnigrams(sWords.size(),dict,sWords,null);
  timeWritingDictToFile(file,dict,VERSION3_WITH_DYNAMIC_UPDATE);
  final FusionDictionaryBufferInterface buffer=getBuffer(file,USE_BYTE_ARRAY);
  try {
    final String longWord=""String_Node_Str"";
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,longWord));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,null));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,""String_Node_Str""));
  }
 catch (  IOException e) {
  }
catch (  UnsupportedFormatException e) {
  }
  long sum=0;
  for (int i=0; i < sWords.size(); ++i) {
    final long time=runGetTerminalPosition(buffer,sWords.get(i),i,true);
    sum+=time == -1 ? 0 : time;
  }
  Log.d(TAG,""String_Node_Str"" + (((double)sum) / sWords.size() / 1000000));
  final Random random=new Random((int)System.currentTimeMillis());
  for (int i=0; i < 1000; ++i) {
    final String word=generateWord(random);
    if (sWords.indexOf(word) != -1)     continue;
    runGetTerminalPosition(buffer,word,i,false);
  }
}",0.9966329966329966
87792,"public BinaryDictIOTests(){
  super();
  final Random random=new Random(123456);
  sWords.clear();
  generateWords(MAX_UNIGRAMS,random);
  for (int i=0; i < sWords.size(); ++i) {
    sChainBigrams.put(i,new ArrayList<Integer>());
    if (i > 0) {
      sChainBigrams.get(i - 1).add(i);
    }
  }
  sStarBigrams.put(0,new ArrayList<Integer>());
  for (int i=1; i < sWords.size(); ++i) {
    sStarBigrams.get(0).add(i);
  }
}","public BinaryDictIOTests(){
  super();
  final long time=System.currentTimeMillis();
  Log.e(TAG,""String_Node_Str"" + time);
  final Random random=new Random(time);
  sWords.clear();
  generateWords(MAX_UNIGRAMS,random);
  for (int i=0; i < sWords.size(); ++i) {
    sChainBigrams.put(i,new ArrayList<Integer>());
    if (i > 0) {
      sChainBigrams.get(i - 1).add(i);
    }
  }
  sStarBigrams.put(0,new ArrayList<Integer>());
  for (int i=1; i < sWords.size(); ++i) {
    sStarBigrams.get(0).add(i);
  }
}",0.8977395048439182
87793,"/** 
 * Generates a random word.
 */
private String generateWord(final int value){
  final int lengthOfChars=CHARACTERS.length;
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  long lvalue=Math.abs((long)value);
  while (lvalue > 0) {
    builder.append(CHARACTERS[(int)(lvalue % lengthOfChars)]);
    lvalue/=lengthOfChars;
  }
  return builder.toString();
}","/** 
 * Generates a random word.
 */
private String generateWord(final Random random){
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  int count=random.nextInt() % 30;
  while (count > 0) {
    final long r=Math.abs(random.nextInt());
    if (r < 0)     continue;
    builder.appendCodePoint((int)(20 + r % (0x10FFFF - 20)));
    --count;
  }
  return builder.toString();
}",0.5425950196592398
87794,"private void generateWords(final int number,final Random random){
  final Set<String> wordSet=CollectionUtils.newHashSet();
  while (wordSet.size() < number) {
    wordSet.add(generateWord(random.nextInt()));
  }
  sWords.addAll(wordSet);
}","private void generateWords(final int number,final Random random){
  final Set<String> wordSet=CollectionUtils.newHashSet();
  while (wordSet.size() < number) {
    wordSet.add(generateWord(random));
  }
  sWords.addAll(wordSet);
}",0.9787234042553192
87795,"@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(mCurrentString.length() - currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=currentGroup.mChars.length;
      for (      int i : currentGroup.mChars)       mCurrentString.append(Character.toChars(i));
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0)       return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mCurrentString.length() - mPositions.getLast().length);
    }
  }
 while (true);
}","@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=mCurrentString.length();
      for (      int i : currentGroup.mChars)       mCurrentString.append(Character.toChars(i));
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0)       return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mPositions.getLast().length);
    }
  }
 while (true);
}",0.8171701112877583
87796,"/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String s){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  CharGroup currentGroup;
  final int codePointCountInS=s.codePointCount(0,s.length());
  do {
    int indexOfGroup=findIndexOfChar(node,s.codePointAt(index));
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (s.length() - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < s.length() && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != s.codePointAt(newIndex))       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePointCountInS) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePointCountInS);
  if (index < codePointCountInS)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !s.equals(checker.toString()))   return null;
  return currentGroup;
}","/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String string){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  final int[] codePoints=getCodePoints(string);
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,codePoints[index]);
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (codePoints.length - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < codePoints.length && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != codePoints[newIndex])       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePoints.length) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePoints.length);
  if (index < codePoints.length)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !codePoints.equals(checker.toString()))   return null;
  return currentGroup;
}",0.8491171749598716
87797,"public void testGetTerminalPosition(){
  File file=null;
  try {
    file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",getContext().getCacheDir());
  }
 catch (  IOException e) {
  }
  assertNotNull(file);
  final FusionDictionary dict=new FusionDictionary(new Node(),new FusionDictionary.DictionaryOptions(new HashMap<String,String>(),false,false));
  addUnigrams(sWords.size(),dict,sWords,null);
  timeWritingDictToFile(file,dict,VERSION3_WITH_DYNAMIC_UPDATE);
  final FusionDictionaryBufferInterface buffer=getBuffer(file,USE_BYTE_ARRAY);
  try {
    final String longWord=""String_Node_Str"";
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,longWord));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,null));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,""String_Node_Str""));
  }
 catch (  IOException e) {
  }
catch (  UnsupportedFormatException e) {
  }
  long sum=0;
  for (int i=0; i < sWords.size(); ++i) {
    final long time=runGetTerminalPosition(buffer,sWords.get(i),i,true);
    sum+=time == -1 ? 0 : time;
  }
  Log.d(TAG,""String_Node_Str"" + (((double)sum) / sWords.size() / 1000000));
  final Random random=new Random((int)System.currentTimeMillis());
  for (int i=0; i < 1000; ++i) {
    final String word=generateWord(random.nextInt());
    if (sWords.indexOf(word) != -1)     continue;
    runGetTerminalPosition(buffer,word,i,false);
  }
}","public void testGetTerminalPosition(){
  File file=null;
  try {
    file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",getContext().getCacheDir());
  }
 catch (  IOException e) {
  }
  assertNotNull(file);
  final FusionDictionary dict=new FusionDictionary(new Node(),new FusionDictionary.DictionaryOptions(new HashMap<String,String>(),false,false));
  addUnigrams(sWords.size(),dict,sWords,null);
  timeWritingDictToFile(file,dict,VERSION3_WITH_DYNAMIC_UPDATE);
  final FusionDictionaryBufferInterface buffer=getBuffer(file,USE_BYTE_ARRAY);
  try {
    final String longWord=""String_Node_Str"";
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,longWord));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,null));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,""String_Node_Str""));
  }
 catch (  IOException e) {
  }
catch (  UnsupportedFormatException e) {
  }
  long sum=0;
  for (int i=0; i < sWords.size(); ++i) {
    final long time=runGetTerminalPosition(buffer,sWords.get(i),i,true);
    sum+=time == -1 ? 0 : time;
  }
  Log.d(TAG,""String_Node_Str"" + (((double)sum) / sWords.size() / 1000000));
  final Random random=new Random((int)System.currentTimeMillis());
  for (int i=0; i < 1000; ++i) {
    final String word=generateWord(random);
    if (sWords.indexOf(word) != -1)     continue;
    runGetTerminalPosition(buffer,word,i,false);
  }
}",0.9966329966329966
87798,"public BinaryDictIOTests(){
  super();
  final Random random=new Random(123456);
  sWords.clear();
  generateWords(MAX_UNIGRAMS,random);
  for (int i=0; i < sWords.size(); ++i) {
    sChainBigrams.put(i,new ArrayList<Integer>());
    if (i > 0) {
      sChainBigrams.get(i - 1).add(i);
    }
  }
  sStarBigrams.put(0,new ArrayList<Integer>());
  for (int i=1; i < sWords.size(); ++i) {
    sStarBigrams.get(0).add(i);
  }
}","public BinaryDictIOTests(){
  super();
  final long time=System.currentTimeMillis();
  Log.e(TAG,""String_Node_Str"" + time);
  final Random random=new Random(time);
  sWords.clear();
  generateWords(MAX_UNIGRAMS,random);
  for (int i=0; i < sWords.size(); ++i) {
    sChainBigrams.put(i,new ArrayList<Integer>());
    if (i > 0) {
      sChainBigrams.get(i - 1).add(i);
    }
  }
  sStarBigrams.put(0,new ArrayList<Integer>());
  for (int i=1; i < sWords.size(); ++i) {
    sStarBigrams.get(0).add(i);
  }
}",0.8977395048439182
87799,"/** 
 * Generates a random word.
 */
private String generateWord(final int value){
  final int lengthOfChars=CHARACTERS.length;
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  long lvalue=Math.abs((long)value);
  while (lvalue > 0) {
    builder.append(CHARACTERS[(int)(lvalue % lengthOfChars)]);
    lvalue/=lengthOfChars;
  }
  return builder.toString();
}","/** 
 * Generates a random word.
 */
private String generateWord(final Random random){
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  int count=random.nextInt() % 30;
  while (count > 0) {
    final long r=Math.abs(random.nextInt());
    if (r < 0)     continue;
    builder.appendCodePoint((int)(20 + r % (0x10FFFF - 20)));
    --count;
  }
  return builder.toString();
}",0.5425950196592398
87800,"private void generateWords(final int number,final Random random){
  final Set<String> wordSet=CollectionUtils.newHashSet();
  while (wordSet.size() < number) {
    wordSet.add(generateWord(random.nextInt()));
  }
  sWords.addAll(wordSet);
}","private void generateWords(final int number,final Random random){
  final Set<String> wordSet=CollectionUtils.newHashSet();
  while (wordSet.size() < number) {
    wordSet.add(generateWord(random));
  }
  sWords.addAll(wordSet);
}",0.9787234042553192
87801,"@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(mCurrentString.length() - currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=currentGroup.mChars.length;
      for (      int i : currentGroup.mChars)       mCurrentString.append(Character.toChars(i));
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0)       return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mCurrentString.length() - mPositions.getLast().length);
    }
  }
 while (true);
}","@Override public Word next(){
  Position currentPos=mPositions.getLast();
  mCurrentString.setLength(currentPos.length);
  do {
    if (currentPos.pos.hasNext()) {
      final CharGroup currentGroup=currentPos.pos.next();
      currentPos.length=mCurrentString.length();
      for (      int i : currentGroup.mChars)       mCurrentString.append(Character.toChars(i));
      if (null != currentGroup.mChildren) {
        currentPos=new Position(currentGroup.mChildren.mData);
        mPositions.addLast(currentPos);
      }
      if (currentGroup.mFrequency >= 0)       return new Word(mCurrentString.toString(),currentGroup.mFrequency,currentGroup.mShortcutTargets,currentGroup.mBigrams,currentGroup.mIsNotAWord,currentGroup.mIsBlacklistEntry);
    }
 else {
      mPositions.removeLast();
      currentPos=mPositions.getLast();
      mCurrentString.setLength(mPositions.getLast().length);
    }
  }
 while (true);
}",0.8171701112877583
87802,"/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String s){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  CharGroup currentGroup;
  final int codePointCountInS=s.codePointCount(0,s.length());
  do {
    int indexOfGroup=findIndexOfChar(node,s.codePointAt(index));
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (s.length() - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < s.length() && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != s.codePointAt(newIndex))       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePointCountInS) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePointCountInS);
  if (index < codePointCountInS)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !s.equals(checker.toString()))   return null;
  return currentGroup;
}","/** 
 * Helper method to find a word in a given branch.
 */
@SuppressWarnings(""String_Node_Str"") public static CharGroup findWordInTree(Node node,final String string){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  final int[] codePoints=getCodePoints(string);
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,codePoints[index]);
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (codePoints.length - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < codePoints.length && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != codePoints[newIndex])       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePoints.length) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePoints.length);
  if (index < codePoints.length)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !codePoints.equals(checker.toString()))   return null;
  return currentGroup;
}",0.8491171749598716
87803,"public void testGetTerminalPosition(){
  File file=null;
  try {
    file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",getContext().getCacheDir());
  }
 catch (  IOException e) {
  }
  assertNotNull(file);
  final FusionDictionary dict=new FusionDictionary(new Node(),new FusionDictionary.DictionaryOptions(new HashMap<String,String>(),false,false));
  addUnigrams(sWords.size(),dict,sWords,null);
  timeWritingDictToFile(file,dict,VERSION3_WITH_DYNAMIC_UPDATE);
  final FusionDictionaryBufferInterface buffer=getBuffer(file,USE_BYTE_ARRAY);
  try {
    final String longWord=""String_Node_Str"";
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,longWord));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,null));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,""String_Node_Str""));
  }
 catch (  IOException e) {
  }
catch (  UnsupportedFormatException e) {
  }
  long sum=0;
  for (int i=0; i < sWords.size(); ++i) {
    final long time=runGetTerminalPosition(buffer,sWords.get(i),i,true);
    sum+=time == -1 ? 0 : time;
  }
  Log.d(TAG,""String_Node_Str"" + (((double)sum) / sWords.size() / 1000000));
  final Random random=new Random((int)System.currentTimeMillis());
  for (int i=0; i < 1000; ++i) {
    final String word=generateWord(random.nextInt());
    if (sWords.indexOf(word) != -1)     continue;
    runGetTerminalPosition(buffer,word,i,false);
  }
}","public void testGetTerminalPosition(){
  File file=null;
  try {
    file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",getContext().getCacheDir());
  }
 catch (  IOException e) {
  }
  assertNotNull(file);
  final FusionDictionary dict=new FusionDictionary(new Node(),new FusionDictionary.DictionaryOptions(new HashMap<String,String>(),false,false));
  addUnigrams(sWords.size(),dict,sWords,null);
  timeWritingDictToFile(file,dict,VERSION3_WITH_DYNAMIC_UPDATE);
  final FusionDictionaryBufferInterface buffer=getBuffer(file,USE_BYTE_ARRAY);
  try {
    final String longWord=""String_Node_Str"";
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,longWord));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,null));
    assertEquals(FormatSpec.NOT_VALID_WORD,BinaryDictIOUtils.getTerminalPosition(buffer,""String_Node_Str""));
  }
 catch (  IOException e) {
  }
catch (  UnsupportedFormatException e) {
  }
  long sum=0;
  for (int i=0; i < sWords.size(); ++i) {
    final long time=runGetTerminalPosition(buffer,sWords.get(i),i,true);
    sum+=time == -1 ? 0 : time;
  }
  Log.d(TAG,""String_Node_Str"" + (((double)sum) / sWords.size() / 1000000));
  final Random random=new Random((int)System.currentTimeMillis());
  for (int i=0; i < 1000; ++i) {
    final String word=generateWord(random);
    if (sWords.indexOf(word) != -1)     continue;
    runGetTerminalPosition(buffer,word,i,false);
  }
}",0.9966329966329966
87804,"public BinaryDictIOTests(){
  super();
  final Random random=new Random(123456);
  sWords.clear();
  generateWords(MAX_UNIGRAMS,random);
  for (int i=0; i < sWords.size(); ++i) {
    sChainBigrams.put(i,new ArrayList<Integer>());
    if (i > 0) {
      sChainBigrams.get(i - 1).add(i);
    }
  }
  sStarBigrams.put(0,new ArrayList<Integer>());
  for (int i=1; i < sWords.size(); ++i) {
    sStarBigrams.get(0).add(i);
  }
}","public BinaryDictIOTests(){
  super();
  final long time=System.currentTimeMillis();
  Log.e(TAG,""String_Node_Str"" + time);
  final Random random=new Random(time);
  sWords.clear();
  generateWords(MAX_UNIGRAMS,random);
  for (int i=0; i < sWords.size(); ++i) {
    sChainBigrams.put(i,new ArrayList<Integer>());
    if (i > 0) {
      sChainBigrams.get(i - 1).add(i);
    }
  }
  sStarBigrams.put(0,new ArrayList<Integer>());
  for (int i=1; i < sWords.size(); ++i) {
    sStarBigrams.get(0).add(i);
  }
}",0.8977395048439182
87805,"/** 
 * Generates a random word.
 */
private String generateWord(final int value){
  final int lengthOfChars=CHARACTERS.length;
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  long lvalue=Math.abs((long)value);
  while (lvalue > 0) {
    builder.append(CHARACTERS[(int)(lvalue % lengthOfChars)]);
    lvalue/=lengthOfChars;
  }
  return builder.toString();
}","/** 
 * Generates a random word.
 */
private String generateWord(final Random random){
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  int count=random.nextInt() % 30;
  while (count > 0) {
    final long r=Math.abs(random.nextInt());
    if (r < 0)     continue;
    builder.appendCodePoint((int)(20 + r % (0x10FFFF - 20)));
    --count;
  }
  return builder.toString();
}",0.5425950196592398
87806,"private void generateWords(final int number,final Random random){
  final Set<String> wordSet=CollectionUtils.newHashSet();
  while (wordSet.size() < number) {
    wordSet.add(generateWord(random.nextInt()));
  }
  sWords.addAll(wordSet);
}","private void generateWords(final int number,final Random random){
  final Set<String> wordSet=CollectionUtils.newHashSet();
  while (wordSet.size() < number) {
    wordSet.add(generateWord(random));
  }
  sWords.addAll(wordSet);
}",0.9787234042553192
87807,"private static DictionaryInfo createDictionaryInfoFromFileAddress(final AssetFileAddress fileAddress){
  final FileHeader header=BinaryDictIOUtils.getDictionaryFileHeaderOrNull(new File(fileAddress.mFilename),fileAddress.mOffset,fileAddress.mLength);
  final Locale locale=LocaleUtils.constructLocaleFromString(header.getLocaleString());
  final String version=header.getVersion();
  return new DictionaryInfo(locale,fileAddress,Integer.parseInt(version));
}","private static DictionaryInfo createDictionaryInfoFromFileAddress(final AssetFileAddress fileAddress){
  final FileHeader header=BinaryDictIOUtils.getDictionaryFileHeaderOrNull(new File(fileAddress.mFilename),fileAddress.mOffset,fileAddress.mLength);
  final String id=header.getId();
  final Locale locale=LocaleUtils.constructLocaleFromString(header.getLocaleString());
  final String version=header.getVersion();
  return new DictionaryInfo(id,locale,fileAddress,Integer.parseInt(version));
}",0.925498426023085
87808,"public DictionaryInfo(final Locale locale,final AssetFileAddress fileAddress,final int version){
  mLocale=locale;
  mFileAddress=fileAddress;
  mVersion=version;
  mId=DEFAULT_MAIN_DICT + ID_CATEGORY_SEPARATOR + mLocale;
}","public DictionaryInfo(final String id,final Locale locale,final AssetFileAddress fileAddress,final int version){
  mId=id;
  mLocale=locale;
  mFileAddress=fileAddress;
  mVersion=version;
}",0.7941888619854721
87809,"private static DictionaryInfo createDictionaryInfoFromFileAddress(final AssetFileAddress fileAddress){
  final FileHeader header=BinaryDictIOUtils.getDictionaryFileHeaderOrNull(new File(fileAddress.mFilename),fileAddress.mOffset,fileAddress.mLength);
  final Locale locale=LocaleUtils.constructLocaleFromString(header.getLocaleString());
  final String version=header.getVersion();
  return new DictionaryInfo(locale,fileAddress,Integer.parseInt(version));
}","private static DictionaryInfo createDictionaryInfoFromFileAddress(final AssetFileAddress fileAddress){
  final FileHeader header=BinaryDictIOUtils.getDictionaryFileHeaderOrNull(new File(fileAddress.mFilename),fileAddress.mOffset,fileAddress.mLength);
  final String id=header.getId();
  final Locale locale=LocaleUtils.constructLocaleFromString(header.getLocaleString());
  final String version=header.getVersion();
  return new DictionaryInfo(id,locale,fileAddress,Integer.parseInt(version));
}",0.925498426023085
87810,"public DictionaryInfo(final Locale locale,final AssetFileAddress fileAddress,final int version){
  mLocale=locale;
  mFileAddress=fileAddress;
  mVersion=version;
  mId=DEFAULT_MAIN_DICT + ID_CATEGORY_SEPARATOR + mLocale;
}","public DictionaryInfo(final String id,final Locale locale,final AssetFileAddress fileAddress,final int version){
  mId=id;
  mLocale=locale;
  mFileAddress=fileAddress;
  mVersion=version;
}",0.7941888619854721
87811,"private void updateDebugMode(){
  if (mDebugMode == null) {
    return;
  }
  boolean isDebugMode=mDebugMode.isChecked();
  String version=""String_Node_Str"";
  try {
    final Context context=getActivity();
    final String packageName=context.getPackageName();
    PackageInfo info=context.getPackageManager().getPackageInfo(packageName,0);
    version=""String_Node_Str"" + info.versionName;
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  if (!isDebugMode) {
    mDebugMode.setTitle(version);
    mDebugMode.setSummary(""String_Node_Str"");
  }
 else {
    mDebugMode.setTitle(getResources().getString(R.string.prefs_debug_mode));
    mDebugMode.setSummary(version);
  }
}","private void updateDebugMode(){
  if (mDebugMode == null) {
    return;
  }
  boolean isDebugMode=mDebugMode.isChecked();
  String version=""String_Node_Str"";
  try {
    final Context context=getActivity();
    if (context == null) {
      return;
    }
    final String packageName=context.getPackageName();
    PackageInfo info=context.getPackageManager().getPackageInfo(packageName,0);
    version=""String_Node_Str"" + info.versionName;
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  if (!isDebugMode) {
    mDebugMode.setTitle(version);
    mDebugMode.setSummary(""String_Node_Str"");
  }
 else {
    mDebugMode.setTitle(getResources().getString(R.string.prefs_debug_mode));
    mDebugMode.setSummary(version);
  }
}",0.9676975945017182
87812,"public synchronized void publish(final LogUnit logUnit,final boolean isIncludingPrivateData){
  try {
    mExecutor.submit(new Callable<Object>(){
      @Override public Object call() throws Exception {
        logUnit.publishTo(ResearchLog.this,isIncludingPrivateData);
        scheduleFlush();
        return null;
      }
    }
);
  }
 catch (  RejectedExecutionException e) {
  }
}","public synchronized void publish(final LogUnit logUnit,final boolean isIncludingPrivateData){
  try {
    mExecutor.submit(new Callable<Object>(){
      @Override public Object call() throws Exception {
        logUnit.publishTo(ResearchLog.this,isIncludingPrivateData);
        scheduleFlush();
        return null;
      }
    }
);
  }
 catch (  RejectedExecutionException e) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"");
    }
  }
}",0.9215922798552472
87813,"public static void latinIME_onStartInputViewInternal(final EditorInfo editorInfo,final SharedPreferences prefs){
  final ResearchLogger researchLogger=getInstance();
  if (editorInfo != null) {
    final boolean isPassword=InputTypeUtils.isPasswordInputType(editorInfo.inputType) || InputTypeUtils.isVisiblePasswordInputType(editorInfo.inputType);
    getInstance().setIsPasswordView(isPassword);
    researchLogger.start();
    final Context context=researchLogger.mLatinIME;
    try {
      final PackageInfo packageInfo;
      packageInfo=context.getPackageManager().getPackageInfo(context.getPackageName(),0);
      final Integer versionCode=packageInfo.versionCode;
      final String versionName=packageInfo.versionName;
      researchLogger.enqueueEvent(LOGSTATEMENT_LATIN_IME_ON_START_INPUT_VIEW_INTERNAL,researchLogger.mUUIDString,editorInfo.packageName,Integer.toHexString(editorInfo.inputType),Integer.toHexString(editorInfo.imeOptions),editorInfo.fieldId,Build.DISPLAY,Build.MODEL,prefs,versionCode,versionName,OUTPUT_FORMAT_VERSION,LOG_EVERYTHING,ProductionFlag.IS_EXPERIMENTAL_DEBUG);
    }
 catch (    NameNotFoundException e) {
      e.printStackTrace();
    }
  }
}","public static void latinIME_onStartInputViewInternal(final EditorInfo editorInfo,final SharedPreferences prefs){
  final ResearchLogger researchLogger=getInstance();
  if (editorInfo != null) {
    final boolean isPassword=InputTypeUtils.isPasswordInputType(editorInfo.inputType) || InputTypeUtils.isVisiblePasswordInputType(editorInfo.inputType);
    getInstance().setIsPasswordView(isPassword);
    researchLogger.start();
    final Context context=researchLogger.mLatinIME;
    try {
      final PackageInfo packageInfo;
      packageInfo=context.getPackageManager().getPackageInfo(context.getPackageName(),0);
      final Integer versionCode=packageInfo.versionCode;
      final String versionName=packageInfo.versionName;
      researchLogger.enqueueEvent(LOGSTATEMENT_LATIN_IME_ON_START_INPUT_VIEW_INTERNAL,researchLogger.mUUIDString,editorInfo.packageName,Integer.toHexString(editorInfo.inputType),Integer.toHexString(editorInfo.imeOptions),editorInfo.fieldId,Build.DISPLAY,Build.MODEL,prefs,versionCode,versionName,OUTPUT_FORMAT_VERSION,IS_LOGGING_EVERYTHING,ProductionFlag.IS_EXPERIMENTAL_DEBUG);
    }
 catch (    NameNotFoundException e) {
      e.printStackTrace();
    }
  }
}",0.9970476592155209
87814,"void stop(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"");
  }
  commitCurrentLogUnit();
  if (mMainLogBuffer != null) {
    publishLogBuffer(mMainLogBuffer,mMainResearchLog,LOG_EVERYTHING);
    mMainResearchLog.close(null);
    mMainLogBuffer=null;
  }
  if (mFeedbackLogBuffer != null) {
    mFeedbackLog.close(null);
    mFeedbackLogBuffer=null;
  }
}","void stop(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"");
  }
  commitCurrentLogUnit();
  if (mMainLogBuffer != null) {
    publishLogBuffer(mMainLogBuffer,mMainResearchLog,IS_LOGGING_EVERYTHING);
    mMainResearchLog.close(null);
    mMainLogBuffer=null;
  }
  if (mFeedbackLogBuffer != null) {
    mFeedbackLog.close(null);
    mFeedbackLogBuffer=null;
  }
}",0.9902912621359224
87815,"void commitCurrentLogUnit(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (mCurrentLogUnit.hasWord() ? ""String_Node_Str"" + mCurrentLogUnit.getWord() : ""String_Node_Str""));
  }
  if (!mCurrentLogUnit.isEmpty()) {
    if (mMainLogBuffer != null) {
      if ((mMainLogBuffer.isSafeToLog() || LOG_EVERYTHING) && mMainResearchLog != null) {
        publishLogBuffer(mMainLogBuffer,mMainResearchLog,true);
        mMainLogBuffer.resetWordCounter();
      }
      mMainLogBuffer.shiftIn(mCurrentLogUnit);
    }
    if (mFeedbackLogBuffer != null) {
      mFeedbackLogBuffer.shiftIn(mCurrentLogUnit);
    }
    mCurrentLogUnit=new LogUnit();
  }
}","void commitCurrentLogUnit(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (mCurrentLogUnit.hasWord() ? ""String_Node_Str"" + mCurrentLogUnit.getWord() : ""String_Node_Str""));
  }
  if (!mCurrentLogUnit.isEmpty()) {
    if (mMainLogBuffer != null) {
      if ((mMainLogBuffer.isSafeToLog() || IS_LOGGING_EVERYTHING) && mMainResearchLog != null) {
        publishLogBuffer(mMainLogBuffer,mMainResearchLog,true);
        mMainLogBuffer.resetWordCounter();
      }
      mMainLogBuffer.shiftIn(mCurrentLogUnit);
    }
    if (mFeedbackLogBuffer != null) {
      mFeedbackLogBuffer.shiftIn(mCurrentLogUnit);
    }
    mCurrentLogUnit=new LogUnit();
  }
}",0.994586233565352
87816,"public static void latinIME_revertCommit(final String committedWord,final String originallyTypedWord,final boolean isBatchMode){
  final ResearchLogger researchLogger=getInstance();
  final LogUnit logUnit=researchLogger.mMainLogBuffer.peekLastLogUnit();
  if (originallyTypedWord.length() > 0 && hasLetters(originallyTypedWord)) {
    if (logUnit != null) {
      logUnit.setWord(originallyTypedWord);
    }
    final Dictionary dictionary=researchLogger.getDictionary();
    researchLogger.mStatistics.recordWordEntered(dictionary != null && dictionary.isValidWord(originallyTypedWord));
  }
  researchLogger.enqueueEvent(logUnit != null ? logUnit : researchLogger.mCurrentLogUnit,LOGSTATEMENT_LATINIME_REVERTCOMMIT,committedWord,originallyTypedWord);
  researchLogger.mStatistics.recordRevertCommit();
  researchLogger.commitCurrentLogUnitAsWord(originallyTypedWord,Long.MAX_VALUE,isBatchMode);
}","public static void latinIME_revertCommit(final String committedWord,final String originallyTypedWord,final boolean isBatchMode){
  final ResearchLogger researchLogger=getInstance();
  final LogUnit logUnit=researchLogger.mMainLogBuffer.peekLastLogUnit();
  if (originallyTypedWord.length() > 0 && hasLetters(originallyTypedWord)) {
    if (logUnit != null) {
      logUnit.setWord(originallyTypedWord);
    }
  }
  researchLogger.enqueueEvent(logUnit != null ? logUnit : researchLogger.mCurrentLogUnit,LOGSTATEMENT_LATINIME_REVERTCOMMIT,committedWord,originallyTypedWord);
  researchLogger.mStatistics.recordRevertCommit();
  researchLogger.commitCurrentLogUnitAsWord(originallyTypedWord,Long.MAX_VALUE,isBatchMode);
}",0.8880643166357453
87817,"public synchronized void publish(final LogUnit logUnit,final boolean isIncludingPrivateData){
  try {
    mExecutor.submit(new Callable<Object>(){
      @Override public Object call() throws Exception {
        logUnit.publishTo(ResearchLog.this,isIncludingPrivateData);
        scheduleFlush();
        return null;
      }
    }
);
  }
 catch (  RejectedExecutionException e) {
  }
}","public synchronized void publish(final LogUnit logUnit,final boolean isIncludingPrivateData){
  try {
    mExecutor.submit(new Callable<Object>(){
      @Override public Object call() throws Exception {
        logUnit.publishTo(ResearchLog.this,isIncludingPrivateData);
        scheduleFlush();
        return null;
      }
    }
);
  }
 catch (  RejectedExecutionException e) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"");
    }
  }
}",0.9215922798552472
87818,"public static void latinIME_onStartInputViewInternal(final EditorInfo editorInfo,final SharedPreferences prefs){
  final ResearchLogger researchLogger=getInstance();
  if (editorInfo != null) {
    final boolean isPassword=InputTypeUtils.isPasswordInputType(editorInfo.inputType) || InputTypeUtils.isVisiblePasswordInputType(editorInfo.inputType);
    getInstance().setIsPasswordView(isPassword);
    researchLogger.start();
    final Context context=researchLogger.mLatinIME;
    try {
      final PackageInfo packageInfo;
      packageInfo=context.getPackageManager().getPackageInfo(context.getPackageName(),0);
      final Integer versionCode=packageInfo.versionCode;
      final String versionName=packageInfo.versionName;
      researchLogger.enqueueEvent(LOGSTATEMENT_LATIN_IME_ON_START_INPUT_VIEW_INTERNAL,researchLogger.mUUIDString,editorInfo.packageName,Integer.toHexString(editorInfo.inputType),Integer.toHexString(editorInfo.imeOptions),editorInfo.fieldId,Build.DISPLAY,Build.MODEL,prefs,versionCode,versionName,OUTPUT_FORMAT_VERSION,LOG_EVERYTHING,ProductionFlag.IS_EXPERIMENTAL_DEBUG);
    }
 catch (    NameNotFoundException e) {
      e.printStackTrace();
    }
  }
}","public static void latinIME_onStartInputViewInternal(final EditorInfo editorInfo,final SharedPreferences prefs){
  final ResearchLogger researchLogger=getInstance();
  if (editorInfo != null) {
    final boolean isPassword=InputTypeUtils.isPasswordInputType(editorInfo.inputType) || InputTypeUtils.isVisiblePasswordInputType(editorInfo.inputType);
    getInstance().setIsPasswordView(isPassword);
    researchLogger.start();
    final Context context=researchLogger.mLatinIME;
    try {
      final PackageInfo packageInfo;
      packageInfo=context.getPackageManager().getPackageInfo(context.getPackageName(),0);
      final Integer versionCode=packageInfo.versionCode;
      final String versionName=packageInfo.versionName;
      researchLogger.enqueueEvent(LOGSTATEMENT_LATIN_IME_ON_START_INPUT_VIEW_INTERNAL,researchLogger.mUUIDString,editorInfo.packageName,Integer.toHexString(editorInfo.inputType),Integer.toHexString(editorInfo.imeOptions),editorInfo.fieldId,Build.DISPLAY,Build.MODEL,prefs,versionCode,versionName,OUTPUT_FORMAT_VERSION,IS_LOGGING_EVERYTHING,ProductionFlag.IS_EXPERIMENTAL_DEBUG);
    }
 catch (    NameNotFoundException e) {
      e.printStackTrace();
    }
  }
}",0.9970476592155209
87819,"void stop(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"");
  }
  commitCurrentLogUnit();
  if (mMainLogBuffer != null) {
    publishLogBuffer(mMainLogBuffer,mMainResearchLog,LOG_EVERYTHING);
    mMainResearchLog.close(null);
    mMainLogBuffer=null;
  }
  if (mFeedbackLogBuffer != null) {
    mFeedbackLog.close(null);
    mFeedbackLogBuffer=null;
  }
}","void stop(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"");
  }
  commitCurrentLogUnit();
  if (mMainLogBuffer != null) {
    publishLogBuffer(mMainLogBuffer,mMainResearchLog,IS_LOGGING_EVERYTHING);
    mMainResearchLog.close(null);
    mMainLogBuffer=null;
  }
  if (mFeedbackLogBuffer != null) {
    mFeedbackLog.close(null);
    mFeedbackLogBuffer=null;
  }
}",0.9902912621359224
87820,"void commitCurrentLogUnit(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (mCurrentLogUnit.hasWord() ? ""String_Node_Str"" + mCurrentLogUnit.getWord() : ""String_Node_Str""));
  }
  if (!mCurrentLogUnit.isEmpty()) {
    if (mMainLogBuffer != null) {
      if ((mMainLogBuffer.isSafeToLog() || LOG_EVERYTHING) && mMainResearchLog != null) {
        publishLogBuffer(mMainLogBuffer,mMainResearchLog,true);
        mMainLogBuffer.resetWordCounter();
      }
      mMainLogBuffer.shiftIn(mCurrentLogUnit);
    }
    if (mFeedbackLogBuffer != null) {
      mFeedbackLogBuffer.shiftIn(mCurrentLogUnit);
    }
    mCurrentLogUnit=new LogUnit();
  }
}","void commitCurrentLogUnit(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (mCurrentLogUnit.hasWord() ? ""String_Node_Str"" + mCurrentLogUnit.getWord() : ""String_Node_Str""));
  }
  if (!mCurrentLogUnit.isEmpty()) {
    if (mMainLogBuffer != null) {
      if ((mMainLogBuffer.isSafeToLog() || IS_LOGGING_EVERYTHING) && mMainResearchLog != null) {
        publishLogBuffer(mMainLogBuffer,mMainResearchLog,true);
        mMainLogBuffer.resetWordCounter();
      }
      mMainLogBuffer.shiftIn(mCurrentLogUnit);
    }
    if (mFeedbackLogBuffer != null) {
      mFeedbackLogBuffer.shiftIn(mCurrentLogUnit);
    }
    mCurrentLogUnit=new LogUnit();
  }
}",0.994586233565352
87821,"public static void latinIME_revertCommit(final String committedWord,final String originallyTypedWord,final boolean isBatchMode){
  final ResearchLogger researchLogger=getInstance();
  final LogUnit logUnit=researchLogger.mMainLogBuffer.peekLastLogUnit();
  if (originallyTypedWord.length() > 0 && hasLetters(originallyTypedWord)) {
    if (logUnit != null) {
      logUnit.setWord(originallyTypedWord);
    }
    final Dictionary dictionary=researchLogger.getDictionary();
    researchLogger.mStatistics.recordWordEntered(dictionary != null && dictionary.isValidWord(originallyTypedWord));
  }
  researchLogger.enqueueEvent(logUnit != null ? logUnit : researchLogger.mCurrentLogUnit,LOGSTATEMENT_LATINIME_REVERTCOMMIT,committedWord,originallyTypedWord);
  researchLogger.mStatistics.recordRevertCommit();
  researchLogger.commitCurrentLogUnitAsWord(originallyTypedWord,Long.MAX_VALUE,isBatchMode);
}","public static void latinIME_revertCommit(final String committedWord,final String originallyTypedWord,final boolean isBatchMode){
  final ResearchLogger researchLogger=getInstance();
  final LogUnit logUnit=researchLogger.mMainLogBuffer.peekLastLogUnit();
  if (originallyTypedWord.length() > 0 && hasLetters(originallyTypedWord)) {
    if (logUnit != null) {
      logUnit.setWord(originallyTypedWord);
    }
  }
  researchLogger.enqueueEvent(logUnit != null ? logUnit : researchLogger.mCurrentLogUnit,LOGSTATEMENT_LATINIME_REVERTCOMMIT,committedWord,originallyTypedWord);
  researchLogger.mStatistics.recordRevertCommit();
  researchLogger.commitCurrentLogUnitAsWord(originallyTypedWord,Long.MAX_VALUE,isBatchMode);
}",0.8880643166357453
87822,"private void updateDebugMode(){
  if (mDebugMode == null) {
    return;
  }
  boolean isDebugMode=mDebugMode.isChecked();
  String version=""String_Node_Str"";
  try {
    final Context context=getActivity();
    final String packageName=context.getPackageName();
    PackageInfo info=context.getPackageManager().getPackageInfo(packageName,0);
    version=""String_Node_Str"" + info.versionName;
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  if (!isDebugMode) {
    mDebugMode.setTitle(version);
    mDebugMode.setSummary(""String_Node_Str"");
  }
 else {
    mDebugMode.setTitle(getResources().getString(R.string.prefs_debug_mode));
    mDebugMode.setSummary(version);
  }
}","private void updateDebugMode(){
  if (mDebugMode == null) {
    return;
  }
  boolean isDebugMode=mDebugMode.isChecked();
  String version=""String_Node_Str"";
  try {
    final Context context=getActivity();
    if (context == null) {
      return;
    }
    final String packageName=context.getPackageName();
    PackageInfo info=context.getPackageManager().getPackageInfo(packageName,0);
    version=""String_Node_Str"" + info.versionName;
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  if (!isDebugMode) {
    mDebugMode.setTitle(version);
    mDebugMode.setSummary(""String_Node_Str"");
  }
 else {
    mDebugMode.setTitle(getResources().getString(R.string.prefs_debug_mode));
    mDebugMode.setSummary(version);
  }
}",0.9676975945017182
87823,"private void updateDebugMode(){
  if (mDebugMode == null) {
    return;
  }
  boolean isDebugMode=mDebugMode.isChecked();
  String version=""String_Node_Str"";
  try {
    final Context context=getActivity();
    final String packageName=context.getPackageName();
    PackageInfo info=context.getPackageManager().getPackageInfo(packageName,0);
    version=""String_Node_Str"" + info.versionName;
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  if (!isDebugMode) {
    mDebugMode.setTitle(version);
    mDebugMode.setSummary(""String_Node_Str"");
  }
 else {
    mDebugMode.setTitle(getResources().getString(R.string.prefs_debug_mode));
    mDebugMode.setSummary(version);
  }
}","private void updateDebugMode(){
  if (mDebugMode == null) {
    return;
  }
  boolean isDebugMode=mDebugMode.isChecked();
  String version=""String_Node_Str"";
  try {
    final Context context=getActivity();
    if (context == null) {
      return;
    }
    final String packageName=context.getPackageName();
    PackageInfo info=context.getPackageManager().getPackageInfo(packageName,0);
    version=""String_Node_Str"" + info.versionName;
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  if (!isDebugMode) {
    mDebugMode.setTitle(version);
    mDebugMode.setSummary(""String_Node_Str"");
  }
 else {
    mDebugMode.setTitle(getResources().getString(R.string.prefs_debug_mode));
    mDebugMode.setSummary(version);
  }
}",0.9676975945017182
87824,"public synchronized void publish(final LogUnit logUnit,final boolean isIncludingPrivateData){
  try {
    mExecutor.submit(new Callable<Object>(){
      @Override public Object call() throws Exception {
        logUnit.publishTo(ResearchLog.this,isIncludingPrivateData);
        scheduleFlush();
        return null;
      }
    }
);
  }
 catch (  RejectedExecutionException e) {
  }
}","public synchronized void publish(final LogUnit logUnit,final boolean isIncludingPrivateData){
  try {
    mExecutor.submit(new Callable<Object>(){
      @Override public Object call() throws Exception {
        logUnit.publishTo(ResearchLog.this,isIncludingPrivateData);
        scheduleFlush();
        return null;
      }
    }
);
  }
 catch (  RejectedExecutionException e) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"");
    }
  }
}",0.9215922798552472
87825,"public static void latinIME_onStartInputViewInternal(final EditorInfo editorInfo,final SharedPreferences prefs){
  final ResearchLogger researchLogger=getInstance();
  if (editorInfo != null) {
    final boolean isPassword=InputTypeUtils.isPasswordInputType(editorInfo.inputType) || InputTypeUtils.isVisiblePasswordInputType(editorInfo.inputType);
    getInstance().setIsPasswordView(isPassword);
    researchLogger.start();
    final Context context=researchLogger.mLatinIME;
    try {
      final PackageInfo packageInfo;
      packageInfo=context.getPackageManager().getPackageInfo(context.getPackageName(),0);
      final Integer versionCode=packageInfo.versionCode;
      final String versionName=packageInfo.versionName;
      researchLogger.enqueueEvent(LOGSTATEMENT_LATIN_IME_ON_START_INPUT_VIEW_INTERNAL,researchLogger.mUUIDString,editorInfo.packageName,Integer.toHexString(editorInfo.inputType),Integer.toHexString(editorInfo.imeOptions),editorInfo.fieldId,Build.DISPLAY,Build.MODEL,prefs,versionCode,versionName,OUTPUT_FORMAT_VERSION,LOG_EVERYTHING,ProductionFlag.IS_EXPERIMENTAL_DEBUG);
    }
 catch (    NameNotFoundException e) {
      e.printStackTrace();
    }
  }
}","public static void latinIME_onStartInputViewInternal(final EditorInfo editorInfo,final SharedPreferences prefs){
  final ResearchLogger researchLogger=getInstance();
  if (editorInfo != null) {
    final boolean isPassword=InputTypeUtils.isPasswordInputType(editorInfo.inputType) || InputTypeUtils.isVisiblePasswordInputType(editorInfo.inputType);
    getInstance().setIsPasswordView(isPassword);
    researchLogger.start();
    final Context context=researchLogger.mLatinIME;
    try {
      final PackageInfo packageInfo;
      packageInfo=context.getPackageManager().getPackageInfo(context.getPackageName(),0);
      final Integer versionCode=packageInfo.versionCode;
      final String versionName=packageInfo.versionName;
      researchLogger.enqueueEvent(LOGSTATEMENT_LATIN_IME_ON_START_INPUT_VIEW_INTERNAL,researchLogger.mUUIDString,editorInfo.packageName,Integer.toHexString(editorInfo.inputType),Integer.toHexString(editorInfo.imeOptions),editorInfo.fieldId,Build.DISPLAY,Build.MODEL,prefs,versionCode,versionName,OUTPUT_FORMAT_VERSION,IS_LOGGING_EVERYTHING,ProductionFlag.IS_EXPERIMENTAL_DEBUG);
    }
 catch (    NameNotFoundException e) {
      e.printStackTrace();
    }
  }
}",0.9970476592155209
87826,"void stop(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"");
  }
  commitCurrentLogUnit();
  if (mMainLogBuffer != null) {
    publishLogBuffer(mMainLogBuffer,mMainResearchLog,LOG_EVERYTHING);
    mMainResearchLog.close(null);
    mMainLogBuffer=null;
  }
  if (mFeedbackLogBuffer != null) {
    mFeedbackLog.close(null);
    mFeedbackLogBuffer=null;
  }
}","void stop(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"");
  }
  commitCurrentLogUnit();
  if (mMainLogBuffer != null) {
    publishLogBuffer(mMainLogBuffer,mMainResearchLog,IS_LOGGING_EVERYTHING);
    mMainResearchLog.close(null);
    mMainLogBuffer=null;
  }
  if (mFeedbackLogBuffer != null) {
    mFeedbackLog.close(null);
    mFeedbackLogBuffer=null;
  }
}",0.9902912621359224
87827,"void commitCurrentLogUnit(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (mCurrentLogUnit.hasWord() ? ""String_Node_Str"" + mCurrentLogUnit.getWord() : ""String_Node_Str""));
  }
  if (!mCurrentLogUnit.isEmpty()) {
    if (mMainLogBuffer != null) {
      if ((mMainLogBuffer.isSafeToLog() || LOG_EVERYTHING) && mMainResearchLog != null) {
        publishLogBuffer(mMainLogBuffer,mMainResearchLog,true);
        mMainLogBuffer.resetWordCounter();
      }
      mMainLogBuffer.shiftIn(mCurrentLogUnit);
    }
    if (mFeedbackLogBuffer != null) {
      mFeedbackLogBuffer.shiftIn(mCurrentLogUnit);
    }
    mCurrentLogUnit=new LogUnit();
  }
}","void commitCurrentLogUnit(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (mCurrentLogUnit.hasWord() ? ""String_Node_Str"" + mCurrentLogUnit.getWord() : ""String_Node_Str""));
  }
  if (!mCurrentLogUnit.isEmpty()) {
    if (mMainLogBuffer != null) {
      if ((mMainLogBuffer.isSafeToLog() || IS_LOGGING_EVERYTHING) && mMainResearchLog != null) {
        publishLogBuffer(mMainLogBuffer,mMainResearchLog,true);
        mMainLogBuffer.resetWordCounter();
      }
      mMainLogBuffer.shiftIn(mCurrentLogUnit);
    }
    if (mFeedbackLogBuffer != null) {
      mFeedbackLogBuffer.shiftIn(mCurrentLogUnit);
    }
    mCurrentLogUnit=new LogUnit();
  }
}",0.994586233565352
87828,"public static void latinIME_revertCommit(final String committedWord,final String originallyTypedWord,final boolean isBatchMode){
  final ResearchLogger researchLogger=getInstance();
  final LogUnit logUnit=researchLogger.mMainLogBuffer.peekLastLogUnit();
  if (originallyTypedWord.length() > 0 && hasLetters(originallyTypedWord)) {
    if (logUnit != null) {
      logUnit.setWord(originallyTypedWord);
    }
    final Dictionary dictionary=researchLogger.getDictionary();
    researchLogger.mStatistics.recordWordEntered(dictionary != null && dictionary.isValidWord(originallyTypedWord));
  }
  researchLogger.enqueueEvent(logUnit != null ? logUnit : researchLogger.mCurrentLogUnit,LOGSTATEMENT_LATINIME_REVERTCOMMIT,committedWord,originallyTypedWord);
  researchLogger.mStatistics.recordRevertCommit();
  researchLogger.commitCurrentLogUnitAsWord(originallyTypedWord,Long.MAX_VALUE,isBatchMode);
}","public static void latinIME_revertCommit(final String committedWord,final String originallyTypedWord,final boolean isBatchMode){
  final ResearchLogger researchLogger=getInstance();
  final LogUnit logUnit=researchLogger.mMainLogBuffer.peekLastLogUnit();
  if (originallyTypedWord.length() > 0 && hasLetters(originallyTypedWord)) {
    if (logUnit != null) {
      logUnit.setWord(originallyTypedWord);
    }
  }
  researchLogger.enqueueEvent(logUnit != null ? logUnit : researchLogger.mCurrentLogUnit,LOGSTATEMENT_LATINIME_REVERTCOMMIT,committedWord,originallyTypedWord);
  researchLogger.mStatistics.recordRevertCommit();
  researchLogger.commitCurrentLogUnitAsWord(originallyTypedWord,Long.MAX_VALUE,isBatchMode);
}",0.8880643166357453
87829,"/** 
 * Returns the text surrounding the cursor.
 * @param sep a string of characters that split words.
 * @param additionalPrecedingWordsCount the number of words before the current word that shouldbe included in the returned range
 * @return a range containing the text surrounding the cursor
 */
public Range getWordRangeAtCursor(final String sep,final int additionalPrecedingWordsCount){
  mIC=mParent.getCurrentInputConnection();
  if (mIC == null || sep == null) {
    return null;
  }
  final CharSequence before=mIC.getTextBeforeCursor(1000,0);
  final CharSequence after=mIC.getTextAfterCursor(1000,0);
  if (before == null || after == null) {
    return null;
  }
  int count=additionalPrecedingWordsCount;
  int start=before.length();
  boolean isStoppingAtWhitespace=true;
  while (true) {
    while (start > 0) {
      final int codePoint=Character.codePointBefore(before,start);
      if (isStoppingAtWhitespace == isSeparator(codePoint,sep)) {
        break;
      }
      --start;
      if (Character.isSupplementaryCodePoint(codePoint)) {
        --start;
      }
    }
    if (isStoppingAtWhitespace && (--count < 0)) {
      break;
    }
    isStoppingAtWhitespace=!isStoppingAtWhitespace;
  }
  int end=-1;
  while (++end < after.length()) {
    final int codePoint=Character.codePointAt(after,end);
    if (isSeparator(codePoint,sep)) {
      break;
    }
    if (Character.isSupplementaryCodePoint(codePoint)) {
      ++end;
    }
  }
  final int cursor=getCursorPosition();
  if (start >= 0 && cursor + end <= after.length() + before.length()) {
    String word=before.toString().substring(start,before.length()) + after.toString().substring(0,end);
    return new Range(before.length() - start,end,word);
  }
  return null;
}","/** 
 * Returns the text surrounding the cursor.
 * @param sep a string of characters that split words.
 * @param additionalPrecedingWordsCount the number of words before the current word that shouldbe included in the returned range
 * @return a range containing the text surrounding the cursor
 */
public Range getWordRangeAtCursor(final String sep,final int additionalPrecedingWordsCount){
  mIC=mParent.getCurrentInputConnection();
  if (mIC == null || sep == null) {
    return null;
  }
  final CharSequence before=mIC.getTextBeforeCursor(1000,0);
  final CharSequence after=mIC.getTextAfterCursor(1000,0);
  if (before == null || after == null) {
    return null;
  }
  int count=additionalPrecedingWordsCount;
  int start=before.length();
  boolean isStoppingAtWhitespace=true;
  while (true) {
    while (start > 0) {
      final int codePoint=Character.codePointBefore(before,start);
      if (isStoppingAtWhitespace == isSeparator(codePoint,sep)) {
        break;
      }
      --start;
      if (Character.isSupplementaryCodePoint(codePoint)) {
        --start;
      }
    }
    if (isStoppingAtWhitespace && (--count < 0)) {
      break;
    }
    isStoppingAtWhitespace=!isStoppingAtWhitespace;
  }
  int end=-1;
  while (++end < after.length()) {
    final int codePoint=Character.codePointAt(after,end);
    if (isSeparator(codePoint,sep)) {
      break;
    }
    if (Character.isSupplementaryCodePoint(codePoint)) {
      ++end;
    }
  }
  final String word=before.toString().substring(start,before.length()) + after.toString().substring(0,end);
  return new Range(before.length() - start,end,word);
}",0.9617097061442564
87830,"/** 
 * Returns the text surrounding the cursor.
 * @param sep a string of characters that split words.
 * @param additionalPrecedingWordsCount the number of words before the current word that shouldbe included in the returned range
 * @return a range containing the text surrounding the cursor
 */
public Range getWordRangeAtCursor(final String sep,final int additionalPrecedingWordsCount){
  mIC=mParent.getCurrentInputConnection();
  if (mIC == null || sep == null) {
    return null;
  }
  final CharSequence before=mIC.getTextBeforeCursor(1000,0);
  final CharSequence after=mIC.getTextAfterCursor(1000,0);
  if (before == null || after == null) {
    return null;
  }
  int count=additionalPrecedingWordsCount;
  int start=before.length();
  boolean isStoppingAtWhitespace=true;
  while (true) {
    while (start > 0) {
      final int codePoint=Character.codePointBefore(before,start);
      if (isStoppingAtWhitespace == isSeparator(codePoint,sep)) {
        break;
      }
      --start;
      if (Character.isSupplementaryCodePoint(codePoint)) {
        --start;
      }
    }
    if (isStoppingAtWhitespace && (--count < 0)) {
      break;
    }
    isStoppingAtWhitespace=!isStoppingAtWhitespace;
  }
  int end=-1;
  while (++end < after.length()) {
    final int codePoint=Character.codePointAt(after,end);
    if (isSeparator(codePoint,sep)) {
      break;
    }
    if (Character.isSupplementaryCodePoint(codePoint)) {
      ++end;
    }
  }
  final int cursor=getCursorPosition();
  if (start >= 0 && cursor + end <= after.length() + before.length()) {
    String word=before.toString().substring(start,before.length()) + after.toString().substring(0,end);
    return new Range(before.length() - start,end,word);
  }
  return null;
}","/** 
 * Returns the text surrounding the cursor.
 * @param sep a string of characters that split words.
 * @param additionalPrecedingWordsCount the number of words before the current word that shouldbe included in the returned range
 * @return a range containing the text surrounding the cursor
 */
public Range getWordRangeAtCursor(final String sep,final int additionalPrecedingWordsCount){
  mIC=mParent.getCurrentInputConnection();
  if (mIC == null || sep == null) {
    return null;
  }
  final CharSequence before=mIC.getTextBeforeCursor(1000,0);
  final CharSequence after=mIC.getTextAfterCursor(1000,0);
  if (before == null || after == null) {
    return null;
  }
  int count=additionalPrecedingWordsCount;
  int start=before.length();
  boolean isStoppingAtWhitespace=true;
  while (true) {
    while (start > 0) {
      final int codePoint=Character.codePointBefore(before,start);
      if (isStoppingAtWhitespace == isSeparator(codePoint,sep)) {
        break;
      }
      --start;
      if (Character.isSupplementaryCodePoint(codePoint)) {
        --start;
      }
    }
    if (isStoppingAtWhitespace && (--count < 0)) {
      break;
    }
    isStoppingAtWhitespace=!isStoppingAtWhitespace;
  }
  int end=-1;
  while (++end < after.length()) {
    final int codePoint=Character.codePointAt(after,end);
    if (isSeparator(codePoint,sep)) {
      break;
    }
    if (Character.isSupplementaryCodePoint(codePoint)) {
      ++end;
    }
  }
  final String word=before.toString().substring(start,before.length()) + after.toString().substring(0,end);
  return new Range(before.length() - start,end,word);
}",0.9617097061442564
87831,"/** 
 * Publish the contents of this LogUnit to researchLog.
 */
public synchronized void publishTo(final ResearchLog researchLog,final boolean isIncludingPrivateData){
  final int size=mLogStatementList.size();
  for (int i=0; i < size; i++) {
    final LogStatement logStatement=mLogStatementList.get(i);
    if (!isIncludingPrivateData && logStatement.mIsPotentiallyPrivate) {
      continue;
    }
    if (mIsPartOfMegaword && logStatement.mIsPotentiallyRevealing) {
      continue;
    }
    final JsonWriter jsonWriter=researchLog.getValidJsonWriterLocked();
    outputLogStatementToLocked(jsonWriter,mLogStatementList.get(i),mValuesList.get(i),mTimeList.get(i));
  }
}","/** 
 * Publish the contents of this LogUnit to researchLog.
 */
public synchronized void publishTo(final ResearchLog researchLog,final boolean isIncludingPrivateData){
  final StringWriter debugStringWriter;
  final JsonWriter debugJsonWriter;
  if (DEBUG) {
    debugStringWriter=new StringWriter();
    debugJsonWriter=new JsonWriter(debugStringWriter);
    debugJsonWriter.setIndent(""String_Node_Str"");
    try {
      debugJsonWriter.beginArray();
    }
 catch (    IOException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
 else {
    debugStringWriter=null;
    debugJsonWriter=null;
  }
  final int size=mLogStatementList.size();
  for (int i=0; i < size; i++) {
    final LogStatement logStatement=mLogStatementList.get(i);
    if (!isIncludingPrivateData && logStatement.mIsPotentiallyPrivate) {
      continue;
    }
    if (mIsPartOfMegaword && logStatement.mIsPotentiallyRevealing) {
      continue;
    }
    final JsonWriter jsonWriter=researchLog.getValidJsonWriterLocked();
    outputLogStatementToLocked(jsonWriter,mLogStatementList.get(i),mValuesList.get(i),mTimeList.get(i));
    if (DEBUG) {
      outputLogStatementToLocked(debugJsonWriter,mLogStatementList.get(i),mValuesList.get(i),mTimeList.get(i));
    }
  }
  if (DEBUG) {
    try {
      debugJsonWriter.endArray();
      debugJsonWriter.flush();
    }
 catch (    IOException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
    final String bigString=debugStringWriter.getBuffer().toString();
    final String[] lines=bigString.split(""String_Node_Str"");
    for (    String line : lines) {
      Log.d(TAG,line);
    }
  }
}",0.5905511811023622
87832,"/** 
 * Publish the contents of this LogUnit to researchLog.
 */
public synchronized void publishTo(final ResearchLog researchLog,final boolean isIncludingPrivateData){
  final int size=mLogStatementList.size();
  for (int i=0; i < size; i++) {
    final LogStatement logStatement=mLogStatementList.get(i);
    if (!isIncludingPrivateData && logStatement.mIsPotentiallyPrivate) {
      continue;
    }
    if (mIsPartOfMegaword && logStatement.mIsPotentiallyRevealing) {
      continue;
    }
    final JsonWriter jsonWriter=researchLog.getValidJsonWriterLocked();
    outputLogStatementToLocked(jsonWriter,mLogStatementList.get(i),mValuesList.get(i),mTimeList.get(i));
  }
}","/** 
 * Publish the contents of this LogUnit to researchLog.
 */
public synchronized void publishTo(final ResearchLog researchLog,final boolean isIncludingPrivateData){
  final StringWriter debugStringWriter;
  final JsonWriter debugJsonWriter;
  if (DEBUG) {
    debugStringWriter=new StringWriter();
    debugJsonWriter=new JsonWriter(debugStringWriter);
    debugJsonWriter.setIndent(""String_Node_Str"");
    try {
      debugJsonWriter.beginArray();
    }
 catch (    IOException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
 else {
    debugStringWriter=null;
    debugJsonWriter=null;
  }
  final int size=mLogStatementList.size();
  for (int i=0; i < size; i++) {
    final LogStatement logStatement=mLogStatementList.get(i);
    if (!isIncludingPrivateData && logStatement.mIsPotentiallyPrivate) {
      continue;
    }
    if (mIsPartOfMegaword && logStatement.mIsPotentiallyRevealing) {
      continue;
    }
    final JsonWriter jsonWriter=researchLog.getValidJsonWriterLocked();
    outputLogStatementToLocked(jsonWriter,mLogStatementList.get(i),mValuesList.get(i),mTimeList.get(i));
    if (DEBUG) {
      outputLogStatementToLocked(debugJsonWriter,mLogStatementList.get(i),mValuesList.get(i),mTimeList.get(i));
    }
  }
  if (DEBUG) {
    try {
      debugJsonWriter.endArray();
      debugJsonWriter.flush();
    }
 catch (    IOException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
    final String bigString=debugStringWriter.getBuffer().toString();
    final String[] lines=bigString.split(""String_Node_Str"");
    for (    String line : lines) {
      Log.d(TAG,line);
    }
  }
}",0.5905511811023622
87833,"/** 
 * Publish the contents of this LogUnit to researchLog.
 */
public synchronized void publishTo(final ResearchLog researchLog,final boolean isIncludingPrivateData){
  final int size=mLogStatementList.size();
  for (int i=0; i < size; i++) {
    final LogStatement logStatement=mLogStatementList.get(i);
    if (!isIncludingPrivateData && logStatement.mIsPotentiallyPrivate) {
      continue;
    }
    if (mIsPartOfMegaword && logStatement.mIsPotentiallyRevealing) {
      continue;
    }
    final JsonWriter jsonWriter=researchLog.getValidJsonWriterLocked();
    outputLogStatementToLocked(jsonWriter,mLogStatementList.get(i),mValuesList.get(i),mTimeList.get(i));
  }
}","/** 
 * Publish the contents of this LogUnit to researchLog.
 */
public synchronized void publishTo(final ResearchLog researchLog,final boolean isIncludingPrivateData){
  final StringWriter debugStringWriter;
  final JsonWriter debugJsonWriter;
  if (DEBUG) {
    debugStringWriter=new StringWriter();
    debugJsonWriter=new JsonWriter(debugStringWriter);
    debugJsonWriter.setIndent(""String_Node_Str"");
    try {
      debugJsonWriter.beginArray();
    }
 catch (    IOException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
 else {
    debugStringWriter=null;
    debugJsonWriter=null;
  }
  final int size=mLogStatementList.size();
  for (int i=0; i < size; i++) {
    final LogStatement logStatement=mLogStatementList.get(i);
    if (!isIncludingPrivateData && logStatement.mIsPotentiallyPrivate) {
      continue;
    }
    if (mIsPartOfMegaword && logStatement.mIsPotentiallyRevealing) {
      continue;
    }
    final JsonWriter jsonWriter=researchLog.getValidJsonWriterLocked();
    outputLogStatementToLocked(jsonWriter,mLogStatementList.get(i),mValuesList.get(i),mTimeList.get(i));
    if (DEBUG) {
      outputLogStatementToLocked(debugJsonWriter,mLogStatementList.get(i),mValuesList.get(i),mTimeList.get(i));
    }
  }
  if (DEBUG) {
    try {
      debugJsonWriter.endArray();
      debugJsonWriter.flush();
    }
 catch (    IOException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
    final String bigString=debugStringWriter.getBuffer().toString();
    final String[] lines=bigString.split(""String_Node_Str"");
    for (    String line : lines) {
      Log.d(TAG,line);
    }
  }
}",0.5905511811023622
87834,"void commitCurrentLogUnit(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (mCurrentLogUnit.hasWord() ? ""String_Node_Str"" + mCurrentLogUnit.getWord() : ""String_Node_Str""));
  }
  if (!mCurrentLogUnit.isEmpty()) {
    if (mMainLogBuffer != null) {
      mMainLogBuffer.shiftIn(mCurrentLogUnit);
      if (mMainLogBuffer.isSafeToLog() && mMainResearchLog != null) {
        publishLogBuffer(mMainLogBuffer,mMainResearchLog,true);
        mMainLogBuffer.resetWordCounter();
      }
    }
    if (mFeedbackLogBuffer != null) {
      mFeedbackLogBuffer.shiftIn(mCurrentLogUnit);
    }
    mCurrentLogUnit=new LogUnit();
  }
}","void commitCurrentLogUnit(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (mCurrentLogUnit.hasWord() ? ""String_Node_Str"" + mCurrentLogUnit.getWord() : ""String_Node_Str""));
  }
  if (!mCurrentLogUnit.isEmpty()) {
    if (mMainLogBuffer != null) {
      mMainLogBuffer.shiftIn(mCurrentLogUnit);
      if ((mMainLogBuffer.isSafeToLog() || LOG_EVERYTHING) && mMainResearchLog != null) {
        publishLogBuffer(mMainLogBuffer,mMainResearchLog,true);
        mMainLogBuffer.resetWordCounter();
      }
    }
    if (mFeedbackLogBuffer != null) {
      mFeedbackLogBuffer.shiftIn(mCurrentLogUnit);
    }
    mCurrentLogUnit=new LogUnit();
  }
}",0.9842022116903634
87835,"void commitCurrentLogUnit(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (mCurrentLogUnit.hasWord() ? ""String_Node_Str"" + mCurrentLogUnit.getWord() : ""String_Node_Str""));
  }
  if (!mCurrentLogUnit.isEmpty()) {
    if (mMainLogBuffer != null) {
      mMainLogBuffer.shiftIn(mCurrentLogUnit);
      if (mMainLogBuffer.isSafeToLog() && mMainResearchLog != null) {
        publishLogBuffer(mMainLogBuffer,mMainResearchLog,true);
        mMainLogBuffer.resetWordCounter();
      }
    }
    if (mFeedbackLogBuffer != null) {
      mFeedbackLogBuffer.shiftIn(mCurrentLogUnit);
    }
    mCurrentLogUnit=new LogUnit();
  }
}","void commitCurrentLogUnit(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (mCurrentLogUnit.hasWord() ? ""String_Node_Str"" + mCurrentLogUnit.getWord() : ""String_Node_Str""));
  }
  if (!mCurrentLogUnit.isEmpty()) {
    if (mMainLogBuffer != null) {
      mMainLogBuffer.shiftIn(mCurrentLogUnit);
      if ((mMainLogBuffer.isSafeToLog() || LOG_EVERYTHING) && mMainResearchLog != null) {
        publishLogBuffer(mMainLogBuffer,mMainResearchLog,true);
        mMainLogBuffer.resetWordCounter();
      }
    }
    if (mFeedbackLogBuffer != null) {
      mFeedbackLogBuffer.shiftIn(mCurrentLogUnit);
    }
    mCurrentLogUnit=new LogUnit();
  }
}",0.9842022116903634
87836,"void commitCurrentLogUnit(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (mCurrentLogUnit.hasWord() ? ""String_Node_Str"" + mCurrentLogUnit.getWord() : ""String_Node_Str""));
  }
  if (!mCurrentLogUnit.isEmpty()) {
    if (mMainLogBuffer != null) {
      mMainLogBuffer.shiftIn(mCurrentLogUnit);
      if (mMainLogBuffer.isSafeToLog() && mMainResearchLog != null) {
        publishLogBuffer(mMainLogBuffer,mMainResearchLog,true);
        mMainLogBuffer.resetWordCounter();
      }
    }
    if (mFeedbackLogBuffer != null) {
      mFeedbackLogBuffer.shiftIn(mCurrentLogUnit);
    }
    mCurrentLogUnit=new LogUnit();
  }
}","void commitCurrentLogUnit(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (mCurrentLogUnit.hasWord() ? ""String_Node_Str"" + mCurrentLogUnit.getWord() : ""String_Node_Str""));
  }
  if (!mCurrentLogUnit.isEmpty()) {
    if (mMainLogBuffer != null) {
      mMainLogBuffer.shiftIn(mCurrentLogUnit);
      if ((mMainLogBuffer.isSafeToLog() || LOG_EVERYTHING) && mMainResearchLog != null) {
        publishLogBuffer(mMainLogBuffer,mMainResearchLog,true);
        mMainLogBuffer.resetWordCounter();
      }
    }
    if (mFeedbackLogBuffer != null) {
      mFeedbackLogBuffer.shiftIn(mCurrentLogUnit);
    }
    mCurrentLogUnit=new LogUnit();
  }
}",0.9842022116903634
87837,"@Override public void showMoreKeysPanel(final View parentView,final Controller controller,final int pointX,final int pointY,final KeyboardActionListener listener){
  mController=controller;
  mListener=listener;
  final View container=getContainerView();
  final int x=pointX - getDefaultCoordX() - container.getPaddingLeft();
  final int y=pointY - container.getMeasuredHeight() + container.getPaddingBottom();
  parentView.getLocationInWindow(mCoordinates);
  final int maxX=parentView.getMeasuredWidth() - container.getMeasuredWidth();
  final int panelX=Math.max(0,Math.min(maxX,x + CoordinateUtils.x(mCoordinates)));
  final int panelY=y + CoordinateUtils.y(mCoordinates);
  container.setX(panelX);
  container.setY(panelY);
  mOriginX=x + container.getPaddingLeft();
  mOriginY=y + container.getPaddingTop();
  controller.onShowMoreKeysPanel(this);
}","@Override public void showMoreKeysPanel(final View parentView,final Controller controller,final int pointX,final int pointY,final KeyboardActionListener listener){
  mController=controller;
  mListener=listener;
  final View container=getContainerView();
  final int x=pointX - getDefaultCoordX() - container.getPaddingLeft();
  final int y=pointY - container.getMeasuredHeight() + container.getPaddingBottom();
  parentView.getLocationInWindow(mCoordinates);
  final int maxX=parentView.getMeasuredWidth() - container.getMeasuredWidth();
  final int panelX=Math.max(0,Math.min(maxX,x)) + CoordinateUtils.x(mCoordinates);
  final int panelY=y + CoordinateUtils.y(mCoordinates);
  container.setX(panelX);
  container.setY(panelY);
  mOriginX=x + container.getPaddingLeft();
  mOriginY=y + container.getPaddingTop();
  controller.onShowMoreKeysPanel(this);
}",0.9976635514018692
87838,"@Override public void showMoreKeysPanel(final View parentView,final Controller controller,final int pointX,final int pointY,final KeyboardActionListener listener){
  mController=controller;
  mListener=listener;
  final View container=getContainerView();
  final int x=pointX - getDefaultCoordX() - container.getPaddingLeft();
  final int y=pointY - container.getMeasuredHeight() + container.getPaddingBottom();
  parentView.getLocationInWindow(mCoordinates);
  final int maxX=parentView.getMeasuredWidth() - container.getMeasuredWidth();
  final int panelX=Math.max(0,Math.min(maxX,x + CoordinateUtils.x(mCoordinates)));
  final int panelY=y + CoordinateUtils.y(mCoordinates);
  container.setX(panelX);
  container.setY(panelY);
  mOriginX=x + container.getPaddingLeft();
  mOriginY=y + container.getPaddingTop();
  controller.onShowMoreKeysPanel(this);
}","@Override public void showMoreKeysPanel(final View parentView,final Controller controller,final int pointX,final int pointY,final KeyboardActionListener listener){
  mController=controller;
  mListener=listener;
  final View container=getContainerView();
  final int x=pointX - getDefaultCoordX() - container.getPaddingLeft();
  final int y=pointY - container.getMeasuredHeight() + container.getPaddingBottom();
  parentView.getLocationInWindow(mCoordinates);
  final int maxX=parentView.getMeasuredWidth() - container.getMeasuredWidth();
  final int panelX=Math.max(0,Math.min(maxX,x)) + CoordinateUtils.x(mCoordinates);
  final int panelY=y + CoordinateUtils.y(mCoordinates);
  container.setX(panelX);
  container.setY(panelY);
  mOriginX=x + container.getPaddingLeft();
  mOriginY=y + container.getPaddingTop();
  controller.onShowMoreKeysPanel(this);
}",0.9976635514018692
87839,"/** 
 * Draw gesture preview trail
 * @param canvas The canvas to draw the gesture preview trail
 * @param paint The paint object to be used to draw the gesture preview trail
 * @param outBoundsRect the bounding box of this gesture trail drawing
 * @param params The drawing parameters of gesture preview trail
 * @return true if some gesture preview trails remain to be drawn
 */
public boolean drawGestureTrail(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine line=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    int lastTime=sinceDown - eventTimes[startIndex];
    float maxWidth=getWidth(lastTime,params);
    float r1=maxWidth / 2.0f;
    outBoundsRect.set(p1x,p1y,p1x,p1y);
    for (int i=startIndex + 1; i < trailSize - 1; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float width=getWidth(elapsedTime,params);
      final float r2=width / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final int alpha=getAlpha(elapsedTime,params);
        paint.setAlpha(alpha);
        final Path path=line.makePath(p1x,p1y,r1,p2x,p2y,r2);
        if (path != null) {
          canvas.drawPath(path,paint);
          outBoundsRect.union(p2x,p2y);
        }
        maxWidth=Math.max(maxWidth,width);
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
      lastTime=elapsedTime;
    }
    final int inset=-((int)maxWidth + 1);
    outBoundsRect.inset(inset,inset);
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
  }
  return newSize > 0;
}","/** 
 * Draw gesture preview trail
 * @param canvas The canvas to draw the gesture preview trail
 * @param paint The paint object to be used to draw the gesture preview trail
 * @param outBoundsRect the bounding box of this gesture trail drawing
 * @param params The drawing parameters of gesture preview trail
 * @return true if some gesture preview trails remain to be drawn
 */
public boolean drawGestureTrail(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine line=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    int lastTime=sinceDown - eventTimes[startIndex];
    float maxWidth=getWidth(lastTime,params);
    float r1=maxWidth / 2.0f;
    outBoundsRect.set(p1x,p1y,p1x,p1y);
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float width=getWidth(elapsedTime,params);
      final float r2=width / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final int alpha=getAlpha(elapsedTime,params);
        paint.setAlpha(alpha);
        final Path path=line.makePath(p1x,p1y,r1,p2x,p2y,r2);
        if (path != null) {
          canvas.drawPath(path,paint);
          outBoundsRect.union(p2x,p2y);
        }
        maxWidth=Math.max(maxWidth,width);
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
      lastTime=elapsedTime;
    }
    final int inset=-((int)maxWidth + 1);
    outBoundsRect.inset(inset,inset);
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
  }
  return newSize > 0;
}",0.9992756247736329
87840,"/** 
 * Draw gesture preview trail
 * @param canvas The canvas to draw the gesture preview trail
 * @param paint The paint object to be used to draw the gesture preview trail
 * @param outBoundsRect the bounding box of this gesture trail drawing
 * @param params The drawing parameters of gesture preview trail
 * @return true if some gesture preview trails remain to be drawn
 */
public boolean drawGestureTrail(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine line=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    int lastTime=sinceDown - eventTimes[startIndex];
    float maxWidth=getWidth(lastTime,params);
    float r1=maxWidth / 2.0f;
    outBoundsRect.set(p1x,p1y,p1x,p1y);
    for (int i=startIndex + 1; i < trailSize - 1; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float width=getWidth(elapsedTime,params);
      final float r2=width / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final int alpha=getAlpha(elapsedTime,params);
        paint.setAlpha(alpha);
        final Path path=line.makePath(p1x,p1y,r1,p2x,p2y,r2);
        if (path != null) {
          canvas.drawPath(path,paint);
          outBoundsRect.union(p2x,p2y);
        }
        maxWidth=Math.max(maxWidth,width);
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
      lastTime=elapsedTime;
    }
    final int inset=-((int)maxWidth + 1);
    outBoundsRect.inset(inset,inset);
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
  }
  return newSize > 0;
}","/** 
 * Draw gesture preview trail
 * @param canvas The canvas to draw the gesture preview trail
 * @param paint The paint object to be used to draw the gesture preview trail
 * @param outBoundsRect the bounding box of this gesture trail drawing
 * @param params The drawing parameters of gesture preview trail
 * @return true if some gesture preview trails remain to be drawn
 */
public boolean drawGestureTrail(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine line=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    int lastTime=sinceDown - eventTimes[startIndex];
    float maxWidth=getWidth(lastTime,params);
    float r1=maxWidth / 2.0f;
    outBoundsRect.set(p1x,p1y,p1x,p1y);
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float width=getWidth(elapsedTime,params);
      final float r2=width / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final int alpha=getAlpha(elapsedTime,params);
        paint.setAlpha(alpha);
        final Path path=line.makePath(p1x,p1y,r1,p2x,p2y,r2);
        if (path != null) {
          canvas.drawPath(path,paint);
          outBoundsRect.union(p2x,p2y);
        }
        maxWidth=Math.max(maxWidth,width);
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
      lastTime=elapsedTime;
    }
    final int inset=-((int)maxWidth + 1);
    outBoundsRect.inset(inset,inset);
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
  }
  return newSize > 0;
}",0.9992756247736329
87841,"/** 
 * Draw gesture preview trail
 * @param canvas The canvas to draw the gesture preview trail
 * @param paint The paint object to be used to draw the gesture preview trail
 * @param outBoundsRect the bounding box of this gesture trail drawing
 * @param params The drawing parameters of gesture preview trail
 * @return true if some gesture preview trails remain to be drawn
 */
public boolean drawGestureTrail(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine line=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    int lastTime=sinceDown - eventTimes[startIndex];
    float maxWidth=getWidth(lastTime,params);
    float r1=maxWidth / 2.0f;
    outBoundsRect.set(p1x,p1y,p1x,p1y);
    for (int i=startIndex + 1; i < trailSize - 1; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float width=getWidth(elapsedTime,params);
      final float r2=width / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final int alpha=getAlpha(elapsedTime,params);
        paint.setAlpha(alpha);
        final Path path=line.makePath(p1x,p1y,r1,p2x,p2y,r2);
        if (path != null) {
          canvas.drawPath(path,paint);
          outBoundsRect.union(p2x,p2y);
        }
        maxWidth=Math.max(maxWidth,width);
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
      lastTime=elapsedTime;
    }
    final int inset=-((int)maxWidth + 1);
    outBoundsRect.inset(inset,inset);
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
  }
  return newSize > 0;
}","/** 
 * Draw gesture preview trail
 * @param canvas The canvas to draw the gesture preview trail
 * @param paint The paint object to be used to draw the gesture preview trail
 * @param outBoundsRect the bounding box of this gesture trail drawing
 * @param params The drawing parameters of gesture preview trail
 * @return true if some gesture preview trails remain to be drawn
 */
public boolean drawGestureTrail(final Canvas canvas,final Paint paint,final Rect outBoundsRect,final Params params){
  final int trailSize=mEventTimes.getLength();
  if (trailSize == 0) {
    return false;
  }
  final int[] eventTimes=mEventTimes.getPrimitiveArray();
  final int[] xCoords=mXCoordinates.getPrimitiveArray();
  final int[] yCoords=mYCoordinates.getPrimitiveArray();
  final int sinceDown=(int)(SystemClock.uptimeMillis() - mCurrentTimeBase);
  int startIndex;
  for (startIndex=mTrailStartIndex; startIndex < trailSize; startIndex++) {
    final int elapsedTime=sinceDown - eventTimes[startIndex];
    if (elapsedTime < params.mTrailLingerDuration) {
      break;
    }
  }
  mTrailStartIndex=startIndex;
  if (startIndex < trailSize) {
    paint.setColor(params.mTrailColor);
    paint.setStyle(Paint.Style.FILL);
    final RoundedLine line=mRoundedLine;
    int p1x=getXCoordValue(xCoords[startIndex]);
    int p1y=yCoords[startIndex];
    int lastTime=sinceDown - eventTimes[startIndex];
    float maxWidth=getWidth(lastTime,params);
    float r1=maxWidth / 2.0f;
    outBoundsRect.set(p1x,p1y,p1x,p1y);
    for (int i=startIndex + 1; i < trailSize; i++) {
      final int elapsedTime=sinceDown - eventTimes[i];
      final int p2x=getXCoordValue(xCoords[i]);
      final int p2y=yCoords[i];
      final float width=getWidth(elapsedTime,params);
      final float r2=width / 2.0f;
      if (!isDownEventXCoord(xCoords[i])) {
        final int alpha=getAlpha(elapsedTime,params);
        paint.setAlpha(alpha);
        final Path path=line.makePath(p1x,p1y,r1,p2x,p2y,r2);
        if (path != null) {
          canvas.drawPath(path,paint);
          outBoundsRect.union(p2x,p2y);
        }
        maxWidth=Math.max(maxWidth,width);
      }
      p1x=p2x;
      p1y=p2y;
      r1=r2;
      lastTime=elapsedTime;
    }
    final int inset=-((int)maxWidth + 1);
    outBoundsRect.inset(inset,inset);
  }
  final int newSize=trailSize - startIndex;
  if (newSize < startIndex) {
    mTrailStartIndex=0;
    if (newSize > 0) {
      System.arraycopy(eventTimes,startIndex,eventTimes,0,newSize);
      System.arraycopy(xCoords,startIndex,xCoords,0,newSize);
      System.arraycopy(yCoords,startIndex,yCoords,0,newSize);
    }
    mEventTimes.setLength(newSize);
    mXCoordinates.setLength(newSize);
    mYCoordinates.setLength(newSize);
  }
  return newSize > 0;
}",0.9992756247736329
87842,"public static void latinIME_onWindowHidden(final int savedSelectionStart,final int savedSelectionEnd,final InputConnection ic){
  if (ic != null) {
    ic.beginBatchEdit();
    ic.performContextMenuAction(android.R.id.selectAll);
    CharSequence charSequence=ic.getSelectedText(0);
    ic.setSelection(savedSelectionStart,savedSelectionEnd);
    ic.endBatchEdit();
    sLatinIMEExpectingUpdateSelection=true;
    final Object[] values=new Object[2];
    if (OUTPUT_ENTIRE_BUFFER) {
      if (TextUtils.isEmpty(charSequence)) {
        values[0]=false;
        values[1]=""String_Node_Str"";
      }
 else {
        if (charSequence.length() > MAX_INPUTVIEW_LENGTH_TO_CAPTURE) {
          int length=MAX_INPUTVIEW_LENGTH_TO_CAPTURE;
          final char c=charSequence.charAt(length - 1);
          if (Character.isHighSurrogate(c)) {
            length--;
          }
          final CharSequence truncatedCharSequence=charSequence.subSequence(0,length);
          values[0]=true;
          values[1]=truncatedCharSequence.toString();
        }
 else {
          values[0]=false;
          values[1]=charSequence.toString();
        }
      }
    }
 else {
      values[0]=true;
      values[1]=""String_Node_Str"";
    }
    final ResearchLogger researchLogger=getInstance();
    researchLogger.enqueueEvent(EVENTKEYS_LATINIME_ONWINDOWHIDDEN,values);
    researchLogger.commitCurrentLogUnit();
    getInstance().stop();
  }
}","public static void latinIME_onWindowHidden(final int savedSelectionStart,final int savedSelectionEnd,final InputConnection ic){
  if (ic != null) {
    final Object[] values=new Object[2];
    if (OUTPUT_ENTIRE_BUFFER) {
      ic.beginBatchEdit();
      ic.performContextMenuAction(android.R.id.selectAll);
      CharSequence charSequence=ic.getSelectedText(0);
      if (savedSelectionStart != -1 && savedSelectionEnd != -1) {
        ic.setSelection(savedSelectionStart,savedSelectionEnd);
      }
      ic.endBatchEdit();
      sLatinIMEExpectingUpdateSelection=true;
      if (TextUtils.isEmpty(charSequence)) {
        values[0]=false;
        values[1]=""String_Node_Str"";
      }
 else {
        if (charSequence.length() > MAX_INPUTVIEW_LENGTH_TO_CAPTURE) {
          int length=MAX_INPUTVIEW_LENGTH_TO_CAPTURE;
          final char c=charSequence.charAt(length - 1);
          if (Character.isHighSurrogate(c)) {
            length--;
          }
          final CharSequence truncatedCharSequence=charSequence.subSequence(0,length);
          values[0]=true;
          values[1]=truncatedCharSequence.toString();
        }
 else {
          values[0]=false;
          values[1]=charSequence.toString();
        }
      }
    }
 else {
      values[0]=true;
      values[1]=""String_Node_Str"";
    }
    final ResearchLogger researchLogger=getInstance();
    researchLogger.enqueueEvent(EVENTKEYS_LATINIME_ONWINDOWHIDDEN,values);
    researchLogger.commitCurrentLogUnit();
    getInstance().stop();
  }
}",0.7914110429447853
87843,"public static void latinIME_onWindowHidden(final int savedSelectionStart,final int savedSelectionEnd,final InputConnection ic){
  if (ic != null) {
    ic.beginBatchEdit();
    ic.performContextMenuAction(android.R.id.selectAll);
    CharSequence charSequence=ic.getSelectedText(0);
    ic.setSelection(savedSelectionStart,savedSelectionEnd);
    ic.endBatchEdit();
    sLatinIMEExpectingUpdateSelection=true;
    final Object[] values=new Object[2];
    if (OUTPUT_ENTIRE_BUFFER) {
      if (TextUtils.isEmpty(charSequence)) {
        values[0]=false;
        values[1]=""String_Node_Str"";
      }
 else {
        if (charSequence.length() > MAX_INPUTVIEW_LENGTH_TO_CAPTURE) {
          int length=MAX_INPUTVIEW_LENGTH_TO_CAPTURE;
          final char c=charSequence.charAt(length - 1);
          if (Character.isHighSurrogate(c)) {
            length--;
          }
          final CharSequence truncatedCharSequence=charSequence.subSequence(0,length);
          values[0]=true;
          values[1]=truncatedCharSequence.toString();
        }
 else {
          values[0]=false;
          values[1]=charSequence.toString();
        }
      }
    }
 else {
      values[0]=true;
      values[1]=""String_Node_Str"";
    }
    final ResearchLogger researchLogger=getInstance();
    researchLogger.enqueueEvent(EVENTKEYS_LATINIME_ONWINDOWHIDDEN,values);
    researchLogger.commitCurrentLogUnit();
    getInstance().stop();
  }
}","public static void latinIME_onWindowHidden(final int savedSelectionStart,final int savedSelectionEnd,final InputConnection ic){
  if (ic != null) {
    final Object[] values=new Object[2];
    if (OUTPUT_ENTIRE_BUFFER) {
      ic.beginBatchEdit();
      ic.performContextMenuAction(android.R.id.selectAll);
      CharSequence charSequence=ic.getSelectedText(0);
      if (savedSelectionStart != -1 && savedSelectionEnd != -1) {
        ic.setSelection(savedSelectionStart,savedSelectionEnd);
      }
      ic.endBatchEdit();
      sLatinIMEExpectingUpdateSelection=true;
      if (TextUtils.isEmpty(charSequence)) {
        values[0]=false;
        values[1]=""String_Node_Str"";
      }
 else {
        if (charSequence.length() > MAX_INPUTVIEW_LENGTH_TO_CAPTURE) {
          int length=MAX_INPUTVIEW_LENGTH_TO_CAPTURE;
          final char c=charSequence.charAt(length - 1);
          if (Character.isHighSurrogate(c)) {
            length--;
          }
          final CharSequence truncatedCharSequence=charSequence.subSequence(0,length);
          values[0]=true;
          values[1]=truncatedCharSequence.toString();
        }
 else {
          values[0]=false;
          values[1]=charSequence.toString();
        }
      }
    }
 else {
      values[0]=true;
      values[1]=""String_Node_Str"";
    }
    final ResearchLogger researchLogger=getInstance();
    researchLogger.enqueueEvent(EVENTKEYS_LATINIME_ONWINDOWHIDDEN,values);
    researchLogger.commitCurrentLogUnit();
    getInstance().stop();
  }
}",0.7914110429447853
87844,"private void setContextThemeWrapper(Context context,KeyboardTheme keyboardTheme){
  if (mKeyboardTheme.mThemeId != keyboardTheme.mThemeId) {
    mKeyboardTheme=keyboardTheme;
    mThemeContext=new ContextThemeWrapper(context,keyboardTheme.mStyleId);
    KeyboardLayoutSet.clearKeyboardCache();
  }
}","private void setContextThemeWrapper(Context context,KeyboardTheme keyboardTheme){
  if (mThemeContext == null || mKeyboardTheme.mThemeId != keyboardTheme.mThemeId) {
    mKeyboardTheme=keyboardTheme;
    mThemeContext=new ContextThemeWrapper(context,keyboardTheme.mStyleId);
    KeyboardLayoutSet.clearKeyboardCache();
  }
}",0.9598715890850722
87845,"public void resetCachesUponCursorMove(final int newCursorPosition){
  mCurrentCursorPosition=newCursorPosition;
  mComposingText.setLength(0);
  mCommittedTextBeforeComposingText.setLength(0);
  mCommittedTextBeforeComposingText.append(getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0));
  mCharAfterTheCursor=getTextAfterCursor(1,0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}","public void resetCachesUponCursorMove(final int newCursorPosition){
  mCurrentCursorPosition=newCursorPosition;
  mComposingText.setLength(0);
  mCommittedTextBeforeComposingText.setLength(0);
  final CharSequence textBeforeCursor=getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0);
  if (null != textBeforeCursor)   mCommittedTextBeforeComposingText.append(textBeforeCursor);
  mCharAfterTheCursor=getTextAfterCursor(1,0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}",0.8623853211009175
87846,"public void resetCachesUponCursorMove(final int newCursorPosition){
  mCurrentCursorPosition=newCursorPosition;
  mComposingText.setLength(0);
  mCommittedTextBeforeComposingText.setLength(0);
  mCommittedTextBeforeComposingText.append(getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0));
  mCharAfterTheCursor=getTextAfterCursor(1,0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}","public void resetCachesUponCursorMove(final int newCursorPosition){
  mCurrentCursorPosition=newCursorPosition;
  mComposingText.setLength(0);
  mCommittedTextBeforeComposingText.setLength(0);
  final CharSequence textBeforeCursor=getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0);
  if (null != textBeforeCursor)   mCommittedTextBeforeComposingText.append(textBeforeCursor);
  mCharAfterTheCursor=getTextAfterCursor(1,0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}",0.8623853211009175
87847,"public void resetCachesUponCursorMove(final int newCursorPosition){
  mCurrentCursorPosition=newCursorPosition;
  mComposingText.setLength(0);
  mCommittedTextBeforeComposingText.setLength(0);
  mCommittedTextBeforeComposingText.append(getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0));
  mCharAfterTheCursor=getTextAfterCursor(1,0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}","public void resetCachesUponCursorMove(final int newCursorPosition){
  mCurrentCursorPosition=newCursorPosition;
  mComposingText.setLength(0);
  mCommittedTextBeforeComposingText.setLength(0);
  final CharSequence textBeforeCursor=getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0);
  if (null != textBeforeCursor)   mCommittedTextBeforeComposingText.append(textBeforeCursor);
  mCharAfterTheCursor=getTextAfterCursor(1,0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}",0.8623853211009175
87848,"public void resetCachesUponCursorMove(final int newCursorPosition){
  mCurrentCursorPosition=newCursorPosition;
  mComposingText.setLength(0);
  mCommittedTextBeforeComposingText.setLength(0);
  mCommittedTextBeforeComposingText.append(getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0));
  mCharAfterTheCursor=getTextAfterCursor(1,0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}","public void resetCachesUponCursorMove(final int newCursorPosition){
  mCurrentCursorPosition=newCursorPosition;
  mComposingText.setLength(0);
  mCommittedTextBeforeComposingText.setLength(0);
  final CharSequence textBeforeCursor=getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0);
  if (null != textBeforeCursor)   mCommittedTextBeforeComposingText.append(textBeforeCursor);
  mCharAfterTheCursor=getTextAfterCursor(1,0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}",0.8623853211009175
87849,"public void resetCachesUponCursorMove(final int newCursorPosition){
  mCurrentCursorPosition=newCursorPosition;
  mComposingText.setLength(0);
  mCommittedTextBeforeComposingText.setLength(0);
  mCommittedTextBeforeComposingText.append(getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0));
  mCharAfterTheCursor=getTextAfterCursor(1,0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}","public void resetCachesUponCursorMove(final int newCursorPosition){
  mCurrentCursorPosition=newCursorPosition;
  mComposingText.setLength(0);
  mCommittedTextBeforeComposingText.setLength(0);
  final CharSequence textBeforeCursor=getTextBeforeCursor(DEFAULT_TEXT_CACHE_SIZE,0);
  if (null != textBeforeCursor)   mCommittedTextBeforeComposingText.append(textBeforeCursor);
  mCharAfterTheCursor=getTextAfterCursor(1,0);
  if (null != mIC) {
    mIC.finishComposingText();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.richInputConnection_finishComposingText();
    }
  }
}",0.8623853211009175
87850,"private static boolean hasAttributesDifferencesAndPrintThemIfAny(final String word,final String type,final ArrayList<WeightedString> list0,final ArrayList<WeightedString> list1){
  if (null == list1) {
    if (null == list0)     return false;
    for (    final WeightedString attribute0 : list0) {
      System.out.println(type + ""String_Node_Str"" + word+ ""String_Node_Str""+ attribute0.mWord+ ""String_Node_Str""+ attribute0.mFrequency);
    }
    return true;
  }
  boolean hasDifferences=false;
  if (null != list0) {
    for (    final WeightedString attribute0 : list0) {
      if (!list1.contains(attribute0)) {
        hasDifferences=true;
        for (        final WeightedString attribute1 : list1) {
          if (attribute0.mWord.equals(attribute1.mWord)) {
            System.out.println(type + ""String_Node_Str"" + word+ ""String_Node_Str""+ attribute0.mWord+ ""String_Node_Str""+ attribute0.mFrequency+ ""String_Node_Str""+ attribute1.mFrequency);
            list1.remove(attribute1);
            break;
          }
          System.out.println(type + ""String_Node_Str"" + word+ ""String_Node_Str""+ attribute0.mWord);
        }
      }
 else {
        list1.remove(attribute0);
      }
    }
  }
  for (  final WeightedString attribute1 : list1) {
    hasDifferences=true;
    System.out.println(type + ""String_Node_Str"" + word+ ""String_Node_Str""+ attribute1.mWord+ ""String_Node_Str""+ attribute1.mFrequency);
  }
  return hasDifferences;
}","private static boolean hasAttributesDifferencesAndPrintThemIfAny(final String word,final String type,final ArrayList<WeightedString> list0,final ArrayList<WeightedString> list1){
  if (null == list1) {
    if (null == list0)     return false;
    for (    final WeightedString attribute0 : list0) {
      System.out.println(type + ""String_Node_Str"" + word+ ""String_Node_Str""+ attribute0.mWord+ ""String_Node_Str""+ attribute0.mFrequency);
    }
    return true;
  }
  boolean hasDifferences=false;
  if (null != list0) {
    for (    final WeightedString attribute0 : list0) {
      if (!list1.contains(attribute0)) {
        hasDifferences=true;
        boolean foundString=false;
        for (        final WeightedString attribute1 : list1) {
          if (attribute0.mWord.equals(attribute1.mWord)) {
            System.out.println(type + ""String_Node_Str"" + word+ ""String_Node_Str""+ attribute0.mWord+ ""String_Node_Str""+ attribute0.mFrequency+ ""String_Node_Str""+ attribute1.mFrequency);
            list1.remove(attribute1);
            foundString=true;
            break;
          }
        }
        if (!foundString) {
          System.out.println(type + ""String_Node_Str"" + word+ ""String_Node_Str""+ attribute0.mWord+ ""String_Node_Str""+ attribute0.mFrequency);
        }
      }
 else {
        list1.remove(attribute0);
      }
    }
  }
  for (  final WeightedString attribute1 : list1) {
    hasDifferences=true;
    System.out.println(type + ""String_Node_Str"" + word+ ""String_Node_Str""+ attribute1.mWord+ ""String_Node_Str""+ attribute1.mFrequency);
  }
  return hasDifferences;
}",0.9521925486317178
87851,"/** 
 * Helper method to add a new bigram to the dictionary.
 * @param word1 the previous word of the context
 * @param word2 the next word of the context
 * @param frequency the bigram frequency
 */
public void setBigram(final String word1,final String word2,final int frequency){
  CharGroup charGroup=findWordInTree(mRoot,word1);
  if (charGroup != null) {
    final CharGroup charGroup2=findWordInTree(mRoot,word2);
    if (charGroup2 == null) {
      add(getCodePoints(word2),0,null,false,false);
    }
    charGroup.addBigram(word2,frequency);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * Helper method to add a new bigram to the dictionary.
 * @param word1 the previous word of the context
 * @param word2 the next word of the context
 * @param frequency the bigram frequency
 */
public void setBigram(final String word1,final String word2,final int frequency){
  CharGroup charGroup=findWordInTree(mRoot,word1);
  if (charGroup != null) {
    final CharGroup charGroup2=findWordInTree(mRoot,word2);
    if (charGroup2 == null) {
      add(getCodePoints(word2),0,null,false,false);
      charGroup=findWordInTree(mRoot,word1);
    }
    charGroup.addBigram(word2,frequency);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.9648711943793912
87852,"@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  final boolean inputTypeChanged=!mCurrentSettings.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    final boolean currentSubtypeEnabled=mSubtypeSwitcher.updateParametersOnStartInputViewAndReturnIfCurrentSubtypeEnabled();
    if (!currentSubtypeEnabled) {
      final InputMethodSubtype newSubtype=ImfUtils.getCurrentInputMethodSubtype(this,mSubtypeSwitcher.getNoLanguageSubtype());
      mSubtypeSwitcher.updateSubtype(newSubtype);
      loadKeyboard();
    }
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  if (isDifferentTextField || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      setPunctuationSuggestions();
    }
  }
  mConnection.resetCachesUponCursorMove(mLastSelectionStart);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mKeyboardSwitcher.updateShiftState();
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setGestureHandlingEnabledByUser(mCurrentSettings.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(mCurrentSettings.mGesturePreviewTrailEnabled,mCurrentSettings.mGestureFloatingPreviewTextEnabled);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  final boolean inputTypeChanged=!mCurrentSettings.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    final boolean currentSubtypeEnabled=mSubtypeSwitcher.updateParametersOnStartInputViewAndReturnIfCurrentSubtypeEnabled();
    if (!currentSubtypeEnabled) {
      final InputMethodSubtype newSubtype=ImfUtils.getCurrentInputMethodSubtype(this,mSubtypeSwitcher.getNoLanguageSubtype());
      mSubtypeSwitcher.updateSubtype(newSubtype);
      loadKeyboard();
    }
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  if (isDifferentTextField || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      setPunctuationSuggestions();
    }
  }
  mConnection.resetCachesUponCursorMove(editorInfo.initialSelStart);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mKeyboardSwitcher.updateShiftState();
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setGestureHandlingEnabledByUser(mCurrentSettings.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(mCurrentSettings.mGesturePreviewTrailEnabled,mCurrentSettings.mGestureFloatingPreviewTextEnabled);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}",0.9957601453664444
87853,"@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  final boolean inputTypeChanged=!mCurrentSettings.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    final boolean currentSubtypeEnabled=mSubtypeSwitcher.updateParametersOnStartInputViewAndReturnIfCurrentSubtypeEnabled();
    if (!currentSubtypeEnabled) {
      final InputMethodSubtype newSubtype=ImfUtils.getCurrentInputMethodSubtype(this,mSubtypeSwitcher.getNoLanguageSubtype());
      mSubtypeSwitcher.updateSubtype(newSubtype);
      loadKeyboard();
    }
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  if (isDifferentTextField || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      setPunctuationSuggestions();
    }
  }
  mConnection.resetCachesUponCursorMove(mLastSelectionStart);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mKeyboardSwitcher.updateShiftState();
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setGestureHandlingEnabledByUser(mCurrentSettings.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(mCurrentSettings.mGesturePreviewTrailEnabled,mCurrentSettings.mGestureFloatingPreviewTextEnabled);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  final boolean inputTypeChanged=!mCurrentSettings.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    final boolean currentSubtypeEnabled=mSubtypeSwitcher.updateParametersOnStartInputViewAndReturnIfCurrentSubtypeEnabled();
    if (!currentSubtypeEnabled) {
      final InputMethodSubtype newSubtype=ImfUtils.getCurrentInputMethodSubtype(this,mSubtypeSwitcher.getNoLanguageSubtype());
      mSubtypeSwitcher.updateSubtype(newSubtype);
      loadKeyboard();
    }
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  if (isDifferentTextField || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      setPunctuationSuggestions();
    }
  }
  mConnection.resetCachesUponCursorMove(editorInfo.initialSelStart);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mKeyboardSwitcher.updateShiftState();
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setGestureHandlingEnabledByUser(mCurrentSettings.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(mCurrentSettings.mGesturePreviewTrailEnabled,mCurrentSettings.mGestureFloatingPreviewTextEnabled);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}",0.9957601453664444
87854,"@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  final boolean inputTypeChanged=!mCurrentSettings.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    final boolean currentSubtypeEnabled=mSubtypeSwitcher.updateParametersOnStartInputViewAndReturnIfCurrentSubtypeEnabled();
    if (!currentSubtypeEnabled) {
      final InputMethodSubtype newSubtype=ImfUtils.getCurrentInputMethodSubtype(this,mSubtypeSwitcher.getNoLanguageSubtype());
      mSubtypeSwitcher.updateSubtype(newSubtype);
      loadKeyboard();
    }
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  if (isDifferentTextField || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      setPunctuationSuggestions();
    }
  }
  mConnection.resetCachesUponCursorMove(mLastSelectionStart);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mKeyboardSwitcher.updateShiftState();
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setGestureHandlingEnabledByUser(mCurrentSettings.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(mCurrentSettings.mGesturePreviewTrailEnabled,mCurrentSettings.mGestureFloatingPreviewTextEnabled);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  final boolean inputTypeChanged=!mCurrentSettings.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    final boolean currentSubtypeEnabled=mSubtypeSwitcher.updateParametersOnStartInputViewAndReturnIfCurrentSubtypeEnabled();
    if (!currentSubtypeEnabled) {
      final InputMethodSubtype newSubtype=ImfUtils.getCurrentInputMethodSubtype(this,mSubtypeSwitcher.getNoLanguageSubtype());
      mSubtypeSwitcher.updateSubtype(newSubtype);
      loadKeyboard();
    }
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  if (isDifferentTextField || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      setPunctuationSuggestions();
    }
  }
  mConnection.resetCachesUponCursorMove(editorInfo.initialSelStart);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mKeyboardSwitcher.updateShiftState();
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setGestureHandlingEnabledByUser(mCurrentSettings.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(mCurrentSettings.mGesturePreviewTrailEnabled,mCurrentSettings.mGestureFloatingPreviewTextEnabled);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}",0.9957601453664444
87855,"@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  final boolean inputTypeChanged=!mCurrentSettings.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    final boolean currentSubtypeEnabled=mSubtypeSwitcher.updateParametersOnStartInputViewAndReturnIfCurrentSubtypeEnabled();
    if (!currentSubtypeEnabled) {
      final InputMethodSubtype newSubtype=ImfUtils.getCurrentInputMethodSubtype(this,mSubtypeSwitcher.getNoLanguageSubtype());
      mSubtypeSwitcher.updateSubtype(newSubtype);
      loadKeyboard();
    }
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  if (isDifferentTextField || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      mSuggestionStripView.clear();
    }
  }
  mConnection.resetCachesUponCursorMove(mLastSelectionStart);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mKeyboardSwitcher.updateShiftState();
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setGestureHandlingEnabledByUser(mCurrentSettings.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(mCurrentSettings.mGesturePreviewTrailEnabled,mCurrentSettings.mGestureFloatingPreviewTextEnabled);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  final boolean inputTypeChanged=!mCurrentSettings.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    final boolean currentSubtypeEnabled=mSubtypeSwitcher.updateParametersOnStartInputViewAndReturnIfCurrentSubtypeEnabled();
    if (!currentSubtypeEnabled) {
      final InputMethodSubtype newSubtype=ImfUtils.getCurrentInputMethodSubtype(this,mSubtypeSwitcher.getNoLanguageSubtype());
      mSubtypeSwitcher.updateSubtype(newSubtype);
      loadKeyboard();
    }
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  if (isDifferentTextField || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      mSuggestionStripView.clear();
    }
  }
  mConnection.resetCachesUponCursorMove(editorInfo.initialSelStart);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mKeyboardSwitcher.updateShiftState();
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setGestureHandlingEnabledByUser(mCurrentSettings.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(mCurrentSettings.mGesturePreviewTrailEnabled,mCurrentSettings.mGestureFloatingPreviewTextEnabled);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}",0.9957611723386218
87856,"@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  final boolean inputTypeChanged=!mCurrentSettings.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    final boolean currentSubtypeEnabled=mSubtypeSwitcher.updateParametersOnStartInputViewAndReturnIfCurrentSubtypeEnabled();
    if (!currentSubtypeEnabled) {
      final InputMethodSubtype newSubtype=ImfUtils.getCurrentInputMethodSubtype(this,mSubtypeSwitcher.getNoLanguageSubtype());
      mSubtypeSwitcher.updateSubtype(newSubtype);
      loadKeyboard();
    }
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  if (isDifferentTextField || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      setPunctuationSuggestions();
    }
  }
  mConnection.resetCachesUponCursorMove(mLastSelectionStart);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mKeyboardSwitcher.updateShiftState();
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setGestureHandlingEnabledByUser(mCurrentSettings.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(mCurrentSettings.mGesturePreviewTrailEnabled,mCurrentSettings.mGestureFloatingPreviewTextEnabled);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(final EditorInfo editorInfo,final boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final MainKeyboardView mainKeyboardView=switcher.getMainKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (mainKeyboardView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(mainKeyboardView,editorInfo,restarting);
  }
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  final boolean inputTypeChanged=!mCurrentSettings.isSameInputType(editorInfo);
  final boolean isDifferentTextField=!restarting || inputTypeChanged;
  if (isDifferentTextField) {
    final boolean currentSubtypeEnabled=mSubtypeSwitcher.updateParametersOnStartInputViewAndReturnIfCurrentSubtypeEnabled();
    if (!currentSubtypeEnabled) {
      final InputMethodSubtype newSubtype=ImfUtils.getCurrentInputMethodSubtype(this,mSubtypeSwitcher.getNoLanguageSubtype());
      mSubtypeSwitcher.updateSubtype(newSubtype);
      loadKeyboard();
    }
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  if (isDifferentTextField || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      setPunctuationSuggestions();
    }
  }
  mConnection.resetCachesUponCursorMove(editorInfo.initialSelStart);
  if (isDifferentTextField) {
    mainKeyboardView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mKeyboardSwitcher.updateShiftState();
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  mainKeyboardView.setMainDictionaryAvailability(mIsMainDictionaryAvailable);
  mainKeyboardView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  mainKeyboardView.setGestureHandlingEnabledByUser(mCurrentSettings.mGestureInputEnabled);
  mainKeyboardView.setGesturePreviewMode(mCurrentSettings.mGesturePreviewTrailEnabled,mCurrentSettings.mGestureFloatingPreviewTextEnabled);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}",0.9957601453664444
87857,"/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED || (mCapsCount > 1) && (mCapsCount == size());
}","/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  if (size() <= 1) {
    return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED;
  }
 else {
    return mCapsCount == size();
  }
}",0.8872832369942196
87858,"/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED || (mCapsCount > 1) && (mCapsCount == size());
}","/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  if (size() <= 1) {
    return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED;
  }
 else {
    return mCapsCount == size();
  }
}",0.8872832369942196
87859,"/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED || (mCapsCount > 0) && (mCapsCount == size());
}","/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED || (mCapsCount > 1) && (mCapsCount == size());
}",0.996996996996997
87860,"/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED || (mCapsCount > 0) && (mCapsCount == size());
}","/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED || (mCapsCount > 1) && (mCapsCount == size());
}",0.996996996996997
87861,"/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED || (mCapsCount > 0) && (mCapsCount == size());
}","/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED || (mCapsCount > 1) && (mCapsCount == size());
}",0.996996996996997
87862,"/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED || (mCapsCount > 1) && (mCapsCount == size());
}","/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  if (size() <= 1) {
    return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED;
  }
 else {
    return mCapsCount == size();
  }
}",0.8872832369942196
87863,"/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED || (mCapsCount > 1) && (mCapsCount == size());
}","/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  if (size() <= 1) {
    return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED;
  }
 else {
    return mCapsCount == size();
  }
}",0.8872832369942196
87864,"/** 
 * Helper method to find a word in a given branch.
 */
public static CharGroup findWordInTree(Node node,final String s){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,s.codePointAt(index));
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (s.length() - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < s.length() && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != s.codePointAt(newIndex))       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < s.length()) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < s.length());
  if (index < s.length())   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !s.equals(checker.toString()))   return null;
  return currentGroup;
}","/** 
 * Helper method to find a word in a given branch.
 */
public static CharGroup findWordInTree(Node node,final String s){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  CharGroup currentGroup;
  final int codePointCountInS=s.codePointCount(0,s.length());
  do {
    int indexOfGroup=findIndexOfChar(node,s.codePointAt(index));
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (s.length() - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < s.length() && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != s.codePointAt(newIndex))       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePointCountInS) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePointCountInS);
  if (index < codePointCountInS)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !s.equals(checker.toString()))   return null;
  return currentGroup;
}",0.9385474860335196
87865,"/** 
 * Helper method to find a word in a given branch.
 */
public static CharGroup findWordInTree(Node node,final String s){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,s.codePointAt(index));
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (s.length() - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < s.length() && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != s.codePointAt(newIndex))       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < s.length()) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < s.length());
  if (index < s.length())   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !s.equals(checker.toString()))   return null;
  return currentGroup;
}","/** 
 * Helper method to find a word in a given branch.
 */
public static CharGroup findWordInTree(Node node,final String s){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  CharGroup currentGroup;
  final int codePointCountInS=s.codePointCount(0,s.length());
  do {
    int indexOfGroup=findIndexOfChar(node,s.codePointAt(index));
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (s.length() - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < s.length() && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != s.codePointAt(newIndex))       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePointCountInS) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePointCountInS);
  if (index < codePointCountInS)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !s.equals(checker.toString()))   return null;
  return currentGroup;
}",0.9385474860335196
87866,"/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED || (mCapsCount > 0) && (mCapsCount == size());
}","/** 
 * Whether or not all of the user typed chars are upper case
 * @return true if all user typed chars are upper case, false otherwise
 */
public boolean isAllUpperCase(){
  return mCapitalizedMode == CAPS_MODE_AUTO_SHIFT_LOCKED || mCapitalizedMode == CAPS_MODE_MANUAL_SHIFT_LOCKED || (mCapsCount > 1) && (mCapsCount == size());
}",0.996996996996997
87867,"/** 
 * Helper method to find a word in a given branch.
 */
public static CharGroup findWordInTree(Node node,final String s){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,s.codePointAt(index));
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (s.length() - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < s.length() && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != s.codePointAt(newIndex))       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < s.length()) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < s.length());
  if (index < s.length())   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !s.equals(checker.toString()))   return null;
  return currentGroup;
}","/** 
 * Helper method to find a word in a given branch.
 */
public static CharGroup findWordInTree(Node node,final String s){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  CharGroup currentGroup;
  final int codePointCountInS=s.codePointCount(0,s.length());
  do {
    int indexOfGroup=findIndexOfChar(node,s.codePointAt(index));
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (s.length() - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < s.length() && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != s.codePointAt(newIndex))       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePointCountInS) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePointCountInS);
  if (index < codePointCountInS)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !s.equals(checker.toString()))   return null;
  return currentGroup;
}",0.9385474860335196
87868,"/** 
 * Helper method to find a word in a given branch.
 */
public static CharGroup findWordInTree(Node node,final String s){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  CharGroup currentGroup;
  do {
    int indexOfGroup=findIndexOfChar(node,s.codePointAt(index));
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (s.length() - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < s.length() && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != s.codePointAt(newIndex))       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < s.length()) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < s.length());
  if (index < s.length())   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !s.equals(checker.toString()))   return null;
  return currentGroup;
}","/** 
 * Helper method to find a word in a given branch.
 */
public static CharGroup findWordInTree(Node node,final String s){
  int index=0;
  final StringBuilder checker=DBG ? new StringBuilder() : null;
  CharGroup currentGroup;
  final int codePointCountInS=s.codePointCount(0,s.length());
  do {
    int indexOfGroup=findIndexOfChar(node,s.codePointAt(index));
    if (CHARACTER_NOT_FOUND == indexOfGroup)     return null;
    currentGroup=node.mData.get(indexOfGroup);
    if (s.length() - index < currentGroup.mChars.length)     return null;
    int newIndex=index;
    while (newIndex < s.length() && newIndex - index < currentGroup.mChars.length) {
      if (currentGroup.mChars[newIndex - index] != s.codePointAt(newIndex))       return null;
      newIndex++;
    }
    index=newIndex;
    if (DBG)     checker.append(new String(currentGroup.mChars,0,currentGroup.mChars.length));
    if (index < codePointCountInS) {
      node=currentGroup.mChildren;
    }
  }
 while (null != node && index < codePointCountInS);
  if (index < codePointCountInS)   return null;
  if (!currentGroup.isTerminal())   return null;
  if (DBG && !s.equals(checker.toString()))   return null;
  return currentGroup;
}",0.9385474860335196
87869,"private boolean handleSeparator(final int primaryCode,final int x,final int y,final int spaceState){
  boolean didAutoCorrect=false;
  if (mWordComposer.isComposingWord()) {
    if (mCurrentSettings.mCorrectionEnabled) {
      commitCurrentAutoCorrection(new String(new int[]{primaryCode},0,1));
      didAutoCorrect=true;
    }
 else {
      commitTyped(new String(new int[]{primaryCode},0,1));
    }
  }
  final boolean swapWeakSpace=maybeStripSpace(primaryCode,spaceState,Constants.SUGGESTION_STRIP_COORDINATE == x);
  if (SPACE_STATE_PHANTOM == spaceState && mCurrentSettings.isPhantomSpacePromotingSymbol(primaryCode)) {
    sendKeyCodePoint(Keyboard.CODE_SPACE);
  }
  sendKeyCodePoint(primaryCode);
  if (Keyboard.CODE_SPACE == primaryCode) {
    if (mCurrentSettings.isSuggestionsRequested(mDisplayOrientation)) {
      if (maybeDoubleSpace()) {
        mSpaceState=SPACE_STATE_DOUBLE;
      }
 else       if (!isShowingPunctuationList()) {
        mSpaceState=SPACE_STATE_WEAK;
      }
    }
    mHandler.startDoubleSpacesTimer();
    if (!mConnection.isCursorTouchingWord(mCurrentSettings)) {
      mHandler.postUpdateSuggestionStrip();
    }
  }
 else {
    if (swapWeakSpace) {
      swapSwapperAndSpace();
      mSpaceState=SPACE_STATE_SWAP_PUNCTUATION;
    }
 else     if (SPACE_STATE_PHANTOM == spaceState && !mCurrentSettings.isWeakSpaceStripper(primaryCode)) {
      mSpaceState=SPACE_STATE_PHANTOM;
    }
    setPunctuationSuggestions();
  }
  Utils.Stats.onSeparator((char)primaryCode,x,y);
  mHandler.postUpdateShiftState();
  return didAutoCorrect;
}","private boolean handleSeparator(final int primaryCode,final int x,final int y,final int spaceState){
  boolean didAutoCorrect=false;
  if (mWordComposer.isComposingWord()) {
    if (mCurrentSettings.mCorrectionEnabled) {
      commitCurrentAutoCorrection(new String(new int[]{primaryCode},0,1));
      didAutoCorrect=true;
    }
 else {
      commitTyped(new String(new int[]{primaryCode},0,1));
    }
  }
  final boolean swapWeakSpace=maybeStripSpace(primaryCode,spaceState,Constants.SUGGESTION_STRIP_COORDINATE == x);
  if (SPACE_STATE_PHANTOM == spaceState && mCurrentSettings.isPhantomSpacePromotingSymbol(primaryCode)) {
    sendKeyCodePoint(Keyboard.CODE_SPACE);
  }
  sendKeyCodePoint(primaryCode);
  if (Keyboard.CODE_SPACE == primaryCode) {
    if (mCurrentSettings.isSuggestionsRequested(mDisplayOrientation)) {
      if (maybeDoubleSpace()) {
        mSpaceState=SPACE_STATE_DOUBLE;
      }
 else       if (!isShowingPunctuationList()) {
        mSpaceState=SPACE_STATE_WEAK;
      }
    }
    mHandler.startDoubleSpacesTimer();
    if (!mConnection.isCursorTouchingWord(mCurrentSettings)) {
      mHandler.postUpdateSuggestionStrip();
    }
  }
 else {
    if (swapWeakSpace) {
      swapSwapperAndSpace();
      mSpaceState=SPACE_STATE_SWAP_PUNCTUATION;
    }
 else     if (SPACE_STATE_PHANTOM == spaceState && !mCurrentSettings.isWeakSpaceStripper(primaryCode) && !mCurrentSettings.isPhantomSpacePromotingSymbol(primaryCode)) {
      mSpaceState=SPACE_STATE_PHANTOM;
    }
    setPunctuationSuggestions();
  }
  Utils.Stats.onSeparator((char)primaryCode,x,y);
  mHandler.postUpdateShiftState();
  return didAutoCorrect;
}",0.9800374298190891
87870,"private boolean handleSeparator(final int primaryCode,final int x,final int y,final int spaceState){
  boolean didAutoCorrect=false;
  if (mWordComposer.isComposingWord()) {
    if (mCurrentSettings.mCorrectionEnabled) {
      commitCurrentAutoCorrection(new String(new int[]{primaryCode},0,1));
      didAutoCorrect=true;
    }
 else {
      commitTyped(new String(new int[]{primaryCode},0,1));
    }
  }
  final boolean swapWeakSpace=maybeStripSpace(primaryCode,spaceState,Constants.SUGGESTION_STRIP_COORDINATE == x);
  if (SPACE_STATE_PHANTOM == spaceState && mCurrentSettings.isPhantomSpacePromotingSymbol(primaryCode)) {
    sendKeyCodePoint(Keyboard.CODE_SPACE);
  }
  sendKeyCodePoint(primaryCode);
  if (Keyboard.CODE_SPACE == primaryCode) {
    if (mCurrentSettings.isSuggestionsRequested(mDisplayOrientation)) {
      if (maybeDoubleSpace()) {
        mSpaceState=SPACE_STATE_DOUBLE;
      }
 else       if (!isShowingPunctuationList()) {
        mSpaceState=SPACE_STATE_WEAK;
      }
    }
    mHandler.startDoubleSpacesTimer();
    if (!mConnection.isCursorTouchingWord(mCurrentSettings)) {
      mHandler.postUpdateSuggestionStrip();
    }
  }
 else {
    if (swapWeakSpace) {
      swapSwapperAndSpace();
      mSpaceState=SPACE_STATE_SWAP_PUNCTUATION;
    }
 else     if (SPACE_STATE_PHANTOM == spaceState && !mCurrentSettings.isWeakSpaceStripper(primaryCode)) {
      mSpaceState=SPACE_STATE_PHANTOM;
    }
    setPunctuationSuggestions();
  }
  Utils.Stats.onSeparator((char)primaryCode,x,y);
  mHandler.postUpdateShiftState();
  return didAutoCorrect;
}","private boolean handleSeparator(final int primaryCode,final int x,final int y,final int spaceState){
  boolean didAutoCorrect=false;
  if (mWordComposer.isComposingWord()) {
    if (mCurrentSettings.mCorrectionEnabled) {
      commitCurrentAutoCorrection(new String(new int[]{primaryCode},0,1));
      didAutoCorrect=true;
    }
 else {
      commitTyped(new String(new int[]{primaryCode},0,1));
    }
  }
  final boolean swapWeakSpace=maybeStripSpace(primaryCode,spaceState,Constants.SUGGESTION_STRIP_COORDINATE == x);
  if (SPACE_STATE_PHANTOM == spaceState && mCurrentSettings.isPhantomSpacePromotingSymbol(primaryCode)) {
    sendKeyCodePoint(Keyboard.CODE_SPACE);
  }
  sendKeyCodePoint(primaryCode);
  if (Keyboard.CODE_SPACE == primaryCode) {
    if (mCurrentSettings.isSuggestionsRequested(mDisplayOrientation)) {
      if (maybeDoubleSpace()) {
        mSpaceState=SPACE_STATE_DOUBLE;
      }
 else       if (!isShowingPunctuationList()) {
        mSpaceState=SPACE_STATE_WEAK;
      }
    }
    mHandler.startDoubleSpacesTimer();
    if (!mConnection.isCursorTouchingWord(mCurrentSettings)) {
      mHandler.postUpdateSuggestionStrip();
    }
  }
 else {
    if (swapWeakSpace) {
      swapSwapperAndSpace();
      mSpaceState=SPACE_STATE_SWAP_PUNCTUATION;
    }
 else     if (SPACE_STATE_PHANTOM == spaceState && !mCurrentSettings.isWeakSpaceStripper(primaryCode) && !mCurrentSettings.isPhantomSpacePromotingSymbol(primaryCode)) {
      mSpaceState=SPACE_STATE_PHANTOM;
    }
    setPunctuationSuggestions();
  }
  Utils.Stats.onSeparator((char)primaryCode,x,y);
  mHandler.postUpdateShiftState();
  return didAutoCorrect;
}",0.9800374298190891
87871,"private boolean handleSeparator(final int primaryCode,final int x,final int y,final int spaceState){
  boolean didAutoCorrect=false;
  if (mWordComposer.isComposingWord()) {
    if (mCurrentSettings.mCorrectionEnabled) {
      commitCurrentAutoCorrection(new String(new int[]{primaryCode},0,1));
      didAutoCorrect=true;
    }
 else {
      commitTyped(new String(new int[]{primaryCode},0,1));
    }
  }
  final boolean swapWeakSpace=maybeStripSpace(primaryCode,spaceState,Constants.SUGGESTION_STRIP_COORDINATE == x);
  if (SPACE_STATE_PHANTOM == spaceState && mCurrentSettings.isPhantomSpacePromotingSymbol(primaryCode)) {
    sendKeyCodePoint(Keyboard.CODE_SPACE);
  }
  sendKeyCodePoint(primaryCode);
  if (Keyboard.CODE_SPACE == primaryCode) {
    if (mCurrentSettings.isSuggestionsRequested(mDisplayOrientation)) {
      if (maybeDoubleSpace()) {
        mSpaceState=SPACE_STATE_DOUBLE;
      }
 else       if (!isShowingPunctuationList()) {
        mSpaceState=SPACE_STATE_WEAK;
      }
    }
    mHandler.startDoubleSpacesTimer();
    if (!mConnection.isCursorTouchingWord(mCurrentSettings)) {
      mHandler.postUpdateSuggestionStrip();
    }
  }
 else {
    if (swapWeakSpace) {
      swapSwapperAndSpace();
      mSpaceState=SPACE_STATE_SWAP_PUNCTUATION;
    }
 else     if (SPACE_STATE_PHANTOM == spaceState && !mCurrentSettings.isWeakSpaceStripper(primaryCode)) {
      mSpaceState=SPACE_STATE_PHANTOM;
    }
    setPunctuationSuggestions();
  }
  Utils.Stats.onSeparator((char)primaryCode,x,y);
  mHandler.postUpdateShiftState();
  return didAutoCorrect;
}","private boolean handleSeparator(final int primaryCode,final int x,final int y,final int spaceState){
  boolean didAutoCorrect=false;
  if (mWordComposer.isComposingWord()) {
    if (mCurrentSettings.mCorrectionEnabled) {
      commitCurrentAutoCorrection(new String(new int[]{primaryCode},0,1));
      didAutoCorrect=true;
    }
 else {
      commitTyped(new String(new int[]{primaryCode},0,1));
    }
  }
  final boolean swapWeakSpace=maybeStripSpace(primaryCode,spaceState,Constants.SUGGESTION_STRIP_COORDINATE == x);
  if (SPACE_STATE_PHANTOM == spaceState && mCurrentSettings.isPhantomSpacePromotingSymbol(primaryCode)) {
    sendKeyCodePoint(Keyboard.CODE_SPACE);
  }
  sendKeyCodePoint(primaryCode);
  if (Keyboard.CODE_SPACE == primaryCode) {
    if (mCurrentSettings.isSuggestionsRequested(mDisplayOrientation)) {
      if (maybeDoubleSpace()) {
        mSpaceState=SPACE_STATE_DOUBLE;
      }
 else       if (!isShowingPunctuationList()) {
        mSpaceState=SPACE_STATE_WEAK;
      }
    }
    mHandler.startDoubleSpacesTimer();
    if (!mConnection.isCursorTouchingWord(mCurrentSettings)) {
      mHandler.postUpdateSuggestionStrip();
    }
  }
 else {
    if (swapWeakSpace) {
      swapSwapperAndSpace();
      mSpaceState=SPACE_STATE_SWAP_PUNCTUATION;
    }
 else     if (SPACE_STATE_PHANTOM == spaceState && !mCurrentSettings.isWeakSpaceStripper(primaryCode) && !mCurrentSettings.isPhantomSpacePromotingSymbol(primaryCode)) {
      mSpaceState=SPACE_STATE_PHANTOM;
    }
    setPunctuationSuggestions();
  }
  Utils.Stats.onSeparator((char)primaryCode,x,y);
  mHandler.postUpdateShiftState();
  return didAutoCorrect;
}",0.9800374298190891
87872,"/** 
 * Append the times, x-coordinates and y-coordinates in the specified   {@link ResizableIntArray}to the end of this.
 * @param pointerId the pointer id of the source.
 * @param times the source {@link ResizableIntArray} to read the event times from.
 * @param xCoordinates the source {@link ResizableIntArray} to read the x-coordinates from.
 * @param yCoordinates the source {@link ResizableIntArray} to read the y-coordinates from.
 * @param startPos the starting index of the data in {@code times} and etc.
 * @param length the number of data to be appended.
 */
public void append(int pointerId,ResizableIntArray times,ResizableIntArray xCoordinates,ResizableIntArray yCoordinates,int startPos,int length){
  if (length == 0) {
    return;
  }
  mXCoordinates.append(xCoordinates,startPos,length);
  mYCoordinates.append(yCoordinates,startPos,length);
  mPointerIds.fill(pointerId,startPos,length);
  mTimes.append(times,startPos,length);
}","/** 
 * Append the times, x-coordinates and y-coordinates in the specified   {@link ResizableIntArray}to the end of this.
 * @param pointerId the pointer id of the source.
 * @param times the source {@link ResizableIntArray} to read the event times from.
 * @param xCoordinates the source {@link ResizableIntArray} to read the x-coordinates from.
 * @param yCoordinates the source {@link ResizableIntArray} to read the y-coordinates from.
 * @param startPos the starting index of the data in {@code times} and etc.
 * @param length the number of data to be appended.
 */
public void append(int pointerId,ResizableIntArray times,ResizableIntArray xCoordinates,ResizableIntArray yCoordinates,int startPos,int length){
  if (length == 0) {
    return;
  }
  mXCoordinates.append(xCoordinates,startPos,length);
  mYCoordinates.append(yCoordinates,startPos,length);
  mPointerIds.fill(pointerId,mPointerIds.getLength(),length);
  mTimes.append(times,startPos,length);
}",0.9858860428646106
87873,"/** 
 * Append the times, x-coordinates and y-coordinates in the specified   {@link ResizableIntArray}to the end of this.
 * @param pointerId the pointer id of the source.
 * @param times the source {@link ResizableIntArray} to read the event times from.
 * @param xCoordinates the source {@link ResizableIntArray} to read the x-coordinates from.
 * @param yCoordinates the source {@link ResizableIntArray} to read the y-coordinates from.
 * @param startPos the starting index of the data in {@code times} and etc.
 * @param length the number of data to be appended.
 */
public void append(int pointerId,ResizableIntArray times,ResizableIntArray xCoordinates,ResizableIntArray yCoordinates,int startPos,int length){
  if (length == 0) {
    return;
  }
  mXCoordinates.append(xCoordinates,startPos,length);
  mYCoordinates.append(yCoordinates,startPos,length);
  mPointerIds.fill(pointerId,startPos,length);
  mTimes.append(times,startPos,length);
}","/** 
 * Append the times, x-coordinates and y-coordinates in the specified   {@link ResizableIntArray}to the end of this.
 * @param pointerId the pointer id of the source.
 * @param times the source {@link ResizableIntArray} to read the event times from.
 * @param xCoordinates the source {@link ResizableIntArray} to read the x-coordinates from.
 * @param yCoordinates the source {@link ResizableIntArray} to read the y-coordinates from.
 * @param startPos the starting index of the data in {@code times} and etc.
 * @param length the number of data to be appended.
 */
public void append(int pointerId,ResizableIntArray times,ResizableIntArray xCoordinates,ResizableIntArray yCoordinates,int startPos,int length){
  if (length == 0) {
    return;
  }
  mXCoordinates.append(xCoordinates,startPos,length);
  mYCoordinates.append(yCoordinates,startPos,length);
  mPointerIds.fill(pointerId,mPointerIds.getLength(),length);
  mTimes.append(times,startPos,length);
}",0.9858860428646106
87874,"/** 
 * Append the times, x-coordinates and y-coordinates in the specified   {@link ResizableIntArray}to the end of this.
 * @param pointerId the pointer id of the source.
 * @param times the source {@link ResizableIntArray} to read the event times from.
 * @param xCoordinates the source {@link ResizableIntArray} to read the x-coordinates from.
 * @param yCoordinates the source {@link ResizableIntArray} to read the y-coordinates from.
 * @param startPos the starting index of the data in {@code times} and etc.
 * @param length the number of data to be appended.
 */
public void append(int pointerId,ResizableIntArray times,ResizableIntArray xCoordinates,ResizableIntArray yCoordinates,int startPos,int length){
  if (length == 0) {
    return;
  }
  mXCoordinates.append(xCoordinates,startPos,length);
  mYCoordinates.append(yCoordinates,startPos,length);
  mPointerIds.fill(pointerId,startPos,length);
  mTimes.append(times,startPos,length);
}","/** 
 * Append the times, x-coordinates and y-coordinates in the specified   {@link ResizableIntArray}to the end of this.
 * @param pointerId the pointer id of the source.
 * @param times the source {@link ResizableIntArray} to read the event times from.
 * @param xCoordinates the source {@link ResizableIntArray} to read the x-coordinates from.
 * @param yCoordinates the source {@link ResizableIntArray} to read the y-coordinates from.
 * @param startPos the starting index of the data in {@code times} and etc.
 * @param length the number of data to be appended.
 */
public void append(int pointerId,ResizableIntArray times,ResizableIntArray xCoordinates,ResizableIntArray yCoordinates,int startPos,int length){
  if (length == 0) {
    return;
  }
  mXCoordinates.append(xCoordinates,startPos,length);
  mYCoordinates.append(yCoordinates,startPos,length);
  mPointerIds.fill(pointerId,mPointerIds.getLength(),length);
  mTimes.append(times,startPos,length);
}",0.9858860428646106
87875,"@Override public ArrayList<SuggestedWordInfo> getSuggestions(final WordComposer composer,final CharSequence prevWord,final ProximityInfo proximityInfo){
  if (reloadDictionaryIfRequired())   return null;
  if (composer.size() <= 1) {
    if (composer.size() >= BinaryDictionary.MAX_WORD_LENGTH) {
      return null;
    }
    final ArrayList<SuggestedWordInfo> suggestions=getWordsInner(composer,prevWord,proximityInfo);
    return suggestions;
  }
 else {
    if (TextUtils.isEmpty(prevWord))     return null;
    final ArrayList<SuggestedWordInfo> suggestions=new ArrayList<SuggestedWordInfo>();
    runBigramReverseLookUp(prevWord,suggestions);
    return suggestions;
  }
}","@Override public ArrayList<SuggestedWordInfo> getSuggestions(final WordComposer composer,final CharSequence prevWord,final ProximityInfo proximityInfo){
  if (reloadDictionaryIfRequired())   return null;
  if (composer.size() > 1) {
    if (composer.size() >= BinaryDictionary.MAX_WORD_LENGTH) {
      return null;
    }
    final ArrayList<SuggestedWordInfo> suggestions=getWordsInner(composer,prevWord,proximityInfo);
    return suggestions;
  }
 else {
    if (TextUtils.isEmpty(prevWord))     return null;
    final ArrayList<SuggestedWordInfo> suggestions=new ArrayList<SuggestedWordInfo>();
    runBigramReverseLookUp(prevWord,suggestions);
    return suggestions;
  }
}",0.9977827050997784
87876,"@Override public ArrayList<SuggestedWordInfo> getSuggestions(final WordComposer composer,final CharSequence prevWord,final ProximityInfo proximityInfo){
  if (reloadDictionaryIfRequired())   return null;
  if (composer.size() <= 1) {
    if (composer.size() >= BinaryDictionary.MAX_WORD_LENGTH) {
      return null;
    }
    final ArrayList<SuggestedWordInfo> suggestions=getWordsInner(composer,prevWord,proximityInfo);
    return suggestions;
  }
 else {
    if (TextUtils.isEmpty(prevWord))     return null;
    final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
    runBigramReverseLookUp(prevWord,suggestions);
    return suggestions;
  }
}","@Override public ArrayList<SuggestedWordInfo> getSuggestions(final WordComposer composer,final CharSequence prevWord,final ProximityInfo proximityInfo){
  if (reloadDictionaryIfRequired())   return null;
  if (composer.size() > 1) {
    if (composer.size() >= BinaryDictionary.MAX_WORD_LENGTH) {
      return null;
    }
    final ArrayList<SuggestedWordInfo> suggestions=getWordsInner(composer,prevWord,proximityInfo);
    return suggestions;
  }
 else {
    if (TextUtils.isEmpty(prevWord))     return null;
    final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
    runBigramReverseLookUp(prevWord,suggestions);
    return suggestions;
  }
}",0.9977695167286246
87877,"@Override public ArrayList<SuggestedWordInfo> getSuggestions(final WordComposer composer,final CharSequence prevWord,final ProximityInfo proximityInfo){
  if (reloadDictionaryIfRequired())   return null;
  if (composer.size() <= 1) {
    if (composer.size() >= BinaryDictionary.MAX_WORD_LENGTH) {
      return null;
    }
    final ArrayList<SuggestedWordInfo> suggestions=getWordsInner(composer,prevWord,proximityInfo);
    return suggestions;
  }
 else {
    if (TextUtils.isEmpty(prevWord))     return null;
    final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
    runBigramReverseLookUp(prevWord,suggestions);
    return suggestions;
  }
}","@Override public ArrayList<SuggestedWordInfo> getSuggestions(final WordComposer composer,final CharSequence prevWord,final ProximityInfo proximityInfo){
  if (reloadDictionaryIfRequired())   return null;
  if (composer.size() > 1) {
    if (composer.size() >= BinaryDictionary.MAX_WORD_LENGTH) {
      return null;
    }
    final ArrayList<SuggestedWordInfo> suggestions=getWordsInner(composer,prevWord,proximityInfo);
    return suggestions;
  }
 else {
    if (TextUtils.isEmpty(prevWord))     return null;
    final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
    runBigramReverseLookUp(prevWord,suggestions);
    return suggestions;
  }
}",0.9977695167286246
87878,"@Override public ArrayList<SuggestedWordInfo> getSuggestions(final WordComposer composer,final CharSequence prevWord,final ProximityInfo proximityInfo){
  if (reloadDictionaryIfRequired())   return null;
  if (composer.size() <= 1) {
    if (composer.size() >= BinaryDictionary.MAX_WORD_LENGTH) {
      return null;
    }
    final ArrayList<SuggestedWordInfo> suggestions=getWordsInner(composer,prevWord,proximityInfo);
    return suggestions;
  }
 else {
    if (TextUtils.isEmpty(prevWord))     return null;
    final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
    runBigramReverseLookUp(prevWord,suggestions);
    return suggestions;
  }
}","@Override public ArrayList<SuggestedWordInfo> getSuggestions(final WordComposer composer,final CharSequence prevWord,final ProximityInfo proximityInfo){
  if (reloadDictionaryIfRequired())   return null;
  if (composer.size() > 1) {
    if (composer.size() >= BinaryDictionary.MAX_WORD_LENGTH) {
      return null;
    }
    final ArrayList<SuggestedWordInfo> suggestions=getWordsInner(composer,prevWord,proximityInfo);
    return suggestions;
  }
 else {
    if (TextUtils.isEmpty(prevWord))     return null;
    final ArrayList<SuggestedWordInfo> suggestions=CollectionUtils.newArrayList();
    runBigramReverseLookUp(prevWord,suggestions);
    return suggestions;
  }
}",0.9977695167286246
87879,"@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(EditorInfo editorInfo,boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  MainKeyboardView inputView=switcher.getKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (inputView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(editorInfo,restarting);
  }
  if (!restarting) {
    mSubtypeSwitcher.updateParametersOnStartInputView();
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  if (!restarting || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      mSuggestionStripView.clear();
    }
  }
  if (!restarting) {
    inputView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
    updateKeyboardViewGestureHandlingModeByMainDictionaryAvailability();
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  inputView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(EditorInfo editorInfo,boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  MainKeyboardView inputView=switcher.getKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (inputView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(editorInfo,restarting);
  }
  if (!restarting) {
    mSubtypeSwitcher.updateParametersOnStartInputView();
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  if (!restarting || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      mSuggestionStripView.clear();
    }
  }
  if (!restarting) {
    inputView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
    updateKeyboardViewGestureHandlingModeByMainDictionaryAvailability();
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mKeyboardSwitcher.updateShiftState();
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  inputView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}",0.993857493857494
87880,"@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(EditorInfo editorInfo,boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  MainKeyboardView inputView=switcher.getKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (inputView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(editorInfo,restarting);
  }
  if (!restarting) {
    mSubtypeSwitcher.updateParametersOnStartInputView();
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  if (!restarting || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      mSuggestionStripView.clear();
    }
  }
  if (!restarting) {
    inputView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
    updateKeyboardViewGestureHandlingModeByMainDictionaryAvailability();
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  inputView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(EditorInfo editorInfo,boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  MainKeyboardView inputView=switcher.getKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (inputView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(editorInfo,restarting);
  }
  if (!restarting) {
    mSubtypeSwitcher.updateParametersOnStartInputView();
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  if (!restarting || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      mSuggestionStripView.clear();
    }
  }
  if (!restarting) {
    inputView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
    updateKeyboardViewGestureHandlingModeByMainDictionaryAvailability();
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mKeyboardSwitcher.updateShiftState();
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  inputView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}",0.993857493857494
87881,"@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(EditorInfo editorInfo,boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  MainKeyboardView inputView=switcher.getKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (inputView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(editorInfo,restarting);
  }
  if (!restarting) {
    mSubtypeSwitcher.updateParametersOnStartInputView();
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  if (!restarting || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      mSuggestionStripView.clear();
    }
  }
  if (!restarting) {
    inputView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
    updateKeyboardViewGestureHandlingModeByMainDictionaryAvailability();
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  inputView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") private void onStartInputViewInternal(EditorInfo editorInfo,boolean restarting){
  super.onStartInputView(editorInfo,restarting);
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  MainKeyboardView inputView=switcher.getKeyboardView();
  if (editorInfo == null) {
    Log.e(TAG,""String_Node_Str"");
    if (LatinImeLogger.sDBG) {
      throw new NullPointerException(""String_Node_Str"");
    }
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + String.format(""String_Node_Str"",editorInfo.inputType,editorInfo.imeOptions));
    Log.d(TAG,""String_Node_Str"" + ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0) + ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0)+ ""String_Node_Str""+ ((editorInfo.inputType & InputType.TYPE_TEXT_FLAG_CAP_WORDS) != 0));
  }
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onStartInputViewInternal(editorInfo,mPrefs);
  }
  if (InputAttributes.inPrivateImeOptions(null,NO_MICROPHONE_COMPAT,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ NO_MICROPHONE+ ""String_Node_Str"");
  }
  if (InputAttributes.inPrivateImeOptions(getPackageName(),FORCE_ASCII,editorInfo)) {
    Log.w(TAG,""String_Node_Str"" + editorInfo.privateImeOptions);
    Log.w(TAG,""String_Node_Str"");
  }
  mTargetApplicationInfo=TargetApplicationGetter.getCachedApplicationInfo(editorInfo.packageName);
  if (null == mTargetApplicationInfo) {
    new TargetApplicationGetter(this,this).execute(editorInfo.packageName);
  }
  LatinImeLogger.onStartInputView(editorInfo);
  if (inputView == null) {
    return;
  }
  final AccessibilityUtils accessUtils=AccessibilityUtils.getInstance();
  if (accessUtils.isTouchExplorationEnabled()) {
    accessUtils.onStartInputViewInternal(editorInfo,restarting);
  }
  if (!restarting) {
    mSubtypeSwitcher.updateParametersOnStartInputView();
  }
  updateFullscreenMode();
  mApplicationSpecifiedCompletions=null;
  final boolean selectionChanged=mLastSelectionStart != editorInfo.initialSelStart || mLastSelectionEnd != editorInfo.initialSelEnd;
  if (!restarting || selectionChanged) {
    mEnteredText=null;
    resetComposingState(true);
    mDeleteCount=0;
    mSpaceState=SPACE_STATE_NONE;
    if (mSuggestionStripView != null) {
      mSuggestionStripView.clear();
    }
  }
  if (!restarting) {
    inputView.closing();
    loadSettings();
    if (mSuggest != null && mCurrentSettings.mCorrectionEnabled) {
      mSuggest.setAutoCorrectionThreshold(mCurrentSettings.mAutoCorrectionThreshold);
    }
    switcher.loadKeyboard(editorInfo,mCurrentSettings);
    updateKeyboardViewGestureHandlingModeByMainDictionaryAvailability();
  }
  setSuggestionStripShownInternal(isSuggestionsStripVisible(),false);
  mLastSelectionStart=editorInfo.initialSelStart;
  mLastSelectionEnd=editorInfo.initialSelEnd;
  mKeyboardSwitcher.updateShiftState();
  mHandler.cancelUpdateSuggestionStrip();
  mHandler.cancelDoubleSpacesTimer();
  inputView.setKeyPreviewPopupEnabled(mCurrentSettings.mKeyPreviewPopupOn,mCurrentSettings.mKeyPreviewPopupDismissDelay);
  if (TRACE)   Debug.startMethodTracing(""String_Node_Str"");
}",0.993857493857494
87882,"@Override public void onDraw(Canvas canvas){
  super.onDraw(canvas);
  canvas.translate(mParams.mCoordinates[0],mParams.mCoordinates[1]);
  PointerTracker.drawGestureTrailForAllPointerTrackers(canvas,mGesturePaint);
}","@Override public void onDraw(Canvas canvas){
  super.onDraw(canvas);
  canvas.translate(mParams.mCoordinates[0],mParams.mCoordinates[1]);
  PointerTracker.drawGestureTrailForAllPointerTrackers(canvas,mGesturePaint);
  canvas.translate(-mParams.mCoordinates[0],-mParams.mCoordinates[1]);
}",0.8594059405940594
87883,"@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,final int x,final int y){
  final SuggestedWords suggestedWords=mSuggestionStripView.getSuggestions();
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  mConnection.beginBatchEdit();
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0 && !mWordComposer.isBatchMode()) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mCurrentSettings.isWeakSpaceStripper(firstChar)) && (!mCurrentSettings.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mCurrentSettings.isApplicationSpecifiedCompletionsOn() && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionStripView != null) {
      mSuggestionStripView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
    mConnection.commitCompletion(completionInfo);
    mConnection.endBatchEdit();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
    }
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mConnection.endBatchEdit();
  mLastComposedWord.deactivate();
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (showingAddToDictionaryHint && mIsUserDictionaryAvailable) {
    mSuggestionStripView.showAddToDictionaryHint(suggestion,mCurrentSettings.mHintToSaveText);
  }
 else {
    mHandler.postUpdateSuggestionStrip();
  }
}","@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,final int x,final int y){
  final SuggestedWords suggestedWords=mSuggestionStripView.getSuggestions();
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  mConnection.beginBatchEdit();
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0 && !mWordComposer.isBatchMode()) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mCurrentSettings.isWeakSpaceStripper(firstChar)) && (!mCurrentSettings.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mCurrentSettings.isApplicationSpecifiedCompletionsOn() && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionStripView != null) {
      mSuggestionStripView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
    mConnection.commitCompletion(completionInfo);
    mConnection.endBatchEdit();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
    }
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mConnection.endBatchEdit();
  mLastComposedWord.deactivate();
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true);
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (showingAddToDictionaryHint && mIsUserDictionaryAvailable) {
    mSuggestionStripView.showAddToDictionaryHint(suggestion,mCurrentSettings.mHintToSaveText);
  }
 else {
    mHandler.postUpdateSuggestionStrip();
  }
}",0.9696316262353998
87884,"@Override public void onDraw(Canvas canvas){
  super.onDraw(canvas);
  canvas.translate(mParams.mCoordinates[0],mParams.mCoordinates[1]);
  PointerTracker.drawGestureTrailForAllPointerTrackers(canvas,mGesturePaint);
}","@Override public void onDraw(Canvas canvas){
  super.onDraw(canvas);
  canvas.translate(mParams.mCoordinates[0],mParams.mCoordinates[1]);
  PointerTracker.drawGestureTrailForAllPointerTrackers(canvas,mGesturePaint);
  canvas.translate(-mParams.mCoordinates[0],-mParams.mCoordinates[1]);
}",0.8594059405940594
87885,"@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,final int x,final int y){
  final SuggestedWords suggestedWords=mSuggestionStripView.getSuggestions();
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  mConnection.beginBatchEdit();
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0 && !mWordComposer.isBatchMode()) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mCurrentSettings.isWeakSpaceStripper(firstChar)) && (!mCurrentSettings.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mCurrentSettings.isApplicationSpecifiedCompletionsOn() && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionStripView != null) {
      mSuggestionStripView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
    mConnection.commitCompletion(completionInfo);
    mConnection.endBatchEdit();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
    }
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mConnection.endBatchEdit();
  mLastComposedWord.deactivate();
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (showingAddToDictionaryHint && mIsUserDictionaryAvailable) {
    mSuggestionStripView.showAddToDictionaryHint(suggestion,mCurrentSettings.mHintToSaveText);
  }
 else {
    mHandler.postUpdateSuggestionStrip();
  }
}","@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,final int x,final int y){
  final SuggestedWords suggestedWords=mSuggestionStripView.getSuggestions();
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  mConnection.beginBatchEdit();
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0 && !mWordComposer.isBatchMode()) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mCurrentSettings.isWeakSpaceStripper(firstChar)) && (!mCurrentSettings.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mCurrentSettings.isApplicationSpecifiedCompletionsOn() && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionStripView != null) {
      mSuggestionStripView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
    mConnection.commitCompletion(completionInfo);
    mConnection.endBatchEdit();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
    }
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mConnection.endBatchEdit();
  mLastComposedWord.deactivate();
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true);
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (showingAddToDictionaryHint && mIsUserDictionaryAvailable) {
    mSuggestionStripView.showAddToDictionaryHint(suggestion,mCurrentSettings.mHintToSaveText);
  }
 else {
    mHandler.postUpdateSuggestionStrip();
  }
}",0.9696316262353998
87886,"public LastComposedWord commitWord(final int type,final String committedWord,final int separatorCode,final CharSequence prevWord){
  final int[] primaryKeyCodes=mPrimaryKeyCodes;
  mPrimaryKeyCodes=new int[N];
  final LastComposedWord lastComposedWord=new LastComposedWord(primaryKeyCodes,mInputPointers,mTypedWord.toString(),committedWord,separatorCode,prevWord);
  mInputPointers.reset();
  if (type != LastComposedWord.COMMIT_TYPE_DECIDED_WORD && type != LastComposedWord.COMMIT_TYPE_MANUAL_PICK) {
    lastComposedWord.deactivate();
  }
  mTypedWord.setLength(0);
  mTrailingSingleQuotesCount=0;
  refreshSize();
  mAutoCorrection=null;
  mIsResumed=false;
  return lastComposedWord;
}","public LastComposedWord commitWord(final int type,final String committedWord,final int separatorCode,final CharSequence prevWord){
  final int[] primaryKeyCodes=mPrimaryKeyCodes;
  mPrimaryKeyCodes=new int[N];
  final LastComposedWord lastComposedWord=new LastComposedWord(primaryKeyCodes,mInputPointers,mTypedWord.toString(),committedWord,separatorCode,prevWord);
  mInputPointers.reset();
  if (type != LastComposedWord.COMMIT_TYPE_DECIDED_WORD && type != LastComposedWord.COMMIT_TYPE_MANUAL_PICK) {
    lastComposedWord.deactivate();
  }
  mCapsCount=0;
  mIsBatchMode=false;
  mTypedWord.setLength(0);
  mTrailingSingleQuotesCount=0;
  mIsFirstCharCapitalized=false;
  refreshSize();
  mAutoCorrection=null;
  mIsResumed=false;
  return lastComposedWord;
}",0.9510006901311248
87887,"public SuggestedWords getSuggestedWords(final WordComposer wordComposer,CharSequence prevWordForBigram,final ProximityInfo proximityInfo,final boolean isCorrectionEnabled,final boolean isPrediction){
  LatinImeLogger.onStartSuggestion(prevWordForBigram);
  final boolean isFirstCharCapitalized=!isPrediction && wordComposer.isFirstCharCapitalized();
  final boolean isAllUpperCase=!isPrediction && wordComposer.isAllUpperCase();
  final int trailingSingleQuotesCount=wordComposer.trailingSingleQuotesCount();
  final BoundedTreeSet suggestionsSet=new BoundedTreeSet(sSuggestedWordInfoComparator,MAX_SUGGESTIONS);
  final String typedWord=wordComposer.getTypedWord();
  final String consideredWord=trailingSingleQuotesCount > 0 ? typedWord.substring(0,typedWord.length() - trailingSingleQuotesCount) : typedWord;
  LatinImeLogger.onAddSuggestedWord(typedWord,Dictionary.TYPE_USER_TYPED);
  if (wordComposer.size() <= 1 && isCorrectionEnabled) {
    if (!TextUtils.isEmpty(prevWordForBigram)) {
      for (      final String key : mDictionaries.keySet()) {
        final Dictionary dictionary=mDictionaries.get(key);
        suggestionsSet.addAll(dictionary.getBigrams(wordComposer,prevWordForBigram));
      }
    }
  }
 else   if (wordComposer.size() > 1) {
    final WordComposer wordComposerForLookup;
    if (trailingSingleQuotesCount > 0) {
      wordComposerForLookup=new WordComposer(wordComposer);
      for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
        wordComposerForLookup.deleteLast();
      }
    }
 else {
      wordComposerForLookup=wordComposer;
    }
    for (    final String key : mDictionaries.keySet()) {
      if (key.equals(Dictionary.TYPE_USER_HISTORY) || key.equals(Dictionary.TYPE_WHITELIST))       continue;
      final Dictionary dictionary=mDictionaries.get(key);
      suggestionsSet.addAll(dictionary.getWords(wordComposerForLookup,prevWordForBigram,proximityInfo));
    }
  }
  final boolean allowsToBeAutoCorrected=AutoCorrection.isWhitelistedOrNotAWord(mDictionaries,consideredWord,wordComposer.isFirstCharCapitalized());
  final CharSequence whitelistedWord=mWhiteListDictionary.getWhitelistedWord(consideredWord);
  final boolean hasAutoCorrection;
  if (!isCorrectionEnabled || !allowsToBeAutoCorrected || wordComposer.isMostlyCaps()|| wordComposer.isResumed()|| !hasMainDictionary()) {
    hasAutoCorrection=false;
  }
 else   if (null != whitelistedWord) {
    hasAutoCorrection=true;
  }
 else   if (suggestionsSet.isEmpty()) {
    hasAutoCorrection=false;
  }
 else   if (AutoCorrection.suggestionExceedsAutoCorrectionThreshold(suggestionsSet.first(),consideredWord,mAutoCorrectionThreshold)) {
    hasAutoCorrection=true;
  }
 else {
    hasAutoCorrection=false;
  }
  if (whitelistedWord != null) {
    suggestionsSet.add(new SuggestedWordInfo(whitelistedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_WHITELIST,Dictionary.TYPE_WHITELIST));
  }
  final ArrayList<SuggestedWordInfo> suggestionsContainer=new ArrayList<SuggestedWordInfo>(suggestionsSet);
  final int suggestionsCount=suggestionsContainer.size();
  if (isFirstCharCapitalized || isAllUpperCase || 0 != trailingSingleQuotesCount) {
    for (int i=0; i < suggestionsCount; ++i) {
      final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
      final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,mLocale,isAllUpperCase,isFirstCharCapitalized,trailingSingleQuotesCount);
      suggestionsContainer.set(i,transformedWordInfo);
    }
  }
  for (int i=0; i < suggestionsCount; ++i) {
    final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
    LatinImeLogger.onAddSuggestedWord(wordInfo.mWord.toString(),wordInfo.mSourceDict);
  }
  if (!TextUtils.isEmpty(typedWord)) {
    suggestionsContainer.add(0,new SuggestedWordInfo(typedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_TYPED,Dictionary.TYPE_USER_TYPED));
  }
  SuggestedWordInfo.removeDups(suggestionsContainer);
  final ArrayList<SuggestedWordInfo> suggestionsList;
  if (DBG && !suggestionsContainer.isEmpty()) {
    suggestionsList=getSuggestionsInfoListWithDebugInfo(typedWord,suggestionsContainer);
  }
 else {
    suggestionsList=suggestionsContainer;
  }
  return new SuggestedWords(suggestionsList,!isPrediction && !allowsToBeAutoCorrected,!isPrediction && hasAutoCorrection,false,false,isPrediction);
}","public SuggestedWords getSuggestedWords(final WordComposer wordComposer,CharSequence prevWordForBigram,final ProximityInfo proximityInfo,final boolean isCorrectionEnabled,final boolean isPrediction){
  LatinImeLogger.onStartSuggestion(prevWordForBigram);
  final boolean isFirstCharCapitalized=!isPrediction && wordComposer.isFirstCharCapitalized();
  final boolean isAllUpperCase=!isPrediction && wordComposer.isAllUpperCase();
  final int trailingSingleQuotesCount=wordComposer.trailingSingleQuotesCount();
  final BoundedTreeSet suggestionsSet=new BoundedTreeSet(sSuggestedWordInfoComparator,MAX_SUGGESTIONS);
  final String typedWord=wordComposer.getTypedWord();
  final String consideredWord=trailingSingleQuotesCount > 0 ? typedWord.substring(0,typedWord.length() - trailingSingleQuotesCount) : typedWord;
  LatinImeLogger.onAddSuggestedWord(typedWord,Dictionary.TYPE_USER_TYPED);
  if (wordComposer.size() <= 1) {
    if (!TextUtils.isEmpty(prevWordForBigram)) {
      for (      final String key : mDictionaries.keySet()) {
        final Dictionary dictionary=mDictionaries.get(key);
        suggestionsSet.addAll(dictionary.getBigrams(wordComposer,prevWordForBigram));
      }
    }
  }
 else {
    final WordComposer wordComposerForLookup;
    if (trailingSingleQuotesCount > 0) {
      wordComposerForLookup=new WordComposer(wordComposer);
      for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
        wordComposerForLookup.deleteLast();
      }
    }
 else {
      wordComposerForLookup=wordComposer;
    }
    for (    final String key : mDictionaries.keySet()) {
      if (key.equals(Dictionary.TYPE_USER_HISTORY) || key.equals(Dictionary.TYPE_WHITELIST))       continue;
      final Dictionary dictionary=mDictionaries.get(key);
      suggestionsSet.addAll(dictionary.getWords(wordComposerForLookup,prevWordForBigram,proximityInfo));
    }
  }
  final boolean allowsToBeAutoCorrected=AutoCorrection.isWhitelistedOrNotAWord(mDictionaries,consideredWord,wordComposer.isFirstCharCapitalized());
  final CharSequence whitelistedWord=mWhiteListDictionary.getWhitelistedWord(consideredWord);
  final boolean hasAutoCorrection;
  if (!isCorrectionEnabled || !allowsToBeAutoCorrected || wordComposer.isMostlyCaps()|| wordComposer.isResumed()|| !hasMainDictionary()) {
    hasAutoCorrection=false;
  }
 else   if (null != whitelistedWord) {
    hasAutoCorrection=true;
  }
 else   if (suggestionsSet.isEmpty()) {
    hasAutoCorrection=false;
  }
 else   if (AutoCorrection.suggestionExceedsAutoCorrectionThreshold(suggestionsSet.first(),consideredWord,mAutoCorrectionThreshold)) {
    hasAutoCorrection=true;
  }
 else {
    hasAutoCorrection=false;
  }
  if (whitelistedWord != null) {
    suggestionsSet.add(new SuggestedWordInfo(whitelistedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_WHITELIST,Dictionary.TYPE_WHITELIST));
  }
  final ArrayList<SuggestedWordInfo> suggestionsContainer=new ArrayList<SuggestedWordInfo>(suggestionsSet);
  final int suggestionsCount=suggestionsContainer.size();
  if (isFirstCharCapitalized || isAllUpperCase || 0 != trailingSingleQuotesCount) {
    for (int i=0; i < suggestionsCount; ++i) {
      final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
      final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,mLocale,isAllUpperCase,isFirstCharCapitalized,trailingSingleQuotesCount);
      suggestionsContainer.set(i,transformedWordInfo);
    }
  }
  for (int i=0; i < suggestionsCount; ++i) {
    final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
    LatinImeLogger.onAddSuggestedWord(wordInfo.mWord.toString(),wordInfo.mSourceDict);
  }
  if (!TextUtils.isEmpty(typedWord)) {
    suggestionsContainer.add(0,new SuggestedWordInfo(typedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_TYPED,Dictionary.TYPE_USER_TYPED));
  }
  SuggestedWordInfo.removeDups(suggestionsContainer);
  final ArrayList<SuggestedWordInfo> suggestionsList;
  if (DBG && !suggestionsContainer.isEmpty()) {
    suggestionsList=getSuggestionsInfoListWithDebugInfo(typedWord,suggestionsContainer);
  }
 else {
    suggestionsList=suggestionsContainer;
  }
  return new SuggestedWords(suggestionsList,!isPrediction && !allowsToBeAutoCorrected,!isPrediction && hasAutoCorrection,false,false,isPrediction);
}",0.99375866851595
87888,"public SuggestedWords getSuggestedWords(final WordComposer wordComposer,CharSequence prevWordForBigram,final ProximityInfo proximityInfo,final boolean isCorrectionEnabled,final boolean isPrediction){
  LatinImeLogger.onStartSuggestion(prevWordForBigram);
  final boolean isFirstCharCapitalized=!isPrediction && wordComposer.isFirstCharCapitalized();
  final boolean isAllUpperCase=!isPrediction && wordComposer.isAllUpperCase();
  final int trailingSingleQuotesCount=wordComposer.trailingSingleQuotesCount();
  final BoundedTreeSet suggestionsSet=new BoundedTreeSet(sSuggestedWordInfoComparator,MAX_SUGGESTIONS);
  final String typedWord=wordComposer.getTypedWord();
  final String consideredWord=trailingSingleQuotesCount > 0 ? typedWord.substring(0,typedWord.length() - trailingSingleQuotesCount) : typedWord;
  LatinImeLogger.onAddSuggestedWord(typedWord,Dictionary.TYPE_USER_TYPED);
  if (wordComposer.size() <= 1 && isCorrectionEnabled) {
    if (!TextUtils.isEmpty(prevWordForBigram)) {
      for (      final String key : mDictionaries.keySet()) {
        final Dictionary dictionary=mDictionaries.get(key);
        suggestionsSet.addAll(dictionary.getBigrams(wordComposer,prevWordForBigram));
      }
    }
  }
 else   if (wordComposer.size() > 1) {
    final WordComposer wordComposerForLookup;
    if (trailingSingleQuotesCount > 0) {
      wordComposerForLookup=new WordComposer(wordComposer);
      for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
        wordComposerForLookup.deleteLast();
      }
    }
 else {
      wordComposerForLookup=wordComposer;
    }
    for (    final String key : mDictionaries.keySet()) {
      if (key.equals(Dictionary.TYPE_USER_HISTORY) || key.equals(Dictionary.TYPE_WHITELIST))       continue;
      final Dictionary dictionary=mDictionaries.get(key);
      suggestionsSet.addAll(dictionary.getWords(wordComposerForLookup,prevWordForBigram,proximityInfo));
    }
  }
  final boolean allowsToBeAutoCorrected=AutoCorrection.isWhitelistedOrNotAWord(mDictionaries,consideredWord,wordComposer.isFirstCharCapitalized());
  final CharSequence whitelistedWord=mWhiteListDictionary.getWhitelistedWord(consideredWord);
  final boolean hasAutoCorrection;
  if (!isCorrectionEnabled || !allowsToBeAutoCorrected || wordComposer.isMostlyCaps()|| wordComposer.isResumed()|| !hasMainDictionary()) {
    hasAutoCorrection=false;
  }
 else   if (null != whitelistedWord) {
    hasAutoCorrection=true;
  }
 else   if (suggestionsSet.isEmpty()) {
    hasAutoCorrection=false;
  }
 else   if (AutoCorrection.suggestionExceedsAutoCorrectionThreshold(suggestionsSet.first(),consideredWord,mAutoCorrectionThreshold)) {
    hasAutoCorrection=true;
  }
 else {
    hasAutoCorrection=false;
  }
  if (whitelistedWord != null) {
    suggestionsSet.add(new SuggestedWordInfo(whitelistedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_WHITELIST,Dictionary.TYPE_WHITELIST));
  }
  final ArrayList<SuggestedWordInfo> suggestionsContainer=new ArrayList<SuggestedWordInfo>(suggestionsSet);
  final int suggestionsCount=suggestionsContainer.size();
  if (isFirstCharCapitalized || isAllUpperCase || 0 != trailingSingleQuotesCount) {
    for (int i=0; i < suggestionsCount; ++i) {
      final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
      final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,mLocale,isAllUpperCase,isFirstCharCapitalized,trailingSingleQuotesCount);
      suggestionsContainer.set(i,transformedWordInfo);
    }
  }
  for (int i=0; i < suggestionsCount; ++i) {
    final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
    LatinImeLogger.onAddSuggestedWord(wordInfo.mWord.toString(),wordInfo.mSourceDict);
  }
  if (!TextUtils.isEmpty(typedWord)) {
    suggestionsContainer.add(0,new SuggestedWordInfo(typedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_TYPED,Dictionary.TYPE_USER_TYPED));
  }
  SuggestedWordInfo.removeDups(suggestionsContainer);
  final ArrayList<SuggestedWordInfo> suggestionsList;
  if (DBG && !suggestionsContainer.isEmpty()) {
    suggestionsList=getSuggestionsInfoListWithDebugInfo(typedWord,suggestionsContainer);
  }
 else {
    suggestionsList=suggestionsContainer;
  }
  return new SuggestedWords(suggestionsList,!isPrediction && !allowsToBeAutoCorrected,!isPrediction && hasAutoCorrection,false,false,isPrediction);
}","public SuggestedWords getSuggestedWords(final WordComposer wordComposer,CharSequence prevWordForBigram,final ProximityInfo proximityInfo,final boolean isCorrectionEnabled,final boolean isPrediction){
  LatinImeLogger.onStartSuggestion(prevWordForBigram);
  final boolean isFirstCharCapitalized=!isPrediction && wordComposer.isFirstCharCapitalized();
  final boolean isAllUpperCase=!isPrediction && wordComposer.isAllUpperCase();
  final int trailingSingleQuotesCount=wordComposer.trailingSingleQuotesCount();
  final BoundedTreeSet suggestionsSet=new BoundedTreeSet(sSuggestedWordInfoComparator,MAX_SUGGESTIONS);
  final String typedWord=wordComposer.getTypedWord();
  final String consideredWord=trailingSingleQuotesCount > 0 ? typedWord.substring(0,typedWord.length() - trailingSingleQuotesCount) : typedWord;
  LatinImeLogger.onAddSuggestedWord(typedWord,Dictionary.TYPE_USER_TYPED);
  if (wordComposer.size() <= 1) {
    if (!TextUtils.isEmpty(prevWordForBigram)) {
      for (      final String key : mDictionaries.keySet()) {
        final Dictionary dictionary=mDictionaries.get(key);
        suggestionsSet.addAll(dictionary.getBigrams(wordComposer,prevWordForBigram));
      }
    }
  }
 else {
    final WordComposer wordComposerForLookup;
    if (trailingSingleQuotesCount > 0) {
      wordComposerForLookup=new WordComposer(wordComposer);
      for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
        wordComposerForLookup.deleteLast();
      }
    }
 else {
      wordComposerForLookup=wordComposer;
    }
    for (    final String key : mDictionaries.keySet()) {
      if (key.equals(Dictionary.TYPE_USER_HISTORY) || key.equals(Dictionary.TYPE_WHITELIST))       continue;
      final Dictionary dictionary=mDictionaries.get(key);
      suggestionsSet.addAll(dictionary.getWords(wordComposerForLookup,prevWordForBigram,proximityInfo));
    }
  }
  final boolean allowsToBeAutoCorrected=AutoCorrection.isWhitelistedOrNotAWord(mDictionaries,consideredWord,wordComposer.isFirstCharCapitalized());
  final CharSequence whitelistedWord=mWhiteListDictionary.getWhitelistedWord(consideredWord);
  final boolean hasAutoCorrection;
  if (!isCorrectionEnabled || !allowsToBeAutoCorrected || wordComposer.isMostlyCaps()|| wordComposer.isResumed()|| !hasMainDictionary()) {
    hasAutoCorrection=false;
  }
 else   if (null != whitelistedWord) {
    hasAutoCorrection=true;
  }
 else   if (suggestionsSet.isEmpty()) {
    hasAutoCorrection=false;
  }
 else   if (AutoCorrection.suggestionExceedsAutoCorrectionThreshold(suggestionsSet.first(),consideredWord,mAutoCorrectionThreshold)) {
    hasAutoCorrection=true;
  }
 else {
    hasAutoCorrection=false;
  }
  if (whitelistedWord != null) {
    suggestionsSet.add(new SuggestedWordInfo(whitelistedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_WHITELIST,Dictionary.TYPE_WHITELIST));
  }
  final ArrayList<SuggestedWordInfo> suggestionsContainer=new ArrayList<SuggestedWordInfo>(suggestionsSet);
  final int suggestionsCount=suggestionsContainer.size();
  if (isFirstCharCapitalized || isAllUpperCase || 0 != trailingSingleQuotesCount) {
    for (int i=0; i < suggestionsCount; ++i) {
      final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
      final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,mLocale,isAllUpperCase,isFirstCharCapitalized,trailingSingleQuotesCount);
      suggestionsContainer.set(i,transformedWordInfo);
    }
  }
  for (int i=0; i < suggestionsCount; ++i) {
    final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
    LatinImeLogger.onAddSuggestedWord(wordInfo.mWord.toString(),wordInfo.mSourceDict);
  }
  if (!TextUtils.isEmpty(typedWord)) {
    suggestionsContainer.add(0,new SuggestedWordInfo(typedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_TYPED,Dictionary.TYPE_USER_TYPED));
  }
  SuggestedWordInfo.removeDups(suggestionsContainer);
  final ArrayList<SuggestedWordInfo> suggestionsList;
  if (DBG && !suggestionsContainer.isEmpty()) {
    suggestionsList=getSuggestionsInfoListWithDebugInfo(typedWord,suggestionsContainer);
  }
 else {
    suggestionsList=suggestionsContainer;
  }
  return new SuggestedWords(suggestionsList,!isPrediction && !allowsToBeAutoCorrected,!isPrediction && hasAutoCorrection,false,false,isPrediction);
}",0.99375866851595
87889,"@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,final int x,final int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mCurrentSettings.isWeakSpaceStripper(firstChar)) && (!mCurrentSettings.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mCurrentSettings.isApplicationSpecifiedCompletionsOn() && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
    mConnection.beginBatchEdit();
    mConnection.commitCompletion(completionInfo);
    mConnection.endBatchEdit();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
    }
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mLastComposedWord.deactivate();
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (showingAddToDictionaryHint && mIsUserDictionaryAvailable) {
    mSuggestionsView.showAddToDictionaryHint(suggestion,mCurrentSettings.mHintToSaveText);
  }
 else {
    mHandler.postUpdateBigramPredictions();
  }
}","@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,final int x,final int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  mConnection.beginBatchEdit();
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mCurrentSettings.isWeakSpaceStripper(firstChar)) && (!mCurrentSettings.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mCurrentSettings.isApplicationSpecifiedCompletionsOn() && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
    mConnection.commitCompletion(completionInfo);
    mConnection.endBatchEdit();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
    }
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mConnection.endBatchEdit();
  mLastComposedWord.deactivate();
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (showingAddToDictionaryHint && mIsUserDictionaryAvailable) {
    mSuggestionsView.showAddToDictionaryHint(suggestion,mCurrentSettings.mHintToSaveText);
  }
 else {
    mHandler.postUpdateBigramPredictions();
  }
}",0.9824817518248176
87890,"@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,final int x,final int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mCurrentSettings.isWeakSpaceStripper(firstChar)) && (!mCurrentSettings.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mCurrentSettings.isApplicationSpecifiedCompletionsOn() && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
    mConnection.beginBatchEdit();
    mConnection.commitCompletion(completionInfo);
    mConnection.endBatchEdit();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
    }
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mLastComposedWord.deactivate();
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (showingAddToDictionaryHint && mIsUserDictionaryAvailable) {
    mSuggestionsView.showAddToDictionaryHint(suggestion,mCurrentSettings.mHintToSaveText);
  }
 else {
    mHandler.postUpdateBigramPredictions();
  }
}","@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,final int x,final int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  mConnection.beginBatchEdit();
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mCurrentSettings.isWeakSpaceStripper(firstChar)) && (!mCurrentSettings.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mCurrentSettings.isApplicationSpecifiedCompletionsOn() && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
    mConnection.commitCompletion(completionInfo);
    mConnection.endBatchEdit();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
    }
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mConnection.endBatchEdit();
  mLastComposedWord.deactivate();
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (showingAddToDictionaryHint && mIsUserDictionaryAvailable) {
    mSuggestionsView.showAddToDictionaryHint(suggestion,mCurrentSettings.mHintToSaveText);
  }
 else {
    mHandler.postUpdateBigramPredictions();
  }
}",0.9824817518248176
87891,"@Override public void onTextInput(CharSequence text){
  mConnection.beginBatchEdit(getCurrentInputConnection());
  commitTyped(LastComposedWord.NOT_A_SEPARATOR);
  text=specificTldProcessingOnTextInput(text);
  if (SPACE_STATE_PHANTOM == mSpaceState) {
    sendKeyCodePoint(Keyboard.CODE_SPACE);
  }
  mConnection.commitText(text,1);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_commitText(text);
  }
  mConnection.endBatchEdit();
  mKeyboardSwitcher.updateShiftState();
  mKeyboardSwitcher.onCodeInput(Keyboard.CODE_OUTPUT_TEXT);
  mSpaceState=SPACE_STATE_NONE;
  mEnteredText=text;
  resetComposingState(true);
}","@Override public void onTextInput(CharSequence text){
  mConnection.beginBatchEdit();
  commitTyped(LastComposedWord.NOT_A_SEPARATOR);
  text=specificTldProcessingOnTextInput(text);
  if (SPACE_STATE_PHANTOM == mSpaceState) {
    sendKeyCodePoint(Keyboard.CODE_SPACE);
  }
  mConnection.commitText(text,1);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_commitText(text);
  }
  mConnection.endBatchEdit();
  mKeyboardSwitcher.updateShiftState();
  mKeyboardSwitcher.onCodeInput(Keyboard.CODE_OUTPUT_TEXT);
  mSpaceState=SPACE_STATE_NONE;
  mEnteredText=text;
  resetComposingState(true);
}",0.9783480352846832
87892,"@Override public void onCodeInput(int primaryCode,int x,int y){
  final long when=SystemClock.uptimeMillis();
  if (primaryCode != Keyboard.CODE_DELETE || when > mLastKeyTime + QUICK_PRESS) {
    mDeleteCount=0;
  }
  mLastKeyTime=when;
  mConnection.beginBatchEdit(getCurrentInputConnection());
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onCodeInput(primaryCode,x,y);
  }
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final int spaceState=mSpaceState;
  if (!mWordComposer.isComposingWord())   mIsAutoCorrectionIndicatorOn=false;
  if (primaryCode != Keyboard.CODE_SPACE) {
    mHandler.cancelDoubleSpacesTimer();
  }
  boolean didAutoCorrect=false;
switch (primaryCode) {
case Keyboard.CODE_DELETE:
    mSpaceState=SPACE_STATE_NONE;
  handleBackspace(spaceState);
mDeleteCount++;
mExpectingUpdateSelection=true;
mShouldSwitchToLastSubtype=true;
LatinImeLogger.logOnDelete(x,y);
break;
case Keyboard.CODE_SHIFT:
case Keyboard.CODE_SWITCH_ALPHA_SYMBOL:
break;
case Keyboard.CODE_SETTINGS:
onSettingsKeyPressed();
break;
case Keyboard.CODE_SHORTCUT:
mSubtypeSwitcher.switchToShortcutIME();
break;
case Keyboard.CODE_ACTION_ENTER:
performEditorAction(getActionId(switcher.getKeyboard()));
break;
case Keyboard.CODE_ACTION_NEXT:
performEditorAction(EditorInfo.IME_ACTION_NEXT);
break;
case Keyboard.CODE_ACTION_PREVIOUS:
performEditorAction(EditorInfo.IME_ACTION_PREVIOUS);
break;
case Keyboard.CODE_LANGUAGE_SWITCH:
handleLanguageSwitchKey();
break;
case Keyboard.CODE_RESEARCH:
if (ProductionFlag.IS_EXPERIMENTAL) {
ResearchLogger.getInstance().presentResearchDialog(this);
}
break;
default :
mSpaceState=SPACE_STATE_NONE;
if (mCurrentSettings.isWordSeparator(primaryCode)) {
didAutoCorrect=handleSeparator(primaryCode,x,y,spaceState);
}
 else {
final Keyboard keyboard=mKeyboardSwitcher.getKeyboard();
if (keyboard != null && keyboard.hasProximityCharsCorrection(primaryCode)) {
handleCharacter(primaryCode,x,y,spaceState);
}
 else {
handleCharacter(primaryCode,NOT_A_TOUCH_COORDINATE,NOT_A_TOUCH_COORDINATE,spaceState);
}
}
mExpectingUpdateSelection=true;
mShouldSwitchToLastSubtype=true;
break;
}
switcher.onCodeInput(primaryCode);
if (!didAutoCorrect && primaryCode != Keyboard.CODE_SHIFT && primaryCode != Keyboard.CODE_SWITCH_ALPHA_SYMBOL) mLastComposedWord.deactivate();
mEnteredText=null;
mConnection.endBatchEdit();
}","@Override public void onCodeInput(int primaryCode,int x,int y){
  final long when=SystemClock.uptimeMillis();
  if (primaryCode != Keyboard.CODE_DELETE || when > mLastKeyTime + QUICK_PRESS) {
    mDeleteCount=0;
  }
  mLastKeyTime=when;
  mConnection.beginBatchEdit();
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onCodeInput(primaryCode,x,y);
  }
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final int spaceState=mSpaceState;
  if (!mWordComposer.isComposingWord())   mIsAutoCorrectionIndicatorOn=false;
  if (primaryCode != Keyboard.CODE_SPACE) {
    mHandler.cancelDoubleSpacesTimer();
  }
  boolean didAutoCorrect=false;
switch (primaryCode) {
case Keyboard.CODE_DELETE:
    mSpaceState=SPACE_STATE_NONE;
  handleBackspace(spaceState);
mDeleteCount++;
mExpectingUpdateSelection=true;
mShouldSwitchToLastSubtype=true;
LatinImeLogger.logOnDelete(x,y);
break;
case Keyboard.CODE_SHIFT:
case Keyboard.CODE_SWITCH_ALPHA_SYMBOL:
break;
case Keyboard.CODE_SETTINGS:
onSettingsKeyPressed();
break;
case Keyboard.CODE_SHORTCUT:
mSubtypeSwitcher.switchToShortcutIME();
break;
case Keyboard.CODE_ACTION_ENTER:
performEditorAction(getActionId(switcher.getKeyboard()));
break;
case Keyboard.CODE_ACTION_NEXT:
performEditorAction(EditorInfo.IME_ACTION_NEXT);
break;
case Keyboard.CODE_ACTION_PREVIOUS:
performEditorAction(EditorInfo.IME_ACTION_PREVIOUS);
break;
case Keyboard.CODE_LANGUAGE_SWITCH:
handleLanguageSwitchKey();
break;
case Keyboard.CODE_RESEARCH:
if (ProductionFlag.IS_EXPERIMENTAL) {
ResearchLogger.getInstance().presentResearchDialog(this);
}
break;
default :
mSpaceState=SPACE_STATE_NONE;
if (mCurrentSettings.isWordSeparator(primaryCode)) {
didAutoCorrect=handleSeparator(primaryCode,x,y,spaceState);
}
 else {
final Keyboard keyboard=mKeyboardSwitcher.getKeyboard();
if (keyboard != null && keyboard.hasProximityCharsCorrection(primaryCode)) {
handleCharacter(primaryCode,x,y,spaceState);
}
 else {
handleCharacter(primaryCode,NOT_A_TOUCH_COORDINATE,NOT_A_TOUCH_COORDINATE,spaceState);
}
}
mExpectingUpdateSelection=true;
mShouldSwitchToLastSubtype=true;
break;
}
switcher.onCodeInput(primaryCode);
if (!didAutoCorrect && primaryCode != Keyboard.CODE_SHIFT && primaryCode != Keyboard.CODE_SWITCH_ALPHA_SYMBOL) mLastComposedWord.deactivate();
mEnteredText=null;
mConnection.endBatchEdit();
}",0.994244297591132
87893,"@Override public void onConfigurationChanged(Configuration conf){
  mSubtypeSwitcher.onConfigurationChanged(conf);
  if (mDisplayOrientation != conf.orientation) {
    mDisplayOrientation=conf.orientation;
    mHandler.startOrientationChanging();
    mConnection.beginBatchEdit(getCurrentInputConnection());
    commitTyped(LastComposedWord.NOT_A_SEPARATOR);
    mConnection.finishComposingText();
    mConnection.endBatchEdit();
    if (isShowingOptionDialog())     mOptionsDialog.dismiss();
  }
  super.onConfigurationChanged(conf);
}","@Override public void onConfigurationChanged(Configuration conf){
  mSubtypeSwitcher.onConfigurationChanged(conf);
  if (mDisplayOrientation != conf.orientation) {
    mDisplayOrientation=conf.orientation;
    mHandler.startOrientationChanging();
    mConnection.beginBatchEdit();
    commitTyped(LastComposedWord.NOT_A_SEPARATOR);
    mConnection.finishComposingText();
    mConnection.endBatchEdit();
    if (isShowingOptionDialog())     mOptionsDialog.dismiss();
  }
  super.onConfigurationChanged(conf);
}",0.9741626794258372
87894,"@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,final int x,final int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mCurrentSettings.isWeakSpaceStripper(firstChar)) && (!mCurrentSettings.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mCurrentSettings.isApplicationSpecifiedCompletionsOn() && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
    mConnection.beginBatchEdit(getCurrentInputConnection());
    mConnection.commitCompletion(completionInfo);
    mConnection.endBatchEdit();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
    }
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mLastComposedWord.deactivate();
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (!showingAddToDictionaryHint) {
    updateSuggestionsOrPredictions(true);
  }
 else {
    if (mIsUserDictionaryAvailable) {
      mSuggestionsView.showAddToDictionaryHint(suggestion,mCurrentSettings.mHintToSaveText);
    }
 else {
      mHandler.postUpdateSuggestions();
    }
  }
}","@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,final int x,final int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mCurrentSettings.isWeakSpaceStripper(firstChar)) && (!mCurrentSettings.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mCurrentSettings.isApplicationSpecifiedCompletionsOn() && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
    mConnection.beginBatchEdit();
    mConnection.commitCompletion(completionInfo);
    mConnection.endBatchEdit();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
    }
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mLastComposedWord.deactivate();
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (!showingAddToDictionaryHint) {
    updateSuggestionsOrPredictions(true);
  }
 else {
    if (mIsUserDictionaryAvailable) {
      mSuggestionsView.showAddToDictionaryHint(suggestion,mCurrentSettings.mHintToSaveText);
    }
 else {
      mHandler.postUpdateSuggestions();
    }
  }
}",0.9951931636104682
87895,"private int getCursorPosition(){
  if (null == mIC)   return INVALID_CURSOR_POSITION;
  final ExtractedText extracted=mIC.getExtractedText(new ExtractedTextRequest(),0);
  if (extracted == null) {
    return INVALID_CURSOR_POSITION;
  }
  return extracted.startOffset + extracted.selectionStart;
}","private int getCursorPosition(){
  mIC=mParent.getCurrentInputConnection();
  if (null == mIC)   return INVALID_CURSOR_POSITION;
  final ExtractedText extracted=mIC.getExtractedText(new ExtractedTextRequest(),0);
  if (extracted == null) {
    return INVALID_CURSOR_POSITION;
  }
  return extracted.startOffset + extracted.selectionStart;
}",0.9324960753532182
87896,"public CharSequence getTextAfterCursor(final int i,final int j){
  if (null != mIC)   return mIC.getTextAfterCursor(i,j);
  return null;
}","public CharSequence getTextAfterCursor(final int i,final int j){
  mIC=mParent.getCurrentInputConnection();
  if (null != mIC)   return mIC.getTextAfterCursor(i,j);
  return null;
}",0.8652037617554859
87897,"public RichInputConnection(){
  mIC=null;
  mNestLevel=0;
}","public RichInputConnection(final InputMethodService parent){
  mParent=parent;
  mIC=null;
  mNestLevel=0;
}",0.7065868263473054
87898,"public CharSequence getTextBeforeCursor(final int i,final int j){
  if (null != mIC)   return mIC.getTextBeforeCursor(i,j);
  return null;
}","public CharSequence getTextBeforeCursor(final int i,final int j){
  mIC=mParent.getCurrentInputConnection();
  if (null != mIC)   return mIC.getTextBeforeCursor(i,j);
  return null;
}",0.8668730650154799
87899,"public void performEditorAction(final int actionId){
  if (null != mIC)   mIC.performEditorAction(actionId);
}","public void performEditorAction(final int actionId){
  mIC=mParent.getCurrentInputConnection();
  if (null != mIC)   mIC.performEditorAction(actionId);
}",0.8365019011406845
87900,"/** 
 * Returns the text surrounding the cursor.
 * @param sep a string of characters that split words.
 * @param additionalPrecedingWordsCount the number of words before the current word that shouldbe included in the returned range
 * @return a range containing the text surrounding the cursor
 */
public Range getWordRangeAtCursor(String sep,int additionalPrecedingWordsCount){
  if (mIC == null || sep == null) {
    return null;
  }
  CharSequence before=mIC.getTextBeforeCursor(1000,0);
  CharSequence after=mIC.getTextAfterCursor(1000,0);
  if (before == null || after == null) {
    return null;
  }
  int start=before.length();
  boolean isStoppingAtWhitespace=true;
  while (true) {
    while (start > 0) {
      final int codePoint=Character.codePointBefore(before,start);
      if (isStoppingAtWhitespace == isSeparator(codePoint,sep)) {
        break;
      }
      --start;
      if (Character.isSupplementaryCodePoint(codePoint)) {
        --start;
      }
    }
    if (isStoppingAtWhitespace && (--additionalPrecedingWordsCount < 0)) {
      break;
    }
    isStoppingAtWhitespace=!isStoppingAtWhitespace;
  }
  int end=-1;
  while (++end < after.length()) {
    final int codePoint=Character.codePointAt(after,end);
    if (isSeparator(codePoint,sep)) {
      break;
    }
    if (Character.isSupplementaryCodePoint(codePoint)) {
      ++end;
    }
  }
  int cursor=getCursorPosition();
  if (start >= 0 && cursor + end <= after.length() + before.length()) {
    String word=before.toString().substring(start,before.length()) + after.toString().substring(0,end);
    return new Range(before.length() - start,end,word);
  }
  return null;
}","/** 
 * Returns the text surrounding the cursor.
 * @param sep a string of characters that split words.
 * @param additionalPrecedingWordsCount the number of words before the current word that shouldbe included in the returned range
 * @return a range containing the text surrounding the cursor
 */
public Range getWordRangeAtCursor(String sep,int additionalPrecedingWordsCount){
  mIC=mParent.getCurrentInputConnection();
  if (mIC == null || sep == null) {
    return null;
  }
  CharSequence before=mIC.getTextBeforeCursor(1000,0);
  CharSequence after=mIC.getTextAfterCursor(1000,0);
  if (before == null || after == null) {
    return null;
  }
  int start=before.length();
  boolean isStoppingAtWhitespace=true;
  while (true) {
    while (start > 0) {
      final int codePoint=Character.codePointBefore(before,start);
      if (isStoppingAtWhitespace == isSeparator(codePoint,sep)) {
        break;
      }
      --start;
      if (Character.isSupplementaryCodePoint(codePoint)) {
        --start;
      }
    }
    if (isStoppingAtWhitespace && (--additionalPrecedingWordsCount < 0)) {
      break;
    }
    isStoppingAtWhitespace=!isStoppingAtWhitespace;
  }
  int end=-1;
  while (++end < after.length()) {
    final int codePoint=Character.codePointAt(after,end);
    if (isSeparator(codePoint,sep)) {
      break;
    }
    if (Character.isSupplementaryCodePoint(codePoint)) {
      ++end;
    }
  }
  int cursor=getCursorPosition();
  if (start >= 0 && cursor + end <= after.length() + before.length()) {
    String word=before.toString().substring(start,before.length()) + after.toString().substring(0,end);
    return new Range(before.length() - start,end,word);
  }
  return null;
}",0.987190944295502
87901,"public void beginBatchEdit(final InputConnection newInputConnection){
  if (++mNestLevel == 1) {
    mIC=newInputConnection;
    if (null != mIC)     mIC.beginBatchEdit();
  }
 else {
    if (DBG) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      Log.e(TAG,""String_Node_Str"" + mNestLevel);
    }
  }
}","public void beginBatchEdit(){
  if (++mNestLevel == 1) {
    mIC=mParent.getCurrentInputConnection();
    if (null != mIC)     mIC.beginBatchEdit();
  }
 else {
    if (DBG) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      Log.e(TAG,""String_Node_Str"" + mNestLevel);
    }
  }
}",0.8998410174880763
87902,"public int getCursorCapsMode(final int inputType){
  if (null == mIC)   return Constants.TextUtils.CAP_MODE_OFF;
  return mIC.getCursorCapsMode(inputType);
}","public int getCursorCapsMode(final int inputType){
  mIC=mParent.getCurrentInputConnection();
  if (null == mIC)   return Constants.TextUtils.CAP_MODE_OFF;
  return mIC.getCursorCapsMode(inputType);
}",0.8795518207282913
87903,"/** 
 * Test logic in getting the word range at the cursor.
 */
public void testGetWordRangeAtCursor(){
  ExtractedText et=new ExtractedText();
  final RichInputConnection ic=new RichInputConnection();
  InputConnection mockConnection;
  mockConnection=new MockConnection(""String_Node_Str"",""String_Node_Str"",et);
  et.startOffset=0;
  et.selectionStart=7;
  Range r;
  ic.beginBatchEdit(mockConnection);
  r=ic.getWordRangeAtCursor(""String_Node_Str"",0);
  assertEquals(""String_Node_Str"",r.mWord);
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  assertEquals(""String_Node_Str"",r.mWord);
  ic.endBatchEdit();
  mockConnection=new MockConnection(""String_Node_Str"",""String_Node_Str"",et);
  ic.beginBatchEdit(mockConnection);
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  mockConnection=new MockConnection(""String_Node_Str"",""String_Node_Str"",et);
  ic.beginBatchEdit(mockConnection);
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  mockConnection=new MockConnection(""String_Node_Str"",""String_Node_Str"",et);
  ic.beginBatchEdit(mockConnection);
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  mockConnection=new MockConnection(""String_Node_Str"",""String_Node_Str"",et);
  ic.beginBatchEdit(mockConnection);
  r=ic.getWordRangeAtCursor(""String_Node_Str"",2);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  final String supplementaryChar=""String_Node_Str"";
  mockConnection=new MockConnection(""String_Node_Str"" + supplementaryChar + ""String_Node_Str"",""String_Node_Str"",et);
  ic.beginBatchEdit(mockConnection);
  r=ic.getWordRangeAtCursor(supplementaryChar,0);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
}","/** 
 * Test logic in getting the word range at the cursor.
 */
public void testGetWordRangeAtCursor(){
  ExtractedText et=new ExtractedText();
  final MockInputMethodService mockInputMethodService=new MockInputMethodService();
  final RichInputConnection ic=new RichInputConnection(mockInputMethodService);
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  et.startOffset=0;
  et.selectionStart=7;
  Range r;
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(""String_Node_Str"",0);
  assertEquals(""String_Node_Str"",r.mWord);
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  assertEquals(""String_Node_Str"",r.mWord);
  ic.endBatchEdit();
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(""String_Node_Str"",2);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  final String supplementaryChar=""String_Node_Str"";
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"" + supplementaryChar + ""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(supplementaryChar,0);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
}",0.8413111342351717
87904,"@Override public void onTextInput(CharSequence text){
  mConnection.beginBatchEdit(getCurrentInputConnection());
  commitTyped(LastComposedWord.NOT_A_SEPARATOR);
  text=specificTldProcessingOnTextInput(text);
  if (SPACE_STATE_PHANTOM == mSpaceState) {
    sendKeyCodePoint(Keyboard.CODE_SPACE);
  }
  mConnection.commitText(text,1);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_commitText(text);
  }
  mConnection.endBatchEdit();
  mKeyboardSwitcher.updateShiftState();
  mKeyboardSwitcher.onCodeInput(Keyboard.CODE_OUTPUT_TEXT);
  mSpaceState=SPACE_STATE_NONE;
  mEnteredText=text;
  resetComposingState(true);
}","@Override public void onTextInput(CharSequence text){
  mConnection.beginBatchEdit();
  commitTyped(LastComposedWord.NOT_A_SEPARATOR);
  text=specificTldProcessingOnTextInput(text);
  if (SPACE_STATE_PHANTOM == mSpaceState) {
    sendKeyCodePoint(Keyboard.CODE_SPACE);
  }
  mConnection.commitText(text,1);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_commitText(text);
  }
  mConnection.endBatchEdit();
  mKeyboardSwitcher.updateShiftState();
  mKeyboardSwitcher.onCodeInput(Keyboard.CODE_OUTPUT_TEXT);
  mSpaceState=SPACE_STATE_NONE;
  mEnteredText=text;
  resetComposingState(true);
}",0.9783480352846832
87905,"@Override public void onCodeInput(int primaryCode,int x,int y){
  final long when=SystemClock.uptimeMillis();
  if (primaryCode != Keyboard.CODE_DELETE || when > mLastKeyTime + QUICK_PRESS) {
    mDeleteCount=0;
  }
  mLastKeyTime=when;
  mConnection.beginBatchEdit(getCurrentInputConnection());
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onCodeInput(primaryCode,x,y);
  }
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final int spaceState=mSpaceState;
  if (!mWordComposer.isComposingWord())   mIsAutoCorrectionIndicatorOn=false;
  if (primaryCode != Keyboard.CODE_SPACE) {
    mHandler.cancelDoubleSpacesTimer();
  }
  boolean didAutoCorrect=false;
switch (primaryCode) {
case Keyboard.CODE_DELETE:
    mSpaceState=SPACE_STATE_NONE;
  handleBackspace(spaceState);
mDeleteCount++;
mExpectingUpdateSelection=true;
mShouldSwitchToLastSubtype=true;
LatinImeLogger.logOnDelete(x,y);
break;
case Keyboard.CODE_SHIFT:
case Keyboard.CODE_SWITCH_ALPHA_SYMBOL:
break;
case Keyboard.CODE_SETTINGS:
onSettingsKeyPressed();
break;
case Keyboard.CODE_SHORTCUT:
mSubtypeSwitcher.switchToShortcutIME();
break;
case Keyboard.CODE_ACTION_ENTER:
performEditorAction(getActionId(switcher.getKeyboard()));
break;
case Keyboard.CODE_ACTION_NEXT:
performEditorAction(EditorInfo.IME_ACTION_NEXT);
break;
case Keyboard.CODE_ACTION_PREVIOUS:
performEditorAction(EditorInfo.IME_ACTION_PREVIOUS);
break;
case Keyboard.CODE_LANGUAGE_SWITCH:
handleLanguageSwitchKey();
break;
case Keyboard.CODE_RESEARCH:
if (ProductionFlag.IS_EXPERIMENTAL) {
ResearchLogger.getInstance().presentResearchDialog(this);
}
break;
default :
if (primaryCode == Keyboard.CODE_TAB && mCurrentSettings.isEditorActionNext()) {
performEditorAction(EditorInfo.IME_ACTION_NEXT);
break;
}
mSpaceState=SPACE_STATE_NONE;
if (mCurrentSettings.isWordSeparator(primaryCode)) {
didAutoCorrect=handleSeparator(primaryCode,x,y,spaceState);
}
 else {
final Keyboard keyboard=mKeyboardSwitcher.getKeyboard();
if (keyboard != null && keyboard.hasProximityCharsCorrection(primaryCode)) {
handleCharacter(primaryCode,x,y,spaceState);
}
 else {
handleCharacter(primaryCode,NOT_A_TOUCH_COORDINATE,NOT_A_TOUCH_COORDINATE,spaceState);
}
}
mExpectingUpdateSelection=true;
mShouldSwitchToLastSubtype=true;
break;
}
switcher.onCodeInput(primaryCode);
if (!didAutoCorrect && primaryCode != Keyboard.CODE_SHIFT && primaryCode != Keyboard.CODE_SWITCH_ALPHA_SYMBOL) mLastComposedWord.deactivate();
mEnteredText=null;
mConnection.endBatchEdit();
}","@Override public void onCodeInput(int primaryCode,int x,int y){
  final long when=SystemClock.uptimeMillis();
  if (primaryCode != Keyboard.CODE_DELETE || when > mLastKeyTime + QUICK_PRESS) {
    mDeleteCount=0;
  }
  mLastKeyTime=when;
  mConnection.beginBatchEdit();
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_onCodeInput(primaryCode,x,y);
  }
  final KeyboardSwitcher switcher=mKeyboardSwitcher;
  final int spaceState=mSpaceState;
  if (!mWordComposer.isComposingWord())   mIsAutoCorrectionIndicatorOn=false;
  if (primaryCode != Keyboard.CODE_SPACE) {
    mHandler.cancelDoubleSpacesTimer();
  }
  boolean didAutoCorrect=false;
switch (primaryCode) {
case Keyboard.CODE_DELETE:
    mSpaceState=SPACE_STATE_NONE;
  handleBackspace(spaceState);
mDeleteCount++;
mExpectingUpdateSelection=true;
mShouldSwitchToLastSubtype=true;
LatinImeLogger.logOnDelete(x,y);
break;
case Keyboard.CODE_SHIFT:
case Keyboard.CODE_SWITCH_ALPHA_SYMBOL:
break;
case Keyboard.CODE_SETTINGS:
onSettingsKeyPressed();
break;
case Keyboard.CODE_SHORTCUT:
mSubtypeSwitcher.switchToShortcutIME();
break;
case Keyboard.CODE_ACTION_ENTER:
performEditorAction(getActionId(switcher.getKeyboard()));
break;
case Keyboard.CODE_ACTION_NEXT:
performEditorAction(EditorInfo.IME_ACTION_NEXT);
break;
case Keyboard.CODE_ACTION_PREVIOUS:
performEditorAction(EditorInfo.IME_ACTION_PREVIOUS);
break;
case Keyboard.CODE_LANGUAGE_SWITCH:
handleLanguageSwitchKey();
break;
case Keyboard.CODE_RESEARCH:
if (ProductionFlag.IS_EXPERIMENTAL) {
ResearchLogger.getInstance().presentResearchDialog(this);
}
break;
default :
if (primaryCode == Keyboard.CODE_TAB && mCurrentSettings.isEditorActionNext()) {
performEditorAction(EditorInfo.IME_ACTION_NEXT);
break;
}
mSpaceState=SPACE_STATE_NONE;
if (mCurrentSettings.isWordSeparator(primaryCode)) {
didAutoCorrect=handleSeparator(primaryCode,x,y,spaceState);
}
 else {
final Keyboard keyboard=mKeyboardSwitcher.getKeyboard();
if (keyboard != null && keyboard.hasProximityCharsCorrection(primaryCode)) {
handleCharacter(primaryCode,x,y,spaceState);
}
 else {
handleCharacter(primaryCode,NOT_A_TOUCH_COORDINATE,NOT_A_TOUCH_COORDINATE,spaceState);
}
}
mExpectingUpdateSelection=true;
mShouldSwitchToLastSubtype=true;
break;
}
switcher.onCodeInput(primaryCode);
if (!didAutoCorrect && primaryCode != Keyboard.CODE_SHIFT && primaryCode != Keyboard.CODE_SWITCH_ALPHA_SYMBOL) mLastComposedWord.deactivate();
mEnteredText=null;
mConnection.endBatchEdit();
}",0.9945663111289998
87906,"@Override public void onConfigurationChanged(Configuration conf){
  mSubtypeSwitcher.onConfigurationChanged(conf);
  if (mDisplayOrientation != conf.orientation) {
    mDisplayOrientation=conf.orientation;
    mHandler.startOrientationChanging();
    mConnection.beginBatchEdit(getCurrentInputConnection());
    commitTyped(LastComposedWord.NOT_A_SEPARATOR);
    mConnection.finishComposingText();
    mConnection.endBatchEdit();
    if (isShowingOptionDialog())     mOptionsDialog.dismiss();
  }
  super.onConfigurationChanged(conf);
}","@Override public void onConfigurationChanged(Configuration conf){
  mSubtypeSwitcher.onConfigurationChanged(conf);
  if (mDisplayOrientation != conf.orientation) {
    mDisplayOrientation=conf.orientation;
    mHandler.startOrientationChanging();
    mConnection.beginBatchEdit();
    commitTyped(LastComposedWord.NOT_A_SEPARATOR);
    mConnection.finishComposingText();
    mConnection.endBatchEdit();
    if (isShowingOptionDialog())     mOptionsDialog.dismiss();
  }
  super.onConfigurationChanged(conf);
}",0.9741626794258372
87907,"@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,final int x,final int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mCurrentSettings.isWeakSpaceStripper(firstChar)) && (!mCurrentSettings.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mCurrentSettings.isApplicationSpecifiedCompletionsOn() && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
    mConnection.beginBatchEdit(getCurrentInputConnection());
    mConnection.commitCompletion(completionInfo);
    mConnection.endBatchEdit();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
    }
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mLastComposedWord.deactivate();
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (!showingAddToDictionaryHint) {
    updateBigramPredictions();
  }
 else {
    if (mIsUserDictionaryAvailable) {
      mSuggestionsView.showAddToDictionaryHint(suggestion,mCurrentSettings.mHintToSaveText);
    }
 else {
      mHandler.postUpdateSuggestions();
    }
  }
}","@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,final int x,final int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mCurrentSettings.isWeakSpaceStripper(firstChar)) && (!mCurrentSettings.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mCurrentSettings.isApplicationSpecifiedCompletionsOn() && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
    mConnection.beginBatchEdit();
    mConnection.commitCompletion(completionInfo);
    mConnection.endBatchEdit();
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
    }
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mLastComposedWord.deactivate();
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (!showingAddToDictionaryHint) {
    updateBigramPredictions();
  }
 else {
    if (mIsUserDictionaryAvailable) {
      mSuggestionsView.showAddToDictionaryHint(suggestion,mCurrentSettings.mHintToSaveText);
    }
 else {
      mHandler.postUpdateSuggestions();
    }
  }
}",0.9951742627345844
87908,"private int getCursorPosition(){
  if (null == mIC)   return INVALID_CURSOR_POSITION;
  final ExtractedText extracted=mIC.getExtractedText(new ExtractedTextRequest(),0);
  if (extracted == null) {
    return INVALID_CURSOR_POSITION;
  }
  return extracted.startOffset + extracted.selectionStart;
}","private int getCursorPosition(){
  mIC=mParent.getCurrentInputConnection();
  if (null == mIC)   return INVALID_CURSOR_POSITION;
  final ExtractedText extracted=mIC.getExtractedText(new ExtractedTextRequest(),0);
  if (extracted == null) {
    return INVALID_CURSOR_POSITION;
  }
  return extracted.startOffset + extracted.selectionStart;
}",0.9324960753532182
87909,"public CharSequence getTextAfterCursor(final int i,final int j){
  if (null != mIC)   return mIC.getTextAfterCursor(i,j);
  return null;
}","public CharSequence getTextAfterCursor(final int i,final int j){
  mIC=mParent.getCurrentInputConnection();
  if (null != mIC)   return mIC.getTextAfterCursor(i,j);
  return null;
}",0.8652037617554859
87910,"public RichInputConnection(){
  mIC=null;
  mNestLevel=0;
}","public RichInputConnection(final InputMethodService parent){
  mParent=parent;
  mIC=null;
  mNestLevel=0;
}",0.7065868263473054
87911,"public CharSequence getTextBeforeCursor(final int i,final int j){
  if (null != mIC)   return mIC.getTextBeforeCursor(i,j);
  return null;
}","public CharSequence getTextBeforeCursor(final int i,final int j){
  mIC=mParent.getCurrentInputConnection();
  if (null != mIC)   return mIC.getTextBeforeCursor(i,j);
  return null;
}",0.8668730650154799
87912,"public void performEditorAction(final int actionId){
  if (null != mIC)   mIC.performEditorAction(actionId);
}","public void performEditorAction(final int actionId){
  mIC=mParent.getCurrentInputConnection();
  if (null != mIC)   mIC.performEditorAction(actionId);
}",0.8365019011406845
87913,"/** 
 * Returns the text surrounding the cursor.
 * @param sep a string of characters that split words.
 * @param additionalPrecedingWordsCount the number of words before the current word that shouldbe included in the returned range
 * @return a range containing the text surrounding the cursor
 */
public Range getWordRangeAtCursor(String sep,int additionalPrecedingWordsCount){
  if (mIC == null || sep == null) {
    return null;
  }
  CharSequence before=mIC.getTextBeforeCursor(1000,0);
  CharSequence after=mIC.getTextAfterCursor(1000,0);
  if (before == null || after == null) {
    return null;
  }
  int start=before.length();
  boolean isStoppingAtWhitespace=true;
  while (true) {
    while (start > 0) {
      final int codePoint=Character.codePointBefore(before,start);
      if (isStoppingAtWhitespace == isSeparator(codePoint,sep)) {
        break;
      }
      --start;
      if (Character.isSupplementaryCodePoint(codePoint)) {
        --start;
      }
    }
    if (isStoppingAtWhitespace && (--additionalPrecedingWordsCount < 0)) {
      break;
    }
    isStoppingAtWhitespace=!isStoppingAtWhitespace;
  }
  int end=-1;
  while (++end < after.length()) {
    final int codePoint=Character.codePointAt(after,end);
    if (isSeparator(codePoint,sep)) {
      break;
    }
    if (Character.isSupplementaryCodePoint(codePoint)) {
      ++end;
    }
  }
  int cursor=getCursorPosition();
  if (start >= 0 && cursor + end <= after.length() + before.length()) {
    String word=before.toString().substring(start,before.length()) + after.toString().substring(0,end);
    return new Range(before.length() - start,end,word);
  }
  return null;
}","/** 
 * Returns the text surrounding the cursor.
 * @param sep a string of characters that split words.
 * @param additionalPrecedingWordsCount the number of words before the current word that shouldbe included in the returned range
 * @return a range containing the text surrounding the cursor
 */
public Range getWordRangeAtCursor(String sep,int additionalPrecedingWordsCount){
  mIC=mParent.getCurrentInputConnection();
  if (mIC == null || sep == null) {
    return null;
  }
  CharSequence before=mIC.getTextBeforeCursor(1000,0);
  CharSequence after=mIC.getTextAfterCursor(1000,0);
  if (before == null || after == null) {
    return null;
  }
  int start=before.length();
  boolean isStoppingAtWhitespace=true;
  while (true) {
    while (start > 0) {
      final int codePoint=Character.codePointBefore(before,start);
      if (isStoppingAtWhitespace == isSeparator(codePoint,sep)) {
        break;
      }
      --start;
      if (Character.isSupplementaryCodePoint(codePoint)) {
        --start;
      }
    }
    if (isStoppingAtWhitespace && (--additionalPrecedingWordsCount < 0)) {
      break;
    }
    isStoppingAtWhitespace=!isStoppingAtWhitespace;
  }
  int end=-1;
  while (++end < after.length()) {
    final int codePoint=Character.codePointAt(after,end);
    if (isSeparator(codePoint,sep)) {
      break;
    }
    if (Character.isSupplementaryCodePoint(codePoint)) {
      ++end;
    }
  }
  int cursor=getCursorPosition();
  if (start >= 0 && cursor + end <= after.length() + before.length()) {
    String word=before.toString().substring(start,before.length()) + after.toString().substring(0,end);
    return new Range(before.length() - start,end,word);
  }
  return null;
}",0.987190944295502
87914,"public void beginBatchEdit(final InputConnection newInputConnection){
  if (++mNestLevel == 1) {
    mIC=newInputConnection;
    if (null != mIC)     mIC.beginBatchEdit();
  }
 else {
    if (DBG) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      Log.e(TAG,""String_Node_Str"" + mNestLevel);
    }
  }
}","public void beginBatchEdit(){
  if (++mNestLevel == 1) {
    mIC=mParent.getCurrentInputConnection();
    if (null != mIC)     mIC.beginBatchEdit();
  }
 else {
    if (DBG) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      Log.e(TAG,""String_Node_Str"" + mNestLevel);
    }
  }
}",0.8998410174880763
87915,"public int getCursorCapsMode(final int inputType){
  if (null == mIC)   return Constants.TextUtils.CAP_MODE_OFF;
  return mIC.getCursorCapsMode(inputType);
}","public int getCursorCapsMode(final int inputType){
  mIC=mParent.getCurrentInputConnection();
  if (null == mIC)   return Constants.TextUtils.CAP_MODE_OFF;
  return mIC.getCursorCapsMode(inputType);
}",0.8795518207282913
87916,"/** 
 * Test logic in getting the word range at the cursor.
 */
public void testGetWordRangeAtCursor(){
  ExtractedText et=new ExtractedText();
  final RichInputConnection ic=new RichInputConnection();
  InputConnection mockConnection;
  mockConnection=new MockConnection(""String_Node_Str"",""String_Node_Str"",et);
  et.startOffset=0;
  et.selectionStart=7;
  Range r;
  ic.beginBatchEdit(mockConnection);
  r=ic.getWordRangeAtCursor(""String_Node_Str"",0);
  assertEquals(""String_Node_Str"",r.mWord);
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  assertEquals(""String_Node_Str"",r.mWord);
  ic.endBatchEdit();
  mockConnection=new MockConnection(""String_Node_Str"",""String_Node_Str"",et);
  ic.beginBatchEdit(mockConnection);
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  mockConnection=new MockConnection(""String_Node_Str"",""String_Node_Str"",et);
  ic.beginBatchEdit(mockConnection);
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  mockConnection=new MockConnection(""String_Node_Str"",""String_Node_Str"",et);
  ic.beginBatchEdit(mockConnection);
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  mockConnection=new MockConnection(""String_Node_Str"",""String_Node_Str"",et);
  ic.beginBatchEdit(mockConnection);
  r=ic.getWordRangeAtCursor(""String_Node_Str"",2);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  final String supplementaryChar=""String_Node_Str"";
  mockConnection=new MockConnection(""String_Node_Str"" + supplementaryChar + ""String_Node_Str"",""String_Node_Str"",et);
  ic.beginBatchEdit(mockConnection);
  r=ic.getWordRangeAtCursor(supplementaryChar,0);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
}","/** 
 * Test logic in getting the word range at the cursor.
 */
public void testGetWordRangeAtCursor(){
  ExtractedText et=new ExtractedText();
  final MockInputMethodService mockInputMethodService=new MockInputMethodService();
  final RichInputConnection ic=new RichInputConnection(mockInputMethodService);
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  et.startOffset=0;
  et.selectionStart=7;
  Range r;
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(""String_Node_Str"",0);
  assertEquals(""String_Node_Str"",r.mWord);
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  assertEquals(""String_Node_Str"",r.mWord);
  ic.endBatchEdit();
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(""String_Node_Str"",1);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(""String_Node_Str"",2);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
  final String supplementaryChar=""String_Node_Str"";
  mockInputMethodService.setInputConnection(new MockConnection(""String_Node_Str"" + supplementaryChar + ""String_Node_Str"",""String_Node_Str"",et));
  ic.beginBatchEdit();
  r=ic.getWordRangeAtCursor(supplementaryChar,0);
  ic.endBatchEdit();
  assertEquals(""String_Node_Str"",r.mWord);
}",0.8413111342351717
87917,"public UserBinaryDictionary(final Context context,final String locale,final boolean alsoUseMoreRestrictiveLocales){
  super(context,getFilenameWithLocale(NAME,locale),Dictionary.TYPE_USER);
  if (null == locale)   throw new NullPointerException();
  mLocale=locale;
  mAlsoUseMoreRestrictiveLocales=alsoUseMoreRestrictiveLocales;
  ContentResolver cres=context.getContentResolver();
  mObserver=new ContentObserver(null){
    @Override public void onChange(    boolean self){
      setRequiresReload(true);
    }
  }
;
  cres.registerContentObserver(Words.CONTENT_URI,true,mObserver);
  loadDictionary();
}","public UserBinaryDictionary(final Context context,final String locale,final boolean alsoUseMoreRestrictiveLocales){
  super(context,getFilenameWithLocale(NAME,locale),Dictionary.TYPE_USER);
  if (null == locale)   throw new NullPointerException();
  if (SubtypeLocale.NO_LANGUAGE.equals(locale)) {
    mLocale=USER_DICTIONARY_ALL_LANGUAGES;
  }
 else {
    mLocale=locale;
  }
  mAlsoUseMoreRestrictiveLocales=alsoUseMoreRestrictiveLocales;
  ContentResolver cres=context.getContentResolver();
  mObserver=new ContentObserver(null){
    @Override public void onChange(    boolean self){
      setRequiresReload(true);
    }
  }
;
  cres.registerContentObserver(Words.CONTENT_URI,true,mObserver);
  loadDictionary();
}",0.9055177626606198
87918,"public SuggestedWords getSuggestedWords(final WordComposer wordComposer,CharSequence prevWordForBigram,final ProximityInfo proximityInfo,final boolean isCorrectionEnabled,final boolean isPrediction){
  LatinImeLogger.onStartSuggestion(prevWordForBigram);
  final boolean isFirstCharCapitalized=!isPrediction && wordComposer.isFirstCharCapitalized();
  final boolean isAllUpperCase=!isPrediction && wordComposer.isAllUpperCase();
  final int trailingSingleQuotesCount=wordComposer.trailingSingleQuotesCount();
  final BoundedTreeSet suggestionsSet=new BoundedTreeSet(sSuggestedWordInfoComparator,MAX_SUGGESTIONS);
  final String typedWord=wordComposer.getTypedWord();
  final String consideredWord=trailingSingleQuotesCount > 0 ? typedWord.substring(0,typedWord.length() - trailingSingleQuotesCount) : typedWord;
  LatinImeLogger.onAddSuggestedWord(typedWord,Dictionary.TYPE_USER_TYPED);
  if (wordComposer.size() <= 1 && isCorrectionEnabled) {
    if (!TextUtils.isEmpty(prevWordForBigram)) {
      final CharSequence lowerPrevWord;
      if (StringUtils.hasUpperCase(prevWordForBigram)) {
        lowerPrevWord=prevWordForBigram.toString().toLowerCase();
      }
 else {
        lowerPrevWord=null;
      }
      for (      final String key : mDictionaries.keySet()) {
        final Dictionary dictionary=mDictionaries.get(key);
        suggestionsSet.addAll(dictionary.getBigrams(wordComposer,prevWordForBigram));
        if (null != lowerPrevWord) {
          suggestionsSet.addAll(dictionary.getBigrams(wordComposer,lowerPrevWord));
        }
      }
    }
  }
 else   if (wordComposer.size() > 1) {
    final WordComposer wordComposerForLookup;
    if (trailingSingleQuotesCount > 0) {
      wordComposerForLookup=new WordComposer(wordComposer);
      for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
        wordComposerForLookup.deleteLast();
      }
    }
 else {
      wordComposerForLookup=wordComposer;
    }
    for (    final String key : mDictionaries.keySet()) {
      if (key.equals(Dictionary.TYPE_USER_HISTORY) || key.equals(Dictionary.TYPE_WHITELIST))       continue;
      final Dictionary dictionary=mDictionaries.get(key);
      suggestionsSet.addAll(dictionary.getWords(wordComposerForLookup,prevWordForBigram,proximityInfo));
    }
  }
  final boolean allowsToBeAutoCorrected=AutoCorrection.isWhitelistedOrNotAWord(mDictionaries,consideredWord,wordComposer.isFirstCharCapitalized()) && hasMainDictionary();
  final CharSequence whitelistedWord=mWhiteListDictionary.getWhitelistedWord(consideredWord);
  final boolean hasAutoCorrection;
  if (!isCorrectionEnabled || wordComposer.isMostlyCaps() || wordComposer.isResumed()) {
    hasAutoCorrection=false;
  }
 else   if (null != whitelistedWord) {
    hasAutoCorrection=true;
  }
 else   if (!AutoCorrection.isWhitelistedOrNotAWord(mDictionaries,consideredWord,wordComposer.isFirstCharCapitalized())) {
    hasAutoCorrection=true;
  }
 else   if (suggestionsSet.isEmpty()) {
    hasAutoCorrection=false;
  }
 else   if (AutoCorrection.suggestionExceedsAutoCorrectionThreshold(suggestionsSet.first(),consideredWord,mAutoCorrectionThreshold)) {
    hasAutoCorrection=!shouldBlockAutoCorrectionBySafetyNet(typedWord,suggestionsSet.first().mWord);
  }
 else {
    hasAutoCorrection=false;
  }
  if (whitelistedWord != null) {
    suggestionsSet.add(new SuggestedWordInfo(whitelistedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_WHITELIST,Dictionary.TYPE_WHITELIST));
  }
  final ArrayList<SuggestedWordInfo> suggestionsContainer=new ArrayList<SuggestedWordInfo>(suggestionsSet);
  final int suggestionsCount=suggestionsContainer.size();
  if (isFirstCharCapitalized || isAllUpperCase || 0 != trailingSingleQuotesCount) {
    for (int i=0; i < suggestionsCount; ++i) {
      final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
      final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,mLocale,isAllUpperCase,isFirstCharCapitalized,trailingSingleQuotesCount);
      suggestionsContainer.set(i,transformedWordInfo);
    }
  }
  for (int i=0; i < suggestionsCount; ++i) {
    final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
    LatinImeLogger.onAddSuggestedWord(wordInfo.mWord.toString(),wordInfo.mSourceDict);
  }
  if (!TextUtils.isEmpty(typedWord)) {
    suggestionsContainer.add(0,new SuggestedWordInfo(typedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_TYPED,Dictionary.TYPE_USER_TYPED));
  }
  SuggestedWordInfo.removeDups(suggestionsContainer);
  final ArrayList<SuggestedWordInfo> suggestionsList;
  if (DBG && !suggestionsContainer.isEmpty()) {
    suggestionsList=getSuggestionsInfoListWithDebugInfo(typedWord,suggestionsContainer);
  }
 else {
    suggestionsList=suggestionsContainer;
  }
  return new SuggestedWords(suggestionsList,!isPrediction && !allowsToBeAutoCorrected,!isPrediction && hasAutoCorrection && allowsToBeAutoCorrected,false,false,isPrediction);
}","public SuggestedWords getSuggestedWords(final WordComposer wordComposer,CharSequence prevWordForBigram,final ProximityInfo proximityInfo,final boolean isCorrectionEnabled,final boolean isPrediction){
  LatinImeLogger.onStartSuggestion(prevWordForBigram);
  final boolean isFirstCharCapitalized=!isPrediction && wordComposer.isFirstCharCapitalized();
  final boolean isAllUpperCase=!isPrediction && wordComposer.isAllUpperCase();
  final int trailingSingleQuotesCount=wordComposer.trailingSingleQuotesCount();
  final BoundedTreeSet suggestionsSet=new BoundedTreeSet(sSuggestedWordInfoComparator,MAX_SUGGESTIONS);
  final String typedWord=wordComposer.getTypedWord();
  final String consideredWord=trailingSingleQuotesCount > 0 ? typedWord.substring(0,typedWord.length() - trailingSingleQuotesCount) : typedWord;
  LatinImeLogger.onAddSuggestedWord(typedWord,Dictionary.TYPE_USER_TYPED);
  if (wordComposer.size() <= 1 && isCorrectionEnabled) {
    if (!TextUtils.isEmpty(prevWordForBigram)) {
      final CharSequence lowerPrevWord;
      if (StringUtils.hasUpperCase(prevWordForBigram)) {
        lowerPrevWord=prevWordForBigram.toString().toLowerCase();
      }
 else {
        lowerPrevWord=null;
      }
      for (      final String key : mDictionaries.keySet()) {
        final Dictionary dictionary=mDictionaries.get(key);
        suggestionsSet.addAll(dictionary.getBigrams(wordComposer,prevWordForBigram));
        if (null != lowerPrevWord) {
          suggestionsSet.addAll(dictionary.getBigrams(wordComposer,lowerPrevWord));
        }
      }
    }
  }
 else   if (wordComposer.size() > 1) {
    final WordComposer wordComposerForLookup;
    if (trailingSingleQuotesCount > 0) {
      wordComposerForLookup=new WordComposer(wordComposer);
      for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
        wordComposerForLookup.deleteLast();
      }
    }
 else {
      wordComposerForLookup=wordComposer;
    }
    for (    final String key : mDictionaries.keySet()) {
      if (key.equals(Dictionary.TYPE_USER_HISTORY) || key.equals(Dictionary.TYPE_WHITELIST))       continue;
      final Dictionary dictionary=mDictionaries.get(key);
      suggestionsSet.addAll(dictionary.getWords(wordComposerForLookup,prevWordForBigram,proximityInfo));
    }
  }
  final boolean allowsToBeAutoCorrected=AutoCorrection.isWhitelistedOrNotAWord(mDictionaries,consideredWord,wordComposer.isFirstCharCapitalized());
  final CharSequence whitelistedWord=mWhiteListDictionary.getWhitelistedWord(consideredWord);
  final boolean hasAutoCorrection;
  if (!isCorrectionEnabled || wordComposer.isMostlyCaps() || wordComposer.isResumed()|| !hasMainDictionary()) {
    hasAutoCorrection=false;
  }
 else   if (null != whitelistedWord) {
    hasAutoCorrection=true;
  }
 else   if (!allowsToBeAutoCorrected) {
    hasAutoCorrection=true;
  }
 else   if (suggestionsSet.isEmpty()) {
    hasAutoCorrection=false;
  }
 else   if (AutoCorrection.suggestionExceedsAutoCorrectionThreshold(suggestionsSet.first(),consideredWord,mAutoCorrectionThreshold)) {
    hasAutoCorrection=!shouldBlockAutoCorrectionBySafetyNet(typedWord,suggestionsSet.first().mWord);
  }
 else {
    hasAutoCorrection=false;
  }
  if (whitelistedWord != null) {
    suggestionsSet.add(new SuggestedWordInfo(whitelistedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_WHITELIST,Dictionary.TYPE_WHITELIST));
  }
  final ArrayList<SuggestedWordInfo> suggestionsContainer=new ArrayList<SuggestedWordInfo>(suggestionsSet);
  final int suggestionsCount=suggestionsContainer.size();
  if (isFirstCharCapitalized || isAllUpperCase || 0 != trailingSingleQuotesCount) {
    for (int i=0; i < suggestionsCount; ++i) {
      final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
      final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,mLocale,isAllUpperCase,isFirstCharCapitalized,trailingSingleQuotesCount);
      suggestionsContainer.set(i,transformedWordInfo);
    }
  }
  for (int i=0; i < suggestionsCount; ++i) {
    final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
    LatinImeLogger.onAddSuggestedWord(wordInfo.mWord.toString(),wordInfo.mSourceDict);
  }
  if (!TextUtils.isEmpty(typedWord)) {
    suggestionsContainer.add(0,new SuggestedWordInfo(typedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_TYPED,Dictionary.TYPE_USER_TYPED));
  }
  SuggestedWordInfo.removeDups(suggestionsContainer);
  final ArrayList<SuggestedWordInfo> suggestionsList;
  if (DBG && !suggestionsContainer.isEmpty()) {
    suggestionsList=getSuggestionsInfoListWithDebugInfo(typedWord,suggestionsContainer);
  }
 else {
    suggestionsList=suggestionsContainer;
  }
  return new SuggestedWords(suggestionsList,!isPrediction && !allowsToBeAutoCorrected,!isPrediction && hasAutoCorrection && allowsToBeAutoCorrected,false,false,isPrediction);
}",0.9843414184832668
87919,"public SuggestedWords getSuggestedWords(final WordComposer wordComposer,CharSequence prevWordForBigram,final ProximityInfo proximityInfo,final boolean isCorrectionEnabled,final boolean isPrediction){
  LatinImeLogger.onStartSuggestion(prevWordForBigram);
  final boolean isFirstCharCapitalized=!isPrediction && wordComposer.isFirstCharCapitalized();
  final boolean isAllUpperCase=!isPrediction && wordComposer.isAllUpperCase();
  final int trailingSingleQuotesCount=wordComposer.trailingSingleQuotesCount();
  final BoundedTreeSet suggestionsSet=new BoundedTreeSet(sSuggestedWordInfoComparator,MAX_SUGGESTIONS);
  final String typedWord=wordComposer.getTypedWord();
  final String consideredWord=trailingSingleQuotesCount > 0 ? typedWord.substring(0,typedWord.length() - trailingSingleQuotesCount) : typedWord;
  LatinImeLogger.onAddSuggestedWord(typedWord,Dictionary.TYPE_USER_TYPED);
  if (wordComposer.size() <= 1 && isCorrectionEnabled) {
    if (!TextUtils.isEmpty(prevWordForBigram)) {
      final CharSequence lowerPrevWord;
      if (StringUtils.hasUpperCase(prevWordForBigram)) {
        lowerPrevWord=prevWordForBigram.toString().toLowerCase();
      }
 else {
        lowerPrevWord=null;
      }
      for (      final String key : mDictionaries.keySet()) {
        final Dictionary dictionary=mDictionaries.get(key);
        suggestionsSet.addAll(dictionary.getBigrams(wordComposer,prevWordForBigram));
        if (null != lowerPrevWord) {
          suggestionsSet.addAll(dictionary.getBigrams(wordComposer,lowerPrevWord));
        }
      }
    }
  }
 else   if (wordComposer.size() > 1) {
    final WordComposer wordComposerForLookup;
    if (trailingSingleQuotesCount > 0) {
      wordComposerForLookup=new WordComposer(wordComposer);
      for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
        wordComposerForLookup.deleteLast();
      }
    }
 else {
      wordComposerForLookup=wordComposer;
    }
    for (    final String key : mDictionaries.keySet()) {
      if (key.equals(Dictionary.TYPE_USER_HISTORY) || key.equals(Dictionary.TYPE_WHITELIST))       continue;
      final Dictionary dictionary=mDictionaries.get(key);
      suggestionsSet.addAll(dictionary.getWords(wordComposerForLookup,prevWordForBigram,proximityInfo));
    }
  }
  final boolean allowsToBeAutoCorrected=AutoCorrection.isWhitelistedOrNotAWord(mDictionaries,consideredWord,wordComposer.isFirstCharCapitalized()) && hasMainDictionary();
  final CharSequence whitelistedWord=mWhiteListDictionary.getWhitelistedWord(consideredWord);
  final boolean hasAutoCorrection;
  if (!isCorrectionEnabled || wordComposer.isMostlyCaps() || wordComposer.isResumed()) {
    hasAutoCorrection=false;
  }
 else   if (null != whitelistedWord) {
    hasAutoCorrection=true;
  }
 else   if (!AutoCorrection.isWhitelistedOrNotAWord(mDictionaries,consideredWord,wordComposer.isFirstCharCapitalized())) {
    hasAutoCorrection=true;
  }
 else   if (suggestionsSet.isEmpty()) {
    hasAutoCorrection=false;
  }
 else   if (AutoCorrection.suggestionExceedsAutoCorrectionThreshold(suggestionsSet.first(),consideredWord,mAutoCorrectionThreshold)) {
    hasAutoCorrection=!shouldBlockAutoCorrectionBySafetyNet(typedWord,suggestionsSet.first().mWord);
  }
 else {
    hasAutoCorrection=false;
  }
  if (whitelistedWord != null) {
    suggestionsSet.add(new SuggestedWordInfo(whitelistedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_WHITELIST,Dictionary.TYPE_WHITELIST));
  }
  final ArrayList<SuggestedWordInfo> suggestionsContainer=new ArrayList<SuggestedWordInfo>(suggestionsSet);
  final int suggestionsCount=suggestionsContainer.size();
  if (isFirstCharCapitalized || isAllUpperCase || 0 != trailingSingleQuotesCount) {
    for (int i=0; i < suggestionsCount; ++i) {
      final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
      final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,mLocale,isAllUpperCase,isFirstCharCapitalized,trailingSingleQuotesCount);
      suggestionsContainer.set(i,transformedWordInfo);
    }
  }
  for (int i=0; i < suggestionsCount; ++i) {
    final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
    LatinImeLogger.onAddSuggestedWord(wordInfo.mWord.toString(),wordInfo.mSourceDict);
  }
  if (!TextUtils.isEmpty(typedWord)) {
    suggestionsContainer.add(0,new SuggestedWordInfo(typedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_TYPED,Dictionary.TYPE_USER_TYPED));
  }
  SuggestedWordInfo.removeDups(suggestionsContainer);
  final ArrayList<SuggestedWordInfo> suggestionsList;
  if (DBG && !suggestionsContainer.isEmpty()) {
    suggestionsList=getSuggestionsInfoListWithDebugInfo(typedWord,suggestionsContainer);
  }
 else {
    suggestionsList=suggestionsContainer;
  }
  return new SuggestedWords(suggestionsList,!isPrediction && !allowsToBeAutoCorrected,!isPrediction && hasAutoCorrection && allowsToBeAutoCorrected,false,false,isPrediction);
}","public SuggestedWords getSuggestedWords(final WordComposer wordComposer,CharSequence prevWordForBigram,final ProximityInfo proximityInfo,final boolean isCorrectionEnabled,final boolean isPrediction){
  LatinImeLogger.onStartSuggestion(prevWordForBigram);
  final boolean isFirstCharCapitalized=!isPrediction && wordComposer.isFirstCharCapitalized();
  final boolean isAllUpperCase=!isPrediction && wordComposer.isAllUpperCase();
  final int trailingSingleQuotesCount=wordComposer.trailingSingleQuotesCount();
  final BoundedTreeSet suggestionsSet=new BoundedTreeSet(sSuggestedWordInfoComparator,MAX_SUGGESTIONS);
  final String typedWord=wordComposer.getTypedWord();
  final String consideredWord=trailingSingleQuotesCount > 0 ? typedWord.substring(0,typedWord.length() - trailingSingleQuotesCount) : typedWord;
  LatinImeLogger.onAddSuggestedWord(typedWord,Dictionary.TYPE_USER_TYPED);
  if (wordComposer.size() <= 1 && isCorrectionEnabled) {
    if (!TextUtils.isEmpty(prevWordForBigram)) {
      final CharSequence lowerPrevWord;
      if (StringUtils.hasUpperCase(prevWordForBigram)) {
        lowerPrevWord=prevWordForBigram.toString().toLowerCase();
      }
 else {
        lowerPrevWord=null;
      }
      for (      final String key : mDictionaries.keySet()) {
        final Dictionary dictionary=mDictionaries.get(key);
        suggestionsSet.addAll(dictionary.getBigrams(wordComposer,prevWordForBigram));
        if (null != lowerPrevWord) {
          suggestionsSet.addAll(dictionary.getBigrams(wordComposer,lowerPrevWord));
        }
      }
    }
  }
 else   if (wordComposer.size() > 1) {
    final WordComposer wordComposerForLookup;
    if (trailingSingleQuotesCount > 0) {
      wordComposerForLookup=new WordComposer(wordComposer);
      for (int i=trailingSingleQuotesCount - 1; i >= 0; --i) {
        wordComposerForLookup.deleteLast();
      }
    }
 else {
      wordComposerForLookup=wordComposer;
    }
    for (    final String key : mDictionaries.keySet()) {
      if (key.equals(Dictionary.TYPE_USER_HISTORY) || key.equals(Dictionary.TYPE_WHITELIST))       continue;
      final Dictionary dictionary=mDictionaries.get(key);
      suggestionsSet.addAll(dictionary.getWords(wordComposerForLookup,prevWordForBigram,proximityInfo));
    }
  }
  final boolean allowsToBeAutoCorrected=AutoCorrection.isWhitelistedOrNotAWord(mDictionaries,consideredWord,wordComposer.isFirstCharCapitalized());
  final CharSequence whitelistedWord=mWhiteListDictionary.getWhitelistedWord(consideredWord);
  final boolean hasAutoCorrection;
  if (!isCorrectionEnabled || wordComposer.isMostlyCaps() || wordComposer.isResumed()|| !hasMainDictionary()) {
    hasAutoCorrection=false;
  }
 else   if (null != whitelistedWord) {
    hasAutoCorrection=true;
  }
 else   if (!allowsToBeAutoCorrected) {
    hasAutoCorrection=true;
  }
 else   if (suggestionsSet.isEmpty()) {
    hasAutoCorrection=false;
  }
 else   if (AutoCorrection.suggestionExceedsAutoCorrectionThreshold(suggestionsSet.first(),consideredWord,mAutoCorrectionThreshold)) {
    hasAutoCorrection=!shouldBlockAutoCorrectionBySafetyNet(typedWord,suggestionsSet.first().mWord);
  }
 else {
    hasAutoCorrection=false;
  }
  if (whitelistedWord != null) {
    suggestionsSet.add(new SuggestedWordInfo(whitelistedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_WHITELIST,Dictionary.TYPE_WHITELIST));
  }
  final ArrayList<SuggestedWordInfo> suggestionsContainer=new ArrayList<SuggestedWordInfo>(suggestionsSet);
  final int suggestionsCount=suggestionsContainer.size();
  if (isFirstCharCapitalized || isAllUpperCase || 0 != trailingSingleQuotesCount) {
    for (int i=0; i < suggestionsCount; ++i) {
      final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
      final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,mLocale,isAllUpperCase,isFirstCharCapitalized,trailingSingleQuotesCount);
      suggestionsContainer.set(i,transformedWordInfo);
    }
  }
  for (int i=0; i < suggestionsCount; ++i) {
    final SuggestedWordInfo wordInfo=suggestionsContainer.get(i);
    LatinImeLogger.onAddSuggestedWord(wordInfo.mWord.toString(),wordInfo.mSourceDict);
  }
  if (!TextUtils.isEmpty(typedWord)) {
    suggestionsContainer.add(0,new SuggestedWordInfo(typedWord,SuggestedWordInfo.MAX_SCORE,SuggestedWordInfo.KIND_TYPED,Dictionary.TYPE_USER_TYPED));
  }
  SuggestedWordInfo.removeDups(suggestionsContainer);
  final ArrayList<SuggestedWordInfo> suggestionsList;
  if (DBG && !suggestionsContainer.isEmpty()) {
    suggestionsList=getSuggestionsInfoListWithDebugInfo(typedWord,suggestionsContainer);
  }
 else {
    suggestionsList=suggestionsContainer;
  }
  return new SuggestedWords(suggestionsList,!isPrediction && !allowsToBeAutoCorrected,!isPrediction && hasAutoCorrection && allowsToBeAutoCorrected,false,false,isPrediction);
}",0.9843414184832668
87920,"public UserBinaryDictionary(final Context context,final String locale,final boolean alsoUseMoreRestrictiveLocales){
  super(context,getFilenameWithLocale(NAME,locale),Dictionary.TYPE_USER);
  if (null == locale)   throw new NullPointerException();
  mLocale=locale;
  mAlsoUseMoreRestrictiveLocales=alsoUseMoreRestrictiveLocales;
  ContentResolver cres=context.getContentResolver();
  mObserver=new ContentObserver(null){
    @Override public void onChange(    boolean self){
      setRequiresReload(true);
    }
  }
;
  cres.registerContentObserver(Words.CONTENT_URI,true,mObserver);
  loadDictionary();
}","public UserBinaryDictionary(final Context context,final String locale,final boolean alsoUseMoreRestrictiveLocales){
  super(context,getFilenameWithLocale(NAME,locale),Dictionary.TYPE_USER);
  if (null == locale)   throw new NullPointerException();
  if (SubtypeLocale.NO_LANGUAGE.equals(locale)) {
    mLocale=USER_DICTIONARY_ALL_LANGUAGES;
  }
 else {
    mLocale=locale;
  }
  mAlsoUseMoreRestrictiveLocales=alsoUseMoreRestrictiveLocales;
  ContentResolver cres=context.getContentResolver();
  mObserver=new ContentObserver(null){
    @Override public void onChange(    boolean self){
      setRequiresReload(true);
    }
  }
;
  cres.registerContentObserver(Words.CONTENT_URI,true,mObserver);
  loadDictionary();
}",0.9055177626606198
87921,"public void updateSuggestions(){
  mHandler.cancelUpdateSuggestions();
  mHandler.cancelUpdateBigramPredictions();
  if ((mSuggest == null || !mCurrentSettings.isSuggestionsRequested(mDisplayOrientation))) {
    if (mWordComposer.isComposingWord()) {
      Log.w(TAG,""String_Node_Str"");
      mWordComposer.setAutoCorrection(mWordComposer.getTypedWord());
    }
    return;
  }
  if (!mWordComposer.isComposingWord()) {
    setPunctuationSuggestions();
    return;
  }
  final CharSequence prevWord=mConnection.getPreviousWord(mCurrentSettings.mWordSeparators);
  final CharSequence typedWord=mWordComposer.getTypedWord();
  final SuggestedWords suggestedWords=mSuggest.getSuggestedWords(mWordComposer,prevWord,mKeyboardSwitcher.getKeyboard().getProximityInfo(),mCurrentSettings.mCorrectionEnabled,false);
  if (suggestedWords.size() > 1 || typedWord.length() == 1 || !suggestedWords.mAllowsToBeAutoCorrected || mSuggestionsView.isShowingAddToDictionaryHint()) {
    showSuggestions(suggestedWords,typedWord);
  }
 else {
    SuggestedWords previousSuggestions=mSuggestionsView.getSuggestions();
    if (previousSuggestions == mCurrentSettings.mSuggestPuncList) {
      previousSuggestions=SuggestedWords.EMPTY;
    }
    final ArrayList<SuggestedWords.SuggestedWordInfo> typedWordAndPreviousSuggestions=SuggestedWords.getTypedWordAndPreviousSuggestions(typedWord,previousSuggestions);
    final SuggestedWords obsoleteSuggestedWords=new SuggestedWords(typedWordAndPreviousSuggestions,false,false,false,false,true,false);
    showSuggestions(obsoleteSuggestedWords,typedWord);
  }
}","public void updateSuggestions(){
  mHandler.cancelUpdateSuggestions();
  mHandler.cancelUpdateBigramPredictions();
  if ((mSuggest == null || !mCurrentSettings.isSuggestionsRequested(mDisplayOrientation))) {
    if (mWordComposer.isComposingWord()) {
      Log.w(TAG,""String_Node_Str"");
      mWordComposer.setAutoCorrection(mWordComposer.getTypedWord());
    }
    return;
  }
  if (!mWordComposer.isComposingWord()) {
    setPunctuationSuggestions();
    return;
  }
  final CharSequence prevWord=mConnection.getPreviousWord(mCurrentSettings.mWordSeparators);
  final CharSequence typedWord=mWordComposer.getTypedWord();
  final SuggestedWords suggestedWords=mSuggest.getSuggestedWords(mWordComposer,prevWord,mKeyboardSwitcher.getKeyboard().getProximityInfo(),mCurrentSettings.mCorrectionEnabled,false);
  if (suggestedWords.size() > 1 || typedWord.length() == 1 || !suggestedWords.mTypedWordValid || mSuggestionsView.isShowingAddToDictionaryHint()) {
    showSuggestions(suggestedWords,typedWord);
  }
 else {
    SuggestedWords previousSuggestions=mSuggestionsView.getSuggestions();
    if (previousSuggestions == mCurrentSettings.mSuggestPuncList) {
      previousSuggestions=SuggestedWords.EMPTY;
    }
    final ArrayList<SuggestedWords.SuggestedWordInfo> typedWordAndPreviousSuggestions=SuggestedWords.getTypedWordAndPreviousSuggestions(typedWord,previousSuggestions);
    final SuggestedWords obsoleteSuggestedWords=new SuggestedWords(typedWordAndPreviousSuggestions,false,false,false,false,true,false);
    showSuggestions(obsoleteSuggestedWords,typedWord);
  }
}",0.989540412044374
87922,"private static boolean shouldAutoCorrectToSelf(final ConcurrentHashMap<String,Dictionary> dictionaries,final WordComposer wordComposer,final SuggestedWordInfo suggestion,final CharSequence consideredWord){
  if (TextUtils.isEmpty(consideredWord))   return false;
  return wordComposer.size() > 1 && null != suggestion && !allowsToBeAutoCorrected(dictionaries,consideredWord,false);
}","private static boolean shouldAutoCorrectToSelf(final ConcurrentHashMap<String,Dictionary> dictionaries,final WordComposer wordComposer,final CharSequence consideredWord){
  if (TextUtils.isEmpty(consideredWord))   return false;
  return wordComposer.size() > 1 && !allowsToBeAutoCorrected(dictionaries,consideredWord,false);
}",0.919605077574048
87923,"public static CharSequence computeAutoCorrectionWord(final ConcurrentHashMap<String,Dictionary> dictionaries,final WordComposer wordComposer,SuggestedWordInfo suggestion,final CharSequence consideredWord,final float autoCorrectionThreshold,final CharSequence whitelistedWord){
  if (hasAutoCorrectionForWhitelistedWord(whitelistedWord)) {
    return whitelistedWord;
  }
 else   if (shouldAutoCorrectToSelf(dictionaries,wordComposer,suggestion,consideredWord)) {
    return consideredWord;
  }
 else   if (hasAutoCorrectionForBinaryDictionary(wordComposer,suggestion,consideredWord,autoCorrectionThreshold)) {
    return suggestion.mWord;
  }
  return null;
}","public static CharSequence computeAutoCorrectionWord(final ConcurrentHashMap<String,Dictionary> dictionaries,final WordComposer wordComposer,SuggestedWordInfo suggestion,final CharSequence consideredWord,final float autoCorrectionThreshold,final CharSequence whitelistedWord){
  if (hasAutoCorrectionForWhitelistedWord(whitelistedWord)) {
    return whitelistedWord;
  }
 else   if (shouldAutoCorrectToSelf(dictionaries,wordComposer,consideredWord)) {
    return consideredWord;
  }
 else   if (hasAutoCorrectionForBinaryDictionary(wordComposer,suggestion,consideredWord,autoCorrectionThreshold)) {
    return suggestion.mWord;
  }
  return null;
}",0.991583779648049
87924,"public boolean addWord(final SuggestedWordInfo wordInfo,final int dicTypeId,final int dataType,final ArrayList<SuggestedWordInfo> suggestions,final String consideredWord){
  int dataTypeForLog=dataType;
  final int prefMaxSuggestions=MAX_SUGGESTIONS;
  final CharSequence word=wordInfo.mWord;
  final int score=wordInfo.mScore;
  int pos=0;
  if (StringUtils.equalsIgnoreCase(consideredWord,word)) {
    if (suggestions.size() > 0) {
      final SuggestedWordInfo currentHighestWord=suggestions.get(0);
      if (StringUtils.equalsIgnoreCase(currentHighestWord.mWord,word) && score <= currentHighestWord.mScore) {
        pos=1;
      }
    }
  }
 else {
    if (suggestions.size() >= prefMaxSuggestions && suggestions.get(prefMaxSuggestions - 1).mScore >= score)     return true;
    final int length=wordInfo.mCodePointCount;
    while (pos < suggestions.size()) {
      final int curScore=suggestions.get(pos).mScore;
      if (curScore < score || (curScore == score && length < suggestions.get(pos).mCodePointCount)) {
        break;
      }
      pos++;
    }
  }
  if (pos >= prefMaxSuggestions) {
    return true;
  }
  final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,mLocale,mIsAllUpperCase,mIsFirstCharCapitalized,mTrailingSingleQuotesCount);
  suggestions.add(pos,transformedWordInfo);
  if (suggestions.size() > prefMaxSuggestions) {
    suggestions.remove(prefMaxSuggestions);
  }
 else {
    LatinImeLogger.onAddSuggestedWord(transformedWordInfo.mWord.toString(),dicTypeId,dataTypeForLog);
  }
  return true;
}","public boolean addWord(final SuggestedWordInfo wordInfo,final int dicTypeId,final int dataType,final ArrayList<SuggestedWordInfo> suggestions,final String consideredWord){
  int dataTypeForLog=dataType;
  final int prefMaxSuggestions=MAX_SUGGESTIONS;
  final CharSequence word=wordInfo.mWord;
  final int score=wordInfo.mScore;
  int pos=0;
  if (StringUtils.equalsIgnoreCase(consideredWord,word)) {
    if (suggestions.size() > 0) {
      final SuggestedWordInfo currentHighestWord=suggestions.get(0);
      if (StringUtils.equalsIgnoreCase(currentHighestWord.mWord,word) && score <= currentHighestWord.mScore) {
        pos=1;
      }
    }
  }
 else {
    if (suggestions.size() >= prefMaxSuggestions && suggestions.get(prefMaxSuggestions - 1).mScore >= score)     return true;
    final int length=wordInfo.mCodePointCount;
    while (pos < suggestions.size()) {
      final int curScore=suggestions.get(pos).mScore;
      if (curScore < score || (curScore == score && length < suggestions.get(pos).mCodePointCount)) {
        break;
      }
      pos++;
    }
  }
  if (pos >= prefMaxSuggestions) {
    return true;
  }
  final SuggestedWordInfo transformedWordInfo=getTransformedSuggestedWordInfo(wordInfo,mLocale,mIsAllUpperCase,mIsFirstCharCapitalized,mTrailingSingleQuotesCount);
  suggestions.add(pos,transformedWordInfo);
  if (suggestions.size() > prefMaxSuggestions) {
    suggestions.remove(prefMaxSuggestions);
  }
  LatinImeLogger.onAddSuggestedWord(transformedWordInfo.mWord.toString(),dicTypeId,dataTypeForLog);
  return true;
}",0.9871216999356084
87925,"public CharSequence getWordBeforeCursorIfAtEndOfWord(final SettingsValues settings){
  final CharSequence textBeforeCursor=getTextBeforeCursor(1,0);
  if (TextUtils.isEmpty(textBeforeCursor) || settings.isWordSeparator(textBeforeCursor.charAt(0)))   return null;
  final CharSequence textAfterCursor=getTextAfterCursor(1,0);
  if (!TextUtils.isEmpty(textAfterCursor) && !settings.isWordSeparator(textAfterCursor.charAt(0)))   return null;
  CharSequence word=getWordAtCursor(settings.mWordSeparators);
  while (!TextUtils.isEmpty(word) && Keyboard.CODE_SINGLE_QUOTE == word.charAt(0)) {
    word=word.subSequence(1,word.length());
  }
  if (TextUtils.isEmpty(word))   return null;
  final char firstChar=word.charAt(0);
  if (word.length() == 1 && !Character.isLetter(firstChar))   return null;
  if (!(Character.isLetter(firstChar) || settings.isSymbolExcludedFromWordSeparators(firstChar))) {
    return null;
  }
  return word;
}","public CharSequence getWordBeforeCursorIfAtEndOfWord(final SettingsValues settings){
  final CharSequence textAfterCursor=getTextAfterCursor(1,0);
  if (!TextUtils.isEmpty(textAfterCursor) && !settings.isWordSeparator(textAfterCursor.charAt(0)))   return null;
  CharSequence word=getWordAtCursor(settings.mWordSeparators);
  while (!TextUtils.isEmpty(word) && Keyboard.CODE_SINGLE_QUOTE == word.charAt(0)) {
    word=word.subSequence(1,word.length());
  }
  if (TextUtils.isEmpty(word))   return null;
  final int lastCodePoint=Character.codePointBefore(word,word.length());
  if (!Character.isDefined(lastCodePoint))   return null;
  if (settings.isWordSeparator(lastCodePoint))   return null;
  final char firstChar=word.charAt(0);
  if (word.length() == 1 && !Character.isLetter(firstChar))   return null;
  if (!(Character.isLetter(firstChar) || settings.isSymbolExcludedFromWordSeparators(firstChar))) {
    return null;
  }
  return word;
}",0.8025545502927088
87926,"public CharSequence getWordBeforeCursorIfAtEndOfWord(final SettingsValues settings){
  final CharSequence textBeforeCursor=getTextBeforeCursor(1,0);
  if (TextUtils.isEmpty(textBeforeCursor) || settings.isWordSeparator(textBeforeCursor.charAt(0)))   return null;
  final CharSequence textAfterCursor=getTextAfterCursor(1,0);
  if (!TextUtils.isEmpty(textAfterCursor) && !settings.isWordSeparator(textAfterCursor.charAt(0)))   return null;
  CharSequence word=getWordAtCursor(settings.mWordSeparators);
  while (!TextUtils.isEmpty(word) && Keyboard.CODE_SINGLE_QUOTE == word.charAt(0)) {
    word=word.subSequence(1,word.length());
  }
  if (TextUtils.isEmpty(word))   return null;
  final char firstChar=word.charAt(0);
  if (word.length() == 1 && !Character.isLetter(firstChar))   return null;
  if (!(Character.isLetter(firstChar) || settings.isSymbolExcludedFromWordSeparators(firstChar))) {
    return null;
  }
  return word;
}","public CharSequence getWordBeforeCursorIfAtEndOfWord(final SettingsValues settings){
  final CharSequence textAfterCursor=getTextAfterCursor(1,0);
  if (!TextUtils.isEmpty(textAfterCursor) && !settings.isWordSeparator(textAfterCursor.charAt(0)))   return null;
  CharSequence word=getWordAtCursor(settings.mWordSeparators);
  while (!TextUtils.isEmpty(word) && Keyboard.CODE_SINGLE_QUOTE == word.charAt(0)) {
    word=word.subSequence(1,word.length());
  }
  if (TextUtils.isEmpty(word))   return null;
  final int lastCodePoint=Character.codePointBefore(word,word.length());
  if (!Character.isDefined(lastCodePoint))   return null;
  if (settings.isWordSeparator(lastCodePoint))   return null;
  final char firstChar=word.charAt(0);
  if (word.length() == 1 && !Character.isLetter(firstChar))   return null;
  if (!(Character.isLetter(firstChar) || settings.isSymbolExcludedFromWordSeparators(firstChar))) {
    return null;
  }
  return word;
}",0.8025545502927088
87927,"private CharSequence addToUserHistoryDictionary(final CharSequence suggestion){
  if (TextUtils.isEmpty(suggestion))   return null;
  if (!mCurrentSettings.mCorrectionEnabled)   return null;
  if (mUserHistoryDictionary != null) {
    final CharSequence prevWord=mConnection.getPreviousWord(mCurrentSettings.mWordSeparators);
    final String secondWord;
    if (mWordComposer.isAutoCapitalized() && !mWordComposer.isMostlyCaps()) {
      secondWord=suggestion.toString().toLowerCase(mSubtypeSwitcher.getCurrentSubtypeLocale());
    }
 else {
      secondWord=suggestion.toString();
    }
    final int maxFreq=AutoCorrection.getMaxFrequency(mSuggest.getUnigramDictionaries(),suggestion);
    if (maxFreq == 0)     return null;
    mUserHistoryDictionary.addToUserHistory(null == prevWord ? null : prevWord.toString(),secondWord,maxFreq > 0);
    return prevWord;
  }
  return null;
}","private CharSequence addToUserHistoryDictionary(final CharSequence suggestion){
  if (TextUtils.isEmpty(suggestion))   return null;
  if (!mCurrentSettings.mCorrectionEnabled)   return null;
  final UserHistoryDictionary userHistoryDictionary=mUserHistoryDictionary;
  if (userHistoryDictionary != null) {
    final CharSequence prevWord=mConnection.getPreviousWord(mCurrentSettings.mWordSeparators);
    final String secondWord;
    if (mWordComposer.isAutoCapitalized() && !mWordComposer.isMostlyCaps()) {
      secondWord=suggestion.toString().toLowerCase(mSubtypeSwitcher.getCurrentSubtypeLocale());
    }
 else {
      secondWord=suggestion.toString();
    }
    final int maxFreq=AutoCorrection.getMaxFrequency(mSuggest.getUnigramDictionaries(),suggestion);
    if (maxFreq == 0)     return null;
    userHistoryDictionary.addToUserHistory(null == prevWord ? null : prevWord.toString(),secondWord,maxFreq > 0);
    return prevWord;
  }
  return null;
}",0.9533116178067318
87928,"private CharSequence addToUserHistoryDictionary(final CharSequence suggestion){
  if (TextUtils.isEmpty(suggestion))   return null;
  if (!mCurrentSettings.isCorrectionOn())   return null;
  if (mUserHistoryDictionary != null) {
    final CharSequence prevWord=mConnection.getPreviousWord(mCurrentSettings.mWordSeparators);
    final String secondWord;
    if (mWordComposer.isAutoCapitalized() && !mWordComposer.isMostlyCaps()) {
      secondWord=suggestion.toString().toLowerCase(mSubtypeSwitcher.getCurrentSubtypeLocale());
    }
 else {
      secondWord=suggestion.toString();
    }
    final int maxFreq=AutoCorrection.getMaxFrequency(mSuggest.getUnigramDictionaries(),suggestion);
    if (maxFreq == 0)     return null;
    mUserHistoryDictionary.addToUserHistory(null == prevWord ? null : prevWord.toString(),secondWord,maxFreq > 0);
    return prevWord;
  }
  return null;
}","private CharSequence addToUserHistoryDictionary(final CharSequence suggestion){
  if (TextUtils.isEmpty(suggestion))   return null;
  if (!mCurrentSettings.isCorrectionOn())   return null;
  final UserHistoryDictionary userHistoryDictionary=mUserHistoryDictionary;
  if (userHistoryDictionary != null) {
    final CharSequence prevWord=mConnection.getPreviousWord(mCurrentSettings.mWordSeparators);
    final String secondWord;
    if (mWordComposer.isAutoCapitalized() && !mWordComposer.isMostlyCaps()) {
      secondWord=suggestion.toString().toLowerCase(mSubtypeSwitcher.getCurrentSubtypeLocale());
    }
 else {
      secondWord=suggestion.toString();
    }
    final int maxFreq=AutoCorrection.getMaxFrequency(mSuggest.getUnigramDictionaries(),suggestion);
    if (maxFreq == 0)     return null;
    userHistoryDictionary.addToUserHistory(null == prevWord ? null : prevWord.toString(),secondWord,maxFreq > 0);
    return prevWord;
  }
  return null;
}",0.9532100108813928
87929,"@Override public void loadDictionaryAsync(){
synchronized (mBigramList) {
    final long last=SettingsValues.getLastUserHistoryWriteTime(mPrefs,mLocale);
    final long now=System.currentTimeMillis();
    final Cursor cursor=query(MAIN_COLUMN_LOCALE + ""String_Node_Str"",new String[]{mLocale});
    if (null == cursor)     return;
    try {
      if (cursor.moveToFirst()) {
        final int word1Index=cursor.getColumnIndex(MAIN_COLUMN_WORD1);
        final int word2Index=cursor.getColumnIndex(MAIN_COLUMN_WORD2);
        final int fcIndex=cursor.getColumnIndex(COLUMN_FORGETTING_CURVE_VALUE);
        while (!cursor.isAfterLast()) {
          final String word1=cursor.getString(word1Index);
          final String word2=cursor.getString(word2Index);
          final int fc=cursor.getInt(fcIndex);
          if (DBG_SAVE_RESTORE) {
            Log.d(TAG,""String_Node_Str"" + word1 + ""String_Node_Str""+ word2+ ""String_Node_Str""+ mLocale+ ""String_Node_Str""+ this);
          }
          if (null == word1) {
            super.addWord(word2,null,fc);
          }
 else           if (word1.length() < BinaryDictionary.MAX_WORD_LENGTH && word2.length() < BinaryDictionary.MAX_WORD_LENGTH) {
            super.setBigramAndGetFrequency(word1,word2,new ForgettingCurveParams(fc,now,last));
          }
          mBigramList.addBigram(word1,word2,(byte)fc);
          cursor.moveToNext();
        }
      }
    }
  finally {
      cursor.close();
      if (PROFILE_SAVE_RESTORE) {
        final long diff=System.currentTimeMillis() - now;
        Log.w(TAG,""String_Node_Str"" + mLocale + ""String_Node_Str""+ diff+ ""String_Node_Str"");
      }
    }
  }
}","@Override public void loadDictionaryAsync(){
synchronized (mBigramList) {
    final long last=SettingsValues.getLastUserHistoryWriteTime(mPrefs,mLocale);
    final boolean initializing=last == 0;
    final long now=System.currentTimeMillis();
    final Cursor cursor=query(MAIN_COLUMN_LOCALE + ""String_Node_Str"",new String[]{mLocale});
    if (null == cursor)     return;
    try {
      if (cursor.moveToFirst()) {
        final int word1Index=cursor.getColumnIndex(MAIN_COLUMN_WORD1);
        final int word2Index=cursor.getColumnIndex(MAIN_COLUMN_WORD2);
        final int fcIndex=cursor.getColumnIndex(COLUMN_FORGETTING_CURVE_VALUE);
        while (!cursor.isAfterLast()) {
          final String word1=cursor.getString(word1Index);
          final String word2=cursor.getString(word2Index);
          final int fc=cursor.getInt(fcIndex);
          if (DBG_SAVE_RESTORE) {
            Log.d(TAG,""String_Node_Str"" + word1 + ""String_Node_Str""+ word2+ ""String_Node_Str""+ mLocale+ ""String_Node_Str""+ this);
          }
          if (null == word1) {
            super.addWord(word2,null,fc);
          }
 else           if (word1.length() < BinaryDictionary.MAX_WORD_LENGTH && word2.length() < BinaryDictionary.MAX_WORD_LENGTH) {
            super.setBigramAndGetFrequency(word1,word2,initializing ? new ForgettingCurveParams(true) : new ForgettingCurveParams(fc,now,last));
          }
          mBigramList.addBigram(word1,word2,(byte)fc);
          cursor.moveToNext();
        }
      }
    }
  finally {
      cursor.close();
      if (PROFILE_SAVE_RESTORE) {
        final long diff=System.currentTimeMillis() - now;
        Log.w(TAG,""String_Node_Str"" + mLocale + ""String_Node_Str""+ diff+ ""String_Node_Str"");
      }
    }
  }
}",0.9730689553122226
87930,"private void updateElapsedTime(long now){
  final int elapsedTimeCount=(int)((now - mLastTouchedTime) / ELAPSED_TIME_INTERVAL_MILLIS);
  if (elapsedTimeCount <= 0) {
    return;
  }
  for (int i=0; i < elapsedTimeCount; ++i) {
    mLastTouchedTime+=ELAPSED_TIME_INTERVAL_MILLIS;
    mFc=pushElapsedTime(mFc);
  }
}","private void updateElapsedTime(long now){
  final int elapsedTimeCount=(int)((now - mLastTouchedTime) / ELAPSED_TIME_INTERVAL_MILLIS);
  if (elapsedTimeCount <= 0) {
    return;
  }
  if (elapsedTimeCount >= MAX_PUSH_ELAPSED) {
    mLastTouchedTime=now;
    mFc=0;
    return;
  }
  for (int i=0; i < elapsedTimeCount; ++i) {
    mLastTouchedTime+=ELAPSED_TIME_INTERVAL_MILLIS;
    mFc=pushElapsedTime(mFc);
  }
}",0.8638239339752407
87931,"@Override public void loadDictionaryAsync(){
synchronized (mBigramList) {
    final long last=SettingsValues.getLastUserHistoryWriteTime(mPrefs,mLocale);
    final long now=System.currentTimeMillis();
    final Cursor cursor=query(MAIN_COLUMN_LOCALE + ""String_Node_Str"",new String[]{mLocale});
    if (null == cursor)     return;
    try {
      if (cursor.moveToFirst()) {
        final int word1Index=cursor.getColumnIndex(MAIN_COLUMN_WORD1);
        final int word2Index=cursor.getColumnIndex(MAIN_COLUMN_WORD2);
        final int fcIndex=cursor.getColumnIndex(COLUMN_FORGETTING_CURVE_VALUE);
        while (!cursor.isAfterLast()) {
          final String word1=cursor.getString(word1Index);
          final String word2=cursor.getString(word2Index);
          final int fc=cursor.getInt(fcIndex);
          if (DBG_SAVE_RESTORE) {
            Log.d(TAG,""String_Node_Str"" + word1 + ""String_Node_Str""+ word2+ ""String_Node_Str""+ mLocale+ ""String_Node_Str""+ this);
          }
          if (null == word1) {
            super.addWord(word2,null,fc);
          }
 else           if (word1.length() < BinaryDictionary.MAX_WORD_LENGTH && word2.length() < BinaryDictionary.MAX_WORD_LENGTH) {
            super.setBigramAndGetFrequency(word1,word2,new ForgettingCurveParams(fc,now,last));
          }
          mBigramList.addBigram(word1,word2,(byte)fc);
          cursor.moveToNext();
        }
      }
    }
  finally {
      cursor.close();
      if (PROFILE_SAVE_RESTORE) {
        final long diff=System.currentTimeMillis() - now;
        Log.w(TAG,""String_Node_Str"" + mLocale + ""String_Node_Str""+ diff+ ""String_Node_Str"");
      }
    }
  }
}","@Override public void loadDictionaryAsync(){
synchronized (mBigramList) {
    final long last=SettingsValues.getLastUserHistoryWriteTime(mPrefs,mLocale);
    final boolean initializing=last == 0;
    final long now=System.currentTimeMillis();
    final Cursor cursor=query(MAIN_COLUMN_LOCALE + ""String_Node_Str"",new String[]{mLocale});
    if (null == cursor)     return;
    try {
      if (cursor.moveToFirst()) {
        final int word1Index=cursor.getColumnIndex(MAIN_COLUMN_WORD1);
        final int word2Index=cursor.getColumnIndex(MAIN_COLUMN_WORD2);
        final int fcIndex=cursor.getColumnIndex(COLUMN_FORGETTING_CURVE_VALUE);
        while (!cursor.isAfterLast()) {
          final String word1=cursor.getString(word1Index);
          final String word2=cursor.getString(word2Index);
          final int fc=cursor.getInt(fcIndex);
          if (DBG_SAVE_RESTORE) {
            Log.d(TAG,""String_Node_Str"" + word1 + ""String_Node_Str""+ word2+ ""String_Node_Str""+ mLocale+ ""String_Node_Str""+ this);
          }
          if (null == word1) {
            super.addWord(word2,null,fc);
          }
 else           if (word1.length() < BinaryDictionary.MAX_WORD_LENGTH && word2.length() < BinaryDictionary.MAX_WORD_LENGTH) {
            super.setBigramAndGetFrequency(word1,word2,initializing ? new ForgettingCurveParams(true) : new ForgettingCurveParams(fc,now,last));
          }
          mBigramList.addBigram(word1,word2,(byte)fc);
          cursor.moveToNext();
        }
      }
    }
  finally {
      cursor.close();
      if (PROFILE_SAVE_RESTORE) {
        final long diff=System.currentTimeMillis() - now;
        Log.w(TAG,""String_Node_Str"" + mLocale + ""String_Node_Str""+ diff+ ""String_Node_Str"");
      }
    }
  }
}",0.9730689553122226
87932,"private void updateElapsedTime(long now){
  final int elapsedTimeCount=(int)((now - mLastTouchedTime) / ELAPSED_TIME_INTERVAL_MILLIS);
  if (elapsedTimeCount <= 0) {
    return;
  }
  for (int i=0; i < elapsedTimeCount; ++i) {
    mLastTouchedTime+=ELAPSED_TIME_INTERVAL_MILLIS;
    mFc=pushElapsedTime(mFc);
  }
}","private void updateElapsedTime(long now){
  final int elapsedTimeCount=(int)((now - mLastTouchedTime) / ELAPSED_TIME_INTERVAL_MILLIS);
  if (elapsedTimeCount <= 0) {
    return;
  }
  if (elapsedTimeCount >= MAX_PUSH_ELAPSED) {
    mLastTouchedTime=now;
    mFc=0;
    return;
  }
  for (int i=0; i < elapsedTimeCount; ++i) {
    mLastTouchedTime+=ELAPSED_TIME_INTERVAL_MILLIS;
    mFc=pushElapsedTime(mFc);
  }
}",0.8638239339752407
87933,"@Override public void loadDictionaryAsync(){
synchronized (mBigramList) {
    final long last=SettingsValues.getLastUserHistoryWriteTime(mPrefs,mLocale);
    final long now=System.currentTimeMillis();
    final Cursor cursor=query(MAIN_COLUMN_LOCALE + ""String_Node_Str"",new String[]{mLocale});
    if (null == cursor)     return;
    try {
      if (cursor.moveToFirst()) {
        final int word1Index=cursor.getColumnIndex(MAIN_COLUMN_WORD1);
        final int word2Index=cursor.getColumnIndex(MAIN_COLUMN_WORD2);
        final int fcIndex=cursor.getColumnIndex(COLUMN_FORGETTING_CURVE_VALUE);
        while (!cursor.isAfterLast()) {
          final String word1=cursor.getString(word1Index);
          final String word2=cursor.getString(word2Index);
          final int fc=cursor.getInt(fcIndex);
          if (DBG_SAVE_RESTORE) {
            Log.d(TAG,""String_Node_Str"" + word1 + ""String_Node_Str""+ word2+ ""String_Node_Str""+ mLocale+ ""String_Node_Str""+ this);
          }
          if (null == word1) {
            super.addWord(word2,null,fc);
          }
 else           if (word1.length() < BinaryDictionary.MAX_WORD_LENGTH && word2.length() < BinaryDictionary.MAX_WORD_LENGTH) {
            super.setBigramAndGetFrequency(word1,word2,new ForgettingCurveParams(fc,now,last));
          }
          mBigramList.addBigram(word1,word2,(byte)fc);
          cursor.moveToNext();
        }
      }
    }
  finally {
      cursor.close();
      if (PROFILE_SAVE_RESTORE) {
        final long diff=System.currentTimeMillis() - now;
        Log.w(TAG,""String_Node_Str"" + mLocale + ""String_Node_Str""+ diff+ ""String_Node_Str"");
      }
    }
  }
}","@Override public void loadDictionaryAsync(){
synchronized (mBigramList) {
    final long last=SettingsValues.getLastUserHistoryWriteTime(mPrefs,mLocale);
    final boolean initializing=last == 0;
    final long now=System.currentTimeMillis();
    final Cursor cursor=query(MAIN_COLUMN_LOCALE + ""String_Node_Str"",new String[]{mLocale});
    if (null == cursor)     return;
    try {
      if (cursor.moveToFirst()) {
        final int word1Index=cursor.getColumnIndex(MAIN_COLUMN_WORD1);
        final int word2Index=cursor.getColumnIndex(MAIN_COLUMN_WORD2);
        final int fcIndex=cursor.getColumnIndex(COLUMN_FORGETTING_CURVE_VALUE);
        while (!cursor.isAfterLast()) {
          final String word1=cursor.getString(word1Index);
          final String word2=cursor.getString(word2Index);
          final int fc=cursor.getInt(fcIndex);
          if (DBG_SAVE_RESTORE) {
            Log.d(TAG,""String_Node_Str"" + word1 + ""String_Node_Str""+ word2+ ""String_Node_Str""+ mLocale+ ""String_Node_Str""+ this);
          }
          if (null == word1) {
            super.addWord(word2,null,fc);
          }
 else           if (word1.length() < BinaryDictionary.MAX_WORD_LENGTH && word2.length() < BinaryDictionary.MAX_WORD_LENGTH) {
            super.setBigramAndGetFrequency(word1,word2,initializing ? new ForgettingCurveParams(true) : new ForgettingCurveParams(fc,now,last));
          }
          mBigramList.addBigram(word1,word2,(byte)fc);
          cursor.moveToNext();
        }
      }
    }
  finally {
      cursor.close();
      if (PROFILE_SAVE_RESTORE) {
        final long diff=System.currentTimeMillis() - now;
        Log.w(TAG,""String_Node_Str"" + mLocale + ""String_Node_Str""+ diff+ ""String_Node_Str"");
      }
    }
  }
}",0.9730689553122226
87934,"private void updateElapsedTime(long now){
  final int elapsedTimeCount=(int)((now - mLastTouchedTime) / ELAPSED_TIME_INTERVAL_MILLIS);
  if (elapsedTimeCount <= 0) {
    return;
  }
  for (int i=0; i < elapsedTimeCount; ++i) {
    mLastTouchedTime+=ELAPSED_TIME_INTERVAL_MILLIS;
    mFc=pushElapsedTime(mFc);
  }
}","private void updateElapsedTime(long now){
  final int elapsedTimeCount=(int)((now - mLastTouchedTime) / ELAPSED_TIME_INTERVAL_MILLIS);
  if (elapsedTimeCount <= 0) {
    return;
  }
  if (elapsedTimeCount >= MAX_PUSH_ELAPSED) {
    mLastTouchedTime=now;
    mFc=0;
    return;
  }
  for (int i=0; i < elapsedTimeCount; ++i) {
    mLastTouchedTime+=ELAPSED_TIME_INTERVAL_MILLIS;
    mFc=pushElapsedTime(mFc);
  }
}",0.8638239339752407
87935,"private void startUsingContactsDictionaryLocked(){
  if (null == mContactsDictionary) {
    mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
  }
  final Iterator<WeakReference<DictionaryCollection>> iterator=mDictionaryCollectionsList.iterator();
  while (iterator.hasNext()) {
    final WeakReference<DictionaryCollection> dictRef=iterator.next();
    final DictionaryCollection dict=dictRef.get();
    if (null == dict) {
      iterator.remove();
    }
 else {
      dict.addDictionary(mContactsDictionary);
    }
  }
}","private void startUsingContactsDictionaryLocked(){
  if (null == mContactsDictionary) {
    if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
      mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this);
    }
 else {
      mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
    }
  }
  final Iterator<WeakReference<DictionaryCollection>> iterator=mDictionaryCollectionsList.iterator();
  while (iterator.hasNext()) {
    final WeakReference<DictionaryCollection> dictRef=iterator.next();
    final DictionaryCollection dict=dictRef.get();
    if (null == dict) {
      iterator.remove();
    }
 else {
      dict.addDictionary(mContactsDictionary);
    }
  }
}",0.8754045307443366
87936,"public SynchronouslyLoadedContactsBinaryDictionary(final Context context){
  super(context,Suggest.DIC_CONTACTS,null);
}","public SynchronouslyLoadedContactsBinaryDictionary(final Context context,final Locale locale){
  super(context,Suggest.DIC_CONTACTS,locale);
}",0.900763358778626
87937,"public DictAndProximity createDictAndProximity(final Locale locale){
  final int script=getScriptFromLocale(locale);
  final ProximityInfo proximityInfo=ProximityInfo.createSpellCheckerProximityInfo(SpellCheckerProximityInfo.getProximityForScript(script),SpellCheckerProximityInfo.ROW_SIZE,SpellCheckerProximityInfo.PROXIMITY_GRID_WIDTH,SpellCheckerProximityInfo.PROXIMITY_GRID_HEIGHT);
  final DictionaryCollection dictionaryCollection=DictionaryFactory.createMainDictionaryFromManager(this,locale,true);
  final String localeStr=locale.toString();
  Dictionary userDictionary=mUserDictionaries.get(localeStr);
  if (null == userDictionary) {
    if (LatinIME.USE_BINARY_USER_DICTIONARY) {
      userDictionary=new SynchronouslyLoadedUserBinaryDictionary(this,localeStr,true);
    }
 else {
      userDictionary=new SynchronouslyLoadedUserDictionary(this,localeStr,true);
    }
    mUserDictionaries.put(localeStr,userDictionary);
  }
  dictionaryCollection.addDictionary(userDictionary);
  Dictionary whitelistDictionary=mWhitelistDictionaries.get(localeStr);
  if (null == whitelistDictionary) {
    whitelistDictionary=new WhitelistDictionary(this,locale);
    mWhitelistDictionaries.put(localeStr,whitelistDictionary);
  }
  dictionaryCollection.addDictionary(whitelistDictionary);
synchronized (mUseContactsLock) {
    if (mUseContactsDictionary) {
      if (null == mContactsDictionary) {
        if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
          mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this);
        }
 else {
          mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
        }
      }
    }
    dictionaryCollection.addDictionary(mContactsDictionary);
    mDictionaryCollectionsList.add(new WeakReference<DictionaryCollection>(dictionaryCollection));
  }
  return new DictAndProximity(dictionaryCollection,proximityInfo);
}","public DictAndProximity createDictAndProximity(final Locale locale){
  final int script=getScriptFromLocale(locale);
  final ProximityInfo proximityInfo=ProximityInfo.createSpellCheckerProximityInfo(SpellCheckerProximityInfo.getProximityForScript(script),SpellCheckerProximityInfo.ROW_SIZE,SpellCheckerProximityInfo.PROXIMITY_GRID_WIDTH,SpellCheckerProximityInfo.PROXIMITY_GRID_HEIGHT);
  final DictionaryCollection dictionaryCollection=DictionaryFactory.createMainDictionaryFromManager(this,locale,true);
  final String localeStr=locale.toString();
  Dictionary userDictionary=mUserDictionaries.get(localeStr);
  if (null == userDictionary) {
    if (LatinIME.USE_BINARY_USER_DICTIONARY) {
      userDictionary=new SynchronouslyLoadedUserBinaryDictionary(this,localeStr,true);
    }
 else {
      userDictionary=new SynchronouslyLoadedUserDictionary(this,localeStr,true);
    }
    mUserDictionaries.put(localeStr,userDictionary);
  }
  dictionaryCollection.addDictionary(userDictionary);
  Dictionary whitelistDictionary=mWhitelistDictionaries.get(localeStr);
  if (null == whitelistDictionary) {
    whitelistDictionary=new WhitelistDictionary(this,locale);
    mWhitelistDictionaries.put(localeStr,whitelistDictionary);
  }
  dictionaryCollection.addDictionary(whitelistDictionary);
synchronized (mUseContactsLock) {
    if (mUseContactsDictionary) {
      if (null == mContactsDictionary) {
        if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
          mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this,Locale.getDefault());
        }
 else {
          mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
        }
      }
    }
    dictionaryCollection.addDictionary(mContactsDictionary);
    mDictionaryCollectionsList.add(new WeakReference<DictionaryCollection>(dictionaryCollection));
  }
  return new DictAndProximity(dictionaryCollection,proximityInfo);
}",0.9947340705634544
87938,"private void startUsingContactsDictionaryLocked(){
  if (null == mContactsDictionary) {
    if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
      mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this);
    }
 else {
      mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
    }
  }
  final Iterator<WeakReference<DictionaryCollection>> iterator=mDictionaryCollectionsList.iterator();
  while (iterator.hasNext()) {
    final WeakReference<DictionaryCollection> dictRef=iterator.next();
    final DictionaryCollection dict=dictRef.get();
    if (null == dict) {
      iterator.remove();
    }
 else {
      dict.addDictionary(mContactsDictionary);
    }
  }
}","private void startUsingContactsDictionaryLocked(){
  if (null == mContactsDictionary) {
    if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
      mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this,Locale.getDefault());
    }
 else {
      mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
    }
  }
  final Iterator<WeakReference<DictionaryCollection>> iterator=mDictionaryCollectionsList.iterator();
  while (iterator.hasNext()) {
    final WeakReference<DictionaryCollection> dictRef=iterator.next();
    final DictionaryCollection dict=dictRef.get();
    if (null == dict) {
      iterator.remove();
    }
 else {
      dict.addDictionary(mContactsDictionary);
    }
  }
}",0.9858156028368794
87939,"private void startUsingContactsDictionaryLocked(){
  if (null == mContactsDictionary) {
    mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
  }
  final Iterator<WeakReference<DictionaryCollection>> iterator=mDictionaryCollectionsList.iterator();
  while (iterator.hasNext()) {
    final WeakReference<DictionaryCollection> dictRef=iterator.next();
    final DictionaryCollection dict=dictRef.get();
    if (null == dict) {
      iterator.remove();
    }
 else {
      dict.addDictionary(mContactsDictionary);
    }
  }
}","private void startUsingContactsDictionaryLocked(){
  if (null == mContactsDictionary) {
    if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
      mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this);
    }
 else {
      mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
    }
  }
  final Iterator<WeakReference<DictionaryCollection>> iterator=mDictionaryCollectionsList.iterator();
  while (iterator.hasNext()) {
    final WeakReference<DictionaryCollection> dictRef=iterator.next();
    final DictionaryCollection dict=dictRef.get();
    if (null == dict) {
      iterator.remove();
    }
 else {
      dict.addDictionary(mContactsDictionary);
    }
  }
}",0.8754045307443366
87940,"public SynchronouslyLoadedContactsBinaryDictionary(final Context context){
  super(context,Suggest.DIC_CONTACTS,null);
}","public SynchronouslyLoadedContactsBinaryDictionary(final Context context,final Locale locale){
  super(context,Suggest.DIC_CONTACTS,locale);
}",0.900763358778626
87941,"public DictAndProximity createDictAndProximity(final Locale locale){
  final int script=getScriptFromLocale(locale);
  final ProximityInfo proximityInfo=ProximityInfo.createSpellCheckerProximityInfo(SpellCheckerProximityInfo.getProximityForScript(script),SpellCheckerProximityInfo.ROW_SIZE,SpellCheckerProximityInfo.PROXIMITY_GRID_WIDTH,SpellCheckerProximityInfo.PROXIMITY_GRID_HEIGHT);
  final DictionaryCollection dictionaryCollection=DictionaryFactory.createMainDictionaryFromManager(this,locale,true);
  final String localeStr=locale.toString();
  Dictionary userDictionary=mUserDictionaries.get(localeStr);
  if (null == userDictionary) {
    if (LatinIME.USE_BINARY_USER_DICTIONARY) {
      userDictionary=new SynchronouslyLoadedUserBinaryDictionary(this,localeStr,true);
    }
 else {
      userDictionary=new SynchronouslyLoadedUserDictionary(this,localeStr,true);
    }
    mUserDictionaries.put(localeStr,userDictionary);
  }
  dictionaryCollection.addDictionary(userDictionary);
  Dictionary whitelistDictionary=mWhitelistDictionaries.get(localeStr);
  if (null == whitelistDictionary) {
    whitelistDictionary=new WhitelistDictionary(this,locale);
    mWhitelistDictionaries.put(localeStr,whitelistDictionary);
  }
  dictionaryCollection.addDictionary(whitelistDictionary);
synchronized (mUseContactsLock) {
    if (mUseContactsDictionary) {
      if (null == mContactsDictionary) {
        if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
          mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this);
        }
 else {
          mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
        }
      }
    }
    dictionaryCollection.addDictionary(mContactsDictionary);
    mDictionaryCollectionsList.add(new WeakReference<DictionaryCollection>(dictionaryCollection));
  }
  return new DictAndProximity(dictionaryCollection,proximityInfo);
}","public DictAndProximity createDictAndProximity(final Locale locale){
  final int script=getScriptFromLocale(locale);
  final ProximityInfo proximityInfo=ProximityInfo.createSpellCheckerProximityInfo(SpellCheckerProximityInfo.getProximityForScript(script),SpellCheckerProximityInfo.ROW_SIZE,SpellCheckerProximityInfo.PROXIMITY_GRID_WIDTH,SpellCheckerProximityInfo.PROXIMITY_GRID_HEIGHT);
  final DictionaryCollection dictionaryCollection=DictionaryFactory.createMainDictionaryFromManager(this,locale,true);
  final String localeStr=locale.toString();
  Dictionary userDictionary=mUserDictionaries.get(localeStr);
  if (null == userDictionary) {
    if (LatinIME.USE_BINARY_USER_DICTIONARY) {
      userDictionary=new SynchronouslyLoadedUserBinaryDictionary(this,localeStr,true);
    }
 else {
      userDictionary=new SynchronouslyLoadedUserDictionary(this,localeStr,true);
    }
    mUserDictionaries.put(localeStr,userDictionary);
  }
  dictionaryCollection.addDictionary(userDictionary);
  Dictionary whitelistDictionary=mWhitelistDictionaries.get(localeStr);
  if (null == whitelistDictionary) {
    whitelistDictionary=new WhitelistDictionary(this,locale);
    mWhitelistDictionaries.put(localeStr,whitelistDictionary);
  }
  dictionaryCollection.addDictionary(whitelistDictionary);
synchronized (mUseContactsLock) {
    if (mUseContactsDictionary) {
      if (null == mContactsDictionary) {
        if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
          mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this,Locale.getDefault());
        }
 else {
          mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
        }
      }
    }
    dictionaryCollection.addDictionary(mContactsDictionary);
    mDictionaryCollectionsList.add(new WeakReference<DictionaryCollection>(dictionaryCollection));
  }
  return new DictAndProximity(dictionaryCollection,proximityInfo);
}",0.9947340705634544
87942,"private void startUsingContactsDictionaryLocked(){
  if (null == mContactsDictionary) {
    if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
      mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this);
    }
 else {
      mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
    }
  }
  final Iterator<WeakReference<DictionaryCollection>> iterator=mDictionaryCollectionsList.iterator();
  while (iterator.hasNext()) {
    final WeakReference<DictionaryCollection> dictRef=iterator.next();
    final DictionaryCollection dict=dictRef.get();
    if (null == dict) {
      iterator.remove();
    }
 else {
      dict.addDictionary(mContactsDictionary);
    }
  }
}","private void startUsingContactsDictionaryLocked(){
  if (null == mContactsDictionary) {
    if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
      mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this,Locale.getDefault());
    }
 else {
      mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
    }
  }
  final Iterator<WeakReference<DictionaryCollection>> iterator=mDictionaryCollectionsList.iterator();
  while (iterator.hasNext()) {
    final WeakReference<DictionaryCollection> dictRef=iterator.next();
    final DictionaryCollection dict=dictRef.get();
    if (null == dict) {
      iterator.remove();
    }
 else {
      dict.addDictionary(mContactsDictionary);
    }
  }
}",0.9858156028368794
87943,"public SynchronouslyLoadedContactsBinaryDictionary(final Context context){
  super(context,Suggest.DIC_CONTACTS,null);
}","public SynchronouslyLoadedContactsBinaryDictionary(final Context context,final Locale locale){
  super(context,Suggest.DIC_CONTACTS,locale);
}",0.900763358778626
87944,"public DictAndProximity createDictAndProximity(final Locale locale){
  final int script=getScriptFromLocale(locale);
  final ProximityInfo proximityInfo=ProximityInfo.createSpellCheckerProximityInfo(SpellCheckerProximityInfo.getProximityForScript(script),SpellCheckerProximityInfo.ROW_SIZE,SpellCheckerProximityInfo.PROXIMITY_GRID_WIDTH,SpellCheckerProximityInfo.PROXIMITY_GRID_HEIGHT);
  final DictionaryCollection dictionaryCollection=DictionaryFactory.createMainDictionaryFromManager(this,locale,true);
  final String localeStr=locale.toString();
  Dictionary userDictionary=mUserDictionaries.get(localeStr);
  if (null == userDictionary) {
    if (LatinIME.USE_BINARY_USER_DICTIONARY) {
      userDictionary=new SynchronouslyLoadedUserBinaryDictionary(this,localeStr,true);
    }
 else {
      userDictionary=new SynchronouslyLoadedUserDictionary(this,localeStr,true);
    }
    mUserDictionaries.put(localeStr,userDictionary);
  }
  dictionaryCollection.addDictionary(userDictionary);
  Dictionary whitelistDictionary=mWhitelistDictionaries.get(localeStr);
  if (null == whitelistDictionary) {
    whitelistDictionary=new WhitelistDictionary(this,locale);
    mWhitelistDictionaries.put(localeStr,whitelistDictionary);
  }
  dictionaryCollection.addDictionary(whitelistDictionary);
synchronized (mUseContactsLock) {
    if (mUseContactsDictionary) {
      if (null == mContactsDictionary) {
        if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
          mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this);
        }
 else {
          mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
        }
      }
    }
    dictionaryCollection.addDictionary(mContactsDictionary);
    mDictionaryCollectionsList.add(new WeakReference<DictionaryCollection>(dictionaryCollection));
  }
  return new DictAndProximity(dictionaryCollection,proximityInfo);
}","public DictAndProximity createDictAndProximity(final Locale locale){
  final int script=getScriptFromLocale(locale);
  final ProximityInfo proximityInfo=ProximityInfo.createSpellCheckerProximityInfo(SpellCheckerProximityInfo.getProximityForScript(script),SpellCheckerProximityInfo.ROW_SIZE,SpellCheckerProximityInfo.PROXIMITY_GRID_WIDTH,SpellCheckerProximityInfo.PROXIMITY_GRID_HEIGHT);
  final DictionaryCollection dictionaryCollection=DictionaryFactory.createMainDictionaryFromManager(this,locale,true);
  final String localeStr=locale.toString();
  Dictionary userDictionary=mUserDictionaries.get(localeStr);
  if (null == userDictionary) {
    if (LatinIME.USE_BINARY_USER_DICTIONARY) {
      userDictionary=new SynchronouslyLoadedUserBinaryDictionary(this,localeStr,true);
    }
 else {
      userDictionary=new SynchronouslyLoadedUserDictionary(this,localeStr,true);
    }
    mUserDictionaries.put(localeStr,userDictionary);
  }
  dictionaryCollection.addDictionary(userDictionary);
  Dictionary whitelistDictionary=mWhitelistDictionaries.get(localeStr);
  if (null == whitelistDictionary) {
    whitelistDictionary=new WhitelistDictionary(this,locale);
    mWhitelistDictionaries.put(localeStr,whitelistDictionary);
  }
  dictionaryCollection.addDictionary(whitelistDictionary);
synchronized (mUseContactsLock) {
    if (mUseContactsDictionary) {
      if (null == mContactsDictionary) {
        if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
          mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this,Locale.getDefault());
        }
 else {
          mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
        }
      }
    }
    dictionaryCollection.addDictionary(mContactsDictionary);
    mDictionaryCollectionsList.add(new WeakReference<DictionaryCollection>(dictionaryCollection));
  }
  return new DictAndProximity(dictionaryCollection,proximityInfo);
}",0.9947340705634544
87945,"private void startUsingContactsDictionaryLocked(){
  if (null == mContactsDictionary) {
    if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
      mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this);
    }
 else {
      mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
    }
  }
  final Iterator<WeakReference<DictionaryCollection>> iterator=mDictionaryCollectionsList.iterator();
  while (iterator.hasNext()) {
    final WeakReference<DictionaryCollection> dictRef=iterator.next();
    final DictionaryCollection dict=dictRef.get();
    if (null == dict) {
      iterator.remove();
    }
 else {
      dict.addDictionary(mContactsDictionary);
    }
  }
}","private void startUsingContactsDictionaryLocked(){
  if (null == mContactsDictionary) {
    if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
      mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this,Locale.getDefault());
    }
 else {
      mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
    }
  }
  final Iterator<WeakReference<DictionaryCollection>> iterator=mDictionaryCollectionsList.iterator();
  while (iterator.hasNext()) {
    final WeakReference<DictionaryCollection> dictRef=iterator.next();
    final DictionaryCollection dict=dictRef.get();
    if (null == dict) {
      iterator.remove();
    }
 else {
      dict.addDictionary(mContactsDictionary);
    }
  }
}",0.9858156028368794
87946,"private void startUsingContactsDictionaryLocked(){
  if (null == mContactsDictionary) {
    mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
  }
  final Iterator<WeakReference<DictionaryCollection>> iterator=mDictionaryCollectionsList.iterator();
  while (iterator.hasNext()) {
    final WeakReference<DictionaryCollection> dictRef=iterator.next();
    final DictionaryCollection dict=dictRef.get();
    if (null == dict) {
      iterator.remove();
    }
 else {
      dict.addDictionary(mContactsDictionary);
    }
  }
}","private void startUsingContactsDictionaryLocked(){
  if (null == mContactsDictionary) {
    if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
      mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this);
    }
 else {
      mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
    }
  }
  final Iterator<WeakReference<DictionaryCollection>> iterator=mDictionaryCollectionsList.iterator();
  while (iterator.hasNext()) {
    final WeakReference<DictionaryCollection> dictRef=iterator.next();
    final DictionaryCollection dict=dictRef.get();
    if (null == dict) {
      iterator.remove();
    }
 else {
      dict.addDictionary(mContactsDictionary);
    }
  }
}",0.8754045307443366
87947,"private void startUsingContactsDictionaryLocked(){
  if (null == mContactsDictionary) {
    mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
  }
  final Iterator<WeakReference<DictionaryCollection>> iterator=mDictionaryCollectionsList.iterator();
  while (iterator.hasNext()) {
    final WeakReference<DictionaryCollection> dictRef=iterator.next();
    final DictionaryCollection dict=dictRef.get();
    if (null == dict) {
      iterator.remove();
    }
 else {
      dict.addDictionary(mContactsDictionary);
    }
  }
}","private void startUsingContactsDictionaryLocked(){
  if (null == mContactsDictionary) {
    if (LatinIME.USE_BINARY_CONTACTS_DICTIONARY) {
      mContactsDictionary=new SynchronouslyLoadedContactsBinaryDictionary(this);
    }
 else {
      mContactsDictionary=new SynchronouslyLoadedContactsDictionary(this);
    }
  }
  final Iterator<WeakReference<DictionaryCollection>> iterator=mDictionaryCollectionsList.iterator();
  while (iterator.hasNext()) {
    final WeakReference<DictionaryCollection> dictRef=iterator.next();
    final DictionaryCollection dict=dictRef.get();
    if (null == dict) {
      iterator.remove();
    }
 else {
      dict.addDictionary(mContactsDictionary);
    }
  }
}",0.8754045307443366
87948,"@Override protected boolean hasContentChanged(){
  final long startTime=SystemClock.uptimeMillis();
  final int contactCount=getContactCount();
  if (contactCount > MAX_CONTACT_COUNT) {
    return false;
  }
  if (contactCount != sContactCountAtLastRebuild) {
    return true;
  }
  Cursor cursor=mContext.getContentResolver().query(Contacts.CONTENT_URI,PROJECTION,null,null,null);
  if (cursor != null) {
    try {
      if (cursor.moveToFirst()) {
        while (!cursor.isAfterLast()) {
          String name=cursor.getString(INDEX_NAME);
          if (isValidName(name) && !isNameInDictionary(name)) {
            if (DEBUG) {
              Log.d(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ (SystemClock.uptimeMillis() - startTime)+ ""String_Node_Str"");
            }
            return true;
          }
          cursor.moveToNext();
        }
      }
    }
  finally {
      cursor.close();
    }
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - startTime) + ""String_Node_Str"");
  }
  return false;
}","@Override protected boolean hasContentChanged(){
  final long startTime=SystemClock.uptimeMillis();
  final int contactCount=getContactCount();
  if (contactCount > MAX_CONTACT_COUNT) {
    return false;
  }
  if (contactCount != sContactCountAtLastRebuild) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + sContactCountAtLastRebuild + ""String_Node_Str""+ contactCount);
    }
    return true;
  }
  Cursor cursor=mContext.getContentResolver().query(Contacts.CONTENT_URI,PROJECTION,null,null,null);
  if (cursor != null) {
    try {
      if (cursor.moveToFirst()) {
        while (!cursor.isAfterLast()) {
          String name=cursor.getString(INDEX_NAME);
          if (isValidName(name) && !isNameInDictionary(name)) {
            if (DEBUG) {
              Log.d(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ (SystemClock.uptimeMillis() - startTime)+ ""String_Node_Str"");
            }
            return true;
          }
          cursor.moveToNext();
        }
      }
    }
  finally {
      cursor.close();
    }
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - startTime) + ""String_Node_Str"");
  }
  return false;
}",0.9448961156278228
87949,"/** 
 * Loads the current binary dictionary from internal storage. Assumes the dictionary file exists.
 */
protected void loadBinaryDictionary(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mSharedDictionaryController.mLastUpdateRequestTime + ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
  final File file=new File(mContext.getFilesDir(),mFilename);
  final String filename=file.getAbsolutePath();
  final long length=file.length();
  final BinaryDictionary newBinaryDictionary=new BinaryDictionary(mContext,filename,0,length,true,null);
  if (mBinaryDictionary != null) {
    final BinaryDictionary oldBinaryDictionary=mBinaryDictionary;
    mLocalDictionaryController.lock();
    mBinaryDictionary=newBinaryDictionary;
    mLocalDictionaryController.unlock();
    oldBinaryDictionary.close();
  }
 else {
    mBinaryDictionary=newBinaryDictionary;
  }
}","/** 
 * Loads the current binary dictionary from internal storage. Assumes the dictionary file exists.
 */
protected void loadBinaryDictionary(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mFilename + ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateRequestTime+ ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
  final File file=new File(mContext.getFilesDir(),mFilename);
  final String filename=file.getAbsolutePath();
  final long length=file.length();
  final BinaryDictionary newBinaryDictionary=new BinaryDictionary(mContext,filename,0,length,true,null);
  if (mBinaryDictionary != null) {
    final BinaryDictionary oldBinaryDictionary=mBinaryDictionary;
    mLocalDictionaryController.lock();
    mBinaryDictionary=newBinaryDictionary;
    mLocalDictionaryController.unlock();
    oldBinaryDictionary.close();
  }
 else {
    mBinaryDictionary=newBinaryDictionary;
  }
}",0.982202447163515
87950,"@Override public void run(){
  syncReloadDictionaryIfRequired();
}","@Override public void run(){
  syncReloadDictionaryInternal();
}",0.9076923076923076
87951,"/** 
 * Reloads the dictionary if required. Reload will occur asynchronously in a separate thread.
 */
void asyncReloadDictionaryIfRequired(){
  new AsyncReloadDictionaryTask().start();
}","/** 
 * Reloads the dictionary if required. Reload will occur asynchronously in a separate thread.
 */
void asyncReloadDictionaryIfRequired(){
  if (!isReloadRequired())   return;
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mFilename);
  }
  new AsyncReloadDictionaryTask().start();
}",0.7857142857142857
87952,"/** 
 * Marks that the dictionary is out of date and requires a reload.
 * @param requiresRebuild Indicates that the source dictionary content has changed and a rebuildof the binary file is required. If not true, the next reload process will only read the current binary dictionary from file.
 */
protected void setRequiresReload(final boolean requiresRebuild){
  final long time=SystemClock.uptimeMillis();
  mLocalDictionaryController.mLastUpdateRequestTime=time;
  mSharedDictionaryController.mLastUpdateRequestTime=time;
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + time + ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
}","/** 
 * Marks that the dictionary is out of date and requires a reload.
 * @param requiresRebuild Indicates that the source dictionary content has changed and a rebuildof the binary file is required. If not true, the next reload process will only read the current binary dictionary from file.
 */
protected void setRequiresReload(final boolean requiresRebuild){
  final long time=SystemClock.uptimeMillis();
  mLocalDictionaryController.mLastUpdateRequestTime=time;
  mSharedDictionaryController.mLastUpdateRequestTime=time;
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mFilename + ""String_Node_Str""+ time+ ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
}",0.9744744744744744
87953,"/** 
 * Reloads the dictionary if required. Access is controlled on a per dictionary file basis and supports concurrent calls from multiple instances that share the same dictionary file.
 */
protected final void syncReloadDictionaryIfRequired(){
  if (mBinaryDictionary != null && !mLocalDictionaryController.isOutOfDate()) {
    return;
  }
  mSharedDictionaryController.lock();
  try {
    final long time=SystemClock.uptimeMillis();
    if (mSharedDictionaryController.isOutOfDate() || !dictionaryFileExists()) {
      if (hasContentChanged()) {
        mSharedDictionaryController.mLastUpdateTime=time;
        generateBinaryDictionary();
        loadBinaryDictionary();
      }
 else {
        mSharedDictionaryController.mLastUpdateRequestTime=mSharedDictionaryController.mLastUpdateTime;
      }
    }
 else     if (mBinaryDictionary == null || mLocalDictionaryController.mLastUpdateTime < mSharedDictionaryController.mLastUpdateTime) {
      loadBinaryDictionary();
    }
    mLocalDictionaryController.mLastUpdateTime=time;
  }
  finally {
    mSharedDictionaryController.unlock();
  }
}","/** 
 * Reloads the dictionary if required.
 */
protected final void syncReloadDictionaryIfRequired(){
  if (!isReloadRequired())   return;
  syncReloadDictionaryInternal();
}",0.2391817466561762
87954,"/** 
 * Generates and writes a new binary dictionary based on the contents of the fusion dictionary.
 */
private void generateBinaryDictionary(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mSharedDictionaryController.mLastUpdateRequestTime + ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
  loadDictionaryAsync();
  final String tempFileName=mFilename + ""String_Node_Str"";
  final File file=new File(mContext.getFilesDir(),mFilename);
  final File tempFile=new File(mContext.getFilesDir(),tempFileName);
  FileOutputStream out=null;
  try {
    out=new FileOutputStream(tempFile);
    BinaryDictInputOutput.writeDictionaryBinary(out,mFusionDictionary,1);
    out.flush();
    out.close();
    tempFile.renameTo(file);
    clearFusionDictionary();
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
catch (  UnsupportedFormatException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException e) {
      }
    }
  }
}","/** 
 * Generates and writes a new binary dictionary based on the contents of the fusion dictionary.
 */
private void generateBinaryDictionary(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mFilename + ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateRequestTime+ ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
  loadDictionaryAsync();
  final String tempFileName=mFilename + ""String_Node_Str"";
  final File file=new File(mContext.getFilesDir(),mFilename);
  final File tempFile=new File(mContext.getFilesDir(),tempFileName);
  FileOutputStream out=null;
  try {
    out=new FileOutputStream(tempFile);
    BinaryDictInputOutput.writeDictionaryBinary(out,mFusionDictionary,1);
    out.flush();
    out.close();
    tempFile.renameTo(file);
    clearFusionDictionary();
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
catch (  UnsupportedFormatException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException e) {
      }
    }
  }
}",0.985060690943044
87955,"@Override protected boolean hasContentChanged(){
  final long startTime=SystemClock.uptimeMillis();
  final int contactCount=getContactCount();
  if (contactCount > MAX_CONTACT_COUNT) {
    return false;
  }
  if (contactCount != sContactCountAtLastRebuild) {
    return true;
  }
  Cursor cursor=mContext.getContentResolver().query(Contacts.CONTENT_URI,PROJECTION,null,null,null);
  if (cursor != null) {
    try {
      if (cursor.moveToFirst()) {
        while (!cursor.isAfterLast()) {
          String name=cursor.getString(INDEX_NAME);
          if (isValidName(name) && !isNameInDictionary(name)) {
            if (DEBUG) {
              Log.d(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ (SystemClock.uptimeMillis() - startTime)+ ""String_Node_Str"");
            }
            return true;
          }
          cursor.moveToNext();
        }
      }
    }
  finally {
      cursor.close();
    }
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - startTime) + ""String_Node_Str"");
  }
  return false;
}","@Override protected boolean hasContentChanged(){
  final long startTime=SystemClock.uptimeMillis();
  final int contactCount=getContactCount();
  if (contactCount > MAX_CONTACT_COUNT) {
    return false;
  }
  if (contactCount != sContactCountAtLastRebuild) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + sContactCountAtLastRebuild + ""String_Node_Str""+ contactCount);
    }
    return true;
  }
  Cursor cursor=mContext.getContentResolver().query(Contacts.CONTENT_URI,PROJECTION,null,null,null);
  if (cursor != null) {
    try {
      if (cursor.moveToFirst()) {
        while (!cursor.isAfterLast()) {
          String name=cursor.getString(INDEX_NAME);
          if (isValidName(name) && !isNameInDictionary(name)) {
            if (DEBUG) {
              Log.d(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ (SystemClock.uptimeMillis() - startTime)+ ""String_Node_Str"");
            }
            return true;
          }
          cursor.moveToNext();
        }
      }
    }
  finally {
      cursor.close();
    }
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - startTime) + ""String_Node_Str"");
  }
  return false;
}",0.9448961156278228
87956,"/** 
 * Loads the current binary dictionary from internal storage. Assumes the dictionary file exists.
 */
protected void loadBinaryDictionary(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mSharedDictionaryController.mLastUpdateRequestTime + ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
  final File file=new File(mContext.getFilesDir(),mFilename);
  final String filename=file.getAbsolutePath();
  final long length=file.length();
  final BinaryDictionary newBinaryDictionary=new BinaryDictionary(mContext,filename,0,length,true,null);
  if (mBinaryDictionary != null) {
    final BinaryDictionary oldBinaryDictionary=mBinaryDictionary;
    mLocalDictionaryController.lock();
    mBinaryDictionary=newBinaryDictionary;
    mLocalDictionaryController.unlock();
    oldBinaryDictionary.close();
  }
 else {
    mBinaryDictionary=newBinaryDictionary;
  }
}","/** 
 * Loads the current binary dictionary from internal storage. Assumes the dictionary file exists.
 */
protected void loadBinaryDictionary(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mFilename + ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateRequestTime+ ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
  final File file=new File(mContext.getFilesDir(),mFilename);
  final String filename=file.getAbsolutePath();
  final long length=file.length();
  final BinaryDictionary newBinaryDictionary=new BinaryDictionary(mContext,filename,0,length,true,null);
  if (mBinaryDictionary != null) {
    final BinaryDictionary oldBinaryDictionary=mBinaryDictionary;
    mLocalDictionaryController.lock();
    mBinaryDictionary=newBinaryDictionary;
    mLocalDictionaryController.unlock();
    oldBinaryDictionary.close();
  }
 else {
    mBinaryDictionary=newBinaryDictionary;
  }
}",0.982202447163515
87957,"@Override public void run(){
  syncReloadDictionaryIfRequired();
}","@Override public void run(){
  syncReloadDictionaryInternal();
}",0.9076923076923076
87958,"/** 
 * Reloads the dictionary if required. Reload will occur asynchronously in a separate thread.
 */
void asyncReloadDictionaryIfRequired(){
  new AsyncReloadDictionaryTask().start();
}","/** 
 * Reloads the dictionary if required. Reload will occur asynchronously in a separate thread.
 */
void asyncReloadDictionaryIfRequired(){
  if (!isReloadRequired())   return;
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mFilename);
  }
  new AsyncReloadDictionaryTask().start();
}",0.7857142857142857
87959,"/** 
 * Marks that the dictionary is out of date and requires a reload.
 * @param requiresRebuild Indicates that the source dictionary content has changed and a rebuildof the binary file is required. If not true, the next reload process will only read the current binary dictionary from file.
 */
protected void setRequiresReload(final boolean requiresRebuild){
  final long time=SystemClock.uptimeMillis();
  mLocalDictionaryController.mLastUpdateRequestTime=time;
  mSharedDictionaryController.mLastUpdateRequestTime=time;
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + time + ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
}","/** 
 * Marks that the dictionary is out of date and requires a reload.
 * @param requiresRebuild Indicates that the source dictionary content has changed and a rebuildof the binary file is required. If not true, the next reload process will only read the current binary dictionary from file.
 */
protected void setRequiresReload(final boolean requiresRebuild){
  final long time=SystemClock.uptimeMillis();
  mLocalDictionaryController.mLastUpdateRequestTime=time;
  mSharedDictionaryController.mLastUpdateRequestTime=time;
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mFilename + ""String_Node_Str""+ time+ ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
}",0.9744744744744744
87960,"/** 
 * Reloads the dictionary if required. Access is controlled on a per dictionary file basis and supports concurrent calls from multiple instances that share the same dictionary file.
 */
protected final void syncReloadDictionaryIfRequired(){
  if (mBinaryDictionary != null && !mLocalDictionaryController.isOutOfDate()) {
    return;
  }
  mSharedDictionaryController.lock();
  try {
    final long time=SystemClock.uptimeMillis();
    if (mSharedDictionaryController.isOutOfDate() || !dictionaryFileExists()) {
      if (hasContentChanged()) {
        mSharedDictionaryController.mLastUpdateTime=time;
        generateBinaryDictionary();
        loadBinaryDictionary();
      }
 else {
        mSharedDictionaryController.mLastUpdateRequestTime=mSharedDictionaryController.mLastUpdateTime;
      }
    }
 else     if (mBinaryDictionary == null || mLocalDictionaryController.mLastUpdateTime < mSharedDictionaryController.mLastUpdateTime) {
      loadBinaryDictionary();
    }
    mLocalDictionaryController.mLastUpdateTime=time;
  }
  finally {
    mSharedDictionaryController.unlock();
  }
}","/** 
 * Reloads the dictionary if required.
 */
protected final void syncReloadDictionaryIfRequired(){
  if (!isReloadRequired())   return;
  syncReloadDictionaryInternal();
}",0.2391817466561762
87961,"/** 
 * Generates and writes a new binary dictionary based on the contents of the fusion dictionary.
 */
private void generateBinaryDictionary(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mSharedDictionaryController.mLastUpdateRequestTime + ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
  loadDictionaryAsync();
  final String tempFileName=mFilename + ""String_Node_Str"";
  final File file=new File(mContext.getFilesDir(),mFilename);
  final File tempFile=new File(mContext.getFilesDir(),tempFileName);
  FileOutputStream out=null;
  try {
    out=new FileOutputStream(tempFile);
    BinaryDictInputOutput.writeDictionaryBinary(out,mFusionDictionary,1);
    out.flush();
    out.close();
    tempFile.renameTo(file);
    clearFusionDictionary();
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
catch (  UnsupportedFormatException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException e) {
      }
    }
  }
}","/** 
 * Generates and writes a new binary dictionary based on the contents of the fusion dictionary.
 */
private void generateBinaryDictionary(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mFilename + ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateRequestTime+ ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
  loadDictionaryAsync();
  final String tempFileName=mFilename + ""String_Node_Str"";
  final File file=new File(mContext.getFilesDir(),mFilename);
  final File tempFile=new File(mContext.getFilesDir(),tempFileName);
  FileOutputStream out=null;
  try {
    out=new FileOutputStream(tempFile);
    BinaryDictInputOutput.writeDictionaryBinary(out,mFusionDictionary,1);
    out.flush();
    out.close();
    tempFile.renameTo(file);
    clearFusionDictionary();
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
catch (  UnsupportedFormatException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException e) {
      }
    }
  }
}",0.985060690943044
87962,"@Override protected boolean hasContentChanged(){
  final long startTime=SystemClock.uptimeMillis();
  final int contactCount=getContactCount();
  if (contactCount > MAX_CONTACT_COUNT) {
    return false;
  }
  if (contactCount != sContactCountAtLastRebuild) {
    return true;
  }
  Cursor cursor=mContext.getContentResolver().query(Contacts.CONTENT_URI,PROJECTION,null,null,null);
  if (cursor != null) {
    try {
      if (cursor.moveToFirst()) {
        while (!cursor.isAfterLast()) {
          String name=cursor.getString(INDEX_NAME);
          if (isValidName(name) && !isNameInDictionary(name)) {
            if (DEBUG) {
              Log.d(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ (SystemClock.uptimeMillis() - startTime)+ ""String_Node_Str"");
            }
            return true;
          }
          cursor.moveToNext();
        }
      }
    }
  finally {
      cursor.close();
    }
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - startTime) + ""String_Node_Str"");
  }
  return false;
}","@Override protected boolean hasContentChanged(){
  final long startTime=SystemClock.uptimeMillis();
  final int contactCount=getContactCount();
  if (contactCount > MAX_CONTACT_COUNT) {
    return false;
  }
  if (contactCount != sContactCountAtLastRebuild) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + sContactCountAtLastRebuild + ""String_Node_Str""+ contactCount);
    }
    return true;
  }
  Cursor cursor=mContext.getContentResolver().query(Contacts.CONTENT_URI,PROJECTION,null,null,null);
  if (cursor != null) {
    try {
      if (cursor.moveToFirst()) {
        while (!cursor.isAfterLast()) {
          String name=cursor.getString(INDEX_NAME);
          if (isValidName(name) && !isNameInDictionary(name)) {
            if (DEBUG) {
              Log.d(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ (SystemClock.uptimeMillis() - startTime)+ ""String_Node_Str"");
            }
            return true;
          }
          cursor.moveToNext();
        }
      }
    }
  finally {
      cursor.close();
    }
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + (SystemClock.uptimeMillis() - startTime) + ""String_Node_Str"");
  }
  return false;
}",0.9448961156278228
87963,"/** 
 * Loads the current binary dictionary from internal storage. Assumes the dictionary file exists.
 */
protected void loadBinaryDictionary(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mSharedDictionaryController.mLastUpdateRequestTime + ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
  final File file=new File(mContext.getFilesDir(),mFilename);
  final String filename=file.getAbsolutePath();
  final long length=file.length();
  final BinaryDictionary newBinaryDictionary=new BinaryDictionary(mContext,filename,0,length,true,null);
  if (mBinaryDictionary != null) {
    final BinaryDictionary oldBinaryDictionary=mBinaryDictionary;
    mLocalDictionaryController.lock();
    mBinaryDictionary=newBinaryDictionary;
    mLocalDictionaryController.unlock();
    oldBinaryDictionary.close();
  }
 else {
    mBinaryDictionary=newBinaryDictionary;
  }
}","/** 
 * Loads the current binary dictionary from internal storage. Assumes the dictionary file exists.
 */
protected void loadBinaryDictionary(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mFilename + ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateRequestTime+ ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
  final File file=new File(mContext.getFilesDir(),mFilename);
  final String filename=file.getAbsolutePath();
  final long length=file.length();
  final BinaryDictionary newBinaryDictionary=new BinaryDictionary(mContext,filename,0,length,true,null);
  if (mBinaryDictionary != null) {
    final BinaryDictionary oldBinaryDictionary=mBinaryDictionary;
    mLocalDictionaryController.lock();
    mBinaryDictionary=newBinaryDictionary;
    mLocalDictionaryController.unlock();
    oldBinaryDictionary.close();
  }
 else {
    mBinaryDictionary=newBinaryDictionary;
  }
}",0.982202447163515
87964,"@Override public void run(){
  syncReloadDictionaryIfRequired();
}","@Override public void run(){
  syncReloadDictionaryInternal();
}",0.9076923076923076
87965,"/** 
 * Reloads the dictionary if required. Reload will occur asynchronously in a separate thread.
 */
void asyncReloadDictionaryIfRequired(){
  new AsyncReloadDictionaryTask().start();
}","/** 
 * Reloads the dictionary if required. Reload will occur asynchronously in a separate thread.
 */
void asyncReloadDictionaryIfRequired(){
  if (!isReloadRequired())   return;
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mFilename);
  }
  new AsyncReloadDictionaryTask().start();
}",0.7857142857142857
87966,"/** 
 * Marks that the dictionary is out of date and requires a reload.
 * @param requiresRebuild Indicates that the source dictionary content has changed and a rebuildof the binary file is required. If not true, the next reload process will only read the current binary dictionary from file.
 */
protected void setRequiresReload(final boolean requiresRebuild){
  final long time=SystemClock.uptimeMillis();
  mLocalDictionaryController.mLastUpdateRequestTime=time;
  mSharedDictionaryController.mLastUpdateRequestTime=time;
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + time + ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
}","/** 
 * Marks that the dictionary is out of date and requires a reload.
 * @param requiresRebuild Indicates that the source dictionary content has changed and a rebuildof the binary file is required. If not true, the next reload process will only read the current binary dictionary from file.
 */
protected void setRequiresReload(final boolean requiresRebuild){
  final long time=SystemClock.uptimeMillis();
  mLocalDictionaryController.mLastUpdateRequestTime=time;
  mSharedDictionaryController.mLastUpdateRequestTime=time;
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mFilename + ""String_Node_Str""+ time+ ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
}",0.9744744744744744
87967,"/** 
 * Reloads the dictionary if required. Access is controlled on a per dictionary file basis and supports concurrent calls from multiple instances that share the same dictionary file.
 */
protected final void syncReloadDictionaryIfRequired(){
  if (mBinaryDictionary != null && !mLocalDictionaryController.isOutOfDate()) {
    return;
  }
  mSharedDictionaryController.lock();
  try {
    final long time=SystemClock.uptimeMillis();
    if (mSharedDictionaryController.isOutOfDate() || !dictionaryFileExists()) {
      if (hasContentChanged()) {
        mSharedDictionaryController.mLastUpdateTime=time;
        generateBinaryDictionary();
        loadBinaryDictionary();
      }
 else {
        mSharedDictionaryController.mLastUpdateRequestTime=mSharedDictionaryController.mLastUpdateTime;
      }
    }
 else     if (mBinaryDictionary == null || mLocalDictionaryController.mLastUpdateTime < mSharedDictionaryController.mLastUpdateTime) {
      loadBinaryDictionary();
    }
    mLocalDictionaryController.mLastUpdateTime=time;
  }
  finally {
    mSharedDictionaryController.unlock();
  }
}","/** 
 * Reloads the dictionary if required.
 */
protected final void syncReloadDictionaryIfRequired(){
  if (!isReloadRequired())   return;
  syncReloadDictionaryInternal();
}",0.2391817466561762
87968,"/** 
 * Generates and writes a new binary dictionary based on the contents of the fusion dictionary.
 */
private void generateBinaryDictionary(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mSharedDictionaryController.mLastUpdateRequestTime + ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
  loadDictionaryAsync();
  final String tempFileName=mFilename + ""String_Node_Str"";
  final File file=new File(mContext.getFilesDir(),mFilename);
  final File tempFile=new File(mContext.getFilesDir(),tempFileName);
  FileOutputStream out=null;
  try {
    out=new FileOutputStream(tempFile);
    BinaryDictInputOutput.writeDictionaryBinary(out,mFusionDictionary,1);
    out.flush();
    out.close();
    tempFile.renameTo(file);
    clearFusionDictionary();
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
catch (  UnsupportedFormatException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException e) {
      }
    }
  }
}","/** 
 * Generates and writes a new binary dictionary based on the contents of the fusion dictionary.
 */
private void generateBinaryDictionary(){
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + mFilename + ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateRequestTime+ ""String_Node_Str""+ mSharedDictionaryController.mLastUpdateTime);
  }
  loadDictionaryAsync();
  final String tempFileName=mFilename + ""String_Node_Str"";
  final File file=new File(mContext.getFilesDir(),mFilename);
  final File tempFile=new File(mContext.getFilesDir(),tempFileName);
  FileOutputStream out=null;
  try {
    out=new FileOutputStream(tempFile);
    BinaryDictInputOutput.writeDictionaryBinary(out,mFusionDictionary,1);
    out.flush();
    out.close();
    tempFile.renameTo(file);
    clearFusionDictionary();
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
catch (  UnsupportedFormatException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException e) {
      }
    }
  }
}",0.985060690943044
87969,"private static boolean hasAutoCorrectionForConsideredWord(HashMap<String,Dictionary> dictionaries,WordComposer wordComposer,ArrayList<SuggestedWordInfo> suggestions,CharSequence consideredWord){
  if (TextUtils.isEmpty(consideredWord))   return false;
  return wordComposer.size() > 1 && suggestions.size() > 0 && !allowsToBeAutoCorrected(dictionaries,consideredWord,false);
}","private static boolean hasAutoCorrectionForConsideredWord(final ConcurrentHashMap<String,Dictionary> dictionaries,final WordComposer wordComposer,final ArrayList<SuggestedWordInfo> suggestions,final CharSequence consideredWord){
  if (TextUtils.isEmpty(consideredWord))   return false;
  return wordComposer.size() > 1 && suggestions.size() > 0 && !allowsToBeAutoCorrected(dictionaries,consideredWord,false);
}",0.9567430025445292
87970,"public static boolean allowsToBeAutoCorrected(HashMap<String,Dictionary> dictionaries,CharSequence word,boolean ignoreCase){
  final WhitelistDictionary whitelistDictionary=(WhitelistDictionary)dictionaries.get(Suggest.DICT_KEY_WHITELIST);
  if (whitelistDictionary != null && whitelistDictionary.shouldForciblyAutoCorrectFrom(word)) {
    return true;
  }
  return !isValidWord(dictionaries,word,ignoreCase);
}","public static boolean allowsToBeAutoCorrected(final ConcurrentHashMap<String,Dictionary> dictionaries,final CharSequence word,final boolean ignoreCase){
  final WhitelistDictionary whitelistDictionary=(WhitelistDictionary)dictionaries.get(Suggest.DICT_KEY_WHITELIST);
  if (whitelistDictionary != null && whitelistDictionary.shouldForciblyAutoCorrectFrom(word)) {
    return true;
  }
  return !isValidWord(dictionaries,word,ignoreCase);
}",0.9670588235294116
87971,"public static CharSequence computeAutoCorrectionWord(HashMap<String,Dictionary> dictionaries,WordComposer wordComposer,ArrayList<SuggestedWordInfo> suggestions,CharSequence consideredWord,float autoCorrectionThreshold,CharSequence whitelistedWord){
  if (hasAutoCorrectionForWhitelistedWord(whitelistedWord)) {
    return whitelistedWord;
  }
 else   if (hasAutoCorrectionForConsideredWord(dictionaries,wordComposer,suggestions,consideredWord)) {
    return consideredWord;
  }
 else   if (hasAutoCorrectionForBinaryDictionary(wordComposer,suggestions,consideredWord,autoCorrectionThreshold)) {
    return suggestions.get(0).mWord;
  }
  return null;
}","public static CharSequence computeAutoCorrectionWord(final ConcurrentHashMap<String,Dictionary> dictionaries,final WordComposer wordComposer,final ArrayList<SuggestedWordInfo> suggestions,final CharSequence consideredWord,final float autoCorrectionThreshold,final CharSequence whitelistedWord){
  if (hasAutoCorrectionForWhitelistedWord(whitelistedWord)) {
    return whitelistedWord;
  }
 else   if (hasAutoCorrectionForConsideredWord(dictionaries,wordComposer,suggestions,consideredWord)) {
    return consideredWord;
  }
 else   if (hasAutoCorrectionForBinaryDictionary(wordComposer,suggestions,consideredWord,autoCorrectionThreshold)) {
    return suggestions.get(0).mWord;
  }
  return null;
}",0.965925925925926
87972,"public static boolean isValidWord(HashMap<String,Dictionary> dictionaries,CharSequence word,boolean ignoreCase){
  if (TextUtils.isEmpty(word)) {
    return false;
  }
  final CharSequence lowerCasedWord=word.toString().toLowerCase();
  for (  final String key : dictionaries.keySet()) {
    if (key.equals(Suggest.DICT_KEY_WHITELIST))     continue;
    final Dictionary dictionary=dictionaries.get(key);
    if (null == dictionary)     continue;
    if (dictionary.isValidWord(word) || (ignoreCase && dictionary.isValidWord(lowerCasedWord))) {
      return true;
    }
  }
  return false;
}","public static boolean isValidWord(final ConcurrentHashMap<String,Dictionary> dictionaries,CharSequence word,boolean ignoreCase){
  if (TextUtils.isEmpty(word)) {
    return false;
  }
  final CharSequence lowerCasedWord=word.toString().toLowerCase();
  for (  final String key : dictionaries.keySet()) {
    if (key.equals(Suggest.DICT_KEY_WHITELIST))     continue;
    final Dictionary dictionary=dictionaries.get(key);
    if (null == dictionary)     continue;
    if (dictionary.isValidWord(word) || (ignoreCase && dictionary.isValidWord(lowerCasedWord))) {
      return true;
    }
  }
  return false;
}",0.986644407345576
87973,"private static void addOrReplaceDictionary(HashMap<String,Dictionary> dictionaries,String key,Dictionary dict){
  final Dictionary oldDict=(dict == null) ? dictionaries.remove(key) : dictionaries.put(key,dict);
  if (oldDict != null && dict != oldDict) {
    oldDict.close();
  }
}","private static void addOrReplaceDictionary(final ConcurrentHashMap<String,Dictionary> dictionaries,final String key,final Dictionary dict){
  final Dictionary oldDict=(dict == null) ? dictionaries.remove(key) : dictionaries.put(key,dict);
  if (oldDict != null && dict != oldDict) {
    oldDict.close();
  }
}",0.952542372881356
87974,"public HashMap<String,Dictionary> getUnigramDictionaries(){
  return mUnigramDictionaries;
}","public ConcurrentHashMap<String,Dictionary> getUnigramDictionaries(){
  return mUnigramDictionaries;
}",0.9484536082474226
87975,"private static boolean hasAutoCorrectionForConsideredWord(HashMap<String,Dictionary> dictionaries,WordComposer wordComposer,ArrayList<SuggestedWordInfo> suggestions,CharSequence consideredWord){
  if (TextUtils.isEmpty(consideredWord))   return false;
  return wordComposer.size() > 1 && suggestions.size() > 0 && !allowsToBeAutoCorrected(dictionaries,consideredWord,false);
}","private static boolean hasAutoCorrectionForConsideredWord(final ConcurrentHashMap<String,Dictionary> dictionaries,final WordComposer wordComposer,final ArrayList<SuggestedWordInfo> suggestions,final CharSequence consideredWord){
  if (TextUtils.isEmpty(consideredWord))   return false;
  return wordComposer.size() > 1 && suggestions.size() > 0 && !allowsToBeAutoCorrected(dictionaries,consideredWord,false);
}",0.9567430025445292
87976,"public static boolean allowsToBeAutoCorrected(HashMap<String,Dictionary> dictionaries,CharSequence word,boolean ignoreCase){
  final WhitelistDictionary whitelistDictionary=(WhitelistDictionary)dictionaries.get(Suggest.DICT_KEY_WHITELIST);
  if (whitelistDictionary != null && whitelistDictionary.shouldForciblyAutoCorrectFrom(word)) {
    return true;
  }
  return !isValidWord(dictionaries,word,ignoreCase);
}","public static boolean allowsToBeAutoCorrected(final ConcurrentHashMap<String,Dictionary> dictionaries,final CharSequence word,final boolean ignoreCase){
  final WhitelistDictionary whitelistDictionary=(WhitelistDictionary)dictionaries.get(Suggest.DICT_KEY_WHITELIST);
  if (whitelistDictionary != null && whitelistDictionary.shouldForciblyAutoCorrectFrom(word)) {
    return true;
  }
  return !isValidWord(dictionaries,word,ignoreCase);
}",0.9670588235294116
87977,"public static CharSequence computeAutoCorrectionWord(HashMap<String,Dictionary> dictionaries,WordComposer wordComposer,ArrayList<SuggestedWordInfo> suggestions,CharSequence consideredWord,float autoCorrectionThreshold,CharSequence whitelistedWord){
  if (hasAutoCorrectionForWhitelistedWord(whitelistedWord)) {
    return whitelistedWord;
  }
 else   if (hasAutoCorrectionForConsideredWord(dictionaries,wordComposer,suggestions,consideredWord)) {
    return consideredWord;
  }
 else   if (hasAutoCorrectionForBinaryDictionary(wordComposer,suggestions,consideredWord,autoCorrectionThreshold)) {
    return suggestions.get(0).mWord;
  }
  return null;
}","public static CharSequence computeAutoCorrectionWord(final ConcurrentHashMap<String,Dictionary> dictionaries,final WordComposer wordComposer,final ArrayList<SuggestedWordInfo> suggestions,final CharSequence consideredWord,final float autoCorrectionThreshold,final CharSequence whitelistedWord){
  if (hasAutoCorrectionForWhitelistedWord(whitelistedWord)) {
    return whitelistedWord;
  }
 else   if (hasAutoCorrectionForConsideredWord(dictionaries,wordComposer,suggestions,consideredWord)) {
    return consideredWord;
  }
 else   if (hasAutoCorrectionForBinaryDictionary(wordComposer,suggestions,consideredWord,autoCorrectionThreshold)) {
    return suggestions.get(0).mWord;
  }
  return null;
}",0.965925925925926
87978,"public static boolean isValidWord(HashMap<String,Dictionary> dictionaries,CharSequence word,boolean ignoreCase){
  if (TextUtils.isEmpty(word)) {
    return false;
  }
  final CharSequence lowerCasedWord=word.toString().toLowerCase();
  for (  final String key : dictionaries.keySet()) {
    if (key.equals(Suggest.DICT_KEY_WHITELIST))     continue;
    final Dictionary dictionary=dictionaries.get(key);
    if (null == dictionary)     continue;
    if (dictionary.isValidWord(word) || (ignoreCase && dictionary.isValidWord(lowerCasedWord))) {
      return true;
    }
  }
  return false;
}","public static boolean isValidWord(final ConcurrentHashMap<String,Dictionary> dictionaries,CharSequence word,boolean ignoreCase){
  if (TextUtils.isEmpty(word)) {
    return false;
  }
  final CharSequence lowerCasedWord=word.toString().toLowerCase();
  for (  final String key : dictionaries.keySet()) {
    if (key.equals(Suggest.DICT_KEY_WHITELIST))     continue;
    final Dictionary dictionary=dictionaries.get(key);
    if (null == dictionary)     continue;
    if (dictionary.isValidWord(word) || (ignoreCase && dictionary.isValidWord(lowerCasedWord))) {
      return true;
    }
  }
  return false;
}",0.986644407345576
87979,"private static void addOrReplaceDictionary(HashMap<String,Dictionary> dictionaries,String key,Dictionary dict){
  final Dictionary oldDict=(dict == null) ? dictionaries.remove(key) : dictionaries.put(key,dict);
  if (oldDict != null && dict != oldDict) {
    oldDict.close();
  }
}","private static void addOrReplaceDictionary(final ConcurrentHashMap<String,Dictionary> dictionaries,final String key,final Dictionary dict){
  final Dictionary oldDict=(dict == null) ? dictionaries.remove(key) : dictionaries.put(key,dict);
  if (oldDict != null && dict != oldDict) {
    oldDict.close();
  }
}",0.952542372881356
87980,"public HashMap<String,Dictionary> getUnigramDictionaries(){
  return mUnigramDictionaries;
}","public ConcurrentHashMap<String,Dictionary> getUnigramDictionaries(){
  return mUnigramDictionaries;
}",0.9484536082474226
87981,"private static boolean hasAutoCorrectionForConsideredWord(HashMap<String,Dictionary> dictionaries,WordComposer wordComposer,ArrayList<SuggestedWordInfo> suggestions,CharSequence consideredWord){
  if (TextUtils.isEmpty(consideredWord))   return false;
  return wordComposer.size() > 1 && suggestions.size() > 0 && !allowsToBeAutoCorrected(dictionaries,consideredWord,false);
}","private static boolean hasAutoCorrectionForConsideredWord(final ConcurrentHashMap<String,Dictionary> dictionaries,final WordComposer wordComposer,final ArrayList<SuggestedWordInfo> suggestions,final CharSequence consideredWord){
  if (TextUtils.isEmpty(consideredWord))   return false;
  return wordComposer.size() > 1 && suggestions.size() > 0 && !allowsToBeAutoCorrected(dictionaries,consideredWord,false);
}",0.9567430025445292
87982,"public static boolean allowsToBeAutoCorrected(HashMap<String,Dictionary> dictionaries,CharSequence word,boolean ignoreCase){
  final WhitelistDictionary whitelistDictionary=(WhitelistDictionary)dictionaries.get(Suggest.DICT_KEY_WHITELIST);
  if (whitelistDictionary != null && whitelistDictionary.shouldForciblyAutoCorrectFrom(word)) {
    return true;
  }
  return !isValidWord(dictionaries,word,ignoreCase);
}","public static boolean allowsToBeAutoCorrected(final ConcurrentHashMap<String,Dictionary> dictionaries,final CharSequence word,final boolean ignoreCase){
  final WhitelistDictionary whitelistDictionary=(WhitelistDictionary)dictionaries.get(Suggest.DICT_KEY_WHITELIST);
  if (whitelistDictionary != null && whitelistDictionary.shouldForciblyAutoCorrectFrom(word)) {
    return true;
  }
  return !isValidWord(dictionaries,word,ignoreCase);
}",0.9670588235294116
87983,"public static CharSequence computeAutoCorrectionWord(HashMap<String,Dictionary> dictionaries,WordComposer wordComposer,ArrayList<SuggestedWordInfo> suggestions,CharSequence consideredWord,float autoCorrectionThreshold,CharSequence whitelistedWord){
  if (hasAutoCorrectionForWhitelistedWord(whitelistedWord)) {
    return whitelistedWord;
  }
 else   if (hasAutoCorrectionForConsideredWord(dictionaries,wordComposer,suggestions,consideredWord)) {
    return consideredWord;
  }
 else   if (hasAutoCorrectionForBinaryDictionary(wordComposer,suggestions,consideredWord,autoCorrectionThreshold)) {
    return suggestions.get(0).mWord;
  }
  return null;
}","public static CharSequence computeAutoCorrectionWord(final ConcurrentHashMap<String,Dictionary> dictionaries,final WordComposer wordComposer,final ArrayList<SuggestedWordInfo> suggestions,final CharSequence consideredWord,final float autoCorrectionThreshold,final CharSequence whitelistedWord){
  if (hasAutoCorrectionForWhitelistedWord(whitelistedWord)) {
    return whitelistedWord;
  }
 else   if (hasAutoCorrectionForConsideredWord(dictionaries,wordComposer,suggestions,consideredWord)) {
    return consideredWord;
  }
 else   if (hasAutoCorrectionForBinaryDictionary(wordComposer,suggestions,consideredWord,autoCorrectionThreshold)) {
    return suggestions.get(0).mWord;
  }
  return null;
}",0.965925925925926
87984,"public static boolean isValidWord(HashMap<String,Dictionary> dictionaries,CharSequence word,boolean ignoreCase){
  if (TextUtils.isEmpty(word)) {
    return false;
  }
  final CharSequence lowerCasedWord=word.toString().toLowerCase();
  for (  final String key : dictionaries.keySet()) {
    if (key.equals(Suggest.DICT_KEY_WHITELIST))     continue;
    final Dictionary dictionary=dictionaries.get(key);
    if (null == dictionary)     continue;
    if (dictionary.isValidWord(word) || (ignoreCase && dictionary.isValidWord(lowerCasedWord))) {
      return true;
    }
  }
  return false;
}","public static boolean isValidWord(final ConcurrentHashMap<String,Dictionary> dictionaries,CharSequence word,boolean ignoreCase){
  if (TextUtils.isEmpty(word)) {
    return false;
  }
  final CharSequence lowerCasedWord=word.toString().toLowerCase();
  for (  final String key : dictionaries.keySet()) {
    if (key.equals(Suggest.DICT_KEY_WHITELIST))     continue;
    final Dictionary dictionary=dictionaries.get(key);
    if (null == dictionary)     continue;
    if (dictionary.isValidWord(word) || (ignoreCase && dictionary.isValidWord(lowerCasedWord))) {
      return true;
    }
  }
  return false;
}",0.986644407345576
87985,"private static void addOrReplaceDictionary(HashMap<String,Dictionary> dictionaries,String key,Dictionary dict){
  final Dictionary oldDict=(dict == null) ? dictionaries.remove(key) : dictionaries.put(key,dict);
  if (oldDict != null && dict != oldDict) {
    oldDict.close();
  }
}","private static void addOrReplaceDictionary(final ConcurrentHashMap<String,Dictionary> dictionaries,final String key,final Dictionary dict){
  final Dictionary oldDict=(dict == null) ? dictionaries.remove(key) : dictionaries.put(key,dict);
  if (oldDict != null && dict != oldDict) {
    oldDict.close();
  }
}",0.952542372881356
87986,"public HashMap<String,Dictionary> getUnigramDictionaries(){
  return mUnigramDictionaries;
}","public ConcurrentHashMap<String,Dictionary> getUnigramDictionaries(){
  return mUnigramDictionaries;
}",0.9484536082474226
87987,"private static boolean hasAutoCorrectionForConsideredWord(HashMap<String,Dictionary> dictionaries,WordComposer wordComposer,ArrayList<SuggestedWordInfo> suggestions,CharSequence consideredWord){
  if (TextUtils.isEmpty(consideredWord))   return false;
  return wordComposer.size() > 1 && suggestions.size() > 0 && !allowsToBeAutoCorrected(dictionaries,consideredWord,false);
}","private static boolean hasAutoCorrectionForConsideredWord(final ConcurrentHashMap<String,Dictionary> dictionaries,final WordComposer wordComposer,final ArrayList<SuggestedWordInfo> suggestions,final CharSequence consideredWord){
  if (TextUtils.isEmpty(consideredWord))   return false;
  return wordComposer.size() > 1 && suggestions.size() > 0 && !allowsToBeAutoCorrected(dictionaries,consideredWord,false);
}",0.9567430025445292
87988,"public static boolean allowsToBeAutoCorrected(HashMap<String,Dictionary> dictionaries,CharSequence word,boolean ignoreCase){
  final WhitelistDictionary whitelistDictionary=(WhitelistDictionary)dictionaries.get(Suggest.DICT_KEY_WHITELIST);
  if (whitelistDictionary != null && whitelistDictionary.shouldForciblyAutoCorrectFrom(word)) {
    return true;
  }
  return !isValidWord(dictionaries,word,ignoreCase);
}","public static boolean allowsToBeAutoCorrected(final ConcurrentHashMap<String,Dictionary> dictionaries,final CharSequence word,final boolean ignoreCase){
  final WhitelistDictionary whitelistDictionary=(WhitelistDictionary)dictionaries.get(Suggest.DICT_KEY_WHITELIST);
  if (whitelistDictionary != null && whitelistDictionary.shouldForciblyAutoCorrectFrom(word)) {
    return true;
  }
  return !isValidWord(dictionaries,word,ignoreCase);
}",0.9670588235294116
87989,"public static CharSequence computeAutoCorrectionWord(HashMap<String,Dictionary> dictionaries,WordComposer wordComposer,ArrayList<SuggestedWordInfo> suggestions,CharSequence consideredWord,float autoCorrectionThreshold,CharSequence whitelistedWord){
  if (hasAutoCorrectionForWhitelistedWord(whitelistedWord)) {
    return whitelistedWord;
  }
 else   if (hasAutoCorrectionForConsideredWord(dictionaries,wordComposer,suggestions,consideredWord)) {
    return consideredWord;
  }
 else   if (hasAutoCorrectionForBinaryDictionary(wordComposer,suggestions,consideredWord,autoCorrectionThreshold)) {
    return suggestions.get(0).mWord;
  }
  return null;
}","public static CharSequence computeAutoCorrectionWord(final ConcurrentHashMap<String,Dictionary> dictionaries,final WordComposer wordComposer,final ArrayList<SuggestedWordInfo> suggestions,final CharSequence consideredWord,final float autoCorrectionThreshold,final CharSequence whitelistedWord){
  if (hasAutoCorrectionForWhitelistedWord(whitelistedWord)) {
    return whitelistedWord;
  }
 else   if (hasAutoCorrectionForConsideredWord(dictionaries,wordComposer,suggestions,consideredWord)) {
    return consideredWord;
  }
 else   if (hasAutoCorrectionForBinaryDictionary(wordComposer,suggestions,consideredWord,autoCorrectionThreshold)) {
    return suggestions.get(0).mWord;
  }
  return null;
}",0.965925925925926
87990,"public static boolean isValidWord(HashMap<String,Dictionary> dictionaries,CharSequence word,boolean ignoreCase){
  if (TextUtils.isEmpty(word)) {
    return false;
  }
  final CharSequence lowerCasedWord=word.toString().toLowerCase();
  for (  final String key : dictionaries.keySet()) {
    if (key.equals(Suggest.DICT_KEY_WHITELIST))     continue;
    final Dictionary dictionary=dictionaries.get(key);
    if (null == dictionary)     continue;
    if (dictionary.isValidWord(word) || (ignoreCase && dictionary.isValidWord(lowerCasedWord))) {
      return true;
    }
  }
  return false;
}","public static boolean isValidWord(final ConcurrentHashMap<String,Dictionary> dictionaries,CharSequence word,boolean ignoreCase){
  if (TextUtils.isEmpty(word)) {
    return false;
  }
  final CharSequence lowerCasedWord=word.toString().toLowerCase();
  for (  final String key : dictionaries.keySet()) {
    if (key.equals(Suggest.DICT_KEY_WHITELIST))     continue;
    final Dictionary dictionary=dictionaries.get(key);
    if (null == dictionary)     continue;
    if (dictionary.isValidWord(word) || (ignoreCase && dictionary.isValidWord(lowerCasedWord))) {
      return true;
    }
  }
  return false;
}",0.986644407345576
87991,"private static void addOrReplaceDictionary(HashMap<String,Dictionary> dictionaries,String key,Dictionary dict){
  final Dictionary oldDict=(dict == null) ? dictionaries.remove(key) : dictionaries.put(key,dict);
  if (oldDict != null && dict != oldDict) {
    oldDict.close();
  }
}","private static void addOrReplaceDictionary(final ConcurrentHashMap<String,Dictionary> dictionaries,final String key,final Dictionary dict){
  final Dictionary oldDict=(dict == null) ? dictionaries.remove(key) : dictionaries.put(key,dict);
  if (oldDict != null && dict != oldDict) {
    oldDict.close();
  }
}",0.952542372881356
87992,"public HashMap<String,Dictionary> getUnigramDictionaries(){
  return mUnigramDictionaries;
}","public ConcurrentHashMap<String,Dictionary> getUnigramDictionaries(){
  return mUnigramDictionaries;
}",0.9484536082474226
87993,"/** 
 * Compute the addresses and sizes of an ordered node array. This method takes a node array and will update its cached address and size values so that they can be written into a file. It determines the smallest size each of the nodes can be given the addresses of its children and attributes, and store that into each node. The order of the node is given by the order of the array. This method makes no effort to find a good order; it only mechanically computes the size this order results in.
 * @param dict the dictionary
 * @param flatNodes the ordered array of nodes
 * @return the same array it was passed. The nodes have been updated for address and size.
 */
private static ArrayList<Node> computeAddresses(FusionDictionary dict,ArrayList<Node> flatNodes){
  for (  Node n : flatNodes)   setNodeMaximumSize(n);
  final int offset=stackNodes(flatNodes);
  MakedictLog.i(""String_Node_Str"" + offset);
  MakedictLog.i(""String_Node_Str"" + offset + ""String_Node_Str"");
  int passes=0;
  boolean changesDone=false;
  do {
    changesDone=false;
    for (    Node n : flatNodes) {
      final int oldNodeSize=n.mCachedSize;
      computeActualNodeSize(n,dict);
      final int newNodeSize=n.mCachedSize;
      if (oldNodeSize < newNodeSize)       throw new RuntimeException(""String_Node_Str"");
      if (oldNodeSize != newNodeSize)       changesDone=true;
    }
    stackNodes(flatNodes);
    ++passes;
  }
 while (changesDone);
  final Node lastNode=flatNodes.get(flatNodes.size() - 1);
  MakedictLog.i(""String_Node_Str"" + passes + ""String_Node_Str"");
  MakedictLog.i(""String_Node_Str"" + (lastNode.mCachedAddress + lastNode.mCachedSize));
  return flatNodes;
}","/** 
 * Compute the addresses and sizes of an ordered node array. This method takes a node array and will update its cached address and size values so that they can be written into a file. It determines the smallest size each of the nodes can be given the addresses of its children and attributes, and store that into each node. The order of the node is given by the order of the array. This method makes no effort to find a good order; it only mechanically computes the size this order results in.
 * @param dict the dictionary
 * @param flatNodes the ordered array of nodes
 * @return the same array it was passed. The nodes have been updated for address and size.
 */
private static ArrayList<Node> computeAddresses(FusionDictionary dict,ArrayList<Node> flatNodes){
  for (  Node n : flatNodes)   setNodeMaximumSize(n);
  final int offset=stackNodes(flatNodes);
  MakedictLog.i(""String_Node_Str"" + offset);
  MakedictLog.i(""String_Node_Str"" + offset + ""String_Node_Str"");
  int passes=0;
  boolean changesDone=false;
  do {
    changesDone=false;
    for (    Node n : flatNodes) {
      final int oldNodeSize=n.mCachedSize;
      final boolean changed=computeActualNodeSize(n,dict);
      final int newNodeSize=n.mCachedSize;
      if (oldNodeSize < newNodeSize)       throw new RuntimeException(""String_Node_Str"");
      changesDone|=changed;
    }
    stackNodes(flatNodes);
    ++passes;
    if (passes > MAX_PASSES)     throw new RuntimeException(""String_Node_Str"");
  }
 while (changesDone);
  final Node lastNode=flatNodes.get(flatNodes.size() - 1);
  MakedictLog.i(""String_Node_Str"" + passes + ""String_Node_Str"");
  MakedictLog.i(""String_Node_Str"" + (lastNode.mCachedAddress + lastNode.mCachedSize));
  return flatNodes;
}",0.9487934078869924
87994,"/** 
 * Computes the actual node size, based on the cached addresses of the children nodes. Each node stores its tentative address. During dictionary address computing, these are not final, but they can be used to compute the node size (the node size depends on the address of the children because the number of bytes necessary to store an address depends on its numeric value.
 * @param node the node to compute the size of.
 * @param dict the dictionary in which the word/attributes are to be found.
 */
private static void computeActualNodeSize(Node node,FusionDictionary dict){
  int size=getGroupCountSize(node);
  for (  CharGroup group : node.mData) {
    int groupSize=GROUP_FLAGS_SIZE + getGroupCharactersSize(group);
    if (group.isTerminal())     groupSize+=GROUP_FREQUENCY_SIZE;
    if (null != group.mChildren) {
      final int offsetBasePoint=groupSize + node.mCachedAddress + size;
      final int offset=group.mChildren.mCachedAddress - offsetBasePoint;
      groupSize+=getByteSize(offset);
    }
    groupSize+=getShortcutListSize(group.mShortcutTargets);
    if (null != group.mBigrams) {
      for (      WeightedString bigram : group.mBigrams) {
        final int offsetBasePoint=groupSize + node.mCachedAddress + size+ GROUP_FLAGS_SIZE;
        final int addressOfBigram=findAddressOfWord(dict,bigram.mWord);
        final int offset=addressOfBigram - offsetBasePoint;
        groupSize+=getByteSize(offset) + GROUP_FLAGS_SIZE;
      }
    }
    group.mCachedSize=groupSize;
    size+=groupSize;
  }
  node.mCachedSize=size;
}","/** 
 * Computes the actual node size, based on the cached addresses of the children nodes. Each node stores its tentative address. During dictionary address computing, these are not final, but they can be used to compute the node size (the node size depends on the address of the children because the number of bytes necessary to store an address depends on its numeric value. The return value indicates whether the node contents (as in, any of the addresses stored in the cache fields) have changed with respect to their previous value.
 * @param node the node to compute the size of.
 * @param dict the dictionary in which the word/attributes are to be found.
 * @return false if none of the cached addresses inside the node changed, true otherwise.
 */
private static boolean computeActualNodeSize(Node node,FusionDictionary dict){
  boolean changed=false;
  int size=getGroupCountSize(node);
  for (  CharGroup group : node.mData) {
    if (group.mCachedAddress != node.mCachedAddress + size) {
      changed=true;
      group.mCachedAddress=node.mCachedAddress + size;
    }
    int groupSize=GROUP_FLAGS_SIZE + getGroupCharactersSize(group);
    if (group.isTerminal())     groupSize+=GROUP_FREQUENCY_SIZE;
    if (null != group.mChildren) {
      final int offsetBasePoint=groupSize + node.mCachedAddress + size;
      final int offset=group.mChildren.mCachedAddress - offsetBasePoint;
      groupSize+=getByteSize(offset);
    }
    groupSize+=getShortcutListSize(group.mShortcutTargets);
    if (null != group.mBigrams) {
      for (      WeightedString bigram : group.mBigrams) {
        final int offsetBasePoint=groupSize + node.mCachedAddress + size+ GROUP_FLAGS_SIZE;
        final int addressOfBigram=findAddressOfWord(dict,bigram.mWord);
        final int offset=addressOfBigram - offsetBasePoint;
        groupSize+=getByteSize(offset) + GROUP_FLAGS_SIZE;
      }
    }
    group.mCachedSize=groupSize;
    size+=groupSize;
  }
  if (node.mCachedSize != size) {
    node.mCachedSize=size;
    changed=true;
  }
  return changed;
}",0.8593663146192329
87995,"/** 
 * Compute the addresses and sizes of an ordered node array. This method takes a node array and will update its cached address and size values so that they can be written into a file. It determines the smallest size each of the nodes can be given the addresses of its children and attributes, and store that into each node. The order of the node is given by the order of the array. This method makes no effort to find a good order; it only mechanically computes the size this order results in.
 * @param dict the dictionary
 * @param flatNodes the ordered array of nodes
 * @return the same array it was passed. The nodes have been updated for address and size.
 */
private static ArrayList<Node> computeAddresses(FusionDictionary dict,ArrayList<Node> flatNodes){
  for (  Node n : flatNodes)   setNodeMaximumSize(n);
  final int offset=stackNodes(flatNodes);
  MakedictLog.i(""String_Node_Str"" + offset);
  MakedictLog.i(""String_Node_Str"" + offset + ""String_Node_Str"");
  int passes=0;
  boolean changesDone=false;
  do {
    changesDone=false;
    for (    Node n : flatNodes) {
      final int oldNodeSize=n.mCachedSize;
      computeActualNodeSize(n,dict);
      final int newNodeSize=n.mCachedSize;
      if (oldNodeSize < newNodeSize)       throw new RuntimeException(""String_Node_Str"");
      if (oldNodeSize != newNodeSize)       changesDone=true;
    }
    stackNodes(flatNodes);
    ++passes;
  }
 while (changesDone);
  final Node lastNode=flatNodes.get(flatNodes.size() - 1);
  MakedictLog.i(""String_Node_Str"" + passes + ""String_Node_Str"");
  MakedictLog.i(""String_Node_Str"" + (lastNode.mCachedAddress + lastNode.mCachedSize));
  return flatNodes;
}","/** 
 * Compute the addresses and sizes of an ordered node array. This method takes a node array and will update its cached address and size values so that they can be written into a file. It determines the smallest size each of the nodes can be given the addresses of its children and attributes, and store that into each node. The order of the node is given by the order of the array. This method makes no effort to find a good order; it only mechanically computes the size this order results in.
 * @param dict the dictionary
 * @param flatNodes the ordered array of nodes
 * @return the same array it was passed. The nodes have been updated for address and size.
 */
private static ArrayList<Node> computeAddresses(FusionDictionary dict,ArrayList<Node> flatNodes){
  for (  Node n : flatNodes)   setNodeMaximumSize(n);
  final int offset=stackNodes(flatNodes);
  MakedictLog.i(""String_Node_Str"" + offset);
  MakedictLog.i(""String_Node_Str"" + offset + ""String_Node_Str"");
  int passes=0;
  boolean changesDone=false;
  do {
    changesDone=false;
    for (    Node n : flatNodes) {
      final int oldNodeSize=n.mCachedSize;
      final boolean changed=computeActualNodeSize(n,dict);
      final int newNodeSize=n.mCachedSize;
      if (oldNodeSize < newNodeSize)       throw new RuntimeException(""String_Node_Str"");
      changesDone|=changed;
    }
    stackNodes(flatNodes);
    ++passes;
    if (passes > MAX_PASSES)     throw new RuntimeException(""String_Node_Str"");
  }
 while (changesDone);
  final Node lastNode=flatNodes.get(flatNodes.size() - 1);
  MakedictLog.i(""String_Node_Str"" + passes + ""String_Node_Str"");
  MakedictLog.i(""String_Node_Str"" + (lastNode.mCachedAddress + lastNode.mCachedSize));
  return flatNodes;
}",0.9487934078869924
87996,"/** 
 * Computes the actual node size, based on the cached addresses of the children nodes. Each node stores its tentative address. During dictionary address computing, these are not final, but they can be used to compute the node size (the node size depends on the address of the children because the number of bytes necessary to store an address depends on its numeric value.
 * @param node the node to compute the size of.
 * @param dict the dictionary in which the word/attributes are to be found.
 */
private static void computeActualNodeSize(Node node,FusionDictionary dict){
  int size=getGroupCountSize(node);
  for (  CharGroup group : node.mData) {
    int groupSize=GROUP_FLAGS_SIZE + getGroupCharactersSize(group);
    if (group.isTerminal())     groupSize+=GROUP_FREQUENCY_SIZE;
    if (null != group.mChildren) {
      final int offsetBasePoint=groupSize + node.mCachedAddress + size;
      final int offset=group.mChildren.mCachedAddress - offsetBasePoint;
      groupSize+=getByteSize(offset);
    }
    groupSize+=getShortcutListSize(group.mShortcutTargets);
    if (null != group.mBigrams) {
      for (      WeightedString bigram : group.mBigrams) {
        final int offsetBasePoint=groupSize + node.mCachedAddress + size+ GROUP_FLAGS_SIZE;
        final int addressOfBigram=findAddressOfWord(dict,bigram.mWord);
        final int offset=addressOfBigram - offsetBasePoint;
        groupSize+=getByteSize(offset) + GROUP_FLAGS_SIZE;
      }
    }
    group.mCachedSize=groupSize;
    size+=groupSize;
  }
  node.mCachedSize=size;
}","/** 
 * Computes the actual node size, based on the cached addresses of the children nodes. Each node stores its tentative address. During dictionary address computing, these are not final, but they can be used to compute the node size (the node size depends on the address of the children because the number of bytes necessary to store an address depends on its numeric value. The return value indicates whether the node contents (as in, any of the addresses stored in the cache fields) have changed with respect to their previous value.
 * @param node the node to compute the size of.
 * @param dict the dictionary in which the word/attributes are to be found.
 * @return false if none of the cached addresses inside the node changed, true otherwise.
 */
private static boolean computeActualNodeSize(Node node,FusionDictionary dict){
  boolean changed=false;
  int size=getGroupCountSize(node);
  for (  CharGroup group : node.mData) {
    if (group.mCachedAddress != node.mCachedAddress + size) {
      changed=true;
      group.mCachedAddress=node.mCachedAddress + size;
    }
    int groupSize=GROUP_FLAGS_SIZE + getGroupCharactersSize(group);
    if (group.isTerminal())     groupSize+=GROUP_FREQUENCY_SIZE;
    if (null != group.mChildren) {
      final int offsetBasePoint=groupSize + node.mCachedAddress + size;
      final int offset=group.mChildren.mCachedAddress - offsetBasePoint;
      groupSize+=getByteSize(offset);
    }
    groupSize+=getShortcutListSize(group.mShortcutTargets);
    if (null != group.mBigrams) {
      for (      WeightedString bigram : group.mBigrams) {
        final int offsetBasePoint=groupSize + node.mCachedAddress + size+ GROUP_FLAGS_SIZE;
        final int addressOfBigram=findAddressOfWord(dict,bigram.mWord);
        final int offset=addressOfBigram - offsetBasePoint;
        groupSize+=getByteSize(offset) + GROUP_FLAGS_SIZE;
      }
    }
    group.mCachedSize=groupSize;
    size+=groupSize;
  }
  if (node.mCachedSize != size) {
    node.mCachedSize=size;
    changed=true;
  }
  return changed;
}",0.8593663146192329
87997,"@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,int x,int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mSettingsValues.isWeakSpaceStripper(firstChar)) && (!mSettingsValues.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mInputAttributes.mApplicationSpecifiedCompletionOn && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    final InputConnection ic=getCurrentInputConnection();
    if (ic != null) {
      final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
      ic.commitCompletion(completionInfo);
      if (ProductionFlag.IS_EXPERIMENTAL) {
        ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
      }
    }
    return;
  }
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mLastComposedWord.deactivate();
  addToUserHistoryDictionary(suggestion);
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (!showingAddToDictionaryHint) {
    updateBigramPredictions();
  }
 else {
    if (mIsUserDictionaryAvailable) {
      mSuggestionsView.showAddToDictionaryHint(suggestion,mSettingsValues.mHintToSaveText);
    }
 else {
      mHandler.postUpdateSuggestions();
    }
  }
}","@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,int x,int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  final InputConnection ic=getCurrentInputConnection();
  if (ic != null)   ic.beginBatchEdit();
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mSettingsValues.isWeakSpaceStripper(firstChar)) && (!mSettingsValues.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mInputAttributes.mApplicationSpecifiedCompletionOn && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    if (ic != null) {
      final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
      ic.commitCompletion(completionInfo);
      if (ProductionFlag.IS_EXPERIMENTAL) {
        ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
      }
    }
    return;
  }
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mLastComposedWord.deactivate();
  addToUserHistoryDictionary(suggestion);
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (!showingAddToDictionaryHint) {
    updateBigramPredictions();
  }
 else {
    if (mIsUserDictionaryAvailable) {
      mSuggestionsView.showAddToDictionaryHint(suggestion,mSettingsValues.mHintToSaveText);
    }
 else {
      mHandler.postUpdateSuggestions();
    }
  }
  if (null != ic)   ic.endBatchEdit();
}",0.966166724799442
87998,"@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,int x,int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mSettingsValues.isWeakSpaceStripper(firstChar)) && (!mSettingsValues.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mInputAttributes.mApplicationSpecifiedCompletionOn && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    final InputConnection ic=getCurrentInputConnection();
    if (ic != null) {
      final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
      ic.commitCompletion(completionInfo);
      if (ProductionFlag.IS_EXPERIMENTAL) {
        ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
      }
    }
    return;
  }
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mLastComposedWord.deactivate();
  addToUserHistoryDictionary(suggestion);
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (!showingAddToDictionaryHint) {
    updateBigramPredictions();
  }
 else {
    if (mIsUserDictionaryAvailable) {
      mSuggestionsView.showAddToDictionaryHint(suggestion,mSettingsValues.mHintToSaveText);
    }
 else {
      mHandler.postUpdateSuggestions();
    }
  }
}","@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,int x,int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  final InputConnection ic=getCurrentInputConnection();
  if (ic != null)   ic.beginBatchEdit();
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mSettingsValues.isWeakSpaceStripper(firstChar)) && (!mSettingsValues.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mInputAttributes.mApplicationSpecifiedCompletionOn && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    if (ic != null) {
      final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
      ic.commitCompletion(completionInfo);
      if (ProductionFlag.IS_EXPERIMENTAL) {
        ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
      }
    }
    return;
  }
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mLastComposedWord.deactivate();
  addToUserHistoryDictionary(suggestion);
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (!showingAddToDictionaryHint) {
    updateBigramPredictions();
  }
 else {
    if (mIsUserDictionaryAvailable) {
      mSuggestionsView.showAddToDictionaryHint(suggestion,mSettingsValues.mHintToSaveText);
    }
 else {
      mHandler.postUpdateSuggestions();
    }
  }
  if (null != ic)   ic.endBatchEdit();
}",0.966166724799442
87999,"@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,int x,int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  final InputConnection ic=getCurrentInputConnection();
  if (ic != null)   ic.beginBatchEdit();
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mSettingsValues.isWeakSpaceStripper(firstChar)) && (!mSettingsValues.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mInputAttributes.mApplicationSpecifiedCompletionOn && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    if (ic != null) {
      final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
      ic.commitCompletion(completionInfo);
      if (ProductionFlag.IS_EXPERIMENTAL) {
        ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
      }
    }
    return;
  }
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mLastComposedWord.deactivate();
  addToUserHistoryDictionary(suggestion);
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (!showingAddToDictionaryHint) {
    updateBigramPredictions();
  }
 else {
    if (mIsUserDictionaryAvailable) {
      mSuggestionsView.showAddToDictionaryHint(suggestion,mSettingsValues.mHintToSaveText);
    }
 else {
      mHandler.postUpdateSuggestions();
    }
  }
  if (null != ic)   ic.endBatchEdit();
}","@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,int x,int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  final InputConnection ic=getCurrentInputConnection();
  if (ic != null)   ic.beginBatchEdit();
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mSettingsValues.isWeakSpaceStripper(firstChar)) && (!mSettingsValues.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mInputAttributes.mApplicationSpecifiedCompletionOn && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    if (ic != null) {
      final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
      ic.commitCompletion(completionInfo);
      if (ProductionFlag.IS_EXPERIMENTAL) {
        ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
      }
    }
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mLastComposedWord.deactivate();
  addToUserHistoryDictionary(suggestion);
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (!showingAddToDictionaryHint) {
    updateBigramPredictions();
  }
 else {
    if (mIsUserDictionaryAvailable) {
      mSuggestionsView.showAddToDictionaryHint(suggestion,mSettingsValues.mHintToSaveText);
    }
 else {
      mHandler.postUpdateSuggestions();
    }
  }
  if (null != ic)   ic.endBatchEdit();
}",0.6779077770130764
88000,"@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,int x,int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  final InputConnection ic=getCurrentInputConnection();
  if (ic != null)   ic.beginBatchEdit();
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mSettingsValues.isWeakSpaceStripper(firstChar)) && (!mSettingsValues.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mInputAttributes.mApplicationSpecifiedCompletionOn && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    if (ic != null) {
      final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
      ic.commitCompletion(completionInfo);
      if (ProductionFlag.IS_EXPERIMENTAL) {
        ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
      }
    }
    return;
  }
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mLastComposedWord.deactivate();
  addToUserHistoryDictionary(suggestion);
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (!showingAddToDictionaryHint) {
    updateBigramPredictions();
  }
 else {
    if (mIsUserDictionaryAvailable) {
      mSuggestionsView.showAddToDictionaryHint(suggestion,mSettingsValues.mHintToSaveText);
    }
 else {
      mHandler.postUpdateSuggestions();
    }
  }
  if (null != ic)   ic.endBatchEdit();
}","@Override public void pickSuggestionManually(final int index,final CharSequence suggestion,int x,int y){
  final SuggestedWords suggestedWords=mSuggestionsView.getSuggestions();
  final InputConnection ic=getCurrentInputConnection();
  if (ic != null)   ic.beginBatchEdit();
  if (suggestion.length() == 1 && isShowingPunctuationList()) {
    LatinImeLogger.logOnManualSuggestion(""String_Node_Str"",suggestion.toString(),index,suggestedWords);
    if (ProductionFlag.IS_EXPERIMENTAL) {
      ResearchLogger.latinIME_punctuationSuggestion(index,suggestion,x,y);
    }
    final int primaryCode=suggestion.charAt(0);
    onCodeInput(primaryCode,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE,KeyboardActionListener.SUGGESTION_STRIP_COORDINATE);
    return;
  }
  if (SPACE_STATE_PHANTOM == mSpaceState && suggestion.length() > 0) {
    int firstChar=Character.codePointAt(suggestion,0);
    if ((!mSettingsValues.isWeakSpaceStripper(firstChar)) && (!mSettingsValues.isWeakSpaceSwapper(firstChar))) {
      sendKeyCodePoint(Keyboard.CODE_SPACE);
    }
  }
  if (mInputAttributes.mApplicationSpecifiedCompletionOn && mApplicationSpecifiedCompletions != null && index >= 0 && index < mApplicationSpecifiedCompletions.length) {
    if (mSuggestionsView != null) {
      mSuggestionsView.clear();
    }
    mKeyboardSwitcher.updateShiftState();
    resetComposingState(true);
    if (ic != null) {
      final CompletionInfo completionInfo=mApplicationSpecifiedCompletions[index];
      ic.commitCompletion(completionInfo);
      if (ProductionFlag.IS_EXPERIMENTAL) {
        ResearchLogger.latinIME_pickApplicationSpecifiedCompletion(index,completionInfo.getText(),x,y);
      }
    }
    return;
  }
  final String replacedWord=mWordComposer.getTypedWord().toString();
  LatinImeLogger.logOnManualSuggestion(replacedWord,suggestion.toString(),index,suggestedWords);
  if (ProductionFlag.IS_EXPERIMENTAL) {
    ResearchLogger.latinIME_pickSuggestionManually(replacedWord,index,suggestion,x,y);
  }
  mExpectingUpdateSelection=true;
  commitChosenWord(suggestion,LastComposedWord.COMMIT_TYPE_MANUAL_PICK,LastComposedWord.NOT_A_SEPARATOR);
  mLastComposedWord.deactivate();
  addToUserHistoryDictionary(suggestion);
  mSpaceState=SPACE_STATE_PHANTOM;
  mKeyboardSwitcher.updateShiftState();
  final boolean showingAddToDictionaryHint=index == 0 && mSuggest != null && (!mSuggest.hasMainDictionary() || !AutoCorrection.isValidWord(mSuggest.getUnigramDictionaries(),suggestion,true));
  Utils.Stats.onSeparator((char)Keyboard.CODE_SPACE,WordComposer.NOT_A_COORDINATE,WordComposer.NOT_A_COORDINATE);
  if (!showingAddToDictionaryHint) {
    updateBigramPredictions();
  }
 else {
    if (mIsUserDictionaryAvailable) {
      mSuggestionsView.showAddToDictionaryHint(suggestion,mSettingsValues.mHintToSaveText);
    }
 else {
      mHandler.postUpdateSuggestions();
    }
  }
  if (null != ic)   ic.endBatchEdit();
}",0.6779077770130764
