record_number,buggy_code,fixed_code,code_similarity
52001,"@Override public int doOffsetQuery(String column,String value,boolean isAscending) throws BrowseException {
  DiscoverQuery query=new DiscoverQuery();
  addLocationScopeFilter(query);
  addStatusFilter(query);
  query.setMaxResults(0);
  query.addFilterQueries(""String_Node_Str"" + Constants.ITEM);
  if (isAscending) {
    query.setQuery(""String_Node_Str"" + column + ""String_Node_Str""+ ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
 else {
    query.setQuery(""String_Node_Str"" + column + ""String_Node_Str""+ ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
  boolean includeUnDiscoverable=itemsWithdrawn || !itemsDiscoverable;
  DiscoverResult resp=null;
  try {
    resp=searcher.search(context,query,includeUnDiscoverable);
  }
 catch (  SearchServiceException e) {
    throw new BrowseException(e);
  }
  return (int)resp.getTotalSearchResults();
}","@Override public int doOffsetQuery(String column,String value,boolean isAscending) throws BrowseException {
  DiscoverQuery query=new DiscoverQuery();
  addLocationScopeFilter(query);
  addStatusFilter(query);
  query.setMaxResults(0);
  query.addFilterQueries(""String_Node_Str"" + Constants.ITEM);
  if (authority != null) {
    query.addFilterQueries(""String_Node_Str"" + facetField + ""String_Node_Str""+ authority);
  }
 else   if (this.value != null && !valuePartial) {
    query.addFilterQueries(""String_Node_Str"" + facetField + ""String_Node_Str""+ this.value);
  }
 else   if (valuePartial) {
    query.addFilterQueries(""String_Node_Str"" + facetField + ""String_Node_Str""+ this.value);
  }
  if (isAscending) {
    query.setQuery(""String_Node_Str"" + column + ""String_Node_Str""+ ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
 else {
    query.setQuery(""String_Node_Str"" + column + ""String_Node_Str""+ ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
  boolean includeUnDiscoverable=itemsWithdrawn || !itemsDiscoverable;
  DiscoverResult resp=null;
  try {
    resp=searcher.search(context,query,includeUnDiscoverable);
  }
 catch (  SearchServiceException e) {
    throw new BrowseException(e);
  }
  return (int)resp.getTotalSearchResults();
}",0.8131241084165478
52002,"/** 
 * is the field is defined as authority controlled
 */
private static boolean isAuthorityControlledField(String md){
  int pos=md.indexOf(""String_Node_Str"");
  String mdf=(pos > -1 ? md.substring(0,pos) : md);
  pos=md.indexOf(""String_Node_Str"");
  mdf=(pos > -1 ? md.substring(pos + 1) : md);
  return authorityControlled.contains(mdf);
}","/** 
 * is the field is defined as authority controlled
 */
private static boolean isAuthorityControlledField(String md){
  String mdf=StringUtils.substringAfter(md,""String_Node_Str"");
  mdf=StringUtils.substringBefore(mdf,""String_Node_Str"");
  return authorityControlled.contains(mdf);
}",0.7215189873417721
52003,"public static Date parse(String date){
  SimpleDateFormat format=new SimpleDateFormat(""String_Node_Str"",Locale.getDefault());
  Date ret;
  try {
    ret=format.parse(date);
    return ret;
  }
 catch (  ParseException e) {
    format=new SimpleDateFormat(""String_Node_Str"",Locale.getDefault());
    try {
      return format.parse(date);
    }
 catch (    ParseException e1) {
      format=new SimpleDateFormat(""String_Node_Str"",Locale.getDefault());
      try {
        return format.parse(date);
      }
 catch (      ParseException e2) {
        format=new SimpleDateFormat(""String_Node_Str"",Locale.getDefault());
        try {
          return format.parse(date);
        }
 catch (        ParseException e3) {
          format=new SimpleDateFormat(""String_Node_Str"",Locale.getDefault());
          try {
            return format.parse(date);
          }
 catch (          ParseException e4) {
            log.error(e4.getMessage(),e);
          }
        }
      }
    }
  }
  return new Date();
}","public static Date parse(String date){
  SimpleDateFormat format=new SimpleDateFormat(""String_Node_Str"");
  format.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  Date ret;
  try {
    ret=format.parse(date);
    return ret;
  }
 catch (  ParseException ex) {
    format=new SimpleDateFormat(""String_Node_Str"",Locale.getDefault());
    try {
      return format.parse(date);
    }
 catch (    ParseException e) {
      format=new SimpleDateFormat(""String_Node_Str"",Locale.getDefault());
      try {
        return format.parse(date);
      }
 catch (      ParseException e1) {
        format=new SimpleDateFormat(""String_Node_Str"",Locale.getDefault());
        try {
          return format.parse(date);
        }
 catch (        ParseException e2) {
          format=new SimpleDateFormat(""String_Node_Str"",Locale.getDefault());
          try {
            return format.parse(date);
          }
 catch (          ParseException e3) {
            format=new SimpleDateFormat(""String_Node_Str"",Locale.getDefault());
            try {
              return format.parse(date);
            }
 catch (            ParseException e4) {
              log.error(e4.getMessage(),e);
            }
          }
        }
      }
    }
  }
  return new Date();
}",0.8518354710305175
52004,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String handle=null;
  String extraPathInfo=null;
  DSpaceObject dso=null;
  String path=request.getPathInfo();
  if (path != null) {
    path=path.substring(1);
    try {
      int firstSlash=path.indexOf('/');
      int secondSlash=path.indexOf('/',firstSlash + 1);
      if (secondSlash != -1) {
        handle=path.substring(0,secondSlash);
        extraPathInfo=path.substring(secondSlash);
      }
 else {
        handle=path;
      }
    }
 catch (    NumberFormatException nfe) {
    }
  }
  if (handle != null) {
    dso=HandleManager.resolveToObject(context,handle);
  }
  if (dso == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + path));
    JSPManager.showInvalidIDError(request,response,StringEscapeUtils.escapeHtml(path),-1);
    return;
  }
  if (""String_Node_Str"".equals(extraPathInfo)) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + handle + ""String_Node_Str""+ extraPathInfo));
    request.setAttribute(""String_Node_Str"",handle);
    RequestDispatcher dispatch=getServletContext().getNamedDispatcher(""String_Node_Str"");
    dispatch.forward(request,response);
    return;
  }
  if (dso.getType() == Constants.ITEM) {
    if ((extraPathInfo == null) || (extraPathInfo.equals(""String_Node_Str""))) {
      Item item=(Item)dso;
      if (context.getCurrentUser() == null) {
        response.setDateHeader(""String_Node_Str"",item.getLastModified().getTime());
        long modSince=request.getDateHeader(""String_Node_Str"");
        if (modSince != -1 && item.getLastModified().getTime() < modSince) {
          response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        }
 else {
          displayItem(context,request,response,item,handle);
        }
      }
 else {
        displayItem(context,request,response,item,handle);
      }
    }
 else {
      request.getRequestDispatcher(extraPathInfo).forward(request,response);
    }
  }
 else   if (dso.getType() == Constants.COLLECTION) {
    Collection c=(Collection)dso;
    request.setAttribute(""String_Node_Str"",c);
    Community[] parents=c.getCommunities();
    request.setAttribute(""String_Node_Str"",parents[0]);
    request.setAttribute(""String_Node_Str"",getParents(parents[0],true));
    if ((extraPathInfo == null) || (extraPathInfo.equals(""String_Node_Str""))) {
      collectionHome(context,request,response,parents[0],c);
    }
 else {
      request.getRequestDispatcher(extraPathInfo).forward(request,response);
    }
  }
 else   if (dso.getType() == Constants.COMMUNITY) {
    Community c=(Community)dso;
    request.setAttribute(""String_Node_Str"",c);
    request.setAttribute(""String_Node_Str"",getParents(c,false));
    if ((extraPathInfo == null) || (extraPathInfo.equals(""String_Node_Str""))) {
      communityHome(context,request,response,c);
    }
 else {
      request.getRequestDispatcher(extraPathInfo).forward(request,response);
    }
  }
 else {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + handle));
    JSPManager.showInvalidIDError(request,response,StringEscapeUtils.escapeHtml(path),-1);
    return;
  }
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String handle=null;
  String extraPathInfo=null;
  DSpaceObject dso=null;
  String path=request.getPathInfo();
  if (path != null) {
    path=path.substring(1);
    try {
      int firstSlash=path.indexOf('/');
      int secondSlash=path.indexOf('/',firstSlash + 1);
      if (secondSlash != -1) {
        handle=path.substring(0,secondSlash);
        extraPathInfo=path.substring(secondSlash);
      }
 else {
        handle=path;
      }
    }
 catch (    NumberFormatException nfe) {
    }
  }
  if (handle != null) {
    dso=HandleManager.resolveToObject(context,handle);
  }
  if (dso == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + path));
    JSPManager.showInvalidIDError(request,response,StringEscapeUtils.escapeHtml(path),-1);
    return;
  }
  if (""String_Node_Str"".equals(extraPathInfo)) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + handle + ""String_Node_Str""+ extraPathInfo));
    request.setAttribute(""String_Node_Str"",handle);
    RequestDispatcher dispatch=getServletContext().getNamedDispatcher(""String_Node_Str"");
    dispatch.forward(request,response);
    return;
  }
 else   if (""String_Node_Str"".equals(extraPathInfo)) {
    request.getRequestDispatcher(extraPathInfo).forward(request,response);
    return;
  }
 else   if (""String_Node_Str"".equals((extraPathInfo)) || StringUtils.startsWith(extraPathInfo,""String_Node_Str"")) {
    request.getRequestDispatcher(extraPathInfo).forward(request,response);
    return;
  }
 else   if (""String_Node_Str"".equals(extraPathInfo) || StringUtils.startsWith(extraPathInfo,""String_Node_Str"")) {
    request.getRequestDispatcher(extraPathInfo).forward(request,response);
    return;
  }
  if (dso.getType() == Constants.ITEM) {
    if ((extraPathInfo == null) || (extraPathInfo.equals(""String_Node_Str""))) {
      Item item=(Item)dso;
      if (context.getCurrentUser() == null) {
        response.setDateHeader(""String_Node_Str"",item.getLastModified().getTime());
        long modSince=request.getDateHeader(""String_Node_Str"");
        if (modSince != -1 && item.getLastModified().getTime() < modSince) {
          response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        }
 else {
          displayItem(context,request,response,item,handle);
        }
      }
 else {
        displayItem(context,request,response,item,handle);
      }
    }
 else {
      log.debug(""String_Node_Str"");
      JSPManager.showInvalidIDError(request,response,StringEscapeUtils.escapeHtml(path),-1);
      return;
    }
  }
 else   if (dso.getType() == Constants.COLLECTION) {
    Collection c=(Collection)dso;
    request.setAttribute(""String_Node_Str"",c);
    Community[] parents=c.getCommunities();
    request.setAttribute(""String_Node_Str"",parents[0]);
    request.setAttribute(""String_Node_Str"",getParents(parents[0],true));
    if ((extraPathInfo == null) || (extraPathInfo.equals(""String_Node_Str""))) {
      collectionHome(context,request,response,parents[0],c);
    }
 else {
      log.debug(""String_Node_Str"");
      JSPManager.showInvalidIDError(request,response,StringEscapeUtils.escapeHtml(path),-1);
      return;
    }
  }
 else   if (dso.getType() == Constants.COMMUNITY) {
    Community c=(Community)dso;
    request.setAttribute(""String_Node_Str"",c);
    request.setAttribute(""String_Node_Str"",getParents(c,false));
    if ((extraPathInfo == null) || (extraPathInfo.equals(""String_Node_Str""))) {
      communityHome(context,request,response,c);
    }
 else {
      log.debug(""String_Node_Str"");
      JSPManager.showInvalidIDError(request,response,StringEscapeUtils.escapeHtml(path),-1);
      return;
    }
  }
 else {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + handle));
    JSPManager.showInvalidIDError(request,response,StringEscapeUtils.escapeHtml(path),-1);
    return;
  }
}",0.8162428219852338
52005,"/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    String authority=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int offset=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (StringUtils.isNotEmpty(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (type == null && bi == null) {
      if (sortBy > 0) {
        bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
      }
 else {
        bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
      }
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso.equals(so)) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (offset < 0) {
      offset=0;
    }
    if (bi != null && resultsperpage < 0 && !bi.isTagCloudEnabled()) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
        if (""String_Node_Str"".equals(order)) {
          startsWith=startsWith + ""String_Node_Str"";
        }
      }
    }
    int level=0;
    if (value != null || authority != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getHandle();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getHandle();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value != null ? value : authority);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setOffset(offset);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    scope.setAuthorityValue(authority);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi != null && bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}","/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    try {
      if (StringUtils.isNotBlank(month) && !""String_Node_Str"".equals(month)) {
        Integer.valueOf(month);
      }
      if (StringUtils.isNotBlank(year) && !""String_Node_Str"".equals(year)) {
        Integer.valueOf(year);
      }
      if (StringUtils.isNotBlank(startsWith)) {
        startsWith=Utils.addEntities(startsWith);
      }
    }
 catch (    Exception ex) {
      log.warn(""String_Node_Str"");
      return null;
    }
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    String authority=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int offset=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (StringUtils.isNotEmpty(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (type == null && bi == null) {
      if (sortBy > 0) {
        bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
      }
 else {
        bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
      }
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso.equals(so)) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (offset < 0) {
      offset=0;
    }
    if (bi != null && resultsperpage < 0 && !bi.isTagCloudEnabled()) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
        if (""String_Node_Str"".equals(order)) {
          startsWith=startsWith + ""String_Node_Str"";
        }
      }
    }
    int level=0;
    if (value != null || authority != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getHandle();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getHandle();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value != null ? value : authority);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setOffset(offset);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    scope.setAuthorityValue(authority);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi != null && bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}",0.9614284476033632
52006,"/** 
 * Do the usual DSpace GET method.  You will notice that browse does not currently respond to POST requests.
 */
protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  BrowserScope scope=getBrowserScopeForRequest(context,request,response);
  if (scope.getBrowseIndex() == null) {
    String requestURL=request.getRequestURI();
    if (request.getQueryString() != null) {
      requestURL+=""String_Node_Str"" + request.getQueryString();
    }
    log.warn(""String_Node_Str"" + requestURL);
    response.sendError(HttpServletResponse.SC_BAD_REQUEST);
    return;
  }
  if (""String_Node_Str"".equals(UIUtil.getSubmitButton(request,""String_Node_Str""))) {
    exportMetadata(context,request,response,scope);
  }
 else {
    processBrowse(context,scope,request,response);
  }
}","/** 
 * Do the usual DSpace GET method.  You will notice that browse does not currently respond to POST requests.
 */
protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  BrowserScope scope=getBrowserScopeForRequest(context,request,response);
  if (scope == null || scope.getBrowseIndex() == null) {
    String requestURL=request.getRequestURI();
    if (request.getQueryString() != null) {
      requestURL+=""String_Node_Str"" + request.getQueryString();
    }
    log.warn(""String_Node_Str"" + requestURL);
    response.sendError(HttpServletResponse.SC_BAD_REQUEST);
    return;
  }
  if (""String_Node_Str"".equals(UIUtil.getSubmitButton(request,""String_Node_Str""))) {
    exportMetadata(context,request,response,scope);
  }
 else {
    processBrowse(context,scope,request,response);
  }
}",0.9905292479108636
52007,"/** 
 * Do the usual DSpace GET method.  You will notice that browse does not currently respond to POST requests.
 */
protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  BrowserScope scope=getBrowserScopeForRequest(context,request,response);
  if (scope.getBrowseIndex() == null) {
    throw new ServletException(""String_Node_Str"");
  }
  if (""String_Node_Str"".equals(UIUtil.getSubmitButton(request,""String_Node_Str""))) {
    exportMetadata(context,request,response,scope);
  }
 else {
    processBrowse(context,scope,request,response);
  }
}","/** 
 * Do the usual DSpace GET method.  You will notice that browse does not currently respond to POST requests.
 */
protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  BrowserScope scope=getBrowserScopeForRequest(context,request,response);
  if (scope.getBrowseIndex() == null) {
    String requestURL=request.getRequestURI();
    if (request.getQueryString() != null) {
      requestURL+=""String_Node_Str"" + request.getQueryString();
    }
    log.warn(""String_Node_Str"" + requestURL);
    response.sendError(HttpServletResponse.SC_BAD_REQUEST);
    return;
  }
  if (""String_Node_Str"".equals(UIUtil.getSubmitButton(request,""String_Node_Str""))) {
    exportMetadata(context,request,response,scope);
  }
 else {
    processBrowse(context,scope,request,response);
  }
}",0.8064516129032258
52008,"/** 
 * Setup the reader. The resource is opened to get an <code>InputStream</code>, the length and the last modification date
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  this.key=src;
  this.setByteRanges(false);
  this.inputSources=new ArrayList<Source>();
  String path=src.substring(0,src.lastIndexOf('/'));
  String file=src.substring(src.lastIndexOf('/') + 1);
  String[] files=file.split(""String_Node_Str"");
  for (  String f : files) {
    if (file.endsWith(""String_Node_Str"") && !f.endsWith(""String_Node_Str"")) {
      f+=""String_Node_Str"";
    }
    if (file.endsWith(""String_Node_Str"") && !f.endsWith(""String_Node_Str"")) {
      f+=""String_Node_Str"";
    }
    if (file.endsWith(""String_Node_Str"") && !f.endsWith(""String_Node_Str"")) {
      f+=""String_Node_Str"";
    }
    String fullPath=path + ""String_Node_Str"" + f;
    this.inputSources.add(resolver.resolveURI(fullPath));
  }
  super.setup(resolver,objectModel,path + ""String_Node_Str"" + files[files.length - 1],par);
  this.streamEnumeration=new StreamEnumeration();
  try {
    if (""String_Node_Str"".equals(par.getParameter(""String_Node_Str""))) {
      this.doMinify=false;
    }
 else {
      this.key+=""String_Node_Str"";
    }
  }
 catch (  ParameterException e) {
    log.error(""String_Node_Str"",e);
  }
}","/** 
 * Setup the reader. The resource is opened to get an <code>InputStream</code>, the length and the last modification date
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  this.key=src;
  this.setByteRanges(false);
  this.inputSources=new ArrayList<Source>();
  String path=""String_Node_Str"";
  if (src.contains(""String_Node_Str"")) {
    path=src.substring(0,src.lastIndexOf('/'));
  }
  String file=src.substring(src.lastIndexOf('/') + 1);
  String[] files=file.split(""String_Node_Str"");
  for (  String f : files) {
    if (file.endsWith(""String_Node_Str"") && !f.endsWith(""String_Node_Str"")) {
      f+=""String_Node_Str"";
    }
    if (file.endsWith(""String_Node_Str"") && !f.endsWith(""String_Node_Str"")) {
      f+=""String_Node_Str"";
    }
    if (file.endsWith(""String_Node_Str"") && !f.endsWith(""String_Node_Str"")) {
      f+=""String_Node_Str"";
    }
    String fullPath;
    if (!path.isEmpty())     fullPath=path + ""String_Node_Str"" + f;
 else     fullPath=f;
    Source inSource=resolver.resolveURI(fullPath);
    if (inSource.exists()) {
      this.inputSources.add(inSource);
    }
 else     throw new ResourceNotFoundException(""String_Node_Str"" + fullPath + ""String_Node_Str"");
  }
  super.setup(resolver,objectModel,path + ""String_Node_Str"" + files[files.length - 1],par);
  this.streamEnumeration=new StreamEnumeration();
  try {
    if (""String_Node_Str"".equals(par.getParameter(""String_Node_Str""))) {
      this.doMinify=false;
    }
 else {
      this.key+=""String_Node_Str"";
    }
  }
 catch (  ParameterException e) {
    log.error(""String_Node_Str"",e);
  }
}",0.8861256544502618
52009,"@RequestMapping(method={RequestMethod.GET,RequestMethod.HEAD},value={""String_Node_Str""}) public String processHandle(HttpServletRequest request,@PathVariable String prefix){
  try {
    Context context=ContextUtil.obtainContext(request);
    IdentifierService dis=new DSpace().getSingletonService(IdentifierService.class);
    if (dis == null)     throw new RuntimeException(""String_Node_Str"");
    DSpaceObject dso=dis.resolve(context,prefix);
    if (dso == null)     throw new RuntimeException(""String_Node_Str"");
    request.setAttribute(DSPACE_OBJECT,dso);
    return ""String_Node_Str"" + dso.getHandle();
  }
 catch (  SQLException e) {
    return ""String_Node_Str"";
  }
catch (  IdentifierNotResolvableException e) {
    return ""String_Node_Str"";
  }
catch (  IdentifierNotFoundException e) {
    request.setAttribute(""String_Node_Str"",prefix);
    return ""String_Node_Str"";
  }
}","@RequestMapping(method={RequestMethod.GET,RequestMethod.HEAD},value={""String_Node_Str""}) public String processHandle(HttpServletRequest request,@PathVariable String prefix){
  try {
    Context context=ContextUtil.obtainContext(request);
    IdentifierService dis=new DSpace().getSingletonService(IdentifierService.class);
    if (dis == null)     throw new RuntimeException(""String_Node_Str"");
    DSpaceObject dso=dis.resolve(context,prefix);
    if (dso == null)     throw new IdentifierNotFoundException(""String_Node_Str"" + prefix + ""String_Node_Str"");
    request.setAttribute(DSPACE_OBJECT,dso);
    return ""String_Node_Str"" + dso.getHandle();
  }
 catch (  SQLException e) {
    return ""String_Node_Str"";
  }
catch (  IdentifierNotResolvableException e) {
    return ""String_Node_Str"";
  }
catch (  IdentifierNotFoundException e) {
    request.setAttribute(""String_Node_Str"",prefix);
    return ""String_Node_Str"";
  }
}",0.9701986754966888
52010,"/** 
 * Recursively export one or more DSpace Objects as a series of packages. This method will export the given DSpace Object as well as all referenced DSpaceObjects (e.g. child objects) into a series of packages. The initial object is exported to the location specified by the OutputStream. All other packages are exported to the same directory location. <p> Package is any serialized representation of the item, at the discretion of the implementing class.  It does not have to include content bitstreams. <br> Use the <code>params</code> parameter list to adjust the way the package is made, e.g. including a ""<code>metadataOnly</code>"" parameter might make the package a bare manifest in XML instead of a Zip file including manifest and contents. <br> Throws an exception of the initial object is not acceptable or there is a failure creating the package.
 * @param context  DSpace context.
 * @param dso  initial DSpace object
 * @param params Properties-style list of options specific to this packager
 * @param pkgFile File where initial package should be written. All otherpackages will be written to the same directory as this File.
 * @throws PackageValidationException if package cannot be created or there isa fatal error in creating it.
 */
@Override public List<File> disseminateAll(Context context,DSpaceObject dso,PackageParameters params,File pkgFile) throws PackageException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  disseminate(context,dso,params,pkgFile);
  if (pkgFile.exists()) {
    addToPackageList(pkgFile);
    if (dso.getType() != Constants.ITEM) {
      String pkgDirectory=pkgFile.getCanonicalFile().getParent();
      if (!pkgDirectory.endsWith(File.separator)) {
        pkgDirectory+=File.separator;
      }
      String fileExtension=PackageUtils.getFileExtension(pkgFile.getName());
switch (dso.getType()) {
case Constants.COLLECTION:
        Collection collection=(Collection)dso;
      ItemIterator iterator=collection.getItems();
    while (iterator.hasNext()) {
      Item item=iterator.next();
      String childFileName=pkgDirectory + PackageUtils.getPackageName(item,fileExtension);
      disseminateAll(context,item,params,new File(childFileName));
    }
  break;
case Constants.COMMUNITY:
Community community=(Community)dso;
Community[] subcommunities=community.getSubcommunities();
for (int i=0; i < subcommunities.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(subcommunities[i],fileExtension);
disseminateAll(context,subcommunities[i],params,new File(childFileName));
}
Collection[] collections=community.getCollections();
for (int i=0; i < collections.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(collections[i],fileExtension);
disseminateAll(context,collections[i],params,new File(childFileName));
}
break;
case Constants.SITE:
Community[] topCommunities=Community.findAllTop(context);
for (int i=0; i < topCommunities.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(topCommunities[i],fileExtension);
disseminateAll(context,topCommunities[i],params,new File(childFileName));
}
break;
}
}
}
return getPackageList();
}","/** 
 * Recursively export one or more DSpace Objects as a series of packages. This method will export the given DSpace Object as well as all referenced DSpaceObjects (e.g. child objects) into a series of packages. The initial object is exported to the location specified by the OutputStream. All other packages are exported to the same directory location. <p> Package is any serialized representation of the item, at the discretion of the implementing class.  It does not have to include content bitstreams. <br> Use the <code>params</code> parameter list to adjust the way the package is made, e.g. including a ""<code>metadataOnly</code>"" parameter might make the package a bare manifest in XML instead of a Zip file including manifest and contents. <br> Throws an exception of the initial object is not acceptable or there is a failure creating the package.
 * @param context  DSpace context.
 * @param dso  initial DSpace object
 * @param params Properties-style list of options specific to this packager
 * @param pkgFile File where initial package should be written. All otherpackages will be written to the same directory as this File.
 * @throws PackageValidationException if package cannot be created or there isa fatal error in creating it.
 */
@Override public List<File> disseminateAll(Context context,DSpaceObject dso,PackageParameters params,File pkgFile) throws PackageException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  if (!getPackageList().contains(pkgFile)) {
    disseminate(context,dso,params,pkgFile);
  }
  if (pkgFile.exists()) {
    addToPackageList(pkgFile);
    if (dso.getType() != Constants.ITEM) {
      String pkgDirectory=pkgFile.getCanonicalFile().getParent();
      if (!pkgDirectory.endsWith(File.separator)) {
        pkgDirectory+=File.separator;
      }
      String fileExtension=PackageUtils.getFileExtension(pkgFile.getName());
switch (dso.getType()) {
case Constants.COLLECTION:
        Collection collection=(Collection)dso;
      ItemIterator iterator=collection.getItems();
    while (iterator.hasNext()) {
      Item item=iterator.next();
      String childFileName=pkgDirectory + PackageUtils.getPackageName(item,fileExtension);
      disseminateAll(context,item,params,new File(childFileName));
    }
  break;
case Constants.COMMUNITY:
Community community=(Community)dso;
Community[] subcommunities=community.getSubcommunities();
for (int i=0; i < subcommunities.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(subcommunities[i],fileExtension);
disseminateAll(context,subcommunities[i],params,new File(childFileName));
}
Collection[] collections=community.getCollections();
for (int i=0; i < collections.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(collections[i],fileExtension);
disseminateAll(context,collections[i],params,new File(childFileName));
}
break;
case Constants.SITE:
Community[] topCommunities=Community.findAllTop(context);
for (int i=0; i < topCommunities.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(topCommunities[i],fileExtension);
disseminateAll(context,topCommunities[i],params,new File(childFileName));
}
break;
}
}
}
return getPackageList();
}",0.9922785768357304
52011,"/** 
 * Recursively create one or more DSpace Objects out of the contents of the ingested package (and all other referenced packages). The initial object is created under the indicated parent.  All other objects are created based on their relationship to the initial object. <p> For example, a scenario may be to create a Collection based on a collection-level package, and also create an Item for every item-level package referenced by the collection-level package. <p> The output of this method is one or more newly created <code>DspaceObject<code>s. <p> The packager <em>may</em> choose not to implement <code>ingestAll</code>, or simply forward the call to <code>ingest</code> if it is unable to support recursive ingestion. <p> The deposit license (Only significant for Item) is passed explicitly as a string since there is no place for it in many package formats.  It is optional and may be given as <code>null</code>.
 * @param context  DSpace context.
 * @param parent parent under which to create the initial object(may be null -- in which case ingester must determine parent from package or throw an error).
 * @param pkgFile  The initial package file to ingest
 * @param params Properties-style list of options (interpreted by each packager).
 * @param license  may be null, which takes default license.
 * @return List of DSpaceObjects created
 * @throws PackageValidationException if initial package (or any referenced package)is unacceptable or there is a fatal error in creating a DSpaceObject
 * @throws UnsupportedOperationException if this packager does notimplement <code>ingestAll</code>
 */
@Override public List<DSpaceObject> ingestAll(Context context,DSpaceObject parent,File pkgFile,PackageParameters params,String license) throws PackageException, UnsupportedOperationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  DSpaceObject dso=null;
  try {
    dso=ingest(context,parent,pkgFile,params,license);
  }
 catch (  IllegalStateException ie) {
    if (params.keepExistingModeEnabled()) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + pkgFile));
    }
 else {
      throw ie;
    }
  }
  if (dso != null) {
    addToIngestedList(dso);
    if (dso.getType() != Constants.ITEM) {
      List<String> childPkgRefs=getPackageReferences(dso);
      if (childPkgRefs != null && !childPkgRefs.isEmpty()) {
        for (        String childPkgRef : childPkgRefs) {
          int oldSize=dsoIngestedList.size();
          File childPkg=new File(pkgFile.getAbsoluteFile().getParent(),childPkgRef);
          ingestAll(context,dso,childPkg,params,license);
          if (Constants.COLLECTION == dso.getType() && dsoIngestedList.size() > oldSize) {
            Item childItem=(Item)dsoIngestedList.get(oldSize);
            Collection collection=(Collection)dso;
            if (!childItem.isIn(collection)) {
              collection.addItem(childItem);
            }
          }
        }
      }
    }
  }
  return getIngestedList();
}","/** 
 * Recursively create one or more DSpace Objects out of the contents of the ingested package (and all other referenced packages). The initial object is created under the indicated parent.  All other objects are created based on their relationship to the initial object. <p> For example, a scenario may be to create a Collection based on a collection-level package, and also create an Item for every item-level package referenced by the collection-level package. <p> The output of this method is one or more newly created <code>DspaceObject<code>s. <p> The packager <em>may</em> choose not to implement <code>ingestAll</code>, or simply forward the call to <code>ingest</code> if it is unable to support recursive ingestion. <p> The deposit license (Only significant for Item) is passed explicitly as a string since there is no place for it in many package formats.  It is optional and may be given as <code>null</code>.
 * @param context  DSpace context.
 * @param parent parent under which to create the initial object(may be null -- in which case ingester must determine parent from package or throw an error).
 * @param pkgFile  The initial package file to ingest
 * @param params Properties-style list of options (interpreted by each packager).
 * @param license  may be null, which takes default license.
 * @return List of DSpaceObjects created
 * @throws PackageValidationException if initial package (or any referenced package)is unacceptable or there is a fatal error in creating a DSpaceObject
 * @throws UnsupportedOperationException if this packager does notimplement <code>ingestAll</code>
 */
@Override public List<DSpaceObject> ingestAll(Context context,DSpaceObject parent,File pkgFile,PackageParameters params,String license) throws PackageException, UnsupportedOperationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  DSpaceObject dso=null;
  if (!getIngestedMap().containsKey(pkgFile)) {
    try {
      dso=ingest(context,parent,pkgFile,params,license);
    }
 catch (    IllegalStateException ie) {
      if (params.keepExistingModeEnabled()) {
        log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + pkgFile.getName()));
      }
 else {
        throw ie;
      }
    }
  }
 else {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + pkgFile.getName()));
  }
  if (dso != null) {
    addToIngestedMap(pkgFile,dso);
    if (dso.getType() != Constants.ITEM) {
      List<String> childPkgRefs=getPackageReferences(dso);
      if (childPkgRefs != null && !childPkgRefs.isEmpty()) {
        for (        String childPkgRef : childPkgRefs) {
          File childPkg=new File(pkgFile.getAbsoluteFile().getParent(),childPkgRef);
          ingestAll(context,null,childPkg,params,license);
          if (Constants.COLLECTION == dso.getType()) {
            Item childItem=(Item)getIngestedMap().get(childPkg);
            Collection collection=(Collection)dso;
            if (childItem != null && !childItem.isIn(collection)) {
              collection.addItem(childItem);
            }
          }
        }
      }
    }
  }
  return getIngestedList();
}",0.8624055415617129
52012,"/** 
 * Recursively replace one or more DSpace Objects out of the contents of the ingested package (and all other referenced packages). The initial object to replace is indicated by <code>dso</code>.  All other objects are replaced based on information provided in the referenced packages. <p> For example, a scenario may be to replace a Collection based on a collection-level package, and also replace *every* Item in that collection based on the item-level packages referenced by the collection-level package. <p> Please note that since the <code>dso</code> input only specifies the initial object to replace, any additional objects to replace must be determined based on the referenced packages (or initial package itself). <p> The output of this method is one or more replaced <code>DspaceObject<code>s. <p> The packager <em>may</em> choose not to implement <code>replaceAll</code>, since it somewhat contradicts the archival nature of DSpace. It also may choose to forward the call to <code>replace</code> if it is unable to support recursive replacement.
 * @param context  DSpace context.
 * @param dso initial existing DSpace Object to be replaced, may be nullif object to replace can be determined from package
 * @param pkgFile  The package file to ingest.
 * @param params Properties-style list of options specific to this packager
 * @return List of DSpaceObjects replaced
 * @throws PackageValidationException if initial package (or any referenced package)is unacceptable or there is a fatal error in creating a DSpaceObject
 * @throws UnsupportedOperationException if this packager does notimplement <code>replaceAll</code>
 */
@Override public List<DSpaceObject> replaceAll(Context context,DSpaceObject dso,File pkgFile,PackageParameters params) throws PackageException, UnsupportedOperationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  DSpaceObject replacedDso=replace(context,dso,pkgFile,params);
  if (replacedDso != null) {
    addToIngestedList(replacedDso);
    if (replacedDso.getType() != Constants.ITEM) {
      List<String> childPkgRefs=getPackageReferences(replacedDso);
      if (childPkgRefs != null && !childPkgRefs.isEmpty()) {
        for (        String childPkgRef : childPkgRefs) {
          int oldSize=dsoIngestedList.size();
          File childPkg=new File(pkgFile.getAbsoluteFile().getParent(),childPkgRef);
          replaceAll(context,null,childPkg,params);
          if (Constants.COLLECTION == replacedDso.getType() && dsoIngestedList.size() > oldSize) {
            Item childItem=(Item)dsoIngestedList.get(oldSize);
            Collection collection=(Collection)replacedDso;
            if (!childItem.isIn(collection)) {
              collection.addItem(childItem);
            }
          }
        }
      }
    }
  }
  return getIngestedList();
}","/** 
 * Recursively replace one or more DSpace Objects out of the contents of the ingested package (and all other referenced packages). The initial object to replace is indicated by <code>dso</code>.  All other objects are replaced based on information provided in the referenced packages. <p> For example, a scenario may be to replace a Collection based on a collection-level package, and also replace *every* Item in that collection based on the item-level packages referenced by the collection-level package. <p> Please note that since the <code>dso</code> input only specifies the initial object to replace, any additional objects to replace must be determined based on the referenced packages (or initial package itself). <p> The output of this method is one or more replaced <code>DspaceObject<code>s. <p> The packager <em>may</em> choose not to implement <code>replaceAll</code>, since it somewhat contradicts the archival nature of DSpace. It also may choose to forward the call to <code>replace</code> if it is unable to support recursive replacement.
 * @param context  DSpace context.
 * @param dso initial existing DSpace Object to be replaced, may be nullif object to replace can be determined from package
 * @param pkgFile  The package file to ingest.
 * @param params Properties-style list of options specific to this packager
 * @return List of DSpaceObjects replaced
 * @throws PackageValidationException if initial package (or any referenced package)is unacceptable or there is a fatal error in creating a DSpaceObject
 * @throws UnsupportedOperationException if this packager does notimplement <code>replaceAll</code>
 */
@Override public List<DSpaceObject> replaceAll(Context context,DSpaceObject dso,File pkgFile,PackageParameters params) throws PackageException, UnsupportedOperationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  DSpaceObject replacedDso=null;
  if (!getIngestedMap().containsKey(pkgFile)) {
    replacedDso=replace(context,dso,pkgFile,params);
  }
 else {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + pkgFile.getName()));
  }
  if (replacedDso != null) {
    addToIngestedMap(pkgFile,replacedDso);
    if (replacedDso.getType() != Constants.ITEM) {
      List<String> childPkgRefs=getPackageReferences(replacedDso);
      if (childPkgRefs != null && !childPkgRefs.isEmpty()) {
        for (        String childPkgRef : childPkgRefs) {
          File childPkg=new File(pkgFile.getAbsoluteFile().getParent(),childPkgRef);
          replaceAll(context,null,childPkg,params);
          if (Constants.COLLECTION == replacedDso.getType()) {
            Item childItem=(Item)getIngestedMap().get(childPkg);
            Collection collection=(Collection)replacedDso;
            if (childItem != null && !childItem.isIn(collection)) {
              collection.addItem(childItem);
            }
          }
        }
      }
    }
  }
  return getIngestedList();
}",0.8540305010893247
52013,"/** 
 * Return List of all DSpaceObjects which have been ingested/replaced by this instance of the Ingester. <P> This list can be useful in reporting back to the user what content has been added or replaced.  It's used by ingestAll() and replaceAll() to return this list of everything that was ingested/replaced.
 * @return List of DSpaceObjects which have been added/replaced
 */
protected List<DSpaceObject> getIngestedList(){
  return dsoIngestedList;
}","/** 
 * Return List of all DSpaceObjects which have been ingested/replaced by this instance of the Ingester. <P> This list can be useful in reporting back to the user what content has been added or replaced.  It's used by ingestAll() and replaceAll() to return this list of everything that was ingested/replaced.
 * @return List of DSpaceObjects which have been added/replaced
 */
protected List<DSpaceObject> getIngestedList(){
  java.util.Collection<DSpaceObject> coll=pkgIngestedMap.values();
  if (coll instanceof List)   return (List)coll;
 else   return new ArrayList(coll);
}",0.8516377649325626
52014,"@Override public Bitstream getPrimaryBitstream(int itemId,String bundleName) throws SQLException {
  TableRowIterator tri=null;
  try {
    tri=DatabaseManager.query(context,selectPrimaryBitstreamID,itemId,bundleName);
    if (tri.hasNext()) {
      TableRow row=tri.next();
      int bid=row.getIntColumn(""String_Node_Str"");
      return Bitstream.find(context,bid);
    }
  }
  finally {
    if (tri != null) {
      tri.close();
    }
  }
  return null;
}","@Override public Bitstream getPrimaryBitstream(int itemId,String bundleName) throws SQLException {
  TableRowIterator tri=null;
  try {
    tri=DatabaseManager.query(context,SELECT_PRIMARY_BITSTREAM_ID,itemId,bundleName);
    if (tri.hasNext()) {
      TableRow row=tri.next();
      int bid=row.getIntColumn(""String_Node_Str"");
      return Bitstream.find(context,bid);
    }
  }
  finally {
    if (tri != null) {
      tri.close();
    }
  }
  return null;
}",0.9532100108813928
52015,"@Override public Bitstream getFirstBitstream(int itemId,String bundleName) throws SQLException {
  TableRowIterator tri=null;
  try {
    tri=DatabaseManager.query(context,selectFirstBitstreamID,itemId,bundleName);
    if (tri.hasNext()) {
      TableRow row=tri.next();
      int bid=row.getIntColumn(""String_Node_Str"");
      return Bitstream.find(context,bid);
    }
  }
  finally {
    if (tri != null) {
      tri.close();
    }
  }
  return null;
}","@Override public Bitstream getFirstBitstream(int itemId,String bundleName) throws SQLException {
  TableRowIterator tri=null;
  try {
    tri=DatabaseManager.query(context,SELECT_FIRST_BITSTREAM_ID,itemId,bundleName);
    if (tri.hasNext()) {
      TableRow row=tri.next();
      int bid=row.getIntColumn(""String_Node_Str"");
      return Bitstream.find(context,bid);
    }
  }
  finally {
    if (tri != null) {
      tri.close();
    }
  }
  return null;
}",0.9571899012074644
52016,"ItemDAOOracle(Context ctx){
  super(ctx);
  int MD_FIELD_ID_NAME=-1;
  try {
    MD_FIELD_ID_NAME=MetadataField.findByElement(context,MetadataSchema.DC_SCHEMA_ID,""String_Node_Str"",null).getFieldID();
  }
 catch (  SQLException ex) {
  }
  if (null == selectPrimaryBitstreamID)   selectPrimaryBitstreamID=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + Constants.BUNDLE + ""String_Node_Str""+ ""String_Node_Str""+ MD_FIELD_ID_NAME+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  if (null == selectFirstBitstreamID)   selectFirstBitstreamID=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + Constants.BUNDLE + ""String_Node_Str""+ ""String_Node_Str""+ MD_FIELD_ID_NAME+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  if (null == selectNamedBitstreamID)   selectNamedBitstreamID=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + Constants.BUNDLE + ""String_Node_Str""+ ""String_Node_Str""+ MD_FIELD_ID_NAME+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ Constants.BITSTREAM+ ""String_Node_Str""+ ""String_Node_Str""+ MD_FIELD_ID_NAME+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
}","ItemDAOOracle(Context ctx){
  super(ctx);
  int MD_FIELD_ID_NAME=-1;
  try {
    MD_FIELD_ID_NAME=MetadataField.findByElement(context,MetadataSchema.DC_SCHEMA_ID,""String_Node_Str"",null).getFieldID();
  }
 catch (  SQLException ex) {
  }
  if (null == SELECT_PRIMARY_BITSTREAM_ID)   SELECT_PRIMARY_BITSTREAM_ID=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + Constants.BUNDLE + ""String_Node_Str""+ ""String_Node_Str""+ MD_FIELD_ID_NAME+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  if (null == SELECT_FIRST_BITSTREAM_ID)   SELECT_FIRST_BITSTREAM_ID=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + Constants.BUNDLE + ""String_Node_Str""+ ""String_Node_Str""+ MD_FIELD_ID_NAME+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  if (null == SELECT_NAMED_BITSTREAM_ID)   SELECT_NAMED_BITSTREAM_ID=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + Constants.BUNDLE + ""String_Node_Str""+ ""String_Node_Str""+ MD_FIELD_ID_NAME+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ Constants.BITSTREAM+ ""String_Node_Str""+ ""String_Node_Str""+ MD_FIELD_ID_NAME+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
}",0.9082089552238806
52017,"@Override public Bitstream getNamedBitstream(int itemId,String bundleName,String fileName) throws SQLException {
  TableRowIterator tri=null;
  try {
    tri=DatabaseManager.query(context,selectNamedBitstreamID,itemId,bundleName,fileName);
    if (tri.hasNext()) {
      TableRow row=tri.next();
      int bid=row.getIntColumn(""String_Node_Str"");
      return Bitstream.find(context,bid);
    }
  }
  finally {
    if (tri != null) {
      tri.close();
    }
  }
  return null;
}","@Override public Bitstream getNamedBitstream(int itemId,String bundleName,String fileName) throws SQLException {
  TableRowIterator tri=null;
  try {
    tri=DatabaseManager.query(context,SELECT_NAMED_BITSTREAM_ID,itemId,bundleName,fileName);
    if (tri.hasNext()) {
      TableRow row=tri.next();
      int bid=row.getIntColumn(""String_Node_Str"");
      return Bitstream.find(context,bid);
    }
  }
  finally {
    if (tri != null) {
      tri.close();
    }
  }
  return null;
}",0.9573361082206036
52018,"/** 
 * Create a new instance, reading the lines in from file
 * @param f The file to read from
 * @param c The DSpace Context
 * @throws Exception thrown if there is an error reading or processing the file
 */
public DSpaceCSV(File f,Context c) throws Exception {
  init();
  BufferedReader input=null;
  try {
    input=new BufferedReader(new InputStreamReader(new FileInputStream(f),""String_Node_Str""));
    String head=input.readLine();
    String[] headingElements=head.split(escapedFieldSeparator);
    int columnCounter=0;
    for (    String element : headingElements) {
      columnCounter++;
      if ((element.startsWith(""String_Node_Str"")) && (element.endsWith(""String_Node_Str""))) {
        element=element.substring(1,element.length() - 1);
      }
      if (""String_Node_Str"".equals(element)) {
        headings.add(element);
      }
 else       if (""String_Node_Str"".equals(element)) {
        headings.add(element);
      }
 else       if (!""String_Node_Str"".equals(element)) {
        String authorityPrefix=""String_Node_Str"";
        AuthorityValue authorityValueType=MetadataImport.getAuthorityValueType(element);
        if (authorityValueType != null) {
          String authorityType=authorityValueType.getAuthorityType();
          authorityPrefix=element.substring(0,authorityType.length() + 1);
          element=element.substring(authorityPrefix.length());
        }
        String[] clean=element.split(""String_Node_Str"");
        String[] parts=clean[0].split(""String_Node_Str"");
        if (parts.length < 2) {
          throw new MetadataImportInvalidHeadingException(element,MetadataImportInvalidHeadingException.ENTRY,columnCounter);
        }
        String metadataSchema=parts[0];
        String metadataElement=parts[1];
        String metadataQualifier=null;
        if (parts.length > 2) {
          metadataQualifier=parts[2];
        }
        MetadataSchema foundSchema=MetadataSchema.find(c,metadataSchema);
        if (foundSchema == null) {
          throw new MetadataImportInvalidHeadingException(clean[0],MetadataImportInvalidHeadingException.SCHEMA,columnCounter);
        }
        int schemaID=foundSchema.getSchemaID();
        MetadataField foundField=MetadataField.findByElement(c,schemaID,metadataElement,metadataQualifier);
        if (foundField == null) {
          throw new MetadataImportInvalidHeadingException(clean[0],MetadataImportInvalidHeadingException.ELEMENT,columnCounter);
        }
        headings.add(authorityPrefix + element);
      }
    }
    StringBuilder lineBuilder=new StringBuilder();
    String lineRead;
    while ((lineRead=input.readLine()) != null) {
      if (lineBuilder.length() > 0) {
        lineBuilder.append(""String_Node_Str"").append(lineRead);
        int quoteCount=0;
        for (int pos=0; pos < lineBuilder.length(); pos++) {
          if (lineBuilder.charAt(pos) == '""') {
            quoteCount++;
          }
        }
        if (quoteCount % 2 == 0) {
          addItem(lineBuilder.toString());
          lineBuilder=new StringBuilder();
        }
      }
 else       if (lineRead.indexOf('""') > -1) {
        int quoteCount=0;
        for (int pos=0; pos < lineRead.length(); pos++) {
          if (lineRead.charAt(pos) == '""') {
            quoteCount++;
          }
        }
        if (quoteCount % 2 == 0) {
          addItem(lineRead);
        }
 else {
          lineBuilder.append(lineRead);
        }
      }
 else {
        addItem(lineRead);
      }
    }
  }
  finally {
    if (input != null) {
      input.close();
    }
  }
}","/** 
 * Create a new instance, reading the lines in from file
 * @param f The file to read from
 * @param c The DSpace Context
 * @throws Exception thrown if there is an error reading or processing the file
 */
public DSpaceCSV(File f,Context c) throws Exception {
  init();
  BufferedReader input=null;
  try {
    input=new BufferedReader(new InputStreamReader(new FileInputStream(f),""String_Node_Str""));
    String head=input.readLine();
    String[] headingElements=head.split(escapedFieldSeparator);
    int columnCounter=0;
    for (    String element : headingElements) {
      columnCounter++;
      if ((element.startsWith(""String_Node_Str"")) && (element.endsWith(""String_Node_Str""))) {
        element=element.substring(1,element.length() - 1);
      }
      if (""String_Node_Str"".equals(element)) {
        headings.add(element);
      }
 else       if (""String_Node_Str"".equals(element)) {
        headings.add(element);
      }
 else       if (!""String_Node_Str"".equals(element)) {
        String authorityPrefix=""String_Node_Str"";
        AuthorityValue authorityValueType=MetadataImport.getAuthorityValueType(element);
        if (authorityValueType != null) {
          String authorityType=authorityValueType.getAuthorityType();
          authorityPrefix=element.substring(0,authorityType.length() + 1);
          element=element.substring(authorityPrefix.length());
        }
        String[] clean=element.split(""String_Node_Str"");
        String[] parts=clean[0].split(""String_Node_Str"");
        if (parts.length < 2) {
          throw new MetadataImportInvalidHeadingException(element,MetadataImportInvalidHeadingException.ENTRY,columnCounter);
        }
        String metadataSchema=parts[0];
        String metadataElement=parts[1];
        String metadataQualifier=null;
        if (parts.length > 2) {
          metadataQualifier=parts[2];
        }
        MetadataSchema foundSchema=MetadataSchema.find(c,metadataSchema);
        if (foundSchema == null) {
          throw new MetadataImportInvalidHeadingException(clean[0],MetadataImportInvalidHeadingException.SCHEMA,columnCounter);
        }
        int schemaID=foundSchema.getSchemaID();
        MetadataField foundField=MetadataField.findByElement(c,schemaID,metadataElement,metadataQualifier);
        if (foundField == null) {
          throw new MetadataImportInvalidHeadingException(clean[0],MetadataImportInvalidHeadingException.ELEMENT,columnCounter);
        }
        headings.add(authorityPrefix + element);
      }
    }
    StringBuilder lineBuilder=new StringBuilder();
    String lineRead;
    while (StringUtils.isNotBlank(lineRead=input.readLine())) {
      if (lineBuilder.length() > 0) {
        lineBuilder.append(""String_Node_Str"").append(lineRead);
        int quoteCount=0;
        for (int pos=0; pos < lineBuilder.length(); pos++) {
          if (lineBuilder.charAt(pos) == '""') {
            quoteCount++;
          }
        }
        if (quoteCount % 2 == 0) {
          addItem(lineBuilder.toString());
          lineBuilder=new StringBuilder();
        }
      }
 else       if (lineRead.indexOf('""') > -1) {
        int quoteCount=0;
        for (int pos=0; pos < lineRead.length(); pos++) {
          if (lineRead.charAt(pos) == '""') {
            quoteCount++;
          }
        }
        if (quoteCount % 2 == 0) {
          addItem(lineRead);
        }
 else {
          lineBuilder.append(lineRead);
        }
      }
 else {
        addItem(lineRead);
      }
    }
  }
  finally {
    if (input != null) {
      input.close();
    }
  }
}",0.9957794034890264
52019,"/** 
 * Get the CSV lines as an array of CSV formatted strings
 * @return the array of CSV formatted Strings
 */
public final String[] getCSVLinesAsStringArray(){
  String[] csvLines=new String[counter + 1];
  csvLines[0]=""String_Node_Str"" + fieldSeparator + ""String_Node_Str"";
  Collections.sort(headings);
  for (  String value : headings) {
    csvLines[0]=csvLines[0] + fieldSeparator + value;
  }
  Iterator<DSpaceCSVLine> i=lines.iterator();
  int c=1;
  while (i.hasNext()) {
    csvLines[c++]=i.next().toCSV(headings);
  }
  return csvLines;
}","/** 
 * Get the CSV lines as an array of CSV formatted strings
 * @return the array of CSV formatted Strings
 */
public final String[] getCSVLinesAsStringArray(){
  String[] csvLines=new String[counter + 1];
  csvLines[0]=""String_Node_Str"" + fieldSeparator + ""String_Node_Str"";
  List<String> headingsCopy=new ArrayList<String>(headings);
  Collections.sort(headingsCopy);
  for (  String value : headingsCopy) {
    csvLines[0]=csvLines[0] + fieldSeparator + value;
  }
  Iterator<DSpaceCSVLine> i=lines.iterator();
  int c=1;
  while (i.hasNext()) {
    csvLines[c++]=i.next().toCSV(headingsCopy);
  }
  return csvLines;
}",0.937872340425532
52020,"/** 
 * Create a new CSV line for a new item
 */
public DSpaceCSVLine(){
  this.id=-1;
  this.items=new HashMap<String,ArrayList>();
}","/** 
 * Create a new CSV line for a new item
 */
public DSpaceCSVLine(){
  this.id=-1;
  this.items=new TreeMap<String,ArrayList>(headerComparator);
}",0.9154929577464788
52021,"/** 
 * Run an import. The import can either be read-only to detect changes, or can write changes as it goes.
 * @param change Whether or not to write the changes to the database
 * @param useWorkflow Whether the workflows should be used when creating new items
 * @param workflowNotify If the workflows should be used, whether to send notifications or not
 * @param useTemplate Use collection template if create new item
 * @return An array of BulkEditChange elements representing the items that have changed
 * @throws MetadataImportException if something goes wrong
 */
public List<BulkEditChange> runImport(boolean change,boolean useWorkflow,boolean workflowNotify,boolean useTemplate) throws MetadataImportException {
  ArrayList<BulkEditChange> changes=new ArrayList<BulkEditChange>();
  try {
    for (    DSpaceCSVLine line : toImport) {
      int id=line.getID();
      if (csv.hasActions() && (!""String_Node_Str"".equals(line.getAction())) && (id == -1)) {
        throw new MetadataImportException(""String_Node_Str"");
      }
      if (id != -1) {
        Item item=Item.find(c,id);
        if (item == null) {
          throw new MetadataImportException(""String_Node_Str"" + id);
        }
        BulkEditChange whatHasChanged=new BulkEditChange(item);
        List<String> collections=line.get(""String_Node_Str"");
        if (collections != null) {
          if (collections.size() == 0) {
            throw new MetadataImportException(""String_Node_Str"" + item.getHandle());
          }
          Collection[] actualCollections=item.getCollections();
          compare(item,collections,actualCollections,whatHasChanged,change);
        }
        for (        String md : line.keys()) {
          if (!""String_Node_Str"".equals(md)) {
            String[] fromCSV=line.get(md).toArray(new String[line.get(md).size()]);
            if (!isAuthorityControlledField(md)) {
              for (int i=0; i < fromCSV.length; i++) {
                int pos=fromCSV[i].indexOf(DSpaceCSV.authoritySeparator);
                if (pos > -1) {
                  fromCSV[i]=fromCSV[i].substring(0,pos);
                }
              }
            }
            compare(item,fromCSV,change,md,whatHasChanged);
          }
        }
        if (csv.hasActions()) {
          String action=line.getAction();
          if (""String_Node_Str"".equals(action)) {
          }
 else           if (""String_Node_Str"".equals(action)) {
            if (!ConfigurationManager.getBooleanProperty(""String_Node_Str"",""String_Node_Str"",false)) {
              throw new MetadataImportException(""String_Node_Str"");
            }
            Collection[] owners=item.getCollections();
            for (            Collection owner : owners) {
              if (change) {
                owner.removeItem(item);
              }
            }
            whatHasChanged.setDeleted();
          }
 else           if (""String_Node_Str"".equals(action)) {
            if (!item.isWithdrawn()) {
              if (change) {
                item.withdraw();
              }
              whatHasChanged.setWithdrawn();
            }
          }
 else           if (""String_Node_Str"".equals(action)) {
            if (item.isWithdrawn()) {
              if (change) {
                item.reinstate();
              }
              whatHasChanged.setReinstated();
            }
          }
 else {
            throw new MetadataImportException(""String_Node_Str"" + action);
          }
        }
        if (whatHasChanged.hasChanges()) {
          changes.add(whatHasChanged);
        }
      }
 else {
        if (c.getCurrentUser() == null) {
          throw new MetadataImportException(""String_Node_Str"");
        }
        BulkEditChange whatHasChanged=new BulkEditChange();
        for (        String md : line.keys()) {
          if (!""String_Node_Str"".equals(md)) {
            String[] fromCSV=line.get(md).toArray(new String[line.get(md).size()]);
            if (!isAuthorityControlledField(md)) {
              for (int i=0; i < fromCSV.length; i++) {
                int pos=fromCSV[i].indexOf(DSpaceCSV.authoritySeparator);
                if (pos > -1) {
                  fromCSV[i]=fromCSV[i].substring(0,pos);
                }
              }
            }
            add(fromCSV,md,whatHasChanged);
          }
        }
        List<String> collections=line.get(""String_Node_Str"");
        if (collections == null) {
          throw new MetadataImportException(""String_Node_Str"");
        }
        ArrayList<Collection> check=new ArrayList<Collection>();
        Collection collection;
        for (        String handle : collections) {
          try {
            collection=(Collection)HandleManager.resolveToObject(c,handle);
            if (collection == null) {
              throw new MetadataImportException(""String_Node_Str"" + handle + ""String_Node_Str"");
            }
            if (check.contains(collection)) {
              throw new MetadataImportException(""String_Node_Str"" + handle);
            }
 else {
              check.add(collection);
            }
          }
 catch (          Exception ex) {
            throw new MetadataImportException(""String_Node_Str"" + handle + ""String_Node_Str"",ex);
          }
        }
        boolean first=true;
        for (        String handle : collections) {
          Collection extra=(Collection)HandleManager.resolveToObject(c,handle);
          if (first) {
            whatHasChanged.setOwningCollection(extra);
          }
 else {
            whatHasChanged.registerNewMappedCollection(extra);
          }
          first=false;
        }
        if (change) {
          String collectionHandle=line.get(""String_Node_Str"").get(0);
          collection=(Collection)HandleManager.resolveToObject(c,collectionHandle);
          WorkspaceItem wsItem=WorkspaceItem.create(c,collection,useTemplate);
          Item item=wsItem.getItem();
          for (          Metadatum dcv : whatHasChanged.getAdds()) {
            item.addMetadata(dcv.schema,dcv.element,dcv.qualifier,dcv.language,dcv.value,dcv.authority,dcv.confidence);
          }
          if (useWorkflow) {
            if (ConfigurationManager.getProperty(""String_Node_Str"",""String_Node_Str"").equals(""String_Node_Str"")) {
              if (workflowNotify) {
                XmlWorkflowManager.start(c,wsItem);
              }
 else {
                XmlWorkflowManager.startWithoutNotify(c,wsItem);
              }
            }
 else {
              if (workflowNotify) {
                WorkflowManager.start(c,wsItem);
              }
 else {
                WorkflowManager.startWithoutNotify(c,wsItem);
              }
            }
          }
 else {
            InstallItem.installItem(c,wsItem);
          }
          if (line.get(""String_Node_Str"").size() > 0) {
            for (int i=1; i < collections.size(); i++) {
              String handle=collections.get(i);
              Collection extra=(Collection)HandleManager.resolveToObject(c,handle);
              extra.addItem(item);
            }
          }
          c.commit();
          whatHasChanged.setItem(item);
        }
        changes.add(whatHasChanged);
      }
    }
  }
 catch (  MetadataImportException mie) {
    throw mie;
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  return changes;
}","/** 
 * Run an import. The import can either be read-only to detect changes, or can write changes as it goes.
 * @param change Whether or not to write the changes to the database
 * @param useWorkflow Whether the workflows should be used when creating new items
 * @param workflowNotify If the workflows should be used, whether to send notifications or not
 * @param useTemplate Use collection template if create new item
 * @return An array of BulkEditChange elements representing the items that have changed
 * @throws MetadataImportException if something goes wrong
 */
public List<BulkEditChange> runImport(boolean change,boolean useWorkflow,boolean workflowNotify,boolean useTemplate) throws MetadataImportException {
  ArrayList<BulkEditChange> changes=new ArrayList<BulkEditChange>();
  try {
    for (    DSpaceCSVLine line : toImport) {
      int id=line.getID();
      if (csv.hasActions() && (!""String_Node_Str"".equals(line.getAction())) && (id == -1)) {
        throw new MetadataImportException(""String_Node_Str"");
      }
      if (id != -1) {
        Item item=Item.find(c,id);
        if (item == null) {
          throw new MetadataImportException(""String_Node_Str"" + id);
        }
        BulkEditChange whatHasChanged=new BulkEditChange(item);
        List<String> collections=line.get(""String_Node_Str"");
        if (collections != null) {
          if (collections.size() == 0) {
            throw new MetadataImportException(""String_Node_Str"" + item.getHandle());
          }
          Collection[] actualCollections=item.getCollections();
          compare(item,collections,actualCollections,whatHasChanged,change);
        }
        for (        String md : line.keys()) {
          if (!""String_Node_Str"".equals(md)) {
            String[] fromCSV=line.get(md).toArray(new String[line.get(md).size()]);
            if (!isAuthorityControlledField(md)) {
              for (int i=0; i < fromCSV.length; i++) {
                int pos=fromCSV[i].indexOf(DSpaceCSV.authoritySeparator);
                if (pos > -1) {
                  fromCSV[i]=fromCSV[i].substring(0,pos);
                }
              }
            }
            compare(item,fromCSV,change,md,whatHasChanged,line);
          }
        }
        if (csv.hasActions()) {
          String action=line.getAction();
          if (""String_Node_Str"".equals(action)) {
          }
 else           if (""String_Node_Str"".equals(action)) {
            if (!ConfigurationManager.getBooleanProperty(""String_Node_Str"",""String_Node_Str"",false)) {
              throw new MetadataImportException(""String_Node_Str"");
            }
            Collection[] owners=item.getCollections();
            for (            Collection owner : owners) {
              if (change) {
                owner.removeItem(item);
              }
            }
            whatHasChanged.setDeleted();
          }
 else           if (""String_Node_Str"".equals(action)) {
            if (!item.isWithdrawn()) {
              if (change) {
                item.withdraw();
              }
              whatHasChanged.setWithdrawn();
            }
          }
 else           if (""String_Node_Str"".equals(action)) {
            if (item.isWithdrawn()) {
              if (change) {
                item.reinstate();
              }
              whatHasChanged.setReinstated();
            }
          }
 else {
            throw new MetadataImportException(""String_Node_Str"" + action);
          }
        }
        if (whatHasChanged.hasChanges()) {
          changes.add(whatHasChanged);
        }
      }
 else {
        if (c.getCurrentUser() == null) {
          throw new MetadataImportException(""String_Node_Str"");
        }
        BulkEditChange whatHasChanged=new BulkEditChange();
        for (        String md : line.keys()) {
          if (!""String_Node_Str"".equals(md)) {
            String[] fromCSV=line.get(md).toArray(new String[line.get(md).size()]);
            if (!isAuthorityControlledField(md)) {
              for (int i=0; i < fromCSV.length; i++) {
                int pos=fromCSV[i].indexOf(DSpaceCSV.authoritySeparator);
                if (pos > -1) {
                  fromCSV[i]=fromCSV[i].substring(0,pos);
                }
              }
            }
            add(fromCSV,md,whatHasChanged);
          }
        }
        List<String> collections=line.get(""String_Node_Str"");
        if (collections == null) {
          throw new MetadataImportException(""String_Node_Str"");
        }
        ArrayList<Collection> check=new ArrayList<Collection>();
        Collection collection;
        for (        String handle : collections) {
          try {
            collection=(Collection)HandleManager.resolveToObject(c,handle);
            if (collection == null) {
              throw new MetadataImportException(""String_Node_Str"" + handle + ""String_Node_Str"");
            }
            if (check.contains(collection)) {
              throw new MetadataImportException(""String_Node_Str"" + handle);
            }
 else {
              check.add(collection);
            }
          }
 catch (          Exception ex) {
            throw new MetadataImportException(""String_Node_Str"" + handle + ""String_Node_Str"",ex);
          }
        }
        boolean first=true;
        for (        String handle : collections) {
          Collection extra=(Collection)HandleManager.resolveToObject(c,handle);
          if (first) {
            whatHasChanged.setOwningCollection(extra);
          }
 else {
            whatHasChanged.registerNewMappedCollection(extra);
          }
          first=false;
        }
        if (change) {
          String collectionHandle=line.get(""String_Node_Str"").get(0);
          collection=(Collection)HandleManager.resolveToObject(c,collectionHandle);
          WorkspaceItem wsItem=WorkspaceItem.create(c,collection,useTemplate);
          Item item=wsItem.getItem();
          for (          Metadatum dcv : whatHasChanged.getAdds()) {
            item.addMetadata(dcv.schema,dcv.element,dcv.qualifier,dcv.language,dcv.value,dcv.authority,dcv.confidence);
          }
          if (useWorkflow) {
            if (ConfigurationManager.getProperty(""String_Node_Str"",""String_Node_Str"").equals(""String_Node_Str"")) {
              if (workflowNotify) {
                XmlWorkflowManager.start(c,wsItem);
              }
 else {
                XmlWorkflowManager.startWithoutNotify(c,wsItem);
              }
            }
 else {
              if (workflowNotify) {
                WorkflowManager.start(c,wsItem);
              }
 else {
                WorkflowManager.startWithoutNotify(c,wsItem);
              }
            }
          }
 else {
            InstallItem.installItem(c,wsItem);
          }
          if (line.get(""String_Node_Str"").size() > 0) {
            for (int i=1; i < collections.size(); i++) {
              String handle=collections.get(i);
              Collection extra=(Collection)HandleManager.resolveToObject(c,handle);
              extra.addItem(item);
            }
          }
          c.commit();
          whatHasChanged.setItem(item);
        }
        changes.add(whatHasChanged);
      }
    }
  }
 catch (  MetadataImportException mie) {
    throw mie;
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  return changes;
}",0.999657416923604
52022,"/** 
 * is the field is defined as authority controlled
 */
private static boolean isAuthorityControlledField(String md){
  int pos=md.indexOf(""String_Node_Str"");
  String mdf=(pos > -1 ? md.substring(0,pos) : md);
  return authorityControlled.contains(mdf);
}","/** 
 * is the field is defined as authority controlled
 */
private static boolean isAuthorityControlledField(String md){
  int pos=md.indexOf(""String_Node_Str"");
  String mdf=(pos > -1 ? md.substring(0,pos) : md);
  pos=md.indexOf(""String_Node_Str"");
  mdf=(pos > -1 ? md.substring(pos + 1) : md);
  return authorityControlled.contains(mdf);
}",0.8609271523178808
52023,"private Metadatum getDcValueFromCSV(String language,String schema,String element,String qualifier,String value,AuthorityValue fromAuthority){
  Metadatum dcv=new Metadatum();
  dcv.schema=schema;
  dcv.element=element;
  dcv.qualifier=qualifier;
  dcv.language=language;
  if (fromAuthority != null) {
    if (value.indexOf(':') > 0) {
      value=value.substring(0,value.indexOf(':'));
    }
    List<AuthorityValue> byValue=authorityValueFinder.findByValue(c,schema,element,qualifier,value);
    AuthorityValue authorityValue=null;
    if (byValue.isEmpty()) {
      String toGenerate=fromAuthority.generateString() + value;
      String field=schema + ""String_Node_Str"" + element+ (StringUtils.isNotBlank(qualifier) ? ""String_Node_Str"" + qualifier : ""String_Node_Str"");
      authorityValue=AuthorityValueGenerator.generate(toGenerate,value,field);
      dcv.authority=toGenerate;
    }
 else {
      authorityValue=byValue.get(0);
      dcv.authority=authorityValue.getId();
    }
    dcv.value=authorityValue.getValue();
    dcv.confidence=Choices.CF_ACCEPTED;
  }
 else   if (value == null || !value.contains(DSpaceCSV.authoritySeparator)) {
    simplyCopyValue(value,dcv);
  }
 else {
    String[] parts=value.split(DSpaceCSV.escapedAuthoritySeparator);
    dcv.value=parts[0];
    dcv.authority=parts[1];
    dcv.confidence=(parts.length > 2 ? Integer.valueOf(parts[2]) : Choices.CF_ACCEPTED);
  }
  return dcv;
}","private Metadatum getDcValueFromCSV(String language,String schema,String element,String qualifier,String value,AuthorityValue fromAuthority){
  Metadatum dcv=new Metadatum();
  dcv.schema=schema;
  dcv.element=element;
  dcv.qualifier=qualifier;
  dcv.language=language;
  if (fromAuthority != null) {
    if (value.indexOf(':') > 0) {
      value=value.substring(0,value.indexOf(':'));
    }
    AuthorityValue example=fromAuthority.newInstance(value);
    List<AuthorityValue> byValue=authorityValueFinder.findByValue(c,schema,element,qualifier,example.getValue());
    AuthorityValue authorityValue=null;
    if (byValue.isEmpty()) {
      String toGenerate=fromAuthority.generateString() + value;
      String field=schema + ""String_Node_Str"" + element+ (StringUtils.isNotBlank(qualifier) ? ""String_Node_Str"" + qualifier : ""String_Node_Str"");
      authorityValue=AuthorityValueGenerator.generate(toGenerate,value,field);
      dcv.authority=toGenerate;
    }
 else {
      authorityValue=byValue.get(0);
      dcv.authority=authorityValue.getId();
    }
    dcv.value=authorityValue.getValue();
    dcv.confidence=Choices.CF_ACCEPTED;
  }
 else   if (value == null || !value.contains(DSpaceCSV.authoritySeparator)) {
    simplyCopyValue(value,dcv);
  }
 else {
    String[] parts=value.split(DSpaceCSV.escapedAuthoritySeparator);
    dcv.value=parts[0];
    dcv.authority=parts[1];
    dcv.confidence=(parts.length > 2 ? Integer.valueOf(parts[2]) : Choices.CF_ACCEPTED);
  }
  return dcv;
}",0.97119341563786
52024,"/** 
 * Add the basic navigational options: Search - advanced search browse - browse by Titles - browse by Authors - browse by Dates language FIXME: add languages context no context options are added. action no action options are added.
 */
public void addOptions(Options options) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Context context=ContextUtil.obtainContext(objectModel);
  Request request=ObjectModelHelper.getRequest(objectModel);
  options.addList(""String_Node_Str"");
  options.addList(""String_Node_Str"");
  options.addList(""String_Node_Str"");
  options.addList(""String_Node_Str"");
  String uri=request.getSitemapURI();
  String search_export_config=ConfigurationManager.getProperty(""String_Node_Str"");
  String query=decodeFromURL(request.getParameter(""String_Node_Str""));
  String scope=request.getParameter(""String_Node_Str"");
  String fqps=""String_Node_Str"";
  String[] fqs=DiscoveryUIUtils.getFilterQueries(ObjectModelHelper.getRequest(objectModel),context);
  if (fqs != null) {
    for (int i=0; i < fqs.length; i++) {
      if (i < fqs.length - 1)       fqps+=fqs[i] + ""String_Node_Str"";
 else       fqps+=fqs[i];
    }
  }
  if (uri.contains(""String_Node_Str"")) {
    if (""String_Node_Str"".equals(query))     query=""String_Node_Str"";
    if (uri.contains(""String_Node_Str"")) {
      scope=uri.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
    }
    try {
      scope=scope.replace(""String_Node_Str"",""String_Node_Str"");
    }
 catch (    NullPointerException e) {
    }
    if (search_export_config != null) {
      if (search_export_config.equals(""String_Node_Str"")) {
        if (AuthorizeManager.isAdmin(context)) {
          List results=options.addList(""String_Node_Str"");
          results.setHead(T_context_head);
          results.addItem().addXref(contextPath + ""String_Node_Str"" + query+ ""String_Node_Str""+ scope+ ""String_Node_Str""+ fqps,T_export_metadata);
        }
      }
 else       if (search_export_config.equals(""String_Node_Str"") || search_export_config.equals(""String_Node_Str"")) {
        List results=options.addList(""String_Node_Str"");
        results.setHead(T_context_head);
        results.addItem().addXref(contextPath + ""String_Node_Str"" + query+ ""String_Node_Str""+ scope+ ""String_Node_Str""+ fqps,T_export_metadata);
      }
    }
  }
}","/** 
 * Add the basic navigational options: Search - advanced search browse - browse by Titles - browse by Authors - browse by Dates language FIXME: add languages context no context options are added. action no action options are added.
 */
public void addOptions(Options options) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Context context=ContextUtil.obtainContext(objectModel);
  Request request=ObjectModelHelper.getRequest(objectModel);
  options.addList(""String_Node_Str"");
  options.addList(""String_Node_Str"");
  options.addList(""String_Node_Str"");
  options.addList(""String_Node_Str"");
  String uri=request.getSitemapURI();
  String search_export_config=ConfigurationManager.getProperty(""String_Node_Str"");
  String query=decodeFromURL(request.getParameter(""String_Node_Str""));
  String scope=request.getParameter(""String_Node_Str"");
  String filters=""String_Node_Str"";
  String[] fqs=DiscoveryUIUtils.getFilterQueries(ObjectModelHelper.getRequest(objectModel),context);
  if (fqs != null) {
    for (int i=0; i < fqs.length; i++) {
      if (i < fqs.length - 1)       filters+=fqs[i] + ""String_Node_Str"";
 else       filters+=fqs[i];
    }
  }
  if (uri.contains(""String_Node_Str"")) {
    if (scope == null || ""String_Node_Str"".equals(scope))     scope=""String_Node_Str"";
    if (query == null || ""String_Node_Str"".equals(query))     query=""String_Node_Str"";
    if (uri.contains(""String_Node_Str"")) {
      scope=uri.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
    }
    try {
      scope=scope.replace(""String_Node_Str"",""String_Node_Str"");
    }
 catch (    NullPointerException e) {
    }
    if (search_export_config != null) {
      if (false) {
        log.warn(""String_Node_Str"");
        log.warn(""String_Node_Str"" + uri);
        log.warn(""String_Node_Str"" + query);
        log.warn(""String_Node_Str"" + scope);
        log.warn(""String_Node_Str"" + filters);
        log.warn(""String_Node_Str"");
      }
      if (search_export_config.equals(""String_Node_Str"")) {
        if (AuthorizeManager.isAdmin(context)) {
          List results=options.addList(""String_Node_Str"");
          results.setHead(T_context_head);
          results.addItem().addXref(contextPath + ""String_Node_Str"" + query+ ""String_Node_Str""+ scope+ ""String_Node_Str""+ filters,T_export_metadata);
        }
      }
 else       if (search_export_config.equals(""String_Node_Str"") || search_export_config.equals(""String_Node_Str"")) {
        List results=options.addList(""String_Node_Str"");
        results.setHead(T_context_head);
        results.addItem().addXref(contextPath + ""String_Node_Str"" + query+ ""String_Node_Str""+ scope+ ""String_Node_Str""+ filters,T_export_metadata);
      }
    }
  }
}",0.9187306501547988
52025,"public void run(){
  Context context=null;
  String importDir=null;
  EPerson eperson=null;
  try {
    context=new Context();
    eperson=EPerson.find(context,oldEPerson.getID());
    context.setCurrentUser(eperson);
    context.setIgnoreAuthorization(true);
    boolean isResume=theResumeDir != null;
    List<Collection> collectionList=new ArrayList<Collection>();
    if (theOtherCollections != null) {
      for (      String colID : theOtherCollections) {
        int colId=Integer.parseInt(colID);
        if (colId != theOwningCollection.getID()) {
          Collection col=Collection.find(context,colId);
          if (col != null) {
            collectionList.add(col);
          }
        }
      }
    }
    Collection[] otherCollections=collectionList.toArray(new Collection[collectionList.size()]);
    importDir=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ context.getCurrentUser().getID()+ File.separator+ (isResume ? theResumeDir : (new GregorianCalendar()).getTimeInMillis());
    File importDirFile=new File(importDir);
    if (!importDirFile.exists()) {
      boolean success=importDirFile.mkdirs();
      if (!success) {
        log.info(""String_Node_Str"");
        throw new Exception(""String_Node_Str"");
      }
    }
    String dataPath=null;
    String dataDir=null;
    if (theInputType.equals(""String_Node_Str"")) {
      dataPath=importDirFile + File.separator + ""String_Node_Str"";
      dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
    }
 else     if (theInputType.equals(""String_Node_Str"")) {
      FileUtils.copyFileToDirectory(new File(theFilePath),importDirFile);
      dataPath=importDirFile + File.separator + (new File(theFilePath)).getName();
      dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
    }
 else {
      dataPath=importDirFile + File.separator + (new File(theFilePath)).getName();
      dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
    }
    if (isResume) {
      (new File(dataPath)).delete();
      FileDeleteStrategy.FORCE.delete(new File(dataDir));
    }
    String sourcePath=null;
    if (theInputType.equals(""String_Node_Str"")) {
      OutputStream os=new FileOutputStream(dataPath);
      byte[] b=new byte[2048];
      int length;
      InputStream is=new URL(theFilePath).openStream();
      while ((length=is.read(b)) != -1) {
        os.write(b,0,length);
      }
      is.close();
      os.close();
      sourcePath=unzip(new File(dataPath),dataDir);
      FileUtils.moveDirectory(new File(sourcePath),new File(importDirFile + File.separator + ""String_Node_Str""+ File.separator));
      FileDeleteStrategy.FORCE.delete(new File(dataDir));
      dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
    }
 else     if (theInputType.equals(""String_Node_Str"")) {
      sourcePath=unzip(new File(dataPath),dataDir);
      FileUtils.moveDirectory(new File(sourcePath),new File(importDirFile + File.separator + ""String_Node_Str""+ File.separator));
      FileDeleteStrategy.FORCE.delete(new File(dataDir));
      dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
    }
    String mapFilePath=importDirFile + File.separator + ""String_Node_Str"";
    Collection[] finalCollections=null;
    if (theOwningCollection != null) {
      finalCollections=new Collection[otherCollections.length + 1];
      finalCollections[0]=theOwningCollection;
      for (int i=0; i < otherCollections.length; i++) {
        finalCollections[i + 1]=otherCollections[i];
      }
    }
    ItemImport myloader=new ItemImport();
    myloader.isResume=isResume;
    if (theInputType.equals(""String_Node_Str"") || theInputType.equals(""String_Node_Str"")) {
      myloader.addItems(context,finalCollections,dataDir,mapFilePath,template);
    }
 else {
      myloader.addBTEItems(context,finalCollections,theFilePath,mapFilePath,template,theInputType,dataDir);
    }
    emailSuccessMessage(context,eperson,mapFilePath);
    context.complete();
  }
 catch (  Exception e) {
    e.printStackTrace();
    String exceptionString=ExceptionUtils.getStackTrace(e);
    if (mapOut != null) {
      mapOut.close();
    }
    mapOut=null;
    try {
      File importDirFile=new File(importDir + File.separator + ""String_Node_Str"");
      PrintWriter errorWriter=new PrintWriter(importDirFile);
      errorWriter.print(exceptionString);
      errorWriter.close();
      emailErrorMessage(eperson,exceptionString);
      throw new Exception(e.getMessage());
    }
 catch (    Exception e2) {
    }
  }
 finally {
    if (mapOut != null) {
      mapOut.close();
    }
    try {
      context.complete();
    }
 catch (    SQLException sqle) {
      context.abort();
    }
  }
}","public void run(){
  Context context=null;
  String importDir=null;
  EPerson eperson=null;
  try {
    context=new Context();
    eperson=EPerson.find(context,oldEPerson.getID());
    context.setCurrentUser(eperson);
    context.setIgnoreAuthorization(true);
    boolean isResume=theResumeDir != null;
    List<Collection> collectionList=new ArrayList<Collection>();
    if (theOtherCollections != null) {
      for (      String colID : theOtherCollections) {
        int colId=Integer.parseInt(colID);
        if (colId != theOwningCollection.getID()) {
          Collection col=Collection.find(context,colId);
          if (col != null) {
            collectionList.add(col);
          }
        }
      }
    }
    Collection[] otherCollections=collectionList.toArray(new Collection[collectionList.size()]);
    importDir=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ context.getCurrentUser().getID()+ File.separator+ (isResume ? theResumeDir : (new GregorianCalendar()).getTimeInMillis());
    File importDirFile=new File(importDir);
    if (!importDirFile.exists()) {
      boolean success=importDirFile.mkdirs();
      if (!success) {
        log.info(""String_Node_Str"");
        throw new Exception(""String_Node_Str"");
      }
    }
    String dataPath=null;
    String dataDir=null;
    if (theInputType.equals(""String_Node_Str"")) {
      dataPath=importDirFile + File.separator + ""String_Node_Str"";
      dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
    }
 else     if (theInputType.equals(""String_Node_Str"")) {
      FileUtils.copyFileToDirectory(new File(theFilePath),importDirFile);
      dataPath=importDirFile + File.separator + (new File(theFilePath)).getName();
      dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
    }
 else {
      dataPath=importDirFile + File.separator + (new File(theFilePath)).getName();
      dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
    }
    if (isResume) {
      if (!theInputType.equals(""String_Node_Str"")) {
        (new File(dataPath)).delete();
      }
      (new File(importDirFile + File.separator + ""String_Node_Str"")).delete();
      FileDeleteStrategy.FORCE.delete(new File(dataDir));
      FileDeleteStrategy.FORCE.delete(new File(importDirFile + File.separator + ""String_Node_Str""+ File.separator));
    }
    String sourcePath=null;
    if (theInputType.equals(""String_Node_Str"")) {
      OutputStream os=new FileOutputStream(dataPath);
      byte[] b=new byte[2048];
      int length;
      InputStream is=new URL(theFilePath).openStream();
      while ((length=is.read(b)) != -1) {
        os.write(b,0,length);
      }
      is.close();
      os.close();
      sourcePath=unzip(new File(dataPath),dataDir);
      FileUtils.moveDirectory(new File(sourcePath),new File(importDirFile + File.separator + ""String_Node_Str""+ File.separator));
      FileDeleteStrategy.FORCE.delete(new File(dataDir));
      dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
    }
 else     if (theInputType.equals(""String_Node_Str"")) {
      sourcePath=unzip(new File(dataPath),dataDir);
      FileUtils.moveDirectory(new File(sourcePath),new File(importDirFile + File.separator + ""String_Node_Str""+ File.separator));
      FileDeleteStrategy.FORCE.delete(new File(dataDir));
      dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
    }
    String mapFilePath=importDirFile + File.separator + ""String_Node_Str"";
    Collection[] finalCollections=null;
    if (theOwningCollection != null) {
      finalCollections=new Collection[otherCollections.length + 1];
      finalCollections[0]=theOwningCollection;
      for (int i=0; i < otherCollections.length; i++) {
        finalCollections[i + 1]=otherCollections[i];
      }
    }
    ItemImport myloader=new ItemImport();
    myloader.isResume=isResume;
    if (theInputType.equals(""String_Node_Str"") || theInputType.equals(""String_Node_Str"")) {
      myloader.addItems(context,finalCollections,dataDir,mapFilePath,template);
    }
 else {
      myloader.addBTEItems(context,finalCollections,theFilePath,mapFilePath,template,theInputType,dataDir);
    }
    emailSuccessMessage(context,eperson,mapFilePath);
    context.complete();
  }
 catch (  Exception e) {
    e.printStackTrace();
    String exceptionString=ExceptionUtils.getStackTrace(e);
    if (mapOut != null) {
      mapOut.close();
    }
    mapOut=null;
    try {
      File importDirFile=new File(importDir + File.separator + ""String_Node_Str"");
      PrintWriter errorWriter=new PrintWriter(importDirFile);
      errorWriter.print(exceptionString);
      errorWriter.close();
      emailErrorMessage(eperson,exceptionString);
      throw new Exception(e.getMessage());
    }
 catch (    Exception e2) {
    }
  }
 finally {
    if (mapOut != null) {
      mapOut.close();
    }
    try {
      context.complete();
    }
 catch (    SQLException sqle) {
      context.abort();
    }
  }
}",0.9736654804270464
52026,"/** 
 * Given a local file or public URL to a zip file that has the Simple Archive Format, this method imports the contents to DSpace
 * @param filepath The filepath to local file or the public URL of the zip file
 * @param owningCollection The owning collection the items will belong to
 * @param otherCollections The collections the created items will be inserted to, apart from the owning one
 * @param resumeDir In case of a resume request, the directory that containsthe old mapfile and data 
 * @param inputType The input type of the data (bibtex, csv, etc.), in case of local file
 * @param context The context
 * @throws Exception
 */
public static void processUIImport(String filepath,Collection owningCollection,String[] otherCollections,String resumeDir,String inputType,Context context) throws Exception {
  final EPerson oldEPerson=context.getCurrentUser();
  final String[] theOtherCollections=otherCollections;
  final Collection theOwningCollection=owningCollection;
  final String theFilePath=filepath;
  final String theInputType=inputType;
  final String theResumeDir=resumeDir;
  Thread go=new Thread(){
    public void run(){
      Context context=null;
      String importDir=null;
      EPerson eperson=null;
      try {
        context=new Context();
        eperson=EPerson.find(context,oldEPerson.getID());
        context.setCurrentUser(eperson);
        context.setIgnoreAuthorization(true);
        boolean isResume=theResumeDir != null;
        List<Collection> collectionList=new ArrayList<Collection>();
        if (theOtherCollections != null) {
          for (          String colID : theOtherCollections) {
            int colId=Integer.parseInt(colID);
            if (colId != theOwningCollection.getID()) {
              Collection col=Collection.find(context,colId);
              if (col != null) {
                collectionList.add(col);
              }
            }
          }
        }
        Collection[] otherCollections=collectionList.toArray(new Collection[collectionList.size()]);
        importDir=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ context.getCurrentUser().getID()+ File.separator+ (isResume ? theResumeDir : (new GregorianCalendar()).getTimeInMillis());
        File importDirFile=new File(importDir);
        if (!importDirFile.exists()) {
          boolean success=importDirFile.mkdirs();
          if (!success) {
            log.info(""String_Node_Str"");
            throw new Exception(""String_Node_Str"");
          }
        }
        String dataPath=null;
        String dataDir=null;
        if (theInputType.equals(""String_Node_Str"")) {
          dataPath=importDirFile + File.separator + ""String_Node_Str"";
          dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
        }
 else         if (theInputType.equals(""String_Node_Str"")) {
          FileUtils.copyFileToDirectory(new File(theFilePath),importDirFile);
          dataPath=importDirFile + File.separator + (new File(theFilePath)).getName();
          dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
        }
 else {
          dataPath=importDirFile + File.separator + (new File(theFilePath)).getName();
          dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
        }
        if (isResume) {
          (new File(dataPath)).delete();
          FileDeleteStrategy.FORCE.delete(new File(dataDir));
        }
        String sourcePath=null;
        if (theInputType.equals(""String_Node_Str"")) {
          OutputStream os=new FileOutputStream(dataPath);
          byte[] b=new byte[2048];
          int length;
          InputStream is=new URL(theFilePath).openStream();
          while ((length=is.read(b)) != -1) {
            os.write(b,0,length);
          }
          is.close();
          os.close();
          sourcePath=unzip(new File(dataPath),dataDir);
          FileUtils.moveDirectory(new File(sourcePath),new File(importDirFile + File.separator + ""String_Node_Str""+ File.separator));
          FileDeleteStrategy.FORCE.delete(new File(dataDir));
          dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
        }
 else         if (theInputType.equals(""String_Node_Str"")) {
          sourcePath=unzip(new File(dataPath),dataDir);
          FileUtils.moveDirectory(new File(sourcePath),new File(importDirFile + File.separator + ""String_Node_Str""+ File.separator));
          FileDeleteStrategy.FORCE.delete(new File(dataDir));
          dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
        }
        String mapFilePath=importDirFile + File.separator + ""String_Node_Str"";
        Collection[] finalCollections=null;
        if (theOwningCollection != null) {
          finalCollections=new Collection[otherCollections.length + 1];
          finalCollections[0]=theOwningCollection;
          for (int i=0; i < otherCollections.length; i++) {
            finalCollections[i + 1]=otherCollections[i];
          }
        }
        ItemImport myloader=new ItemImport();
        myloader.isResume=isResume;
        if (theInputType.equals(""String_Node_Str"") || theInputType.equals(""String_Node_Str"")) {
          myloader.addItems(context,finalCollections,dataDir,mapFilePath,template);
        }
 else {
          myloader.addBTEItems(context,finalCollections,theFilePath,mapFilePath,template,theInputType,dataDir);
        }
        emailSuccessMessage(context,eperson,mapFilePath);
        context.complete();
      }
 catch (      Exception e) {
        e.printStackTrace();
        String exceptionString=ExceptionUtils.getStackTrace(e);
        if (mapOut != null) {
          mapOut.close();
        }
        mapOut=null;
        try {
          File importDirFile=new File(importDir + File.separator + ""String_Node_Str"");
          PrintWriter errorWriter=new PrintWriter(importDirFile);
          errorWriter.print(exceptionString);
          errorWriter.close();
          emailErrorMessage(eperson,exceptionString);
          throw new Exception(e.getMessage());
        }
 catch (        Exception e2) {
        }
      }
 finally {
        if (mapOut != null) {
          mapOut.close();
        }
        try {
          context.complete();
        }
 catch (        SQLException sqle) {
          context.abort();
        }
      }
    }
  }
;
  go.isDaemon();
  go.start();
}","/** 
 * Given a local file or public URL to a zip file that has the Simple Archive Format, this method imports the contents to DSpace
 * @param filepath The filepath to local file or the public URL of the zip file
 * @param owningCollection The owning collection the items will belong to
 * @param otherCollections The collections the created items will be inserted to, apart from the owning one
 * @param resumeDir In case of a resume request, the directory that containsthe old mapfile and data 
 * @param inputType The input type of the data (bibtex, csv, etc.), in case of local file
 * @param context The context
 * @throws Exception
 */
public static void processUIImport(String filepath,Collection owningCollection,String[] otherCollections,String resumeDir,String inputType,Context context) throws Exception {
  final EPerson oldEPerson=context.getCurrentUser();
  final String[] theOtherCollections=otherCollections;
  final Collection theOwningCollection=owningCollection;
  final String theFilePath=filepath;
  final String theInputType=inputType;
  final String theResumeDir=resumeDir;
  Thread go=new Thread(){
    public void run(){
      Context context=null;
      String importDir=null;
      EPerson eperson=null;
      try {
        context=new Context();
        eperson=EPerson.find(context,oldEPerson.getID());
        context.setCurrentUser(eperson);
        context.setIgnoreAuthorization(true);
        boolean isResume=theResumeDir != null;
        List<Collection> collectionList=new ArrayList<Collection>();
        if (theOtherCollections != null) {
          for (          String colID : theOtherCollections) {
            int colId=Integer.parseInt(colID);
            if (colId != theOwningCollection.getID()) {
              Collection col=Collection.find(context,colId);
              if (col != null) {
                collectionList.add(col);
              }
            }
          }
        }
        Collection[] otherCollections=collectionList.toArray(new Collection[collectionList.size()]);
        importDir=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ context.getCurrentUser().getID()+ File.separator+ (isResume ? theResumeDir : (new GregorianCalendar()).getTimeInMillis());
        File importDirFile=new File(importDir);
        if (!importDirFile.exists()) {
          boolean success=importDirFile.mkdirs();
          if (!success) {
            log.info(""String_Node_Str"");
            throw new Exception(""String_Node_Str"");
          }
        }
        String dataPath=null;
        String dataDir=null;
        if (theInputType.equals(""String_Node_Str"")) {
          dataPath=importDirFile + File.separator + ""String_Node_Str"";
          dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
        }
 else         if (theInputType.equals(""String_Node_Str"")) {
          FileUtils.copyFileToDirectory(new File(theFilePath),importDirFile);
          dataPath=importDirFile + File.separator + (new File(theFilePath)).getName();
          dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
        }
 else {
          dataPath=importDirFile + File.separator + (new File(theFilePath)).getName();
          dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
        }
        if (isResume) {
          if (!theInputType.equals(""String_Node_Str"")) {
            (new File(dataPath)).delete();
          }
          (new File(importDirFile + File.separator + ""String_Node_Str"")).delete();
          FileDeleteStrategy.FORCE.delete(new File(dataDir));
          FileDeleteStrategy.FORCE.delete(new File(importDirFile + File.separator + ""String_Node_Str""+ File.separator));
        }
        String sourcePath=null;
        if (theInputType.equals(""String_Node_Str"")) {
          OutputStream os=new FileOutputStream(dataPath);
          byte[] b=new byte[2048];
          int length;
          InputStream is=new URL(theFilePath).openStream();
          while ((length=is.read(b)) != -1) {
            os.write(b,0,length);
          }
          is.close();
          os.close();
          sourcePath=unzip(new File(dataPath),dataDir);
          FileUtils.moveDirectory(new File(sourcePath),new File(importDirFile + File.separator + ""String_Node_Str""+ File.separator));
          FileDeleteStrategy.FORCE.delete(new File(dataDir));
          dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
        }
 else         if (theInputType.equals(""String_Node_Str"")) {
          sourcePath=unzip(new File(dataPath),dataDir);
          FileUtils.moveDirectory(new File(sourcePath),new File(importDirFile + File.separator + ""String_Node_Str""+ File.separator));
          FileDeleteStrategy.FORCE.delete(new File(dataDir));
          dataDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
        }
        String mapFilePath=importDirFile + File.separator + ""String_Node_Str"";
        Collection[] finalCollections=null;
        if (theOwningCollection != null) {
          finalCollections=new Collection[otherCollections.length + 1];
          finalCollections[0]=theOwningCollection;
          for (int i=0; i < otherCollections.length; i++) {
            finalCollections[i + 1]=otherCollections[i];
          }
        }
        ItemImport myloader=new ItemImport();
        myloader.isResume=isResume;
        if (theInputType.equals(""String_Node_Str"") || theInputType.equals(""String_Node_Str"")) {
          myloader.addItems(context,finalCollections,dataDir,mapFilePath,template);
        }
 else {
          myloader.addBTEItems(context,finalCollections,theFilePath,mapFilePath,template,theInputType,dataDir);
        }
        emailSuccessMessage(context,eperson,mapFilePath);
        context.complete();
      }
 catch (      Exception e) {
        e.printStackTrace();
        String exceptionString=ExceptionUtils.getStackTrace(e);
        if (mapOut != null) {
          mapOut.close();
        }
        mapOut=null;
        try {
          File importDirFile=new File(importDir + File.separator + ""String_Node_Str"");
          PrintWriter errorWriter=new PrintWriter(importDirFile);
          errorWriter.print(exceptionString);
          errorWriter.close();
          emailErrorMessage(eperson,exceptionString);
          throw new Exception(e.getMessage());
        }
 catch (        Exception e2) {
        }
      }
 finally {
        if (mapOut != null) {
          mapOut.close();
        }
        try {
          context.complete();
        }
 catch (        SQLException sqle) {
          context.abort();
        }
      }
    }
  }
;
  go.isDaemon();
  go.start();
}",0.9790794979079498
52027,"/** 
 * Actually perform Reindexing in Discovery/Solr. This is synchronized so that only one thread can get in at a time.
 */
@Override public void run(){
synchronized (this.indexer) {
    if (DatabaseUtils.getReindexDiscovery()) {
      Context context=null;
      try {
        context=new Context();
        log.info(""String_Node_Str"");
        this.indexer.createIndex(context);
        this.indexer.buildSpellCheck();
        DatabaseUtils.setReindexDiscovery(false);
        log.info(""String_Node_Str"");
      }
 catch (      SearchServiceException sse) {
        log.warn(""String_Node_Str"",sse);
      }
catch (      SQLException|IOException e) {
        log.error(""String_Node_Str"",e);
      }
 finally {
        if (context != null && context.isValid())         context.abort();
      }
    }
  }
}","/** 
 * Actually perform Reindexing in Discovery/Solr. This is synchronized so that only one thread can get in at a time.
 */
@Override public void run(){
synchronized (this.indexer) {
    if (DatabaseUtils.getReindexDiscovery()) {
      Context context=null;
      try {
        context=new Context();
        log.info(""String_Node_Str"");
        this.indexer.cleanIndex(true);
        this.indexer.createIndex(context);
        this.indexer.buildSpellCheck();
        log.info(""String_Node_Str"");
      }
 catch (      SearchServiceException sse) {
        log.warn(""String_Node_Str"",sse);
      }
catch (      SQLException|IOException e) {
        log.error(""String_Node_Str"",e);
      }
 finally {
        DatabaseUtils.setReindexDiscovery(false);
        if (context != null && context.isValid())         context.abort();
      }
    }
  }
}",0.9159104658197216
52028,"public static boolean sequenceExists(Connection connection,String sequenceName){
  boolean exists=false;
  PreparedStatement statement=null;
  ResultSet results=null;
  boolean schemaFilter=false;
  try {
    String schema=getSchemaName(connection);
    schema=canonicalize(connection,schema);
    String dbtype=DatabaseManager.findDbKeyword(connection.getMetaData());
    String sequenceSQL=null;
switch (dbtype) {
case DatabaseManager.DBMS_POSTGRES:
      if (schema == null) {
        schema=""String_Node_Str"";
      }
    sequenceSQL=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  schemaFilter=true;
break;
case DatabaseManager.DBMS_ORACLE:
sequenceSQL=""String_Node_Str"";
break;
case DatabaseManager.DBMS_H2:
sequenceSQL=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
break;
default :
throw new SQLException(""String_Node_Str"" + dbtype + ""String_Node_Str"");
}
if (sequenceSQL != null) {
statement=connection.prepareStatement(sequenceSQL);
statement.setString(1,StringUtils.upperCase(sequenceName));
if (schemaFilter) {
statement.setString(2,StringUtils.upperCase(schema));
}
results=statement.executeQuery();
if (results != null && results.next() && results.getInt(1) > 0) {
exists=true;
}
}
}
 catch (SQLException e) {
log.error(""String_Node_Str"" + sequenceName + ""String_Node_Str"",e);
}
 finally {
try {
if (statement != null && !statement.isClosed()) statement.close();
if (results != null && !results.isClosed()) results.close();
}
 catch (SQLException e) {
}
}
return exists;
}","public static boolean sequenceExists(Connection connection,String sequenceName){
  boolean exists=false;
  PreparedStatement statement=null;
  ResultSet results=null;
  boolean schemaFilter=false;
  try {
    String schema=getSchemaName(connection);
    schema=canonicalize(connection,schema);
    sequenceName=canonicalize(connection,sequenceName);
    String dbtype=DatabaseManager.findDbKeyword(connection.getMetaData());
    String sequenceSQL=null;
switch (dbtype) {
case DatabaseManager.DBMS_POSTGRES:
      if (schema == null) {
        schema=""String_Node_Str"";
      }
    sequenceSQL=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  schemaFilter=true;
break;
case DatabaseManager.DBMS_ORACLE:
sequenceSQL=""String_Node_Str"";
break;
case DatabaseManager.DBMS_H2:
sequenceSQL=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
break;
default :
throw new SQLException(""String_Node_Str"" + dbtype + ""String_Node_Str"");
}
if (sequenceSQL != null) {
statement=connection.prepareStatement(sequenceSQL);
statement.setString(1,sequenceName);
if (schemaFilter) {
statement.setString(2,schema);
}
results=statement.executeQuery();
if (results != null && results.next() && results.getInt(1) > 0) {
exists=true;
}
}
}
 catch (SQLException e) {
log.error(""String_Node_Str"" + sequenceName + ""String_Node_Str"",e);
}
 finally {
try {
if (statement != null && !statement.isClosed()) statement.close();
if (results != null && !results.isClosed()) results.close();
}
 catch (SQLException e) {
}
}
return exists;
}",0.9671814671814672
52029,"/** 
 * Setup/Initialize the Flyway API to run against our DSpace database and point at our migration scripts.
 * @param datasource DataSource object initialized by DatabaseManager
 * @return initialized Flyway object
 */
private static Flyway setupFlyway(DataSource datasource){
  if (flywaydb == null) {
    try (Connection connection=datasource.getConnection()){
      flywaydb=new Flyway();
      flywaydb.setDataSource(datasource);
      flywaydb.setEncoding(""String_Node_Str"");
      DatabaseMetaData meta=connection.getMetaData();
      String dbType=DatabaseManager.findDbKeyword(meta);
      connection.close();
      ArrayList<String> scriptLocations=new ArrayList<String>();
      scriptLocations.add(""String_Node_Str"" + ConfigurationManager.getProperty(""String_Node_Str"") + ""String_Node_Str""+ dbType);
      scriptLocations.add(""String_Node_Str"" + dbType);
      scriptLocations.add(""String_Node_Str"");
      if (ConfigurationManager.getProperty(""String_Node_Str"",""String_Node_Str"").equals(""String_Node_Str"")) {
        scriptLocations.add(""String_Node_Str"");
      }
      log.info(""String_Node_Str"" + StringUtils.join(scriptLocations,""String_Node_Str""));
      flywaydb.setLocations(scriptLocations.toArray(new String[scriptLocations.size()]));
      flywaydb.setCallbacks(new DatabaseRegistryUpdater(),new DatabaseLegacyReindexer());
    }
 catch (    SQLException e) {
      log.error(""String_Node_Str"",e);
    }
  }
  return flywaydb;
}","/** 
 * Setup/Initialize the Flyway API to run against our DSpace database and point at our migration scripts.
 * @param datasource DataSource object initialized by DatabaseManager
 * @return initialized Flyway object
 */
private static Flyway setupFlyway(DataSource datasource){
  if (flywaydb == null) {
    try (Connection connection=datasource.getConnection()){
      flywaydb=new Flyway();
      flywaydb.setDataSource(datasource);
      flywaydb.setEncoding(""String_Node_Str"");
      DatabaseMetaData meta=connection.getMetaData();
      String dbType=DatabaseManager.findDbKeyword(meta);
      connection.close();
      ArrayList<String> scriptLocations=new ArrayList<String>();
      if (!dbType.equals(DatabaseManager.DBMS_H2)) {
        scriptLocations.add(""String_Node_Str"" + ConfigurationManager.getProperty(""String_Node_Str"") + ""String_Node_Str""+ dbType);
      }
      scriptLocations.add(""String_Node_Str"" + dbType);
      scriptLocations.add(""String_Node_Str"");
      if (ConfigurationManager.getProperty(""String_Node_Str"",""String_Node_Str"").equals(""String_Node_Str"")) {
        scriptLocations.add(""String_Node_Str"");
      }
      log.info(""String_Node_Str"" + StringUtils.join(scriptLocations,""String_Node_Str""));
      flywaydb.setLocations(scriptLocations.toArray(new String[scriptLocations.size()]));
      flywaydb.setCallbacks(new DatabaseRegistryUpdater(),new DatabaseLegacyReindexer());
    }
 catch (    SQLException e) {
      log.error(""String_Node_Str"",e);
    }
  }
  return flywaydb;
}",0.9787807342539576
52030,"/** 
 * Ensures the current database is up-to-date with regards to the latest DSpace DB schema. If the scheme is not up-to-date, then any necessary database migrations are performed. <P> FlywayDB (http://flywaydb.org/) is used to perform database migrations. If a Flyway DB migration fails it will be rolled back to the last successful migration, and any errors will be logged.
 * @param datasource DataSource object (retrieved from DatabaseManager())
 * @param connection Database connection
 * @throws SQLException If database cannot be upgraded.
 */
protected static synchronized void updateDatabase(DataSource datasource,Connection connection) throws SQLException {
  Flyway flyway=setupFlyway(datasource);
  if (!tableExists(connection,flyway.getTable())) {
    String dbVersion=determineDBVersion(connection);
    if (dbVersion == null) {
      flyway.init();
    }
 else {
      flyway.setInitVersion(dbVersion);
      flyway.setInitDescription(""String_Node_Str"" + dbVersion + ""String_Node_Str"");
      flyway.init();
    }
  }
  MigrationInfo[] pending=flyway.info().pending();
  if (pending != null && pending.length > 0) {
    log.info(""String_Node_Str"");
    for (    MigrationInfo info : pending) {
      log.info(""String_Node_Str"" + info.getVersion() + ""String_Node_Str""+ info.getDescription()+ ""String_Node_Str""+ info.getType()+ ""String_Node_Str""+ info.getState());
    }
    flyway.migrate();
    setReindexDiscovery(true);
  }
 else   log.info(""String_Node_Str"");
}","/** 
 * Ensures the current database is up-to-date with regards to the latest DSpace DB schema. If the scheme is not up-to-date, then any necessary database migrations are performed. <P> FlywayDB (http://flywaydb.org/) is used to perform database migrations. If a Flyway DB migration fails it will be rolled back to the last successful migration, and any errors will be logged.
 * @param datasource DataSource object (retrieved from DatabaseManager())
 * @param connection Database connection
 * @throws SQLException If database cannot be upgraded.
 */
protected static synchronized void updateDatabase(DataSource datasource,Connection connection) throws SQLException {
  Flyway flyway=setupFlyway(datasource);
  if (!tableExists(connection,flyway.getTable(),true)) {
    String dbVersion=determineDBVersion(connection);
    if (dbVersion == null) {
      flyway.init();
    }
 else {
      flyway.setInitVersion(dbVersion);
      flyway.setInitDescription(""String_Node_Str"" + dbVersion + ""String_Node_Str"");
      flyway.init();
    }
  }
  MigrationInfo[] pending=flyway.info().pending();
  if (pending != null && pending.length > 0) {
    log.info(""String_Node_Str"");
    for (    MigrationInfo info : pending) {
      log.info(""String_Node_Str"" + info.getVersion() + ""String_Node_Str""+ info.getDescription()+ ""String_Node_Str""+ info.getType()+ ""String_Node_Str""+ info.getState());
    }
    flyway.migrate();
    setReindexDiscovery(true);
  }
 else   log.info(""String_Node_Str"");
}",0.9983147960903268
52031,"/** 
 * Commandline tools for managing database changes, etc.
 * @param argv
 */
public static void main(String[] argv){
  if (argv.length != 1) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  try {
    DataSource dataSource=DatabaseManager.initDataSource();
    String url=ConfigurationManager.getProperty(""String_Node_Str"");
    Flyway flyway=setupFlyway(dataSource);
    if (argv[0].equalsIgnoreCase(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + url);
      System.out.println(""String_Node_Str"" + ConfigurationManager.getProperty(""String_Node_Str""));
      System.out.println(""String_Node_Str"" + ConfigurationManager.getProperty(""String_Node_Str""));
      System.out.println(""String_Node_Str"" + ConfigurationManager.getProperty(""String_Node_Str""));
      System.out.println(""String_Node_Str"" + ConfigurationManager.getProperty(""String_Node_Str""));
      System.out.println(""String_Node_Str"");
      try {
        Connection connection=dataSource.getConnection();
        connection.close();
      }
 catch (      SQLException sqle) {
        System.err.println(""String_Node_Str"");
        System.err.println(""String_Node_Str"" + sqle);
        System.err.println(""String_Node_Str"");
        System.exit(1);
      }
      System.out.println(""String_Node_Str"");
    }
 else     if (argv[0].equalsIgnoreCase(""String_Node_Str"")) {
      Connection connection=dataSource.getConnection();
      DatabaseMetaData meta=connection.getMetaData();
      System.out.println(""String_Node_Str"" + url);
      System.out.println(""String_Node_Str"" + meta.getDatabaseProductName() + ""String_Node_Str""+ meta.getDatabaseProductVersion());
      System.out.println(""String_Node_Str"" + meta.getDriverName() + ""String_Node_Str""+ meta.getDriverVersion());
      System.out.println(""String_Node_Str"" + MigrationInfoDumper.dumpToAsciiTable(flyway.info().all()));
      if (!tableExists(connection,flyway.getTable())) {
        System.out.println(""String_Node_Str"");
        String dbVersion=determineDBVersion(connection);
        if (dbVersion != null) {
          System.out.println(""String_Node_Str"" + dbVersion);
          System.out.println(""String_Node_Str"" + dbVersion + ""String_Node_Str"");
        }
      }
      connection.close();
    }
 else     if (argv[0].equalsIgnoreCase(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"" + url);
      System.out.println(""String_Node_Str"");
      DatabaseManager.getDbName();
      System.out.println(""String_Node_Str"");
    }
 else     if (argv[0].equalsIgnoreCase(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"" + url);
      System.out.println(""String_Node_Str"");
      flyway.repair();
      System.out.println(""String_Node_Str"");
    }
 else     if (argv[0].equalsIgnoreCase(""String_Node_Str"")) {
      BufferedReader input=new BufferedReader(new InputStreamReader(System.in));
      System.out.println(""String_Node_Str"" + url);
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.print(""String_Node_Str"");
      String choiceString=input.readLine();
      input.close();
      if (choiceString.equalsIgnoreCase(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"");
        cleanDatabase(flyway,dataSource);
        System.out.println(""String_Node_Str"");
      }
    }
 else {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    System.exit(0);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"");
    e.printStackTrace();
    System.exit(1);
  }
}","/** 
 * Commandline tools for managing database changes, etc.
 * @param argv
 */
public static void main(String[] argv){
  if (argv.length != 1) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  try {
    DataSource dataSource=DatabaseManager.initDataSource();
    String url=ConfigurationManager.getProperty(""String_Node_Str"");
    Flyway flyway=setupFlyway(dataSource);
    if (argv[0].equalsIgnoreCase(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + url);
      System.out.println(""String_Node_Str"" + ConfigurationManager.getProperty(""String_Node_Str""));
      System.out.println(""String_Node_Str"" + ConfigurationManager.getProperty(""String_Node_Str""));
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + ConfigurationManager.getProperty(""String_Node_Str""));
      System.out.println(""String_Node_Str"");
      try {
        Connection connection=dataSource.getConnection();
        connection.close();
      }
 catch (      SQLException sqle) {
        System.err.println(""String_Node_Str"");
        System.err.println(""String_Node_Str"" + sqle);
        System.err.println(""String_Node_Str"");
        System.exit(1);
      }
      System.out.println(""String_Node_Str"");
    }
 else     if (argv[0].equalsIgnoreCase(""String_Node_Str"")) {
      Connection connection=dataSource.getConnection();
      DatabaseMetaData meta=connection.getMetaData();
      System.out.println(""String_Node_Str"" + url);
      System.out.println(""String_Node_Str"" + meta.getDatabaseProductName() + ""String_Node_Str""+ meta.getDatabaseProductVersion());
      System.out.println(""String_Node_Str"" + meta.getDriverName() + ""String_Node_Str""+ meta.getDriverVersion());
      System.out.println(""String_Node_Str"" + MigrationInfoDumper.dumpToAsciiTable(flyway.info().all()));
      if (!tableExists(connection,flyway.getTable(),true)) {
        System.out.println(""String_Node_Str"");
        String dbVersion=determineDBVersion(connection);
        if (dbVersion != null) {
          System.out.println(""String_Node_Str"" + dbVersion);
          System.out.println(""String_Node_Str"" + dbVersion + ""String_Node_Str"");
        }
      }
      connection.close();
    }
 else     if (argv[0].equalsIgnoreCase(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"" + url);
      System.out.println(""String_Node_Str"");
      DatabaseManager.getDbName();
      System.out.println(""String_Node_Str"");
    }
 else     if (argv[0].equalsIgnoreCase(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"" + url);
      System.out.println(""String_Node_Str"");
      flyway.repair();
      System.out.println(""String_Node_Str"");
    }
 else     if (argv[0].equalsIgnoreCase(""String_Node_Str"")) {
      BufferedReader input=new BufferedReader(new InputStreamReader(System.in));
      System.out.println(""String_Node_Str"" + url);
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.print(""String_Node_Str"");
      String choiceString=input.readLine();
      input.close();
      if (choiceString.equalsIgnoreCase(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"");
        cleanDatabase(flyway,dataSource);
        System.out.println(""String_Node_Str"");
      }
    }
 else {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    System.exit(0);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"");
    e.printStackTrace();
    System.exit(1);
  }
}",0.9925645872715816
52032,"/** 
 * Determine if a particular database table exists in our database
 * @param connection Current Database Connection
 * @param tableName The name of the table
 * @return true if table of that name exists, false otherwise
 */
public static boolean tableExists(Connection connection,String tableName){
  String schema=ConfigurationManager.getProperty(""String_Node_Str"");
  if (StringUtils.isBlank(schema)) {
    schema=null;
  }
  boolean exists=false;
  ResultSet results=null;
  try {
    DatabaseMetaData meta=connection.getMetaData();
    if (meta.storesLowerCaseIdentifiers()) {
      schema=(schema == null) ? null : StringUtils.lowerCase(schema);
      tableName=StringUtils.lowerCase(tableName);
    }
 else     if (meta.storesUpperCaseIdentifiers()) {
      schema=(schema == null) ? null : StringUtils.upperCase(schema);
      tableName=StringUtils.upperCase(tableName);
    }
    results=meta.getTables(null,schema,tableName,null);
    if (results != null && results.next()) {
      exists=true;
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"" + tableName + ""String_Node_Str"",e);
  }
 finally {
    try {
      if (results != null && !results.isClosed())       results.close();
    }
 catch (    SQLException e) {
    }
  }
  return exists;
}","/** 
 * Determine if a particular database table exists in our database
 * @param connection Current Database Connection
 * @param tableName The name of the table
 * @param caseSensitive When ""true"", the case of the tableName will not be changed. When ""false, the name may be uppercased or lowercased based on DB type.
 * @return true if table of that name exists, false otherwise
 */
public static boolean tableExists(Connection connection,String tableName,boolean caseSensitive){
  String schema=ConfigurationManager.getProperty(""String_Node_Str"");
  if (StringUtils.isBlank(schema)) {
    schema=null;
  }
  boolean exists=false;
  ResultSet results=null;
  try {
    DatabaseMetaData meta=connection.getMetaData();
    if (!caseSensitive) {
      if (meta.storesLowerCaseIdentifiers()) {
        schema=(schema == null) ? null : StringUtils.lowerCase(schema);
        tableName=StringUtils.lowerCase(tableName);
      }
 else       if (meta.storesUpperCaseIdentifiers()) {
        schema=(schema == null) ? null : StringUtils.upperCase(schema);
        tableName=StringUtils.upperCase(tableName);
      }
    }
    results=meta.getTables(null,schema,tableName,null);
    if (results != null && results.next()) {
      exists=true;
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"" + tableName + ""String_Node_Str"",e);
  }
 finally {
    try {
      if (results != null && !results.isClosed())       results.close();
    }
 catch (    SQLException e) {
    }
  }
  return exists;
}",0.918705035971223
52033,"/** 
 * Process a node in the bitstream format registry XML file. The node must be a ""bitstream-type"" node
 * @param context DSpace context object
 * @param node the node in the DOM tree
 */
private static void loadFormat(Context context,Node node) throws SQLException, IOException, TransformerException, AuthorizeException {
  String mimeType=getElementData(node,""String_Node_Str"");
  String shortDesc=getElementData(node,""String_Node_Str"");
  String desc=getElementData(node,""String_Node_Str"");
  String supportLevelString=getElementData(node,""String_Node_Str"");
  int supportLevel=Integer.parseInt(supportLevelString);
  String internalString=getElementData(node,""String_Node_Str"");
  boolean internal=Boolean.valueOf(internalString).booleanValue();
  String[] extensions=getRepeatedElementData(node,""String_Node_Str"");
  BitstreamFormat exists=BitstreamFormat.findByMIMEType(context,mimeType);
  if (exists == null) {
    BitstreamFormat format=BitstreamFormat.create(context);
    format.setMIMEType(mimeType);
    format.setShortDescription(shortDesc);
    format.setDescription(desc);
    format.setSupportLevel(supportLevel);
    format.setInternal(internal);
    format.setExtensions(extensions);
    format.update();
  }
}","/** 
 * Process a node in the bitstream format registry XML file. The node must be a ""bitstream-type"" node
 * @param context DSpace context object
 * @param node the node in the DOM tree
 */
private static void loadFormat(Context context,Node node) throws SQLException, IOException, TransformerException, AuthorizeException {
  String mimeType=getElementData(node,""String_Node_Str"");
  String shortDesc=getElementData(node,""String_Node_Str"");
  String desc=getElementData(node,""String_Node_Str"");
  String supportLevelString=getElementData(node,""String_Node_Str"");
  int supportLevel=Integer.parseInt(supportLevelString);
  String internalString=getElementData(node,""String_Node_Str"");
  boolean internal=Boolean.valueOf(internalString).booleanValue();
  String[] extensions=getRepeatedElementData(node,""String_Node_Str"");
  BitstreamFormat exists=BitstreamFormat.findByMIMEType(context,mimeType);
  if (exists == null) {
    exists=BitstreamFormat.findByShortDescription(context,shortDesc);
  }
  if (exists == null) {
    BitstreamFormat format=BitstreamFormat.create(context);
    format.setMIMEType(mimeType);
    format.setShortDescription(shortDesc);
    format.setDescription(desc);
    format.setSupportLevel(supportLevel);
    format.setInternal(internal);
    format.setExtensions(extensions);
    format.update();
  }
}",0.9617486338797814
52034,"@Override public void afterMigrate(Connection connection){
  if (freshInstall) {
    updateRegistries();
    freshInstall=false;
  }
}","@Override public void afterMigrate(Connection connection){
  if (freshInstall) {
    updateRegistries();
    freshInstall=false;
  }
  Context context=null;
  try {
    context=new Context();
    context.turnOffAuthorisationSystem();
    Group.initDefaultGroupNames(context);
    context.restoreAuthSystemState();
    context.complete();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
  }
 finally {
    if (context != null && context.isValid())     context.abort();
  }
}",0.4294871794871794
52035,"/** 
 * Method to actually update our registries from latest configs
 */
private void updateRegistries(){
  Context context=null;
  try {
    context=new Context();
    context.turnOffAuthorisationSystem();
    String base=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator;
    log.info(""String_Node_Str"" + base + ""String_Node_Str"");
    RegistryLoader.loadBitstreamFormats(context,base + ""String_Node_Str"");
    log.info(""String_Node_Str"" + base);
    MetadataImporter.loadRegistry(base + ""String_Node_Str"",true);
    MetadataImporter.loadRegistry(base + ""String_Node_Str"",true);
    MetadataImporter.loadRegistry(base + ""String_Node_Str"",true);
    MetadataImporter.loadRegistry(base + ""String_Node_Str"",true);
    if (ConfigurationManager.getProperty(""String_Node_Str"",""String_Node_Str"").equals(""String_Node_Str"")) {
      MetadataImporter.loadRegistry(base + ""String_Node_Str"",true);
    }
    Group.initDefaultGroupNames(context);
    context.restoreAuthSystemState();
    context.complete();
    log.info(""String_Node_Str"");
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
  }
 finally {
    if (context != null && context.isValid())     context.abort();
  }
}","/** 
 * Method to actually update our registries from latest configs
 */
private void updateRegistries(){
  Context context=null;
  try {
    context=new Context();
    context.turnOffAuthorisationSystem();
    String base=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator;
    log.info(""String_Node_Str"" + base + ""String_Node_Str"");
    RegistryLoader.loadBitstreamFormats(context,base + ""String_Node_Str"");
    log.info(""String_Node_Str"" + base);
    MetadataImporter.loadRegistry(base + ""String_Node_Str"",true);
    MetadataImporter.loadRegistry(base + ""String_Node_Str"",true);
    MetadataImporter.loadRegistry(base + ""String_Node_Str"",true);
    MetadataImporter.loadRegistry(base + ""String_Node_Str"",true);
    if (ConfigurationManager.getProperty(""String_Node_Str"",""String_Node_Str"").equals(""String_Node_Str"")) {
      MetadataImporter.loadRegistry(base + ""String_Node_Str"",true);
    }
    context.restoreAuthSystemState();
    context.complete();
    log.info(""String_Node_Str"");
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
  }
 finally {
    if (context != null && context.isValid())     context.abort();
  }
}",0.9832268370607028
52036,"@Override public ItemMarkingInfo getItemMarkingInfo(Context context,Item item) throws SQLException {
  Bundle[] bundles=item.getBundles(""String_Node_Str"");
  if (bundles.length == 0) {
    ItemMarkingInfo markInfo=new ItemMarkingInfo();
    markInfo.setImageName(nonAvailableImageName);
    return markInfo;
  }
 else {
    Bundle originalBundle=bundles[0];
    if (originalBundle.getBitstreams().length == 0) {
      ItemMarkingInfo markInfo=new ItemMarkingInfo();
      markInfo.setImageName(nonAvailableImageName);
      return markInfo;
    }
 else {
      Bitstream bitstream=originalBundle.getBitstreams()[0];
      ItemMarkingInfo signInfo=new ItemMarkingInfo();
      signInfo.setImageName(availableImageName);
      signInfo.setTooltip(bitstream.getName());
      String bsLink=""String_Node_Str"";
      bsLink=bsLink + ""String_Node_Str"" + item.getHandle()+ ""String_Node_Str""+ bitstream.getSequenceID()+ ""String_Node_Str"";
      try {
        bsLink=bsLink + encodeBitstreamName(bitstream.getName(),Constants.DEFAULT_ENCODING);
      }
 catch (      UnsupportedEncodingException e) {
        e.printStackTrace();
      }
      signInfo.setLink(bsLink);
      return signInfo;
    }
  }
}","@Override public ItemMarkingInfo getItemMarkingInfo(Context context,Item item) throws SQLException {
  Bundle[] bundles=item.getBundles(""String_Node_Str"");
  if (bundles.length == 0) {
    ItemMarkingInfo markInfo=new ItemMarkingInfo();
    markInfo.setImageName(nonAvailableImageName);
    return markInfo;
  }
 else {
    Bundle originalBundle=bundles[0];
    if (originalBundle.getBitstreams().length == 0) {
      ItemMarkingInfo markInfo=new ItemMarkingInfo();
      markInfo.setImageName(nonAvailableImageName);
      return markInfo;
    }
 else {
      Bitstream bitstream=originalBundle.getBitstreams()[0];
      ItemMarkingInfo signInfo=new ItemMarkingInfo();
      signInfo.setImageName(availableImageName);
      signInfo.setTooltip(bitstream.getName());
      String bsLink=""String_Node_Str"";
      bsLink=bsLink + ""String_Node_Str"" + item.getHandle()+ ""String_Node_Str""+ bitstream.getSequenceID()+ ""String_Node_Str"";
      try {
        bsLink=bsLink + Util.encodeBitstreamName(bitstream.getName(),Constants.DEFAULT_ENCODING);
      }
 catch (      UnsupportedEncodingException e) {
        e.printStackTrace();
      }
      signInfo.setLink(bsLink);
      return signInfo;
    }
  }
}",0.9979123173277662
52037,"public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
  String browseListLine=null;
  String browseWidthLine=null;
  if (browseInfo != null) {
    SortOption so=browseInfo.getSortOption();
    BrowseIndex bix=browseInfo.getBrowseIndex();
    if (bix != null) {
      if (so != null && browseListLine == null) {
        browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str""+ so.getName()+ ""String_Node_Str"");
        browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str""+ so.getName()+ ""String_Node_Str"");
      }
      if (so == null) {
        so=bix.getSortOption();
      }
    }
    if (so != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
    }
    if (bix != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
    }
    if (so != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
    }
    if (bix != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
    }
  }
  if (browseListLine == null) {
    browseListLine=ConfigurationManager.getProperty(""String_Node_Str"");
    browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (browseListLine != null) {
    if (!showThumbs && browseListLine.contains(""String_Node_Str"")) {
      browseListLine=browseListLine == null ? ""String_Node_Str"" : browseListLine;
      browseWidthLine=browseWidthLine == null ? ""String_Node_Str"" : browseWidthLine;
      StringTokenizer bllt=new StringTokenizer(browseListLine,""String_Node_Str"");
      StringTokenizer bwlt=new StringTokenizer(browseWidthLine,""String_Node_Str"");
      StringBuilder newBLLine=new StringBuilder();
      StringBuilder newBWLine=new StringBuilder();
      while (bllt.hasMoreTokens() || bwlt.hasMoreTokens()) {
        String browseListTok=bllt.hasMoreTokens() ? bllt.nextToken() : null;
        String browseWidthTok=bwlt.hasMoreTokens() ? bwlt.nextToken() : null;
        if (browseListTok == null || !browseListTok.trim().equals(""String_Node_Str"")) {
          if (browseListTok != null) {
            if (newBLLine.length() > 0) {
              newBLLine.append(""String_Node_Str"");
            }
            newBLLine.append(browseListTok);
          }
          if (browseWidthTok != null) {
            if (newBWLine.length() > 0) {
              newBWLine.append(""String_Node_Str"");
            }
            newBWLine.append(browseWidthTok);
          }
        }
      }
      browseListLine=newBLLine.toString();
      browseWidthLine=newBWLine.toString();
    }
  }
 else {
    browseListLine=DEFAULT_LIST_FIELDS;
    browseWidthLine=DEFAULT_LIST_WIDTHS;
  }
  String[] fieldArr=browseListLine == null ? new String[0] : browseListLine.split(""String_Node_Str"");
  String[] widthArr=browseWidthLine == null ? new String[0] : browseWidthLine.split(""String_Node_Str"");
  boolean isDate[]=new boolean[fieldArr.length];
  boolean emph[]=new boolean[fieldArr.length];
  boolean isAuthor[]=new boolean[fieldArr.length];
  boolean viewFull[]=new boolean[fieldArr.length];
  String[] browseType=new String[fieldArr.length];
  String[] cOddOrEven=new String[fieldArr.length];
  try {
    CrossLinks cl=new CrossLinks();
    String tablewidth=ConfigurationManager.getProperty(""String_Node_Str"");
    if (widthArr.length > 0 && widthArr.length == fieldArr.length && !linkToEdit) {
      if (!StringUtils.isEmpty(tablewidth)) {
        out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
      }
 else {
        out.println(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      for (int w=0; w < widthArr.length; w++) {
        out.print(""String_Node_Str"");
        if (fieldArr[w].equals(""String_Node_Str"") && widthArr[w].equals(""String_Node_Str"")) {
          out.print(thumbItemListMaxWidth);
        }
 else {
          out.print(StringUtils.isEmpty(widthArr[w]) ? ""String_Node_Str"" : widthArr[w]);
        }
        out.print(""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
 else     if (!StringUtils.isEmpty(tablewidth)) {
      out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
    }
 else {
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
    for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
      String field=fieldArr[colIdx].toLowerCase().trim();
      cOddOrEven[colIdx]=(((colIdx + 1) % 2) == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
      if (field.indexOf(""String_Node_Str"") > 0) {
        field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
        isDate[colIdx]=true;
      }
      fieldArr[colIdx]=field;
      if (field.equals(authorField)) {
        isAuthor[colIdx]=true;
      }
      if (cl.hasLink(field)) {
        browseType[colIdx]=cl.getLinkType(field);
        viewFull[colIdx]=BrowseIndex.getBrowseIndex(browseType[colIdx]).isItemIndex();
      }
      if (field.equals(emphColumn)) {
        emph[colIdx]=true;
      }
      String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
      String css=""String_Node_Str"" + cOddOrEven[colIdx] + ""String_Node_Str"";
      String message=""String_Node_Str"" + field;
      String markClass=""String_Node_Str"";
      if (field.startsWith(""String_Node_Str"")) {
        markClass=""String_Node_Str"" + field + ""String_Node_Str"";
      }
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ markClass+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ LocaleSupport.getLocalizedMessage(pageContext,message)+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    if (linkToEdit) {
      String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
      String css=""String_Node_Str"" + cOddOrEven[cOddOrEven.length - 2] + ""String_Node_Str"";
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    out.print(""String_Node_Str"");
    for (int i=0; i < items.length; i++) {
      out.print(""String_Node_Str"");
      String rOddOrEven;
      if (i == highlightRow) {
        rOddOrEven=""String_Node_Str"";
      }
 else {
        rOddOrEven=((i & 1) == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
      }
      for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
        String field=fieldArr[colIdx];
        StringTokenizer eq=new StringTokenizer(field,""String_Node_Str"");
        String[] tokens={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int k=0;
        while (eq.hasMoreTokens()) {
          tokens[k]=eq.nextToken().toLowerCase().trim();
          k++;
        }
        String schema=tokens[0];
        String element=tokens[1];
        String qualifier=tokens[2];
        DCValue[] metadataArray;
        if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,Item.ANY,Item.ANY);
        }
 else         if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,null,Item.ANY);
        }
 else {
          metadataArray=items[i].getMetadata(schema,element,qualifier,Item.ANY);
        }
        if (metadataArray == null) {
          metadataArray=new DCValue[0];
        }
        String metadata=""String_Node_Str"";
        if (field.equals(""String_Node_Str"")) {
          metadata=getThumbMarkup(hrq,items[i]);
        }
 else         if (field.startsWith(""String_Node_Str"")) {
          metadata=getMarkingMarkup(hrq,items[i],field);
        }
 else         if (metadataArray.length > 0) {
          if (isDate[colIdx]) {
            DCDate dd=new DCDate(metadataArray[0].value);
            metadata=UIUtil.displayDate(dd,false,false,hrq);
          }
 else           if (field.equals(titleField) && items[i].isWithdrawn()) {
            metadata=Utils.addEntities(metadataArray[0].value);
          }
 else           if (field.equals(titleField)) {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ Utils.addEntities(metadataArray[0].value)+ ""String_Node_Str"";
          }
 else {
            boolean truncated=false;
            int loopLimit=metadataArray.length;
            if (isAuthor[colIdx]) {
              int fieldMax=(authorLimit == -1 ? metadataArray.length : authorLimit);
              loopLimit=(fieldMax > metadataArray.length ? metadataArray.length : fieldMax);
              truncated=(fieldMax < metadataArray.length);
              log.debug(""String_Node_Str"" + field + ""String_Node_Str""+ Integer.toString(loopLimit)+ ""String_Node_Str""+ Integer.toString(metadataArray.length));
            }
            StringBuffer sb=new StringBuffer();
            for (int j=0; j < loopLimit; j++) {
              String startLink=""String_Node_Str"";
              String endLink=""String_Node_Str"";
              if (!StringUtils.isEmpty(browseType[colIdx]) && !disableCrossLinks) {
                String argument;
                String value;
                if (metadataArray[j].authority != null && metadataArray[j].confidence >= MetadataAuthorityManager.getManager().getMinConfidence(metadataArray[j].schema,metadataArray[j].element,metadataArray[j].qualifier)) {
                  argument=""String_Node_Str"";
                  value=metadataArray[j].authority;
                }
 else {
                  argument=""String_Node_Str"";
                  value=metadataArray[j].value;
                }
                if (viewFull[colIdx]) {
                  argument=""String_Node_Str"";
                }
                startLink=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ browseType[colIdx]+ ""String_Node_Str""+ argument+ ""String_Node_Str""+ URLEncoder.encode(value,""String_Node_Str"");
                if (metadataArray[j].language != null) {
                  startLink=startLink + ""String_Node_Str"" + argument+ ""String_Node_Str""+ URLEncoder.encode(metadataArray[j].language,""String_Node_Str"");
                }
                if (""String_Node_Str"".equals(argument)) {
                  startLink+=""String_Node_Str"" + browseType[colIdx] + ""String_Node_Str"";
                }
 else {
                  startLink=startLink + ""String_Node_Str"";
                }
                endLink=""String_Node_Str"";
              }
              sb.append(startLink);
              sb.append(Utils.addEntities(metadataArray[j].value));
              sb.append(endLink);
              if (j < (loopLimit - 1)) {
                sb.append(""String_Node_Str"");
              }
            }
            if (truncated) {
              String etal=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
              sb.append(""String_Node_Str"").append(etal);
            }
            metadata=""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
          }
        }
 else         if (field.equals(titleField)) {
          String undefined=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
          if (items[i].isWithdrawn()) {
            metadata=""String_Node_Str"" + undefined + ""String_Node_Str"";
          }
 else {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ undefined+ ""String_Node_Str""+ ""String_Node_Str"";
          }
        }
        String extras=""String_Node_Str"";
        if (isDate[colIdx]) {
          extras=""String_Node_Str"";
        }
        String markClass=""String_Node_Str"";
        if (field.startsWith(""String_Node_Str"")) {
          markClass=""String_Node_Str"" + field + ""String_Node_Str"";
        }
        String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[colIdx]+ ""String_Node_Str""+ markClass+ ""String_Node_Str""+ extras+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ metadata+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      }
      if (linkToEdit) {
        String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[cOddOrEven.length - 2]+ ""String_Node_Str""+ ""String_Node_Str""+ hrq.getContextPath()+ ""String_Node_Str""+ ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
catch (  BrowseException e) {
    throw new JspException(e);
  }
  return SKIP_BODY;
}","public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
  String browseListLine=null;
  String browseWidthLine=null;
  if (browseInfo != null) {
    SortOption so=browseInfo.getSortOption();
    BrowseIndex bix=browseInfo.getBrowseIndex();
    if (bix != null) {
      if (so != null && browseListLine == null) {
        browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str""+ so.getName()+ ""String_Node_Str"");
        browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str""+ so.getName()+ ""String_Node_Str"");
      }
      if (so == null) {
        so=bix.getSortOption();
      }
    }
    if (so != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
    }
    if (bix != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
    }
    if (so != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
    }
    if (bix != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
    }
  }
  if (browseListLine == null) {
    browseListLine=ConfigurationManager.getProperty(""String_Node_Str"");
    browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (browseListLine != null) {
    if (!showThumbs && browseListLine.contains(""String_Node_Str"")) {
      browseListLine=browseListLine == null ? ""String_Node_Str"" : browseListLine;
      browseWidthLine=browseWidthLine == null ? ""String_Node_Str"" : browseWidthLine;
      StringTokenizer bllt=new StringTokenizer(browseListLine,""String_Node_Str"");
      StringTokenizer bwlt=new StringTokenizer(browseWidthLine,""String_Node_Str"");
      StringBuilder newBLLine=new StringBuilder();
      StringBuilder newBWLine=new StringBuilder();
      while (bllt.hasMoreTokens() || bwlt.hasMoreTokens()) {
        String browseListTok=bllt.hasMoreTokens() ? bllt.nextToken() : null;
        String browseWidthTok=bwlt.hasMoreTokens() ? bwlt.nextToken() : null;
        if (browseListTok == null || !browseListTok.trim().equals(""String_Node_Str"")) {
          if (browseListTok != null) {
            if (newBLLine.length() > 0) {
              newBLLine.append(""String_Node_Str"");
            }
            newBLLine.append(browseListTok);
          }
          if (browseWidthTok != null) {
            if (newBWLine.length() > 0) {
              newBWLine.append(""String_Node_Str"");
            }
            newBWLine.append(browseWidthTok);
          }
        }
      }
      browseListLine=newBLLine.toString();
      browseWidthLine=newBWLine.toString();
    }
  }
 else {
    browseListLine=DEFAULT_LIST_FIELDS;
    browseWidthLine=DEFAULT_LIST_WIDTHS;
  }
  String[] fieldArr=browseListLine == null ? new String[0] : browseListLine.split(""String_Node_Str"");
  String[] widthArr=browseWidthLine == null ? new String[0] : browseWidthLine.split(""String_Node_Str"");
  boolean isDate[]=new boolean[fieldArr.length];
  boolean emph[]=new boolean[fieldArr.length];
  boolean isAuthor[]=new boolean[fieldArr.length];
  boolean viewFull[]=new boolean[fieldArr.length];
  String[] browseType=new String[fieldArr.length];
  String[] cOddOrEven=new String[fieldArr.length];
  try {
    CrossLinks cl=new CrossLinks();
    String tablewidth=ConfigurationManager.getProperty(""String_Node_Str"");
    if (widthArr.length > 0 && widthArr.length == fieldArr.length && !linkToEdit) {
      if (!StringUtils.isEmpty(tablewidth)) {
        out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
      }
 else {
        out.println(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      for (int w=0; w < widthArr.length; w++) {
        out.print(""String_Node_Str"");
        if (fieldArr[w].equals(""String_Node_Str"") && widthArr[w].equals(""String_Node_Str"")) {
          out.print(thumbItemListMaxWidth);
        }
 else {
          out.print(StringUtils.isEmpty(widthArr[w]) ? ""String_Node_Str"" : widthArr[w]);
        }
        out.print(""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
 else     if (!StringUtils.isEmpty(tablewidth)) {
      out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
    }
 else {
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
    for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
      String field=fieldArr[colIdx].toLowerCase().trim();
      cOddOrEven[colIdx]=(((colIdx + 1) % 2) == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
      if (field.indexOf(""String_Node_Str"") > 0) {
        field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
        isDate[colIdx]=true;
      }
      fieldArr[colIdx]=field;
      if (field.equals(authorField)) {
        isAuthor[colIdx]=true;
      }
      if (cl.hasLink(field)) {
        browseType[colIdx]=cl.getLinkType(field);
        viewFull[colIdx]=BrowseIndex.getBrowseIndex(browseType[colIdx]).isItemIndex();
      }
      if (field.equals(emphColumn)) {
        emph[colIdx]=true;
      }
      String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
      String css=""String_Node_Str"" + cOddOrEven[colIdx] + ""String_Node_Str"";
      String message=""String_Node_Str"" + field;
      String markClass=""String_Node_Str"";
      if (field.startsWith(""String_Node_Str"")) {
        markClass=""String_Node_Str"" + field + ""String_Node_Str"";
      }
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ markClass+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ LocaleSupport.getLocalizedMessage(pageContext,message)+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    if (linkToEdit) {
      String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
      String css=""String_Node_Str"" + cOddOrEven[cOddOrEven.length - 2] + ""String_Node_Str"";
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    out.print(""String_Node_Str"");
    for (int i=0; i < items.length; i++) {
      out.print(""String_Node_Str"");
      String rOddOrEven;
      if (i == highlightRow) {
        rOddOrEven=""String_Node_Str"";
      }
 else {
        rOddOrEven=((i & 1) == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
      }
      for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
        String field=fieldArr[colIdx];
        StringTokenizer eq=new StringTokenizer(field,""String_Node_Str"");
        String[] tokens={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int k=0;
        while (eq.hasMoreTokens()) {
          tokens[k]=eq.nextToken().toLowerCase().trim();
          k++;
        }
        String schema=tokens[0];
        String element=tokens[1];
        String qualifier=tokens[2];
        DCValue[] metadataArray;
        if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,Item.ANY,Item.ANY);
        }
 else         if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,null,Item.ANY);
        }
 else {
          metadataArray=items[i].getMetadata(schema,element,qualifier,Item.ANY);
        }
        if (metadataArray == null) {
          metadataArray=new DCValue[0];
        }
        String metadata=""String_Node_Str"";
        if (field.equals(""String_Node_Str"")) {
          metadata=getThumbMarkup(hrq,items[i]);
        }
 else         if (field.startsWith(""String_Node_Str"")) {
          metadata=UIUtil.getMarkingMarkup(hrq,items[i],field);
        }
 else         if (metadataArray.length > 0) {
          if (isDate[colIdx]) {
            DCDate dd=new DCDate(metadataArray[0].value);
            metadata=UIUtil.displayDate(dd,false,false,hrq);
          }
 else           if (field.equals(titleField) && items[i].isWithdrawn()) {
            metadata=Utils.addEntities(metadataArray[0].value);
          }
 else           if (field.equals(titleField)) {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ Utils.addEntities(metadataArray[0].value)+ ""String_Node_Str"";
          }
 else {
            boolean truncated=false;
            int loopLimit=metadataArray.length;
            if (isAuthor[colIdx]) {
              int fieldMax=(authorLimit == -1 ? metadataArray.length : authorLimit);
              loopLimit=(fieldMax > metadataArray.length ? metadataArray.length : fieldMax);
              truncated=(fieldMax < metadataArray.length);
              log.debug(""String_Node_Str"" + field + ""String_Node_Str""+ Integer.toString(loopLimit)+ ""String_Node_Str""+ Integer.toString(metadataArray.length));
            }
            StringBuffer sb=new StringBuffer();
            for (int j=0; j < loopLimit; j++) {
              String startLink=""String_Node_Str"";
              String endLink=""String_Node_Str"";
              if (!StringUtils.isEmpty(browseType[colIdx]) && !disableCrossLinks) {
                String argument;
                String value;
                if (metadataArray[j].authority != null && metadataArray[j].confidence >= MetadataAuthorityManager.getManager().getMinConfidence(metadataArray[j].schema,metadataArray[j].element,metadataArray[j].qualifier)) {
                  argument=""String_Node_Str"";
                  value=metadataArray[j].authority;
                }
 else {
                  argument=""String_Node_Str"";
                  value=metadataArray[j].value;
                }
                if (viewFull[colIdx]) {
                  argument=""String_Node_Str"";
                }
                startLink=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ browseType[colIdx]+ ""String_Node_Str""+ argument+ ""String_Node_Str""+ URLEncoder.encode(value,""String_Node_Str"");
                if (metadataArray[j].language != null) {
                  startLink=startLink + ""String_Node_Str"" + argument+ ""String_Node_Str""+ URLEncoder.encode(metadataArray[j].language,""String_Node_Str"");
                }
                if (""String_Node_Str"".equals(argument)) {
                  startLink+=""String_Node_Str"" + browseType[colIdx] + ""String_Node_Str"";
                }
 else {
                  startLink=startLink + ""String_Node_Str"";
                }
                endLink=""String_Node_Str"";
              }
              sb.append(startLink);
              sb.append(Utils.addEntities(metadataArray[j].value));
              sb.append(endLink);
              if (j < (loopLimit - 1)) {
                sb.append(""String_Node_Str"");
              }
            }
            if (truncated) {
              String etal=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
              sb.append(""String_Node_Str"").append(etal);
            }
            metadata=""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
          }
        }
 else         if (field.equals(titleField)) {
          String undefined=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
          if (items[i].isWithdrawn()) {
            metadata=""String_Node_Str"" + undefined + ""String_Node_Str"";
          }
 else {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ undefined+ ""String_Node_Str""+ ""String_Node_Str"";
          }
        }
        String extras=""String_Node_Str"";
        if (isDate[colIdx]) {
          extras=""String_Node_Str"";
        }
        String markClass=""String_Node_Str"";
        if (field.startsWith(""String_Node_Str"")) {
          markClass=""String_Node_Str"" + field + ""String_Node_Str"";
        }
        String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[colIdx]+ ""String_Node_Str""+ markClass+ ""String_Node_Str""+ extras+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ metadata+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      }
      if (linkToEdit) {
        String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[cOddOrEven.length - 2]+ ""String_Node_Str""+ ""String_Node_Str""+ hrq.getContextPath()+ ""String_Node_Str""+ ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
catch (  BrowseException e) {
    throw new JspException(e);
  }
  return SKIP_BODY;
}",0.9997436930174656
52038,"public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
  boolean emphasiseDate=false;
  boolean emphasiseTitle=false;
  if (emphColumn != null) {
    emphasiseDate=emphColumn.equalsIgnoreCase(""String_Node_Str"");
    emphasiseTitle=emphColumn.equalsIgnoreCase(""String_Node_Str"");
  }
  String configLine=null;
  String widthLine=null;
  if (sortOption != null) {
    if (configLine == null) {
      configLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
      widthLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
    }
    if (configLine == null) {
      configLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
      widthLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
    }
  }
  if (configLine == null) {
    configLine=ConfigurationManager.getProperty(""String_Node_Str"");
    widthLine=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (configLine != null) {
    if (!showThumbs && configLine.contains(""String_Node_Str"")) {
      configLine=configLine == null ? ""String_Node_Str"" : configLine;
      widthLine=widthLine == null ? ""String_Node_Str"" : widthLine;
      StringTokenizer llt=new StringTokenizer(configLine,""String_Node_Str"");
      StringTokenizer wlt=new StringTokenizer(widthLine,""String_Node_Str"");
      StringBuilder newLLine=new StringBuilder();
      StringBuilder newWLine=new StringBuilder();
      while (llt.hasMoreTokens() || wlt.hasMoreTokens()) {
        String listTok=llt.hasMoreTokens() ? llt.nextToken() : null;
        String widthTok=wlt.hasMoreTokens() ? wlt.nextToken() : null;
        if (listTok == null || !listTok.trim().equals(""String_Node_Str"")) {
          if (listTok != null) {
            if (newLLine.length() > 0) {
              newLLine.append(""String_Node_Str"");
            }
            newLLine.append(listTok);
          }
          if (widthTok != null) {
            if (newWLine.length() > 0) {
              newWLine.append(""String_Node_Str"");
            }
            newWLine.append(widthTok);
          }
        }
      }
      configLine=newLLine.toString();
      widthLine=newWLine.toString();
    }
  }
 else {
    configLine=DEFAULT_LIST_FIELDS;
    widthLine=DEFAULT_LIST_WIDTHS;
  }
  String[] fieldArr=configLine == null ? new String[0] : configLine.split(""String_Node_Str"");
  String[] widthArr=widthLine == null ? new String[0] : widthLine.split(""String_Node_Str"");
  boolean isDate[]=new boolean[fieldArr.length];
  boolean emph[]=new boolean[fieldArr.length];
  boolean isAuthor[]=new boolean[fieldArr.length];
  boolean viewFull[]=new boolean[fieldArr.length];
  String[] browseType=new String[fieldArr.length];
  String[] cOddOrEven=new String[fieldArr.length];
  try {
    CrossLinks cl=new CrossLinks();
    String tablewidth=ConfigurationManager.getProperty(""String_Node_Str"");
    if (widthArr.length > 0 && widthArr.length == fieldArr.length && !linkToEdit) {
      if (!StringUtils.isEmpty(tablewidth)) {
        out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
      }
 else {
        out.println(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      for (int w=0; w < widthArr.length; w++) {
        out.print(""String_Node_Str"");
        if (fieldArr[w].equals(""String_Node_Str"") && widthArr[w].equals(""String_Node_Str"")) {
          out.print(thumbItemListMaxWidth);
        }
 else {
          out.print(StringUtils.isEmpty(widthArr[w]) ? ""String_Node_Str"" : widthArr[w]);
        }
        out.print(""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
 else     if (!StringUtils.isEmpty(tablewidth)) {
      out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
    }
 else {
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
    for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
      String field=fieldArr[colIdx].toLowerCase().trim();
      cOddOrEven[colIdx]=(((colIdx + 1) % 2) == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
      if (field.indexOf(""String_Node_Str"") > 0) {
        field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
        isDate[colIdx]=true;
      }
      fieldArr[colIdx]=field;
      if (field.equals(authorField)) {
        isAuthor[colIdx]=true;
      }
      if (cl.hasLink(field)) {
        browseType[colIdx]=cl.getLinkType(field);
        viewFull[colIdx]=BrowseIndex.getBrowseIndex(browseType[colIdx]).isItemIndex();
      }
      if (field.equals(emphColumn)) {
        emph[colIdx]=true;
      }
 else       if ((field.equals(dateField) && emphasiseDate) || (field.equals(titleField) && emphasiseTitle)) {
        emph[colIdx]=true;
      }
      String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
      String css=""String_Node_Str"" + cOddOrEven[colIdx] + ""String_Node_Str"";
      String message=""String_Node_Str"" + field;
      String markClass=""String_Node_Str"";
      if (field.startsWith(""String_Node_Str"")) {
        markClass=""String_Node_Str"" + field + ""String_Node_Str"";
      }
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ markClass+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ LocaleSupport.getLocalizedMessage(pageContext,message)+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    if (linkToEdit) {
      String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
      String css=""String_Node_Str"" + cOddOrEven[cOddOrEven.length - 2] + ""String_Node_Str"";
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    out.print(""String_Node_Str"");
    for (int i=0; i < items.length; i++) {
      out.print(""String_Node_Str"");
      String rOddOrEven;
      if (i == highlightRow) {
        rOddOrEven=""String_Node_Str"";
      }
 else {
        rOddOrEven=((i & 1) == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
      }
      for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
        String field=fieldArr[colIdx];
        StringTokenizer eq=new StringTokenizer(field,""String_Node_Str"");
        String[] tokens={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int k=0;
        while (eq.hasMoreTokens()) {
          tokens[k]=eq.nextToken().toLowerCase().trim();
          k++;
        }
        String schema=tokens[0];
        String element=tokens[1];
        String qualifier=tokens[2];
        DCValue[] metadataArray;
        if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,Item.ANY,Item.ANY);
        }
 else         if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,null,Item.ANY);
        }
 else {
          metadataArray=items[i].getMetadata(schema,element,qualifier,Item.ANY);
        }
        if (metadataArray == null) {
          metadataArray=new DCValue[0];
        }
        String metadata=""String_Node_Str"";
        if (field.equals(""String_Node_Str"")) {
          metadata=getThumbMarkup(hrq,items[i]);
        }
 else         if (field.startsWith(""String_Node_Str"")) {
          metadata=getMarkingMarkup(hrq,items[i],field);
        }
        if (metadataArray.length > 0) {
          if (isDate[colIdx]) {
            DCDate dd=new DCDate(metadataArray[0].value);
            metadata=UIUtil.displayDate(dd,false,false,hrq);
          }
 else           if (field.equals(titleField) && items[i].isWithdrawn()) {
            metadata=Utils.addEntities(metadataArray[0].value);
          }
 else           if (field.equals(titleField)) {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ Utils.addEntities(metadataArray[0].value)+ ""String_Node_Str"";
          }
 else {
            boolean truncated=false;
            int loopLimit=metadataArray.length;
            if (isAuthor[colIdx]) {
              int fieldMax=(authorLimit > 0 ? authorLimit : metadataArray.length);
              loopLimit=(fieldMax > metadataArray.length ? metadataArray.length : fieldMax);
              truncated=(fieldMax < metadataArray.length);
              log.debug(""String_Node_Str"" + field + ""String_Node_Str""+ Integer.toString(loopLimit)+ ""String_Node_Str""+ Integer.toString(metadataArray.length));
            }
            StringBuffer sb=new StringBuffer();
            for (int j=0; j < loopLimit; j++) {
              String startLink=""String_Node_Str"";
              String endLink=""String_Node_Str"";
              if (!StringUtils.isEmpty(browseType[colIdx]) && !disableCrossLinks) {
                String argument;
                String value;
                if (metadataArray[j].authority != null && metadataArray[j].confidence >= MetadataAuthorityManager.getManager().getMinConfidence(metadataArray[j].schema,metadataArray[j].element,metadataArray[j].qualifier)) {
                  argument=""String_Node_Str"";
                  value=metadataArray[j].authority;
                }
 else {
                  argument=""String_Node_Str"";
                  value=metadataArray[j].value;
                }
                if (viewFull[colIdx]) {
                  argument=""String_Node_Str"";
                }
                startLink=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ browseType[colIdx]+ ""String_Node_Str""+ argument+ ""String_Node_Str""+ URLEncoder.encode(value,""String_Node_Str"");
                if (metadataArray[j].language != null) {
                  startLink=startLink + ""String_Node_Str"" + argument+ ""String_Node_Str""+ URLEncoder.encode(metadataArray[j].language,""String_Node_Str"");
                }
                if (""String_Node_Str"".equals(argument)) {
                  startLink+=""String_Node_Str"" + browseType[colIdx] + ""String_Node_Str"";
                }
 else {
                  startLink=startLink + ""String_Node_Str"";
                }
                endLink=""String_Node_Str"";
              }
              sb.append(startLink);
              sb.append(Utils.addEntities(metadataArray[j].value));
              sb.append(endLink);
              if (j < (loopLimit - 1)) {
                sb.append(""String_Node_Str"");
              }
            }
            if (truncated) {
              String etal=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
              sb.append(""String_Node_Str"").append(etal);
            }
            metadata=""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
          }
        }
 else         if (field.equals(titleField)) {
          String undefined=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
          if (items[i].isWithdrawn()) {
            metadata=""String_Node_Str"" + undefined + ""String_Node_Str"";
          }
 else {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ undefined+ ""String_Node_Str""+ ""String_Node_Str"";
          }
        }
        String extras=""String_Node_Str"";
        if (isDate[colIdx]) {
          extras=""String_Node_Str"";
        }
        String markClass=""String_Node_Str"";
        if (field.startsWith(""String_Node_Str"")) {
          markClass=""String_Node_Str"" + field + ""String_Node_Str"";
        }
        String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[colIdx]+ ""String_Node_Str""+ markClass+ ""String_Node_Str""+ extras+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ metadata+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      }
      if (linkToEdit) {
        String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[cOddOrEven.length - 2]+ ""String_Node_Str""+ ""String_Node_Str""+ hrq.getContextPath()+ ""String_Node_Str""+ ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
catch (  BrowseException e) {
    throw new JspException(e);
  }
  return SKIP_BODY;
}","public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
  boolean emphasiseDate=false;
  boolean emphasiseTitle=false;
  if (emphColumn != null) {
    emphasiseDate=emphColumn.equalsIgnoreCase(""String_Node_Str"");
    emphasiseTitle=emphColumn.equalsIgnoreCase(""String_Node_Str"");
  }
  String configLine=null;
  String widthLine=null;
  if (sortOption != null) {
    if (configLine == null) {
      configLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
      widthLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
    }
    if (configLine == null) {
      configLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
      widthLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
    }
  }
  if (configLine == null) {
    configLine=ConfigurationManager.getProperty(""String_Node_Str"");
    widthLine=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (configLine != null) {
    if (!showThumbs && configLine.contains(""String_Node_Str"")) {
      configLine=configLine == null ? ""String_Node_Str"" : configLine;
      widthLine=widthLine == null ? ""String_Node_Str"" : widthLine;
      StringTokenizer llt=new StringTokenizer(configLine,""String_Node_Str"");
      StringTokenizer wlt=new StringTokenizer(widthLine,""String_Node_Str"");
      StringBuilder newLLine=new StringBuilder();
      StringBuilder newWLine=new StringBuilder();
      while (llt.hasMoreTokens() || wlt.hasMoreTokens()) {
        String listTok=llt.hasMoreTokens() ? llt.nextToken() : null;
        String widthTok=wlt.hasMoreTokens() ? wlt.nextToken() : null;
        if (listTok == null || !listTok.trim().equals(""String_Node_Str"")) {
          if (listTok != null) {
            if (newLLine.length() > 0) {
              newLLine.append(""String_Node_Str"");
            }
            newLLine.append(listTok);
          }
          if (widthTok != null) {
            if (newWLine.length() > 0) {
              newWLine.append(""String_Node_Str"");
            }
            newWLine.append(widthTok);
          }
        }
      }
      configLine=newLLine.toString();
      widthLine=newWLine.toString();
    }
  }
 else {
    configLine=DEFAULT_LIST_FIELDS;
    widthLine=DEFAULT_LIST_WIDTHS;
  }
  String[] fieldArr=configLine == null ? new String[0] : configLine.split(""String_Node_Str"");
  String[] widthArr=widthLine == null ? new String[0] : widthLine.split(""String_Node_Str"");
  boolean isDate[]=new boolean[fieldArr.length];
  boolean emph[]=new boolean[fieldArr.length];
  boolean isAuthor[]=new boolean[fieldArr.length];
  boolean viewFull[]=new boolean[fieldArr.length];
  String[] browseType=new String[fieldArr.length];
  String[] cOddOrEven=new String[fieldArr.length];
  try {
    CrossLinks cl=new CrossLinks();
    String tablewidth=ConfigurationManager.getProperty(""String_Node_Str"");
    if (widthArr.length > 0 && widthArr.length == fieldArr.length && !linkToEdit) {
      if (!StringUtils.isEmpty(tablewidth)) {
        out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
      }
 else {
        out.println(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      for (int w=0; w < widthArr.length; w++) {
        out.print(""String_Node_Str"");
        if (fieldArr[w].equals(""String_Node_Str"") && widthArr[w].equals(""String_Node_Str"")) {
          out.print(thumbItemListMaxWidth);
        }
 else {
          out.print(StringUtils.isEmpty(widthArr[w]) ? ""String_Node_Str"" : widthArr[w]);
        }
        out.print(""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
 else     if (!StringUtils.isEmpty(tablewidth)) {
      out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
    }
 else {
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
    for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
      String field=fieldArr[colIdx].toLowerCase().trim();
      cOddOrEven[colIdx]=(((colIdx + 1) % 2) == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
      if (field.indexOf(""String_Node_Str"") > 0) {
        field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
        isDate[colIdx]=true;
      }
      fieldArr[colIdx]=field;
      if (field.equals(authorField)) {
        isAuthor[colIdx]=true;
      }
      if (cl.hasLink(field)) {
        browseType[colIdx]=cl.getLinkType(field);
        viewFull[colIdx]=BrowseIndex.getBrowseIndex(browseType[colIdx]).isItemIndex();
      }
      if (field.equals(emphColumn)) {
        emph[colIdx]=true;
      }
 else       if ((field.equals(dateField) && emphasiseDate) || (field.equals(titleField) && emphasiseTitle)) {
        emph[colIdx]=true;
      }
      String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
      String css=""String_Node_Str"" + cOddOrEven[colIdx] + ""String_Node_Str"";
      String message=""String_Node_Str"" + field;
      String markClass=""String_Node_Str"";
      if (field.startsWith(""String_Node_Str"")) {
        markClass=""String_Node_Str"" + field + ""String_Node_Str"";
      }
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ markClass+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ LocaleSupport.getLocalizedMessage(pageContext,message)+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    if (linkToEdit) {
      String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
      String css=""String_Node_Str"" + cOddOrEven[cOddOrEven.length - 2] + ""String_Node_Str"";
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    out.print(""String_Node_Str"");
    for (int i=0; i < items.length; i++) {
      out.print(""String_Node_Str"");
      String rOddOrEven;
      if (i == highlightRow) {
        rOddOrEven=""String_Node_Str"";
      }
 else {
        rOddOrEven=((i & 1) == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
      }
      for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
        String field=fieldArr[colIdx];
        StringTokenizer eq=new StringTokenizer(field,""String_Node_Str"");
        String[] tokens={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int k=0;
        while (eq.hasMoreTokens()) {
          tokens[k]=eq.nextToken().toLowerCase().trim();
          k++;
        }
        String schema=tokens[0];
        String element=tokens[1];
        String qualifier=tokens[2];
        DCValue[] metadataArray;
        if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,Item.ANY,Item.ANY);
        }
 else         if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,null,Item.ANY);
        }
 else {
          metadataArray=items[i].getMetadata(schema,element,qualifier,Item.ANY);
        }
        if (metadataArray == null) {
          metadataArray=new DCValue[0];
        }
        String metadata=""String_Node_Str"";
        if (field.equals(""String_Node_Str"")) {
          metadata=getThumbMarkup(hrq,items[i]);
        }
 else         if (field.startsWith(""String_Node_Str"")) {
          metadata=UIUtil.getMarkingMarkup(hrq,items[i],field);
        }
        if (metadataArray.length > 0) {
          if (isDate[colIdx]) {
            DCDate dd=new DCDate(metadataArray[0].value);
            metadata=UIUtil.displayDate(dd,false,false,hrq);
          }
 else           if (field.equals(titleField) && items[i].isWithdrawn()) {
            metadata=Utils.addEntities(metadataArray[0].value);
          }
 else           if (field.equals(titleField)) {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ Utils.addEntities(metadataArray[0].value)+ ""String_Node_Str"";
          }
 else {
            boolean truncated=false;
            int loopLimit=metadataArray.length;
            if (isAuthor[colIdx]) {
              int fieldMax=(authorLimit > 0 ? authorLimit : metadataArray.length);
              loopLimit=(fieldMax > metadataArray.length ? metadataArray.length : fieldMax);
              truncated=(fieldMax < metadataArray.length);
              log.debug(""String_Node_Str"" + field + ""String_Node_Str""+ Integer.toString(loopLimit)+ ""String_Node_Str""+ Integer.toString(metadataArray.length));
            }
            StringBuffer sb=new StringBuffer();
            for (int j=0; j < loopLimit; j++) {
              String startLink=""String_Node_Str"";
              String endLink=""String_Node_Str"";
              if (!StringUtils.isEmpty(browseType[colIdx]) && !disableCrossLinks) {
                String argument;
                String value;
                if (metadataArray[j].authority != null && metadataArray[j].confidence >= MetadataAuthorityManager.getManager().getMinConfidence(metadataArray[j].schema,metadataArray[j].element,metadataArray[j].qualifier)) {
                  argument=""String_Node_Str"";
                  value=metadataArray[j].authority;
                }
 else {
                  argument=""String_Node_Str"";
                  value=metadataArray[j].value;
                }
                if (viewFull[colIdx]) {
                  argument=""String_Node_Str"";
                }
                startLink=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ browseType[colIdx]+ ""String_Node_Str""+ argument+ ""String_Node_Str""+ URLEncoder.encode(value,""String_Node_Str"");
                if (metadataArray[j].language != null) {
                  startLink=startLink + ""String_Node_Str"" + argument+ ""String_Node_Str""+ URLEncoder.encode(metadataArray[j].language,""String_Node_Str"");
                }
                if (""String_Node_Str"".equals(argument)) {
                  startLink+=""String_Node_Str"" + browseType[colIdx] + ""String_Node_Str"";
                }
 else {
                  startLink=startLink + ""String_Node_Str"";
                }
                endLink=""String_Node_Str"";
              }
              sb.append(startLink);
              sb.append(Utils.addEntities(metadataArray[j].value));
              sb.append(endLink);
              if (j < (loopLimit - 1)) {
                sb.append(""String_Node_Str"");
              }
            }
            if (truncated) {
              String etal=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
              sb.append(""String_Node_Str"").append(etal);
            }
            metadata=""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
          }
        }
 else         if (field.equals(titleField)) {
          String undefined=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
          if (items[i].isWithdrawn()) {
            metadata=""String_Node_Str"" + undefined + ""String_Node_Str"";
          }
 else {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ undefined+ ""String_Node_Str""+ ""String_Node_Str"";
          }
        }
        String extras=""String_Node_Str"";
        if (isDate[colIdx]) {
          extras=""String_Node_Str"";
        }
        String markClass=""String_Node_Str"";
        if (field.startsWith(""String_Node_Str"")) {
          markClass=""String_Node_Str"" + field + ""String_Node_Str"";
        }
        String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[colIdx]+ ""String_Node_Str""+ markClass+ ""String_Node_Str""+ extras+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ metadata+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      }
      if (linkToEdit) {
        String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[cOddOrEven.length - 2]+ ""String_Node_Str""+ ""String_Node_Str""+ hrq.getContextPath()+ ""String_Node_Str""+ ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
catch (  BrowseException e) {
    throw new JspException(e);
  }
  return SKIP_BODY;
}",0.9997250481165796
52039,"@Override public ItemMarkingInfo getItemMarkingInfo(Context context,Item item) throws SQLException {
  if (metadataField != null && mapping != null) {
    DCValue[] vals=item.getMetadata(metadataField);
    if (vals.length > 0) {
      for (      DCValue value : vals) {
        String type=value.value;
        if (mapping.containsKey(type)) {
          return mapping.get(type);
        }
      }
    }
  }
  return null;
}","@Override public ItemMarkingInfo getItemMarkingInfo(Context context,Item item) throws SQLException {
  if (metadataField != null && mapping != null) {
    DCValue[] vals=item.getMetadataByMetadataString(metadataField);
    if (vals.length > 0) {
      for (      DCValue value : vals) {
        String type=value.value;
        if (mapping.containsKey(type)) {
          return mapping.get(type);
        }
      }
    }
  }
  return null;
}",0.9815242494226328
52040,"/** 
 * Read list of bitstreams. It throws WebApplicationException with response code INTERNAL_SERVER_ERROR(500), if there was problem while reading bitstreams from database.
 * @param limit How much bitstreams in list will be. Default value is 100.
 * @param offset On which index will list starts. Default values is 0.
 * @param headers If you want to access to item under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return It returns array of bistreams. In array are not bitstreams onwhich user has not permission to read.
 * @throws WebApplicationException It is thrown when was problem with database reading or with creating context.
 */
@GET @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Bitstream[] getBitstreams(@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + offset + ""String_Node_Str""+ limit+ ""String_Node_Str"");
  org.dspace.core.Context context=null;
  List<Bitstream> bitstreams=new ArrayList<Bitstream>();
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Bitstream[] dspaceBitstreams=org.dspace.content.Bitstream.findAll(context);
    if (!((limit != null) && (limit >= 0) && (offset != null)&& (offset >= 0))) {
      log.warn(""String_Node_Str"");
      limit=100;
      offset=0;
    }
    for (int i=offset; (i < (offset + limit)) && (i < dspaceBitstreams.length); i++) {
      if (AuthorizeManager.authorizeActionBoolean(context,dspaceBitstreams[i],org.dspace.core.Constants.READ)) {
        if (dspaceBitstreams[i].getParentObject() != null) {
          bitstreams.add(new Bitstream(dspaceBitstreams[i],expand));
          writeStats(dspaceBitstreams[i],UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request);
        }
      }
    }
    context.complete();
    log.trace(""String_Node_Str"");
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  return bitstreams.toArray(new Bitstream[0]);
}","/** 
 * Read list of bitstreams. It throws WebApplicationException with response code INTERNAL_SERVER_ERROR(500), if there was problem while reading bitstreams from database.
 * @param limit How much bitstreams in list will be. Default value is 100.
 * @param offset On which index will list starts. Default values is 0.
 * @param headers If you want to access to item under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return It returns array of bistreams. In array are not bitstreams onwhich user has not permission to read.
 * @throws WebApplicationException It is thrown when was problem with database reading or with creating context.
 */
@GET @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Bitstream[] getBitstreams(@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + offset + ""String_Node_Str""+ limit+ ""String_Node_Str"");
  org.dspace.core.Context context=null;
  List<Bitstream> bitstreams=new ArrayList<Bitstream>();
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Bitstream[] dspaceBitstreams=org.dspace.content.Bitstream.findAll(context);
    if (!((limit != null) && (limit >= 0) && (offset != null)&& (offset >= 0))) {
      log.warn(""String_Node_Str"");
      limit=100;
      offset=0;
    }
    for (int i=offset; (i < (offset + limit)) && (i < dspaceBitstreams.length); i++) {
      if (AuthorizeManager.authorizeActionBoolean(context,dspaceBitstreams[i],org.dspace.core.Constants.READ)) {
        if (dspaceBitstreams[i].getParentObject() != null) {
          bitstreams.add(new Bitstream(dspaceBitstreams[i],expand));
          writeStats(dspaceBitstreams[i],UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request,context);
        }
      }
    }
    context.complete();
    log.trace(""String_Node_Str"");
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  return bitstreams.toArray(new Bitstream[0]);
}",0.9984447900466564
52041,"/** 
 * Return bitstream properties without file data. It can throws WebApplicationException with three response codes. Response code NOT_FOUND(404) or UNAUTHORIZED(401) or INTERNAL_SERVER_ERROR(500). Bad request is when id of bitstream does not exist. UNAUTHORIZED is if logged user into DSpace context have not permission to access bitstream. Server error when something went wrong.
 * @param bitstreamId Id of bitstream in DSpace.
 * @param expand This string defined, which additional options will be added into bitstream. Single options are separated by commas without space. Options are: ""all"", ""parent"".
 * @param headers If you want to access to item under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return If user is allowed to read bitstream, it returns instance ofbitstream. Otherwise, it throws WebApplicationException with response code UNAUTHORIZED.
 * @throws WebApplicationException It can happen on: Bad request, unauthorized, SQL exception and context exception(could not create context).
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Bitstream getBitstream(@PathParam(""String_Node_Str"") Integer bitstreamId,@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  Bitstream bitstream=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Bitstream dspaceBitstream=findBitstream(context,bitstreamId,org.dspace.core.Constants.READ);
    writeStats(dspaceBitstream,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request);
    bitstream=new Bitstream(dspaceBitstream,expand);
    context.complete();
    log.trace(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  return bitstream;
}","/** 
 * Return bitstream properties without file data. It can throws WebApplicationException with three response codes. Response code NOT_FOUND(404) or UNAUTHORIZED(401) or INTERNAL_SERVER_ERROR(500). Bad request is when id of bitstream does not exist. UNAUTHORIZED is if logged user into DSpace context have not permission to access bitstream. Server error when something went wrong.
 * @param bitstreamId Id of bitstream in DSpace.
 * @param expand This string defined, which additional options will be added into bitstream. Single options are separated by commas without space. Options are: ""all"", ""parent"".
 * @param headers If you want to access to item under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return If user is allowed to read bitstream, it returns instance ofbitstream. Otherwise, it throws WebApplicationException with response code UNAUTHORIZED.
 * @throws WebApplicationException It can happen on: Bad request, unauthorized, SQL exception and context exception(could not create context).
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Bitstream getBitstream(@PathParam(""String_Node_Str"") Integer bitstreamId,@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  Bitstream bitstream=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Bitstream dspaceBitstream=findBitstream(context,bitstreamId,org.dspace.core.Constants.READ);
    writeStats(dspaceBitstream,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request,context);
    bitstream=new Bitstream(dspaceBitstream,expand);
    context.complete();
    log.trace(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  return bitstream;
}",0.9983532317826266
52042,"/** 
 * Update bitstream metadata. It replace everything on targeted bitstream. It can throws WebApplicationException caused by two exceptions: SQLException, if there was problem with database. AuthorizeException if there was problem with authorization to edit bitstream metadata.
 * @param bitstreamId Id of bistream, wich will be updated.
 * @param bitstream Bitstream with will be placed. It muset have filled user creditials.
 * @param headers If you want to access to item under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response codes: OK(200), NOT_FOUND(404) if bitstream doesnot exist and UNAUTHORIZED(401) if user is not allowed to write to bitstream.
 * @throws WebApplicationException It can be thrown by: Error in reading from database. Or creating context or with authorization to bitstream.
 */
@PUT @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Response updateBitstream(@PathParam(""String_Node_Str"") Integer bitstreamId,Bitstream bitstream,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Bitstream dspaceBitstream=findBitstream(context,bitstreamId,org.dspace.core.Constants.WRITE);
    writeStats(dspaceBitstream,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request);
    log.trace(""String_Node_Str"");
    dspaceBitstream.setDescription(bitstream.getDescription());
    if (getMimeType(bitstream.getName()) == null) {
      dspaceBitstream.setFormat(BitstreamFormat.findUnknown(context));
    }
 else {
      dspaceBitstream.setFormat(BitstreamFormat.findByMIMEType(context,getMimeType(bitstream.getName())));
    }
    dspaceBitstream.setName(bitstream.getName());
    Integer sequenceId=bitstream.getSequenceId();
    if (sequenceId != null && sequenceId.intValue() != -1) {
      dspaceBitstream.setSequenceID(sequenceId);
    }
    dspaceBitstream.update();
    if (bitstream.getPolicies() != null) {
      Bundle[] bundles=dspaceBitstream.getBundles();
      ResourcePolicy[] policies=bitstream.getPolicies();
      for (      Bundle bundle : bundles) {
        List<org.dspace.authorize.ResourcePolicy> bitstreamsPolicies=bundle.getBitstreamPolicies();
        List<org.dspace.authorize.ResourcePolicy> policiesToRemove=new ArrayList<org.dspace.authorize.ResourcePolicy>();
        for (        org.dspace.authorize.ResourcePolicy policy : bitstreamsPolicies) {
          if (policy.getResourceID() == dspaceBitstream.getID()) {
            policiesToRemove.add(policy);
          }
        }
        for (        org.dspace.authorize.ResourcePolicy policy : policiesToRemove) {
          bitstreamsPolicies.remove(policy);
        }
        for (        ResourcePolicy policy : policies) {
          org.dspace.authorize.ResourcePolicy dspacePolicy=org.dspace.authorize.ResourcePolicy.create(context);
          dspacePolicy.setAction(policy.getActionInt());
          dspacePolicy.setGroup(Group.find(context,policy.getGroupId()));
          dspacePolicy.setResourceID(dspaceBitstream.getID());
          dspacePolicy.setResource(dspaceBitstream);
          dspacePolicy.setResourceType(org.dspace.core.Constants.BITSTREAM);
          dspacePolicy.setStartDate(policy.getStartDate());
          dspacePolicy.setEndDate(policy.getEndDate());
          dspacePolicy.setRpDescription(policy.getRpDescription());
          dspacePolicy.setRpName(policy.getRpName());
          dspacePolicy.update();
          bitstreamsPolicies.add(dspacePolicy);
        }
        bundle.replaceAllBitstreamPolicies(bitstreamsPolicies);
        bundle.update();
      }
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  return Response.ok().build();
}","/** 
 * Update bitstream metadata. It replace everything on targeted bitstream. It can throws WebApplicationException caused by two exceptions: SQLException, if there was problem with database. AuthorizeException if there was problem with authorization to edit bitstream metadata.
 * @param bitstreamId Id of bistream, wich will be updated.
 * @param bitstream Bitstream with will be placed. It muset have filled user creditials.
 * @param headers If you want to access to item under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response codes: OK(200), NOT_FOUND(404) if bitstream doesnot exist and UNAUTHORIZED(401) if user is not allowed to write to bitstream.
 * @throws WebApplicationException It can be thrown by: Error in reading from database. Or creating context or with authorization to bitstream.
 */
@PUT @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Response updateBitstream(@PathParam(""String_Node_Str"") Integer bitstreamId,Bitstream bitstream,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Bitstream dspaceBitstream=findBitstream(context,bitstreamId,org.dspace.core.Constants.WRITE);
    writeStats(dspaceBitstream,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request,context);
    log.trace(""String_Node_Str"");
    dspaceBitstream.setDescription(bitstream.getDescription());
    if (getMimeType(bitstream.getName()) == null) {
      dspaceBitstream.setFormat(BitstreamFormat.findUnknown(context));
    }
 else {
      dspaceBitstream.setFormat(BitstreamFormat.findByMIMEType(context,getMimeType(bitstream.getName())));
    }
    dspaceBitstream.setName(bitstream.getName());
    Integer sequenceId=bitstream.getSequenceId();
    if (sequenceId != null && sequenceId.intValue() != -1) {
      dspaceBitstream.setSequenceID(sequenceId);
    }
    dspaceBitstream.update();
    if (bitstream.getPolicies() != null) {
      Bundle[] bundles=dspaceBitstream.getBundles();
      ResourcePolicy[] policies=bitstream.getPolicies();
      for (      Bundle bundle : bundles) {
        List<org.dspace.authorize.ResourcePolicy> bitstreamsPolicies=bundle.getBitstreamPolicies();
        List<org.dspace.authorize.ResourcePolicy> policiesToRemove=new ArrayList<org.dspace.authorize.ResourcePolicy>();
        for (        org.dspace.authorize.ResourcePolicy policy : bitstreamsPolicies) {
          if (policy.getResourceID() == dspaceBitstream.getID()) {
            policiesToRemove.add(policy);
          }
        }
        for (        org.dspace.authorize.ResourcePolicy policy : policiesToRemove) {
          bitstreamsPolicies.remove(policy);
        }
        for (        ResourcePolicy policy : policies) {
          org.dspace.authorize.ResourcePolicy dspacePolicy=org.dspace.authorize.ResourcePolicy.create(context);
          dspacePolicy.setAction(policy.getActionInt());
          dspacePolicy.setGroup(Group.find(context,policy.getGroupId()));
          dspacePolicy.setResourceID(dspaceBitstream.getID());
          dspacePolicy.setResource(dspaceBitstream);
          dspacePolicy.setResourceType(org.dspace.core.Constants.BITSTREAM);
          dspacePolicy.setStartDate(policy.getStartDate());
          dspacePolicy.setEndDate(policy.getEndDate());
          dspacePolicy.setRpDescription(policy.getRpDescription());
          dspacePolicy.setRpName(policy.getRpName());
          dspacePolicy.update();
          bitstreamsPolicies.add(dspacePolicy);
        }
        bundle.replaceAllBitstreamPolicies(bitstreamsPolicies);
        bundle.update();
      }
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  return Response.ok().build();
}",0.999124726477024
52043,"/** 
 * Delete bitstream from all bundles in dspace. It can throw WebApplicationException, which can be caused by three exceptions. SQLException if there was problem with reading from database or removing from database. AuthorizeException, if user has not permission to delete bitstream or file. IOException, if there was problem with file deleting.
 * @param bitstreamId Id of bitsream, which will be deleted.
 * @param headers If you want to access to item under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response codes: OK(200), NOT_FOUND(404) if bitstream ofthat id does not exist and UNAUTHORIZED(401) if user is not allowed to delete bitstream.
 * @throws WebApplicationException It can be throw when was problem with reading or editting database. Or problem with file deleting. Or problem with authorization to bitstream and bundles. Or problem with creating context.
 */
@DELETE @Path(""String_Node_Str"") public Response deleteBitstream(@PathParam(""String_Node_Str"") Integer bitstreamId,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Bitstream dspaceBitstream=findBitstream(context,bitstreamId,org.dspace.core.Constants.DELETE);
    writeStats(dspaceBitstream,UsageEvent.Action.DELETE,user_ip,user_agent,xforwarderfor,headers,request);
    log.trace(""String_Node_Str"");
    for (    org.dspace.content.Bundle bundle : dspaceBitstream.getBundles()) {
      org.dspace.content.Bundle.find(context,bundle.getID()).removeBitstream(dspaceBitstream);
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  return Response.ok().build();
}","/** 
 * Delete bitstream from all bundles in dspace. It can throw WebApplicationException, which can be caused by three exceptions. SQLException if there was problem with reading from database or removing from database. AuthorizeException, if user has not permission to delete bitstream or file. IOException, if there was problem with file deleting.
 * @param bitstreamId Id of bitsream, which will be deleted.
 * @param headers If you want to access to item under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response codes: OK(200), NOT_FOUND(404) if bitstream ofthat id does not exist and UNAUTHORIZED(401) if user is not allowed to delete bitstream.
 * @throws WebApplicationException It can be throw when was problem with reading or editting database. Or problem with file deleting. Or problem with authorization to bitstream and bundles. Or problem with creating context.
 */
@DELETE @Path(""String_Node_Str"") public Response deleteBitstream(@PathParam(""String_Node_Str"") Integer bitstreamId,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Bitstream dspaceBitstream=findBitstream(context,bitstreamId,org.dspace.core.Constants.DELETE);
    writeStats(dspaceBitstream,UsageEvent.Action.DELETE,user_ip,user_agent,xforwarderfor,headers,request,context);
    log.trace(""String_Node_Str"");
    for (    org.dspace.content.Bundle bundle : dspaceBitstream.getBundles()) {
      org.dspace.content.Bundle.find(context,bundle.getID()).removeBitstream(dspaceBitstream);
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  return Response.ok().build();
}",0.9984567901234568
52044,"/** 
 * Read bitstream data. It can throw WebApplicationException with code INTERNAL_SERVER_ERROR(500). Caused by three exceptions: IOException if there was problem with reading bitstream file. SQLException if there was problem while reading from database. And AuthorizeException if there was problem with authorization of user logged to DSpace context.
 * @param bitstreamId Id of bitstream, of which will be read data.
 * @param headers If you want to access to item under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Returns response with data with content type of file. It canreturn response code NOT_FOUND(404) if there was bad id of bitstream. Or response code UNAUTHORIZED(401) if user is not allowed to read bitstream.
 * @throws WebApplicationException It is throw in this cases: When was problem with reading file data. Or was problem with database reading. Or was problem with creating context. Or problem with authorization.
 */
@GET @Path(""String_Node_Str"") public javax.ws.rs.core.Response getBitstreamData(@PathParam(""String_Node_Str"") Integer bitstreamId,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  InputStream inputStream=null;
  String type=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Bitstream dspaceBitstream=findBitstream(context,bitstreamId,org.dspace.core.Constants.READ);
    writeStats(dspaceBitstream,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request);
    log.trace(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
    inputStream=dspaceBitstream.retrieve();
    type=dspaceBitstream.getFormat().getMIMEType();
    context.complete();
  }
 catch (  IOException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  SQLException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  return Response.ok(inputStream).type(type).build();
}","/** 
 * Read bitstream data. It can throw WebApplicationException with code INTERNAL_SERVER_ERROR(500). Caused by three exceptions: IOException if there was problem with reading bitstream file. SQLException if there was problem while reading from database. And AuthorizeException if there was problem with authorization of user logged to DSpace context.
 * @param bitstreamId Id of bitstream, of which will be read data.
 * @param headers If you want to access to item under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Returns response with data with content type of file. It canreturn response code NOT_FOUND(404) if there was bad id of bitstream. Or response code UNAUTHORIZED(401) if user is not allowed to read bitstream.
 * @throws WebApplicationException It is throw in this cases: When was problem with reading file data. Or was problem with database reading. Or was problem with creating context. Or problem with authorization.
 */
@GET @Path(""String_Node_Str"") public javax.ws.rs.core.Response getBitstreamData(@PathParam(""String_Node_Str"") Integer bitstreamId,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  InputStream inputStream=null;
  String type=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Bitstream dspaceBitstream=findBitstream(context,bitstreamId,org.dspace.core.Constants.READ);
    writeStats(dspaceBitstream,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request,context);
    log.trace(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
    inputStream=dspaceBitstream.retrieve();
    type=dspaceBitstream.getFormat().getMIMEType();
    context.complete();
  }
 catch (  IOException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  SQLException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  return Response.ok(inputStream).type(type).build();
}",0.9984691924990432
52045,"/** 
 * Update bitstream data. It change bitstream data by editing database rows. It can throw WebApplicationException caused by: SQLException if there was problem with database editing or reading, IOException if there was problem with reading from inputstream, Exception if there was another problem.
 * @param bitstreamId Id of bistream, which will be updated.
 * @param is Inputstream filled with new data.
 * @param headers If you want to access to item under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response if bitstream was updated. Response codes:OK(200), NOT_FOUND(404) if id of bitstream was bad. And UNAUTHORIZED(401) if user is not allowed to update bitstream.
 * @throws WebApplicationException This exception can be thrown in this cases: Problem with reading or writing to database. Or problem with reading from inputstream.
 */
@PUT @Path(""String_Node_Str"") public Response updateBitstreamData(@PathParam(""String_Node_Str"") Integer bitstreamId,InputStream is,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Bitstream dspaceBitstream=findBitstream(context,bitstreamId,org.dspace.core.Constants.WRITE);
    writeStats(dspaceBitstream,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request);
    log.trace(""String_Node_Str"");
    int newBitstreamId=BitstreamStorageManager.store(context,is);
    log.trace(""String_Node_Str"");
    TableRow originalBitstreamRow=DatabaseManager.find(context,""String_Node_Str"",bitstreamId);
    TableRow bitstream=DatabaseManager.find(context,""String_Node_Str"",newBitstreamId);
    log.trace(""String_Node_Str"");
    String internal_id=originalBitstreamRow.getStringColumn(""String_Node_Str"");
    Long size_bytes=originalBitstreamRow.getLongColumn(""String_Node_Str"");
    originalBitstreamRow.setColumn(""String_Node_Str"",bitstream.getStringColumn(""String_Node_Str""));
    originalBitstreamRow.setColumn(""String_Node_Str"",bitstream.getLongColumn(""String_Node_Str""));
    bitstream.setColumn(""String_Node_Str"",internal_id);
    bitstream.setColumn(""String_Node_Str"",size_bytes);
    DatabaseManager.update(context,originalBitstreamRow);
    BitstreamStorageManager.delete(context,newBitstreamId);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  return Response.ok().build();
}","/** 
 * Update bitstream data. It change bitstream data by editing database rows. It can throw WebApplicationException caused by: SQLException if there was problem with database editing or reading, IOException if there was problem with reading from inputstream, Exception if there was another problem.
 * @param bitstreamId Id of bistream, which will be updated.
 * @param is Inputstream filled with new data.
 * @param headers If you want to access to item under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response if bitstream was updated. Response codes:OK(200), NOT_FOUND(404) if id of bitstream was bad. And UNAUTHORIZED(401) if user is not allowed to update bitstream.
 * @throws WebApplicationException This exception can be thrown in this cases: Problem with reading or writing to database. Or problem with reading from inputstream.
 */
@PUT @Path(""String_Node_Str"") public Response updateBitstreamData(@PathParam(""String_Node_Str"") Integer bitstreamId,InputStream is,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Bitstream dspaceBitstream=findBitstream(context,bitstreamId,org.dspace.core.Constants.WRITE);
    writeStats(dspaceBitstream,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request,context);
    log.trace(""String_Node_Str"");
    int newBitstreamId=BitstreamStorageManager.store(context,is);
    log.trace(""String_Node_Str"");
    TableRow originalBitstreamRow=DatabaseManager.find(context,""String_Node_Str"",bitstreamId);
    TableRow bitstream=DatabaseManager.find(context,""String_Node_Str"",newBitstreamId);
    log.trace(""String_Node_Str"");
    String internal_id=originalBitstreamRow.getStringColumn(""String_Node_Str"");
    Long size_bytes=originalBitstreamRow.getLongColumn(""String_Node_Str"");
    originalBitstreamRow.setColumn(""String_Node_Str"",bitstream.getStringColumn(""String_Node_Str""));
    originalBitstreamRow.setColumn(""String_Node_Str"",bitstream.getLongColumn(""String_Node_Str""));
    bitstream.setColumn(""String_Node_Str"",internal_id);
    bitstream.setColumn(""String_Node_Str"",size_bytes);
    DatabaseManager.update(context,originalBitstreamRow);
    BitstreamStorageManager.delete(context,newBitstreamId);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + bitstreamId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + bitstreamId + ""String_Node_Str"");
  return Response.ok().build();
}",0.9987365761212889
52046,"/** 
 * Return instance of collection with passed id. You can add more properties through expand parameter.
 * @param collectionId Id of collection in DSpace.
 * @param expand String in which is what you want to add to returned instance of collection. Options are: ""all"", ""parentCommunityList"", ""parentCommunity"", ""items"", ""license"" and ""logo"". If you want to use multiple options, it must be separated by commas.
 * @param limit Limit value for items in list in collection. Default value is 100.
 * @param offset Offset of start index in list of items of collection. Default value is 0.
 * @param headers If you want to access to collection under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return instance of collection. It can also return status codeNOT_FOUND(404) if id of collection is incorrect or status code UNATHORIZED(401) if user has no permission to read collection.
 * @throws WebApplicationException It is thrown when was problem with database reading (SQLException) or problem with creating context(ContextException). It is thrown by NOT_FOUND and UNATHORIZED status codes, too.
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public org.dspace.rest.common.Collection getCollection(@PathParam(""String_Node_Str"") Integer collectionId,@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  Collection collection=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Collection dspaceCollection=findCollection(context,collectionId,org.dspace.core.Constants.READ);
    writeStats(dspaceCollection,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request);
    collection=new Collection(dspaceCollection,expand,context,limit,offset);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  return collection;
}","/** 
 * Return instance of collection with passed id. You can add more properties through expand parameter.
 * @param collectionId Id of collection in DSpace.
 * @param expand String in which is what you want to add to returned instance of collection. Options are: ""all"", ""parentCommunityList"", ""parentCommunity"", ""items"", ""license"" and ""logo"". If you want to use multiple options, it must be separated by commas.
 * @param limit Limit value for items in list in collection. Default value is 100.
 * @param offset Offset of start index in list of items of collection. Default value is 0.
 * @param headers If you want to access to collection under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return instance of collection. It can also return status codeNOT_FOUND(404) if id of collection is incorrect or status code UNATHORIZED(401) if user has no permission to read collection.
 * @throws WebApplicationException It is thrown when was problem with database reading (SQLException) or problem with creating context(ContextException). It is thrown by NOT_FOUND and UNATHORIZED status codes, too.
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public org.dspace.rest.common.Collection getCollection(@PathParam(""String_Node_Str"") Integer collectionId,@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  Collection collection=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Collection dspaceCollection=findCollection(context,collectionId,org.dspace.core.Constants.READ);
    writeStats(dspaceCollection,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request,context);
    collection=new Collection(dspaceCollection,expand,context,limit,offset);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  return collection;
}",0.9985396129974444
52047,"/** 
 * Update collection. It replace all properties.
 * @param collectionId Id of collection in DSpace.
 * @param collection Collection which will replace properties of actual collection.
 * @param headers If you want to access to collection under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response 200 if was everything all right. Otherwise 400when id of community was incorrect or 401 if was problem with permission to write into collection.
 * @throws WebApplicationException It is thrown when was problem with database reading or writing. Or problem with authorization to collection. Or problem with creating context.
 */
@PUT @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Response updateCollection(@PathParam(""String_Node_Str"") Integer collectionId,org.dspace.rest.common.Collection collection,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Collection dspaceCollection=findCollection(context,collectionId,org.dspace.core.Constants.WRITE);
    writeStats(dspaceCollection,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request);
    dspaceCollection.setMetadata(""String_Node_Str"",collection.getName());
    dspaceCollection.setLicense(collection.getLicense());
    dspaceCollection.setMetadata(org.dspace.content.Collection.COPYRIGHT_TEXT,collection.getCopyrightText());
    dspaceCollection.setMetadata(org.dspace.content.Collection.INTRODUCTORY_TEXT,collection.getIntroductoryText());
    dspaceCollection.setMetadata(org.dspace.content.Collection.SHORT_DESCRIPTION,collection.getShortDescription());
    dspaceCollection.setMetadata(org.dspace.content.Collection.SIDEBAR_TEXT,collection.getSidebarText());
    dspaceCollection.update();
    context.complete();
  }
 catch (  ContextException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e.getMessage(),context);
  }
catch (  SQLException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  return Response.ok().build();
}","/** 
 * Update collection. It replace all properties.
 * @param collectionId Id of collection in DSpace.
 * @param collection Collection which will replace properties of actual collection.
 * @param headers If you want to access to collection under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response 200 if was everything all right. Otherwise 400when id of community was incorrect or 401 if was problem with permission to write into collection.
 * @throws WebApplicationException It is thrown when was problem with database reading or writing. Or problem with authorization to collection. Or problem with creating context.
 */
@PUT @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Response updateCollection(@PathParam(""String_Node_Str"") Integer collectionId,org.dspace.rest.common.Collection collection,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Collection dspaceCollection=findCollection(context,collectionId,org.dspace.core.Constants.WRITE);
    writeStats(dspaceCollection,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request,context);
    dspaceCollection.setMetadata(""String_Node_Str"",collection.getName());
    dspaceCollection.setLicense(collection.getLicense());
    dspaceCollection.setMetadata(org.dspace.content.Collection.COPYRIGHT_TEXT,collection.getCopyrightText());
    dspaceCollection.setMetadata(org.dspace.content.Collection.INTRODUCTORY_TEXT,collection.getIntroductoryText());
    dspaceCollection.setMetadata(org.dspace.content.Collection.SHORT_DESCRIPTION,collection.getShortDescription());
    dspaceCollection.setMetadata(org.dspace.content.Collection.SIDEBAR_TEXT,collection.getSidebarText());
    dspaceCollection.update();
    context.complete();
  }
 catch (  ContextException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e.getMessage(),context);
  }
catch (  SQLException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  return Response.ok().build();
}",0.9985396129974444
52048,"/** 
 * Delete collection.
 * @param collectionId Id of collection which will be deleted.
 * @param headers If you want to access to collection under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response code OK(200) if was everything all right.Otherwise return NOT_FOUND(404) if was id of community or collection incorrect. Or (UNAUTHORIZED)401 if was problem with permission to community or collection.
 * @throws WebApplicationException It is throw when was problem with creating context or problem with database reading or writing. Or problem with deleting collection caused by IOException or authorization.
 */
@DELETE @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Response deleteCollection(@PathParam(""String_Node_Str"") Integer collectionId,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Collection dspaceCollection=findCollection(context,collectionId,org.dspace.core.Constants.DELETE);
    writeStats(dspaceCollection,UsageEvent.Action.REMOVE,user_ip,user_agent,xforwarderfor,headers,request);
    org.dspace.content.Community community=(org.dspace.content.Community)dspaceCollection.getParentObject();
    community.removeCollection(dspaceCollection);
    context.complete();
  }
 catch (  ContextException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e.getMessage(),context);
  }
catch (  SQLException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  return Response.ok().build();
}","/** 
 * Delete collection.
 * @param collectionId Id of collection which will be deleted.
 * @param headers If you want to access to collection under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response code OK(200) if was everything all right.Otherwise return NOT_FOUND(404) if was id of community or collection incorrect. Or (UNAUTHORIZED)401 if was problem with permission to community or collection.
 * @throws WebApplicationException It is throw when was problem with creating context or problem with database reading or writing. Or problem with deleting collection caused by IOException or authorization.
 */
@DELETE @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Response deleteCollection(@PathParam(""String_Node_Str"") Integer collectionId,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Collection dspaceCollection=findCollection(context,collectionId,org.dspace.core.Constants.DELETE);
    writeStats(dspaceCollection,UsageEvent.Action.REMOVE,user_ip,user_agent,xforwarderfor,headers,request,context);
    org.dspace.content.Community community=(org.dspace.content.Community)dspaceCollection.getParentObject();
    community.removeCollection(dspaceCollection);
    context.complete();
  }
 catch (  ContextException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e.getMessage(),context);
  }
catch (  SQLException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  return Response.ok().build();
}",0.998297147722435
52049,"/** 
 * Delete item in collection.
 * @param collectionId Id of collection which will be deleted.
 * @param itemId Id of item in colletion.
 * @return It returns status code: OK(200). NOT_FOUND(404) if item orcollection was not found, UNAUTHORIZED(401) if user is not allowed to delete item or permission to write into collection.
 * @throws WebApplicationException It can be thrown by: SQLException, when was problem with database reading or writting. AuthorizeException, when was problem with authorization to item or collection. IOException, when was problem with removing item. ContextException, when was problem with creating context of DSpace.
 */
@DELETE @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Response deleteCollectionItem(@PathParam(""String_Node_Str"") Integer collectionId,@PathParam(""String_Node_Str"") Integer itemId,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + itemId + ""String_Node_Str""+ collectionId+ ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Collection dspaceCollection=findCollection(context,collectionId,org.dspace.core.Constants.WRITE);
    org.dspace.content.Item item=null;
    org.dspace.content.ItemIterator dspaceItems=dspaceCollection.getItems();
    while (dspaceItems.hasNext()) {
      org.dspace.content.Item dspaceItem=dspaceItems.next();
      if (dspaceItem.getID() == itemId) {
        item=dspaceItem;
      }
    }
    if (item == null) {
      context.abort();
      log.warn(""String_Node_Str"" + itemId + ""String_Node_Str"");
      throw new WebApplicationException(Response.Status.NOT_FOUND);
    }
 else     if (!AuthorizeManager.authorizeActionBoolean(context,item,org.dspace.core.Constants.REMOVE)) {
      context.abort();
      if (context.getCurrentUser() != null) {
        log.error(""String_Node_Str"" + context.getCurrentUser().getEmail() + ""String_Node_Str"");
      }
 else {
        log.error(""String_Node_Str"");
      }
      throw new WebApplicationException(Response.Status.UNAUTHORIZED);
    }
    writeStats(dspaceCollection,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request);
    writeStats(item,UsageEvent.Action.REMOVE,user_ip,user_agent,xforwarderfor,headers,request);
    dspaceCollection.removeItem(item);
    context.complete();
  }
 catch (  ContextException e) {
    processException(""String_Node_Str"" + itemId + ""String_Node_Str""+ collectionId+ ""String_Node_Str""+ e.getMessage(),context);
  }
catch (  SQLException e) {
    processException(""String_Node_Str"" + itemId + ""String_Node_Str""+ collectionId+ ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + itemId + ""String_Node_Str""+ collectionId+ ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + itemId + ""String_Node_Str""+ collectionId+ ""String_Node_Str""+ e,context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + itemId + ""String_Node_Str""+ collectionId+ ""String_Node_Str"");
  return Response.ok().build();
}","/** 
 * Delete item in collection.
 * @param collectionId Id of collection which will be deleted.
 * @param itemId Id of item in colletion.
 * @return It returns status code: OK(200). NOT_FOUND(404) if item orcollection was not found, UNAUTHORIZED(401) if user is not allowed to delete item or permission to write into collection.
 * @throws WebApplicationException It can be thrown by: SQLException, when was problem with database reading or writting. AuthorizeException, when was problem with authorization to item or collection. IOException, when was problem with removing item. ContextException, when was problem with creating context of DSpace.
 */
@DELETE @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Response deleteCollectionItem(@PathParam(""String_Node_Str"") Integer collectionId,@PathParam(""String_Node_Str"") Integer itemId,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + itemId + ""String_Node_Str""+ collectionId+ ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Collection dspaceCollection=findCollection(context,collectionId,org.dspace.core.Constants.WRITE);
    org.dspace.content.Item item=null;
    org.dspace.content.ItemIterator dspaceItems=dspaceCollection.getItems();
    while (dspaceItems.hasNext()) {
      org.dspace.content.Item dspaceItem=dspaceItems.next();
      if (dspaceItem.getID() == itemId) {
        item=dspaceItem;
      }
    }
    if (item == null) {
      context.abort();
      log.warn(""String_Node_Str"" + itemId + ""String_Node_Str"");
      throw new WebApplicationException(Response.Status.NOT_FOUND);
    }
 else     if (!AuthorizeManager.authorizeActionBoolean(context,item,org.dspace.core.Constants.REMOVE)) {
      context.abort();
      if (context.getCurrentUser() != null) {
        log.error(""String_Node_Str"" + context.getCurrentUser().getEmail() + ""String_Node_Str"");
      }
 else {
        log.error(""String_Node_Str"");
      }
      throw new WebApplicationException(Response.Status.UNAUTHORIZED);
    }
    writeStats(dspaceCollection,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request,context);
    writeStats(item,UsageEvent.Action.REMOVE,user_ip,user_agent,xforwarderfor,headers,request,context);
    dspaceCollection.removeItem(item);
    context.complete();
  }
 catch (  ContextException e) {
    processException(""String_Node_Str"" + itemId + ""String_Node_Str""+ collectionId+ ""String_Node_Str""+ e.getMessage(),context);
  }
catch (  SQLException e) {
    processException(""String_Node_Str"" + itemId + ""String_Node_Str""+ collectionId+ ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + itemId + ""String_Node_Str""+ collectionId+ ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + itemId + ""String_Node_Str""+ collectionId+ ""String_Node_Str""+ e,context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + itemId + ""String_Node_Str""+ collectionId+ ""String_Node_Str"");
  return Response.ok().build();
}",0.9976324356318438
52050,"/** 
 * Return array of all collections in DSpace. You can add more properties through expand parameter.
 * @param expand String in which is what you want to add to returned instance of collection. Options are: ""all"", ""parentCommunityList"", ""parentCommunity"", ""items"", ""license"" and ""logo"". If you want to use multiple options, it must be separated by commas.
 * @param limit Limit value for items in list in collection. Default value is 100.
 * @param offset Offset of start index in list of items of collection. Default value is 0.
 * @param headers If you want to access to collections under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return array of collection, on which has logged user permissionto view.
 * @throws WebApplicationException It is thrown when was problem with database reading (SQLException) or problem with creating context(ContextException).
 */
@GET @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public org.dspace.rest.common.Collection[] getCollections(@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + offset + ""String_Node_Str""+ limit+ ""String_Node_Str"");
  org.dspace.core.Context context=null;
  List<Collection> collections=new ArrayList<Collection>();
  try {
    context=createContext(getUser(headers));
    if (!((limit != null) && (limit >= 0) && (offset != null)&& (offset >= 0))) {
      log.warn(""String_Node_Str"");
      limit=100;
      offset=0;
    }
    org.dspace.content.Collection[] dspaceCollections=org.dspace.content.Collection.findAll(context,limit,offset);
    for (    org.dspace.content.Collection dspaceCollection : dspaceCollections) {
      if (AuthorizeManager.authorizeActionBoolean(context,dspaceCollection,org.dspace.core.Constants.READ)) {
        Collection collection=new org.dspace.rest.common.Collection(dspaceCollection,null,context,limit,offset);
        collections.add(collection);
        writeStats(dspaceCollection,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request);
      }
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"");
  return collections.toArray(new org.dspace.rest.common.Collection[0]);
}","/** 
 * Return array of all collections in DSpace. You can add more properties through expand parameter.
 * @param expand String in which is what you want to add to returned instance of collection. Options are: ""all"", ""parentCommunityList"", ""parentCommunity"", ""items"", ""license"" and ""logo"". If you want to use multiple options, it must be separated by commas.
 * @param limit Limit value for items in list in collection. Default value is 100.
 * @param offset Offset of start index in list of items of collection. Default value is 0.
 * @param headers If you want to access to collections under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return array of collection, on which has logged user permissionto view.
 * @throws WebApplicationException It is thrown when was problem with database reading (SQLException) or problem with creating context(ContextException).
 */
@GET @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public org.dspace.rest.common.Collection[] getCollections(@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + offset + ""String_Node_Str""+ limit+ ""String_Node_Str"");
  org.dspace.core.Context context=null;
  List<Collection> collections=new ArrayList<Collection>();
  try {
    context=createContext(getUser(headers));
    if (!((limit != null) && (limit >= 0) && (offset != null)&& (offset >= 0))) {
      log.warn(""String_Node_Str"");
      limit=100;
      offset=0;
    }
    org.dspace.content.Collection[] dspaceCollections=org.dspace.content.Collection.findAll(context,limit,offset);
    for (    org.dspace.content.Collection dspaceCollection : dspaceCollections) {
      if (AuthorizeManager.authorizeActionBoolean(context,dspaceCollection,org.dspace.core.Constants.READ)) {
        Collection collection=new org.dspace.rest.common.Collection(dspaceCollection,null,context,limit,offset);
        collections.add(collection);
        writeStats(dspaceCollection,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request,context);
      }
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"");
  return collections.toArray(new org.dspace.rest.common.Collection[0]);
}",0.9986062717770036
52051,"/** 
 * Create item in collection. Item can be without filled metadata.
 * @param collectionId Id of collection in which will be item created.
 * @param item Item filled only with metadata, other variables are ignored.
 * @param headers If you want to access to collection under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return status code with item. Return status (OK)200 if item wascreated. NOT_FOUND(404) if id of collection does not exists. UNAUTHORIZED(401) if user have not permission to write items in collection.
 * @throws WebApplicationException It is thrown when was problem with database reading or writing (SQLException) or problem with creating context(ContextException) or problem with authorization to collection or IOException or problem with index item into browse index. It is thrown by NOT_FOUND and UNATHORIZED status codes, too.
 */
@POST @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Item addCollectionItem(@PathParam(""String_Node_Str"") Integer collectionId,Item item,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  Item returnItem=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Collection dspaceCollection=findCollection(context,collectionId,org.dspace.core.Constants.WRITE);
    writeStats(dspaceCollection,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request);
    log.trace(""String_Node_Str"" + collectionId + ""String_Node_Str"");
    org.dspace.content.WorkspaceItem workspaceItem=org.dspace.content.WorkspaceItem.create(context,dspaceCollection,false);
    org.dspace.content.Item dspaceItem=workspaceItem.getItem();
    log.trace(""String_Node_Str"" + dspaceItem.getID() + ""String_Node_Str"");
    if (item.getMetadata() != null) {
      for (      MetadataEntry entry : item.getMetadata()) {
        String data[]=mySplit(entry.getKey());
        dspaceItem.addMetadata(data[0],data[1],data[2],entry.getLanguage(),entry.getValue());
      }
    }
    workspaceItem.update();
    org.dspace.browse.IndexBrowse browse=new org.dspace.browse.IndexBrowse();
    browse.indexItem(dspaceItem);
    log.trace(""String_Node_Str"" + collectionId + ""String_Node_Str"");
    dspaceItem=org.dspace.content.InstallItem.installItem(context,workspaceItem);
    returnItem=new Item(dspaceItem,""String_Node_Str"",context);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
catch (  BrowseException e) {
    processException(""String_Node_Str"" + e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str""+ returnItem.getHandle());
  return returnItem;
}","/** 
 * Create item in collection. Item can be without filled metadata.
 * @param collectionId Id of collection in which will be item created.
 * @param item Item filled only with metadata, other variables are ignored.
 * @param headers If you want to access to collection under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return status code with item. Return status (OK)200 if item wascreated. NOT_FOUND(404) if id of collection does not exists. UNAUTHORIZED(401) if user have not permission to write items in collection.
 * @throws WebApplicationException It is thrown when was problem with database reading or writing (SQLException) or problem with creating context(ContextException) or problem with authorization to collection or IOException or problem with index item into browse index. It is thrown by NOT_FOUND and UNATHORIZED status codes, too.
 */
@POST @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Item addCollectionItem(@PathParam(""String_Node_Str"") Integer collectionId,Item item,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  Item returnItem=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Collection dspaceCollection=findCollection(context,collectionId,org.dspace.core.Constants.WRITE);
    writeStats(dspaceCollection,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request,context);
    log.trace(""String_Node_Str"" + collectionId + ""String_Node_Str"");
    org.dspace.content.WorkspaceItem workspaceItem=org.dspace.content.WorkspaceItem.create(context,dspaceCollection,false);
    org.dspace.content.Item dspaceItem=workspaceItem.getItem();
    log.trace(""String_Node_Str"" + dspaceItem.getID() + ""String_Node_Str"");
    if (item.getMetadata() != null) {
      for (      MetadataEntry entry : item.getMetadata()) {
        String data[]=mySplit(entry.getKey());
        dspaceItem.addMetadata(data[0],data[1],data[2],entry.getLanguage(),entry.getValue());
      }
    }
    workspaceItem.update();
    org.dspace.browse.IndexBrowse browse=new org.dspace.browse.IndexBrowse();
    browse.indexItem(dspaceItem);
    log.trace(""String_Node_Str"" + collectionId + ""String_Node_Str"");
    dspaceItem=org.dspace.content.InstallItem.installItem(context,workspaceItem);
    returnItem=new Item(dspaceItem,""String_Node_Str"",context);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e,context);
  }
catch (  BrowseException e) {
    processException(""String_Node_Str"" + e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str""+ returnItem.getHandle());
  return returnItem;
}",0.9988548525622674
52052,"/** 
 * Return array of items in collection. You can add more properties to items with expand parameter.
 * @param collectionId Id of collection in DSpace.
 * @param expand String which define, what additional properties will be in returned item. Options are separeted by commas and are: ""all"", ""metadata"", ""parentCollection"", ""parentCollectionList"", ""parentCommunityList"" and ""bitstreams"".
 * @param limit Limit value for items in array. Default value is 100.
 * @param offset Offset of start index in array of items of collection. Default value is 0.
 * @param headers If you want to access to collection under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return array of items, on which has logged user permission toread. It can also return status code NOT_FOUND(404) if id of collection is incorrect or status code UNATHORIZED(401) if user has no permission to read collection.
 * @throws WebApplicationException It is thrown when was problem with database reading (SQLException) or problem with creating context(ContextException). It is thrown by NOT_FOUND and UNATHORIZED status codes, too.
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public org.dspace.rest.common.Item[] getCollectionItems(@PathParam(""String_Node_Str"") Integer collectionId,@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  List<Item> items=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Collection dspaceCollection=findCollection(context,collectionId,org.dspace.core.Constants.READ);
    writeStats(dspaceCollection,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request);
    items=new ArrayList<Item>();
    org.dspace.content.ItemIterator dspaceItems=dspaceCollection.getItems();
    for (int i=0; (dspaceItems.hasNext()) && (i < (limit + offset)); i++) {
      if (i >= offset) {
        org.dspace.content.Item dspaceItem=dspaceItems.next();
        if (AuthorizeManager.authorizeActionBoolean(context,dspaceItem,org.dspace.core.Constants.READ)) {
          items.add(new Item(dspaceItem,expand,context));
          writeStats(dspaceItem,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request);
        }
      }
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  return items.toArray(new Item[0]);
}","/** 
 * Return array of items in collection. You can add more properties to items with expand parameter.
 * @param collectionId Id of collection in DSpace.
 * @param expand String which define, what additional properties will be in returned item. Options are separeted by commas and are: ""all"", ""metadata"", ""parentCollection"", ""parentCollectionList"", ""parentCommunityList"" and ""bitstreams"".
 * @param limit Limit value for items in array. Default value is 100.
 * @param offset Offset of start index in array of items of collection. Default value is 0.
 * @param headers If you want to access to collection under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return array of items, on which has logged user permission toread. It can also return status code NOT_FOUND(404) if id of collection is incorrect or status code UNATHORIZED(401) if user has no permission to read collection.
 * @throws WebApplicationException It is thrown when was problem with database reading (SQLException) or problem with creating context(ContextException). It is thrown by NOT_FOUND and UNATHORIZED status codes, too.
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public org.dspace.rest.common.Item[] getCollectionItems(@PathParam(""String_Node_Str"") Integer collectionId,@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  List<Item> items=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Collection dspaceCollection=findCollection(context,collectionId,org.dspace.core.Constants.READ);
    writeStats(dspaceCollection,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request,context);
    items=new ArrayList<Item>();
    org.dspace.content.ItemIterator dspaceItems=dspaceCollection.getItems();
    for (int i=0; (dspaceItems.hasNext()) && (i < (limit + offset)); i++) {
      if (i >= offset) {
        org.dspace.content.Item dspaceItem=dspaceItems.next();
        if (AuthorizeManager.authorizeActionBoolean(context,dspaceItem,org.dspace.core.Constants.READ)) {
          items.add(new Item(dspaceItem,expand,context));
          writeStats(dspaceItem,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request,context);
        }
      }
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"" + collectionId + ""String_Node_Str"");
  return items.toArray(new Item[0]);
}",0.9974842767295596
52053,"/** 
 * Returns community with basic properties. If you want more, use expand parameter or method for community collections or subcommunities.
 * @param communityId Id of community in DSpace.
 * @param expand String in which is what you want to add to returned instance of community. Options are: ""all"", ""parentCommunity"", ""collections"", ""subCommunities"" and ""logo"". If you want to use multiple options, it must be separated by commas.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return instance of org.dspace.rest.common.Community.
 * @throws WebApplicationException It is throw when was problem with creating context or problem with database reading. Also if id of community is incorrect or logged user into context has no permission to read.
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Community getCommunity(@PathParam(""String_Node_Str"") Integer communityId,@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  Community community=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community dspaceCommunity=findCommunity(context,communityId,org.dspace.core.Constants.READ);
    writeStats(dspaceCommunity,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request);
    community=new Community(dspaceCommunity,expand,context);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"" + communityId + ""String_Node_Str"");
  return community;
}","/** 
 * Returns community with basic properties. If you want more, use expand parameter or method for community collections or subcommunities.
 * @param communityId Id of community in DSpace.
 * @param expand String in which is what you want to add to returned instance of community. Options are: ""all"", ""parentCommunity"", ""collections"", ""subCommunities"" and ""logo"". If you want to use multiple options, it must be separated by commas.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return instance of org.dspace.rest.common.Community.
 * @throws WebApplicationException It is throw when was problem with creating context or problem with database reading. Also if id of community is incorrect or logged user into context has no permission to read.
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Community getCommunity(@PathParam(""String_Node_Str"") Integer communityId,@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  Community community=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community dspaceCommunity=findCommunity(context,communityId,org.dspace.core.Constants.READ);
    writeStats(dspaceCommunity,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request,context);
    community=new Community(dspaceCommunity,expand,context);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"" + communityId + ""String_Node_Str"");
  return community;
}",0.998212689901698
52054,"/** 
 * Return all subcommunities of community.
 * @param communityId Id of community in DSpace.
 * @param expand String in which is what you want to add to returned instance of community. Options are: ""all"", ""parentCommunity"", ""collections"", ""subCommunities"" and ""logo"". If you want to use multiple options, it must be separated by commas.
 * @param limit Maximum communities in array. Default value is 20.
 * @param offset Index from which will start array of communities. Default value is 0.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return array of subcommunities of community.
 * @throws WebApplicationException It can be caused by creating context or while was problem with reading community from database(SQLException).
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Community[] getCommunityCommunities(@PathParam(""String_Node_Str"") Integer communityId,@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  ArrayList<Community> communities=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community dspaceCommunity=findCommunity(context,communityId,org.dspace.core.Constants.READ);
    writeStats(dspaceCommunity,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request);
    if (!((limit != null) && (limit >= 0) && (offset != null)&& (offset >= 0))) {
      log.warn(""String_Node_Str"");
      limit=100;
      offset=0;
    }
    communities=new ArrayList<Community>();
    org.dspace.content.Community[] dspaceCommunities=dspaceCommunity.getSubcommunities();
    for (int i=offset; (i < (offset + limit)) && (i < dspaceCommunities.length); i++) {
      if (AuthorizeManager.authorizeActionBoolean(context,dspaceCommunities[i],org.dspace.core.Constants.READ)) {
        communities.add(new Community(dspaceCommunities[i],expand,context));
        writeStats(dspaceCommunities[i],UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request);
      }
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"" + communityId + ""String_Node_Str"");
  return communities.toArray(new Community[0]);
}","/** 
 * Return all subcommunities of community.
 * @param communityId Id of community in DSpace.
 * @param expand String in which is what you want to add to returned instance of community. Options are: ""all"", ""parentCommunity"", ""collections"", ""subCommunities"" and ""logo"". If you want to use multiple options, it must be separated by commas.
 * @param limit Maximum communities in array. Default value is 20.
 * @param offset Index from which will start array of communities. Default value is 0.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return array of subcommunities of community.
 * @throws WebApplicationException It can be caused by creating context or while was problem with reading community from database(SQLException).
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Community[] getCommunityCommunities(@PathParam(""String_Node_Str"") Integer communityId,@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  ArrayList<Community> communities=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community dspaceCommunity=findCommunity(context,communityId,org.dspace.core.Constants.READ);
    writeStats(dspaceCommunity,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request,context);
    if (!((limit != null) && (limit >= 0) && (offset != null)&& (offset >= 0))) {
      log.warn(""String_Node_Str"");
      limit=100;
      offset=0;
    }
    communities=new ArrayList<Community>();
    org.dspace.content.Community[] dspaceCommunities=dspaceCommunity.getSubcommunities();
    for (int i=offset; (i < (offset + limit)) && (i < dspaceCommunities.length); i++) {
      if (AuthorizeManager.authorizeActionBoolean(context,dspaceCommunities[i],org.dspace.core.Constants.READ)) {
        communities.add(new Community(dspaceCommunities[i],expand,context));
        writeStats(dspaceCommunities[i],UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request,context);
      }
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"" + communityId + ""String_Node_Str"");
  return communities.toArray(new Community[0]);
}",0.9973966807679792
52055,"/** 
 * Return all top communities in DSpace. Top communities are communities on the root of tree.
 * @param expand String in which is what you want to add to returned instance of community. Options are: ""all"", ""parentCommunity"", ""collections"", ""subCommunities"" and ""logo"". If you want to use multiple options, it must be separated by commas.
 * @param limit Maximum communities in array. Default value is 100.
 * @param offset Index from which will start array of communities. Default value is 0.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return array of top communities.
 * @throws WebApplicationException It can be caused by creating context or while was problem with reading community from database(SQLException).
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Community[] getTopCommunities(@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + offset + ""String_Node_Str""+ limit+ ""String_Node_Str"");
  org.dspace.core.Context context=null;
  ArrayList<Community> communities=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community[] dspaceCommunities=org.dspace.content.Community.findAllTop(context);
    communities=new ArrayList<Community>();
    if (!((limit != null) && (limit >= 0) && (offset != null)&& (offset >= 0))) {
      log.warn(""String_Node_Str"");
      limit=100;
      offset=0;
    }
    for (int i=offset; (i < (offset + limit)) && i < dspaceCommunities.length; i++) {
      if (AuthorizeManager.authorizeActionBoolean(context,dspaceCommunities[i],org.dspace.core.Constants.READ)) {
        Community community=new Community(dspaceCommunities[i],expand,context);
        writeStats(dspaceCommunities[i],UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request);
        communities.add(community);
      }
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"");
  return communities.toArray(new Community[0]);
}","/** 
 * Return all top communities in DSpace. Top communities are communities on the root of tree.
 * @param expand String in which is what you want to add to returned instance of community. Options are: ""all"", ""parentCommunity"", ""collections"", ""subCommunities"" and ""logo"". If you want to use multiple options, it must be separated by commas.
 * @param limit Maximum communities in array. Default value is 100.
 * @param offset Index from which will start array of communities. Default value is 0.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return array of top communities.
 * @throws WebApplicationException It can be caused by creating context or while was problem with reading community from database(SQLException).
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Community[] getTopCommunities(@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + offset + ""String_Node_Str""+ limit+ ""String_Node_Str"");
  org.dspace.core.Context context=null;
  ArrayList<Community> communities=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community[] dspaceCommunities=org.dspace.content.Community.findAllTop(context);
    communities=new ArrayList<Community>();
    if (!((limit != null) && (limit >= 0) && (offset != null)&& (offset >= 0))) {
      log.warn(""String_Node_Str"");
      limit=100;
      offset=0;
    }
    for (int i=offset; (i < (offset + limit)) && i < dspaceCommunities.length; i++) {
      if (AuthorizeManager.authorizeActionBoolean(context,dspaceCommunities[i],org.dspace.core.Constants.READ)) {
        Community community=new Community(dspaceCommunities[i],expand,context);
        writeStats(dspaceCommunities[i],UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request,context);
        communities.add(community);
      }
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"");
  return communities.toArray(new Community[0]);
}",0.998547567175018
52056,"/** 
 * Create subcommunity in community.
 * @param communityId Id of community in DSpace, in which will be created subcommunity.
 * @param community Community which will be added into community.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response 200 if was everything all right. Otherwise 400when id of community was incorrect or 401 if was problem with permission to write into collection.
 * @throws WebApplicationException It is thrown when was problem with database reading or writing. Or problem with authorization to community. Or problem with creating context.
 */
@POST @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Community addCommunityCommunity(@PathParam(""String_Node_Str"") Integer communityId,Community community,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  Community retCommunity=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community dspaceParentCommunity=findCommunity(context,communityId,org.dspace.core.Constants.WRITE);
    writeStats(dspaceParentCommunity,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request);
    org.dspace.content.Community dspaceCommunity=org.dspace.content.Community.create(dspaceParentCommunity,context);
    dspaceCommunity.setMetadata(""String_Node_Str"",community.getName());
    dspaceCommunity.setMetadata(org.dspace.content.Community.COPYRIGHT_TEXT,community.getCopyrightText());
    dspaceCommunity.setMetadata(org.dspace.content.Community.INTRODUCTORY_TEXT,community.getIntroductoryText());
    dspaceCommunity.setMetadata(org.dspace.content.Community.SHORT_DESCRIPTION,community.getShortDescription());
    dspaceCommunity.setMetadata(org.dspace.content.Community.SIDEBAR_TEXT,community.getSidebarText());
    dspaceCommunity.update();
    dspaceParentCommunity.update();
    retCommunity=new Community(dspaceCommunity,""String_Node_Str"",context);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  return retCommunity;
}","/** 
 * Create subcommunity in community.
 * @param communityId Id of community in DSpace, in which will be created subcommunity.
 * @param community Community which will be added into community.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response 200 if was everything all right. Otherwise 400when id of community was incorrect or 401 if was problem with permission to write into collection.
 * @throws WebApplicationException It is thrown when was problem with database reading or writing. Or problem with authorization to community. Or problem with creating context.
 */
@POST @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Community addCommunityCommunity(@PathParam(""String_Node_Str"") Integer communityId,Community community,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  Community retCommunity=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community dspaceParentCommunity=findCommunity(context,communityId,org.dspace.core.Constants.WRITE);
    writeStats(dspaceParentCommunity,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request,context);
    org.dspace.content.Community dspaceCommunity=org.dspace.content.Community.create(dspaceParentCommunity,context);
    dspaceCommunity.setMetadata(""String_Node_Str"",community.getName());
    dspaceCommunity.setMetadata(org.dspace.content.Community.COPYRIGHT_TEXT,community.getCopyrightText());
    dspaceCommunity.setMetadata(org.dspace.content.Community.INTRODUCTORY_TEXT,community.getIntroductoryText());
    dspaceCommunity.setMetadata(org.dspace.content.Community.SHORT_DESCRIPTION,community.getShortDescription());
    dspaceCommunity.setMetadata(org.dspace.content.Community.SIDEBAR_TEXT,community.getSidebarText());
    dspaceCommunity.update();
    dspaceParentCommunity.update();
    retCommunity=new Community(dspaceCommunity,""String_Node_Str"",context);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  return retCommunity;
}",0.9986163957108268
52057,"/** 
 * Delete collection in community.
 * @param communityId Id of community in DSpace.
 * @param collectionId Id of collection which will be deleted.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response code OK(200) if was everything all right.Otherwise return NOT_FOUND(404) if was id of community or collection incorrect. Or (UNAUTHORIZED)401 if was problem with permission to community or collection.
 * @throws WebApplicationException It is throw when was problem with creating context or problem with database reading or deleting. Or problem with deleting collection caused by IOException or authorization.
 */
@DELETE @Path(""String_Node_Str"") public Response deleteCommunityCollection(@PathParam(""String_Node_Str"") Integer communityId,@PathParam(""String_Node_Str"") Integer collectionId,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str""+ communityId+ ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community community=findCommunity(context,communityId,org.dspace.core.Constants.WRITE);
    org.dspace.content.Collection collection=null;
    for (    org.dspace.content.Collection dspaceCollection : community.getAllCollections()) {
      if (dspaceCollection.getID() == collectionId) {
        collection=dspaceCollection;
        break;
      }
    }
    if (collection == null) {
      context.abort();
      log.warn(""String_Node_Str"" + collectionId + ""String_Node_Str"");
      throw new WebApplicationException(Response.Status.NOT_FOUND);
    }
 else     if (!AuthorizeManager.authorizeActionBoolean(context,collection,org.dspace.core.Constants.REMOVE)) {
      context.abort();
      if (context.getCurrentUser() != null) {
        log.error(""String_Node_Str"" + context.getCurrentUser().getEmail() + ""String_Node_Str"");
      }
 else {
        log.error(""String_Node_Str"");
      }
      throw new WebApplicationException(Response.Status.UNAUTHORIZED);
    }
    writeStats(community,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request);
    writeStats(collection,UsageEvent.Action.DELETE,user_ip,user_agent,xforwarderfor,headers,request);
    community.removeCollection(collection);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ communityId+ ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ communityId+ ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ communityId+ ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ communityId+ ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str""+ communityId+ ""String_Node_Str"");
  return Response.status(Response.Status.OK).build();
}","/** 
 * Delete collection in community.
 * @param communityId Id of community in DSpace.
 * @param collectionId Id of collection which will be deleted.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response code OK(200) if was everything all right.Otherwise return NOT_FOUND(404) if was id of community or collection incorrect. Or (UNAUTHORIZED)401 if was problem with permission to community or collection.
 * @throws WebApplicationException It is throw when was problem with creating context or problem with database reading or deleting. Or problem with deleting collection caused by IOException or authorization.
 */
@DELETE @Path(""String_Node_Str"") public Response deleteCommunityCollection(@PathParam(""String_Node_Str"") Integer communityId,@PathParam(""String_Node_Str"") Integer collectionId,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str""+ communityId+ ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community community=findCommunity(context,communityId,org.dspace.core.Constants.WRITE);
    org.dspace.content.Collection collection=null;
    for (    org.dspace.content.Collection dspaceCollection : community.getAllCollections()) {
      if (dspaceCollection.getID() == collectionId) {
        collection=dspaceCollection;
        break;
      }
    }
    if (collection == null) {
      context.abort();
      log.warn(""String_Node_Str"" + collectionId + ""String_Node_Str"");
      throw new WebApplicationException(Response.Status.NOT_FOUND);
    }
 else     if (!AuthorizeManager.authorizeActionBoolean(context,collection,org.dspace.core.Constants.REMOVE)) {
      context.abort();
      if (context.getCurrentUser() != null) {
        log.error(""String_Node_Str"" + context.getCurrentUser().getEmail() + ""String_Node_Str"");
      }
 else {
        log.error(""String_Node_Str"");
      }
      throw new WebApplicationException(Response.Status.UNAUTHORIZED);
    }
    writeStats(community,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request,context);
    writeStats(collection,UsageEvent.Action.DELETE,user_ip,user_agent,xforwarderfor,headers,request,context);
    community.removeCollection(collection);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ communityId+ ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ communityId+ ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ communityId+ ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + collectionId + ""String_Node_Str""+ communityId+ ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + collectionId + ""String_Node_Str""+ communityId+ ""String_Node_Str"");
  return Response.status(Response.Status.OK).build();
}",0.997693859901989
52058,"/** 
 * Delete community from DSpace. It delete it everything with community!
 * @param communityId Id of community in DSpace.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response code OK(200) if was everything all right.Otherwise return NOT_FOUND(404) if was id of community incorrect. Or (UNAUTHORIZED)401 if was problem with permission to community.
 * @throws WebApplicationException It is throw when was problem with creating context or problem with database reading or deleting. Or problem with deleting community caused by IOException or authorization.
 */
@DELETE @Path(""String_Node_Str"") public Response deleteCommunity(@PathParam(""String_Node_Str"") Integer communityId,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community community=findCommunity(context,communityId,org.dspace.core.Constants.DELETE);
    writeStats(community,UsageEvent.Action.DELETE,user_ip,user_agent,xforwarderfor,headers,request);
    community.delete();
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  return Response.status(Response.Status.OK).build();
}","/** 
 * Delete community from DSpace. It delete it everything with community!
 * @param communityId Id of community in DSpace.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response code OK(200) if was everything all right.Otherwise return NOT_FOUND(404) if was id of community incorrect. Or (UNAUTHORIZED)401 if was problem with permission to community.
 * @throws WebApplicationException It is throw when was problem with creating context or problem with database reading or deleting. Or problem with deleting community caused by IOException or authorization.
 */
@DELETE @Path(""String_Node_Str"") public Response deleteCommunity(@PathParam(""String_Node_Str"") Integer communityId,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community community=findCommunity(context,communityId,org.dspace.core.Constants.DELETE);
    writeStats(community,UsageEvent.Action.DELETE,user_ip,user_agent,xforwarderfor,headers,request,context);
    community.delete();
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  return Response.status(Response.Status.OK).build();
}",0.9981421272642824
52059,"/** 
 * Delete subcommunity in community.
 * @param parentCommunityId Id of community in DSpace.
 * @param subcommunityId Id of community which will be deleted.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response code OK(200) if was everything all right.Otherwise return NOT_FOUND(404) if was id of community or subcommunity incorrect. Or (UNAUTHORIZED)401 if was problem with permission to community or subcommunity.
 * @throws WebApplicationException It is throw when was problem with creating context or problem with database reading or deleting. Or problem with deleting subcommunity caused by IOException or authorization.
 */
@DELETE @Path(""String_Node_Str"") public Response deleteCommunityCommunity(@PathParam(""String_Node_Str"") Integer parentCommunityId,@PathParam(""String_Node_Str"") Integer subcommunityId,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + parentCommunityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community parentCommunity=findCommunity(context,parentCommunityId,org.dspace.core.Constants.WRITE);
    org.dspace.content.Community subcommunity=null;
    for (    org.dspace.content.Community dspaceCommunity : parentCommunity.getSubcommunities()) {
      if (dspaceCommunity.getID() == subcommunityId) {
        subcommunity=dspaceCommunity;
        break;
      }
    }
    if (subcommunity == null) {
      context.abort();
      log.warn(""String_Node_Str"" + subcommunityId + ""String_Node_Str""+ ""String_Node_Str"");
      throw new WebApplicationException(Response.Status.NOT_FOUND);
    }
 else     if (!AuthorizeManager.authorizeActionBoolean(context,subcommunity,org.dspace.core.Constants.REMOVE)) {
      context.abort();
      if (context.getCurrentUser() != null) {
        log.error(""String_Node_Str"" + context.getCurrentUser().getEmail() + ""String_Node_Str"");
      }
 else {
        log.error(""String_Node_Str"");
      }
      throw new WebApplicationException(Response.Status.UNAUTHORIZED);
    }
    writeStats(parentCommunity,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request);
    writeStats(subcommunity,UsageEvent.Action.DELETE,user_ip,user_agent,xforwarderfor,headers,request);
    parentCommunity.removeSubcommunity(subcommunity);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + subcommunityId + ""String_Node_Str""+ parentCommunityId+ ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + subcommunityId + ""String_Node_Str""+ parentCommunityId+ ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + subcommunityId + ""String_Node_Str""+ parentCommunityId+ ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + subcommunityId + ""String_Node_Str""+ parentCommunityId+ ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + subcommunityId + ""String_Node_Str""+ parentCommunityId+ ""String_Node_Str"");
  return Response.status(Response.Status.OK).build();
}","/** 
 * Delete subcommunity in community.
 * @param parentCommunityId Id of community in DSpace.
 * @param subcommunityId Id of community which will be deleted.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response code OK(200) if was everything all right.Otherwise return NOT_FOUND(404) if was id of community or subcommunity incorrect. Or (UNAUTHORIZED)401 if was problem with permission to community or subcommunity.
 * @throws WebApplicationException It is throw when was problem with creating context or problem with database reading or deleting. Or problem with deleting subcommunity caused by IOException or authorization.
 */
@DELETE @Path(""String_Node_Str"") public Response deleteCommunityCommunity(@PathParam(""String_Node_Str"") Integer parentCommunityId,@PathParam(""String_Node_Str"") Integer subcommunityId,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + parentCommunityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community parentCommunity=findCommunity(context,parentCommunityId,org.dspace.core.Constants.WRITE);
    org.dspace.content.Community subcommunity=null;
    for (    org.dspace.content.Community dspaceCommunity : parentCommunity.getSubcommunities()) {
      if (dspaceCommunity.getID() == subcommunityId) {
        subcommunity=dspaceCommunity;
        break;
      }
    }
    if (subcommunity == null) {
      context.abort();
      log.warn(""String_Node_Str"" + subcommunityId + ""String_Node_Str""+ ""String_Node_Str"");
      throw new WebApplicationException(Response.Status.NOT_FOUND);
    }
 else     if (!AuthorizeManager.authorizeActionBoolean(context,subcommunity,org.dspace.core.Constants.REMOVE)) {
      context.abort();
      if (context.getCurrentUser() != null) {
        log.error(""String_Node_Str"" + context.getCurrentUser().getEmail() + ""String_Node_Str"");
      }
 else {
        log.error(""String_Node_Str"");
      }
      throw new WebApplicationException(Response.Status.UNAUTHORIZED);
    }
    writeStats(parentCommunity,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request,context);
    writeStats(subcommunity,UsageEvent.Action.DELETE,user_ip,user_agent,xforwarderfor,headers,request,context);
    parentCommunity.removeSubcommunity(subcommunity);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + subcommunityId + ""String_Node_Str""+ parentCommunityId+ ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + subcommunityId + ""String_Node_Str""+ parentCommunityId+ ""String_Node_Str""+ e,context);
  }
catch (  IOException e) {
    processException(""String_Node_Str"" + subcommunityId + ""String_Node_Str""+ parentCommunityId+ ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + subcommunityId + ""String_Node_Str""+ parentCommunityId+ ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + subcommunityId + ""String_Node_Str""+ parentCommunityId+ ""String_Node_Str"");
  return Response.status(Response.Status.OK).build();
}",0.9977565900168256
52060,"/** 
 * Create community at top level. Creating community at top level has permission only admin.
 * @param community Community which will be created at top level of communities.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Returns response with handle of community, if was all ok.
 * @throws WebApplicationException It can be thrown by SQLException, AuthorizeException and ContextException.
 */
@POST @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Community createCommunity(Community community,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"");
  org.dspace.core.Context context=null;
  Community retCommunity=null;
  try {
    context=createContext(getUser(headers));
    if (!AuthorizeManager.isAdmin(context)) {
      context.abort();
      String user=""String_Node_Str"";
      if (context.getCurrentUser() != null) {
        user=context.getCurrentUser().getEmail();
      }
      log.error(""String_Node_Str"" + user + ""String_Node_Str"");
      throw new WebApplicationException(Response.Status.UNAUTHORIZED);
    }
    org.dspace.content.Community dspaceCommunity=org.dspace.content.Community.create(null,context);
    writeStats(dspaceCommunity,UsageEvent.Action.CREATE,user_ip,user_agent,xforwarderfor,headers,request);
    dspaceCommunity.setMetadata(""String_Node_Str"",community.getName());
    dspaceCommunity.setMetadata(org.dspace.content.Community.COPYRIGHT_TEXT,community.getCopyrightText());
    dspaceCommunity.setMetadata(org.dspace.content.Community.INTRODUCTORY_TEXT,community.getIntroductoryText());
    dspaceCommunity.setMetadata(org.dspace.content.Community.SHORT_DESCRIPTION,community.getShortDescription());
    dspaceCommunity.setMetadata(org.dspace.content.Community.SIDEBAR_TEXT,community.getSidebarText());
    dspaceCommunity.update();
    retCommunity=new Community(dspaceCommunity,""String_Node_Str"",context);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + e.getMessage(),context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + retCommunity.getHandle());
  return retCommunity;
}","/** 
 * Create community at top level. Creating community at top level has permission only admin.
 * @param community Community which will be created at top level of communities.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Returns response with handle of community, if was all ok.
 * @throws WebApplicationException It can be thrown by SQLException, AuthorizeException and ContextException.
 */
@POST @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Community createCommunity(Community community,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"");
  org.dspace.core.Context context=null;
  Community retCommunity=null;
  try {
    context=createContext(getUser(headers));
    if (!AuthorizeManager.isAdmin(context)) {
      context.abort();
      String user=""String_Node_Str"";
      if (context.getCurrentUser() != null) {
        user=context.getCurrentUser().getEmail();
      }
      log.error(""String_Node_Str"" + user + ""String_Node_Str"");
      throw new WebApplicationException(Response.Status.UNAUTHORIZED);
    }
    org.dspace.content.Community dspaceCommunity=org.dspace.content.Community.create(null,context);
    writeStats(dspaceCommunity,UsageEvent.Action.CREATE,user_ip,user_agent,xforwarderfor,headers,request,context);
    dspaceCommunity.setMetadata(""String_Node_Str"",community.getName());
    dspaceCommunity.setMetadata(org.dspace.content.Community.COPYRIGHT_TEXT,community.getCopyrightText());
    dspaceCommunity.setMetadata(org.dspace.content.Community.INTRODUCTORY_TEXT,community.getIntroductoryText());
    dspaceCommunity.setMetadata(org.dspace.content.Community.SHORT_DESCRIPTION,community.getShortDescription());
    dspaceCommunity.setMetadata(org.dspace.content.Community.SIDEBAR_TEXT,community.getSidebarText());
    dspaceCommunity.update();
    retCommunity=new Community(dspaceCommunity,""String_Node_Str"",context);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + e.getMessage(),context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + retCommunity.getHandle());
  return retCommunity;
}",0.998505790063504
52061,"/** 
 * Create collection in community.
 * @param communityId Id of community in DSpace.
 * @param collection Collection which will be added into community.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response 200 if was everything all right. Otherwise 400when id of community was incorrect or 401 if was problem with permission to write into collection.
 * @throws WebApplicationException It is thrown when was problem with database reading or writing. Or problem with authorization to community. Or problem with creating context.
 */
@POST @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Collection addCommunityCollection(@PathParam(""String_Node_Str"") Integer communityId,Collection collection,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  Collection retCollection=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community dspaceCommunity=findCommunity(context,communityId,org.dspace.core.Constants.WRITE);
    writeStats(dspaceCommunity,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request);
    org.dspace.content.Collection dspaceCollection=dspaceCommunity.createCollection();
    dspaceCollection.setLicense(collection.getLicense());
    dspaceCollection.setMetadata(""String_Node_Str"",collection.getName());
    dspaceCollection.setMetadata(org.dspace.content.Collection.COPYRIGHT_TEXT,collection.getCopyrightText());
    dspaceCollection.setMetadata(org.dspace.content.Collection.INTRODUCTORY_TEXT,collection.getIntroductoryText());
    dspaceCollection.setMetadata(org.dspace.content.Collection.SHORT_DESCRIPTION,collection.getShortDescription());
    dspaceCollection.setMetadata(org.dspace.content.Collection.SIDEBAR_TEXT,collection.getSidebarText());
    dspaceCollection.setLicense(collection.getLicense());
    dspaceCollection.update();
    dspaceCommunity.update();
    retCollection=new Collection(dspaceCollection,""String_Node_Str"",context,100,0);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str""+ retCollection.getHandle());
  return retCollection;
}","/** 
 * Create collection in community.
 * @param communityId Id of community in DSpace.
 * @param collection Collection which will be added into community.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return response 200 if was everything all right. Otherwise 400when id of community was incorrect or 401 if was problem with permission to write into collection.
 * @throws WebApplicationException It is thrown when was problem with database reading or writing. Or problem with authorization to community. Or problem with creating context.
 */
@POST @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Collection addCommunityCollection(@PathParam(""String_Node_Str"") Integer communityId,Collection collection,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  Collection retCollection=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community dspaceCommunity=findCommunity(context,communityId,org.dspace.core.Constants.WRITE);
    writeStats(dspaceCommunity,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request,context);
    org.dspace.content.Collection dspaceCollection=dspaceCommunity.createCollection();
    dspaceCollection.setLicense(collection.getLicense());
    dspaceCollection.setMetadata(""String_Node_Str"",collection.getName());
    dspaceCollection.setMetadata(org.dspace.content.Collection.COPYRIGHT_TEXT,collection.getCopyrightText());
    dspaceCollection.setMetadata(org.dspace.content.Collection.INTRODUCTORY_TEXT,collection.getIntroductoryText());
    dspaceCollection.setMetadata(org.dspace.content.Collection.SHORT_DESCRIPTION,collection.getShortDescription());
    dspaceCollection.setMetadata(org.dspace.content.Collection.SIDEBAR_TEXT,collection.getSidebarText());
    dspaceCollection.setLicense(collection.getLicense());
    dspaceCollection.update();
    dspaceCommunity.update();
    retCollection=new Collection(dspaceCollection,""String_Node_Str"",context,100,0);
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str""+ retCollection.getHandle());
  return retCollection;
}",0.9986626546305584
52062,"/** 
 * Return all collections of community.
 * @param communityId Id of community in DSpace.
 * @param expand String in which is what you want to add to returned instance of collection. Options are: ""all"", ""parentCommunityList"", ""parentCommunity"", ""items"", ""license"" and ""logo"". If you want to use multiple options, it must be separated by commas.
 * @param limit Maximum collection in array. Default value is 100.
 * @param offset Index from which will start array of collections. Default value is 0.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return array of collections of community.
 * @throws WebApplicationException It can be caused by creating context or while was problem with reading community from database(SQLException).
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Collection[] getCommunityCollections(@PathParam(""String_Node_Str"") Integer communityId,@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  ArrayList<Collection> collections=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community dspaceCommunity=findCommunity(context,communityId,org.dspace.core.Constants.READ);
    writeStats(dspaceCommunity,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request);
    if (!((limit != null) && (limit >= 0) && (offset != null)&& (offset >= 0))) {
      log.warn(""String_Node_Str"");
      limit=100;
      offset=0;
    }
    collections=new ArrayList<Collection>();
    org.dspace.content.Collection[] dspaceCollections=dspaceCommunity.getCollections();
    for (int i=offset; (i < (offset + limit)) && (i < dspaceCollections.length); i++) {
      if (AuthorizeManager.authorizeActionBoolean(context,dspaceCollections[i],org.dspace.core.Constants.READ)) {
        collections.add(new Collection(dspaceCollections[i],expand,context,20,0));
        writeStats(dspaceCollections[i],UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request);
      }
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"" + communityId + ""String_Node_Str"");
  return collections.toArray(new Collection[0]);
}","/** 
 * Return all collections of community.
 * @param communityId Id of community in DSpace.
 * @param expand String in which is what you want to add to returned instance of collection. Options are: ""all"", ""parentCommunityList"", ""parentCommunity"", ""items"", ""license"" and ""logo"". If you want to use multiple options, it must be separated by commas.
 * @param limit Maximum collection in array. Default value is 100.
 * @param offset Index from which will start array of collections. Default value is 0.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return array of collections of community.
 * @throws WebApplicationException It can be caused by creating context or while was problem with reading community from database(SQLException).
 */
@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Collection[] getCommunityCollections(@PathParam(""String_Node_Str"") Integer communityId,@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  ArrayList<Collection> collections=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community dspaceCommunity=findCommunity(context,communityId,org.dspace.core.Constants.READ);
    writeStats(dspaceCommunity,UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request,context);
    if (!((limit != null) && (limit >= 0) && (offset != null)&& (offset >= 0))) {
      log.warn(""String_Node_Str"");
      limit=100;
      offset=0;
    }
    collections=new ArrayList<Collection>();
    org.dspace.content.Collection[] dspaceCollections=dspaceCommunity.getCollections();
    for (int i=offset; (i < (offset + limit)) && (i < dspaceCollections.length); i++) {
      if (AuthorizeManager.authorizeActionBoolean(context,dspaceCollections[i],org.dspace.core.Constants.READ)) {
        collections.add(new Collection(dspaceCollections[i],expand,context,20,0));
        writeStats(dspaceCollections[i],UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request,context);
      }
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"" + communityId + ""String_Node_Str"");
  return collections.toArray(new Collection[0]);
}",0.9974076474400518
52063,"/** 
 * Return all communities in DSpace.
 * @param expand String in which is what you want to add to returned instance of community. Options are: ""all"", ""parentCommunity"", ""collections"", ""subCommunities"" and ""logo"". If you want to use multiple options, it must be separated by commas.
 * @param limit Maximum communities in array. Default value is 100.
 * @param offset Index from which will start array of communities.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return array of communities.
 * @throws WebApplicationException It can be caused by creating context or while was problem with reading community from database(SQLException).
 */
@GET @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Community[] getCommunities(@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + offset + ""String_Node_Str""+ limit+ ""String_Node_Str"");
  org.dspace.core.Context context=null;
  ArrayList<Community> communities=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community[] dspaceCommunities=org.dspace.content.Community.findAll(context);
    communities=new ArrayList<Community>();
    if (!((limit != null) && (limit >= 0) && (offset != null)&& (offset >= 0))) {
      log.warn(""String_Node_Str"");
      limit=100;
      offset=0;
    }
    for (int i=offset; (i < (offset + limit)) && i < dspaceCommunities.length; i++) {
      if (AuthorizeManager.authorizeActionBoolean(context,dspaceCommunities[i],org.dspace.core.Constants.READ)) {
        Community community=new Community(dspaceCommunities[i],expand,context);
        writeStats(dspaceCommunities[i],UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request);
        communities.add(community);
      }
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"");
  return communities.toArray(new Community[0]);
}","/** 
 * Return all communities in DSpace.
 * @param expand String in which is what you want to add to returned instance of community. Options are: ""all"", ""parentCommunity"", ""collections"", ""subCommunities"" and ""logo"". If you want to use multiple options, it must be separated by commas.
 * @param limit Maximum communities in array. Default value is 100.
 * @param offset Index from which will start array of communities.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Return array of communities.
 * @throws WebApplicationException It can be caused by creating context or while was problem with reading community from database(SQLException).
 */
@GET @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Community[] getCommunities(@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + offset + ""String_Node_Str""+ limit+ ""String_Node_Str"");
  org.dspace.core.Context context=null;
  ArrayList<Community> communities=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community[] dspaceCommunities=org.dspace.content.Community.findAll(context);
    communities=new ArrayList<Community>();
    if (!((limit != null) && (limit >= 0) && (offset != null)&& (offset >= 0))) {
      log.warn(""String_Node_Str"");
      limit=100;
      offset=0;
    }
    for (int i=offset; (i < (offset + limit)) && i < dspaceCommunities.length; i++) {
      if (AuthorizeManager.authorizeActionBoolean(context,dspaceCommunities[i],org.dspace.core.Constants.READ)) {
        Community community=new Community(dspaceCommunities[i],expand,context);
        writeStats(dspaceCommunities[i],UsageEvent.Action.VIEW,user_ip,user_agent,xforwarderfor,headers,request,context);
        communities.add(community);
      }
    }
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + e.getMessage(),context);
  }
 finally {
    processFinally(context);
  }
  log.trace(""String_Node_Str"");
  return communities.toArray(new Community[0]);
}",0.9984859954579864
52064,"/** 
 * Update community. Replace all information about community except: id, handle and expandle items.
 * @param communityId Id of community in DSpace.
 * @param community Instance of community which will replace actual community in DSpace.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Response 200 if was all ok. Otherwise 400 if was id incorrect or401 if logged user has no permission to delete community.
 * @throws WebApplicationException It is throw when was problem with creating context or problem with database reading or writing. Or problem with writing to community caused by authorization.
 */
@PUT @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Response updateCommunity(@PathParam(""String_Node_Str"") Integer communityId,Community community,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community dspaceCommunity=findCommunity(context,communityId,org.dspace.core.Constants.WRITE);
    writeStats(dspaceCommunity,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request);
    dspaceCommunity.setMetadata(""String_Node_Str"",community.getName());
    dspaceCommunity.setMetadata(org.dspace.content.Community.COPYRIGHT_TEXT,community.getCopyrightText());
    dspaceCommunity.setMetadata(org.dspace.content.Community.INTRODUCTORY_TEXT,community.getIntroductoryText());
    dspaceCommunity.setMetadata(org.dspace.content.Community.SHORT_DESCRIPTION,community.getShortDescription());
    dspaceCommunity.setMetadata(org.dspace.content.Community.SIDEBAR_TEXT,community.getSidebarText());
    dspaceCommunity.update();
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  return Response.ok().build();
}","/** 
 * Update community. Replace all information about community except: id, handle and expandle items.
 * @param communityId Id of community in DSpace.
 * @param community Instance of community which will replace actual community in DSpace.
 * @param headers If you want to access to community under logged user into context. In headers must be set header ""rest-dspace-token"" with passed token from login method.
 * @return Response 200 if was all ok. Otherwise 400 if was id incorrect or401 if logged user has no permission to delete community.
 * @throws WebApplicationException It is throw when was problem with creating context or problem with database reading or writing. Or problem with writing to community caused by authorization.
 */
@PUT @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Response updateCommunity(@PathParam(""String_Node_Str"") Integer communityId,Community community,@QueryParam(""String_Node_Str"") String user_ip,@QueryParam(""String_Node_Str"") String user_agent,@QueryParam(""String_Node_Str"") String xforwarderfor,@Context HttpHeaders headers,@Context HttpServletRequest request) throws WebApplicationException {
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  org.dspace.core.Context context=null;
  try {
    context=createContext(getUser(headers));
    org.dspace.content.Community dspaceCommunity=findCommunity(context,communityId,org.dspace.core.Constants.WRITE);
    writeStats(dspaceCommunity,UsageEvent.Action.UPDATE,user_ip,user_agent,xforwarderfor,headers,request,context);
    dspaceCommunity.setMetadata(""String_Node_Str"",community.getName());
    dspaceCommunity.setMetadata(org.dspace.content.Community.COPYRIGHT_TEXT,community.getCopyrightText());
    dspaceCommunity.setMetadata(org.dspace.content.Community.INTRODUCTORY_TEXT,community.getIntroductoryText());
    dspaceCommunity.setMetadata(org.dspace.content.Community.SHORT_DESCRIPTION,community.getShortDescription());
    dspaceCommunity.setMetadata(org.dspace.content.Community.SIDEBAR_TEXT,community.getSidebarText());
    dspaceCommunity.update();
    context.complete();
  }
 catch (  SQLException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  ContextException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
catch (  AuthorizeException e) {
    processException(""String_Node_Str"" + communityId + ""String_Node_Str""+ e,context);
  }
 finally {
    processFinally(context);
  }
  log.info(""String_Node_Str"" + communityId + ""String_Node_Str"");
  return Response.ok().build();
}",0.9984877126654064
52065,"public DCValue[] queryMetadata(int itemId,String schema,String element,String qualifier,String lang) throws SQLException {
  List<DCValue> values=new ArrayList<DCValue>();
  TableRowIterator tri=null;
  try {
    if (qualifier == null) {
      Object[] params={Integer.valueOf(itemId),element,schema};
      tri=DatabaseManager.query(context,getByMetadataElement,params,Constants.ITEM);
    }
 else     if (Item.ANY.equals(qualifier)) {
      Object[] params={Integer.valueOf(itemId),element,schema};
      tri=DatabaseManager.query(context,getByMetadataAnyQualifier,params,Constants.ITEM);
    }
 else {
      Object[] params={Integer.valueOf(itemId),element,qualifier,schema,Constants.ITEM};
      tri=DatabaseManager.query(context,getByMetadata,params);
    }
    if (!tri.hasNext()) {
      return new DCValue[0];
    }
    while (tri.hasNext()) {
      TableRow tr=tri.next();
      DCValue dcv=new DCValue();
      dcv.schema=schema;
      dcv.element=tr.getStringColumn(""String_Node_Str"");
      dcv.qualifier=tr.getStringColumn(""String_Node_Str"");
      dcv.language=tr.getStringColumn(""String_Node_Str"");
      dcv.value=tr.getStringColumn(""String_Node_Str"");
      dcv.authority=tr.getStringColumn(""String_Node_Str"");
      dcv.confidence=tr.getIntColumn(""String_Node_Str"");
      values.add(dcv);
    }
  }
  finally {
    if (tri != null) {
      tri.close();
    }
  }
  DCValue[] dcvs=new DCValue[values.size()];
  return values.toArray(dcvs);
}","public DCValue[] queryMetadata(int itemId,String schema,String element,String qualifier,String lang) throws SQLException {
  List<DCValue> values=new ArrayList<DCValue>();
  TableRowIterator tri=null;
  try {
    if (qualifier == null) {
      Object[] params={Integer.valueOf(itemId),element,schema,Constants.ITEM};
      tri=DatabaseManager.query(context,getByMetadataElement,params);
    }
 else     if (Item.ANY.equals(qualifier)) {
      Object[] params={Integer.valueOf(itemId),element,schema,Constants.ITEM};
      tri=DatabaseManager.query(context,getByMetadataAnyQualifier,params);
    }
 else {
      Object[] params={Integer.valueOf(itemId),element,qualifier,schema,Constants.ITEM};
      tri=DatabaseManager.query(context,getByMetadata,params);
    }
    if (!tri.hasNext()) {
      return new DCValue[0];
    }
    while (tri.hasNext()) {
      TableRow tr=tri.next();
      DCValue dcv=new DCValue();
      dcv.schema=schema;
      dcv.element=tr.getStringColumn(""String_Node_Str"");
      dcv.qualifier=tr.getStringColumn(""String_Node_Str"");
      dcv.language=tr.getStringColumn(""String_Node_Str"");
      dcv.value=tr.getStringColumn(""String_Node_Str"");
      dcv.authority=tr.getStringColumn(""String_Node_Str"");
      dcv.confidence=tr.getIntColumn(""String_Node_Str"");
      values.add(dcv);
    }
  }
  finally {
    if (tri != null) {
      tri.close();
    }
  }
  DCValue[] dcvs=new DCValue[values.size()];
  return values.toArray(dcvs);
}",0.7416038382453736
52066,"private void addItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template) throws Exception {
  Map<String,String> skipItems=new HashMap<String,String>();
  System.out.println(""String_Node_Str"" + sourceDir);
  System.out.println(""String_Node_Str"" + mapFile);
  File outFile=null;
  if (!isTest) {
    if (isResume) {
      skipItems=readMapFile(mapFile);
    }
    outFile=new File(mapFile);
    mapOut=new PrintWriter(new FileWriter(outFile,isResume));
    if (mapOut == null) {
      throw new Exception(""String_Node_Str"" + mapFile);
    }
  }
  File d=new java.io.File(sourceDir);
  if (d == null || !d.isDirectory()) {
    throw new Exception(""String_Node_Str"" + sourceDir);
  }
  String[] dircontents=d.list(directoryFilter);
  Arrays.sort(dircontents);
  for (int i=0; i < dircontents.length; i++) {
    if (skipItems.containsKey(dircontents[i])) {
      System.out.println(""String_Node_Str"" + dircontents[i]);
    }
 else {
      if (mycollections == null) {
        String path=sourceDir + File.separatorChar + dircontents[i];
        try {
          Collection[] cols=processCollectionFile(c,path,""String_Node_Str"");
          if (cols == null) {
            System.out.println(""String_Node_Str"" + dircontents[i] + ""String_Node_Str"");
            continue;
          }
          mycollections=cols;
        }
 catch (        IllegalArgumentException e) {
          System.out.println(e.getMessage() + ""String_Node_Str"");
          continue;
        }
      }
      addItem(c,mycollections,sourceDir,dircontents[i],mapOut,template);
      System.out.println(i + ""String_Node_Str"" + dircontents[i]);
      c.clearCache();
    }
  }
}","private void addItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template) throws Exception {
  Map<String,String> skipItems=new HashMap<String,String>();
  System.out.println(""String_Node_Str"" + sourceDir);
  System.out.println(""String_Node_Str"" + mapFile);
  File outFile=null;
  boolean directoryFileCollections=false;
  if (mycollections == null) {
    directoryFileCollections=true;
  }
  if (!isTest) {
    if (isResume) {
      skipItems=readMapFile(mapFile);
    }
    outFile=new File(mapFile);
    mapOut=new PrintWriter(new FileWriter(outFile,isResume));
    if (mapOut == null) {
      throw new Exception(""String_Node_Str"" + mapFile);
    }
  }
  File d=new java.io.File(sourceDir);
  if (d == null || !d.isDirectory()) {
    throw new Exception(""String_Node_Str"" + sourceDir);
  }
  String[] dircontents=d.list(directoryFilter);
  Arrays.sort(dircontents);
  for (int i=0; i < dircontents.length; i++) {
    if (skipItems.containsKey(dircontents[i])) {
      System.out.println(""String_Node_Str"" + dircontents[i]);
    }
 else {
      Collection[] clist;
      if (directoryFileCollections) {
        String path=sourceDir + File.separatorChar + dircontents[i];
        try {
          Collection[] cols=processCollectionFile(c,path,""String_Node_Str"");
          if (cols == null) {
            System.out.println(""String_Node_Str"" + dircontents[i] + ""String_Node_Str"");
            continue;
          }
          clist=cols;
        }
 catch (        IllegalArgumentException e) {
          System.out.println(e.getMessage() + ""String_Node_Str"");
          continue;
        }
      }
 else {
        clist=mycollections;
      }
      addItem(c,clist,sourceDir,dircontents[i],mapOut,template);
      System.out.println(i + ""String_Node_Str"" + dircontents[i]);
      c.clearCache();
    }
  }
}",0.9255258669698692
52067,"public static void processResumableImport(String url,Collection owningCollection,Collection[] collections,String resumeDir,Context context) throws Exception {
  final EPerson eperson=context.getCurrentUser();
  final Collection[] otherCollections=collections;
  final Collection theOwningCollection=owningCollection;
  final String zipurl=url;
  final String resumePath=resumeDir;
  Thread go=new Thread(){
    public void run(){
      Context context=null;
      String importDir=null;
      try {
        context=new Context();
        context.setCurrentUser(eperson);
        context.setIgnoreAuthorization(true);
        InputStream is=new URL(zipurl).openStream();
        importDir=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ context.getCurrentUser().getID()+ File.separator+ resumePath;
        File importDirFile=new File(importDir);
        if (!importDirFile.exists()) {
          boolean success=importDirFile.mkdirs();
          if (!success) {
            log.info(""String_Node_Str"");
            throw new Exception(""String_Node_Str"");
          }
        }
        String dataZipPath=importDirFile + File.separator + ""String_Node_Str"";
        String dataZipDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
        (new File(dataZipPath)).delete();
        (new File(dataZipDir)).delete();
        OutputStream os=new FileOutputStream(dataZipPath);
        byte[] b=new byte[2048];
        int length;
        while ((length=is.read(b)) != -1) {
          os.write(b,0,length);
        }
        is.close();
        os.close();
        ZipFile zf=new ZipFile(dataZipPath);
        ZipEntry entry;
        Enumeration<? extends ZipEntry> entries=zf.entries();
        while (entries.hasMoreElements()) {
          entry=entries.nextElement();
          if (entry.isDirectory()) {
            if (!new File(dataZipDir + entry.getName()).mkdir()) {
              log.error(""String_Node_Str"");
            }
          }
 else {
            int index=entry.getName().lastIndexOf('/');
            if (index == -1) {
              index=entry.getName().lastIndexOf('\\');
            }
            if (index > 0) {
              File dir=new File(dataZipDir + entry.getName().substring(0,index));
              if (!dir.mkdirs()) {
                log.error(""String_Node_Str"");
              }
            }
            byte[] buffer=new byte[1024];
            int len;
            InputStream in=zf.getInputStream(entry);
            BufferedOutputStream out=new BufferedOutputStream(new FileOutputStream(dataZipDir + entry.getName()));
            while ((len=in.read(buffer)) >= 0) {
              out.write(buffer,0,len);
            }
            in.close();
            out.close();
          }
        }
        zf.close();
        String sourcePath=dataZipDir;
        String mapFilePath=importDirFile + File.separator + ""String_Node_Str"";
        ItemImport myloader=new ItemImport();
        myloader.isResume=true;
        Collection[] finalCollections=null;
        if (theOwningCollection != null) {
          finalCollections=new Collection[otherCollections.length + 1];
          finalCollections[0]=theOwningCollection;
          for (int i=0; i < otherCollections.length; i++) {
            finalCollections[i + 1]=otherCollections[i];
          }
        }
        myloader.addItems(context,finalCollections,sourcePath,mapFilePath,template);
        emailSuccessMessage(context,eperson,mapFilePath);
        context.complete();
      }
 catch (      Exception e) {
        e.printStackTrace();
        if (mapOut != null) {
          mapOut.close();
        }
        mapOut=null;
        if (importDir != null) {
        }
        try {
          emailErrorMessage(eperson,e.getMessage());
          throw new Exception(e.getMessage());
        }
 catch (        Exception e2) {
        }
      }
 finally {
        if (mapOut != null) {
          mapOut.close();
        }
        try {
          context.complete();
        }
 catch (        SQLException sqle) {
          context.abort();
        }
      }
    }
  }
;
  go.isDaemon();
  go.start();
}","public static void processResumableImport(String url,Collection owningCollection,String[] collections,String resumeDir,Context context) throws Exception {
  final EPerson eperson=context.getCurrentUser();
  final String[] otherCollections2=collections;
  final Collection theOwningCollection=owningCollection;
  final String zipurl=url;
  final String resumePath=resumeDir;
  Thread go=new Thread(){
    public void run(){
      Context context=null;
      String importDir=null;
      try {
        context=new Context();
        context.setCurrentUser(eperson);
        context.setIgnoreAuthorization(true);
        List<Collection> collectionList=new ArrayList<Collection>();
        if (otherCollections2 != null) {
          for (          String colID : otherCollections2) {
            int colId=Integer.parseInt(colID);
            if (colId != theOwningCollection.getID()) {
              Collection col=Collection.find(context,colId);
              if (col != null) {
                collectionList.add(col);
              }
            }
          }
        }
        Collection[] otherCollections=collectionList.toArray(new Collection[collectionList.size()]);
        InputStream is=new URL(zipurl).openStream();
        importDir=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ context.getCurrentUser().getID()+ File.separator+ resumePath;
        File importDirFile=new File(importDir);
        if (!importDirFile.exists()) {
          boolean success=importDirFile.mkdirs();
          if (!success) {
            log.info(""String_Node_Str"");
            throw new Exception(""String_Node_Str"");
          }
        }
        String dataZipPath=importDirFile + File.separator + ""String_Node_Str"";
        String dataZipDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
        (new File(dataZipPath)).delete();
        (new File(dataZipDir)).delete();
        OutputStream os=new FileOutputStream(dataZipPath);
        byte[] b=new byte[2048];
        int length;
        while ((length=is.read(b)) != -1) {
          os.write(b,0,length);
        }
        is.close();
        os.close();
        ZipFile zf=new ZipFile(dataZipPath);
        ZipEntry entry;
        Enumeration<? extends ZipEntry> entries=zf.entries();
        while (entries.hasMoreElements()) {
          entry=entries.nextElement();
          if (entry.isDirectory()) {
            if (!new File(dataZipDir + entry.getName()).mkdir()) {
              log.error(""String_Node_Str"");
            }
          }
 else {
            int index=entry.getName().lastIndexOf('/');
            if (index == -1) {
              index=entry.getName().lastIndexOf('\\');
            }
            if (index > 0) {
              File dir=new File(dataZipDir + entry.getName().substring(0,index));
              if (!dir.mkdirs()) {
                log.error(""String_Node_Str"");
              }
            }
            byte[] buffer=new byte[1024];
            int len;
            InputStream in=zf.getInputStream(entry);
            BufferedOutputStream out=new BufferedOutputStream(new FileOutputStream(dataZipDir + entry.getName()));
            while ((len=in.read(buffer)) >= 0) {
              out.write(buffer,0,len);
            }
            in.close();
            out.close();
          }
        }
        zf.close();
        String sourcePath=dataZipDir;
        String mapFilePath=importDirFile + File.separator + ""String_Node_Str"";
        ItemImport myloader=new ItemImport();
        myloader.isResume=true;
        Collection[] finalCollections=null;
        if (theOwningCollection != null) {
          finalCollections=new Collection[otherCollections.length + 1];
          finalCollections[0]=theOwningCollection;
          for (int i=0; i < otherCollections.length; i++) {
            finalCollections[i + 1]=otherCollections[i];
          }
        }
        myloader.addItems(context,finalCollections,sourcePath,mapFilePath,template);
        emailSuccessMessage(context,eperson,mapFilePath);
        context.complete();
      }
 catch (      Exception e) {
        e.printStackTrace();
        if (mapOut != null) {
          mapOut.close();
        }
        mapOut=null;
        if (importDir != null) {
        }
        try {
          emailErrorMessage(eperson,e.getMessage());
          throw new Exception(e.getMessage());
        }
 catch (        Exception e2) {
        }
      }
 finally {
        if (mapOut != null) {
          mapOut.close();
        }
        try {
          context.complete();
        }
 catch (        SQLException sqle) {
          context.abort();
        }
      }
    }
  }
;
  go.isDaemon();
  go.start();
}",0.9330783938814532
52068,"public void run(){
  Context context=null;
  String importDir=null;
  try {
    context=new Context();
    context.setCurrentUser(eperson);
    context.setIgnoreAuthorization(true);
    InputStream is=new URL(zipurl).openStream();
    importDir=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ context.getCurrentUser().getID()+ File.separator+ resumePath;
    File importDirFile=new File(importDir);
    if (!importDirFile.exists()) {
      boolean success=importDirFile.mkdirs();
      if (!success) {
        log.info(""String_Node_Str"");
        throw new Exception(""String_Node_Str"");
      }
    }
    String dataZipPath=importDirFile + File.separator + ""String_Node_Str"";
    String dataZipDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
    (new File(dataZipPath)).delete();
    (new File(dataZipDir)).delete();
    OutputStream os=new FileOutputStream(dataZipPath);
    byte[] b=new byte[2048];
    int length;
    while ((length=is.read(b)) != -1) {
      os.write(b,0,length);
    }
    is.close();
    os.close();
    ZipFile zf=new ZipFile(dataZipPath);
    ZipEntry entry;
    Enumeration<? extends ZipEntry> entries=zf.entries();
    while (entries.hasMoreElements()) {
      entry=entries.nextElement();
      if (entry.isDirectory()) {
        if (!new File(dataZipDir + entry.getName()).mkdir()) {
          log.error(""String_Node_Str"");
        }
      }
 else {
        int index=entry.getName().lastIndexOf('/');
        if (index == -1) {
          index=entry.getName().lastIndexOf('\\');
        }
        if (index > 0) {
          File dir=new File(dataZipDir + entry.getName().substring(0,index));
          if (!dir.mkdirs()) {
            log.error(""String_Node_Str"");
          }
        }
        byte[] buffer=new byte[1024];
        int len;
        InputStream in=zf.getInputStream(entry);
        BufferedOutputStream out=new BufferedOutputStream(new FileOutputStream(dataZipDir + entry.getName()));
        while ((len=in.read(buffer)) >= 0) {
          out.write(buffer,0,len);
        }
        in.close();
        out.close();
      }
    }
    zf.close();
    String sourcePath=dataZipDir;
    String mapFilePath=importDirFile + File.separator + ""String_Node_Str"";
    ItemImport myloader=new ItemImport();
    myloader.isResume=true;
    Collection[] finalCollections=null;
    if (theOwningCollection != null) {
      finalCollections=new Collection[otherCollections.length + 1];
      finalCollections[0]=theOwningCollection;
      for (int i=0; i < otherCollections.length; i++) {
        finalCollections[i + 1]=otherCollections[i];
      }
    }
    myloader.addItems(context,finalCollections,sourcePath,mapFilePath,template);
    emailSuccessMessage(context,eperson,mapFilePath);
    context.complete();
  }
 catch (  Exception e) {
    e.printStackTrace();
    if (mapOut != null) {
      mapOut.close();
    }
    mapOut=null;
    if (importDir != null) {
    }
    try {
      emailErrorMessage(eperson,e.getMessage());
      throw new Exception(e.getMessage());
    }
 catch (    Exception e2) {
    }
  }
 finally {
    if (mapOut != null) {
      mapOut.close();
    }
    try {
      context.complete();
    }
 catch (    SQLException sqle) {
      context.abort();
    }
  }
}","public void run(){
  Context context=null;
  String importDir=null;
  try {
    context=new Context();
    context.setCurrentUser(eperson);
    context.setIgnoreAuthorization(true);
    List<Collection> collectionList=new ArrayList<Collection>();
    if (otherCollections2 != null) {
      for (      String colID : otherCollections2) {
        int colId=Integer.parseInt(colID);
        if (colId != theOwningCollection.getID()) {
          Collection col=Collection.find(context,colId);
          if (col != null) {
            collectionList.add(col);
          }
        }
      }
    }
    Collection[] otherCollections=collectionList.toArray(new Collection[collectionList.size()]);
    InputStream is=new URL(zipurl).openStream();
    importDir=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ context.getCurrentUser().getID()+ File.separator+ resumePath;
    File importDirFile=new File(importDir);
    if (!importDirFile.exists()) {
      boolean success=importDirFile.mkdirs();
      if (!success) {
        log.info(""String_Node_Str"");
        throw new Exception(""String_Node_Str"");
      }
    }
    String dataZipPath=importDirFile + File.separator + ""String_Node_Str"";
    String dataZipDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
    (new File(dataZipPath)).delete();
    (new File(dataZipDir)).delete();
    OutputStream os=new FileOutputStream(dataZipPath);
    byte[] b=new byte[2048];
    int length;
    while ((length=is.read(b)) != -1) {
      os.write(b,0,length);
    }
    is.close();
    os.close();
    ZipFile zf=new ZipFile(dataZipPath);
    ZipEntry entry;
    Enumeration<? extends ZipEntry> entries=zf.entries();
    while (entries.hasMoreElements()) {
      entry=entries.nextElement();
      if (entry.isDirectory()) {
        if (!new File(dataZipDir + entry.getName()).mkdir()) {
          log.error(""String_Node_Str"");
        }
      }
 else {
        int index=entry.getName().lastIndexOf('/');
        if (index == -1) {
          index=entry.getName().lastIndexOf('\\');
        }
        if (index > 0) {
          File dir=new File(dataZipDir + entry.getName().substring(0,index));
          if (!dir.mkdirs()) {
            log.error(""String_Node_Str"");
          }
        }
        byte[] buffer=new byte[1024];
        int len;
        InputStream in=zf.getInputStream(entry);
        BufferedOutputStream out=new BufferedOutputStream(new FileOutputStream(dataZipDir + entry.getName()));
        while ((len=in.read(buffer)) >= 0) {
          out.write(buffer,0,len);
        }
        in.close();
        out.close();
      }
    }
    zf.close();
    String sourcePath=dataZipDir;
    String mapFilePath=importDirFile + File.separator + ""String_Node_Str"";
    ItemImport myloader=new ItemImport();
    myloader.isResume=true;
    Collection[] finalCollections=null;
    if (theOwningCollection != null) {
      finalCollections=new Collection[otherCollections.length + 1];
      finalCollections[0]=theOwningCollection;
      for (int i=0; i < otherCollections.length; i++) {
        finalCollections[i + 1]=otherCollections[i];
      }
    }
    myloader.addItems(context,finalCollections,sourcePath,mapFilePath,template);
    emailSuccessMessage(context,eperson,mapFilePath);
    context.complete();
  }
 catch (  Exception e) {
    e.printStackTrace();
    if (mapOut != null) {
      mapOut.close();
    }
    mapOut=null;
    if (importDir != null) {
    }
    try {
      emailErrorMessage(eperson,e.getMessage());
      throw new Exception(e.getMessage());
    }
 catch (    Exception e2) {
    }
  }
 finally {
    if (mapOut != null) {
      mapOut.close();
    }
    try {
      context.complete();
    }
 catch (    SQLException sqle) {
      context.abort();
    }
  }
}",0.9289924221161944
52069,"/** 
 * Given an uploaded file, this method calls the method to instantiate a BTE instance to transform the input data and batch import them to DSpace
 * @param file The input file to read data from
 * @param collections The collections the created items will be inserted to
 * @param bteInputType The input type of the data (bibtex, csv, etc.)
 * @param context The context
 * @throws Exception
 */
public static void processUploadableImport(String url,Collection owningCollection,Collection[] collections,Context context) throws Exception {
  final EPerson eperson=context.getCurrentUser();
  final Collection[] otherCollections=collections;
  final Collection theOwningCollection=owningCollection;
  final String zipurl=url;
  Thread go=new Thread(){
    public void run(){
      Context context=null;
      String importDir=null;
      try {
        context=new Context();
        context.setCurrentUser(eperson);
        context.setIgnoreAuthorization(true);
        InputStream is=new URL(zipurl).openStream();
        importDir=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ context.getCurrentUser().getID()+ File.separator+ (new GregorianCalendar()).getTimeInMillis();
        File importDirFile=new File(importDir);
        if (!importDirFile.exists()) {
          boolean success=importDirFile.mkdirs();
          if (!success) {
            log.info(""String_Node_Str"");
            throw new Exception(""String_Node_Str"");
          }
        }
        String dataZipPath=importDirFile + File.separator + ""String_Node_Str"";
        String dataZipDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
        OutputStream os=new FileOutputStream(dataZipPath);
        byte[] b=new byte[2048];
        int length;
        while ((length=is.read(b)) != -1) {
          os.write(b,0,length);
        }
        is.close();
        os.close();
        ZipFile zf=new ZipFile(dataZipPath);
        ZipEntry entry;
        Enumeration<? extends ZipEntry> entries=zf.entries();
        while (entries.hasMoreElements()) {
          entry=entries.nextElement();
          if (entry.isDirectory()) {
            if (!new File(dataZipDir + entry.getName()).mkdir()) {
              log.error(""String_Node_Str"");
            }
          }
 else {
            int index=entry.getName().lastIndexOf('/');
            if (index == -1) {
              index=entry.getName().lastIndexOf('\\');
            }
            if (index > 0) {
              File dir=new File(dataZipDir + entry.getName().substring(0,index));
              if (!dir.mkdirs()) {
                log.error(""String_Node_Str"");
              }
            }
            byte[] buffer=new byte[1024];
            int len;
            InputStream in=zf.getInputStream(entry);
            BufferedOutputStream out=new BufferedOutputStream(new FileOutputStream(dataZipDir + entry.getName()));
            while ((len=in.read(buffer)) >= 0) {
              out.write(buffer,0,len);
            }
            in.close();
            out.close();
          }
        }
        zf.close();
        String sourcePath=dataZipDir;
        String mapFilePath=importDirFile + File.separator + ""String_Node_Str"";
        ItemImport myloader=new ItemImport();
        Collection[] finalCollections=null;
        if (theOwningCollection != null) {
          finalCollections=new Collection[otherCollections.length + 1];
          finalCollections[0]=theOwningCollection;
          for (int i=0; i < otherCollections.length; i++) {
            finalCollections[i + 1]=otherCollections[i];
          }
        }
        myloader.addItems(context,finalCollections,sourcePath,mapFilePath,template);
        emailSuccessMessage(context,eperson,mapFilePath);
        context.complete();
      }
 catch (      Exception e) {
        e.printStackTrace();
        if (mapOut != null) {
          mapOut.close();
        }
        mapOut=null;
        if (importDir != null) {
        }
        try {
          emailErrorMessage(eperson,e.getMessage());
          throw new Exception(e.getMessage());
        }
 catch (        Exception e2) {
        }
      }
 finally {
        if (mapOut != null) {
          mapOut.close();
        }
        try {
          context.complete();
        }
 catch (        SQLException sqle) {
          context.abort();
        }
      }
    }
  }
;
  go.isDaemon();
  go.start();
}","/** 
 * Given an uploaded file, this method calls the method to instantiate a BTE instance to transform the input data and batch import them to DSpace
 * @param file The input file to read data from
 * @param collections The collections the created items will be inserted to
 * @param bteInputType The input type of the data (bibtex, csv, etc.)
 * @param context The context
 * @throws Exception
 */
public static void processUploadableImport(String url,Collection owningCollection,String[] collections,Context context2) throws Exception {
  final EPerson eperson=context2.getCurrentUser();
  final String[] otherCollections2=collections;
  final Collection theOwningCollection=owningCollection;
  final String zipurl=url;
  Thread go=new Thread(){
    public void run(){
      Context context=null;
      String importDir=null;
      try {
        context=new Context();
        context.setCurrentUser(eperson);
        context.setIgnoreAuthorization(true);
        List<Collection> collectionList=new ArrayList<Collection>();
        if (otherCollections2 != null) {
          for (          String colID : otherCollections2) {
            int colId=Integer.parseInt(colID);
            if (colId != theOwningCollection.getID()) {
              Collection col=Collection.find(context,colId);
              if (col != null) {
                collectionList.add(col);
              }
            }
          }
        }
        Collection[] otherCollections=collectionList.toArray(new Collection[collectionList.size()]);
        InputStream is=new URL(zipurl).openStream();
        importDir=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ context.getCurrentUser().getID()+ File.separator+ (new GregorianCalendar()).getTimeInMillis();
        File importDirFile=new File(importDir);
        if (!importDirFile.exists()) {
          boolean success=importDirFile.mkdirs();
          if (!success) {
            log.info(""String_Node_Str"");
            throw new Exception(""String_Node_Str"");
          }
        }
        String dataZipPath=importDirFile + File.separator + ""String_Node_Str"";
        String dataZipDir=importDirFile + File.separator + ""String_Node_Str""+ File.separator;
        OutputStream os=new FileOutputStream(dataZipPath);
        byte[] b=new byte[2048];
        int length;
        while ((length=is.read(b)) != -1) {
          os.write(b,0,length);
        }
        is.close();
        os.close();
        ZipFile zf=new ZipFile(dataZipPath);
        ZipEntry entry;
        Enumeration<? extends ZipEntry> entries=zf.entries();
        while (entries.hasMoreElements()) {
          entry=entries.nextElement();
          if (entry.isDirectory()) {
            if (!new File(dataZipDir + entry.getName()).mkdir()) {
              log.error(""String_Node_Str"");
            }
          }
 else {
            int index=entry.getName().lastIndexOf('/');
            if (index == -1) {
              index=entry.getName().lastIndexOf('\\');
            }
            if (index > 0) {
              File dir=new File(dataZipDir + entry.getName().substring(0,index));
              if (!dir.mkdirs()) {
                log.error(""String_Node_Str"");
              }
            }
            byte[] buffer=new byte[1024];
            int len;
            InputStream in=zf.getInputStream(entry);
            BufferedOutputStream out=new BufferedOutputStream(new FileOutputStream(dataZipDir + entry.getName()));
            while ((len=in.read(buffer)) >= 0) {
              out.write(buffer,0,len);
            }
            in.close();
            out.close();
          }
        }
        zf.close();
        String sourcePath=dataZipDir;
        String mapFilePath=importDirFile + File.separator + ""String_Node_Str"";
        ItemImport myloader=new ItemImport();
        myloader.isResume=false;
        Collection[] finalCollections=null;
        if (theOwningCollection != null) {
          finalCollections=new Collection[otherCollections.length + 1];
          finalCollections[0]=theOwningCollection;
          for (int i=0; i < otherCollections.length; i++) {
            finalCollections[i + 1]=otherCollections[i];
          }
        }
        myloader.addItems(context,finalCollections,sourcePath,mapFilePath,template);
        emailSuccessMessage(context,eperson,mapFilePath);
      }
 catch (      Exception e) {
        e.printStackTrace();
        if (mapOut != null) {
          mapOut.close();
        }
        mapOut=null;
        if (importDir != null) {
        }
        try {
          emailErrorMessage(eperson,e.getMessage());
          throw new Exception(e.getMessage());
        }
 catch (        Exception e2) {
        }
      }
 finally {
        if (mapOut != null) {
          mapOut.close();
        }
        try {
          context.complete();
        }
 catch (        SQLException sqle) {
          context.abort();
        }
      }
    }
  }
;
  go.isDaemon();
  go.start();
}",0.9302078913873568
52070,"/** 
 * Respond to a post request for metadata bulk importing via csv
 * @param context a DSpace Context object
 * @param request the HTTP request
 * @param response the HTTP response
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  int type=-1;
  String typeS=request.getParameter(""String_Node_Str"");
  if (typeS != null) {
    try {
      type=Integer.parseInt(typeS);
    }
 catch (    NumberFormatException e) {
      e.printStackTrace();
    }
  }
  List<Collection> collections=null;
  String colIdS=request.getParameter(""String_Node_Str"");
  if (colIdS != null) {
    collections=new ArrayList<Collection>();
    collections.add(Collection.find(context,Integer.parseInt(colIdS)));
  }
 else {
    collections=Arrays.asList(Collection.findAll(context));
  }
  request.setAttribute(""String_Node_Str"",collections);
  if (type != 0) {
    String contentType=request.getContentType();
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
      String message=null;
      try {
        FileUploadRequest wrapper=new FileUploadRequest(request);
        File f=wrapper.getFile(""String_Node_Str"");
        int colId=Integer.parseInt(wrapper.getParameter(""String_Node_Str""));
        Collection collection=Collection.find(context,colId);
        String inputType=wrapper.getParameter(""String_Node_Str"");
        try {
          ItemImport.processUploadableImport(f,new Collection[]{collection},inputType,context);
          request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        }
 catch (        Exception e) {
          request.setAttribute(""String_Node_Str"",""String_Node_Str"");
          message=e.getMessage();
          e.printStackTrace();
        }
      }
 catch (      FileSizeLimitExceededException e) {
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        message=e.getMessage();
        e.printStackTrace();
      }
catch (      Exception e) {
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        message=e.getMessage();
        e.printStackTrace();
      }
      BTEBatchImportService dls=new DSpace().getSingletonService(BTEBatchImportService.class);
      List<String> inputTypes=dls.getFileDataLoaders();
      request.setAttribute(""String_Node_Str"",inputTypes);
      request.setAttribute(""String_Node_Str"",message);
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else {
      request.setAttribute(""String_Node_Str"",""String_Node_Str"");
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    request.setAttribute(""String_Node_Str"",type);
    String message=null;
    String uploadId=request.getParameter(""String_Node_Str"");
    if (uploadId != null) {
      request.setAttribute(""String_Node_Str"",uploadId);
    }
    String zipurl=request.getParameter(""String_Node_Str"");
    if (StringUtils.isEmpty(zipurl)) {
      request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      Collection owningCollection=null;
      if (request.getParameter(""String_Node_Str"") != null) {
        int colId=Integer.parseInt(request.getParameter(""String_Node_Str""));
        if (colId > 0)         owningCollection=Collection.find(context,colId);
      }
      String[] reqCollections=request.getParameterValues(""String_Node_Str"");
      if (owningCollection == null && reqCollections.length > 0) {
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        Locale locale=request.getLocale();
        ResourceBundle msgs=ResourceBundle.getBundle(""String_Node_Str"",locale);
        String ms=msgs.getString(""String_Node_Str"");
        if (ms == null) {
          ms=""String_Node_Str"";
        }
        request.setAttribute(""String_Node_Str"",ms);
        JSPManager.showJSP(request,response,""String_Node_Str"");
        return;
      }
      List<Collection> collectionList=new ArrayList<Collection>();
      if (reqCollections != null) {
        for (        String colID : reqCollections) {
          int colId=Integer.parseInt(colID);
          if (colId != owningCollection.getID()) {
            Collection col=Collection.find(context,colId);
            if (col != null) {
              collectionList.add(col);
            }
          }
        }
      }
      Collection[] otherCollections=collectionList.toArray(new Collection[collectionList.size()]);
      try {
        if (uploadId != null) {
          ItemImport.processResumableImport(zipurl,owningCollection,otherCollections,uploadId,context);
        }
 else {
          ItemImport.processUploadableImport(zipurl,owningCollection,otherCollections,context);
        }
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
 catch (      Exception e) {
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        message=e.getMessage();
        e.printStackTrace();
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}","/** 
 * Respond to a post request for metadata bulk importing via csv
 * @param context a DSpace Context object
 * @param request the HTTP request
 * @param response the HTTP response
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  int type=-1;
  String typeS=request.getParameter(""String_Node_Str"");
  if (typeS != null) {
    try {
      type=Integer.parseInt(typeS);
    }
 catch (    NumberFormatException e) {
      e.printStackTrace();
    }
  }
  List<Collection> collections=null;
  String colIdS=request.getParameter(""String_Node_Str"");
  if (colIdS != null) {
    collections=new ArrayList<Collection>();
    collections.add(Collection.find(context,Integer.parseInt(colIdS)));
  }
 else {
    collections=Arrays.asList(Collection.findAll(context));
  }
  request.setAttribute(""String_Node_Str"",collections);
  if (type != 0) {
    String contentType=request.getContentType();
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
      String message=null;
      try {
        FileUploadRequest wrapper=new FileUploadRequest(request);
        File f=wrapper.getFile(""String_Node_Str"");
        int colId=Integer.parseInt(wrapper.getParameter(""String_Node_Str""));
        Collection collection=Collection.find(context,colId);
        String inputType=wrapper.getParameter(""String_Node_Str"");
        try {
          ItemImport.processUploadableImport(f,new Collection[]{collection},inputType,context);
          request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        }
 catch (        Exception e) {
          request.setAttribute(""String_Node_Str"",""String_Node_Str"");
          message=e.getMessage();
          e.printStackTrace();
        }
      }
 catch (      FileSizeLimitExceededException e) {
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        message=e.getMessage();
        e.printStackTrace();
      }
catch (      Exception e) {
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        message=e.getMessage();
        e.printStackTrace();
      }
      BTEBatchImportService dls=new DSpace().getSingletonService(BTEBatchImportService.class);
      List<String> inputTypes=dls.getFileDataLoaders();
      request.setAttribute(""String_Node_Str"",inputTypes);
      request.setAttribute(""String_Node_Str"",message);
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else {
      request.setAttribute(""String_Node_Str"",""String_Node_Str"");
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    request.setAttribute(""String_Node_Str"",type);
    String message=null;
    String uploadId=request.getParameter(""String_Node_Str"");
    if (uploadId != null) {
      request.setAttribute(""String_Node_Str"",uploadId);
    }
    String zipurl=request.getParameter(""String_Node_Str"");
    if (StringUtils.isEmpty(zipurl)) {
      request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      Collection owningCollection=null;
      if (request.getParameter(""String_Node_Str"") != null) {
        int colId=Integer.parseInt(request.getParameter(""String_Node_Str""));
        if (colId > 0)         owningCollection=Collection.find(context,colId);
      }
      String[] reqCollections=request.getParameterValues(""String_Node_Str"");
      if (owningCollection == null && reqCollections.length > 0) {
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        Locale locale=request.getLocale();
        ResourceBundle msgs=ResourceBundle.getBundle(""String_Node_Str"",locale);
        String ms=msgs.getString(""String_Node_Str"");
        if (ms == null) {
          ms=""String_Node_Str"";
        }
        request.setAttribute(""String_Node_Str"",ms);
        JSPManager.showJSP(request,response,""String_Node_Str"");
        return;
      }
      try {
        if (uploadId != null) {
          ItemImport.processResumableImport(zipurl,owningCollection,reqCollections,uploadId,context);
        }
 else {
          ItemImport.processUploadableImport(zipurl,owningCollection,reqCollections,context);
        }
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
 catch (      Exception e) {
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        message=e.getMessage();
        e.printStackTrace();
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}",0.945137409998986
52071,"/** 
 * Add authenticated users to the group defined in authentication-password.cfg by the login.specialgroup key.
 */
public int[] getSpecialGroups(Context context,HttpServletRequest request){
  try {
    if (!context.getCurrentUser().getMetadata(""String_Node_Str"").equals(""String_Node_Str"")) {
      String groupName=ConfigurationManager.getProperty(""String_Node_Str"",""String_Node_Str"");
      if ((groupName != null) && (!groupName.trim().equals(""String_Node_Str""))) {
        Group specialGroup=Group.findByName(context,groupName);
        if (specialGroup == null) {
          log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          return new int[0];
        }
 else {
          return new int[]{specialGroup.getID()};
        }
      }
    }
  }
 catch (  Exception e) {
  }
  return new int[0];
}","/** 
 * Add authenticated users to the group defined in authentication-password.cfg by the login.specialgroup key.
 */
public int[] getSpecialGroups(Context context,HttpServletRequest request){
  try {
    if (context.getCurrentUser().getPasswordHash() != null && !context.getCurrentUser().getPasswordHash().toString().equals(""String_Node_Str"")) {
      String groupName=ConfigurationManager.getProperty(""String_Node_Str"",""String_Node_Str"");
      if ((groupName != null) && (!groupName.trim().equals(""String_Node_Str""))) {
        Group specialGroup=Group.findByName(context,groupName);
        if (specialGroup == null) {
          log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          return new int[0];
        }
 else {
          return new int[]{specialGroup.getID()};
        }
      }
    }
  }
 catch (  Exception e) {
  }
  return new int[0];
}",0.9396051103368176
52072,"protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String netid=request.getParameter(""String_Node_Str"");
  String password=request.getParameter(""String_Node_Str"");
  String jsp=null;
  int status=AuthenticationManager.authenticate(context,netid,password,null,request);
  if (status == AuthenticationMethod.SUCCESS) {
    Authenticate.loggedIn(context,request,context.getCurrentUser());
    Locale epersonLocale=I18nUtil.getEPersonLocale(context.getCurrentUser());
    context.setCurrentLocale(epersonLocale);
    Config.set(request.getSession(),Config.FMT_LOCALE,epersonLocale);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    Authenticate.resumeInterruptedRequest(request,response);
    return;
  }
 else   if (status == AuthenticationMethod.CERT_REQUIRED) {
    jsp=""String_Node_Str"";
  }
 else {
    jsp=""String_Node_Str"";
  }
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + netid + ""String_Node_Str""+ String.valueOf(status)));
  JSPManager.showJSP(request,response,jsp);
}","protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String netid=request.getParameter(""String_Node_Str"");
  String password=request.getParameter(""String_Node_Str"");
  String jsp=null;
  int status=AuthenticationManager.authenticate(context,netid,password,null,request);
  if (status == AuthenticationMethod.SUCCESS) {
    try {
      context.commit();
    }
 catch (    SQLException ex) {
      log.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    }
    Authenticate.loggedIn(context,request,context.getCurrentUser());
    Locale epersonLocale=I18nUtil.getEPersonLocale(context.getCurrentUser());
    context.setCurrentLocale(epersonLocale);
    Config.set(request.getSession(),Config.FMT_LOCALE,epersonLocale);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    Authenticate.resumeInterruptedRequest(request,response);
    return;
  }
 else   if (status == AuthenticationMethod.CERT_REQUIRED) {
    jsp=""String_Node_Str"";
  }
 else {
    jsp=""String_Node_Str"";
  }
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + netid + ""String_Node_Str""+ String.valueOf(status)));
  JSPManager.showJSP(request,response,jsp);
}",0.9448051948051948
52073,"protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String email=request.getParameter(""String_Node_Str"");
  String password=request.getParameter(""String_Node_Str"");
  String jsp=null;
  int status=AuthenticationManager.authenticate(context,email,password,null,request);
  if (status == AuthenticationMethod.SUCCESS) {
    Authenticate.loggedIn(context,request,context.getCurrentUser());
    Locale epersonLocale=I18nUtil.getEPersonLocale(context.getCurrentUser());
    context.setCurrentLocale(epersonLocale);
    Config.set(request.getSession(),Config.FMT_LOCALE,epersonLocale);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    Authenticate.resumeInterruptedRequest(request,response);
    return;
  }
 else   if (status == AuthenticationMethod.CERT_REQUIRED) {
    jsp=""String_Node_Str"";
  }
 else {
    jsp=""String_Node_Str"";
  }
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + email + ""String_Node_Str""+ String.valueOf(status)));
  JSPManager.showJSP(request,response,jsp);
}","protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String email=request.getParameter(""String_Node_Str"");
  String password=request.getParameter(""String_Node_Str"");
  String jsp=null;
  int status=AuthenticationManager.authenticate(context,email,password,null,request);
  if (status == AuthenticationMethod.SUCCESS) {
    try {
      context.commit();
    }
 catch (    SQLException ex) {
      log.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    }
    Authenticate.loggedIn(context,request,context.getCurrentUser());
    Locale epersonLocale=I18nUtil.getEPersonLocale(context.getCurrentUser());
    context.setCurrentLocale(epersonLocale);
    Config.set(request.getSession(),Config.FMT_LOCALE,epersonLocale);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    Authenticate.resumeInterruptedRequest(request,response);
    return;
  }
 else   if (status == AuthenticationMethod.CERT_REQUIRED) {
    jsp=""String_Node_Str"";
  }
 else {
    jsp=""String_Node_Str"";
  }
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + email + ""String_Node_Str""+ String.valueOf(status)));
  JSPManager.showJSP(request,response,jsp);
}",0.9448051948051948
52074,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  java.util.Enumeration names=request.getHeaderNames();
  String name;
  while (names.hasMoreElements()) {
    name=names.nextElement().toString();
    log.info(""String_Node_Str"" + name + ""String_Node_Str""+ request.getHeader(name));
  }
  String jsp=null;
  int status=AuthenticationManager.authenticate(context,null,null,null,request);
  if (status == AuthenticationMethod.SUCCESS) {
    Authenticate.loggedIn(context,request,context.getCurrentUser());
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    Authenticate.resumeInterruptedRequest(request,response);
    return;
  }
 else   if (status == AuthenticationMethod.CERT_REQUIRED) {
    jsp=""String_Node_Str"";
  }
 else   if (status == AuthenticationMethod.NO_SUCH_USER) {
    jsp=""String_Node_Str"";
  }
 else   if (status == AuthenticationMethod.BAD_ARGS) {
    jsp=""String_Node_Str"";
  }
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + String.valueOf(status)));
  JSPManager.showJSP(request,response,jsp);
  return;
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  java.util.Enumeration names=request.getHeaderNames();
  String name;
  while (names.hasMoreElements()) {
    name=names.nextElement().toString();
    log.info(""String_Node_Str"" + name + ""String_Node_Str""+ request.getHeader(name));
  }
  String jsp=null;
  int status=AuthenticationManager.authenticate(context,null,null,null,request);
  if (status == AuthenticationMethod.SUCCESS) {
    try {
      context.commit();
    }
 catch (    SQLException ex) {
      log.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    }
    Authenticate.loggedIn(context,request,context.getCurrentUser());
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    Authenticate.resumeInterruptedRequest(request,response);
    return;
  }
 else   if (status == AuthenticationMethod.CERT_REQUIRED) {
    jsp=""String_Node_Str"";
  }
 else   if (status == AuthenticationMethod.NO_SUCH_USER) {
    jsp=""String_Node_Str"";
  }
 else   if (status == AuthenticationMethod.BAD_ARGS) {
    jsp=""String_Node_Str"";
  }
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + String.valueOf(status)));
  JSPManager.showJSP(request,response,jsp);
  return;
}",0.9466666666666668
52075,"/** 
 * Start the authentication process. This packages up the request that led to authentication being required, and then invokes the site-specific authentication method. If it returns true, the user was authenticated without any redirection (e.g. by an X.509 certificate or other implicit method) so the process that called this can continue and send its own response. A ""false"" result means this method has sent its own redirect.
 * @param context current DSpace context
 * @param request current HTTP request - the one that prompted authentication
 * @param response current HTTP response
 * @return true if authentication is already finished (implicit method)
 */
public static boolean startAuthentication(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  HttpSession session=request.getSession();
  if (AuthenticationManager.authenticateImplicit(context,null,null,null,request) == AuthenticationMethod.SUCCESS) {
    loggedIn(context,request,context.getCurrentUser());
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    if (context.getCurrentUser() != null) {
      Authenticate.resumeInterruptedRequest(request,response);
      return false;
    }
 else {
      return true;
    }
  }
 else {
    response.addDateHeader(""String_Node_Str"",1);
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    RequestInfo info=new RequestInfo(request);
    session.setAttribute(""String_Node_Str"",info);
    session.setAttribute(""String_Node_Str"",UIUtil.getOriginalURL(request));
    Iterator ai=AuthenticationManager.authenticationMethodIterator();
    AuthenticationMethod am;
    int count=0;
    String url=null;
    while (ai.hasNext()) {
      String s;
      am=(AuthenticationMethod)ai.next();
      s=am.loginPageURL(context,request,response);
      if (s != null) {
        url=s;
        ++count;
      }
    }
    if (count == 1) {
      response.sendRedirect(url);
    }
 else {
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
  return false;
}","/** 
 * Start the authentication process. This packages up the request that led to authentication being required, and then invokes the site-specific authentication method. If it returns true, the user was authenticated without any redirection (e.g. by an X.509 certificate or other implicit method) so the process that called this can continue and send its own response. A ""false"" result means this method has sent its own redirect.
 * @param context current DSpace context
 * @param request current HTTP request - the one that prompted authentication
 * @param response current HTTP response
 * @return true if authentication is already finished (implicit method)
 */
public static boolean startAuthentication(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  HttpSession session=request.getSession();
  if (AuthenticationManager.authenticateImplicit(context,null,null,null,request) == AuthenticationMethod.SUCCESS) {
    try {
      context.commit();
    }
 catch (    SQLException ex) {
      log.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    }
    loggedIn(context,request,context.getCurrentUser());
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    if (context.getCurrentUser() != null) {
      Authenticate.resumeInterruptedRequest(request,response);
      return false;
    }
 else {
      return true;
    }
  }
 else {
    response.addDateHeader(""String_Node_Str"",1);
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    RequestInfo info=new RequestInfo(request);
    session.setAttribute(""String_Node_Str"",info);
    session.setAttribute(""String_Node_Str"",UIUtil.getOriginalURL(request));
    Iterator ai=AuthenticationManager.authenticationMethodIterator();
    AuthenticationMethod am;
    int count=0;
    String url=null;
    while (ai.hasNext()) {
      String s;
      am=(AuthenticationMethod)ai.next();
      s=am.loginPageURL(context,request,response);
      if (s != null) {
        url=s;
        ++count;
      }
    }
    if (count == 1) {
      response.sendRedirect(url);
    }
 else {
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
  return false;
}",0.969244685662596
52076,"protected DiscoverResult retrieveResult(Context context,DiscoverQuery query,QueryResponse solrQueryResponse) throws SQLException {
  DiscoverResult result=new DiscoverResult();
  if (solrQueryResponse != null) {
    result.setSearchTime(solrQueryResponse.getQTime());
    result.setStart(query.getStart());
    result.setMaxResults(query.getMaxResults());
    result.setTotalSearchResults(solrQueryResponse.getResults().getNumFound());
    List<String> searchFields=query.getSearchFields();
    for (    SolrDocument doc : solrQueryResponse.getResults()) {
      DSpaceObject dso=findDSpaceObject(context,doc);
      if (dso != null) {
        result.addDSpaceObject(dso);
      }
 else {
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + doc.getFirstValue(""String_Node_Str"")));
        continue;
      }
      DiscoverResult.SearchDocument resultDoc=new DiscoverResult.SearchDocument();
      for (      String field : searchFields) {
        List<String> valuesAsString=new ArrayList<String>();
        for (        Object o : doc.getFieldValues(field)) {
          valuesAsString.add(String.valueOf(o));
        }
        resultDoc.addSearchField(field,valuesAsString.toArray(new String[valuesAsString.size()]));
      }
      result.addSearchDocument(dso,resultDoc);
      if (solrQueryResponse.getHighlighting() != null) {
        Map<String,List<String>> highlightedFields=solrQueryResponse.getHighlighting().get(dso.getType() + ""String_Node_Str"" + dso.getID());
        if (MapUtils.isNotEmpty(highlightedFields)) {
          Map<String,List<String>> resultMap=new HashMap<String,List<String>>();
          for (          String key : highlightedFields.keySet()) {
            resultMap.put(key.substring(0,key.lastIndexOf(""String_Node_Str"")),highlightedFields.get(key));
          }
          result.addHighlightedResult(dso,new DiscoverResult.DSpaceObjectHighlightResult(dso,resultMap));
        }
      }
    }
    List<FacetField> facetFields=solrQueryResponse.getFacetFields();
    if (facetFields != null) {
      for (int i=0; i < facetFields.size(); i++) {
        FacetField facetField=facetFields.get(i);
        DiscoverFacetField facetFieldConfig=query.getFacetFields().get(i);
        List<FacetField.Count> facetValues=facetField.getValues();
        if (facetValues != null) {
          if (facetFieldConfig.getType().equals(DiscoveryConfigurationParameters.TYPE_DATE) && facetFieldConfig.getSortOrder().equals(DiscoveryConfigurationParameters.SORT.VALUE)) {
            Collections.reverse(facetValues);
          }
          for (          FacetField.Count facetValue : facetValues) {
            String displayedValue=transformDisplayedValue(context,facetField.getName(),facetValue.getName());
            String field=transformFacetField(facetFieldConfig,facetField.getName(),true);
            String authorityValue=transformAuthorityValue(context,facetField.getName(),facetValue.getName());
            String sortValue=transformSortValue(context,facetField.getName(),facetValue.getName());
            String filterValue=displayedValue;
            if (StringUtils.isNotBlank(authorityValue)) {
              filterValue=authorityValue;
            }
            result.addFacetResult(field,new DiscoverResult.FacetResult(filterValue,displayedValue,authorityValue,sortValue,facetValue.getCount()));
          }
        }
      }
    }
    if (solrQueryResponse.getFacetQuery() != null) {
      LinkedHashMap<String,Integer> sortedFacetQueries=new LinkedHashMap<String,Integer>(solrQueryResponse.getFacetQuery());
      for (      String facetQuery : sortedFacetQueries.keySet()) {
        String facetField=facetQuery.substring(0,facetQuery.indexOf(""String_Node_Str""));
        String name=facetQuery.substring(facetQuery.indexOf('[') + 1);
        name=name.substring(0,name.lastIndexOf(']')).replaceAll(""String_Node_Str"",""String_Node_Str"");
        String filter=facetQuery.substring(facetQuery.indexOf('['));
        filter=filter.substring(0,filter.lastIndexOf(']') + 1);
        Integer count=sortedFacetQueries.get(facetQuery);
        if (0 < count) {
          result.addFacetResult(facetField,new DiscoverResult.FacetResult(filter,name,null,name,count));
        }
      }
    }
    if (solrQueryResponse.getSpellCheckResponse() != null) {
      String recommendedQuery=solrQueryResponse.getSpellCheckResponse().getCollatedResult();
      if (StringUtils.isNotBlank(recommendedQuery)) {
        result.setSpellCheckQuery(recommendedQuery);
      }
    }
  }
  return result;
}","protected DiscoverResult retrieveResult(Context context,DiscoverQuery query,QueryResponse solrQueryResponse) throws SQLException {
  DiscoverResult result=new DiscoverResult();
  if (solrQueryResponse != null) {
    result.setSearchTime(solrQueryResponse.getQTime());
    result.setStart(query.getStart());
    result.setMaxResults(query.getMaxResults());
    result.setTotalSearchResults(solrQueryResponse.getResults().getNumFound());
    List<String> searchFields=query.getSearchFields();
    for (    SolrDocument doc : solrQueryResponse.getResults()) {
      DSpaceObject dso=findDSpaceObject(context,doc);
      if (dso != null) {
        result.addDSpaceObject(dso);
      }
 else {
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + doc.getFirstValue(""String_Node_Str"")));
        continue;
      }
      DiscoverResult.SearchDocument resultDoc=new DiscoverResult.SearchDocument();
      for (      String field : searchFields) {
        List<String> valuesAsString=new ArrayList<String>();
        for (        Object o : doc.getFieldValues(field)) {
          valuesAsString.add(String.valueOf(o));
        }
        resultDoc.addSearchField(field,valuesAsString.toArray(new String[valuesAsString.size()]));
      }
      result.addSearchDocument(dso,resultDoc);
      if (solrQueryResponse.getHighlighting() != null) {
        Map<String,List<String>> highlightedFields=solrQueryResponse.getHighlighting().get(dso.getType() + ""String_Node_Str"" + dso.getID());
        if (MapUtils.isNotEmpty(highlightedFields)) {
          Map<String,List<String>> resultMap=new HashMap<String,List<String>>();
          for (          String key : highlightedFields.keySet()) {
            resultMap.put(key.substring(0,key.lastIndexOf(""String_Node_Str"")),highlightedFields.get(key));
          }
          result.addHighlightedResult(dso,new DiscoverResult.DSpaceObjectHighlightResult(dso,resultMap));
        }
      }
    }
    List<FacetField> facetFields=solrQueryResponse.getFacetFields();
    if (facetFields != null) {
      for (int i=0; i < facetFields.size(); i++) {
        FacetField facetField=facetFields.get(i);
        DiscoverFacetField facetFieldConfig=query.getFacetFields().get(i);
        List<FacetField.Count> facetValues=facetField.getValues();
        if (facetValues != null) {
          if (facetFieldConfig.getType().equals(DiscoveryConfigurationParameters.TYPE_DATE) && facetFieldConfig.getSortOrder().equals(DiscoveryConfigurationParameters.SORT.VALUE)) {
            Collections.reverse(facetValues);
          }
          for (          FacetField.Count facetValue : facetValues) {
            String displayedValue=transformDisplayedValue(context,facetField.getName(),facetValue.getName());
            String field=transformFacetField(facetFieldConfig,facetField.getName(),true);
            String authorityValue=transformAuthorityValue(context,facetField.getName(),facetValue.getName());
            String sortValue=transformSortValue(context,facetField.getName(),facetValue.getName());
            String filterValue=displayedValue;
            if (StringUtils.isNotBlank(authorityValue)) {
              filterValue=authorityValue;
            }
            result.addFacetResult(field,new DiscoverResult.FacetResult(filterValue,displayedValue,authorityValue,sortValue,facetValue.getCount()));
          }
        }
      }
    }
    if (solrQueryResponse.getFacetQuery() != null) {
      LinkedHashMap<String,Integer> sortedFacetQueries=new LinkedHashMap<String,Integer>(solrQueryResponse.getFacetQuery());
      for (      String facetQuery : sortedFacetQueries.keySet()) {
        String facetField=facetQuery.substring(0,facetQuery.indexOf(""String_Node_Str""));
        String name=""String_Node_Str"";
        String filter=""String_Node_Str"";
        if (facetQuery.indexOf('[') > -1 && facetQuery.lastIndexOf(']') > -1) {
          name=facetQuery.substring(facetQuery.indexOf('[') + 1);
          name=name.substring(0,name.lastIndexOf(']')).replaceAll(""String_Node_Str"",""String_Node_Str"");
          filter=facetQuery.substring(facetQuery.indexOf('['));
          filter=filter.substring(0,filter.lastIndexOf(']') + 1);
        }
        Integer count=sortedFacetQueries.get(facetQuery);
        if (0 < count) {
          result.addFacetResult(facetField,new DiscoverResult.FacetResult(filter,name,null,name,count));
        }
      }
    }
    if (solrQueryResponse.getSpellCheckResponse() != null) {
      String recommendedQuery=solrQueryResponse.getSpellCheckResponse().getCollatedResult();
      if (StringUtils.isNotBlank(recommendedQuery)) {
        result.setSpellCheckQuery(recommendedQuery);
      }
    }
  }
  return result;
}",0.96825739581084
52077,"/** 
 * Setup the basic query arguments: the main query and all the filters (default + user). Return the list of user filter
 * @param context
 * @param request
 * @param queryArgs the query object to populate
 * @return the list of user filer (as filter query)
 */
private static List<String> setupBasicQuery(Context context,DiscoveryConfiguration discoveryConfiguration,HttpServletRequest request,DiscoverQuery queryArgs){
  String query=request.getParameter(""String_Node_Str"");
  if (StringUtils.isNotBlank(query)) {
    queryArgs.setQuery(query);
  }
  List<String> defaultFilterQueries=discoveryConfiguration.getDefaultFilterQueries();
  if (defaultFilterQueries != null) {
    for (    String f : defaultFilterQueries) {
      queryArgs.addFacetQuery(f);
    }
  }
  List<String[]> filters=getFilters(request);
  List<String> userFilters=new ArrayList<String>();
  for (  String[] f : filters) {
    try {
      String newFilterQuery=SearchUtils.getSearchService().toFilterQuery(context,f[0],f[1],f[2]).getFilterQuery();
      if (newFilterQuery != null) {
        queryArgs.addFilterQueries(newFilterQuery);
        userFilters.add(newFilterQuery);
      }
    }
 catch (    SQLException e) {
      log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + f[0] + ""String_Node_Str""+ f[1]+ ""String_Node_Str""+ f[2]),e);
    }
  }
  return userFilters;
}","/** 
 * Setup the basic query arguments: the main query and all the filters (default + user). Return the list of user filter
 * @param context
 * @param request
 * @param queryArgs the query object to populate
 * @return the list of user filer (as filter query)
 */
private static List<String> setupBasicQuery(Context context,DiscoveryConfiguration discoveryConfiguration,HttpServletRequest request,DiscoverQuery queryArgs){
  String query=request.getParameter(""String_Node_Str"");
  if (StringUtils.isNotBlank(query)) {
    queryArgs.setQuery(query);
  }
  List<String> defaultFilterQueries=discoveryConfiguration.getDefaultFilterQueries();
  if (defaultFilterQueries != null) {
    for (    String f : defaultFilterQueries) {
      queryArgs.addFilterQueries(f);
    }
  }
  List<String[]> filters=getFilters(request);
  List<String> userFilters=new ArrayList<String>();
  for (  String[] f : filters) {
    try {
      String newFilterQuery=SearchUtils.getSearchService().toFilterQuery(context,f[0],f[1],f[2]).getFilterQuery();
      if (newFilterQuery != null) {
        queryArgs.addFilterQueries(newFilterQuery);
        userFilters.add(newFilterQuery);
      }
    }
 catch (    SQLException e) {
      log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + f[0] + ""String_Node_Str""+ f[1]+ ""String_Node_Str""+ f[2]),e);
    }
  }
  return userFilters;
}",0.9923830250272034
52078,"/** 
 * In this method, the BTE is instantiated. THe workflow generates the DSpace files necessary for the upload, and the default item import method is called
 * @param c The contect
 * @param mycollections The collections the items are inserted to
 * @param sourceDir The filepath to the file to read data from
 * @param mapFile The filepath to mapfile to be generated
 * @param template
 * @param inputType The type of the input data (bibtex, csv, etc.)
 * @param workingDir The path to create temporary files (for command line or UI based)
 * @throws Exception
 */
private void addBTEItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template,String inputType,String workingDir) throws Exception {
  String outputFolder=null;
  if (workingDir == null) {
    File importDir=new File(ConfigurationManager.getProperty(""String_Node_Str""));
    if (!importDir.exists()) {
      boolean success=importDir.mkdir();
      if (!success) {
        log.info(""String_Node_Str"");
        throw new Exception(""String_Node_Str"");
      }
    }
    outputFolder=importDir + File.separator + generateRandomFilename(true);
  }
 else {
    outputFolder=workingDir + File.separator + ""String_Node_Str"";
  }
  BTEBatchImportService dls=new DSpace().getSingletonService(BTEBatchImportService.class);
  DataLoader dataLoader=dls.getDataLoaders().get(inputType);
  Map<String,String> outputMap=dls.getOutputMap();
  TransformationEngine te=dls.getTransformationEngine();
  if (dataLoader == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  if (outputMap == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  if (dataLoader instanceof FileDataLoader) {
    FileDataLoader fdl=(FileDataLoader)dataLoader;
    if (!StringUtils.isBlank(sourceDir)) {
      System.out.println(""String_Node_Str"");
      fdl.setFilename(sourceDir);
    }
  }
 else   if (dataLoader instanceof OAIPMHDataLoader) {
    OAIPMHDataLoader fdl=(OAIPMHDataLoader)dataLoader;
    System.out.println(sourceDir);
    if (!StringUtils.isBlank(sourceDir)) {
      System.out.println(""String_Node_Str"");
      fdl.setServerAddress(sourceDir);
    }
  }
  if (dataLoader != null) {
    System.out.println(""String_Node_Str"" + dataLoader.toString() + ""String_Node_Str"");
    te.setDataLoader(dataLoader);
    DSpaceOutputGenerator outputGenerator=new DSpaceOutputGenerator(outputMap);
    outputGenerator.setOutputDirectory(outputFolder);
    te.setOutputGenerator(outputGenerator);
    try {
      TransformationResult res=te.transform(new TransformationSpec());
      List<String> output=res.getOutput();
      outputGenerator.writeOutput(output);
    }
 catch (    Exception e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
      throw e;
    }
    ItemImport myloader=new ItemImport();
    myloader.addItems(c,mycollections,outputFolder,mapFile,template);
    deleteDirectory(new File(outputFolder));
  }
}","/** 
 * In this method, the BTE is instantiated. THe workflow generates the DSpace files necessary for the upload, and the default item import method is called
 * @param c The contect
 * @param mycollections The collections the items are inserted to
 * @param sourceDir The filepath to the file to read data from
 * @param mapFile The filepath to mapfile to be generated
 * @param template
 * @param inputType The type of the input data (bibtex, csv, etc.)
 * @param workingDir The path to create temporary files (for command line or UI based)
 * @throws Exception
 */
private void addBTEItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template,String inputType,String workingDir) throws Exception {
  String outputFolder=null;
  if (workingDir == null) {
    File importDir=new File(ConfigurationManager.getProperty(""String_Node_Str""));
    if (!importDir.exists()) {
      boolean success=importDir.mkdir();
      if (!success) {
        log.info(""String_Node_Str"");
        throw new Exception(""String_Node_Str"");
      }
    }
    outputFolder=importDir + File.separator + generateRandomFilename(true);
  }
 else {
    outputFolder=workingDir + File.separator + ""String_Node_Str"";
  }
  BTEBatchImportService dls=new DSpace().getSingletonService(BTEBatchImportService.class);
  DataLoader dataLoader=dls.getDataLoaders().get(inputType);
  Map<String,String> outputMap=dls.getOutputMap();
  TransformationEngine te=dls.getTransformationEngine();
  if (dataLoader == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  if (outputMap == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  if (dataLoader instanceof FileDataLoader) {
    FileDataLoader fdl=(FileDataLoader)dataLoader;
    if (!StringUtils.isBlank(sourceDir)) {
      System.out.println(""String_Node_Str"");
      fdl.setFilename(sourceDir);
    }
  }
 else   if (dataLoader instanceof OAIPMHDataLoader) {
    OAIPMHDataLoader fdl=(OAIPMHDataLoader)dataLoader;
    System.out.println(sourceDir);
    if (!StringUtils.isBlank(sourceDir)) {
      System.out.println(""String_Node_Str"");
      fdl.setServerAddress(sourceDir);
    }
  }
  if (dataLoader != null) {
    System.out.println(""String_Node_Str"" + dataLoader.toString() + ""String_Node_Str"");
    te.setDataLoader(dataLoader);
    DSpaceOutputGenerator outputGenerator=new DSpaceOutputGenerator(outputMap);
    outputGenerator.setOutputDirectory(outputFolder);
    te.setOutputGenerator(outputGenerator);
    try {
      TransformationResult res=te.transform(new TransformationSpec());
      List<String> output=res.getOutput();
      outputGenerator.writeOutput(output);
    }
 catch (    Exception e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
    }
    ItemImport myloader=new ItemImport();
    myloader.addItems(c,mycollections,outputFolder,mapFile,template);
    deleteDirectory(new File(outputFolder));
  }
}",0.9440761516233216
52079,"private void replaceItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template) throws Exception {
  File d=new java.io.File(sourceDir);
  if (d == null || !d.isDirectory()) {
    System.out.println(""String_Node_Str"" + sourceDir);
    System.exit(1);
  }
  Map<String,String> myHash=readMapFile(mapFile);
  for (  Map.Entry<String,String> mapEntry : myHash.entrySet()) {
    String newItemName=mapEntry.getKey();
    String oldHandle=mapEntry.getValue();
    Item oldItem=null;
    if (oldHandle.indexOf('/') != -1) {
      System.out.println(""String_Node_Str"" + oldHandle);
      oldItem=(Item)HandleManager.resolveToObject(c,oldHandle);
    }
 else {
      oldItem=Item.find(c,Integer.parseInt(oldHandle));
    }
    File handleFile=new File(sourceDir + File.separatorChar + newItemName+ File.separatorChar+ ""String_Node_Str"");
    PrintWriter handleOut=new PrintWriter(new FileWriter(handleFile,true));
    if (handleOut == null) {
      throw new Exception(""String_Node_Str"" + handleFile.getCanonicalPath());
    }
    handleOut.println(oldHandle);
    handleOut.close();
    deleteItem(c,oldItem);
    addItem(c,mycollections,sourceDir,newItemName,null,template);
    c.clearCache();
  }
}","private void replaceItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template) throws Exception {
  File d=new java.io.File(sourceDir);
  if (d == null || !d.isDirectory()) {
    throw new Exception(""String_Node_Str"" + sourceDir);
  }
  Map<String,String> myHash=readMapFile(mapFile);
  for (  Map.Entry<String,String> mapEntry : myHash.entrySet()) {
    String newItemName=mapEntry.getKey();
    String oldHandle=mapEntry.getValue();
    Item oldItem=null;
    if (oldHandle.indexOf('/') != -1) {
      System.out.println(""String_Node_Str"" + oldHandle);
      oldItem=(Item)HandleManager.resolveToObject(c,oldHandle);
    }
 else {
      oldItem=Item.find(c,Integer.parseInt(oldHandle));
    }
    File handleFile=new File(sourceDir + File.separatorChar + newItemName+ File.separatorChar+ ""String_Node_Str"");
    PrintWriter handleOut=new PrintWriter(new FileWriter(handleFile,true));
    if (handleOut == null) {
      throw new Exception(""String_Node_Str"" + handleFile.getCanonicalPath());
    }
    handleOut.println(oldHandle);
    handleOut.close();
    deleteItem(c,oldItem);
    addItem(c,mycollections,sourceDir,newItemName,null,template);
    c.clearCache();
  }
}",0.9774127310061602
52080,"private void addItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template) throws Exception {
  Map<String,String> skipItems=new HashMap<String,String>();
  System.out.println(""String_Node_Str"" + sourceDir);
  System.out.println(""String_Node_Str"" + mapFile);
  File outFile=null;
  if (!isTest) {
    if (isResume) {
      skipItems=readMapFile(mapFile);
    }
    outFile=new File(mapFile);
    mapOut=new PrintWriter(new FileWriter(outFile,isResume));
    if (mapOut == null) {
      throw new Exception(""String_Node_Str"" + mapFile);
    }
  }
  File d=new java.io.File(sourceDir);
  if (d == null || !d.isDirectory()) {
    System.out.println(""String_Node_Str"" + sourceDir);
    System.exit(1);
  }
  String[] dircontents=d.list(directoryFilter);
  Arrays.sort(dircontents);
  for (int i=0; i < dircontents.length; i++) {
    if (skipItems.containsKey(dircontents[i])) {
      System.out.println(""String_Node_Str"" + dircontents[i]);
    }
 else {
      addItem(c,mycollections,sourceDir,dircontents[i],mapOut,template);
      System.out.println(i + ""String_Node_Str"" + dircontents[i]);
      c.clearCache();
    }
  }
}","private void addItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template) throws Exception {
  Map<String,String> skipItems=new HashMap<String,String>();
  System.out.println(""String_Node_Str"" + sourceDir);
  System.out.println(""String_Node_Str"" + mapFile);
  File outFile=null;
  if (!isTest) {
    if (isResume) {
      skipItems=readMapFile(mapFile);
    }
    outFile=new File(mapFile);
    mapOut=new PrintWriter(new FileWriter(outFile,isResume));
    if (mapOut == null) {
      throw new Exception(""String_Node_Str"" + mapFile);
    }
  }
  File d=new java.io.File(sourceDir);
  if (d == null || !d.isDirectory()) {
    throw new Exception(""String_Node_Str"" + sourceDir);
  }
  String[] dircontents=d.list(directoryFilter);
  Arrays.sort(dircontents);
  for (int i=0; i < dircontents.length; i++) {
    if (skipItems.containsKey(dircontents[i])) {
      System.out.println(""String_Node_Str"" + dircontents[i]);
    }
 else {
      addItem(c,mycollections,sourceDir,dircontents[i],mapOut,template);
      System.out.println(i + ""String_Node_Str"" + dircontents[i]);
      c.clearCache();
    }
  }
}",0.9760139555167904
52081,"/** 
 * In this method, the BTE is instantiated. THe workflow generates the DSpace files necessary for the upload, and the default item import method is called
 * @param c The contect
 * @param mycollections The collections the items are inserted to
 * @param sourceDir The filepath to the file to read data from
 * @param mapFile The filepath to mapfile to be generated
 * @param template
 * @param inputType The type of the input data (bibtex, csv, etc.)
 * @param workingDir The path to create temporary files (for command line or UI based)
 * @throws Exception
 */
private void addBTEItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template,String inputType,String workingDir) throws Exception {
  String outputFolder=null;
  if (workingDir == null) {
    File importDir=new File(ConfigurationManager.getProperty(""String_Node_Str""));
    if (!importDir.exists()) {
      boolean success=importDir.mkdir();
      if (!success) {
        log.info(""String_Node_Str"");
        throw new Exception(""String_Node_Str"");
      }
    }
    outputFolder=importDir + File.separator + generateRandomFilename(true);
  }
 else {
    outputFolder=workingDir + File.separator + ""String_Node_Str"";
  }
  BTEBatchImportService dls=new DSpace().getSingletonService(BTEBatchImportService.class);
  DataLoader dataLoader=dls.getDataLoaders().get(inputType);
  Map<String,String> outputMap=dls.getOutputMap();
  TransformationEngine te=dls.getTransformationEngine();
  if (dataLoader == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  if (outputMap == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  if (dataLoader instanceof FileDataLoader) {
    FileDataLoader fdl=(FileDataLoader)dataLoader;
    if (!StringUtils.isBlank(sourceDir)) {
      System.out.println(""String_Node_Str"");
      fdl.setFilename(sourceDir);
    }
  }
 else   if (dataLoader instanceof OAIPMHDataLoader) {
    OAIPMHDataLoader fdl=(OAIPMHDataLoader)dataLoader;
    System.out.println(sourceDir);
    if (!StringUtils.isBlank(sourceDir)) {
      System.out.println(""String_Node_Str"");
      fdl.setServerAddress(sourceDir);
    }
  }
  if (dataLoader != null) {
    System.out.println(""String_Node_Str"" + dataLoader.toString() + ""String_Node_Str"");
    te.setDataLoader(dataLoader);
    DSpaceOutputGenerator outputGenerator=new DSpaceOutputGenerator(outputMap);
    outputGenerator.setOutputDirectory(outputFolder);
    te.setOutputGenerator(outputGenerator);
    try {
      TransformationResult res=te.transform(new TransformationSpec());
      List<String> output=res.getOutput();
      outputGenerator.writeOutput(output);
    }
 catch (    Exception e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
      throw e;
    }
    ItemImport myloader=new ItemImport();
    myloader.addItems(c,mycollections,outputFolder,mapFile,template);
    deleteDirectory(new File(outputFolder));
  }
}","/** 
 * In this method, the BTE is instantiated. THe workflow generates the DSpace files necessary for the upload, and the default item import method is called
 * @param c The contect
 * @param mycollections The collections the items are inserted to
 * @param sourceDir The filepath to the file to read data from
 * @param mapFile The filepath to mapfile to be generated
 * @param template
 * @param inputType The type of the input data (bibtex, csv, etc.)
 * @param workingDir The path to create temporary files (for command line or UI based)
 * @throws Exception
 */
private void addBTEItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template,String inputType,String workingDir) throws Exception {
  String outputFolder=null;
  if (workingDir == null) {
    File importDir=new File(ConfigurationManager.getProperty(""String_Node_Str""));
    if (!importDir.exists()) {
      boolean success=importDir.mkdir();
      if (!success) {
        log.info(""String_Node_Str"");
        throw new Exception(""String_Node_Str"");
      }
    }
    outputFolder=importDir + File.separator + generateRandomFilename(true);
  }
 else {
    outputFolder=workingDir + File.separator + ""String_Node_Str"";
  }
  BTEBatchImportService dls=new DSpace().getSingletonService(BTEBatchImportService.class);
  DataLoader dataLoader=dls.getDataLoaders().get(inputType);
  Map<String,String> outputMap=dls.getOutputMap();
  TransformationEngine te=dls.getTransformationEngine();
  if (dataLoader == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  if (outputMap == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  if (dataLoader instanceof FileDataLoader) {
    FileDataLoader fdl=(FileDataLoader)dataLoader;
    if (!StringUtils.isBlank(sourceDir)) {
      System.out.println(""String_Node_Str"");
      fdl.setFilename(sourceDir);
    }
  }
 else   if (dataLoader instanceof OAIPMHDataLoader) {
    OAIPMHDataLoader fdl=(OAIPMHDataLoader)dataLoader;
    System.out.println(sourceDir);
    if (!StringUtils.isBlank(sourceDir)) {
      System.out.println(""String_Node_Str"");
      fdl.setServerAddress(sourceDir);
    }
  }
  if (dataLoader != null) {
    System.out.println(""String_Node_Str"" + dataLoader.toString() + ""String_Node_Str"");
    te.setDataLoader(dataLoader);
    DSpaceOutputGenerator outputGenerator=new DSpaceOutputGenerator(outputMap);
    outputGenerator.setOutputDirectory(outputFolder);
    te.setOutputGenerator(outputGenerator);
    try {
      TransformationResult res=te.transform(new TransformationSpec());
      List<String> output=res.getOutput();
      outputGenerator.writeOutput(output);
    }
 catch (    Exception e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
    }
    ItemImport myloader=new ItemImport();
    myloader.addItems(c,mycollections,outputFolder,mapFile,template);
    deleteDirectory(new File(outputFolder));
  }
}",0.9440761516233216
52082,"private void replaceItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template) throws Exception {
  File d=new java.io.File(sourceDir);
  if (d == null || !d.isDirectory()) {
    System.out.println(""String_Node_Str"" + sourceDir);
    System.exit(1);
  }
  Map<String,String> myHash=readMapFile(mapFile);
  for (  Map.Entry<String,String> mapEntry : myHash.entrySet()) {
    String newItemName=mapEntry.getKey();
    String oldHandle=mapEntry.getValue();
    Item oldItem=null;
    if (oldHandle.indexOf('/') != -1) {
      System.out.println(""String_Node_Str"" + oldHandle);
      oldItem=(Item)HandleManager.resolveToObject(c,oldHandle);
    }
 else {
      oldItem=Item.find(c,Integer.parseInt(oldHandle));
    }
    File handleFile=new File(sourceDir + File.separatorChar + newItemName+ File.separatorChar+ ""String_Node_Str"");
    PrintWriter handleOut=new PrintWriter(new FileWriter(handleFile,true));
    if (handleOut == null) {
      throw new Exception(""String_Node_Str"" + handleFile.getCanonicalPath());
    }
    handleOut.println(oldHandle);
    handleOut.close();
    deleteItem(c,oldItem);
    addItem(c,mycollections,sourceDir,newItemName,null,template);
    c.clearCache();
  }
}","private void replaceItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template) throws Exception {
  File d=new java.io.File(sourceDir);
  if (d == null || !d.isDirectory()) {
    throw new Exception(""String_Node_Str"" + sourceDir);
  }
  Map<String,String> myHash=readMapFile(mapFile);
  for (  Map.Entry<String,String> mapEntry : myHash.entrySet()) {
    String newItemName=mapEntry.getKey();
    String oldHandle=mapEntry.getValue();
    Item oldItem=null;
    if (oldHandle.indexOf('/') != -1) {
      System.out.println(""String_Node_Str"" + oldHandle);
      oldItem=(Item)HandleManager.resolveToObject(c,oldHandle);
    }
 else {
      oldItem=Item.find(c,Integer.parseInt(oldHandle));
    }
    File handleFile=new File(sourceDir + File.separatorChar + newItemName+ File.separatorChar+ ""String_Node_Str"");
    PrintWriter handleOut=new PrintWriter(new FileWriter(handleFile,true));
    if (handleOut == null) {
      throw new Exception(""String_Node_Str"" + handleFile.getCanonicalPath());
    }
    handleOut.println(oldHandle);
    handleOut.close();
    deleteItem(c,oldItem);
    addItem(c,mycollections,sourceDir,newItemName,null,template);
    c.clearCache();
  }
}",0.9774127310061602
52083,"private void addItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template) throws Exception {
  Map<String,String> skipItems=new HashMap<String,String>();
  System.out.println(""String_Node_Str"" + sourceDir);
  System.out.println(""String_Node_Str"" + mapFile);
  File outFile=null;
  if (!isTest) {
    if (isResume) {
      skipItems=readMapFile(mapFile);
    }
    outFile=new File(mapFile);
    mapOut=new PrintWriter(new FileWriter(outFile,isResume));
    if (mapOut == null) {
      throw new Exception(""String_Node_Str"" + mapFile);
    }
  }
  File d=new java.io.File(sourceDir);
  if (d == null || !d.isDirectory()) {
    System.out.println(""String_Node_Str"" + sourceDir);
    System.exit(1);
  }
  String[] dircontents=d.list(directoryFilter);
  Arrays.sort(dircontents);
  for (int i=0; i < dircontents.length; i++) {
    if (skipItems.containsKey(dircontents[i])) {
      System.out.println(""String_Node_Str"" + dircontents[i]);
    }
 else {
      addItem(c,mycollections,sourceDir,dircontents[i],mapOut,template);
      System.out.println(i + ""String_Node_Str"" + dircontents[i]);
      c.clearCache();
    }
  }
}","private void addItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template) throws Exception {
  Map<String,String> skipItems=new HashMap<String,String>();
  System.out.println(""String_Node_Str"" + sourceDir);
  System.out.println(""String_Node_Str"" + mapFile);
  File outFile=null;
  if (!isTest) {
    if (isResume) {
      skipItems=readMapFile(mapFile);
    }
    outFile=new File(mapFile);
    mapOut=new PrintWriter(new FileWriter(outFile,isResume));
    if (mapOut == null) {
      throw new Exception(""String_Node_Str"" + mapFile);
    }
  }
  File d=new java.io.File(sourceDir);
  if (d == null || !d.isDirectory()) {
    throw new Exception(""String_Node_Str"" + sourceDir);
  }
  String[] dircontents=d.list(directoryFilter);
  Arrays.sort(dircontents);
  for (int i=0; i < dircontents.length; i++) {
    if (skipItems.containsKey(dircontents[i])) {
      System.out.println(""String_Node_Str"" + dircontents[i]);
    }
 else {
      addItem(c,mycollections,sourceDir,dircontents[i],mapOut,template);
      System.out.println(i + ""String_Node_Str"" + dircontents[i]);
      c.clearCache();
    }
  }
}",0.9760139555167904
52084,"public static Record convertCrossRefDomToRecord(Element pubArticle){
  MutableRecord record=new SubmissionLookupPublication(""String_Node_Str"");
  Map<String,String> mounthToNum=new HashMap<String,String>();
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  Element medline=XMLUtils.getSingleElement(pubArticle,""String_Node_Str"");
  Element article=XMLUtils.getSingleElement(medline,""String_Node_Str"");
  Element pubmed=XMLUtils.getSingleElement(pubArticle,""String_Node_Str"");
  Element identifierList=XMLUtils.getSingleElement(pubmed,""String_Node_Str"");
  if (identifierList != null) {
    List<Element> identifiers=XMLUtils.getElementList(identifierList,""String_Node_Str"");
    if (identifiers != null) {
      for (      Element id : identifiers) {
        if (""String_Node_Str"".equals(id.getAttribute(""String_Node_Str""))) {
          String pubmedID=id.getTextContent().trim();
          if (pubmedID != null)           record.addValue(""String_Node_Str"",new StringValue(pubmedID));
        }
 else         if (""String_Node_Str"".equals(id.getAttribute(""String_Node_Str""))) {
          String doi=id.getTextContent().trim();
          if (doi != null)           record.addValue(""String_Node_Str"",new StringValue(doi));
        }
      }
    }
  }
  String status=XMLUtils.getElementValue(pubmed,""String_Node_Str"");
  if (status != null)   record.addValue(""String_Node_Str"",new StringValue(status));
  String pubblicationModel=XMLUtils.getElementAttribute(medline,""String_Node_Str"",""String_Node_Str"");
  if (pubblicationModel != null)   record.addValue(""String_Node_Str"",new StringValue(pubblicationModel));
  String title=XMLUtils.getElementValue(article,""String_Node_Str"");
  if (title != null)   record.addValue(""String_Node_Str"",new StringValue(title));
  Element abstractElement=XMLUtils.getSingleElement(medline,""String_Node_Str"");
  if (abstractElement == null) {
    abstractElement=XMLUtils.getSingleElement(medline,""String_Node_Str"");
  }
  if (abstractElement != null) {
    String summary=XMLUtils.getElementValue(abstractElement,""String_Node_Str"");
    if (summary != null)     record.addValue(""String_Node_Str"",new StringValue(summary));
  }
  List<String[]> authors=new LinkedList<String[]>();
  Element authorList=XMLUtils.getSingleElement(article,""String_Node_Str"");
  if (authorList != null) {
    List<Element> authorsElement=XMLUtils.getElementList(authorList,""String_Node_Str"");
    if (authorsElement != null) {
      for (      Element author : authorsElement) {
        if (StringUtils.isBlank(XMLUtils.getElementValue(author,""String_Node_Str""))) {
          authors.add(new String[]{XMLUtils.getElementValue(author,""String_Node_Str""),XMLUtils.getElementValue(author,""String_Node_Str"")});
        }
      }
    }
  }
  if (authors.size() > 0) {
    List<Value> values=new LinkedList<Value>();
    for (    String[] sArray : authors) {
      values.add(new StringValue(sArray[1] + ""String_Node_Str"" + sArray[0]));
    }
    record.addField(""String_Node_Str"",values);
  }
  Element journal=XMLUtils.getSingleElement(article,""String_Node_Str"");
  if (journal != null) {
    List<Element> jnumbers=XMLUtils.getElementList(journal,""String_Node_Str"");
    if (jnumbers != null) {
      for (      Element jnumber : jnumbers) {
        if (""String_Node_Str"".equals(jnumber.getAttribute(""String_Node_Str""))) {
          String issn=jnumber.getTextContent().trim();
          if (issn != null)           record.addValue(""String_Node_Str"",new StringValue(issn));
        }
 else {
          String eissn=jnumber.getTextContent().trim();
          if (eissn != null)           record.addValue(""String_Node_Str"",new StringValue(eissn));
        }
      }
    }
    String journalTitle=XMLUtils.getElementValue(journal,""String_Node_Str"");
    if (journalTitle != null)     record.addValue(""String_Node_Str"",new StringValue(journalTitle));
    Element journalIssueElement=XMLUtils.getSingleElement(journal,""String_Node_Str"");
    if (journalIssueElement != null) {
      String volume=XMLUtils.getElementValue(journalIssueElement,""String_Node_Str"");
      if (volume != null)       record.addValue(""String_Node_Str"",new StringValue(volume));
      String issue=XMLUtils.getElementValue(journalIssueElement,""String_Node_Str"");
      if (issue != null)       record.addValue(""String_Node_Str"",new StringValue(issue));
      Element pubDataElement=XMLUtils.getSingleElement(journalIssueElement,""String_Node_Str"");
      String year=null;
      if (pubDataElement != null) {
        year=XMLUtils.getElementValue(pubDataElement,""String_Node_Str"");
        String mounth=XMLUtils.getElementValue(pubDataElement,""String_Node_Str"");
        String day=XMLUtils.getElementValue(pubDataElement,""String_Node_Str"");
        if (StringUtils.isNotBlank(mounth) && mounthToNum.containsKey(mounth)) {
          year+=""String_Node_Str"" + mounthToNum.get(mounth);
          if (StringUtils.isNotBlank(day)) {
            year+=""String_Node_Str"" + (day.length() == 1 ? ""String_Node_Str"" + day : day);
          }
        }
      }
      if (year != null)       record.addValue(""String_Node_Str"",new StringValue(year));
    }
    String language=XMLUtils.getElementValue(article,""String_Node_Str"");
    if (language != null)     record.addValue(""String_Node_Str"",new StringValue(language));
    List<String> type=new LinkedList<String>();
    Element publicationTypeList=XMLUtils.getSingleElement(article,""String_Node_Str"");
    if (publicationTypeList != null) {
      List<Element> publicationTypes=XMLUtils.getElementList(publicationTypeList,""String_Node_Str"");
      for (      Element publicationType : publicationTypes) {
        type.add(publicationType.getTextContent().trim());
      }
    }
    if (type.size() > 0) {
      List<Value> values=new LinkedList<Value>();
      for (      String s : type) {
        values.add(new StringValue(s));
      }
      record.addField(""String_Node_Str"",values);
    }
    List<String> primaryKeywords=new LinkedList<String>();
    List<String> secondaryKeywords=new LinkedList<String>();
    Element keywordsList=XMLUtils.getSingleElement(medline,""String_Node_Str"");
    if (keywordsList != null) {
      List<Element> keywords=XMLUtils.getElementList(keywordsList,""String_Node_Str"");
      for (      Element keyword : keywords) {
        if (""String_Node_Str"".equals(keyword.getAttribute(""String_Node_Str""))) {
          primaryKeywords.add(keyword.getTextContent().trim());
        }
 else {
          secondaryKeywords.add(keyword.getTextContent().trim());
        }
      }
    }
    if (primaryKeywords.size() > 0) {
      List<Value> values=new LinkedList<Value>();
      for (      String s : primaryKeywords) {
        values.add(new StringValue(s));
      }
      record.addField(""String_Node_Str"",values);
    }
    if (secondaryKeywords.size() > 0) {
      List<Value> values=new LinkedList<Value>();
      for (      String s : secondaryKeywords) {
        values.add(new StringValue(s));
      }
      record.addField(""String_Node_Str"",values);
    }
    List<String> primaryMeshHeadings=new LinkedList<String>();
    List<String> secondaryMeshHeadings=new LinkedList<String>();
    Element meshHeadingsList=XMLUtils.getSingleElement(medline,""String_Node_Str"");
    if (meshHeadingsList != null) {
      List<Element> meshHeadings=XMLUtils.getElementList(meshHeadingsList,""String_Node_Str"");
      for (      Element meshHeading : meshHeadings) {
        if (""String_Node_Str"".equals(XMLUtils.getElementAttribute(meshHeading,""String_Node_Str"",""String_Node_Str""))) {
          primaryMeshHeadings.add(XMLUtils.getElementValue(meshHeading,""String_Node_Str""));
        }
 else {
          secondaryMeshHeadings.add(XMLUtils.getElementValue(meshHeading,""String_Node_Str""));
        }
      }
    }
    if (primaryMeshHeadings.size() > 0) {
      List<Value> values=new LinkedList<Value>();
      for (      String s : primaryMeshHeadings) {
        values.add(new StringValue(s));
      }
      record.addField(""String_Node_Str"",values);
    }
    if (secondaryMeshHeadings.size() > 0) {
      List<Value> values=new LinkedList<Value>();
      for (      String s : secondaryMeshHeadings) {
        values.add(new StringValue(s));
      }
      record.addField(""String_Node_Str"",values);
    }
    Element paginationElement=XMLUtils.getSingleElement(article,""String_Node_Str"");
    if (paginationElement != null) {
      String startPage=XMLUtils.getElementValue(paginationElement,""String_Node_Str"");
      String endPage=XMLUtils.getElementValue(paginationElement,""String_Node_Str"");
      if (StringUtils.isBlank(startPage)) {
        startPage=XMLUtils.getElementValue(paginationElement,""String_Node_Str"");
      }
      if (startPage != null)       record.addValue(""String_Node_Str"",new StringValue(startPage));
      if (endPage != null)       record.addValue(""String_Node_Str"",new StringValue(endPage));
    }
  }
  return record;
}","public static Record convertCrossRefDomToRecord(Element pubArticle){
  MutableRecord record=new SubmissionLookupPublication(""String_Node_Str"");
  Map<String,String> mounthToNum=new HashMap<String,String>();
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  mounthToNum.put(""String_Node_Str"",""String_Node_Str"");
  Element medline=XMLUtils.getSingleElement(pubArticle,""String_Node_Str"");
  Element article=XMLUtils.getSingleElement(medline,""String_Node_Str"");
  Element pubmed=XMLUtils.getSingleElement(pubArticle,""String_Node_Str"");
  Element identifierList=XMLUtils.getSingleElement(pubmed,""String_Node_Str"");
  if (identifierList != null) {
    List<Element> identifiers=XMLUtils.getElementList(identifierList,""String_Node_Str"");
    if (identifiers != null) {
      for (      Element id : identifiers) {
        if (""String_Node_Str"".equals(id.getAttribute(""String_Node_Str""))) {
          String pubmedID=id.getTextContent().trim();
          if (pubmedID != null)           record.addValue(""String_Node_Str"",new StringValue(pubmedID));
        }
 else         if (""String_Node_Str"".equals(id.getAttribute(""String_Node_Str""))) {
          String doi=id.getTextContent().trim();
          if (doi != null)           record.addValue(""String_Node_Str"",new StringValue(doi));
        }
      }
    }
  }
  String status=XMLUtils.getElementValue(pubmed,""String_Node_Str"");
  if (status != null)   record.addValue(""String_Node_Str"",new StringValue(status));
  String pubblicationModel=XMLUtils.getElementAttribute(medline,""String_Node_Str"",""String_Node_Str"");
  if (pubblicationModel != null)   record.addValue(""String_Node_Str"",new StringValue(pubblicationModel));
  String title=XMLUtils.getElementValue(article,""String_Node_Str"");
  if (title != null)   record.addValue(""String_Node_Str"",new StringValue(title));
  Element abstractElement=XMLUtils.getSingleElement(article,""String_Node_Str"");
  if (abstractElement == null) {
    abstractElement=XMLUtils.getSingleElement(medline,""String_Node_Str"");
  }
  if (abstractElement != null) {
    String summary=XMLUtils.getElementValue(abstractElement,""String_Node_Str"");
    if (summary != null)     record.addValue(""String_Node_Str"",new StringValue(summary));
  }
  List<String[]> authors=new LinkedList<String[]>();
  Element authorList=XMLUtils.getSingleElement(article,""String_Node_Str"");
  if (authorList != null) {
    List<Element> authorsElement=XMLUtils.getElementList(authorList,""String_Node_Str"");
    if (authorsElement != null) {
      for (      Element author : authorsElement) {
        if (StringUtils.isBlank(XMLUtils.getElementValue(author,""String_Node_Str""))) {
          authors.add(new String[]{XMLUtils.getElementValue(author,""String_Node_Str""),XMLUtils.getElementValue(author,""String_Node_Str"")});
        }
      }
    }
  }
  if (authors.size() > 0) {
    List<Value> values=new LinkedList<Value>();
    for (    String[] sArray : authors) {
      values.add(new StringValue(sArray[1] + ""String_Node_Str"" + sArray[0]));
    }
    record.addField(""String_Node_Str"",values);
  }
  Element journal=XMLUtils.getSingleElement(article,""String_Node_Str"");
  if (journal != null) {
    List<Element> jnumbers=XMLUtils.getElementList(journal,""String_Node_Str"");
    if (jnumbers != null) {
      for (      Element jnumber : jnumbers) {
        if (""String_Node_Str"".equals(jnumber.getAttribute(""String_Node_Str""))) {
          String issn=jnumber.getTextContent().trim();
          if (issn != null)           record.addValue(""String_Node_Str"",new StringValue(issn));
        }
 else {
          String eissn=jnumber.getTextContent().trim();
          if (eissn != null)           record.addValue(""String_Node_Str"",new StringValue(eissn));
        }
      }
    }
    String journalTitle=XMLUtils.getElementValue(journal,""String_Node_Str"");
    if (journalTitle != null)     record.addValue(""String_Node_Str"",new StringValue(journalTitle));
    Element journalIssueElement=XMLUtils.getSingleElement(journal,""String_Node_Str"");
    if (journalIssueElement != null) {
      String volume=XMLUtils.getElementValue(journalIssueElement,""String_Node_Str"");
      if (volume != null)       record.addValue(""String_Node_Str"",new StringValue(volume));
      String issue=XMLUtils.getElementValue(journalIssueElement,""String_Node_Str"");
      if (issue != null)       record.addValue(""String_Node_Str"",new StringValue(issue));
      Element pubDataElement=XMLUtils.getSingleElement(journalIssueElement,""String_Node_Str"");
      String year=null;
      if (pubDataElement != null) {
        year=XMLUtils.getElementValue(pubDataElement,""String_Node_Str"");
        String mounth=XMLUtils.getElementValue(pubDataElement,""String_Node_Str"");
        String day=XMLUtils.getElementValue(pubDataElement,""String_Node_Str"");
        if (StringUtils.isNotBlank(mounth) && mounthToNum.containsKey(mounth)) {
          year+=""String_Node_Str"" + mounthToNum.get(mounth);
          if (StringUtils.isNotBlank(day)) {
            year+=""String_Node_Str"" + (day.length() == 1 ? ""String_Node_Str"" + day : day);
          }
        }
      }
      if (year != null)       record.addValue(""String_Node_Str"",new StringValue(year));
    }
    String language=XMLUtils.getElementValue(article,""String_Node_Str"");
    if (language != null)     record.addValue(""String_Node_Str"",new StringValue(language));
    List<String> type=new LinkedList<String>();
    Element publicationTypeList=XMLUtils.getSingleElement(article,""String_Node_Str"");
    if (publicationTypeList != null) {
      List<Element> publicationTypes=XMLUtils.getElementList(publicationTypeList,""String_Node_Str"");
      for (      Element publicationType : publicationTypes) {
        type.add(publicationType.getTextContent().trim());
      }
    }
    if (type.size() > 0) {
      List<Value> values=new LinkedList<Value>();
      for (      String s : type) {
        values.add(new StringValue(s));
      }
      record.addField(""String_Node_Str"",values);
    }
    List<String> primaryKeywords=new LinkedList<String>();
    List<String> secondaryKeywords=new LinkedList<String>();
    Element keywordsList=XMLUtils.getSingleElement(medline,""String_Node_Str"");
    if (keywordsList != null) {
      List<Element> keywords=XMLUtils.getElementList(keywordsList,""String_Node_Str"");
      for (      Element keyword : keywords) {
        if (""String_Node_Str"".equals(keyword.getAttribute(""String_Node_Str""))) {
          primaryKeywords.add(keyword.getTextContent().trim());
        }
 else {
          secondaryKeywords.add(keyword.getTextContent().trim());
        }
      }
    }
    if (primaryKeywords.size() > 0) {
      List<Value> values=new LinkedList<Value>();
      for (      String s : primaryKeywords) {
        values.add(new StringValue(s));
      }
      record.addField(""String_Node_Str"",values);
    }
    if (secondaryKeywords.size() > 0) {
      List<Value> values=new LinkedList<Value>();
      for (      String s : secondaryKeywords) {
        values.add(new StringValue(s));
      }
      record.addField(""String_Node_Str"",values);
    }
    List<String> primaryMeshHeadings=new LinkedList<String>();
    List<String> secondaryMeshHeadings=new LinkedList<String>();
    Element meshHeadingsList=XMLUtils.getSingleElement(medline,""String_Node_Str"");
    if (meshHeadingsList != null) {
      List<Element> meshHeadings=XMLUtils.getElementList(meshHeadingsList,""String_Node_Str"");
      for (      Element meshHeading : meshHeadings) {
        if (""String_Node_Str"".equals(XMLUtils.getElementAttribute(meshHeading,""String_Node_Str"",""String_Node_Str""))) {
          primaryMeshHeadings.add(XMLUtils.getElementValue(meshHeading,""String_Node_Str""));
        }
 else {
          secondaryMeshHeadings.add(XMLUtils.getElementValue(meshHeading,""String_Node_Str""));
        }
      }
    }
    if (primaryMeshHeadings.size() > 0) {
      List<Value> values=new LinkedList<Value>();
      for (      String s : primaryMeshHeadings) {
        values.add(new StringValue(s));
      }
      record.addField(""String_Node_Str"",values);
    }
    if (secondaryMeshHeadings.size() > 0) {
      List<Value> values=new LinkedList<Value>();
      for (      String s : secondaryMeshHeadings) {
        values.add(new StringValue(s));
      }
      record.addField(""String_Node_Str"",values);
    }
    Element paginationElement=XMLUtils.getSingleElement(article,""String_Node_Str"");
    if (paginationElement != null) {
      String startPage=XMLUtils.getElementValue(paginationElement,""String_Node_Str"");
      String endPage=XMLUtils.getElementValue(paginationElement,""String_Node_Str"");
      if (StringUtils.isBlank(startPage)) {
        startPage=XMLUtils.getElementValue(paginationElement,""String_Node_Str"");
      }
      if (startPage != null)       record.addValue(""String_Node_Str"",new StringValue(startPage));
      if (endPage != null)       record.addValue(""String_Node_Str"",new StringValue(endPage));
    }
  }
  return record;
}",0.9993692178301092
52085,"private void prepareXwalk(){
  if (null != this.xwalk)   return;
  this.xwalk=(DisseminationCrosswalk)PluginManager.getNamedPlugin(DisseminationCrosswalk.class,this.CROSSWALK_NAME);
  if (this.xwalk == null) {
    throw new RuntimeException(""String_Node_Str"" + CROSSWALK_NAME + ""String_Node_Str"");
  }
}","protected void prepareXwalk(){
  if (null != this.xwalk)   return;
  this.xwalk=(DisseminationCrosswalk)PluginManager.getNamedPlugin(DisseminationCrosswalk.class,this.CROSSWALK_NAME);
  if (this.xwalk == null) {
    throw new RuntimeException(""String_Node_Str"" + CROSSWALK_NAME + ""String_Node_Str"");
  }
}",0.9802631578947368
52086,"private DataCiteResponse sendDOIGetRequest(String doi) throws DOIIdentifierException {
  return sendGetRequest(doi,DOI_PATH);
}","protected DataCiteResponse sendDOIGetRequest(String doi) throws DOIIdentifierException {
  return sendGetRequest(doi,DOI_PATH);
}",0.96875
52087,"private DataCiteResponse sendMetadataDeleteRequest(String doi) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(SCHEME).setHost(HOST).setPath(METADATA_PATH + doi.substring(DOI.SCHEME.length()));
  HttpDelete httpdelete=null;
  try {
    httpdelete=new HttpDelete(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",SCHEME + ""String_Node_Str"" + HOST+ DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  return sendHttpRequest(httpdelete,doi);
}","protected DataCiteResponse sendMetadataDeleteRequest(String doi) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(SCHEME).setHost(HOST).setPath(METADATA_PATH + doi.substring(DOI.SCHEME.length()));
  HttpDelete httpdelete=null;
  try {
    httpdelete=new HttpDelete(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",SCHEME + ""String_Node_Str"" + HOST+ DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  return sendHttpRequest(httpdelete,doi);
}",0.991150442477876
52088,"private String getUsername(){
  if (null == this.USERNAME) {
    this.USERNAME=this.configurationService.getProperty(CFG_USER);
    if (null == this.USERNAME) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + CFG_USER + ""String_Node_Str"");
    }
  }
  return this.USERNAME;
}","protected String getUsername(){
  if (null == this.USERNAME) {
    this.USERNAME=this.configurationService.getProperty(CFG_USER);
    if (null == this.USERNAME) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + CFG_USER + ""String_Node_Str"");
    }
  }
  return this.USERNAME;
}",0.9800664451827242
52089,"private DataCiteResponse sendMetadataGetRequest(String doi) throws DOIIdentifierException {
  return sendGetRequest(doi,METADATA_PATH);
}","protected DataCiteResponse sendMetadataGetRequest(String doi) throws DOIIdentifierException {
  return sendGetRequest(doi,METADATA_PATH);
}",0.9710144927536232
52090,"/** 
 * @param req
 * @param doi
 * @return
 * @throws DOIIdentifierException 
 */
private DataCiteResponse sendHttpRequest(HttpUriRequest req,String doi) throws DOIIdentifierException {
  DefaultHttpClient httpclient=new DefaultHttpClient();
  httpclient.getCredentialsProvider().setCredentials(new AuthScope(HOST,443),new UsernamePasswordCredentials(this.getUsername(),this.getPassword()));
  HttpEntity entity=null;
  try {
    HttpResponse response=httpclient.execute(req);
    StatusLine status=response.getStatusLine();
    int statusCode=status.getStatusCode();
    String content=null;
    entity=response.getEntity();
    if (null != entity) {
      content=EntityUtils.toString(entity,""String_Node_Str"");
    }
switch (statusCode) {
case (401):
{
        log.info(""String_Node_Str"");
        log.info(""String_Node_Str"",content);
        throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.AUTHENTICATION_ERROR);
      }
case (403):
{
      log.info(""String_Node_Str"" + ""String_Node_Str"",doi,content);
      throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.FOREIGN_DOI);
    }
case (500):
{
    log.warn(""String_Node_Str"" + ""String_Node_Str"" + content);
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.INTERNAL_ERROR);
  }
}
return new DataCiteResponse(statusCode,content);
}
 catch (IOException e) {
log.warn(""String_Node_Str"" + e.getMessage());
throw new RuntimeException(e);
}
 finally {
try {
if (null != entity) {
  EntityUtils.consume(entity);
}
}
 catch (IOException e) {
log.warn(""String_Node_Str"" + e.getMessage());
}
}
}","/** 
 * @param req
 * @param doi
 * @return
 * @throws DOIIdentifierException 
 */
protected DataCiteResponse sendHttpRequest(HttpUriRequest req,String doi) throws DOIIdentifierException {
  DefaultHttpClient httpclient=new DefaultHttpClient();
  httpclient.getCredentialsProvider().setCredentials(new AuthScope(HOST,443),new UsernamePasswordCredentials(this.getUsername(),this.getPassword()));
  HttpEntity entity=null;
  try {
    HttpResponse response=httpclient.execute(req);
    StatusLine status=response.getStatusLine();
    int statusCode=status.getStatusCode();
    String content=null;
    entity=response.getEntity();
    if (null != entity) {
      content=EntityUtils.toString(entity,""String_Node_Str"");
    }
switch (statusCode) {
case (401):
{
        log.info(""String_Node_Str"");
        log.info(""String_Node_Str"",content);
        throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.AUTHENTICATION_ERROR);
      }
case (403):
{
      log.info(""String_Node_Str"" + ""String_Node_Str"",doi,content);
      throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.FOREIGN_DOI);
    }
case (500):
{
    log.warn(""String_Node_Str"" + ""String_Node_Str"" + content);
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.INTERNAL_ERROR);
  }
}
return new DataCiteResponse(statusCode,content);
}
 catch (IOException e) {
log.warn(""String_Node_Str"" + e.getMessage());
throw new RuntimeException(e);
}
 finally {
try {
if (null != entity) {
  EntityUtils.consume(entity);
}
}
 catch (IOException e) {
log.warn(""String_Node_Str"" + e.getMessage());
}
}
}",0.9965055329062318
52091,"private DataCiteResponse sendDOIPostRequest(String doi,String url) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(SCHEME).setHost(HOST).setPath(DOI_PATH);
  HttpPost httppost=null;
  try {
    httppost=new HttpPost(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",SCHEME + ""String_Node_Str"" + HOST+ DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  HttpEntity reqEntity=null;
  try {
    String req=""String_Node_Str"" + doi.substring(DOI.SCHEME.length()) + ""String_Node_Str""+ ""String_Node_Str""+ url+ ""String_Node_Str"";
    ContentType contentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
    reqEntity=new StringEntity(req,contentType);
    httppost.setEntity(reqEntity);
    return sendHttpRequest(httppost,doi);
  }
  finally {
    try {
      EntityUtils.consume(reqEntity);
    }
 catch (    IOException ioe) {
      log.info(""String_Node_Str"" + ioe.getMessage());
    }
  }
}","protected DataCiteResponse sendDOIPostRequest(String doi,String url) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(SCHEME).setHost(HOST).setPath(DOI_PATH);
  HttpPost httppost=null;
  try {
    httppost=new HttpPost(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",SCHEME + ""String_Node_Str"" + HOST+ DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  HttpEntity reqEntity=null;
  try {
    String req=""String_Node_Str"" + doi.substring(DOI.SCHEME.length()) + ""String_Node_Str""+ ""String_Node_Str""+ url+ ""String_Node_Str"";
    ContentType contentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
    reqEntity=new StringEntity(req,contentType);
    httppost.setEntity(reqEntity);
    return sendHttpRequest(httppost,doi);
  }
  finally {
    try {
      EntityUtils.consume(reqEntity);
    }
 catch (    IOException ioe) {
      log.info(""String_Node_Str"" + ioe.getMessage());
    }
  }
}",0.9947229551451188
52092,"private String extractAlternateIdentifier(Context context,String content) throws SQLException, DOIIdentifierException {
  if (content == null) {
    return null;
  }
  SAXBuilder saxBuilder=new SAXBuilder();
  Document doc=null;
  try {
    doc=saxBuilder.build(new ByteArrayInputStream(content.getBytes(""String_Node_Str"")));
  }
 catch (  IOException ioe) {
    throw new RuntimeException(""String_Node_Str"",ioe);
  }
catch (  JDOMException jde) {
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",jde,DOIIdentifierException.BAD_ANSWER);
  }
  String handle=null;
  Iterator<Element> it=doc.getDescendants(new ElementFilter(""String_Node_Str""));
  while (handle == null && it.hasNext()) {
    Element alternateIdentifier=it.next();
    try {
      handle=HandleManager.resolveUrlToHandle(context,alternateIdentifier.getText());
    }
 catch (    SQLException e) {
      throw e;
    }
  }
  return handle;
}","protected String extractAlternateIdentifier(Context context,String content) throws SQLException, DOIIdentifierException {
  if (content == null) {
    return null;
  }
  SAXBuilder saxBuilder=new SAXBuilder();
  Document doc=null;
  try {
    doc=saxBuilder.build(new ByteArrayInputStream(content.getBytes(""String_Node_Str"")));
  }
 catch (  IOException ioe) {
    throw new RuntimeException(""String_Node_Str"",ioe);
  }
catch (  JDOMException jde) {
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",jde,DOIIdentifierException.BAD_ANSWER);
  }
  String handle=null;
  Iterator<Element> it=doc.getDescendants(new ElementFilter(""String_Node_Str""));
  while (handle == null && it.hasNext()) {
    Element alternateIdentifier=it.next();
    try {
      handle=HandleManager.resolveUrlToHandle(context,alternateIdentifier.getText());
    }
 catch (    SQLException e) {
      throw e;
    }
  }
  return handle;
}",0.9935622317596566
52093,"private Element addDOI(String doi,Element root){
  if (null != extractDOI(root)) {
    return root;
  }
  Element identifier=new Element(""String_Node_Str"",""String_Node_Str"");
  identifier.setAttribute(""String_Node_Str"",""String_Node_Str"");
  identifier.addContent(doi.substring(DOI.SCHEME.length()));
  return root.addContent(0,identifier);
}","protected Element addDOI(String doi,Element root){
  if (null != extractDOI(root)) {
    return root;
  }
  Element identifier=new Element(""String_Node_Str"",""String_Node_Str"");
  identifier.setAttribute(""String_Node_Str"",""String_Node_Str"");
  identifier.addContent(doi.substring(DOI.SCHEME.length()));
  return root.addContent(0,identifier);
}",0.9824561403508772
52094,"private DataCiteResponse sendMetadataPostRequest(String doi,String metadata) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(SCHEME).setHost(HOST).setPath(METADATA_PATH);
  HttpPost httppost=null;
  try {
    httppost=new HttpPost(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",SCHEME + ""String_Node_Str"" + HOST+ DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  HttpEntity reqEntity=null;
  try {
    ContentType contentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
    reqEntity=new StringEntity(metadata,contentType);
    httppost.setEntity(reqEntity);
    return sendHttpRequest(httppost,doi);
  }
  finally {
    try {
      EntityUtils.consume(reqEntity);
    }
 catch (    IOException ioe) {
      log.info(""String_Node_Str"" + ioe.getMessage());
    }
  }
}","protected DataCiteResponse sendMetadataPostRequest(String doi,String metadata) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(SCHEME).setHost(HOST).setPath(METADATA_PATH);
  HttpPost httppost=null;
  try {
    httppost=new HttpPost(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",SCHEME + ""String_Node_Str"" + HOST+ DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  HttpEntity reqEntity=null;
  try {
    ContentType contentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
    reqEntity=new StringEntity(metadata,contentType);
    httppost.setEntity(reqEntity);
    return sendHttpRequest(httppost,doi);
  }
  finally {
    try {
      EntityUtils.consume(reqEntity);
    }
 catch (    IOException ioe) {
      log.info(""String_Node_Str"" + ioe.getMessage());
    }
  }
}",0.9941348973607038
52095,"private DataCiteResponse sendGetRequest(String doi,String path) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(SCHEME).setHost(HOST).setPath(path + doi.substring(DOI.SCHEME.length()));
  HttpGet httpget=null;
  try {
    httpget=new HttpGet(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",SCHEME + ""String_Node_Str"" + HOST+ DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  return sendHttpRequest(httpget,doi);
}","protected DataCiteResponse sendGetRequest(String doi,String path) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(SCHEME).setHost(HOST).setPath(path + doi.substring(DOI.SCHEME.length()));
  HttpGet httpget=null;
  try {
    httpget=new HttpGet(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",SCHEME + ""String_Node_Str"" + HOST+ DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  return sendHttpRequest(httpget,doi);
}",0.9908396946564886
52096,"private String getPassword(){
  if (null == this.PASSWORD) {
    this.PASSWORD=this.configurationService.getProperty(CFG_PASSWORD);
    if (null == this.PASSWORD) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + CFG_PASSWORD + ""String_Node_Str"");
    }
  }
  return this.PASSWORD;
}","protected String getPassword(){
  if (null == this.PASSWORD) {
    this.PASSWORD=this.configurationService.getProperty(CFG_PASSWORD);
    if (null == this.PASSWORD) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + CFG_PASSWORD + ""String_Node_Str"");
    }
  }
  return this.PASSWORD;
}",0.9805825242718448
52097,"private String extractDOI(Element root){
  Element doi=root.getChild(""String_Node_Str"",root.getNamespace());
  return (null == doi) ? null : doi.getTextTrim();
}","protected String extractDOI(Element root){
  Element doi=root.getChild(""String_Node_Str"",root.getNamespace());
  return (null == doi) ? null : doi.getTextTrim();
}",0.9753086419753086
52098,"private DataCiteResponse sendMetadataDeleteRequest(String doi) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(""String_Node_Str"").setHost(HOST).setPath(METADATA_PATH + doi.substring(DOI.SCHEME.length()));
  HttpDelete httpdelete=null;
  try {
    httpdelete=new HttpDelete(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",""String_Node_Str"" + HOST + DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  return sendHttpRequest(httpdelete,doi);
}","private DataCiteResponse sendMetadataDeleteRequest(String doi) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(SCHEME).setHost(HOST).setPath(METADATA_PATH + doi.substring(DOI.SCHEME.length()));
  HttpDelete httpdelete=null;
  try {
    httpdelete=new HttpDelete(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",SCHEME + ""String_Node_Str"" + HOST+ DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  return sendHttpRequest(httpdelete,doi);
}",0.9756816507000736
52099,"private DataCiteResponse sendDOIPostRequest(String doi,String url) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(""String_Node_Str"").setHost(HOST).setPath(DOI_PATH);
  HttpPost httppost=null;
  try {
    httppost=new HttpPost(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",""String_Node_Str"" + HOST + DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  HttpEntity reqEntity=null;
  try {
    String req=""String_Node_Str"" + doi.substring(DOI.SCHEME.length()) + ""String_Node_Str""+ ""String_Node_Str""+ url+ ""String_Node_Str"";
    ContentType contentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
    reqEntity=new StringEntity(req,contentType);
    httppost.setEntity(reqEntity);
    return sendHttpRequest(httppost,doi);
  }
  finally {
    try {
      EntityUtils.consume(reqEntity);
    }
 catch (    IOException ioe) {
      log.info(""String_Node_Str"" + ioe.getMessage());
    }
  }
}","private DataCiteResponse sendDOIPostRequest(String doi,String url) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(SCHEME).setHost(HOST).setPath(DOI_PATH);
  HttpPost httppost=null;
  try {
    httppost=new HttpPost(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",SCHEME + ""String_Node_Str"" + HOST+ DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  HttpEntity reqEntity=null;
  try {
    String req=""String_Node_Str"" + doi.substring(DOI.SCHEME.length()) + ""String_Node_Str""+ ""String_Node_Str""+ url+ ""String_Node_Str"";
    ContentType contentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
    reqEntity=new StringEntity(req,contentType);
    httppost.setEntity(reqEntity);
    return sendHttpRequest(httppost,doi);
  }
  finally {
    try {
      EntityUtils.consume(reqEntity);
    }
 catch (    IOException ioe) {
      log.info(""String_Node_Str"" + ioe.getMessage());
    }
  }
}",0.9854945054945056
52100,"private DataCiteResponse sendMetadataPostRequest(String doi,String metadata) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(""String_Node_Str"").setHost(HOST).setPath(METADATA_PATH);
  HttpPost httppost=null;
  try {
    httppost=new HttpPost(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",""String_Node_Str"" + HOST + DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  HttpEntity reqEntity=null;
  try {
    ContentType contentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
    reqEntity=new StringEntity(metadata,contentType);
    httppost.setEntity(reqEntity);
    return sendHttpRequest(httppost,doi);
  }
  finally {
    try {
      EntityUtils.consume(reqEntity);
    }
 catch (    IOException ioe) {
      log.info(""String_Node_Str"" + ioe.getMessage());
    }
  }
}","private DataCiteResponse sendMetadataPostRequest(String doi,String metadata) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(SCHEME).setHost(HOST).setPath(METADATA_PATH);
  HttpPost httppost=null;
  try {
    httppost=new HttpPost(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",SCHEME + ""String_Node_Str"" + HOST+ DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  HttpEntity reqEntity=null;
  try {
    ContentType contentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
    reqEntity=new StringEntity(metadata,contentType);
    httppost.setEntity(reqEntity);
    return sendHttpRequest(httppost,doi);
  }
  finally {
    try {
      EntityUtils.consume(reqEntity);
    }
 catch (    IOException ioe) {
      log.info(""String_Node_Str"" + ioe.getMessage());
    }
  }
}",0.9838788470933072
52101,"private DataCiteResponse sendGetRequest(String doi,String path) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(""String_Node_Str"").setHost(HOST).setPath(path + doi.substring(DOI.SCHEME.length()));
  HttpGet httpget=null;
  try {
    httpget=new HttpGet(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",""String_Node_Str"" + HOST + DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  return sendHttpRequest(httpget,doi);
}","private DataCiteResponse sendGetRequest(String doi,String path) throws DOIIdentifierException {
  URIBuilder uribuilder=new URIBuilder();
  uribuilder.setScheme(SCHEME).setHost(HOST).setPath(path + doi.substring(DOI.SCHEME.length()));
  HttpGet httpget=null;
  try {
    httpget=new HttpGet(uribuilder.build());
  }
 catch (  URISyntaxException e) {
    log.error(""String_Node_Str"" + ""String_Node_Str"");
    log.error(""String_Node_Str"",SCHEME + ""String_Node_Str"" + HOST+ DOI_PATH+ ""String_Node_Str""+ doi.substring(DOI.SCHEME.length()));
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  return sendHttpRequest(httpget,doi);
}",0.9748283752860412
52102,"public void run(){
  Context context=null;
  ItemIterator iitems=null;
  try {
    context=new Context();
    context.setIgnoreAuthorization(true);
    File importDir=new File(ConfigurationManager.getProperty(""String_Node_Str""));
    if (!importDir.exists()) {
      boolean success=importDir.mkdir();
      if (!success) {
        log.info(""String_Node_Str"");
        throw new Exception();
      }
    }
    String subDirName=generateRandomFilename(false);
    String workingDir=importDir.getAbsolutePath() + File.separator + subDirName;
    boolean success=(new File(workingDir)).mkdir();
    if (!success) {
      log.info(""String_Node_Str"");
      throw new Exception();
    }
    String mapfile=workingDir + File.separator + ""String_Node_Str"";
    ItemImport myloader=new ItemImport();
    myloader.addBTEItems(context,mycollections,myFile.getAbsolutePath(),mapfile,template,myBteInputType,workingDir);
    emailSuccessMessage(context,eperson,mapfile);
    context.setIgnoreAuthorization(false);
  }
 catch (  Exception e1) {
    try {
      emailErrorMessage(eperson,e1.getMessage());
    }
 catch (    Exception e) {
    }
    throw new IllegalStateException(e1);
  }
 finally {
    if (iitems != null) {
      iitems.close();
    }
    if (mapOut != null) {
      mapOut.close();
    }
    try {
      context.complete();
    }
 catch (    SQLException sqle) {
      context.abort();
    }
  }
}","public void run(){
  Context context=null;
  ItemIterator iitems=null;
  try {
    context=new Context();
    context.setCurrentUser(eperson);
    context.setIgnoreAuthorization(true);
    File importDir=new File(ConfigurationManager.getProperty(""String_Node_Str""));
    if (!importDir.exists()) {
      boolean success=importDir.mkdir();
      if (!success) {
        log.info(""String_Node_Str"");
        throw new Exception();
      }
    }
    String subDirName=generateRandomFilename(false);
    String workingDir=importDir.getAbsolutePath() + File.separator + subDirName;
    boolean success=(new File(workingDir)).mkdir();
    if (!success) {
      log.info(""String_Node_Str"");
      throw new Exception();
    }
    String mapfile=workingDir + File.separator + ""String_Node_Str"";
    ItemImport myloader=new ItemImport();
    myloader.addBTEItems(context,mycollections,myFile.getAbsolutePath(),mapfile,template,myBteInputType,workingDir);
    emailSuccessMessage(context,eperson,mapfile);
    context.setIgnoreAuthorization(false);
  }
 catch (  Exception e1) {
    try {
      emailErrorMessage(eperson,e1.getMessage());
    }
 catch (    Exception e) {
    }
    throw new IllegalStateException(e1);
  }
 finally {
    if (iitems != null) {
      iitems.close();
    }
    if (mapOut != null) {
      mapOut.close();
    }
    try {
      context.complete();
    }
 catch (    SQLException sqle) {
      context.abort();
    }
  }
}",0.9869947275922673
52103,"/** 
 * Given an uploaded file, this method calls the method to instantiate a BTE instance to  transform the input data and batch import them to DSpace
 * @param file The input file to read data from
 * @param collections The collections the created items will be inserted to
 * @param bteInputType The input type of the data (bibtex, csv, etc.)
 * @param context The context
 * @throws Exception
 */
public static void processUploadableImport(File file,Collection[] collections,String bteInputType,Context context) throws Exception {
  final EPerson eperson=context.getCurrentUser();
  final File myFile=file;
  final Collection[] mycollections=collections;
  final String myBteInputType=bteInputType;
  if (file.exists()) {
    Thread go=new Thread(){
      public void run(){
        Context context=null;
        ItemIterator iitems=null;
        try {
          context=new Context();
          context.setIgnoreAuthorization(true);
          File importDir=new File(ConfigurationManager.getProperty(""String_Node_Str""));
          if (!importDir.exists()) {
            boolean success=importDir.mkdir();
            if (!success) {
              log.info(""String_Node_Str"");
              throw new Exception();
            }
          }
          String subDirName=generateRandomFilename(false);
          String workingDir=importDir.getAbsolutePath() + File.separator + subDirName;
          boolean success=(new File(workingDir)).mkdir();
          if (!success) {
            log.info(""String_Node_Str"");
            throw new Exception();
          }
          String mapfile=workingDir + File.separator + ""String_Node_Str"";
          ItemImport myloader=new ItemImport();
          myloader.addBTEItems(context,mycollections,myFile.getAbsolutePath(),mapfile,template,myBteInputType,workingDir);
          emailSuccessMessage(context,eperson,mapfile);
          context.setIgnoreAuthorization(false);
        }
 catch (        Exception e1) {
          try {
            emailErrorMessage(eperson,e1.getMessage());
          }
 catch (          Exception e) {
          }
          throw new IllegalStateException(e1);
        }
 finally {
          if (iitems != null) {
            iitems.close();
          }
          if (mapOut != null) {
            mapOut.close();
          }
          try {
            context.complete();
          }
 catch (          SQLException sqle) {
            context.abort();
          }
        }
      }
    }
;
    go.isDaemon();
    go.start();
  }
 else {
    log.error(""String_Node_Str"");
  }
}","/** 
 * Given an uploaded file, this method calls the method to instantiate a BTE instance to  transform the input data and batch import them to DSpace
 * @param file The input file to read data from
 * @param collections The collections the created items will be inserted to
 * @param bteInputType The input type of the data (bibtex, csv, etc.)
 * @param context The context
 * @throws Exception
 */
public static void processUploadableImport(File file,Collection[] collections,String bteInputType,Context context) throws Exception {
  final EPerson eperson=context.getCurrentUser();
  final File myFile=file;
  final Collection[] mycollections=collections;
  final String myBteInputType=bteInputType;
  if (file.exists()) {
    Thread go=new Thread(){
      public void run(){
        Context context=null;
        ItemIterator iitems=null;
        try {
          context=new Context();
          context.setCurrentUser(eperson);
          context.setIgnoreAuthorization(true);
          File importDir=new File(ConfigurationManager.getProperty(""String_Node_Str""));
          if (!importDir.exists()) {
            boolean success=importDir.mkdir();
            if (!success) {
              log.info(""String_Node_Str"");
              throw new Exception();
            }
          }
          String subDirName=generateRandomFilename(false);
          String workingDir=importDir.getAbsolutePath() + File.separator + subDirName;
          boolean success=(new File(workingDir)).mkdir();
          if (!success) {
            log.info(""String_Node_Str"");
            throw new Exception();
          }
          String mapfile=workingDir + File.separator + ""String_Node_Str"";
          ItemImport myloader=new ItemImport();
          myloader.addBTEItems(context,mycollections,myFile.getAbsolutePath(),mapfile,template,myBteInputType,workingDir);
          emailSuccessMessage(context,eperson,mapfile);
          context.setIgnoreAuthorization(false);
        }
 catch (        Exception e1) {
          try {
            emailErrorMessage(eperson,e1.getMessage());
          }
 catch (          Exception e) {
          }
          throw new IllegalStateException(e1);
        }
 finally {
          if (iitems != null) {
            iitems.close();
          }
          if (mapOut != null) {
            mapOut.close();
          }
          try {
            context.complete();
          }
 catch (          SQLException sqle) {
            context.abort();
          }
        }
      }
    }
;
    go.isDaemon();
    go.start();
  }
 else {
    log.error(""String_Node_Str"");
  }
}",0.9916293556550516
52104,"public void reserveOnline(Context context,DSpaceObject dso,String identifier) throws IdentifierException, IllegalArgumentException, SQLException {
  String doi=DOI.formatIdentifier(identifier);
  TableRow doiRow=loadOrCreateDOI(context,dso,doi);
  if (DELETED == doiRow.getIntColumn(""String_Node_Str"") || TO_BE_DELETED == doiRow.getIntColumn(""String_Node_Str"")) {
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.DOI_IS_DELETED);
  }
  if (connector.isDOIReserved(context,doi)) {
    if (!connector.isDOIReserved(context,dso,doi)) {
      log.warn(""String_Node_Str"",doi);
      throw new DOIIdentifierException(DOIIdentifierException.DOI_ALREADY_EXISTS);
    }
  }
 else {
    connector.reserveDOI(context,dso,doi);
  }
  doiRow.setColumn(""String_Node_Str"",IS_RESERVED);
  DatabaseManager.update(context,doiRow);
}","public void reserveOnline(Context context,DSpaceObject dso,String identifier) throws IdentifierException, IllegalArgumentException, SQLException {
  String doi=DOI.formatIdentifier(identifier);
  TableRow doiRow=loadOrCreateDOI(context,dso,doi);
  if (DELETED == doiRow.getIntColumn(""String_Node_Str"") || TO_BE_DELETED == doiRow.getIntColumn(""String_Node_Str"")) {
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.DOI_IS_DELETED);
  }
  connector.reserveDOI(context,dso,doi);
  doiRow.setColumn(""String_Node_Str"",IS_RESERVED);
  DatabaseManager.update(context,doiRow);
}",0.812964213369345
52105,"public void updateMetadataOnline(Context context,DSpaceObject dso,String identifier) throws IdentifierException, SQLException {
  String doi=DOI.formatIdentifier(identifier);
  TableRow doiRow=null;
  try {
    doiRow=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",doi.substring(DOI.SCHEME.length()));
  }
 catch (  SQLException sqle) {
    log.warn(""String_Node_Str"",sqle);
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",sqle);
  }
  if (null == doiRow) {
    log.error(""String_Node_Str"" + ""String_Node_Str"",doi);
    throw new DOIIdentifierException(""String_Node_Str"",DOIIdentifierException.DOI_DOES_NOT_EXIST);
  }
  if (doiRow.getIntColumn(""String_Node_Str"") != dso.getID() || doiRow.getIntColumn(""String_Node_Str"") != dso.getType()) {
    log.error(""String_Node_Str"" + ""String_Node_Str"",new String[]{doi,dso.getTypeText(),Integer.toString(dso.getID())});
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.MISMATCH);
  }
  if (DELETED == doiRow.getIntColumn(""String_Node_Str"") || TO_BE_DELETED == doiRow.getIntColumn(""String_Node_Str"")) {
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.DOI_IS_DELETED);
  }
  if (connector.isDOIReserved(context,identifier)) {
    if (!connector.isDOIReserved(context,dso,doi)) {
      log.warn(""String_Node_Str"" + ""String_Node_Str"",doi);
      throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.DOI_ALREADY_EXISTS);
    }
  }
  connector.updateMetadata(context,dso,doi);
  if (UPDATE_REGISTERED == doiRow.getIntColumn(""String_Node_Str"")) {
    doiRow.setColumn(""String_Node_Str"",IS_REGISTERED);
  }
 else   if (UPDATE_BEFORE_REGISTERATION == doiRow.getIntColumn(""String_Node_Str"")) {
    doiRow.setColumn(""String_Node_Str"",TO_BE_REGISTERED);
  }
 else   if (UPDATE_RESERVERED == doiRow.getIntColumn(""String_Node_Str"")) {
    doiRow.setColumn(""String_Node_Str"",IS_RESERVED);
  }
  DatabaseManager.update(context,doiRow);
}","public void updateMetadataOnline(Context context,DSpaceObject dso,String identifier) throws IdentifierException, SQLException {
  String doi=DOI.formatIdentifier(identifier);
  TableRow doiRow=null;
  try {
    doiRow=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",doi.substring(DOI.SCHEME.length()));
  }
 catch (  SQLException sqle) {
    log.warn(""String_Node_Str"",sqle);
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",sqle);
  }
  if (null == doiRow) {
    log.error(""String_Node_Str"" + ""String_Node_Str"",doi);
    throw new DOIIdentifierException(""String_Node_Str"",DOIIdentifierException.DOI_DOES_NOT_EXIST);
  }
  if (doiRow.getIntColumn(""String_Node_Str"") != dso.getID() || doiRow.getIntColumn(""String_Node_Str"") != dso.getType()) {
    log.error(""String_Node_Str"" + ""String_Node_Str"",new String[]{doi,dso.getTypeText(),Integer.toString(dso.getID())});
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.MISMATCH);
  }
  if (DELETED == doiRow.getIntColumn(""String_Node_Str"") || TO_BE_DELETED == doiRow.getIntColumn(""String_Node_Str"")) {
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.DOI_IS_DELETED);
  }
  connector.updateMetadata(context,dso,doi);
  if (UPDATE_REGISTERED == doiRow.getIntColumn(""String_Node_Str"")) {
    doiRow.setColumn(""String_Node_Str"",IS_REGISTERED);
  }
 else   if (UPDATE_BEFORE_REGISTERATION == doiRow.getIntColumn(""String_Node_Str"")) {
    doiRow.setColumn(""String_Node_Str"",TO_BE_REGISTERED);
  }
 else   if (UPDATE_RESERVERED == doiRow.getIntColumn(""String_Node_Str"")) {
    doiRow.setColumn(""String_Node_Str"",IS_RESERVED);
  }
  DatabaseManager.update(context,doiRow);
}",0.9221462388216728
52106,"public void registerOnline(Context context,DSpaceObject dso,String identifier) throws IdentifierException, IllegalArgumentException, SQLException {
  String doi=DOI.formatIdentifier(identifier);
  TableRow doiRow=loadOrCreateDOI(context,dso,doi);
  if (DELETED == doiRow.getIntColumn(""String_Node_Str"") || TO_BE_DELETED == doiRow.getIntColumn(""String_Node_Str"")) {
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.DOI_IS_DELETED);
  }
  if (connector.isDOIRegistered(context,doi)) {
    if (!connector.isDOIRegistered(context,dso,doi)) {
      log.warn(""String_Node_Str"",doi);
      throw new DOIIdentifierException(DOIIdentifierException.DOI_ALREADY_EXISTS);
    }
  }
 else {
    if (!connector.isDOIReserved(context,dso,doi)) {
      if (connector.isDOIReserved(context,doi)) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"",doi);
        throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.DOI_ALREADY_EXISTS);
      }
      connector.reserveDOI(context,dso,doi);
    }
    try {
      connector.registerDOI(context,dso,doi);
    }
 catch (    DOIIdentifierException die) {
      if (die.getCode() == DOIIdentifierException.RESERVE_FIRST) {
        this.reserveOnline(context,dso,identifier);
        connector.registerDOI(context,dso,doi);
      }
 else {
        throw die;
      }
    }
  }
  try {
    saveDOIToObject(context,dso,doi);
  }
 catch (  AuthorizeException ae) {
    throw new IdentifierException(""String_Node_Str"",ae);
  }
catch (  SQLException sqle) {
    throw new RuntimeException(sqle);
  }
  doiRow.setColumn(""String_Node_Str"",IS_REGISTERED);
  DatabaseManager.update(context,doiRow);
}","public void registerOnline(Context context,DSpaceObject dso,String identifier) throws IdentifierException, IllegalArgumentException, SQLException {
  String doi=DOI.formatIdentifier(identifier);
  TableRow doiRow=loadOrCreateDOI(context,dso,doi);
  if (DELETED == doiRow.getIntColumn(""String_Node_Str"") || TO_BE_DELETED == doiRow.getIntColumn(""String_Node_Str"")) {
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.DOI_IS_DELETED);
  }
  try {
    connector.registerDOI(context,dso,doi);
  }
 catch (  DOIIdentifierException die) {
    if (die.getCode() == DOIIdentifierException.RESERVE_FIRST) {
      this.reserveOnline(context,dso,identifier);
      connector.registerDOI(context,dso,doi);
    }
 else {
      throw die;
    }
  }
  try {
    saveDOIToObject(context,dso,doi);
  }
 catch (  AuthorizeException ae) {
    throw new IdentifierException(""String_Node_Str"",ae);
  }
catch (  SQLException sqle) {
    throw new RuntimeException(sqle);
  }
  doiRow.setColumn(""String_Node_Str"",IS_REGISTERED);
  DatabaseManager.update(context,doiRow);
}",0.7239045244032776
52107,"/** 
 * Sends a request to the DOI registry to register a DOI. Please check on your own if the DOI is already reserved or even registered before you try to register it. You can use the methods  {@code DOIConnector.isDOIRegistered(...)} and{@code DOIConnector.isDOIReserved(...)} for it. The DOIConnector won'tdo any tests and throws an DOIIdentifierException in case of any problems with the DOI you want to register.
 * @param context
 * @param dso
 * @param doi
 * @return
 * @throws DOIIdentifierException 
 */
public void registerDOI(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException ;","/** 
 * Sends a request to the DOI registry to register a DOI. The DOIConnector ensures compliance with the workflow of the registration agency. For example, if a DOI has to be reserved before it can be registered the DOIConnector has to check if it is reserved. In this case you can throw an DOIIdentifierExcpetion and set the error code to   {@link DOIIdentifierException.RESERVE_FIRST}.
 * @param context
 * @param dso
 * @param doi
 * @return
 * @throws DOIIdentifierException 
 */
public void registerDOI(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException ;",0.4583333333333333
52108,"/** 
 * Sends a request to the DOI registry to update Metadata for a DOI. The DOIConnector won't do any tests and throws an IdentifierException  in case of any problems with the DOI you want to update the metadata.
 * @param context
 * @param dso
 * @param doi
 * @return
 * @throws IdentifierException 
 */
public void updateMetadata(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException ;","/** 
 * Sends a request to the DOI registry to update metadata for a DOI. The DOIConnector should check weather the DOI is reserved or registered  for the specified DSpace Object before it sends the metadata update.
 * @param context
 * @param dso
 * @param doi
 * @return
 * @throws IdentifierException 
 */
public void updateMetadata(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException ;",0.3450789793438639
52109,"/** 
 * Sends a request to the DOI registry to reserve a DOI. Please check on your own if the DOI is already reserved or even registered before you try to reserve it. You can use  {@link isDOIRegistered} and {@link isDOIReserved} for it. TheDOIConnector won't do any tests and throws an DOIIdentifierException in case of any problems with the DOI you want to reserve.
 * @param context
 * @param dso
 * @param doi
 * @return
 * @throws DOIIdentifierException 
 */
public void reserveDOI(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException ;","/** 
 * Sends a request to the DOI registry to reserve a DOI. The DOIConnector should check weather this DOI is reserved for another object already. In this case it should throw an   {@link DOIIdentifierException} and set the error code to {@code DOIIdentifierException.DOI_ALREADY_EXISTS}.
 * @param context
 * @param dso
 * @param doi
 * @return
 * @throws DOIIdentifierException 
 */
public void reserveDOI(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException ;",0.5300285986653956
52110,"/** 
 * Sends the DELETE-Request to the DOI registry. <p>This method sends a request to ""delete"" a DOI. As DOIs are persistent identifiers they should never be deleted. For example, if you send a HTTP DELETE request to the DataCite Metadata API directly, it will set the DOI to inactive.</p> <p>A DOIConnector does not have to check whether the DOI is reserved, registered or not. It will only send the request and return the answer in form of a boolean weather the deletion was successful or not. It may even throw an DOIIdentifierException in case you are not allowed to delete a DOI, the DOI does not exist, ... So please be sure that the deletion of a DOI is conform with the rules of the registry and that the DOI is in the appropriate state (f.e. reserved but not registered).</p>
 * @param context
 * @param doi
 * @return
 * @throws DOIIdentifierException 
 */
public void deleteDOI(Context context,String doi) throws DOIIdentifierException ;","/** 
 * Sends the DELETE-Request to the DOI registry. <p>This method sends a request to ""delete"" a DOI. As DOIs are persistent identifiers they should never be deleted. For example, if you send a HTTP DELETE request to the DataCite Metadata API directly, it will set the DOI to inactive.</p>
 * @param context
 * @param doi
 * @return
 * @throws DOIIdentifierException 
 */
public void deleteDOI(Context context,String doi) throws DOIIdentifierException ;",0.6476868327402135
52111,"@Override public void registerDOI(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException {
  log.debug(""String_Node_Str"",doi);
  DataCiteResponse resp=null;
  try {
    resp=this.sendDOIPostRequest(doi,HandleManager.resolveToURL(context,dso.getHandle()));
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"" + e.getMessage());
    throw new RuntimeException(e);
  }
switch (resp.statusCode) {
case (201):
{
      return;
    }
case (400):
{
    log.warn(""String_Node_Str"" + ""String_Node_Str"" + resp.getContent());
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.BAD_REQUEST);
  }
case (412):
{
  log.error(""String_Node_Str"" + ""String_Node_Str"",doi,resp.getContent());
  throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",DOIIdentifierException.RESERVE_FIRST);
}
default :
{
log.warn(""String_Node_Str"" + ""String_Node_Str"",new String[]{doi,Integer.toString(resp.statusCode),resp.getContent()});
throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.BAD_ANSWER);
}
}
}","@Override public void registerDOI(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException {
  if (this.isDOIRegistered(context,doi)) {
    if (!this.isDOIRegistered(context,dso,doi)) {
      log.warn(""String_Node_Str"",doi);
      throw new DOIIdentifierException(DOIIdentifierException.DOI_ALREADY_EXISTS);
    }
    return;
  }
 else {
    if (!this.isDOIReserved(context,dso,doi)) {
      if (this.isDOIReserved(context,doi)) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"",doi);
        throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.DOI_ALREADY_EXISTS);
      }
      throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.RESERVE_FIRST);
    }
  }
  DataCiteResponse resp=null;
  try {
    resp=this.sendDOIPostRequest(doi,HandleManager.resolveToURL(context,dso.getHandle()));
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"" + e.getMessage());
    throw new RuntimeException(e);
  }
switch (resp.statusCode) {
case (201):
{
      return;
    }
case (400):
{
    log.warn(""String_Node_Str"" + ""String_Node_Str"" + resp.getContent());
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.BAD_REQUEST);
  }
case (412):
{
  log.error(""String_Node_Str"" + ""String_Node_Str"",doi,resp.getContent());
  throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",DOIIdentifierException.RESERVE_FIRST);
}
default :
{
log.warn(""String_Node_Str"" + ""String_Node_Str"",new String[]{doi,Integer.toString(resp.statusCode),resp.getContent()});
throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.BAD_ANSWER);
}
}
}",0.771680216802168
52112,"@Override public void reserveDOI(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException {
  this.prepareXwalk();
  if (!this.xwalk.canDisseminate(dso)) {
    log.error(""String_Node_Str"" + this.CROSSWALK_NAME + ""String_Node_Str""+ dso.getType()+ ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ doi+ ""String_Node_Str"");
    throw new DOIIdentifierException(""String_Node_Str"" + dso.getTypeText() + ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ this.CROSSWALK_NAME+ ""String_Node_Str"",DOIIdentifierException.CONVERSION_ERROR);
  }
  Element root=null;
  try {
    root=xwalk.disseminateElement(dso);
  }
 catch (  AuthorizeException ae) {
    log.error(""String_Node_Str"" + ""String_Node_Str"" + dso.getType() + ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ doi+ ""String_Node_Str"",ae);
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + dso.getTypeText() + ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ this.CROSSWALK_NAME+ ""String_Node_Str"",ae,DOIIdentifierException.CONVERSION_ERROR);
  }
catch (  CrosswalkException ce) {
    log.error(""String_Node_Str"" + doi + ""String_Node_Str""+ dso.getType()+ ""String_Node_Str""+ dso.getID()+ ""String_Node_Str"",ce);
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + dso.getTypeText() + ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ this.CROSSWALK_NAME+ ""String_Node_Str"",ce,DOIIdentifierException.CONVERSION_ERROR);
  }
catch (  IOException ioe) {
    throw new RuntimeException(ioe);
  }
catch (  SQLException se) {
    throw new RuntimeException(se);
  }
  String metadataDOI=extractDOI(root);
  if (null == metadataDOI) {
    root=addDOI(doi,root);
  }
 else   if (!metadataDOI.equals(doi.substring(DOI.SCHEME.length()))) {
    throw new DOIIdentifierException(""String_Node_Str"" + dso.getTypeText() + ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ metadataDOI+ ""String_Node_Str""+ doi+ ""String_Node_Str"");
  }
  DataCiteResponse resp=this.sendMetadataPostRequest(doi,root);
switch (resp.getStatusCode()) {
case (201):
{
      return;
    }
case (400):
{
    log.warn(""String_Node_Str"");
    log.warn(""String_Node_Str"" + ""String_Node_Str"" + resp.getContent());
    Format format=Format.getCompactFormat();
    format.setEncoding(""String_Node_Str"");
    XMLOutputter xout=new XMLOutputter(format);
    log.info(""String_Node_Str"" + xout.outputString(root));
    throw new DOIIdentifierException(""String_Node_Str"" + doi + ""String_Node_Str""+ ""String_Node_Str"",DOIIdentifierException.BAD_REQUEST);
  }
default :
{
  log.warn(""String_Node_Str"" + ""String_Node_Str"",new String[]{doi,Integer.toString(resp.statusCode),resp.getContent()});
  throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.BAD_ANSWER);
}
}
}","@Override public void reserveDOI(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException {
  if (this.isDOIReserved(context,doi)) {
    if (!this.isDOIReserved(context,dso,doi)) {
      log.warn(""String_Node_Str"",doi);
      throw new DOIIdentifierException(DOIIdentifierException.DOI_ALREADY_EXISTS);
    }
  }
  this.prepareXwalk();
  if (!this.xwalk.canDisseminate(dso)) {
    log.error(""String_Node_Str"" + this.CROSSWALK_NAME + ""String_Node_Str""+ dso.getType()+ ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ doi+ ""String_Node_Str"");
    throw new DOIIdentifierException(""String_Node_Str"" + dso.getTypeText() + ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ this.CROSSWALK_NAME+ ""String_Node_Str"",DOIIdentifierException.CONVERSION_ERROR);
  }
  Element root=null;
  try {
    root=xwalk.disseminateElement(dso);
  }
 catch (  AuthorizeException ae) {
    log.error(""String_Node_Str"" + ""String_Node_Str"" + dso.getType() + ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ doi+ ""String_Node_Str"",ae);
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + dso.getTypeText() + ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ this.CROSSWALK_NAME+ ""String_Node_Str"",ae,DOIIdentifierException.CONVERSION_ERROR);
  }
catch (  CrosswalkException ce) {
    log.error(""String_Node_Str"" + doi + ""String_Node_Str""+ dso.getType()+ ""String_Node_Str""+ dso.getID()+ ""String_Node_Str"",ce);
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + dso.getTypeText() + ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ this.CROSSWALK_NAME+ ""String_Node_Str"",ce,DOIIdentifierException.CONVERSION_ERROR);
  }
catch (  IOException ioe) {
    throw new RuntimeException(ioe);
  }
catch (  SQLException se) {
    throw new RuntimeException(se);
  }
  String metadataDOI=extractDOI(root);
  if (null == metadataDOI) {
    root=addDOI(doi,root);
  }
 else   if (!metadataDOI.equals(doi.substring(DOI.SCHEME.length()))) {
    throw new DOIIdentifierException(""String_Node_Str"" + dso.getTypeText() + ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ metadataDOI+ ""String_Node_Str""+ doi+ ""String_Node_Str"");
  }
  DataCiteResponse resp=this.sendMetadataPostRequest(doi,root);
switch (resp.getStatusCode()) {
case (201):
{
      return;
    }
case (400):
{
    log.warn(""String_Node_Str"");
    log.warn(""String_Node_Str"" + ""String_Node_Str"" + resp.getContent());
    Format format=Format.getCompactFormat();
    format.setEncoding(""String_Node_Str"");
    XMLOutputter xout=new XMLOutputter(format);
    log.info(""String_Node_Str"" + xout.outputString(root));
    throw new DOIIdentifierException(""String_Node_Str"" + doi + ""String_Node_Str""+ ""String_Node_Str"",DOIIdentifierException.BAD_REQUEST);
  }
default :
{
  log.warn(""String_Node_Str"" + ""String_Node_Str"",new String[]{doi,Integer.toString(resp.statusCode),resp.getContent()});
  throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.BAD_ANSWER);
}
}
}",0.9616918010053735
52113,"@Override public void updateMetadata(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException {
  this.reserveDOI(context,dso,doi);
}","@Override public void updateMetadata(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException {
  if (!this.isDOIReserved(context,dso,doi) && this.isDOIReserved(context,doi)) {
    log.warn(""String_Node_Str"" + ""String_Node_Str"",doi);
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.DOI_ALREADY_EXISTS);
  }
  this.reserveDOI(context,dso,doi);
}",0.4795737122557726
52114,"public void registerOnline(Context context,DSpaceObject dso,String identifier) throws IdentifierException, IllegalArgumentException, SQLException {
  String doi=DOI.formatIdentifier(identifier);
  TableRow doiRow=loadOrCreateDOI(context,dso,doi);
  if (DELETED == doiRow.getIntColumn(""String_Node_Str"") || TO_BE_DELETED == doiRow.getIntColumn(""String_Node_Str"")) {
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.DOI_IS_DELETED);
  }
  if (connector.isDOIRegistered(context,doi)) {
    if (!connector.isDOIRegistered(context,dso,doi)) {
      log.warn(""String_Node_Str"",doi);
      throw new DOIIdentifierException(DOIIdentifierException.DOI_ALREADY_EXISTS);
    }
  }
 else {
    if (!connector.isDOIReserved(context,dso,doi)) {
      if (connector.isDOIReserved(context,doi)) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"",doi);
        throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.DOI_ALREADY_EXISTS);
      }
      connector.reserveDOI(context,dso,doi);
    }
    try {
      connector.registerDOI(context,dso,doi);
    }
 catch (    DOIIdentifierException die) {
      if (die.getCode() == DOIIdentifierException.REGISTER_FIRST) {
        this.reserveOnline(context,dso,identifier);
        connector.registerDOI(context,dso,doi);
      }
 else {
        throw die;
      }
    }
  }
  try {
    saveDOIToObject(context,dso,doi);
  }
 catch (  AuthorizeException ae) {
    throw new IdentifierException(""String_Node_Str"",ae);
  }
catch (  SQLException sqle) {
    throw new RuntimeException(sqle);
  }
  doiRow.setColumn(""String_Node_Str"",IS_REGISTERED);
  DatabaseManager.update(context,doiRow);
}","public void registerOnline(Context context,DSpaceObject dso,String identifier) throws IdentifierException, IllegalArgumentException, SQLException {
  String doi=DOI.formatIdentifier(identifier);
  TableRow doiRow=loadOrCreateDOI(context,dso,doi);
  if (DELETED == doiRow.getIntColumn(""String_Node_Str"") || TO_BE_DELETED == doiRow.getIntColumn(""String_Node_Str"")) {
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.DOI_IS_DELETED);
  }
  if (connector.isDOIRegistered(context,doi)) {
    if (!connector.isDOIRegistered(context,dso,doi)) {
      log.warn(""String_Node_Str"",doi);
      throw new DOIIdentifierException(DOIIdentifierException.DOI_ALREADY_EXISTS);
    }
  }
 else {
    if (!connector.isDOIReserved(context,dso,doi)) {
      if (connector.isDOIReserved(context,doi)) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"",doi);
        throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.DOI_ALREADY_EXISTS);
      }
      connector.reserveDOI(context,dso,doi);
    }
    try {
      connector.registerDOI(context,dso,doi);
    }
 catch (    DOIIdentifierException die) {
      if (die.getCode() == DOIIdentifierException.RESERVE_FIRST) {
        this.reserveOnline(context,dso,identifier);
        connector.registerDOI(context,dso,doi);
      }
 else {
        throw die;
      }
    }
  }
  try {
    saveDOIToObject(context,dso,doi);
  }
 catch (  AuthorizeException ae) {
    throw new IdentifierException(""String_Node_Str"",ae);
  }
catch (  SQLException sqle) {
    throw new RuntimeException(sqle);
  }
  doiRow.setColumn(""String_Node_Str"",IS_REGISTERED);
  DatabaseManager.update(context,doiRow);
}",0.9979550102249488
52115,"public static String codeToString(int code){
switch (code) {
case CODE_NOT_SET:
    return ""String_Node_Str"";
case DOI_DOES_NOT_EXIST:
  return ""String_Node_Str"";
case DOI_ALREADY_EXISTS:
return ""String_Node_Str"";
case FOREIGN_DOI:
return ""String_Node_Str"";
case BAD_ANSWER:
return ""String_Node_Str"";
case REGISTER_FIRST:
return ""String_Node_Str"";
case AUTHENTICATION_ERROR:
return ""String_Node_Str"";
case INTERNAL_ERROR:
return ""String_Node_Str"";
case CONVERSION_ERROR:
return ""String_Node_Str"";
case MISMATCH:
return ""String_Node_Str"";
case UNRECOGNIZED:
return ""String_Node_Str"";
case UNAUTHORIZED_METADATA_MANIPULATION:
return ""String_Node_Str"";
case DOI_IS_DELETED:
return ""String_Node_Str"";
default :
return ""String_Node_Str"";
}
}","public static String codeToString(int code){
switch (code) {
case CODE_NOT_SET:
    return ""String_Node_Str"";
case DOI_DOES_NOT_EXIST:
  return ""String_Node_Str"";
case DOI_ALREADY_EXISTS:
return ""String_Node_Str"";
case FOREIGN_DOI:
return ""String_Node_Str"";
case BAD_ANSWER:
return ""String_Node_Str"";
case RESERVE_FIRST:
return ""String_Node_Str"";
case AUTHENTICATION_ERROR:
return ""String_Node_Str"";
case INTERNAL_ERROR:
return ""String_Node_Str"";
case CONVERSION_ERROR:
return ""String_Node_Str"";
case MISMATCH:
return ""String_Node_Str"";
case UNRECOGNIZED:
return ""String_Node_Str"";
case UNAUTHORIZED_METADATA_MANIPULATION:
return ""String_Node_Str"";
case DOI_IS_DELETED:
return ""String_Node_Str"";
default :
return ""String_Node_Str"";
}
}",0.992522093813732
52116,"@Override public void registerDOI(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException {
  log.debug(""String_Node_Str"",doi);
  DataCiteResponse resp=null;
  try {
    resp=this.sendDOIPostRequest(doi,HandleManager.resolveToURL(context,dso.getHandle()));
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"" + e.getMessage());
    throw new RuntimeException(e);
  }
switch (resp.statusCode) {
case (201):
{
      return;
    }
case (400):
{
    log.warn(""String_Node_Str"" + ""String_Node_Str"" + resp.getContent());
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.BAD_REQUEST);
  }
case (412):
{
  log.error(""String_Node_Str"" + ""String_Node_Str"",doi,resp.getContent());
  throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",DOIIdentifierException.REGISTER_FIRST);
}
default :
{
log.warn(""String_Node_Str"" + ""String_Node_Str"",new String[]{doi,Integer.toString(resp.statusCode),resp.getContent()});
throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.BAD_ANSWER);
}
}
}","@Override public void registerDOI(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException {
  log.debug(""String_Node_Str"",doi);
  DataCiteResponse resp=null;
  try {
    resp=this.sendDOIPostRequest(doi,HandleManager.resolveToURL(context,dso.getHandle()));
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"" + e.getMessage());
    throw new RuntimeException(e);
  }
switch (resp.statusCode) {
case (201):
{
      return;
    }
case (400):
{
    log.warn(""String_Node_Str"" + ""String_Node_Str"" + resp.getContent());
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.BAD_REQUEST);
  }
case (412):
{
  log.error(""String_Node_Str"" + ""String_Node_Str"",doi,resp.getContent());
  throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",DOIIdentifierException.RESERVE_FIRST);
}
default :
{
log.warn(""String_Node_Str"" + ""String_Node_Str"",new String[]{doi,Integer.toString(resp.statusCode),resp.getContent()});
throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.BAD_ANSWER);
}
}
}",0.9969995713673382
52117,"@Override @Mock public void registerDOI(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException {
  if (!reserved.containsKey(doi)) {
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.REGISTER_FIRST);
  }
  if (reserved.get(doi).intValue() != dso.getID()) {
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.MISMATCH);
  }
  if (registered.containsKey(doi)) {
    if (registered.get(doi).intValue() == dso.getID()) {
      return;
    }
 else {
      throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.MISMATCH);
    }
  }
  registered.put(doi,new Integer(dso.getID()));
}","@Override @Mock public void registerDOI(Context context,DSpaceObject dso,String doi) throws DOIIdentifierException {
  if (!reserved.containsKey(doi)) {
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.RESERVE_FIRST);
  }
  if (reserved.get(doi).intValue() != dso.getID()) {
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.MISMATCH);
  }
  if (registered.containsKey(doi)) {
    if (registered.get(doi).intValue() == dso.getID()) {
      return;
    }
 else {
      throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.MISMATCH);
    }
  }
  registered.put(doi,new Integer(dso.getID()));
}",0.9952021932830706
52118,"@Override public RecordSet getRecords(DataLoadingSpec spec) throws MalformedSourceException {
  return getRecords();
}","@Override public RecordSet getRecords(DataLoadingSpec spec) throws MalformedSourceException {
  if (spec.getOffset() > 0) {
    return new RecordSet();
  }
  return getRecords();
}",0.7919463087248322
52119,"@Override public RecordSet getRecords(DataLoadingSpec spec) throws MalformedSourceException {
  return getRecords();
}","@Override public RecordSet getRecords(DataLoadingSpec spec) throws MalformedSourceException {
  if (spec.getOffset() > 0) {
    return new RecordSet();
  }
  return getRecords();
}",0.7919463087248322
52120,"@Override public RecordSet getRecords(DataLoadingSpec spec) throws MalformedSourceException {
  return getRecords();
}","@Override public RecordSet getRecords(DataLoadingSpec spec) throws MalformedSourceException {
  if (spec.getOffset() > 0) {
    return new RecordSet();
  }
  return getRecords();
}",0.7919463087248322
52121,"/** 
 * Respond to a post request for metadata bulk importing via csv
 * @param context a DSpace Context object
 * @param request the HTTP request
 * @param response the HTTP response
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String contentType=request.getContentType();
  if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
    String message=null;
    try {
      FileUploadRequest wrapper=new FileUploadRequest(request);
      File f=wrapper.getFile(""String_Node_Str"");
      int colId=Integer.parseInt(wrapper.getParameter(""String_Node_Str""));
      Collection collection=Collection.find(context,colId);
      String inputType=wrapper.getParameter(""String_Node_Str"");
      try {
        ItemImport.processUploadableImport(f,new Collection[]{collection},inputType,context);
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
 catch (      Exception e) {
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        message=e.getMessage();
        e.printStackTrace();
      }
    }
 catch (    FileSizeLimitExceededException e) {
      request.setAttribute(""String_Node_Str"",""String_Node_Str"");
      message=e.getMessage();
      e.printStackTrace();
    }
catch (    Exception e) {
      request.setAttribute(""String_Node_Str"",""String_Node_Str"");
      message=e.getMessage();
      e.printStackTrace();
    }
    DataLoaderService dls=new DSpace().getSingletonService(DataLoaderService.class);
    List<String> inputTypes=Lists.newArrayList(dls.getDataLoaders().keySet());
    request.setAttribute(""String_Node_Str"",inputTypes);
    List<Collection> collections=null;
    String colIdS=request.getParameter(""String_Node_Str"");
    if (colIdS != null) {
      collections=new ArrayList<Collection>();
      collections.add(Collection.find(context,Integer.parseInt(colIdS)));
    }
 else {
      collections=Arrays.asList(Collection.findAll(context));
    }
    request.setAttribute(""String_Node_Str"",collections);
    request.setAttribute(""String_Node_Str"",message);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}","/** 
 * Respond to a post request for metadata bulk importing via csv
 * @param context a DSpace Context object
 * @param request the HTTP request
 * @param response the HTTP response
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String contentType=request.getContentType();
  if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
    String message=null;
    try {
      FileUploadRequest wrapper=new FileUploadRequest(request);
      File f=wrapper.getFile(""String_Node_Str"");
      int colId=Integer.parseInt(wrapper.getParameter(""String_Node_Str""));
      Collection collection=Collection.find(context,colId);
      String inputType=wrapper.getParameter(""String_Node_Str"");
      try {
        ItemImport.processUploadableImport(f,new Collection[]{collection},inputType,context);
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
 catch (      Exception e) {
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        message=e.getMessage();
        e.printStackTrace();
      }
    }
 catch (    FileSizeLimitExceededException e) {
      request.setAttribute(""String_Node_Str"",""String_Node_Str"");
      message=e.getMessage();
      e.printStackTrace();
    }
catch (    Exception e) {
      request.setAttribute(""String_Node_Str"",""String_Node_Str"");
      message=e.getMessage();
      e.printStackTrace();
    }
    BTEBatchImportService dls=new DSpace().getSingletonService(BTEBatchImportService.class);
    List<String> inputTypes=Lists.newArrayList(dls.getDataLoaders().keySet());
    request.setAttribute(""String_Node_Str"",inputTypes);
    List<Collection> collections=null;
    String colIdS=request.getParameter(""String_Node_Str"");
    if (colIdS != null) {
      collections=new ArrayList<Collection>();
      collections.add(Collection.find(context,Integer.parseInt(colIdS)));
    }
 else {
      collections=Arrays.asList(Collection.findAll(context));
    }
    request.setAttribute(""String_Node_Str"",collections);
    request.setAttribute(""String_Node_Str"",message);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}",0.9754131398629584
52122,"/** 
 * GET request is only ever used to show the upload form
 * @param context a DSpace Context object
 * @param request the HTTP request
 * @param response the HTTP response
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  DataLoaderService dls=new DSpace().getSingletonService(DataLoaderService.class);
  List<String> inputTypes=Lists.newArrayList(dls.getDataLoaders().keySet());
  request.setAttribute(""String_Node_Str"",inputTypes);
  List<Collection> collections=null;
  String colIdS=request.getParameter(""String_Node_Str"");
  if (colIdS != null) {
    collections=new ArrayList<Collection>();
    collections.add(Collection.find(context,Integer.parseInt(colIdS)));
  }
 else {
    collections=Arrays.asList(Collection.findAll(context));
  }
  request.setAttribute(""String_Node_Str"",collections);
  JSPManager.showJSP(request,response,""String_Node_Str"");
}","/** 
 * GET request is only ever used to show the upload form
 * @param context a DSpace Context object
 * @param request the HTTP request
 * @param response the HTTP response
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  BTEBatchImportService dls=new DSpace().getSingletonService(BTEBatchImportService.class);
  List<String> inputTypes=Lists.newArrayList(dls.getDataLoaders().keySet());
  request.setAttribute(""String_Node_Str"",inputTypes);
  List<Collection> collections=null;
  String colIdS=request.getParameter(""String_Node_Str"");
  if (colIdS != null) {
    collections=new ArrayList<Collection>();
    collections.add(Collection.find(context,Integer.parseInt(colIdS)));
  }
 else {
    collections=Arrays.asList(Collection.findAll(context));
  }
  request.setAttribute(""String_Node_Str"",collections);
  JSPManager.showJSP(request,response,""String_Node_Str"");
}",0.944393801276208
52123,"@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public org.dspace.rest.common.Collection[] list(@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset){
  try {
    if (context == null || !context.isValid()) {
      context=new org.dspace.core.Context();
      context.getDBConnection().setAutoCommit(true);
    }
    org.dspace.content.Collection[] collections;
    if (limit != null && limit >= 0 && offset != null && offset != 0) {
      collections=org.dspace.content.Collection.findAll(context,limit,offset);
    }
 else {
      collections=org.dspace.content.Collection.findAll(context);
    }
    ArrayList<org.dspace.rest.common.Collection> collectionArrayList=new ArrayList<org.dspace.rest.common.Collection>();
    for (    org.dspace.content.Collection collection : collections) {
      if (AuthorizeManager.authorizeActionBoolean(context,collection,org.dspace.core.Constants.READ)) {
        org.dspace.rest.common.Collection restCollection=new org.dspace.rest.common.Collection(collection,expand,context,limit,offset);
        collectionArrayList.add(restCollection);
      }
    }
    return collectionArrayList.toArray(new org.dspace.rest.common.Collection[0]);
  }
 catch (  SQLException e) {
    log.error(e.getMessage());
    throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);
  }
}","@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public org.dspace.rest.common.Collection[] list(@QueryParam(""String_Node_Str"") String expand,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer limit,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") Integer offset){
  try {
    if (context == null || !context.isValid()) {
      context=new org.dspace.core.Context();
      context.getDBConnection().setAutoCommit(true);
    }
    org.dspace.content.Collection[] collections;
    if (limit != null && limit >= 0 && offset != null && offset >= 0) {
      collections=org.dspace.content.Collection.findAll(context,limit,offset);
    }
 else {
      collections=org.dspace.content.Collection.findAll(context);
    }
    ArrayList<org.dspace.rest.common.Collection> collectionArrayList=new ArrayList<org.dspace.rest.common.Collection>();
    for (    org.dspace.content.Collection collection : collections) {
      if (AuthorizeManager.authorizeActionBoolean(context,collection,org.dspace.core.Constants.READ)) {
        org.dspace.rest.common.Collection restCollection=new org.dspace.rest.common.Collection(collection,expand,context,limit,offset);
        collectionArrayList.add(restCollection);
      }
    }
    return collectionArrayList.toArray(new org.dspace.rest.common.Collection[0]);
  }
 catch (  SQLException e) {
    log.error(e.getMessage());
    throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);
  }
}",0.9993412384716732
52124,"@Override public RecordSet getRecords(DataLoadingSpec arg0) throws MalformedSourceException {
  return getRecords();
}","@Override public RecordSet getRecords(DataLoadingSpec loadingSpec) throws MalformedSourceException {
  if (loadingSpec.getOffset() > 0)   return new RecordSet();
  return getRecords();
}",0.7631578947368421
52125,"@Override public List<Record> getByIdentifier(Context context,Map<String,Set<String>> keys) throws HttpException, IOException {
  Set<String> pmids=keys != null ? keys.get(PUBMED) : null;
  Set<String> dois=keys != null ? keys.get(DOI) : null;
  List<Record> results=new ArrayList<Record>();
  if (pmids != null && pmids.size() > 0 && dois == null) {
    for (    String pmid : pmids) {
      PubmedItem p=null;
      try {
        p=pubmedService.getByPubmedID(pmid);
      }
 catch (      Exception e) {
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + pmid),e);
      }
      if (p != null)       results.add(convert(p));
    }
  }
 else   if (dois != null && dois.size() > 0 && pmids == null) {
    StringBuffer query=new StringBuffer();
    for (    String d : dois) {
      if (query.length() > 0) {
        query.append(""String_Node_Str"");
      }
      query.append(d).append(""String_Node_Str"");
    }
    List<PubmedItem> pubmedResults=pubmedService.search(query.toString());
    for (    PubmedItem p : pubmedResults) {
      results.add(convert(p));
    }
  }
 else {
    List<PubmedItem> pubmedResults=pubmedService.search(dois.iterator().next(),pmids.iterator().next());
    if (pubmedResults != null) {
      for (      PubmedItem p : pubmedResults) {
        results.add(convert(p));
      }
    }
  }
  return results;
}","@Override public List<Record> getByIdentifier(Context context,Map<String,Set<String>> keys) throws HttpException, IOException {
  Set<String> pmids=keys != null ? keys.get(PUBMED) : null;
  Set<String> dois=keys != null ? keys.get(DOI) : null;
  List<Record> results=new ArrayList<Record>();
  if (pmids != null && pmids.size() > 0 && (dois == null || dois.size() == 0)) {
    for (    String pmid : pmids) {
      PubmedItem p=null;
      try {
        p=pubmedService.getByPubmedID(pmid);
      }
 catch (      Exception e) {
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + pmid),e);
      }
      if (p != null)       results.add(convert(p));
    }
  }
 else   if (dois != null && dois.size() > 0 && (pmids == null || pmids.size() == 0)) {
    StringBuffer query=new StringBuffer();
    for (    String d : dois) {
      if (query.length() > 0) {
        query.append(""String_Node_Str"");
      }
      query.append(d).append(""String_Node_Str"");
    }
    List<PubmedItem> pubmedResults=pubmedService.search(query.toString());
    for (    PubmedItem p : pubmedResults) {
      results.add(convert(p));
    }
  }
 else   if (dois != null && dois.size() > 0 && pmids != null && pmids.size() > 0) {
    List<PubmedItem> pubmedResults=pubmedService.search(dois.iterator().next(),pmids.iterator().next());
    if (pubmedResults != null) {
      for (      PubmedItem p : pubmedResults) {
        results.add(convert(p));
      }
    }
  }
  return results;
}",0.9403141361256544
52126,"public void setTransformationEngine(TransformationEngine transformationEngine){
  this.transformationEngine=transformationEngine;
  MultipleSubmissionLookupDataLoader dataLoader=(MultipleSubmissionLookupDataLoader)transformationEngine.getDataLoader();
  this.idents2provs=new HashMap<String,List<SubmissionLookupProvider>>();
  this.searchProviders=new ArrayList<SubmissionLookupProvider>();
  if (providers != null) {
    this.providers=new ArrayList<SubmissionLookupProvider>();
    for (    SubmissionLookupProvider p : dataLoader.getProviders()) {
      this.providers.add(p);
      if (p.isSearchProvider()) {
        searchProviders.add(p);
      }
      List<String> suppIdentifiers=p.getSupportedIdentifiers();
      if (suppIdentifiers != null) {
        for (        String ident : suppIdentifiers) {
          List<SubmissionLookupProvider> tmp=idents2provs.get(ident);
          if (tmp == null) {
            tmp=new ArrayList<SubmissionLookupProvider>();
            idents2provs.put(ident,tmp);
          }
          tmp.add(p);
        }
      }
    }
  }
}","public void setTransformationEngine(TransformationEngine transformationEngine){
  this.transformationEngine=transformationEngine;
  MultipleSubmissionLookupDataLoader dataLoader=(MultipleSubmissionLookupDataLoader)transformationEngine.getDataLoader();
  this.idents2provs=new HashMap<String,List<SubmissionLookupProvider>>();
  this.searchProviders=new ArrayList<SubmissionLookupProvider>();
  if (providers == null) {
    this.providers=new ArrayList<SubmissionLookupProvider>();
    for (    SubmissionLookupProvider p : dataLoader.getProviders()) {
      this.providers.add(p);
      if (p.isSearchProvider()) {
        searchProviders.add(p);
      }
      List<String> suppIdentifiers=p.getSupportedIdentifiers();
      if (suppIdentifiers != null) {
        for (        String ident : suppIdentifiers) {
          List<SubmissionLookupProvider> tmp=idents2provs.get(ident);
          if (tmp == null) {
            tmp=new ArrayList<SubmissionLookupProvider>();
            idents2provs.put(ident,tmp);
          }
          tmp.add(p);
        }
      }
    }
  }
}",0.9990680335507922
52127,"@Override public List<Value> getValues(String md){
  if (enhancedMetadata != null && enhancedMetadata.keySet().contains(md)) {
    if (cacheEnhanched != null && cacheEnhanched.keySet().contains(md)) {
      List<Value> values=new ArrayList<Value>();
      for (      String s : cacheEnhanched.get(md)) {
        values.add(new StringValue(s));
      }
      return values;
    }
 else {
      EnhancerSubmissionLookup enhancer=enhancedMetadata.get(md);
      List<String> values=enhancer.getValues(this);
      List<Value> valuesvalues=new ArrayList<Value>();
      for (      String s : values) {
        valuesvalues.add(new StringValue(s));
      }
      cacheEnhanched.put(md,values);
      return valuesvalues;
    }
  }
 else {
    return lookupPublication.getValues(md);
  }
}","@Override public List<Value> getValues(String md){
  if (enhancedMetadata != null && enhancedMetadata.keySet().contains(md)) {
    if (cacheEnhanched != null && cacheEnhanched.keySet().contains(md)) {
      List<Value> values=new ArrayList<Value>();
      for (      String s : cacheEnhanched.get(md)) {
        values.add(new StringValue(s));
      }
      return values;
    }
 else {
      EnhancerSubmissionLookup enhancer=enhancedMetadata.get(md);
      List<String> values=enhancer.getValues(this);
      if (values != null && values.size() > 0) {
        List<Value> valuesvalues=new ArrayList<Value>();
        for (        String s : values) {
          valuesvalues.add(new StringValue(s));
        }
        cacheEnhanched.put(md,values);
        return valuesvalues;
      }
    }
    return null;
  }
 else {
    return lookupPublication.getValues(md);
  }
}",0.9214026602176542
52128,"@Override public List<Value> getValues(String md){
  List<String> stringValues=storage.get(md);
  List<Value> values=new ArrayList<Value>();
  for (  String value : stringValues) {
    values.add(new StringValue(value));
  }
  return values;
}","@Override public List<Value> getValues(String md){
  List<String> stringValues=storage.get(md);
  if (stringValues == null) {
    return null;
  }
  List<Value> values=new ArrayList<Value>();
  for (  String value : stringValues) {
    values.add(new StringValue(value));
  }
  return values;
}",0.905027932960894
52129,"private String getMetadata(String formName,Record itemLookup,String name){
  String type=SubmissionLookupService.getType(itemLookup);
  String md=outputMap.get(name);
  if (md != null && md.contains(""String_Node_Str"")) {
    String[] cond=md.trim().split(""String_Node_Str"");
    for (int idx=1; idx < cond.length; idx++) {
      boolean temp=itemLookup.getFields().contains(cond[idx]);
      if (temp) {
        return null;
      }
    }
    return cond[0];
  }
  return md;
}","private String getMetadata(String formName,Record itemLookup,String name){
  String type=SubmissionLookupService.getType(itemLookup);
  String md=outputMap.get(type + ""String_Node_Str"" + name);
  if (StringUtils.isBlank(md)) {
    md=outputMap.get(formName + ""String_Node_Str"" + name);
    if (StringUtils.isBlank(md)) {
      md=outputMap.get(name);
    }
  }
  if (md != null && md.contains(""String_Node_Str"")) {
    String[] cond=md.trim().split(""String_Node_Str"");
    for (int idx=1; idx < cond.length; idx++) {
      boolean temp=itemLookup.getFields().contains(cond[idx]);
      if (temp) {
        return null;
      }
    }
    return cond[0];
  }
  return md;
}",0.8205574912891986
52130,"private boolean isValidMetadata(String formName,String[] md){
  try {
    return getDCInput(formName,md[0],md[1],md[2]) != null;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return false;
}","private boolean isValidMetadata(String formName,String[] md){
  try {
    if (extraMetadataToKeep != null && extraMetadataToKeep.contains(StringUtils.join(Arrays.copyOfRange(md,0,3),""String_Node_Str""))) {
      return true;
    }
    return getDCInput(formName,md[0],md[1],md[2]) != null;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return false;
}",0.7183098591549296
52131,"@Override public Record modify(MutableRecord rec){
  for (  String target_field : merge_field_map.keySet()) {
    List<String> source_fields=merge_field_map.get(target_field);
    for (    String source_field : source_fields) {
      List<Value> values=rec.getValues(source_field);
      for (      Value value : values) {
        rec.addValue(target_field,value);
      }
      rec.removeField(source_field);
    }
  }
  return rec;
}","@Override public Record modify(MutableRecord rec){
  if (merge_field_map != null) {
    for (    String target_field : merge_field_map.keySet()) {
      List<String> source_fields=merge_field_map.get(target_field);
      for (      String source_field : source_fields) {
        List<Value> values=rec.getValues(source_field);
        if (values != null && values.size() > 0) {
          for (          Value value : values) {
            rec.addValue(target_field,value);
          }
        }
        rec.removeField(source_field);
      }
    }
  }
  return rec;
}",0.8383233532934131
52132,"/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  int id=Util.getIntParameter(request,""String_Node_Str"");
  String titolo=request.getParameter(""String_Node_Str"");
  String date=request.getParameter(""String_Node_Str"");
  String autori=request.getParameter(""String_Node_Str"");
  String uuidSubmission=request.getParameter(""String_Node_Str"");
  String uuidLookup=request.getParameter(""String_Node_Str"");
  if (StringUtils.isBlank(uuidSubmission)) {
    return STATUS_NO_SUUID;
  }
  SubmissionLookupDTO submissionDTO=slService.getSubmissionLookupDTO(request,uuidSubmission);
  if (submissionDTO == null) {
    return STATUS_SUBMISSION_EXPIRED;
  }
  ItemSubmissionLookupDTO itemLookup=null;
  if (StringUtils.isNotBlank(uuidLookup)) {
    itemLookup=submissionDTO.getLookupItem(uuidLookup);
    if (itemLookup == null) {
      return STATUS_SUBMISSION_EXPIRED;
    }
  }
  if (id < 0) {
    return STATUS_NO_COLLECTION;
  }
  Collection col=Collection.find(context,id);
  if (col == null) {
    return STATUS_INVALID_COLLECTION;
  }
 else {
    DCInputSet inputSet=null;
    try {
      inputSet=new DCInputsReader().getInputs(col.getHandle());
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    ItemSubmissionLookupDTO dto=null;
    if (itemLookup != null) {
      dto=itemLookup;
    }
 else {
      SubmissionLookupPublication manualPub=new SubmissionLookupPublication(SubmissionLookupService.MANUAL_USER_INPUT);
      manualPub.add(""String_Node_Str"",titolo);
      manualPub.add(""String_Node_Str"",date);
      manualPub.add(""String_Node_Str"",autori);
      Enumeration e=request.getParameterNames();
      while (e.hasMoreElements()) {
        String parameterName=(String)e.nextElement();
        String parameterValue=request.getParameter(parameterName);
        if (parameterName.startsWith(""String_Node_Str"") && StringUtils.isNotBlank(parameterValue)) {
          manualPub.add(parameterName.substring(""String_Node_Str"".length()),parameterValue);
        }
      }
      List<Record> publications=new ArrayList<Record>();
      publications.add(manualPub);
      dto=new ItemSubmissionLookupDTO(publications);
    }
    List<WorkspaceItem> result=null;
    TransformationEngine transformationEngine=slService.getPhase2TransformationEngine();
    if (transformationEngine != null) {
      SubmissionItemDataLoader dataLoader=(SubmissionItemDataLoader)transformationEngine.getDataLoader();
      dataLoader.setDtoList(Arrays.asList(new ItemSubmissionLookupDTO[]{dto}));
      DSpaceWorkspaceItemOutputGenerator outputGenerator=(DSpaceWorkspaceItemOutputGenerator)transformationEngine.getOutputGenerator();
      result=outputGenerator.getWitems();
      try {
        transformationEngine.transform(new TransformationSpec());
      }
 catch (      BadTransformationSpec e1) {
        e1.printStackTrace();
      }
catch (      MalformedSourceException e1) {
        e1.printStackTrace();
      }
    }
    if (result != null && result.size() > 0) {
      subInfo.setSubmissionItem(result.iterator().next());
    }
    context.commit();
    subInfo.reloadSubmissionConfig(request);
  }
  slService.invalidateDTOs(request,uuidSubmission);
  return STATUS_COMPLETE;
}","/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  int id=Util.getIntParameter(request,""String_Node_Str"");
  String titolo=request.getParameter(""String_Node_Str"");
  String date=request.getParameter(""String_Node_Str"");
  String autori=request.getParameter(""String_Node_Str"");
  String uuidSubmission=request.getParameter(""String_Node_Str"");
  String uuidLookup=request.getParameter(""String_Node_Str"");
  if (StringUtils.isBlank(uuidSubmission)) {
    return STATUS_NO_SUUID;
  }
  SubmissionLookupDTO submissionDTO=slService.getSubmissionLookupDTO(request,uuidSubmission);
  if (submissionDTO == null) {
    return STATUS_SUBMISSION_EXPIRED;
  }
  ItemSubmissionLookupDTO itemLookup=null;
  if (StringUtils.isNotBlank(uuidLookup)) {
    itemLookup=submissionDTO.getLookupItem(uuidLookup);
    if (itemLookup == null) {
      return STATUS_SUBMISSION_EXPIRED;
    }
  }
  if (id < 0) {
    return STATUS_NO_COLLECTION;
  }
  Collection col=Collection.find(context,id);
  if (col == null) {
    return STATUS_INVALID_COLLECTION;
  }
 else {
    DCInputSet inputSet=null;
    try {
      inputSet=new DCInputsReader().getInputs(col.getHandle());
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    ItemSubmissionLookupDTO dto=null;
    if (itemLookup != null) {
      dto=itemLookup;
    }
 else {
      SubmissionLookupPublication manualPub=new SubmissionLookupPublication(SubmissionLookupService.MANUAL_USER_INPUT);
      manualPub.add(""String_Node_Str"",titolo);
      manualPub.add(""String_Node_Str"",date);
      manualPub.add(""String_Node_Str"",autori);
      Enumeration e=request.getParameterNames();
      while (e.hasMoreElements()) {
        String parameterName=(String)e.nextElement();
        String parameterValue=request.getParameter(parameterName);
        if (parameterName.startsWith(""String_Node_Str"") && StringUtils.isNotBlank(parameterValue)) {
          manualPub.add(parameterName.substring(""String_Node_Str"".length()),parameterValue);
        }
      }
      List<Record> publications=new ArrayList<Record>();
      publications.add(manualPub);
      dto=new ItemSubmissionLookupDTO(publications);
    }
    List<WorkspaceItem> result=null;
    TransformationEngine transformationEngine=slService.getPhase2TransformationEngine();
    if (transformationEngine != null) {
      SubmissionItemDataLoader dataLoader=(SubmissionItemDataLoader)transformationEngine.getDataLoader();
      dataLoader.setDtoList(Arrays.asList(new ItemSubmissionLookupDTO[]{dto}));
      DSpaceWorkspaceItemOutputGenerator outputGenerator=(DSpaceWorkspaceItemOutputGenerator)transformationEngine.getOutputGenerator();
      outputGenerator.setCollection(col);
      outputGenerator.setContext(context);
      outputGenerator.setFormName(inputSet.getFormName());
      outputGenerator.setDto(dto);
      try {
        transformationEngine.transform(new TransformationSpec());
        result=outputGenerator.getWitems();
      }
 catch (      BadTransformationSpec e1) {
        e1.printStackTrace();
      }
catch (      MalformedSourceException e1) {
        e1.printStackTrace();
      }
    }
    if (result != null && result.size() > 0) {
      subInfo.setSubmissionItem(result.iterator().next());
    }
    context.commit();
    subInfo.reloadSubmissionConfig(request);
  }
  slService.invalidateDTOs(request,uuidSubmission);
  return STATUS_COMPLETE;
}",0.96004742145821
52133,"@Override public Record modify(MutableRecord record){
  if (mapConfig != null && fieldKeys != null) {
    for (    String key : fieldKeys) {
      List<Value> values=record.getValues(key);
      List<Value> newValues=new ArrayList<Value>();
      for (      Value value : values) {
        String stringValue=value.getAsString();
        String tmp=""String_Node_Str"";
        if (mapConfig.containsKey(stringValue)) {
          tmp=mapConfig.getProperty(stringValue,mapConfig.getProperty(""String_Node_Str""));
        }
 else {
          tmp=mapConfig.getProperty(""String_Node_Str"");
          for (          String regex : regexConfig.keySet()) {
            if (stringValue != null && stringValue.matches(regex)) {
              tmp=stringValue.replaceAll(regex,regexConfig.get(regex));
            }
          }
        }
        if (""String_Node_Str"".equals(tmp)) {
          newValues.add(new StringValue(stringValue));
        }
 else         if (StringUtils.isNotBlank(tmp)) {
          newValues.add(new StringValue(tmp));
        }
 else         newValues.add(new StringValue(stringValue));
      }
      record.updateField(key,newValues);
    }
  }
  return record;
}","@Override public Record modify(MutableRecord record){
  if (mapping != null && fieldKeys != null) {
    for (    String key : fieldKeys) {
      List<Value> values=record.getValues(key);
      if (values == null)       continue;
      List<Value> newValues=new ArrayList<Value>();
      for (      Value value : values) {
        String stringValue=value.getAsString();
        String tmp=""String_Node_Str"";
        if (mapping.containsKey(stringValue)) {
          tmp=mapping.get(stringValue);
        }
 else {
          tmp=defaultValue;
          for (          String regex : regexConfig.keySet()) {
            if (stringValue != null && stringValue.matches(regex)) {
              tmp=stringValue.replaceAll(regex,regexConfig.get(regex));
            }
          }
        }
        if (""String_Node_Str"".equals(tmp)) {
          newValues.add(new StringValue(stringValue));
        }
 else         if (StringUtils.isNotBlank(tmp)) {
          newValues.add(new StringValue(tmp));
        }
 else         newValues.add(new StringValue(stringValue));
      }
      record.updateField(key,newValues);
    }
  }
  return record;
}",0.6793595845954132
52134,"public void merge(String formName,Item item,Record record){
  Record itemLookup=record;
  Set<String> addedMetadata=new HashSet<String>();
  for (  String field : itemLookup.getFields()) {
    String metadata=getMetadata(formName,itemLookup,field);
    if (StringUtils.isBlank(metadata)) {
      continue;
    }
    if (item.getMetadata(metadata).length == 0 || addedMetadata.contains(metadata)) {
      addedMetadata.add(metadata);
      String[] md=splitMetadata(metadata);
      if (isValidMetadata(formName,md)) {
        List<Value> values=itemLookup.getValues(field);
        if (values != null && values.size() > 0) {
          if (isRepeatableMetadata(formName,md)) {
            for (            Value value : values) {
              String[] splitValue=splitValue(value.getAsString());
              if (splitValue[3] != null) {
                item.addMetadata(md[0],md[1],md[2],md[3],splitValue[0],splitValue[1],Integer.parseInt(splitValue[2]));
              }
 else {
                item.addMetadata(md[0],md[1],md[2],md[3],value.getAsString());
              }
            }
          }
 else {
            String value=values.iterator().next().getAsString();
            String[] splitValue=splitValue(value);
            if (splitValue[3] != null) {
              item.addMetadata(md[0],md[1],md[2],md[3],splitValue[0],splitValue[1],Integer.parseInt(splitValue[2]));
            }
 else {
              item.addMetadata(md[0],md[1],md[2],md[3],value);
            }
          }
        }
      }
    }
  }
  Context context=null;
  try {
    context=new Context();
    for (    Record pub : dto.getPublications()) {
      String providerName=SubmissionLookupService.getProviderName(pub);
      if (providerName != SubmissionLookupService.MANUAL_USER_INPUT) {
        for (        String field : pub.getFields()) {
          String metadata=getMetadata(formName,pub,field);
          if (StringUtils.isBlank(metadata)) {
            continue;
          }
          String[] md=splitMetadata(metadata);
          if (isValidMetadata(formName,md)) {
            makeSureMetadataExist(context,providerName,md[1],md[2]);
            if (isRepeatableMetadata(formName,md)) {
              for (              Value value : pub.getValues(field)) {
                String[] splitValue=splitValue(value.getAsString());
                item.addMetadata(providerName,md[1],md[2],md[3],splitValue[0],splitValue[1],Integer.parseInt(splitValue[2]));
              }
            }
 else {
              String[] splitValue=splitValue(SubmissionLookupService.getFirstValue(pub,field));
              item.addMetadata(providerName,md[1],md[2],md[3],splitValue[0],splitValue[1],Integer.parseInt(splitValue[2]));
            }
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e.getMessage(),e);
  }
 finally {
    if (context != null && context.isValid()) {
      context.abort();
    }
  }
}","public void merge(String formName,Item item,Record record){
  Record itemLookup=record;
  Set<String> addedMetadata=new HashSet<String>();
  for (  String field : itemLookup.getFields()) {
    String metadata=getMetadata(formName,itemLookup,field);
    if (StringUtils.isBlank(metadata)) {
      continue;
    }
    if (item.getMetadata(metadata).length == 0 || addedMetadata.contains(metadata)) {
      addedMetadata.add(metadata);
      String[] md=splitMetadata(metadata);
      if (isValidMetadata(formName,md)) {
        List<Value> values=itemLookup.getValues(field);
        if (values != null && values.size() > 0) {
          if (isRepeatableMetadata(formName,md)) {
            for (            Value value : values) {
              String[] splitValue=splitValue(value.getAsString());
              if (splitValue[3] != null) {
                item.addMetadata(md[0],md[1],md[2],md[3],splitValue[0],splitValue[1],Integer.parseInt(splitValue[2]));
              }
 else {
                item.addMetadata(md[0],md[1],md[2],md[3],value.getAsString());
              }
            }
          }
 else {
            String value=values.iterator().next().getAsString();
            String[] splitValue=splitValue(value);
            if (splitValue[3] != null) {
              item.addMetadata(md[0],md[1],md[2],md[3],splitValue[0],splitValue[1],Integer.parseInt(splitValue[2]));
            }
 else {
              item.addMetadata(md[0],md[1],md[2],md[3],value);
            }
          }
        }
      }
    }
  }
  Context context=null;
  try {
    context=new Context();
    for (    Record pub : dto.getPublications()) {
      String providerName=SubmissionLookupService.getProviderName(pub);
      if (providerName != SubmissionLookupService.MANUAL_USER_INPUT) {
        for (        String field : pub.getFields()) {
          String metadata=getMetadata(formName,pub,field);
          if (StringUtils.isBlank(metadata)) {
            continue;
          }
          String[] md=splitMetadata(metadata);
          if (isValidMetadata(formName,md)) {
            makeSureMetadataExist(context,providerName,md[1],md[2]);
            if (isRepeatableMetadata(formName,md)) {
              for (              Value value : pub.getValues(field)) {
                String[] splitValue=splitValue(value.getAsString());
                item.addMetadata(providerName,md[1],md[2],md[3],splitValue[0],splitValue[1],Integer.parseInt(splitValue[2]));
              }
            }
 else {
              String[] splitValue=splitValue(SubmissionLookupUtils.getFirstValue(pub,field));
              item.addMetadata(providerName,md[1],md[2],md[3],splitValue[0],splitValue[1],Integer.parseInt(splitValue[2]));
            }
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e.getMessage(),e);
  }
 finally {
    if (context != null && context.isValid()) {
      context.abort();
    }
  }
}",0.9979564032697548
52135,"public static String getProviderName(Record rec){
  return getFirstValue(rec,SubmissionLookupService.PROVIDER_NAME_FIELD);
}","public static String getProviderName(Record rec){
  return SubmissionLookupUtils.getFirstValue(rec,SubmissionLookupService.PROVIDER_NAME_FIELD);
}",0.9185185185185184
52136,"public static String getType(Record rec){
  return getFirstValue(rec,SubmissionLookupProvider.TYPE);
}","public static String getType(Record rec){
  return SubmissionLookupUtils.getFirstValue(rec,SubmissionLookupProvider.TYPE);
}",0.9026548672566372
52137,"public Record convert(String shortName,Object bean) throws SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  Record publication=new SubmissionLookupPublication(shortName);
  Field[] fields=bean.getClass().getDeclaredFields();
  for (  Field field : fields) {
    if (field.getType() == String.class) {
      Method getter=bean.getClass().getMethod(""String_Node_Str"" + field.getName().substring(0,1).toUpperCase() + field.getName().substring(1));
      String value=(String)getter.invoke(bean);
      addMetadata(shortName,publication,field.getName(),value);
    }
 else     if (field.getType() == List.class) {
      ParameterizedType pt=(ParameterizedType)field.getGenericType();
      Method getter=bean.getClass().getMethod(""String_Node_Str"" + field.getName().substring(0,1).toUpperCase() + field.getName().substring(1));
      ParameterizedType stringListType=(ParameterizedType)field.getGenericType();
      Class<?> stringListClass=(Class<?>)stringListType.getActualTypeArguments()[0];
      if (String.class.isAssignableFrom(stringListClass)) {
        List<String> values=(List<String>)getter.invoke(bean);
        if (values != null) {
          for (          String value : values) {
            addMetadata(shortName,publication,field.getName(),value);
          }
        }
      }
 else {
        List<String[]> values=(List<String[]>)getter.invoke(bean);
        if (values != null) {
          for (          String[] nvalue : values) {
            String value=nvalue[1] + ""String_Node_Str"" + nvalue[0];
            addMetadata(shortName,publication,field.getName(),value);
          }
        }
      }
    }
  }
  return publication;
}","public Record convert(String shortName,Object bean) throws SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  Record publication=new SubmissionLookupPublication(shortName);
  Field[] fields=bean.getClass().getDeclaredFields();
  for (  Field field : fields) {
    if (field.getType() == String.class) {
      Method getter=bean.getClass().getMethod(""String_Node_Str"" + field.getName().substring(0,1).toUpperCase() + field.getName().substring(1));
      String value=(String)getter.invoke(bean);
      addMetadata(shortName,publication,field.getName(),value);
    }
 else     if (field.getType() == List.class) {
      ParameterizedType pt=(ParameterizedType)field.getGenericType();
      Method getter=bean.getClass().getMethod(""String_Node_Str"" + field.getName().substring(0,1).toUpperCase() + field.getName().substring(1));
      if (pt.getActualTypeArguments()[0] instanceof GenericArrayType) {
        List<String[]> values=(List<String[]>)getter.invoke(bean);
        if (values != null) {
          for (          String[] nvalue : values) {
            String value=nvalue[1] + ""String_Node_Str"" + nvalue[0];
            addMetadata(shortName,publication,field.getName(),value);
          }
        }
      }
 else {
        List<String> values=(List<String>)getter.invoke(bean);
        if (values != null) {
          for (          String value : values) {
            addMetadata(shortName,publication,field.getName(),value);
          }
        }
      }
    }
  }
  return publication;
}",0.7182286927509858
52138,"@Override public Record modify(MutableRecord rec){
  if (merge_field_map != null) {
    for (    String target_field : merge_field_map.keySet()) {
      List<String> source_fields=merge_field_map.get(target_field);
      for (      String source_field : source_fields) {
        List<Value> values=rec.getValues(source_field);
        if (values != null && values.size() > 0) {
          for (          Value value : values) {
            rec.addValue(target_field,value);
          }
        }
        rec.removeField(source_field);
      }
    }
  }
  return rec;
}","@Override public Record modify(MutableRecord rec){
  if (merge_field_map != null) {
    for (    String target_field : merge_field_map.keySet()) {
      List<String> source_fields=merge_field_map.get(target_field);
      for (      String source_field : source_fields) {
        List<Value> values=rec.getValues(source_field);
        if (values != null && values.size() > 0) {
          for (          Value value : values) {
            rec.addValue(target_field,value);
          }
        }
      }
    }
  }
  return rec;
}",0.9205479452054794
52139,"public List<String> getIdentifiers(){
  List<String> identifiers=new ArrayList<String>();
  identifiers.add(""String_Node_Str"");
  identifiers.add(""String_Node_Str"");
  identifiers.add(""String_Node_Str"");
  return identifiers;
}","public List<String> getIdentifiers(){
  List<String> allSupportedIdentifiers=new ArrayList<String>();
  MultipleSubmissionLookupDataLoader dataLoader=(MultipleSubmissionLookupDataLoader)phase1TransformationEngine.getDataLoader();
  for (  SubmissionLookupProvider provider : dataLoader.getProviders()) {
    for (    String identifier : provider.getSupportedIdentifiers()) {
      if (!allSupportedIdentifiers.contains(identifier)) {
        allSupportedIdentifiers.add(identifier);
      }
    }
  }
  return allSupportedIdentifiers;
}",0.2778505897771953
52140,"public Record getTotalPublication(List<SubmissionLookupProvider> providers){
  if (publications == null) {
    return null;
  }
 else   if (publications.size() == 1) {
    return publications.get(0);
  }
 else {
    MutableRecord pub=new SubmissionLookupPublication(MERGED_PUBLICATION_PROVIDER);
    for (    SubmissionLookupProvider prov : providers) {
      for (      Record p : publications) {
        if (!SubmissionLookupService.getProviderName(p).equals(prov.getShortName())) {
          continue;
        }
        for (        String field : p.getFields()) {
          List<Value> values=p.getValues(field);
          if (values != null && values.size() > 0) {
            if (!pub.getFields().contains(field)) {
              for (              Value v : values) {
                pub.addValue(field,v);
              }
            }
          }
        }
      }
    }
    return pub;
  }
}","public Record getTotalPublication(List<SubmissionLookupProvider> providers){
  if (publications == null) {
    return null;
  }
 else   if (publications.size() == 1) {
    return publications.get(0);
  }
 else {
    MutableRecord pub=new SubmissionLookupPublication(MERGED_PUBLICATION_PROVIDER);
    for (    Record p : publications) {
      for (      String field : p.getFields()) {
        List<Value> values=p.getValues(field);
        if (values != null && values.size() > 0) {
          if (!pub.getFields().contains(field)) {
            for (            Value v : values) {
              pub.addValue(field,v);
            }
          }
        }
      }
    }
    return pub;
  }
}",0.7919547454431175
52141,"private List<Map<String,Object>> getLightResultList(List<ItemSubmissionLookupDTO> result){
  List<Map<String,Object>> publications=new ArrayList<Map<String,Object>>();
  if (result != null && result.size() > 0) {
    for (    ItemSubmissionLookupDTO item : result) {
      String uuid=item.getUUID();
      Record pub=item.getTotalPublication(service.getProviders());
      Map<String,Object> data=new HashMap<String,Object>();
      data.put(""String_Node_Str"",uuid);
      data.put(""String_Node_Str"",item.getProviders());
      data.put(""String_Node_Str"",SubmissionLookupService.getFirstValue(pub,""String_Node_Str""));
      data.put(""String_Node_Str"",pub.getValues(""String_Node_Str"") != null ? StringUtils.join(pub.getValues(""String_Node_Str"").iterator(),""String_Node_Str"") : ""String_Node_Str"");
      data.put(""String_Node_Str"",SubmissionLookupService.getFirstValue(pub,""String_Node_Str""));
      publications.add(data);
    }
  }
  return publications;
}","private List<Map<String,Object>> getLightResultList(List<ItemSubmissionLookupDTO> result){
  List<Map<String,Object>> publications=new ArrayList<Map<String,Object>>();
  if (result != null && result.size() > 0) {
    for (    ItemSubmissionLookupDTO item : result) {
      String uuid=item.getUUID();
      Record pub=item.getTotalPublication(service.getProviders());
      Map<String,Object> data=new HashMap<String,Object>();
      data.put(""String_Node_Str"",uuid);
      data.put(""String_Node_Str"",item.getProviders());
      data.put(""String_Node_Str"",SubmissionLookupService.getFirstValue(pub,""String_Node_Str""));
      List<String> authors=SubmissionLookupService.getStringValuesFromValues(pub,""String_Node_Str"");
      data.put(""String_Node_Str"",authors != null ? StringUtils.join(authors.iterator(),""String_Node_Str"") : ""String_Node_Str"");
      data.put(""String_Node_Str"",SubmissionLookupService.getFirstValue(pub,""String_Node_Str""));
      publications.add(data);
    }
  }
  return publications;
}",0.7928753180661577
52142,"@Override public void doJSONRequest(Context context,HttpServletRequest req,HttpServletResponse resp) throws AuthorizeException, IOException {
  String suuid=req.getParameter(""String_Node_Str"");
  SubmissionLookupDTO subDTO=service.getSubmissionLookupDTO(req,suuid);
  if (""String_Node_Str"".equalsIgnoreCase(req.getParameter(""String_Node_Str""))) {
    Map<String,Set<String>> identifiers=new HashMap<String,Set<String>>();
    Enumeration e=req.getParameterNames();
    while (e.hasMoreElements()) {
      String parameterName=(String)e.nextElement();
      String parameterValue=req.getParameter(parameterName);
      if (parameterName.startsWith(""String_Node_Str"") && StringUtils.isNotBlank(parameterValue)) {
        Set<String> set=new HashSet<String>();
        set.add(parameterValue);
        identifiers.put(parameterName.substring(""String_Node_Str"".length()),set);
      }
    }
    List<ItemSubmissionLookupDTO> result=new ArrayList<ItemSubmissionLookupDTO>();
    TransformationEngine transformationEngine=service.getPhase1TransformationEngine();
    if (transformationEngine != null) {
      MultipleSubmissionLookupDataLoader dataLoader=(MultipleSubmissionLookupDataLoader)transformationEngine.getDataLoader();
      dataLoader.setIdentifiers(identifiers);
      try {
        transformationEngine.transform(new TransformationSpec());
        SubmissionLookupOutputGenerator outputGenerator=(SubmissionLookupOutputGenerator)transformationEngine.getOutputGenerator();
        result=outputGenerator.getDtoList();
      }
 catch (      BadTransformationSpec e1) {
        e1.printStackTrace();
      }
catch (      MalformedSourceException e1) {
        e1.printStackTrace();
      }
    }
    subDTO.setItems(result);
    service.storeDTOs(req,suuid,subDTO);
    List<Map<String,Object>> dto=getLightResultList(result);
    JSONSerializer serializer=new JSONSerializer();
    serializer.rootName(""String_Node_Str"");
    serializer.deepSerialize(dto,resp.getWriter());
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(req.getParameter(""String_Node_Str""))) {
    String title=req.getParameter(""String_Node_Str"");
    String author=req.getParameter(""String_Node_Str"");
    int year=UIUtil.getIntParameter(req,""String_Node_Str"");
    Map<String,Set<String>> searchTerms=new HashMap<String,Set<String>>();
    Set<String> tmp1=new HashSet<String>();
    tmp1.add(title);
    Set<String> tmp2=new HashSet<String>();
    tmp2.add(author);
    Set<String> tmp3=new HashSet<String>();
    tmp3.add(String.valueOf(year));
    searchTerms.put(""String_Node_Str"",tmp1);
    searchTerms.put(""String_Node_Str"",tmp2);
    searchTerms.put(""String_Node_Str"",tmp3);
    List<ItemSubmissionLookupDTO> result=new ArrayList<ItemSubmissionLookupDTO>();
    TransformationEngine transformationEngine=service.getPhase1TransformationEngine();
    if (transformationEngine != null) {
      MultipleSubmissionLookupDataLoader dataLoader=(MultipleSubmissionLookupDataLoader)transformationEngine.getDataLoader();
      dataLoader.setSearchTerms(searchTerms);
      SubmissionLookupOutputGenerator outputGenerator=(SubmissionLookupOutputGenerator)transformationEngine.getOutputGenerator();
      result=outputGenerator.getDtoList();
      try {
        transformationEngine.transform(new TransformationSpec());
      }
 catch (      BadTransformationSpec e1) {
        e1.printStackTrace();
      }
catch (      MalformedSourceException e1) {
        e1.printStackTrace();
      }
    }
    subDTO.setItems(result);
    service.storeDTOs(req,suuid,subDTO);
    List<Map<String,Object>> dto=getLightResultList(result);
    JSONSerializer serializer=new JSONSerializer();
    serializer.rootName(""String_Node_Str"");
    serializer.deepSerialize(dto,resp.getWriter());
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(req.getParameter(""String_Node_Str""))) {
    String i_uuid=req.getParameter(""String_Node_Str"");
    JSONSerializer serializer=new JSONSerializer();
    serializer.rootName(""String_Node_Str"");
    Map<String,Object> dto=getDetails(subDTO.getLookupItem(i_uuid),context);
    serializer.deepSerialize(dto,resp.getWriter());
  }
}","@Override public void doJSONRequest(Context context,HttpServletRequest req,HttpServletResponse resp) throws AuthorizeException, IOException {
  String suuid=req.getParameter(""String_Node_Str"");
  SubmissionLookupDTO subDTO=service.getSubmissionLookupDTO(req,suuid);
  if (""String_Node_Str"".equalsIgnoreCase(req.getParameter(""String_Node_Str""))) {
    Map<String,Set<String>> identifiers=new HashMap<String,Set<String>>();
    Enumeration e=req.getParameterNames();
    while (e.hasMoreElements()) {
      String parameterName=(String)e.nextElement();
      String parameterValue=req.getParameter(parameterName);
      if (parameterName.startsWith(""String_Node_Str"") && StringUtils.isNotBlank(parameterValue)) {
        Set<String> set=new HashSet<String>();
        set.add(parameterValue);
        identifiers.put(parameterName.substring(""String_Node_Str"".length()),set);
      }
    }
    List<ItemSubmissionLookupDTO> result=new ArrayList<ItemSubmissionLookupDTO>();
    TransformationEngine transformationEngine=service.getPhase1TransformationEngine();
    if (transformationEngine != null) {
      MultipleSubmissionLookupDataLoader dataLoader=(MultipleSubmissionLookupDataLoader)transformationEngine.getDataLoader();
      dataLoader.setIdentifiers(identifiers);
      try {
        log.debug(""String_Node_Str"");
        transformationEngine.transform(new TransformationSpec());
        log.debug(""String_Node_Str"");
        SubmissionLookupOutputGenerator outputGenerator=(SubmissionLookupOutputGenerator)transformationEngine.getOutputGenerator();
        result=outputGenerator.getDtoList();
      }
 catch (      BadTransformationSpec e1) {
        e1.printStackTrace();
      }
catch (      MalformedSourceException e1) {
        e1.printStackTrace();
      }
    }
    subDTO.setItems(result);
    service.storeDTOs(req,suuid,subDTO);
    List<Map<String,Object>> dto=getLightResultList(result);
    JSONSerializer serializer=new JSONSerializer();
    serializer.rootName(""String_Node_Str"");
    serializer.deepSerialize(dto,resp.getWriter());
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(req.getParameter(""String_Node_Str""))) {
    String title=req.getParameter(""String_Node_Str"");
    String author=req.getParameter(""String_Node_Str"");
    int year=UIUtil.getIntParameter(req,""String_Node_Str"");
    Map<String,Set<String>> searchTerms=new HashMap<String,Set<String>>();
    Set<String> tmp1=new HashSet<String>();
    tmp1.add(title);
    Set<String> tmp2=new HashSet<String>();
    tmp2.add(author);
    Set<String> tmp3=new HashSet<String>();
    tmp3.add(String.valueOf(year));
    searchTerms.put(""String_Node_Str"",tmp1);
    searchTerms.put(""String_Node_Str"",tmp2);
    searchTerms.put(""String_Node_Str"",tmp3);
    List<ItemSubmissionLookupDTO> result=new ArrayList<ItemSubmissionLookupDTO>();
    TransformationEngine transformationEngine=service.getPhase1TransformationEngine();
    if (transformationEngine != null) {
      MultipleSubmissionLookupDataLoader dataLoader=(MultipleSubmissionLookupDataLoader)transformationEngine.getDataLoader();
      dataLoader.setSearchTerms(searchTerms);
      SubmissionLookupOutputGenerator outputGenerator=(SubmissionLookupOutputGenerator)transformationEngine.getOutputGenerator();
      result=outputGenerator.getDtoList();
      try {
        transformationEngine.transform(new TransformationSpec());
      }
 catch (      BadTransformationSpec e1) {
        e1.printStackTrace();
      }
catch (      MalformedSourceException e1) {
        e1.printStackTrace();
      }
    }
    subDTO.setItems(result);
    service.storeDTOs(req,suuid,subDTO);
    List<Map<String,Object>> dto=getLightResultList(result);
    JSONSerializer serializer=new JSONSerializer();
    serializer.rootName(""String_Node_Str"");
    serializer.deepSerialize(dto,resp.getWriter());
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(req.getParameter(""String_Node_Str""))) {
    String i_uuid=req.getParameter(""String_Node_Str"");
    JSONSerializer serializer=new JSONSerializer();
    serializer.rootName(""String_Node_Str"");
    Map<String,Object> dto=getDetails(subDTO.getLookupItem(i_uuid),context);
    serializer.deepSerialize(dto,resp.getWriter());
  }
}",0.9908697741470448
52143,"private void addBTEItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template,String inputType) throws Exception {
  TransformationEngine te=new DSpace().getSingletonService(TransformationEngine.class);
  DataLoaderService dls=new DSpace().getSingletonService(DataLoaderService.class);
  DataLoader dataLoader=dls.getDataLoaders().get(inputType);
  Map<String,String> outputMap=dls.getOutputMap();
  if (dataLoader == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  if (outputMap == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  if (dataLoader instanceof FileDataLoader) {
    FileDataLoader fdl=(FileDataLoader)dataLoader;
    if (!""String_Node_Str"".equals(sourceDir)) {
      System.out.println(""String_Node_Str"");
      fdl.setFilename(sourceDir);
    }
  }
  if (dataLoader instanceof OAIPMHDataLoader) {
    OAIPMHDataLoader fdl=(OAIPMHDataLoader)dataLoader;
    if (!""String_Node_Str"".equals(sourceDir)) {
      System.out.println(""String_Node_Str"");
      fdl.setServerAddress(sourceDir);
    }
  }
  if (dataLoader != null) {
    System.out.println(""String_Node_Str"" + dataLoader.toString() + ""String_Node_Str"");
    te.setDataLoader(dataLoader);
    DSpaceOutputGenerator outputGenerator=new DSpaceOutputGenerator(outputMap);
    outputGenerator.setOutputDirectory(""String_Node_Str"");
    te.setOutputGenerator(outputGenerator);
    try {
      TransformationResult res=te.transform(new TransformationSpec());
      List<String> output=res.getOutput();
      outputGenerator.writeOutput(output);
    }
 catch (    Exception e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
    }
    ItemImport myloader=new ItemImport();
    myloader.addItems(c,mycollections,""String_Node_Str"",mapFile,template);
    deleteDirectory(new File(""String_Node_Str""));
  }
}","private void addBTEItems(Context c,Collection[] mycollections,String sourceDir,String mapFile,boolean template,String inputType) throws Exception {
  TransformationEngine te=new DSpace().getSingletonService(TransformationEngine.class);
  DataLoaderService dls=new DSpace().getSingletonService(DataLoaderService.class);
  DataLoader dataLoader=dls.getDataLoaders().get(inputType);
  Map<String,String> outputMap=dls.getOutputMap();
  if (dataLoader == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  if (outputMap == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  if (dataLoader instanceof FileDataLoader) {
    FileDataLoader fdl=(FileDataLoader)dataLoader;
    if (!StringUtils.isBlank(sourceDir)) {
      System.out.println(""String_Node_Str"");
      fdl.setFilename(sourceDir);
    }
  }
 else   if (dataLoader instanceof OAIPMHDataLoader) {
    OAIPMHDataLoader fdl=(OAIPMHDataLoader)dataLoader;
    System.out.println(sourceDir);
    if (!StringUtils.isBlank(sourceDir)) {
      System.out.println(""String_Node_Str"");
      fdl.setServerAddress(sourceDir);
    }
  }
  if (dataLoader != null) {
    System.out.println(""String_Node_Str"" + dataLoader.toString() + ""String_Node_Str"");
    te.setDataLoader(dataLoader);
    DSpaceOutputGenerator outputGenerator=new DSpaceOutputGenerator(outputMap);
    outputGenerator.setOutputDirectory(""String_Node_Str"");
    te.setOutputGenerator(outputGenerator);
    try {
      TransformationResult res=te.transform(new TransformationSpec());
      List<String> output=res.getOutput();
      outputGenerator.writeOutput(output);
    }
 catch (    Exception e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
    }
    ItemImport myloader=new ItemImport();
    myloader.addItems(c,mycollections,""String_Node_Str"",mapFile,template);
    deleteDirectory(new File(""String_Node_Str""));
  }
}",0.9449614464238234
52144,"public SubmissionLookupOutputGenerator(){
  dtoList=new ArrayList<ItemSubmissionLookupDTO>();
}","public SubmissionLookupOutputGenerator(){
}",0.6231884057971014
52145,"/** 
 * Search the database for a DOI, using the type and id of an DSpaceObject.
 * @param context
 * @param dso DSpaceObject to find doi for.
 * @return The DOI as String or null if DOI was not found.
 * @throws SQLException 
 */
public static String getDOIByObject(Context context,DSpaceObject dso) throws SQLException {
  String sql=""String_Node_Str"" + ""String_Node_Str"";
  TableRow doiRow=DatabaseManager.querySingleTable(context,""String_Node_Str"",sql,dso.getType(),dso.getID());
  if (null == doiRow) {
    return null;
  }
  if (doiRow.isColumnNull(""String_Node_Str"")) {
    log.error(""String_Node_Str"" + dso.getTypeText() + ""String_Node_Str""+ dso.getID()+ ""String_Node_Str"");
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + dso.getTypeText() + ""String_Node_Str""+ dso.getID()+ ""String_Node_Str"");
  }
  return DOI.SCHEME + doiRow.getStringColumn(""String_Node_Str"");
}","/** 
 * Search the database for a DOI, using the type and id of an DSpaceObject.
 * @param context
 * @param dso DSpaceObject to find doi for. DOIs with status DELETED will beignored.
 * @return The DOI as String or null if DOI was not found.
 * @throws SQLException
 */
public static String getDOIByObject(Context context,DSpaceObject dso) throws SQLException {
  String sql=""String_Node_Str"" + ""String_Node_Str"";
  TableRow doiRow=DatabaseManager.querySingleTable(context,""String_Node_Str"",sql,dso.getType(),dso.getID(),DOIIdentifierProvider.DELETED);
  if (null == doiRow) {
    return null;
  }
  if (doiRow.isColumnNull(""String_Node_Str"")) {
    log.error(""String_Node_Str"" + dso.getTypeText() + ""String_Node_Str""+ dso.getID()+ ""String_Node_Str"");
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + dso.getTypeText() + ""String_Node_Str""+ dso.getID()+ ""String_Node_Str"");
  }
  return DOI.SCHEME + doiRow.getStringColumn(""String_Node_Str"");
}",0.9615384615384616
52146,"/** 
 * Adds a DOI to the metadata of an item.
 * @param context
 * @param dso DSpaceObject the DOI should be added to.
 * @param doi The DOI that should be added as metadata.
 * @throws SQLException
 * @throws AuthorizeException 
 */
protected void saveDOIToObject(Context context,DSpaceObject dso,String doi) throws SQLException, AuthorizeException {
  if (!(dso instanceof Item)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + dso.getTypeText() + ""String_Node_Str"");
  }
  Item item=(Item)dso;
  item.addMetadata(MD_SCHEMA,DOI_ELEMENT,DOI_QUALIFIER,null,doi);
  try {
    item.update();
    context.commit();
    log.info(""String_Node_Str"",doi);
  }
 catch (  SQLException ex) {
    throw ex;
  }
catch (  AuthorizeException ex) {
    throw ex;
  }
}","/** 
 * Adds a DOI to the metadata of an item.
 * @param context
 * @param dso DSpaceObject the DOI should be added to.
 * @param doi The DOI that should be added as metadata.
 * @throws SQLException
 * @throws AuthorizeException 
 */
protected void saveDOIToObject(Context context,DSpaceObject dso,String doi) throws SQLException, AuthorizeException {
  if (!(dso instanceof Item)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + dso.getTypeText() + ""String_Node_Str"");
  }
  Item item=(Item)dso;
  item.addMetadata(MD_SCHEMA,DOI_ELEMENT,DOI_QUALIFIER,null,doi);
  try {
    item.update();
    context.commit();
  }
 catch (  SQLException ex) {
    throw ex;
  }
catch (  AuthorizeException ex) {
    throw ex;
  }
}",0.9759271307742357
52147,"@Override public void delete(Context context,DSpaceObject dso,String identifier) throws IdentifierException {
  String doi=DOI.formatIdentifier(identifier);
  TableRow doiRow=null;
  String oldStatus=null;
  try {
    doiRow=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",doi.substring(DOI.SCHEME.length()));
  }
 catch (  SQLException sqle) {
    throw new RuntimeException(sqle);
  }
  if (null != doiRow) {
    if (doiRow.getIntColumn(""String_Node_Str"") != dso.getID() || doiRow.getIntColumn(""String_Node_Str"") != dso.getType()) {
      throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.MISMATCH);
    }
  }
  try {
    removeDOIFromObject(context,dso,doi);
  }
 catch (  AuthorizeException ex) {
    log.error(""String_Node_Str"",ex);
    throw new DOIIdentifierException(""String_Node_Str"",ex,DOIIdentifierException.UNAUTHORIZED_METADATA_MANIPULATION);
  }
catch (  SQLException ex) {
    log.error(""String_Node_Str"" + ex.getMessage());
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + dso.getID(),ex);
  }
  if (null != doiRow) {
    doiRow.setColumn(""String_Node_Str"",DELETED);
    try {
      DatabaseManager.update(context,doiRow);
    }
 catch (    SQLException sqle) {
      log.warn(""String_Node_Str"",doi);
      throw new RuntimeException(sqle);
    }
  }
  connector.deleteDOI(context,doi);
}","@Override public void delete(Context context,DSpaceObject dso,String identifier) throws IdentifierException {
  String doi=DOI.formatIdentifier(identifier);
  TableRow doiRow=null;
  String oldStatus=null;
  try {
    doiRow=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",doi.substring(DOI.SCHEME.length()));
  }
 catch (  SQLException sqle) {
    throw new RuntimeException(sqle);
  }
  if (null != doiRow) {
    if (doiRow.getIntColumn(""String_Node_Str"") != dso.getID() || doiRow.getIntColumn(""String_Node_Str"") != dso.getType()) {
      throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.MISMATCH);
    }
  }
  try {
    removeDOIFromObject(context,dso,doi);
  }
 catch (  AuthorizeException ex) {
    log.error(""String_Node_Str"",ex);
    throw new DOIIdentifierException(""String_Node_Str"",ex,DOIIdentifierException.UNAUTHORIZED_METADATA_MANIPULATION);
  }
catch (  SQLException ex) {
    log.error(""String_Node_Str"" + ex.getMessage());
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + dso.getID(),ex);
  }
  if (null != doiRow) {
    doiRow.setColumn(""String_Node_Str"",DELETED);
    try {
      DatabaseManager.update(context,doiRow);
      context.commit();
    }
 catch (    SQLException sqle) {
      log.warn(""String_Node_Str"",doi);
      throw new RuntimeException(sqle);
    }
  }
  connector.deleteDOI(context,doi);
}",0.9914712153518124
52148,"/** 
 * This identifier provider supports identifiers in the following format: <ul> <li>doi:10.123/456</li> <li>10.123/456</li> <li>http://dx.doi.org/10.123/456</li> </ul>
 * @param identifier to check if it is in a supported format.
 * @return 
 */
@Override public boolean supports(String identifier){
  try {
    DOI.formatIdentifier(identifier);
  }
 catch (  IdentifierException e) {
    return false;
  }
  return true;
}","/** 
 * This identifier provider supports identifiers in the following format: <ul> <li>doi:10.123/456</li> <li>10.123/456</li> <li>http://dx.doi.org/10.123/456</li> </ul>
 * @param identifier to check if it is in a supported format.
 * @return 
 */
@Override public boolean supports(String identifier){
  try {
    DOI.formatIdentifier(identifier);
  }
 catch (  IdentifierException e) {
    return false;
  }
catch (  IllegalArgumentException e) {
    return false;
  }
  return true;
}",0.907103825136612
52149,"@Override public void delete(Context context,DSpaceObject dso,String identifier) throws IdentifierException {
  String doi=DOI.formatIdentifier(identifier);
  TableRow doiRow=null;
  String oldStatus=null;
  try {
    doiRow=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",doi);
  }
 catch (  SQLException sqle) {
    throw new RuntimeException(sqle);
  }
  if (null != doiRow) {
    if (doiRow.getIntColumn(""String_Node_Str"") != dso.getID() || doiRow.getIntColumn(""String_Node_Str"") != dso.getType()) {
      throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.MISMATCH);
    }
  }
  try {
    removeDOIFromObject(context,dso,doi);
  }
 catch (  AuthorizeException ex) {
    log.error(""String_Node_Str"",ex);
    throw new DOIIdentifierException(""String_Node_Str"",ex,DOIIdentifierException.UNAUTHORIZED_METADATA_MANIPULATION);
  }
catch (  SQLException ex) {
    log.error(""String_Node_Str"" + ex.getMessage());
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + dso.getID(),ex);
  }
  if (null != doiRow) {
    doiRow.setColumn(""String_Node_Str"",""String_Node_Str"");
    try {
      DatabaseManager.update(context,doiRow);
    }
 catch (    SQLException sqle) {
      log.warn(""String_Node_Str"",doi);
      throw new RuntimeException(sqle);
    }
  }
  connector.deleteDOI(context,doi);
}","@Override public void delete(Context context,DSpaceObject dso,String identifier) throws IdentifierException {
  String doi=DOI.formatIdentifier(identifier);
  TableRow doiRow=null;
  String oldStatus=null;
  try {
    doiRow=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",doi.substring(DOI.SCHEME.length()));
  }
 catch (  SQLException sqle) {
    throw new RuntimeException(sqle);
  }
  if (null != doiRow) {
    if (doiRow.getIntColumn(""String_Node_Str"") != dso.getID() || doiRow.getIntColumn(""String_Node_Str"") != dso.getType()) {
      throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.MISMATCH);
    }
  }
  try {
    removeDOIFromObject(context,dso,doi);
  }
 catch (  AuthorizeException ex) {
    log.error(""String_Node_Str"",ex);
    throw new DOIIdentifierException(""String_Node_Str"",ex,DOIIdentifierException.UNAUTHORIZED_METADATA_MANIPULATION);
  }
catch (  SQLException ex) {
    log.error(""String_Node_Str"" + ex.getMessage());
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + dso.getID(),ex);
  }
  if (null != doiRow) {
    doiRow.setColumn(""String_Node_Str"",""String_Node_Str"");
    try {
      DatabaseManager.update(context,doiRow);
    }
 catch (    SQLException sqle) {
      log.warn(""String_Node_Str"",doi);
      throw new RuntimeException(sqle);
    }
  }
  connector.deleteDOI(context,doi);
}",0.9888449082403742
52150,"public void updateMetadata(Context context,DSpaceObject dso,String identifier) throws IdentifierException {
  String doi=DOI.formatIdentifier(identifier);
  TableRow doiRow=null;
  try {
    doiRow=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",doi);
  }
 catch (  SQLException sqle) {
    log.warn(""String_Node_Str"",sqle);
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",sqle);
  }
  if (null == doiRow) {
    log.error(""String_Node_Str"" + ""String_Node_Str"",doi);
    throw new DOIIdentifierException(""String_Node_Str"",DOIIdentifierException.DOI_DOES_NOT_EXIST);
  }
  if (doiRow.getIntColumn(""String_Node_Str"") != dso.getID() || doiRow.getIntColumn(""String_Node_Str"") != dso.getType()) {
    log.error(""String_Node_Str"" + ""String_Node_Str"",new String[]{doi,dso.getTypeText(),Integer.toString(dso.getID())});
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.MISMATCH);
  }
  connector.updateMetadata(context,dso,doi);
}","public void updateMetadata(Context context,DSpaceObject dso,String identifier) throws IdentifierException {
  String doi=DOI.formatIdentifier(identifier);
  TableRow doiRow=null;
  try {
    doiRow=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",doi.substring(DOI.SCHEME.length()));
  }
 catch (  SQLException sqle) {
    log.warn(""String_Node_Str"",sqle);
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",sqle);
  }
  if (null == doiRow) {
    log.error(""String_Node_Str"" + ""String_Node_Str"",doi);
    throw new DOIIdentifierException(""String_Node_Str"",DOIIdentifierException.DOI_DOES_NOT_EXIST);
  }
  if (doiRow.getIntColumn(""String_Node_Str"") != dso.getID() || doiRow.getIntColumn(""String_Node_Str"") != dso.getType()) {
    log.error(""String_Node_Str"" + ""String_Node_Str"",new String[]{doi,dso.getTypeText(),Integer.toString(dso.getID())});
    throw new DOIIdentifierException(""String_Node_Str"" + ""String_Node_Str"",DOIIdentifierException.MISMATCH);
  }
  connector.updateMetadata(context,dso,doi);
}",0.984973339796413
52151,"private static void updateObject(Context context,String argument){
  TableRow row=null;
  TableRow doiRow=null;
  DOIIdentifierProvider doiIdentifierProvider=new DSpace().getSingletonService(DOIIdentifierProvider.class);
  String sql=""String_Node_Str"";
  try {
    if (argument.matches(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
      Integer itemID=Integer.valueOf(argument);
      row=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",itemID);
      if (null != row) {
        System.err.println(""String_Node_Str"");
        doiRow=DatabaseManager.querySingleTable(context,""String_Node_Str"",sql,row.getIntColumn(""String_Node_Str""),row.getIntColumn(""String_Node_Str""));
        if (null != doiRow) {
          DSpaceObject dso=DSpaceObject.find(context,doiRow.getIntColumn(""String_Node_Str""),doiRow.getIntColumn(""String_Node_Str""));
          doiIdentifierProvider.updateMetadata(context,dso,doiRow.getStringColumn(""String_Node_Str""));
          return;
        }
 else {
          LOG.error(""String_Node_Str"" + argument);
        }
      }
 else {
        LOG.error(""String_Node_Str"" + argument + ""String_Node_Str"");
      }
    }
    row=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",argument);
    if (null != row) {
      doiRow=DatabaseManager.querySingleTable(context,""String_Node_Str"",sql,row.getIntColumn(""String_Node_Str""),row.getIntColumn(""String_Node_Str""));
      if (null != doiRow) {
        DSpaceObject dso=DSpaceObject.find(context,doiRow.getIntColumn(""String_Node_Str""),doiRow.getIntColumn(""String_Node_Str""));
        doiIdentifierProvider.updateMetadata(context,dso,doiRow.getStringColumn(""String_Node_Str""));
        return;
      }
 else {
        LOG.error(""String_Node_Str"" + argument);
      }
    }
 else {
      LOG.error(""String_Node_Str"" + argument + ""String_Node_Str"");
    }
    String doi=doiIdentifierProvider.formatIdentifier(argument);
    row=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",doi.substring(DOI.SCHEME.length()));
    if (null != row) {
      DSpaceObject dso=DSpaceObject.find(context,row.getIntColumn(""String_Node_Str""),row.getIntColumn(""String_Node_Str""));
      doiIdentifierProvider.updateMetadata(context,dso,row.getStringColumn(""String_Node_Str""));
    }
 else {
      LOG.error(""String_Node_Str"" + argument + ""String_Node_Str"");
    }
  }
 catch (  SQLException ex) {
    LOG.error(ex);
  }
catch (  IdentifierException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
}","private static void updateObject(Context context,String argument){
  TableRow row=null;
  TableRow doiRow=null;
  DOIIdentifierProvider doiIdentifierProvider=new DSpace().getSingletonService(DOIIdentifierProvider.class);
  String sql=""String_Node_Str"";
  try {
    if (argument.matches(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
      Integer itemID=Integer.valueOf(argument);
      row=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",itemID);
      if (null != row) {
        System.err.println(""String_Node_Str"");
        doiRow=DatabaseManager.querySingleTable(context,""String_Node_Str"",sql,row.getIntColumn(""String_Node_Str""),row.getIntColumn(""String_Node_Str""));
        if (null != doiRow) {
          DSpaceObject dso=DSpaceObject.find(context,doiRow.getIntColumn(""String_Node_Str""),doiRow.getIntColumn(""String_Node_Str""));
          doiIdentifierProvider.updateMetadata(context,dso,doiRow.getStringColumn(""String_Node_Str""));
          return;
        }
 else {
          LOG.error(""String_Node_Str"" + argument);
        }
      }
 else {
        LOG.error(""String_Node_Str"" + argument + ""String_Node_Str"");
      }
    }
    row=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",argument);
    if (null != row) {
      doiRow=DatabaseManager.querySingleTable(context,""String_Node_Str"",sql,row.getIntColumn(""String_Node_Str""),row.getIntColumn(""String_Node_Str""));
      if (null != doiRow) {
        DSpaceObject dso=DSpaceObject.find(context,doiRow.getIntColumn(""String_Node_Str""),doiRow.getIntColumn(""String_Node_Str""));
        doiIdentifierProvider.updateMetadata(context,dso,doiRow.getStringColumn(""String_Node_Str""));
        return;
      }
 else {
        LOG.error(""String_Node_Str"" + argument);
      }
    }
 else {
      LOG.error(""String_Node_Str"" + argument + ""String_Node_Str"");
    }
    String doi=DOI.formatIdentifier(argument);
    row=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",doi.substring(DOI.SCHEME.length()));
    if (null != row) {
      DSpaceObject dso=DSpaceObject.find(context,row.getIntColumn(""String_Node_Str""),row.getIntColumn(""String_Node_Str""));
      doiIdentifierProvider.updateMetadata(context,dso,row.getStringColumn(""String_Node_Str""));
    }
 else {
      LOG.error(""String_Node_Str"" + argument + ""String_Node_Str"");
    }
  }
 catch (  SQLException ex) {
    LOG.error(ex);
  }
catch (  IdentifierException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
}",0.9956279809220986
52152,"public static void main(String[] args){
  LOG.info(""String_Node_Str"");
  CommandLineParser parser=new PosixParser();
  CommandLine line=null;
  Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  Option registerDoi=OptionBuilder.withArgName(""String_Node_Str"").hasArgs(1).withDescription(""String_Node_Str"" + ""String_Node_Str"").create('g');
  options.addOption(registerDoi);
  Option reserveDoi=OptionBuilder.withArgName(""String_Node_Str"").hasArgs(1).withDescription(""String_Node_Str"" + ""String_Node_Str"").create('v');
  options.addOption(reserveDoi);
  Option registerByItemOrHandle=OptionBuilder.withArgName(""String_Node_Str"").hasArgs(1).withDescription(""String_Node_Str"" + ""String_Node_Str"").create('t');
  options.addOption(registerByItemOrHandle);
  Option reserveByItemOrHandle=OptionBuilder.withArgName(""String_Node_Str"").hasArgs(1).withDescription(""String_Node_Str"" + ""String_Node_Str"").create('i');
  options.addOption(reserveByItemOrHandle);
  Option udate=OptionBuilder.withArgName(""String_Node_Str"").hasArgs(1).withDescription(""String_Node_Str"" + ""String_Node_Str"").create('u');
  options.addOption(udate);
  Context context=null;
  try {
    context=new Context();
  }
 catch (  SQLException sqle) {
    System.err.println(""String_Node_Str"" + sqle.getMessage());
    System.exit(-1);
  }
  context.turnOffAuthorisationSystem();
  try {
    line=parser.parse(options,args);
  }
 catch (  ParseException ex) {
    LOG.fatal(ex);
    System.exit(1);
  }
  if (line.hasOption('h')) {
    printHelp(options);
  }
  if (line.hasOption('l')) {
    listDoiTable(context);
  }
  if (line.hasOption('s')) {
    doiRequest(context,""String_Node_Str"");
  }
  if (line.hasOption('r')) {
    doiRequest(context,""String_Node_Str"");
  }
  if (line.hasOption('g')) {
    String identifier=line.getOptionValue('g');
    if (null == identifier) {
    }
 else {
      doiRequestByDOI(context,identifier,""String_Node_Str"");
    }
  }
  if (line.hasOption('v')) {
    String identifier=line.getOptionValue('v');
    if (null == identifier) {
    }
 else {
      doiRequestByDOI(context,identifier,""String_Node_Str"");
    }
  }
  if (line.hasOption('t')) {
    String itemID_Hdl=line.getOptionValue('t');
    if (null == itemID_Hdl) {
      printHelp(options);
    }
 else {
      doiRequestByItemID_Handle(context,itemID_Hdl,""String_Node_Str"");
    }
  }
  if (line.hasOption('i')) {
    String itemID_Hdl=line.getOptionValue('i');
    if (null == itemID_Hdl) {
      printHelp(options);
    }
 else {
      doiRequestByItemID_Handle(context,itemID_Hdl,""String_Node_Str"");
    }
  }
  if (line.hasOption('u')) {
    String argument=line.getOptionValue('u');
    if (null == argument) {
      printHelp(options);
    }
 else {
      updateObject(context,argument);
    }
  }
  try {
    context.complete();
  }
 catch (  SQLException sqle) {
    System.err.println(""String_Node_Str"" + sqle.getMessage());
    System.exit(-1);
  }
  LOG.info(""String_Node_Str"");
}","public static void main(String[] args){
  LOG.info(""String_Node_Str"");
  CommandLineParser parser=new PosixParser();
  CommandLine line=null;
  Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  Option registerDoi=OptionBuilder.withArgName(""String_Node_Str"").hasArgs(1).withDescription(""String_Node_Str"" + ""String_Node_Str"").create('g');
  options.addOption(registerDoi);
  Option reserveDoi=OptionBuilder.withArgName(""String_Node_Str"").hasArgs(1).withDescription(""String_Node_Str"" + ""String_Node_Str"").create('v');
  options.addOption(reserveDoi);
  Option registerByItemOrHandle=OptionBuilder.withArgName(""String_Node_Str"").hasArgs(1).withDescription(""String_Node_Str"" + ""String_Node_Str"").create('t');
  options.addOption(registerByItemOrHandle);
  Option reserveByItemOrHandle=OptionBuilder.withArgName(""String_Node_Str"").hasArgs(1).withDescription(""String_Node_Str"" + ""String_Node_Str"").create('i');
  options.addOption(reserveByItemOrHandle);
  Option update=OptionBuilder.withArgName(""String_Node_Str"").hasArgs(1).withDescription(""String_Node_Str"" + ""String_Node_Str"").create('u');
  options.addOption(update);
  Context context=null;
  try {
    context=new Context();
  }
 catch (  SQLException sqle) {
    System.err.println(""String_Node_Str"" + sqle.getMessage());
    System.exit(-1);
  }
  context.turnOffAuthorisationSystem();
  try {
    line=parser.parse(options,args);
  }
 catch (  ParseException ex) {
    LOG.fatal(ex);
    System.exit(1);
  }
  if (line.hasOption('h')) {
    printHelp(options);
  }
  if (line.hasOption('l')) {
    listDoiTable(context);
  }
  if (line.hasOption('s')) {
    doiRequest(context,""String_Node_Str"");
  }
  if (line.hasOption('r')) {
    doiRequest(context,""String_Node_Str"");
  }
  if (line.hasOption('g')) {
    String identifier=line.getOptionValue('g');
    if (null == identifier) {
      printHelp(options);
    }
 else {
      doiRequestByDOI(context,identifier,""String_Node_Str"");
    }
  }
  if (line.hasOption('v')) {
    String identifier=line.getOptionValue('v');
    if (null == identifier) {
      printHelp(options);
    }
 else {
      doiRequestByDOI(context,identifier,""String_Node_Str"");
    }
  }
  if (line.hasOption('t')) {
    String itemID_Hdl=line.getOptionValue('t');
    if (null == itemID_Hdl) {
      printHelp(options);
    }
 else {
      doiRequestByItemID_Handle(context,itemID_Hdl,""String_Node_Str"");
    }
  }
  if (line.hasOption('i')) {
    String itemID_Hdl=line.getOptionValue('i');
    if (null == itemID_Hdl) {
      printHelp(options);
    }
 else {
      doiRequestByItemID_Handle(context,itemID_Hdl,""String_Node_Str"");
    }
  }
  if (line.hasOption('u')) {
    String argument=line.getOptionValue('u');
    if (null == argument) {
      printHelp(options);
    }
 else {
      updateObject(context,argument);
    }
  }
  try {
    context.complete();
  }
 catch (  SQLException sqle) {
    System.err.println(""String_Node_Str"" + sqle.getMessage());
    System.exit(-1);
  }
  LOG.info(""String_Node_Str"");
}",0.9917808219178084
52153,"public int doEndTag() throws JspException {
  ServletRequest request=pageContext.getRequest();
  HttpServletResponse response=(HttpServletResponse)pageContext.getResponse();
  ServletConfig config=pageContext.getServletConfig();
  String header=templatePath + ""String_Node_Str"";
  if (style != null) {
    header=templatePath + ""String_Node_Str"" + style.toLowerCase()+ ""String_Node_Str"";
  }
  if (sidebar != null) {
    request.setAttribute(""String_Node_Str"",sidebar);
  }
  try {
    if ((noCache != null) && noCache.equalsIgnoreCase(""String_Node_Str"")) {
      response.addDateHeader(""String_Node_Str"",1);
      response.addHeader(""String_Node_Str"",""String_Node_Str"");
      response.addHeader(""String_Node_Str"",""String_Node_Str"");
    }
    response.setContentType(""String_Node_Str"");
    RequestDispatcher rd=config.getServletContext().getRequestDispatcher(header);
    rd.include(request,response);
    getBodyContent().writeOut(pageContext.getOut());
  }
 catch (  IOException ioe) {
    throw new JspException(""String_Node_Str"" + ioe);
  }
catch (  ServletException se) {
    log.warn(""String_Node_Str"",se.getRootCause());
    throw new JspException(""String_Node_Str"" + se);
  }
  String footer=templatePath + ""String_Node_Str"";
  if (style != null) {
    footer=templatePath + ""String_Node_Str"" + style.toLowerCase()+ ""String_Node_Str"";
  }
  try {
    pageContext.getOut().flush();
    RequestDispatcher rd=config.getServletContext().getRequestDispatcher(footer);
    rd.include(request,response);
  }
 catch (  ServletException se) {
    throw new JspException(""String_Node_Str"" + se);
  }
catch (  IOException ioe) {
    throw new JspException(""String_Node_Str"" + ioe);
  }
  return EVAL_PAGE;
}","public int doEndTag() throws JspException {
  ServletRequest request=pageContext.getRequest();
  HttpServletResponse response=(HttpServletResponse)pageContext.getResponse();
  ServletConfig config=pageContext.getServletConfig();
  String header=templatePath + ""String_Node_Str"";
  if (style != null) {
    header=templatePath + ""String_Node_Str"" + style.toLowerCase()+ ""String_Node_Str"";
  }
  if (sidebar != null) {
    request.setAttribute(""String_Node_Str"",sidebar);
  }
  try {
    if ((noCache != null) && noCache.equalsIgnoreCase(""String_Node_Str"")) {
      response.addDateHeader(""String_Node_Str"",1);
      response.addHeader(""String_Node_Str"",""String_Node_Str"");
      response.addHeader(""String_Node_Str"",""String_Node_Str"");
    }
    response.setContentType(""String_Node_Str"");
    RequestDispatcher rd=config.getServletContext().getRequestDispatcher(header);
    rd.include(request,response);
    getBodyContent().writeOut(pageContext.getOut());
  }
 catch (  IOException ioe) {
    throw new JspException(""String_Node_Str"" + ioe);
  }
catch (  ServletException se) {
    log.warn(""String_Node_Str"",se.getRootCause());
    throw new JspException(""String_Node_Str"" + se);
  }
  String footer=templatePath + ""String_Node_Str"";
  if (style != null) {
    footer=templatePath + ""String_Node_Str"" + style.toLowerCase()+ ""String_Node_Str"";
  }
  try {
    pageContext.getOut().flush();
    RequestDispatcher rd=config.getServletContext().getRequestDispatcher(footer);
    rd.include(request,response);
  }
 catch (  ServletException se) {
    throw new JspException(""String_Node_Str"" + se);
  }
catch (  IOException ioe) {
    throw new JspException(""String_Node_Str"" + ioe);
  }
  style=null;
  title=null;
  sidebar=null;
  navbar=null;
  locbar=null;
  parentTitle=null;
  parentLink=null;
  noCache=null;
  feedData=null;
  return EVAL_PAGE;
}",0.9589887640449438
52154,"/** 
 * Process the upload of a new file!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed byUI-related code! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
protected int processUploadFile(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  boolean formatKnown=true;
  boolean fileOK=false;
  BitstreamFormat bf=null;
  Bitstream b=null;
  Enumeration attNames=request.getAttributeNames();
  while (attNames.hasMoreElements()) {
    String attr=(String)attNames.nextElement();
    if (attr.endsWith(""String_Node_Str"")) {
      String param=attr.replace(""String_Node_Str"",""String_Node_Str"");
      String filePath=(String)request.getAttribute(param + ""String_Node_Str"");
      InputStream fileInputStream=(InputStream)request.getAttribute(param + ""String_Node_Str"");
      String fileDescription=(String)request.getAttribute(param + ""String_Node_Str"");
      if (fileDescription == null || fileDescription.length() == 0) {
        request.getParameter(""String_Node_Str"");
      }
      if (filePath == null || fileInputStream == null) {
        return STATUS_UPLOAD_ERROR;
      }
      if (subInfo == null) {
        return STATUS_INTEGRITY_ERROR;
      }
      Item item=subInfo.getSubmissionItem().getItem();
      Bundle[] bundles=item.getBundles(""String_Node_Str"");
      if (bundles.length < 1) {
        b=item.createSingleBitstream(fileInputStream,""String_Node_Str"");
      }
 else {
        b=bundles[0].createBitstream(fileInputStream);
      }
      String noPath=filePath;
      while (noPath.indexOf('/') > -1) {
        noPath=noPath.substring(noPath.indexOf('/') + 1);
      }
      while (noPath.indexOf('\\') > -1) {
        noPath=noPath.substring(noPath.indexOf('\\') + 1);
      }
      b.setName(noPath);
      b.setSource(filePath);
      b.setDescription(fileDescription);
      bf=FormatIdentifier.guessFormat(context,b);
      b.setFormat(bf);
      b.update();
      item.update();
      if ((bf != null) && (bf.isInternal())) {
        log.warn(""String_Node_Str"");
        backoutBitstream(subInfo,b,item);
        return STATUS_UPLOAD_ERROR;
      }
      if (ConfigurationManager.getBooleanProperty(""String_Node_Str"",""String_Node_Str"")) {
        Curator curator=new Curator();
        curator.addTask(""String_Node_Str"").curate(item);
        int status=curator.getStatus(""String_Node_Str"");
        if (status == Curator.CURATE_ERROR) {
          backoutBitstream(subInfo,b,item);
          return STATUS_VIRUS_CHECKER_UNAVAILABLE;
        }
 else         if (status == Curator.CURATE_FAIL) {
          backoutBitstream(subInfo,b,item);
          return STATUS_CONTAINS_VIRUS;
        }
      }
      context.commit();
      subInfo.setBitstream(b);
      if (bf == null) {
        return STATUS_UNKNOWN_FORMAT;
      }
    }
  }
  return STATUS_COMPLETE;
}","/** 
 * Process the upload of a new file!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed byUI-related code! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
protected int processUploadFile(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  boolean formatKnown=true;
  boolean fileOK=false;
  BitstreamFormat bf=null;
  Bitstream b=null;
  Enumeration attNames=request.getAttributeNames();
  while (attNames.hasMoreElements()) {
    String attr=(String)attNames.nextElement();
    if (attr.endsWith(""String_Node_Str"")) {
      String param=attr.replace(""String_Node_Str"",""String_Node_Str"");
      String filePath=(String)request.getAttribute(param + ""String_Node_Str"");
      InputStream fileInputStream=(InputStream)request.getAttribute(param + ""String_Node_Str"");
      String fileDescription=(String)request.getAttribute(param + ""String_Node_Str"");
      if (fileDescription == null || fileDescription.length() == 0) {
        fileDescription=request.getParameter(""String_Node_Str"");
      }
      if (filePath == null || fileInputStream == null) {
        return STATUS_UPLOAD_ERROR;
      }
      if (subInfo == null) {
        return STATUS_INTEGRITY_ERROR;
      }
      Item item=subInfo.getSubmissionItem().getItem();
      Bundle[] bundles=item.getBundles(""String_Node_Str"");
      if (bundles.length < 1) {
        b=item.createSingleBitstream(fileInputStream,""String_Node_Str"");
      }
 else {
        b=bundles[0].createBitstream(fileInputStream);
      }
      String noPath=filePath;
      while (noPath.indexOf('/') > -1) {
        noPath=noPath.substring(noPath.indexOf('/') + 1);
      }
      while (noPath.indexOf('\\') > -1) {
        noPath=noPath.substring(noPath.indexOf('\\') + 1);
      }
      b.setName(noPath);
      b.setSource(filePath);
      b.setDescription(fileDescription);
      bf=FormatIdentifier.guessFormat(context,b);
      b.setFormat(bf);
      b.update();
      item.update();
      if ((bf != null) && (bf.isInternal())) {
        log.warn(""String_Node_Str"");
        backoutBitstream(subInfo,b,item);
        return STATUS_UPLOAD_ERROR;
      }
      if (ConfigurationManager.getBooleanProperty(""String_Node_Str"",""String_Node_Str"")) {
        Curator curator=new Curator();
        curator.addTask(""String_Node_Str"").curate(item);
        int status=curator.getStatus(""String_Node_Str"");
        if (status == Curator.CURATE_ERROR) {
          backoutBitstream(subInfo,b,item);
          return STATUS_VIRUS_CHECKER_UNAVAILABLE;
        }
 else         if (status == Curator.CURATE_FAIL) {
          backoutBitstream(subInfo,b,item);
          return STATUS_CONTAINS_VIRUS;
        }
      }
      context.commit();
      subInfo.setBitstream(b);
      if (bf == null) {
        return STATUS_UNKNOWN_FORMAT;
      }
    }
  }
  return STATUS_COMPLETE;
}",0.9974342527261064
52155,"@Override public ListItemsResults getItemsUntil(List<Filter> filters,int offset,int length,String setSpec,Date from){
  filters.add(new Filter(new DateFromFilter(from),FilterScope.Query));
  filters.add(new Filter(new DspaceSetSpecFilter(setSpec),FilterScope.Query));
  return this.getItems(filters,offset,length);
}","@Override public ListItemsResults getItemsUntil(List<Filter> filters,int offset,int length,String setSpec,Date from){
  filters.add(new Filter(new DateUntilFilter(from),FilterScope.Query));
  filters.add(new Filter(new DspaceSetSpecFilter(setSpec),FilterScope.Query));
  return this.getItems(filters,offset,length);
}",0.985781990521327
52156,"/** 
 * Find a particular Shibboleth header value and return the all values. The header name uses a bit of fuzzy logic, so it will first try case sensitive, then it will try lowercase, and finally it will try uppercase. Shibboleth attributes may contain multiple values separated by a semicolon and semicolons are escaped with a backslash. This method will split all the attributes into a list and unescape semicolons. If no attributes are found then null is returned.
 * @param request The HTTP request to look for headers values on.
 * @param name The name of the header
 * @return The list of values found, or null if none found.
 */
private List<String> findMultipleHeaders(HttpServletRequest request,String name){
  String values=findHeader(request,name);
  if (values == null)   return null;
  List<String> valueList=new ArrayList<String>();
  int idx=0;
  do {
    idx=values.indexOf(';',idx);
    if (idx == 0) {
      values=values.substring(1,values.length());
    }
 else     if (idx > 0 && values.charAt(idx - 1) != '\\') {
      idx++;
    }
 else     if (idx > 0) {
      String value=values.substring(0,idx);
      value=value.replaceAll(""String_Node_Str"",""String_Node_Str"");
      valueList.add(value);
      values=values.substring(idx + 1,values.length());
      idx=0;
    }
  }
 while (idx >= 0);
  if (values.length() > 0) {
    values=values.replaceAll(""String_Node_Str"",""String_Node_Str"");
    valueList.add(values);
  }
  return valueList;
}","/** 
 * Find a particular Shibboleth header value and return the all values. The header name uses a bit of fuzzy logic, so it will first try case sensitive, then it will try lowercase, and finally it will try uppercase. Shibboleth attributes may contain multiple values separated by a semicolon and semicolons are escaped with a backslash. This method will split all the attributes into a list and unescape semicolons. If no attributes are found then null is returned.
 * @param request The HTTP request to look for headers values on.
 * @param name The name of the header
 * @return The list of values found, or null if none found.
 */
private List<String> findMultipleHeaders(HttpServletRequest request,String name){
  String values=findHeader(request,name);
  if (values == null)   return null;
  List<String> valueList=new ArrayList<String>();
  int idx=0;
  do {
    idx=values.indexOf(';',idx);
    if (idx == 0) {
      values=values.substring(1,values.length());
    }
 else     if (idx > 0 && values.charAt(idx - 1) == '\\') {
      idx++;
    }
 else     if (idx > 0) {
      String value=values.substring(0,idx);
      value=value.replaceAll(""String_Node_Str"",""String_Node_Str"");
      valueList.add(value);
      values=values.substring(idx + 1,values.length());
      idx=0;
    }
  }
 while (idx >= 0);
  if (values.length() > 0) {
    values=values.replaceAll(""String_Node_Str"",""String_Node_Str"");
    valueList.add(values);
  }
  return valueList;
}",0.9993174061433449
52157,"/** 
 * Simple command-line rig for testing the DIM output of a stylesheet. Usage:  java XSLTDisseminationCrosswalk  <crosswalk-name> <handle> [output-file]
 */
public static void main(String[] argv) throws Exception {
  log.error(""String_Node_Str"");
  if (argv.length < 2 || argv.length > 3) {
    System.err.println(""String_Node_Str"");
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  String xwalkname=argv[0];
  String handle=argv[1];
  OutputStream out=System.out;
  if (argv.length > 2) {
    try {
      out=new FileOutputStream(argv[2]);
    }
 catch (    FileNotFoundException e) {
      System.err.println(""String_Node_Str"" + e.getMessage());
      System.err.println(""String_Node_Str"");
    }
  }
  DisseminationCrosswalk xwalk=(DisseminationCrosswalk)PluginManager.getNamedPlugin(DisseminationCrosswalk.class,xwalkname);
  if (xwalk == null) {
    System.err.println(""String_Node_Str"" + xwalkname + ""String_Node_Str"");
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  context=new Context();
  context.turnOffAuthorisationSystem();
  DSpaceObject dso=null;
  try {
    dso=HandleManager.resolveToObject(context,handle);
  }
 catch (  SQLException e) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  if (null == dso) {
    System.err.println(""String_Node_Str"" + handle + ""String_Node_Str"");
    System.exit(1);
  }
  if (!xwalk.canDisseminate(dso)) {
    System.err.println(""String_Node_Str"");
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  Element root=null;
  try {
    root=xwalk.disseminateElement(dso);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(e.getMessage());
    System.err.println(""String_Node_Str"");
    System.err.println(e.getStackTrace());
    System.err.println(""String_Node_Str"");
    log.error(""String_Node_Str"" + e.toString() + ""String_Node_Str"");
    log.error(e.getMessage());
    log.error(e.getStackTrace());
    System.exit(1);
  }
  try {
    XMLOutputter xmlout=new XMLOutputter(Format.getPrettyFormat());
    xmlout.output(new Document(root),out);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(e.getMessage());
    System.err.println(""String_Node_Str"");
    System.err.println(e.getStackTrace());
    System.err.println(""String_Node_Str"");
    log.error(""String_Node_Str"" + e.toString() + ""String_Node_Str"");
    log.error(e.getMessage());
    log.error(e.getStackTrace());
    System.exit(1);
  }
  context.complete();
  if (out instanceof FileOutputStream) {
    out.close();
  }
}","/** 
 * Simple command-line rig for testing the DIM output of a stylesheet. Usage:  java XSLTDisseminationCrosswalk  <crosswalk-name> <handle> [output-file]
 */
public static void main(String[] argv) throws Exception {
  log.error(""String_Node_Str"");
  if (argv.length < 2 || argv.length > 3) {
    System.err.println(""String_Node_Str"");
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  String xwalkname=argv[0];
  String handle=argv[1];
  OutputStream out=System.out;
  if (argv.length > 2) {
    try {
      out=new FileOutputStream(argv[2]);
    }
 catch (    FileNotFoundException e) {
      System.err.println(""String_Node_Str"" + e.getMessage());
      System.err.println(""String_Node_Str"");
    }
  }
  DisseminationCrosswalk xwalk=(DisseminationCrosswalk)PluginManager.getNamedPlugin(DisseminationCrosswalk.class,xwalkname);
  if (xwalk == null) {
    System.err.println(""String_Node_Str"" + xwalkname + ""String_Node_Str"");
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  context=new Context();
  context.turnOffAuthorisationSystem();
  DSpaceObject dso=null;
  try {
    dso=HandleManager.resolveToObject(context,handle);
  }
 catch (  SQLException e) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  if (null == dso) {
    System.err.println(""String_Node_Str"" + handle + ""String_Node_Str"");
    System.exit(1);
  }
  if (!xwalk.canDisseminate(dso)) {
    System.err.println(""String_Node_Str"");
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  Element root=null;
  try {
    root=xwalk.disseminateElement(dso);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(e.getMessage());
    System.err.println(""String_Node_Str"");
    e.printStackTrace();
    System.err.println(""String_Node_Str"");
    log.error(""String_Node_Str"" + e.toString() + ""String_Node_Str"");
    log.error(e.getMessage());
    log.error(e.getStackTrace());
    System.exit(1);
  }
  try {
    XMLOutputter xmlout=new XMLOutputter(Format.getPrettyFormat());
    xmlout.output(new Document(root),out);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(e.getMessage());
    System.err.println(""String_Node_Str"");
    System.err.println(e.getStackTrace());
    System.err.println(""String_Node_Str"");
    log.error(""String_Node_Str"" + e.toString() + ""String_Node_Str"");
    log.error(e.getMessage());
    log.error(e.getStackTrace());
    System.exit(1);
  }
  context.complete();
  if (out instanceof FileOutputStream) {
    out.close();
  }
}",0.9944362017804156
52158,"public void addBody(Body body) throws SAXException, WingException, SQLException, IOException {
  int collectionID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  Collection collection=Collection.find(context,collectionID);
  String query=decodeFromURL(parameters.getParameter(""String_Node_Str"",null));
  java.util.List<Item> items=preformSearch(collection,query);
  Division div=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_GET,""String_Node_Str"");
  div.setHead(T_head1.parameterize(query));
  Para actions=div.addPara();
  actions.addButton(""String_Node_Str"").setValue(T_submit_map);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  Table table=div.addTable(""String_Node_Str"",1,1);
  Row header=table.addRow(Row.ROLE_HEADER);
  header.addCellContent(T_column1);
  header.addCellContent(T_column2);
  header.addCellContent(T_column3);
  header.addCellContent(T_column4);
  for (  Item item : items) {
    String itemID=String.valueOf(item.getID());
    Collection owningCollection=item.getOwningCollection();
    String owning=owningCollection.getMetadata(""String_Node_Str"");
    String author=""String_Node_Str"";
    DCValue[] dcAuthors=item.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    if (dcAuthors != null && dcAuthors.length >= 1) {
      author=dcAuthors[0].value;
    }
    String title=""String_Node_Str"";
    DCValue[] dcTitles=item.getDC(""String_Node_Str"",null,Item.ANY);
    if (dcTitles != null && dcTitles.length >= 1) {
      title=dcTitles[0].value;
    }
    String url=contextPath + ""String_Node_Str"" + item.getHandle();
    Row row=table.addRow();
    boolean canBeMapped=true;
    Collection[] collections=item.getCollections();
    for (    Collection c : collections) {
      if (c.getID() == collectionID) {
        canBeMapped=false;
      }
    }
    if (canBeMapped) {
      CheckBox select=row.addCell().addCheckBox(""String_Node_Str"");
      select.setLabel(""String_Node_Str"");
      select.addOption(itemID);
    }
 else {
      row.addCell().addContent(""String_Node_Str"");
    }
    row.addCellContent(owning);
    row.addCell().addXref(url,author);
    row.addCell().addXref(url,title);
  }
  actions=div.addPara();
  actions.addButton(""String_Node_Str"").setValue(T_submit_map);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, SQLException, IOException {
  int collectionID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  Collection collection=Collection.find(context,collectionID);
  String query=decodeFromURL(parameters.getParameter(""String_Node_Str"",null));
  java.util.List<Item> items=preformSearch(collection,query);
  Division div=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_GET,""String_Node_Str"");
  div.setHead(T_head1.parameterize(query));
  Para actions=div.addPara();
  actions.addButton(""String_Node_Str"").setValue(T_submit_map);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  Table table=div.addTable(""String_Node_Str"",1,1);
  Row header=table.addRow(Row.ROLE_HEADER);
  header.addCellContent(T_column1);
  header.addCellContent(T_column2);
  header.addCellContent(T_column3);
  header.addCellContent(T_column4);
  for (  Item item : items) {
    String itemID=String.valueOf(item.getID());
    Collection owningCollection=item.getOwningCollection();
    String owning=""String_Node_Str"";
    if (owningCollection != null)     owning=owningCollection.getMetadata(""String_Node_Str"");
    String author=""String_Node_Str"";
    DCValue[] dcCreators=item.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    if (dcCreators != null && dcCreators.length >= 1) {
      author=dcCreators[0].value;
    }
 else {
      DCValue[] dcContributors=item.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
      if (dcContributors != null && dcContributors.length >= 1) {
        author=dcContributors[0].value;
      }
    }
    String title=""String_Node_Str"";
    DCValue[] dcTitles=item.getDC(""String_Node_Str"",null,Item.ANY);
    if (dcTitles != null && dcTitles.length >= 1) {
      title=dcTitles[0].value;
    }
    String url=contextPath + ""String_Node_Str"" + item.getHandle();
    Row row=table.addRow();
    boolean canBeMapped=true;
    Collection[] collections=item.getCollections();
    for (    Collection c : collections) {
      if (c.getID() == collectionID) {
        canBeMapped=false;
      }
    }
    if (canBeMapped) {
      CheckBox select=row.addCell().addCheckBox(""String_Node_Str"");
      select.setLabel(""String_Node_Str"");
      select.addOption(itemID);
    }
 else {
      row.addCell().addContent(""String_Node_Str"");
    }
    row.addCellContent(owning);
    row.addCell().addXref(url,author);
    row.addCell().addXref(url,title);
  }
  actions=div.addPara();
  actions.addButton(""String_Node_Str"").setValue(T_submit_map);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}",0.9000392003136025
52159,"/** 
 * Start the authentication process. This packages up the request that led to authentication being required, and then invokes the site-specific authentication method. If it returns true, the user was authenticated without any redirection (e.g. by an X.509 certificate or other implicit method) so the process that called this can continue and send its own response. A ""false"" result means this method has sent its own redirect.
 * @param context current DSpace context
 * @param request current HTTP request - the one that prompted authentication
 * @param response current HTTP response
 * @return true if authentication is already finished (implicit method)
 */
public static boolean startAuthentication(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  HttpSession session=request.getSession();
  if (AuthenticationManager.authenticateImplicit(context,null,null,null,request) == AuthenticationMethod.SUCCESS) {
    loggedIn(context,request,context.getCurrentUser());
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    return true;
  }
 else {
    response.addDateHeader(""String_Node_Str"",1);
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    RequestInfo info=new RequestInfo(request);
    session.setAttribute(""String_Node_Str"",info);
    session.setAttribute(""String_Node_Str"",UIUtil.getOriginalURL(request));
    Iterator ai=AuthenticationManager.authenticationMethodIterator();
    AuthenticationMethod am;
    int count=0;
    String url=null;
    while (ai.hasNext()) {
      String s;
      am=(AuthenticationMethod)ai.next();
      s=am.loginPageURL(context,request,response);
      if (s != null) {
        url=s;
        ++count;
      }
    }
    if (count == 1) {
      response.sendRedirect(url);
    }
 else {
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
  return false;
}","/** 
 * Start the authentication process. This packages up the request that led to authentication being required, and then invokes the site-specific authentication method. If it returns true, the user was authenticated without any redirection (e.g. by an X.509 certificate or other implicit method) so the process that called this can continue and send its own response. A ""false"" result means this method has sent its own redirect.
 * @param context current DSpace context
 * @param request current HTTP request - the one that prompted authentication
 * @param response current HTTP response
 * @return true if authentication is already finished (implicit method)
 */
public static boolean startAuthentication(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  HttpSession session=request.getSession();
  if (AuthenticationManager.authenticateImplicit(context,null,null,null,request) == AuthenticationMethod.SUCCESS) {
    loggedIn(context,request,context.getCurrentUser());
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    if (context.getCurrentUser() != null) {
      Authenticate.resumeInterruptedRequest(request,response);
      return false;
    }
 else {
      return true;
    }
  }
 else {
    response.addDateHeader(""String_Node_Str"",1);
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    RequestInfo info=new RequestInfo(request);
    session.setAttribute(""String_Node_Str"",info);
    session.setAttribute(""String_Node_Str"",UIUtil.getOriginalURL(request));
    Iterator ai=AuthenticationManager.authenticationMethodIterator();
    AuthenticationMethod am;
    int count=0;
    String url=null;
    while (ai.hasNext()) {
      String s;
      am=(AuthenticationMethod)ai.next();
      s=am.loginPageURL(context,request,response);
      if (s != null) {
        url=s;
        ++count;
      }
    }
    if (count == 1) {
      response.sendRedirect(url);
    }
 else {
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
  return false;
}",0.9581822576746436
52160,"public void setDefaultSort(boolean defaultSort){
  this.defaultSort=defaultSort;
}","public void setDefaultSort(DiscoverySortFieldConfiguration defaultSort){
  this.defaultSort=defaultSort;
}",0.851063829787234
52161,"/** 
 * Query DSpace for a list of all items / collections / or communities that match the given search query.
 * @param scope the dspace object parent
 */
public void performSearch(DSpaceObject scope) throws UIException, SearchServiceException {
  if (queryResults != null) {
    return;
  }
  String query=getQuery();
  int page=getParameterPage();
  List<String> filterQueries=new ArrayList<String>();
  String[] fqs=getFilterQueries();
  if (fqs != null) {
    filterQueries.addAll(Arrays.asList(fqs));
  }
  this.queryArgs=new DiscoverQuery();
  DiscoveryConfiguration discoveryConfiguration=SearchUtils.getDiscoveryConfiguration(scope);
  List<String> defaultFilterQueries=discoveryConfiguration.getDefaultFilterQueries();
  queryArgs.addFilterQueries(defaultFilterQueries.toArray(new String[defaultFilterQueries.size()]));
  if (filterQueries.size() > 0) {
    queryArgs.addFilterQueries(filterQueries.toArray(new String[filterQueries.size()]));
  }
  queryArgs.setMaxResults(getParameterRpp());
  String sortBy=ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
  if (sortBy == null) {
    sortBy=""String_Node_Str"";
    List<DiscoverySortConfiguration> searchSortFields=discoveryConfiguration.getSearchSortFields();
    for (    DiscoverySortConfiguration sortConfiguration : searchSortFields) {
      if (sortConfiguration.isDefaultSort()) {
        sortBy=SearchUtils.getSearchService().toSortFieldIndex(sortConfiguration.getMetadataField(),sortConfiguration.getType());
      }
    }
  }
  String sortOrder=ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
  if (sortOrder == null) {
    sortOrder=new DSpace().getConfigurationService().getProperty(""String_Node_Str"");
  }
  if (sortOrder == null || sortOrder.equals(""String_Node_Str"")) {
    queryArgs.setSortField(sortBy,DiscoverQuery.SORT_ORDER.desc);
  }
 else {
    queryArgs.setSortField(sortBy,DiscoverQuery.SORT_ORDER.asc);
  }
  String groupBy=ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
  if (groupBy != null && !groupBy.equalsIgnoreCase(""String_Node_Str"")) {
    queryArgs.addProperty(""String_Node_Str"",groupBy);
    queryArgs.addProperty(""String_Node_Str"",""String_Node_Str"");
    queryArgs.addProperty(""String_Node_Str"",""String_Node_Str"");
    queryArgs.addProperty(""String_Node_Str"",""String_Node_Str"");
    queryArgs.setSortField(""String_Node_Str"",DiscoverQuery.SORT_ORDER.asc);
  }
  queryArgs.setQuery(query != null && !query.trim().equals(""String_Node_Str"") ? query : null);
  if (page > 1) {
    queryArgs.setStart((page - 1) * queryArgs.getMaxResults());
  }
 else {
    queryArgs.setStart(0);
  }
  this.queryResults=SearchUtils.getSearchService().search(context,scope,queryArgs);
}","/** 
 * Query DSpace for a list of all items / collections / or communities that match the given search query.
 * @param scope the dspace object parent
 */
public void performSearch(DSpaceObject scope) throws UIException, SearchServiceException {
  if (queryResults != null) {
    return;
  }
  String query=getQuery();
  int page=getParameterPage();
  List<String> filterQueries=new ArrayList<String>();
  String[] fqs=getFilterQueries();
  if (fqs != null) {
    filterQueries.addAll(Arrays.asList(fqs));
  }
  this.queryArgs=new DiscoverQuery();
  DiscoveryConfiguration discoveryConfiguration=SearchUtils.getDiscoveryConfiguration(scope);
  List<String> defaultFilterQueries=discoveryConfiguration.getDefaultFilterQueries();
  queryArgs.addFilterQueries(defaultFilterQueries.toArray(new String[defaultFilterQueries.size()]));
  if (filterQueries.size() > 0) {
    queryArgs.addFilterQueries(filterQueries.toArray(new String[filterQueries.size()]));
  }
  queryArgs.setMaxResults(getParameterRpp());
  String sortBy=ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
  DiscoverySortConfiguration searchSortConfiguration=discoveryConfiguration.getSearchSortConfiguration();
  if (sortBy == null) {
    sortBy=""String_Node_Str"";
    if (searchSortConfiguration != null) {
      for (      DiscoverySortFieldConfiguration sortFieldConfiguration : searchSortConfiguration.getSortFields()) {
        if (sortFieldConfiguration.equals(searchSortConfiguration.getDefaultSort())) {
          sortBy=SearchUtils.getSearchService().toSortFieldIndex(sortFieldConfiguration.getMetadataField(),sortFieldConfiguration.getType());
        }
      }
    }
  }
  String sortOrder=ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
  if (sortOrder == null && searchSortConfiguration != null) {
    sortOrder=searchSortConfiguration.getDefaultSortOrder().toString();
  }
  if (sortOrder == null || sortOrder.equalsIgnoreCase(""String_Node_Str"")) {
    queryArgs.setSortField(sortBy,DiscoverQuery.SORT_ORDER.desc);
  }
 else {
    queryArgs.setSortField(sortBy,DiscoverQuery.SORT_ORDER.asc);
  }
  String groupBy=ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
  if (groupBy != null && !groupBy.equalsIgnoreCase(""String_Node_Str"")) {
    queryArgs.addProperty(""String_Node_Str"",groupBy);
    queryArgs.addProperty(""String_Node_Str"",""String_Node_Str"");
    queryArgs.addProperty(""String_Node_Str"",""String_Node_Str"");
    queryArgs.addProperty(""String_Node_Str"",""String_Node_Str"");
    queryArgs.setSortField(""String_Node_Str"",DiscoverQuery.SORT_ORDER.asc);
  }
  queryArgs.setQuery(query != null && !query.trim().equals(""String_Node_Str"") ? query : null);
  if (page > 1) {
    queryArgs.setStart((page - 1) * queryArgs.getMaxResults());
  }
 else {
    queryArgs.setStart(0);
  }
  this.queryResults=SearchUtils.getSearchService().search(context,scope,queryArgs);
}",0.8915960451977402
52162,"protected String getParameterOrder(){
  String sortOrder=ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
  if (sortOrder == null) {
    sortOrder=new DSpace().getConfigurationService().getProperty(""String_Node_Str"");
  }
  return sortOrder;
}","protected String getParameterOrder(){
  return ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
}",0.6122448979591837
52163,"protected void buildSearchControls(Division div) throws WingException, SQLException {
  org.dspace.app.xmlui.wing.element.List controlsList=div.addList(""String_Node_Str"",org.dspace.app.xmlui.wing.element.List.TYPE_FORM);
  controlsList.setHead(T_sort_head);
  org.dspace.app.xmlui.wing.element.Item controlsItem=controlsList.addItem();
  controlsItem.addContent(T_rpp);
  Select rppSelect=controlsItem.addSelect(""String_Node_Str"");
  for (  int i : RESULTS_PER_PAGE_PROGRESSION) {
    rppSelect.addOption((i == getParameterRpp()),i,Integer.toString(i));
  }
  controlsItem.addContent(T_sort_by);
  Select sortSelect=controlsItem.addSelect(""String_Node_Str"");
  sortSelect.addOption(false,""String_Node_Str"",T_sort_by_relevance);
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  DiscoveryConfiguration discoveryConfiguration=SearchUtils.getDiscoveryConfiguration(dso);
  for (  DiscoverySortConfiguration sortConfiguration : discoveryConfiguration.getSearchSortFields()) {
    String sortField=SearchUtils.getSearchService().toSortFieldIndex(sortConfiguration.getMetadataField(),sortConfiguration.getType());
    String currentSort=getParameterSortBy();
    sortSelect.addOption((sortField.equals(currentSort) || sortConfiguration.isDefaultSort()),sortField,message(""String_Node_Str"" + sortField));
  }
  controlsItem.addContent(T_order);
  Select orderSelect=controlsItem.addSelect(""String_Node_Str"");
  orderSelect.addOption(SortOption.ASCENDING.equals(getParameterOrder()),SortOption.ASCENDING,T_order_asc);
  orderSelect.addOption(SortOption.DESCENDING.equals(getParameterOrder()),SortOption.DESCENDING,T_order_desc);
  controlsItem.addButton(""String_Node_Str"").setValue(T_sort_button);
}","protected void buildSearchControls(Division div) throws WingException, SQLException {
  org.dspace.app.xmlui.wing.element.List controlsList=div.addList(""String_Node_Str"",org.dspace.app.xmlui.wing.element.List.TYPE_FORM);
  controlsList.setHead(T_sort_head);
  org.dspace.app.xmlui.wing.element.Item controlsItem=controlsList.addItem();
  controlsItem.addContent(T_rpp);
  Select rppSelect=controlsItem.addSelect(""String_Node_Str"");
  for (  int i : RESULTS_PER_PAGE_PROGRESSION) {
    rppSelect.addOption((i == getParameterRpp()),i,Integer.toString(i));
  }
  controlsItem.addContent(T_sort_by);
  Select sortSelect=controlsItem.addSelect(""String_Node_Str"");
  sortSelect.addOption(false,""String_Node_Str"",T_sort_by_relevance);
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  DiscoveryConfiguration discoveryConfiguration=SearchUtils.getDiscoveryConfiguration(dso);
  DiscoverySortConfiguration searchSortConfiguration=discoveryConfiguration.getSearchSortConfiguration();
  if (searchSortConfiguration != null) {
    for (    DiscoverySortFieldConfiguration sortFieldConfiguration : searchSortConfiguration.getSortFields()) {
      String sortField=SearchUtils.getSearchService().toSortFieldIndex(sortFieldConfiguration.getMetadataField(),sortFieldConfiguration.getType());
      String currentSort=getParameterSortBy();
      sortSelect.addOption((sortField.equals(currentSort) || sortFieldConfiguration.equals(searchSortConfiguration.getDefaultSort())),sortField,message(""String_Node_Str"" + sortField));
    }
  }
  controlsItem.addContent(T_order);
  Select orderSelect=controlsItem.addSelect(""String_Node_Str"");
  String parameterOrder=getParameterOrder();
  if (parameterOrder == null && searchSortConfiguration != null) {
    parameterOrder=searchSortConfiguration.getDefaultSortOrder().toString();
  }
  orderSelect.addOption(SortOption.ASCENDING.equalsIgnoreCase(parameterOrder),SortOption.ASCENDING,T_order_asc);
  orderSelect.addOption(SortOption.DESCENDING.equalsIgnoreCase(parameterOrder),SortOption.DESCENDING,T_order_desc);
  controlsItem.addButton(""String_Node_Str"").setValue(T_sort_button);
}",0.855197695731867
52164,"/** 
 * Generate a url to the simple search url.
 */
protected String generateURL(Map<String,String> parameters) throws UIException {
  String query=getQuery();
  if (!""String_Node_Str"".equals(query)) {
    parameters.put(""String_Node_Str"",encodeForURL(query));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterPage()));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterRpp()));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(this.getParameterGroup()));
  }
  if (getParameterSortBy() != null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterSortBy()));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",getParameterOrder());
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterEtAl()));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",getParameterScope());
  }
  return AbstractDSpaceTransformer.generateURL(""String_Node_Str"",parameters);
}","/** 
 * Generate a url to the simple search url.
 */
protected String generateURL(Map<String,String> parameters) throws UIException {
  String query=getQuery();
  if (!""String_Node_Str"".equals(query)) {
    parameters.put(""String_Node_Str"",encodeForURL(query));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterPage()));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterRpp()));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(this.getParameterGroup()));
  }
  if (parameters.get(""String_Node_Str"") == null && getParameterSortBy() != null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterSortBy()));
  }
  if (parameters.get(""String_Node_Str"") == null && getParameterOrder() != null) {
    parameters.put(""String_Node_Str"",getParameterOrder());
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterEtAl()));
  }
  if (parameters.get(""String_Node_Str"") == null && getParameterScope() != null) {
    parameters.put(""String_Node_Str"",getParameterScope());
  }
  return AbstractDSpaceTransformer.generateURL(""String_Node_Str"",parameters);
}",0.9577242196760174
52165,"@Override public ActionResult execute(Context c,XmlWorkflowItem wfi,Step step,HttpServletRequest request) throws SQLException, AuthorizeException, IOException {
  if (request.getParameter(""String_Node_Str"") != null) {
    WorkflowRequirementsManager.addClaimedUser(c,wfi,step,c.getCurrentUser());
    return new ActionResult(ActionResult.TYPE.TYPE_OUTCOME,ActionResult.OUTCOME_COMPLETE);
  }
 else {
    return new ActionResult(ActionResult.TYPE.TYPE_CANCEL);
  }
}","@Override public ActionResult execute(Context c,XmlWorkflowItem wfi,Step step,HttpServletRequest request) throws SQLException, AuthorizeException, IOException {
  if (request.getParameter(""String_Node_Str"") != null || request.getParameter(""String_Node_Str"") != null) {
    WorkflowRequirementsManager.addClaimedUser(c,wfi,step,c.getCurrentUser());
    return new ActionResult(ActionResult.TYPE.TYPE_OUTCOME,ActionResult.OUTCOME_COMPLETE);
  }
 else {
    return new ActionResult(ActionResult.TYPE.TYPE_CANCEL);
  }
}",0.9480122324159022
52166,"/** 
 * If the user has any workflow tasks, either assigned to them or in an available pool of tasks, then build two tables listing each of these queues. If the user dosn't have any workflows then don't do anything.
 * @param division The division to add the two queues too.
 */
private void addWorkflowTasks(Division division) throws SQLException, WingException, AuthorizeException, IOException {
  @SuppressWarnings(""String_Node_Str"") java.util.List<ClaimedTask> ownedItems=ClaimedTask.findByEperson(context,context.getCurrentUser().getID());
  @SuppressWarnings(""String_Node_Str"") java.util.List<PoolTask> pooledItems=PoolTask.findByEperson(context,context.getCurrentUser().getID());
  if (!(ownedItems.size() > 0 || pooledItems.size() > 0))   return;
  Division workflow=division.addDivision(""String_Node_Str"");
  workflow.setHead(T_w_head1);
  workflow.addPara(T_w_info1);
  Table table=workflow.addTable(""String_Node_Str"",ownedItems.size() + 2,5);
  table.setHead(T_w_head2);
  Row header=table.addRow(Row.ROLE_HEADER);
  header.addCellContent(T_w_column1);
  header.addCellContent(T_w_column2);
  header.addCellContent(T_w_column3);
  header.addCellContent(T_w_column4);
  header.addCellContent(T_w_column5);
  boolean showReturnToPoolButton=false;
  if (ownedItems.size() > 0) {
    for (    ClaimedTask owned : ownedItems) {
      int workflowItemID=owned.getWorkflowItemID();
      String step_id=owned.getStepID();
      String action_id=owned.getActionID();
      XmlWorkflowItem item=null;
      try {
        item=XmlWorkflowItem.find(context,workflowItemID);
        Workflow wf=WorkflowFactory.getWorkflow(item.getCollection());
        Step step=wf.getStep(step_id);
        WorkflowActionConfig action=step.getActionConfig(action_id);
        String url=contextPath + ""String_Node_Str"" + item.getCollection().getHandle()+ ""String_Node_Str""+ workflowItemID+ ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id;
        DCValue[] titles=item.getItem().getDC(""String_Node_Str"",null,Item.ANY);
        String collectionName=item.getCollection().getMetadata(""String_Node_Str"");
        EPerson submitter=item.getSubmitter();
        String submitterName=submitter.getFullName();
        String submitterEmail=submitter.getEmail();
        boolean taskHasPool=step.getUserSelectionMethod().getProcessingAction().usesTaskPool();
        if (taskHasPool) {
          showReturnToPoolButton=true;
        }
        Row row=table.addRow();
        Cell firstCell=row.addCell();
        if (taskHasPool) {
          CheckBox remove=firstCell.addCheckBox(""String_Node_Str"");
          remove.setLabel(""String_Node_Str"");
          remove.addOption(workflowItemID + ""String_Node_Str"" + step.getId());
        }
        row.addCell().addXref(url,message(""String_Node_Str"" + wf.getID() + ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id));
        if (titles != null && titles.length > 0) {
          String displayTitle=titles[0].value;
          if (displayTitle.length() > 50)           displayTitle=displayTitle.substring(0,50) + ""String_Node_Str"";
          row.addCell().addXref(url,displayTitle);
        }
 else         row.addCell().addXref(url,T_untitled);
        row.addCell().addXref(url,collectionName);
        Cell cell=row.addCell();
        cell.addContent(T_email);
        cell.addXref(""String_Node_Str"" + submitterEmail,submitterName);
      }
 catch (      WorkflowConfigurationException e) {
        Row row=table.addRow();
        row.addCell().addContent(""String_Node_Str"");
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
catch (      Exception e) {
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
    }
    if (showReturnToPoolButton) {
      Row row=table.addRow();
      row.addCell(0,5).addButton(""String_Node_Str"").setValue(T_w_submit_return);
    }
  }
 else {
    Row row=table.addRow();
    row.addCell(0,5).addHighlight(""String_Node_Str"").addContent(T_w_info2);
  }
  table=workflow.addTable(""String_Node_Str"",pooledItems.size() + 2,5);
  table.setHead(T_w_head3);
  header=table.addRow(Row.ROLE_HEADER);
  header.addCellContent(T_w_column2);
  header.addCellContent(T_w_column3);
  header.addCellContent(T_w_column4);
  header.addCellContent(T_w_column5);
  if (pooledItems.size() > 0) {
    for (    PoolTask pooled : pooledItems) {
      String step_id=pooled.getStepID();
      int workflowItemID=pooled.getWorkflowItemID();
      String action_id=pooled.getActionID();
      XmlWorkflowItem item;
      try {
        item=XmlWorkflowItem.find(context,workflowItemID);
        Workflow wf=WorkflowFactory.getWorkflow(item.getCollection());
        Step step=wf.getStep(step_id);
        String url=contextPath + ""String_Node_Str"" + item.getCollection().getHandle()+ ""String_Node_Str""+ workflowItemID+ ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id;
        DCValue[] titles=item.getItem().getDC(""String_Node_Str"",null,Item.ANY);
        String collectionName=item.getCollection().getMetadata(""String_Node_Str"");
        EPerson submitter=item.getSubmitter();
        String submitterName=submitter.getFullName();
        String submitterEmail=submitter.getEmail();
        Row row=table.addRow();
        row.addCell().addXref(url,message(""String_Node_Str"" + wf.getID() + ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id));
        if (titles != null && titles.length > 0) {
          String displayTitle=titles[0].value;
          if (displayTitle.length() > 50)           displayTitle=displayTitle.substring(0,50) + ""String_Node_Str"";
          row.addCell().addXref(url,displayTitle);
        }
 else         row.addCell().addXref(url,T_untitled);
        row.addCell().addXref(url,collectionName);
        Cell cell=row.addCell();
        cell.addContent(T_email);
        cell.addXref(""String_Node_Str"" + submitterEmail,submitterName);
      }
 catch (      WorkflowConfigurationException e) {
        Row row=table.addRow();
        row.addCell().addContent(""String_Node_Str"");
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
catch (      Exception e) {
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
    }
  }
 else {
    Row row=table.addRow();
    row.addCell(0,4).addHighlight(""String_Node_Str"").addContent(T_w_info3);
  }
}","/** 
 * If the user has any workflow tasks, either assigned to them or in an available pool of tasks, then build two tables listing each of these queues. If the user dosn't have any workflows then don't do anything.
 * @param division The division to add the two queues too.
 */
private void addWorkflowTasks(Division division) throws SQLException, WingException, AuthorizeException, IOException {
  @SuppressWarnings(""String_Node_Str"") java.util.List<ClaimedTask> ownedItems=ClaimedTask.findByEperson(context,context.getCurrentUser().getID());
  @SuppressWarnings(""String_Node_Str"") java.util.List<PoolTask> pooledItems=PoolTask.findByEperson(context,context.getCurrentUser().getID());
  if (!(ownedItems.size() > 0 || pooledItems.size() > 0))   return;
  Division workflow=division.addDivision(""String_Node_Str"");
  workflow.setHead(T_w_head1);
  workflow.addPara(T_w_info1);
  Table table=workflow.addTable(""String_Node_Str"",ownedItems.size() + 2,5);
  table.setHead(T_w_head2);
  Row header=table.addRow(Row.ROLE_HEADER);
  header.addCellContent(T_w_column1);
  header.addCellContent(T_w_column2);
  header.addCellContent(T_w_column3);
  header.addCellContent(T_w_column4);
  header.addCellContent(T_w_column5);
  boolean showReturnToPoolButton=false;
  if (ownedItems.size() > 0) {
    for (    ClaimedTask owned : ownedItems) {
      int workflowItemID=owned.getWorkflowItemID();
      String step_id=owned.getStepID();
      String action_id=owned.getActionID();
      XmlWorkflowItem item=null;
      try {
        item=XmlWorkflowItem.find(context,workflowItemID);
        Workflow wf=WorkflowFactory.getWorkflow(item.getCollection());
        Step step=wf.getStep(step_id);
        WorkflowActionConfig action=step.getActionConfig(action_id);
        String url=contextPath + ""String_Node_Str"" + item.getCollection().getHandle()+ ""String_Node_Str""+ workflowItemID+ ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id;
        DCValue[] titles=item.getItem().getDC(""String_Node_Str"",null,Item.ANY);
        String collectionName=item.getCollection().getMetadata(""String_Node_Str"");
        EPerson submitter=item.getSubmitter();
        String submitterName=submitter.getFullName();
        String submitterEmail=submitter.getEmail();
        boolean taskHasPool=step.getUserSelectionMethod().getProcessingAction().usesTaskPool();
        if (taskHasPool) {
          showReturnToPoolButton=true;
        }
        Row row=table.addRow();
        Cell firstCell=row.addCell();
        if (taskHasPool) {
          CheckBox remove=firstCell.addCheckBox(""String_Node_Str"");
          remove.setLabel(""String_Node_Str"");
          remove.addOption(workflowItemID + ""String_Node_Str"" + step.getId());
        }
        row.addCell().addXref(url,message(""String_Node_Str"" + wf.getID() + ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id));
        if (titles != null && titles.length > 0) {
          String displayTitle=titles[0].value;
          if (displayTitle.length() > 50)           displayTitle=displayTitle.substring(0,50) + ""String_Node_Str"";
          row.addCell().addXref(url,displayTitle);
        }
 else         row.addCell().addXref(url,T_untitled);
        row.addCell().addXref(url,collectionName);
        Cell cell=row.addCell();
        cell.addContent(T_email);
        cell.addXref(""String_Node_Str"" + submitterEmail,submitterName);
      }
 catch (      WorkflowConfigurationException e) {
        Row row=table.addRow();
        row.addCell().addContent(""String_Node_Str"");
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
catch (      Exception e) {
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
    }
    if (showReturnToPoolButton) {
      Row row=table.addRow();
      row.addCell(0,5).addButton(""String_Node_Str"").setValue(T_w_submit_return);
    }
  }
 else {
    Row row=table.addRow();
    row.addCell(0,5).addHighlight(""String_Node_Str"").addContent(T_w_info2);
  }
  table=workflow.addTable(""String_Node_Str"",pooledItems.size() + 2,5);
  table.setHead(T_w_head3);
  header=table.addRow(Row.ROLE_HEADER);
  header.addCellContent(T_w_column1);
  header.addCellContent(T_w_column2);
  header.addCellContent(T_w_column3);
  header.addCellContent(T_w_column4);
  header.addCellContent(T_w_column5);
  if (pooledItems.size() > 0) {
    for (    PoolTask pooled : pooledItems) {
      String step_id=pooled.getStepID();
      int workflowItemID=pooled.getWorkflowItemID();
      String action_id=pooled.getActionID();
      XmlWorkflowItem item;
      try {
        item=XmlWorkflowItem.find(context,workflowItemID);
        Workflow wf=WorkflowFactory.getWorkflow(item.getCollection());
        String url=contextPath + ""String_Node_Str"" + item.getCollection().getHandle()+ ""String_Node_Str""+ workflowItemID+ ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id;
        DCValue[] titles=item.getItem().getDC(""String_Node_Str"",null,Item.ANY);
        String collectionName=item.getCollection().getMetadata(""String_Node_Str"");
        EPerson submitter=item.getSubmitter();
        String submitterName=submitter.getFullName();
        String submitterEmail=submitter.getEmail();
        Row row=table.addRow();
        CheckBox claimTask=row.addCell().addCheckBox(""String_Node_Str"");
        claimTask.setLabel(""String_Node_Str"");
        claimTask.addOption(workflowItemID);
        row.addCell().addXref(url,message(""String_Node_Str"" + wf.getID() + ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id));
        if (titles != null && titles.length > 0) {
          String displayTitle=titles[0].value;
          if (displayTitle.length() > 50)           displayTitle=displayTitle.substring(0,50) + ""String_Node_Str"";
          row.addCell().addXref(url,displayTitle);
        }
 else         row.addCell().addXref(url,T_untitled);
        row.addCell().addXref(url,collectionName);
        Cell cell=row.addCell();
        cell.addContent(T_email);
        cell.addXref(""String_Node_Str"" + submitterEmail,submitterName);
      }
 catch (      WorkflowConfigurationException e) {
        Row row=table.addRow();
        row.addCell().addContent(""String_Node_Str"");
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
catch (      Exception e) {
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
    }
    Row row=table.addRow();
    row.addCell(0,5).addButton(""String_Node_Str"").setValue(T_w_submit_take);
  }
 else {
    Row row=table.addRow();
    row.addCell(0,4).addHighlight(""String_Node_Str"").addContent(T_w_info3);
  }
}",0.9734486188690796
52167,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  String handle=parameters.getParameter(""String_Node_Str"",null);
  Division main=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  main.setHead(T_main_head.parameterize(handle));
  Request request=ObjectModelHelper.getRequest(objectModel);
  ServiceDocument serviceDoc=(ServiceDocument)request.getAttribute(""String_Node_Str"");
  java.util.List<Collection> collections=ServiceDocumentHelper.getCollections(serviceDoc);
  List collectionsList=main.addList(""String_Node_Str"",List.TYPE_SIMPLE);
  for (  Collection collection : collections) {
    List collectionList=collectionsList.addList(collection + ""String_Node_Str"",List.TYPE_FORM);
    collectionList.setHead(T_collection_head.parameterize(collection.getLocation()));
    List paramsList=collectionList.addList(collection + ""String_Node_Str"",List.TYPE_BULLETED);
    paramsList.addItem().addContent(T_collection_title.parameterize(collection.getTitle()));
    paramsList.addItem().addContent(T_collection_policy.parameterize(collection.getCollectionPolicy()));
    paramsList.addItem().addContent(T_collection_mediation.parameterize(Boolean.toString(collection.getMediation())));
    String[] fileTypes=collection.getAccepts();
    String fileTypesString=arrayToString(fileTypes);
    paramsList.addItem().addContent(T_collection_file_types.parameterize(fileTypesString));
    String[] packageFormats=ServiceDocumentHelper.getPackageFormats(collection);
    String packageFormatsString=arrayToString(packageFormats);
    paramsList.addItem().addContent(T_collection_package_formats.parameterize(packageFormatsString));
    if ((fileTypes.length > 0) && (packageFormats.length > 0)) {
      collectionList.addItem().addHidden(""String_Node_Str"").setValue(collection.getLocation());
      collectionList.addItem().addButton(""String_Node_Str"").setValue(T_collection_deposit_button);
    }
    if ((collection.getService() != null) && (collection.getService().length() > 0)) {
      collectionList.addItem().addContent(T_sub_service_target + collection.getService());
      collectionList.addItem().addHidden(""String_Node_Str"").setValue(collection.getService());
      collectionList.addItem().addButton(""String_Node_Str"").setValue(T_sub_service_target_button);
    }
  }
  Para buttonList=main.addPara();
  buttonList.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  main.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  String handle=parameters.getParameter(""String_Node_Str"",null);
  Division main=body.addDivision(""String_Node_Str"");
  main.setHead(T_main_head.parameterize(handle));
  Request request=ObjectModelHelper.getRequest(objectModel);
  ServiceDocument serviceDoc=(ServiceDocument)request.getAttribute(""String_Node_Str"");
  java.util.List<Collection> collections=ServiceDocumentHelper.getCollections(serviceDoc);
  for (  Collection collection : collections) {
    Division collectionDiv=main.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
    collectionDiv.setHead(T_collection_head.parameterize(collection.getLocation()));
    List paramsList=collectionDiv.addList(collection + ""String_Node_Str"",List.TYPE_BULLETED);
    paramsList.addItem().addContent(T_collection_title.parameterize(collection.getTitle()));
    paramsList.addItem().addContent(T_collection_policy.parameterize(collection.getCollectionPolicy()));
    paramsList.addItem().addContent(T_collection_mediation.parameterize(Boolean.toString(collection.getMediation())));
    String[] fileTypes=collection.getAccepts();
    String fileTypesString=arrayToString(fileTypes);
    paramsList.addItem().addContent(T_collection_file_types.parameterize(fileTypesString));
    String[] packageFormats=ServiceDocumentHelper.getPackageFormats(collection);
    String packageFormatsString=arrayToString(packageFormats);
    paramsList.addItem().addContent(T_collection_package_formats.parameterize(packageFormatsString));
    if ((fileTypes.length > 0) && (packageFormats.length > 0)) {
      collectionDiv.addPara().addButton(""String_Node_Str"").setValue(T_collection_deposit_button);
      collectionDiv.addHidden(""String_Node_Str"").setValue(collection.getLocation());
      collectionDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
    }
    if ((collection.getService() != null) && (collection.getService().length() > 0)) {
      collectionDiv.addPara(T_sub_service_target + collection.getService());
      collectionDiv.addPara().addButton(""String_Node_Str"").setValue(T_sub_service_target_button);
      collectionDiv.addHidden(""String_Node_Str"").setValue(collection.getService());
      collectionDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
    }
  }
  Division buttons=main.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  Para buttonList=buttons.addPara();
  buttonList.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  buttons.addHidden(""String_Node_Str"").setValue(knot.getId());
}",0.520805874599887
52168,"/** 
 * Set up the bitstream reader. See the class description for information on configuration options.
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    this.isSpider=par.getParameter(""String_Node_Str"",""String_Node_Str"").equals(""String_Node_Str"");
    Bitstream bitstream=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      dso=HandleManager.resolveToObject(context,handle);
      if (dso instanceof Item) {
        item=(Item)dso;
        if (sequence > -1) {
          bitstream=findBitstreamBySequence(item,sequence);
        }
 else         if (name != null) {
          bitstream=findBitstreamByName(item,name);
        }
      }
    }
    if ((sequence > -1 && bitstream == null) && name != null) {
      bitstream=findBitstreamByName(item,name);
      if (bitstream != null) {
        String redirectURL=""String_Node_Str"";
        if (item.getHandle() != null && item.getHandle().length() > 0) {
          redirectURL=request.getContextPath() + ""String_Node_Str"" + item.getHandle();
        }
 else {
          redirectURL=request.getContextPath() + ""String_Node_Str"" + item.getID();
        }
        redirectURL+=""String_Node_Str"" + name + ""String_Node_Str""+ bitstream.getSequenceID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redirectURL);
        return;
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    boolean isAuthorized=AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ);
    if (item != null && item.isWithdrawn() && !AuthorizeManager.isAdmin(context)) {
      isAuthorized=false;
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + item.getHandle() + ""String_Node_Str""));
    }
    if (!isAuthorized) {
      if (context.getCurrentUser() != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=item.getHandle();
        }
 else         if (dso != null) {
          redictURL+=dso.getHandle();
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (context.getCurrentUser() == null) {
      this.isAnonymouslyReadable=true;
    }
 else {
      this.isAnonymouslyReadable=false;
      for (      ResourcePolicy rp : AuthorizeManager.getPoliciesActionFilter(context,bitstream,Constants.READ)) {
        if (rp.getGroupID() == 0) {
          this.isAnonymouslyReadable=true;
        }
      }
    }
    if (bitstreamName != null && bitstreamName.length() > 0) {
      int finalSlashIndex=bitstreamName.lastIndexOf('/');
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
 else {
      bitstreamName=""String_Node_Str"";
    }
    new DSpace().getEventService().fireEvent(new UsageEvent(UsageEvent.Action.VIEW,ObjectModelHelper.getRequest(objectModel),ContextUtil.obtainContext(ObjectModelHelper.getRequest(objectModel)),bitstream));
    context.complete();
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}","/** 
 * Set up the bitstream reader. See the class description for information on configuration options.
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    boolean BistreamReaderOpenedContext=!ContextUtil.isContextAvailable(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    this.isSpider=par.getParameter(""String_Node_Str"",""String_Node_Str"").equals(""String_Node_Str"");
    Bitstream bitstream=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      dso=HandleManager.resolveToObject(context,handle);
      if (dso instanceof Item) {
        item=(Item)dso;
        if (sequence > -1) {
          bitstream=findBitstreamBySequence(item,sequence);
        }
 else         if (name != null) {
          bitstream=findBitstreamByName(item,name);
        }
      }
    }
    if ((sequence > -1 && bitstream == null) && name != null) {
      bitstream=findBitstreamByName(item,name);
      if (bitstream != null) {
        String redirectURL=""String_Node_Str"";
        if (item.getHandle() != null && item.getHandle().length() > 0) {
          redirectURL=request.getContextPath() + ""String_Node_Str"" + item.getHandle();
        }
 else {
          redirectURL=request.getContextPath() + ""String_Node_Str"" + item.getID();
        }
        redirectURL+=""String_Node_Str"" + name + ""String_Node_Str""+ bitstream.getSequenceID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redirectURL);
        return;
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    boolean isAuthorized=AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ);
    if (item != null && item.isWithdrawn() && !AuthorizeManager.isAdmin(context)) {
      isAuthorized=false;
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + item.getHandle() + ""String_Node_Str""));
    }
    if (!isAuthorized) {
      if (context.getCurrentUser() != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=item.getHandle();
        }
 else         if (dso != null) {
          redictURL+=dso.getHandle();
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (context.getCurrentUser() == null) {
      this.isAnonymouslyReadable=true;
    }
 else {
      this.isAnonymouslyReadable=false;
      for (      ResourcePolicy rp : AuthorizeManager.getPoliciesActionFilter(context,bitstream,Constants.READ)) {
        if (rp.getGroupID() == 0) {
          this.isAnonymouslyReadable=true;
        }
      }
    }
    if (bitstreamName != null && bitstreamName.length() > 0) {
      int finalSlashIndex=bitstreamName.lastIndexOf('/');
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
 else {
      bitstreamName=""String_Node_Str"";
    }
    new DSpace().getEventService().fireEvent(new UsageEvent(UsageEvent.Action.VIEW,ObjectModelHelper.getRequest(objectModel),ContextUtil.obtainContext(ObjectModelHelper.getRequest(objectModel)),bitstream));
    if (BistreamReaderOpenedContext)     context.complete();
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}",0.9879352623835214
52169,"/** 
 * Create a <div> element with <mptr> which references a child object via its handle (and via a local file name, when recursively disseminating all child objects).
 * @param type - type attr value for the <div>
 * @param dso - object for which to create the div
 * @param params
 * @return
 */
protected Div makeChildDiv(String type,DSpaceObject dso,PackageParameters params){
  String handle=dso.getHandle();
  Div div=new Div();
  div.setID(gensym(""String_Node_Str""));
  div.setTYPE(type);
  boolean emptyDiv=true;
  if (handle == null || handle.length() == 0) {
    log.warn(""String_Node_Str"" + type + ""String_Node_Str""+ dso.toString());
  }
 else {
    Mptr mptr=new Mptr();
    mptr.setID(gensym(""String_Node_Str""));
    mptr.setLOCTYPE(Loctype.HANDLE);
    mptr.setXlinkHref(handle);
    div.getContent().add(mptr);
    emptyDiv=false;
  }
  if (params.recursiveModeEnabled()) {
    String childFileExtension=(params.getBooleanProperty(""String_Node_Str"",false)) ? ""String_Node_Str"" : ""String_Node_Str"";
    Mptr mptr2=new Mptr();
    mptr2.setID(gensym(""String_Node_Str""));
    mptr2.setLOCTYPE(Loctype.URL);
    mptr2.setXlinkHref(PackageUtils.getPackageName(dso,childFileExtension));
    div.getContent().add(mptr2);
    emptyDiv=false;
  }
  if (emptyDiv) {
    return null;
  }
 else {
    return div;
  }
}","/** 
 * Create a <div> element with <mptr> which references a child object via its handle (and via a local file name, when recursively disseminating all child objects).
 * @param type - type attr value for the <div>
 * @param dso - object for which to create the div
 * @param params
 * @return
 */
protected Div makeChildDiv(String type,DSpaceObject dso,PackageParameters params){
  String handle=dso.getHandle();
  Div div=new Div();
  div.setID(gensym(""String_Node_Str""));
  div.setTYPE(type);
  if (handle == null || handle.length() == 0) {
    log.warn(""String_Node_Str"" + type + ""String_Node_Str""+ dso.toString());
  }
 else {
    Mptr mptr=new Mptr();
    mptr.setID(gensym(""String_Node_Str""));
    mptr.setLOCTYPE(Loctype.HANDLE);
    mptr.setXlinkHref(handle);
    div.getContent().add(mptr);
  }
  String childFileExtension=(params.getBooleanProperty(""String_Node_Str"",false)) ? ""String_Node_Str"" : ""String_Node_Str"";
  Mptr mptr2=new Mptr();
  mptr2.setID(gensym(""String_Node_Str""));
  mptr2.setLOCTYPE(Loctype.URL);
  mptr2.setXlinkHref(PackageUtils.getPackageName(dso,childFileExtension));
  div.getContent().add(mptr2);
  return div;
}",0.9202751922298664
52170,"/** 
 * Gets all <code>file</code> elements which make up the item's content.
 * @return a List of <code>Element</code>s.
 */
public List<Element> getContentFiles() throws MetadataValidationException {
  if (contentFiles != null) {
    return contentFiles;
  }
  Element fileSec=mets.getChild(""String_Node_Str"",metsNS);
  if (fileSec == null) {
    throw new MetadataValidationException(""String_Node_Str"");
  }
  contentFiles=new ArrayList<Element>();
  Iterator fgi=fileSec.getChildren(""String_Node_Str"",metsNS).iterator();
  while (fgi.hasNext()) {
    Element fg=(Element)fgi.next();
    Iterator fi=fg.getChildren(""String_Node_Str"",metsNS).iterator();
    while (fi.hasNext()) {
      Element f=(Element)fi.next();
      contentFiles.add(f);
    }
  }
  return contentFiles;
}","/** 
 * Gets all <code>file</code> elements which make up the item's content.
 * @return a List of <code>Element</code>s.
 */
public List<Element> getContentFiles() throws MetadataValidationException {
  if (contentFiles != null) {
    return contentFiles;
  }
  contentFiles=new ArrayList<Element>();
  Element fileSec=mets.getChild(""String_Node_Str"",metsNS);
  if (fileSec != null) {
    Iterator fgi=fileSec.getChildren(""String_Node_Str"",metsNS).iterator();
    while (fgi.hasNext()) {
      Element fg=(Element)fgi.next();
      Iterator fi=fg.getChildren(""String_Node_Str"",metsNS).iterator();
      while (fi.hasNext()) {
        Element f=(Element)fi.next();
        contentFiles.add(f);
      }
    }
  }
  return contentFiles;
}",0.7058047493403694
52171,"/** 
 * Recursively create one or more DSpace Objects out of the contents of the ingested package (and all other referenced packages). The initial object is created under the indicated parent.  All other objects are created based on their relationship to the initial object. <p> For example, a scenario may be to create a Collection based on a collection-level package, and also create an Item for every item-level package referenced by the collection-level package. <p> The output of this method is one or more newly created <code>DspaceObject<code>s. <p> The packager <em>may</em> choose not to implement <code>ingestAll</code>, or simply forward the call to <code>ingest</code> if it is unable to support recursive ingestion. <p> The deposit license (Only significant for Item) is passed explicitly as a string since there is no place for it in many package formats.  It is optional and may be given as <code>null</code>.
 * @param context  DSpace context.
 * @param parent parent under which to create the initial object(may be null -- in which case ingester must determine parent from package or throw an error).
 * @param pkgFile  The initial package file to ingest
 * @param params Properties-style list of options (interpreted by each packager).
 * @param license  may be null, which takes default license.
 * @return List of DSpaceObjects created
 * @throws PackageValidationException if initial package (or any referenced package)is unacceptable or there is a fatal error in creating a DSpaceObject
 * @throws UnsupportedOperationException if this packager does notimplement <code>ingestAll</code>
 */
public List<DSpaceObject> ingestAll(Context context,DSpaceObject parent,File pkgFile,PackageParameters params,String license) throws PackageException, UnsupportedOperationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  DSpaceObject dso=null;
  try {
    dso=ingest(context,parent,pkgFile,params,license);
  }
 catch (  IllegalStateException ie) {
    if (params.keepExistingModeEnabled()) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + pkgFile));
    }
 else {
      throw ie;
    }
  }
  if (dso != null) {
    addToIngestedList(dso);
    if (dso.getType() != Constants.ITEM) {
      List<String> childPkgRefs=getPackageReferences(dso);
      if (childPkgRefs != null && !childPkgRefs.isEmpty()) {
        for (        String childPkgRef : childPkgRefs) {
          int oldSize=dsoIngestedList.size();
          File childPkg=new File(pkgFile.getAbsoluteFile().getParent(),childPkgRef);
          ingestAll(context,dso,childPkg,params,license);
          if (Constants.COLLECTION == dso.getType()) {
            Item childItem=(Item)dsoIngestedList.get(oldSize);
            Collection collection=(Collection)dso;
            if (!childItem.isIn(collection)) {
              collection.addItem(childItem);
            }
          }
        }
      }
    }
  }
  return getIngestedList();
}","/** 
 * Recursively create one or more DSpace Objects out of the contents of the ingested package (and all other referenced packages). The initial object is created under the indicated parent.  All other objects are created based on their relationship to the initial object. <p> For example, a scenario may be to create a Collection based on a collection-level package, and also create an Item for every item-level package referenced by the collection-level package. <p> The output of this method is one or more newly created <code>DspaceObject<code>s. <p> The packager <em>may</em> choose not to implement <code>ingestAll</code>, or simply forward the call to <code>ingest</code> if it is unable to support recursive ingestion. <p> The deposit license (Only significant for Item) is passed explicitly as a string since there is no place for it in many package formats.  It is optional and may be given as <code>null</code>.
 * @param context  DSpace context.
 * @param parent parent under which to create the initial object(may be null -- in which case ingester must determine parent from package or throw an error).
 * @param pkgFile  The initial package file to ingest
 * @param params Properties-style list of options (interpreted by each packager).
 * @param license  may be null, which takes default license.
 * @return List of DSpaceObjects created
 * @throws PackageValidationException if initial package (or any referenced package)is unacceptable or there is a fatal error in creating a DSpaceObject
 * @throws UnsupportedOperationException if this packager does notimplement <code>ingestAll</code>
 */
@Override public List<DSpaceObject> ingestAll(Context context,DSpaceObject parent,File pkgFile,PackageParameters params,String license) throws PackageException, UnsupportedOperationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  DSpaceObject dso=null;
  try {
    dso=ingest(context,parent,pkgFile,params,license);
  }
 catch (  IllegalStateException ie) {
    if (params.keepExistingModeEnabled()) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + pkgFile));
    }
 else {
      throw ie;
    }
  }
  if (dso != null) {
    addToIngestedList(dso);
    if (dso.getType() != Constants.ITEM) {
      List<String> childPkgRefs=getPackageReferences(dso);
      if (childPkgRefs != null && !childPkgRefs.isEmpty()) {
        for (        String childPkgRef : childPkgRefs) {
          int oldSize=dsoIngestedList.size();
          File childPkg=new File(pkgFile.getAbsoluteFile().getParent(),childPkgRef);
          ingestAll(context,dso,childPkg,params,license);
          if (Constants.COLLECTION == dso.getType() && dsoIngestedList.size() > oldSize) {
            Item childItem=(Item)dsoIngestedList.get(oldSize);
            Collection collection=(Collection)dso;
            if (!childItem.isIn(collection)) {
              collection.addItem(childItem);
            }
          }
        }
      }
    }
  }
  return getIngestedList();
}",0.9925348912690684
52172,"/** 
 * Recursively replace one or more DSpace Objects out of the contents of the ingested package (and all other referenced packages). The initial object to replace is indicated by <code>dso</code>.  All other objects are replaced based on information provided in the referenced packages. <p> For example, a scenario may be to replace a Collection based on a collection-level package, and also replace *every* Item in that collection based on the item-level packages referenced by the collection-level package. <p> Please note that since the <code>dso</code> input only specifies the initial object to replace, any additional objects to replace must be determined based on the referenced packages (or initial package itself). <p> The output of this method is one or more replaced <code>DspaceObject<code>s. <p> The packager <em>may</em> choose not to implement <code>replaceAll</code>, since it somewhat contradicts the archival nature of DSpace. It also may choose to forward the call to <code>replace</code> if it is unable to support recursive replacement.
 * @param context  DSpace context.
 * @param dso initial existing DSpace Object to be replaced, may be nullif object to replace can be determined from package
 * @param pkgFile  The package file to ingest.
 * @param params Properties-style list of options specific to this packager
 * @return List of DSpaceObjects replaced
 * @throws PackageValidationException if initial package (or any referenced package)is unacceptable or there is a fatal error in creating a DSpaceObject
 * @throws UnsupportedOperationException if this packager does notimplement <code>replaceAll</code>
 */
public List<DSpaceObject> replaceAll(Context context,DSpaceObject dso,File pkgFile,PackageParameters params) throws PackageException, UnsupportedOperationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  DSpaceObject replacedDso=replace(context,dso,pkgFile,params);
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + Constants.typeText[replacedDso.getType()] + ""String_Node_Str""+ replacedDso.getHandle()));
  addToIngestedList(replacedDso);
  if (replacedDso.getType() != Constants.ITEM) {
    List<String> childPkgRefs=getPackageReferences(replacedDso);
    if (childPkgRefs != null && !childPkgRefs.isEmpty()) {
      for (      String childPkgRef : childPkgRefs) {
        int oldSize=dsoIngestedList.size();
        File childPkg=new File(pkgFile.getAbsoluteFile().getParent(),childPkgRef);
        replaceAll(context,null,childPkg,params);
        if (Constants.COLLECTION == replacedDso.getType()) {
          Item childItem=(Item)dsoIngestedList.get(oldSize);
          Collection collection=(Collection)replacedDso;
          if (!childItem.isIn(collection)) {
            collection.addItem(childItem);
          }
        }
      }
    }
  }
  return getIngestedList();
}","/** 
 * Recursively replace one or more DSpace Objects out of the contents of the ingested package (and all other referenced packages). The initial object to replace is indicated by <code>dso</code>.  All other objects are replaced based on information provided in the referenced packages. <p> For example, a scenario may be to replace a Collection based on a collection-level package, and also replace *every* Item in that collection based on the item-level packages referenced by the collection-level package. <p> Please note that since the <code>dso</code> input only specifies the initial object to replace, any additional objects to replace must be determined based on the referenced packages (or initial package itself). <p> The output of this method is one or more replaced <code>DspaceObject<code>s. <p> The packager <em>may</em> choose not to implement <code>replaceAll</code>, since it somewhat contradicts the archival nature of DSpace. It also may choose to forward the call to <code>replace</code> if it is unable to support recursive replacement.
 * @param context  DSpace context.
 * @param dso initial existing DSpace Object to be replaced, may be nullif object to replace can be determined from package
 * @param pkgFile  The package file to ingest.
 * @param params Properties-style list of options specific to this packager
 * @return List of DSpaceObjects replaced
 * @throws PackageValidationException if initial package (or any referenced package)is unacceptable or there is a fatal error in creating a DSpaceObject
 * @throws UnsupportedOperationException if this packager does notimplement <code>replaceAll</code>
 */
@Override public List<DSpaceObject> replaceAll(Context context,DSpaceObject dso,File pkgFile,PackageParameters params) throws PackageException, UnsupportedOperationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  DSpaceObject replacedDso=replace(context,dso,pkgFile,params);
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + Constants.typeText[replacedDso.getType()] + ""String_Node_Str""+ replacedDso.getHandle()));
  addToIngestedList(replacedDso);
  if (replacedDso.getType() != Constants.ITEM) {
    List<String> childPkgRefs=getPackageReferences(replacedDso);
    if (childPkgRefs != null && !childPkgRefs.isEmpty()) {
      for (      String childPkgRef : childPkgRefs) {
        int oldSize=dsoIngestedList.size();
        File childPkg=new File(pkgFile.getAbsoluteFile().getParent(),childPkgRef);
        replaceAll(context,null,childPkg,params);
        if (Constants.COLLECTION == replacedDso.getType()) {
          Item childItem=(Item)dsoIngestedList.get(oldSize);
          Collection collection=(Collection)replacedDso;
          if (!childItem.isIn(collection)) {
            collection.addItem(childItem);
          }
        }
      }
    }
  }
  return getIngestedList();
}",0.9983176312247644
52173,"/** 
 * Recursively export one or more DSpace Objects as a series of packages. This method will export the given DSpace Object as well as all referenced DSpaceObjects (e.g. child objects) into a series of packages. The initial object is exported to the location specified by the OutputStream. All other packages are exported to the same directory location. <p> Package is any serialized representation of the item, at the discretion of the implementing class.  It does not have to include content bitstreams. <br> Use the <code>params</code> parameter list to adjust the way the package is made, e.g. including a ""<code>metadataOnly</code>"" parameter might make the package a bare manifest in XML instead of a Zip file including manifest and contents. <br> Throws an exception of the initial object is not acceptable or there is a failure creating the package.
 * @param context  DSpace context.
 * @param dso  initial DSpace object
 * @param params Properties-style list of options specific to this packager
 * @param pkgFile File where initial package should be written. All otherpackages will be written to the same directory as this File.
 * @throws PackageValidationException if package cannot be created or there isa fatal error in creating it.
 */
public List<File> disseminateAll(Context context,DSpaceObject dso,PackageParameters params,File pkgFile) throws PackageException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  disseminate(context,dso,params,pkgFile);
  if (pkgFile.exists()) {
    addToPackageList(pkgFile);
    if (dso.getType() != Constants.ITEM) {
      String pkgDirectory=pkgFile.getCanonicalFile().getParent();
      if (!pkgDirectory.endsWith(File.separator)) {
        pkgDirectory+=File.separator;
      }
      String fileExtension=PackageUtils.getFileExtension(pkgFile.getName());
switch (dso.getType()) {
case Constants.COLLECTION:
        Collection collection=(Collection)dso;
      ItemIterator iterator=collection.getItems();
    while (iterator.hasNext()) {
      Item item=iterator.next();
      String childFileName=pkgDirectory + PackageUtils.getPackageName(item,fileExtension);
      disseminateAll(context,item,params,new File(childFileName));
    }
  break;
case Constants.COMMUNITY:
Community community=(Community)dso;
Community[] subcommunities=community.getSubcommunities();
for (int i=0; i < subcommunities.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(subcommunities[i],fileExtension);
disseminateAll(context,subcommunities[i],params,new File(childFileName));
}
Collection[] collections=community.getCollections();
for (int i=0; i < collections.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(collections[i],fileExtension);
disseminateAll(context,collections[i],params,new File(childFileName));
}
break;
case Constants.SITE:
Community[] topCommunities=Community.findAllTop(context);
for (int i=0; i < topCommunities.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(topCommunities[i],fileExtension);
disseminateAll(context,topCommunities[i],params,new File(childFileName));
}
break;
}
}
}
return getPackageList();
}","/** 
 * Recursively export one or more DSpace Objects as a series of packages. This method will export the given DSpace Object as well as all referenced DSpaceObjects (e.g. child objects) into a series of packages. The initial object is exported to the location specified by the OutputStream. All other packages are exported to the same directory location. <p> Package is any serialized representation of the item, at the discretion of the implementing class.  It does not have to include content bitstreams. <br> Use the <code>params</code> parameter list to adjust the way the package is made, e.g. including a ""<code>metadataOnly</code>"" parameter might make the package a bare manifest in XML instead of a Zip file including manifest and contents. <br> Throws an exception of the initial object is not acceptable or there is a failure creating the package.
 * @param context  DSpace context.
 * @param dso  initial DSpace object
 * @param params Properties-style list of options specific to this packager
 * @param pkgFile File where initial package should be written. All otherpackages will be written to the same directory as this File.
 * @throws PackageValidationException if package cannot be created or there isa fatal error in creating it.
 */
@Override public List<File> disseminateAll(Context context,DSpaceObject dso,PackageParameters params,File pkgFile) throws PackageException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  disseminate(context,dso,params,pkgFile);
  if (pkgFile.exists()) {
    addToPackageList(pkgFile);
    if (dso.getType() != Constants.ITEM) {
      String pkgDirectory=pkgFile.getCanonicalFile().getParent();
      if (!pkgDirectory.endsWith(File.separator)) {
        pkgDirectory+=File.separator;
      }
      String fileExtension=PackageUtils.getFileExtension(pkgFile.getName());
switch (dso.getType()) {
case Constants.COLLECTION:
        Collection collection=(Collection)dso;
      ItemIterator iterator=collection.getItems();
    while (iterator.hasNext()) {
      Item item=iterator.next();
      String childFileName=pkgDirectory + PackageUtils.getPackageName(item,fileExtension);
      disseminateAll(context,item,params,new File(childFileName));
    }
  break;
case Constants.COMMUNITY:
Community community=(Community)dso;
Community[] subcommunities=community.getSubcommunities();
for (int i=0; i < subcommunities.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(subcommunities[i],fileExtension);
disseminateAll(context,subcommunities[i],params,new File(childFileName));
}
Collection[] collections=community.getCollections();
for (int i=0; i < collections.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(collections[i],fileExtension);
disseminateAll(context,collections[i],params,new File(childFileName));
}
break;
case Constants.SITE:
Community[] topCommunities=Community.findAllTop(context);
for (int i=0; i < topCommunities.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(topCommunities[i],fileExtension);
disseminateAll(context,topCommunities[i],params,new File(childFileName));
}
break;
}
}
}
return getPackageList();
}",0.9984718826405868
52174,"/** 
 * Add File to list of successfully disseminated package files
 * @param file File
 */
protected void addToPackageList(File f){
  packageFileList.add(f);
}","/** 
 * Add File to list of successfully disseminated package files
 * @param file File
 */
protected void addToPackageList(File f){
  if (!packageFileList.contains(f)) {
    packageFileList.add(f);
  }
}",0.8791208791208791
52175,"/** 
 * Store original package on disk and companion file containing SWORD headers as found in the deposit object Also write companion file with header info from the deposit object.
 * @param deposit
 */
private void storePackageAsFile(Deposit deposit) throws IOException {
  String path=swordService.getSwordConfig().getFailedPackageDir();
  File dir=new File(path);
  if (!dir.exists() || !dir.isDirectory()) {
    throw new IOException(""String_Node_Str"");
  }
  String filenameBase=""String_Node_Str"" + deposit.getUsername() + ""String_Node_Str""+ (new Date()).getTime();
  File packageFile=new File(path,filenameBase);
  File headersFile=new File(path,filenameBase + ""String_Node_Str"");
  InputStream is=deposit.getFile();
  FileOutputStream fos=new FileOutputStream(packageFile);
  Utils.copy(is,fos);
  fos.close();
  is.close();
  PrintWriter pw=new PrintWriter(new BufferedWriter(new FileWriter(headersFile)));
  pw.println(""String_Node_Str"" + deposit.getContentDisposition());
  pw.println(""String_Node_Str"" + deposit.getContentType());
  pw.println(""String_Node_Str"" + deposit.getPackaging());
  pw.println(""String_Node_Str"" + deposit.getLocation());
  pw.println(""String_Node_Str"" + deposit.getOnBehalfOf());
  pw.println(""String_Node_Str"" + deposit.getSlug());
  pw.println(""String_Node_Str"" + deposit.getUsername());
  pw.close();
}","/** 
 * Store original package on disk and companion file containing SWORD headers as found in the deposit object Also write companion file with header info from the deposit object.
 * @param deposit
 */
private void storePackageAsFile(Deposit deposit) throws IOException {
  String path=swordService.getSwordConfig().getFailedPackageDir();
  File dir=new File(path);
  if (!dir.exists() || !dir.isDirectory()) {
    throw new IOException(""String_Node_Str"");
  }
  String filenameBase=""String_Node_Str"" + deposit.getUsername() + ""String_Node_Str""+ (new Date()).getTime();
  File packageFile=new File(path,filenameBase);
  File headersFile=new File(path,filenameBase + ""String_Node_Str"");
  InputStream is=new BufferedInputStream(new FileInputStream(deposit.getFile()));
  OutputStream fos=new BufferedOutputStream(new FileOutputStream(packageFile));
  Utils.copy(is,fos);
  fos.close();
  is.close();
  PrintWriter pw=new PrintWriter(new BufferedWriter(new FileWriter(headersFile)));
  pw.println(""String_Node_Str"" + deposit.getContentDisposition());
  pw.println(""String_Node_Str"" + deposit.getContentType());
  pw.println(""String_Node_Str"" + deposit.getPackaging());
  pw.println(""String_Node_Str"" + deposit.getLocation());
  pw.println(""String_Node_Str"" + deposit.getOnBehalfOf());
  pw.println(""String_Node_Str"" + deposit.getSlug());
  pw.println(""String_Node_Str"" + deposit.getUsername());
  pw.close();
}",0.9542151162790696
52176,"/** 
 * Convert the current row in a ResultSet into a TableRow object.
 * @param results A ResultSet to process
 * @param table The name of the table
 * @return A TableRow object with the data from the ResultSet
 * @exception SQLException If a database error occurs
 */
static TableRow process(ResultSet results,String table) throws SQLException {
  ResultSetMetaData meta=results.getMetaData();
  int columns=meta.getColumnCount() + 1;
  List<String> columnNames=(table == null) ? getColumnNames(meta) : getColumnNames(table);
  TableRow row=new TableRow(canonicalize(table),columnNames);
  for (int i=1; i < columns; i++) {
    String name=meta.getColumnName(i);
    int jdbctype=meta.getColumnType(i);
    if (results.wasNull()) {
      row.setColumnNull(name);
    }
 else {
switch (jdbctype) {
case Types.BIT:
        row.setColumn(name,results.getBoolean(i));
      break;
case Types.INTEGER:
    if (isOracle) {
      long longValue=results.getLong(i);
      if (longValue <= (long)Integer.MAX_VALUE) {
        row.setColumn(name,(int)longValue);
      }
 else {
        row.setColumn(name,longValue);
      }
    }
 else {
      row.setColumn(name,results.getInt(i));
    }
  break;
case Types.NUMERIC:
case Types.DECIMAL:
case Types.BIGINT:
row.setColumn(name,results.getLong(i));
break;
case Types.DOUBLE:
row.setColumn(name,results.getDouble(i));
break;
case Types.CLOB:
if (isOracle) {
row.setColumn(name,results.getString(i));
}
 else {
throw new IllegalArgumentException(""String_Node_Str"" + jdbctype);
}
break;
case Types.VARCHAR:
try {
byte[] bytes=results.getBytes(i);
if (bytes != null) {
String mystring=new String(results.getBytes(i),""String_Node_Str"");
row.setColumn(name,mystring);
}
 else {
row.setColumn(name,results.getString(i));
}
}
 catch (UnsupportedEncodingException e) {
log.error(""String_Node_Str"",e);
}
break;
case Types.DATE:
row.setColumn(name,results.getDate(i));
break;
case Types.TIME:
row.setColumn(name,results.getTime(i));
break;
case Types.TIMESTAMP:
row.setColumn(name,results.getTimestamp(i));
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + jdbctype);
}
}
}
row.resetChanged();
return row;
}","/** 
 * Convert the current row in a ResultSet into a TableRow object.
 * @param results A ResultSet to process
 * @param table The name of the table
 * @return A TableRow object with the data from the ResultSet
 * @exception SQLException If a database error occurs
 */
static TableRow process(ResultSet results,String table) throws SQLException {
  ResultSetMetaData meta=results.getMetaData();
  int columns=meta.getColumnCount() + 1;
  List<String> columnNames=(table == null) ? getColumnNames(meta) : getColumnNames(table);
  TableRow row=new TableRow(canonicalize(table),columnNames);
  for (int i=1; i < columns; i++) {
    String name=meta.getColumnName(i);
    int jdbctype=meta.getColumnType(i);
switch (jdbctype) {
case Types.BIT:
      row.setColumn(name,results.getBoolean(i));
    break;
case Types.INTEGER:
  if (isOracle) {
    long longValue=results.getLong(i);
    if (longValue <= (long)Integer.MAX_VALUE) {
      row.setColumn(name,(int)longValue);
    }
 else {
      row.setColumn(name,longValue);
    }
  }
 else {
    row.setColumn(name,results.getInt(i));
  }
break;
case Types.NUMERIC:
case Types.DECIMAL:
case Types.BIGINT:
row.setColumn(name,results.getLong(i));
break;
case Types.DOUBLE:
row.setColumn(name,results.getDouble(i));
break;
case Types.CLOB:
if (isOracle) {
row.setColumn(name,results.getString(i));
}
 else {
throw new IllegalArgumentException(""String_Node_Str"" + jdbctype);
}
break;
case Types.VARCHAR:
try {
byte[] bytes=results.getBytes(i);
if (bytes != null) {
String mystring=new String(results.getBytes(i),""String_Node_Str"");
row.setColumn(name,mystring);
}
 else {
row.setColumn(name,results.getString(i));
}
}
 catch (UnsupportedEncodingException e) {
log.error(""String_Node_Str"",e);
}
break;
case Types.DATE:
row.setColumn(name,results.getDate(i));
break;
case Types.TIME:
row.setColumn(name,results.getTime(i));
break;
case Types.TIMESTAMP:
row.setColumn(name,results.getTimestamp(i));
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + jdbctype);
}
if (results.wasNull()) {
row.setColumnNull(name);
}
}
row.resetChanged();
return row;
}",0.96485473289597
52177,"String getStringColumnCanonicalized(String column){
  if (!hasColumnCanonicalized(column)) {
    throw new IllegalArgumentException(""String_Node_Str"" + column);
  }
  if (isColumnNull(column)) {
    return null;
  }
  Object value=data.get(column);
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + column + ""String_Node_Str"");
  }
  if (!(value instanceof String)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return (String)value;
}","String getStringColumnCanonicalized(String column){
  if (!hasColumnCanonicalized(column)) {
    throw new IllegalArgumentException(""String_Node_Str"" + column);
  }
  if (isColumnNullCanonicalized(column)) {
    return null;
  }
  Object value=data.get(column);
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + column + ""String_Node_Str"");
  }
  if (!(value instanceof String)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return (String)value;
}",0.98685540950455
52178,"/** 
 * Get the URL by which the METS manifest refers to a Bitstream member within the same package.  In other words, this is generally a relative path link to where the Bitstream file is within the Zipped up AIP. <p> For a manifest-only AIP, this is a reference to an HTTP URL where the bitstream should be able to be downloaded from. An external AIP names a file in the package with a relative URL, that is, relative pathname.
 * @param bitstream  the Bitstream
 * @param params Packager Parameters
 * @return String in URL format naming path to bitstream.
 */
@Override public String makeBitstreamURL(Bitstream bitstream,PackageParameters params){
  if (params != null && (params.getBooleanProperty(""String_Node_Str"",false))) {
    try {
      String handle=null;
      Bundle[] bn=bitstream.getBundles();
      if (bn.length > 0) {
        Item bi[]=bn[0].getItems();
        if (bi.length > 0) {
          handle=bi[0].getHandle();
        }
      }
      if (handle != null) {
        return ConfigurationManager.getProperty(""String_Node_Str"") + ""String_Node_Str"" + handle+ ""String_Node_Str""+ String.valueOf(bitstream.getSequenceID())+ ""String_Node_Str""+ URLEncoder.encode(bitstream.getName(),""String_Node_Str"");
      }
    }
 catch (    SQLException e) {
      log.error(""String_Node_Str"",e);
    }
catch (    UnsupportedEncodingException e) {
      log.error(""String_Node_Str"",e);
    }
    return bitstream.getName();
  }
 else {
    String base=""String_Node_Str"" + String.valueOf(bitstream.getID());
    String ext[]=bitstream.getFormat().getExtensions();
    return (ext.length > 0) ? base + ""String_Node_Str"" + ext[0] : base;
  }
}","/** 
 * Get the URL by which the METS manifest refers to a Bitstream member within the same package.  In other words, this is generally a relative path link to where the Bitstream file is within the Zipped up AIP. <p> For a manifest-only AIP, this is a reference to an HTTP URL where the bitstream should be able to be downloaded from. An external AIP names a file in the package with a relative URL, that is, relative pathname.
 * @param bitstream  the Bitstream
 * @param params Packager Parameters
 * @return String in URL format naming path to bitstream.
 */
@Override public String makeBitstreamURL(Bitstream bitstream,PackageParameters params){
  if (params != null && (params.getBooleanProperty(""String_Node_Str"",false))) {
    try {
      String handle=null;
      Bundle[] bn=bitstream.getBundles();
      if (bn.length > 0) {
        Item bi[]=bn[0].getItems();
        if (bi.length > 0) {
          handle=bi[0].getHandle();
        }
      }
      if (handle != null) {
        return ConfigurationManager.getProperty(""String_Node_Str"") + ""String_Node_Str"" + handle+ ""String_Node_Str""+ String.valueOf(bitstream.getSequenceID())+ ""String_Node_Str""+ URLEncoder.encode(bitstream.getName(),""String_Node_Str"");
      }
 else {
        return ConfigurationManager.getProperty(""String_Node_Str"") + ""String_Node_Str"" + String.valueOf(bitstream.getID());
      }
    }
 catch (    SQLException e) {
      log.error(""String_Node_Str"",e);
    }
catch (    UnsupportedEncodingException e) {
      log.error(""String_Node_Str"",e);
    }
    return bitstream.getName();
  }
 else {
    String base=""String_Node_Str"" + String.valueOf(bitstream.getID());
    String ext[]=bitstream.getFormat().getExtensions();
    return (ext.length > 0) ? base + ""String_Node_Str"" + ext[0] : base;
  }
}",0.9591598599766628
52179,"/** 
 * Do nothing, to prevent wrapped stream from being closed prematurely.
 */
public void close(){
}","/** 
 * Do nothing, to prevent wrapped stream from being closed prematurely.
 */
@Override public void close(){
}",0.9537037037037036
52180,"/** 
 * When DSpace creates Default Group Names they are of a very specific format, for example: <li> COMMUNITY_[ID]_ADMIN <li> COLLECTION_[ID]_ADMIN <li> COLLECTION_[ID]_SUBMIT <li> COLLECTION_[ID]_WORKFLOW_STEP_# <p> Although these names work fine within DSpace, the DSpace internal ID (represented by [ID] above) becomes meaningless when content is exported outside of DSpace.  In order to make these Group names meaningful outside of DSpace, they must be translated into a different format: <li> COMMUNITY_[HANDLE]_ADMIN (e.g. COMMUNITY_hdl:123456789/10_ADMIN), etc. <p> This format replaces the internal ID with an external Handle identifier (which is expected to be more meaningful even when content is exported from DSpace). <p> This method prepares group names for export by replacing any found internal IDs with the appropriate external Handle identifier.  If the group name either doesn't have an embedded internal ID, or the corresponding Handle cannot be determined, then it is returned as is. <p> This method may be useful to any Crosswalks/Packagers which deal with import/export of DSpace Groups. <p> Also see the translateGroupNameForImport() method which does the opposite of this method.
 * @param relatedDso DSpaceObject associated with group
 * @param groupName Group's name
 * @return the group name, with any internal IDs translated to Handles
 */
public static String translateGroupNameForExport(Context context,String groupName) throws PackageException {
  if (!groupName.matches(""String_Node_Str"")) {
    return groupName;
  }
  String objType=groupName.substring(0,groupName.indexOf('_'));
  String tmpEndString=groupName.substring(groupName.indexOf('_') + 1);
  String objID=tmpEndString.substring(0,tmpEndString.indexOf('_'));
  String groupType=tmpEndString.substring(tmpEndString.indexOf('_') + 1);
  try {
    DSpaceObject dso=DSpaceObject.find(context,Constants.getTypeID(objType),Integer.parseInt(objID));
    if (dso == null) {
      log.warn(""String_Node_Str"" + groupName + ""String_Node_Str""+ objID+ ""String_Node_Str""+ objType+ ""String_Node_Str"");
      return groupName;
    }
    return objType + ""String_Node_Str"" + ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ groupType;
  }
 catch (  SQLException sqle) {
    throw new PackageException(""String_Node_Str"" + groupName + ""String_Node_Str"",sqle);
  }
}","/** 
 * When DSpace creates Default Group Names they are of a very specific format, for example: <li> COMMUNITY_[ID]_ADMIN <li> COLLECTION_[ID]_ADMIN <li> COLLECTION_[ID]_SUBMIT <li> COLLECTION_[ID]_WORKFLOW_STEP_# <p> Although these names work fine within DSpace, the DSpace internal ID (represented by [ID] above) becomes meaningless when content is exported outside of DSpace.  In order to make these Group names meaningful outside of DSpace, they must be translated into a different format: <li> COMMUNITY_[HANDLE]_ADMIN (e.g. COMMUNITY_hdl:123456789/10_ADMIN), etc. <p> This format replaces the internal ID with an external Handle identifier (which is expected to be more meaningful even when content is exported from DSpace). <p> This method prepares group names for export by replacing any found internal IDs with the appropriate external Handle identifier.  If the group name doesn't have an embedded internal ID, it is returned as is. If the group name contains an embedded internal ID, but the corresponding Handle cannot be determined, then null is returned (as the group name could not be translated). <p> This method may be useful to any Crosswalks/Packagers which deal with import/export of DSpace Groups. <p> Also see the translateGroupNameForImport() method which does the opposite of this method.
 * @param relatedDso DSpaceObject associated with group
 * @param groupName Group's name
 * @return the group name, with any internal IDs translated to Handles
 */
public static String translateGroupNameForExport(Context context,String groupName) throws PackageException {
  if (!groupName.matches(""String_Node_Str"")) {
    return groupName;
  }
  String objType=groupName.substring(0,groupName.indexOf('_'));
  String tmpEndString=groupName.substring(groupName.indexOf('_') + 1);
  String objID=tmpEndString.substring(0,tmpEndString.indexOf('_'));
  String groupType=tmpEndString.substring(tmpEndString.indexOf('_') + 1);
  try {
    DSpaceObject dso=DSpaceObject.find(context,Constants.getTypeID(objType),Integer.parseInt(objID));
    if (dso == null) {
      log.warn(""String_Node_Str"" + groupName + ""String_Node_Str""+ objID+ ""String_Node_Str""+ objType+ ""String_Node_Str"");
      return null;
    }
    return objType + ""String_Node_Str"" + ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ groupType;
  }
 catch (  SQLException sqle) {
    throw new PackageException(""String_Node_Str"" + groupName + ""String_Node_Str"",sqle);
  }
}",0.962700562617212
52181,"/** 
 * Emit XML describing a single Group.
 * @param context the DSpace Context
 * @parm relatedObjectthe DSpaceObject related to this group (if any)
 * @param group the Group to describe
 * @param write the description to this stream
 */
private void writeGroup(Context context,DSpaceObject relatedObject,Group group,XMLStreamWriter writer) throws XMLStreamException, PackageException {
  writer.writeStartElement(GROUP);
  writer.writeAttribute(ID,String.valueOf(group.getID()));
  writer.writeAttribute(NAME,PackageUtils.translateGroupNameForExport(context,group.getName()));
  String groupType=getGroupType(relatedObject,group);
  if (groupType != null && !groupType.isEmpty()) {
    writer.writeAttribute(TYPE,groupType);
  }
  if (group.getMembers().length > 0) {
    writer.writeStartElement(MEMBERS);
    for (    EPerson member : group.getMembers()) {
      writer.writeEmptyElement(MEMBER);
      writer.writeAttribute(ID,String.valueOf(member.getID()));
      writer.writeAttribute(NAME,member.getName());
    }
    writer.writeEndElement();
  }
  if (group.getMemberGroups().length > 0) {
    writer.writeStartElement(MEMBER_GROUPS);
    for (    Group member : group.getMemberGroups()) {
      writer.writeEmptyElement(MEMBER_GROUP);
      writer.writeAttribute(ID,String.valueOf(member.getID()));
      writer.writeAttribute(NAME,PackageUtils.translateGroupNameForExport(context,member.getName()));
    }
    writer.writeEndElement();
  }
  writer.writeEndElement();
}","/** 
 * Emit XML describing a single Group.
 * @param context the DSpace Context
 * @parm relatedObjectthe DSpaceObject related to this group (if any)
 * @param group the Group to describe
 * @param write the description to this stream
 */
private void writeGroup(Context context,DSpaceObject relatedObject,Group group,XMLStreamWriter writer) throws XMLStreamException, PackageException {
  String exportGroupName=PackageUtils.translateGroupNameForExport(context,group.getName());
  if (exportGroupName == null)   return;
  writer.writeStartElement(GROUP);
  writer.writeAttribute(ID,String.valueOf(group.getID()));
  writer.writeAttribute(NAME,exportGroupName);
  String groupType=getGroupType(relatedObject,group);
  if (groupType != null && !groupType.isEmpty()) {
    writer.writeAttribute(TYPE,groupType);
  }
  if (group.getMembers().length > 0) {
    writer.writeStartElement(MEMBERS);
    for (    EPerson member : group.getMembers()) {
      writer.writeEmptyElement(MEMBER);
      writer.writeAttribute(ID,String.valueOf(member.getID()));
      writer.writeAttribute(NAME,member.getName());
    }
    writer.writeEndElement();
  }
  if (group.getMemberGroups().length > 0) {
    writer.writeStartElement(MEMBER_GROUPS);
    for (    Group member : group.getMemberGroups()) {
      String exportMemberName=PackageUtils.translateGroupNameForExport(context,member.getName());
      if (exportMemberName != null) {
        writer.writeEmptyElement(MEMBER_GROUP);
        writer.writeAttribute(ID,String.valueOf(member.getID()));
        writer.writeAttribute(NAME,PackageUtils.translateGroupNameForExport(context,member.getName()));
      }
    }
    writer.writeEndElement();
  }
  writer.writeEndElement();
}",0.8921537980618943
52182,"public void run(){
  try {
    writeToStream(context,object,stream,emitPasswords);
    stream.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  PackageException e) {
    e.printStackTrace();
  }
}","@Override public void run(){
  try {
    writeToStream(context,object,stream,emitPasswords);
    stream.close();
  }
 catch (  IOException e) {
    log.error(e);
  }
catch (  PackageException e) {
    log.error(e);
  }
}",0.8198198198198198
52183,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  Bitstream bitstream=null;
  boolean displayLicense=ConfigurationManager.getBooleanProperty(""String_Node_Str"",false);
  boolean isLicense=false;
  String idString=request.getPathInfo();
  if (idString != null) {
    if (idString.startsWith(""String_Node_Str"")) {
      idString=idString.substring(1);
    }
    int slashIndex=idString.indexOf('/');
    if (slashIndex != -1) {
      idString=idString.substring(0,slashIndex);
    }
    try {
      int id=Integer.parseInt(idString);
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
    }
  }
  if (bitstream != null) {
    Bundle bundle=bitstream.getBundles()[0];
    if (bundle.getName().equals(Constants.LICENSE_BUNDLE_NAME) && bitstream.getName().equals(Constants.LICENSE_BITSTREAM_NAME)) {
      isLicense=true;
    }
    if (isLicense && !displayLicense && !AuthorizeManager.isAdmin(context)) {
      throw new AuthorizeException();
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
    new DSpace().getEventService().fireEvent(new UsageEvent(UsageEvent.Action.VIEW,request,context,bitstream));
    InputStream is=bitstream.retrieve();
    response.setContentType(bitstream.getFormat().getMIMEType());
    response.setHeader(""String_Node_Str"",String.valueOf(bitstream.getSize()));
    if (threshold != -1 && bitstream.getSize() >= threshold) {
      UIUtil.setBitstreamDisposition(bitstream.getName(),request,response);
    }
    Utils.bufferedCopy(is,response.getOutputStream());
    is.close();
    response.getOutputStream().flush();
  }
 else {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + idString));
    JSPManager.showInvalidIDError(request,response,idString,Constants.BITSTREAM);
  }
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  Bitstream bitstream=null;
  boolean displayLicense=ConfigurationManager.getBooleanProperty(""String_Node_Str"",false);
  boolean isLicense=false;
  String idString=request.getPathInfo();
  if (idString != null) {
    if (idString.startsWith(""String_Node_Str"")) {
      idString=idString.substring(1);
    }
    int slashIndex=idString.indexOf('/');
    if (slashIndex != -1) {
      idString=idString.substring(0,slashIndex);
    }
    try {
      int id=Integer.parseInt(idString);
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
    }
  }
  if (bitstream != null) {
    Bundle bundle=bitstream.getBundles().length > 0 ? bitstream.getBundles()[0] : null;
    if (bundle != null && bundle.getName().equals(Constants.LICENSE_BUNDLE_NAME) && bitstream.getName().equals(Constants.LICENSE_BITSTREAM_NAME)) {
      isLicense=true;
    }
    if (isLicense && !displayLicense && !AuthorizeManager.isAdmin(context)) {
      throw new AuthorizeException();
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
    new DSpace().getEventService().fireEvent(new UsageEvent(UsageEvent.Action.VIEW,request,context,bitstream));
    InputStream is=bitstream.retrieve();
    response.setContentType(bitstream.getFormat().getMIMEType());
    response.setHeader(""String_Node_Str"",String.valueOf(bitstream.getSize()));
    if (threshold != -1 && bitstream.getSize() >= threshold) {
      UIUtil.setBitstreamDisposition(bitstream.getName(),request,response);
    }
    Utils.bufferedCopy(is,response.getOutputStream());
    is.close();
    response.getOutputStream().flush();
  }
 else {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + idString));
    JSPManager.showInvalidIDError(request,response,idString,Constants.BITSTREAM);
  }
}",0.984607620489528
52184,"/** 
 * Take a node list of communities and build the structure from them, delegating to the relevant methods in this class for sub-communities and collections
 * @param context the context of the request
 * @param communities a nodelist of communities to create along with their subjstructures
 * @param parent the parent community of the nodelist of communities to create
 * @return an element array containing additional information regarding the created communities (e.g. the handles they have been assigned)
 */
private static Element[] handleCommunities(Context context,NodeList communities,Community parent) throws TransformerException, SQLException, Exception {
  Element[] elements=new Element[communities.getLength()];
  for (int i=0; i < communities.getLength(); i++) {
    Community community;
    Element element=new Element(""String_Node_Str"");
    if (parent != null) {
      community=parent.createSubcommunity();
    }
 else {
      community=Community.create(null,context);
    }
    community.setMetadata(""String_Node_Str"",""String_Node_Str"");
    Node tn=communities.item(i);
    Enumeration keys=communityMap.keys();
    while (keys.hasMoreElements()) {
      Node node=null;
      String key=(String)keys.nextElement();
      NodeList nl=XPathAPI.selectNodeList(tn,key);
      if (nl.getLength() == 1) {
        node=nl.item(0);
        community.setMetadata((String)communityMap.get(key),getStringValue(node));
      }
    }
    community.update();
    element.setAttribute(""String_Node_Str"",community.getHandle());
    Element nameElement=new Element(""String_Node_Str"");
    nameElement.setText(community.getMetadata(""String_Node_Str""));
    element.addContent(nameElement);
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element descriptionElement=new Element(""String_Node_Str"");
      descriptionElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(descriptionElement);
    }
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element introElement=new Element(""String_Node_Str"");
      introElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(introElement);
    }
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element copyrightElement=new Element(""String_Node_Str"");
      copyrightElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(copyrightElement);
    }
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element sidebarElement=new Element(""String_Node_Str"");
      sidebarElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(sidebarElement);
    }
    NodeList subCommunities=XPathAPI.selectNodeList(tn,""String_Node_Str"");
    Element[] subCommunityElements=handleCommunities(context,subCommunities,community);
    NodeList collections=XPathAPI.selectNodeList(tn,""String_Node_Str"");
    Element[] collectionElements=handleCollections(context,collections,community);
    int j;
    for (j=0; j < subCommunityElements.length; j++) {
      element.addContent(subCommunityElements[j]);
    }
    for (j=0; j < collectionElements.length; j++) {
      element.addContent(collectionElements[j]);
    }
    elements[i]=element;
  }
  return elements;
}","/** 
 * Take a node list of communities and build the structure from them, delegating to the relevant methods in this class for sub-communities and collections
 * @param context the context of the request
 * @param communities a nodelist of communities to create along with their sub-structures
 * @param parent the parent community of the nodelist of communities to create
 * @return an element array containing additional information regarding the created communities (e.g. the handles they have been assigned)
 */
private static Element[] handleCommunities(Context context,NodeList communities,Community parent) throws TransformerException, SQLException, Exception {
  Element[] elements=new Element[communities.getLength()];
  for (int i=0; i < communities.getLength(); i++) {
    Community community;
    Element element=new Element(""String_Node_Str"");
    if (parent != null) {
      community=parent.createSubcommunity();
    }
 else {
      community=Community.create(null,context);
    }
    community.setMetadata(""String_Node_Str"",""String_Node_Str"");
    Node tn=communities.item(i);
    Enumeration keys=communityMap.keys();
    while (keys.hasMoreElements()) {
      Node node=null;
      String key=(String)keys.nextElement();
      NodeList nl=XPathAPI.selectNodeList(tn,key);
      if (nl.getLength() == 1) {
        node=nl.item(0);
        community.setMetadata((String)communityMap.get(key),getStringValue(node));
      }
    }
    community.update();
    element.setAttribute(""String_Node_Str"",community.getHandle());
    Element nameElement=new Element(""String_Node_Str"");
    nameElement.setText(community.getMetadata(""String_Node_Str""));
    element.addContent(nameElement);
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element descriptionElement=new Element(""String_Node_Str"");
      descriptionElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(descriptionElement);
    }
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element introElement=new Element(""String_Node_Str"");
      introElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(introElement);
    }
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element copyrightElement=new Element(""String_Node_Str"");
      copyrightElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(copyrightElement);
    }
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element sidebarElement=new Element(""String_Node_Str"");
      sidebarElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(sidebarElement);
    }
    NodeList subCommunities=XPathAPI.selectNodeList(tn,""String_Node_Str"");
    Element[] subCommunityElements=handleCommunities(context,subCommunities,community);
    NodeList collections=XPathAPI.selectNodeList(tn,""String_Node_Str"");
    Element[] collectionElements=handleCollections(context,collections,community);
    int j;
    for (j=0; j < subCommunityElements.length; j++) {
      element.addContent(subCommunityElements[j]);
    }
    for (j=0; j < collectionElements.length; j++) {
      element.addContent(collectionElements[j]);
    }
    elements[i]=element;
  }
  return elements;
}",0.9996940960538392
52185,"/** 
 * Initalise a new change holder for an existing item
 * @param i The Item to store
 */
public BulkEditChange(Item i){
  item=i;
  newItem=false;
  empty=true;
  adds=new ArrayList<DCValue>();
  removes=new ArrayList<DCValue>();
  constant=new ArrayList<DCValue>();
  complete=new ArrayList<DCValue>();
  oldMappedCollections=new ArrayList<Collection>();
  newMappedCollections=new ArrayList<Collection>();
}","/** 
 * Initialise a new change holder for an existing item
 * @param i The Item to store
 */
public BulkEditChange(Item i){
  item=i;
  newItem=false;
  empty=true;
  adds=new ArrayList<DCValue>();
  removes=new ArrayList<DCValue>();
  constant=new ArrayList<DCValue>();
  complete=new ArrayList<DCValue>();
  oldMappedCollections=new ArrayList<Collection>();
  newMappedCollections=new ArrayList<Collection>();
}",0.9987908101571948
52186,"/** 
 * Initalise this class with values from dspace.cfg
 */
private void init(){
  setValueSeparator();
  setFieldSeparator();
  headings=new ArrayList<String>();
  lines=new ArrayList<DSpaceCSVLine>();
  counter=0;
  ignore=new Hashtable<String,String>();
  String toIgnore=ConfigurationManager.getProperty(""String_Node_Str"");
  if ((toIgnore == null) || (""String_Node_Str"".equals(toIgnore.trim()))) {
    toIgnore=""String_Node_Str"" + ""String_Node_Str"";
  }
  String[] toIgnoreArray=toIgnore.split(""String_Node_Str"");
  for (  String toIgnoreString : toIgnoreArray) {
    if (!""String_Node_Str"".equals(toIgnoreString.trim())) {
      ignore.put(toIgnoreString.trim(),toIgnoreString.trim());
    }
  }
}","/** 
 * Initialise this class with values from dspace.cfg
 */
private void init(){
  setValueSeparator();
  setFieldSeparator();
  headings=new ArrayList<String>();
  lines=new ArrayList<DSpaceCSVLine>();
  counter=0;
  ignore=new Hashtable<String,String>();
  String toIgnore=ConfigurationManager.getProperty(""String_Node_Str"");
  if ((toIgnore == null) || (""String_Node_Str"".equals(toIgnore.trim()))) {
    toIgnore=""String_Node_Str"" + ""String_Node_Str"";
  }
  String[] toIgnoreArray=toIgnore.split(""String_Node_Str"");
  for (  String toIgnoreString : toIgnoreArray) {
    if (!""String_Node_Str"".equals(toIgnoreString.trim())) {
      ignore.put(toIgnoreString.trim(),toIgnoreString.trim());
    }
  }
}",0.9992902767920512
52187,"/** 
 * Add an item to the CSV file, from a CSV line of elements
 * @param line The line of elements
 * @throws Exception Thrown if an error occurs when adding the item
 */
public void addItem(String line) throws Exception {
  boolean last=false;
  if (line.endsWith(fieldSeparator)) {
    last=true;
    line+=""String_Node_Str"";
  }
  String[] parts=line.split(escapedFieldSeparator);
  ArrayList<String> bits=new ArrayList<String>();
  bits.addAll(Arrays.asList(parts));
  boolean alldone=false;
  while (!alldone) {
    boolean found=false;
    int i=0;
    for (    String part : bits) {
      int bitcounter=part.length() - part.replaceAll(""String_Node_Str"",""String_Node_Str"").length();
      if ((part.startsWith(""String_Node_Str"")) && ((!part.endsWith(""String_Node_Str"")) || ((bitcounter % 2) == 1))) {
        found=true;
        String add=bits.get(i) + fieldSeparator + bits.get(i + 1);
        bits.remove(i);
        bits.add(i,add);
        bits.remove(i + 1);
        break;
      }
      i++;
    }
    alldone=!found;
  }
  int i=0;
  for (  String part : bits) {
    if ((part.startsWith(""String_Node_Str"")) && (part.endsWith(""String_Node_Str""))) {
      part=part.substring(1,part.length() - 1);
      bits.set(i,part);
    }
    i++;
  }
  i=0;
  for (  String part : bits) {
    if (part.contains(""String_Node_Str"")) {
      part=part.replaceAll(""String_Node_Str"",""String_Node_Str"");
      bits.set(i,part);
    }
    i++;
  }
  String id=parts[0].replaceAll(""String_Node_Str"",""String_Node_Str"");
  DSpaceCSVLine csvLine;
  if (""String_Node_Str"".equals(id)) {
    csvLine=new DSpaceCSVLine();
  }
 else {
    try {
      csvLine=new DSpaceCSVLine(Integer.parseInt(id));
    }
 catch (    NumberFormatException nfe) {
      System.err.println(""String_Node_Str"" + id);
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      throw (nfe);
    }
  }
  i=0;
  for (  String part : bits) {
    if (i > 0) {
      if ((last) && (i == headings.size())) {
        part=""String_Node_Str"";
      }
      csvLine.add(headings.get(i - 1),null);
      String[] elements=part.split(escpaedValueSeparator);
      for (      String element : elements) {
        if ((element != null) && (!""String_Node_Str"".equals(element))) {
          csvLine.add(headings.get(i - 1),element);
        }
      }
    }
    i++;
  }
  lines.add(csvLine);
  counter++;
}","/** 
 * Add an item to the CSV file, from a CSV line of elements
 * @param line The line of elements
 * @throws Exception Thrown if an error occurs when adding the item
 */
public void addItem(String line) throws Exception {
  boolean last=false;
  if (line.endsWith(fieldSeparator)) {
    last=true;
    line+=""String_Node_Str"";
  }
  String[] parts=line.split(escapedFieldSeparator);
  ArrayList<String> bits=new ArrayList<String>();
  bits.addAll(Arrays.asList(parts));
  boolean alldone=false;
  while (!alldone) {
    boolean found=false;
    int i=0;
    for (    String part : bits) {
      int bitcounter=part.length() - part.replaceAll(""String_Node_Str"",""String_Node_Str"").length();
      if ((part.startsWith(""String_Node_Str"")) && ((!part.endsWith(""String_Node_Str"")) || ((bitcounter % 2) == 1))) {
        found=true;
        String add=bits.get(i) + fieldSeparator + bits.get(i + 1);
        bits.remove(i);
        bits.add(i,add);
        bits.remove(i + 1);
        break;
      }
      i++;
    }
    alldone=!found;
  }
  int i=0;
  for (  String part : bits) {
    if ((part.startsWith(""String_Node_Str"")) && (part.endsWith(""String_Node_Str""))) {
      part=part.substring(1,part.length() - 1);
      bits.set(i,part);
    }
    i++;
  }
  i=0;
  for (  String part : bits) {
    if (part.contains(""String_Node_Str"")) {
      part=part.replaceAll(""String_Node_Str"",""String_Node_Str"");
      bits.set(i,part);
    }
    i++;
  }
  String id=parts[0].replaceAll(""String_Node_Str"",""String_Node_Str"");
  DSpaceCSVLine csvLine;
  if (""String_Node_Str"".equals(id)) {
    csvLine=new DSpaceCSVLine();
  }
 else {
    try {
      csvLine=new DSpaceCSVLine(Integer.parseInt(id));
    }
 catch (    NumberFormatException nfe) {
      System.err.println(""String_Node_Str"" + id);
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      throw (nfe);
    }
  }
  i=0;
  for (  String part : bits) {
    if (i > 0) {
      if ((last) && (i == headings.size())) {
        part=""String_Node_Str"";
      }
      csvLine.add(headings.get(i - 1),null);
      String[] elements=part.split(escapedValueSeparator);
      for (      String element : elements) {
        if ((element != null) && (!""String_Node_Str"".equals(element))) {
          csvLine.add(headings.get(i - 1),element);
        }
      }
    }
    i++;
  }
  lines.add(csvLine);
  counter++;
}",0.99915611814346
52188,"/** 
 * Set the value separator for multiple values stored in one csv value. Is set in dspace.cfg as bulkedit.valueseparator If not set, defaults to double pipe '||'
 */
private void setValueSeparator(){
  valueSeparator=ConfigurationManager.getProperty(""String_Node_Str"");
  if ((valueSeparator != null) && (!""String_Node_Str"".equals(valueSeparator.trim()))) {
    valueSeparator=valueSeparator.trim();
  }
 else {
    valueSeparator=""String_Node_Str"";
  }
  Pattern spchars=Pattern.compile(""String_Node_Str"");
  Matcher match=spchars.matcher(valueSeparator);
  escpaedValueSeparator=match.replaceAll(""String_Node_Str"");
}","/** 
 * Set the value separator for multiple values stored in one csv value. Is set in dspace.cfg as bulkedit.valueseparator If not set, defaults to double pipe '||'
 */
private void setValueSeparator(){
  valueSeparator=ConfigurationManager.getProperty(""String_Node_Str"");
  if ((valueSeparator != null) && (!""String_Node_Str"".equals(valueSeparator.trim()))) {
    valueSeparator=valueSeparator.trim();
  }
 else {
    valueSeparator=""String_Node_Str"";
  }
  Pattern spchars=Pattern.compile(""String_Node_Str"");
  Matcher match=spchars.matcher(valueSeparator);
  escapedValueSeparator=match.replaceAll(""String_Node_Str"");
}",0.9967897271268058
52189,"/** 
 * output the explanation of the stat block in the relevant format
 * @param explanation     the explanatory or clarification text for the stats
 * @return      a string contianing the formatted explanation
 */
abstract public String blockExplanation(String explanation);","/** 
 * output the explanation of the stat block in the relevant format
 * @param explanation     the explanatory or clarification text for the stats
 * @return      a string containing the formatted explanation
 */
abstract public String blockExplanation(String explanation);",0.9927536231884058
52190,"/** 
 * Syncronize the cached list of analysis / report files with the reports directory We synchronize if: 1) The number of files is different (ie. files have been added or removed) 2) We haven't cached anything yet 3) The cache was last generate over an hour ago
 */
private static void syncFileList(){
  File[] fileList=StatisticsLoader.getAnalysisAndReportFileList();
  if (fileList != null && fileList.length != fileCount)   StatisticsLoader.loadFileList(fileList);
 else   if (lastLoaded == null)   StatisticsLoader.loadFileList(fileList);
 else   if (DateUtils.addHours(lastLoaded,1).before(new Date()))   StatisticsLoader.loadFileList(fileList);
}","/** 
 * Synchronize the cached list of analysis / report files with the reports directory We synchronize if: 1) The number of files is different (ie. files have been added or removed) 2) We haven't cached anything yet 3) The cache was last generate over an hour ago
 */
private static void syncFileList(){
  File[] fileList=StatisticsLoader.getAnalysisAndReportFileList();
  if (fileList != null && fileList.length != fileCount)   StatisticsLoader.loadFileList(fileList);
 else   if (lastLoaded == null)   StatisticsLoader.loadFileList(fileList);
 else   if (DateUtils.addHours(lastLoaded,1).before(new Date()))   StatisticsLoader.loadFileList(fileList);
}",0.9992372234935164
52191,"/** 
 * The helper function to vaildate the DatePattern.
 * @param pstrPattern The DatePattern to be validated.
 * @return The validated date pattern or defautlt DATE_PATTERN
 */
private String checkPattern(String pstrPattern){
  String strRet=null;
  SimpleDateFormat objFmt=new SimpleDateFormat(DATE_PATTERN);
  try {
    this.mobjSDF=new SimpleDateFormat(pstrPattern);
    strRet=pstrPattern;
  }
 catch (  NullPointerException NPExIgnore) {
    LogLog.error(""String_Node_Str"" + pstrPattern,NPExIgnore);
    this.mobjSDF=objFmt;
    strRet=DATE_PATTERN;
  }
catch (  IllegalArgumentException IlArgExIgnore) {
    LogLog.error(""String_Node_Str"" + pstrPattern,IlArgExIgnore);
    this.mobjSDF=objFmt;
    strRet=DATE_PATTERN;
  }
 finally {
    objFmt=null;
  }
  return strRet;
}","/** 
 * The helper function to validate the DatePattern.
 * @param pstrPattern The DatePattern to be validated.
 * @return The validated date pattern or defautlt DATE_PATTERN
 */
private String checkPattern(String pstrPattern){
  String strRet=null;
  SimpleDateFormat objFmt=new SimpleDateFormat(DATE_PATTERN);
  try {
    this.mobjSDF=new SimpleDateFormat(pstrPattern);
    strRet=pstrPattern;
  }
 catch (  NullPointerException NPExIgnore) {
    LogLog.error(""String_Node_Str"" + pstrPattern,NPExIgnore);
    this.mobjSDF=objFmt;
    strRet=DATE_PATTERN;
  }
catch (  IllegalArgumentException IlArgExIgnore) {
    LogLog.error(""String_Node_Str"" + pstrPattern,IlArgExIgnore);
    this.mobjSDF=objFmt;
    strRet=DATE_PATTERN;
  }
 finally {
    objFmt=null;
  }
  return strRet;
}",0.997439180537772
52192,"/** 
 * Load necessary information to build the Progress Bar for the Item Submission Progress. This information is returned in the form of a HashMap (which is then stored as a part of the SubmissionInfo). The HashMap takes the following form: Keys - the number of the step, followed by the number of the page within the step (e.g. ""2.1"" = The first page of Step 2) (e.g. ""5.2"" = The second page of Step 5) Values - the headings to display for each step (e.g. ""Describe"", ""Verify"")
 * @param request The HTTP Servlet Request object
 * @param subInfo the SubmissionInfo object we are loading into
 * @param forceReload If true, this method reloads from stratch (and overwrites cached progress bar info)
 */
private static void loadProgressBar(HttpServletRequest request,SubmissionInfo subInfo,boolean forceReload){
  LinkedHashMap progressBarInfo=null;
  log.debug(""String_Node_Str"");
  if (!forceReload) {
    progressBarInfo=(LinkedHashMap)loadProgressBarFromCache(request.getSession());
  }
  if (progressBarInfo != null && log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + progressBarInfo.size() + ""String_Node_Str"");
  }
 else {
    progressBarInfo=new LinkedHashMap();
    for (int i=0; i < subInfo.submissionConfig.getNumberOfSteps(); i++) {
      SubmissionStepConfig currentStep=subInfo.submissionConfig.getStep(i);
      String stepNumber=Integer.toString(currentStep.getStepNumber());
      String stepHeading=currentStep.getHeading();
      if (currentStep.isVisible()) {
        int numPages=1;
        try {
          ClassLoader loader=subInfo.getClass().getClassLoader();
          Class stepClass=loader.loadClass(currentStep.getProcessingClassName());
          AbstractProcessingStep step=(AbstractProcessingStep)stepClass.newInstance();
          numPages=step.getNumberOfPages(request,subInfo);
        }
 catch (        Exception e) {
          log.error(""String_Node_Str"" + currentStep.getProcessingClassName() + ""String_Node_Str"",e);
        }
        for (int j=1; j <= numPages; j++) {
          String pageNumber=Integer.toString(j);
          progressBarInfo.put(stepNumber + ""String_Node_Str"" + pageNumber,stepHeading);
        }
      }
    }
    log.debug(""String_Node_Str"" + progressBarInfo.size() + ""String_Node_Str"");
    saveProgressBarToCache(request.getSession(),progressBarInfo);
  }
  subInfo.progressBar=progressBarInfo;
}","/** 
 * Load necessary information to build the Progress Bar for the Item Submission Progress. This information is returned in the form of a HashMap (which is then stored as a part of the SubmissionInfo). The HashMap takes the following form: Keys - the number of the step, followed by the number of the page within the step (e.g. ""2.1"" = The first page of Step 2) (e.g. ""5.2"" = The second page of Step 5) Values - the headings to display for each step (e.g. ""Describe"", ""Verify"")
 * @param request The HTTP Servlet Request object
 * @param subInfo the SubmissionInfo object we are loading into
 * @param forceReload If true, this method reloads from scratch (and overwrites cached progress bar info)
 */
private static void loadProgressBar(HttpServletRequest request,SubmissionInfo subInfo,boolean forceReload){
  LinkedHashMap progressBarInfo=null;
  log.debug(""String_Node_Str"");
  if (!forceReload) {
    progressBarInfo=(LinkedHashMap)loadProgressBarFromCache(request.getSession());
  }
  if (progressBarInfo != null && log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + progressBarInfo.size() + ""String_Node_Str"");
  }
 else {
    progressBarInfo=new LinkedHashMap();
    for (int i=0; i < subInfo.submissionConfig.getNumberOfSteps(); i++) {
      SubmissionStepConfig currentStep=subInfo.submissionConfig.getStep(i);
      String stepNumber=Integer.toString(currentStep.getStepNumber());
      String stepHeading=currentStep.getHeading();
      if (currentStep.isVisible()) {
        int numPages=1;
        try {
          ClassLoader loader=subInfo.getClass().getClassLoader();
          Class stepClass=loader.loadClass(currentStep.getProcessingClassName());
          AbstractProcessingStep step=(AbstractProcessingStep)stepClass.newInstance();
          numPages=step.getNumberOfPages(request,subInfo);
        }
 catch (        Exception e) {
          log.error(""String_Node_Str"" + currentStep.getProcessingClassName() + ""String_Node_Str"",e);
        }
        for (int j=1; j <= numPages; j++) {
          String pageNumber=Integer.toString(j);
          progressBarInfo.put(stepNumber + ""String_Node_Str"" + pageNumber,stepHeading);
        }
      }
    }
    log.debug(""String_Node_Str"" + progressBarInfo.size() + ""String_Node_Str"");
    saveProgressBarToCache(request.getSession(),progressBarInfo);
  }
  subInfo.progressBar=progressBarInfo;
}",0.9995777027027029
52193,"/** 
 * Loads SubmissionConfig object for the given submission info object. If a SubmissionConfig object cannot be loaded, a Servlet Error is thrown. <p> This method just loads this SubmissionConfig object internally, so that it is available via a call to ""getSubmissionConfig()""
 * @param request The HTTP Servlet Request object
 * @param subInfo the SubmissionInfo object we are loading into
 * @param forceReload If true, this method reloads from stratch (and overwrites cached SubmissionConfig)
 */
private static void loadSubmissionConfig(HttpServletRequest request,SubmissionInfo subInfo,boolean forceReload) throws ServletException {
  log.debug(""String_Node_Str"");
  if (!forceReload) {
    subInfo.submissionConfig=loadSubmissionConfigFromCache(request.getSession(),subInfo.getCollectionHandle(),subInfo.isInWorkflow());
  }
  if (subInfo.submissionConfig == null || forceReload) {
    subInfo.submissionConfig=submissionConfigReader.getSubmissionConfig(subInfo.getCollectionHandle(),subInfo.isInWorkflow());
    saveSubmissionConfigToCache(request.getSession(),subInfo.submissionConfig,subInfo.getCollectionHandle(),subInfo.isInWorkflow());
    loadProgressBar(request,subInfo,true);
  }
 else {
    log.debug(""String_Node_Str"");
    loadProgressBar(request,subInfo,false);
  }
}","/** 
 * Loads SubmissionConfig object for the given submission info object. If a SubmissionConfig object cannot be loaded, a Servlet Error is thrown. <p> This method just loads this SubmissionConfig object internally, so that it is available via a call to ""getSubmissionConfig()""
 * @param request The HTTP Servlet Request object
 * @param subInfo the SubmissionInfo object we are loading into
 * @param forceReload If true, this method reloads from scratch (and overwrites cached SubmissionConfig)
 */
private static void loadSubmissionConfig(HttpServletRequest request,SubmissionInfo subInfo,boolean forceReload) throws ServletException {
  log.debug(""String_Node_Str"");
  if (!forceReload) {
    subInfo.submissionConfig=loadSubmissionConfigFromCache(request.getSession(),subInfo.getCollectionHandle(),subInfo.isInWorkflow());
  }
  if (subInfo.submissionConfig == null || forceReload) {
    subInfo.submissionConfig=submissionConfigReader.getSubmissionConfig(subInfo.getCollectionHandle(),subInfo.isInWorkflow());
    saveSubmissionConfigToCache(request.getSession(),subInfo.submissionConfig,subInfo.getCollectionHandle(),subInfo.isInWorkflow());
    loadProgressBar(request,subInfo,true);
  }
 else {
    log.debug(""String_Node_Str"");
    loadProgressBar(request,subInfo,false);
  }
}",0.99922420480993
52194,"/** 
 * Formats the file size. Examples: - 50 = 50B - 1024 = 1KB - 1,024,000 = 1MB etc The numbers are formatted using java Locales
 * @param in The number to covnert
 * @return the file size as a String
 */
public static String formatFileSize(double in){
  NumberFormat nf=NumberFormat.getNumberInstance(Locale.getDefault());
  DecimalFormat df=(DecimalFormat)nf;
  df.applyPattern(""String_Node_Str"");
  if (in < 1024) {
    df.applyPattern(""String_Node_Str"");
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
 else   if (in < 1024000) {
    in=in / 1024;
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
 else   if (in < 1024000000) {
    in=in / 1024000;
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
 else {
    in=in / 1024000000;
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
}","/** 
 * Formats the file size. Examples: - 50 = 50B - 1024 = 1KB - 1,024,000 = 1MB etc The numbers are formatted using java Locales
 * @param in The number to convert
 * @return the file size as a String
 */
public static String formatFileSize(double in){
  NumberFormat nf=NumberFormat.getNumberInstance(Locale.getDefault());
  DecimalFormat df=(DecimalFormat)nf;
  df.applyPattern(""String_Node_Str"");
  if (in < 1024) {
    df.applyPattern(""String_Node_Str"");
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
 else   if (in < 1024000) {
    in=in / 1024;
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
 else   if (in < 1024000000) {
    in=in / 1024000;
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
 else {
    in=in / 1024000000;
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
}",0.9988545246277204
52195,"/** 
 * So that any left over indices for items which have been deleted can be assured to have been removed, this method checks for indicies for items which are not in the item table. If it finds an index which does not have an associated item it removes it.
 * @param table		the index table to check
 * @param map		the name of the associated distinct mapping table
 * @param withdrawn TODO
 * @throws BrowseException
 */
public void pruneExcess(String table,String map,boolean withdrawn) throws BrowseException ;","/** 
 * So that any left over indices for items which have been deleted can be assured to have been removed, this method checks for indices for items which are not in the item table. If it finds an index which does not have an associated item it removes it.
 * @param table		the index table to check
 * @param map		the name of the associated distinct mapping table
 * @param withdrawn TODO
 * @throws BrowseException
 */
public void pruneExcess(String table,String map,boolean withdrawn) throws BrowseException ;",0.9990243902439024
52196,"private static void init(){
  if (hiddenElementSets == null) {
    hiddenElementSets=new HashMap<String,Set<String>>();
    hiddenElementMaps=new HashMap<String,Map<String,Set<String>>>();
    Enumeration pne=ConfigurationManager.propertyNames();
    while (pne.hasMoreElements()) {
      String key=(String)pne.nextElement();
      if (key.startsWith(CONFIG_PREFIX)) {
        String mdField=key.substring(CONFIG_PREFIX.length());
        String segment[]=mdField.split(""String_Node_Str"",3);
        if (segment.length == 3) {
          Map<String,Set<String>> eltMap=hiddenElementMaps.get(segment[0]);
          if (eltMap == null) {
            eltMap=new HashMap<String,Set<String>>();
            hiddenElementMaps.put(segment[0],eltMap);
          }
          if (!eltMap.containsKey(segment[1])) {
            eltMap.put(segment[1],new HashSet<String>());
          }
          eltMap.get(segment[1]).add(segment[2]);
        }
 else         if (segment.length == 2) {
          if (!hiddenElementSets.containsKey(segment[0])) {
            hiddenElementSets.put(segment[0],new HashSet<String>());
          }
          hiddenElementSets.get(segment[0]).add(segment[1]);
        }
 else {
          log.warn(""String_Node_Str"" + mdField + ""String_Node_Str""+ key);
        }
      }
    }
  }
}","private static synchronized void init(){
  if (!isInitialized()) {
    hiddenElementSets=new HashMap<String,Set<String>>();
    hiddenElementMaps=new HashMap<String,Map<String,Set<String>>>();
    Enumeration pne=ConfigurationManager.propertyNames();
    while (pne.hasMoreElements()) {
      String key=(String)pne.nextElement();
      if (key.startsWith(CONFIG_PREFIX)) {
        String mdField=key.substring(CONFIG_PREFIX.length());
        String segment[]=mdField.split(""String_Node_Str"",3);
        if (segment.length == 3) {
          Map<String,Set<String>> eltMap=hiddenElementMaps.get(segment[0]);
          if (eltMap == null) {
            eltMap=new HashMap<String,Set<String>>();
            hiddenElementMaps.put(segment[0],eltMap);
          }
          if (!eltMap.containsKey(segment[1])) {
            eltMap.put(segment[1],new HashSet<String>());
          }
          eltMap.get(segment[1]).add(segment[2]);
        }
 else         if (segment.length == 2) {
          if (!hiddenElementSets.containsKey(segment[0])) {
            hiddenElementSets.put(segment[0],new HashSet<String>());
          }
          hiddenElementSets.get(segment[0]).add(segment[1]);
        }
 else {
          log.warn(""String_Node_Str"" + mdField + ""String_Node_Str""+ key);
        }
      }
    }
  }
}",0.9792467332820908
52197,"public static boolean isHidden(Context context,String schema,String element,String qualifier) throws SQLException {
  if (context != null && AuthorizeManager.isAdmin(context))   return false;
  init();
  if (qualifier == null) {
    Set<String> elts=hiddenElementSets.get(schema);
    return elts == null ? false : elts.contains(element);
  }
 else {
    Map<String,Set<String>> elts=hiddenElementMaps.get(schema);
    if (elts == null)     return false;
    Set<String> quals=elts.get(element);
    return quals == null ? false : quals.contains(qualifier);
  }
}","public static boolean isHidden(Context context,String schema,String element,String qualifier) throws SQLException {
  if (context != null && AuthorizeManager.isAdmin(context))   return false;
  if (!isInitialized()) {
    init();
  }
  if (qualifier == null) {
    Set<String> elts=hiddenElementSets.get(schema);
    return elts == null ? false : elts.contains(element);
  }
 else {
    Map<String,Set<String>> elts=hiddenElementMaps.get(schema);
    if (elts == null)     return false;
    Set<String> quals=elts.get(element);
    return quals == null ? false : quals.contains(qualifier);
  }
}",0.9620034542314336
52198,"private static void initCache(Context context) throws SQLException {
  if (id2field != null)   return;
synchronized (MetadataField.class) {
    if (id2field == null) {
      HashMap new_id2field=new HashMap();
      log.info(""String_Node_Str"");
      TableRowIterator tri=DatabaseManager.queryTable(context,""String_Node_Str"",""String_Node_Str"");
      try {
        while (tri.hasNext()) {
          TableRow row=tri.next();
          int fieldID=row.getIntColumn(""String_Node_Str"");
          new_id2field.put(new Integer(fieldID),new MetadataField(row));
        }
      }
  finally {
        if (tri != null)         tri.close();
      }
      id2field=new_id2field;
    }
  }
}","private static synchronized void initCache(Context context) throws SQLException {
  if (!isCacheInitialized()) {
    HashMap new_id2field=new HashMap();
    log.info(""String_Node_Str"");
    TableRowIterator tri=DatabaseManager.queryTable(context,""String_Node_Str"",""String_Node_Str"");
    try {
      while (tri.hasNext()) {
        TableRow row=tri.next();
        int fieldID=row.getIntColumn(""String_Node_Str"");
        new_id2field.put(new Integer(fieldID),new MetadataField(row));
      }
    }
  finally {
      if (tri != null)       tri.close();
    }
    id2field=new_id2field;
  }
}",0.8056648308418568
52199,"/** 
 * Find the field corresponding to the given numeric ID.  The ID is a database key internal to DSpace.
 * @param context context, in case we need to read it in from DB
 * @param id the metadata field ID
 * @return the metadata field object
 * @throws SQLException
 */
public static MetadataField find(Context context,int id) throws SQLException {
  initCache(context);
  Integer iid=new Integer(id);
  if (!id2field.containsKey(iid))   return null;
  return (MetadataField)id2field.get(iid);
}","/** 
 * Find the field corresponding to the given numeric ID.  The ID is a database key internal to DSpace.
 * @param context context, in case we need to read it in from DB
 * @param id the metadata field ID
 * @return the metadata field object
 * @throws SQLException
 */
public static MetadataField find(Context context,int id) throws SQLException {
  if (!isCacheInitialized()) {
    initCache(context);
  }
  Integer iid=new Integer(id);
  if (!id2field.containsKey(iid))   return null;
  return (MetadataField)id2field.get(iid);
}",0.9583736689254598
52200,"private static void initCache(Context context) throws SQLException {
  if (id2schema != null && name2schema != null)   return;
synchronized (MetadataSchema.class) {
    if (id2schema == null && name2schema == null) {
      log.info(""String_Node_Str"");
      HashMap new_id2schema=new HashMap();
      HashMap new_name2schema=new HashMap();
      TableRowIterator tri=DatabaseManager.queryTable(context,""String_Node_Str"",""String_Node_Str"");
      try {
        while (tri.hasNext()) {
          TableRow row=tri.next();
          MetadataSchema s=new MetadataSchema(row);
          new_id2schema.put(new Integer(s.schemaID),s);
          new_name2schema.put(s.name,s);
        }
      }
  finally {
        if (tri != null)         tri.close();
      }
      id2schema=new_id2schema;
      name2schema=new_name2schema;
    }
  }
}","private static synchronized void initCache(Context context) throws SQLException {
  if (!isCacheInitialized()) {
    log.info(""String_Node_Str"");
    HashMap new_id2schema=new HashMap();
    HashMap new_name2schema=new HashMap();
    TableRowIterator tri=DatabaseManager.queryTable(context,""String_Node_Str"",""String_Node_Str"");
    try {
      while (tri.hasNext()) {
        TableRow row=tri.next();
        MetadataSchema s=new MetadataSchema(row);
        new_id2schema.put(new Integer(s.schemaID),s);
        new_name2schema.put(s.name,s);
      }
    }
  finally {
      if (tri != null)       tri.close();
    }
    id2schema=new_id2schema;
    name2schema=new_name2schema;
  }
}",0.6459709379128138
52201,"/** 
 * Get the schema corresponding with this short name.
 * @param context context, in case we need to read it in from DB
 * @param shortName the short name for the schema
 * @return the metadata schema object
 * @throws SQLException
 */
public static MetadataSchema find(Context context,String shortName) throws SQLException {
  if (shortName == null)   return null;
  initCache(context);
  if (!name2schema.containsKey(shortName))   return null;
  return (MetadataSchema)name2schema.get(shortName);
}","/** 
 * Get the schema corresponding with this short name.
 * @param context context, in case we need to read it in from DB
 * @param shortName the short name for the schema
 * @return the metadata schema object
 * @throws SQLException
 */
public static MetadataSchema find(Context context,String shortName) throws SQLException {
  if (shortName == null)   return null;
  if (!isCacheInitialized()) {
    initCache(context);
  }
  if (!name2schema.containsKey(shortName))   return null;
  return (MetadataSchema)name2schema.get(shortName);
}",0.9588516746411484
52202,"public static String[] getPluginNames(){
  if (pluginNames == null) {
    try {
      if (dci == null)       dci=new DCInputsReader();
    }
 catch (    DCInputsReaderException e) {
      log.error(""String_Node_Str"",e);
    }
    List<String> names=new ArrayList<String>();
    Iterator pi=dci.getPairsNameIterator();
    while (pi.hasNext())     names.add((String)pi.next());
    pluginNames=names.toArray(new String[names.size()]);
    log.debug(""String_Node_Str"" + Arrays.deepToString(pluginNames));
  }
  return pluginNames;
}","public static String[] getPluginNames(){
  if (pluginNames == null) {
    try {
      if (dci == null)       dci=new DCInputsReader();
    }
 catch (    DCInputsReaderException e) {
      log.error(""String_Node_Str"",e);
    }
    List<String> names=new ArrayList<String>();
    Iterator pi=dci.getPairsNameIterator();
    while (pi.hasNext()) {
      names.add((String)pi.next());
    }
    pluginNames=names.toArray(new String[names.size()]);
    log.debug(""String_Node_Str"" + Arrays.deepToString(pluginNames));
  }
  return pluginNames;
}",0.9906542056074766
52203,"/** 
 * Close any IndexSearcher that is currently open.
 */
public static void close(){
  if (searcher != null) {
    try {
      searcher.close();
      searcher=null;
    }
 catch (    IOException ioe) {
      log.error(""String_Node_Str"",ioe);
    }
  }
}","/** 
 * Close any IndexSearcher that is currently open.
 */
public static synchronized void close(){
  if (searcher != null) {
    try {
      searcher.close();
      searcher=null;
    }
 catch (    IOException ioe) {
      log.error(""String_Node_Str"",ioe);
    }
  }
}",0.9753320683111956
52204,"/** 
 * Return all the configured sort options
 * @return
 * @throws SortException
 */
public static Set<SortOption> getSortOptions() throws SortException {
  if (SortOption.sortOptionsSet != null)   return SortOption.sortOptionsSet;
synchronized (SortOption.class) {
    if (SortOption.sortOptionsSet == null) {
      Set<SortOption> newSortOptionsSet=new HashSet<SortOption>();
      int idx=1;
      String option;
      while (((option=ConfigurationManager.getProperty(""String_Node_Str"" + idx))) != null) {
        SortOption so=new SortOption(idx,option);
        newSortOptionsSet.add(so);
        idx++;
      }
      SortOption.sortOptionsSet=newSortOptionsSet;
    }
  }
  return SortOption.sortOptionsSet;
}","/** 
 * Return all the configured sort options
 * @return
 * @throws SortException
 */
public static Set<SortOption> getSortOptions() throws SortException {
  if (SortOption.sortOptionsSet == null) {
    throw new SortException(""String_Node_Str"");
  }
  return SortOption.sortOptionsSet;
}",0.4612326043737574
52205,"/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        Set<Integer> distIDSet=new HashSet<Integer>();
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null && values.length > 0) {
              int minConfidence=MetadataAuthorityManager.getManager().getMinConfidence(values[0].schema,values[0].element,values[0].qualifier);
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  if (bis[i].isAuthorityIndex() && (values[x].authority == null || values[x].confidence < minConfidence)) {
                    log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ ""String_Node_Str""+ values[x].qualifier+ ""String_Node_Str""+ values[x].value+ ""String_Node_Str""+ values[x].authority+ ""String_Node_Str""+ values[x].confidence+ ""String_Node_Str"");
                    break;
                  }
                  if (values[x].authority != null && values[x].confidence >= minConfidence) {
                    boolean isValueVariants=false;
                    List<String> variants=ChoiceAuthorityManager.getManager().getVariants(values[x].schema,values[x].element,values[x].qualifier,values[x].authority,values[x].language);
                    if (variants != null) {
                      for (                      String var : variants) {
                        String nVal=OrderFormat.makeSortString(var,values[x].language,bis[i].getDataType());
                        distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),var,values[x].authority,nVal));
                        if (var.equals(values[x].value)) {
                          isValueVariants=true;
                        }
                      }
                    }
                    if (!isValueVariants) {
                      String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                      distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,values[x].authority,nVal));
                    }
                  }
 else {
                    String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                    distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,null,nVal));
                  }
                }
              }
            }
          }
        }
        if (distIDSet.isEmpty()) {
          removeIndex(item.getID(),bis[i].getMapTableName());
        }
 else {
          int[] distIDarr=new int[distIDSet.size()];
          int didx=0;
          for (          Integer distID : distIDSet) {
            distIDarr[didx++]=distID;
          }
          dao.updateDistinctMappings(bis[i].getMapTableName(),item.getID(),distIDarr);
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        Set<Integer> distIDSet=new HashSet<Integer>();
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null && values.length > 0) {
              int minConfidence=MetadataAuthorityManager.getManager().getMinConfidence(values[0].schema,values[0].element,values[0].qualifier);
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  if (bis[i].isAuthorityIndex() && (values[x].authority == null || values[x].confidence < minConfidence)) {
                    log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ ""String_Node_Str""+ values[x].qualifier+ ""String_Node_Str""+ values[x].value+ ""String_Node_Str""+ values[x].authority+ ""String_Node_Str""+ values[x].confidence+ ""String_Node_Str"");
                    continue;
                  }
                  if (values[x].authority != null && values[x].confidence >= minConfidence) {
                    boolean isValueVariants=false;
                    List<String> variants=ChoiceAuthorityManager.getManager().getVariants(values[x].schema,values[x].element,values[x].qualifier,values[x].authority,values[x].language);
                    if (variants != null) {
                      for (                      String var : variants) {
                        String nVal=OrderFormat.makeSortString(var,values[x].language,bis[i].getDataType());
                        distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),var,values[x].authority,nVal));
                        if (var.equals(values[x].value)) {
                          isValueVariants=true;
                        }
                      }
                    }
                    if (!isValueVariants) {
                      String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                      distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,values[x].authority,nVal));
                    }
                  }
 else {
                    String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                    distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,null,nVal));
                  }
                }
              }
            }
          }
        }
        if (distIDSet.isEmpty()) {
          removeIndex(item.getID(),bis[i].getMapTableName());
        }
 else {
          int[] distIDarr=new int[distIDSet.size()];
          int didx=0;
          for (          Integer distID : distIDSet) {
            distIDarr[didx++]=distID;
          }
          dao.updateDistinctMappings(bis[i].getMapTableName(),item.getID(),distIDarr);
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9986891196934556
52206,"/** 
 * When DSpace creates Default Group Names they are of a very specific format, for example: <li> COMMUNITY_[ID]_ADMIN <li> COLLECTION_[ID]_ADMIN <li> COLLECTION_[ID]_SUBMIT <li> COLLECTION_[ID]_WORKFLOW_STEP_# <p> Although these names work fine within DSpace, the DSpace internal ID (represented by [ID] above) becomes meaningless when content is exported outside of DSpace.  In order to make these Group names meaningful outside of DSpace, they must be translated into a different format: <li> COMMUNITY_[HANDLE]_ADMIN (e.g. COMMUNITY_hdl:123456789/10_ADMIN), etc. <p> This format replaces the internal ID with an external Handle identifier (which is expected to be more meaningful even when content is exported from DSpace). <p> This method translates between the two Group Name formats. In either case if the specified <code>groupDefaultName</code> looks to be a default group name with an identifier, its identifier is replaced with the value of <code>newGroupIdentifier</code>.  This allows you to more easily translate an internal group name to one that can have meaning external to DSpace (and visa versa). <p> This method may be useful to any Crosswalks/Packagers which deal with import/export of DSpace Groups.
 * @param relatedDso DSpaceObject associated with group
 * @param groupDefaultName Group's default name
 * @return a new default Group name, containing the newGroupIdentifier
 */
public static String crosswalkDefaultGroupName(Context context,String groupDefaultName) throws PackageException {
  if (!groupDefaultName.matches(""String_Node_Str"")) {
    return groupDefaultName;
  }
  String objType=groupDefaultName.substring(0,groupDefaultName.indexOf(""String_Node_Str""));
  String tmpEndString=groupDefaultName.substring(groupDefaultName.indexOf(""String_Node_Str"") + 1);
  String objID=tmpEndString.substring(0,tmpEndString.indexOf(""String_Node_Str""));
  String groupType=tmpEndString.substring(tmpEndString.indexOf(""String_Node_Str"") + 1);
  try {
    if (objID.contains(""String_Node_Str"")) {
      DSpaceObject dso=HandleManager.resolveToObject(context,objID.substring(4));
      if (dso == null)       throw new PackageException(""String_Node_Str"" + objID + ""String_Node_Str""+ groupDefaultName+ ""String_Node_Str"");
      if (Constants.getTypeID(objType) != dso.getType())       throw new PackageException(""String_Node_Str"" + objID + ""String_Node_Str""+ groupDefaultName+ ""String_Node_Str"");
      return objType + ""String_Node_Str"" + dso.getID()+ ""String_Node_Str""+ groupType;
    }
 else {
      DSpaceObject dso=DSpaceObject.find(context,Constants.getTypeID(objType),Integer.parseInt(objID));
      if (dso == null)       throw new PackageException(""String_Node_Str"" + objID + ""String_Node_Str""+ objType+ ""String_Node_Str""+ groupDefaultName+ ""String_Node_Str"");
      return objType + ""String_Node_Str"" + ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ groupType;
    }
  }
 catch (  SQLException sqle) {
    throw new PackageException(""String_Node_Str"" + groupDefaultName + ""String_Node_Str"");
  }
}","/** 
 * When DSpace creates Default Group Names they are of a very specific format, for example: <li> COMMUNITY_[ID]_ADMIN <li> COLLECTION_[ID]_ADMIN <li> COLLECTION_[ID]_SUBMIT <li> COLLECTION_[ID]_WORKFLOW_STEP_# <p> Although these names work fine within DSpace, the DSpace internal ID (represented by [ID] above) becomes meaningless when content is exported outside of DSpace.  In order to make these Group names meaningful outside of DSpace, they must be translated into a different format: <li> COMMUNITY_[HANDLE]_ADMIN (e.g. COMMUNITY_hdl:123456789/10_ADMIN), etc. <p> This format replaces the internal ID with an external Handle identifier (which is expected to be more meaningful even when content is exported from DSpace). <p> This method translates between the two Group Name formats. In either case if the specified <code>groupDefaultName</code> looks to be a default group name with an identifier, its identifier is replaced with the value of <code>newGroupIdentifier</code>.  This allows you to more easily translate an internal group name to one that can have meaning external to DSpace (and visa versa). <p> This method may be useful to any Crosswalks/Packagers which deal with import/export of DSpace Groups.
 * @param relatedDso DSpaceObject associated with group
 * @param groupDefaultName Group's default name
 * @return a new default Group name, containing the newGroupIdentifier
 */
public static String crosswalkDefaultGroupName(Context context,String groupDefaultName) throws PackageException {
  if (!groupDefaultName.matches(""String_Node_Str"")) {
    return groupDefaultName;
  }
  String objType=groupDefaultName.substring(0,groupDefaultName.indexOf(""String_Node_Str""));
  String tmpEndString=groupDefaultName.substring(groupDefaultName.indexOf(""String_Node_Str"") + 1);
  String objID=tmpEndString.substring(0,tmpEndString.indexOf(""String_Node_Str""));
  String groupType=tmpEndString.substring(tmpEndString.indexOf(""String_Node_Str"") + 1);
  try {
    if (objID.contains(""String_Node_Str"")) {
      DSpaceObject dso=HandleManager.resolveToObject(context,objID.substring(4));
      if (dso == null) {
        log.warn(""String_Node_Str"" + groupDefaultName + ""String_Node_Str""+ objID+ ""String_Node_Str"");
        return groupDefaultName;
      }
      if (Constants.getTypeID(objType) != dso.getType())       throw new PackageException(""String_Node_Str"" + objID + ""String_Node_Str""+ groupDefaultName+ ""String_Node_Str"");
      return objType + ""String_Node_Str"" + dso.getID()+ ""String_Node_Str""+ groupType;
    }
 else {
      DSpaceObject dso=DSpaceObject.find(context,Constants.getTypeID(objType),Integer.parseInt(objID));
      if (dso == null) {
        log.warn(""String_Node_Str"" + groupDefaultName + ""String_Node_Str""+ objID+ ""String_Node_Str""+ objType+ ""String_Node_Str"");
        return groupDefaultName;
      }
      return objType + ""String_Node_Str"" + ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ groupType;
    }
  }
 catch (  SQLException sqle) {
    throw new PackageException(""String_Node_Str"" + groupDefaultName + ""String_Node_Str"");
  }
}",0.9467668190725016
52207,"/** 
 * Return a Group Type string (see RoleDisseminator.GROUP_TYPE_* constants) which describes the type of group and its relation to the given object. <P> As a basic example, if the Group is a Collection Administration group, the Group Type string returned should be ""ADMIN"" <P> If type string cannot be determined, null is returned.
 * @param dso the related DSpaceObject
 * @param group the group
 * @return a group type string or null
 */
private String getGroupType(DSpaceObject dso,Group group){
  if (dso.getType() == Constants.COMMUNITY) {
    Community community=(Community)dso;
    if (community.getAdministrators().equals(group))     return GROUP_TYPE_ADMIN;
  }
 else   if (dso.getType() == Constants.COLLECTION) {
    Collection collection=(Collection)dso;
    if (collection.getAdministrators().equals(group))     return GROUP_TYPE_ADMIN;
 else     if (collection.getSubmitters().equals(group))     return GROUP_TYPE_SUBMIT;
 else     if (collection.getWorkflowGroup(1).equals(group))     return GROUP_TYPE_WORKFLOW_STEP_1;
 else     if (collection.getWorkflowGroup(2).equals(group))     return GROUP_TYPE_WORKFLOW_STEP_2;
 else     if (collection.getWorkflowGroup(3).equals(group))     return GROUP_TYPE_WORKFLOW_STEP_3;
  }
  return null;
}","/** 
 * Return a Group Type string (see RoleDisseminator.GROUP_TYPE_* constants) which describes the type of group and its relation to the given object. <P> As a basic example, if the Group is a Collection Administration group, the Group Type string returned should be ""ADMIN"" <P> If type string cannot be determined, null is returned.
 * @param dso the related DSpaceObject
 * @param group the group
 * @return a group type string or null
 */
private String getGroupType(DSpaceObject dso,Group group){
  if (dso.getType() == Constants.COMMUNITY) {
    Community community=(Community)dso;
    if (community.getAdministrators() != null && community.getAdministrators().equals(group))     return GROUP_TYPE_ADMIN;
  }
 else   if (dso.getType() == Constants.COLLECTION) {
    Collection collection=(Collection)dso;
    if (collection.getAdministrators() != null && collection.getAdministrators().equals(group))     return GROUP_TYPE_ADMIN;
 else     if (collection.getSubmitters() != null && collection.getSubmitters().equals(group))     return GROUP_TYPE_SUBMIT;
 else     if (collection.getWorkflowGroup(1) != null && collection.getWorkflowGroup(1).equals(group))     return GROUP_TYPE_WORKFLOW_STEP_1;
 else     if (collection.getWorkflowGroup(2) != null && collection.getWorkflowGroup(2).equals(group))     return GROUP_TYPE_WORKFLOW_STEP_2;
 else     if (collection.getWorkflowGroup(3) != null && collection.getWorkflowGroup(3).equals(group))     return GROUP_TYPE_WORKFLOW_STEP_3;
  }
  return null;
}",0.9105396595436436
52208,"/** 
 * Actually Disseminate into METSRights schema.  This method locates all DSpace policies (permissions) for the provided object, and translates them into METSRights PermissionTypes.
 * @param dso DSpace Object
 * @return XML Element corresponding to the new <RightsDeclarationMD> translation
 * @throws CrosswalkException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
@Override public Element disseminateElement(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso == null)   return null;
 else   if (dso.getType() == Constants.SITE)   throw new CrosswalkObjectNotSupported(""String_Node_Str"");
  Element rightsMD=new Element(""String_Node_Str"",METSRights_NS);
  rightsMD.setAttribute(""String_Node_Str"",""String_Node_Str"");
  Context context=new Context();
  List<ResourcePolicy> policies=AuthorizeManager.getPolicies(context,dso);
  for (  ResourcePolicy policy : policies) {
    Group group=policy.getGroup();
    EPerson person=policy.getEPerson();
    Element rightsContext=new Element(""String_Node_Str"",METSRights_NS);
    rightsMD.addContent(rightsContext);
    if (group != null) {
      String contextClass=GROUP_CONTEXTCLASS;
      if (group.getID() == 0)       contextClass=ANONYMOUS_CONTEXTCLASS;
 else       if (group.getID() == 1)       contextClass=ADMIN_CONTEXTCLASS;
      rightsContext.setAttribute(""String_Node_Str"",contextClass);
      if (contextClass.equals(GROUP_CONTEXTCLASS)) {
        try {
          Element rightsUser=new Element(""String_Node_Str"",METSRights_NS);
          rightsUser.setAttribute(""String_Node_Str"",GROUP_USERTYPE);
          rightsUser.addContent(PackageUtils.crosswalkDefaultGroupName(context,group.getName()));
          rightsContext.addContent(rightsUser);
        }
 catch (        PackageException pe) {
          throw new CrosswalkException(pe);
        }
      }
    }
 else     if (person != null) {
      rightsContext.setAttribute(""String_Node_Str"",PERSON_CONTEXTCLASS);
      Element rightsUser=new Element(""String_Node_Str"",METSRights_NS);
      rightsUser.setAttribute(""String_Node_Str"",PERSON_USERTYPE);
      rightsUser.addContent(person.getEmail());
      rightsContext.addContent(rightsUser);
    }
    Element rightsPerm=translatePermissions(policy);
    rightsContext.addContent(rightsPerm);
  }
  context.complete();
  return rightsMD;
}","/** 
 * Actually Disseminate into METSRights schema.  This method locates all DSpace policies (permissions) for the provided object, and translates them into METSRights PermissionTypes.
 * @param dso DSpace Object
 * @return XML Element corresponding to the new <RightsDeclarationMD> translation
 * @throws CrosswalkException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
@Override public Element disseminateElement(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso == null)   return null;
 else   if (dso.getType() == Constants.SITE)   throw new CrosswalkObjectNotSupported(""String_Node_Str"");
  Element rightsMD=new Element(""String_Node_Str"",METSRights_NS);
  rightsMD.setAttribute(""String_Node_Str"",""String_Node_Str"");
  Context context=new Context();
  List<ResourcePolicy> policies=AuthorizeManager.getPolicies(context,dso);
  for (  ResourcePolicy policy : policies) {
    Group group=policy.getGroup();
    EPerson person=policy.getEPerson();
    Element rightsContext=new Element(""String_Node_Str"",METSRights_NS);
    rightsMD.addContent(rightsContext);
    if (group != null) {
      String contextClass=GROUP_CONTEXTCLASS;
      if (group.getID() == 0)       contextClass=ANONYMOUS_CONTEXTCLASS;
 else       if (group.getID() == 1)       contextClass=ADMIN_CONTEXTCLASS;
      rightsContext.setAttribute(""String_Node_Str"",contextClass);
      if (contextClass.equals(GROUP_CONTEXTCLASS)) {
        try {
          Element rightsUser=new Element(""String_Node_Str"",METSRights_NS);
          rightsUser.setAttribute(""String_Node_Str"",GROUP_USERTYPE);
          rightsUser.addContent(PackageUtils.translateGroupNameForExport(context,group.getName()));
          rightsContext.addContent(rightsUser);
        }
 catch (        PackageException pe) {
          throw new CrosswalkException(pe);
        }
      }
    }
 else     if (person != null) {
      rightsContext.setAttribute(""String_Node_Str"",PERSON_CONTEXTCLASS);
      Element rightsUser=new Element(""String_Node_Str"",METSRights_NS);
      rightsUser.setAttribute(""String_Node_Str"",PERSON_USERTYPE);
      rightsUser.addContent(person.getEmail());
      rightsContext.addContent(rightsUser);
    }
    Element rightsPerm=translatePermissions(policy);
    rightsContext.addContent(rightsPerm);
  }
  context.complete();
  return rightsMD;
}",0.9928900041823504
52209,"/** 
 * Ingest a List of XML elements <P> This method creates new DSpace Policies based on the parsed METSRights XML contents. These Policies assign permissions to DSpace Groups or EPeople. <P> NOTE: This crosswalk will NOT create missing DSpace Groups or EPeople. Therefore, it is recommended to use this METSRightsCrosswalk in conjunction with another Crosswalk which can create/restore missing Groups or EPeople (e.g. RoleCrosswalk).
 * @param context
 * @param dso
 * @param metadata
 * @throws CrosswalkException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 * @see RoleCrosswalk
 */
@Override public void ingest(Context context,DSpaceObject dso,List ml) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() == Constants.SITE)   throw new CrosswalkObjectNotSupported(""String_Node_Str"");
  if (!ml.isEmpty())   AuthorizeManager.removeAllPolicies(context,dso);
  Iterator mi=ml.iterator();
  while (mi.hasNext()) {
    Element element=(Element)mi.next();
    if (element.getName().equals(""String_Node_Str""))     ingest(context,dso,element.getChildren());
 else     if (element.getName().equals(""String_Node_Str"")) {
      String contextClass=element.getAttributeValue(""String_Node_Str"");
      Element permsElement=element.getChild(""String_Node_Str"",METSRights_NS);
      if (contextClass.equals(ANONYMOUS_CONTEXTCLASS)) {
        Group anonGroup=Group.find(context,0);
        if (anonGroup == null)         throw new CrosswalkInternalException(""String_Node_Str"");
        assignPermissions(context,dso,anonGroup,permsElement);
      }
 else       if (contextClass.equals(ADMIN_CONTEXTCLASS)) {
        Group adminGroup=Group.find(context,1);
        if (adminGroup == null)         throw new CrosswalkInternalException(""String_Node_Str"");
        assignPermissions(context,dso,adminGroup,permsElement);
      }
 else       if (contextClass.equals(GROUP_CONTEXTCLASS)) {
        try {
          String groupName=element.getChildTextTrim(""String_Node_Str"",METSRights_NS);
          groupName=PackageUtils.crosswalkDefaultGroupName(context,groupName);
          Group group=Group.findByName(context,groupName);
          if (group == null) {
            throw new CrosswalkInternalException(""String_Node_Str"" + ""String_Node_Str"" + Constants.typeText[dso.getType()] + ""String_Node_Str""+ ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ groupName+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          assignPermissions(context,dso,group,permsElement);
        }
 catch (        PackageException pe) {
          throw new CrosswalkException(pe);
        }
      }
 else       if (contextClass.equals(PERSON_CONTEXTCLASS)) {
        String personEmail=element.getChildTextTrim(""String_Node_Str"",METSRights_NS);
        EPerson person=EPerson.findByEmail(context,personEmail);
        if (person == null)         person=EPerson.findByNetid(context,personEmail);
        if (person == null) {
          throw new CrosswalkInternalException(""String_Node_Str"" + ""String_Node_Str"" + Constants.typeText[dso.getType()] + ""String_Node_Str""+ ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ personEmail+ ""String_Node_Str""+ ""String_Node_Str"");
        }
        assignPermissions(context,dso,person,permsElement);
      }
    }
  }
}","/** 
 * Ingest a List of XML elements <P> This method creates new DSpace Policies based on the parsed METSRights XML contents. These Policies assign permissions to DSpace Groups or EPeople. <P> NOTE: This crosswalk will NOT create missing DSpace Groups or EPeople. Therefore, it is recommended to use this METSRightsCrosswalk in conjunction with another Crosswalk which can create/restore missing Groups or EPeople (e.g. RoleCrosswalk).
 * @param context
 * @param dso
 * @param metadata
 * @throws CrosswalkException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 * @see RoleCrosswalk
 */
@Override public void ingest(Context context,DSpaceObject dso,List ml) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() == Constants.SITE)   throw new CrosswalkObjectNotSupported(""String_Node_Str"");
  if (!ml.isEmpty())   AuthorizeManager.removeAllPolicies(context,dso);
  Iterator mi=ml.iterator();
  while (mi.hasNext()) {
    Element element=(Element)mi.next();
    if (element.getName().equals(""String_Node_Str""))     ingest(context,dso,element.getChildren());
 else     if (element.getName().equals(""String_Node_Str"")) {
      String contextClass=element.getAttributeValue(""String_Node_Str"");
      Element permsElement=element.getChild(""String_Node_Str"",METSRights_NS);
      if (contextClass.equals(ANONYMOUS_CONTEXTCLASS)) {
        Group anonGroup=Group.find(context,0);
        if (anonGroup == null)         throw new CrosswalkInternalException(""String_Node_Str"");
        assignPermissions(context,dso,anonGroup,permsElement);
      }
 else       if (contextClass.equals(ADMIN_CONTEXTCLASS)) {
        Group adminGroup=Group.find(context,1);
        if (adminGroup == null)         throw new CrosswalkInternalException(""String_Node_Str"");
        assignPermissions(context,dso,adminGroup,permsElement);
      }
 else       if (contextClass.equals(GROUP_CONTEXTCLASS)) {
        try {
          String groupName=element.getChildTextTrim(""String_Node_Str"",METSRights_NS);
          groupName=PackageUtils.translateGroupNameForImport(context,groupName);
          Group group=Group.findByName(context,groupName);
          if (group == null) {
            throw new CrosswalkInternalException(""String_Node_Str"" + ""String_Node_Str"" + Constants.typeText[dso.getType()] + ""String_Node_Str""+ ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ groupName+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          assignPermissions(context,dso,group,permsElement);
        }
 catch (        PackageException pe) {
          throw new CrosswalkException(pe);
        }
      }
 else       if (contextClass.equals(PERSON_CONTEXTCLASS)) {
        String personEmail=element.getChildTextTrim(""String_Node_Str"",METSRights_NS);
        EPerson person=EPerson.findByEmail(context,personEmail);
        if (person == null)         person=EPerson.findByNetid(context,personEmail);
        if (person == null) {
          throw new CrosswalkInternalException(""String_Node_Str"" + ""String_Node_Str"" + Constants.typeText[dso.getType()] + ""String_Node_Str""+ ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ personEmail+ ""String_Node_Str""+ ""String_Node_Str"");
        }
        assignPermissions(context,dso,person,permsElement);
      }
    }
  }
}",0.9950263311878292
52210,"/** 
 * Emit XML describing a single Group.
 * @param context the DSpace Context
 * @parm relatedObjectthe DSpaceObject related to this group (if any)
 * @param group the Group to describe
 * @param write the description to this stream
 */
private void writeGroup(Context context,DSpaceObject relatedObject,Group group,XMLStreamWriter writer) throws XMLStreamException, PackageException {
  writer.writeStartElement(GROUP);
  writer.writeAttribute(ID,String.valueOf(group.getID()));
  writer.writeAttribute(NAME,PackageUtils.crosswalkDefaultGroupName(context,group.getName()));
  String groupType=getGroupType(relatedObject,group);
  if (groupType != null && !groupType.isEmpty())   writer.writeAttribute(TYPE,groupType);
  writer.writeStartElement(MEMBERS);
  for (  EPerson member : group.getMembers()) {
    writer.writeEmptyElement(MEMBER);
    writer.writeAttribute(ID,String.valueOf(member.getID()));
    writer.writeAttribute(NAME,member.getName());
  }
  writer.writeEndElement();
  writer.writeStartElement(MEMBER_GROUPS);
  for (  Group member : group.getMemberGroups()) {
    writer.writeEmptyElement(MEMBER_GROUP);
    writer.writeAttribute(ID,String.valueOf(member.getID()));
    writer.writeAttribute(NAME,PackageUtils.crosswalkDefaultGroupName(context,member.getName()));
  }
  writer.writeEndElement();
  writer.writeEndElement();
}","/** 
 * Emit XML describing a single Group.
 * @param context the DSpace Context
 * @parm relatedObjectthe DSpaceObject related to this group (if any)
 * @param group the Group to describe
 * @param write the description to this stream
 */
private void writeGroup(Context context,DSpaceObject relatedObject,Group group,XMLStreamWriter writer) throws XMLStreamException, PackageException {
  writer.writeStartElement(GROUP);
  writer.writeAttribute(ID,String.valueOf(group.getID()));
  writer.writeAttribute(NAME,PackageUtils.translateGroupNameForExport(context,group.getName()));
  String groupType=getGroupType(relatedObject,group);
  if (groupType != null && !groupType.isEmpty())   writer.writeAttribute(TYPE,groupType);
  writer.writeStartElement(MEMBERS);
  for (  EPerson member : group.getMembers()) {
    writer.writeEmptyElement(MEMBER);
    writer.writeAttribute(ID,String.valueOf(member.getID()));
    writer.writeAttribute(NAME,member.getName());
  }
  writer.writeEndElement();
  writer.writeStartElement(MEMBER_GROUPS);
  for (  Group member : group.getMemberGroups()) {
    writer.writeEmptyElement(MEMBER_GROUP);
    writer.writeAttribute(ID,String.valueOf(member.getID()));
    writer.writeAttribute(NAME,PackageUtils.translateGroupNameForExport(context,member.getName()));
  }
  writer.writeEndElement();
  writer.writeEndElement();
}",0.9703703703703704
52211,"/** 
 * Common code to ingest roles from a Document.
 * @param context DSpace Context
 * @param parent the Parent DSpaceObject
 * @param document the XML Document
 * @throws SQLException
 * @throws AuthorizeException
 * @throws PackageException
 */
static void ingestDocument(Context context,DSpaceObject parent,PackageParameters params,Document document) throws SQLException, AuthorizeException, PackageException {
  String myEmail=context.getCurrentUser().getEmail();
  String myNetid=context.getCurrentUser().getNetid();
  NodeList users=document.getElementsByTagName(RoleDisseminator.EPERSON);
  for (int i=0; i < users.getLength(); i++) {
    Element user=(Element)users.item(i);
    NodeList emails=user.getElementsByTagName(RoleDisseminator.EMAIL);
    NodeList netids=user.getElementsByTagName(RoleDisseminator.NETID);
    EPerson eperson;
    EPerson collider;
    String email=null;
    String netid=null;
    String identity;
    if (emails.getLength() > 0) {
      email=emails.item(0).getTextContent();
      if (email.equals(myEmail))       continue;
      identity=email;
      collider=EPerson.findByEmail(context,identity);
    }
 else     if (netids.getLength() > 0) {
      netid=netids.item(0).getTextContent();
      if (netid.equals(myNetid))       continue;
      identity=netid;
      collider=EPerson.findByNetid(context,identity);
    }
 else     throw new PackageException(""String_Node_Str"");
    if (null != collider)     if (params.replaceModeEnabled()) {
      eperson=collider;
    }
 else     if (params.keepExistingModeEnabled()) {
      log.warn(""String_Node_Str"",identity);
      continue;
    }
 else     throw new PackageException(""String_Node_Str"" + identity + ""String_Node_Str"");
 else {
      eperson=EPerson.create(context);
      log.info(""String_Node_Str"",identity);
    }
    eperson.setEmail(email);
    eperson.setNetid(netid);
    NodeList data;
    data=user.getElementsByTagName(RoleDisseminator.FIRST_NAME);
    if (data.getLength() > 0)     eperson.setFirstName(data.item(0).getTextContent());
 else     eperson.setFirstName(null);
    data=user.getElementsByTagName(RoleDisseminator.LAST_NAME);
    if (data.getLength() > 0)     eperson.setLastName(data.item(0).getTextContent());
 else     eperson.setLastName(null);
    data=user.getElementsByTagName(RoleDisseminator.LANGUAGE);
    if (data.getLength() > 0)     eperson.setLanguage(data.item(0).getTextContent());
 else     eperson.setLanguage(null);
    data=user.getElementsByTagName(RoleDisseminator.CAN_LOGIN);
    eperson.setCanLogIn(data.getLength() > 0);
    data=user.getElementsByTagName(RoleDisseminator.REQUIRE_CERTIFICATE);
    eperson.setRequireCertificate(data.getLength() > 0);
    data=user.getElementsByTagName(RoleDisseminator.SELF_REGISTERED);
    eperson.setSelfRegistered(data.getLength() > 0);
    data=user.getElementsByTagName(RoleDisseminator.PASSWORD_HASH);
    if (data.getLength() > 0)     eperson.setPasswordHash(data.item(0).getTextContent());
 else     eperson.setPasswordHash(null);
    eperson.update();
  }
  NodeList groups=document.getElementsByTagName(RoleDisseminator.GROUP);
  for (int groupx=0; groupx < groups.getLength(); groupx++) {
    Element group=(Element)groups.item(groupx);
    String name=group.getAttribute(RoleDisseminator.NAME);
    name=PackageUtils.crosswalkDefaultGroupName(context,name);
    Group groupObj=null;
    Group collider=Group.findByName(context,name);
    if (null != collider) {
      if (params.replaceModeEnabled()) {
        for (        Group member : collider.getMemberGroups())         collider.removeMember(member);
        for (        EPerson member : collider.getMembers())         collider.removeMember(member);
        log.info(""String_Node_Str"",name);
        groupObj=collider;
      }
 else       if (params.keepExistingModeEnabled()) {
        log.warn(""String_Node_Str"",name);
        continue;
      }
 else       throw new PackageException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
 else {
      String type=group.getAttribute(RoleDisseminator.TYPE);
      if (type != null && !type.isEmpty() && parent != null) {
        if (parent.getType() == Constants.COLLECTION) {
          Collection collection=(Collection)parent;
          if (type.equals(RoleDisseminator.GROUP_TYPE_ADMIN))           groupObj=collection.createAdministrators();
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_SUBMIT))           groupObj=collection.createSubmitters();
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_WORKFLOW_STEP_1))           groupObj=collection.createWorkflowGroup(1);
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_WORKFLOW_STEP_2))           groupObj=collection.createWorkflowGroup(2);
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_WORKFLOW_STEP_3))           groupObj=collection.createWorkflowGroup(3);
        }
 else         if (parent.getType() == Constants.COMMUNITY) {
          Community community=(Community)parent;
          if (type.equals(RoleDisseminator.GROUP_TYPE_ADMIN))           groupObj=community.createAdministrators();
        }
      }
      if (groupObj == null) {
        groupObj=Group.create(context);
        groupObj.setName(name);
      }
      log.info(""String_Node_Str"",groupObj.getName());
    }
    NodeList members=group.getElementsByTagName(RoleDisseminator.MEMBER);
    for (int memberx=0; memberx < members.getLength(); memberx++) {
      Element member=(Element)members.item(memberx);
      String memberName=member.getAttribute(RoleDisseminator.NAME);
      EPerson memberEPerson=EPerson.findByEmail(context,memberName);
      groupObj.addMember(memberEPerson);
    }
    groupObj.update();
  }
  for (int groupx=0; groupx < groups.getLength(); groupx++) {
    Element group=(Element)groups.item(groupx);
    String name=group.getAttribute(RoleDisseminator.NAME);
    name=PackageUtils.crosswalkDefaultGroupName(context,name);
    Group groupObj=Group.findByName(context,name);
    NodeList members=group.getElementsByTagName(RoleDisseminator.MEMBER_GROUP);
    for (int memberx=0; memberx < members.getLength(); memberx++) {
      Element member=(Element)members.item(memberx);
      String memberName=member.getAttribute(RoleDisseminator.NAME);
      memberName=PackageUtils.crosswalkDefaultGroupName(context,memberName);
      Group memberGroup=Group.findByName(context,memberName);
      groupObj.addMember(memberGroup);
    }
    groupObj.update();
  }
}","/** 
 * Common code to ingest roles from a Document.
 * @param context DSpace Context
 * @param parent the Parent DSpaceObject
 * @param document the XML Document
 * @throws SQLException
 * @throws AuthorizeException
 * @throws PackageException
 */
static void ingestDocument(Context context,DSpaceObject parent,PackageParameters params,Document document) throws SQLException, AuthorizeException, PackageException {
  String myEmail=context.getCurrentUser().getEmail();
  String myNetid=context.getCurrentUser().getNetid();
  NodeList users=document.getElementsByTagName(RoleDisseminator.EPERSON);
  for (int i=0; i < users.getLength(); i++) {
    Element user=(Element)users.item(i);
    NodeList emails=user.getElementsByTagName(RoleDisseminator.EMAIL);
    NodeList netids=user.getElementsByTagName(RoleDisseminator.NETID);
    EPerson eperson;
    EPerson collider;
    String email=null;
    String netid=null;
    String identity;
    if (emails.getLength() > 0) {
      email=emails.item(0).getTextContent();
      if (email.equals(myEmail))       continue;
      identity=email;
      collider=EPerson.findByEmail(context,identity);
    }
 else     if (netids.getLength() > 0) {
      netid=netids.item(0).getTextContent();
      if (netid.equals(myNetid))       continue;
      identity=netid;
      collider=EPerson.findByNetid(context,identity);
    }
 else     throw new PackageException(""String_Node_Str"");
    if (null != collider)     if (params.replaceModeEnabled()) {
      eperson=collider;
    }
 else     if (params.keepExistingModeEnabled()) {
      log.warn(""String_Node_Str"",identity);
      continue;
    }
 else     throw new PackageException(""String_Node_Str"" + identity + ""String_Node_Str"");
 else {
      eperson=EPerson.create(context);
      log.info(""String_Node_Str"",identity);
    }
    eperson.setEmail(email);
    eperson.setNetid(netid);
    NodeList data;
    data=user.getElementsByTagName(RoleDisseminator.FIRST_NAME);
    if (data.getLength() > 0)     eperson.setFirstName(data.item(0).getTextContent());
 else     eperson.setFirstName(null);
    data=user.getElementsByTagName(RoleDisseminator.LAST_NAME);
    if (data.getLength() > 0)     eperson.setLastName(data.item(0).getTextContent());
 else     eperson.setLastName(null);
    data=user.getElementsByTagName(RoleDisseminator.LANGUAGE);
    if (data.getLength() > 0)     eperson.setLanguage(data.item(0).getTextContent());
 else     eperson.setLanguage(null);
    data=user.getElementsByTagName(RoleDisseminator.CAN_LOGIN);
    eperson.setCanLogIn(data.getLength() > 0);
    data=user.getElementsByTagName(RoleDisseminator.REQUIRE_CERTIFICATE);
    eperson.setRequireCertificate(data.getLength() > 0);
    data=user.getElementsByTagName(RoleDisseminator.SELF_REGISTERED);
    eperson.setSelfRegistered(data.getLength() > 0);
    data=user.getElementsByTagName(RoleDisseminator.PASSWORD_HASH);
    if (data.getLength() > 0)     eperson.setPasswordHash(data.item(0).getTextContent());
 else     eperson.setPasswordHash(null);
    eperson.update();
  }
  NodeList groups=document.getElementsByTagName(RoleDisseminator.GROUP);
  for (int groupx=0; groupx < groups.getLength(); groupx++) {
    Element group=(Element)groups.item(groupx);
    String name=group.getAttribute(RoleDisseminator.NAME);
    try {
      name=PackageUtils.translateGroupNameForImport(context,name);
    }
 catch (    PackageException pe) {
      log.warn(""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
      continue;
    }
    Group groupObj=null;
    Group collider=Group.findByName(context,name);
    if (null != collider) {
      if (params.replaceModeEnabled()) {
        for (        Group member : collider.getMemberGroups())         collider.removeMember(member);
        for (        EPerson member : collider.getMembers()) {
          if (!(collider.equals(Group.find(context,1)) && member.equals(context.getCurrentUser())))           collider.removeMember(member);
        }
        log.info(""String_Node_Str"",name);
        groupObj=collider;
      }
 else       if (params.keepExistingModeEnabled()) {
        log.warn(""String_Node_Str"",name);
        continue;
      }
 else       throw new PackageException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
 else {
      String type=group.getAttribute(RoleDisseminator.TYPE);
      if (type != null && !type.isEmpty() && parent != null) {
        if (parent.getType() == Constants.COLLECTION) {
          Collection collection=(Collection)parent;
          if (type.equals(RoleDisseminator.GROUP_TYPE_ADMIN))           groupObj=collection.createAdministrators();
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_SUBMIT))           groupObj=collection.createSubmitters();
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_WORKFLOW_STEP_1))           groupObj=collection.createWorkflowGroup(1);
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_WORKFLOW_STEP_2))           groupObj=collection.createWorkflowGroup(2);
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_WORKFLOW_STEP_3))           groupObj=collection.createWorkflowGroup(3);
        }
 else         if (parent.getType() == Constants.COMMUNITY) {
          Community community=(Community)parent;
          if (type.equals(RoleDisseminator.GROUP_TYPE_ADMIN))           groupObj=community.createAdministrators();
        }
      }
      if (groupObj == null) {
        groupObj=Group.create(context);
        groupObj.setName(name);
      }
      log.info(""String_Node_Str"",groupObj.getName());
    }
    NodeList members=group.getElementsByTagName(RoleDisseminator.MEMBER);
    for (int memberx=0; memberx < members.getLength(); memberx++) {
      Element member=(Element)members.item(memberx);
      String memberName=member.getAttribute(RoleDisseminator.NAME);
      EPerson memberEPerson=EPerson.findByEmail(context,memberName);
      groupObj.addMember(memberEPerson);
    }
    groupObj.update();
  }
  for (int groupx=0; groupx < groups.getLength(); groupx++) {
    Element group=(Element)groups.item(groupx);
    String name=group.getAttribute(RoleDisseminator.NAME);
    try {
      name=PackageUtils.translateGroupNameForImport(context,name);
    }
 catch (    PackageException pe) {
      continue;
    }
    Group groupObj=Group.findByName(context,name);
    NodeList members=group.getElementsByTagName(RoleDisseminator.MEMBER_GROUP);
    for (int memberx=0; memberx < members.getLength(); memberx++) {
      Element member=(Element)members.item(memberx);
      String memberName=member.getAttribute(RoleDisseminator.NAME);
      memberName=PackageUtils.translateGroupNameForImport(context,memberName);
      Group memberGroup=Group.findByName(context,memberName);
      groupObj.addMember(memberGroup);
    }
    groupObj.update();
  }
}",0.959637872500943
52212,"/** 
 * Generate a url to the simple search url.
 */
protected String generateURL(Map<String,String> parameters) throws UIException {
  String query=getQuery();
  if (!""String_Node_Str"".equals(query))   parameters.put(""String_Node_Str"",URLEncode(query));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterPage()));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterRpp()));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterSortBy()));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",getParameterOrder());
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterEtAl()));
  return super.generateURL(""String_Node_Str"",parameters);
}","/** 
 * Generate a url to the simple search url.
 */
protected String generateURL(Map<String,String> parameters) throws UIException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String scope=request.getParameter(""String_Node_Str"");
  if (scope != null)   parameters.put(""String_Node_Str"",scope);
  String query=getQuery();
  if (!""String_Node_Str"".equals(query))   parameters.put(""String_Node_Str"",URLEncode(query));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterPage()));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterRpp()));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterSortBy()));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",getParameterOrder());
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterEtAl()));
  return super.generateURL(""String_Node_Str"",parameters);
}",0.9090909090909092
52213,"/** 
 * Create a new DSpace object out of a METS content package. All contents are dictated by the METS manifest. Package is a ZIP archive (or optionally bare manifest XML document). In a Zip, all files relative to top level and the manifest (as per spec) in mets.xml.
 * @param context  DSpace context.
 * @param parent parent under which to create new object(may be null -- in which case ingester must determine parent from package or throw an error).
 * @param pkgFile  The package file to ingest
 * @param params Properties-style list of options (interpreted by each packager).
 * @param license  may be null, which takes default license.
 * @return DSpaceObject created by ingest.
 * @throws PackageValidationException if package is unacceptable or there isa fatal error turning it into a DSpaceObject.
 * @throws CrosswalkException
 * @throws AuthorizeException
 * @throws SQLException
 * @throws IOException
 */
public DSpaceObject ingest(Context context,DSpaceObject parent,File pkgFile,PackageParameters params,String license) throws PackageValidationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  METSManifest manifest=null;
  DSpaceObject dso=null;
  try {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + pkgFile.getName()));
    manifest=parsePackage(context,pkgFile,params);
    if (manifest == null)     throw new PackageValidationException(""String_Node_Str"" + METSManifest.MANIFEST_FILE + ""String_Node_Str"");
    checkManifest(manifest);
    if (!params.restoreModeEnabled() && !params.containsKey(""String_Node_Str"")) {
      params.addProperty(""String_Node_Str"",""String_Node_Str"");
    }
    if (parent != null && !params.containsKey(""String_Node_Str"")) {
      params.addProperty(""String_Node_Str"",""String_Node_Str"");
    }
    dso=ingestObject(context,parent,manifest,pkgFile,params,license);
    String action=""String_Node_Str"";
    if (params.restoreModeEnabled())     action=""String_Node_Str"";
    log.info(LogManager.getHeader(context,action,""String_Node_Str"" + Constants.typeText[dso.getType()] + ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ String.valueOf(dso.getID())));
    if (params.recursiveModeEnabled()) {
      String[] childFilePaths=manifest.getChildMetsFilePaths();
      for (int i=0; i < childFilePaths.length; i++)       addPackageReference(dso,childFilePaths[i]);
    }
    return dso;
  }
 catch (  SQLException se) {
    dso=null;
    throw se;
  }
}","/** 
 * Create a new DSpace object out of a METS content package. All contents are dictated by the METS manifest. Package is a ZIP archive (or optionally bare manifest XML document). In a Zip, all files relative to top level and the manifest (as per spec) in mets.xml.
 * @param context  DSpace context.
 * @param parent parent under which to create new object(may be null -- in which case ingester must determine parent from package or throw an error).
 * @param pkgFile  The package file to ingest
 * @param params Properties-style list of options (interpreted by each packager).
 * @param license  may be null, which takes default license.
 * @return DSpaceObject created by ingest.
 * @throws PackageValidationException if package is unacceptable or there isa fatal error turning it into a DSpaceObject.
 * @throws CrosswalkException
 * @throws AuthorizeException
 * @throws SQLException
 * @throws IOException
 */
public DSpaceObject ingest(Context context,DSpaceObject parent,File pkgFile,PackageParameters params,String license) throws PackageValidationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  METSManifest manifest=null;
  DSpaceObject dso=null;
  try {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + pkgFile.getName()));
    manifest=parsePackage(context,pkgFile,params);
    if (manifest == null)     throw new PackageValidationException(""String_Node_Str"" + METSManifest.MANIFEST_FILE + ""String_Node_Str"");
    checkManifest(manifest);
    if (!params.restoreModeEnabled() && !params.containsKey(""String_Node_Str"")) {
      params.addProperty(""String_Node_Str"",""String_Node_Str"");
    }
    if (parent != null && !params.containsKey(""String_Node_Str"")) {
      params.addProperty(""String_Node_Str"",""String_Node_Str"");
    }
    int type=getObjectType(manifest);
    if (type == Constants.SITE) {
      dso=Site.find(context,Site.SITE_ID);
    }
 else {
      dso=ingestObject(context,parent,manifest,pkgFile,params,license);
      String action=""String_Node_Str"";
      if (params.restoreModeEnabled())       action=""String_Node_Str"";
      log.info(LogManager.getHeader(context,action,""String_Node_Str"" + Constants.typeText[dso.getType()] + ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ String.valueOf(dso.getID())));
    }
    if (params.recursiveModeEnabled()) {
      String[] childFilePaths=manifest.getChildMetsFilePaths();
      for (int i=0; i < childFilePaths.length; i++)       addPackageReference(dso,childFilePaths[i]);
    }
    return dso;
  }
 catch (  SQLException se) {
    dso=null;
    throw se;
  }
}",0.8363851151801536
52214,"/** 
 * Find the eperson by their email address
 * @return EPerson
 */
public static EPerson findByEmail(Context context,String email) throws SQLException, AuthorizeException {
  TableRow row=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",email);
  if (row == null) {
    return null;
  }
 else {
    EPerson fromCache=(EPerson)context.fromCache(EPerson.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      return fromCache;
    }
 else {
      return new EPerson(context,row);
    }
  }
}","/** 
 * Find the eperson by their email address
 * @return EPerson
 */
public static EPerson findByEmail(Context context,String email) throws SQLException, AuthorizeException {
  if (email == null) {
    return null;
  }
  TableRow row=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",email.toLowerCase());
  if (row == null) {
    return null;
  }
 else {
    EPerson fromCache=(EPerson)context.fromCache(EPerson.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      return fromCache;
    }
 else {
      return new EPerson(context,row);
    }
  }
}",0.9491228070175438
52215,"/** 
 * Simple test program Usage:  java org.dspace.content.DCdate [DCDate | -l yyyy [mm [dd ..]]] ] (-l form tests local time parsing) Default is to use current time.
 */
public static void main(String args[]) throws Exception {
  DCDate d;
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      int val[]={-1,-1,-1,-1,-1,-1};
      for (int i=1; i < 7 && i < args.length; ++i)       val[i - 1]=Integer.parseInt(args[i]);
      d=new DCDate();
      d.setDateLocal(val[0],val[1],val[2],val[3],val[4],val[5]);
    }
 else     d=new DCDate(args[0]);
  }
 else   d=DCDate.getCurrent();
  System.out.println(""String_Node_Str"" + d.toString() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + d.toDate().toString() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + d.granularity);
  System.out.println(""String_Node_Str"" + d.getYear());
  System.out.println(""String_Node_Str"" + d.getMonth());
  System.out.println(""String_Node_Str"" + d.getDay());
  System.out.println(""String_Node_Str"" + d.getHour());
  System.out.println(""String_Node_Str"" + d.getMinute());
  System.out.println(""String_Node_Str"" + d.getSecond());
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + d.getYearGMT());
  System.out.println(""String_Node_Str"" + d.getMonthGMT());
  System.out.println(""String_Node_Str"" + d.getDayGMT());
  System.out.println(""String_Node_Str"" + d.getHourGMT());
  System.out.println(""String_Node_Str"" + d.getMinuteGMT());
  System.out.println(""String_Node_Str"" + d.getSecondGMT());
  DCDate hw=new DCDate();
  hw.setDateLocal(d.getYear(),d.getMonth(),d.getDay(),d.getHour(),d.getMinute(),d.getSecond());
  System.out.println(""String_Node_Str"" + hw.toString() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + DCDate.getMonthName(d.getMonth(),Locale.getDefault()) + ""String_Node_Str"");
}","/** 
 * Simple test program Usage:  java org.dspace.content.DCdate [DCDate | -l yyyy [mm [dd ..]]] ] where ""DCDate"" is the kind of value that would be in metadata, e.g. ""2006"", ""2006-02-03"", etc. (-l form tests local time parsing) Default is to use current time.
 */
public static void main(String args[]) throws Exception {
  DCDate d;
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      int val[]={-1,-1,-1,-1,-1,-1};
      for (int i=1; i < 7 && i < args.length; ++i)       val[i - 1]=Integer.parseInt(args[i]);
      d=new DCDate();
      d.setDateLocal(val[0],val[1],val[2],val[3],val[4],val[5]);
    }
 else     d=new DCDate(args[0]);
  }
 else   d=DCDate.getCurrent();
  System.out.println(""String_Node_Str"" + d.toString() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + d.toDate().toString() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + d.granularity);
  System.out.println(""String_Node_Str"" + d.getYear());
  System.out.println(""String_Node_Str"" + d.getMonth());
  System.out.println(""String_Node_Str"" + d.getDay());
  System.out.println(""String_Node_Str"" + d.getHour());
  System.out.println(""String_Node_Str"" + d.getMinute());
  System.out.println(""String_Node_Str"" + d.getSecond());
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + d.getYearGMT());
  System.out.println(""String_Node_Str"" + d.getMonthGMT());
  System.out.println(""String_Node_Str"" + d.getDayGMT());
  System.out.println(""String_Node_Str"" + d.getHourGMT());
  System.out.println(""String_Node_Str"" + d.getMinuteGMT());
  System.out.println(""String_Node_Str"" + d.getSecondGMT());
  DCDate hw=new DCDate();
  hw.setDateLocal(d.getYear(),d.getMonth(),d.getDay(),d.getHour(),d.getMinute(),d.getSecond());
  System.out.println(""String_Node_Str"" + hw.toString() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + DCDate.getMonthName(d.getMonth(),Locale.getDefault()) + ""String_Node_Str"");
}",0.9757095372027614
52216,"private synchronized String toStringInternal(){
  if (granularity == DateGran.YEAR)   return yearIso.format(calendar.getTime());
 else   if (granularity == DateGran.MONTH)   return yearMonthIso.format(calendar.getTime());
 else   if (granularity == DateGran.DAY)   return dateIso.format(calendar.getTime());
 else   return fullIso.format(calendar.getTime());
}","private synchronized String toStringInternal(){
  if (granularity == DateGran.YEAR)   return String.format(""String_Node_Str"",getYear());
 else   if (granularity == DateGran.MONTH)   return String.format(""String_Node_Str"",getYear(),getMonth());
 else   if (granularity == DateGran.DAY)   return String.format(""String_Node_Str"",getYear(),getMonth(),getDay());
 else   return fullIso.format(calendar.getTime());
}",0.7194805194805195
52217,"/** 
 * Construct a date from a Dublin Core value
 * @param fromDC the date string, in ISO 8601 (no timezone, always use UTC/GMT)
 */
public DCDate(String fromDC){
  super();
  if ((fromDC == null) || fromDC.equals(""String_Node_Str"")) {
    return;
  }
  granularity=DateGran.TIME;
  Date date=tryParse(fullIso,fromDC);
  if (date == null)   date=tryParse(fullIso2,fromDC);
  if (date == null)   date=tryParse(fullIso3,fromDC);
  if (date == null) {
    date=tryParse(dateIso,fromDC);
    granularity=DateGran.DAY;
  }
  if (date == null) {
    date=tryParse(yearMonthIso,fromDC);
    granularity=DateGran.MONTH;
  }
  if (date == null) {
    date=tryParse(yearIso,fromDC);
    granularity=DateGran.YEAR;
  }
  if (date == null)   log.warn(""String_Node_Str"" + fromDC + ""String_Node_Str"");
 else   setTime(date);
}","/** 
 * Construct a date from a Dublin Core value
 * @param fromDC the date string, in ISO 8601 (no timezone, always use UTC/GMT)
 */
public DCDate(String fromDC){
  super();
  if ((fromDC == null) || fromDC.equals(""String_Node_Str"")) {
    return;
  }
  granularity=DateGran.TIME;
  Date date=tryParse(fullIso,fromDC);
  if (date == null)   date=tryParse(fullIso2,fromDC);
  if (date == null)   date=tryParse(fullIso3,fromDC);
  if (date == null) {
    date=tryParse(dateIso,fromDC);
    if (date != null) {
      long ldate=date.getTime();
      date=new Date(ldate - localZone.getOffset(ldate));
      granularity=DateGran.DAY;
    }
  }
  if (date == null) {
    date=tryParse(yearMonthIso,fromDC);
    if (date != null) {
      long ldate=date.getTime();
      date=new Date(ldate - localZone.getOffset(ldate));
      granularity=DateGran.MONTH;
    }
  }
  if (date == null) {
    date=tryParse(yearIso,fromDC);
    if (date != null) {
      long ldate=date.getTime();
      date=new Date(ldate - localZone.getOffset(ldate));
      granularity=DateGran.YEAR;
    }
  }
  if (date == null)   log.warn(""String_Node_Str"" + fromDC + ""String_Node_Str"");
 else   setTime(date);
}",0.8162650602409639
52218,"/** 
 * Render a date field to the DRI document. The date field consists of three component fields, a 4 character text field for the year, a select box for the month, and a 2 character text field for the day.
 * @param form The form list to add the field too
 * @param fieldName The field's name.
 * @param dcInput The field's input deffinition
 * @param dcValues The field's pre-existing values.
 */
private void renderDateField(List form,String fieldName,DCInput dcInput,DCValue[] dcValues,boolean readonly) throws WingException {
  Composite fullDate=form.addItem().addComposite(fieldName,""String_Node_Str"");
  Text year=fullDate.addText(fieldName + ""String_Node_Str"");
  Select month=fullDate.addSelect(fieldName + ""String_Node_Str"");
  Text day=fullDate.addText(fieldName + ""String_Node_Str"");
  fullDate.setLabel(dcInput.getLabel());
  fullDate.setHelp(cleanHints(dcInput.getHints()));
  if (dcInput.isRequired())   fullDate.setRequired();
  if (isFieldInError(fieldName))   fullDate.addError(T_required_field);
  if (dcInput.isRepeatable() && !readonly)   fullDate.enableAddOperation();
  if ((dcInput.isRepeatable() || dcValues.length > 1) && !readonly)   fullDate.enableDeleteOperation();
  if (readonly) {
    year.setDisabled();
    month.setDisabled();
    day.setDisabled();
  }
  year.setLabel(T_year);
  year.setSize(4,4);
  month.setLabel(T_month);
  month.addOption(0,""String_Node_Str"");
  for (int i=1; i < 13; i++) {
    month.addOption(i,org.dspace.content.DCDate.getMonthName(i,Locale.getDefault()));
  }
  day.setLabel(T_day);
  day.setSize(2,2);
  if (dcInput.isRepeatable() || dcValues.length > 1) {
    for (    DCValue dcValue : dcValues) {
      DCDate dcDate=new DCDate(dcValue.value);
      year.addInstance().setValue(String.valueOf(dcDate.getYearGMT()));
      month.addInstance().setOptionSelected(dcDate.getMonthGMT());
      day.addInstance().setValue(String.valueOf(dcDate.getDayGMT()));
      fullDate.addInstance().setValue(dcDate.toString());
    }
  }
 else   if (dcValues.length == 1) {
    DCDate dcDate=new DCDate(dcValues[0].value);
    year.setValue(String.valueOf(dcDate.getYearGMT()));
    month.setOptionSelected(dcDate.getMonthGMT());
    if (dcDate.getDayGMT() == -1)     day.setValue(""String_Node_Str"");
 else     day.setValue(String.valueOf(dcDate.getDayGMT()));
  }
}","/** 
 * Render a date field to the DRI document. The date field consists of three component fields, a 4 character text field for the year, a select box for the month, and a 2 character text field for the day.
 * @param form The form list to add the field too
 * @param fieldName The field's name.
 * @param dcInput The field's input deffinition
 * @param dcValues The field's pre-existing values.
 */
private void renderDateField(List form,String fieldName,DCInput dcInput,DCValue[] dcValues,boolean readonly) throws WingException {
  Composite fullDate=form.addItem().addComposite(fieldName,""String_Node_Str"");
  Text year=fullDate.addText(fieldName + ""String_Node_Str"");
  Select month=fullDate.addSelect(fieldName + ""String_Node_Str"");
  Text day=fullDate.addText(fieldName + ""String_Node_Str"");
  fullDate.setLabel(dcInput.getLabel());
  fullDate.setHelp(cleanHints(dcInput.getHints()));
  if (dcInput.isRequired())   fullDate.setRequired();
  if (isFieldInError(fieldName))   fullDate.addError(T_required_field);
  if (dcInput.isRepeatable() && !readonly)   fullDate.enableAddOperation();
  if ((dcInput.isRepeatable() || dcValues.length > 1) && !readonly)   fullDate.enableDeleteOperation();
  if (readonly) {
    year.setDisabled();
    month.setDisabled();
    day.setDisabled();
  }
  year.setLabel(T_year);
  year.setSize(4,4);
  month.setLabel(T_month);
  month.addOption(0,""String_Node_Str"");
  for (int i=1; i < 13; i++) {
    month.addOption(i,org.dspace.content.DCDate.getMonthName(i,Locale.getDefault()));
  }
  day.setLabel(T_day);
  day.setSize(2,2);
  if (dcInput.isRepeatable() || dcValues.length > 1) {
    for (    DCValue dcValue : dcValues) {
      DCDate dcDate=new DCDate(dcValue.value);
      year.addInstance().setValue(String.valueOf(dcDate.getYear()));
      month.addInstance().setOptionSelected(dcDate.getMonth());
      day.addInstance().setValue(String.valueOf(dcDate.getDay()));
      fullDate.addInstance().setValue(dcDate.toString());
    }
  }
 else   if (dcValues.length == 1) {
    DCDate dcDate=new DCDate(dcValues[0].value);
    year.setValue(String.valueOf(dcDate.getYear()));
    month.setOptionSelected(dcDate.getMonth());
    if (dcDate.getDay() == -1)     day.setValue(""String_Node_Str"");
 else     day.setValue(String.valueOf(dcDate.getDay()));
  }
}",0.915312973792506
52219,"/** 
 * Execute the DSpace script launcher
 * @param args Any parameters required to be passed to the scripts it executes
 * @throws Exception
 */
public static void main(String[] args){
  if (args.length < 1) {
    System.err.println(""String_Node_Str"");
    display();
    System.exit(1);
  }
  try {
    kernelImpl=DSpaceKernelInit.getKernel(null);
    if (!kernelImpl.isRunning()) {
      kernelImpl.start(ConfigurationManager.getProperty(""String_Node_Str""));
    }
  }
 catch (  Exception e) {
    try {
      kernelImpl.destroy();
    }
 catch (    Exception e1) {
    }
    String message=""String_Node_Str"" + e.getMessage();
    System.err.println(message + ""String_Node_Str"" + e);
    throw new RuntimeException(message,e);
  }
  Document doc=getConfig();
  String request=args[0];
  Element root=doc.getRootElement();
  List<Element> commands=root.getChildren(""String_Node_Str"");
  for (  Element command : commands) {
    if (request.equalsIgnoreCase(command.getChild(""String_Node_Str"").getValue())) {
      List<Element> steps=command.getChildren(""String_Node_Str"");
      for (      Element step : steps) {
        Class target=null;
        String className=step.getChild(""String_Node_Str"").getValue();
        try {
          target=Class.forName(className,true,Thread.currentThread().getContextClassLoader());
        }
 catch (        ClassNotFoundException e) {
          System.err.println(""String_Node_Str"" + className);
          System.exit(1);
        }
        String[] useargs=args.clone();
        Class[] argTypes={useargs.getClass()};
        boolean passargs=true;
        if ((step.getAttribute(""String_Node_Str"") != null) && (""String_Node_Str"".equalsIgnoreCase(step.getAttribute(""String_Node_Str"").getValue()))) {
          passargs=false;
        }
        if ((args.length == 1) || (!passargs)) {
          useargs=new String[0];
        }
 else {
          String[] argsnew=new String[useargs.length - 1];
          for (int i=1; i < useargs.length; i++) {
            argsnew[i - 1]=useargs[i];
          }
          useargs=argsnew;
        }
        List<Element> bits=step.getChildren(""String_Node_Str"");
        if (step.getChild(""String_Node_Str"") != null) {
          String[] argsnew=new String[useargs.length + bits.size()];
          int i=0;
          for (          Element arg : bits) {
            argsnew[i++]=arg.getValue();
          }
          for (; i < bits.size() + useargs.length; i++) {
            argsnew[i]=useargs[i - bits.size()];
          }
          useargs=argsnew;
        }
        RequestService requestService=kernelImpl.getServiceManager().getServiceByName(RequestService.class.getName(),RequestService.class);
        if (requestService == null) {
          throw new IllegalStateException(""String_Node_Str"");
        }
        requestService.startRequest();
        try {
          Object[] arguments={useargs};
          Method main=target.getMethod(""String_Node_Str"",argTypes);
          Object output=main.invoke(null,arguments);
          requestService.endRequest(null);
        }
 catch (        Exception e) {
          requestService.endRequest(e);
          if (kernelImpl != null) {
            kernelImpl.destroy();
            kernelImpl=null;
          }
          System.err.println(""String_Node_Str"" + e.getMessage());
          System.exit(1);
        }
      }
      if (kernelImpl != null) {
        kernelImpl.destroy();
        kernelImpl=null;
      }
      System.exit(0);
    }
  }
  if (kernelImpl != null) {
    kernelImpl.destroy();
    kernelImpl=null;
  }
  System.err.println(""String_Node_Str"" + args[0]);
  display();
  System.exit(1);
}","/** 
 * Execute the DSpace script launcher
 * @param args Any parameters required to be passed to the scripts it executes
 * @throws Exception
 */
public static void main(String[] args){
  if (args.length < 1) {
    System.err.println(""String_Node_Str"");
    display();
    System.exit(1);
  }
  try {
    kernelImpl=DSpaceKernelInit.getKernel(null);
    if (!kernelImpl.isRunning()) {
      kernelImpl.start(ConfigurationManager.getProperty(""String_Node_Str""));
    }
  }
 catch (  Exception e) {
    try {
      kernelImpl.destroy();
    }
 catch (    Exception e1) {
    }
    String message=""String_Node_Str"" + e.getMessage();
    System.err.println(message + ""String_Node_Str"" + e);
    throw new RuntimeException(message,e);
  }
  Document doc=getConfig();
  String request=args[0];
  Element root=doc.getRootElement();
  List<Element> commands=root.getChildren(""String_Node_Str"");
  for (  Element command : commands) {
    if (request.equalsIgnoreCase(command.getChild(""String_Node_Str"").getValue())) {
      List<Element> steps=command.getChildren(""String_Node_Str"");
      for (      Element step : steps) {
        Class target=null;
        String className=step.getChild(""String_Node_Str"").getValue();
        try {
          target=Class.forName(className,true,Thread.currentThread().getContextClassLoader());
        }
 catch (        ClassNotFoundException e) {
          System.err.println(""String_Node_Str"" + className);
          System.exit(1);
        }
        String[] useargs=args.clone();
        Class[] argTypes={useargs.getClass()};
        boolean passargs=true;
        if ((step.getAttribute(""String_Node_Str"") != null) && (""String_Node_Str"".equalsIgnoreCase(step.getAttribute(""String_Node_Str"").getValue()))) {
          passargs=false;
        }
        if ((args.length == 1) || (!passargs)) {
          useargs=new String[0];
        }
 else {
          String[] argsnew=new String[useargs.length - 1];
          for (int i=1; i < useargs.length; i++) {
            argsnew[i - 1]=useargs[i];
          }
          useargs=argsnew;
        }
        List<Element> bits=step.getChildren(""String_Node_Str"");
        if (step.getChild(""String_Node_Str"") != null) {
          String[] argsnew=new String[useargs.length + bits.size()];
          int i=0;
          for (          Element arg : bits) {
            argsnew[i++]=arg.getValue();
          }
          for (; i < bits.size() + useargs.length; i++) {
            argsnew[i]=useargs[i - bits.size()];
          }
          useargs=argsnew;
        }
        RequestService requestService=kernelImpl.getServiceManager().getServiceByName(RequestService.class.getName(),RequestService.class);
        if (requestService == null) {
          throw new IllegalStateException(""String_Node_Str"");
        }
        requestService.startRequest();
        try {
          Object[] arguments={useargs};
          Method main=target.getMethod(""String_Node_Str"",argTypes);
          Object output=main.invoke(null,arguments);
          requestService.endRequest(null);
        }
 catch (        Exception e) {
          requestService.endRequest(e);
          if (kernelImpl != null) {
            kernelImpl.destroy();
            kernelImpl=null;
          }
          Throwable cause=e.getCause();
          System.err.println(""String_Node_Str"" + cause.getMessage());
          cause.printStackTrace();
          System.exit(1);
        }
      }
      if (kernelImpl != null) {
        kernelImpl.destroy();
        kernelImpl=null;
      }
      System.exit(0);
    }
  }
  if (kernelImpl != null) {
    kernelImpl.destroy();
    kernelImpl=null;
  }
  System.err.println(""String_Node_Str"" + args[0]);
  display();
  System.exit(1);
}",0.9892619274160664
52220,"/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        Set<Integer> distIDSet=new HashSet<Integer>();
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null && values.length > 0) {
              int minConfidence=MetadataAuthorityManager.getManager().getMinConfidence(values[0].schema,values[0].element,values[0].qualifier);
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else                 if (bis[i].isAuthorityIndex()) {
                  if (values[x].authority != null && values[x].confidence >= minConfidence) {
                    boolean isValueVariants=false;
                    List<String> variants=ChoiceAuthorityManager.getManager().getVariants(values[x].schema,values[x].element,values[x].qualifier,values[x].authority,values[x].language);
                    if (variants != null) {
                      for (                      String var : variants) {
                        String nVal=OrderFormat.makeSortString(var,values[x].language,bis[i].getDataType());
                        distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),var,values[x].authority,nVal));
                        if (var.equals(values[x].value)) {
                          isValueVariants=true;
                        }
                      }
                    }
                    if (!isValueVariants) {
                      String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                      distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,values[x].authority,nVal));
                    }
                  }
 else {
                    log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ ""String_Node_Str""+ values[x].qualifier+ ""String_Node_Str""+ values[x].value+ ""String_Node_Str""+ values[x].authority+ ""String_Node_Str""+ values[x].confidence+ ""String_Node_Str"");
                  }
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,null,nVal));
                }
              }
            }
          }
        }
        if (distIDSet.isEmpty()) {
          removeIndex(item.getID(),bis[i].getMapTableName());
        }
 else {
          int[] distIDarr=new int[distIDSet.size()];
          int didx=0;
          for (          Integer distID : distIDSet) {
            distIDarr[didx++]=distID;
          }
          dao.updateDistinctMappings(bis[i].getMapTableName(),item.getID(),distIDarr);
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        Set<Integer> distIDSet=new HashSet<Integer>();
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null && values.length > 0) {
              int minConfidence=MetadataAuthorityManager.getManager().getMinConfidence(values[0].schema,values[0].element,values[0].qualifier);
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  if (bis[i].isAuthorityIndex() && (values[x].authority == null || values[x].confidence < minConfidence)) {
                    log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ ""String_Node_Str""+ values[x].qualifier+ ""String_Node_Str""+ values[x].value+ ""String_Node_Str""+ values[x].authority+ ""String_Node_Str""+ values[x].confidence+ ""String_Node_Str"");
                    break;
                  }
                  if (values[x].authority != null && values[x].confidence >= minConfidence) {
                    boolean isValueVariants=false;
                    List<String> variants=ChoiceAuthorityManager.getManager().getVariants(values[x].schema,values[x].element,values[x].qualifier,values[x].authority,values[x].language);
                    if (variants != null) {
                      for (                      String var : variants) {
                        String nVal=OrderFormat.makeSortString(var,values[x].language,bis[i].getDataType());
                        distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),var,values[x].authority,nVal));
                        if (var.equals(values[x].value)) {
                          isValueVariants=true;
                        }
                      }
                    }
                    if (!isValueVariants) {
                      String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                      distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,values[x].authority,nVal));
                    }
                  }
 else {
                    String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                    distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,null,nVal));
                  }
                }
              }
            }
          }
        }
        if (distIDSet.isEmpty()) {
          removeIndex(item.getID(),bis[i].getMapTableName());
        }
 else {
          int[] distIDarr=new int[distIDSet.size()];
          int didx=0;
          for (          Integer distID : distIDSet) {
            distIDarr[didx++]=distID;
          }
          dao.updateDistinctMappings(bis[i].getMapTableName(),item.getID(),distIDarr);
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9160211985324092
52221,"/** 
 * Generate the AJAX response Document. Looks for request parameters: field - MD field key, i.e. form key, REQUIRED - derivated from url. query - string to match collection - db ID of Collection ot serve as context start - index to start from, default 0. limit - max number of lines, default 1000. format - opt. result XML/XHTML format: ""select"", ""ul"", ""xml""(default) locale - explicit locale, pass to choice plugin
 */
private void process(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String[] paths=request.getPathInfo().split(""String_Node_Str"");
  String field=paths[paths.length - 1];
  ChoiceAuthorityManager cam=ChoiceAuthorityManager.getManager();
  String query=request.getParameter(""String_Node_Str"");
  String format=request.getParameter(""String_Node_Str"");
  int collection=UIUtil.getIntParameter(request,""String_Node_Str"");
  int start=UIUtil.getIntParameter(request,""String_Node_Str"");
  int limit=UIUtil.getIntParameter(request,""String_Node_Str"");
  Choices result=cam.getMatches(field,query,collection,start,limit,null);
  Writer writer=response.getWriter();
  Properties props=OutputPropertiesFactory.getDefaultMethodProperties(Method.XML);
  Serializer ser=SerializerFactory.getSerializer(props);
  ser.setWriter(writer);
  try {
    ChoicesXMLGenerator.generate(result,format,ser.asContentHandler());
  }
 catch (  SAXException e) {
    throw new IOException(e.toString());
  }
 finally {
    ser.reset();
  }
  writer.flush();
}","/** 
 * Generate the AJAX response Document. Looks for request parameters: field - MD field key, i.e. form key, REQUIRED - derivated from url. query - string to match collection - db ID of Collection ot serve as context start - index to start from, default 0. limit - max number of lines, default 1000. format - opt. result XML/XHTML format: ""select"", ""ul"", ""xml""(default) locale - explicit locale, pass to choice plugin
 */
private void process(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String[] paths=request.getPathInfo().split(""String_Node_Str"");
  String field=paths[paths.length - 1];
  ChoiceAuthorityManager cam=ChoiceAuthorityManager.getManager();
  String query=request.getParameter(""String_Node_Str"");
  String format=request.getParameter(""String_Node_Str"");
  int collection=UIUtil.getIntParameter(request,""String_Node_Str"");
  int start=UIUtil.getIntParameter(request,""String_Node_Str"");
  int limit=UIUtil.getIntParameter(request,""String_Node_Str"");
  Choices result=cam.getMatches(field,query,collection,start,limit,null);
  Writer writer=response.getWriter();
  response.setContentType(""String_Node_Str"");
  Properties props=OutputPropertiesFactory.getDefaultMethodProperties(Method.XML);
  Serializer ser=SerializerFactory.getSerializer(props);
  ser.setWriter(writer);
  try {
    ChoicesXMLGenerator.generate(result,format,ser.asContentHandler());
  }
 catch (  SAXException e) {
    throw new IOException(e.toString());
  }
 finally {
    ser.reset();
  }
  writer.flush();
}",0.985424588086185
52222,"/** 
 * Write the actual data out to the response. Some implementation notes, 1) We set a short expires time just in the hopes of preventing someone from overloading the server by clicking reload a bunch of times. I realize that this is nowhere near 100% effective but it may help in some cases and shouldn't hurt anything. 2) We accept partial downloads, thus if you lose a connection half way through most web browser will enable you to resume downloading the bitstream.
 */
public void generate() throws IOException, SAXException, ProcessingException {
  if (this.bitstreamInputStream == null)   return;
  if (isSpider) {
    long modSince=request.getDateHeader(""String_Node_Str"");
    if (modSince != -1 && item.getLastModified().getTime() < modSince) {
      response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
      return;
    }
  }
  try {
    if (isSpider || ContextUtil.obtainContext(request).getCurrentUser() == null) {
      response.setDateHeader(""String_Node_Str"",item.getLastModified().getTime());
    }
  }
 catch (  SQLException e) {
    throw new ProcessingException(e);
  }
  byte[] buffer=new byte[BUFFER_SIZE];
  int length=-1;
  if (isAnonymouslyReadable)   response.setDateHeader(""String_Node_Str"",System.currentTimeMillis() + expires);
  int threshold=ConfigurationManager.getIntProperty(""String_Node_Str"");
  if (bitstreamSize > threshold && threshold != 0) {
    String name=bitstreamName;
    try {
      String agent=request.getHeader(""String_Node_Str"");
      if (agent != null && agent.contains(""String_Node_Str""))       name=URLEncoder.encode(name,""String_Node_Str"");
 else       if (agent != null && agent.contains(""String_Node_Str""))       name=MimeUtility.encodeText(name,""String_Node_Str"",""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException see) {
    }
    response.setHeader(""String_Node_Str"",""String_Node_Str"" + name);
  }
  String ranges=null;
  ByteRange byteRange=null;
  if (ranges != null) {
    try {
      ranges=ranges.substring(ranges.indexOf('=') + 1);
      byteRange=new ByteRange(ranges);
    }
 catch (    NumberFormatException e) {
      byteRange=null;
      if (response instanceof HttpResponse) {
        ((HttpResponse)response).setStatus(416);
      }
    }
  }
  if (byteRange != null) {
    String entityLength;
    String entityRange;
    if (this.bitstreamSize != -1) {
      entityLength=""String_Node_Str"" + this.bitstreamSize;
      entityRange=byteRange.intersection(new ByteRange(0,this.bitstreamSize)).toString();
    }
 else {
      entityLength=""String_Node_Str"";
      entityRange=byteRange.toString();
    }
    response.setHeader(""String_Node_Str"",entityRange + ""String_Node_Str"" + entityLength);
    if (response instanceof HttpResponse) {
      ((HttpResponse)response).setStatus(206);
    }
    int pos=0;
    int posEnd;
    while ((length=this.bitstreamInputStream.read(buffer)) > -1) {
      posEnd=pos + length - 1;
      ByteRange intersection=byteRange.intersection(new ByteRange(pos,posEnd));
      if (intersection != null) {
        out.write(buffer,(int)intersection.getStart() - pos,(int)intersection.length());
      }
      pos+=length;
    }
  }
 else {
    response.setHeader(""String_Node_Str"",String.valueOf(this.bitstreamSize));
    while ((length=this.bitstreamInputStream.read(buffer)) > -1) {
      out.write(buffer,0,length);
    }
    out.flush();
  }
}","/** 
 * Write the actual data out to the response. Some implementation notes, 1) We set a short expires time just in the hopes of preventing someone from overloading the server by clicking reload a bunch of times. I realize that this is nowhere near 100% effective but it may help in some cases and shouldn't hurt anything. 2) We accept partial downloads, thus if you lose a connection half way through most web browser will enable you to resume downloading the bitstream.
 */
public void generate() throws IOException, SAXException, ProcessingException {
  if (this.bitstreamInputStream == null)   return;
  if (isSpider) {
    long modSince=request.getDateHeader(""String_Node_Str"");
    if (modSince != -1 && item != null && item.getLastModified().getTime() < modSince) {
      response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
      return;
    }
  }
  try {
    if (item != null && (isSpider || ContextUtil.obtainContext(request).getCurrentUser() == null)) {
      response.setDateHeader(""String_Node_Str"",item.getLastModified().getTime());
    }
  }
 catch (  SQLException e) {
    throw new ProcessingException(e);
  }
  byte[] buffer=new byte[BUFFER_SIZE];
  int length=-1;
  if (isAnonymouslyReadable)   response.setDateHeader(""String_Node_Str"",System.currentTimeMillis() + expires);
  int threshold=ConfigurationManager.getIntProperty(""String_Node_Str"");
  if (bitstreamSize > threshold && threshold != 0) {
    String name=bitstreamName;
    try {
      String agent=request.getHeader(""String_Node_Str"");
      if (agent != null && agent.contains(""String_Node_Str""))       name=URLEncoder.encode(name,""String_Node_Str"");
 else       if (agent != null && agent.contains(""String_Node_Str""))       name=MimeUtility.encodeText(name,""String_Node_Str"",""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException see) {
    }
    response.setHeader(""String_Node_Str"",""String_Node_Str"" + name);
  }
  String ranges=null;
  ByteRange byteRange=null;
  if (ranges != null) {
    try {
      ranges=ranges.substring(ranges.indexOf('=') + 1);
      byteRange=new ByteRange(ranges);
    }
 catch (    NumberFormatException e) {
      byteRange=null;
      if (response instanceof HttpResponse) {
        ((HttpResponse)response).setStatus(416);
      }
    }
  }
  if (byteRange != null) {
    String entityLength;
    String entityRange;
    if (this.bitstreamSize != -1) {
      entityLength=""String_Node_Str"" + this.bitstreamSize;
      entityRange=byteRange.intersection(new ByteRange(0,this.bitstreamSize)).toString();
    }
 else {
      entityLength=""String_Node_Str"";
      entityRange=byteRange.toString();
    }
    response.setHeader(""String_Node_Str"",entityRange + ""String_Node_Str"" + entityLength);
    if (response instanceof HttpResponse) {
      ((HttpResponse)response).setStatus(206);
    }
    int pos=0;
    int posEnd;
    while ((length=this.bitstreamInputStream.read(buffer)) > -1) {
      posEnd=pos + length - 1;
      ByteRange intersection=byteRange.intersection(new ByteRange(pos,posEnd));
      if (intersection != null) {
        out.write(buffer,(int)intersection.getStart() - pos,(int)intersection.length());
      }
      pos+=length;
    }
  }
 else {
    response.setHeader(""String_Node_Str"",String.valueOf(this.bitstreamSize));
    while ((length=this.bitstreamInputStream.read(buffer)) > -1) {
      out.write(buffer,0,length);
    }
    out.flush();
  }
}",0.9949808089754946
52223,"/** 
 * Add a new eperson. This method will check that the email address,  first name, and last name are non empty. Also a check is preformed  to see if the requested email address is allready in use by another user.
 * @param context The current DSpace context
 * @param request The HTTP request parameters
 * @param objectModel Cocoon's object model
 * @return A process result's object.
 */
public static FlowResult processAddEPerson(Context context,Request request,Map objectModel) throws SQLException, AuthorizeException {
  FlowResult result=new FlowResult();
  result.setContinue(false);
  String email=request.getParameter(""String_Node_Str"");
  String first=request.getParameter(""String_Node_Str"");
  String last=request.getParameter(""String_Node_Str"");
  String phone=request.getParameter(""String_Node_Str"");
  boolean login=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  boolean certificate=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  if (email.length() == 0)   result.addError(""String_Node_Str"");
  if (first.length() == 0)   result.addError(""String_Node_Str"");
  if (last.length() == 0)   result.addError(""String_Node_Str"");
  EPerson potentialDupicate=EPerson.findByEmail(context,email);
  if (potentialDupicate != null) {
    result.addError(""String_Node_Str"");
  }
  if (result.getErrors() == null) {
    EPerson newPerson=AuthenticationUtil.createNewEperson(objectModel,email);
    newPerson.setFirstName(first);
    newPerson.setLastName(last);
    newPerson.setMetadata(""String_Node_Str"",phone);
    newPerson.setCanLogIn(login);
    newPerson.setRequireCertificate(certificate);
    newPerson.setSelfRegistered(false);
    newPerson.update();
    context.commit();
    result.setContinue(true);
    result.setOutcome(true);
    result.setMessage(T_add_eperson_success_notice);
    result.setParameter(""String_Node_Str"",newPerson.getID());
  }
  return result;
}","/** 
 * Add a new eperson. This method will check that the email address,  first name, and last name are non empty. Also a check is preformed  to see if the requested email address is allready in use by another user.
 * @param context The current DSpace context
 * @param request The HTTP request parameters
 * @param objectModel Cocoon's object model
 * @return A process result's object.
 */
public static FlowResult processAddEPerson(Context context,Request request,Map objectModel) throws SQLException, AuthorizeException {
  FlowResult result=new FlowResult();
  result.setContinue(false);
  String email=request.getParameter(""String_Node_Str"").trim();
  String first=request.getParameter(""String_Node_Str"").trim();
  String last=request.getParameter(""String_Node_Str"").trim();
  String phone=request.getParameter(""String_Node_Str"").trim();
  boolean login=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  boolean certificate=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  if (email.length() == 0)   result.addError(""String_Node_Str"");
  if (first.length() == 0)   result.addError(""String_Node_Str"");
  if (last.length() == 0)   result.addError(""String_Node_Str"");
  EPerson potentialDupicate=EPerson.findByEmail(context,email);
  if (potentialDupicate != null) {
    result.addError(""String_Node_Str"");
  }
  if (result.getErrors() == null) {
    EPerson newPerson=AuthenticationUtil.createNewEperson(objectModel,email);
    newPerson.setFirstName(first);
    newPerson.setLastName(last);
    newPerson.setMetadata(""String_Node_Str"",phone);
    newPerson.setCanLogIn(login);
    newPerson.setRequireCertificate(certificate);
    newPerson.setSelfRegistered(false);
    newPerson.update();
    context.commit();
    result.setContinue(true);
    result.setOutcome(true);
    result.setMessage(T_add_eperson_success_notice);
    result.setParameter(""String_Node_Str"",newPerson.getID());
  }
  return result;
}",0.9927797833935018
52224,"/** 
 * Compare changes between an items owning collections and what is in the CSV file
 * @param item The item in question
 * @param collections The collection handles fro mthe CSV file
 * @param actualCollections The Collections from the actual item
 * @param bechange The bulkedit change object for this item
 * @param change Whether or not to actuate a change
 * @throws SQLException if there is a problem accessing a Collection from the database, from its handle
 * @throws AuthorizeException if there is an authorization problem with permissions
 * @throws IOException Can be thrown when moving items in communities
 * @throws MetadataImportException If something goes wrong to be reported back to the user
 */
private void compare(Item item,ArrayList<String> collections,Collection[] actualCollections,BulkEditChange bechange,boolean change) throws SQLException, AuthorizeException, IOException, MetadataImportException {
  for (  String csvcollection : collections) {
    boolean found=false;
    for (    Collection collection : actualCollections) {
      if (csvcollection.equals(collection.getHandle())) {
        found=true;
      }
    }
    if (!found) {
      DSpaceObject dso=HandleManager.resolveToObject(c,csvcollection);
      if ((dso == null) || (dso.getType() != Constants.COLLECTION)) {
        throw new MetadataImportException(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ item.getHandle()+ ""String_Node_Str"");
      }
 else {
        Collection col=(Collection)dso;
        bechange.registerNewOwningCollection(col);
        if (change) {
          col.addItem(item);
        }
      }
    }
  }
  for (  Collection collection : actualCollections) {
    boolean found=false;
    for (    String csvcollection : collections) {
      if (collection.getHandle().equals(csvcollection)) {
        found=true;
      }
    }
    if (!found) {
      bechange.registerOldOwningCollection(collection);
      if (change) {
        if (item.getCollections().length > 1) {
          collection.removeItem(item);
        }
 else {
          throw new MetadataImportException(""String_Node_Str"" + item.getHandle() + ""String_Node_Str""+ collection.getHandle()+ ""String_Node_Str"");
        }
      }
    }
  }
}","/** 
 * Compare changes between an items owning collections and what is in the CSV file
 * @param item The item in question
 * @param collections The collection handles fro mthe CSV file
 * @param actualCollections The Collections from the actual item
 * @param bechange The bulkedit change object for this item
 * @param change Whether or not to actuate a change
 * @throws SQLException if there is a problem accessing a Collection from the database, from its handle
 * @throws AuthorizeException if there is an authorization problem with permissions
 * @throws IOException Can be thrown when moving items in communities
 * @throws MetadataImportException If something goes wrong to be reported back to the user
 */
private void compare(Item item,ArrayList<String> collections,Collection[] actualCollections,BulkEditChange bechange,boolean change) throws SQLException, AuthorizeException, IOException, MetadataImportException {
  for (  String csvcollection : collections) {
    boolean found=false;
    for (    Collection collection : actualCollections) {
      if (csvcollection.equals(collection.getHandle())) {
        found=true;
      }
    }
    if (!found) {
      DSpaceObject dso=HandleManager.resolveToObject(c,csvcollection);
      if ((dso == null) || (dso.getType() != Constants.COLLECTION)) {
        throw new MetadataImportException(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ item.getHandle()+ ""String_Node_Str"");
      }
 else {
        Collection col=(Collection)dso;
        bechange.registerNewOwningCollection(col);
        if (change) {
          col.addItem(item);
        }
      }
    }
  }
  for (  Collection collection : actualCollections) {
    boolean found=false;
    for (    String csvcollection : collections) {
      if (collection.getHandle().equals(csvcollection)) {
        found=true;
      }
    }
    if (!found) {
      bechange.registerOldOwningCollection(collection);
      if (change) {
        if (item.getCollections().length > 1) {
          collection.removeItem(item);
        }
 else {
          throw new MetadataImportException(""String_Node_Str"" + item.getHandle() + ""String_Node_Str""+ collection.getHandle()+ ""String_Node_Str"");
        }
      }
    }
  }
  if ((change) && (!collections.get(0).equals(item.getOwningCollection().getHandle()))) {
    Collection owner=(Collection)HandleManager.resolveToObject(c,collections.get(0));
    item.setOwningCollection(Collection.find(c,owner.getID()));
    item.update();
  }
}",0.944220572640509
52225,"/** 
 * Compare changes between an items owning collections and what is in the CSV file
 * @param item The item in question
 * @param collections The collection handles fro mthe CSV file
 * @param actualCollections The Collections from the actual item
 * @param bechange The bulkedit change object for this item
 * @param change Whether or not to actuate a change
 * @throws SQLException if there is a problem accessing a Collection from the database, from its handle
 * @throws AuthorizeException if there is an authorization problem with permissions
 * @throws IOException Can be thrown when moving items in communities 
 */
private void compare(Item item,ArrayList<String> collections,Collection[] actualCollections,BulkEditChange bechange,boolean change) throws SQLException, AuthorizeException, IOException, MetadataImportException {
  for (  String csvcollection : collections) {
    boolean found=false;
    for (    Collection collection : actualCollections) {
      if (csvcollection.equals(collection.getHandle())) {
        found=true;
      }
    }
    if (!found) {
      DSpaceObject dso=HandleManager.resolveToObject(c,csvcollection);
      if ((dso == null) || (dso.getType() != Constants.COLLECTION)) {
        throw new MetadataImportException(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ item.getHandle()+ ""String_Node_Str"");
      }
 else {
        Collection col=(Collection)dso;
        bechange.registerNewOwningCollection(col);
        if (change) {
          col.addItem(item);
        }
      }
    }
  }
  for (  Collection collection : actualCollections) {
    boolean found=false;
    for (    String csvcollection : collections) {
      if (collection.getHandle().equals(csvcollection)) {
        found=true;
      }
    }
    if (!found) {
      bechange.registerOldOwningCollection(collection);
      if (change) {
        if (item.getCollections().length > 1) {
          collection.removeItem(item);
        }
 else {
          throw new MetadataImportException(""String_Node_Str"" + item.getHandle() + ""String_Node_Str""+ collection.getHandle()+ ""String_Node_Str"");
        }
      }
    }
  }
}","/** 
 * Compare changes between an items owning collections and what is in the CSV file
 * @param item The item in question
 * @param collections The collection handles fro mthe CSV file
 * @param actualCollections The Collections from the actual item
 * @param bechange The bulkedit change object for this item
 * @param change Whether or not to actuate a change
 * @throws SQLException if there is a problem accessing a Collection from the database, from its handle
 * @throws AuthorizeException if there is an authorization problem with permissions
 * @throws IOException Can be thrown when moving items in communities
 * @throws MetadataImportException If something goes wrong to be reported back to the user
 */
private void compare(Item item,ArrayList<String> collections,Collection[] actualCollections,BulkEditChange bechange,boolean change) throws SQLException, AuthorizeException, IOException, MetadataImportException {
  for (  String csvcollection : collections) {
    boolean found=false;
    for (    Collection collection : actualCollections) {
      if (csvcollection.equals(collection.getHandle())) {
        found=true;
      }
    }
    if (!found) {
      DSpaceObject dso=HandleManager.resolveToObject(c,csvcollection);
      if ((dso == null) || (dso.getType() != Constants.COLLECTION)) {
        throw new MetadataImportException(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ item.getHandle()+ ""String_Node_Str"");
      }
 else {
        Collection col=(Collection)dso;
        bechange.registerNewOwningCollection(col);
        if (change) {
          col.addItem(item);
        }
      }
    }
  }
  for (  Collection collection : actualCollections) {
    boolean found=false;
    for (    String csvcollection : collections) {
      if (collection.getHandle().equals(csvcollection)) {
        found=true;
      }
    }
    if (!found) {
      bechange.registerOldOwningCollection(collection);
      if (change) {
        if (item.getCollections().length > 1) {
          collection.removeItem(item);
        }
 else {
          throw new MetadataImportException(""String_Node_Str"" + item.getHandle() + ""String_Node_Str""+ collection.getHandle()+ ""String_Node_Str"");
        }
      }
    }
  }
}",0.9789087574507108
52226,"/** 
 * Run an import. The import can either be read-only to detect changes, or can write changes as it goes.
 * @param change Whether or not to write the changes to the database
 * @param useWorkflow Whether the workflows should be used when creating new items
 * @param workflowNotify If the workflows should be used, whether to send notifications or not
 * @param useTemplate Use collection template if create new item
 * @return An array of BulkEditChange elements representing the items that have changed
 * @throws MetadataImportException if something goes wrong
 */
public ArrayList<BulkEditChange> runImport(boolean change,boolean useWorkflow,boolean workflowNotify,boolean useTemplate) throws MetadataImportException {
  ArrayList<BulkEditChange> changes=new ArrayList<BulkEditChange>();
  try {
    for (    DSpaceCSVLine line : toImport) {
      int id=line.getID();
      if (id != -1) {
        Item item=Item.find(c,id);
        BulkEditChange whatHasChanged=new BulkEditChange(item);
        ArrayList<String> collections=line.get(""String_Node_Str"");
        if (collections != null) {
          if (collections.size() == 0) {
            throw new MetadataImportException(""String_Node_Str"" + item.getHandle());
          }
          Collection[] actualCollections=item.getCollections();
          compare(item,collections,actualCollections,whatHasChanged,change);
        }
        Enumeration<String> e=line.keys();
        while (e.hasMoreElements()) {
          String md=e.nextElement();
          if (!""String_Node_Str"".equals(md)) {
            String[] fromCSV=line.get(md).toArray(new String[line.get(md).size()]);
            compare(item,fromCSV,change,md,whatHasChanged);
          }
        }
        if (whatHasChanged.hasChanges()) {
          changes.add(whatHasChanged);
        }
      }
 else {
        if (c.getCurrentUser() == null) {
          throw new MetadataImportException(""String_Node_Str"");
        }
        Enumeration<String> e=line.keys();
        BulkEditChange whatHasChanged=new BulkEditChange();
        while (e.hasMoreElements()) {
          String md=e.nextElement();
          if (!""String_Node_Str"".equals(md)) {
            String[] fromCSV=line.get(md).toArray(new String[line.get(md).size()]);
            add(fromCSV,md,whatHasChanged);
          }
        }
        if (line.get(""String_Node_Str"") == null) {
          throw new MetadataImportException(""String_Node_Str"");
        }
        ArrayList<String> collections=line.get(""String_Node_Str"");
        ArrayList<Collection> check=new ArrayList<Collection>();
        for (int i=0; i < collections.size(); i++) {
          String handle=collections.get(i);
          Collection collection;
          try {
            collection=(Collection)HandleManager.resolveToObject(c,handle);
            if (check.contains(collection)) {
              throw new MetadataImportException(""String_Node_Str"" + handle);
            }
 else {
              check.add(collection);
            }
          }
 catch (          Exception ex) {
            throw new MetadataImportException(""String_Node_Str"" + handle + ""String_Node_Str"");
          }
        }
        for (int i=0; i < collections.size(); i++) {
          String handle=collections.get(i);
          Collection extra=(Collection)HandleManager.resolveToObject(c,handle);
          whatHasChanged.registerNewOwningCollection(extra);
        }
        if (change) {
          String collectionHandle=line.get(""String_Node_Str"").get(0);
          Collection collection=(Collection)HandleManager.resolveToObject(c,collectionHandle);
          WorkspaceItem wsItem=WorkspaceItem.create(c,collection,useTemplate);
          Item item=wsItem.getItem();
          for (          DCValue dcv : whatHasChanged.getAdds()) {
            item.addMetadata(dcv.schema,dcv.element,dcv.qualifier,dcv.language,dcv.value);
          }
          if ((useWorkflow) && (workflowNotify)) {
            WorkflowManager.start(c,wsItem);
          }
 else           if (useWorkflow) {
            WorkflowManager.startWithoutNotify(c,wsItem);
          }
 else {
            InstallItem.installItem(c,wsItem);
          }
          if (line.get(""String_Node_Str"").size() > 0) {
            for (int i=1; i < collections.size(); i++) {
              String handle=collections.get(i);
              Collection extra=(Collection)HandleManager.resolveToObject(c,handle);
              extra.addItem(item);
            }
          }
          c.commit();
          whatHasChanged.setItem(item);
        }
        changes.add(whatHasChanged);
      }
    }
  }
 catch (  MetadataImportException mie) {
    throw mie;
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  return changes;
}","/** 
 * Run an import. The import can either be read-only to detect changes, or can write changes as it goes.
 * @param change Whether or not to write the changes to the database
 * @param useWorkflow Whether the workflows should be used when creating new items
 * @param workflowNotify If the workflows should be used, whether to send notifications or not
 * @param useTemplate Use collection template if create new item
 * @return An array of BulkEditChange elements representing the items that have changed
 * @throws MetadataImportException if something goes wrong
 */
public ArrayList<BulkEditChange> runImport(boolean change,boolean useWorkflow,boolean workflowNotify,boolean useTemplate) throws MetadataImportException {
  ArrayList<BulkEditChange> changes=new ArrayList<BulkEditChange>();
  try {
    for (    DSpaceCSVLine line : toImport) {
      int id=line.getID();
      if (id != -1) {
        Item item=Item.find(c,id);
        BulkEditChange whatHasChanged=new BulkEditChange(item);
        ArrayList<String> collections=line.get(""String_Node_Str"");
        if (collections != null) {
          if (collections.size() == 0) {
            throw new MetadataImportException(""String_Node_Str"" + item.getHandle());
          }
          Collection[] actualCollections=item.getCollections();
          compare(item,collections,actualCollections,whatHasChanged,change);
        }
        Enumeration<String> e=line.keys();
        while (e.hasMoreElements()) {
          String md=e.nextElement();
          if (!""String_Node_Str"".equals(md)) {
            String[] fromCSV=line.get(md).toArray(new String[line.get(md).size()]);
            compare(item,fromCSV,change,md,whatHasChanged);
          }
        }
        if (whatHasChanged.hasChanges()) {
          changes.add(whatHasChanged);
        }
      }
 else {
        if (c.getCurrentUser() == null) {
          throw new MetadataImportException(""String_Node_Str"");
        }
        Enumeration<String> e=line.keys();
        BulkEditChange whatHasChanged=new BulkEditChange();
        while (e.hasMoreElements()) {
          String md=e.nextElement();
          if (!""String_Node_Str"".equals(md)) {
            String[] fromCSV=line.get(md).toArray(new String[line.get(md).size()]);
            add(fromCSV,md,whatHasChanged);
          }
        }
        ArrayList<String> collections=line.get(""String_Node_Str"");
        if (collections == null) {
          throw new MetadataImportException(""String_Node_Str"");
        }
        ArrayList<Collection> check=new ArrayList<Collection>();
        Collection collection;
        for (        String handle : collections) {
          try {
            collection=(Collection)HandleManager.resolveToObject(c,handle);
            if (collection == null) {
              throw new MetadataImportException(""String_Node_Str"" + handle + ""String_Node_Str"");
            }
            if (check.contains(collection)) {
              throw new MetadataImportException(""String_Node_Str"" + handle);
            }
 else {
              check.add(collection);
            }
          }
 catch (          Exception ex) {
            throw new MetadataImportException(""String_Node_Str"" + handle + ""String_Node_Str"");
          }
        }
        for (        String handle : collections) {
          Collection extra=(Collection)HandleManager.resolveToObject(c,handle);
          whatHasChanged.registerNewOwningCollection(extra);
        }
        if (change) {
          String collectionHandle=line.get(""String_Node_Str"").get(0);
          collection=(Collection)HandleManager.resolveToObject(c,collectionHandle);
          WorkspaceItem wsItem=WorkspaceItem.create(c,collection,useTemplate);
          Item item=wsItem.getItem();
          for (          DCValue dcv : whatHasChanged.getAdds()) {
            item.addMetadata(dcv.schema,dcv.element,dcv.qualifier,dcv.language,dcv.value);
          }
          if ((useWorkflow) && (workflowNotify)) {
            WorkflowManager.start(c,wsItem);
          }
 else           if (useWorkflow) {
            WorkflowManager.startWithoutNotify(c,wsItem);
          }
 else {
            InstallItem.installItem(c,wsItem);
          }
          if (line.get(""String_Node_Str"").size() > 0) {
            for (int i=1; i < collections.size(); i++) {
              String handle=collections.get(i);
              Collection extra=(Collection)HandleManager.resolveToObject(c,handle);
              extra.addItem(item);
            }
          }
          c.commit();
          whatHasChanged.setItem(item);
        }
        changes.add(whatHasChanged);
      }
    }
  }
 catch (  MetadataImportException mie) {
    throw mie;
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  return changes;
}",0.910759493670886
52227,"/** 
 * main method to run the metadata exporter
 * @param argv the command line arguments given
 * @throws Exception Thrown if something goes wrong with the import
 */
public static void main(String[] argv){
  CommandLineParser parser=new PosixParser();
  Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  CommandLine line;
  try {
    line=parser.parse(options,argv);
  }
 catch (  ParseException pe) {
    System.err.println(""String_Node_Str"" + pe.getMessage());
    System.exit(1);
    return;
  }
  if (line.hasOption('h')) {
    printHelp(options,0);
  }
  if (!line.hasOption('f')) {
    System.err.println(""String_Node_Str"");
    printHelp(options,1);
  }
  String filename=line.getOptionValue('f');
  boolean useTemplate=false;
  if (line.hasOption('t')) {
    useTemplate=true;
  }
  boolean useWorkflow=false;
  boolean workflowNotify=false;
  if (line.hasOption('w')) {
    useWorkflow=true;
    if (line.hasOption('n')) {
      workflowNotify=true;
    }
  }
 else   if (line.hasOption('n')) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  Context c;
  try {
    c=new Context();
    c.turnOffAuthorisationSystem();
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
    return;
  }
  try {
    if (line.hasOption('e')) {
      EPerson eperson=null;
      String e=line.getOptionValue('e');
      if (e.indexOf('@') != -1) {
        eperson=EPerson.findByEmail(c,e);
      }
 else {
        eperson=EPerson.find(c,Integer.parseInt(e));
      }
      if (eperson == null) {
        System.out.println(""String_Node_Str"" + e);
        System.exit(1);
      }
      c.setCurrentUser(eperson);
    }
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
    return;
  }
  boolean change=false;
  DSpaceCSV csv;
  try {
    csv=new DSpaceCSV(new File(filename));
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
    return;
  }
  MetadataImport importer=new MetadataImport(c,csv.getCSVLines());
  ArrayList<BulkEditChange> changes;
  if (!line.hasOption('s')) {
    try {
      changes=importer.runImport(false,useWorkflow,workflowNotify,useTemplate);
    }
 catch (    MetadataImportException mie) {
      System.err.println(""String_Node_Str"" + mie.getMessage());
      System.exit(1);
      return;
    }
    int changeCounter=displayChanges(changes,false);
    if (changeCounter > 0) {
      try {
        System.out.println(""String_Node_Str"" + changeCounter + ""String_Node_Str"");
        System.out.print(""String_Node_Str"");
        String yn=(new BufferedReader(new InputStreamReader(System.in))).readLine();
        if (""String_Node_Str"".equalsIgnoreCase(yn)) {
          change=true;
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
 catch (      IOException ioe) {
        System.err.println(""String_Node_Str"" + ioe.getMessage());
        System.err.println(""String_Node_Str"");
        System.exit(1);
      }
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 else {
    change=true;
  }
  try {
    if (change) {
      try {
        changes=importer.runImport(true,useWorkflow,workflowNotify,useTemplate);
      }
 catch (      MetadataImportException mie) {
        System.err.println(""String_Node_Str"" + mie.getMessage());
        System.exit(1);
        return;
      }
      displayChanges(changes,true);
      c.commit();
    }
    c.restoreAuthSystemState();
    c.complete();
  }
 catch (  Exception e) {
    c.abort();
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
}","/** 
 * main method to run the metadata exporter
 * @param argv the command line arguments given
 */
public static void main(String[] argv){
  CommandLineParser parser=new PosixParser();
  Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  CommandLine line;
  try {
    line=parser.parse(options,argv);
  }
 catch (  ParseException pe) {
    System.err.println(""String_Node_Str"" + pe.getMessage());
    System.exit(1);
    return;
  }
  if (line.hasOption('h')) {
    printHelp(options,0);
  }
  if (!line.hasOption('f')) {
    System.err.println(""String_Node_Str"");
    printHelp(options,1);
  }
  String filename=line.getOptionValue('f');
  boolean useTemplate=false;
  if (line.hasOption('t')) {
    useTemplate=true;
  }
  boolean useWorkflow=false;
  boolean workflowNotify=false;
  if (line.hasOption('w')) {
    useWorkflow=true;
    if (line.hasOption('n')) {
      workflowNotify=true;
    }
  }
 else   if (line.hasOption('n')) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  Context c;
  try {
    c=new Context();
    c.turnOffAuthorisationSystem();
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
    return;
  }
  try {
    if (line.hasOption('e')) {
      EPerson eperson;
      String e=line.getOptionValue('e');
      if (e.indexOf('@') != -1) {
        eperson=EPerson.findByEmail(c,e);
      }
 else {
        eperson=EPerson.find(c,Integer.parseInt(e));
      }
      if (eperson == null) {
        System.out.println(""String_Node_Str"" + e);
        System.exit(1);
      }
      c.setCurrentUser(eperson);
    }
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
    return;
  }
  boolean change=false;
  DSpaceCSV csv;
  try {
    csv=new DSpaceCSV(new File(filename));
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
    return;
  }
  MetadataImport importer=new MetadataImport(c,csv.getCSVLines());
  ArrayList<BulkEditChange> changes;
  if (!line.hasOption('s')) {
    try {
      changes=importer.runImport(false,useWorkflow,workflowNotify,useTemplate);
    }
 catch (    MetadataImportException mie) {
      System.err.println(""String_Node_Str"" + mie.getMessage());
      System.exit(1);
      return;
    }
    int changeCounter=displayChanges(changes,false);
    if (changeCounter > 0) {
      try {
        System.out.println(""String_Node_Str"" + changeCounter + ""String_Node_Str"");
        System.out.print(""String_Node_Str"");
        String yn=(new BufferedReader(new InputStreamReader(System.in))).readLine();
        if (""String_Node_Str"".equalsIgnoreCase(yn)) {
          change=true;
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
 catch (      IOException ioe) {
        System.err.println(""String_Node_Str"" + ioe.getMessage());
        System.err.println(""String_Node_Str"");
        System.exit(1);
      }
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 else {
    change=true;
  }
  try {
    if (change) {
      try {
        changes=importer.runImport(true,useWorkflow,workflowNotify,useTemplate);
      }
 catch (      MetadataImportException mie) {
        System.err.println(""String_Node_Str"" + mie.getMessage());
        System.exit(1);
        return;
      }
      displayChanges(changes,true);
      c.commit();
    }
    c.restoreAuthSystemState();
    c.complete();
  }
 catch (  Exception e) {
    c.abort();
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
}",0.9913945538135094
52228,"public void addBody(Body body) throws WingException {
  Division updated=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  updated.setHead(T_head);
  updated.addPara(T_para1);
  updated.addPara().addXref(contextPath,T_go_home);
}","public void addBody(Body body) throws WingException {
  Division updated=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  updated.setHead(T_head);
  updated.addPara(T_para1);
  updated.addPara().addXref(contextPath + ""String_Node_Str"",T_go_home);
}",0.959349593495935
52229,"/** 
 * Interpret named event type.
 * @param text name of event type.
 * @returns numeric value of event type or 0 for error.
 */
public static int parseEventType(String s){
  if (s.equals(""String_Node_Str"") | s.equalsIgnoreCase(""String_Node_Str"")) {
    int result=0;
    for (int i=0; i < eventTypeText.length; ++i)     result|=(1 << i);
    return result;
  }
  for (int i=0; i < eventTypeText.length; ++i)   if (eventTypeText[i].equalsIgnoreCase(s))   return 1 << i;
  return 0;
}","/** 
 * Interpret named event type.
 * @param text name of event type.
 * @returns numeric value of event type or 0 for error.
 */
public static int parseEventType(String s){
  if (""String_Node_Str"".equals(s) || ""String_Node_Str"".equalsIgnoreCase(s)) {
    int result=0;
    for (int i=0; i < eventTypeText.length; ++i)     result|=(1 << i);
    return result;
  }
  for (int i=0; i < eventTypeText.length; ++i)   if (eventTypeText[i].equalsIgnoreCase(s))   return 1 << i;
  return 0;
}",0.9392378990731204
52230,"/** 
 * Translate a textual DSpace Object type name into an event subject-type mask. NOTE: This returns a BIT-MASK, not a numeric type value; the mask is only used within the event system.
 * @param s text name of object type.
 * @returns numeric value of object type or 0 for error.
 */
public static int parseObjectType(String s){
  if (s.equals(""String_Node_Str"") | s.equalsIgnoreCase(""String_Node_Str""))   return ALL_OBJECTS_MASK;
 else {
    int id=Constants.getTypeID(s.toUpperCase());
    if (id >= 0)     return 1 << id;
  }
  return 0;
}","/** 
 * Translate a textual DSpace Object type name into an event subject-type mask. NOTE: This returns a BIT-MASK, not a numeric type value; the mask is only used within the event system.
 * @param s text name of object type.
 * @returns numeric value of object type or 0 for error.
 */
public static int parseObjectType(String s){
  if (""String_Node_Str"".equals(s) || ""String_Node_Str"".equalsIgnoreCase(s))   return ALL_OBJECTS_MASK;
 else {
    int id=Constants.getTypeID(s.toUpperCase());
    if (id >= 0)     return 1 << id;
  }
  return 0;
}",0.9460201280878316
52231,"private void sendFile(HttpServletRequest request,HttpServletResponse response,String file,String mimeType,boolean compressed) throws ServletException, IOException {
  File f=new File(ConfigurationManager.getProperty(""String_Node_Str""),file);
  if (!f.exists()) {
    response.setStatus(HttpServletResponse.SC_NOT_FOUND);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  long lastMod=f.lastModified();
  response.setDateHeader(""String_Node_Str"",lastMod);
  long modSince=request.getDateHeader(""String_Node_Str"");
  if (modSince != -1 && lastMod < modSince) {
    response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
    return;
  }
  if (compressed) {
    response.setHeader(""String_Node_Str"",""String_Node_Str"");
  }
  InputStream is=new FileInputStream(f);
  response.setContentType(mimeType);
  response.setHeader(""String_Node_Str"",String.valueOf(f.length()));
  Utils.bufferedCopy(is,response.getOutputStream());
  is.close();
  response.getOutputStream().flush();
}","private void sendFile(HttpServletRequest request,HttpServletResponse response,String file,String mimeType,boolean compressed) throws ServletException, IOException {
  File f=new File(ConfigurationManager.getProperty(""String_Node_Str""),file);
  if (!f.exists()) {
    response.setStatus(HttpServletResponse.SC_NOT_FOUND);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  long lastMod=f.lastModified();
  response.setDateHeader(""String_Node_Str"",lastMod);
  long modSince=request.getDateHeader(""String_Node_Str"");
  if (modSince != -1 && lastMod < modSince) {
    response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
    return;
  }
  if (compressed) {
    response.setHeader(""String_Node_Str"",""String_Node_Str"");
  }
  InputStream is=new FileInputStream(f);
  try {
    response.setContentType(mimeType);
    response.setHeader(""String_Node_Str"",String.valueOf(f.length()));
    Utils.bufferedCopy(is,response.getOutputStream());
  }
  finally {
    is.close();
  }
  response.getOutputStream().flush();
}",0.9823356231599608
52232,"/** 
 * Implement WebDAV PUT http request. This might be simpler with a real HTTP client library, but java.net.HttpURLConnection is part of the standard SDK and it demonstrates the concepts.
 * @param lni the lni
 * @param collHandle the coll handle
 * @param packager the packager
 * @param source the source
 * @param endpoint the endpoint
 * @throws RemoteException the remote exception
 * @throws ProtocolException the protocol exception
 * @throws IOException Signals that an I/O exception has occurred.
 * @throws FileNotFoundException the file not found exception
 */
private static void doPut(LNISoapServlet lni,String collHandle,String packager,String source,String endpoint) throws java.rmi.RemoteException, ProtocolException, IOException, FileNotFoundException {
  String collURI=doLookup(lni,collHandle,null);
  URL url=LNIClientUtils.makeDAVURL(endpoint,collURI,packager);
  System.err.println(""String_Node_Str"" + source + ""String_Node_Str""+ url.toString());
  HttpURLConnection conn=(HttpURLConnection)url.openConnection();
  conn.setRequestMethod(""String_Node_Str"");
  conn.setDoOutput(true);
  fixBasicAuth(url,conn);
  conn.connect();
  InputStream in=new FileInputStream(source);
  OutputStream out=conn.getOutputStream();
  copyStream(in,out);
  in.close();
  out.close();
  int status=conn.getResponseCode();
  if (status < 200 || status >= 300) {
    die(status,""String_Node_Str"" + String.valueOf(status) + ""String_Node_Str""+ conn.getResponseMessage());
  }
  System.err.println(""String_Node_Str"" + source);
  System.err.println(""String_Node_Str"" + String.valueOf(conn.getResponseCode()) + ""String_Node_Str""+ conn.getResponseMessage());
  String loc=conn.getHeaderField(""String_Node_Str"");
  System.err.println(""String_Node_Str"" + ((loc == null) ? ""String_Node_Str"" : loc));
}","/** 
 * Implement WebDAV PUT http request. This might be simpler with a real HTTP client library, but java.net.HttpURLConnection is part of the standard SDK and it demonstrates the concepts.
 * @param lni the lni
 * @param collHandle the coll handle
 * @param packager the packager
 * @param source the source
 * @param endpoint the endpoint
 * @throws RemoteException the remote exception
 * @throws ProtocolException the protocol exception
 * @throws IOException Signals that an I/O exception has occurred.
 * @throws FileNotFoundException the file not found exception
 */
private static void doPut(LNISoapServlet lni,String collHandle,String packager,String source,String endpoint) throws java.rmi.RemoteException, ProtocolException, IOException, FileNotFoundException {
  String collURI=doLookup(lni,collHandle,null);
  URL url=LNIClientUtils.makeDAVURL(endpoint,collURI,packager);
  System.err.println(""String_Node_Str"" + source + ""String_Node_Str""+ url.toString());
  HttpURLConnection conn=(HttpURLConnection)url.openConnection();
  conn.setRequestMethod(""String_Node_Str"");
  conn.setDoOutput(true);
  fixBasicAuth(url,conn);
  conn.connect();
  InputStream in=new FileInputStream(source);
  OutputStream out=conn.getOutputStream();
  try {
    copyStream(in,out);
  }
  finally {
    in.close();
    out.close();
  }
  int status=conn.getResponseCode();
  if (status < 200 || status >= 300) {
    die(status,""String_Node_Str"" + String.valueOf(status) + ""String_Node_Str""+ conn.getResponseMessage());
  }
  System.err.println(""String_Node_Str"" + source);
  System.err.println(""String_Node_Str"" + String.valueOf(conn.getResponseCode()) + ""String_Node_Str""+ conn.getResponseMessage());
  String loc=conn.getHeaderField(""String_Node_Str"");
  System.err.println(""String_Node_Str"" + ((loc == null) ? ""String_Node_Str"" : loc));
}",0.9889746416758544
52233,"/** 
 * Sets the cause1 value for this LNIRemoteException.
 * @param cause1
 */
public void setCause1(java.lang.Object cause1){
  this.cause1=cause1;
}","/** 
 * Sets the cause1 value for this LNIRemoteException.
 * @param cause1
 */
public synchronized void setCause1(java.lang.Object cause1){
  this.cause1=cause1;
}",0.9587301587301588
52234,"public synchronized boolean equals(java.lang.Object obj){
  if (!(obj instanceof LNIRemoteException))   return false;
  LNIRemoteException other=(LNIRemoteException)obj;
  if (obj == null)   return false;
  if (this == obj)   return true;
  if (__equalsCalc != null) {
    return (__equalsCalc == obj);
  }
  __equalsCalc=obj;
  boolean _equals;
  _equals=true && ((this.cause1 == null && other.getCause1() == null) || (this.cause1 != null && this.cause1.equals(other.getCause1()))) && ((this.message1 == null && other.getMessage1() == null) || (this.message1 != null && this.message1.equals(other.getMessage1())));
  __equalsCalc=null;
  return _equals;
}","public synchronized boolean equals(java.lang.Object obj){
  if (!(obj instanceof LNIRemoteException))   return false;
  LNIRemoteException other=(LNIRemoteException)obj;
  if (this == obj)   return true;
  if (__equalsCalc != null) {
    return (__equalsCalc == obj);
  }
  __equalsCalc=obj;
  boolean _equals;
  _equals=true && ((this.cause1 == null && other.getCause1() == null) || (this.cause1 != null && this.cause1.equals(other.getCause1()))) && ((this.message1 == null && other.getMessage1() == null) || (this.message1 != null && this.message1.equals(other.getMessage1())));
  __equalsCalc=null;
  return _equals;
}",0.9725920125293656
52235,"/** 
 * Gets the cause1 value for this LNIRemoteException.
 * @return cause1
 */
public java.lang.Object getCause1(){
  return cause1;
}","/** 
 * Gets the cause1 value for this LNIRemoteException.
 * @return cause1
 */
public synchronized java.lang.Object getCause1(){
  return cause1;
}",0.9543859649122808
52236,"/** 
 * Sets the message1 value for this LNIRemoteException.
 * @param message1
 */
public void setMessage1(java.lang.String message1){
  this.message1=message1;
}","/** 
 * Sets the message1 value for this LNIRemoteException.
 * @param message1
 */
public synchronized void setMessage1(java.lang.String message1){
  this.message1=message1;
}",0.9616519174041298
52237,"/** 
 * Gets the message1 value for this LNIRemoteException.
 * @return message1
 */
public java.lang.String getMessage1(){
  return message1;
}","/** 
 * Gets the message1 value for this LNIRemoteException.
 * @return message1
 */
public synchronized java.lang.String getMessage1(){
  return message1;
}",0.956810631229236
52238,"/** 
 * @param elements
 * @param attributes
 * @return
 */
protected SwordValidationInfo validate(SwordValidationInfo info,Properties validationContext){
  if (errorURI == null) {
    info.addValidationInfo(new SwordValidationInfo(xmlName,ATTRIBUTE_HREF_NAME,SwordValidationInfo.MISSING_ATTRIBUTE_WARNING,SwordValidationInfoType.WARNING));
  }
 else {
    boolean validUri=true;
    if (errorURI.startsWith(""String_Node_Str"")) {
      if (!(errorURI.equals(ErrorCodes.ERROR_CONTENT) | errorURI.equals(ErrorCodes.ERROR_CHECKSUM_MISMATCH) | errorURI.equals(ErrorCodes.ERROR_BAD_REQUEST)| errorURI.equals(ErrorCodes.TARGET_OWNER_UKNOWN)| errorURI.equals(ErrorCodes.MEDIATION_NOT_ALLOWED))) {
        info.addValidationInfo(new SwordValidationInfo(xmlName,ATTRIBUTE_HREF_NAME,""String_Node_Str"",SwordValidationInfoType.ERROR));
        validUri=false;
      }
    }
    if (validUri) {
      SwordValidationInfo item=new SwordValidationInfo(xmlName,ATTRIBUTE_HREF_NAME);
      item.setContentDescription(errorURI);
      info.addAttributeValidationInfo(item);
    }
  }
  return info;
}","/** 
 * @param elements
 * @param attributes
 * @return
 */
protected SwordValidationInfo validate(SwordValidationInfo info,Properties validationContext){
  if (errorURI == null) {
    info.addValidationInfo(new SwordValidationInfo(xmlName,ATTRIBUTE_HREF_NAME,SwordValidationInfo.MISSING_ATTRIBUTE_WARNING,SwordValidationInfoType.WARNING));
  }
 else {
    boolean validUri=true;
    if (errorURI.startsWith(""String_Node_Str"")) {
      if (!(errorURI.equals(ErrorCodes.ERROR_CONTENT) || errorURI.equals(ErrorCodes.ERROR_CHECKSUM_MISMATCH) || errorURI.equals(ErrorCodes.ERROR_BAD_REQUEST)|| errorURI.equals(ErrorCodes.TARGET_OWNER_UKNOWN)|| errorURI.equals(ErrorCodes.MEDIATION_NOT_ALLOWED))) {
        info.addValidationInfo(new SwordValidationInfo(xmlName,ATTRIBUTE_HREF_NAME,""String_Node_Str"",SwordValidationInfoType.ERROR));
        validUri=false;
      }
    }
    if (validUri) {
      SwordValidationInfo item=new SwordValidationInfo(xmlName,ATTRIBUTE_HREF_NAME);
      item.setContentDescription(errorURI);
      info.addAttributeValidationInfo(item);
    }
  }
  return info;
}",0.9981549815498156
52239,"/** 
 * Process a post request.
 */
protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  Deposit d=new Deposit();
  Date date=new Date();
  log.debug(""String_Node_Str"" + date.toString() + ""String_Node_Str""+ request.getRemoteAddr());
  String usernamePassword=getUsernamePassword(request);
  if ((usernamePassword != null) && (!usernamePassword.equals(""String_Node_Str""))) {
    int p=usernamePassword.indexOf(""String_Node_Str"");
    if (p != -1) {
      d.setUsername(usernamePassword.substring(0,p));
      d.setPassword(usernamePassword.substring(p + 1));
    }
  }
 else   if (authenticateWithBasic()) {
    String s=""String_Node_Str"";
    response.setHeader(""String_Node_Str"",s);
    response.setStatus(401);
    return;
  }
  String filename=null;
  File f=null;
  FileInputStream fis=null;
  try {
    filename=tempDirectory + ""String_Node_Str"" + request.getRemoteAddr()+ ""String_Node_Str""+ counter.addAndGet(1);
    InputStream inputStream=request.getInputStream();
    OutputStream outputStream=new FileOutputStream(filename);
    int data;
    while ((data=inputStream.read()) != -1) {
      outputStream.write(data);
    }
    inputStream.close();
    outputStream.close();
    File file=new File(filename);
    long fLength=file.length() / 1024;
    if ((maxUploadSize != -1) && (fLength > maxUploadSize)) {
      this.makeErrorDocument(ErrorCodes.MAX_UPLOAD_SIZE_EXCEEDED,HttpServletResponse.SC_REQUEST_ENTITY_TOO_LARGE,""String_Node_Str"" + fLength + ""String_Node_Str""+ maxUploadSize+ ""String_Node_Str"",request,response);
      return;
    }
    String receivedMD5=ChecksumUtils.generateMD5(filename);
    log.debug(""String_Node_Str"" + receivedMD5);
    d.setMd5(receivedMD5);
    String md5=request.getHeader(""String_Node_Str"");
    log.debug(""String_Node_Str"" + md5);
    if ((md5 != null) && (!md5.equals(receivedMD5))) {
      this.makeErrorDocument(ErrorCodes.ERROR_CHECKSUM_MISMATCH,HttpServletResponse.SC_PRECONDITION_FAILED,""String_Node_Str"",request,response);
      log.debug(""String_Node_Str"");
      return;
    }
 else {
      f=new File(filename);
      fis=new FileInputStream(f);
      d.setFile(fis);
      String onBehalfOf=request.getHeader(HttpHeaders.X_ON_BEHALF_OF.toString());
      if ((onBehalfOf != null) && (onBehalfOf.equals(""String_Node_Str""))) {
        throw new SWORDErrorException(ErrorCodes.TARGET_OWNER_UKNOWN,""String_Node_Str"");
      }
 else {
        d.setOnBehalfOf(onBehalfOf);
      }
      d.setPackaging(request.getHeader(HttpHeaders.X_PACKAGING));
      String noop=request.getHeader(HttpHeaders.X_NO_OP);
      log.error(""String_Node_Str"" + noop);
      if ((noop != null) && (noop.equals(""String_Node_Str""))) {
        d.setNoOp(true);
      }
 else       if ((noop != null) && (noop.equals(""String_Node_Str""))) {
        d.setNoOp(false);
      }
 else       if (noop == null) {
        d.setNoOp(false);
      }
 else {
        throw new SWORDErrorException(ErrorCodes.ERROR_BAD_REQUEST,""String_Node_Str"");
      }
      String verbose=request.getHeader(HttpHeaders.X_VERBOSE);
      if ((verbose != null) && (verbose.equals(""String_Node_Str""))) {
        d.setVerbose(true);
      }
 else       if ((verbose != null) && (verbose.equals(""String_Node_Str""))) {
        d.setVerbose(false);
      }
 else       if (verbose == null) {
        d.setVerbose(false);
      }
 else {
        throw new SWORDErrorException(ErrorCodes.ERROR_BAD_REQUEST,""String_Node_Str"");
      }
      String slug=request.getHeader(HttpHeaders.SLUG);
      if (slug != null) {
        d.setSlug(slug);
      }
      d.setContentDisposition(request.getHeader(HttpHeaders.CONTENT_DISPOSITION));
      d.setIPAddress(request.getRemoteAddr());
      d.setLocation(getUrl(request));
      d.setContentType(request.getContentType());
      String cl=request.getHeader(HttpHeaders.CONTENT_LENGTH);
      if ((cl != null) && (!cl.equals(""String_Node_Str""))) {
        d.setContentLength(Integer.parseInt(cl));
      }
      DepositResponse dr=myRepository.doDeposit(d);
      if (request.getHeader(HttpHeaders.USER_AGENT.toString()) != null) {
        dr.getEntry().setUserAgent(request.getHeader(HttpHeaders.USER_AGENT.toString()));
      }
      if (request.getHeader(HttpHeaders.X_PACKAGING.toString()) != null) {
        dr.getEntry().setPackaging(request.getHeader(HttpHeaders.X_PACKAGING.toString()));
      }
      response.setStatus(dr.getHttpResponse());
      if ((dr.getLocation() != null) && (!dr.getLocation().equals(""String_Node_Str""))) {
        response.setHeader(""String_Node_Str"",dr.getLocation());
      }
      response.setContentType(""String_Node_Str"");
      PrintWriter out=response.getWriter();
      out.write(dr.marshall());
      out.flush();
    }
  }
 catch (  SWORDAuthenticationException sae) {
    if (authN.equals(""String_Node_Str"")) {
      String s=""String_Node_Str"";
      response.setHeader(""String_Node_Str"",s);
      response.setStatus(401);
    }
  }
catch (  SWORDErrorException see) {
    log.error(see.toString());
    this.makeErrorDocument(see.getErrorURI(),see.getStatus(),see.getDescription(),request,response);
    return;
  }
catch (  SWORDException se) {
    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    log.error(se.toString());
  }
catch (  NoSuchAlgorithmException nsae) {
    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    log.error(nsae.toString());
  }
 finally {
    if (fis != null) {
      fis.close();
    }
    if (filename != null) {
      f=new File(filename);
      f.delete();
    }
  }
}","/** 
 * Process a post request.
 */
protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  Deposit d=new Deposit();
  Date date=new Date();
  log.debug(""String_Node_Str"" + date.toString() + ""String_Node_Str""+ request.getRemoteAddr());
  String usernamePassword=getUsernamePassword(request);
  if ((usernamePassword != null) && (!usernamePassword.equals(""String_Node_Str""))) {
    int p=usernamePassword.indexOf(""String_Node_Str"");
    if (p != -1) {
      d.setUsername(usernamePassword.substring(0,p));
      d.setPassword(usernamePassword.substring(p + 1));
    }
  }
 else   if (authenticateWithBasic()) {
    String s=""String_Node_Str"";
    response.setHeader(""String_Node_Str"",s);
    response.setStatus(401);
    return;
  }
  String filename=null;
  File f=null;
  FileInputStream fis=null;
  try {
    filename=tempDirectory + ""String_Node_Str"" + request.getRemoteAddr()+ ""String_Node_Str""+ counter.addAndGet(1);
    InputStream inputStream=request.getInputStream();
    OutputStream outputStream=new FileOutputStream(filename);
    try {
      int data;
      while ((data=inputStream.read()) != -1) {
        outputStream.write(data);
      }
    }
  finally {
      inputStream.close();
      outputStream.close();
    }
    File file=new File(filename);
    long fLength=file.length() / 1024;
    if ((maxUploadSize != -1) && (fLength > maxUploadSize)) {
      this.makeErrorDocument(ErrorCodes.MAX_UPLOAD_SIZE_EXCEEDED,HttpServletResponse.SC_REQUEST_ENTITY_TOO_LARGE,""String_Node_Str"" + fLength + ""String_Node_Str""+ maxUploadSize+ ""String_Node_Str"",request,response);
      return;
    }
    String receivedMD5=ChecksumUtils.generateMD5(filename);
    log.debug(""String_Node_Str"" + receivedMD5);
    d.setMd5(receivedMD5);
    String md5=request.getHeader(""String_Node_Str"");
    log.debug(""String_Node_Str"" + md5);
    if ((md5 != null) && (!md5.equals(receivedMD5))) {
      this.makeErrorDocument(ErrorCodes.ERROR_CHECKSUM_MISMATCH,HttpServletResponse.SC_PRECONDITION_FAILED,""String_Node_Str"",request,response);
      log.debug(""String_Node_Str"");
      return;
    }
 else {
      f=new File(filename);
      fis=new FileInputStream(f);
      d.setFile(fis);
      String onBehalfOf=request.getHeader(HttpHeaders.X_ON_BEHALF_OF.toString());
      if ((onBehalfOf != null) && (onBehalfOf.equals(""String_Node_Str""))) {
        throw new SWORDErrorException(ErrorCodes.TARGET_OWNER_UKNOWN,""String_Node_Str"");
      }
 else {
        d.setOnBehalfOf(onBehalfOf);
      }
      d.setPackaging(request.getHeader(HttpHeaders.X_PACKAGING));
      String noop=request.getHeader(HttpHeaders.X_NO_OP);
      log.error(""String_Node_Str"" + noop);
      if ((noop != null) && (noop.equals(""String_Node_Str""))) {
        d.setNoOp(true);
      }
 else       if ((noop != null) && (noop.equals(""String_Node_Str""))) {
        d.setNoOp(false);
      }
 else       if (noop == null) {
        d.setNoOp(false);
      }
 else {
        throw new SWORDErrorException(ErrorCodes.ERROR_BAD_REQUEST,""String_Node_Str"");
      }
      String verbose=request.getHeader(HttpHeaders.X_VERBOSE);
      if ((verbose != null) && (verbose.equals(""String_Node_Str""))) {
        d.setVerbose(true);
      }
 else       if ((verbose != null) && (verbose.equals(""String_Node_Str""))) {
        d.setVerbose(false);
      }
 else       if (verbose == null) {
        d.setVerbose(false);
      }
 else {
        throw new SWORDErrorException(ErrorCodes.ERROR_BAD_REQUEST,""String_Node_Str"");
      }
      String slug=request.getHeader(HttpHeaders.SLUG);
      if (slug != null) {
        d.setSlug(slug);
      }
      d.setContentDisposition(request.getHeader(HttpHeaders.CONTENT_DISPOSITION));
      d.setIPAddress(request.getRemoteAddr());
      d.setLocation(getUrl(request));
      d.setContentType(request.getContentType());
      String cl=request.getHeader(HttpHeaders.CONTENT_LENGTH);
      if ((cl != null) && (!cl.equals(""String_Node_Str""))) {
        d.setContentLength(Integer.parseInt(cl));
      }
      DepositResponse dr=myRepository.doDeposit(d);
      if (request.getHeader(HttpHeaders.USER_AGENT.toString()) != null) {
        dr.getEntry().setUserAgent(request.getHeader(HttpHeaders.USER_AGENT.toString()));
      }
      if (request.getHeader(HttpHeaders.X_PACKAGING.toString()) != null) {
        dr.getEntry().setPackaging(request.getHeader(HttpHeaders.X_PACKAGING.toString()));
      }
      response.setStatus(dr.getHttpResponse());
      if ((dr.getLocation() != null) && (!dr.getLocation().equals(""String_Node_Str""))) {
        response.setHeader(""String_Node_Str"",dr.getLocation());
      }
      response.setContentType(""String_Node_Str"");
      PrintWriter out=response.getWriter();
      out.write(dr.marshall());
      out.flush();
    }
  }
 catch (  SWORDAuthenticationException sae) {
    if (authN.equals(""String_Node_Str"")) {
      String s=""String_Node_Str"";
      response.setHeader(""String_Node_Str"",s);
      response.setStatus(401);
    }
  }
catch (  SWORDErrorException see) {
    log.error(see.toString());
    this.makeErrorDocument(see.getErrorURI(),see.getStatus(),see.getDescription(),request,response);
    return;
  }
catch (  SWORDException se) {
    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    log.error(se.toString());
  }
catch (  NoSuchAlgorithmException nsae) {
    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    log.error(nsae.toString());
  }
 finally {
    if (fis != null) {
      fis.close();
    }
    if (filename != null) {
      f=new File(filename);
      f.delete();
    }
  }
}",0.9941249777461278
52240,"/** 
 * Edit an eperson's metadata, the email address, first name, and last name are all required. The user's email address can be updated but it must remain unique, if the email address allready exists then the an error is produced.
 * @param context The current DSpace context
 * @param request The HTTP request parameters
 * @param objectModel Cocoon's object model
 * @param epersonID The unique id of the eperson being edited.
 * @return A process result's object.
 */
public static FlowResult processEditEPerson(Context context,Request request,Map ObjectModel,int epersonID) throws SQLException, AuthorizeException {
  FlowResult result=new FlowResult();
  result.setContinue(false);
  String email=request.getParameter(""String_Node_Str"");
  String first=request.getParameter(""String_Node_Str"");
  String last=request.getParameter(""String_Node_Str"");
  String phone=request.getParameter(""String_Node_Str"");
  boolean login=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  boolean certificate=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  if (email.length() == 0)   result.addError(""String_Node_Str"");
  if (first.length() == 0)   result.addError(""String_Node_Str"");
  if (last.length() == 0)   result.addError(""String_Node_Str"");
  if (result.getErrors() == null) {
    EPerson personModified=EPerson.find(context,epersonID);
    if (personModified.getEmail() != email) {
      EPerson potentialDupicate=EPerson.findByEmail(context,email);
      if (potentialDupicate == null) {
        personModified.setEmail(email);
      }
 else       if (potentialDupicate != personModified) {
        result.addError(""String_Node_Str"");
        return result;
      }
    }
    if (personModified.getFirstName() != first) {
      personModified.setFirstName(first);
    }
    if (personModified.getLastName() != last) {
      personModified.setLastName(last);
    }
    if (personModified.getMetadata(""String_Node_Str"") != phone) {
      personModified.setMetadata(""String_Node_Str"",phone);
    }
    personModified.setCanLogIn(login);
    personModified.setRequireCertificate(certificate);
    personModified.update();
    context.commit();
    result.setContinue(true);
    result.setOutcome(true);
    result.setMessage(T_edit_eperson_success_notice);
  }
  return result;
}","/** 
 * Edit an eperson's metadata, the email address, first name, and last name are all required. The user's email address can be updated but it must remain unique, if the email address allready exists then the an error is produced.
 * @param context The current DSpace context
 * @param request The HTTP request parameters
 * @param objectModel Cocoon's object model
 * @param epersonID The unique id of the eperson being edited.
 * @return A process result's object.
 */
public static FlowResult processEditEPerson(Context context,Request request,Map ObjectModel,int epersonID) throws SQLException, AuthorizeException {
  FlowResult result=new FlowResult();
  result.setContinue(false);
  String email=request.getParameter(""String_Node_Str"");
  String first=request.getParameter(""String_Node_Str"");
  String last=request.getParameter(""String_Node_Str"");
  String phone=request.getParameter(""String_Node_Str"");
  boolean login=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  boolean certificate=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  if (email.length() == 0)   result.addError(""String_Node_Str"");
  if (first.length() == 0)   result.addError(""String_Node_Str"");
  if (last.length() == 0)   result.addError(""String_Node_Str"");
  if (result.getErrors() == null) {
    EPerson personModified=EPerson.find(context,epersonID);
    if (!personModified.getEmail().equals(email)) {
      EPerson potentialDupicate=EPerson.findByEmail(context,email);
      if (potentialDupicate == null) {
        personModified.setEmail(email);
      }
 else       if (potentialDupicate != personModified) {
        result.addError(""String_Node_Str"");
        return result;
      }
    }
    if (!personModified.getFirstName().equals(first)) {
      personModified.setFirstName(first);
    }
    if (!personModified.getLastName().equals(last)) {
      personModified.setLastName(last);
    }
    if (!personModified.getMetadata(""String_Node_Str"").equals(phone)) {
      personModified.setMetadata(""String_Node_Str"",phone);
    }
    personModified.setCanLogIn(login);
    personModified.setRequireCertificate(certificate);
    personModified.update();
    context.commit();
    result.setContinue(true);
    result.setOutcome(true);
    result.setMessage(T_edit_eperson_success_notice);
  }
  return result;
}",0.932043010752688
52241,"public String getServletPath(){
  return this.getServletPath();
}","public String getServletPath(){
  return this.cocoonRequest.getServletPath();
}",0.9027777777777778
52242,"public String getRequestURI(){
  return this.getRequestURI();
}","public String getRequestURI(){
  return this.cocoonRequest.getRequestURI();
}",0.9
52243,"public String getRemoteUser(){
  return this.getRemoteUser();
}","public String getRemoteUser(){
  return this.cocoonRequest.getRemoteUser();
}",0.9
52244,"public HttpSession getSession(boolean arg0){
  return this.getSession(arg0);
}","public HttpSession getSession(boolean arg0){
  return (HttpSession)this.cocoonRequest.getSession(arg0);
}",0.8524590163934426
52245,"public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Map<String,String> map=new HashMap<String,String>();
  String propertyFile=parameters.getParameter(""String_Node_Str"");
  Properties props=new Properties();
  InputStream in=new FileInputStream(propertyFile);
  props.load(in);
  in.close();
  final String[] parameterNames=parameters.getNames();
  for (int i=0; i < parameterNames.length; i++) {
    final String paramName=parameterNames[i];
    if (""String_Node_Str"".equals(paramName)) {
      continue;
    }
    map.put(parameters.getParameter(paramName),props.getProperty(paramName));
  }
  return map;
}","public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Map<String,String> map=new HashMap<String,String>();
  String propertyFile=parameters.getParameter(""String_Node_Str"");
  Properties props=new Properties();
  InputStream in=new FileInputStream(propertyFile);
  try {
    props.load(in);
  }
  finally {
    in.close();
  }
  final String[] parameterNames=parameters.getNames();
  for (int i=0; i < parameterNames.length; i++) {
    final String paramName=parameterNames[i];
    if (""String_Node_Str"".equals(paramName)) {
      continue;
    }
    map.put(parameters.getParameter(paramName),props.getProperty(paramName));
  }
  return map;
}",0.961864406779661
52246,"/** 
 * Take an InProgressSubmission and turn it into a fully-archived Item.
 * @param c  current context
 * @param is submission to install
 * @param suppliedHandle the existing Handle to give the installed item
 * @return the fully archived Item
 */
public static Item installItem(Context c,InProgressSubmission is,String suppliedHandle) throws SQLException, IOException, AuthorizeException {
  Item item=is.getItem();
  String handle;
  DCDate now=DCDate.getCurrent();
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  DCValue[] currentDateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  if (currentDateIssued.length == 0) {
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  }
  if (suppliedHandle == null) {
    handle=HandleManager.createHandle(c,item);
  }
 else {
    handle=HandleManager.createHandle(c,item,suppliedHandle);
  }
  String handleref=HandleManager.getCanonicalForm(handle);
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,handleref);
  String provDescription=""String_Node_Str"" + now + ""String_Node_Str""+ getBitstreamProvenanceMessage(item);
  if (currentDateIssued.length != 0) {
    DCDate d=new DCDate(currentDateIssued[0].value);
    provDescription=provDescription + ""String_Node_Str"" + d.toString();
  }
  item.addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",provDescription);
  is.getCollection().addItem(item);
  item.setOwningCollection(is.getCollection());
  item.setArchived(true);
  item.update();
  is.deleteWrapper();
  item.inheritCollectionDefaultPolicies(is.getCollection());
  return item;
}","/** 
 * Take an InProgressSubmission and turn it into a fully-archived Item.
 * @param c  current context
 * @param is submission to install
 * @param suppliedHandle the existing Handle to give the installed item
 * @return the fully archived Item
 */
public static Item installItem(Context c,InProgressSubmission is,String suppliedHandle) throws SQLException, IOException, AuthorizeException {
  Item item=is.getItem();
  String handle;
  DCDate now=DCDate.getCurrent();
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  DCValue[] currentDateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  if (currentDateIssued.length == 0) {
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  }
  if (suppliedHandle == null) {
    handle=HandleManager.createHandle(c,item);
  }
 else {
    handle=HandleManager.createHandle(c,item,suppliedHandle);
  }
  String handleref=HandleManager.getCanonicalForm(handle);
  boolean identifierExists=false;
  DCValue[] identifiers=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  for (  DCValue identifier : identifiers)   if (handleref.equals(identifier.value))   identifierExists=true;
  if (!identifierExists)   item.addDC(""String_Node_Str"",""String_Node_Str"",null,handleref);
  String provDescription=""String_Node_Str"" + now + ""String_Node_Str""+ getBitstreamProvenanceMessage(item);
  if (currentDateIssued.length != 0) {
    DCDate d=new DCDate(currentDateIssued[0].value);
    provDescription=provDescription + ""String_Node_Str"" + d.toString();
  }
  item.addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",provDescription);
  is.getCollection().addItem(item);
  item.setOwningCollection(is.getCollection());
  item.setArchived(true);
  item.update();
  is.deleteWrapper();
  item.inheritCollectionDefaultPolicies(is.getCollection());
  return item;
}",0.930720397460668
52247,"/** 
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String page=request.getParameter(""String_Node_Str"");
  String address=request.getParameter(""String_Node_Str"");
  String agent=request.getHeader(""String_Node_Str"");
  String session=request.getSession().getId();
  String comments=request.getParameter(""String_Node_Str"");
  Context context=ContextUtil.obtainContext(objectModel);
  EPerson loggedin=context.getCurrentUser();
  String eperson=null;
  if (loggedin != null)   eperson=loggedin.getEmail();
  if (page == null || page.equals(""String_Node_Str"")) {
    page=request.getHeader(""String_Node_Str"");
  }
  if ((address == null) || address.equals(""String_Node_Str"") || (comments == null)|| comments.equals(""String_Node_Str"")) {
    Map<String,String> map=new HashMap<String,String>();
    map.put(""String_Node_Str"",page);
    if (address == null || address.equals(""String_Node_Str""))     map.put(""String_Node_Str"",eperson);
 else     map.put(""String_Node_Str"",address);
    map.put(""String_Node_Str"",comments);
    return map;
  }
  Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(context.getCurrentLocale(),""String_Node_Str""));
  email.addRecipient(ConfigurationManager.getProperty(""String_Node_Str""));
  email.addArgument(new Date());
  email.addArgument(address);
  email.addArgument(eperson);
  email.addArgument(page);
  email.addArgument(agent);
  email.addArgument(session);
  email.addArgument(comments);
  email.setReplyTo(address);
  email.send();
  return null;
}","/** 
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String page=request.getParameter(""String_Node_Str"");
  String address=request.getParameter(""String_Node_Str"");
  String agent=request.getHeader(""String_Node_Str"");
  String session=request.getSession().getId();
  String comments=request.getParameter(""String_Node_Str"");
  String fromPage=request.getHeader(""String_Node_Str"");
  String host=ConfigurationManager.getProperty(""String_Node_Str"");
  String basicHost=""String_Node_Str"";
  if (host.equals(""String_Node_Str"") || host.equals(""String_Node_Str"") || host.equals(InetAddress.getLocalHost().getHostAddress()))   basicHost=host;
 else {
    int lastDot=host.lastIndexOf(""String_Node_Str"");
    basicHost=host.substring(host.substring(0,lastDot).lastIndexOf(""String_Node_Str""));
  }
  if (fromPage == null || fromPage.indexOf(basicHost) == -1) {
    throw new AuthorizeException();
  }
  Context context=ContextUtil.obtainContext(objectModel);
  EPerson loggedin=context.getCurrentUser();
  String eperson=null;
  if (loggedin != null)   eperson=loggedin.getEmail();
  if (page == null || page.equals(""String_Node_Str"")) {
    page=fromPage;
  }
  if ((address == null) || address.equals(""String_Node_Str"") || (comments == null)|| comments.equals(""String_Node_Str"")) {
    Map<String,String> map=new HashMap<String,String>();
    map.put(""String_Node_Str"",page);
    if (address == null || address.equals(""String_Node_Str""))     map.put(""String_Node_Str"",eperson);
 else     map.put(""String_Node_Str"",address);
    map.put(""String_Node_Str"",comments);
    return map;
  }
  Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(context.getCurrentLocale(),""String_Node_Str""));
  email.addRecipient(ConfigurationManager.getProperty(""String_Node_Str""));
  email.addArgument(new Date());
  email.addArgument(address);
  email.addArgument(eperson);
  email.addArgument(page);
  email.addArgument(agent);
  email.addArgument(session);
  email.addArgument(comments);
  email.setReplyTo(address);
  email.send();
  return null;
}",0.8410096278948738
52248,"/** 
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String page=request.getParameter(""String_Node_Str"");
  String address=request.getParameter(""String_Node_Str"");
  String agent=request.getHeader(""String_Node_Str"");
  String session=request.getSession().getId();
  String comments=request.getParameter(""String_Node_Str"");
  Context context=ContextUtil.obtainContext(objectModel);
  EPerson loggedin=context.getCurrentUser();
  String eperson=null;
  if (loggedin != null)   eperson=loggedin.getEmail();
  if (page == null || page.equals(""String_Node_Str"")) {
    page=request.getHeader(""String_Node_Str"");
  }
  if ((address == null) || address.equals(""String_Node_Str"") || (comments == null)|| comments.equals(""String_Node_Str"")) {
    Map<String,String> map=new HashMap<String,String>();
    map.put(""String_Node_Str"",page);
    if (address == null || address.equals(""String_Node_Str""))     map.put(""String_Node_Str"",eperson);
 else     map.put(""String_Node_Str"",address);
    map.put(""String_Node_Str"",comments);
    return map;
  }
  Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(context.getCurrentLocale(),""String_Node_Str""));
  email.addRecipient(ConfigurationManager.getProperty(""String_Node_Str""));
  email.addArgument(new Date());
  email.addArgument(address);
  email.addArgument(eperson);
  email.addArgument(page);
  email.addArgument(agent);
  email.addArgument(session);
  email.addArgument(comments);
  email.setReplyTo(address);
  email.send();
  return null;
}","/** 
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String page=request.getParameter(""String_Node_Str"");
  String address=request.getParameter(""String_Node_Str"");
  String agent=request.getHeader(""String_Node_Str"");
  String session=request.getSession().getId();
  String comments=request.getParameter(""String_Node_Str"");
  String fromPage=request.getHeader(""String_Node_Str"");
  String host=ConfigurationManager.getProperty(""String_Node_Str"");
  String basicHost=""String_Node_Str"";
  if (host.equals(""String_Node_Str"") || host.equals(""String_Node_Str"") || host.equals(InetAddress.getLocalHost().getHostAddress()))   basicHost=host;
 else {
    int lastDot=host.lastIndexOf(""String_Node_Str"");
    basicHost=host.substring(host.substring(0,lastDot).lastIndexOf(""String_Node_Str""));
  }
  if (fromPage == null || fromPage.indexOf(basicHost) == -1) {
    throw new AuthorizeException();
  }
  Context context=ContextUtil.obtainContext(objectModel);
  EPerson loggedin=context.getCurrentUser();
  String eperson=null;
  if (loggedin != null)   eperson=loggedin.getEmail();
  if (page == null || page.equals(""String_Node_Str"")) {
    page=fromPage;
  }
  if ((address == null) || address.equals(""String_Node_Str"") || (comments == null)|| comments.equals(""String_Node_Str"")) {
    Map<String,String> map=new HashMap<String,String>();
    map.put(""String_Node_Str"",page);
    if (address == null || address.equals(""String_Node_Str""))     map.put(""String_Node_Str"",eperson);
 else     map.put(""String_Node_Str"",address);
    map.put(""String_Node_Str"",comments);
    return map;
  }
  Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(context.getCurrentLocale(),""String_Node_Str""));
  email.addRecipient(ConfigurationManager.getProperty(""String_Node_Str""));
  email.addArgument(new Date());
  email.addArgument(address);
  email.addArgument(eperson);
  email.addArgument(page);
  email.addArgument(agent);
  email.addArgument(session);
  email.addArgument(comments);
  email.setReplyTo(address);
  email.send();
  return null;
}",0.8410096278948738
52249,"/** 
 * Compare these two activity events based upon the given sort parameter. In the case of a tie, allways fallback to sorting based upon the timestamp.
 */
public int compare(E a,E b){
  if (EventSort.URL == sortBy) {
    String aURL=a.getURL();
    String bURL=b.getURL();
    int cmp=aURL.compareTo(bURL);
    if (cmp != 0)     return cmp;
  }
 else   if (EventSort.AGENT == sortBy) {
    String aAgent=a.getDectectedBrowser();
    String bAgent=b.getDectectedBrowser();
    int cmp=aAgent.compareTo(bAgent);
    if (cmp != 0)     return cmp;
  }
 else   if (EventSort.IP == sortBy) {
    String aIP=a.getIP();
    String bIP=b.getIP();
    int cmp=aIP.compareTo(bIP);
    if (cmp != 0)     return cmp;
  }
 else   if (EventSort.SESSION == sortBy) {
    String aSession=a.getSessionID();
    String bSession=b.getSessionID();
    int cmp=aSession.compareTo(bSession);
    if (cmp != 0)     return cmp;
  }
  if (a.getTimeStamp() > b.getTimeStamp())   return 1;
 else   if (a.getTimeStamp() > b.getTimeStamp())   return -1;
  return 0;
}","/** 
 * Compare these two activity events based upon the given sort parameter. In the case of a tie, allways fallback to sorting based upon the timestamp.
 */
public int compare(E a,E b){
  if (a != null && b == null)   return 1;
 else   if (a == null && b != null)   return -1;
 else   if (a == null && b == null)   return 0;
  if (EventSort.URL == sortBy) {
    String aURL=a.getURL();
    String bURL=b.getURL();
    int cmp=aURL.compareTo(bURL);
    if (cmp != 0)     return cmp;
  }
 else   if (EventSort.AGENT == sortBy) {
    String aAgent=a.getDectectedBrowser();
    String bAgent=b.getDectectedBrowser();
    int cmp=aAgent.compareTo(bAgent);
    if (cmp != 0)     return cmp;
  }
 else   if (EventSort.IP == sortBy) {
    String aIP=a.getIP();
    String bIP=b.getIP();
    int cmp=aIP.compareTo(bIP);
    if (cmp != 0)     return cmp;
  }
 else   if (EventSort.SESSION == sortBy) {
    if (a.getEPersonID() > 0 && b.getEPersonID() < 0)     return 1;
 else     if (a.getEPersonID() < 0 && b.getEPersonID() > 0)     return -1;
    String aSession=a.getSessionID();
    String bSession=b.getSessionID();
    int cmp=aSession.compareTo(bSession);
    if (cmp != 0)     return cmp;
  }
  if (a.getTimeStamp() > b.getTimeStamp())   return 1;
 else   if (a.getTimeStamp() > b.getTimeStamp())   return -1;
  return 0;
}",0.6852791878172588
52250,"/** 
 * Create a list of all activity.
 */
private void addActivity(Division div) throws WingException, SQLException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showSelf=request.getParameter(""String_Node_Str"");
  if (showSelf == null || !showSelf.equals(""String_Node_Str""))   showSelf=""String_Node_Str"";
  EventSort sortBy=EventSort.TIME;
  String sortByString=request.getParameter(""String_Node_Str"");
  if (EventSort.TIME.toString().equals(sortByString))   sortBy=EventSort.TIME;
  if (EventSort.URL.toString().equals(sortByString))   sortBy=EventSort.URL;
  if (EventSort.SESSION.toString().equals(sortByString))   sortBy=EventSort.SESSION;
  if (EventSort.AGENT.toString().equals(sortByString))   sortBy=EventSort.AGENT;
  if (EventSort.IP.toString().equals(sortByString))   sortBy=EventSort.IP;
  java.util.List<CurrentActivityAction.Event> events=CurrentActivityAction.getEvents();
  Collections.sort(events,new ActivitySort<CurrentActivityAction.Event>(sortBy));
  Collections.reverse(events);
  if (showSelf.equals(""String_Node_Str""))   div.addPara().addXref(""String_Node_Str"" + sortBy + ""String_Node_Str"").addContent(T_activity_hideself);
 else   div.addPara().addXref(""String_Node_Str"" + sortBy + ""String_Node_Str"").addContent(T_activity_showself);
  Table activeUsers=div.addTable(""String_Node_Str"",1,1);
  activeUsers.setHead(T_activity_head);
  Row row=activeUsers.addRow(Row.ROLE_HEADER);
  if (sortBy == EventSort.TIME)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.TIME + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_time);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.TIME + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_time);
  if (sortBy == EventSort.SESSION)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.SESSION + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_user);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.SESSION + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_user);
  if (sortBy == EventSort.IP)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.IP + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_ip);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.IP + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_ip);
  if (sortBy == EventSort.URL)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.URL + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_url);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.URL + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_url);
  if (sortBy == EventSort.AGENT)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.AGENT + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_agent);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.AGENT + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_agent);
  HashMap<String,Integer> anonymousHash=new HashMap<String,Integer>();
  int anonymousCount=1;
  int shown=0;
  for (  CurrentActivityAction.Event event : events) {
    if (showSelf.equals(""String_Node_Str"") && event.getEPersonID() == context.getCurrentUser().getID())     continue;
    shown++;
    Message timeStampMessage=null;
    long ago=System.currentTimeMillis() - event.getTimeStamp();
    if (ago > 2 * 60 * 60* 1000)     timeStampMessage=T_hours.parameterize((ago / (60 * 60 * 1000)));
 else     if (ago > 60 * 1000)     timeStampMessage=T_minutes.parameterize((ago / (60 * 1000)));
 else     timeStampMessage=T_seconds.parameterize((ago / (1000)));
    Row eventRow=activeUsers.addRow();
    eventRow.addCellContent(timeStampMessage);
    int eid=event.getEPersonID();
    EPerson eperson=EPerson.find(context,eid);
    if (eperson != null) {
      String name=eperson.getFullName();
      eventRow.addCellContent(name);
    }
 else {
      if (!anonymousHash.containsKey(event.getSessionID()))       anonymousHash.put(event.getSessionID(),anonymousCount++);
      eventRow.addCellContent(T_activity_anonymous.parameterize(anonymousHash.get(event.getSessionID())));
    }
    eventRow.addCellContent(event.getIP());
    eventRow.addCell().addXref(contextPath + ""String_Node_Str"" + event.getURL()).addContent(""String_Node_Str"" + event.getURL());
    eventRow.addCellContent(event.getDectectedBrowser());
  }
  if (shown == 0) {
    activeUsers.addRow().addCell(1,5).addContent(T_activity_none.parameterize(CurrentActivityAction.MAX_EVENTS));
  }
}","/** 
 * Create a list of all activity.
 */
private void addActivity(Division div) throws WingException, SQLException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showSelf=request.getParameter(""String_Node_Str"");
  if (showSelf == null || !showSelf.equals(""String_Node_Str""))   showSelf=""String_Node_Str"";
  EventSort sortBy=EventSort.TIME;
  String sortByString=request.getParameter(""String_Node_Str"");
  if (EventSort.TIME.toString().equals(sortByString))   sortBy=EventSort.TIME;
  if (EventSort.URL.toString().equals(sortByString))   sortBy=EventSort.URL;
  if (EventSort.SESSION.toString().equals(sortByString))   sortBy=EventSort.SESSION;
  if (EventSort.AGENT.toString().equals(sortByString))   sortBy=EventSort.AGENT;
  if (EventSort.IP.toString().equals(sortByString))   sortBy=EventSort.IP;
  java.util.List<CurrentActivityAction.Event> events=CurrentActivityAction.getEvents();
  Collections.sort(events,new ActivitySort<CurrentActivityAction.Event>(sortBy));
  Collections.reverse(events);
  if (showSelf.equals(""String_Node_Str""))   div.addPara().addXref(""String_Node_Str"" + sortBy + ""String_Node_Str"").addContent(T_activity_hideself);
 else   div.addPara().addXref(""String_Node_Str"" + sortBy + ""String_Node_Str"").addContent(T_activity_showself);
  Table activeUsers=div.addTable(""String_Node_Str"",1,1);
  activeUsers.setHead(T_activity_head.parameterize(CurrentActivityAction.MAX_EVENTS));
  Row row=activeUsers.addRow(Row.ROLE_HEADER);
  if (sortBy == EventSort.TIME)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.TIME + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_time);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.TIME + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_time);
  if (sortBy == EventSort.SESSION)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.SESSION + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_user);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.SESSION + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_user);
  if (sortBy == EventSort.IP)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.IP + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_ip);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.IP + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_ip);
  if (sortBy == EventSort.URL)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.URL + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_url);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.URL + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_url);
  if (sortBy == EventSort.AGENT)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.AGENT + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_agent);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.AGENT + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_agent);
  HashMap<String,Integer> anonymousHash=new HashMap<String,Integer>();
  int anonymousCount=1;
  int shown=0;
  for (  CurrentActivityAction.Event event : events) {
    if (event == null)     continue;
    if (showSelf.equals(""String_Node_Str"") && event.getEPersonID() == context.getCurrentUser().getID())     continue;
    shown++;
    Message timeStampMessage=null;
    long ago=System.currentTimeMillis() - event.getTimeStamp();
    if (ago > 2 * 60 * 60* 1000)     timeStampMessage=T_hours.parameterize((ago / (60 * 60 * 1000)));
 else     if (ago > 60 * 1000)     timeStampMessage=T_minutes.parameterize((ago / (60 * 1000)));
 else     timeStampMessage=T_seconds.parameterize((ago / (1000)));
    Row eventRow=activeUsers.addRow();
    eventRow.addCellContent(timeStampMessage);
    int eid=event.getEPersonID();
    EPerson eperson=EPerson.find(context,eid);
    if (eperson != null) {
      String name=eperson.getFullName();
      eventRow.addCellContent(name);
    }
 else {
      if (!anonymousHash.containsKey(event.getSessionID()))       anonymousHash.put(event.getSessionID(),anonymousCount++);
      eventRow.addCellContent(T_activity_anonymous.parameterize(anonymousHash.get(event.getSessionID())));
    }
    eventRow.addCellContent(event.getIP());
    eventRow.addCell().addXref(contextPath + ""String_Node_Str"" + event.getURL()).addContent(""String_Node_Str"" + event.getURL());
    eventRow.addCellContent(event.getDectectedBrowser());
  }
  if (shown == 0) {
    activeUsers.addRow().addCell(1,5).addContent(T_activity_none.parameterize(CurrentActivityAction.MAX_EVENTS));
  }
}",0.9909071227538429
52251,"/** 
 * @return a list of all current events.
 */
public static List<Event> getEvents(){
  List<Event> list=new ArrayList<Event>();
  list.addAll(events);
  return list;
}","/** 
 * @return a list of all current events.
 */
public static List<Event> getEvents(){
  List<Event> list=new ArrayList<Event>();
synchronized (events) {
    list.addAll(events);
  }
  return list;
}",0.9193548387096774
52252,"/** 
 * Record this current event.
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  Context context=ContextUtil.obtainContext(objectModel);
  Event event=new Event(context,request);
  events.add(event);
  while (events.size() > MAX_EVENTS)   events.poll();
  return null;
}","/** 
 * Record this current event.
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  Context context=ContextUtil.obtainContext(objectModel);
synchronized (events) {
    Event event=new Event(context,request);
    events.add(event);
    while (events.size() > MAX_EVENTS)     events.poll();
  }
  return null;
}",0.8484162895927602
52253,"/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  WorkspaceItemDAO wsiDAO=WorkspaceItemDAOFactory.getInstance(context);
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  int currentPage=getCurrentPage(request);
  Collection c=subInfo.getSubmissionItem().getCollection();
  DCInput[] inputs=inputsReader.getInputs(c.getIdentifier().getCanonicalForm()).getPageRows(currentPage - 1,subInfo.getSubmissionItem().hasMultipleTitles(),subInfo.getSubmissionItem().isPublishedBefore());
  for (int i=0; i < inputs.length; i++) {
    String qualifier=inputs[i].getQualifier();
    if (qualifier == null && inputs[i].getInputType().equals(""String_Node_Str"")) {
      qualifier=Item.ANY;
    }
    item.clearMetadata(inputs[i].getSchema(),inputs[i].getElement(),qualifier,Item.ANY);
  }
  String fieldName;
  boolean moreInput=false;
  for (int j=0; j < inputs.length; j++) {
    String element=inputs[j].getElement();
    String qualifier=inputs[j].getQualifier();
    String schema=inputs[j].getSchema();
    if (qualifier != null && !qualifier.equals(Item.ANY)) {
      fieldName=schema + ""String_Node_Str"" + element+ '_'+ qualifier;
    }
 else {
      fieldName=schema + ""String_Node_Str"" + element;
    }
    String inputType=inputs[j].getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      readNames(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readDate(request,item,schema,element,qualifier);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readSeriesNumbers(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      List quals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      List vals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      for (int z=0; z < vals.size(); z++) {
        String thisQual=(String)quals.get(z);
        if (""String_Node_Str"".equals(thisQual)) {
          thisQual=null;
        }
        String thisVal=(String)vals.get(z);
        if (!buttonPressed.equals(""String_Node_Str"" + schema + ""String_Node_Str""+ element+ ""String_Node_Str""+ z) && !thisVal.equals(""String_Node_Str"")) {
          item.addMetadata(schema,element,thisQual,null,thisVal);
        }
      }
    }
 else     if (inputType.equals(""String_Node_Str"") || inputType.equals(""String_Node_Str"")) {
      String[] vals=request.getParameterValues(fieldName);
      if (vals != null) {
        for (int z=0; z < vals.length; z++) {
          if (!vals[z].equals(""String_Node_Str"")) {
            item.addMetadata(schema,element,qualifier,""String_Node_Str"",vals[z]);
          }
        }
      }
    }
 else     if ((inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str""))) {
      readText(request,item,schema,element,qualifier,inputs[j].getRepeatable(),""String_Node_Str"");
    }
 else {
      throw new ServletException(""String_Node_Str"" + fieldName + ""String_Node_Str""+ inputType);
    }
    if (!moreInput && buttonPressed.equals(""String_Node_Str"" + fieldName + ""String_Node_Str"")) {
      subInfo.setMoreBoxesFor(fieldName);
      subInfo.setJumpToField(fieldName);
      moreInput=true;
    }
  }
  clearErrorFields(request);
  for (int i=0; i < inputs.length; i++) {
    DCValue[] values=item.getMetadata(inputs[i].getSchema(),inputs[i].getElement(),inputs[i].getQualifier(),Item.ANY);
    if (inputs[i].isRequired() && values.length == 0) {
      addErrorField(request,getFieldName(inputs[i]));
    }
  }
  wsiDAO.update((WorkspaceItem)subInfo.getSubmissionItem());
  context.commit();
  if (moreInput) {
    return STATUS_MORE_INPUT_REQUESTED;
  }
 else   if (getErrorFields(request) != null && getErrorFields(request).size() > 0) {
    return STATUS_MISSING_REQUIRED_FIELDS;
  }
  return STATUS_COMPLETE;
}","/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  WorkspaceItemDAO wsiDAO=WorkspaceItemDAOFactory.getInstance(context);
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  int currentPage=getCurrentPage(request);
  Collection c=subInfo.getSubmissionItem().getCollection();
  DCInput[] inputs=inputsReader.getInputs(c.getIdentifier().getCanonicalForm()).getPageRows(currentPage - 1,subInfo.getSubmissionItem().hasMultipleTitles(),subInfo.getSubmissionItem().isPublishedBefore());
  for (int i=0; i < inputs.length; i++) {
    String qualifier=inputs[i].getQualifier();
    if (qualifier == null && inputs[i].getInputType().equals(""String_Node_Str"")) {
      qualifier=Item.ANY;
    }
    item.clearMetadata(inputs[i].getSchema(),inputs[i].getElement(),qualifier,Item.ANY);
  }
  String fieldName;
  boolean moreInput=false;
  for (int j=0; j < inputs.length; j++) {
    String element=inputs[j].getElement();
    String qualifier=inputs[j].getQualifier();
    String schema=inputs[j].getSchema();
    if (qualifier != null && !qualifier.equals(Item.ANY)) {
      fieldName=schema + ""String_Node_Str"" + element+ '_'+ qualifier;
    }
 else {
      fieldName=schema + ""String_Node_Str"" + element;
    }
    String inputType=inputs[j].getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      readNames(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readDate(request,item,schema,element,qualifier);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readSeriesNumbers(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      List quals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      List vals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      for (int z=0; z < vals.size(); z++) {
        String thisQual=(String)quals.get(z);
        if (""String_Node_Str"".equals(thisQual)) {
          thisQual=null;
        }
        String thisVal=(String)vals.get(z);
        if (!buttonPressed.equals(""String_Node_Str"" + schema + ""String_Node_Str""+ element+ ""String_Node_Str""+ z) && !thisVal.equals(""String_Node_Str"")) {
          item.addMetadata(schema,element,thisQual,null,thisVal);
        }
      }
    }
 else     if (inputType.equals(""String_Node_Str"") || inputType.equals(""String_Node_Str"")) {
      String[] vals=request.getParameterValues(fieldName);
      if (vals != null) {
        for (int z=0; z < vals.length; z++) {
          if (!vals[z].equals(""String_Node_Str"")) {
            item.addMetadata(schema,element,qualifier,""String_Node_Str"",vals[z]);
          }
        }
      }
    }
 else     if ((inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str""))) {
      readText(request,item,schema,element,qualifier,inputs[j].getRepeatable(),""String_Node_Str"");
    }
 else {
      throw new ServletException(""String_Node_Str"" + fieldName + ""String_Node_Str""+ inputType);
    }
    if (!moreInput && buttonPressed.equals(""String_Node_Str"" + fieldName + ""String_Node_Str"")) {
      subInfo.setMoreBoxesFor(fieldName);
      subInfo.setJumpToField(fieldName);
      moreInput=true;
    }
  }
  if (buttonPressed.equals(NEXT_BUTTON) || buttonPressed.startsWith(PROGRESS_BAR_PREFIX)) {
    clearErrorFields(request);
    for (int i=0; i < inputs.length; i++) {
      DCValue[] values=item.getMetadata(inputs[i].getSchema(),inputs[i].getElement(),inputs[i].getQualifier(),Item.ANY);
      if (inputs[i].isRequired() && values.length == 0) {
        addErrorField(request,getFieldName(inputs[i]));
      }
    }
  }
  wsiDAO.update((WorkspaceItem)subInfo.getSubmissionItem());
  context.commit();
  if (moreInput) {
    return STATUS_MORE_INPUT_REQUESTED;
  }
 else   if (getErrorFields(request) != null && getErrorFields(request).size() > 0) {
    return STATUS_MISSING_REQUIRED_FIELDS;
  }
  return STATUS_COMPLETE;
}",0.9873891625615764
52254,"/** 
 * Create both the bitstreams and the contents file. Any bitstreams that were originally registered will be marked in the contents file as such. However, the export directory will contain actual copies of the content files being exported.
 * @param c the DSpace context
 * @param i the item being exported
 * @param destDir the item's export directory
 * @throws Exception if there is any problem writing to the export directory
 */
private static void writeBitstreams(Context c,Item i,File destDir) throws Exception {
  File outFile=new File(destDir,""String_Node_Str"");
  if (outFile.createNewFile()) {
    PrintWriter out=new PrintWriter(new FileWriter(outFile));
    Bundle[] bundles=i.getBundles();
    for (int j=0; j < bundles.length; j++) {
      Bitstream[] bitstreams=bundles[j].getBitstreams();
      String bundleName=bundles[j].getName();
      for (int k=0; k < bitstreams.length; k++) {
        Bitstream b=bitstreams[k];
        String myName=b.getName();
        String oldName=myName;
        int myPrefix=1;
        InputStream is=b.retrieve();
        boolean isDone=false;
        while (!isDone) {
          File fout=new File(destDir,myName);
          if (fout.createNewFile()) {
            FileOutputStream fos=new FileOutputStream(fout);
            Utils.bufferedCopy(is,fos);
            is.close();
            fos.close();
            if (b.isRegisteredBitstream()) {
              out.println(""String_Node_Str"" + b.getStoreNumber() + ""String_Node_Str""+ myName+ ""String_Node_Str""+ bundleName);
            }
 else {
              out.println(myName + ""String_Node_Str"" + bundleName);
            }
            isDone=true;
          }
 else {
            myName=myPrefix + ""String_Node_Str"" + oldName;
            myPrefix++;
          }
        }
      }
    }
    out.close();
  }
 else {
    throw new Exception(""String_Node_Str"" + destDir);
  }
}","/** 
 * Create both the bitstreams and the contents file. Any bitstreams that were originally registered will be marked in the contents file as such. However, the export directory will contain actual copies of the content files being exported.
 * @param c the DSpace context
 * @param i the item being exported
 * @param destDir the item's export directory
 * @throws Exception if there is any problem writing to the export directory
 */
private static void writeBitstreams(Context c,Item i,File destDir) throws Exception {
  File outFile=new File(destDir,""String_Node_Str"");
  if (outFile.createNewFile()) {
    PrintWriter out=new PrintWriter(new FileWriter(outFile));
    Bundle[] bundles=i.getBundles();
    for (int j=0; j < bundles.length; j++) {
      Bitstream[] bitstreams=bundles[j].getBitstreams();
      String bundleName=bundles[j].getName();
      for (int k=0; k < bitstreams.length; k++) {
        Bitstream b=bitstreams[k];
        String myName=b.getName();
        String oldName=myName;
        int myPrefix=1;
        InputStream is=b.retrieve();
        boolean isDone=false;
        while (!isDone) {
          if (myName.contains(File.separator)) {
            String dirs=myName.substring(0,myName.lastIndexOf(File.separator));
            File fdirs=new File(destDir + File.separator + dirs);
            fdirs.mkdirs();
          }
          File fout=new File(destDir,myName);
          if (fout.createNewFile()) {
            FileOutputStream fos=new FileOutputStream(fout);
            Utils.bufferedCopy(is,fos);
            is.close();
            fos.close();
            if (b.isRegisteredBitstream()) {
              out.println(""String_Node_Str"" + b.getStoreNumber() + ""String_Node_Str""+ myName+ ""String_Node_Str""+ bundleName);
            }
 else {
              out.println(myName + ""String_Node_Str"" + bundleName);
            }
            isDone=true;
          }
 else {
            myName=myPrefix + ""String_Node_Str"" + oldName;
            myPrefix++;
          }
        }
      }
    }
    out.close();
  }
 else {
    throw new Exception(""String_Node_Str"" + destDir);
  }
}",0.9413233458177278
52255,"/** 
 * Get the file size of the export archive represented by the file name
 * @param fileName name of the file to get the size
 * @param eperson the eperson requesting file
 * @return
 * @throws Exception
 */
public static long getExportFileSize(String fileName) throws Exception {
  String strID=fileName.substring(fileName.lastIndexOf('_') + 1,fileName.lastIndexOf('.'));
  File file=new File(getExportDownloadDirectory(Integer.parseInt(strID)) + System.getProperty(""String_Node_Str"") + fileName);
  if (!file.exists() || !file.isFile()) {
    throw new FileNotFoundException(""String_Node_Str"" + getExportDownloadDirectory(Integer.parseInt(strID)) + System.getProperty(""String_Node_Str"")+ fileName+ ""String_Node_Str"");
  }
  return file.length();
}","/** 
 * Get the file size of the export archive represented by the file name
 * @param fileName name of the file to get the size
 * @return
 * @throws Exception
 */
public static long getExportFileSize(String fileName) throws Exception {
  String strID=fileName.substring(fileName.lastIndexOf('_') + 1,fileName.lastIndexOf('.'));
  File file=new File(getExportDownloadDirectory(Integer.parseInt(strID)) + System.getProperty(""String_Node_Str"") + fileName);
  if (!file.exists() || !file.isFile()) {
    throw new FileNotFoundException(""String_Node_Str"" + getExportDownloadDirectory(Integer.parseInt(strID)) + System.getProperty(""String_Node_Str"")+ fileName+ ""String_Node_Str"");
  }
  return file.length();
}",0.9684499314128944
52256,"/** 
 * Since the archive is created in a new thread we are unable to communicate with calling method about success or failure. We accomplis this communication with email instead. Send an error email if the export archive fails
 * @param toMail -email to send message to
 * @param fromMail -email for the from field
 * @param ccMail -carbon copy email
 * @param fileName -the file name to be downloaded. It is added to the url in the email
 * @throws MessagingException
 */
public static void emailErrorMessage(String toMail,String fromMail,String ccMail,String error) throws MessagingException {
  StringBuffer content=new StringBuffer();
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(error);
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  sendMessage(toMail,fromMail,ccMail,""String_Node_Str"",content);
}","/** 
 * Since the archive is created in a new thread we are unable to communicate with calling method about success or failure. We accomplis this communication with email instead. Send an error email if the export archive fails
 * @param toMail -email to send message to
 * @param fromMail -email for the from field
 * @param ccMail -carbon copy email
 * @param error -the error message
 * @throws MessagingException
 */
public static void emailErrorMessage(String toMail,String fromMail,String ccMail,String error) throws MessagingException {
  StringBuffer content=new StringBuffer();
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(error);
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  sendMessage(toMail,fromMail,ccMail,""String_Node_Str"",content);
}",0.9627459187944748
52257,"/** 
 * Decode the given string from URL transmission.
 * @param encodedString The encoded string.
 * @return The unencoded string
 */
public static String URLDecode(String encodedString) throws UIException {
  if (encodedString == null)   return null;
  try {
    return URLDecoder.decode(encodedString,Constants.DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException uee) {
    throw new UIException(uee);
  }
}","/** 
 * Decode the given string from URL transmission.
 * @param encodedString The encoded string.
 * @return The unencoded string
 */
public static String URLDecode(String encodedString) throws UIException {
  if (encodedString == null)   return null;
  try {
    if (encodedString.contains(""String_Node_Str"")) {
      encodedString=encodedString.replace(""String_Node_Str"",""String_Node_Str"");
    }
    return URLDecoder.decode(encodedString,Constants.DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException uee) {
    throw new UIException(uee);
  }
}",0.8580183861082737
52258,"/** 
 * Since the archive is created in a new thread we are unable to communicate with calling method about success or failure. We accomplis this communication with email instead. Send a success email once the export archive is complete and ready for download
 * @param toMail - email to send message to
 * @param fromMail - email for the from field
 * @param ccMail - carbon copy email
 * @param fileName - the file name to be downloaded. It is added to the url in the email
 * @throws MessagingException
 */
public static void emailSuccessMessage(String toMail,String fromMail,String ccMail,String fileName) throws MessagingException {
  StringBuffer content=new StringBuffer();
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(ConfigurationManager.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(fileName);
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(ConfigurationManager.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  sendMessage(toMail,fromMail,ccMail,""String_Node_Str"",content);
}","/** 
 * Since the archive is created in a new thread we are unable to communicate with calling method about success or failure. We accomplis this communication with email instead. Send a success email once the export archive is complete and ready for download
 * @param context - the current Context
 * @param eperson - eperson to send the email to
 * @param fileName - the file name to be downloaded. It is added to the url in the email
 * @throws MessagingException
 */
public static void emailSuccessMessage(Context context,EPerson eperson,String fileName) throws MessagingException {
  try {
    Locale supportedLocale=I18nUtil.getEPersonLocale(eperson);
    Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(supportedLocale,""String_Node_Str""));
    email.addRecipient(eperson.getEmail());
    email.addArgument(ConfigurationManager.getProperty(""String_Node_Str"") + ""String_Node_Str"" + fileName);
    email.addArgument(ConfigurationManager.getProperty(""String_Node_Str""));
    email.send();
  }
 catch (  Exception e) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
  }
}",0.47976011994003
52259,"public void run(){
  Context context;
  ItemIterator iitems=null;
  try {
    context=new Context();
    context.setIgnoreAuthorization(true);
    iitems=new ItemIterator(context,items);
    String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
    String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
    String downloadDir=getExportDownloadDirectory(eperson.getID());
    File wkDir=new File(workDir);
    if (!wkDir.exists()) {
      wkDir.mkdirs();
    }
    File dnDir=new File(downloadDir);
    if (!dnDir.exists()) {
      dnDir.mkdirs();
    }
    exportItem(context,iitems,workDir,1);
    zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
    emailSuccessMessage(eperson.getEmail(),ConfigurationManager.getProperty(""String_Node_Str""),additionalEmail,fileName + ""String_Node_Str"");
    context.setIgnoreAuthorization(false);
  }
 catch (  Exception e1) {
    try {
      emailErrorMessage(eperson.getEmail(),ConfigurationManager.getProperty(""String_Node_Str""),additionalEmail,e1.getMessage());
    }
 catch (    Exception e) {
    }
    throw new RuntimeException(e1);
  }
 finally {
    if (iitems != null)     iitems.close();
  }
}","public void run(){
  Context context;
  ItemIterator iitems=null;
  try {
    context=new Context();
    context.setIgnoreAuthorization(true);
    iitems=new ItemIterator(context,items);
    String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
    String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
    String downloadDir=getExportDownloadDirectory(eperson.getID());
    File wkDir=new File(workDir);
    if (!wkDir.exists()) {
      wkDir.mkdirs();
    }
    File dnDir=new File(downloadDir);
    if (!dnDir.exists()) {
      dnDir.mkdirs();
    }
    exportItem(context,iitems,workDir,1);
    zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
    emailSuccessMessage(context,eperson,fileName + ""String_Node_Str"");
    context.setIgnoreAuthorization(false);
  }
 catch (  Exception e1) {
    try {
      emailErrorMessage(eperson,e1.getMessage());
    }
 catch (    Exception e) {
    }
    throw new RuntimeException(e1);
  }
 finally {
    if (iitems != null)     iitems.close();
  }
}",0.9153122326775022
52260,"/** 
 * Does the work creating a List with all the Items in the Community or Collection It then kicks off a new Thread to export the items, zip the export directory and send confirmation email
 * @param dsObjects - List of dspace objects to process
 * @param context - the dspace context
 * @param additionalEmail - email address to cc in addition the the current user email
 * @throws Exception
 */
private static void processDownloadableExport(List<DSpaceObject> dsObjects,Context context,final String additionalEmail) throws Exception {
  final EPerson eperson=context.getCurrentUser();
  deleteOldExportArchives(eperson.getID());
  float size=0;
  final ArrayList<Integer> items=new ArrayList<Integer>();
  for (  DSpaceObject dso : dsObjects) {
    if (dso.getType() == Constants.COMMUNITY) {
      Community community=(Community)dso;
      Collection[] collections=community.getCollections();
      for (      Collection collection : collections) {
        ItemIterator iitems=collection.getItems();
        try {
          while (iitems.hasNext()) {
            Item item=iitems.next();
            Bundle[] bundles=item.getBundles();
            for (            Bundle bundle : bundles) {
              Bitstream[] bitstreams=bundle.getBitstreams();
              for (              Bitstream bit : bitstreams) {
                size+=bit.getSize();
              }
            }
            items.add(item.getID());
          }
        }
  finally {
          if (iitems != null)           iitems.close();
        }
      }
    }
 else     if (dso.getType() == Constants.COLLECTION) {
      Collection collection=(Collection)dso;
      ItemIterator iitems=collection.getItems();
      try {
        while (iitems.hasNext()) {
          Item item=iitems.next();
          Bundle[] bundles=item.getBundles();
          for (          Bundle bundle : bundles) {
            Bitstream[] bitstreams=bundle.getBitstreams();
            for (            Bitstream bit : bitstreams) {
              size+=bit.getSize();
            }
          }
          items.add(item.getID());
        }
      }
  finally {
        if (iitems != null)         iitems.close();
      }
    }
 else     if (dso.getType() == Constants.ITEM) {
      Item item=(Item)dso;
      Bundle[] bundles=item.getBundles();
      for (      Bundle bundle : bundles) {
        Bitstream[] bitstreams=bundle.getBitstreams();
        for (        Bitstream bit : bitstreams) {
          size+=bit.getSize();
        }
      }
      items.add(item.getID());
    }
 else {
    }
  }
  String megaBytes=ConfigurationManager.getProperty(""String_Node_Str"");
  if (megaBytes != null) {
    float maxSize=0;
    try {
      maxSize=Float.parseFloat(megaBytes);
    }
 catch (    Exception e) {
    }
    if (maxSize > 0) {
      if (maxSize < (size / 1048576.00)) {
        throw new Exception(""String_Node_Str"");
      }
    }
  }
  if (items.size() > 0) {
    Thread go=new Thread(){
      public void run(){
        Context context;
        ItemIterator iitems=null;
        try {
          context=new Context();
          context.setIgnoreAuthorization(true);
          iitems=new ItemIterator(context,items);
          String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
          String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
          String downloadDir=getExportDownloadDirectory(eperson.getID());
          File wkDir=new File(workDir);
          if (!wkDir.exists()) {
            wkDir.mkdirs();
          }
          File dnDir=new File(downloadDir);
          if (!dnDir.exists()) {
            dnDir.mkdirs();
          }
          exportItem(context,iitems,workDir,1);
          zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
          emailSuccessMessage(eperson.getEmail(),ConfigurationManager.getProperty(""String_Node_Str""),additionalEmail,fileName + ""String_Node_Str"");
          context.setIgnoreAuthorization(false);
        }
 catch (        Exception e1) {
          try {
            emailErrorMessage(eperson.getEmail(),ConfigurationManager.getProperty(""String_Node_Str""),additionalEmail,e1.getMessage());
          }
 catch (          Exception e) {
          }
          throw new RuntimeException(e1);
        }
 finally {
          if (iitems != null)           iitems.close();
        }
      }
    }
;
    go.isDaemon();
    go.start();
  }
}","/** 
 * Does the work creating a List with all the Items in the Community or Collection It then kicks off a new Thread to export the items, zip the export directory and send confirmation email
 * @param dsObjects - List of dspace objects to process
 * @param context - the dspace context
 * @param additionalEmail - email address to cc in addition the the current user email
 * @throws Exception
 */
private static void processDownloadableExport(List<DSpaceObject> dsObjects,Context context,final String additionalEmail) throws Exception {
  final EPerson eperson=context.getCurrentUser();
  deleteOldExportArchives(eperson.getID());
  float size=0;
  final ArrayList<Integer> items=new ArrayList<Integer>();
  for (  DSpaceObject dso : dsObjects) {
    if (dso.getType() == Constants.COMMUNITY) {
      Community community=(Community)dso;
      Collection[] collections=community.getCollections();
      for (      Collection collection : collections) {
        ItemIterator iitems=collection.getItems();
        try {
          while (iitems.hasNext()) {
            Item item=iitems.next();
            Bundle[] bundles=item.getBundles();
            for (            Bundle bundle : bundles) {
              Bitstream[] bitstreams=bundle.getBitstreams();
              for (              Bitstream bit : bitstreams) {
                size+=bit.getSize();
              }
            }
            items.add(item.getID());
          }
        }
  finally {
          if (iitems != null)           iitems.close();
        }
      }
    }
 else     if (dso.getType() == Constants.COLLECTION) {
      Collection collection=(Collection)dso;
      ItemIterator iitems=collection.getItems();
      try {
        while (iitems.hasNext()) {
          Item item=iitems.next();
          Bundle[] bundles=item.getBundles();
          for (          Bundle bundle : bundles) {
            Bitstream[] bitstreams=bundle.getBitstreams();
            for (            Bitstream bit : bitstreams) {
              size+=bit.getSize();
            }
          }
          items.add(item.getID());
        }
      }
  finally {
        if (iitems != null)         iitems.close();
      }
    }
 else     if (dso.getType() == Constants.ITEM) {
      Item item=(Item)dso;
      Bundle[] bundles=item.getBundles();
      for (      Bundle bundle : bundles) {
        Bitstream[] bitstreams=bundle.getBitstreams();
        for (        Bitstream bit : bitstreams) {
          size+=bit.getSize();
        }
      }
      items.add(item.getID());
    }
 else {
    }
  }
  String megaBytes=ConfigurationManager.getProperty(""String_Node_Str"");
  if (megaBytes != null) {
    float maxSize=0;
    try {
      maxSize=Float.parseFloat(megaBytes);
    }
 catch (    Exception e) {
    }
    if (maxSize > 0) {
      if (maxSize < (size / 1048576.00)) {
        throw new Exception(""String_Node_Str"");
      }
    }
  }
  if (items.size() > 0) {
    Thread go=new Thread(){
      public void run(){
        Context context;
        ItemIterator iitems=null;
        try {
          context=new Context();
          context.setIgnoreAuthorization(true);
          iitems=new ItemIterator(context,items);
          String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
          String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
          String downloadDir=getExportDownloadDirectory(eperson.getID());
          File wkDir=new File(workDir);
          if (!wkDir.exists()) {
            wkDir.mkdirs();
          }
          File dnDir=new File(downloadDir);
          if (!dnDir.exists()) {
            dnDir.mkdirs();
          }
          exportItem(context,iitems,workDir,1);
          zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
          emailSuccessMessage(context,eperson,fileName + ""String_Node_Str"");
          context.setIgnoreAuthorization(false);
        }
 catch (        Exception e1) {
          try {
            emailErrorMessage(eperson,e1.getMessage());
          }
 catch (          Exception e) {
          }
          throw new RuntimeException(e1);
        }
 finally {
          if (iitems != null)           iitems.close();
        }
      }
    }
;
    go.isDaemon();
    go.start();
  }
}",0.9789810372401188
52261,"/** 
 * Since the archive is created in a new thread we are unable to communicate with calling method about success or failure. We accomplis this communication with email instead. Send an error email if the export archive fails
 * @param toMail - email to send message to
 * @param fromMail - email for the from field
 * @param ccMail - carbon copy email
 * @param error - the error message
 * @throws MessagingException
 */
public static void emailErrorMessage(String toMail,String fromMail,String ccMail,String error) throws MessagingException {
  StringBuffer content=new StringBuffer();
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(error);
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  sendMessage(toMail,fromMail,ccMail,""String_Node_Str"",content);
}","/** 
 * Since the archive is created in a new thread we are unable to communicate with calling method about success or failure. We accomplis this communication with email instead. Send an error email if the export archive fails
 * @param eperson - EPerson to send the error message to
 * @param error - the error message
 * @throws MessagingException
 */
public static void emailErrorMessage(EPerson eperson,String error) throws MessagingException {
  log.warn(""String_Node_Str"" + error);
  try {
    Locale supportedLocale=I18nUtil.getEPersonLocale(eperson);
    Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(supportedLocale,""String_Node_Str""));
    email.addRecipient(eperson.getEmail());
    email.addArgument(error);
    email.addArgument(ConfigurationManager.getProperty(""String_Node_Str"") + ""String_Node_Str"");
    email.send();
  }
 catch (  Exception e) {
    log.warn(""String_Node_Str"",e);
  }
}",0.4537654909437559
52262,"public void run(){
  Context context;
  ItemIterator iitems=null;
  try {
    context=new Context();
    context.setIgnoreAuthorization(true);
    iitems=new ItemIterator(context,items);
    String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
    String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
    String downloadDir=getExportDownloadDirectory(eperson.getID());
    File wkDir=new File(workDir);
    if (!wkDir.exists()) {
      wkDir.mkdirs();
    }
    File dnDir=new File(downloadDir);
    if (!dnDir.exists()) {
      dnDir.mkdirs();
    }
    exportItem(context,iitems,workDir,1);
    zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
    emailSuccessMessage(context,eperson,fileName + ""String_Node_Str"");
    context.setIgnoreAuthorization(false);
  }
 catch (  Exception e1) {
    try {
      emailErrorMessage(eperson,e1.getMessage());
    }
 catch (    Exception e) {
    }
    throw new RuntimeException(e1);
  }
 finally {
    if (iitems != null)     iitems.close();
  }
}","public void run(){
  Context context=null;
  ItemIterator iitems=null;
  try {
    context=new Context();
    context.setIgnoreAuthorization(true);
    iitems=new ItemIterator(context,items);
    String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
    String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
    String downloadDir=getExportDownloadDirectory(eperson.getID());
    File wkDir=new File(workDir);
    if (!wkDir.exists()) {
      wkDir.mkdirs();
    }
    File dnDir=new File(downloadDir);
    if (!dnDir.exists()) {
      dnDir.mkdirs();
    }
    exportItem(context,iitems,workDir,1);
    zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
    emailSuccessMessage(context,eperson,fileName + ""String_Node_Str"");
    context.setIgnoreAuthorization(false);
  }
 catch (  Exception e1) {
    try {
      emailErrorMessage(eperson,e1.getMessage());
    }
 catch (    Exception e) {
    }
    throw new RuntimeException(e1);
  }
 finally {
    if (iitems != null)     iitems.close();
    try {
      context.complete();
    }
 catch (    SQLException sqle) {
      context.abort();
    }
  }
}",0.9525468001741402
52263,"/** 
 * Does the work creating a List with all the Items in the Community or Collection It then kicks off a new Thread to export the items, zip the export directory and send confirmation email
 * @param dsObjects - List of dspace objects to process
 * @param context - the dspace context
 * @param additionalEmail - email address to cc in addition the the current user email
 * @throws Exception
 */
private static void processDownloadableExport(List<DSpaceObject> dsObjects,Context context,final String additionalEmail) throws Exception {
  final EPerson eperson=context.getCurrentUser();
  deleteOldExportArchives(eperson.getID());
  float size=0;
  final ArrayList<Integer> items=new ArrayList<Integer>();
  for (  DSpaceObject dso : dsObjects) {
    if (dso.getType() == Constants.COMMUNITY) {
      Community community=(Community)dso;
      Collection[] collections=community.getCollections();
      for (      Collection collection : collections) {
        ItemIterator iitems=collection.getItems();
        try {
          while (iitems.hasNext()) {
            Item item=iitems.next();
            Bundle[] bundles=item.getBundles();
            for (            Bundle bundle : bundles) {
              Bitstream[] bitstreams=bundle.getBitstreams();
              for (              Bitstream bit : bitstreams) {
                size+=bit.getSize();
              }
            }
            items.add(item.getID());
          }
        }
  finally {
          if (iitems != null)           iitems.close();
        }
      }
    }
 else     if (dso.getType() == Constants.COLLECTION) {
      Collection collection=(Collection)dso;
      ItemIterator iitems=collection.getItems();
      try {
        while (iitems.hasNext()) {
          Item item=iitems.next();
          Bundle[] bundles=item.getBundles();
          for (          Bundle bundle : bundles) {
            Bitstream[] bitstreams=bundle.getBitstreams();
            for (            Bitstream bit : bitstreams) {
              size+=bit.getSize();
            }
          }
          items.add(item.getID());
        }
      }
  finally {
        if (iitems != null)         iitems.close();
      }
    }
 else     if (dso.getType() == Constants.ITEM) {
      Item item=(Item)dso;
      Bundle[] bundles=item.getBundles();
      for (      Bundle bundle : bundles) {
        Bitstream[] bitstreams=bundle.getBitstreams();
        for (        Bitstream bit : bitstreams) {
          size+=bit.getSize();
        }
      }
      items.add(item.getID());
    }
 else {
    }
  }
  String megaBytes=ConfigurationManager.getProperty(""String_Node_Str"");
  if (megaBytes != null) {
    float maxSize=0;
    try {
      maxSize=Float.parseFloat(megaBytes);
    }
 catch (    Exception e) {
    }
    if (maxSize > 0) {
      if (maxSize < (size / 1048576.00)) {
        throw new Exception(""String_Node_Str"");
      }
    }
  }
  if (items.size() > 0) {
    Thread go=new Thread(){
      public void run(){
        Context context;
        ItemIterator iitems=null;
        try {
          context=new Context();
          context.setIgnoreAuthorization(true);
          iitems=new ItemIterator(context,items);
          String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
          String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
          String downloadDir=getExportDownloadDirectory(eperson.getID());
          File wkDir=new File(workDir);
          if (!wkDir.exists()) {
            wkDir.mkdirs();
          }
          File dnDir=new File(downloadDir);
          if (!dnDir.exists()) {
            dnDir.mkdirs();
          }
          exportItem(context,iitems,workDir,1);
          zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
          emailSuccessMessage(context,eperson,fileName + ""String_Node_Str"");
          context.setIgnoreAuthorization(false);
        }
 catch (        Exception e1) {
          try {
            emailErrorMessage(eperson,e1.getMessage());
          }
 catch (          Exception e) {
          }
          throw new RuntimeException(e1);
        }
 finally {
          if (iitems != null)           iitems.close();
        }
      }
    }
;
    go.isDaemon();
    go.start();
  }
}","/** 
 * Does the work creating a List with all the Items in the Community or Collection It then kicks off a new Thread to export the items, zip the export directory and send confirmation email
 * @param dsObjects - List of dspace objects to process
 * @param context - the dspace context
 * @param additionalEmail - email address to cc in addition the the current user email
 * @throws Exception
 */
private static void processDownloadableExport(List<DSpaceObject> dsObjects,Context context,final String additionalEmail) throws Exception {
  final EPerson eperson=context.getCurrentUser();
  deleteOldExportArchives(eperson.getID());
  float size=0;
  final ArrayList<Integer> items=new ArrayList<Integer>();
  for (  DSpaceObject dso : dsObjects) {
    if (dso.getType() == Constants.COMMUNITY) {
      Community community=(Community)dso;
      Collection[] collections=community.getCollections();
      for (      Collection collection : collections) {
        ItemIterator iitems=collection.getItems();
        try {
          while (iitems.hasNext()) {
            Item item=iitems.next();
            Bundle[] bundles=item.getBundles();
            for (            Bundle bundle : bundles) {
              Bitstream[] bitstreams=bundle.getBitstreams();
              for (              Bitstream bit : bitstreams) {
                size+=bit.getSize();
              }
            }
            items.add(item.getID());
          }
        }
  finally {
          if (iitems != null)           iitems.close();
        }
      }
    }
 else     if (dso.getType() == Constants.COLLECTION) {
      Collection collection=(Collection)dso;
      ItemIterator iitems=collection.getItems();
      try {
        while (iitems.hasNext()) {
          Item item=iitems.next();
          Bundle[] bundles=item.getBundles();
          for (          Bundle bundle : bundles) {
            Bitstream[] bitstreams=bundle.getBitstreams();
            for (            Bitstream bit : bitstreams) {
              size+=bit.getSize();
            }
          }
          items.add(item.getID());
        }
      }
  finally {
        if (iitems != null)         iitems.close();
      }
    }
 else     if (dso.getType() == Constants.ITEM) {
      Item item=(Item)dso;
      Bundle[] bundles=item.getBundles();
      for (      Bundle bundle : bundles) {
        Bitstream[] bitstreams=bundle.getBitstreams();
        for (        Bitstream bit : bitstreams) {
          size+=bit.getSize();
        }
      }
      items.add(item.getID());
    }
 else {
    }
  }
  String megaBytes=ConfigurationManager.getProperty(""String_Node_Str"");
  if (megaBytes != null) {
    float maxSize=0;
    try {
      maxSize=Float.parseFloat(megaBytes);
    }
 catch (    Exception e) {
    }
    if (maxSize > 0) {
      if (maxSize < (size / 1048576.00)) {
        throw new Exception(""String_Node_Str"");
      }
    }
  }
  if (items.size() > 0) {
    Thread go=new Thread(){
      public void run(){
        Context context=null;
        ItemIterator iitems=null;
        try {
          context=new Context();
          context.setIgnoreAuthorization(true);
          iitems=new ItemIterator(context,items);
          String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
          String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
          String downloadDir=getExportDownloadDirectory(eperson.getID());
          File wkDir=new File(workDir);
          if (!wkDir.exists()) {
            wkDir.mkdirs();
          }
          File dnDir=new File(downloadDir);
          if (!dnDir.exists()) {
            dnDir.mkdirs();
          }
          exportItem(context,iitems,workDir,1);
          zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
          emailSuccessMessage(context,eperson,fileName + ""String_Node_Str"");
          context.setIgnoreAuthorization(false);
        }
 catch (        Exception e1) {
          try {
            emailErrorMessage(eperson,e1.getMessage());
          }
 catch (          Exception e) {
          }
          throw new RuntimeException(e1);
        }
 finally {
          if (iitems != null)           iitems.close();
          try {
            context.complete();
          }
 catch (          SQLException sqle) {
            context.abort();
          }
        }
      }
    }
;
    go.isDaemon();
    go.start();
  }
}",0.9834266773345524
52264,"/** 
 * Get repeated values from a form. If ""foo"" is passed in as the parameter, values in the form of parameters ""foo"", ""foo_1"", ""foo_2"", etc. are returned. <P> This method can also handle ""composite fields"" (metadata fields which may require multiple params, etc. a first name and last name).
 * @param request the HTTP request containing the form information
 * @param metadataField the metadata field which can store repeated values
 * @param param the repeated parameter on the page (used to fill out the metadataField)
 * @return a List of Strings
 */
protected List getRepeatedParameter(HttpServletRequest request,String metadataField,String param){
  List vals=new LinkedList();
  int i=0;
  boolean foundLast=false;
  log.debug(""String_Node_Str"" + metadataField + ""String_Node_Str""+ metadataField);
  while (!foundLast) {
    String s=null;
    if (i == 0)     s=request.getParameter(param);
 else     s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s != null) {
      boolean addValue=true;
      String[] selected=request.getParameterValues(metadataField + ""String_Node_Str"");
      if (selected != null) {
        for (int j=0; j < selected.length; j++) {
          if (selected[j].equals(metadataField + ""String_Node_Str"" + i)) {
            addValue=false;
          }
        }
      }
      if (addValue)       vals.add(s.trim());
    }
 else {
      foundLast=true;
    }
    i++;
  }
  return vals;
}","/** 
 * Get repeated values from a form. If ""foo"" is passed in as the parameter, values in the form of parameters ""foo"", ""foo_1"", ""foo_2"", etc. are returned. <P> This method can also handle ""composite fields"" (metadata fields which may require multiple params, etc. a first name and last name).
 * @param request the HTTP request containing the form information
 * @param metadataField the metadata field which can store repeated values
 * @param param the repeated parameter on the page (used to fill out the metadataField)
 * @return a List of Strings
 */
protected List getRepeatedParameter(HttpServletRequest request,String metadataField,String param){
  List vals=new LinkedList();
  int i=1;
  boolean foundLast=false;
  log.debug(""String_Node_Str"" + metadataField + ""String_Node_Str""+ metadataField);
  while (!foundLast) {
    String s=null;
    s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s == null) {
      s=request.getParameter(param);
      foundLast=true;
    }
    if (s != null) {
      boolean addValue=true;
      String[] selected=request.getParameterValues(metadataField + ""String_Node_Str"");
      if (selected != null) {
        for (int j=0; j < selected.length; j++) {
          if (selected[j].equals(metadataField + ""String_Node_Str"" + i)) {
            addValue=false;
          }
        }
      }
      if (addValue)       vals.add(s.trim());
    }
    i++;
  }
  return vals;
}",0.9282966072053166
52265,"/** 
 * What to add at the end of the body 
 */
public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (this.bodyEmpty) {
    Division notFound=body.addDivision(""String_Node_Str"",""String_Node_Str"");
    notFound.setHead(T_head);
    notFound.addPara(T_para1);
    notFound.addPara().addXref(contextPath,T_go_home);
  }
}","/** 
 * What to add at the end of the body 
 */
public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (this.bodyEmpty) {
    Division notFound=body.addDivision(""String_Node_Str"",""String_Node_Str"");
    notFound.setHead(T_head);
    notFound.addPara(T_para1);
    notFound.addPara().addXref(contextPath,T_go_home);
    HttpServletResponse response=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
    response.setStatus(HttpServletResponse.SC_NOT_FOUND);
  }
}",0.8265835929387332
52266,"/** 
 * Get repeated values from a form. If ""foo"" is passed in as the parameter, values in the form of parameters ""foo"", ""foo_1"", ""foo_2"", etc. are returned. <P> This method can also handle ""composite fields"" (metadata fields which may require multiple params, etc. a first name and last name).
 * @param request the HTTP request containing the form information
 * @param metadataField the metadata field which can store repeated values
 * @param param the repeated parameter on the page (used to fill out the metadataField)
 * @return a List of Strings
 */
protected List getRepeatedParameter(HttpServletRequest request,String metadataField,String param){
  List vals=new LinkedList();
  int i=0;
  boolean foundLast=false;
  log.debug(""String_Node_Str"" + metadataField + ""String_Node_Str""+ metadataField);
  while (!foundLast) {
    String s=null;
    if (i == 0)     s=request.getParameter(param);
 else     s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s != null) {
      boolean addValue=true;
      String[] selected=request.getParameterValues(metadataField + ""String_Node_Str"");
      if (selected != null) {
        for (int j=0; j < selected.length; j++) {
          if (selected[j].equals(metadataField + ""String_Node_Str"" + i)) {
            addValue=false;
          }
        }
      }
      if (addValue)       vals.add(s.trim());
    }
 else {
      foundLast=true;
    }
    i++;
  }
  return vals;
}","/** 
 * Get repeated values from a form. If ""foo"" is passed in as the parameter, values in the form of parameters ""foo"", ""foo_1"", ""foo_2"", etc. are returned. <P> This method can also handle ""composite fields"" (metadata fields which may require multiple params, etc. a first name and last name).
 * @param request the HTTP request containing the form information
 * @param metadataField the metadata field which can store repeated values
 * @param param the repeated parameter on the page (used to fill out the metadataField)
 * @return a List of Strings
 */
protected List getRepeatedParameter(HttpServletRequest request,String metadataField,String param){
  List vals=new LinkedList();
  int i=1;
  boolean foundLast=false;
  log.debug(""String_Node_Str"" + metadataField + ""String_Node_Str""+ metadataField);
  while (!foundLast) {
    String s=null;
    s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s == null) {
      s=request.getParameter(param);
      foundLast=true;
    }
    if (s != null) {
      boolean addValue=true;
      String[] selected=request.getParameterValues(metadataField + ""String_Node_Str"");
      if (selected != null) {
        for (int j=0; j < selected.length; j++) {
          if (selected[j].equals(metadataField + ""String_Node_Str"" + i)) {
            addValue=false;
          }
        }
      }
      if (addValue)       vals.add(s.trim());
    }
    i++;
  }
  return vals;
}",0.9282966072053166
52267,"/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  int currentPage=getCurrentPage(request);
  Collection c=subInfo.getSubmissionItem().getCollection();
  DCInput[] inputs=inputsReader.getInputs(c.getHandle()).getPageRows(currentPage - 1,subInfo.getSubmissionItem().hasMultipleTitles(),subInfo.getSubmissionItem().isPublishedBefore());
  for (int i=0; i < inputs.length; i++) {
    String qualifier=inputs[i].getQualifier();
    if (qualifier == null && inputs[i].getInputType().equals(""String_Node_Str"")) {
      qualifier=Item.ANY;
    }
    item.clearMetadata(inputs[i].getSchema(),inputs[i].getElement(),qualifier,Item.ANY);
  }
  String fieldName;
  boolean moreInput=false;
  for (int j=0; j < inputs.length; j++) {
    String element=inputs[j].getElement();
    String qualifier=inputs[j].getQualifier();
    String schema=inputs[j].getSchema();
    if (qualifier != null && !qualifier.equals(Item.ANY)) {
      fieldName=schema + ""String_Node_Str"" + element+ '_'+ qualifier;
    }
 else {
      fieldName=schema + ""String_Node_Str"" + element;
    }
    String inputType=inputs[j].getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      readNames(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readDate(request,item,schema,element,qualifier);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readSeriesNumbers(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      List quals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      List vals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      for (int z=0; z < vals.size(); z++) {
        String thisQual=(String)quals.get(z);
        if (""String_Node_Str"".equals(thisQual)) {
          thisQual=null;
        }
        String thisVal=(String)vals.get(z);
        if (!buttonPressed.equals(""String_Node_Str"" + schema + ""String_Node_Str""+ element+ ""String_Node_Str""+ z) && !thisVal.equals(""String_Node_Str"")) {
          item.addMetadata(schema,element,thisQual,null,thisVal);
        }
      }
    }
 else     if (inputType.equals(""String_Node_Str"") || inputType.equals(""String_Node_Str"")) {
      String[] vals=request.getParameterValues(fieldName);
      if (vals != null) {
        for (int z=0; z < vals.length; z++) {
          if (!vals[z].equals(""String_Node_Str"")) {
            item.addMetadata(schema,element,qualifier,LANGUAGE_QUALIFIER,vals[z]);
          }
        }
      }
    }
 else     if ((inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str""))) {
      readText(request,item,schema,element,qualifier,inputs[j].getRepeatable(),LANGUAGE_QUALIFIER);
    }
 else {
      throw new ServletException(""String_Node_Str"" + fieldName + ""String_Node_Str""+ inputType);
    }
    if (!moreInput && buttonPressed.equals(""String_Node_Str"" + fieldName + ""String_Node_Str"")) {
      subInfo.setMoreBoxesFor(fieldName);
      subInfo.setJumpToField(fieldName);
      moreInput=true;
    }
  }
  clearErrorFields(request);
  for (int i=0; i < inputs.length; i++) {
    DCValue[] values=item.getMetadata(inputs[i].getSchema(),inputs[i].getElement(),inputs[i].getQualifier(),Item.ANY);
    if (inputs[i].isRequired() && values.length == 0) {
      addErrorField(request,getFieldName(inputs[i]));
    }
  }
  subInfo.getSubmissionItem().update();
  context.commit();
  if (moreInput) {
    return STATUS_MORE_INPUT_REQUESTED;
  }
 else   if (getErrorFields(request) != null && getErrorFields(request).size() > 0) {
    return STATUS_MISSING_REQUIRED_FIELDS;
  }
  return STATUS_COMPLETE;
}","/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  int currentPage=getCurrentPage(request);
  Collection c=subInfo.getSubmissionItem().getCollection();
  DCInput[] inputs=inputsReader.getInputs(c.getHandle()).getPageRows(currentPage - 1,subInfo.getSubmissionItem().hasMultipleTitles(),subInfo.getSubmissionItem().isPublishedBefore());
  for (int i=0; i < inputs.length; i++) {
    String qualifier=inputs[i].getQualifier();
    if (qualifier == null && inputs[i].getInputType().equals(""String_Node_Str"")) {
      qualifier=Item.ANY;
    }
    item.clearMetadata(inputs[i].getSchema(),inputs[i].getElement(),qualifier,Item.ANY);
  }
  String fieldName;
  boolean moreInput=false;
  for (int j=0; j < inputs.length; j++) {
    String element=inputs[j].getElement();
    String qualifier=inputs[j].getQualifier();
    String schema=inputs[j].getSchema();
    if (qualifier != null && !qualifier.equals(Item.ANY)) {
      fieldName=schema + ""String_Node_Str"" + element+ '_'+ qualifier;
    }
 else {
      fieldName=schema + ""String_Node_Str"" + element;
    }
    String inputType=inputs[j].getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      readNames(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readDate(request,item,schema,element,qualifier);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readSeriesNumbers(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      List quals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      List vals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      for (int z=0; z < vals.size(); z++) {
        String thisQual=(String)quals.get(z);
        if (""String_Node_Str"".equals(thisQual)) {
          thisQual=null;
        }
        String thisVal=(String)vals.get(z);
        if (!buttonPressed.equals(""String_Node_Str"" + schema + ""String_Node_Str""+ element+ ""String_Node_Str""+ z) && !thisVal.equals(""String_Node_Str"")) {
          item.addMetadata(schema,element,thisQual,null,thisVal);
        }
      }
    }
 else     if (inputType.equals(""String_Node_Str"") || inputType.equals(""String_Node_Str"")) {
      String[] vals=request.getParameterValues(fieldName);
      if (vals != null) {
        for (int z=0; z < vals.length; z++) {
          if (!vals[z].equals(""String_Node_Str"")) {
            item.addMetadata(schema,element,qualifier,LANGUAGE_QUALIFIER,vals[z]);
          }
        }
      }
    }
 else     if ((inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str""))) {
      readText(request,item,schema,element,qualifier,inputs[j].getRepeatable(),LANGUAGE_QUALIFIER);
    }
 else {
      throw new ServletException(""String_Node_Str"" + fieldName + ""String_Node_Str""+ inputType);
    }
    if (!moreInput && buttonPressed.equals(""String_Node_Str"" + fieldName + ""String_Node_Str"")) {
      subInfo.setMoreBoxesFor(fieldName);
      subInfo.setJumpToField(fieldName);
      moreInput=true;
    }
  }
  if (buttonPressed.equals(NEXT_BUTTON) || buttonPressed.startsWith(PROGRESS_BAR_PREFIX)) {
    clearErrorFields(request);
    for (int i=0; i < inputs.length; i++) {
      DCValue[] values=item.getMetadata(inputs[i].getSchema(),inputs[i].getElement(),inputs[i].getQualifier(),Item.ANY);
      if (inputs[i].isRequired() && values.length == 0) {
        addErrorField(request,getFieldName(inputs[i]));
      }
    }
  }
  subInfo.getSubmissionItem().update();
  context.commit();
  if (moreInput) {
    return STATUS_MORE_INPUT_REQUESTED;
  }
 else   if (getErrorFields(request) != null && getErrorFields(request).size() > 0) {
    return STATUS_MISSING_REQUIRED_FIELDS;
  }
  return STATUS_COMPLETE;
}",0.9870993751259828
52268,"/** 
 * Decode the given string from URL transmission.
 * @param encodedString The encoded string.
 * @return The unencoded string
 */
public static String URLDecode(String encodedString) throws UIException {
  if (encodedString == null)   return null;
  try {
    return URLDecoder.decode(encodedString,Constants.DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException uee) {
    throw new UIException(uee);
  }
}","/** 
 * Decode the given string from URL transmission.
 * @param encodedString The encoded string.
 * @return The unencoded string
 */
public static String URLDecode(String encodedString) throws UIException {
  if (encodedString == null)   return null;
  try {
    if (encodedString.contains(""String_Node_Str"")) {
      encodedString=encodedString.replace(""String_Node_Str"",""String_Node_Str"");
    }
    return URLDecoder.decode(encodedString,Constants.DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException uee) {
    throw new UIException(uee);
  }
}",0.8580183861082737
52269,"/** 
 * Sends an email to the given e-person with details of new items in the given collections, items that appeared yesterday. No e-mail is sent if there aren't any new items in any of the collections.
 * @param context DSpace context object
 * @param eperson eperson to send to
 * @param collections List of collection IDs (Integers)
 * @param test 
 */
public static void sendEmail(Context context,EPerson eperson,List collections,boolean test) throws IOException, MessagingException, SQLException {
  Locale supportedLocale=I18nUtil.getEPersonLocale(eperson);
  ResourceBundle labels=ResourceBundle.getBundle(""String_Node_Str"",supportedLocale);
  Date thisTimeYesterday=new Date(System.currentTimeMillis() - (24 * 60 * 60* 1000));
  DCDate dcDateYesterday=new DCDate(thisTimeYesterday);
  String isoDateYesterday=dcDateYesterday.toString().substring(0,10);
  String startDate=isoDateYesterday;
  String endDate=isoDateYesterday + ""String_Node_Str"";
  StringBuffer emailText=new StringBuffer();
  boolean isFirst=true;
  for (int i=0; i < collections.size(); i++) {
    Collection c=(Collection)collections.get(i);
    try {
      List itemInfos=Harvest.harvest(context,c,startDate,endDate,0,0,true,false,false);
      if (ConfigurationManager.getBooleanProperty(""String_Node_Str"",false)) {
        itemInfos=filterOutModified(itemInfos);
      }
      if (itemInfos.size() > 0) {
        if (!isFirst) {
          emailText.append(""String_Node_Str"");
        }
 else {
          isFirst=false;
        }
        emailText.append(labels.getString(""String_Node_Str"")).append(c.getMetadata(""String_Node_Str"")).append(""String_Node_Str"").append(itemInfos.size()).append(""String_Node_Str"");
        for (int j=0; j < itemInfos.size(); j++) {
          HarvestedItemInfo hii=(HarvestedItemInfo)itemInfos.get(j);
          DCValue[] titles=hii.item.getDC(""String_Node_Str"",null,Item.ANY);
          emailText.append(""String_Node_Str"").append(labels.getString(""String_Node_Str"")).append(""String_Node_Str"");
          if (titles.length > 0) {
            emailText.append(titles[0].value);
          }
 else {
            emailText.append(labels.getString(""String_Node_Str""));
          }
          DCValue[] authors=hii.item.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
          if (authors.length > 0) {
            emailText.append(""String_Node_Str"").append(labels.getString(""String_Node_Str"")).append(authors[0].value);
            for (int k=1; k < authors.length; k++) {
              emailText.append(""String_Node_Str"").append(authors[k].value);
            }
          }
          emailText.append(""String_Node_Str"").append(labels.getString(""String_Node_Str"")).append(HandleManager.getCanonicalForm(hii.handle)).append(""String_Node_Str"");
        }
      }
    }
 catch (    ParseException pe) {
    }
  }
  if (emailText.length() > 0) {
    if (test) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + emailText.toString()));
    }
 else {
      Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(supportedLocale,""String_Node_Str""));
      email.addRecipient(eperson.getEmail());
      email.addArgument(emailText.toString());
      email.send();
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getID()));
    }
  }
}","/** 
 * Sends an email to the given e-person with details of new items in the given collections, items that appeared yesterday. No e-mail is sent if there aren't any new items in any of the collections.
 * @param context DSpace context object
 * @param eperson eperson to send to
 * @param collections List of collection IDs (Integers)
 * @param test 
 */
public static void sendEmail(Context context,EPerson eperson,List collections,boolean test) throws IOException, MessagingException, SQLException {
  Locale supportedLocale=I18nUtil.getEPersonLocale(eperson);
  ResourceBundle labels=ResourceBundle.getBundle(""String_Node_Str"",supportedLocale);
  Date thisTimeYesterday=new Date(System.currentTimeMillis() - (24 * 60 * 60* 1000));
  DCDate dcDateYesterday=new DCDate(thisTimeYesterday);
  String isoDateYesterday=dcDateYesterday.toString().substring(0,10);
  String startDate=isoDateYesterday;
  String endDate=isoDateYesterday + ""String_Node_Str"";
  StringBuffer emailText=new StringBuffer();
  boolean isFirst=true;
  for (int i=0; i < collections.size(); i++) {
    Collection c=(Collection)collections.get(i);
    try {
      boolean includeAll=ConfigurationManager.getBooleanProperty(""String_Node_Str"",true);
      List itemInfos=Harvest.harvest(context,c,startDate,endDate,0,0,true,false,false,includeAll);
      if (ConfigurationManager.getBooleanProperty(""String_Node_Str"",false)) {
        itemInfos=filterOutModified(itemInfos);
      }
      if (itemInfos.size() > 0) {
        if (!isFirst) {
          emailText.append(""String_Node_Str"");
        }
 else {
          isFirst=false;
        }
        emailText.append(labels.getString(""String_Node_Str"")).append(c.getMetadata(""String_Node_Str"")).append(""String_Node_Str"").append(itemInfos.size()).append(""String_Node_Str"");
        for (int j=0; j < itemInfos.size(); j++) {
          HarvestedItemInfo hii=(HarvestedItemInfo)itemInfos.get(j);
          DCValue[] titles=hii.item.getDC(""String_Node_Str"",null,Item.ANY);
          emailText.append(""String_Node_Str"").append(labels.getString(""String_Node_Str"")).append(""String_Node_Str"");
          if (titles.length > 0) {
            emailText.append(titles[0].value);
          }
 else {
            emailText.append(labels.getString(""String_Node_Str""));
          }
          DCValue[] authors=hii.item.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
          if (authors.length > 0) {
            emailText.append(""String_Node_Str"").append(labels.getString(""String_Node_Str"")).append(authors[0].value);
            for (int k=1; k < authors.length; k++) {
              emailText.append(""String_Node_Str"").append(authors[k].value);
            }
          }
          emailText.append(""String_Node_Str"").append(labels.getString(""String_Node_Str"")).append(HandleManager.getCanonicalForm(hii.handle)).append(""String_Node_Str"");
        }
      }
    }
 catch (    ParseException pe) {
    }
  }
  if (emailText.length() > 0) {
    if (test) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + emailText.toString()));
    }
 else {
      Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(supportedLocale,""String_Node_Str""));
      email.addRecipient(eperson.getEmail());
      email.addArgument(emailText.toString());
      email.send();
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getID()));
    }
  }
}",0.9854319919226886
52270,"/** 
 * Obtain information about items that have been created, modified or withdrawn within a given date range. You can also specify 'offset' and 'limit' so that a big harvest can be split up into smaller sections. <P> Note that dates are passed in the standard ISO8601 format used by DSpace (and OAI-PMH). <P> FIXME: Assumes all in_archive items have public metadata
 * @param context DSpace context
 * @param scope a Collection, Community, or <code>null</code> indicating the scope is all of DSpace
 * @param startDate start of date range, or <code>null</code>
 * @param endDate end of date range, or <code>null</code>
 * @param offset for a partial harvest, the point in the overall list of matching items to start at. 0 means just start at the beginning.
 * @param limit the number of matching items to return in a partial harvest. Specify 0 to return the whole list (or the rest of the list if an offset was specified.)
 * @param items if <code>true</code> the <code>item</code> field of each <code>HarvestedItemInfo</code> object is filled out
 * @param collections if <code>true</code> the <code>collectionHandles</code> field of each <code>HarvestedItemInfo</code> object is filled out
 * @param withdrawn If <code>true</code>, information about withdrawn items is included
 * @return List of <code>HarvestedItemInfo</code> objects
 * @throws SQLException
 * @throws ParseException If the date is not in a supported format
 */
public static List harvest(Context context,DSpaceObject scope,String startDate,String endDate,int offset,int limit,boolean items,boolean collections,boolean withdrawn) throws SQLException, ParseException {
  String query=""String_Node_Str"";
  List parameters=new ArrayList();
  if (scope != null) {
    if (scope.getType() == Constants.COLLECTION) {
      query+=""String_Node_Str"";
    }
 else     if (scope.getType() == Constants.COMMUNITY) {
      query+=""String_Node_Str"";
    }
  }
  query+=""String_Node_Str"" + Constants.ITEM + ""String_Node_Str"";
  if (scope != null) {
    if (scope.getType() == Constants.COLLECTION) {
      query+=""String_Node_Str"" + ""String_Node_Str"";
      parameters.add(new Integer(scope.getID()));
    }
 else     if (scope.getType() == Constants.COMMUNITY) {
      query+=""String_Node_Str"" + ""String_Node_Str"";
      parameters.add(new Integer(scope.getID()));
    }
  }
  if (startDate != null) {
    query=query + ""String_Node_Str"";
    parameters.add(toTimestamp(startDate,false));
  }
  if (endDate != null) {
    boolean selfGenerated=false;
    if (endDate.length() == 20) {
      endDate=endDate.substring(0,19) + ""String_Node_Str"";
      selfGenerated=true;
    }
    query+=""String_Node_Str"";
    parameters.add(toTimestamp(endDate,selfGenerated));
  }
  if (withdrawn == false) {
    if (""String_Node_Str"".equals(ConfigurationManager.getProperty(""String_Node_Str""))) {
      query+=""String_Node_Str"";
    }
 else {
      query+=""String_Node_Str"";
    }
  }
  query+=""String_Node_Str"";
  log.debug(LogManager.getHeader(context,""String_Node_Str"",query));
  Object[] parametersArray=parameters.toArray();
  TableRowIterator tri=DatabaseManager.query(context,query,parametersArray);
  List infoObjects=new LinkedList();
  int index=0;
  try {
    while (tri.hasNext()) {
      TableRow row=tri.next();
      if ((index >= offset) && ((limit == 0) || (index < (offset + limit)))) {
        HarvestedItemInfo itemInfo=new HarvestedItemInfo();
        itemInfo.context=context;
        itemInfo.handle=row.getStringColumn(""String_Node_Str"");
        itemInfo.itemID=row.getIntColumn(""String_Node_Str"");
        itemInfo.datestamp=row.getDateColumn(""String_Node_Str"");
        itemInfo.withdrawn=row.getBooleanColumn(""String_Node_Str"");
        if (collections) {
          fillCollections(context,itemInfo);
        }
        if (items) {
          itemInfo.item=Item.find(context,itemInfo.itemID);
        }
        infoObjects.add(itemInfo);
      }
      index++;
    }
  }
  finally {
    if (tri != null)     tri.close();
  }
  return infoObjects;
}","/** 
 * Obtain information about items that have been created, modified or withdrawn within a given date range. You can also specify 'offset' and 'limit' so that a big harvest can be split up into smaller sections. <P> Note that dates are passed in the standard ISO8601 format used by DSpace (and OAI-PMH). <P> FIXME: Assumes all in_archive items have public metadata
 * @param context DSpace context
 * @param scope a Collection, Community, or <code>null</code> indicating the scope is all of DSpace
 * @param startDate start of date range, or <code>null</code>
 * @param endDate end of date range, or <code>null</code>
 * @param offset for a partial harvest, the point in the overall list of matching items to start at. 0 means just start at the beginning.
 * @param limit the number of matching items to return in a partial harvest. Specify 0 to return the whole list (or the rest of the list if an offset was specified.)
 * @param items if <code>true</code> the <code>item</code> field of each <code>HarvestedItemInfo</code> object is filled out
 * @param collections if <code>true</code> the <code>collectionHandles</code> field of each <code>HarvestedItemInfo</code> object is filled out
 * @param withdrawn If <code>true</code>, information about withdrawn items is included
 * @param nonAnon If items without anonymous access should be included or not
 * @return List of <code>HarvestedItemInfo</code> objects
 * @throws SQLException
 * @throws ParseException If the date is not in a supported format
 */
public static List harvest(Context context,DSpaceObject scope,String startDate,String endDate,int offset,int limit,boolean items,boolean collections,boolean withdrawn,boolean nonAnon) throws SQLException, ParseException {
  String query=""String_Node_Str"";
  List parameters=new ArrayList();
  if (scope != null) {
    if (scope.getType() == Constants.COLLECTION) {
      query+=""String_Node_Str"";
    }
 else     if (scope.getType() == Constants.COMMUNITY) {
      query+=""String_Node_Str"";
    }
  }
  query+=""String_Node_Str"" + Constants.ITEM + ""String_Node_Str"";
  if (scope != null) {
    if (scope.getType() == Constants.COLLECTION) {
      query+=""String_Node_Str"" + ""String_Node_Str"";
      parameters.add(new Integer(scope.getID()));
    }
 else     if (scope.getType() == Constants.COMMUNITY) {
      query+=""String_Node_Str"" + ""String_Node_Str"";
      parameters.add(new Integer(scope.getID()));
    }
  }
  if (startDate != null) {
    query=query + ""String_Node_Str"";
    parameters.add(toTimestamp(startDate,false));
  }
  if (endDate != null) {
    boolean selfGenerated=false;
    if (endDate.length() == 20) {
      endDate=endDate.substring(0,19) + ""String_Node_Str"";
      selfGenerated=true;
    }
    query+=""String_Node_Str"";
    parameters.add(toTimestamp(endDate,selfGenerated));
  }
  if (withdrawn == false) {
    if (""String_Node_Str"".equals(ConfigurationManager.getProperty(""String_Node_Str""))) {
      query+=""String_Node_Str"";
    }
 else {
      query+=""String_Node_Str"";
    }
  }
  query+=""String_Node_Str"";
  log.debug(LogManager.getHeader(context,""String_Node_Str"",query));
  Object[] parametersArray=parameters.toArray();
  TableRowIterator tri=DatabaseManager.query(context,query,parametersArray);
  List infoObjects=new LinkedList();
  int index=0;
  try {
    while (tri.hasNext()) {
      TableRow row=tri.next();
      if ((index >= offset) && ((limit == 0) || (index < (offset + limit)))) {
        HarvestedItemInfo itemInfo=new HarvestedItemInfo();
        itemInfo.context=context;
        itemInfo.handle=row.getStringColumn(""String_Node_Str"");
        itemInfo.itemID=row.getIntColumn(""String_Node_Str"");
        itemInfo.datestamp=row.getDateColumn(""String_Node_Str"");
        itemInfo.withdrawn=row.getBooleanColumn(""String_Node_Str"");
        if (collections) {
          fillCollections(context,itemInfo);
        }
        if (items) {
          itemInfo.item=Item.find(context,itemInfo.itemID);
        }
        if (nonAnon) {
          infoObjects.add(itemInfo);
        }
 else {
          Group[] authorizedGroups=AuthorizeManager.getAuthorizedGroups(context,itemInfo.item,Constants.READ);
          boolean added=false;
          for (int i=0; i < authorizedGroups.length; i++) {
            if ((authorizedGroups[i].getID() == 0) && (!added)) {
              infoObjects.add(itemInfo);
              added=true;
            }
          }
        }
      }
      index++;
    }
  }
  finally {
    if (tri != null)     tri.close();
  }
  return infoObjects;
}",0.9405847953216374
52271,"private boolean itemsChanged(Context context,DSpaceObject dso,long timeStamp) throws SQLException {
  DCDate dcStartDate=new DCDate(new Date(timeStamp));
  DCDate dcEndDate=new DCDate(new Date(System.currentTimeMillis()));
  String startDate=dcStartDate.toString().substring(0,10);
  String endDate=dcEndDate.toString().substring(0,10);
  try {
    return (Harvest.harvest(context,dso,startDate,endDate,0,1,false,false,false).size() > 0);
  }
 catch (  ParseException pe) {
    return false;
  }
}","private boolean itemsChanged(Context context,DSpaceObject dso,long timeStamp) throws SQLException {
  DCDate dcStartDate=new DCDate(new Date(timeStamp));
  DCDate dcEndDate=new DCDate(new Date(System.currentTimeMillis()));
  String startDate=dcStartDate.toString().substring(0,10);
  String endDate=dcEndDate.toString().substring(0,10);
  try {
    boolean includeAll=ConfigurationManager.getBooleanProperty(""String_Node_Str"",true);
    return (Harvest.harvest(context,dso,startDate,endDate,0,1,false,false,false,includeAll).size() > 0);
  }
 catch (  ParseException pe) {
    return false;
  }
}",0.909423604757548
52272,"/** 
 * Method to do the actual harvest of records
 * @param from OAI 'from' parameter
 * @param until OAI 'until' parameter
 * @param set OAI 'set' parameter
 * @param metadataPrefix OAI 'metadataPrefix' parameter
 * @param offset where to start this harvest
 * @return the Map for listRecords to return, or null if the metadataPrefixis invalid
 */
private Map doRecordHarvest(String from,String until,String set,String metadataPrefix,int offset) throws OAIInternalServerError, BadArgumentException {
  Context context=null;
  String schemaURL=getCrosswalks().getSchemaURL(metadataPrefix);
  Map results=new HashMap();
  if (schemaURL == null) {
    return null;
  }
  List records=new LinkedList();
  try {
    context=new Context();
    DSpaceObject scope=resolveSet(context,set);
    List itemInfos=Harvest.harvest(context,scope,from,until,offset,MAX_RECORDS,true,true,true);
    Iterator i=itemInfos.iterator();
    while (i.hasNext()) {
      HarvestedItemInfo itemInfo=(HarvestedItemInfo)i.next();
      try {
        String recordXML=getRecordFactory().create(itemInfo,schemaURL,metadataPrefix);
        records.add(recordXML);
      }
 catch (      CannotDisseminateFormatException cdfe) {
        if (log.isDebugEnabled()) {
          log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + metadataPrefix + ""String_Node_Str""+ itemInfo.handle));
        }
      }
    }
    results.put(""String_Node_Str"",records.iterator());
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + records.size()));
    if (records.size() >= MAX_RECORDS) {
      String resumptionToken=makeResumptionToken(from,until,set,metadataPrefix,offset + MAX_RECORDS);
      if (log.isDebugEnabled()) {
        log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + resumptionToken));
      }
      results.put(""String_Node_Str"",getResumptionMap(resumptionToken));
    }
  }
 catch (  SQLException se) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),se);
    throw new OAIInternalServerError(se.toString());
  }
catch (  ParseException pe) {
    throw new OAIInternalServerError(pe.toString());
  }
 finally {
    if (context != null) {
      context.abort();
    }
  }
  return results;
}","/** 
 * Method to do the actual harvest of records
 * @param from OAI 'from' parameter
 * @param until OAI 'until' parameter
 * @param set OAI 'set' parameter
 * @param metadataPrefix OAI 'metadataPrefix' parameter
 * @param offset where to start this harvest
 * @return the Map for listRecords to return, or null if the metadataPrefixis invalid
 */
private Map doRecordHarvest(String from,String until,String set,String metadataPrefix,int offset) throws OAIInternalServerError, BadArgumentException {
  Context context=null;
  String schemaURL=getCrosswalks().getSchemaURL(metadataPrefix);
  Map results=new HashMap();
  if (schemaURL == null) {
    return null;
  }
  List records=new LinkedList();
  try {
    context=new Context();
    DSpaceObject scope=resolveSet(context,set);
    boolean includeAll=ConfigurationManager.getBooleanProperty(""String_Node_Str"",true);
    List itemInfos=Harvest.harvest(context,scope,from,until,offset,MAX_RECORDS,true,true,true,includeAll);
    Iterator i=itemInfos.iterator();
    while (i.hasNext()) {
      HarvestedItemInfo itemInfo=(HarvestedItemInfo)i.next();
      try {
        String recordXML=getRecordFactory().create(itemInfo,schemaURL,metadataPrefix);
        records.add(recordXML);
      }
 catch (      CannotDisseminateFormatException cdfe) {
        if (log.isDebugEnabled()) {
          log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + metadataPrefix + ""String_Node_Str""+ itemInfo.handle));
        }
      }
    }
    results.put(""String_Node_Str"",records.iterator());
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + records.size()));
    if (records.size() >= MAX_RECORDS) {
      String resumptionToken=makeResumptionToken(from,until,set,metadataPrefix,offset + MAX_RECORDS);
      if (log.isDebugEnabled()) {
        log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + resumptionToken));
      }
      results.put(""String_Node_Str"",getResumptionMap(resumptionToken));
    }
  }
 catch (  SQLException se) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),se);
    throw new OAIInternalServerError(se.toString());
  }
catch (  ParseException pe) {
    throw new OAIInternalServerError(pe.toString());
  }
 finally {
    if (context != null) {
      context.abort();
    }
  }
  return results;
}",0.9786775791514108
52273,"/** 
 * output the report block based on the passed mapping, where the mapping sould be ""name of report element"" => ""value"", where both sides of the mapping should be Strings.  This class also assumes that the reference is a linkable URL to the resource
 * @param content     the statistic object array to be displayed
 * @return              a string containing the statistics block HTML formatted
 */
public String statBlock(Statistics content){
  StringBuffer frag=new StringBuffer();
  Stat[] stats=content.getStats();
  frag.append(""String_Node_Str"");
  if (content.getStatName() != null || content.getResultName() != null) {
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
    if (content.getStatName() != null) {
      frag.append(""String_Node_Str"" + content.getStatName() + ""String_Node_Str"");
    }
 else {
      frag.append(""String_Node_Str"");
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
    if (content.getResultName() != null) {
      frag.append(""String_Node_Str"" + content.getResultName() + ""String_Node_Str"");
    }
 else {
      frag.append(""String_Node_Str"");
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
  }
  for (int i=0; i < stats.length; i++) {
    String style=null;
    if ((i % 2) == 1) {
      style=""String_Node_Str"";
    }
 else {
      style=""String_Node_Str"";
    }
    frag.append(""String_Node_Str"" + style + ""String_Node_Str"");
    frag.append(""String_Node_Str"");
    if (stats[i].getReference() != null) {
      frag.append(""String_Node_Str"" + stats[i].getReference() + ""String_Node_Str"");
      frag.append(""String_Node_Str"");
    }
    frag.append(stats[i].getKey());
    if (stats[i].getReference() != null) {
      frag.append(""String_Node_Str"");
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"" + ReportTools.numberFormat(stats[i].getValue()));
    if (stats[i].getUnits() != null) {
      frag.append(""String_Node_Str"" + stats[i].getUnits());
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
  }
  frag.append(""String_Node_Str"");
  return frag.toString();
}","/** 
 * output the report block based on the passed mapping, where the mapping sould be ""name of report element"" => ""value"", where both sides of the mapping should be Strings.  This class also assumes that the reference is a linkable URL to the resource
 * @param content     the statistic object array to be displayed
 * @return              a string containing the statistics block HTML formatted
 */
public String statBlock(Statistics content){
  StringBuffer frag=new StringBuffer();
  Stat[] stats=content.getStats();
  frag.append(""String_Node_Str"");
  if (content.getStatName() != null || content.getResultName() != null) {
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
    if (content.getStatName() != null) {
      frag.append(""String_Node_Str"" + content.getStatName() + ""String_Node_Str"");
    }
 else {
      frag.append(""String_Node_Str"");
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
    if (content.getResultName() != null) {
      frag.append(""String_Node_Str"" + content.getResultName() + ""String_Node_Str"");
    }
 else {
      frag.append(""String_Node_Str"");
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
  }
  for (int i=0; i < stats.length; i++) {
    String style=null;
    if ((i % 2) == 1) {
      style=""String_Node_Str"";
    }
 else {
      style=""String_Node_Str"";
    }
    frag.append(""String_Node_Str"" + style + ""String_Node_Str"");
    frag.append(""String_Node_Str"");
    if (stats[i].getReference() != null) {
      frag.append(""String_Node_Str"" + stats[i].getReference() + ""String_Node_Str"");
      frag.append(""String_Node_Str"");
    }
    frag.append(this.clean(stats[i].getKey()));
    if (stats[i].getReference() != null) {
      frag.append(""String_Node_Str"");
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"" + ReportTools.numberFormat(stats[i].getValue()));
    if (stats[i].getUnits() != null) {
      frag.append(""String_Node_Str"" + stats[i].getUnits());
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
  }
  frag.append(""String_Node_Str"");
  return frag.toString();
}",0.997254004576659
52274,"/** 
 * Determine which type of adatper to use for this object, either a community, collection, item, or repository adatpter. The decisios is based upon the two supplied identifiers: a handle or an internal id. If the handle is supplied then this is resolved and the approprate adapter is picked. Otherwise the internal identifier is used to resolve the correct type of adapter. The internal identifier must be of the form ""type:id"" i.g. item:255 or collection:99. In the case of a repository the handle prefix must be used.
 * @return Return the correct adaptor or null if none found.
 */
private AbstractAdapter resolveAdapter(Context context) throws SQLException {
  try {
    Request request=ObjectModelHelper.getRequest(objectModel);
    String contextPath=request.getContextPath();
    String uri=parameters.getParameter(""String_Node_Str"",null);
    String internal=parameters.getParameter(""String_Node_Str"",null);
    AbstractAdapter adapter=null;
    if (uri != null) {
      ResolvableIdentifier ri=IdentifierService.resolve(context,uri);
      DSpaceObject dso=(DSpaceObject)IdentifierService.getResource(context,ri);
      if (dso instanceof Item)       adapter=new ItemAdapter((Item)dso,contextPath);
 else       if (dso instanceof Collection || dso instanceof Community)       adapter=new ContainerAdapter(context,dso,contextPath);
    }
 else     if (internal != null) {
      String[] parts=internal.split(""String_Node_Str"");
      if (parts.length == 2) {
        String type=parts[0];
        int id=Integer.valueOf(parts[1]);
        if (""String_Node_Str"".equals(type)) {
          Item item=Item.find(context,id);
          if (item != null)           adapter=new ItemAdapter(item,contextPath);
        }
 else         if (""String_Node_Str"".equals(type)) {
          Collection collection=Collection.find(context,id);
          if (collection != null)           adapter=new ContainerAdapter(context,collection,contextPath);
        }
 else         if (""String_Node_Str"".equals(type)) {
          Community community=Community.find(context,id);
          if (community != null)           adapter=new ContainerAdapter(context,community,contextPath);
        }
 else         if (""String_Node_Str"".equals(type)) {
          if (ConfigurationManager.getProperty(""String_Node_Str"").equals(id))           adapter=new RepositoryAdapter(context,contextPath);
        }
      }
    }
    return adapter;
  }
 catch (  IdentifierException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Determine which type of adatper to use for this object, either a community, collection, item, or repository adatpter. The decisios is based upon the two supplied identifiers: a handle or an internal id. If the handle is supplied then this is resolved and the approprate adapter is picked. Otherwise the internal identifier is used to resolve the correct type of adapter. The internal identifier must be of the form ""type:id"" i.g. item:255 or collection:99. In the case of a repository the handle prefix must be used.
 * @return Return the correct adaptor or null if none found.
 */
private AbstractAdapter resolveAdapter(Context context) throws SQLException {
  try {
    Request request=ObjectModelHelper.getRequest(objectModel);
    String contextPath=request.getContextPath();
    String uri=parameters.getParameter(""String_Node_Str"",null);
    String internal=parameters.getParameter(""String_Node_Str"",null);
    AbstractAdapter adapter=null;
    if (uri != null) {
      ResolvableIdentifier ri=IdentifierService.resolve(context,uri);
      DSpaceObject dso=(DSpaceObject)IdentifierService.getResource(context,ri);
      if (dso instanceof Item)       adapter=new ItemAdapter((Item)dso,contextPath);
 else       if (dso instanceof Collection || dso instanceof Community)       adapter=new ContainerAdapter(context,dso,contextPath);
    }
 else     if (internal != null) {
      String[] parts=internal.split(""String_Node_Str"");
      if (parts.length == 2) {
        String type=parts[0];
        int id=Integer.valueOf(parts[1]);
        if (""String_Node_Str"".equals(type)) {
          Item item=Item.find(context,id);
          if (item != null)           adapter=new ItemAdapter(item,contextPath);
        }
 else         if (""String_Node_Str"".equals(type)) {
          Collection collection=Collection.find(context,id);
          if (collection != null)           adapter=new ContainerAdapter(context,collection,contextPath);
        }
 else         if (""String_Node_Str"".equals(type)) {
          Community community=Community.find(context,id);
          if (community != null)           adapter=new ContainerAdapter(context,community,contextPath);
        }
 else         if (""String_Node_Str"".equals(type)) {
          if (ConfigurationManager.getProperty(""String_Node_Str"").equals(String.valueOf(id)))           adapter=new RepositoryAdapter(context,contextPath);
        }
      }
    }
    return adapter;
  }
 catch (  IdentifierException e) {
    throw new RuntimeException(e);
  }
}",0.996
52275,"/** 
 * Determine which type of adatper to use for this object, either a community, collection, item, or repository adatpter. The decisios is based upon the two supplied identifiers: a handle or an internal id. If the handle is supplied then this is resolved and the approprate adapter is picked. Otherwise the internal identifier is used to resolve the correct type of adapter. The internal identifier must be of the form ""type:id"" i.g. item:255 or collection:99. In the case of a repository the handle prefix must be used.
 * @return Return the correct adaptor or null if none found.
 */
private AbstractAdapter resolveAdapter(Context context) throws SQLException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String contextPath=request.getContextPath();
  String handle=parameters.getParameter(""String_Node_Str"",null);
  String internal=parameters.getParameter(""String_Node_Str"",null);
  AbstractAdapter adapter=null;
  if (handle != null) {
    DSpaceObject dso=HandleManager.resolveToObject(context,handle);
    if (dso instanceof Item)     adapter=new ItemAdapter((Item)dso,contextPath);
 else     if (dso instanceof Collection || dso instanceof Community)     adapter=new ContainerAdapter(context,dso,contextPath);
  }
 else   if (internal != null) {
    String[] parts=internal.split(""String_Node_Str"");
    if (parts.length == 2) {
      String type=parts[0];
      int id=Integer.valueOf(parts[1]);
      if (""String_Node_Str"".equals(type)) {
        Item item=Item.find(context,id);
        if (item != null)         adapter=new ItemAdapter(item,contextPath);
      }
 else       if (""String_Node_Str"".equals(type)) {
        Collection collection=Collection.find(context,id);
        if (collection != null)         adapter=new ContainerAdapter(context,collection,contextPath);
      }
 else       if (""String_Node_Str"".equals(type)) {
        Community community=Community.find(context,id);
        if (community != null)         adapter=new ContainerAdapter(context,community,contextPath);
      }
 else       if (""String_Node_Str"".equals(type)) {
        if (ConfigurationManager.getProperty(""String_Node_Str"").equals(id))         adapter=new RepositoryAdapter(context,contextPath);
      }
    }
  }
  return adapter;
}","/** 
 * Determine which type of adatper to use for this object, either a community, collection, item, or repository adatpter. The decisios is based upon the two supplied identifiers: a handle or an internal id. If the handle is supplied then this is resolved and the approprate adapter is picked. Otherwise the internal identifier is used to resolve the correct type of adapter. The internal identifier must be of the form ""type:id"" i.g. item:255 or collection:99. In the case of a repository the handle prefix must be used.
 * @return Return the correct adaptor or null if none found.
 */
private AbstractAdapter resolveAdapter(Context context) throws SQLException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String contextPath=request.getContextPath();
  String handle=parameters.getParameter(""String_Node_Str"",null);
  String internal=parameters.getParameter(""String_Node_Str"",null);
  AbstractAdapter adapter=null;
  if (handle != null) {
    DSpaceObject dso=HandleManager.resolveToObject(context,handle);
    if (dso instanceof Item)     adapter=new ItemAdapter((Item)dso,contextPath);
 else     if (dso instanceof Collection || dso instanceof Community)     adapter=new ContainerAdapter(context,dso,contextPath);
  }
 else   if (internal != null) {
    String[] parts=internal.split(""String_Node_Str"");
    if (parts.length == 2) {
      String type=parts[0];
      int id=Integer.valueOf(parts[1]);
      if (""String_Node_Str"".equals(type)) {
        Item item=Item.find(context,id);
        if (item != null)         adapter=new ItemAdapter(item,contextPath);
      }
 else       if (""String_Node_Str"".equals(type)) {
        Collection collection=Collection.find(context,id);
        if (collection != null)         adapter=new ContainerAdapter(context,collection,contextPath);
      }
 else       if (""String_Node_Str"".equals(type)) {
        Community community=Community.find(context,id);
        if (community != null)         adapter=new ContainerAdapter(context,community,contextPath);
      }
 else       if (""String_Node_Str"".equals(type)) {
        if (ConfigurationManager.getProperty(""String_Node_Str"").equals(String.valueOf(id)))         adapter=new RepositoryAdapter(context,contextPath);
      }
    }
  }
  return adapter;
}",0.995579133510168
52276,"public boolean canDisseminate(DSpaceObject dso){
  return true;
}","public boolean canDisseminate(DSpaceObject dso){
  if (dso.getType() == Constants.BITSTREAM)   return true;
 else   return false;
}",0.6632653061224489
52277,"public boolean canDisseminate(DSpaceObject dso){
  return true;
}","public boolean canDisseminate(DSpaceObject dso){
  if (dso.getType() == Constants.BITSTREAM)   return true;
 else   return false;
}",0.6632653061224489
52278,"/** 
 * add group to this group
 * @param g
 */
public void addMember(Group g){
  loadData();
  if (isMember(g)) {
    return;
  }
  groups.add(g);
  groupsChanged=true;
  myContext.addEvent(new Event(Event.ADD,Constants.GROUP,getID(),Constants.GROUP,g.getID(),g.getName()));
}","/** 
 * add group to this group
 * @param g
 */
public void addMember(Group g){
  loadData();
  if (isMember(g) || getID() == g.getID()) {
    return;
  }
  groups.add(g);
  groupsChanged=true;
  myContext.addEvent(new Event(Event.ADD,Constants.GROUP,getID(),Constants.GROUP,g.getID(),g.getName()));
}",0.9584775086505192
52279,"/** 
 * Close the context, without committing any of the changes performed using this context. The database connection is freed. No exception is thrown if there is an error freeing the database connection, since this method may be called as part of an error-handling routine where an SQLException has already been thrown.
 */
public void abort(){
  try {
    connection.rollback();
  }
 catch (  SQLException se) {
    log.error(se.getMessage());
    se.printStackTrace();
  }
 finally {
    DatabaseManager.freeConnection(connection);
    connection=null;
    events=null;
  }
}","/** 
 * Close the context, without committing any of the changes performed using this context. The database connection is freed. No exception is thrown if there is an error freeing the database connection, since this method may be called as part of an error-handling routine where an SQLException has already been thrown.
 */
public void abort(){
  try {
    if (!connection.isClosed())     connection.rollback();
  }
 catch (  SQLException se) {
    log.error(se.getMessage());
    se.printStackTrace();
  }
 finally {
    try {
      if (!connection.isClosed())       DatabaseManager.freeConnection(connection);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
    }
    connection=null;
    events=null;
  }
}",0.8880368098159509
52280,"static String checkEmptyQuery(String myquery){
  if (myquery.equals(""String_Node_Str"")) {
    myquery=""String_Node_Str"";
  }
  return myquery;
}","static String checkEmptyQuery(String myquery){
  if (myquery == null || myquery.equals(""String_Node_Str"") || myquery.equals(""String_Node_Str"")) {
    myquery=""String_Node_Str"";
  }
  return myquery;
}",0.7441860465116279
52281,"/** 
 * Set the DSpace context to use
 * @param context
 */
public void setContext(Context context){
  this.context=context;
}","/** 
 * Set the DSpace context to use
 * @param context the context
 */
public void setContext(Context context){
  this.context=context;
}",0.9545454545454546
52282,"public int[] getSpecialGroups(Context context,HttpServletRequest request){
  if ((context.getCurrentUser() != null) && (!context.getCurrentUser().getNetid().equals(""String_Node_Str""))) {
    if (ldapGroup == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
      return new int[0];
    }
 else {
      return new int[]{ldapGroup.getID()};
    }
  }
  return new int[0];
}","public int[] getSpecialGroups(Context context,HttpServletRequest request){
  try {
    if (!context.getCurrentUser().getNetid().equals(""String_Node_Str"")) {
      if (ldapGroup == null) {
        log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
        return new int[0];
      }
 else {
        return new int[]{ldapGroup.getID()};
      }
    }
  }
 catch (  NullPointerException npe) {
  }
  return new int[0];
}",0.8364485981308412
52283,"/** 
 * Generate the validity for this cached entry
 * @return
 */
public SourceValidity getValidity(){
  if (validity == null) {
    try {
      initialise();
      boolean showReport=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
      if (!showReport) {
        try {
          showReport=AuthorizeManager.isAdmin(context);
        }
 catch (        SQLException sqle) {
          log.error(""String_Node_Str"",sqle);
        }
      }
      if (showReport) {
        File analysisFile=null;
        if (reportDate != null)         analysisFile=StatisticsLoader.getAnalysisFor(reportDate);
 else         analysisFile=StatisticsLoader.getGeneralAnalysis();
        if (analysisFile != null) {
          DSpaceValidity newValidity=new DSpaceValidity();
          newValidity.add(Long.toString(analysisFile.lastModified()));
          newValidity.add(""String_Node_Str"");
          newValidity.add(Long.toString(analysisFile.length()));
          validity=newValidity.complete();
        }
      }
    }
 catch (    Exception e) {
    }
  }
  return validity;
}","/** 
 * Generate the validity for this cached entry
 * @return
 */
public SourceValidity getValidity(){
  if (validity == null) {
    try {
      initialise();
      boolean showReport=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
      if (!showReport) {
        showReport=AuthorizeManager.isAdmin(context);
      }
      if (showReport) {
        File analysisFile=null;
        if (reportDate != null)         analysisFile=StatisticsLoader.getAnalysisFor(reportDate);
 else         analysisFile=StatisticsLoader.getGeneralAnalysis();
        if (analysisFile != null) {
          DSpaceValidity newValidity=new DSpaceValidity();
          newValidity.add(Long.toString(analysisFile.lastModified()));
          newValidity.add(""String_Node_Str"");
          newValidity.add(Long.toString(analysisFile.length()));
          validity=newValidity.complete();
        }
      }
    }
 catch (    Exception e) {
    }
  }
  return validity;
}",0.3685770750988142
52284,"/** 
 * Attempt to authenticate the user. 
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String email=request.getParameter(""String_Node_Str"");
  String password=request.getParameter(""String_Node_Str"");
  String realm=request.getParameter(""String_Node_Str"");
  if (email == null)   email=""String_Node_Str"";
  if (password == null)   password=""String_Node_Str"";
  try {
    Context context=AuthenticationUtil.Authenticate(objectModel,email,password,realm);
    EPerson eperson=context.getCurrentUser();
    if (eperson != null) {
      String redirectURL=request.getContextPath();
      if (AuthenticationUtil.isInterupptedRequest(objectModel)) {
        redirectURL+=AuthenticationUtil.resumeInterruptedRequest(objectModel);
      }
 else {
        String loginRedirect=ConfigurationManager.getProperty(""String_Node_Str"");
        redirectURL+=(loginRedirect != null) ? loginRedirect.trim() : ""String_Node_Str"";
      }
      final HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
      httpResponse.sendRedirect(redirectURL);
      context.setCurrentUser(null);
      return new HashMap();
    }
  }
 catch (  SQLException sqle) {
    throw new PatternException(""String_Node_Str"",sqle);
  }
  return null;
}","/** 
 * Attempt to authenticate the user. 
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String email=request.getParameter(""String_Node_Str"");
  String password=request.getParameter(""String_Node_Str"");
  String realm=request.getParameter(""String_Node_Str"");
  if ((email == null) || (password == null)) {
    return null;
  }
  try {
    Context context=AuthenticationUtil.Authenticate(objectModel,email,password,realm);
    EPerson eperson=context.getCurrentUser();
    if (eperson != null) {
      String redirectURL=request.getContextPath();
      if (AuthenticationUtil.isInterupptedRequest(objectModel)) {
        redirectURL+=AuthenticationUtil.resumeInterruptedRequest(objectModel);
      }
 else {
        String loginRedirect=ConfigurationManager.getProperty(""String_Node_Str"");
        redirectURL+=(loginRedirect != null) ? loginRedirect.trim() : ""String_Node_Str"";
      }
      final HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
      httpResponse.sendRedirect(redirectURL);
      context.setCurrentUser(null);
      return new HashMap();
    }
  }
 catch (  SQLException sqle) {
    throw new PatternException(""String_Node_Str"",sqle);
  }
  return null;
}",0.9686609686609686
52285,"protected String getDNOfUser(String adminUser,String adminPassword,Context context,String netid){
  String resultDN;
  int ldap_search_scope_value=0;
  try {
    ldap_search_scope_value=Integer.parseInt(ldap_search_scope.trim());
  }
 catch (  Exception e) {
    if (ldap_search_scope != null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + ldap_search_scope));
    }
  }
  Hashtable env=new Hashtable(11);
  env.put(javax.naming.Context.INITIAL_CONTEXT_FACTORY,""String_Node_Str"");
  env.put(javax.naming.Context.PROVIDER_URL,ldap_provider_url);
  env.put(javax.naming.Context.SECURITY_AUTHENTICATION,""String_Node_Str"");
  env.put(javax.naming.Context.SECURITY_PRINCIPAL,adminUser);
  env.put(javax.naming.Context.SECURITY_CREDENTIALS,adminPassword);
  DirContext ctx=null;
  try {
    ctx=new InitialDirContext(env);
    Attributes matchAttrs=new BasicAttributes(true);
    matchAttrs.put(new BasicAttribute(ldap_id_field,netid));
    try {
      SearchControls ctrls=new SearchControls();
      ctrls.setSearchScope(ldap_search_scope_value);
      NamingEnumeration<SearchResult> answer=ctx.search(ldap_provider_url + ldap_search_context,""String_Node_Str"",new Object[]{ldap_id_field,netid},ctrls);
      while (answer.hasMoreElements()) {
        SearchResult sr=answer.next();
        resultDN=(sr.getName() + ""String_Node_Str"" + ldap_search_context);
        String attlist[]={ldap_email_field,ldap_givenname_field,ldap_surname_field,ldap_phone_field};
        Attributes atts=sr.getAttributes();
        Attribute att;
        if (attlist[0] != null) {
          att=atts.get(attlist[0]);
          if (att != null)           ldapEmail=(String)att.get();
        }
        if (attlist[1] != null) {
          att=atts.get(attlist[1]);
          if (att != null)           ldapGivenName=(String)att.get();
        }
        if (attlist[2] != null) {
          att=atts.get(attlist[2]);
          if (att != null)           ldapSurname=(String)att.get();
        }
        if (attlist[3] != null) {
          att=atts.get(attlist[3]);
          if (att != null)           ldapPhone=(String)att.get();
        }
        if (answer.hasMoreElements()) {
        }
 else {
          log.warn(LogManager.getHeader(context,""String_Node_Str"",resultDN));
          return resultDN;
        }
      }
    }
 catch (    NamingException e) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + e));
    }
  }
 catch (  NamingException e) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + e));
  }
 finally {
    try {
      if (ctx != null)       ctx.close();
    }
 catch (    NamingException e) {
    }
  }
  return null;
}","protected String getDNOfUser(String adminUser,String adminPassword,Context context,String netid){
  String resultDN;
  int ldap_search_scope_value=0;
  try {
    ldap_search_scope_value=Integer.parseInt(ldap_search_scope.trim());
  }
 catch (  Exception e) {
    if (ldap_search_scope != null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + ldap_search_scope));
    }
  }
  Hashtable env=new Hashtable(11);
  env.put(javax.naming.Context.INITIAL_CONTEXT_FACTORY,""String_Node_Str"");
  env.put(javax.naming.Context.PROVIDER_URL,ldap_provider_url);
  env.put(javax.naming.Context.SECURITY_AUTHENTICATION,""String_Node_Str"");
  env.put(javax.naming.Context.SECURITY_PRINCIPAL,adminUser);
  env.put(javax.naming.Context.SECURITY_CREDENTIALS,adminPassword);
  DirContext ctx=null;
  try {
    ctx=new InitialDirContext(env);
    Attributes matchAttrs=new BasicAttributes(true);
    matchAttrs.put(new BasicAttribute(ldap_id_field,netid));
    try {
      SearchControls ctrls=new SearchControls();
      ctrls.setSearchScope(ldap_search_scope_value);
      NamingEnumeration<SearchResult> answer=ctx.search(ldap_provider_url + ldap_search_context,""String_Node_Str"",new Object[]{ldap_id_field,netid},ctrls);
      while (answer.hasMoreElements()) {
        SearchResult sr=answer.next();
        resultDN=(sr.getName() + ""String_Node_Str"" + ldap_search_context);
        String attlist[]={ldap_email_field,ldap_givenname_field,ldap_surname_field,ldap_phone_field};
        Attributes atts=sr.getAttributes();
        Attribute att;
        if (attlist[0] != null) {
          att=atts.get(attlist[0]);
          if (att != null)           ldapEmail=(String)att.get();
        }
        if (attlist[1] != null) {
          att=atts.get(attlist[1]);
          if (att != null)           ldapGivenName=(String)att.get();
        }
        if (attlist[2] != null) {
          att=atts.get(attlist[2]);
          if (att != null)           ldapSurname=(String)att.get();
        }
        if (attlist[3] != null) {
          att=atts.get(attlist[3]);
          if (att != null)           ldapPhone=(String)att.get();
        }
        if (answer.hasMoreElements()) {
        }
 else {
          log.debug(LogManager.getHeader(context,""String_Node_Str"",resultDN));
          return resultDN;
        }
      }
    }
 catch (    NamingException e) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + e));
    }
  }
 catch (  NamingException e) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + e));
  }
 finally {
    try {
      if (ctx != null)       ctx.close();
    }
 catch (    NamingException e) {
    }
  }
  return null;
}",0.9983434566537824
52286,"public int[] getSpecialGroups(Context context,HttpServletRequest request){
  try {
    if (!context.getCurrentUser().getNetid().equals(""String_Node_Str"")) {
      if (ldapGroup == null) {
        log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
        return new int[0];
      }
 else {
        return new int[]{ldapGroup.getID()};
      }
    }
  }
 catch (  NullPointerException npe) {
  }
  return new int[0];
}","public int[] getSpecialGroups(Context context,HttpServletRequest request){
  try {
    if (!context.getCurrentUser().getNetid().equals(""String_Node_Str"")) {
      String groupName=ConfigurationManager.getProperty(""String_Node_Str"");
      if ((groupName != null) && (!groupName.trim().equals(""String_Node_Str""))) {
        ldapGroup=Group.findByName(new Context(),groupName);
        if (ldapGroup == null) {
          log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          return new int[0];
        }
 else {
          return new int[]{ldapGroup.getID()};
        }
      }
    }
  }
 catch (  Exception npe) {
  }
  return new int[0];
}",0.7755834829443446
52287,"/** 
 * Add a single link to the view item page that allows the user  to submit to the collection.
 */
public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  if (!(dso instanceof Collection))   return;
  Collection collection=(Collection)dso;
  if (AuthorizeManager.authorizeActionBoolean(context,collection,Constants.ADD)) {
    Division home=body.addDivision(""String_Node_Str"",""String_Node_Str"");
    Division viewer=home.addDivision(""String_Node_Str"",""String_Node_Str"");
    String submitURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
    viewer.addPara().addXref(submitURL,""String_Node_Str"");
  }
}","/** 
 * Add a single link to the view item page that allows the user  to submit to the collection.
 */
public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  if (!(dso instanceof Collection))   return;
  Collection collection=(Collection)dso;
  if (AuthorizeManager.authorizeActionBoolean(context,collection,Constants.ADD)) {
    Division home=body.addDivision(""String_Node_Str"",""String_Node_Str"");
    Division viewer=home.addDivision(""String_Node_Str"",""String_Node_Str"");
    String submitURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
    viewer.addPara().addXref(submitURL,T_submit);
  }
}",0.9836280288146692
52288,"/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    String h=dso.getHandle();
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]+ ""String_Node_Str""+ (h == null ? ""String_Node_Str"" : h));
  }
  Item item=(Item)dso;
  String handle=item.getHandle();
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + (handle == null ? String.valueOf(dso.getID()) : handle) + ""String_Node_Str""+ originalKey);
      }
    }
 else {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      if (v.value == null) {
        e.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
 else {
        String reason=Verifier.checkCharacterData(v.value);
        if (reason == null) {
          e.setAttribute(""String_Node_Str"",v.value == null ? ""String_Node_Str"" : v.value);
        }
 else {
          log.warn(""String_Node_Str"" + reason);
          String simpleText=v.value.replaceAll(""String_Node_Str"",""String_Node_Str"");
          if (Verifier.checkCharacterData(simpleText) == null)           e.setAttribute(""String_Node_Str"",simpleText);
        }
      }
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}","/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    String h=dso.getHandle();
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]+ ""String_Node_Str""+ (h == null ? ""String_Node_Str"" : h));
  }
  Item item=(Item)dso;
  String handle=item.getHandle();
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    boolean provenance=""String_Node_Str"".equals(v.element) && ""String_Node_Str"".equals(v.qualifier);
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + (handle == null ? String.valueOf(dso.getID()) : handle) + ""String_Node_Str""+ originalKey);
      }
    }
 else     if (provenance != true) {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      if (v.value == null) {
        e.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
 else {
        String reason=Verifier.checkCharacterData(v.value);
        if (reason == null) {
          e.setAttribute(""String_Node_Str"",v.value == null ? ""String_Node_Str"" : v.value);
        }
 else {
          log.warn(""String_Node_Str"" + reason);
          String simpleText=v.value.replaceAll(""String_Node_Str"",""String_Node_Str"");
          if (Verifier.checkCharacterData(simpleText) == null)           e.setAttribute(""String_Node_Str"",simpleText);
        }
      }
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}",0.975964225824483
52289,"/** 
 * Do the beginning of a Step. First do pre-processing, then display the JSP (if there is one). If there's no JSP, just End the step immediately.
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return true if the step is completed (no JSP was loaded), falseotherwise
 */
private boolean doStepStart(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  log.debug(""String_Node_Str"" + this.getClass().getName());
  stepJSPUI.doPreProcessing(context,request,response,subInfo);
  if (!response.isCommitted()) {
    log.debug(""String_Node_Str"" + this.getClass().getName());
    int errorFlag=stepProcessing.doProcessing(context,request,response,subInfo);
    if (errorFlag != AbstractProcessingStep.STATUS_COMPLETE) {
      String errorMessage=stepProcessing.getErrorMessage(errorFlag);
      if (errorMessage == null) {
        errorMessage=""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ errorFlag+ ""String_Node_Str""+ ""String_Node_Str"";
      }
      log.error(errorMessage);
    }
    return completeStep(context,request,response,subInfo);
  }
 else   return false;
}","/** 
 * Do the beginning of a Step. First do pre-processing, then display the JSP (if there is one). If there's no JSP, just End the step immediately.
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return true if the step is completed (no JSP was loaded), falseotherwise
 */
private boolean doStepStart(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  log.debug(""String_Node_Str"" + this.getClass().getName());
  if (stepJSPUI != null)   stepJSPUI.doPreProcessing(context,request,response,subInfo);
  if (!response.isCommitted()) {
    log.debug(""String_Node_Str"" + this.getClass().getName());
    int errorFlag=stepProcessing.doProcessing(context,request,response,subInfo);
    if (errorFlag != AbstractProcessingStep.STATUS_COMPLETE) {
      String errorMessage=stepProcessing.getErrorMessage(errorFlag);
      if (errorMessage == null) {
        errorMessage=""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ errorFlag+ ""String_Node_Str""+ ""String_Node_Str"";
      }
      log.error(errorMessage);
    }
    return completeStep(context,request,response,subInfo);
  }
 else   return false;
}",0.9907851087357168
52290,"/** 
 * Initialize the current JSPStepManager object, by loading the  specified step class.
 * @param stepConfig the SubmissionStepConfig object which describes this step's configuration in the item-submission.xml
 * @throws Exception if the JSPStep cannot be loaded or the class specified doesn't implement the JSPStep interface
 */
public static JSPStepManager loadStep(SubmissionStepConfig stepConfig) throws Exception {
  JSPStepManager stepManager=new JSPStepManager();
  stepManager.stepConfig=stepConfig;
  ClassLoader loader=stepManager.getClass().getClassLoader();
  Class stepClass=loader.loadClass(stepConfig.getProcessingClassName());
  Object stepInstance=stepClass.newInstance();
  if (stepInstance instanceof AbstractProcessingStep) {
    stepManager.stepProcessing=(AbstractProcessingStep)stepClass.newInstance();
  }
 else {
    throw new Exception(""String_Node_Str"" + stepConfig.getProcessingClassName() + ""String_Node_Str""+ ""String_Node_Str"");
  }
  stepClass=loader.loadClass(stepConfig.getJSPUIClassName());
  stepInstance=stepClass.newInstance();
  if (stepInstance instanceof JSPStep) {
    stepManager.stepJSPUI=(JSPStep)stepClass.newInstance();
  }
 else {
    throw new Exception(""String_Node_Str"" + stepConfig.getJSPUIClassName() + ""String_Node_Str""+ ""String_Node_Str"");
  }
  return stepManager;
}","/** 
 * Initialize the current JSPStepManager object, by loading the  specified step class.
 * @param stepConfig the SubmissionStepConfig object which describes this step's configuration in the item-submission.xml
 * @throws Exception if the JSPStep cannot be loaded or the class specified doesn't implement the JSPStep interface
 */
public static JSPStepManager loadStep(SubmissionStepConfig stepConfig) throws Exception {
  JSPStepManager stepManager=new JSPStepManager();
  stepManager.stepConfig=stepConfig;
  ClassLoader loader=stepManager.getClass().getClassLoader();
  Class stepClass=loader.loadClass(stepConfig.getProcessingClassName());
  Object stepInstance=stepClass.newInstance();
  if (stepInstance instanceof AbstractProcessingStep) {
    stepManager.stepProcessing=(AbstractProcessingStep)stepClass.newInstance();
  }
 else {
    throw new Exception(""String_Node_Str"" + stepConfig.getProcessingClassName() + ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (stepConfig.getJSPUIClassName() != null && stepConfig.getJSPUIClassName().length() > 0) {
    stepClass=loader.loadClass(stepConfig.getJSPUIClassName());
    stepInstance=stepClass.newInstance();
    if (stepInstance instanceof JSPStep) {
      stepManager.stepJSPUI=(JSPStep)stepClass.newInstance();
    }
 else {
      throw new Exception(""String_Node_Str"" + stepConfig.getJSPUIClassName() + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  return stepManager;
}",0.9402823018458196
52291,"/** 
 * Authenticate the given username/password pair, in conjunction with the onBehalfOf user.  The rules are that the username/password pair must successfully authenticate the user, and the onBehalfOf user must exist in the user database.
 * @param un
 * @param pw
 * @param obo
 * @return	a SWORD context holding the various user information
 * @throws SWORDAuthenticationException
 * @throws SWORDException
 */
private SWORDContext authenticate(Context context,String un,String pw,String obo) throws SWORDAuthenticationException, SWORDException {
  if (""String_Node_Str"".equals(obo)) {
    obo=null;
  }
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
  SWORDContext sc=new SWORDContext();
  SWORDAuthentication auth=new SWORDAuthentication();
  EPerson ep=null;
  boolean authenticated=false;
  if (auth.authenticates(this.context,un,pw)) {
    ep=EPerson.findByEmail(context,un);
    if (ep != null) {
      authenticated=true;
      sc.setAuthenticated(ep);
    }
    if (obo != null) {
      EPerson epObo=EPerson.findByEmail(this.context,obo);
      if (epObo != null) {
        sc.setOnBehalfOf(epObo);
      }
 else {
        authenticated=false;
      }
    }
  }
  if (ep != null && authenticated) {
    this.context.setCurrentUser(ep);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + ep.getID()));
  }
 else {
    if (ep != null) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un));
      throw new SWORDAuthenticationException(""String_Node_Str"");
    }
 else {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
      throw new SWORDAuthenticationException(""String_Node_Str"");
    }
  }
  return sc;
}","/** 
 * Authenticate the given username/password pair, in conjunction with the onBehalfOf user.  The rules are that the username/password pair must successfully authenticate the user, and the onBehalfOf user must exist in the user database.
 * @param un
 * @param pw
 * @param obo
 * @return	a SWORD context holding the various user information
 * @throws SWORDAuthenticationException
 * @throws SWORDException
 */
private SWORDContext authenticate(Context context,String un,String pw,String obo) throws SWORDAuthenticationException, SWORDException {
  if (""String_Node_Str"".equals(obo)) {
    obo=null;
  }
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
  SWORDContext sc=new SWORDContext();
  SWORDAuthentication auth=new SWORDAuthentication();
  EPerson ep=null;
  boolean authenticated=false;
  if (auth.authenticates(context,un,pw)) {
    ep=EPerson.findByEmail(context,un);
    if (ep != null) {
      authenticated=true;
      sc.setAuthenticated(ep);
    }
    if (obo != null) {
      EPerson epObo=EPerson.findByEmail(context,obo);
      if (epObo != null) {
        sc.setOnBehalfOf(epObo);
      }
 else {
        authenticated=false;
      }
    }
  }
  if (ep != null && authenticated) {
    context.setCurrentUser(ep);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + ep.getID()));
  }
 else {
    if (ep != null) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un));
      throw new SWORDAuthenticationException(""String_Node_Str"");
    }
 else {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
      throw new SWORDAuthenticationException(""String_Node_Str"");
    }
  }
  return sc;
}",0.995834490419328
52292,"/** 
 * Generate the cache validity object. The validity object will include the item being viewed, along with all bundles & bitstreams.
 */
public SourceValidity getValidity(){
  DSpaceObject dso=null;
  if (this.validity == null) {
    try {
      dso=URIUtil.resolve(objectModel);
      DSpaceValidity validity=new DSpaceValidity();
      validity.add(dso);
      this.validity=validity.complete();
    }
 catch (    Exception e) {
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + (dso == null ? ""String_Node_Str"" : dso.getHandle())));
  }
  return this.validity;
}","/** 
 * Generate the cache validity object. The validity object will include the item being viewed, along with all bundles & bitstreams.
 */
public SourceValidity getValidity(){
  DSpaceObject dso=null;
  if (this.validity == null) {
    try {
      dso=URIUtil.resolve(objectModel);
      DSpaceValidity validity=new DSpaceValidity();
      validity.add(dso);
      this.validity=validity.complete();
    }
 catch (    Exception e) {
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + (dso == null ? ""String_Node_Str"" : IdentifierService.getCanonicalForm(dso))));
  }
  return this.validity;
}",0.9578606158833064
52293,"/** 
 * Set up the bitstream reader. See the class description for information on configuration options. FIXME: This should use the parameter ""uri"" rather than ""handle"" to be consistent with the JSPUI. Unfortunately, I have no idea how this works right now, so I'll have to do that later. It should still work for now though. --JR
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    Bitstream bitstream=null;
    Item item=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      ResolvableIdentifier ri=IdentifierService.resolve(context,handle);
      dso=(DSpaceObject)IdentifierService.getResource(context,ri);
      if (dso instanceof Item && sequence > -1) {
        bitstream=findBitstreamBySequence((Item)dso,sequence);
      }
 else       if (dso instanceof Item && name != null) {
        bitstream=findBitstreamByName((Item)dso,name);
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    boolean isAuthorized=AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ);
    if (item != null && item.isWithdrawn() && !AuthorizeManager.isAdmin(context)) {
      isAuthorized=false;
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + item.getHandle() + ""String_Node_Str""));
    }
    if (!isAuthorized) {
      if (this.request.getSession().getAttribute(""String_Node_Str"") != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=IdentifierService.getCanonicalForm(item);
        }
 else         if (dso != null) {
          redictURL+=IdentifierService.getCanonicalForm(dso);
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (bitstreamName != null && bitstreamName.length() > 0) {
      int finalSlashIndex=bitstreamName.lastIndexOf(""String_Node_Str"");
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
 else {
      bitstreamName=""String_Node_Str"";
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  IdentifierException e) {
    log.error(""String_Node_Str"",e);
    throw new ProcessingException(""String_Node_Str"",e);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}","/** 
 * Set up the bitstream reader. See the class description for information on configuration options. FIXME: This should use the parameter ""uri"" rather than ""handle"" to be consistent with the JSPUI. Unfortunately, I have no idea how this works right now, so I'll have to do that later. It should still work for now though. --JR
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    Bitstream bitstream=null;
    Item item=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      ResolvableIdentifier ri=IdentifierService.resolve(context,handle);
      dso=(DSpaceObject)IdentifierService.getResource(context,ri);
      if (dso instanceof Item && sequence > -1) {
        bitstream=findBitstreamBySequence((Item)dso,sequence);
      }
 else       if (dso instanceof Item && name != null) {
        bitstream=findBitstreamByName((Item)dso,name);
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    boolean isAuthorized=AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ);
    if (item != null && item.isWithdrawn() && !AuthorizeManager.isAdmin(context)) {
      isAuthorized=false;
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + IdentifierService.getCanonicalForm(item) + ""String_Node_Str""));
    }
    if (!isAuthorized) {
      if (this.request.getSession().getAttribute(""String_Node_Str"") != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=IdentifierService.getCanonicalForm(item);
        }
 else         if (dso != null) {
          redictURL+=IdentifierService.getCanonicalForm(dso);
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (bitstreamName != null && bitstreamName.length() > 0) {
      int finalSlashIndex=bitstreamName.lastIndexOf(""String_Node_Str"");
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
 else {
      bitstreamName=""String_Node_Str"";
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  IdentifierException e) {
    log.error(""String_Node_Str"",e);
    throw new ProcessingException(""String_Node_Str"",e);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}",0.9936440677966102
52294,"public int authenticate(Context context,String netid,String password,String realm,HttpServletRequest request) throws SQLException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + netid));
  if (netid == null || password == null)   return BAD_ARGS;
  EPerson eperson=null;
  try {
    eperson=EPerson.findByNetid(context,netid.toLowerCase());
  }
 catch (  SQLException e) {
  }
  boolean loggedIn=false;
  SpeakerToLDAP ldap=new SpeakerToLDAP(log);
  if (eperson != null) {
    if (eperson.getRequireCertificate())     return CERT_REQUIRED;
 else     if (!eperson.canLogIn())     return BAD_ARGS;
{
      if (ldap.ldapAuthenticate(netid,password,context)) {
        context.setCurrentUser(eperson=EPerson.findByNetid(context,netid.toLowerCase()));
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
        return SUCCESS;
      }
 else       return BAD_CREDENTIALS;
    }
  }
 else {
    if (ldap.ldapAuthenticate(netid,password,context)) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + netid));
      if ((ldap.ldapEmail != null) && (!ldap.ldapEmail.equals(""String_Node_Str""))) {
        try {
          eperson=EPerson.findByEmail(context,ldap.ldapEmail);
          if (eperson != null) {
            log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
            context.setIgnoreAuthorization(true);
            eperson.setNetid(netid);
            eperson.update();
            context.commit();
            context.setIgnoreAuthorization(false);
            context.setCurrentUser(eperson);
            return SUCCESS;
          }
 else {
            if (canSelfRegister(context,request,netid)) {
              try {
                context.setIgnoreAuthorization(true);
                eperson=EPerson.create(context);
                if ((ldap.ldapEmail != null) && (!ldap.ldapEmail.equals(""String_Node_Str"")))                 eperson.setEmail(ldap.ldapEmail);
 else                 eperson.setEmail(netid);
                if ((ldap.ldapGivenName != null) && (!ldap.ldapGivenName.equals(""String_Node_Str"")))                 eperson.setFirstName(ldap.ldapGivenName);
                if ((ldap.ldapSurname != null) && (!ldap.ldapSurname.equals(""String_Node_Str"")))                 eperson.setLastName(ldap.ldapSurname);
                if ((ldap.ldapPhone != null) && (!ldap.ldapPhone.equals(""String_Node_Str"")))                 eperson.setMetadata(""String_Node_Str"",ldap.ldapPhone);
                eperson.setNetid(netid);
                eperson.setCanLogIn(true);
                AuthenticationManager.initEPerson(context,request,eperson);
                eperson.update();
                context.commit();
              }
 catch (              AuthorizeException e) {
                return NO_SUCH_USER;
              }
 finally {
                context.setIgnoreAuthorization(false);
              }
              log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
              return SUCCESS;
            }
 else {
              log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
              return NO_SUCH_USER;
            }
          }
        }
 catch (        AuthorizeException e) {
          eperson=null;
        }
 finally {
          context.setIgnoreAuthorization(false);
        }
      }
    }
  }
  return BAD_ARGS;
}","public int authenticate(Context context,String netid,String password,String realm,HttpServletRequest request) throws SQLException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + netid));
  if (netid == null || password == null)   return BAD_ARGS;
  EPerson eperson=null;
  try {
    eperson=EPerson.findByNetid(context,netid.toLowerCase());
  }
 catch (  SQLException e) {
  }
  boolean loggedIn=false;
  SpeakerToLDAP ldap=new SpeakerToLDAP(log);
  if (eperson != null) {
    if (eperson.getRequireCertificate())     return CERT_REQUIRED;
 else     if (!eperson.canLogIn())     return BAD_ARGS;
{
      if (ldap.ldapAuthenticate(netid,password,context)) {
        context.setCurrentUser(eperson=EPerson.findByNetid(context,netid.toLowerCase()));
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
        return SUCCESS;
      }
 else       return BAD_CREDENTIALS;
    }
  }
 else {
    if (ldap.ldapAuthenticate(netid,password,context)) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + netid));
      if ((ldap.ldapEmail != null) && (!ldap.ldapEmail.equals(""String_Node_Str""))) {
        try {
          eperson=EPerson.findByEmail(context,ldap.ldapEmail);
          if (eperson != null) {
            log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
            context.setIgnoreAuthorization(true);
            eperson.setNetid(netid);
            eperson.update();
            context.commit();
            context.setIgnoreAuthorization(false);
            context.setCurrentUser(eperson);
            return SUCCESS;
          }
 else {
            if (canSelfRegister(context,request,netid)) {
              try {
                context.setIgnoreAuthorization(true);
                eperson=EPerson.create(context);
                if ((ldap.ldapEmail != null) && (!ldap.ldapEmail.equals(""String_Node_Str"")))                 eperson.setEmail(ldap.ldapEmail);
 else                 eperson.setEmail(netid);
                if ((ldap.ldapGivenName != null) && (!ldap.ldapGivenName.equals(""String_Node_Str"")))                 eperson.setFirstName(ldap.ldapGivenName);
                if ((ldap.ldapSurname != null) && (!ldap.ldapSurname.equals(""String_Node_Str"")))                 eperson.setLastName(ldap.ldapSurname);
                if ((ldap.ldapPhone != null) && (!ldap.ldapPhone.equals(""String_Node_Str"")))                 eperson.setMetadata(""String_Node_Str"",ldap.ldapPhone);
                eperson.setNetid(netid);
                eperson.setCanLogIn(true);
                AuthenticationManager.initEPerson(context,request,eperson);
                eperson.update();
                context.commit();
                context.setCurrentUser(eperson);
              }
 catch (              AuthorizeException e) {
                return NO_SUCH_USER;
              }
 finally {
                context.setIgnoreAuthorization(false);
              }
              log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
              return SUCCESS;
            }
 else {
              log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
              return NO_SUCH_USER;
            }
          }
        }
 catch (        AuthorizeException e) {
          eperson=null;
        }
 finally {
          context.setIgnoreAuthorization(false);
        }
      }
    }
  }
  return BAD_ARGS;
}",0.9929098538561714
52295,"/** 
 * Method for invoking subscriptions via the command line
 * @param argv command-line arguments, none used yet
 */
public static void main(String[] argv){
  Options options=new Options();
  HelpFormatter formatter=new HelpFormatter();
  CommandLine line=null;
  options.addOption(OptionBuilder.isRequired(false).withDescription(""String_Node_Str"").withLongOpt(""String_Node_Str"").create(""String_Node_Str""));
  boolean test=options.hasOption(""String_Node_Str"");
  if (test)   log.setLevel(Level.DEBUG);
  Context context=null;
  try {
    context=new Context();
    processDaily(context,test);
    context.complete();
  }
 catch (  Exception e) {
    log.fatal(e);
  }
 finally {
    if (context != null && context.isValid()) {
      context.abort();
    }
  }
}","/** 
 * Method for invoking subscriptions via the command line
 * @param argv command-line arguments, none used yet
 */
public static void main(String[] argv){
  String usage=""String_Node_Str"";
  Options options=new Options();
  HelpFormatter formatter=new HelpFormatter();
  CommandLine line=null;
{
    Option opt=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
    opt.setRequired(false);
    options.addOption(opt);
  }
{
    Option opt=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
    opt.setRequired(false);
    options.addOption(opt);
  }
  try {
    line=new PosixParser().parse(options,argv);
  }
 catch (  Exception e) {
    formatter.printHelp(usage,e.getMessage(),options,""String_Node_Str"");
    System.exit(1);
  }
  if (line.hasOption(""String_Node_Str"")) {
    formatter.printHelp(usage,options);
    System.exit(1);
  }
  boolean test=line.hasOption(""String_Node_Str"");
  if (test)   log.setLevel(Level.DEBUG);
  Context context=null;
  try {
    context=new Context();
    processDaily(context,test);
    context.complete();
  }
 catch (  Exception e) {
    log.fatal(e);
  }
 finally {
    if (context != null && context.isValid()) {
      context.abort();
    }
  }
}",0.6813186813186813
52296,"public void addBody(Body body) throws WingException, SQLException {
  int groupID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  String currentName=URLDecode(parameters.getParameter(""String_Node_Str"",null));
  if (currentName == null || currentName.length() == 0)   currentName=FlowGroupUtils.getName(context,groupID);
  Group group=null;
  if (groupID >= 0)   group=Group.find(context,groupID);
  Collection collection=null;
  if (group != null) {
    int collectionID=FlowGroupUtils.getCollectionId(group.getName());
    if (collectionID > -1)     collection=Collection.find(context,collectionID);
    if (collection == null)     collectionID=-1;
  }
  String memberGroupIDsString=parameters.getParameter(""String_Node_Str"",null);
  ArrayList<Integer> memberGroupIDs=new ArrayList<Integer>();
  if (memberGroupIDsString != null) {
    for (    String id : memberGroupIDsString.split(""String_Node_Str"")) {
      if (id.length() > 0)       memberGroupIDs.add(Integer.valueOf(id));
    }
  }
  String memberEPeopleIDsString=parameters.getParameter(""String_Node_Str"",null);
  ArrayList<Integer> memberEPeopleIDs=new ArrayList<Integer>();
  if (memberEPeopleIDsString != null) {
    for (    String id : memberEPeopleIDsString.split(""String_Node_Str""))     if (id.length() > 0)     memberEPeopleIDs.add(Integer.valueOf(id));
  }
  int highlightEPersonID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  int highlightGroupID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  String query=URLDecode(parameters.getParameter(""String_Node_Str"",null));
  int page=parameters.getParameterAsInteger(""String_Node_Str"",0);
  String type=parameters.getParameter(""String_Node_Str"",null);
  String errorString=parameters.getParameter(""String_Node_Str"",null);
  ArrayList<String> errors=new ArrayList<String>();
  if (errorString != null)   for (  String error : errorString.split(""String_Node_Str""))   errors.add(error);
  Division main=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  if (group == null)   main.setHead(T_main_head_new);
 else   main.setHead(T_main_head.parameterize(group.getName(),groupID));
  if (collection != null) {
    Para para=main.addPara();
    para.addContent(T_collection_para);
    para.addXref(contextPath + ""String_Node_Str"" + collection.getHandle(),collection.getMetadata(""String_Node_Str""));
  }
  Division actions=main.addDivision(""String_Node_Str"");
  Para groupName=actions.addPara();
  groupName.addContent(T_label_name);
  Text groupText=groupName.addText(""String_Node_Str"");
  groupText.setValue(currentName);
  if (collection != null) {
    groupText.setDisabled();
    groupText.setHelp(T_label_instructions);
  }
 else   if (errors.contains(""String_Node_Str"") || errors.contains(""String_Node_Str""))   groupText.addError(""String_Node_Str"");
  Para searchBoxes=actions.addPara();
  searchBoxes.addContent(T_label_search);
  Text queryField=searchBoxes.addText(""String_Node_Str"");
  queryField.setValue(query);
  queryField.setSize(15);
  searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_search_people);
  searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_search_groups);
  if (query != null) {
    if (""String_Node_Str"".equals(type)) {
      searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_clear);
      addEPeopleSearch(main,query,page,group,memberEPeopleIDs);
    }
 else     if (""String_Node_Str"".equals(type)) {
      searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_clear);
      addGroupSearch(main,group,query,page,group,memberGroupIDs);
    }
  }
  boolean changes=false;
  if (group != null)   changes=addMemberList(main,group,memberGroupIDs,memberEPeopleIDs,highlightEPersonID,highlightGroupID);
  Para buttons=main.addPara();
  buttons.addButton(""String_Node_Str"").setValue(T_submit_save);
  buttons.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  if (changes)   main.addPara().addHighlight(""String_Node_Str"").addContent(""String_Node_Str"");
  main.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws WingException, SQLException {
  int groupID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  String currentName=URLDecode(parameters.getParameter(""String_Node_Str"",null));
  if (currentName == null || currentName.length() == 0)   currentName=FlowGroupUtils.getName(context,groupID);
  Group group=null;
  if (groupID >= 0)   group=Group.find(context,groupID);
  Collection collection=null;
  if (group != null) {
    int collectionID=FlowGroupUtils.getCollectionId(group.getName());
    if (collectionID > -1)     collection=Collection.find(context,collectionID);
    if (collection == null)     collectionID=-1;
  }
  String memberGroupIDsString=parameters.getParameter(""String_Node_Str"",null);
  ArrayList<Integer> memberGroupIDs=new ArrayList<Integer>();
  if (memberGroupIDsString != null) {
    for (    String id : memberGroupIDsString.split(""String_Node_Str"")) {
      if (id.length() > 0)       memberGroupIDs.add(Integer.valueOf(id));
    }
  }
  String memberEPeopleIDsString=parameters.getParameter(""String_Node_Str"",null);
  ArrayList<Integer> memberEPeopleIDs=new ArrayList<Integer>();
  if (memberEPeopleIDsString != null) {
    for (    String id : memberEPeopleIDsString.split(""String_Node_Str""))     if (id.length() > 0)     memberEPeopleIDs.add(Integer.valueOf(id));
  }
  int highlightEPersonID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  int highlightGroupID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  String query=URLDecode(parameters.getParameter(""String_Node_Str"",null));
  int page=parameters.getParameterAsInteger(""String_Node_Str"",0);
  String type=parameters.getParameter(""String_Node_Str"",null);
  String errorString=parameters.getParameter(""String_Node_Str"",null);
  ArrayList<String> errors=new ArrayList<String>();
  if (errorString != null)   for (  String error : errorString.split(""String_Node_Str""))   errors.add(error);
  Division main=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  if (group == null)   main.setHead(T_main_head_new);
 else   main.setHead(T_main_head.parameterize(group.getName(),groupID));
  if (collection != null) {
    Para para=main.addPara();
    para.addContent(T_collection_para);
    para.addXref(contextPath + ""String_Node_Str"" + collection.getHandle(),collection.getMetadata(""String_Node_Str""));
  }
  Division actions=main.addDivision(""String_Node_Str"");
  Para groupName=actions.addPara();
  groupName.addContent(T_label_name);
  Text groupText=groupName.addText(""String_Node_Str"");
  groupText.setValue(currentName);
  if (collection != null) {
    groupText.setDisabled();
    groupText.setHelp(T_label_instructions);
  }
 else   if (errors.contains(""String_Node_Str"") || errors.contains(""String_Node_Str""))   groupText.addError(""String_Node_Str"");
  Para searchBoxes=actions.addPara();
  searchBoxes.addContent(T_label_search);
  Text queryField=searchBoxes.addText(""String_Node_Str"");
  queryField.setValue(query);
  queryField.setSize(15);
  searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_search_people);
  searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_search_groups);
  if (query != null) {
    if (""String_Node_Str"".equals(type)) {
      searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_clear);
      addEPeopleSearch(main,query,page,group,memberEPeopleIDs);
    }
 else     if (""String_Node_Str"".equals(type)) {
      searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_clear);
      addGroupSearch(main,group,query,page,group,memberGroupIDs);
    }
  }
  boolean changes=false;
  if (group != null)   changes=addMemberList(main,group,memberGroupIDs,memberEPeopleIDs,highlightEPersonID,highlightGroupID);
  Para buttons=main.addPara();
  buttons.addButton(""String_Node_Str"").setValue(T_submit_save);
  buttons.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  if (changes)   main.addPara().addHighlight(""String_Node_Str"").addContent(T_pending_warn);
  main.addHidden(""String_Node_Str"").setValue(knot.getId());
}",0.9962070231249236
52297,"/** 
 * Method for invoking subscriptions via the command line
 * @param argv command-line arguments, none used yet
 */
public static void main(String[] argv){
  Options options=new Options();
  HelpFormatter formatter=new HelpFormatter();
  CommandLine line=null;
  options.addOption(OptionBuilder.isRequired(false).withDescription(""String_Node_Str"").withLongOpt(""String_Node_Str"").create(""String_Node_Str""));
  boolean test=options.hasOption(""String_Node_Str"");
  if (test)   log.setLevel(Level.DEBUG);
  Context context=null;
  try {
    context=new Context();
    processDaily(context,test);
    context.complete();
  }
 catch (  Exception e) {
    log.fatal(e);
  }
 finally {
    if (context != null && context.isValid()) {
      context.abort();
    }
  }
}","/** 
 * Method for invoking subscriptions via the command line
 * @param argv command-line arguments, none used yet
 */
public static void main(String[] argv){
  String usage=""String_Node_Str"";
  Options options=new Options();
  HelpFormatter formatter=new HelpFormatter();
  CommandLine line=null;
{
    Option opt=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
    opt.setRequired(false);
    options.addOption(opt);
  }
{
    Option opt=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
    opt.setRequired(false);
    options.addOption(opt);
  }
  try {
    line=new PosixParser().parse(options,argv);
  }
 catch (  Exception e) {
    formatter.printHelp(usage,e.getMessage(),options,""String_Node_Str"");
    System.exit(1);
  }
  if (line.hasOption(""String_Node_Str"")) {
    formatter.printHelp(usage,options);
    System.exit(1);
  }
  boolean test=line.hasOption(""String_Node_Str"");
  if (test)   log.setLevel(Level.DEBUG);
  Context context=null;
  try {
    context=new Context();
    processDaily(context,test);
    context.complete();
  }
 catch (  Exception e) {
    log.fatal(e);
  }
 finally {
    if (context != null && context.isValid()) {
      context.abort();
    }
  }
}",0.6813186813186813
52298,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String workspaceID=request.getParameter(""String_Node_Str"");
  String workflowID=request.getParameter(""String_Node_Str"");
  if (workspaceID != null) {
    try {
      WorkspaceItem wi=WorkspaceItem.find(context,Integer.parseInt(workspaceID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      if (getStepReached(si) >= si.getSubmissionConfig().getNumberOfSteps()) {
        int lastStep=si.getSubmissionConfig().getNumberOfSteps() - 1;
        wi.setStageReached(lastStep);
        wi.setPageReached(AbstractProcessingStep.LAST_PAGE_REACHED);
        wi.update();
        context.commit();
        si.setSubmissionItem(wi);
      }
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workspaceID));
      JSPManager.showInvalidIDError(request,response,workspaceID,-1);
    }
  }
 else   if (workflowID != null) {
    try {
      WorkflowItem wi=WorkflowItem.find(context,Integer.parseInt(workflowID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      FIRST_STEP=0;
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workflowID));
      JSPManager.showInvalidIDError(request,response,workflowID,-1);
    }
  }
 else {
    doDSPost(context,request,response);
  }
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String workspaceID=request.getParameter(""String_Node_Str"");
  String workflowID=request.getParameter(""String_Node_Str"");
  if (workspaceID != null) {
    try {
      WorkspaceItem wi=WorkspaceItem.find(context,Integer.parseInt(workspaceID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      if (getStepReached(si) >= si.getSubmissionConfig().getNumberOfSteps()) {
        int lastStep=si.getSubmissionConfig().getNumberOfSteps() - 1;
        wi.setStageReached(lastStep);
        wi.setPageReached(AbstractProcessingStep.LAST_PAGE_REACHED);
        wi.update();
        context.commit();
        si.setSubmissionItem(wi);
      }
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workspaceID));
      JSPManager.showInvalidIDError(request,response,workspaceID,-1);
    }
  }
 else   if (workflowID != null) {
    try {
      WorkflowItem wi=WorkflowItem.find(context,Integer.parseInt(workflowID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,WORKFLOW_FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workflowID));
      JSPManager.showInvalidIDError(request,response,workflowID,-1);
    }
  }
 else {
    doDSPost(context,request,response);
  }
}",0.9472443265546714
52299,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String workspaceID=request.getParameter(""String_Node_Str"");
  String workflowID=request.getParameter(""String_Node_Str"");
  if (workspaceID != null) {
    try {
      WorkspaceItem wi=WorkspaceItem.find(context,Integer.parseInt(workspaceID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      if (getStepReached(si) >= si.getSubmissionConfig().getNumberOfSteps()) {
        int lastStep=si.getSubmissionConfig().getNumberOfSteps() - 1;
        wi.setStageReached(lastStep);
        wi.setPageReached(AbstractProcessingStep.LAST_PAGE_REACHED);
        wi.update();
        context.commit();
        si.setSubmissionItem(wi);
      }
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workspaceID));
      JSPManager.showInvalidIDError(request,response,workspaceID,-1);
    }
  }
 else   if (workflowID != null) {
    try {
      WorkflowItem wi=WorkflowItem.find(context,Integer.parseInt(workflowID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      FIRST_STEP=0;
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workflowID));
      JSPManager.showInvalidIDError(request,response,workflowID,-1);
    }
  }
 else {
    doDSPost(context,request,response);
  }
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String workspaceID=request.getParameter(""String_Node_Str"");
  String workflowID=request.getParameter(""String_Node_Str"");
  if (workspaceID != null) {
    try {
      WorkspaceItem wi=WorkspaceItem.find(context,Integer.parseInt(workspaceID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      if (getStepReached(si) >= si.getSubmissionConfig().getNumberOfSteps()) {
        int lastStep=si.getSubmissionConfig().getNumberOfSteps() - 1;
        wi.setStageReached(lastStep);
        wi.setPageReached(AbstractProcessingStep.LAST_PAGE_REACHED);
        wi.update();
        context.commit();
        si.setSubmissionItem(wi);
      }
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workspaceID));
      JSPManager.showInvalidIDError(request,response,workspaceID,-1);
    }
  }
 else   if (workflowID != null) {
    try {
      WorkflowItem wi=WorkflowItem.find(context,Integer.parseInt(workflowID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,WORKFLOW_FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workflowID));
      JSPManager.showInvalidIDError(request,response,workflowID,-1);
    }
  }
 else {
    doDSPost(context,request,response);
  }
}",0.9472443265546714
52300,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  boolean https=request.isSecure();
  String server=request.getServerName();
  int port=request.getServerPort();
  String exitURL=(https) ? ""String_Node_Str"" : ""String_Node_Str"";
  exitURL+=server;
  if (!(port == 80 || port == 443))   exitURL+=""String_Node_Str"" + port;
  exitURL+=actionURL + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  Division div=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  div.setHead(T_submission_head);
  Division progressDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  addSubmissionProgressList(progressDiv);
  progressDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  Division offsiteDiv=div.addInteractiveDivision(""String_Node_Str"",CREATIVE_COMMONS_URL,Division.METHOD_POST);
  offsiteDiv.setHead(T_head);
  offsiteDiv.addPara(T_info1);
  offsiteDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  offsiteDiv.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  offsiteDiv.addHidden(""String_Node_Str"").setValue(exitURL);
  Para ccPara=offsiteDiv.addPara(""String_Node_Str"",""String_Node_Str"");
  ccPara.addButton(""String_Node_Str"").setValue(T_submit_to_creative_commons);
  Division onsiteDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  List form=onsiteDiv.addList(""String_Node_Str"",List.TYPE_FORM);
  form.addLabel(T_license);
  if (CreativeCommons.hasLicense(context,item)) {
    String url=CreativeCommons.getLicenseURL(item);
    form.addItem().addXref(url,url);
    form.addItem().addButton(""String_Node_Str"").setValue(T_submit_remove);
    form.addItem().addHidden(""String_Node_Str"").setValue(url);
  }
 else {
    form.addItem().addHighlight(""String_Node_Str"").addContent(T_no_license);
  }
  addControlButtons(form);
  onsiteDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  boolean https=request.isSecure();
  String server=request.getServerName();
  int port=request.getServerPort();
  String exitURL=(https) ? ""String_Node_Str"" : ""String_Node_Str"";
  exitURL+=server;
  if (!(port == 80 || port == 443))   exitURL+=""String_Node_Str"" + port;
  exitURL+=actionURL + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  Division div=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  div.setHead(T_submission_head);
  Division progressDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  addSubmissionProgressList(progressDiv);
  progressDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  Division offsiteDiv=div.addInteractiveDivision(""String_Node_Str"",CREATIVE_COMMONS_URL,Division.METHOD_POST);
  offsiteDiv.setHead(T_head);
  offsiteDiv.addPara(T_info1);
  offsiteDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  offsiteDiv.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  offsiteDiv.addHidden(""String_Node_Str"").setValue(exitURL);
  Para ccPara=offsiteDiv.addPara(""String_Node_Str"",""String_Node_Str"");
  ccPara.addButton(""String_Node_Str"").setValue(T_submit_to_creative_commons);
  Division onsiteDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  List form=onsiteDiv.addList(""String_Node_Str"",List.TYPE_FORM);
  form.addLabel(T_license);
  if (CreativeCommons.hasLicense(context,item)) {
    String url=CreativeCommons.getLicenseURL(item);
    form.addItem().addXref(url,url);
    form.addItem().addButton(""String_Node_Str"").setValue(T_submit_remove);
    form.addItem().addHidden(""String_Node_Str"").setValue(url);
  }
 else {
    form.addItem().addHighlight(""String_Node_Str"").addContent(T_no_license);
  }
  addControlButtons(form);
}",0.977319587628866
52301,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  DCInputSet inputSet=null;
  DCInput[] inputs={};
  try {
    inputSet=getInputsReader().getInputs(IdentifierService.getCanonicalForm(submission.getCollection()));
    inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  for (  DCInput dcInput : inputs) {
    if (!dcInput.isVisible(submissionInfo.isInWorkflow() ? WORKFLOW_SCOPE : SUBMISSION_SCOPE))     continue;
    String schema=dcInput.getSchema();
    String element=dcInput.getElement();
    String qualifier=dcInput.getQualifier();
    DCValue[] dcValues=item.getMetadata(schema,element,qualifier,Item.ANY);
    String fieldName=FlowUtils.getFieldName(dcInput);
    String inputType=dcInput.getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      renderNameField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDateField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSeriesField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      DCValue[] unfiltered=item.getMetadata(dcInput.getSchema(),dcInput.getElement(),Item.ANY,Item.ANY);
      ArrayList<DCValue> filtered=new ArrayList<DCValue>();
      for (      DCValue dcValue : unfiltered) {
        String unfilteredFieldName=dcValue.element + ""String_Node_Str"" + dcValue.qualifier;
        if (!inputSet.isFieldPresent(unfilteredFieldName)) {
          filtered.add(dcValue);
        }
      }
      renderQualdropField(form,fieldName,dcInput,filtered.toArray(new DCValue[filtered.size()]));
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderTextArea(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDropdownField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSelectFromListField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else {
      form.addItem(T_unknown_field);
    }
  }
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
  addControlButtons(form);
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  DCInputSet inputSet=null;
  DCInput[] inputs={};
  try {
    inputSet=getInputsReader().getInputs(IdentifierService.getCanonicalForm(submission.getCollection()));
    inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  for (  DCInput dcInput : inputs) {
    if (!dcInput.isVisible(submissionInfo.isInWorkflow() ? WORKFLOW_SCOPE : SUBMISSION_SCOPE))     continue;
    String schema=dcInput.getSchema();
    String element=dcInput.getElement();
    String qualifier=dcInput.getQualifier();
    DCValue[] dcValues=item.getMetadata(schema,element,qualifier,Item.ANY);
    String fieldName=FlowUtils.getFieldName(dcInput);
    String inputType=dcInput.getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      renderNameField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDateField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSeriesField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      DCValue[] unfiltered=item.getMetadata(dcInput.getSchema(),dcInput.getElement(),Item.ANY,Item.ANY);
      ArrayList<DCValue> filtered=new ArrayList<DCValue>();
      for (      DCValue dcValue : unfiltered) {
        String unfilteredFieldName=dcValue.element + ""String_Node_Str"" + dcValue.qualifier;
        if (!inputSet.isFieldPresent(unfilteredFieldName)) {
          filtered.add(dcValue);
        }
      }
      renderQualdropField(form,fieldName,dcInput,filtered.toArray(new DCValue[filtered.size()]));
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderTextArea(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDropdownField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSelectFromListField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else {
      form.addItem(T_unknown_field);
    }
  }
  addControlButtons(form);
}",0.9844767150726088
52302,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  BitstreamFormat currentFormat=bitstream.getFormat();
  BitstreamFormat guessedFormat=FormatIdentifier.guessFormat(context,bitstream);
  BitstreamFormat[] bitstreamFormats=BitstreamFormat.findNonInternal(context);
  int itemID=submissionInfo.getSubmissionItem().getItem().getID();
  String fileUrl=contextPath + ""String_Node_Str"" + itemID+ ""String_Node_Str""+ bitstream.getName();
  String fileName=bitstream.getName();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List edit=div.addList(""String_Node_Str"",List.TYPE_FORM);
  edit.setHead(T_head);
  edit.addLabel(T_file);
  edit.addItem().addXref(fileUrl,fileName);
  Text description=edit.addItem().addText(""String_Node_Str"");
  description.setLabel(T_description);
  description.setHelp(T_description_help);
  description.setValue(bitstream.getDescription());
  edit.addItem(T_info1);
  if (guessedFormat != null) {
    edit.addLabel(T_format_detected);
    edit.addItem(guessedFormat.getShortDescription());
  }
  Select format=edit.addItem().addSelect(""String_Node_Str"");
  format.setLabel(T_format_selected);
  format.addOption(-1,T_format_default);
  for (  BitstreamFormat bitstreamFormat : bitstreamFormats) {
    String supportLevel=""String_Node_Str"";
    if (bitstreamFormat.getSupportLevel() == BitstreamFormat.KNOWN)     supportLevel=""String_Node_Str"";
 else     if (bitstreamFormat.getSupportLevel() == BitstreamFormat.SUPPORTED)     supportLevel=""String_Node_Str"";
    String name=bitstreamFormat.getShortDescription() + ""String_Node_Str"" + supportLevel+ ""String_Node_Str"";
    int id=bitstreamFormat.getID();
    format.addOption(id,name);
  }
  if (currentFormat != null) {
    format.setOptionSelected(currentFormat.getID());
  }
 else   if (guessedFormat != null) {
    format.setOptionSelected(guessedFormat.getID());
  }
 else {
    format.setOptionSelected(-1);
  }
  edit.addItem(T_info2);
  Text userFormat=edit.addItem().addText(""String_Node_Str"");
  userFormat.setLabel(T_format_user);
  userFormat.setHelp(T_format_user_help);
  userFormat.setValue(bitstream.getUserFormatDescription());
  div.addHidden(""String_Node_Str"").setValue(bitstream.getID());
  org.dspace.app.xmlui.wing.element.Item actions=edit.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  BitstreamFormat currentFormat=bitstream.getFormat();
  BitstreamFormat guessedFormat=FormatIdentifier.guessFormat(context,bitstream);
  BitstreamFormat[] bitstreamFormats=BitstreamFormat.findNonInternal(context);
  int itemID=submissionInfo.getSubmissionItem().getItem().getID();
  String fileUrl=contextPath + ""String_Node_Str"" + itemID+ ""String_Node_Str""+ bitstream.getName();
  String fileName=bitstream.getName();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List edit=div.addList(""String_Node_Str"",List.TYPE_FORM);
  edit.setHead(T_head);
  edit.addLabel(T_file);
  edit.addItem().addXref(fileUrl,fileName);
  Text description=edit.addItem().addText(""String_Node_Str"");
  description.setLabel(T_description);
  description.setHelp(T_description_help);
  description.setValue(bitstream.getDescription());
  edit.addItem(T_info1);
  if (guessedFormat != null) {
    edit.addLabel(T_format_detected);
    edit.addItem(guessedFormat.getShortDescription());
  }
  Select format=edit.addItem().addSelect(""String_Node_Str"");
  format.setLabel(T_format_selected);
  format.addOption(-1,T_format_default);
  for (  BitstreamFormat bitstreamFormat : bitstreamFormats) {
    String supportLevel=""String_Node_Str"";
    if (bitstreamFormat.getSupportLevel() == BitstreamFormat.KNOWN)     supportLevel=""String_Node_Str"";
 else     if (bitstreamFormat.getSupportLevel() == BitstreamFormat.SUPPORTED)     supportLevel=""String_Node_Str"";
    String name=bitstreamFormat.getShortDescription() + ""String_Node_Str"" + supportLevel+ ""String_Node_Str"";
    int id=bitstreamFormat.getID();
    format.addOption(id,name);
  }
  if (currentFormat != null) {
    format.setOptionSelected(currentFormat.getID());
  }
 else   if (guessedFormat != null) {
    format.setOptionSelected(guessedFormat.getID());
  }
 else {
    format.setOptionSelected(-1);
  }
  edit.addItem(T_info2);
  Text userFormat=edit.addItem().addText(""String_Node_Str"");
  userFormat.setLabel(T_format_user);
  userFormat.setHelp(T_format_user_help);
  userFormat.setValue(bitstream.getUserFormatDescription());
  div.addHidden(""String_Node_Str"").setValue(bitstream.getID());
  org.dspace.app.xmlui.wing.element.Item actions=edit.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
}",0.9832402234636872
52303,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  DCValue[] titles=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] dateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] citation=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] publisher=item.getDC(""String_Node_Str"",null,Item.ANY);
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  CheckBox multipleTitles=form.addItem().addCheckBox(""String_Node_Str"");
  multipleTitles.setLabel(T_multiple_titles);
  multipleTitles.setHelp(T_multiple_titles_help);
  multipleTitles.addOption(""String_Node_Str"");
  if (submission.hasMultipleTitles()) {
    multipleTitles.setOptionSelected(""String_Node_Str"");
  }
  if (titles.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_multiple_titles_note);
    for (int i=0; i < titles.length; i++) {
      if (i > 0)       note.addContent(T_separator);
      note.addContent(""String_Node_Str"");
      note.addHighlight(""String_Node_Str"").addContent(titles[i].value);
      note.addContent(""String_Node_Str"");
    }
  }
  CheckBox publishedBefore=form.addItem().addCheckBox(""String_Node_Str"");
  publishedBefore.setLabel(T_published_before);
  publishedBefore.setHelp(T_published_before_help);
  publishedBefore.addOption(""String_Node_Str"");
  if (submission.isPublishedBefore()) {
    publishedBefore.setOptionSelected(""String_Node_Str"");
  }
  if (dateIssued.length > 0 || citation.length > 0 || publisher.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_published_before_note);
    if (dateIssued.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_date_issued);
      note.addContent(T_open);
      for (int i=0; i < dateIssued.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(dateIssued[i].value);
      }
      note.addContent(T_close);
    }
    if (dateIssued.length > 0 && (citation.length > 0 || publisher.length > 0))     note.addContent(T_separator);
    if (dateIssued.length > 0 && citation.length > 0 && publisher.length == 0) {
      note.addContent(T_and);
    }
    if (citation.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_citation);
      note.addContent(T_open);
      for (int i=0; i < citation.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(citation[i].value);
      }
      note.addContent(T_close);
    }
    if (citation.length > 0 && publisher.length > 0) {
      note.addContent(T_separator);
    }
    if ((dateIssued.length > 0 || citation.length > 0) && publisher.length > 0) {
      note.addContent(T_and);
    }
    if (publisher.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_publisher);
      note.addContent(T_open);
      for (int i=0; i < publisher.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(publisher[i].value);
      }
      note.addContent(T_close);
    }
  }
  addControlButtons(form);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
  div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  DCValue[] titles=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] dateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] citation=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] publisher=item.getDC(""String_Node_Str"",null,Item.ANY);
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  CheckBox multipleTitles=form.addItem().addCheckBox(""String_Node_Str"");
  multipleTitles.setLabel(T_multiple_titles);
  multipleTitles.setHelp(T_multiple_titles_help);
  multipleTitles.addOption(""String_Node_Str"");
  if (submission.hasMultipleTitles()) {
    multipleTitles.setOptionSelected(""String_Node_Str"");
  }
  if (titles.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_multiple_titles_note);
    for (int i=0; i < titles.length; i++) {
      if (i > 0)       note.addContent(T_separator);
      note.addContent(""String_Node_Str"");
      note.addHighlight(""String_Node_Str"").addContent(titles[i].value);
      note.addContent(""String_Node_Str"");
    }
  }
  CheckBox publishedBefore=form.addItem().addCheckBox(""String_Node_Str"");
  publishedBefore.setLabel(T_published_before);
  publishedBefore.setHelp(T_published_before_help);
  publishedBefore.addOption(""String_Node_Str"");
  if (submission.isPublishedBefore()) {
    publishedBefore.setOptionSelected(""String_Node_Str"");
  }
  if (dateIssued.length > 0 || citation.length > 0 || publisher.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_published_before_note);
    if (dateIssued.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_date_issued);
      note.addContent(T_open);
      for (int i=0; i < dateIssued.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(dateIssued[i].value);
      }
      note.addContent(T_close);
    }
    if (dateIssued.length > 0 && (citation.length > 0 || publisher.length > 0))     note.addContent(T_separator);
    if (dateIssued.length > 0 && citation.length > 0 && publisher.length == 0) {
      note.addContent(T_and);
    }
    if (citation.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_citation);
      note.addContent(T_open);
      for (int i=0; i < citation.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(citation[i].value);
      }
      note.addContent(T_close);
    }
    if (citation.length > 0 && publisher.length > 0) {
      note.addContent(T_separator);
    }
    if ((dateIssued.length > 0 || citation.length > 0) && publisher.length > 0) {
      note.addContent(T_and);
    }
    if (publisher.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_publisher);
      note.addContent(T_open);
      for (int i=0; i < publisher.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(publisher[i].value);
      }
      note.addContent(T_close);
    }
  }
  addControlButtons(form);
  div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
}",0.9878032786885246
52304,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (CreativeCommons.isEnabled() && ccLicenseStep != null) {
    ccLicenseStep.addBody(body);
    return;
  }
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  String licenseText=collection.getLicense();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  Division inner=div.addDivision(""String_Node_Str"");
  inner.setHead(T_head);
  inner.addPara(T_info1);
  inner.addPara(T_info2);
  Division displayLicense=inner.addDivision(""String_Node_Str"",""String_Node_Str"");
  displayLicense.addSimpleHTMLFragment(true,licenseText);
  inner.addPara(T_info3);
  List controls=inner.addList(""String_Node_Str"",List.TYPE_FORM);
  CheckBox decision=controls.addItem().addCheckBox(""String_Node_Str"");
  decision.setLabel(T_decision_label);
  decision.addOption(""String_Node_Str"",T_decision_checkbox);
  if (this.errorFlag == org.dspace.submit.step.LicenseStep.STATUS_LICENSE_REJECTED) {
    decision.addError(T_decision_error);
  }
  addControlButtons(controls);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (CreativeCommons.isEnabled() && ccLicenseStep != null) {
    ccLicenseStep.addBody(body);
    return;
  }
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  String licenseText=collection.getLicense();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  Division inner=div.addDivision(""String_Node_Str"");
  inner.setHead(T_head);
  inner.addPara(T_info1);
  inner.addPara(T_info2);
  Division displayLicense=inner.addDivision(""String_Node_Str"",""String_Node_Str"");
  displayLicense.addSimpleHTMLFragment(true,licenseText);
  inner.addPara(T_info3);
  List controls=inner.addList(""String_Node_Str"",List.TYPE_FORM);
  CheckBox decision=controls.addItem().addCheckBox(""String_Node_Str"");
  decision.setLabel(T_decision_label);
  decision.addOption(""String_Node_Str"",T_decision_checkbox);
  if (this.errorFlag == org.dspace.submit.step.LicenseStep.STATUS_LICENSE_REJECTED) {
    decision.addError(T_decision_error);
  }
  addControlButtons(controls);
}",0.9654660230226512
52305,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  org.dspace.app.xmlui.wing.element.Item actions=form.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_resume);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  org.dspace.app.xmlui.wing.element.Item actions=form.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_resume);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
}",0.968718466195762
52306,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  SubmissionConfig subConfig=submissionInfo.getSubmissionConfig();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List review=div.addList(""String_Node_Str"",List.TYPE_FORM);
  review.setHead(T_head);
  Set submissionPagesSet=submissionInfo.getProgressBarInfo().keySet();
  String[] submissionPages=(String[])submissionPagesSet.toArray(new String[submissionPagesSet.size()]);
  for (int i=0; i < submissionPages.length; i++) {
    double currentStepAndPage=Double.valueOf(submissionPages[i]).doubleValue();
    if (currentStepAndPage == this.stepAndPage) {
      break;
    }
    SubmissionStepConfig stepConfig=subConfig.getStep(FlowUtils.getStep(currentStepAndPage));
    AbstractStep stepUIClass=loadXMLUIClass(stepConfig.getXMLUIClassName());
    try {
      parameters.setParameter(""String_Node_Str"",Double.toString(currentStepAndPage));
      stepUIClass.setup(resolver,objectModel,src,parameters);
    }
 catch (    Exception e) {
      throw new UIException(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"",e);
    }
    if (stepUIClass instanceof AbstractSubmissionStep) {
      List stepSection=((AbstractSubmissionStep)stepUIClass).addReviewSection(review);
      if (stepSection != null) {
        addJumpButton(stepSection,T_submit_jump,currentStepAndPage);
      }
    }
 else {
      log.warn(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"");
    }
  }
  addControlButtons(review);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  SubmissionConfig subConfig=submissionInfo.getSubmissionConfig();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List review=div.addList(""String_Node_Str"",List.TYPE_FORM);
  review.setHead(T_head);
  Set submissionPagesSet=submissionInfo.getProgressBarInfo().keySet();
  String[] submissionPages=(String[])submissionPagesSet.toArray(new String[submissionPagesSet.size()]);
  for (int i=0; i < submissionPages.length; i++) {
    double currentStepAndPage=Double.valueOf(submissionPages[i]).doubleValue();
    if (currentStepAndPage == this.stepAndPage) {
      break;
    }
    SubmissionStepConfig stepConfig=subConfig.getStep(FlowUtils.getStep(currentStepAndPage));
    AbstractStep stepUIClass=loadXMLUIClass(stepConfig.getXMLUIClassName());
    try {
      parameters.setParameter(""String_Node_Str"",Double.toString(currentStepAndPage));
      stepUIClass.setup(resolver,objectModel,src,parameters);
    }
 catch (    Exception e) {
      throw new UIException(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"",e);
    }
    if (stepUIClass instanceof AbstractSubmissionStep) {
      List stepSection=((AbstractSubmissionStep)stepUIClass).addReviewSection(review);
      if (stepSection != null) {
        addJumpButton(stepSection,T_submit_jump,currentStepAndPage);
      }
    }
 else {
      log.warn(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"");
    }
  }
  addControlButtons(review);
}",0.9754033324517324
52307,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List saveOrCancel=div.addList(""String_Node_Str"",List.TYPE_FORM);
  saveOrCancel.setHead(T_head);
  saveOrCancel.addItem(T_info1);
  saveOrCancel.addItem().addButton(""String_Node_Str"").setValue(T_submit_back);
  org.dspace.app.xmlui.wing.element.Item actions=saveOrCancel.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_remove);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List saveOrCancel=div.addList(""String_Node_Str"",List.TYPE_FORM);
  saveOrCancel.setHead(T_head);
  saveOrCancel.addItem(T_info1);
  saveOrCancel.addItem().addButton(""String_Node_Str"").setValue(T_submit_back);
  org.dspace.app.xmlui.wing.element.Item actions=saveOrCancel.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_remove);
}",0.948873007146784
52308,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  try {
    Collection[] collections;
    ResolvableIdentifier eid=IdentifierService.resolve(context,handle);
    DSpaceObject dso=null;
    if (eid != null) {
      dso=(DSpaceObject)IdentifierService.getResource(context,eid);
    }
    if (dso != null && dso instanceof Community) {
      collections=Collection.findAuthorized(context,((Community)dso),Constants.ADD);
    }
 else {
      collections=Collection.findAuthorized(context,null,Constants.ADD);
    }
    Division div=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
    div.setHead(T_submission_head);
    List list=div.addList(""String_Node_Str"",List.TYPE_FORM);
    list.setHead(T_head);
    Select select=list.addItem().addSelect(""String_Node_Str"");
    select.setLabel(T_collection);
    select.setHelp(T_collection_help);
    select.addOption(""String_Node_Str"",T_collection_default);
    for (    Collection collection : collections) {
      String name=collection.getMetadata(""String_Node_Str"");
      if (name.length() > 50)       name=name.substring(0,47) + ""String_Node_Str"";
      select.addOption(IdentifierService.getCanonicalForm(collection),name);
    }
    Button submit=list.addItem().addButton(""String_Node_Str"");
    submit.setValue(T_submit_next);
    div.addHidden(""String_Node_Str"").setValue(knot.getId());
  }
 catch (  IdentifierException e) {
    throw new RuntimeException(e);
  }
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  try {
    Collection[] collections;
    String actionURL=contextPath + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
    ResolvableIdentifier eid=IdentifierService.resolve(context,handle);
    DSpaceObject dso=null;
    if (eid != null) {
      dso=(DSpaceObject)IdentifierService.getResource(context,eid);
    }
    if (dso != null && dso instanceof Community) {
      collections=Collection.findAuthorized(context,((Community)dso),Constants.ADD);
    }
 else {
      collections=Collection.findAuthorized(context,null,Constants.ADD);
    }
    Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
    div.setHead(T_submission_head);
    List list=div.addList(""String_Node_Str"",List.TYPE_FORM);
    list.setHead(T_head);
    Select select=list.addItem().addSelect(""String_Node_Str"");
    select.setLabel(T_collection);
    select.setHelp(T_collection_help);
    select.addOption(""String_Node_Str"",T_collection_default);
    for (    Collection collection : collections) {
      String name=collection.getMetadata(""String_Node_Str"");
      if (name.length() > 50)       name=name.substring(0,47) + ""String_Node_Str"";
      select.addOption(IdentifierService.getCanonicalForm(collection),name);
    }
    Button submit=list.addItem().addButton(""String_Node_Str"");
    submit.setValue(T_submit_next);
  }
 catch (  IdentifierException e) {
    throw new RuntimeException(e);
  }
}",0.9397897419560368
52309,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (this.editFile != null) {
    editFile.addBody(body);
    return;
  }
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  boolean workflow=submission instanceof WorkflowItem;
  Bundle[] bundles=item.getBundles(""String_Node_Str"");
  Bitstream[] bitstreams=new Bitstream[0];
  if (bundles.length > 0) {
    bitstreams=bundles[0].getBitstreams();
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_MULTIPART,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List upload=null;
  if (!workflow) {
    upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
    upload.setHead(T_head);
    File file=upload.addItem().addFile(""String_Node_Str"");
    file.setLabel(T_file);
    file.setHelp(T_file_help);
    file.setRequired();
    if (this.errorFlag == org.dspace.submit.step.UploadStep.STATUS_NO_FILES_ERROR)     file.addError(T_file_error);
    Text description=upload.addItem().addText(""String_Node_Str"");
    description.setLabel(T_description);
    description.setHelp(T_description_help);
    Button uploadSubmit=upload.addItem().addButton(""String_Node_Str"");
    uploadSubmit.setValue(T_submit_upload);
  }
  if (bitstreams.length > 0 || workflow) {
    Table summary=div.addTable(""String_Node_Str"",(bitstreams.length * 2) + 2,7);
    summary.setHead(T_head2);
    Row header=summary.addRow(Row.ROLE_HEADER);
    header.addCellContent(T_column1);
    header.addCellContent(T_column2);
    header.addCellContent(T_column3);
    header.addCellContent(T_column4);
    header.addCellContent(T_column5);
    header.addCellContent(T_column6);
    for (    Bitstream bitstream : bitstreams) {
      int id=bitstream.getID();
      String name=bitstream.getName();
      String url=contextPath + ""String_Node_Str"" + item.getID()+ ""String_Node_Str""+ name;
      long bytes=bitstream.getSize();
      String desc=bitstream.getDescription();
      String algorithm=bitstream.getChecksumAlgorithm();
      String checksum=bitstream.getChecksum();
      BitstreamFormat format=bitstream.getFormat();
      int support=format.getSupportLevel();
      Row row=summary.addRow();
      if (!workflow) {
        CheckBox remove=row.addCell().addCheckBox(""String_Node_Str"");
        remove.setLabel(""String_Node_Str"");
        remove.addOption(id);
      }
 else {
        row.addCell();
      }
      row.addCell().addXref(url,name);
      row.addCellContent(bytes + ""String_Node_Str"");
      if (desc == null || desc.length() == 0)       row.addCellContent(T_unknown_name);
 else       row.addCellContent(desc);
      if (format == null) {
        row.addCellContent(T_unknown_format);
      }
 else {
        Cell cell=row.addCell();
        cell.addContent(format.getMIMEType());
        cell.addContent(""String_Node_Str"");
switch (support) {
case 1:
          cell.addContent(T_supported);
        break;
case 2:
      cell.addContent(T_known);
    break;
case 3:
  cell.addContent(T_unsupported);
break;
}
}
Button edit=row.addCell().addButton(""String_Node_Str"" + id);
edit.setValue(T_submit_edit);
Row checksumRow=summary.addRow();
checksumRow.addCell();
Cell checksumCell=checksumRow.addCell(null,null,0,6,null);
checksumCell.addHighlight(""String_Node_Str"").addContent(T_checksum);
checksumCell.addContent(""String_Node_Str"");
checksumCell.addContent(algorithm + ""String_Node_Str"" + checksum);
}
if (!workflow) {
Row actionRow=summary.addRow();
actionRow.addCell();
Button removeSeleceted=actionRow.addCell(null,null,0,6,null).addButton(""String_Node_Str"");
removeSeleceted.setValue(T_submit_remove);
}
upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
}
addControlButtons(upload);
div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (this.editFile != null) {
    editFile.addBody(body);
    return;
  }
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  boolean workflow=submission instanceof WorkflowItem;
  Bundle[] bundles=item.getBundles(""String_Node_Str"");
  Bitstream[] bitstreams=new Bitstream[0];
  if (bundles.length > 0) {
    bitstreams=bundles[0].getBitstreams();
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_MULTIPART,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List upload=null;
  if (!workflow) {
    upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
    upload.setHead(T_head);
    File file=upload.addItem().addFile(""String_Node_Str"");
    file.setLabel(T_file);
    file.setHelp(T_file_help);
    file.setRequired();
    if (this.errorFlag == org.dspace.submit.step.UploadStep.STATUS_NO_FILES_ERROR)     file.addError(T_file_error);
    Text description=upload.addItem().addText(""String_Node_Str"");
    description.setLabel(T_description);
    description.setHelp(T_description_help);
    Button uploadSubmit=upload.addItem().addButton(""String_Node_Str"");
    uploadSubmit.setValue(T_submit_upload);
  }
  if (bitstreams.length > 0 || workflow) {
    Table summary=div.addTable(""String_Node_Str"",(bitstreams.length * 2) + 2,7);
    summary.setHead(T_head2);
    Row header=summary.addRow(Row.ROLE_HEADER);
    header.addCellContent(T_column1);
    header.addCellContent(T_column2);
    header.addCellContent(T_column3);
    header.addCellContent(T_column4);
    header.addCellContent(T_column5);
    header.addCellContent(T_column6);
    for (    Bitstream bitstream : bitstreams) {
      int id=bitstream.getID();
      String name=bitstream.getName();
      String url=contextPath + ""String_Node_Str"" + item.getID()+ ""String_Node_Str""+ name;
      long bytes=bitstream.getSize();
      String desc=bitstream.getDescription();
      String algorithm=bitstream.getChecksumAlgorithm();
      String checksum=bitstream.getChecksum();
      BitstreamFormat format=bitstream.getFormat();
      int support=format.getSupportLevel();
      Row row=summary.addRow();
      if (!workflow) {
        CheckBox remove=row.addCell().addCheckBox(""String_Node_Str"");
        remove.setLabel(""String_Node_Str"");
        remove.addOption(id);
      }
 else {
        row.addCell();
      }
      row.addCell().addXref(url,name);
      row.addCellContent(bytes + ""String_Node_Str"");
      if (desc == null || desc.length() == 0)       row.addCellContent(T_unknown_name);
 else       row.addCellContent(desc);
      if (format == null) {
        row.addCellContent(T_unknown_format);
      }
 else {
        Cell cell=row.addCell();
        cell.addContent(format.getMIMEType());
        cell.addContent(""String_Node_Str"");
switch (support) {
case 1:
          cell.addContent(T_supported);
        break;
case 2:
      cell.addContent(T_known);
    break;
case 3:
  cell.addContent(T_unsupported);
break;
}
}
Button edit=row.addCell().addButton(""String_Node_Str"" + id);
edit.setValue(T_submit_edit);
Row checksumRow=summary.addRow();
checksumRow.addCell();
Cell checksumCell=checksumRow.addCell(null,null,0,6,null);
checksumCell.addHighlight(""String_Node_Str"").addContent(T_checksum);
checksumCell.addContent(""String_Node_Str"");
checksumCell.addContent(algorithm + ""String_Node_Str"" + checksum);
}
if (!workflow) {
Row actionRow=summary.addRow();
actionRow.addCell();
Button removeSeleceted=actionRow.addCell(null,null,0,6,null).addButton(""String_Node_Str"");
removeSeleceted.setValue(T_submit_remove);
}
upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
}
addControlButtons(upload);
}",0.9884970294526608
52310,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  boolean https=request.isSecure();
  String server=request.getServerName();
  int port=request.getServerPort();
  String exitURL=(https) ? ""String_Node_Str"" : ""String_Node_Str"";
  exitURL+=server;
  if (!(port == 80 || port == 443))   exitURL+=""String_Node_Str"" + port;
  exitURL+=actionURL + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  Division div=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  div.setHead(T_submission_head);
  Division progressDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  addSubmissionProgressList(progressDiv);
  progressDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  Division offsiteDiv=div.addInteractiveDivision(""String_Node_Str"",CREATIVE_COMMONS_URL,Division.METHOD_POST);
  offsiteDiv.setHead(T_head);
  offsiteDiv.addPara(T_info1);
  offsiteDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  offsiteDiv.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  offsiteDiv.addHidden(""String_Node_Str"").setValue(exitURL);
  Para ccPara=offsiteDiv.addPara(""String_Node_Str"",""String_Node_Str"");
  ccPara.addButton(""String_Node_Str"").setValue(T_submit_to_creative_commons);
  Division onsiteDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  List form=onsiteDiv.addList(""String_Node_Str"",List.TYPE_FORM);
  form.addLabel(T_license);
  if (CreativeCommons.hasLicense(context,item)) {
    String url=CreativeCommons.getLicenseURL(item);
    form.addItem().addXref(url,url);
    form.addItem().addButton(""String_Node_Str"").setValue(T_submit_remove);
    form.addItem().addHidden(""String_Node_Str"").setValue(url);
  }
 else {
    form.addItem().addHighlight(""String_Node_Str"").addContent(T_no_license);
  }
  addControlButtons(form);
  onsiteDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  boolean https=request.isSecure();
  String server=request.getServerName();
  int port=request.getServerPort();
  String exitURL=(https) ? ""String_Node_Str"" : ""String_Node_Str"";
  exitURL+=server;
  if (!(port == 80 || port == 443))   exitURL+=""String_Node_Str"" + port;
  exitURL+=actionURL + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  Division div=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  div.setHead(T_submission_head);
  Division progressDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  addSubmissionProgressList(progressDiv);
  progressDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  Division offsiteDiv=div.addInteractiveDivision(""String_Node_Str"",CREATIVE_COMMONS_URL,Division.METHOD_POST);
  offsiteDiv.setHead(T_head);
  offsiteDiv.addPara(T_info1);
  offsiteDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  offsiteDiv.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  offsiteDiv.addHidden(""String_Node_Str"").setValue(exitURL);
  Para ccPara=offsiteDiv.addPara(""String_Node_Str"",""String_Node_Str"");
  ccPara.addButton(""String_Node_Str"").setValue(T_submit_to_creative_commons);
  Division onsiteDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  List form=onsiteDiv.addList(""String_Node_Str"",List.TYPE_FORM);
  form.addLabel(T_license);
  if (CreativeCommons.hasLicense(context,item)) {
    String url=CreativeCommons.getLicenseURL(item);
    form.addItem().addXref(url,url);
    form.addItem().addButton(""String_Node_Str"").setValue(T_submit_remove);
    form.addItem().addHidden(""String_Node_Str"").setValue(url);
  }
 else {
    form.addItem().addHighlight(""String_Node_Str"").addContent(T_no_license);
  }
  addControlButtons(form);
}",0.9776255707762556
52311,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  DCInputSet inputSet=null;
  DCInput[] inputs={};
  try {
    inputSet=getInputsReader().getInputs(submission.getCollection().getHandle());
    inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  for (  DCInput dcInput : inputs) {
    if (!dcInput.isVisible(submissionInfo.isInWorkflow() ? WORKFLOW_SCOPE : SUBMISSION_SCOPE))     continue;
    String schema=dcInput.getSchema();
    String element=dcInput.getElement();
    String qualifier=dcInput.getQualifier();
    DCValue[] dcValues=item.getMetadata(schema,element,qualifier,Item.ANY);
    String fieldName=FlowUtils.getFieldName(dcInput);
    String inputType=dcInput.getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      renderNameField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDateField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSeriesField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      DCValue[] unfiltered=item.getMetadata(dcInput.getSchema(),dcInput.getElement(),Item.ANY,Item.ANY);
      ArrayList<DCValue> filtered=new ArrayList<DCValue>();
      for (      DCValue dcValue : unfiltered) {
        String unfilteredFieldName=dcValue.element + ""String_Node_Str"" + dcValue.qualifier;
        if (!inputSet.isFieldPresent(unfilteredFieldName)) {
          filtered.add(dcValue);
        }
      }
      renderQualdropField(form,fieldName,dcInput,filtered.toArray(new DCValue[filtered.size()]));
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderTextArea(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDropdownField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSelectFromListField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else {
      form.addItem(T_unknown_field);
    }
  }
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
  addControlButtons(form);
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  DCInputSet inputSet=null;
  DCInput[] inputs={};
  try {
    inputSet=getInputsReader().getInputs(submission.getCollection().getHandle());
    inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  for (  DCInput dcInput : inputs) {
    if (!dcInput.isVisible(submissionInfo.isInWorkflow() ? WORKFLOW_SCOPE : SUBMISSION_SCOPE))     continue;
    String schema=dcInput.getSchema();
    String element=dcInput.getElement();
    String qualifier=dcInput.getQualifier();
    DCValue[] dcValues=item.getMetadata(schema,element,qualifier,Item.ANY);
    String fieldName=FlowUtils.getFieldName(dcInput);
    String inputType=dcInput.getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      renderNameField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDateField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSeriesField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      DCValue[] unfiltered=item.getMetadata(dcInput.getSchema(),dcInput.getElement(),Item.ANY,Item.ANY);
      ArrayList<DCValue> filtered=new ArrayList<DCValue>();
      for (      DCValue dcValue : unfiltered) {
        String unfilteredFieldName=dcValue.element + ""String_Node_Str"" + dcValue.qualifier;
        if (!inputSet.isFieldPresent(unfilteredFieldName)) {
          filtered.add(dcValue);
        }
      }
      renderQualdropField(form,fieldName,dcInput,filtered.toArray(new DCValue[filtered.size()]));
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderTextArea(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDropdownField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSelectFromListField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else {
      form.addItem(T_unknown_field);
    }
  }
  addControlButtons(form);
}",0.9845585767035918
52312,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  BitstreamFormat currentFormat=bitstream.getFormat();
  BitstreamFormat guessedFormat=FormatIdentifier.guessFormat(context,bitstream);
  BitstreamFormat[] bitstreamFormats=BitstreamFormat.findNonInternal(context);
  int itemID=submissionInfo.getSubmissionItem().getItem().getID();
  String fileUrl=contextPath + ""String_Node_Str"" + itemID+ ""String_Node_Str""+ bitstream.getName();
  String fileName=bitstream.getName();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List edit=div.addList(""String_Node_Str"",List.TYPE_FORM);
  edit.setHead(T_head);
  edit.addLabel(T_file);
  edit.addItem().addXref(fileUrl,fileName);
  Text description=edit.addItem().addText(""String_Node_Str"");
  description.setLabel(T_description);
  description.setHelp(T_description_help);
  description.setValue(bitstream.getDescription());
  edit.addItem(T_info1);
  if (guessedFormat != null) {
    edit.addLabel(T_format_detected);
    edit.addItem(guessedFormat.getShortDescription());
  }
  Select format=edit.addItem().addSelect(""String_Node_Str"");
  format.setLabel(T_format_selected);
  format.addOption(-1,T_format_default);
  for (  BitstreamFormat bitstreamFormat : bitstreamFormats) {
    String supportLevel=""String_Node_Str"";
    if (bitstreamFormat.getSupportLevel() == BitstreamFormat.KNOWN)     supportLevel=""String_Node_Str"";
 else     if (bitstreamFormat.getSupportLevel() == BitstreamFormat.SUPPORTED)     supportLevel=""String_Node_Str"";
    String name=bitstreamFormat.getShortDescription() + ""String_Node_Str"" + supportLevel+ ""String_Node_Str"";
    int id=bitstreamFormat.getID();
    format.addOption(id,name);
  }
  if (currentFormat != null) {
    format.setOptionSelected(currentFormat.getID());
  }
 else   if (guessedFormat != null) {
    format.setOptionSelected(guessedFormat.getID());
  }
 else {
    format.setOptionSelected(-1);
  }
  edit.addItem(T_info2);
  Text userFormat=edit.addItem().addText(""String_Node_Str"");
  userFormat.setLabel(T_format_user);
  userFormat.setHelp(T_format_user_help);
  userFormat.setValue(bitstream.getUserFormatDescription());
  div.addHidden(""String_Node_Str"").setValue(bitstream.getID());
  org.dspace.app.xmlui.wing.element.Item actions=edit.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  BitstreamFormat currentFormat=bitstream.getFormat();
  BitstreamFormat guessedFormat=FormatIdentifier.guessFormat(context,bitstream);
  BitstreamFormat[] bitstreamFormats=BitstreamFormat.findNonInternal(context);
  int itemID=submissionInfo.getSubmissionItem().getItem().getID();
  String fileUrl=contextPath + ""String_Node_Str"" + itemID+ ""String_Node_Str""+ bitstream.getName();
  String fileName=bitstream.getName();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List edit=div.addList(""String_Node_Str"",List.TYPE_FORM);
  edit.setHead(T_head);
  edit.addLabel(T_file);
  edit.addItem().addXref(fileUrl,fileName);
  Text description=edit.addItem().addText(""String_Node_Str"");
  description.setLabel(T_description);
  description.setHelp(T_description_help);
  description.setValue(bitstream.getDescription());
  edit.addItem(T_info1);
  if (guessedFormat != null) {
    edit.addLabel(T_format_detected);
    edit.addItem(guessedFormat.getShortDescription());
  }
  Select format=edit.addItem().addSelect(""String_Node_Str"");
  format.setLabel(T_format_selected);
  format.addOption(-1,T_format_default);
  for (  BitstreamFormat bitstreamFormat : bitstreamFormats) {
    String supportLevel=""String_Node_Str"";
    if (bitstreamFormat.getSupportLevel() == BitstreamFormat.KNOWN)     supportLevel=""String_Node_Str"";
 else     if (bitstreamFormat.getSupportLevel() == BitstreamFormat.SUPPORTED)     supportLevel=""String_Node_Str"";
    String name=bitstreamFormat.getShortDescription() + ""String_Node_Str"" + supportLevel+ ""String_Node_Str"";
    int id=bitstreamFormat.getID();
    format.addOption(id,name);
  }
  if (currentFormat != null) {
    format.setOptionSelected(currentFormat.getID());
  }
 else   if (guessedFormat != null) {
    format.setOptionSelected(guessedFormat.getID());
  }
 else {
    format.setOptionSelected(-1);
  }
  edit.addItem(T_info2);
  Text userFormat=edit.addItem().addText(""String_Node_Str"");
  userFormat.setLabel(T_format_user);
  userFormat.setHelp(T_format_user_help);
  userFormat.setValue(bitstream.getUserFormatDescription());
  div.addHidden(""String_Node_Str"").setValue(bitstream.getID());
  org.dspace.app.xmlui.wing.element.Item actions=edit.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
}",0.9834651329978432
52313,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  DCValue[] titles=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] dateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] citation=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] publisher=item.getDC(""String_Node_Str"",null,Item.ANY);
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  CheckBox multipleTitles=form.addItem().addCheckBox(""String_Node_Str"");
  multipleTitles.setLabel(T_multiple_titles);
  multipleTitles.setHelp(T_multiple_titles_help);
  multipleTitles.addOption(""String_Node_Str"");
  if (submission.hasMultipleTitles()) {
    multipleTitles.setOptionSelected(""String_Node_Str"");
  }
  if (titles.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_multiple_titles_note);
    for (int i=0; i < titles.length; i++) {
      if (i > 0)       note.addContent(T_separator);
      note.addContent(""String_Node_Str"");
      note.addHighlight(""String_Node_Str"").addContent(titles[i].value);
      note.addContent(""String_Node_Str"");
    }
  }
  CheckBox publishedBefore=form.addItem().addCheckBox(""String_Node_Str"");
  publishedBefore.setLabel(T_published_before);
  publishedBefore.setHelp(T_published_before_help);
  publishedBefore.addOption(""String_Node_Str"");
  if (submission.isPublishedBefore()) {
    publishedBefore.setOptionSelected(""String_Node_Str"");
  }
  if (dateIssued.length > 0 || citation.length > 0 || publisher.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_published_before_note);
    if (dateIssued.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_date_issued);
      note.addContent(T_open);
      for (int i=0; i < dateIssued.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(dateIssued[i].value);
      }
      note.addContent(T_close);
    }
    if (dateIssued.length > 0 && (citation.length > 0 || publisher.length > 0))     note.addContent(T_separator);
    if (dateIssued.length > 0 && citation.length > 0 && publisher.length == 0) {
      note.addContent(T_and);
    }
    if (citation.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_citation);
      note.addContent(T_open);
      for (int i=0; i < citation.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(citation[i].value);
      }
      note.addContent(T_close);
    }
    if (citation.length > 0 && publisher.length > 0) {
      note.addContent(T_separator);
    }
    if ((dateIssued.length > 0 || citation.length > 0) && publisher.length > 0) {
      note.addContent(T_and);
    }
    if (publisher.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_publisher);
      note.addContent(T_open);
      for (int i=0; i < publisher.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(publisher[i].value);
      }
      note.addContent(T_close);
    }
  }
  addControlButtons(form);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
  div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  DCValue[] titles=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] dateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] citation=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] publisher=item.getDC(""String_Node_Str"",null,Item.ANY);
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  CheckBox multipleTitles=form.addItem().addCheckBox(""String_Node_Str"");
  multipleTitles.setLabel(T_multiple_titles);
  multipleTitles.setHelp(T_multiple_titles_help);
  multipleTitles.addOption(""String_Node_Str"");
  if (submission.hasMultipleTitles()) {
    multipleTitles.setOptionSelected(""String_Node_Str"");
  }
  if (titles.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_multiple_titles_note);
    for (int i=0; i < titles.length; i++) {
      if (i > 0)       note.addContent(T_separator);
      note.addContent(""String_Node_Str"");
      note.addHighlight(""String_Node_Str"").addContent(titles[i].value);
      note.addContent(""String_Node_Str"");
    }
  }
  CheckBox publishedBefore=form.addItem().addCheckBox(""String_Node_Str"");
  publishedBefore.setLabel(T_published_before);
  publishedBefore.setHelp(T_published_before_help);
  publishedBefore.addOption(""String_Node_Str"");
  if (submission.isPublishedBefore()) {
    publishedBefore.setOptionSelected(""String_Node_Str"");
  }
  if (dateIssued.length > 0 || citation.length > 0 || publisher.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_published_before_note);
    if (dateIssued.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_date_issued);
      note.addContent(T_open);
      for (int i=0; i < dateIssued.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(dateIssued[i].value);
      }
      note.addContent(T_close);
    }
    if (dateIssued.length > 0 && (citation.length > 0 || publisher.length > 0))     note.addContent(T_separator);
    if (dateIssued.length > 0 && citation.length > 0 && publisher.length == 0) {
      note.addContent(T_and);
    }
    if (citation.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_citation);
      note.addContent(T_open);
      for (int i=0; i < citation.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(citation[i].value);
      }
      note.addContent(T_close);
    }
    if (citation.length > 0 && publisher.length > 0) {
      note.addContent(T_separator);
    }
    if ((dateIssued.length > 0 || citation.length > 0) && publisher.length > 0) {
      note.addContent(T_and);
    }
    if (publisher.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_publisher);
      note.addContent(T_open);
      for (int i=0; i < publisher.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(publisher[i].value);
      }
      note.addContent(T_close);
    }
  }
  addControlButtons(form);
  div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
}",0.987958115183246
52314,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (CreativeCommons.isEnabled() && ccLicenseStep != null) {
    ccLicenseStep.addBody(body);
    return;
  }
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  String licenseText=collection.getLicense();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  Division inner=div.addDivision(""String_Node_Str"");
  inner.setHead(T_head);
  inner.addPara(T_info1);
  inner.addPara(T_info2);
  Division displayLicense=inner.addDivision(""String_Node_Str"",""String_Node_Str"");
  displayLicense.addSimpleHTMLFragment(true,licenseText);
  inner.addPara(T_info3);
  List controls=inner.addList(""String_Node_Str"",List.TYPE_FORM);
  CheckBox decision=controls.addItem().addCheckBox(""String_Node_Str"");
  decision.setLabel(T_decision_label);
  decision.addOption(""String_Node_Str"",T_decision_checkbox);
  if (this.errorFlag == org.dspace.submit.step.LicenseStep.STATUS_LICENSE_REJECTED) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",submissionInfo.getSubmissionLogInfo()));
    decision.addError(T_decision_error);
  }
  addControlButtons(controls);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (CreativeCommons.isEnabled() && ccLicenseStep != null) {
    ccLicenseStep.addBody(body);
    return;
  }
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  String licenseText=collection.getLicense();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  Division inner=div.addDivision(""String_Node_Str"");
  inner.setHead(T_head);
  inner.addPara(T_info1);
  inner.addPara(T_info2);
  Division displayLicense=inner.addDivision(""String_Node_Str"",""String_Node_Str"");
  displayLicense.addSimpleHTMLFragment(true,licenseText);
  inner.addPara(T_info3);
  List controls=inner.addList(""String_Node_Str"",List.TYPE_FORM);
  CheckBox decision=controls.addItem().addCheckBox(""String_Node_Str"");
  decision.setLabel(T_decision_label);
  decision.addOption(""String_Node_Str"",T_decision_checkbox);
  if (this.errorFlag == org.dspace.submit.step.LicenseStep.STATUS_LICENSE_REJECTED) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",submissionInfo.getSubmissionLogInfo()));
    decision.addError(T_decision_error);
  }
  addControlButtons(controls);
}",0.968384879725086
52315,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  org.dspace.app.xmlui.wing.element.Item actions=form.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_resume);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  org.dspace.app.xmlui.wing.element.Item actions=form.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_resume);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
}",0.9692101740294512
52316,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  SubmissionConfig subConfig=submissionInfo.getSubmissionConfig();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List review=div.addList(""String_Node_Str"",List.TYPE_FORM);
  review.setHead(T_head);
  Set submissionPagesSet=submissionInfo.getProgressBarInfo().keySet();
  String[] submissionPages=(String[])submissionPagesSet.toArray(new String[submissionPagesSet.size()]);
  for (int i=0; i < submissionPages.length; i++) {
    double currentStepAndPage=Double.valueOf(submissionPages[i]).doubleValue();
    if (currentStepAndPage == this.stepAndPage) {
      break;
    }
    SubmissionStepConfig stepConfig=subConfig.getStep(FlowUtils.getStep(currentStepAndPage));
    AbstractStep stepUIClass=loadXMLUIClass(stepConfig.getXMLUIClassName());
    try {
      parameters.setParameter(""String_Node_Str"",Double.toString(currentStepAndPage));
      stepUIClass.setup(resolver,objectModel,src,parameters);
    }
 catch (    Exception e) {
      throw new UIException(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"",e);
    }
    if (stepUIClass instanceof AbstractSubmissionStep) {
      List stepSection=((AbstractSubmissionStep)stepUIClass).addReviewSection(review);
      if (stepSection != null) {
        addJumpButton(stepSection,T_submit_jump,currentStepAndPage);
      }
    }
 else {
      log.warn(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"");
    }
  }
  addControlButtons(review);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  SubmissionConfig subConfig=submissionInfo.getSubmissionConfig();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List review=div.addList(""String_Node_Str"",List.TYPE_FORM);
  review.setHead(T_head);
  Set submissionPagesSet=submissionInfo.getProgressBarInfo().keySet();
  String[] submissionPages=(String[])submissionPagesSet.toArray(new String[submissionPagesSet.size()]);
  for (int i=0; i < submissionPages.length; i++) {
    double currentStepAndPage=Double.valueOf(submissionPages[i]).doubleValue();
    if (currentStepAndPage == this.stepAndPage) {
      break;
    }
    SubmissionStepConfig stepConfig=subConfig.getStep(FlowUtils.getStep(currentStepAndPage));
    AbstractStep stepUIClass=loadXMLUIClass(stepConfig.getXMLUIClassName());
    try {
      parameters.setParameter(""String_Node_Str"",Double.toString(currentStepAndPage));
      stepUIClass.setup(resolver,objectModel,src,parameters);
    }
 catch (    Exception e) {
      throw new UIException(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"",e);
    }
    if (stepUIClass instanceof AbstractSubmissionStep) {
      List stepSection=((AbstractSubmissionStep)stepUIClass).addReviewSection(review);
      if (stepSection != null) {
        addJumpButton(stepSection,T_submit_jump,currentStepAndPage);
      }
    }
 else {
      log.warn(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"");
    }
  }
  addControlButtons(review);
}",0.975763962065332
52317,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List saveOrCancel=div.addList(""String_Node_Str"",List.TYPE_FORM);
  saveOrCancel.setHead(T_head);
  saveOrCancel.addItem(T_info1);
  saveOrCancel.addItem().addButton(""String_Node_Str"").setValue(T_submit_back);
  org.dspace.app.xmlui.wing.element.Item actions=saveOrCancel.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_remove);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List saveOrCancel=div.addList(""String_Node_Str"",List.TYPE_FORM);
  saveOrCancel.setHead(T_head);
  saveOrCancel.addItem(T_info1);
  saveOrCancel.addItem().addButton(""String_Node_Str"").setValue(T_submit_back);
  org.dspace.app.xmlui.wing.element.Item actions=saveOrCancel.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_remove);
}",0.9498364231188658
52318,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection[] collections;
  DSpaceObject dso=HandleManager.resolveToObject(context,handle);
  if (dso != null && dso instanceof Community) {
    collections=Collection.findAuthorized(context,((Community)dso),Constants.ADD);
  }
 else {
    collections=Collection.findAuthorized(context,null,Constants.ADD);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  List list=div.addList(""String_Node_Str"",List.TYPE_FORM);
  list.setHead(T_head);
  Select select=list.addItem().addSelect(""String_Node_Str"");
  select.setLabel(T_collection);
  select.setHelp(T_collection_help);
  select.addOption(""String_Node_Str"",T_collection_default);
  for (  Collection collection : collections) {
    String name=collection.getMetadata(""String_Node_Str"");
    if (name.length() > 50)     name=name.substring(0,47) + ""String_Node_Str"";
    select.addOption(collection.getHandle(),name);
  }
  Button submit=list.addItem().addButton(""String_Node_Str"");
  submit.setValue(T_submit_next);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection[] collections;
  String actionURL=contextPath + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  DSpaceObject dso=HandleManager.resolveToObject(context,handle);
  if (dso != null && dso instanceof Community) {
    collections=Collection.findAuthorized(context,((Community)dso),Constants.ADD);
  }
 else {
    collections=Collection.findAuthorized(context,null,Constants.ADD);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  List list=div.addList(""String_Node_Str"",List.TYPE_FORM);
  list.setHead(T_head);
  Select select=list.addItem().addSelect(""String_Node_Str"");
  select.setLabel(T_collection);
  select.setHelp(T_collection_help);
  select.addOption(""String_Node_Str"",T_collection_default);
  for (  Collection collection : collections) {
    String name=collection.getMetadata(""String_Node_Str"");
    if (name.length() > 50)     name=name.substring(0,47) + ""String_Node_Str"";
    select.addOption(collection.getHandle(),name);
  }
  Button submit=list.addItem().addButton(""String_Node_Str"");
  submit.setValue(T_submit_next);
}",0.927818962153726
52319,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (this.editFile != null) {
    editFile.addBody(body);
    return;
  }
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  boolean workflow=submission instanceof WorkflowItem;
  Bundle[] bundles=item.getBundles(""String_Node_Str"");
  Bitstream[] bitstreams=new Bitstream[0];
  if (bundles.length > 0) {
    bitstreams=bundles[0].getBitstreams();
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_MULTIPART,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List upload=null;
  if (!workflow) {
    upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
    upload.setHead(T_head);
    File file=upload.addItem().addFile(""String_Node_Str"");
    file.setLabel(T_file);
    file.setHelp(T_file_help);
    file.setRequired();
    if (this.errorFlag == org.dspace.submit.step.UploadStep.STATUS_NO_FILES_ERROR)     file.addError(T_file_error);
    Text description=upload.addItem().addText(""String_Node_Str"");
    description.setLabel(T_description);
    description.setHelp(T_description_help);
    Button uploadSubmit=upload.addItem().addButton(""String_Node_Str"");
    uploadSubmit.setValue(T_submit_upload);
  }
  if (bitstreams.length > 0 || workflow) {
    Table summary=div.addTable(""String_Node_Str"",(bitstreams.length * 2) + 2,7);
    summary.setHead(T_head2);
    Row header=summary.addRow(Row.ROLE_HEADER);
    header.addCellContent(T_column1);
    header.addCellContent(T_column2);
    header.addCellContent(T_column3);
    header.addCellContent(T_column4);
    header.addCellContent(T_column5);
    header.addCellContent(T_column6);
    for (    Bitstream bitstream : bitstreams) {
      int id=bitstream.getID();
      String name=bitstream.getName();
      String url=contextPath + ""String_Node_Str"" + item.getID()+ ""String_Node_Str""+ name;
      long bytes=bitstream.getSize();
      String desc=bitstream.getDescription();
      String algorithm=bitstream.getChecksumAlgorithm();
      String checksum=bitstream.getChecksum();
      BitstreamFormat format=bitstream.getFormat();
      int support=format.getSupportLevel();
      Row row=summary.addRow();
      if (!workflow) {
        CheckBox remove=row.addCell().addCheckBox(""String_Node_Str"");
        remove.setLabel(""String_Node_Str"");
        remove.addOption(id);
      }
 else {
        row.addCell();
      }
      row.addCell().addXref(url,name);
      row.addCellContent(bytes + ""String_Node_Str"");
      if (desc == null || desc.length() == 0)       row.addCellContent(T_unknown_name);
 else       row.addCellContent(desc);
      if (format == null) {
        row.addCellContent(T_unknown_format);
      }
 else {
        Cell cell=row.addCell();
        cell.addContent(format.getMIMEType());
        cell.addContent(""String_Node_Str"");
switch (support) {
case 1:
          cell.addContent(T_supported);
        break;
case 2:
      cell.addContent(T_known);
    break;
case 3:
  cell.addContent(T_unsupported);
break;
}
}
Button edit=row.addCell().addButton(""String_Node_Str"" + id);
edit.setValue(T_submit_edit);
Row checksumRow=summary.addRow();
checksumRow.addCell();
Cell checksumCell=checksumRow.addCell(null,null,0,6,null);
checksumCell.addHighlight(""String_Node_Str"").addContent(T_checksum);
checksumCell.addContent(""String_Node_Str"");
checksumCell.addContent(algorithm + ""String_Node_Str"" + checksum);
}
if (!workflow) {
Row actionRow=summary.addRow();
actionRow.addCell();
Button removeSeleceted=actionRow.addCell(null,null,0,6,null).addButton(""String_Node_Str"");
removeSeleceted.setValue(T_submit_remove);
}
upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
}
addControlButtons(upload);
div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (this.editFile != null) {
    editFile.addBody(body);
    return;
  }
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  boolean workflow=submission instanceof WorkflowItem;
  Bundle[] bundles=item.getBundles(""String_Node_Str"");
  Bitstream[] bitstreams=new Bitstream[0];
  if (bundles.length > 0) {
    bitstreams=bundles[0].getBitstreams();
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_MULTIPART,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List upload=null;
  if (!workflow) {
    upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
    upload.setHead(T_head);
    File file=upload.addItem().addFile(""String_Node_Str"");
    file.setLabel(T_file);
    file.setHelp(T_file_help);
    file.setRequired();
    if (this.errorFlag == org.dspace.submit.step.UploadStep.STATUS_NO_FILES_ERROR)     file.addError(T_file_error);
    Text description=upload.addItem().addText(""String_Node_Str"");
    description.setLabel(T_description);
    description.setHelp(T_description_help);
    Button uploadSubmit=upload.addItem().addButton(""String_Node_Str"");
    uploadSubmit.setValue(T_submit_upload);
  }
  if (bitstreams.length > 0 || workflow) {
    Table summary=div.addTable(""String_Node_Str"",(bitstreams.length * 2) + 2,7);
    summary.setHead(T_head2);
    Row header=summary.addRow(Row.ROLE_HEADER);
    header.addCellContent(T_column1);
    header.addCellContent(T_column2);
    header.addCellContent(T_column3);
    header.addCellContent(T_column4);
    header.addCellContent(T_column5);
    header.addCellContent(T_column6);
    for (    Bitstream bitstream : bitstreams) {
      int id=bitstream.getID();
      String name=bitstream.getName();
      String url=contextPath + ""String_Node_Str"" + item.getID()+ ""String_Node_Str""+ name;
      long bytes=bitstream.getSize();
      String desc=bitstream.getDescription();
      String algorithm=bitstream.getChecksumAlgorithm();
      String checksum=bitstream.getChecksum();
      BitstreamFormat format=bitstream.getFormat();
      int support=format.getSupportLevel();
      Row row=summary.addRow();
      if (!workflow) {
        CheckBox remove=row.addCell().addCheckBox(""String_Node_Str"");
        remove.setLabel(""String_Node_Str"");
        remove.addOption(id);
      }
 else {
        row.addCell();
      }
      row.addCell().addXref(url,name);
      row.addCellContent(bytes + ""String_Node_Str"");
      if (desc == null || desc.length() == 0)       row.addCellContent(T_unknown_name);
 else       row.addCellContent(desc);
      if (format == null) {
        row.addCellContent(T_unknown_format);
      }
 else {
        Cell cell=row.addCell();
        cell.addContent(format.getMIMEType());
        cell.addContent(""String_Node_Str"");
switch (support) {
case 1:
          cell.addContent(T_supported);
        break;
case 2:
      cell.addContent(T_known);
    break;
case 3:
  cell.addContent(T_unsupported);
break;
}
}
Button edit=row.addCell().addButton(""String_Node_Str"" + id);
edit.setValue(T_submit_edit);
Row checksumRow=summary.addRow();
checksumRow.addCell();
Cell checksumCell=checksumRow.addCell(null,null,0,6,null);
checksumCell.addHighlight(""String_Node_Str"").addContent(T_checksum);
checksumCell.addContent(""String_Node_Str"");
checksumCell.addContent(algorithm + ""String_Node_Str"" + checksum);
}
if (!workflow) {
Row actionRow=summary.addRow();
actionRow.addCell();
Button removeSeleceted=actionRow.addCell(null,null,0,6,null).addButton(""String_Node_Str"");
removeSeleceted.setValue(T_submit_remove);
}
upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
}
addControlButtons(upload);
}",0.9886449659348978
52320,"/** 
 * Initialise various variables, read in config etc.
 * @param context DSpace context
 */
private static void init(Context context) throws SQLException, IOException {
  if (licenseFormat != -1) {
    return;
  }
  BitstreamFormat bf=BitstreamFormat.findByShortDescription(context,""String_Node_Str"");
  licenseFormat=bf.getID();
  String configFile=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
  InputStream is=new FileInputStream(configFile);
  dcToMODS=new Properties();
  dcToMODS.load(is);
}","/** 
 * Initialise various variables, read in config etc.
 * @param context DSpace context
 */
private static void init(Context context) throws SQLException, IOException {
  if (licenseFormat != -1) {
    return;
  }
  BitstreamFormat bf=BitstreamFormat.findByShortDescription(context,""String_Node_Str"");
  licenseFormat=bf.getID();
  String configFile=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
  InputStream is=null;
  try {
    is=new FileInputStream(configFile);
    dcToMODS=new Properties();
    dcToMODS.load(is);
  }
  finally {
    if (is != null)     try {
      is.close();
    }
 catch (    IOException ioe) {
    }
  }
}",0.8948995363214838
52321,"/** 
 * read in the action map file which converts log file line actions into actions which are more understandable to humans
 * @param map     the map file
 */
public static void readMap(String map) throws IOException {
  FileReader fr=null;
  BufferedReader br=null;
  String record=null;
  try {
    fr=new FileReader(map);
    br=new BufferedReader(fr);
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"");
    return;
  }
  while ((record=br.readLine()) != null) {
    Matcher matchReal=real.matcher(record);
    if (matchReal.matches()) {
      actionMap.put(matchReal.group(1).trim(),matchReal.group(2).trim());
    }
  }
}","/** 
 * read in the action map file which converts log file line actions into actions which are more understandable to humans
 * @param map     the map file
 */
public static void readMap(String map) throws IOException {
  FileReader fr=null;
  BufferedReader br=null;
  try {
    String record=null;
    try {
      fr=new FileReader(map);
      br=new BufferedReader(fr);
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"");
      return;
    }
    while ((record=br.readLine()) != null) {
      Matcher matchReal=real.matcher(record);
      if (matchReal.matches()) {
        actionMap.put(matchReal.group(1).trim(),matchReal.group(2).trim());
      }
    }
  }
  finally {
    if (br != null)     try {
      br.close();
    }
 catch (    IOException ioe) {
    }
    if (fr != null)     try {
      fr.close();
    }
 catch (    IOException ioe) {
    }
  }
}",0.8067444876783398
52322,"/** 
 * Return a List of the policies for a group
 * @param c  current context
 * @param g  group to retrieve policies for
 * @return List of <code>ResourcePolicy</code> objects
 */
public static List<ResourcePolicy> getPoliciesForGroup(Context c,Group g) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"",g.getID());
  List<ResourcePolicy> policies=new ArrayList<ResourcePolicy>();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
    if (cachepolicy != null) {
      policies.add(cachepolicy);
    }
 else {
      policies.add(new ResourcePolicy(c,row));
    }
  }
  tri.close();
  return policies;
}","/** 
 * Return a List of the policies for a group
 * @param c  current context
 * @param g  group to retrieve policies for
 * @return List of <code>ResourcePolicy</code> objects
 */
public static List<ResourcePolicy> getPoliciesForGroup(Context c,Group g) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"",g.getID());
  List<ResourcePolicy> policies=new ArrayList<ResourcePolicy>();
  try {
    while (tri.hasNext()) {
      TableRow row=tri.next();
      ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
      if (cachepolicy != null) {
        policies.add(cachepolicy);
      }
 else {
        policies.add(new ResourcePolicy(c,row));
      }
    }
  }
  finally {
    if (tri != null)     tri.close();
  }
  return policies;
}",0.9579524680073126
52323,"/** 
 * Return a list of policies for an object that match the action
 * @param c context
 * @param o DSpaceObject policies relate to
 * @param actionID action (defined in class Constants)
 * @throws SQLException if there's a database problem
 */
public static List<ResourcePolicy> getPoliciesActionFilter(Context c,DSpaceObject o,int actionID) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",o.getType(),o.getID(),actionID);
  List<ResourcePolicy> policies=new ArrayList<ResourcePolicy>();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
    if (cachepolicy != null) {
      policies.add(cachepolicy);
    }
 else {
      policies.add(new ResourcePolicy(c,row));
    }
  }
  tri.close();
  return policies;
}","/** 
 * Return a list of policies for an object that match the action
 * @param c context
 * @param o DSpaceObject policies relate to
 * @param actionID action (defined in class Constants)
 * @throws SQLException if there's a database problem
 */
public static List<ResourcePolicy> getPoliciesActionFilter(Context c,DSpaceObject o,int actionID) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",o.getType(),o.getID(),actionID);
  List<ResourcePolicy> policies=new ArrayList<ResourcePolicy>();
  try {
    while (tri.hasNext()) {
      TableRow row=tri.next();
      ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
      if (cachepolicy != null) {
        policies.add(cachepolicy);
      }
 else {
        policies.add(new ResourcePolicy(c,row));
      }
    }
  }
  finally {
    if (tri != null)     tri.close();
  }
  return policies;
}",0.9637033140452392
52324,"/** 
 * Returns all groups authorized to perform an action on an object. Returns empty array if no matches.
 * @param c current context
 * @param o object
 * @param actionID ID of action frm <code>org.dspace.core.Constants</code>
 * @return array of <code>Group</code>s that can perform the specifiedaction on the specified object
 * @throws java.sql.SQLException if there's a database problem
 */
public static Group[] getAuthorizedGroups(Context c,DSpaceObject o,int actionID) throws java.sql.SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",o.getType(),o.getID(),actionID);
  List<Group> groups=new ArrayList<Group>();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
    ResourcePolicy myPolicy=null;
    if (cachepolicy != null) {
      myPolicy=cachepolicy;
    }
 else {
      myPolicy=new ResourcePolicy(c,row);
    }
    Group myGroup=myPolicy.getGroup();
    if (myGroup != null) {
      groups.add(myGroup);
    }
  }
  tri.close();
  Group[] groupArray=new Group[groups.size()];
  groupArray=groups.toArray(groupArray);
  return groupArray;
}","/** 
 * Returns all groups authorized to perform an action on an object. Returns empty array if no matches.
 * @param c current context
 * @param o object
 * @param actionID ID of action frm <code>org.dspace.core.Constants</code>
 * @return array of <code>Group</code>s that can perform the specifiedaction on the specified object
 * @throws java.sql.SQLException if there's a database problem
 */
public static Group[] getAuthorizedGroups(Context c,DSpaceObject o,int actionID) throws java.sql.SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",o.getType(),o.getID(),actionID);
  List<Group> groups=new ArrayList<Group>();
  try {
    while (tri.hasNext()) {
      TableRow row=tri.next();
      ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
      ResourcePolicy myPolicy=null;
      if (cachepolicy != null) {
        myPolicy=cachepolicy;
      }
 else {
        myPolicy=new ResourcePolicy(c,row);
      }
      Group myGroup=myPolicy.getGroup();
      if (myGroup != null) {
        groups.add(myGroup);
      }
    }
  }
  finally {
    if (tri != null)     tri.close();
  }
  Group[] groupArray=new Group[groups.size()];
  groupArray=groups.toArray(groupArray);
  return groupArray;
}",0.9694154084397988
52325,"/** 
 * Return a List of the policies for an object
 * @param c  current context
 * @param o  object to retrieve policies for
 * @return List of <code>ResourcePolicy</code> objects
 */
public static List<ResourcePolicy> getPolicies(Context c,DSpaceObject o) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"",o.getType(),o.getID());
  List<ResourcePolicy> policies=new ArrayList();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
    if (cachepolicy != null) {
      policies.add(cachepolicy);
    }
 else {
      policies.add(new ResourcePolicy(c,row));
    }
  }
  tri.close();
  return policies;
}","/** 
 * Return a List of the policies for an object
 * @param c  current context
 * @param o  object to retrieve policies for
 * @return List of <code>ResourcePolicy</code> objects
 */
public static List<ResourcePolicy> getPolicies(Context c,DSpaceObject o) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"",o.getType(),o.getID());
  List<ResourcePolicy> policies=new ArrayList();
  try {
    while (tri.hasNext()) {
      TableRow row=tri.next();
      ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
      if (cachepolicy != null) {
        policies.add(cachepolicy);
      }
 else {
        policies.add(new ResourcePolicy(c,row));
      }
    }
  }
  finally {
    if (tri != null)     tri.close();
  }
  return policies;
}",0.9578497251069028
52326,"public ServiceDocument doServiceDocument(ServiceDocumentRequest request) throws SWORDAuthenticationException, SWORDException {
  if (log.isDebugEnabled()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  }
  try {
    SWORDContext sc=this.authenticate(request);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + request.getUsername() + ""String_Node_Str""+ request.getOnBehalfOf()));
    SWORDService service=new SWORDService();
    service.setContext(context);
    service.setSWORDContext(sc);
    ServiceDocument doc=service.getServiceDocument();
    return doc;
  }
 catch (  DSpaceSWORDException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
 finally {
    if (context != null) {
      context.abort();
    }
  }
}","public ServiceDocument doServiceDocument(ServiceDocumentRequest request) throws SWORDAuthenticationException, SWORDException {
  Context context=constructContext(request.getIPAddress());
  if (log.isDebugEnabled()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  }
  try {
    SWORDContext sc=this.authenticate(context,request);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + request.getUsername() + ""String_Node_Str""+ request.getOnBehalfOf()));
    SWORDService service=new SWORDService();
    service.setContext(context);
    service.setSWORDContext(sc);
    ServiceDocument doc=service.getServiceDocument();
    return doc;
  }
 catch (  DSpaceSWORDException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
 finally {
    if (context != null) {
      context.abort();
    }
  }
}",0.9607843137254902
52327,"/** 
 * Construct the context object member variable of this class using the passed IP address as part of the loggable information
 * @param ip	the ip address of the incoming request
 * @throws SWORDException
 */
private void constructContext(String ip) throws SWORDException {
  try {
    this.context=new Context();
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
  this.context.setExtraLogInfo(""String_Node_Str"" + ip);
}","/** 
 * Construct the context object member variable of this class using the passed IP address as part of the loggable information
 * @param ip	the ip address of the incoming request
 * @throws SWORDException
 */
private Context constructContext(String ip) throws SWORDException {
  try {
    Context context=new Context();
    context.setExtraLogInfo(""String_Node_Str"" + ip);
    return context;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
}",0.8498527968596663
52328,"/** 
 * Authenticate the given username/password pair, in conjunction with the onBehalfOf user.  The rules are that the username/password pair must successfully authenticate the user, and the onBehalfOf user must exist in the user database.
 * @param un
 * @param pw
 * @param obo
 * @return	a SWORD context holding the various user information
 * @throws SWORDAuthenticationException
 * @throws SWORDException
 */
private SWORDContext authenticate(String un,String pw,String obo) throws SWORDAuthenticationException, SWORDException {
  if (""String_Node_Str"".equals(obo)) {
    obo=null;
  }
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
  try {
    SWORDContext sc=new SWORDContext();
    SWORDAuthentication auth=new SWORDAuthentication();
    EPerson ep=null;
    boolean authenticated=false;
    if (auth.authenticates(this.context,un,pw)) {
      ep=context.getCurrentUser();
      if (ep != null) {
        authenticated=true;
        sc.setAuthenticated(ep);
      }
      if (obo != null) {
        EPerson epObo=EPerson.findByEmail(this.context,obo);
        if (epObo != null) {
          sc.setOnBehalfOf(epObo);
        }
 else {
          authenticated=false;
        }
      }
    }
    if (ep != null && authenticated) {
      this.context.setCurrentUser(ep);
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + ep.getID()));
    }
 else {
      if (ep != null) {
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un));
        throw new SWORDAuthenticationException(""String_Node_Str"");
      }
 else {
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
        throw new SWORDAuthenticationException(""String_Node_Str"");
      }
    }
    return sc;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
catch (  AuthorizeException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDAuthenticationException(""String_Node_Str"",e);
  }
}","/** 
 * Authenticate the given username/password pair, in conjunction with the onBehalfOf user.  The rules are that the username/password pair must successfully authenticate the user, and the onBehalfOf user must exist in the user database.
 * @param un
 * @param pw
 * @param obo
 * @return	a SWORD context holding the various user information
 * @throws SWORDAuthenticationException
 * @throws SWORDException
 */
private SWORDContext authenticate(Context context,String un,String pw,String obo) throws SWORDAuthenticationException, SWORDException {
  if (""String_Node_Str"".equals(obo)) {
    obo=null;
  }
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
  try {
    SWORDContext sc=new SWORDContext();
    SWORDAuthentication auth=new SWORDAuthentication();
    EPerson ep=null;
    boolean authenticated=false;
    if (auth.authenticates(context,un,pw)) {
      ep=context.getCurrentUser();
      if (ep != null) {
        authenticated=true;
        sc.setAuthenticated(ep);
      }
      if (obo != null) {
        EPerson epObo=EPerson.findByEmail(context,obo);
        if (epObo != null) {
          sc.setOnBehalfOf(epObo);
        }
 else {
          authenticated=false;
        }
      }
    }
    if (ep != null && authenticated) {
      context.setCurrentUser(ep);
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + ep.getID()));
    }
 else {
      if (ep != null) {
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un));
        throw new SWORDAuthenticationException(""String_Node_Str"");
      }
 else {
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
        throw new SWORDAuthenticationException(""String_Node_Str"");
      }
    }
    return sc;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
catch (  AuthorizeException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDAuthenticationException(""String_Node_Str"",e);
  }
}",0.9926835024781684
52329,"public DepositResponse doDeposit(Deposit deposit) throws SWORDAuthenticationException, SWORDException {
  try {
    if (log.isDebugEnabled()) {
      log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    }
    SWORDContext sc=this.authenticate(deposit);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + deposit.getUsername() + ""String_Node_Str""+ deposit.getOnBehalfOf()));
    DepositManager dm=new DepositManager();
    dm.setContext(context);
    dm.setDeposit(deposit);
    dm.setSWORDContext(sc);
    DepositResponse response=dm.deposit();
    if (context != null && context.isValid()) {
      context.commit();
    }
    return response;
  }
 catch (  DSpaceSWORDException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDAuthenticationException(""String_Node_Str"",e);
  }
catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
 finally {
    if (context != null && context.isValid()) {
      context.abort();
    }
  }
}","public DepositResponse doDeposit(Deposit deposit) throws SWORDAuthenticationException, SWORDException {
  Context context=constructContext(deposit.getIPAddress());
  try {
    if (log.isDebugEnabled()) {
      log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    }
    SWORDContext sc=this.authenticate(context,deposit);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + deposit.getUsername() + ""String_Node_Str""+ deposit.getOnBehalfOf()));
    DepositManager dm=new DepositManager();
    dm.setContext(context);
    dm.setDeposit(deposit);
    dm.setSWORDContext(sc);
    DepositResponse response=dm.deposit();
    if (context != null && context.isValid()) {
      context.commit();
    }
    return response;
  }
 catch (  DSpaceSWORDException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDAuthenticationException(""String_Node_Str"",e);
  }
catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
 finally {
    if (context != null && context.isValid()) {
      context.abort();
    }
  }
}",0.9688644688644688
52330,"/** 
 * Moves the item from one collection to another one
 * @throws SQLException
 * @throws AuthorizeException
 * @throws IOException
 */
public void move(Collection from,Collection to) throws SQLException, AuthorizeException, IOException {
  if (isOwningCollection(from)) {
    setOwningCollection(to);
    update();
  }
  to.addItem(this);
  from.removeItem(this);
}","/** 
 * Moves the item from one collection to another one
 * @throws SQLException
 * @throws AuthorizeException
 * @throws IOException
 */
public void move(Collection from,Collection to) throws SQLException, AuthorizeException, IOException {
  to.addItem(this);
  from.removeItem(this);
  if (isOwningCollection(from)) {
    setOwningCollection(to);
    update();
  }
 else {
    ourContext.addEvent(new Event(Event.MODIFY,Constants.ITEM,getID(),null));
  }
}",0.6956521739130435
52331,"/** 
 * Log the given user in as a real authenticated user. This should only be used after  a user has presented their credintals and they have been validated. 
 * @param context DSpace context
 * @param request HTTP request
 * @param eperson the eperson logged in
 */
private static void logIn(Context context,HttpServletRequest request,EPerson eperson) throws SQLException {
  if (eperson == null)   return;
  HttpSession session=request.getSession();
  context.setCurrentUser(eperson);
  if (!AuthorizeManager.isAdmin(context) && !SystemwideAlerts.canUserStartSession()) {
    context.setCurrentUser(null);
    return;
  }
  int[] groupIDs=AuthenticationManager.getSpecialGroups(context,request);
  for (  int groupID : groupIDs)   context.setSpecialGroup(groupID);
  session.setAttribute(CURRENT_IP_ADDRESS,request.getRemoteAddr());
  session.setAttribute(EFFECTIVE_USER_ID,eperson.getID());
  session.setAttribute(AUTHENTICATED_USER_ID,eperson.getID());
}","/** 
 * Log the given user in as a real authenticated user. This should only be used after  a user has presented their credintals and they have been validated. This method  signature is provided to be easier to call from flow scripts.
 * @param objectModel The cocoon object model.
 * @param eperson the eperson logged in
 */
public static void logIn(Map objectModel,EPerson eperson) throws SQLException {
  final HttpServletRequest request=(HttpServletRequest)objectModel.get(HttpEnvironment.HTTP_REQUEST_OBJECT);
  Context context=ContextUtil.obtainContext(objectModel);
  logIn(context,request,eperson);
}",0.3903061224489796
52332,"/** 
 * Log the given user in as a real authenticated user. This should only be used after  a user has presented their credintals and they have been validated. 
 * @param context DSpace context
 * @param request HTTP request
 * @param eperson the eperson logged in
 */
private static void logIn(Context context,HttpServletRequest request,EPerson eperson) throws SQLException {
  if (eperson == null)   return;
  HttpSession session=request.getSession();
  context.setCurrentUser(eperson);
  if (!AuthorizeManager.isAdmin(context) && !SystemwideAlerts.canUserStartSession()) {
    context.setCurrentUser(null);
    return;
  }
  int[] groupIDs=AuthenticationManager.getSpecialGroups(context,request);
  for (  int groupID : groupIDs)   context.setSpecialGroup(groupID);
  session.setAttribute(CURRENT_IP_ADDRESS,request.getRemoteAddr());
  session.setAttribute(EFFECTIVE_USER_ID,eperson.getID());
  session.setAttribute(AUTHENTICATED_USER_ID,eperson.getID());
}","/** 
 * Log the given user in as a real authenticated user. This should only be used after  a user has presented their credintals and they have been validated. This method  signature is provided to be easier to call from flow scripts.
 * @param objectModel The cocoon object model.
 * @param eperson the eperson logged in
 */
public static void logIn(Map objectModel,EPerson eperson) throws SQLException {
  final HttpServletRequest request=(HttpServletRequest)objectModel.get(HttpEnvironment.HTTP_REQUEST_OBJECT);
  Context context=ContextUtil.obtainContext(objectModel);
  logIn(context,request,eperson);
}",0.3903061224489796
52333,"/** 
 * Makes the jump-list navigation for the results
 * @param div
 * @param info
 * @param params
 * @throws WingException
 */
private void addBrowseJumpNavigation(Division div,BrowseInfo info,BrowseParams params) throws WingException {
  String type=info.getBrowseIndex().getName();
  Map<String,String> queryParams=new HashMap<String,String>();
  queryParams.putAll(params.getCommonParameters());
  queryParams.putAll(params.getControlParameters());
  Division jump=div.addInteractiveDivision(""String_Node_Str"",WITHDRAWN_URL_BASE,Division.METHOD_POST,""String_Node_Str"");
  for (  String key : queryParams.keySet())   jump.addHidden(key).setValue(queryParams.get(key));
  if (isSortedByDate(info)) {
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_select);
    Select month=jumpForm.addSelect(BrowseParams.MONTH);
    month.addOption(false,""String_Node_Str"",T_choose_month);
    for (int i=1; i <= 12; i++) {
      month.addOption(false,String.valueOf(i),DCDate.getMonthName(i,Locale.getDefault()));
    }
    Select year=jumpForm.addSelect(BrowseParams.YEAR);
    year.addOption(false,""String_Node_Str"",T_choose_year);
    int currentYear=DCDate.getCurrent().getYear();
    int i=currentYear;
    int oneYearBreak=((currentYear - ONE_YEAR_LIMIT) / 5) * 5;
    int fiveYearBreak=((currentYear - FIVE_YEAR_LIMIT) / 10) * 10;
    int tenYearBreak=(currentYear - TEN_YEAR_LIMIT);
    do {
      year.addOption(false,String.valueOf(i),String.valueOf(i));
      if (i <= fiveYearBreak)       i-=10;
 else       if (i <= oneYearBreak)       i-=5;
 else       i--;
    }
 while (i > tenYearBreak);
    jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_year);
    jumpForm.addText(""String_Node_Str"").setHelp(T_jump_year_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
 else {
    List jumpList=jump.addList(""String_Node_Str"",List.TYPE_SIMPLE,""String_Node_Str"");
    for (char c='A'; c <= 'Z'; c++) {
      Map<String,String> cQuery=new HashMap<String,String>(queryParams);
      cQuery.put(BrowseParams.STARTS_WITH,Character.toString(c));
      jumpList.addItemXref(super.generateURL(WITHDRAWN_URL_BASE,cQuery),Character.toString(c));
    }
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_starts_with);
    jumpForm.addText(BrowseParams.STARTS_WITH).setHelp(T_starts_with_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
}","/** 
 * Makes the jump-list navigation for the results
 * @param div
 * @param info
 * @param params
 * @throws WingException
 */
private void addBrowseJumpNavigation(Division div,BrowseInfo info,BrowseParams params) throws WingException {
  String type=info.getBrowseIndex().getName();
  Map<String,String> queryParams=new HashMap<String,String>();
  queryParams.putAll(params.getCommonParameters());
  queryParams.putAll(params.getControlParameters());
  Division jump=div.addInteractiveDivision(""String_Node_Str"",WITHDRAWN_URL_BASE,Division.METHOD_POST,""String_Node_Str"");
  for (  String key : queryParams.keySet())   jump.addHidden(key).setValue(queryParams.get(key));
  if (isSortedByDate(info)) {
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_select);
    Select month=jumpForm.addSelect(BrowseParams.MONTH);
    month.addOption(false,""String_Node_Str"",T_choose_month);
    for (int i=1; i <= 12; i++) {
      month.addOption(false,String.valueOf(i),DCDate.getMonthName(i,Locale.getDefault()));
    }
    Select year=jumpForm.addSelect(BrowseParams.YEAR);
    year.addOption(false,""String_Node_Str"",T_choose_year);
    int currentYear=DCDate.getCurrent().getYear();
    int i=currentYear;
    int oneYearBreak=((currentYear - ONE_YEAR_LIMIT) / 5) * 5;
    int fiveYearBreak=((currentYear - FIVE_YEAR_LIMIT) / 10) * 10;
    int tenYearBreak=(currentYear - TEN_YEAR_LIMIT);
    do {
      year.addOption(false,String.valueOf(i),String.valueOf(i));
      if (i <= fiveYearBreak)       i-=10;
 else       if (i <= oneYearBreak)       i-=5;
 else       i--;
    }
 while (i > tenYearBreak);
    jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_year);
    jumpForm.addText(BrowseParams.STARTS_WITH).setHelp(T_jump_year_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
 else {
    List jumpList=jump.addList(""String_Node_Str"",List.TYPE_SIMPLE,""String_Node_Str"");
    for (char c='A'; c <= 'Z'; c++) {
      Map<String,String> cQuery=new HashMap<String,String>(queryParams);
      cQuery.put(BrowseParams.STARTS_WITH,Character.toString(c));
      jumpList.addItemXref(super.generateURL(WITHDRAWN_URL_BASE,cQuery),Character.toString(c));
    }
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_starts_with);
    jumpForm.addText(BrowseParams.STARTS_WITH).setHelp(T_starts_with_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
}",0.9914494264859228
52334,"/** 
 * Makes the jump-list navigation for the results
 * @param div
 * @param info
 * @param params
 * @throws WingException
 */
private void addBrowseJumpNavigation(Division div,BrowseInfo info,BrowseParams params) throws WingException {
  String type=info.getBrowseIndex().getName();
  Map<String,String> queryParams=new HashMap<String,String>();
  queryParams.putAll(params.getCommonParameters());
  queryParams.putAll(params.getControlParameters());
  Division jump=div.addInteractiveDivision(""String_Node_Str"",BROWSE_URL_BASE,Division.METHOD_POST,""String_Node_Str"");
  for (  String key : queryParams.keySet())   jump.addHidden(key).setValue(queryParams.get(key));
  if (isSortedByDate(info)) {
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_select);
    Select month=jumpForm.addSelect(BrowseParams.MONTH);
    month.addOption(false,""String_Node_Str"",T_choose_month);
    for (int i=1; i <= 12; i++) {
      month.addOption(false,String.valueOf(i),DCDate.getMonthName(i,Locale.getDefault()));
    }
    Select year=jumpForm.addSelect(BrowseParams.YEAR);
    year.addOption(false,""String_Node_Str"",T_choose_year);
    int currentYear=DCDate.getCurrent().getYear();
    int i=currentYear;
    int oneYearBreak=((currentYear - ONE_YEAR_LIMIT) / 5) * 5;
    int fiveYearBreak=((currentYear - FIVE_YEAR_LIMIT) / 10) * 10;
    int tenYearBreak=(currentYear - TEN_YEAR_LIMIT);
    do {
      year.addOption(false,String.valueOf(i),String.valueOf(i));
      if (i <= fiveYearBreak)       i-=10;
 else       if (i <= oneYearBreak)       i-=5;
 else       i--;
    }
 while (i > tenYearBreak);
    jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_year);
    jumpForm.addText(""String_Node_Str"").setHelp(T_jump_year_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
 else {
    List jumpList=jump.addList(""String_Node_Str"",List.TYPE_SIMPLE,""String_Node_Str"");
    Map<String,String> zeroQuery=new HashMap<String,String>(queryParams);
    zeroQuery.put(BrowseParams.STARTS_WITH,""String_Node_Str"");
    jumpList.addItemXref(super.generateURL(BROWSE_URL_BASE,zeroQuery),""String_Node_Str"");
    for (char c='A'; c <= 'Z'; c++) {
      Map<String,String> cQuery=new HashMap<String,String>(queryParams);
      cQuery.put(BrowseParams.STARTS_WITH,Character.toString(c));
      jumpList.addItemXref(super.generateURL(BROWSE_URL_BASE,cQuery),Character.toString(c));
    }
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_starts_with);
    jumpForm.addText(BrowseParams.STARTS_WITH).setHelp(T_starts_with_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
}","/** 
 * Makes the jump-list navigation for the results
 * @param div
 * @param info
 * @param params
 * @throws WingException
 */
private void addBrowseJumpNavigation(Division div,BrowseInfo info,BrowseParams params) throws WingException {
  String type=info.getBrowseIndex().getName();
  Map<String,String> queryParams=new HashMap<String,String>();
  queryParams.putAll(params.getCommonParameters());
  queryParams.putAll(params.getControlParameters());
  Division jump=div.addInteractiveDivision(""String_Node_Str"",BROWSE_URL_BASE,Division.METHOD_POST,""String_Node_Str"");
  for (  String key : queryParams.keySet())   jump.addHidden(key).setValue(queryParams.get(key));
  if (isSortedByDate(info)) {
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_select);
    Select month=jumpForm.addSelect(BrowseParams.MONTH);
    month.addOption(false,""String_Node_Str"",T_choose_month);
    for (int i=1; i <= 12; i++) {
      month.addOption(false,String.valueOf(i),DCDate.getMonthName(i,Locale.getDefault()));
    }
    Select year=jumpForm.addSelect(BrowseParams.YEAR);
    year.addOption(false,""String_Node_Str"",T_choose_year);
    int currentYear=DCDate.getCurrent().getYear();
    int i=currentYear;
    int oneYearBreak=((currentYear - ONE_YEAR_LIMIT) / 5) * 5;
    int fiveYearBreak=((currentYear - FIVE_YEAR_LIMIT) / 10) * 10;
    int tenYearBreak=(currentYear - TEN_YEAR_LIMIT);
    do {
      year.addOption(false,String.valueOf(i),String.valueOf(i));
      if (i <= fiveYearBreak)       i-=10;
 else       if (i <= oneYearBreak)       i-=5;
 else       i--;
    }
 while (i > tenYearBreak);
    jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_year);
    jumpForm.addText(BrowseParams.STARTS_WITH).setHelp(T_jump_year_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
 else {
    List jumpList=jump.addList(""String_Node_Str"",List.TYPE_SIMPLE,""String_Node_Str"");
    Map<String,String> zeroQuery=new HashMap<String,String>(queryParams);
    zeroQuery.put(BrowseParams.STARTS_WITH,""String_Node_Str"");
    jumpList.addItemXref(super.generateURL(BROWSE_URL_BASE,zeroQuery),""String_Node_Str"");
    for (char c='A'; c <= 'Z'; c++) {
      Map<String,String> cQuery=new HashMap<String,String>(queryParams);
      cQuery.put(BrowseParams.STARTS_WITH,Character.toString(c));
      jumpList.addItemXref(super.generateURL(BROWSE_URL_BASE,cQuery),Character.toString(c));
    }
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_starts_with);
    jumpForm.addText(BrowseParams.STARTS_WITH).setHelp(T_starts_with_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
}",0.9921710903188848
52335,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  int state=((WorkflowItem)submission).getState();
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_workflow_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  Table table=div.addTable(""String_Node_Str"",1,1);
  table.setHead(T_info1);
  Row row;
  if (state == WFSTATE_STEP1POOL || state == WFSTATE_STEP2POOL || state == WFSTATE_STEP3POOL) {
    row=table.addRow();
    row.addCellContent(T_take_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_take_submit);
    row=table.addRow();
    row.addCellContent(T_leave_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_leave_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_approve_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_approve_submit);
  }
  if (state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_commit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_commit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_reject_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_reject_submit);
  }
  if (state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_edit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_edit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2 || state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_return_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_return_submit);
  }
  row=table.addRow();
  row.addCell(0,2).addButton(""String_Node_Str"").setValue(T_cancel_submit);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  int state=((WorkflowItem)submission).getState();
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_workflow_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  Table table=div.addTable(""String_Node_Str"",1,1);
  table.setHead(T_info1);
  Row row;
  if (state == WFSTATE_STEP1POOL || state == WFSTATE_STEP2POOL || state == WFSTATE_STEP3POOL) {
    row=table.addRow();
    row.addCellContent(T_take_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_take_submit);
    row=table.addRow();
    row.addCellContent(T_leave_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_leave_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_approve_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_approve_submit);
  }
  if (state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_commit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_commit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_reject_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_reject_submit);
  }
  if (state == WFSTATE_STEP2 || state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_edit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_edit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2 || state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_return_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_return_submit);
  }
  row=table.addRow();
  row.addCell(0,2).addButton(""String_Node_Str"").setValue(T_cancel_submit);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}",0.9953982300884956
52336,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  int state=((WorkflowItem)submission).getState();
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_workflow_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  Table table=div.addTable(""String_Node_Str"",1,1);
  table.setHead(T_info1);
  Row row;
  if (state == WFSTATE_STEP1POOL || state == WFSTATE_STEP2POOL || state == WFSTATE_STEP3POOL) {
    row=table.addRow();
    row.addCellContent(T_take_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_take_submit);
    row=table.addRow();
    row.addCellContent(T_leave_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_leave_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_approve_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_approve_submit);
  }
  if (state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_commit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_commit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_reject_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_reject_submit);
  }
  if (state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_edit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_edit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2 || state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_return_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_return_submit);
  }
  row=table.addRow();
  row.addCell(0,2).addButton(""String_Node_Str"").setValue(T_cancel_submit);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  int state=((WorkflowItem)submission).getState();
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_workflow_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  Table table=div.addTable(""String_Node_Str"",1,1);
  table.setHead(T_info1);
  Row row;
  if (state == WFSTATE_STEP1POOL || state == WFSTATE_STEP2POOL || state == WFSTATE_STEP3POOL) {
    row=table.addRow();
    row.addCellContent(T_take_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_take_submit);
    row=table.addRow();
    row.addCellContent(T_leave_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_leave_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_approve_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_approve_submit);
  }
  if (state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_commit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_commit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_reject_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_reject_submit);
  }
  if (state == WFSTATE_STEP2 || state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_edit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_edit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2 || state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_return_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_return_submit);
  }
  row=table.addRow();
  row.addCell(0,2).addButton(""String_Node_Str"").setValue(T_cancel_submit);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}",0.9954112248499823
52337,"/** 
 * Set up the bitstream reader. See the class description for information on configuration options.
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    Bitstream bitstream=null;
    Item item=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      dso=HandleManager.resolveToObject(context,handle);
      if (dso instanceof Item) {
        item=(Item)dso;
        if (sequence > -1) {
          bitstream=findBitstreamBySequence(item,sequence);
        }
 else         if (name != null) {
          bitstream=findBitstreamByName(item,name);
        }
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    boolean isAuthorized=AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ);
    if (item != null && item.isWithdrawn() && !AuthorizeManager.isAdmin(context)) {
      isAuthorized=false;
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + item.getHandle() + ""String_Node_Str""));
    }
    if (!isAuthorized) {
      if (this.request.getSession().getAttribute(""String_Node_Str"") != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=item.getHandle();
        }
 else         if (dso != null) {
          redictURL+=dso.getHandle();
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (bitstreamName != null) {
      int finalSlashIndex=bitstreamName.lastIndexOf(""String_Node_Str"");
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}","/** 
 * Set up the bitstream reader. See the class description for information on configuration options.
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    Bitstream bitstream=null;
    Item item=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      dso=HandleManager.resolveToObject(context,handle);
      if (dso instanceof Item) {
        item=(Item)dso;
        if (sequence > -1) {
          bitstream=findBitstreamBySequence(item,sequence);
        }
 else         if (name != null) {
          bitstream=findBitstreamByName(item,name);
        }
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    boolean isAuthorized=AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ);
    if (item != null && item.isWithdrawn() && !AuthorizeManager.isAdmin(context)) {
      isAuthorized=false;
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + item.getHandle() + ""String_Node_Str""));
    }
    if (!isAuthorized) {
      if (this.request.getSession().getAttribute(""String_Node_Str"") != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=item.getHandle();
        }
 else         if (dso != null) {
          redictURL+=dso.getHandle();
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (bitstreamName != null && bitstreamName.length() > 0) {
      int finalSlashIndex=bitstreamName.lastIndexOf(""String_Node_Str"");
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
 else {
      bitstreamName=""String_Node_Str"";
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}",0.9888695185731528
52338,"/** 
 * Set up the bitstream reader. See the class description for information on configuration options. FIXME: This should use the parameter ""uri"" rather than ""handle"" to be consistent with the JSPUI. Unfortunately, I have no idea how this works right now, so I'll have to do that later. It should still work for now though. --JR
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    Bitstream bitstream=null;
    Item item=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      ResolvableIdentifier ri=IdentifierService.resolve(context,handle);
      dso=(DSpaceObject)IdentifierService.getResource(context,ri);
      if (dso instanceof Item && sequence > -1) {
        bitstream=findBitstreamBySequence((Item)dso,sequence);
      }
 else       if (dso instanceof Item && name != null) {
        bitstream=findBitstreamByName((Item)dso,name);
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    if (!AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ)) {
      if (this.request.getSession().getAttribute(""String_Node_Str"") != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=IdentifierService.getCanonicalForm(item);
        }
 else         if (dso != null) {
          redictURL+=IdentifierService.getCanonicalForm(dso);
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (bitstreamName != null) {
      int finalSlashIndex=bitstreamName.lastIndexOf(""String_Node_Str"");
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  IdentifierException e) {
    log.error(""String_Node_Str"",e);
    throw new ProcessingException(""String_Node_Str"",e);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}","/** 
 * Set up the bitstream reader. See the class description for information on configuration options. FIXME: This should use the parameter ""uri"" rather than ""handle"" to be consistent with the JSPUI. Unfortunately, I have no idea how this works right now, so I'll have to do that later. It should still work for now though. --JR
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    Bitstream bitstream=null;
    Item item=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      ResolvableIdentifier ri=IdentifierService.resolve(context,handle);
      dso=(DSpaceObject)IdentifierService.getResource(context,ri);
      if (dso instanceof Item && sequence > -1) {
        bitstream=findBitstreamBySequence((Item)dso,sequence);
      }
 else       if (dso instanceof Item && name != null) {
        bitstream=findBitstreamByName((Item)dso,name);
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    if (!AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ)) {
      if (this.request.getSession().getAttribute(""String_Node_Str"") != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=IdentifierService.getCanonicalForm(item);
        }
 else         if (dso != null) {
          redictURL+=IdentifierService.getCanonicalForm(dso);
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (bitstreamName != null && bitstreamName.length() > 0) {
      int finalSlashIndex=bitstreamName.lastIndexOf(""String_Node_Str"");
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
 else {
      bitstreamName=""String_Node_Str"";
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  IdentifierException e) {
    log.error(""String_Node_Str"",e);
    throw new ProcessingException(""String_Node_Str"",e);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}",0.9894065092533504
52339,"public int doStartTag() throws JspException {
  try {
    if (ids.size() < 1) {
      return SKIP_BODY;
    }
    JspWriter out=pageContext.getOut();
    String header=this.getHeaderText();
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"" + header + ""String_Node_Str"");
    for (    ExternalIdentifier eid : ids) {
      writeIdentifier(eid,out);
    }
    return SKIP_BODY;
  }
 catch (  IOException e) {
    throw new JspException(e);
  }
}","public int doStartTag() throws JspException {
  try {
    if (ids.size() < 1) {
      return SKIP_BODY;
    }
    JspWriter out=pageContext.getOut();
    String header=this.getHeaderText();
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"" + header + ""String_Node_Str"");
    for (    ExternalIdentifier eid : ids) {
      writeIdentifier(eid,out);
    }
    out.println(""String_Node_Str"");
    return SKIP_BODY;
  }
 catch (  IOException e) {
    throw new JspException(e);
  }
}",0.9625779625779626
52340,"public int doOffsetQuery(String column,String value,boolean isAscending) throws BrowseException {
  TableRowIterator tri=null;
  try {
    List paramsList=new ArrayList();
    StringBuffer queryBuf=new StringBuffer();
    queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
    buildSelectStatement(queryBuf,paramsList);
    if (isAscending) {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value);
    }
 else {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value + Character.MAX_VALUE);
    }
    if (containerTable != null || (value != null && valueField != null && tableDis != null && tableMap != null)) {
      queryBuf.append(""String_Node_Str"").append(""String_Node_Str"");
      queryBuf.append(table).append(""String_Node_Str"");
    }
    tri=DatabaseManager.query(context,queryBuf.toString(),paramsList.toArray());
    TableRow row;
    if (tri.hasNext()) {
      row=tri.next();
      return row.getIntColumn(""String_Node_Str"");
    }
 else {
      return 0;
    }
  }
 catch (  SQLException e) {
    throw new BrowseException(e);
  }
 finally {
    if (tri != null) {
      tri.close();
    }
  }
}","public int doOffsetQuery(String column,String value,boolean isAscending) throws BrowseException {
  TableRowIterator tri=null;
  if (column == null || value == null)   return 0;
  try {
    List paramsList=new ArrayList();
    StringBuffer queryBuf=new StringBuffer();
    queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
    buildSelectStatement(queryBuf,paramsList);
    if (isAscending) {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value);
    }
 else {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value + Character.MAX_VALUE);
    }
    if (containerTable != null || (value != null && valueField != null && tableDis != null && tableMap != null)) {
      queryBuf.append(""String_Node_Str"").append(""String_Node_Str"");
      queryBuf.append(table).append(""String_Node_Str"");
    }
    tri=DatabaseManager.query(context,queryBuf.toString(),paramsList.toArray());
    TableRow row;
    if (tri.hasNext()) {
      row=tri.next();
      return row.getIntColumn(""String_Node_Str"");
    }
 else {
      return 0;
    }
  }
 catch (  SQLException e) {
    throw new BrowseException(e);
  }
 finally {
    if (tri != null) {
      tri.close();
    }
  }
}",0.9799449469130947
52341,"public int doOffsetQuery(String column,String value,boolean isAscending) throws BrowseException {
  TableRowIterator tri=null;
  try {
    List paramsList=new ArrayList();
    StringBuffer queryBuf=new StringBuffer();
    queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
    buildSelectStatement(queryBuf,paramsList);
    if (isAscending) {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value);
    }
 else {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value + Character.MAX_VALUE);
    }
    if (containerTable != null || (value != null && valueField != null && tableDis != null && tableMap != null)) {
      queryBuf.append(""String_Node_Str"").append(""String_Node_Str"");
      queryBuf.append(table).append(""String_Node_Str"");
    }
    tri=DatabaseManager.query(context,queryBuf.toString(),paramsList.toArray());
    TableRow row;
    if (tri.hasNext()) {
      row=tri.next();
      return (int)row.getLongColumn(""String_Node_Str"");
    }
 else {
      return 0;
    }
  }
 catch (  SQLException e) {
    throw new BrowseException(e);
  }
 finally {
    if (tri != null) {
      tri.close();
    }
  }
}","public int doOffsetQuery(String column,String value,boolean isAscending) throws BrowseException {
  TableRowIterator tri=null;
  if (column == null || value == null)   return 0;
  try {
    List paramsList=new ArrayList();
    StringBuffer queryBuf=new StringBuffer();
    queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
    buildSelectStatement(queryBuf,paramsList);
    if (isAscending) {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value);
    }
 else {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value + Character.MAX_VALUE);
    }
    if (containerTable != null || (value != null && valueField != null && tableDis != null && tableMap != null)) {
      queryBuf.append(""String_Node_Str"").append(""String_Node_Str"");
      queryBuf.append(table).append(""String_Node_Str"");
    }
    tri=DatabaseManager.query(context,queryBuf.toString(),paramsList.toArray());
    TableRow row;
    if (tri.hasNext()) {
      row=tri.next();
      return (int)row.getLongColumn(""String_Node_Str"");
    }
 else {
      return 0;
    }
  }
 catch (  SQLException e) {
    throw new BrowseException(e);
  }
 finally {
    if (tri != null) {
      tri.close();
    }
  }
}",0.9800391389432486
52342,"public static Identifiable getResource(Context context,ResolvableIdentifier ri) throws IdentifierException {
  try {
    ObjectIdentifier oid=ri.getObjectIdentifier();
    if (oid.getResourceTypeID() == -1 || oid.getResourceID() == -1) {
      ObjectIdentifierDAO dao=ObjectIdentifierDAOFactory.getInstance(context);
      ObjectIdentifier noid=dao.retrieve(oid.getUUID());
      if (noid == null) {
        return null;
      }
    }
    return IdentifierService.getObjectByResourceID(context,oid);
  }
 catch (  ObjectIdentifierStorageException e) {
    log.error(""String_Node_Str"",e);
    throw new IdentifierException(e);
  }
}","public static Identifiable getResource(Context context,ResolvableIdentifier ri) throws IdentifierException {
  try {
    ObjectIdentifier oid=ri.getObjectIdentifier();
    if (oid.getResourceTypeID() == -1 || oid.getResourceID() == -1) {
      ObjectIdentifierDAO dao=ObjectIdentifierDAOFactory.getInstance(context);
      ObjectIdentifier noid=dao.retrieve(oid.getUUID());
      if (noid == null) {
        return null;
      }
      oid=noid;
    }
    return IdentifierService.getObjectByResourceID(context,oid);
  }
 catch (  ObjectIdentifierStorageException e) {
    log.error(""String_Node_Str"",e);
    throw new IdentifierException(e);
  }
}",0.9874804381846636
52343,"/** 
 * The metadata fields of the given item will be added to the given feed.
 * @param context	DSpace context object
 * @param dspaceItem	DSpace Item
 * @return an object representing a feed entry
 */
private com.sun.syndication.feed.rss.Item itemFromDSpaceItem(Context context,Item dspaceItem) throws SQLException {
  com.sun.syndication.feed.rss.Item rssItem=new com.sun.syndication.feed.rss.Item();
  String titleField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleField == null) {
    titleField=""String_Node_Str"";
  }
  String dateField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateField == null) {
    dateField=""String_Node_Str"";
  }
  String itHandle=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? HandleManager.resolveToURL(context,dspaceItem.getHandle()) : HandleManager.getCanonicalForm(dspaceItem.getHandle());
  rssItem.setLink(itHandle);
  String title=null;
  try {
    title=dspaceItem.getMetadata(titleField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    title=labels.getString(clazz + ""String_Node_Str"");
  }
  rssItem.setTitle(title);
  String descriptionFields=ConfigurationManager.getProperty(""String_Node_Str"");
  if (descriptionFields == null) {
    descriptionFields=defaultDescriptionFields;
  }
  StringBuffer descBuf=new StringBuffer();
  StringTokenizer st=new StringTokenizer(descriptionFields,""String_Node_Str"");
  while (st.hasMoreTokens()) {
    String field=st.nextToken().trim();
    boolean isDate=false;
    if (field.indexOf(""String_Node_Str"") > 0) {
      field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
      isDate=true;
    }
    DCValue[] values=dspaceItem.getMetadata(field);
    if (values != null && values.length > 0) {
      if (descBuf.length() > 0) {
        descBuf.append(""String_Node_Str"");
        descBuf.append(""String_Node_Str"");
      }
      String fieldLabel=null;
      try {
        fieldLabel=labels.getString(""String_Node_Str"" + field);
      }
 catch (      java.util.MissingResourceException e) {
      }
      if (fieldLabel != null && fieldLabel.length() > 0)       descBuf.append(fieldLabel + ""String_Node_Str"");
      for (int i=0; i < values.length; i++) {
        String fieldValue=values[i].value;
        if (isDate)         fieldValue=(new DCDate(fieldValue)).toString();
        descBuf.append(fieldValue);
        if (i < values.length - 1) {
          descBuf.append(""String_Node_Str"");
        }
      }
    }
  }
  Description descrip=new Description();
  descrip.setValue(descBuf.toString());
  rssItem.setDescription(descrip);
  String dcDate=null;
  try {
    dcDate=dspaceItem.getMetadata(dateField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
  }
  if (dcDate != null) {
    rssItem.setPubDate((new DCDate(dcDate)).toDate());
  }
  return rssItem;
}","/** 
 * The metadata fields of the given item will be added to the given feed.
 * @param context	DSpace context object
 * @param dspaceItem	DSpace Item
 * @return an object representing a feed entry
 */
private com.sun.syndication.feed.rss.Item itemFromDSpaceItem(Context context,Item dspaceItem) throws SQLException {
  com.sun.syndication.feed.rss.Item rssItem=new com.sun.syndication.feed.rss.Item();
  String titleField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleField == null) {
    titleField=""String_Node_Str"";
  }
  String dateField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateField == null) {
    dateField=""String_Node_Str"";
  }
  String itHandle=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? HandleManager.resolveToURL(context,dspaceItem.getHandle()) : HandleManager.getCanonicalForm(dspaceItem.getHandle());
  rssItem.setLink(itHandle);
  String title=null;
  try {
    title=dspaceItem.getMetadata(titleField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    title=labels.getString(clazz + ""String_Node_Str"");
  }
  rssItem.setTitle(title);
  String descriptionFields=ConfigurationManager.getProperty(""String_Node_Str"");
  if (descriptionFields == null) {
    descriptionFields=defaultDescriptionFields;
  }
  StringBuffer descBuf=new StringBuffer();
  StringTokenizer st=new StringTokenizer(descriptionFields,""String_Node_Str"");
  while (st.hasMoreTokens()) {
    String field=st.nextToken().trim();
    boolean isDate=false;
    if (field.indexOf(""String_Node_Str"") > 0) {
      field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
      isDate=true;
    }
    DCValue[] values=dspaceItem.getMetadata(field);
    if (values != null && values.length > 0) {
      if (descBuf.length() > 0) {
        descBuf.append(""String_Node_Str"");
        descBuf.append(""String_Node_Str"");
      }
      String fieldLabel=null;
      try {
        fieldLabel=labels.getString(""String_Node_Str"" + field);
      }
 catch (      java.util.MissingResourceException e) {
      }
      if (fieldLabel != null && fieldLabel.length() > 0)       descBuf.append(fieldLabel + ""String_Node_Str"");
      for (int i=0; i < values.length; i++) {
        String fieldValue=values[i].value;
        if (isDate)         fieldValue=(new DCDate(fieldValue)).toString();
        descBuf.append(fieldValue);
        if (i < values.length - 1) {
          descBuf.append(""String_Node_Str"");
        }
      }
    }
  }
  Description descrip=new Description();
  descrip.setValue(descBuf.toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
  rssItem.setDescription(descrip);
  String dcDate=null;
  try {
    dcDate=dspaceItem.getMetadata(dateField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
  }
  if (dcDate != null) {
    rssItem.setPubDate((new DCDate(dcDate)).toDate());
  }
  return rssItem;
}",0.9915966386554622
52344,"/** 
 * Generate a syndication feed for a collection or community or community
 * @param context	the DSpace context object
 * @param dso		DSpace object - collection or community
 * @return		an object representing the feed
 */
private Channel generateFeed(Context context,DSpaceObject dso) throws IOException, SQLException {
  try {
    String dspaceUrl=ConfigurationManager.getProperty(""String_Node_Str"");
    String type=null;
    String description=null;
    String title=null;
    Bitstream logo=null;
    String idx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (idx == null) {
      throw new IOException(""String_Node_Str"");
    }
    BrowseIndex bix=BrowseIndex.getItemBrowseIndex();
    if (bix == null) {
      throw new IOException(""String_Node_Str"" + idx);
    }
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bix);
    for (    SortOption so : SortOption.getSortOptions()) {
      if (so.getName().equals(idx))       scope.setSortBy(so.getNumber());
    }
    scope.setOrder(SortOption.DESCENDING);
    Channel channel=new Channel();
    if (dso == null) {
      channel.setTitle(ConfigurationManager.getProperty(""String_Node_Str""));
      channel.setLink(dspaceUrl);
      channel.setDescription(labels.getString(clazz + ""String_Node_Str""));
    }
 else {
      if (dso.getType() == Constants.COLLECTION) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Collection col=(Collection)dso;
        description=col.getMetadata(""String_Node_Str"");
        title=col.getMetadata(""String_Node_Str"");
        logo=col.getLogo();
        scope.setBrowseContainer(col);
      }
 else       if (dso.getType() == Constants.COMMUNITY) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Community comm=(Community)dso;
        description=comm.getMetadata(""String_Node_Str"");
        title=comm.getMetadata(""String_Node_Str"");
        logo=comm.getLogo();
        scope.setBrowseContainer(comm);
      }
      String objectUrl=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? HandleManager.resolveToURL(context,dso.getHandle()) : HandleManager.getCanonicalForm(dso.getHandle());
      channel.setDescription(description);
      channel.setLink(objectUrl);
      String channelTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type,title});
      channel.setTitle(channelTitle);
      if (logo != null) {
        Image image=new Image();
        image.setLink(objectUrl);
        image.setTitle(labels.getString(clazz + ""String_Node_Str""));
        image.setUrl(dspaceUrl + ""String_Node_Str"" + logo.getID());
        channel.setImage(image);
      }
    }
    TextInput input=new TextInput();
    input.setLink(dspaceUrl + ""String_Node_Str"");
    input.setDescription(labels.getString(clazz + ""String_Node_Str""));
    String searchTitle=""String_Node_Str"";
    if (type != null) {
      searchTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type});
    }
 else {
      searchTitle=labels.getString(clazz + ""String_Node_Str"");
    }
    input.setTitle(searchTitle);
    input.setName(labels.getString(clazz + ""String_Node_Str""));
    channel.setTextInput(input);
    scope.setResultsPerPage(itemCount);
    BrowseEngine be=new BrowseEngine(context);
    BrowseInfo bi=be.browseMini(scope);
    Item[] results=bi.getItemResults(context);
    List items=new ArrayList();
    for (int i=0; i < results.length; i++) {
      items.add(itemFromDSpaceItem(context,results[i]));
    }
    channel.setItems(items);
    if (channel.getDescription() == null)     channel.setDescription(""String_Node_Str"");
    return channel;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new IOException(se.getMessage());
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new IOException(e.getMessage());
  }
}","/** 
 * Generate a syndication feed for a collection or community or community
 * @param context	the DSpace context object
 * @param dso		DSpace object - collection or community
 * @return		an object representing the feed
 */
private Channel generateFeed(Context context,DSpaceObject dso) throws IOException, SQLException {
  try {
    String dspaceUrl=ConfigurationManager.getProperty(""String_Node_Str"");
    String type=null;
    String description=null;
    String title=null;
    Bitstream logo=null;
    String idx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (idx == null) {
      throw new IOException(""String_Node_Str"");
    }
    BrowseIndex bix=BrowseIndex.getItemBrowseIndex();
    if (bix == null) {
      throw new IOException(""String_Node_Str"" + idx);
    }
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bix);
    for (    SortOption so : SortOption.getSortOptions()) {
      if (so.getName().equals(idx))       scope.setSortBy(so.getNumber());
    }
    scope.setOrder(SortOption.DESCENDING);
    Channel channel=new Channel();
    if (dso == null) {
      channel.setTitle(ConfigurationManager.getProperty(""String_Node_Str""));
      channel.setLink(dspaceUrl);
      channel.setDescription(labels.getString(clazz + ""String_Node_Str""));
    }
 else {
      if (dso.getType() == Constants.COLLECTION) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Collection col=(Collection)dso;
        description=col.getMetadata(""String_Node_Str"");
        title=col.getMetadata(""String_Node_Str"");
        logo=col.getLogo();
        scope.setBrowseContainer(col);
      }
 else       if (dso.getType() == Constants.COMMUNITY) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Community comm=(Community)dso;
        description=comm.getMetadata(""String_Node_Str"");
        title=comm.getMetadata(""String_Node_Str"");
        logo=comm.getLogo();
        scope.setBrowseContainer(comm);
      }
      String objectUrl=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? HandleManager.resolveToURL(context,dso.getHandle()) : HandleManager.getCanonicalForm(dso.getHandle());
      channel.setDescription(description.replaceAll(""String_Node_Str"",""String_Node_Str""));
      channel.setLink(objectUrl);
      String channelTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type,title});
      channel.setTitle(channelTitle);
      if (logo != null) {
        Image image=new Image();
        image.setLink(objectUrl);
        image.setTitle(labels.getString(clazz + ""String_Node_Str""));
        image.setUrl(dspaceUrl + ""String_Node_Str"" + logo.getID());
        channel.setImage(image);
      }
    }
    TextInput input=new TextInput();
    input.setLink(dspaceUrl + ""String_Node_Str"");
    input.setDescription(labels.getString(clazz + ""String_Node_Str""));
    String searchTitle=""String_Node_Str"";
    if (type != null) {
      searchTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type});
    }
 else {
      searchTitle=labels.getString(clazz + ""String_Node_Str"");
    }
    input.setTitle(searchTitle);
    input.setName(labels.getString(clazz + ""String_Node_Str""));
    channel.setTextInput(input);
    scope.setResultsPerPage(itemCount);
    BrowseEngine be=new BrowseEngine(context);
    BrowseInfo bi=be.browseMini(scope);
    Item[] results=bi.getItemResults(context);
    List items=new ArrayList();
    for (int i=0; i < results.length; i++) {
      items.add(itemFromDSpaceItem(context,results[i]));
    }
    channel.setItems(items);
    if (channel.getDescription() == null)     channel.setDescription(""String_Node_Str"");
    return channel;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new IOException(se.getMessage());
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new IOException(e.getMessage());
  }
}",0.9938853503184714
52345,"/** 
 * The metadata fields of the given item will be added to the given feed.
 * @param context	DSpace context object
 * @param dspaceItem	DSpace Item
 * @return an object representing a feed entry
 */
private com.sun.syndication.feed.rss.Item itemFromDSpaceItem(Context context,Item dspaceItem) throws SQLException {
  com.sun.syndication.feed.rss.Item rssItem=new com.sun.syndication.feed.rss.Item();
  String titleField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleField == null) {
    titleField=""String_Node_Str"";
  }
  String dateField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateField == null) {
    dateField=""String_Node_Str"";
  }
  String link=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? IdentifierService.getURL(dspaceItem).toString() : dspaceItem.getExternalIdentifier().getURI().toString();
  rssItem.setLink(link);
  String title=null;
  try {
    title=dspaceItem.getMetadata(titleField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    title=labels.getString(clazz + ""String_Node_Str"");
  }
  rssItem.setTitle(title);
  String descriptionFields=ConfigurationManager.getProperty(""String_Node_Str"");
  if (descriptionFields == null) {
    descriptionFields=defaultDescriptionFields;
  }
  StringBuffer descBuf=new StringBuffer();
  StringTokenizer st=new StringTokenizer(descriptionFields,""String_Node_Str"");
  while (st.hasMoreTokens()) {
    String field=st.nextToken().trim();
    boolean isDate=false;
    if (field.indexOf(""String_Node_Str"") > 0) {
      field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
      isDate=true;
    }
    DCValue[] values=dspaceItem.getMetadata(field);
    if (values != null && values.length > 0) {
      if (descBuf.length() > 0) {
        descBuf.append(""String_Node_Str"");
        descBuf.append(""String_Node_Str"");
      }
      String fieldLabel=null;
      try {
        fieldLabel=labels.getString(""String_Node_Str"" + field);
      }
 catch (      java.util.MissingResourceException e) {
      }
      if (fieldLabel != null && fieldLabel.length() > 0)       descBuf.append(fieldLabel + ""String_Node_Str"");
      for (int i=0; i < values.length; i++) {
        String fieldValue=values[i].value;
        if (isDate)         fieldValue=(new DCDate(fieldValue)).toString();
        descBuf.append(fieldValue);
        if (i < values.length - 1) {
          descBuf.append(""String_Node_Str"");
        }
      }
    }
  }
  Description descrip=new Description();
  descrip.setValue(descBuf.toString());
  rssItem.setDescription(descrip);
  String dcDate=null;
  try {
    dcDate=dspaceItem.getMetadata(dateField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
  }
  if (dcDate != null) {
    rssItem.setPubDate((new DCDate(dcDate)).toDate());
  }
  return rssItem;
}","/** 
 * The metadata fields of the given item will be added to the given feed.
 * @param context	DSpace context object
 * @param dspaceItem	DSpace Item
 * @return an object representing a feed entry
 */
private com.sun.syndication.feed.rss.Item itemFromDSpaceItem(Context context,Item dspaceItem) throws SQLException {
  com.sun.syndication.feed.rss.Item rssItem=new com.sun.syndication.feed.rss.Item();
  String titleField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleField == null) {
    titleField=""String_Node_Str"";
  }
  String dateField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateField == null) {
    dateField=""String_Node_Str"";
  }
  String link=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? IdentifierService.getURL(dspaceItem).toString() : dspaceItem.getExternalIdentifier().getURI().toString();
  rssItem.setLink(link);
  String title=null;
  try {
    title=dspaceItem.getMetadata(titleField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    title=labels.getString(clazz + ""String_Node_Str"");
  }
  rssItem.setTitle(title);
  String descriptionFields=ConfigurationManager.getProperty(""String_Node_Str"");
  if (descriptionFields == null) {
    descriptionFields=defaultDescriptionFields;
  }
  StringBuffer descBuf=new StringBuffer();
  StringTokenizer st=new StringTokenizer(descriptionFields,""String_Node_Str"");
  while (st.hasMoreTokens()) {
    String field=st.nextToken().trim();
    boolean isDate=false;
    if (field.indexOf(""String_Node_Str"") > 0) {
      field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
      isDate=true;
    }
    DCValue[] values=dspaceItem.getMetadata(field);
    if (values != null && values.length > 0) {
      if (descBuf.length() > 0) {
        descBuf.append(""String_Node_Str"");
        descBuf.append(""String_Node_Str"");
      }
      String fieldLabel=null;
      try {
        fieldLabel=labels.getString(""String_Node_Str"" + field);
      }
 catch (      java.util.MissingResourceException e) {
      }
      if (fieldLabel != null && fieldLabel.length() > 0)       descBuf.append(fieldLabel + ""String_Node_Str"");
      for (int i=0; i < values.length; i++) {
        String fieldValue=values[i].value;
        if (isDate)         fieldValue=(new DCDate(fieldValue)).toString();
        descBuf.append(fieldValue);
        if (i < values.length - 1) {
          descBuf.append(""String_Node_Str"");
        }
      }
    }
  }
  Description descrip=new Description();
  descrip.setValue(descBuf.toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
  rssItem.setDescription(descrip);
  String dcDate=null;
  try {
    dcDate=dspaceItem.getMetadata(dateField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
  }
  if (dcDate != null) {
    rssItem.setPubDate((new DCDate(dcDate)).toDate());
  }
  return rssItem;
}",0.9915403595347198
52346,"/** 
 * Generate a syndication feed for a collection or community or community
 * @param context	the DSpace context object
 * @param dso		DSpace object - collection or community
 * @return		an object representing the feed
 */
private Channel generateFeed(Context context,DSpaceObject dso) throws IOException, SQLException {
  try {
    String dspaceUrl=ConfigurationManager.getProperty(""String_Node_Str"");
    String type=null;
    String description=null;
    String title=null;
    Bitstream logo=null;
    String idx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (idx == null) {
      throw new IOException(""String_Node_Str"");
    }
    BrowseIndex bix=BrowseIndex.getItemBrowseIndex();
    if (bix == null) {
      throw new IOException(""String_Node_Str"" + idx);
    }
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bix);
    for (    SortOption so : SortOption.getSortOptions()) {
      if (so.getName().equals(idx))       scope.setSortBy(so.getNumber());
    }
    scope.setOrder(SortOption.DESCENDING);
    Channel channel=new Channel();
    if (dso == null) {
      channel.setTitle(ConfigurationManager.getProperty(""String_Node_Str""));
      channel.setLink(dspaceUrl);
      channel.setDescription(labels.getString(clazz + ""String_Node_Str""));
    }
 else {
      if (dso.getType() == Constants.COLLECTION) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Collection col=(Collection)dso;
        description=col.getMetadata(""String_Node_Str"");
        title=col.getMetadata(""String_Node_Str"");
        logo=col.getLogo();
        scope.setBrowseContainer(col);
      }
 else       if (dso.getType() == Constants.COMMUNITY) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Community comm=(Community)dso;
        description=comm.getMetadata(""String_Node_Str"");
        title=comm.getMetadata(""String_Node_Str"");
        logo=comm.getLogo();
        scope.setBrowseContainer(comm);
      }
      String objectUrl=""String_Node_Str"";
      if (dso.getExternalIdentifier() != null) {
        objectUrl=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? IdentifierService.getURL(dso).toString() : dso.getExternalIdentifier().getURI().toString();
      }
 else {
        objectUrl=IdentifierService.getURL(dso).toString();
      }
      channel.setDescription(description);
      channel.setLink(objectUrl);
      String channelTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type,title});
      channel.setTitle(channelTitle);
      if (logo != null) {
        Image image=new Image();
        image.setLink(objectUrl);
        image.setTitle(labels.getString(clazz + ""String_Node_Str""));
        image.setUrl(dspaceUrl + ""String_Node_Str"" + logo.getID());
        channel.setImage(image);
      }
    }
    TextInput input=new TextInput();
    input.setLink(dspaceUrl + ""String_Node_Str"");
    input.setDescription(labels.getString(clazz + ""String_Node_Str""));
    String searchTitle=""String_Node_Str"";
    if (type != null) {
      searchTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type});
    }
 else {
      searchTitle=labels.getString(clazz + ""String_Node_Str"");
    }
    input.setTitle(searchTitle);
    input.setName(labels.getString(clazz + ""String_Node_Str""));
    channel.setTextInput(input);
    scope.setResultsPerPage(itemCount);
    BrowseEngine be=new BrowseEngine(context);
    BrowseInfo bi=be.browseMini(scope);
    Item[] results=bi.getBrowseItemResults(context);
    List items=new ArrayList();
    for (int i=0; i < results.length; i++) {
      items.add(itemFromDSpaceItem(context,results[i]));
    }
    channel.setItems(items);
    if (channel.getDescription() == null)     channel.setDescription(""String_Node_Str"");
    return channel;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new IOException(se.getMessage());
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new IOException(e.getMessage());
  }
}","/** 
 * Generate a syndication feed for a collection or community or community
 * @param context	the DSpace context object
 * @param dso		DSpace object - collection or community
 * @return		an object representing the feed
 */
private Channel generateFeed(Context context,DSpaceObject dso) throws IOException, SQLException {
  try {
    String dspaceUrl=ConfigurationManager.getProperty(""String_Node_Str"");
    String type=null;
    String description=null;
    String title=null;
    Bitstream logo=null;
    String idx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (idx == null) {
      throw new IOException(""String_Node_Str"");
    }
    BrowseIndex bix=BrowseIndex.getItemBrowseIndex();
    if (bix == null) {
      throw new IOException(""String_Node_Str"" + idx);
    }
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bix);
    for (    SortOption so : SortOption.getSortOptions()) {
      if (so.getName().equals(idx))       scope.setSortBy(so.getNumber());
    }
    scope.setOrder(SortOption.DESCENDING);
    Channel channel=new Channel();
    if (dso == null) {
      channel.setTitle(ConfigurationManager.getProperty(""String_Node_Str""));
      channel.setLink(dspaceUrl);
      channel.setDescription(labels.getString(clazz + ""String_Node_Str""));
    }
 else {
      if (dso.getType() == Constants.COLLECTION) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Collection col=(Collection)dso;
        description=col.getMetadata(""String_Node_Str"");
        title=col.getMetadata(""String_Node_Str"");
        logo=col.getLogo();
        scope.setBrowseContainer(col);
      }
 else       if (dso.getType() == Constants.COMMUNITY) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Community comm=(Community)dso;
        description=comm.getMetadata(""String_Node_Str"");
        title=comm.getMetadata(""String_Node_Str"");
        logo=comm.getLogo();
        scope.setBrowseContainer(comm);
      }
      String objectUrl=""String_Node_Str"";
      if (dso.getExternalIdentifier() != null) {
        objectUrl=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? IdentifierService.getURL(dso).toString() : dso.getExternalIdentifier().getURI().toString();
      }
 else {
        objectUrl=IdentifierService.getURL(dso).toString();
      }
      channel.setDescription(description.replaceAll(""String_Node_Str"",""String_Node_Str""));
      channel.setLink(objectUrl);
      String channelTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type,title});
      channel.setTitle(channelTitle);
      if (logo != null) {
        Image image=new Image();
        image.setLink(objectUrl);
        image.setTitle(labels.getString(clazz + ""String_Node_Str""));
        image.setUrl(dspaceUrl + ""String_Node_Str"" + logo.getID());
        channel.setImage(image);
      }
    }
    TextInput input=new TextInput();
    input.setLink(dspaceUrl + ""String_Node_Str"");
    input.setDescription(labels.getString(clazz + ""String_Node_Str""));
    String searchTitle=""String_Node_Str"";
    if (type != null) {
      searchTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type});
    }
 else {
      searchTitle=labels.getString(clazz + ""String_Node_Str"");
    }
    input.setTitle(searchTitle);
    input.setName(labels.getString(clazz + ""String_Node_Str""));
    channel.setTextInput(input);
    scope.setResultsPerPage(itemCount);
    BrowseEngine be=new BrowseEngine(context);
    BrowseInfo bi=be.browseMini(scope);
    Item[] results=bi.getBrowseItemResults(context);
    List items=new ArrayList();
    for (int i=0; i < results.length; i++) {
      items.add(itemFromDSpaceItem(context,results[i]));
    }
    channel.setItems(items);
    if (channel.getDescription() == null)     channel.setDescription(""String_Node_Str"");
    return channel;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new IOException(se.getMessage());
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new IOException(e.getMessage());
  }
}",0.9941320293398532
52347,"/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]);
  }
  Item item=(Item)dso;
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + dso.getID());
      }
    }
 else {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      e.setAttribute(""String_Node_Str"",v.value == null ? ""String_Node_Str"" : v.value);
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}","/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]);
  }
  Item item=(Item)dso;
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + dso.getID());
      }
    }
 else {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      if (v.value == null) {
        e.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
 else {
        String reason=Verifier.checkCharacterData(v.value);
        if (reason == null) {
          e.setAttribute(""String_Node_Str"",v.value == null ? ""String_Node_Str"" : v.value);
        }
 else {
          log.warn(""String_Node_Str"" + reason);
          String simpleText=v.value.replaceAll(""String_Node_Str"",""String_Node_Str"");
          if (Verifier.checkCharacterData(simpleText) == null)           e.setAttribute(""String_Node_Str"",simpleText);
        }
      }
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}",0.8879706152433425
52348,"/** 
 * Get the limit clause to perform search result truncation.  Will return something of the form: <code> LIMIT [limit] </code>
 */
private void buildRowLimitAndOffset(StringBuffer queryBuf,List params){
  if (limit > 0 || offset > 0) {
    queryBuf.insert(0,""String_Node_Str"");
    queryBuf.append(""String_Node_Str"");
  }
  if (limit > 0) {
    queryBuf.append(""String_Node_Str"");
    if (offset > 0)     params.add(new Integer(limit + offset));
 else     params.add(new Integer(limit));
  }
  if (offset > -1) {
    queryBuf.insert(0,""String_Node_Str"");
    queryBuf.append(""String_Node_Str"");
    params.add(new Integer(offset));
  }
}","/** 
 * Get the limit clause to perform search result truncation.  Will return something of the form: <code> LIMIT [limit] </code>
 */
private void buildRowLimitAndOffset(StringBuffer queryBuf,List params){
  if (limit > 0 || offset > 0) {
    queryBuf.insert(0,""String_Node_Str"");
    queryBuf.append(""String_Node_Str"");
  }
  if (limit > 0) {
    queryBuf.append(""String_Node_Str"");
    if (offset > 0)     params.add(new Integer(limit + offset));
 else     params.add(new Integer(limit));
  }
  if (offset > 0) {
    queryBuf.insert(0,""String_Node_Str"");
    queryBuf.append(""String_Node_Str"");
    params.add(new Integer(offset));
  }
}",0.9976580796252928
52349,"/** 
 * Find the epeople that match the search query across firstname, lastname or email.  This method also allows offsets and limits for pagination purposes. 
 * @param context DSpace context
 * @param query The search string
 * @param offset Inclusive offset 
 * @param limit Maximum number of matches returned
 * @return array of EPerson objects
 */
public static EPerson[] search(Context context,String query,int offset,int limit) throws SQLException {
  String params=""String_Node_Str"" + query.toLowerCase() + ""String_Node_Str"";
  String dbquery=""String_Node_Str"" + ""String_Node_Str"";
  if (offset >= 0 && limit > 0) {
    dbquery+=""String_Node_Str"" + limit + ""String_Node_Str""+ offset;
  }
  Integer int_param;
  try {
    int_param=Integer.valueOf(query);
  }
 catch (  NumberFormatException e) {
    int_param=new Integer(-1);
  }
  TableRowIterator rows=DatabaseManager.query(context,dbquery,new Object[]{int_param,params,params,params});
  List epeopleRows=rows.toList();
  EPerson[] epeople=new EPerson[epeopleRows.size()];
  for (int i=0; i < epeopleRows.size(); i++) {
    TableRow row=(TableRow)epeopleRows.get(i);
    EPerson fromCache=(EPerson)context.fromCache(EPerson.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      epeople[i]=fromCache;
    }
 else {
      epeople[i]=new EPerson(context,row);
    }
  }
  return epeople;
}","/** 
 * Find the epeople that match the search query across firstname, lastname or email.  This method also allows offsets and limits for pagination purposes. 
 * @param context DSpace context
 * @param query The search string
 * @param offset Inclusive offset 
 * @param limit Maximum number of matches returned
 * @return array of EPerson objects
 */
public static EPerson[] search(Context context,String query,int offset,int limit) throws SQLException {
  String params=""String_Node_Str"" + query.toLowerCase() + ""String_Node_Str"";
  StringBuffer queryBuf=new StringBuffer();
  queryBuf.append(""String_Node_Str"");
  queryBuf.append(""String_Node_Str"");
  if (""String_Node_Str"".equals(ConfigurationManager.getProperty(""String_Node_Str""))) {
    if (limit > 0 || offset > 0) {
      queryBuf.insert(0,""String_Node_Str"");
      queryBuf.append(""String_Node_Str"");
    }
    if (limit > 0) {
      queryBuf.append(""String_Node_Str"");
      if (offset > 0)       limit+=offset;
    }
    if (offset > 0) {
      queryBuf.insert(0,""String_Node_Str"");
      queryBuf.append(""String_Node_Str"");
    }
  }
 else {
    if (limit > 0)     queryBuf.append(""String_Node_Str"");
    if (offset > 0)     queryBuf.append(""String_Node_Str"");
  }
  String dbquery=queryBuf.toString();
  Integer int_param;
  try {
    int_param=Integer.valueOf(query);
  }
 catch (  NumberFormatException e) {
    int_param=new Integer(-1);
  }
  Object[] paramArr=new Object[]{int_param,params,params,params};
  if (limit > 0 && offset > 0)   paramArr=new Object[]{int_param,params,params,params,limit,offset};
 else   if (limit > 0)   paramArr=new Object[]{int_param,params,params,params,limit};
 else   if (offset > 0)   paramArr=new Object[]{int_param,params,params,params,offset};
  TableRowIterator rows=DatabaseManager.query(context,dbquery,paramArr);
  List epeopleRows=rows.toList();
  EPerson[] epeople=new EPerson[epeopleRows.size()];
  for (int i=0; i < epeopleRows.size(); i++) {
    TableRow row=(TableRow)epeopleRows.get(i);
    EPerson fromCache=(EPerson)context.fromCache(EPerson.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      epeople[i]=fromCache;
    }
 else {
      epeople[i]=new EPerson(context,row);
    }
  }
  return epeople;
}",0.6460519050248481
52350,"/** 
 * Find the groups that match the search query across eperson_group_id or name
 * @param context DSpace context
 * @param query The search string
 * @param offset Inclusive offset 
 * @param limit Maximum number of matches returned
 * @return array of Group objects
 */
public static Group[] search(Context context,String query,int offset,int limit) throws SQLException {
  String params=""String_Node_Str"" + query.toLowerCase() + ""String_Node_Str"";
  String dbquery=""String_Node_Str"";
  if (offset >= 0 && limit > 0) {
    dbquery+=""String_Node_Str"" + limit + ""String_Node_Str""+ offset;
  }
  Integer int_param;
  try {
    int_param=Integer.valueOf(query);
  }
 catch (  NumberFormatException e) {
    int_param=new Integer(-1);
  }
  TableRowIterator rows=DatabaseManager.query(context,dbquery,new Object[]{params,int_param});
  List groupRows=rows.toList();
  Group[] groups=new Group[groupRows.size()];
  for (int i=0; i < groupRows.size(); i++) {
    TableRow row=(TableRow)groupRows.get(i);
    Group fromCache=(Group)context.fromCache(Group.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      groups[i]=fromCache;
    }
 else {
      groups[i]=new Group(context,row);
    }
  }
  return groups;
}","/** 
 * Find the groups that match the search query across eperson_group_id or name
 * @param context DSpace context
 * @param query The search string
 * @param offset Inclusive offset 
 * @param limit Maximum number of matches returned
 * @return array of Group objects
 */
public static Group[] search(Context context,String query,int offset,int limit) throws SQLException {
  String params=""String_Node_Str"" + query.toLowerCase() + ""String_Node_Str"";
  StringBuffer queryBuf=new StringBuffer();
  queryBuf.append(""String_Node_Str"");
  if (""String_Node_Str"".equals(ConfigurationManager.getProperty(""String_Node_Str""))) {
    if (limit > 0 || offset > 0) {
      queryBuf.insert(0,""String_Node_Str"");
      queryBuf.append(""String_Node_Str"");
    }
    if (limit > 0) {
      queryBuf.append(""String_Node_Str"");
      if (offset > 0)       limit+=offset;
    }
    if (offset > 0) {
      queryBuf.insert(0,""String_Node_Str"");
      queryBuf.append(""String_Node_Str"");
    }
  }
 else {
    if (limit > 0)     queryBuf.append(""String_Node_Str"");
    if (offset > 0)     queryBuf.append(""String_Node_Str"");
  }
  String dbquery=queryBuf.toString();
  Integer int_param;
  try {
    int_param=Integer.valueOf(query);
  }
 catch (  NumberFormatException e) {
    int_param=new Integer(-1);
  }
  Object[] paramArr=new Object[]{params,int_param};
  if (limit > 0 && offset > 0)   paramArr=new Object[]{params,int_param,limit,offset};
 else   if (limit > 0)   paramArr=new Object[]{params,int_param,limit};
 else   if (offset > 0)   paramArr=new Object[]{params,int_param,offset};
  TableRowIterator rows=DatabaseManager.query(context,dbquery,paramArr);
  List groupRows=rows.toList();
  Group[] groups=new Group[groupRows.size()];
  for (int i=0; i < groupRows.size(); i++) {
    TableRow row=(TableRow)groupRows.get(i);
    Group fromCache=(Group)context.fromCache(Group.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      groups[i]=fromCache;
    }
 else {
      groups[i]=new Group(context,row);
    }
  }
  return groups;
}",0.6043822276323798
52351,"/** 
 * Query DSpace for a list of all items / collections / or communities that match the given search query.
 * @return The associated query results.
 */
protected void performSearch() throws SQLException, IOException {
  if (queryResults != null)   return;
  Context context=ContextUtil.obtainContext(objectModel);
  String query=getQuery();
  DSpaceObject scope=getScope();
  int page=getParameterPage();
  QueryArgs qArgs=new QueryArgs();
  qArgs.setPageSize(getParameterRpp());
  try {
    qArgs.setSortOption(SortOption.getSortOption(getParameterSortBy()));
  }
 catch (  SortException se) {
  }
  qArgs.setSortOrder(getParameterOrder());
  qArgs.setQuery(query);
  if (page > 1)   qArgs.setStart((Integer.valueOf(page) - 1) * qArgs.getPageSize());
 else   qArgs.setStart(0);
  QueryResults qResults=null;
  if (scope instanceof Community) {
    qResults=DSQuery.doQuery(context,qArgs,(Community)scope);
  }
 else   if (scope instanceof Collection) {
    qResults=DSQuery.doQuery(context,qArgs,(Collection)scope);
  }
 else {
    qResults=DSQuery.doQuery(context,qArgs);
  }
  this.queryResults=qResults;
}","/** 
 * Query DSpace for a list of all items / collections / or communities that match the given search query.
 * @return The associated query results.
 */
protected void performSearch() throws SQLException, IOException, UIException {
  if (queryResults != null)   return;
  Context context=ContextUtil.obtainContext(objectModel);
  String query=getQuery();
  DSpaceObject scope=getScope();
  int page=getParameterPage();
  QueryArgs qArgs=new QueryArgs();
  qArgs.setPageSize(getParameterRpp());
  try {
    qArgs.setSortOption(SortOption.getSortOption(getParameterSortBy()));
  }
 catch (  SortException se) {
  }
  qArgs.setSortOrder(getParameterOrder());
  qArgs.setQuery(query);
  if (page > 1)   qArgs.setStart((Integer.valueOf(page) - 1) * qArgs.getPageSize());
 else   qArgs.setStart(0);
  QueryResults qResults=null;
  if (scope instanceof Community) {
    qResults=DSQuery.doQuery(context,qArgs,(Community)scope);
  }
 else   if (scope instanceof Collection) {
    qResults=DSQuery.doQuery(context,qArgs,(Collection)scope);
  }
 else {
    qResults=DSQuery.doQuery(context,qArgs);
  }
  this.queryResults=qResults;
}",0.994193836534167
52352,"/** 
 * Extract the query string. Under most implementations this will be derived from the url parameters.
 * @return The query string.
 */
abstract protected String getQuery();","/** 
 * Extract the query string. Under most implementations this will be derived from the url parameters.
 * @return The query string.
 */
abstract protected String getQuery() throws UIException ;",0.946524064171123
52353,"/** 
 * Build the query field for the given cell.
 * @param row The current row.
 * @param cell The current cell.
 */
private void buildQueryField(int row,Cell cell) throws WingException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String current=request.getParameter(""String_Node_Str"" + row);
  Text text=cell.addText(""String_Node_Str"" + row);
  if (current != null)   text.setValue(current);
}","/** 
 * Build the query field for the given cell.
 * @param row The current row.
 * @param cell The current cell.
 */
private void buildQueryField(int row,Cell cell) throws WingException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String current=URLDecode(request.getParameter(""String_Node_Str"" + row));
  Text text=cell.addText(""String_Node_Str"" + row);
  if (current != null)   text.setValue(current);
}",0.9869203329369798
52354,"/** 
 * Get a list of search fields from the request object and parse them into a linear array of fileds. The field's index is preserved, so if it comes in as index 17 it will  be outputted as field 17.
 * @param request The http request object
 * @return Array of search fields
 */
public ArrayList<SearchField> getSearchFields(Request request){
  if (this.fields != null)   return this.fields;
  int numSearchField;
  try {
    String numSearchFieldStr=request.getParameter(""String_Node_Str"");
    numSearchField=Integer.valueOf(numSearchFieldStr);
  }
 catch (  NumberFormatException nfe) {
    numSearchField=FIELD_MAX_COUNT;
  }
  ArrayList<SearchField> fields=new ArrayList<SearchField>();
  for (int i=1; i <= numSearchField; i++) {
    String field=request.getParameter(""String_Node_Str"" + i);
    String query=request.getParameter(""String_Node_Str"" + i);
    String conjunction=request.getParameter(""String_Node_Str"" + i);
    if (field != null) {
      field=field.trim();
      if (field.length() == 0)       field=null;
    }
    if (query != null) {
      query=query.trim();
      if (query.length() == 0)       query=null;
    }
    if (conjunction != null) {
      conjunction=conjunction.trim();
      if (conjunction.length() == 0)       conjunction=null;
    }
    if (field == null)     field=""String_Node_Str"";
    if (conjunction == null)     conjunction=""String_Node_Str"";
    if (query != null)     fields.add(new SearchField(i,field,query,conjunction));
  }
  this.fields=fields;
  return this.fields;
}","/** 
 * Get a list of search fields from the request object and parse them into a linear array of fileds. The field's index is preserved, so if it comes in as index 17 it will  be outputted as field 17.
 * @param request The http request object
 * @return Array of search fields
 * @throws UIException 
 */
public ArrayList<SearchField> getSearchFields(Request request) throws UIException {
  if (this.fields != null)   return this.fields;
  int numSearchField;
  try {
    String numSearchFieldStr=request.getParameter(""String_Node_Str"");
    numSearchField=Integer.valueOf(numSearchFieldStr);
  }
 catch (  NumberFormatException nfe) {
    numSearchField=FIELD_MAX_COUNT;
  }
  ArrayList<SearchField> fields=new ArrayList<SearchField>();
  for (int i=1; i <= numSearchField; i++) {
    String field=request.getParameter(""String_Node_Str"" + i);
    String query=URLDecode(request.getParameter(""String_Node_Str"" + i));
    String conjunction=request.getParameter(""String_Node_Str"" + i);
    if (field != null) {
      field=field.trim();
      if (field.length() == 0)       field=null;
    }
    if (query != null) {
      query=query.trim();
      if (query.length() == 0)       query=null;
    }
    if (conjunction != null) {
      conjunction=conjunction.trim();
      if (conjunction.length() == 0)       conjunction=null;
    }
    if (field == null)     field=""String_Node_Str"";
    if (conjunction == null)     conjunction=""String_Node_Str"";
    if (query != null)     fields.add(new SearchField(i,field,query,conjunction));
  }
  this.fields=fields;
  return this.fields;
}",0.9823207971713276
52355,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Division search=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  search.setHead(T_head);
  search.addPara(T_para1);
  Para fields=search.addPara();
  fields.addText(""String_Node_Str"");
  fields.addButton(""String_Node_Str"").setValue(T_go);
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Division search=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_GET,""String_Node_Str"");
  search.setHead(T_head);
  search.addPara(T_para1);
  Para fields=search.addPara();
  fields.addText(""String_Node_Str"");
  fields.addButton(""String_Node_Str"").setValue(T_go);
}",0.9943374858437146
52356,"/** 
 * build the DRI page representing the body of the search query. This provides a widget to generate a new query and list of search results if present.
 */
public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  String queryString=getQuery();
  Division search=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  search.setHead(T_head);
  Division query=search.addInteractiveDivision(""String_Node_Str"",""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  List queryList=query.addList(""String_Node_Str"",List.TYPE_FORM);
  if (variableScope()) {
    Select scope=queryList.addItem().addSelect(""String_Node_Str"");
    scope.setLabel(T_search_scope);
    buildScopeList(scope);
  }
  Text text=queryList.addItem().addText(""String_Node_Str"");
  text.setLabel(T_full_text_search);
  text.setValue(queryString);
  buildSearchControls(query);
  query.addPara(null,""String_Node_Str"").addButton(""String_Node_Str"").setValue(T_go);
  buildSearchResultsDivision(search);
}","/** 
 * build the DRI page representing the body of the search query. This provides a widget to generate a new query and list of search results if present.
 */
public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  String queryString=getQuery();
  Division search=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  search.setHead(T_head);
  Division query=search.addInteractiveDivision(""String_Node_Str"",""String_Node_Str"",Division.METHOD_GET,""String_Node_Str"");
  List queryList=query.addList(""String_Node_Str"",List.TYPE_FORM);
  if (variableScope()) {
    Select scope=queryList.addItem().addSelect(""String_Node_Str"");
    scope.setLabel(T_search_scope);
    buildScopeList(scope);
  }
  Text text=queryList.addItem().addText(""String_Node_Str"");
  text.setLabel(T_full_text_search);
  text.setValue(queryString);
  buildSearchControls(query);
  query.addPara(null,""String_Node_Str"").addButton(""String_Node_Str"").setValue(T_go);
  buildSearchResultsDivision(search);
}",0.997617913292044
52357,"/** 
 * Get the search query from the URL parameter, if none is found the empty string is returned.
 */
protected String getQuery(){
  Request request=ObjectModelHelper.getRequest(objectModel);
  String query=request.getParameter(""String_Node_Str"");
  if (query == null)   return ""String_Node_Str"";
  return query;
}","/** 
 * Get the search query from the URL parameter, if none is found the empty string is returned.
 */
protected String getQuery() throws UIException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String query=URLDecode(request.getParameter(""String_Node_Str""));
  if (query == null)   return ""String_Node_Str"";
  return query;
}",0.9532428355957768
52358,"/** 
 * Get the query parameters supplied to the browse.
 * @return
 * @throws SQLException
 * @throws UIException
 */
private BrowseParams getUserParams() throws SQLException, UIException {
  if (this.userParams != null)   return this.userParams;
  Context context=ContextUtil.obtainContext(objectModel);
  Request request=ObjectModelHelper.getRequest(objectModel);
  BrowseParams params=new BrowseParams();
  params.month=request.getParameter(BrowseParams.MONTH);
  params.year=request.getParameter(BrowseParams.YEAR);
  params.etAl=RequestUtils.getIntParameter(request,BrowseParams.ETAL);
  params.scope=new BrowserScope(context);
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  if (dso instanceof Community)   params.scope.setCommunity((Community)dso);
  if (dso instanceof Collection)   params.scope.setCollection((Collection)dso);
  try {
    String type=request.getParameter(BrowseParams.TYPE);
    int sortBy=RequestUtils.getIntParameter(request,BrowseParams.SORT_BY);
    BrowseIndex bi=BrowseIndex.getBrowseIndex(type);
    if (bi == null) {
      throw new BrowseException(""String_Node_Str"" + type);
    }
    if (sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi.isItemIndex() && !bi.isInternalIndex()) {
      try {
        SortOption bso=bi.getSortOption();
        SortOption so=SortOption.getSortOption(sortBy);
        if (bso != null && bso != so) {
          BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
          if (newBi != null) {
            bi=newBi;
            type=bi.getName();
          }
        }
      }
 catch (      SortException se) {
        throw new UIException(""String_Node_Str"",se);
      }
    }
    params.scope.setBrowseIndex(bi);
    params.scope.setSortBy(sortBy);
    params.scope.setJumpToItem(RequestUtils.getIntParameter(request,BrowseParams.JUMPTO_ITEM));
    params.scope.setOrder(request.getParameter(BrowseParams.ORDER));
    int offset=RequestUtils.getIntParameter(request,BrowseParams.OFFSET);
    params.scope.setOffset(offset > 0 ? offset : 0);
    params.scope.setResultsPerPage(RequestUtils.getIntParameter(request,BrowseParams.RESULTS_PER_PAGE));
    params.scope.setStartsWith(request.getParameter(BrowseParams.STARTS_WITH));
    params.scope.setFilterValue(request.getParameter(BrowseParams.FILTER_VALUE));
    params.scope.setJumpToValue(request.getParameter(BrowseParams.JUMPTO_VALUE));
    params.scope.setJumpToValueLang(request.getParameter(BrowseParams.JUMPTO_VALUE_LANG));
    params.scope.setFilterValueLang(request.getParameter(BrowseParams.FILTER_VALUE_LANG));
    if (params.scope.getFilterValue() != null)     params.scope.setBrowseLevel(1);
    if (params.year != null && !""String_Node_Str"".equals(params.year) && !""String_Node_Str"".equals(params.year)) {
      String startsWith=params.year;
      if ((params.month != null) && !""String_Node_Str"".equals(params.month) && !""String_Node_Str"".equals(params.month)) {
        if (""String_Node_Str"".equals(params.scope.getOrder())) {
          params.month=Integer.toString((Integer.parseInt(params.month) - 1));
        }
        if (params.month.length() == 1) {
          params.month=""String_Node_Str"" + params.month;
        }
        startsWith=params.year + ""String_Node_Str"" + params.month;
        if (""String_Node_Str"".equals(params.scope.getOrder())) {
          startsWith=startsWith + ""String_Node_Str"";
        }
      }
      params.scope.setStartsWith(startsWith);
    }
  }
 catch (  BrowseException bex) {
    throw new UIException(""String_Node_Str"",bex);
  }
  this.userParams=params;
  return params;
}","/** 
 * Get the query parameters supplied to the browse.
 * @return
 * @throws SQLException
 * @throws UIException
 */
private BrowseParams getUserParams() throws SQLException, UIException {
  if (this.userParams != null)   return this.userParams;
  Context context=ContextUtil.obtainContext(objectModel);
  Request request=ObjectModelHelper.getRequest(objectModel);
  BrowseParams params=new BrowseParams();
  params.month=request.getParameter(BrowseParams.MONTH);
  params.year=request.getParameter(BrowseParams.YEAR);
  params.etAl=RequestUtils.getIntParameter(request,BrowseParams.ETAL);
  params.scope=new BrowserScope(context);
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  if (dso instanceof Community)   params.scope.setCommunity((Community)dso);
  if (dso instanceof Collection)   params.scope.setCollection((Collection)dso);
  try {
    String type=request.getParameter(BrowseParams.TYPE);
    int sortBy=RequestUtils.getIntParameter(request,BrowseParams.SORT_BY);
    BrowseIndex bi=BrowseIndex.getBrowseIndex(type);
    if (bi == null) {
      throw new BrowseException(""String_Node_Str"" + type);
    }
    if (sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi.isItemIndex() && !bi.isInternalIndex()) {
      try {
        SortOption bso=bi.getSortOption();
        SortOption so=SortOption.getSortOption(sortBy);
        if (bso != null && bso != so) {
          BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
          if (newBi != null) {
            bi=newBi;
            type=bi.getName();
          }
        }
      }
 catch (      SortException se) {
        throw new UIException(""String_Node_Str"",se);
      }
    }
    params.scope.setBrowseIndex(bi);
    params.scope.setSortBy(sortBy);
    params.scope.setJumpToItem(RequestUtils.getIntParameter(request,BrowseParams.JUMPTO_ITEM));
    params.scope.setOrder(request.getParameter(BrowseParams.ORDER));
    int offset=RequestUtils.getIntParameter(request,BrowseParams.OFFSET);
    params.scope.setOffset(offset > 0 ? offset : 0);
    params.scope.setResultsPerPage(RequestUtils.getIntParameter(request,BrowseParams.RESULTS_PER_PAGE));
    params.scope.setStartsWith(URLDecode(request.getParameter(BrowseParams.STARTS_WITH)));
    params.scope.setFilterValue(URLDecode(request.getParameter(BrowseParams.FILTER_VALUE)));
    params.scope.setJumpToValue(URLDecode(request.getParameter(BrowseParams.JUMPTO_VALUE)));
    params.scope.setJumpToValueLang(URLDecode(request.getParameter(BrowseParams.JUMPTO_VALUE_LANG)));
    params.scope.setFilterValueLang(URLDecode(request.getParameter(BrowseParams.FILTER_VALUE_LANG)));
    if (params.scope.getFilterValue() != null)     params.scope.setBrowseLevel(1);
    if (params.year != null && !""String_Node_Str"".equals(params.year) && !""String_Node_Str"".equals(params.year)) {
      String startsWith=params.year;
      if ((params.month != null) && !""String_Node_Str"".equals(params.month) && !""String_Node_Str"".equals(params.month)) {
        if (""String_Node_Str"".equals(params.scope.getOrder())) {
          params.month=Integer.toString((Integer.parseInt(params.month) - 1));
        }
        if (params.month.length() == 1) {
          params.month=""String_Node_Str"" + params.month;
        }
        startsWith=params.year + ""String_Node_Str"" + params.month;
        if (""String_Node_Str"".equals(params.scope.getOrder())) {
          startsWith=startsWith + ""String_Node_Str"";
        }
      }
      params.scope.setStartsWith(startsWith);
    }
  }
 catch (  BrowseException bex) {
    throw new UIException(""String_Node_Str"",bex);
  }
  this.userParams=params;
  return params;
}",0.992526158445441
52359,"/** 
 * Decode the given string from URL transmission.
 * @param encodedString The encoded string.
 * @return The unencoded string
 */
public static String URLDecode(String encodedString) throws UIException {
  try {
    return URLDecoder.decode(encodedString,Constants.DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException uee) {
    throw new UIException(uee);
  }
}","/** 
 * Decode the given string from URL transmission.
 * @param encodedString The encoded string.
 * @return The unencoded string
 */
public static String URLDecode(String encodedString) throws UIException {
  if (encodedString == null)   return null;
  try {
    return URLDecoder.decode(encodedString,Constants.DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException uee) {
    throw new UIException(uee);
  }
}",0.9447236180904522
52360,"public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
  String browseListLine=null;
  String browseWidthLine=null;
  if (browseInfo != null) {
    SortOption so=browseInfo.getSortOption();
    BrowseIndex bix=browseInfo.getBrowseIndex();
    if (bix != null) {
      if (so != null && browseListLine == null) {
        browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str""+ so.getName()+ ""String_Node_Str"");
        browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str""+ so.getName()+ ""String_Node_Str"");
      }
      if (so == null)       so=bix.getSortOption();
    }
    if (so != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
    }
    if (bix != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
    }
    if (so != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
    }
    if (bix != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
    }
  }
  if (browseListLine == null) {
    browseListLine=ConfigurationManager.getProperty(""String_Node_Str"");
    browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (browseListLine != null) {
    if (!showThumbs && browseListLine.contains(""String_Node_Str"")) {
      browseListLine=browseListLine == null ? ""String_Node_Str"" : browseListLine;
      browseWidthLine=browseWidthLine == null ? ""String_Node_Str"" : browseWidthLine;
      StringTokenizer bllt=new StringTokenizer(browseListLine,""String_Node_Str"");
      StringTokenizer bwlt=new StringTokenizer(browseWidthLine,""String_Node_Str"");
      StringBuilder newBLLine=new StringBuilder();
      StringBuilder newBWLine=new StringBuilder();
      while (bllt.hasMoreTokens() && bwlt.hasMoreTokens()) {
        String browseListTok=bllt.hasMoreTokens() ? bllt.nextToken() : null;
        String browseWidthTok=bwlt.hasMoreTokens() ? bwlt.nextToken() : null;
        if (browseListTok == null || !browseListTok.trim().equals(""String_Node_Str"")) {
          if (browseListTok != null) {
            if (newBLLine.length() > 0)             newBLLine.append(""String_Node_Str"");
            newBLLine.append(browseListTok);
          }
          if (browseWidthTok != null) {
            if (newBWLine.length() > 0)             newBWLine.append(""String_Node_Str"");
            newBWLine.append(browseWidthTok);
          }
        }
      }
      browseListLine=newBLLine.toString();
      browseWidthLine=newBWLine.toString();
    }
    listFields=browseListLine;
    listWidths=browseWidthLine;
  }
  String dateLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateLine != null) {
    dateField=dateLine;
  }
  String titleLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleLine != null) {
    titleField=titleLine;
  }
  String authorLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (authorLine != null) {
    authorField=authorLine;
  }
  String[] fieldArr=listFields == null ? new String[0] : listFields.split(""String_Node_Str"");
  String[] widthArr=listWidths == null ? new String[0] : listWidths.split(""String_Node_Str"");
  boolean isDate[]=new boolean[fieldArr.length];
  boolean emph[]=new boolean[fieldArr.length];
  boolean isAuthor[]=new boolean[fieldArr.length];
  boolean viewFull[]=new boolean[fieldArr.length];
  String[] browseType=new String[fieldArr.length];
  String[] cOddOrEven=new String[fieldArr.length];
  try {
    CrossLinks cl=new CrossLinks();
    String tablewidth=ConfigurationManager.getProperty(""String_Node_Str"");
    if (widthArr.length > 0 && widthArr.length == fieldArr.length && !linkToEdit) {
      if (!StringUtils.isEmpty(tablewidth)) {
        out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
      }
 else {
        out.println(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      for (int w=0; w < widthArr.length; w++) {
        out.print(""String_Node_Str"");
        if (fieldArr[w].equals(""String_Node_Str"") && widthArr[w].equals(""String_Node_Str"")) {
          out.print(thumbItemListMaxWidth);
        }
 else {
          out.print(StringUtils.isEmpty(widthArr[w]) ? ""String_Node_Str"" : widthArr[w]);
        }
        out.print(""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
 else     if (!StringUtils.isEmpty(tablewidth)) {
      out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
    }
 else {
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
    for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
      String field=fieldArr[colIdx].toLowerCase().trim();
      cOddOrEven[colIdx]=(((colIdx + 1) % 2) == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
      if (field.indexOf(""String_Node_Str"") > 0) {
        field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
        isDate[colIdx]=true;
      }
      fieldArr[colIdx]=field;
      if (field.equals(authorField)) {
        isAuthor[colIdx]=true;
      }
      if (cl.hasLink(field)) {
        browseType[colIdx]=cl.getLinkType(field);
        viewFull[colIdx]=BrowseIndex.getBrowseIndex(browseType[colIdx]).isItemIndex();
      }
      if (field.equals(emphColumn)) {
        emph[colIdx]=true;
      }
      String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
      String css=""String_Node_Str"" + cOddOrEven[colIdx] + ""String_Node_Str"";
      String message=""String_Node_Str"" + field;
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ LocaleSupport.getLocalizedMessage(pageContext,message)+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    if (linkToEdit) {
      String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
      String css=""String_Node_Str"" + cOddOrEven[cOddOrEven.length - 2] + ""String_Node_Str"";
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    out.print(""String_Node_Str"");
    for (int i=0; i < items.length; i++) {
      String rOddOrEven;
      if (i == highlightRow) {
        rOddOrEven=""String_Node_Str"";
      }
 else {
        rOddOrEven=((i % 2) == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
      }
      for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
        String field=fieldArr[colIdx];
        StringTokenizer eq=new StringTokenizer(field,""String_Node_Str"");
        String[] tokens={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int k=0;
        while (eq.hasMoreTokens()) {
          tokens[k]=eq.nextToken().toLowerCase().trim();
          k++;
        }
        String schema=tokens[0];
        String element=tokens[1];
        String qualifier=tokens[2];
        DCValue[] metadataArray;
        if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,Item.ANY,Item.ANY);
        }
 else         if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,null,Item.ANY);
        }
 else {
          metadataArray=items[i].getMetadata(schema,element,qualifier,Item.ANY);
        }
        if (metadataArray == null) {
          metadataArray=new DCValue[0];
        }
        String metadata=""String_Node_Str"";
        if (field.equals(""String_Node_Str"")) {
          metadata=getThumbMarkup(hrq,items[i]);
        }
 else         if (metadataArray.length > 0) {
          if (isDate[colIdx]) {
            DCDate dd=new DCDate(metadataArray[0].value);
            metadata=UIUtil.displayDate(dd,false,false,hrq);
          }
 else           if (field.equals(titleField) && items[i].isWithdrawn()) {
            metadata=Utils.addEntities(metadataArray[0].value);
          }
 else           if (field.equals(titleField)) {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ Utils.addEntities(metadataArray[0].value)+ ""String_Node_Str"";
          }
 else {
            boolean truncated=false;
            int loopLimit=metadataArray.length;
            if (isAuthor[colIdx]) {
              int fieldMax=(authorLimit == -1 ? metadataArray.length : authorLimit);
              loopLimit=(fieldMax > metadataArray.length ? metadataArray.length : fieldMax);
              truncated=(fieldMax < metadataArray.length);
              log.debug(""String_Node_Str"" + field + ""String_Node_Str""+ Integer.toString(loopLimit)+ ""String_Node_Str""+ Integer.toString(metadataArray.length));
            }
            StringBuffer sb=new StringBuffer();
            for (int j=0; j < loopLimit; j++) {
              String startLink=""String_Node_Str"";
              String endLink=""String_Node_Str"";
              if (!StringUtils.isEmpty(browseType[colIdx]) && !disableCrossLinks) {
                String argument=""String_Node_Str"";
                if (viewFull[colIdx]) {
                  argument=""String_Node_Str"";
                }
                startLink=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ browseType[colIdx]+ ""String_Node_Str""+ argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].value);
                if (metadataArray[j].language != null) {
                  startLink=startLink + ""String_Node_Str"" + argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].language)+ ""String_Node_Str"";
                }
 else {
                  startLink=startLink + ""String_Node_Str"";
                }
                endLink=""String_Node_Str"";
              }
              sb.append(startLink);
              sb.append(Utils.addEntities(metadataArray[j].value));
              sb.append(endLink);
              if (j < (loopLimit - 1)) {
                sb.append(""String_Node_Str"");
              }
            }
            if (truncated) {
              String etal=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
              sb.append(""String_Node_Str"" + etal);
            }
            metadata=""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
          }
        }
        String extras=""String_Node_Str"";
        if (isDate[colIdx]) {
          extras=""String_Node_Str"";
        }
        String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[colIdx]+ ""String_Node_Str""+ extras+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ metadata+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      }
      if (linkToEdit) {
        String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[cOddOrEven.length - 2]+ ""String_Node_Str""+ ""String_Node_Str""+ hrq.getContextPath()+ ""String_Node_Str""+ ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
catch (  SQLException e) {
    throw new JspException(e);
  }
catch (  BrowseException e) {
    throw new JspException(e);
  }
  return SKIP_BODY;
}","public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
  String browseListLine=null;
  String browseWidthLine=null;
  if (browseInfo != null) {
    SortOption so=browseInfo.getSortOption();
    BrowseIndex bix=browseInfo.getBrowseIndex();
    if (bix != null) {
      if (so != null && browseListLine == null) {
        browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str""+ so.getName()+ ""String_Node_Str"");
        browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str""+ so.getName()+ ""String_Node_Str"");
      }
      if (so == null)       so=bix.getSortOption();
    }
    if (so != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
    }
    if (bix != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
    }
    if (so != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
    }
    if (bix != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
    }
  }
  if (browseListLine == null) {
    browseListLine=ConfigurationManager.getProperty(""String_Node_Str"");
    browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (browseListLine != null) {
    if (!showThumbs && browseListLine.contains(""String_Node_Str"")) {
      browseListLine=browseListLine == null ? ""String_Node_Str"" : browseListLine;
      browseWidthLine=browseWidthLine == null ? ""String_Node_Str"" : browseWidthLine;
      StringTokenizer bllt=new StringTokenizer(browseListLine,""String_Node_Str"");
      StringTokenizer bwlt=new StringTokenizer(browseWidthLine,""String_Node_Str"");
      StringBuilder newBLLine=new StringBuilder();
      StringBuilder newBWLine=new StringBuilder();
      while (bllt.hasMoreTokens() || bwlt.hasMoreTokens()) {
        String browseListTok=bllt.hasMoreTokens() ? bllt.nextToken() : null;
        String browseWidthTok=bwlt.hasMoreTokens() ? bwlt.nextToken() : null;
        if (browseListTok == null || !browseListTok.trim().equals(""String_Node_Str"")) {
          if (browseListTok != null) {
            if (newBLLine.length() > 0)             newBLLine.append(""String_Node_Str"");
            newBLLine.append(browseListTok);
          }
          if (browseWidthTok != null) {
            if (newBWLine.length() > 0)             newBWLine.append(""String_Node_Str"");
            newBWLine.append(browseWidthTok);
          }
        }
      }
      browseListLine=newBLLine.toString();
      browseWidthLine=newBWLine.toString();
    }
    listFields=browseListLine;
    listWidths=browseWidthLine;
  }
  String dateLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateLine != null) {
    dateField=dateLine;
  }
  String titleLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleLine != null) {
    titleField=titleLine;
  }
  String authorLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (authorLine != null) {
    authorField=authorLine;
  }
  String[] fieldArr=listFields == null ? new String[0] : listFields.split(""String_Node_Str"");
  String[] widthArr=listWidths == null ? new String[0] : listWidths.split(""String_Node_Str"");
  boolean isDate[]=new boolean[fieldArr.length];
  boolean emph[]=new boolean[fieldArr.length];
  boolean isAuthor[]=new boolean[fieldArr.length];
  boolean viewFull[]=new boolean[fieldArr.length];
  String[] browseType=new String[fieldArr.length];
  String[] cOddOrEven=new String[fieldArr.length];
  try {
    CrossLinks cl=new CrossLinks();
    String tablewidth=ConfigurationManager.getProperty(""String_Node_Str"");
    if (widthArr.length > 0 && widthArr.length == fieldArr.length && !linkToEdit) {
      if (!StringUtils.isEmpty(tablewidth)) {
        out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
      }
 else {
        out.println(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      for (int w=0; w < widthArr.length; w++) {
        out.print(""String_Node_Str"");
        if (fieldArr[w].equals(""String_Node_Str"") && widthArr[w].equals(""String_Node_Str"")) {
          out.print(thumbItemListMaxWidth);
        }
 else {
          out.print(StringUtils.isEmpty(widthArr[w]) ? ""String_Node_Str"" : widthArr[w]);
        }
        out.print(""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
 else     if (!StringUtils.isEmpty(tablewidth)) {
      out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
    }
 else {
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
    for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
      String field=fieldArr[colIdx].toLowerCase().trim();
      cOddOrEven[colIdx]=(((colIdx + 1) % 2) == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
      if (field.indexOf(""String_Node_Str"") > 0) {
        field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
        isDate[colIdx]=true;
      }
      fieldArr[colIdx]=field;
      if (field.equals(authorField)) {
        isAuthor[colIdx]=true;
      }
      if (cl.hasLink(field)) {
        browseType[colIdx]=cl.getLinkType(field);
        viewFull[colIdx]=BrowseIndex.getBrowseIndex(browseType[colIdx]).isItemIndex();
      }
      if (field.equals(emphColumn)) {
        emph[colIdx]=true;
      }
      String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
      String css=""String_Node_Str"" + cOddOrEven[colIdx] + ""String_Node_Str"";
      String message=""String_Node_Str"" + field;
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ LocaleSupport.getLocalizedMessage(pageContext,message)+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    if (linkToEdit) {
      String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
      String css=""String_Node_Str"" + cOddOrEven[cOddOrEven.length - 2] + ""String_Node_Str"";
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    out.print(""String_Node_Str"");
    for (int i=0; i < items.length; i++) {
      String rOddOrEven;
      if (i == highlightRow) {
        rOddOrEven=""String_Node_Str"";
      }
 else {
        rOddOrEven=((i % 2) == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
      }
      for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
        String field=fieldArr[colIdx];
        StringTokenizer eq=new StringTokenizer(field,""String_Node_Str"");
        String[] tokens={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int k=0;
        while (eq.hasMoreTokens()) {
          tokens[k]=eq.nextToken().toLowerCase().trim();
          k++;
        }
        String schema=tokens[0];
        String element=tokens[1];
        String qualifier=tokens[2];
        DCValue[] metadataArray;
        if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,Item.ANY,Item.ANY);
        }
 else         if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,null,Item.ANY);
        }
 else {
          metadataArray=items[i].getMetadata(schema,element,qualifier,Item.ANY);
        }
        if (metadataArray == null) {
          metadataArray=new DCValue[0];
        }
        String metadata=""String_Node_Str"";
        if (field.equals(""String_Node_Str"")) {
          metadata=getThumbMarkup(hrq,items[i]);
        }
 else         if (metadataArray.length > 0) {
          if (isDate[colIdx]) {
            DCDate dd=new DCDate(metadataArray[0].value);
            metadata=UIUtil.displayDate(dd,false,false,hrq);
          }
 else           if (field.equals(titleField) && items[i].isWithdrawn()) {
            metadata=Utils.addEntities(metadataArray[0].value);
          }
 else           if (field.equals(titleField)) {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ Utils.addEntities(metadataArray[0].value)+ ""String_Node_Str"";
          }
 else {
            boolean truncated=false;
            int loopLimit=metadataArray.length;
            if (isAuthor[colIdx]) {
              int fieldMax=(authorLimit == -1 ? metadataArray.length : authorLimit);
              loopLimit=(fieldMax > metadataArray.length ? metadataArray.length : fieldMax);
              truncated=(fieldMax < metadataArray.length);
              log.debug(""String_Node_Str"" + field + ""String_Node_Str""+ Integer.toString(loopLimit)+ ""String_Node_Str""+ Integer.toString(metadataArray.length));
            }
            StringBuffer sb=new StringBuffer();
            for (int j=0; j < loopLimit; j++) {
              String startLink=""String_Node_Str"";
              String endLink=""String_Node_Str"";
              if (!StringUtils.isEmpty(browseType[colIdx]) && !disableCrossLinks) {
                String argument=""String_Node_Str"";
                if (viewFull[colIdx]) {
                  argument=""String_Node_Str"";
                }
                startLink=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ browseType[colIdx]+ ""String_Node_Str""+ argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].value);
                if (metadataArray[j].language != null) {
                  startLink=startLink + ""String_Node_Str"" + argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].language)+ ""String_Node_Str"";
                }
 else {
                  startLink=startLink + ""String_Node_Str"";
                }
                endLink=""String_Node_Str"";
              }
              sb.append(startLink);
              sb.append(Utils.addEntities(metadataArray[j].value));
              sb.append(endLink);
              if (j < (loopLimit - 1)) {
                sb.append(""String_Node_Str"");
              }
            }
            if (truncated) {
              String etal=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
              sb.append(""String_Node_Str"" + etal);
            }
            metadata=""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
          }
        }
        String extras=""String_Node_Str"";
        if (isDate[colIdx]) {
          extras=""String_Node_Str"";
        }
        String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[colIdx]+ ""String_Node_Str""+ extras+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ metadata+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      }
      if (linkToEdit) {
        String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[cOddOrEven.length - 2]+ ""String_Node_Str""+ ""String_Node_Str""+ hrq.getContextPath()+ ""String_Node_Str""+ ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
catch (  SQLException e) {
    throw new JspException(e);
  }
catch (  BrowseException e) {
    throw new JspException(e);
  }
  return SKIP_BODY;
}",0.999837925445705
52361,"public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
  boolean emphasiseDate=false;
  boolean emphasiseTitle=false;
  if (emphColumn != null) {
    emphasiseDate=emphColumn.equalsIgnoreCase(""String_Node_Str"");
    emphasiseTitle=emphColumn.equalsIgnoreCase(""String_Node_Str"");
  }
  String configLine=null;
  String widthLine=null;
  if (sortOption != null) {
    if (configLine == null) {
      configLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
      widthLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
    }
    if (configLine == null) {
      configLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
      widthLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
    }
  }
  if (configLine == null) {
    configLine=ConfigurationManager.getProperty(""String_Node_Str"");
    widthLine=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (configLine != null) {
    if (!showThumbs && configLine.contains(""String_Node_Str"")) {
      configLine=configLine == null ? ""String_Node_Str"" : configLine;
      widthLine=widthLine == null ? ""String_Node_Str"" : widthLine;
      StringTokenizer llt=new StringTokenizer(configLine,""String_Node_Str"");
      StringTokenizer wlt=new StringTokenizer(widthLine,""String_Node_Str"");
      StringBuilder newLLine=new StringBuilder();
      StringBuilder newWLine=new StringBuilder();
      while (llt.hasMoreTokens() && wlt.hasMoreTokens()) {
        String listTok=llt.hasMoreTokens() ? llt.nextToken() : null;
        String widthTok=wlt.hasMoreTokens() ? wlt.nextToken() : null;
        if (listTok == null || !listTok.trim().equals(""String_Node_Str"")) {
          if (listTok != null) {
            if (newLLine.length() > 0)             newLLine.append(""String_Node_Str"");
            newLLine.append(listTok);
          }
          if (widthTok != null) {
            if (newWLine.length() > 0)             newWLine.append(""String_Node_Str"");
            newWLine.append(widthTok);
          }
        }
      }
      configLine=newLLine.toString();
      widthLine=newWLine.toString();
    }
    listFields=configLine;
    listWidths=widthLine;
  }
  String dateLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateLine != null) {
    dateField=dateLine;
  }
  String titleLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleLine != null) {
    titleField=titleLine;
  }
  String authorLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (authorLine != null) {
    authorField=authorLine;
  }
  String[] fieldArr=listFields.split(""String_Node_Str"");
  String[] widthArr=listWidths == null ? new String[0] : listWidths.split(""String_Node_Str"");
  boolean isDate[]=new boolean[fieldArr.length];
  boolean emph[]=new boolean[fieldArr.length];
  boolean isAuthor[]=new boolean[fieldArr.length];
  boolean viewFull[]=new boolean[fieldArr.length];
  String[] browseType=new String[fieldArr.length];
  String[] cOddOrEven=new String[fieldArr.length];
  try {
    CrossLinks cl=new CrossLinks();
    String tablewidth=ConfigurationManager.getProperty(""String_Node_Str"");
    if (widthArr.length > 0 && widthArr.length == fieldArr.length && !linkToEdit) {
      if (!StringUtils.isEmpty(tablewidth)) {
        out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
      }
 else {
        out.println(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      for (int w=0; w < widthArr.length; w++) {
        out.print(""String_Node_Str"");
        if (fieldArr[w].equals(""String_Node_Str"") && widthArr[w].equals(""String_Node_Str"")) {
          out.print(thumbItemListMaxWidth);
        }
 else {
          out.print(StringUtils.isEmpty(widthArr[w]) ? ""String_Node_Str"" : widthArr[w]);
        }
        out.print(""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
 else     if (!StringUtils.isEmpty(tablewidth)) {
      out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
    }
 else {
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
    for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
      String field=fieldArr[colIdx].toLowerCase().trim();
      cOddOrEven[colIdx]=(((colIdx + 1) % 2) == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
      if (field.indexOf(""String_Node_Str"") > 0) {
        field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
        isDate[colIdx]=true;
      }
      fieldArr[colIdx]=field;
      if (field.equals(authorField)) {
        isAuthor[colIdx]=true;
      }
      if (cl.hasLink(field)) {
        browseType[colIdx]=cl.getLinkType(field);
        viewFull[colIdx]=BrowseIndex.getBrowseIndex(browseType[colIdx]).isItemIndex();
      }
      if (field.equals(emphColumn)) {
        emph[colIdx]=true;
      }
 else       if ((field.equals(dateField) && emphasiseDate) || (field.equals(titleField) && emphasiseTitle)) {
        emph[colIdx]=true;
      }
      String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
      String css=""String_Node_Str"" + cOddOrEven[colIdx] + ""String_Node_Str"";
      String message=""String_Node_Str"" + field;
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ LocaleSupport.getLocalizedMessage(pageContext,message)+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    if (linkToEdit) {
      String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
      String css=""String_Node_Str"" + cOddOrEven[cOddOrEven.length - 2] + ""String_Node_Str"";
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    out.print(""String_Node_Str"");
    for (int i=0; i < items.length; i++) {
      String rOddOrEven;
      if (i == highlightRow) {
        rOddOrEven=""String_Node_Str"";
      }
 else {
        rOddOrEven=((i % 2) == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
      }
      for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
        String field=fieldArr[colIdx];
        StringTokenizer eq=new StringTokenizer(field,""String_Node_Str"");
        String[] tokens={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int k=0;
        while (eq.hasMoreTokens()) {
          tokens[k]=eq.nextToken().toLowerCase().trim();
          k++;
        }
        String schema=tokens[0];
        String element=tokens[1];
        String qualifier=tokens[2];
        DCValue[] metadataArray;
        if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,Item.ANY,Item.ANY);
        }
 else         if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,null,Item.ANY);
        }
 else {
          metadataArray=items[i].getMetadata(schema,element,qualifier,Item.ANY);
        }
        if (metadataArray == null) {
          metadataArray=new DCValue[0];
        }
        String metadata=""String_Node_Str"";
        if (field.equals(""String_Node_Str"")) {
          metadata=getThumbMarkup(hrq,items[i]);
        }
        if (metadataArray.length > 0) {
          if (isDate[colIdx]) {
            DCDate dd=new DCDate(metadataArray[0].value);
            metadata=UIUtil.displayDate(dd,false,false,hrq);
          }
 else           if (field.equals(titleField) && items[i].isWithdrawn()) {
            metadata=Utils.addEntities(metadataArray[0].value);
          }
 else           if (field.equals(titleField)) {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ Utils.addEntities(metadataArray[0].value)+ ""String_Node_Str"";
          }
 else {
            boolean truncated=false;
            int loopLimit=metadataArray.length;
            if (isAuthor[colIdx]) {
              int fieldMax=(authorLimit > 0 ? authorLimit : metadataArray.length);
              loopLimit=(fieldMax > metadataArray.length ? metadataArray.length : fieldMax);
              truncated=(fieldMax < metadataArray.length);
              log.debug(""String_Node_Str"" + field + ""String_Node_Str""+ Integer.toString(loopLimit)+ ""String_Node_Str""+ Integer.toString(metadataArray.length));
            }
            StringBuffer sb=new StringBuffer();
            for (int j=0; j < loopLimit; j++) {
              String startLink=""String_Node_Str"";
              String endLink=""String_Node_Str"";
              if (!StringUtils.isEmpty(browseType[colIdx]) && !disableCrossLinks) {
                String argument=""String_Node_Str"";
                if (viewFull[colIdx]) {
                  argument=""String_Node_Str"";
                }
                startLink=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ browseType[colIdx]+ ""String_Node_Str""+ argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].value);
                if (metadataArray[j].language != null) {
                  startLink=startLink + ""String_Node_Str"" + argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].language)+ ""String_Node_Str"";
                }
 else {
                  startLink=startLink + ""String_Node_Str"";
                }
                endLink=""String_Node_Str"";
              }
              sb.append(startLink);
              sb.append(Utils.addEntities(metadataArray[j].value));
              sb.append(endLink);
              if (j < (loopLimit - 1)) {
                sb.append(""String_Node_Str"");
              }
            }
            if (truncated) {
              String etal=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
              sb.append(""String_Node_Str"" + etal);
            }
            metadata=""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
          }
        }
        String extras=""String_Node_Str"";
        if (isDate[colIdx]) {
          extras=""String_Node_Str"";
        }
        String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[colIdx]+ ""String_Node_Str""+ extras+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ metadata+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      }
      if (linkToEdit) {
        String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[cOddOrEven.length - 2]+ ""String_Node_Str""+ ""String_Node_Str""+ hrq.getContextPath()+ ""String_Node_Str""+ ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
catch (  BrowseException e) {
    throw new JspException(e);
  }
  return SKIP_BODY;
}","public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
  boolean emphasiseDate=false;
  boolean emphasiseTitle=false;
  if (emphColumn != null) {
    emphasiseDate=emphColumn.equalsIgnoreCase(""String_Node_Str"");
    emphasiseTitle=emphColumn.equalsIgnoreCase(""String_Node_Str"");
  }
  String configLine=null;
  String widthLine=null;
  if (sortOption != null) {
    if (configLine == null) {
      configLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
      widthLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
    }
    if (configLine == null) {
      configLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
      widthLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
    }
  }
  if (configLine == null) {
    configLine=ConfigurationManager.getProperty(""String_Node_Str"");
    widthLine=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (configLine != null) {
    if (!showThumbs && configLine.contains(""String_Node_Str"")) {
      configLine=configLine == null ? ""String_Node_Str"" : configLine;
      widthLine=widthLine == null ? ""String_Node_Str"" : widthLine;
      StringTokenizer llt=new StringTokenizer(configLine,""String_Node_Str"");
      StringTokenizer wlt=new StringTokenizer(widthLine,""String_Node_Str"");
      StringBuilder newLLine=new StringBuilder();
      StringBuilder newWLine=new StringBuilder();
      while (llt.hasMoreTokens() || wlt.hasMoreTokens()) {
        String listTok=llt.hasMoreTokens() ? llt.nextToken() : null;
        String widthTok=wlt.hasMoreTokens() ? wlt.nextToken() : null;
        if (listTok == null || !listTok.trim().equals(""String_Node_Str"")) {
          if (listTok != null) {
            if (newLLine.length() > 0)             newLLine.append(""String_Node_Str"");
            newLLine.append(listTok);
          }
          if (widthTok != null) {
            if (newWLine.length() > 0)             newWLine.append(""String_Node_Str"");
            newWLine.append(widthTok);
          }
        }
      }
      configLine=newLLine.toString();
      widthLine=newWLine.toString();
    }
    listFields=configLine;
    listWidths=widthLine;
  }
  String dateLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateLine != null) {
    dateField=dateLine;
  }
  String titleLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleLine != null) {
    titleField=titleLine;
  }
  String authorLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (authorLine != null) {
    authorField=authorLine;
  }
  String[] fieldArr=listFields.split(""String_Node_Str"");
  String[] widthArr=listWidths == null ? new String[0] : listWidths.split(""String_Node_Str"");
  boolean isDate[]=new boolean[fieldArr.length];
  boolean emph[]=new boolean[fieldArr.length];
  boolean isAuthor[]=new boolean[fieldArr.length];
  boolean viewFull[]=new boolean[fieldArr.length];
  String[] browseType=new String[fieldArr.length];
  String[] cOddOrEven=new String[fieldArr.length];
  try {
    CrossLinks cl=new CrossLinks();
    String tablewidth=ConfigurationManager.getProperty(""String_Node_Str"");
    if (widthArr.length > 0 && widthArr.length == fieldArr.length && !linkToEdit) {
      if (!StringUtils.isEmpty(tablewidth)) {
        out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
      }
 else {
        out.println(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      for (int w=0; w < widthArr.length; w++) {
        out.print(""String_Node_Str"");
        if (fieldArr[w].equals(""String_Node_Str"") && widthArr[w].equals(""String_Node_Str"")) {
          out.print(thumbItemListMaxWidth);
        }
 else {
          out.print(StringUtils.isEmpty(widthArr[w]) ? ""String_Node_Str"" : widthArr[w]);
        }
        out.print(""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
 else     if (!StringUtils.isEmpty(tablewidth)) {
      out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
    }
 else {
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
    for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
      String field=fieldArr[colIdx].toLowerCase().trim();
      cOddOrEven[colIdx]=(((colIdx + 1) % 2) == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
      if (field.indexOf(""String_Node_Str"") > 0) {
        field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
        isDate[colIdx]=true;
      }
      fieldArr[colIdx]=field;
      if (field.equals(authorField)) {
        isAuthor[colIdx]=true;
      }
      if (cl.hasLink(field)) {
        browseType[colIdx]=cl.getLinkType(field);
        viewFull[colIdx]=BrowseIndex.getBrowseIndex(browseType[colIdx]).isItemIndex();
      }
      if (field.equals(emphColumn)) {
        emph[colIdx]=true;
      }
 else       if ((field.equals(dateField) && emphasiseDate) || (field.equals(titleField) && emphasiseTitle)) {
        emph[colIdx]=true;
      }
      String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
      String css=""String_Node_Str"" + cOddOrEven[colIdx] + ""String_Node_Str"";
      String message=""String_Node_Str"" + field;
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ LocaleSupport.getLocalizedMessage(pageContext,message)+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    if (linkToEdit) {
      String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
      String css=""String_Node_Str"" + cOddOrEven[cOddOrEven.length - 2] + ""String_Node_Str"";
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    out.print(""String_Node_Str"");
    for (int i=0; i < items.length; i++) {
      String rOddOrEven;
      if (i == highlightRow) {
        rOddOrEven=""String_Node_Str"";
      }
 else {
        rOddOrEven=((i % 2) == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
      }
      for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
        String field=fieldArr[colIdx];
        StringTokenizer eq=new StringTokenizer(field,""String_Node_Str"");
        String[] tokens={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int k=0;
        while (eq.hasMoreTokens()) {
          tokens[k]=eq.nextToken().toLowerCase().trim();
          k++;
        }
        String schema=tokens[0];
        String element=tokens[1];
        String qualifier=tokens[2];
        DCValue[] metadataArray;
        if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,Item.ANY,Item.ANY);
        }
 else         if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,null,Item.ANY);
        }
 else {
          metadataArray=items[i].getMetadata(schema,element,qualifier,Item.ANY);
        }
        if (metadataArray == null) {
          metadataArray=new DCValue[0];
        }
        String metadata=""String_Node_Str"";
        if (field.equals(""String_Node_Str"")) {
          metadata=getThumbMarkup(hrq,items[i]);
        }
        if (metadataArray.length > 0) {
          if (isDate[colIdx]) {
            DCDate dd=new DCDate(metadataArray[0].value);
            metadata=UIUtil.displayDate(dd,false,false,hrq);
          }
 else           if (field.equals(titleField) && items[i].isWithdrawn()) {
            metadata=Utils.addEntities(metadataArray[0].value);
          }
 else           if (field.equals(titleField)) {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ Utils.addEntities(metadataArray[0].value)+ ""String_Node_Str"";
          }
 else {
            boolean truncated=false;
            int loopLimit=metadataArray.length;
            if (isAuthor[colIdx]) {
              int fieldMax=(authorLimit > 0 ? authorLimit : metadataArray.length);
              loopLimit=(fieldMax > metadataArray.length ? metadataArray.length : fieldMax);
              truncated=(fieldMax < metadataArray.length);
              log.debug(""String_Node_Str"" + field + ""String_Node_Str""+ Integer.toString(loopLimit)+ ""String_Node_Str""+ Integer.toString(metadataArray.length));
            }
            StringBuffer sb=new StringBuffer();
            for (int j=0; j < loopLimit; j++) {
              String startLink=""String_Node_Str"";
              String endLink=""String_Node_Str"";
              if (!StringUtils.isEmpty(browseType[colIdx]) && !disableCrossLinks) {
                String argument=""String_Node_Str"";
                if (viewFull[colIdx]) {
                  argument=""String_Node_Str"";
                }
                startLink=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ browseType[colIdx]+ ""String_Node_Str""+ argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].value);
                if (metadataArray[j].language != null) {
                  startLink=startLink + ""String_Node_Str"" + argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].language)+ ""String_Node_Str"";
                }
 else {
                  startLink=startLink + ""String_Node_Str"";
                }
                endLink=""String_Node_Str"";
              }
              sb.append(startLink);
              sb.append(Utils.addEntities(metadataArray[j].value));
              sb.append(endLink);
              if (j < (loopLimit - 1)) {
                sb.append(""String_Node_Str"");
              }
            }
            if (truncated) {
              String etal=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
              sb.append(""String_Node_Str"" + etal);
            }
            metadata=""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
          }
        }
        String extras=""String_Node_Str"";
        if (isDate[colIdx]) {
          extras=""String_Node_Str"";
        }
        String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[colIdx]+ ""String_Node_Str""+ extras+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ metadata+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      }
      if (linkToEdit) {
        String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[cOddOrEven.length - 2]+ ""String_Node_Str""+ ""String_Node_Str""+ hrq.getContextPath()+ ""String_Node_Str""+ ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
catch (  BrowseException e) {
    throw new JspException(e);
  }
  return SKIP_BODY;
}",0.9998237419582268
52362,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  DCInputSet inputSet=null;
  DCInput[] inputs={};
  try {
    inputSet=getInputsReader().getInputs(submission.getCollection().getHandle());
    inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  for (  DCInput dcInput : inputs) {
    if (!dcInput.isVisible(SCOPE))     continue;
    String schema=dcInput.getSchema();
    String element=dcInput.getElement();
    String qualifier=dcInput.getQualifier();
    DCValue[] dcValues=item.getMetadata(schema,element,qualifier,Item.ANY);
    String fieldName=FlowUtils.getFieldName(dcInput);
    String inputType=dcInput.getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      renderNameField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDateField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSeriesField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      DCValue[] unfiltered=item.getMetadata(dcInput.getSchema(),dcInput.getElement(),Item.ANY,Item.ANY);
      ArrayList<DCValue> filtered=new ArrayList<DCValue>();
      for (      DCValue dcValue : unfiltered) {
        String unfilteredFieldName=dcValue.element + ""String_Node_Str"" + dcValue.qualifier;
        if (!inputSet.isFieldPresent(unfilteredFieldName)) {
          filtered.add(dcValue);
        }
      }
      renderQualdropField(form,fieldName,dcInput,filtered.toArray(new DCValue[filtered.size()]));
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderTextArea(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDropdownField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSelectFromListField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else {
      form.addItem(T_unknown_field);
    }
  }
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
  addControlButtons(form);
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  DCInputSet inputSet=null;
  DCInput[] inputs={};
  try {
    inputSet=getInputsReader().getInputs(submission.getCollection().getHandle());
    inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  for (  DCInput dcInput : inputs) {
    if (!dcInput.isVisible(submissionInfo.isInWorkflow() ? WORKFLOW_SCOPE : SUBMISSION_SCOPE))     continue;
    String schema=dcInput.getSchema();
    String element=dcInput.getElement();
    String qualifier=dcInput.getQualifier();
    DCValue[] dcValues=item.getMetadata(schema,element,qualifier,Item.ANY);
    String fieldName=FlowUtils.getFieldName(dcInput);
    String inputType=dcInput.getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      renderNameField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDateField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSeriesField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      DCValue[] unfiltered=item.getMetadata(dcInput.getSchema(),dcInput.getElement(),Item.ANY,Item.ANY);
      ArrayList<DCValue> filtered=new ArrayList<DCValue>();
      for (      DCValue dcValue : unfiltered) {
        String unfilteredFieldName=dcValue.element + ""String_Node_Str"" + dcValue.qualifier;
        if (!inputSet.isFieldPresent(unfilteredFieldName)) {
          filtered.add(dcValue);
        }
      }
      renderQualdropField(form,fieldName,dcInput,filtered.toArray(new DCValue[filtered.size()]));
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderTextArea(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDropdownField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSelectFromListField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else {
      form.addItem(T_unknown_field);
    }
  }
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
  addControlButtons(form);
}",0.9898717083051992
52363,"/** 
 * Each submission step must define its own information to be reviewed during the final Review/Verify Step in the submission process. <P> The information to review should be tacked onto the passed in  List object. <P> NOTE: To remain consistent across all Steps, you should first add a sub-List object (with this step's name as the heading), by using a call to reviewList.addList().   This sublist is the list you return from this method!
 * @param reviewList The List to which all reviewable information should be added
 * @return The new sub-List object created by this step, which contains all the reviewable information.  If this step has nothing to review, then return null!   
 */
public List addReviewSection(List reviewList) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  List describeSection=reviewList.addList(""String_Node_Str"" + this.stepAndPage,List.TYPE_FORM);
  describeSection.setHead(T_head);
  DCInputSet inputSet=null;
  try {
    inputSet=getInputsReader().getInputs(submission.getCollection().getHandle());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  DCInput[] inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  for (  DCInput input : inputs) {
    if (!input.isVisible(SCOPE))     continue;
    String inputType=input.getInputType();
    String pairsName=input.getPairsType();
    DCValue[] values=new DCValue[0];
    if (inputType.equals(""String_Node_Str"")) {
      values=submission.getItem().getMetadata(input.getSchema(),input.getElement(),Item.ANY,Item.ANY);
    }
 else {
      values=submission.getItem().getMetadata(input.getSchema(),input.getElement(),input.getQualifier(),Item.ANY);
    }
    if (values.length == 0) {
      describeSection.addLabel(input.getLabel());
      describeSection.addItem().addHighlight(""String_Node_Str"").addContent(ReviewStep.T_no_metadata);
    }
 else {
      for (      DCValue value : values) {
        String displayValue=null;
        if (inputType.equals(""String_Node_Str"")) {
          DCDate date=new DCDate(value.value);
          displayValue=date.toString();
        }
 else         if (inputType.equals(""String_Node_Str"")) {
          displayValue=input.getDisplayString(pairsName,value.value);
        }
 else         if (inputType.equals(""String_Node_Str"")) {
          String qualifier=value.qualifier;
          String displayQual=input.getDisplayString(pairsName,qualifier);
          displayValue=displayQual + ""String_Node_Str"" + value.value;
        }
 else {
          displayValue=value.value;
        }
        describeSection.addLabel(input.getLabel());
        describeSection.addItem(displayValue);
      }
    }
  }
  return describeSection;
}","/** 
 * Each submission step must define its own information to be reviewed during the final Review/Verify Step in the submission process. <P> The information to review should be tacked onto the passed in  List object. <P> NOTE: To remain consistent across all Steps, you should first add a sub-List object (with this step's name as the heading), by using a call to reviewList.addList().   This sublist is the list you return from this method!
 * @param reviewList The List to which all reviewable information should be added
 * @return The new sub-List object created by this step, which contains all the reviewable information.  If this step has nothing to review, then return null!   
 */
public List addReviewSection(List reviewList) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  List describeSection=reviewList.addList(""String_Node_Str"" + this.stepAndPage,List.TYPE_FORM);
  describeSection.setHead(T_head);
  DCInputSet inputSet=null;
  try {
    inputSet=getInputsReader().getInputs(submission.getCollection().getHandle());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  DCInput[] inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  for (  DCInput input : inputs) {
    if (!input.isVisible(submissionInfo.isInWorkflow() ? WORKFLOW_SCOPE : SUBMISSION_SCOPE))     continue;
    String inputType=input.getInputType();
    String pairsName=input.getPairsType();
    DCValue[] values=new DCValue[0];
    if (inputType.equals(""String_Node_Str"")) {
      values=submission.getItem().getMetadata(input.getSchema(),input.getElement(),Item.ANY,Item.ANY);
    }
 else {
      values=submission.getItem().getMetadata(input.getSchema(),input.getElement(),input.getQualifier(),Item.ANY);
    }
    if (values.length == 0) {
      describeSection.addLabel(input.getLabel());
      describeSection.addItem().addHighlight(""String_Node_Str"").addContent(ReviewStep.T_no_metadata);
    }
 else {
      for (      DCValue value : values) {
        String displayValue=null;
        if (inputType.equals(""String_Node_Str"")) {
          DCDate date=new DCDate(value.value);
          displayValue=date.toString();
        }
 else         if (inputType.equals(""String_Node_Str"")) {
          displayValue=input.getDisplayString(pairsName,value.value);
        }
 else         if (inputType.equals(""String_Node_Str"")) {
          String qualifier=value.qualifier;
          String displayQual=input.getDisplayString(pairsName,qualifier);
          displayValue=displayQual + ""String_Node_Str"" + value.value;
        }
 else {
          displayValue=value.value;
        }
        describeSection.addLabel(input.getLabel());
        describeSection.addItem(displayValue);
      }
    }
  }
  return describeSection;
}",0.9893048128342246
52364,"/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]);
  }
  Item item=(Item)dso;
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + dso.getID());
      }
    }
 else {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      e.setAttribute(""String_Node_Str"",v.value);
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}","/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]);
  }
  Item item=(Item)dso;
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + dso.getID());
      }
    }
 else {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      e.setAttribute(""String_Node_Str"",v.value == null ? ""String_Node_Str"" : v.value);
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}",0.9900783289817232
52365,"/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    String h=dso.getHandle();
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]+ ""String_Node_Str""+ (h == null ? ""String_Node_Str"" : h));
  }
  Item item=(Item)dso;
  String handle=item.getHandle();
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + (handle == null ? String.valueOf(dso.getID()) : handle) + ""String_Node_Str""+ originalKey);
      }
    }
 else {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      e.setAttribute(""String_Node_Str"",v.value);
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}","/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    String h=dso.getHandle();
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]+ ""String_Node_Str""+ (h == null ? ""String_Node_Str"" : h));
  }
  Item item=(Item)dso;
  String handle=item.getHandle();
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + (handle == null ? String.valueOf(dso.getID()) : handle) + ""String_Node_Str""+ originalKey);
      }
    }
 else {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      e.setAttribute(""String_Node_Str"",v.value == null ? ""String_Node_Str"" : v.value);
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}",0.9910037878787878
52366,"/** 
 */
public static Properties getProperties(){
  return (Properties)properties.clone();
}","/** 
 */
public static Properties getProperties(){
  if (properties == null) {
    loadConfig(null);
  }
  return (Properties)properties.clone();
}",0.775
52367,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Division feedback=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  feedback.setHead(T_head);
  feedback.addPara(T_para1);
  List form=feedback.addList(""String_Node_Str"",List.TYPE_FORM);
  Text email=form.addItem().addText(""String_Node_Str"");
  email.setLabel(T_email);
  email.setHelp(T_email_help);
  email.setValue(parameters.getParameter(""String_Node_Str"",""String_Node_Str""));
  TextArea comments=form.addItem().addTextArea(""String_Node_Str"");
  comments.setLabel(T_comments);
  comments.setSize(5,60);
  comments.setValue(parameters.getParameter(""String_Node_Str"",""String_Node_Str""));
  form.addItem().addButton(""String_Node_Str"").setValue(T_submit);
  feedback.addHidden(""String_Node_Str"").setValue(parameters.getParameter(""String_Node_Str"",""String_Node_Str""));
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Division feedback=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  feedback.setHead(T_head);
  feedback.addPara(T_para1);
  List form=feedback.addList(""String_Node_Str"",List.TYPE_FORM);
  Text email=form.addItem().addText(""String_Node_Str"");
  email.setLabel(T_email);
  email.setHelp(T_email_help);
  email.setValue(parameters.getParameter(""String_Node_Str"",""String_Node_Str""));
  TextArea comments=form.addItem().addTextArea(""String_Node_Str"");
  comments.setLabel(T_comments);
  comments.setValue(parameters.getParameter(""String_Node_Str"",""String_Node_Str""));
  form.addItem().addButton(""String_Node_Str"").setValue(T_submit);
  feedback.addHidden(""String_Node_Str"").setValue(parameters.getParameter(""String_Node_Str"",""String_Node_Str""));
}",0.9864158829676072
52368,"/** 
 * figures out if the date is valid for the policy
 * @return true if policy has begun and hasn't expired yet (or no dates areset)
 */
public boolean isDateValid(){
  Date sd=getStartDate();
  Date ed=getEndDate();
  if ((sd == null) && (ed == null)) {
    return true;
  }
  Date now=new Date();
  if (sd != null) {
    if (now.before(sd)) {
      return false;
    }
  }
  if (ed != null) {
    if (now.after(sd)) {
      return false;
    }
  }
  return true;
}","/** 
 * figures out if the date is valid for the policy
 * @return true if policy has begun and hasn't expired yet (or no dates areset)
 */
public boolean isDateValid(){
  Date sd=getStartDate();
  Date ed=getEndDate();
  if ((sd == null) && (ed == null)) {
    return true;
  }
  Date now=new Date();
  if (sd != null) {
    if (now.before(sd)) {
      return false;
    }
  }
  if (ed != null) {
    if (now.after(ed)) {
      return false;
    }
  }
  return true;
}",0.8869936034115139
52369,"/** 
 * figures out if the date is valid for the policy
 * @return true if policy has begun and hasn't expired yet (or no dates areset)
 */
public boolean isDateValid(){
  Date sd=getStartDate();
  Date ed=getEndDate();
  if ((sd == null) && (ed == null)) {
    return true;
  }
  Date now=new Date();
  if (sd != null) {
    if (now.before(sd)) {
      return false;
    }
  }
  if (ed != null) {
    if (now.after(sd)) {
      return false;
    }
  }
  return true;
}","/** 
 * figures out if the date is valid for the policy
 * @return true if policy has begun and hasn't expired yet (or no dates areset)
 */
public boolean isDateValid(){
  Date sd=getStartDate();
  Date ed=getEndDate();
  if ((sd == null) && (ed == null)) {
    return true;
  }
  Date now=new Date();
  if (sd != null) {
    if (now.before(sd)) {
      return false;
    }
  }
  if (ed != null) {
    if (now.after(ed)) {
      return false;
    }
  }
  return true;
}",0.8869936034115139
52370,"/** 
 * Browse the archive by single values (such as the name of an author).  This produces a BrowseInfo object that contains Strings as the results of the browse
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByValue(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bs.getJumpToValue()));
  try {
    dao.setTable(browseIndex.getDistinctTableName());
    dao.setDistinct(true);
    dao.setAscending(scope.isAscending());
    dao.setOrderField(""String_Node_Str"");
    if (scope.inCollection() || scope.inCommunity()) {
      dao.setFilterMappingTables(null,browseIndex.getMapTableName());
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    dao.setJumpToField(""String_Node_Str"");
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && scope.hasJumpToValue() || scope.hasStartsWith()) {
      String focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith() && browseIndex.isDate()) {
        focusValue=focusValue + ""String_Node_Str"";
      }
      offset=getOffsetForDistinctValue(focusValue);
    }
    dao.setOffset(offset);
    dao.setLimit(scope.getResultsPerPage());
    List results=dao.doValueQuery();
    int total=getTotalResults(true);
    if (results.size() == 0) {
      offset=total - scope.getResultsPerPage();
      if (offset < 0)       offset=0;
      dao.setOffset(offset);
      results=dao.doQuery();
      total=getTotalResults();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setFocus(rawFocusValue);
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by single values (such as the name of an author).  This produces a BrowseInfo object that contains Strings as the results of the browse
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByValue(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bs.getJumpToValue()));
  try {
    dao.setTable(browseIndex.getDistinctTableName());
    dao.setDistinct(true);
    dao.setAscending(scope.isAscending());
    dao.setOrderField(""String_Node_Str"");
    if (scope.inCollection() || scope.inCommunity()) {
      dao.setFilterMappingTables(null,browseIndex.getMapTableName());
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    dao.setJumpToField(""String_Node_Str"");
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && scope.hasJumpToValue() || scope.hasStartsWith()) {
      String focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith() && browseIndex.isDate()) {
        focusValue=focusValue + ""String_Node_Str"";
      }
      offset=getOffsetForDistinctValue(focusValue);
    }
    dao.setOffset(offset);
    dao.setLimit(scope.getResultsPerPage());
    int total=getTotalResults();
    List results=null;
    if (total > 0) {
      results=dao.doQuery();
      if (results.size() == 0) {
        offset=total - scope.getResultsPerPage();
        if (offset < 0)         offset=0;
        dao.setOffset(offset);
        results=dao.doQuery();
      }
    }
 else {
      results=new ArrayList();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setFocus(rawFocusValue);
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9677839245037424
52371,"/** 
 * Get the total number of results.  The argument determines whether this is a distinct browse or not as this has an impact on how results are counted
 * @param distinct  is this a distinct browse or not
 * @return          the total number of results available in this type of browse
 * @throws SQLException
 * @throws BrowseException
 */
private int getTotalResults(boolean distinct) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + distinct));
  dao.setDistinct(distinct);
  String[] select={""String_Node_Str""};
  dao.setCountValues(select);
  String focusField=dao.getJumpToField();
  String focusValue=dao.getJumpToValue();
  String orderField=dao.getOrderField();
  int limit=dao.getLimit();
  int offset=dao.getOffset();
  dao.setJumpToField(null);
  dao.setJumpToValue(null);
  dao.setOrderField(null);
  dao.setLimit(-1);
  dao.setOffset(-1);
  int count=dao.doCountQuery();
  dao.setJumpToField(focusField);
  dao.setJumpToValue(focusValue);
  dao.setOrderField(orderField);
  dao.setLimit(limit);
  dao.setOffset(offset);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + count));
  return count;
}","/** 
 * Get the total number of results.  The argument determines whether this is a distinct browse or not as this has an impact on how results are counted
 * @param distinct  is this a distinct browse or not
 * @return          the total number of results available in this type of browse
 * @throws SQLException
 * @throws BrowseException
 */
private int getTotalResults(boolean distinct) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + distinct));
  dao.setDistinct(distinct);
  String[] select={""String_Node_Str""};
  dao.setCountValues(select);
  String focusField=dao.getJumpToField();
  String focusValue=dao.getJumpToValue();
  String orderField=dao.getOrderField();
  int limit=dao.getLimit();
  int offset=dao.getOffset();
  dao.setJumpToField(null);
  dao.setJumpToValue(null);
  dao.setOrderField(null);
  dao.setLimit(-1);
  dao.setOffset(-1);
  int count=dao.doCountQuery();
  dao.setJumpToField(focusField);
  dao.setJumpToValue(focusValue);
  dao.setOrderField(orderField);
  dao.setLimit(limit);
  dao.setOffset(offset);
  dao.setCountValues(null);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + count));
  return count;
}",0.9885807504078304
52372,"/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName());
    dao.setAscending(scope.isAscending());
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      String value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
      dao.setFilterMappingTables(browseIndex.getDistinctTableName(),browseIndex.getMapTableName());
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith())) {
      rawFocusValue=getJumpToValue();
      String focusValue=normalizeJumpToValue(rawFocusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      String focusField=browseIndex.getSortField(scope.isSecondLevel());
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      offset=getOffsetForValue(focusValue);
    }
    dao.setOffset(offset);
    String orderBy=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage());
    List results=dao.doQuery();
    int total=getTotalResults();
    if (results.size() == 0) {
      offset=total - scope.getResultsPerPage();
      if (offset < 0)       offset=0;
      dao.setOffset(offset);
      results=dao.doQuery();
      total=getTotalResults();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName());
    dao.setAscending(scope.isAscending());
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      String value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
      dao.setFilterMappingTables(browseIndex.getDistinctTableName(),browseIndex.getMapTableName());
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith())) {
      rawFocusValue=getJumpToValue();
      String focusValue=normalizeJumpToValue(rawFocusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      String focusField=browseIndex.getSortField(scope.isSecondLevel());
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      offset=getOffsetForValue(focusValue);
    }
    dao.setOffset(offset);
    String orderBy=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage());
    int total=getTotalResults();
    List results=null;
    if (total > 0) {
      results=dao.doQuery();
      if (results.size() == 0) {
        offset=total - scope.getResultsPerPage();
        if (offset < 0)         offset=0;
        dao.setOffset(offset);
        results=dao.doQuery();
      }
    }
 else {
      results=new ArrayList();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9778667000125046
52373,"/** 
 * Set the database id of the container object.  This should be the id of a  Community or Collection.  This will constrain the results of the browse to only items or values within items that appear in the given container.
 * @param containerID
 */
public void setContainerID(int containerID);","/** 
 * Set the database id of the container object.  This should be the id of a Community or Collection.  This will constrain the results of the browse to only items or values within items that appear in the given container.
 * @param containerID
 */
public void setContainerID(int containerID);",0.9983136593591906
52374,"/** 
 * get the integer number which is the limit of the results that will be returned by any query.  The default is -1, which means unlimited results.
 * @return	the maximum possible number of results allowed to be returned
 */
public int getLimit();","/** 
 * get the integer number which is the limit of the results that will be returned by any query.  The default is -1, which means unlimited results.
 * @return  the maximum possible number of results allowed to be returned
 */
public int getLimit();",0.9940357852882704
52375,"/** 
 * Get the offset from the first result from which to return results.  This  functionality is present for backwards compatibility, but is ill advised.  All normal browse operations can be completed without it.  The default is -1, which means do not offset.
 * @return		the offset
 */
public int getOffset();","/** 
 * Get the offset from the first result from which to return results.  This functionality is present for backwards compatibility, but is ill advised.  All normal browse operations can be completed without it.  The default is -1, which means do not offset.
 * @return      the offset
 */
public int getOffset();",0.985645933014354
52376,"/** 
 * get the name of the field in which to look for the container id.  This is principally for use internal to the DAO.
 * @return	the name of the container id field.  For example ""collection_id"" or""community_id""
 */
public String getContainerIDField();","/** 
 * get the name of the field in which to look for the container id.  This is principally for use internal to the DAO.
 * @return  the name of the container id field.  For example ""collection_id"" or""community_id""
 */
public String getContainerIDField();",0.9941520467836256
52377,"/** 
 * Set the focus field upon which we will match a value from which to start the browse.  This will either be the ""sort_value"" field or one of the additional sort fields defined by configuration param focusField		the name of the focus field
 */
public void setJumpToField(String focusField);","/** 
 * Set the focus field upon which we will match a value from which to start the browse.  This will either be the ""sort_value"" field or one of the additional sort fields defined by configuration param focusField     the name of the focus field
 */
public void setJumpToField(String focusField);",0.988195615514334
52378,"/** 
 * This executes a query which will count the number of results for the parameters you set.
 * @return		the integer value of the number of results found
 * @throws BrowseException
 */
public int doCountQuery() throws BrowseException ;","/** 
 * This executes a query which will count the number of results for the parameters you set.
 * @return      the integer value of the number of results found
 * @throws BrowseException
 */
public int doCountQuery() throws BrowseException ;",0.983402489626556
52379,"/** 
 * Get the database ID of the container object.  The container object will be a Community or a Collection.
 * @return	the database id of the container, or -1 if none is set
 */
public int getContainerID();","/** 
 * Get the database ID of the container object.  The container object will be a Community or a Collection.
 * @return  the database id of the container, or -1 if none is set
 */
public int getContainerID();",0.992874109263658
52380,"/** 
 * Set whether the query should use an equals comparator when doing less than or  greater than comparisons.  That is, if true then comparisons will be made  using the equivalent of ""<="" and "">="", while if false it will use the  equivalent of ""<"" and "">""
 * @param equalsComparator	true to use, false to not.
 */
public void setEqualsComparator(boolean equalsComparator);","/** 
 * Set whether the query should use an equals comparator when doing less than or greater than comparisons.  That is, if true then comparisons will be made using the equivalent of ""<="" and "">="", while if false it will use the equivalent of ""<"" and "">""
 * @param equalsComparator  true to use, false to not.
 */
public void setEqualsComparator(boolean equalsComparator);",0.9919786096256684
52381,"/** 
 * Get the array of values that we will be selecting on.  The default is to select all of the values from a given table
 * @return	an array of values to select on
 */
public String[] getSelectValues();","/** 
 * Get the array of values that we will be selecting on.  The default is to select all of the values from a given table
 * @return  an array of values to select on
 */
public String[] getSelectValues();",0.9927360774818402
52382,"/** 
 * Get the offset from the first result from which to return results.  This  functionality is present for backwards compatibility, but is ill advised.  All normal browse operations can be completed without it.  The default is -1, which means do not offset.
 * @param offset
 */
public void setOffset(int offset);","/** 
 * Get the offset from the first result from which to return results.  This functionality is present for backwards compatibility, but is ill advised.  All normal browse operations can be completed without it.  The default is -1, which means do not offset.
 * @param offset
 */
public void setOffset(int offset);",0.9984202211690364
52383,"/** 
 * Set the database field which will be used to sort result sets on
 * @param orderField	the field by which results will be sorted
 */
public void setOrderField(String orderField);","/** 
 * Set the database field which will be used to sort result sets on
 * @param orderField    the field by which results will be sorted
 */
public void setOrderField(String orderField);",0.9865951742627346
52384,"/** 
 * Does the query use the equals comparator when doing less than or greater than comparisons.  @see setEqualsComparator Default value is true
 * @return	true if using it, false if not
 */
public boolean useEqualsComparator();","/** 
 * Does the query use the equals comparator when doing less than or greater than comparisons.  @see setEqualsComparator Default value is true
 * @return  true if using it, false if not
 */
public boolean useEqualsComparator();",0.9934924078091106
52385,"/** 
 * Get the name of the field in which the value to constrain results is contained
 * @return	the name of the field
 */
public String getFilterValueField();","/** 
 * Get the name of the field in which the value to constrain results is contained
 * @return  the name of the field
 */
public String getFilterValueField();",0.9906542056074766
52386,"/** 
 * Get the array of fields that we will be counting on.
 * @return	an array of fields to be counted over
 */
public String[] getCountValues();","/** 
 * Get the array of fields that we will be counting on.
 * @return  an array of fields to be counted over
 */
public String[] getCountValues();",0.9898305084745764
52387,"/** 
 * Get the value which we are constraining all our browse results to contain.
 * @return	the value to which to constrain results
 */
public String getFilterValue();","/** 
 * Get the value which we are constraining all our browse results to contain.
 * @return  the value to which to constrain results
 */
public String getFilterValue();",0.991150442477876
52388,"/** 
 * Set the value upon which to start the browse from.  The value supplied here will be the top result on the page of results
 * @param focusValue	the value in the focus field on which to start browsing
 */
public void setJumpToValue(String focusValue);","/** 
 * Set the value upon which to start the browse from.  The value supplied here will be the top result on the page of results
 * @param focusValue    the value in the focus field on which to start browsing
 */
public void setJumpToValue(String focusValue);",0.9903288201160542
52389,"/** 
 * Set whether the results should be sorted in ascending order (on the given sort column) or descending order.
 * @param ascending		true to ascend, false to descend
 */
public void setAscending(boolean ascending);","/** 
 * Set whether the results should be sorted in ascending order (on the given sort column) or descending order.
 * @param ascending     true to ascend, false to descend
 */
public void setAscending(boolean ascending);",0.9840546697038725
52390,"/** 
 * Set he name of the field in which the value to constrain results is  contained
 * @param valueField 	the name of the field
 */
public void setFilterValueField(String valueField);","/** 
 * Set he name of the field in which the value to constrain results is contained
 * @param valueField    the name of the field
 */
public void setFilterValueField(String valueField);",0.9865951742627346
52391,"/** 
 * Set the array of columns that we will be counting over.  In general, the wildcard (*) will suffice
 * @param fields	an array of fields to be counted over
 */
public void setCountValues(String[] fields);","/** 
 * Set the array of columns that we will be counting over.  In general, the wildcard (*) will suffice
 * @param fields    an array of fields to be counted over
 */
public void setCountValues(String[] fields);",0.9881796690307328
52392,"/** 
 * If we have specified a container id and container field, we must also specify a container table.  This is the name of the table that maps the item onto the distinct value.  Since we are in a container, this value will actually be the view which allows us to select only items which are within a given container
 * @param containerTable	the name of the container table mapping
 */
public void setContainerTable(String containerTable);","/** 
 * If we have specified a container id and container field, we must also specify a container table.  This is the name of the table that maps the item onto the distinct value.  Since we are in a container, this value will actually be the view which allows us to select only items which are within a given container
 * @param containerTable    the name of the container table mapping
 */
public void setContainerTable(String containerTable);",0.9943502824858758
52393,"/** 
 * This executes a query which returns a List object containing String values which represent the results of a single value browse (for example, the list of all subject headings).  This is most commonly used with a Distinct browse type.
 * @return	List of Strings representing the single value query results
 * @throws BrowseException
 */
public List doValueQuery() throws BrowseException ;","/** 
 * This executes a query which returns a List object containing String values which represent the results of a single value browse (for example, the list of all subject headings).  This is most commonly used with a Distinct browse type.
 * @return  List of Strings representing the single value query results
 * @throws BrowseException
 */
public List doValueQuery() throws BrowseException ;",0.9962073324905184
52394,"/** 
 * Is this a distinct value browse?
 * @return	true if distinct, false if not
 */
public boolean isDistinct();","/** 
 * Is this a distinct value browse?
 * @return  true if distinct, false if not
 */
public boolean isDistinct();",0.987012987012987
52395,"/** 
 * This executes a query which returns the value of the ""highest"" (max) value in the given table's column for the given item id.
 * @param column	the column to interrogate
 * @param table		the table to query
 * @param itemID	the item id
 * @return			String representing the max value in the given column
 * @throws BrowseException
 */
public String doMaxQuery(String column,String table,int itemID) throws BrowseException ;","/** 
 * This executes a query which returns the value of the ""highest"" (max) value in the given table's column for the given item id.
 * @param column    the column to interrogate
 * @param table     the table to query
 * @param itemID    the item id
 * @return          String representing the max value in the given column
 * @throws BrowseException
 */
public String doMaxQuery(String column,String table,int itemID) throws BrowseException ;",0.9655963302752294
52396,"/** 
 * Get the value at which the browse will start.  The value supplied here will be the top result on the page of results.
 * @return		the value to start browsing on
 */
public String getJumpToValue();","/** 
 * Get the value at which the browse will start.  The value supplied here will be the top result on the page of results.
 * @return      the value to start browsing on
 */
public String getJumpToValue();",0.9805825242718448
52397,"/** 
 * Set the array of values to select on.  This should be a list of the columns available in the target table, or the SQL wildcards.  The default is  single element array with the standard wildcard (*)
 * @param selectValues	the values to select on
 */
public void setSelectValues(String[] selectValues);","/** 
 * Set the array of values to select on.  This should be a list of the columns available in the target table, or the SQL wildcards.  The default is single element array with the standard wildcard (*)
 * @param selectValues  the values to select on
 */
public void setSelectValues(String[] selectValues);",0.9935064935064936
52398,"/** 
 * Get the database field which will be used to do the sorting of result sets on.
 * @return		the field by which results will be sorted
 */
public String getOrderField();","/** 
 * Get the database field which will be used to do the sorting of result sets on.
 * @return      the field by which results will be sorted
 */
public String getOrderField();",0.9774011299435028
52399,"/** 
 * get the name of the table that we are querying
 * @return	the name of the table
 */
public String getTable();","/** 
 * get the name of the table that we are querying
 * @return  the name of the table
 */
public String getTable();",0.9872340425531916
52400,"/** 
 * Set the limit for how many results should be returned.  This is generally for use in paging or limiting the number of items be be displayed.  The default is -1, meaning unlimited results.  Note that if the number of results of the query is less than this number, the size of the result set will be smaller than this limit.
 * @param limit		the maximum number of results to return.
 */
public void setLimit(int limit);","/** 
 * Set the limit for how many results should be returned.  This is generally for use in paging or limiting the number of items be be displayed.  The default is -1, meaning unlimited results.  Note that if the number of results of the query is less than this number, the size of the result set will be smaller than this limit.
 * @param limit     the maximum number of results to return.
 */
public void setLimit(int limit);",0.9917936694021102
52401,"/** 
 * Set the name of the table to query
 * @param table		the name of the table
 */
public void setTable(String table);","/** 
 * Set the name of the table to query
 * @param table     the name of the table
 */
public void setTable(String table);",0.9714285714285714
52402,"/** 
 * Get the name of the container table that is being used to map items to distinct values when in a container constrained browse
 * @return	the name of the table
 */
public String getContainerTable();","/** 
 * Get the name of the container table that is being used to map items to distinct values when in a container constrained browse
 * @return  the name of the table
 */
public String getContainerTable();",0.9927007299270072
52403,"/** 
 * set the name of the field in which to look for the container id.
 * @param containerIDField	the name of the container id field.  For example ""collection_id"" or ""community_id""
 */
public void setContainerIDField(String containerIDField);","/** 
 * set the name of the field in which to look for the container id.
 * @param containerIDField  the name of the container id field.For example ""collection_id"" or ""community_id""
 */
public void setContainerIDField(String containerIDField);",0.9897330595482546
52404,"/** 
 * Set whether this is a distinct value browse or not
 * @param bool	true if distinct value, false if not
 */
public void setDistinct(boolean bool);","/** 
 * Set whether this is a distinct value browse or not
 * @param bool  true if distinct value, false if not
 */
public void setDistinct(boolean bool);",0.990228013029316
52405,"/** 
 * Get the field in which we will match a focus value from which to start the browse.  This will either be the ""sort_value"" field or one of the additional sort fields defined by configuration
 * @return	the name of the focus field
 */
public String getJumpToField();","/** 
 * Get the field in which we will match a focus value from which to start the browse.  This will either be the ""sort_value"" field or one of the additional sort fields defined by configuration
 * @return  the name of the focus field
 */
public String getJumpToField();",0.994475138121547
52406,"/** 
 * Is the sort order ascending or descending? Default value is true
 * @return	true for ascending, false for descending
 */
public boolean isAscending();","/** 
 * Is the sort order ascending or descending? Default value is true
 * @return  true for ascending, false for descending
 */
public boolean isAscending();",0.9905362776025236
52407,"/** 
 * Set the value to which all our browse results should be constrained.  For example, if you are listing all of the publications by a single author your value would be the author name.
 * @param value	the value to which to constrain results
 */
public void setFilterValue(String value);","/** 
 * Set the value to which all our browse results should be constrained.  For example, if you are listing all of the publications by a single author your value would be the author name.
 * @param value the value to which to constrain results
 */
public void setFilterValue(String value);",0.9965635738831616
52408,"/** 
 * assemble a WHERE clause with the given constraints.  This will return something of the form: <code> WHERE [focus clause] [AND] [value clause] [AND] [container constraint] </code> The container constraint is described in one of either getFullConstraint or  getDistinctConstraint, and the form of that section of the query can be found in their documentation. If either of focusClause or valueClause is null, they will be duly omitted from the WHERE clause.
 */
private void buildWhereClauseDistinctConstraints(StringBuffer queryBuf,List params){
  if (containerIDField != null && containerID != -1 && containerTable != null) {
    buildWhereClauseOpInsert(queryBuf);
    queryBuf.append(""String_Node_Str"");
    buildFocusedSelectTables(queryBuf);
    queryBuf.append(""String_Node_Str"");
    buildFocusedSelectClauses(queryBuf,params);
    queryBuf.append(""String_Node_Str"" + table + ""String_Node_Str"");
  }
}","/** 
 * assemble a WHERE clause with the given constraints.  This will return something of the form: <code> WHERE [focus clause] [AND] [value clause] [AND] [container constraint] </code> The container constraint is described in one of either getFullConstraint or getDistinctConstraint, and the form of that section of the query can be found in their documentation. If either of focusClause or valueClause is null, they will be duly omitted from the WHERE clause.
 */
private void buildWhereClauseDistinctConstraints(StringBuffer queryBuf,List params){
  if (containerIDField != null && containerID != -1 && containerTable != null) {
    buildWhereClauseOpInsert(queryBuf);
    queryBuf.append(""String_Node_Str"").append(table).append(""String_Node_Str"");
  }
}",0.8918111177525403
52409,"/** 
 * assemble a WHERE clause with the given constraints.  This will return something of the form: <code> WHERE [focus clause] [AND] [value clause] [AND] [container constraint] </code> The container constraint is described in one of either getFullConstraint or  getDistinctConstraint, and the form of that section of the query can be found in their documentation. If either of focusClause or valueClause is null, they will be duly omitted from the WHERE clause.
 */
private void buildWhereClauseFullConstraints(StringBuffer queryBuf,List params){
  if (tableDis == null || tableMap == null) {
    if (containerIDField != null && containerID != -1) {
      buildWhereClauseOpInsert(queryBuf);
      queryBuf.append(""String_Node_Str"").append(table).append(""String_Node_Str"");
    }
  }
}","/** 
 * assemble a WHERE clause with the given constraints.  This will return something of the form: <code> WHERE [focus clause] [AND] [value clause] [AND] [container constraint] </code> The container constraint is described in one of either getFullConstraint or getDistinctConstraint, and the form of that section of the query can be found in their documentation. If either of focusClause or valueClause is null, they will be duly omitted from the WHERE clause.
 */
private void buildWhereClauseFullConstraints(StringBuffer queryBuf,List params){
  if (tableDis == null || tableMap == null) {
    if (containerIDField != null && containerID != -1) {
      buildWhereClauseOpInsert(queryBuf);
      queryBuf.append(""String_Node_Str"").append(table).append(""String_Node_Str"");
    }
  }
}",0.9993642720915448
52410,"/** 
 * Prepare the select clause using the pre-prepared arguments.  This will produce something of the form: <code> SELECT [arguments] FROM [table] </code>
 * @param queryBuf  the string value obtained from distinctClause, countClause or selectValues
 * @return  the SELECT part of the query
 */
private void buildSelectStatementDistinct(StringBuffer queryBuf,List params) throws BrowseException {
  if (queryBuf.length() == 0) {
    throw new BrowseException(""String_Node_Str"");
  }
  if (table == null || ""String_Node_Str"".equals(table)) {
    throw new BrowseException(""String_Node_Str"");
  }
  queryBuf.insert(0,""String_Node_Str"");
  queryBuf.append(""String_Node_Str"");
  queryBuf.append(table);
  queryBuf.append(""String_Node_Str"");
}","/** 
 * Prepare the select clause using the pre-prepared arguments.  This will produce something of the form: <code> SELECT [arguments] FROM [table] </code>
 * @param queryBuf  the string value obtained from distinctClause, countClause or selectValues
 * @return  the SELECT part of the query
 */
private void buildSelectStatementDistinct(StringBuffer queryBuf,List params) throws BrowseException {
  if (queryBuf.length() == 0) {
    throw new BrowseException(""String_Node_Str"");
  }
  if (table == null || ""String_Node_Str"".equals(table)) {
    throw new BrowseException(""String_Node_Str"");
  }
  queryBuf.insert(0,""String_Node_Str"");
  queryBuf.append(""String_Node_Str"");
  queryBuf.append(table);
  if (containerTable != null && tableMap != null) {
    queryBuf.append(""String_Node_Str"").append(tableMap).append(""String_Node_Str"");
    queryBuf.append(""String_Node_Str"");
    buildFocusedSelectTables(queryBuf);
    queryBuf.append(""String_Node_Str"");
    buildFocusedSelectClauses(queryBuf,params);
    queryBuf.append(""String_Node_Str"");
  }
  queryBuf.append(""String_Node_Str"");
}",0.8078817733990148
52411,"/** 
 * Build the query that will be used for a full browse.
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatement(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseFilterValue(queryBuf,params);
  buildWhereClauseFullConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimit(queryBuf,params);
  buildRowOffset(queryBuf,params);
  return queryBuf.toString();
}","/** 
 * Build the query that will be used for a full browse.
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatement(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseFilterValue(queryBuf,params);
  buildWhereClauseFullConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimitAndOffset(queryBuf,params);
  return queryBuf.toString();
}",0.969187675070028
52412,"/** 
 * Build the query that will be used for a distinct select.  This incorporates only the parts of the parameters that are actually useful for this type of browse
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildDistinctQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatementDistinct(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseDistinctConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimit(queryBuf,params);
  return queryBuf.toString();
}","/** 
 * Build the query that will be used for a distinct select.  This incorporates only the parts of the parameters that are actually useful for this type of browse
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildDistinctQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatementDistinct(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseDistinctConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimitAndOffset(queryBuf,params);
  return queryBuf.toString();
}",0.9941822882999354
52413,"/** 
 * Build the query that will be used for a full browse.
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatement(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseFilterValue(queryBuf,params);
  buildWhereClauseFullConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimit(queryBuf,params);
  buildRowOffset(queryBuf,params);
  return queryBuf.toString();
}","/** 
 * Build the query that will be used for a full browse.
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatement(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseFilterValue(queryBuf,params);
  buildWhereClauseFullConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimitAndOffset(queryBuf,params);
  return queryBuf.toString();
}",0.969187675070028
52414,"/** 
 * Required constructor for use by BrowseDAOFactory 
 * @param context   DSpace context
 */
public BrowseDAOPostgres(Context context) throws BrowseException {
  this.context=context;
  utils=BrowseDAOFactory.getUtils(context);
}","/** 
 * Required constructor for use by BrowseDAOFactory
 * @param context   DSpace context
 */
public BrowseDAOPostgres(Context context) throws BrowseException {
  this.context=context;
  utils=BrowseDAOFactory.getUtils(context);
}",0.9978494623655914
52415,"/** 
 * Build the query that will be used for a distinct select.  This incorporates only the parts of the parameters that are actually useful for this type of browse
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildDistinctQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatementDistinct(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseDistinctConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimit(queryBuf,params);
  return queryBuf.toString();
}","/** 
 * Build the query that will be used for a distinct select.  This incorporates only the parts of the parameters that are actually useful for this type of browse
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildDistinctQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatementDistinct(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseDistinctConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimitAndOffset(queryBuf,params);
  return queryBuf.toString();
}",0.9941822882999354
52416,"/** 
 * Return a normalized focus value. If there is no normalization that can be performed, return the focus value that is passed in.
 * @param value a focus value to normalize
 * @return  the normalized focus value
 * @throws BrowseException
 */
private String normalizeJumpToValue(String value) throws BrowseException {
  if (scope.hasJumpToValue()) {
    return OrderFormat.makeSortString(scope.getJumpToValue(),scope.setJumpToValueLang(),scope.getBrowseIndex().getDataType());
  }
 else   if (scope.hasStartsWith()) {
    return OrderFormat.makeSortString(scope.getStartsWith(),null,scope.getBrowseIndex().getDataType());
  }
  return value;
}","/** 
 * Return a normalized focus value. If there is no normalization that can be performed, return the focus value that is passed in.
 * @param value a focus value to normalize
 * @return  the normalized focus value
 * @throws BrowseException
 */
private String normalizeJumpToValue(String value) throws BrowseException {
  if (scope.hasJumpToValue()) {
    return OrderFormat.makeSortString(scope.getJumpToValue(),scope.getJumpToValueLang(),scope.getBrowseIndex().getDataType());
  }
 else   if (scope.hasStartsWith()) {
    return OrderFormat.makeSortString(scope.getStartsWith(),null,scope.getBrowseIndex().getDataType());
  }
  return value;
}",0.9984567901234568
52417,"/** 
 * Get the database id of the item at the top of what will be the previous page of results.  This is so that a ""back"" button can be generated by the User Interface when paging through results.  The callback argument is there so that if the caller wishes the actual results from the previous page can also be returned (this is useful, for example, if you are on the very last page of results, and need some previous results to pad out the full number of results per page).  If the callback is null, then no results are kept
 * @param callback	A List object for holding BrowseItem objects indexed numerically in the correct order
 * @return			the database id of the top of the previous page
 * @throws SQLException
 * @throws BrowseException
 */
private int getPreviousPageID(List callback) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  boolean capture=false;
  if (callback != null) {
    capture=true;
  }
  boolean isAscending=dao.isAscending();
  dao.setAscending(!isAscending);
  boolean useEquals=dao.useEqualsComparator();
  dao.setEqualsComparator(false);
  int resultLimit=dao.getLimit();
  int limit=scope.getResultsPerPage();
  if (capture) {
    limit*=2;
  }
  dao.setLimit(limit);
  List results=dao.doQuery();
  dao.setAscending(isAscending);
  dao.setEqualsComparator(useEquals);
  dao.setLimit(resultLimit);
  Iterator itr=results.iterator();
  int i=0;
  BrowseItem prev=null;
  while (itr.hasNext()) {
    BrowseItem browseItem=(BrowseItem)itr.next();
    prev=browseItem;
    if (capture && i < scope.getResultsPerPage()) {
      callback.add(0,browseItem);
      i++;
    }
  }
  if (prev != null) {
    return prev.getID();
  }
 else {
    return -1;
  }
}","/** 
 * Get the database id of the item at the top of what will be the previous page of results.  This is so that a ""back"" button can be generated by the User Interface when paging through results.  The callback argument is there so that if the caller wishes the actual results from the previous page can also be returned (this is useful, for example, if you are on the very last page of results, and need some previous results to pad out the full number of results per page).  If the callback is null, then no results are kept
 * @param callback  A List object for holding BrowseItem objects indexed numerically in the correct order
 * @return          the database id of the top of the previous page
 * @throws SQLException
 * @throws BrowseException
 */
private int getPreviousPageID(List callback) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  boolean capture=false;
  if (callback != null) {
    capture=true;
  }
  boolean isAscending=dao.isAscending();
  dao.setAscending(!isAscending);
  boolean useEquals=dao.useEqualsComparator();
  dao.setEqualsComparator(false);
  int resultLimit=dao.getLimit();
  int limit=scope.getResultsPerPage();
  if (capture) {
    limit*=2;
  }
  dao.setLimit(limit);
  List results=dao.doQuery();
  dao.setAscending(isAscending);
  dao.setEqualsComparator(useEquals);
  dao.setLimit(resultLimit);
  Iterator itr=results.iterator();
  int i=0;
  BrowseItem prev=null;
  while (itr.hasNext()) {
    BrowseItem browseItem=(BrowseItem)itr.next();
    prev=browseItem;
    if (capture && i < scope.getResultsPerPage()) {
      callback.add(0,browseItem);
      i++;
    }
  }
  if (prev != null) {
    return prev.getID();
  }
 else {
    return -1;
  }
}",0.9954545454545456
52418,"/** 
 * Get the value (for single value browses) for the result that appears at the top of the previous page, for when the User Interface is performing result set paging. The callback argument allows for this method to populate the List with the results obtained from the query, which can be useful when, for example, reaching the final browse page and needing additional results to pad up to the number of results per page
 * @param callback		A List object for holding String objects indexed numerically in the correct order
 * @return				the value of the top of the previous page
 * @throws SQLException
 * @throws BrowseException
 */
private String getPreviousPageValue(List callback) throws SQLException, BrowseException {
  boolean capture=false;
  if (callback != null) {
    capture=true;
  }
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + capture));
  boolean isAscending=dao.isAscending();
  dao.setAscending(!isAscending);
  boolean useEquals=dao.useEqualsComparator();
  dao.setEqualsComparator(false);
  int resultLimit=dao.getLimit();
  int limit=scope.getResultsPerPage();
  if (capture) {
    limit*=2;
  }
  dao.setLimit(limit);
  List results=dao.doValueQuery();
  dao.setAscending(isAscending);
  dao.setEqualsComparator(useEquals);
  dao.setLimit(resultLimit);
  Iterator itr=results.iterator();
  int i=0;
  String prev=null;
  while (itr.hasNext()) {
    String value=(String)itr.next();
    prev=value;
    if (capture && i < scope.getResultsPerPage()) {
      callback.add(0,value);
      i++;
    }
  }
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + prev));
  return prev;
}","/** 
 * Get the value (for single value browses) for the result that appears at the top of the previous page, for when the User Interface is performing result set paging. The callback argument allows for this method to populate the List with the results obtained from the query, which can be useful when, for example, reaching the final browse page and needing additional results to pad up to the number of results per page
 * @param callback      A List object for holding String objects indexed numerically in the correct order
 * @return              the value of the top of the previous page
 * @throws SQLException
 * @throws BrowseException
 */
private String getPreviousPageValue(List callback) throws SQLException, BrowseException {
  boolean capture=false;
  if (callback != null) {
    capture=true;
  }
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + capture));
  boolean isAscending=dao.isAscending();
  dao.setAscending(!isAscending);
  boolean useEquals=dao.useEqualsComparator();
  dao.setEqualsComparator(false);
  int resultLimit=dao.getLimit();
  int limit=scope.getResultsPerPage();
  if (capture) {
    limit*=2;
  }
  dao.setLimit(limit);
  List results=dao.doValueQuery();
  dao.setAscending(isAscending);
  dao.setEqualsComparator(useEquals);
  dao.setLimit(resultLimit);
  Iterator itr=results.iterator();
  int i=0;
  String prev=null;
  while (itr.hasNext()) {
    String value=(String)itr.next();
    prev=value;
    if (capture && i < scope.getResultsPerPage()) {
      callback.add(0,value);
      i++;
    }
  }
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + prev));
  return prev;
}",0.9922109047333731
52419,"/** 
 * Get the position of the current start point of the browse in the field of total objects relevant to this browse.  This is integrally related to how results are presented in pages to the User Interface.  The argument tells us whether this is a distinct browse or not, as this has an impact on how results are calculated
 * @param distinct		is this a distinct browse
 * @return				the offset of the first result from the start of the set
 * @throws SQLException
 * @throws BrowseException
 */
private int getPosition(boolean distinct) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + distinct));
  if (dao.getJumpToValue() == null) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    return 0;
  }
  String tableName=browseIndex.getTableName(distinct,scope.inCommunity(),scope.inCollection());
  String[] select={""String_Node_Str""};
  dao.setCountValues(select);
  boolean isAscending=dao.isAscending();
  boolean useEquals=dao.useEqualsComparator();
  String orderField=dao.getOrderField();
  int limit=dao.getLimit();
  int offset=dao.getOffset();
  dao.setAscending(!isAscending);
  dao.setEqualsComparator(false);
  dao.setOrderField(null);
  dao.setLimit(-1);
  dao.setOffset(-1);
  int count=dao.doCountQuery();
  dao.setAscending(isAscending);
  dao.setEqualsComparator(useEquals);
  dao.setOrderField(orderField);
  dao.setLimit(limit);
  dao.setOffset(offset);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + count));
  return count;
}","/** 
 * Get the position of the current start point of the browse in the field of total objects relevant to this browse.  This is integrally related to how results are presented in pages to the User Interface.  The argument tells us whether this is a distinct browse or not, as this has an impact on how results are calculated
 * @param distinct      is this a distinct browse
 * @return              the offset of the first result from the start of the set
 * @throws SQLException
 * @throws BrowseException
 */
private int getPosition(boolean distinct) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + distinct));
  if (dao.getJumpToValue() == null) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    return 0;
  }
  String tableName=browseIndex.getTableName(distinct,scope.inCommunity(),scope.inCollection());
  String[] select={""String_Node_Str""};
  dao.setCountValues(select);
  boolean isAscending=dao.isAscending();
  boolean useEquals=dao.useEqualsComparator();
  String orderField=dao.getOrderField();
  int limit=dao.getLimit();
  int offset=dao.getOffset();
  dao.setAscending(!isAscending);
  dao.setEqualsComparator(false);
  dao.setOrderField(null);
  dao.setLimit(-1);
  dao.setOffset(-1);
  int count=dao.doCountQuery();
  dao.setAscending(isAscending);
  dao.setEqualsComparator(useEquals);
  dao.setOrderField(orderField);
  dao.setLimit(limit);
  dao.setOffset(offset);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + count));
  return count;
}",0.9918392969240428
52420,"/** 
 * Browse the archive by single values (such as the name of an author).  This produces a BrowseInfo object that contains Strings as the results of  the browse
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByValue(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bs.getJumpToValue()));
  try {
    dao.setTable(browseIndex.getTableName(true,scope.inCommunity(),scope.inCollection()));
    dao.setDistinct(true);
    dao.setAscending(scope.isAscending());
    dao.setJumpToField(""String_Node_Str"");
    String focusValue=null;
    String rawFocusValue=null;
    if (scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith() && browseIndex.isDate()) {
        focusValue=focusValue + ""String_Node_Str"";
      }
      dao.setJumpToValue(focusValue);
    }
    if (scope.inCollection() || scope.inCommunity()) {
      dao.setFilterMappingTables(null,browseIndex.getTableName(false,false,false,true));
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    dao.setOrderField(""String_Node_Str"");
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doValueQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    String next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(String)results.get(lastIndex);
      results.remove(lastIndex);
    }
    String prev=null;
    if (scope.hasJumpToValue() || scope.hasStartsWith()) {
      if (showLast) {
        prev=getPreviousPageValue(results);
      }
 else {
        prev=getPreviousPageValue(null);
      }
    }
    int offset=0;
    int total=getTotalResults(true);
    int position=getPosition(true);
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextValue(next);
    }
    if (prev != null) {
      browseInfo.setPrevValue(prev);
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setFocus(rawFocusValue);
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by single values (such as the name of an author).  This produces a BrowseInfo object that contains Strings as the results of the browse
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByValue(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bs.getJumpToValue()));
  try {
    dao.setTable(browseIndex.getDistinctTableName());
    dao.setDistinct(true);
    dao.setAscending(scope.isAscending());
    dao.setOrderField(""String_Node_Str"");
    if (scope.inCollection() || scope.inCommunity()) {
      dao.setFilterMappingTables(null,browseIndex.getMapTableName());
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    dao.setJumpToField(""String_Node_Str"");
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && scope.hasJumpToValue() || scope.hasStartsWith()) {
      String focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith() && browseIndex.isDate()) {
        focusValue=focusValue + ""String_Node_Str"";
      }
      offset=getOffsetForDistinctValue(focusValue);
    }
    dao.setOffset(offset);
    dao.setLimit(scope.getResultsPerPage());
    List results=dao.doValueQuery();
    int total=getTotalResults(true);
    if (results.size() == 0) {
      offset=total - scope.getResultsPerPage();
      if (offset < 0)       offset=0;
      dao.setOffset(offset);
      results=dao.doQuery();
      total=getTotalResults();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setFocus(rawFocusValue);
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.6241044419678395
52421,"/** 
 * Create a new instance of the Browse engine, using the given DSpace Context object.  This will automatically assign a Data Access Object for the Browse Engine, based on the dspace.cfg setting for db.name
 * @param context		the DSpace context
 * @throws BrowseException
 */
public BrowseEngine(Context context) throws BrowseException {
  this.context=context;
  dao=BrowseDAOFactory.getInstance(context);
}","/** 
 * Create a new instance of the Browse engine, using the given DSpace Context object.  This will automatically assign a Data Access Object for the Browse Engine, based on the dspace.cfg setting for db.name
 * @param context       the DSpace context
 * @throws BrowseException
 */
public BrowseEngine(Context context) throws BrowseException {
  this.context=context;
  dao=BrowseDAOFactory.getInstance(context);
}",0.9891435464414958
52422,"/** 
 * Get the total number of results.  The argument determines whether this is a distinct browse or not as this has an impact on how results are counted
 * @param distinct	is this a distinct browse or not
 * @return			the total number of results available in this type of browse
 * @throws SQLException
 * @throws BrowseException
 */
private int getTotalResults(boolean distinct) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + distinct));
  String tableName=browseIndex.getTableName(distinct,scope.inCommunity(),scope.inCollection());
  dao.setDistinct(distinct);
  String[] select={""String_Node_Str""};
  dao.setCountValues(select);
  String focusField=dao.getJumpToField();
  String focusValue=dao.getJumpToValue();
  String orderField=dao.getOrderField();
  int limit=dao.getLimit();
  int offset=dao.getOffset();
  dao.setJumpToField(null);
  dao.setJumpToValue(null);
  dao.setOrderField(null);
  dao.setLimit(-1);
  dao.setOffset(-1);
  int count=dao.doCountQuery();
  dao.setJumpToField(focusField);
  dao.setJumpToValue(focusValue);
  dao.setOrderField(orderField);
  dao.setLimit(limit);
  dao.setOffset(offset);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + count));
  return count;
}","/** 
 * Get the total number of results.  The argument determines whether this is a distinct browse or not as this has an impact on how results are counted
 * @param distinct  is this a distinct browse or not
 * @return          the total number of results available in this type of browse
 * @throws SQLException
 * @throws BrowseException
 */
private int getTotalResults(boolean distinct) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + distinct));
  dao.setDistinct(distinct);
  String[] select={""String_Node_Str""};
  dao.setCountValues(select);
  String focusField=dao.getJumpToField();
  String focusValue=dao.getJumpToValue();
  String orderField=dao.getOrderField();
  int limit=dao.getLimit();
  int offset=dao.getOffset();
  dao.setJumpToField(null);
  dao.setJumpToValue(null);
  dao.setOrderField(null);
  dao.setLimit(-1);
  dao.setOffset(-1);
  int count=dao.doCountQuery();
  dao.setJumpToField(focusField);
  dao.setJumpToValue(focusValue);
  dao.setOrderField(orderField);
  dao.setLimit(limit);
  dao.setOffset(offset);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + count));
  return count;
}",0.9554140127388536
52423,"/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName());
    dao.setAscending(scope.isAscending());
    String focusValue=null;
    String rawFocusValue=null;
    String focusField=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      dao.setJumpToField(focusField);
      dao.setJumpToValue(focusValue);
    }
    String value=null;
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
      dao.setFilterMappingTables(browseIndex.getTableName(false,false,true,false),browseIndex.getTableName(false,false,false,true));
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    String orderBy=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    BrowseItem next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(BrowseItem)results.get(lastIndex);
      results.remove(lastIndex);
    }
    BrowseItem prev=null;
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      int prevID=-1;
      if (showLast) {
        prevID=getPreviousPageID(results);
      }
 else {
        prevID=getPreviousPageID(null);
      }
      if (prevID != -1) {
        if (bs.getBrowseIndex() == BrowseIndex.getWithdrawnBrowseIndex())         prev=new BrowseItem(context,prevID,false,true);
 else         prev=new BrowseItem(context,prevID,true,false);
      }
    }
    int offset=0;
    int total=getTotalResults();
    int position=-1;
    if (total > 0) {
      if (showLast) {
        position=total - scope.getResultsPerPage();
        if (position < 0)         position=0;
      }
 else {
        position=getPosition(false);
      }
    }
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextItem(next.getID());
    }
    if (prev != null) {
      browseInfo.setPrevItem(prev.getID());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName());
    dao.setAscending(scope.isAscending());
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      String value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
      dao.setFilterMappingTables(browseIndex.getDistinctTableName(),browseIndex.getMapTableName());
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith())) {
      rawFocusValue=getJumpToValue();
      String focusValue=normalizeJumpToValue(rawFocusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      String focusField=browseIndex.getSortField(scope.isSecondLevel());
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      offset=getOffsetForValue(focusValue);
    }
    dao.setOffset(offset);
    String orderBy=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage());
    List results=dao.doQuery();
    int total=getTotalResults();
    if (results.size() == 0) {
      offset=total - scope.getResultsPerPage();
      if (offset < 0)       offset=0;
      dao.setOffset(offset);
      results=dao.doQuery();
      total=getTotalResults();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.4271217712177121
52424,"/** 
 * Return the focus value.
 * @return	the focus value to use
 * @throws BrowseException
 */
private String getJumpToValue() throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  if (scope.hasJumpToValue()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getJumpToValue()));
    return scope.getJumpToValue();
  }
  if (scope.hasStartsWith()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getStartsWith()));
    return scope.getStartsWith();
  }
  int id=scope.getJumpToItem();
  String tableName=browseIndex.getTableName();
  SortOption so=scope.getSortOption();
  if (so == null || so.getNumber() == 0) {
    if (browseIndex.getSortOption() != null)     so=browseIndex.getSortOption();
  }
  String col=""String_Node_Str"";
  if (so.getNumber() > 0) {
    col=""String_Node_Str"" + Integer.toString(so.getNumber());
  }
  String max=dao.doMaxQuery(col,tableName,id);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + max));
  return max;
}","/** 
 * Return the focus value.
 * @return  the focus value to use
 * @throws BrowseException
 */
private String getJumpToValue() throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  if (scope.hasJumpToValue()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getJumpToValue()));
    return scope.getJumpToValue();
  }
  if (scope.hasStartsWith()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getStartsWith()));
    return scope.getStartsWith();
  }
  int id=scope.getJumpToItem();
  String tableName=browseIndex.getTableName();
  SortOption so=scope.getSortOption();
  if (so == null || so.getNumber() == 0) {
    if (browseIndex.getSortOption() != null)     so=browseIndex.getSortOption();
  }
  String col=""String_Node_Str"";
  if (so.getNumber() > 0) {
    col=""String_Node_Str"" + Integer.toString(so.getNumber());
  }
  String max=dao.doMaxQuery(col,tableName,id);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + max));
  return max;
}",0.9986455981941308
52425,"/** 
 * Perform a limited browse, which only returns the results requested,  without any extraneous information.  To perform a full browse, use BrowseEngine.browse() above.  This supports Item browse only, and does not currently support focus or values.  This method is used, for example, to generate the Recently Submitted Items results.
 * @param bs	the scope of the browse
 * @return		the results of the browse
 */
public BrowseInfo browseMini(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  dao.setTable(browseIndex.getTableName());
  dao.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    if (scope.inCollection()) {
      Collection col=(Collection)scope.getBrowseContainer();
      dao.setContainerTable(""String_Node_Str"");
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(col.getID());
    }
 else     if (scope.inCommunity()) {
      Community com=(Community)scope.getBrowseContainer();
      dao.setContainerTable(""String_Node_Str"");
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(com.getID());
    }
  }
  dao.setLimit(scope.getResultsPerPage());
  String orderBy=browseIndex.getSortField(scope.isSecondLevel());
  if (scope.getSortBy() > 0) {
    orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
  }
  dao.setOrderField(orderBy);
  List results=dao.doQuery();
  BrowseInfo browseInfo=new BrowseInfo(results,0,scope.getResultsPerPage(),0);
  browseInfo.setBrowseIndex(browseIndex);
  browseInfo.setSortOption(scope.getSortOption());
  browseInfo.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    browseInfo.setBrowseContainer(scope.getBrowseContainer());
  }
  browseInfo.setResultsPerPage(scope.getResultsPerPage());
  browseInfo.setEtAl(scope.getEtAl());
  return browseInfo;
}","/** 
 * Perform a limited browse, which only returns the results requested, without any extraneous information.  To perform a full browse, use BrowseEngine.browse() above.  This supports Item browse only, and does not currently support focus or values.  This method is used, for example, to generate the Recently Submitted Items results.
 * @param bs    the scope of the browse
 * @return      the results of the browse
 */
public BrowseInfo browseMini(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  dao.setTable(browseIndex.getTableName());
  dao.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    if (scope.inCollection()) {
      Collection col=(Collection)scope.getBrowseContainer();
      dao.setContainerTable(""String_Node_Str"");
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(col.getID());
    }
 else     if (scope.inCommunity()) {
      Community com=(Community)scope.getBrowseContainer();
      dao.setContainerTable(""String_Node_Str"");
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(com.getID());
    }
  }
  dao.setOffset(scope.getOffset());
  dao.setLimit(scope.getResultsPerPage());
  String orderBy=browseIndex.getSortField(scope.isSecondLevel());
  if (scope.getSortBy() > 0) {
    orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
  }
  dao.setOrderField(orderBy);
  List results=dao.doQuery();
  BrowseInfo browseInfo=new BrowseInfo(results,0,scope.getResultsPerPage(),0);
  browseInfo.setBrowseIndex(browseIndex);
  browseInfo.setSortOption(scope.getSortOption());
  browseInfo.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    browseInfo.setBrowseContainer(scope.getBrowseContainer());
  }
  browseInfo.setResultsPerPage(scope.getResultsPerPage());
  browseInfo.setEtAl(scope.getEtAl());
  return browseInfo;
}",0.9874623871614844
52426,"/** 
 * Perform a standard browse, which will return a BrowseInfo object that represents the results for the current page, the total number of results, the range, and information to construct previous and next links on any web page
 * @param bs	the scope of the browse
 * @return		the results of the browse
 * @throws BrowseException
 */
public BrowseInfo browse(BrowserScope bs) throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  if (browseIndex.isMetadataIndex() && !scope.isSecondLevel()) {
    return browseByValue(scope);
  }
 else {
    return browseByItem(scope);
  }
}","/** 
 * Perform a standard browse, which will return a BrowseInfo object that represents the results for the current page, the total number of results, the range, and information to construct previous and next links on any web page
 * @param bs    the scope of the browse
 * @return      the results of the browse
 * @throws BrowseException
 */
public BrowseInfo browse(BrowserScope bs) throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  if (browseIndex.isMetadataIndex() && !scope.isSecondLevel()) {
    return browseByValue(scope);
  }
 else {
    return browseByItem(scope);
  }
}",0.9905865314989138
52427,"/** 
 * Are there results prior to these that haven't been returned here?
 * @return	true if previous page, false if not
 */
public boolean hasPrevPage(){
  if (!""String_Node_Str"".equals(prevValue) && (prevValue != null)) {
    return true;
  }
  if (prevItem != -1) {
    return true;
  }
  return false;
}","/** 
 * Are there results prior to these that haven't been returned here?
 * @return	true if previous page, false if not
 */
public boolean hasPrevPage(){
  if (offset > 0) {
    return true;
  }
  return false;
}",0.7384615384615385
52428,"/** 
 * Does this browse have an item focus (as opposed to one of: no focus,  a value focus)
 * @return	true if item focus, false if not
 */
public boolean hasItemFocus(){
  if (focusItem == -1) {
    return false;
  }
  return true;
}","/** 
 * Does this browse have an item focus (as opposed to one of: no focus, a value focus)
 * @return	true if item focus, false if not
 */
public boolean hasItemFocus(){
  if (focusItem == -1) {
    return false;
  }
  return true;
}",0.997867803837953
52429,"/** 
 * Are there further results for the browse that haven't been returned yet?
 * @return	true if next page, false if not
 */
public boolean hasNextPage(){
  if (!""String_Node_Str"".equals(nextValue) && (nextValue != null)) {
    return true;
  }
  if (nextItem != -1) {
    return true;
  }
  return false;
}","/** 
 * Are there further results for the browse that haven't been returned yet?
 * @return	true if next page, false if not
 */
public boolean hasNextPage(){
  if (nextOffset > -1) {
    return true;
  }
  return false;
}",0.8022598870056498
52430,"/** 
 * Utility method for obtaining a string representation of the browse.  This is useful only for debug
 */
public String toString(){
  try {
    StringBuffer sb=new StringBuffer();
    String from=Integer.toString(overallPosition + 1);
    String to=Integer.toString(overallPosition + results.size());
    String of=Integer.toString(total);
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"" + from + ""String_Node_Str""+ to+ ""String_Node_Str""+ of+ ""String_Node_Str"");
    sb.append(""String_Node_Str"" + browseIndex.getName() + ""String_Node_Str""+ browseIndex.getDataType()+ ""String_Node_Str""+ browseIndex.getDisplayType()+ ""String_Node_Str"");
    sb.append(""String_Node_Str"");
    String container=""String_Node_Str"";
    DSpaceObject theContainer=null;
    if (inCollection()) {
      container=""String_Node_Str"";
      theContainer=this.collection;
    }
 else     if (inCommunity()) {
      container=""String_Node_Str"";
      theContainer=this.community;
    }
    String containerID=""String_Node_Str"";
    if (theContainer != null) {
      containerID=Integer.toString(theContainer.getID()) + ""String_Node_Str"" + theContainer.getHandle()+ ""String_Node_Str"";
    }
    sb.append(""String_Node_Str"" + container + ""String_Node_Str""+ containerID);
    sb.append(""String_Node_Str"");
    ItemListConfig config=new ItemListConfig();
    if (browseIndex.isItemIndex()) {
      sb.append(""String_Node_Str"" + Integer.toString(config.numCols()) + ""String_Node_Str"");
      for (int k=1; k <= config.numCols(); k++) {
        if (k > 1) {
          sb.append(""String_Node_Str"");
        }
        String[] meta=config.getMetadata(k);
        sb.append(meta[0] + ""String_Node_Str"" + meta[1]+ ""String_Node_Str""+ meta[2]);
      }
      if (value != null) {
        sb.append(""String_Node_Str"" + value);
      }
      if (isStartsWith()) {
        sb.append(""String_Node_Str"" + focus);
      }
 else       if (hasFocus()) {
        sb.append(""String_Node_Str"" + focus);
      }
    }
 else     if (browseIndex.isMetadataIndex()) {
      sb.append(""String_Node_Str"" + browseIndex.getMetadata());
      if (isStartsWith()) {
        sb.append(""String_Node_Str"" + focus);
      }
 else       if (hasFocus()) {
        sb.append(""String_Node_Str"" + focus);
      }
    }
    sb.append(""String_Node_Str"");
    String direction=(ascending ? ""String_Node_Str"" : ""String_Node_Str"");
    sb.append(""String_Node_Str"" + sortOption.getMetadata() + ""String_Node_Str""+ direction+ ""String_Node_Str""+ Integer.toString(sortOption.getNumber())+ ""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (browseIndex.isMetadataIndex() && !isSecondLevel()) {
      sb.append(valueListingString());
    }
 else     if (browseIndex.isItemIndex() || isSecondLevel()) {
      sb.append(fullListingString(config));
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (hasNextPage()) {
      if (browseIndex.isMetadataIndex() && !isSecondLevel()) {
        sb.append(this.nextValue);
      }
 else       if (browseIndex.isItemIndex() || isSecondLevel()) {
        sb.append(""String_Node_Str"" + Integer.toString(this.nextItem));
      }
    }
 else {
      sb.append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (hasPrevPage()) {
      if (browseIndex.isMetadataIndex() && !isSecondLevel()) {
        sb.append(this.prevValue);
      }
 else       if (browseIndex.isItemIndex() || isSecondLevel()) {
        sb.append(""String_Node_Str"" + Integer.toString(this.prevItem));
      }
    }
 else {
      sb.append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
    return sb.toString();
  }
 catch (  SQLException e) {
    return e.getMessage();
  }
catch (  BrowseException e) {
    return e.getMessage();
  }
}","/** 
 * Utility method for obtaining a string representation of the browse.  This is useful only for debug
 */
public String toString(){
  try {
    StringBuffer sb=new StringBuffer();
    String from=Integer.toString(overallPosition + 1);
    String to=Integer.toString(overallPosition + results.size());
    String of=Integer.toString(total);
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"" + from + ""String_Node_Str""+ to+ ""String_Node_Str""+ of+ ""String_Node_Str"");
    sb.append(""String_Node_Str"" + browseIndex.getName() + ""String_Node_Str""+ browseIndex.getDataType()+ ""String_Node_Str""+ browseIndex.getDisplayType()+ ""String_Node_Str"");
    sb.append(""String_Node_Str"");
    String container=""String_Node_Str"";
    DSpaceObject theContainer=null;
    if (inCollection()) {
      container=""String_Node_Str"";
      theContainer=this.collection;
    }
 else     if (inCommunity()) {
      container=""String_Node_Str"";
      theContainer=this.community;
    }
    String containerID=""String_Node_Str"";
    if (theContainer != null) {
      containerID=Integer.toString(theContainer.getID()) + ""String_Node_Str"" + theContainer.getHandle()+ ""String_Node_Str"";
    }
    sb.append(""String_Node_Str"" + container + ""String_Node_Str""+ containerID);
    sb.append(""String_Node_Str"");
    ItemListConfig config=new ItemListConfig();
    if (browseIndex.isItemIndex()) {
      sb.append(""String_Node_Str"" + Integer.toString(config.numCols()) + ""String_Node_Str"");
      for (int k=1; k <= config.numCols(); k++) {
        if (k > 1) {
          sb.append(""String_Node_Str"");
        }
        String[] meta=config.getMetadata(k);
        sb.append(meta[0] + ""String_Node_Str"" + meta[1]+ ""String_Node_Str""+ meta[2]);
      }
      if (value != null) {
        sb.append(""String_Node_Str"" + value);
      }
      if (isStartsWith()) {
        sb.append(""String_Node_Str"" + focus);
      }
 else       if (hasFocus()) {
        sb.append(""String_Node_Str"" + focus);
      }
    }
 else     if (browseIndex.isMetadataIndex()) {
      sb.append(""String_Node_Str"" + browseIndex.getMetadata());
      if (isStartsWith()) {
        sb.append(""String_Node_Str"" + focus);
      }
 else       if (hasFocus()) {
        sb.append(""String_Node_Str"" + focus);
      }
    }
    sb.append(""String_Node_Str"");
    String direction=(ascending ? ""String_Node_Str"" : ""String_Node_Str"");
    sb.append(""String_Node_Str"" + sortOption.getMetadata() + ""String_Node_Str""+ direction+ ""String_Node_Str""+ Integer.toString(sortOption.getNumber())+ ""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (browseIndex.isMetadataIndex() && !isSecondLevel()) {
      sb.append(valueListingString());
    }
 else     if (browseIndex.isItemIndex() || isSecondLevel()) {
      sb.append(fullListingString(config));
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (hasNextPage()) {
      sb.append(""String_Node_Str"" + Integer.toString(this.nextOffset));
    }
 else {
      sb.append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (hasPrevPage()) {
      sb.append(""String_Node_Str"" + Integer.toString(this.prevOffset));
    }
 else {
      sb.append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
    return sb.toString();
  }
 catch (  SQLException e) {
    return e.getMessage();
  }
catch (  BrowseException e) {
    return e.getMessage();
  }
}",0.9168283892431384
52431,"/** 
 * @return	true if in collection, false if not
 */
public boolean inCollection(){
  if (this.collection != null) {
    return true;
  }
  return false;
}","/** 
 * @return  true if in collection, false if not
 */
public boolean inCollection(){
  if (this.collection != null) {
    return true;
  }
  return false;
}",0.9905362776025236
52432,"/** 
 * @return	true if has item focus, false if not
 */
public boolean hasJumpToItem(){
  if (jumpItemId == -1) {
    return false;
  }
  return true;
}","/** 
 * @return  true if has item focus, false if not
 */
public boolean hasJumpToItem(){
  if (jumpItemId == -1) {
    return false;
  }
  return true;
}",0.990228013029316
52433,"/** 
 * Obtain a DSpaceObject that represents the container object.  This will be a Community or a Collection
 * @return	A DSpaceObject representing a Community or a Collection
 */
public DSpaceObject getBrowseContainer(){
  if (this.collection != null) {
    return this.collection;
  }
  if (this.community != null) {
    return this.community;
  }
  return null;
}","/** 
 * Obtain a DSpaceObject that represents the container object.  This will be a Community or a Collection
 * @return  A DSpaceObject representing a Community or a Collection
 */
public DSpaceObject getBrowseContainer(){
  if (this.collection != null) {
    return this.collection;
  }
  if (this.community != null) {
    return this.community;
  }
  return null;
}",0.9959183673469388
52434,"/** 
 * @return	true if has value focus, false if not
 */
public boolean hasJumpToValue(){
  if (this.jumpValue != null) {
    return true;
  }
  return false;
}","/** 
 * @return  true if has value focus, false if not
 */
public boolean hasJumpToValue(){
  if (this.jumpValue != null) {
    return true;
  }
  return false;
}",0.9907120743034056
52435,"/** 
 * @return	true if has starts with value, false if not
 */
public boolean hasStartsWith(){
  if (this.startsWith != null) {
    return true;
  }
  return false;
}","/** 
 * @return  true if has starts with value, false if not
 */
public boolean hasStartsWith(){
  if (this.startsWith != null) {
    return true;
  }
  return false;
}",0.991044776119403
52436,"/** 
 * Set the DSpaceObject that is the container for this browse.  If this is not of type Collection or Community, this method will throw an exception
 * @param dso		the container object; a Community or Collection
 * @throws BrowseException
 */
public void setBrowseContainer(DSpaceObject dso) throws BrowseException {
  if (dso instanceof Collection) {
    this.collection=(Collection)dso;
  }
 else   if (dso instanceof Community) {
    this.community=(Community)dso;
  }
 else {
    throw new BrowseException(""String_Node_Str"");
  }
}","/** 
 * Set the DSpaceObject that is the container for this browse.  If this is not of type Collection or Community, this method will throw an exception
 * @param dso       the container object; a Community or Collection
 * @throws BrowseException
 */
public void setBrowseContainer(DSpaceObject dso) throws BrowseException {
  if (dso instanceof Collection) {
    this.collection=(Collection)dso;
  }
 else   if (dso instanceof Community) {
    this.community=(Community)dso;
  }
 else {
    throw new BrowseException(""String_Node_Str"");
  }
}",0.9916897506925209
52437,"/** 
 * @return	true if second level browse, false if not
 */
public boolean isSecondLevel(){
  if (this.level == 1) {
    return true;
  }
  return false;
}","/** 
 * @return  true if second level browse, false if not
 */
public boolean isSecondLevel(){
  if (this.level == 1) {
    return true;
  }
  return false;
}",0.9904761904761904
52438,"/** 
 * @return	true if in community, false if not
 */
public boolean inCommunity(){
  if (this.community != null) {
    return true;
  }
  return false;
}","/** 
 * @return  true if in community, false if not
 */
public boolean inCommunity(){
  if (this.community != null) {
    return true;
  }
  return false;
}",0.990353697749196
52439,"/** 
 * Obtain the sort option
 * @return	the sort option
 * @throws BrowseException
 */
public SortOption getSortOption() throws BrowseException {
  try {
    if (sortOption == null) {
      if (browseIndex != null) {
        if (sortBy <= 0 && browseIndex.isMetadataIndex()) {
          String dataType=browseIndex.getDataType();
          String type=(""String_Node_Str"".equals(dataType) ? ""String_Node_Str"" : ""String_Node_Str"");
          sortOption=new SortOption(0,browseIndex.getName(),browseIndex.getMetadata(0),type);
        }
 else {
          if (sortBy <= 0) {
            sortOption=browseIndex.getSortOption();
            if (sortOption == null) {
              for (              SortOption so : SortOption.getSortOptions()) {
                sortOption=so;
                break;
              }
            }
          }
 else {
            for (            SortOption so : SortOption.getSortOptions()) {
              if (so.getNumber() == sortBy)               sortOption=so;
            }
          }
        }
      }
    }
    return sortOption;
  }
 catch (  SortException se) {
    throw new BrowseException(""String_Node_Str"",se);
  }
}","/** 
 * Obtain the sort option
 * @return  the sort option
 * @throws BrowseException
 */
public SortOption getSortOption() throws BrowseException {
  try {
    if (sortOption == null) {
      if (browseIndex != null) {
        if (sortBy <= 0 && browseIndex.isMetadataIndex()) {
          String dataType=browseIndex.getDataType();
          String type=(""String_Node_Str"".equals(dataType) ? ""String_Node_Str"" : ""String_Node_Str"");
          sortOption=new SortOption(0,browseIndex.getName(),browseIndex.getMetadata(0),type);
        }
 else {
          if (sortBy <= 0) {
            sortOption=browseIndex.getSortOption();
            if (sortOption == null) {
              for (              SortOption so : SortOption.getSortOptions()) {
                sortOption=so;
                break;
              }
            }
          }
 else {
            for (            SortOption so : SortOption.getSortOptions()) {
              if (so.getNumber() == sortBy)               sortOption=so;
            }
          }
        }
      }
    }
    return sortOption;
  }
 catch (  SortException se) {
    throw new BrowseException(""String_Node_Str"",se);
  }
}",0.9987085665088248
52440,"/** 
 * Used for second-level item browses, to only display items that match the value 
 * @return Returns the value.
 */
public String getFilterValue(){
  return filterValue;
}","/** 
 * Used for second-level item browses, to only display items that match the value
 * @return Returns the value.
 */
public String getFilterValue(){
  return filterValue;
}",0.9971671388101984
52441,"/** 
 * @param level		the browse level
 */
public void setBrowseLevel(int level){
  this.level=level;
}","/** 
 * @param level     the browse level
 */
public void setBrowseLevel(int level){
  this.level=level;
}",0.9665071770334928
52442,"/** 
 * @param value		the value to focus on
 */
public void setJumpToValue(String value){
  this.jumpValue=value;
}","/** 
 * @param value     the value to focus on
 */
public void setJumpToValue(String value){
  this.jumpValue=value;
}",0.9699570815450644
52443,"/** 
 * @return	the value to focus on
 */
public String getJumpToValue(){
  return jumpValue;
}","/** 
 * @return  the value to focus on
 */
public String getJumpToValue(){
  return jumpValue;
}",0.9842931937172776
52444,"/** 
 * @return	the browse level
 */
public int getBrowseLevel(){
  return this.level;
}","/** 
 * @return  the browse level
 */
public int getBrowseLevel(){
  return this.level;
}",0.9830508474576272
52445,"/** 
 * @return	true if ascending, false if not - or not set
 */
public boolean isAscending(){
  if (SortOption.ASCENDING.equalsIgnoreCase(order)) {
    return true;
  }
  if (SortOption.DESCENDING.equalsIgnoreCase(order)) {
    return false;
  }
  BrowseIndex bi=getBrowseIndex();
  if (bi != null && SortOption.DESCENDING.equalsIgnoreCase(bi.getDefaultOrder()))   return false;
  return true;
}","/** 
 * @return  true if ascending, false if not - or not set
 */
public boolean isAscending(){
  if (SortOption.ASCENDING.equalsIgnoreCase(order)) {
    return true;
  }
  if (SortOption.DESCENDING.equalsIgnoreCase(order)) {
    return false;
  }
  BrowseIndex bi=getBrowseIndex();
  if (bi != null && SortOption.DESCENDING.equalsIgnoreCase(bi.getDefaultOrder()))   return false;
  return true;
}",0.996216897856242
52446,"/** 
 * @return	true if has value, false if not
 */
public boolean hasFilterValue(){
  if (filterValue == null || ""String_Node_Str"".equals(filterValue)) {
    return false;
  }
  return true;
}","/** 
 * @return  true if has value, false if not
 */
public boolean hasFilterValue(){
  if (filterValue == null || ""String_Node_Str"".equals(filterValue)) {
    return false;
  }
  return true;
}",0.992248062015504
52447,"/** 
 * Construct a new BrowserScope using the given Context 
 * @param context	the DSpace Context
 */
public BrowserScope(Context context){
  this.context=context;
}","/** 
 * Construct a new BrowserScope using the given Context
 * @param context   the DSpace Context
 */
public BrowserScope(Context context){
  this.context=context;
}",0.984984984984985
52448,"/** 
 * Used for second-level item browses, to only display items that match the value 
 * @param value The value to set.
 */
public void setFilterValue(String value){
  this.filterValue=value;
}","/** 
 * Used for second-level item browses, to only display items that match the value
 * @param value The value to set.
 */
public void setFilterValue(String value){
  this.filterValue=value;
}",0.9974293059125964
52449,"/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getHandle();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getHandle();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi != null && bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}","/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int offset=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (offset < 0) {
      offset=0;
    }
    if (resultsperpage < 0) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getHandle();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getHandle();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setOffset(offset);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi != null && bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}",0.9532964365472376
52450,"/** 
 * Display the single page.  This is the page which lists just the single values of a  metadata browse, not individual items.  Single values are links through to all the items that match that metadata value
 * @param context
 * @param request
 * @param response
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected abstract void showSinglePage(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException ;","/** 
 * Display the single page.  This is the page which lists just the single values of a metadata browse, not individual items.  Single values are links through to all the items that match that metadata value
 * @param context
 * @param request
 * @param response
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected abstract void showSinglePage(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException ;",0.9991063449508488
52451,"/** 
 * using the pre-configuration information passed here, analyse the logs and produce the aggregation file
 * @param context     the DSpace context object this occurs under
 * @param myLogDir    the passed log directory.  Uses default if null
 * @param myFileTemplate  the passed file name regex.  Uses default if null
 * @param myConfigFile    the DStat config file.  Uses default if null
 * @param myOutFile    the file to which to output aggregation data.  Uses default if null
 * @param myStartDate     the desired start of the analysis.  Starts from the beginning otherwise
 * @param myEndDate       the desired end of the analysis.  Goes to the end otherwise
 * @param myLookUp        force a lookup of the database
 */
public static void processLogs(Context context,String myLogDir,String myFileTemplate,String myConfigFile,String myOutFile,Date myStartDate,Date myEndDate,boolean myLookUp) throws IOException, SQLException {
  startTime=new GregorianCalendar();
  actionAggregator=new HashMap();
  searchAggregator=new HashMap();
  userAggregator=new HashMap();
  itemAggregator=new HashMap();
  archiveStats=new HashMap();
  generalSummary=new ArrayList();
  excludeWords=new ArrayList();
  excludeTypes=new ArrayList();
  excludeChars=new ArrayList();
  itemTypes=new ArrayList();
  setParameters(myLogDir,myFileTemplate,myConfigFile,myOutFile,myStartDate,myEndDate,myLookUp);
  FileReader fr=null;
  BufferedReader br=null;
  readConfig(configFile);
  setRegex(fileTemplate);
  File[] logFiles=getLogFiles(logDir);
  int i=0;
  for (i=0; i < logFiles.length; i++) {
    Matcher matchRegex=logRegex.matcher(logFiles[i].getName());
    if (matchRegex.matches()) {
      try {
        fr=new FileReader(logFiles[i].toString());
        br=new BufferedReader(fr);
      }
 catch (      IOException e) {
        System.out.println(""String_Node_Str"" + logFiles[i].toString());
        System.exit(0);
      }
      String line=null;
      while ((line=br.readLine()) != null) {
        LogLine logLine=getLogLine(line);
        if (logLine != null) {
          if (logLine.beforeDate(startDate)) {
            continue;
          }
          if (logLine.afterDate(endDate)) {
            break;
          }
          lineCount++;
          if (startDate == null) {
            if (logStartDate != null) {
              if (logLine.beforeDate(logStartDate)) {
                logStartDate=logLine.getDate();
              }
            }
 else {
              logStartDate=logLine.getDate();
            }
          }
          if (endDate == null) {
            if (logEndDate != null) {
              if (logLine.afterDate(logEndDate)) {
                logEndDate=logLine.getDate();
              }
            }
 else {
              logEndDate=logLine.getDate();
            }
          }
          if (logLine.isLevel(""String_Node_Str"")) {
            warnCount++;
          }
          if (logLine.isAction(""String_Node_Str"")) {
            String[] words=analyseQuery(logLine.getParams());
            for (int j=0; j < words.length; j++) {
              searchAggregator.put(words[j],increment(searchAggregator,words[j]));
            }
          }
          if (logLine.isAction(""String_Node_Str"") && !userEmail.equals(""String_Node_Str"")) {
            userAggregator.put(logLine.getUser(),increment(userAggregator,logLine.getUser()));
          }
          if (logLine.isAction(""String_Node_Str"")) {
            String handle=logLine.getParams();
            Matcher matchHandle=handleRX.matcher(handle);
            handle=matchHandle.replaceAll(""String_Node_Str"");
            Matcher matchItem=itemRX.matcher(handle);
            handle=matchItem.replaceAll(""String_Node_Str"");
            handle.trim();
            itemAggregator.put(handle,increment(itemAggregator,handle));
          }
          actionAggregator.put(logLine.getAction(),increment(actionAggregator,logLine.getAction()));
        }
      }
      br.close();
      fr.close();
    }
  }
  archiveStats.put(""String_Node_Str"",getNumItems(context));
  for (i=0; i < itemTypes.size(); i++) {
    archiveStats.put(itemTypes.get(i),getNumItems(context,(String)itemTypes.get(i)));
  }
  hostName=ConfigurationManager.getProperty(""String_Node_Str"").trim();
  name=ConfigurationManager.getProperty(""String_Node_Str"").trim();
  url=ConfigurationManager.getProperties(""String_Node_Str"").trim();
  if ((url != null) && (!url.endsWith(""String_Node_Str""))) {
    url=url + ""String_Node_Str"";
  }
  if (((Integer)archiveStats.get(""String_Node_Str"")).intValue() != 0) {
    Double avg=new Double(Math.ceil(((Integer)actionAggregator.get(""String_Node_Str"")).intValue() / ((Integer)archiveStats.get(""String_Node_Str"")).intValue()));
    views=avg.intValue();
  }
  createOutput();
  return;
}","/** 
 * using the pre-configuration information passed here, analyse the logs and produce the aggregation file
 * @param context     the DSpace context object this occurs under
 * @param myLogDir    the passed log directory.  Uses default if null
 * @param myFileTemplate  the passed file name regex.  Uses default if null
 * @param myConfigFile    the DStat config file.  Uses default if null
 * @param myOutFile    the file to which to output aggregation data.  Uses default if null
 * @param myStartDate     the desired start of the analysis.  Starts from the beginning otherwise
 * @param myEndDate       the desired end of the analysis.  Goes to the end otherwise
 * @param myLookUp        force a lookup of the database
 */
public static void processLogs(Context context,String myLogDir,String myFileTemplate,String myConfigFile,String myOutFile,Date myStartDate,Date myEndDate,boolean myLookUp) throws IOException, SQLException {
  startTime=new GregorianCalendar();
  actionAggregator=new HashMap();
  searchAggregator=new HashMap();
  userAggregator=new HashMap();
  itemAggregator=new HashMap();
  archiveStats=new HashMap();
  generalSummary=new ArrayList();
  excludeWords=new ArrayList();
  excludeTypes=new ArrayList();
  excludeChars=new ArrayList();
  itemTypes=new ArrayList();
  setParameters(myLogDir,myFileTemplate,myConfigFile,myOutFile,myStartDate,myEndDate,myLookUp);
  FileReader fr=null;
  BufferedReader br=null;
  readConfig(configFile);
  setRegex(fileTemplate);
  File[] logFiles=getLogFiles(logDir);
  int i=0;
  for (i=0; i < logFiles.length; i++) {
    Matcher matchRegex=logRegex.matcher(logFiles[i].getName());
    if (matchRegex.matches()) {
      try {
        fr=new FileReader(logFiles[i].toString());
        br=new BufferedReader(fr);
      }
 catch (      IOException e) {
        System.out.println(""String_Node_Str"" + logFiles[i].toString());
        System.exit(0);
      }
      String line=null;
      while ((line=br.readLine()) != null) {
        LogLine logLine=getLogLine(line);
        if (logLine != null) {
          if (logLine.beforeDate(startDate)) {
            continue;
          }
          if (logLine.afterDate(endDate)) {
            break;
          }
          lineCount++;
          if (startDate == null) {
            if (logStartDate != null) {
              if (logLine.beforeDate(logStartDate)) {
                logStartDate=logLine.getDate();
              }
            }
 else {
              logStartDate=logLine.getDate();
            }
          }
          if (endDate == null) {
            if (logEndDate != null) {
              if (logLine.afterDate(logEndDate)) {
                logEndDate=logLine.getDate();
              }
            }
 else {
              logEndDate=logLine.getDate();
            }
          }
          if (logLine.isLevel(""String_Node_Str"")) {
            warnCount++;
          }
          if (logLine.isAction(""String_Node_Str"")) {
            String[] words=analyseQuery(logLine.getParams());
            for (int j=0; j < words.length; j++) {
              searchAggregator.put(words[j],increment(searchAggregator,words[j]));
            }
          }
          if (logLine.isAction(""String_Node_Str"") && !userEmail.equals(""String_Node_Str"")) {
            userAggregator.put(logLine.getUser(),increment(userAggregator,logLine.getUser()));
          }
          if (logLine.isAction(""String_Node_Str"")) {
            String handle=logLine.getParams();
            Matcher matchHandle=handleRX.matcher(handle);
            handle=matchHandle.replaceAll(""String_Node_Str"");
            Matcher matchItem=itemRX.matcher(handle);
            handle=matchItem.replaceAll(""String_Node_Str"");
            handle.trim();
            itemAggregator.put(handle,increment(itemAggregator,handle));
          }
          actionAggregator.put(logLine.getAction(),increment(actionAggregator,logLine.getAction()));
        }
      }
      br.close();
      fr.close();
    }
  }
  archiveStats.put(""String_Node_Str"",getNumItems(context));
  for (i=0; i < itemTypes.size(); i++) {
    archiveStats.put(itemTypes.get(i),getNumItems(context,(String)itemTypes.get(i)));
  }
  hostName=ConfigurationManager.getProperty(""String_Node_Str"").trim();
  name=ConfigurationManager.getProperty(""String_Node_Str"").trim();
  url=ConfigurationManager.getProperty(""String_Node_Str"").trim();
  if ((url != null) && (!url.endsWith(""String_Node_Str""))) {
    url=url + ""String_Node_Str"";
  }
  if (((Integer)archiveStats.get(""String_Node_Str"")).intValue() != 0) {
    Double avg=new Double(Math.ceil(((Integer)actionAggregator.get(""String_Node_Str"")).intValue() / ((Integer)archiveStats.get(""String_Node_Str"")).intValue()));
    views=avg.intValue();
  }
  createOutput();
  return;
}",0.9995800965777872
52452,"/** 
 * Browse the archive by single values (such as the name of an author).  This produces a BrowseInfo object that contains Strings as the results of the browse
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByValue(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bs.getJumpToValue()));
  try {
    dao.setTable(browseIndex.getDistinctTableName());
    dao.setDistinct(true);
    dao.setAscending(scope.isAscending());
    dao.setOrderField(""String_Node_Str"");
    if (scope.inCollection() || scope.inCommunity()) {
      dao.setFilterMappingTables(null,browseIndex.getMapTableName());
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    dao.setJumpToField(""String_Node_Str"");
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && scope.hasJumpToValue() || scope.hasStartsWith()) {
      String focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith() && browseIndex.isDate()) {
        focusValue=focusValue + ""String_Node_Str"";
      }
      offset=getOffsetForDistinctValue(focusValue);
    }
    dao.setOffset(offset);
    dao.setLimit(scope.getResultsPerPage());
    int total=getTotalResults();
    List results=null;
    if (total > 0) {
      results=dao.doQuery();
      if (results.size() == 0) {
        offset=total - scope.getResultsPerPage();
        if (offset < 0)         offset=0;
        dao.setOffset(offset);
        results=dao.doQuery();
      }
    }
 else {
      results=new ArrayList();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setFocus(rawFocusValue);
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by single values (such as the name of an author).  This produces a BrowseInfo object that contains Strings as the results of the browse
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByValue(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bs.getJumpToValue()));
  try {
    dao.setTable(browseIndex.getDistinctTableName());
    dao.setDistinct(true);
    dao.setAscending(scope.isAscending());
    dao.setOrderField(""String_Node_Str"");
    if (scope.inCollection() || scope.inCommunity()) {
      dao.setFilterMappingTables(null,browseIndex.getMapTableName());
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    dao.setJumpToField(""String_Node_Str"");
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && scope.hasJumpToValue() || scope.hasStartsWith()) {
      String focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith() && browseIndex.isDate()) {
        focusValue=focusValue + ""String_Node_Str"";
      }
      offset=getOffsetForDistinctValue(focusValue);
    }
    dao.setOffset(offset);
    dao.setLimit(scope.getResultsPerPage());
    int total=getTotalResults(true);
    List results=null;
    if (total > 0) {
      results=dao.doValueQuery();
      if (results.size() == 0) {
        offset=total - scope.getResultsPerPage();
        if (offset < 0)         offset=0;
        dao.setOffset(offset);
        results=dao.doValueQuery();
      }
    }
 else {
      results=new ArrayList();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setFocus(rawFocusValue);
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9977513652425312
52453,"/** 
 * Return the focus value.
 * @return	the focus value to use
 * @throws BrowseException
 */
private String getJumpToValue() throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  if (scope.hasJumpToValue()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getJumpToValue()));
    return scope.getJumpToValue();
  }
  if (scope.hasStartsWith()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getStartsWith()));
    return scope.getStartsWith();
  }
  int id=scope.getJumpToItem();
  String tableName=browseIndex.getTableName();
  SortOption so=scope.getSortOption();
  String col=""String_Node_Str"";
  if (so.getNumber() > 0) {
    col=""String_Node_Str"" + Integer.toString(so.getNumber());
  }
  String max=dao.doMaxQuery(col,tableName,id);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + max));
  return max;
}","/** 
 * Return the focus value.
 * @return	the focus value to use
 * @throws BrowseException
 */
private String getJumpToValue() throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  if (scope.hasJumpToValue()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getJumpToValue()));
    return scope.getJumpToValue();
  }
  if (scope.hasStartsWith()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getStartsWith()));
    return scope.getStartsWith();
  }
  int id=scope.getJumpToItem();
  String tableName=browseIndex.getTableName();
  SortOption so=scope.getSortOption();
  if (so == null || so.getNumber() == 0) {
    if (browseIndex.getSortOption() != null)     so=browseIndex.getSortOption();
  }
  String col=""String_Node_Str"";
  if (so.getNumber() > 0) {
    col=""String_Node_Str"" + Integer.toString(so.getNumber());
  }
  String max=dao.doMaxQuery(col,tableName,id);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + max));
  return max;
}",0.9108341323106424
52454,"/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    dao.deleteCommunityMappings(item.getID());
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      dao.insertCommunityMappings(item.getID());
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        boolean itemMapped=false;
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  int distinctID=dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal);
                  if (!dao.updateDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID))                   dao.createDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID);
                  itemMapped=true;
                }
              }
            }
          }
        }
        if (!itemMapped)         removeIndex(item.getID(),bis[i].getMapTableName());
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        boolean itemMapped=false;
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  int distinctID=dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal);
                  if (!dao.updateDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID))                   dao.createDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID);
                  itemMapped=true;
                }
              }
            }
          }
        }
        if (!itemMapped)         removeIndex(item.getID(),bis[i].getMapTableName());
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9617823479005998
52455,"protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws java.sql.SQLException, javax.servlet.ServletException, java.io.IOException, AuthorizeException {
  String jspPage=null;
  int myID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Collection myCollection=Collection.find(context,myID);
  AuthorizeManager.authorizeAction(context,myCollection,Constants.COLLECTION_ADMIN);
  String action=request.getParameter(""String_Node_Str"");
  if (action == null) {
    action=""String_Node_Str"";
  }
  String cancel=request.getParameter(""String_Node_Str"");
  if (cancel == null) {
    cancel=""String_Node_Str"";
  }
  if (action.equals(""String_Node_Str"") || !cancel.equals(""String_Node_Str"")) {
    int count_native=0;
    int count_import=0;
    Map myItems=new HashMap();
    Map myCollections=new HashMap();
    Map myCounts=new HashMap();
    ItemIterator i=myCollection.getItems();
    while (i.hasNext()) {
      Item myItem=i.next();
      Integer myKey=new Integer(myItem.getID());
      if (myItem.isOwningCollection(myCollection)) {
        count_native++;
      }
 else {
        count_import++;
      }
      Collection owningCollection=myItem.getOwningCollection();
      Integer cKey=new Integer(owningCollection.getID());
      if (myCollections.containsKey(cKey)) {
        Integer x=(Integer)myCounts.get(cKey);
        int myCount=x.intValue() + 1;
        myCounts.put(cKey,new Integer(myCount));
      }
 else {
        myCollections.put(cKey,owningCollection);
        myCounts.put(cKey,new Integer(1));
      }
      myItems.put(myKey,myItem);
    }
    myCollections.remove(new Integer(myCollection.getID()));
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",new Integer(count_native));
    request.setAttribute(""String_Node_Str"",new Integer(count_import));
    request.setAttribute(""String_Node_Str"",myItems);
    request.setAttribute(""String_Node_Str"",myCollections);
    request.setAttribute(""String_Node_Str"",myCounts);
    request.setAttribute(""String_Node_Str"",Collection.findAll(context));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList removedItems=new LinkedList();
    for (int j=0; j < itemIDs.length; j++) {
      int i=Integer.parseInt(itemIDs[j]);
      removedItems.add(itemIDs[j]);
      Item myItem=Item.find(context,i);
      if (!myItem.isOwningCollection(myCollection)) {
        myCollection.removeItem(myItem);
        try {
          IndexBrowse ib=new IndexBrowse(context);
          ib.itemChanged(myItem);
        }
 catch (        BrowseException e) {
          log.error(""String_Node_Str"",e);
          throw new ServletException(e);
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",removedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList addedItems=new LinkedList();
    if (itemIDs == null) {
      message=""String_Node_Str"";
    }
 else {
      for (int j=0; j < itemIDs.length; j++) {
        int i=Integer.parseInt(itemIDs[j]);
        Item myItem=Item.find(context,i);
        if (AuthorizeManager.authorizeActionBoolean(context,myItem,Constants.READ)) {
          if (!myItem.isOwningCollection(myCollection)) {
            myCollection.addItem(myItem);
            try {
              IndexBrowse ib=new IndexBrowse(context);
              ib.itemChanged(myItem);
            }
 catch (            BrowseException e) {
              log.error(""String_Node_Str"",e);
              throw new ServletException(e);
            }
            addedItems.add(itemIDs[j]);
          }
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",addedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String name=(String)request.getParameter(""String_Node_Str"");
    String bidx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (bidx == null) {
      throw new ServletException(""String_Node_Str"");
    }
    Map items=new HashMap();
    try {
      BrowserScope bs=new BrowserScope(context);
      BrowseIndex bi=BrowseIndex.getBrowseIndex(bidx);
      bs.setBrowseIndex(bi);
      bs.setOrder(SortOption.ASCENDING);
      bs.setFilterValue(name);
      bs.setFilterValuePartial(true);
      bs.setJumpToValue(null);
      bs.setResultsPerPage(10000);
      bs.setSortBy(0);
      bs.setBrowseLevel(1);
      BrowseEngine be=new BrowseEngine(context);
      BrowseInfo results=be.browse(bs);
      Item[] browseItems=results.getItemResults(context);
      ItemIterator itr=myCollection.getItems();
      ArrayList idslist=new ArrayList();
      while (itr.hasNext()) {
        idslist.add(new Integer(itr.nextID()));
      }
      for (int i=0; i < browseItems.length; i++) {
        if (!idslist.contains(new Integer(browseItems[i].getID()))) {
          if (AuthorizeManager.authorizeActionBoolean(context,browseItems[i],Constants.READ)) {
            items.put(new Integer(browseItems[i].getID()),browseItems[i]);
          }
        }
      }
    }
 catch (    BrowseException e) {
      log.error(""String_Node_Str"",e);
      throw new ServletException(e);
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",name);
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    int t=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection targetCollection=Collection.find(context,t);
    ItemIterator i=myCollection.getItems();
    Map items=new HashMap();
    while (i.hasNext()) {
      Item myItem=i.next();
      if (myItem.isOwningCollection(targetCollection)) {
        Integer myKey=new Integer(myItem.getID());
        items.put(myKey,myItem);
      }
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",targetCollection.getMetadata(""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
  context.complete();
}","protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws java.sql.SQLException, javax.servlet.ServletException, java.io.IOException, AuthorizeException {
  String jspPage=null;
  int myID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Collection myCollection=Collection.find(context,myID);
  AuthorizeManager.authorizeAction(context,myCollection,Constants.COLLECTION_ADMIN);
  String action=request.getParameter(""String_Node_Str"");
  if (action == null) {
    action=""String_Node_Str"";
  }
  String cancel=request.getParameter(""String_Node_Str"");
  if (cancel == null) {
    cancel=""String_Node_Str"";
  }
  if (action.equals(""String_Node_Str"") || !cancel.equals(""String_Node_Str"")) {
    int count_native=0;
    int count_import=0;
    Map myItems=new HashMap();
    Map myCollections=new HashMap();
    Map myCounts=new HashMap();
    ItemIterator i=myCollection.getItems();
    while (i.hasNext()) {
      Item myItem=i.next();
      Integer myKey=new Integer(myItem.getID());
      if (myItem.isOwningCollection(myCollection)) {
        count_native++;
      }
 else {
        count_import++;
      }
      Collection owningCollection=myItem.getOwningCollection();
      Integer cKey=new Integer(owningCollection.getID());
      if (myCollections.containsKey(cKey)) {
        Integer x=(Integer)myCounts.get(cKey);
        int myCount=x.intValue() + 1;
        myCounts.put(cKey,new Integer(myCount));
      }
 else {
        myCollections.put(cKey,owningCollection);
        myCounts.put(cKey,new Integer(1));
      }
      myItems.put(myKey,myItem);
    }
    myCollections.remove(new Integer(myCollection.getID()));
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",new Integer(count_native));
    request.setAttribute(""String_Node_Str"",new Integer(count_import));
    request.setAttribute(""String_Node_Str"",myItems);
    request.setAttribute(""String_Node_Str"",myCollections);
    request.setAttribute(""String_Node_Str"",myCounts);
    request.setAttribute(""String_Node_Str"",Collection.findAll(context));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList removedItems=new LinkedList();
    for (int j=0; j < itemIDs.length; j++) {
      int i=Integer.parseInt(itemIDs[j]);
      removedItems.add(itemIDs[j]);
      Item myItem=Item.find(context,i);
      if (!myItem.isOwningCollection(myCollection)) {
        myCollection.removeItem(myItem);
        try {
          IndexBrowse ib=new IndexBrowse(context);
          ib.itemChanged(myItem);
        }
 catch (        BrowseException e) {
          log.error(""String_Node_Str"",e);
          throw new ServletException(e);
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",removedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList addedItems=new LinkedList();
    if (itemIDs == null) {
      message=""String_Node_Str"";
    }
 else {
      for (int j=0; j < itemIDs.length; j++) {
        int i=Integer.parseInt(itemIDs[j]);
        Item myItem=Item.find(context,i);
        if (AuthorizeManager.authorizeActionBoolean(context,myItem,Constants.READ)) {
          if (!myItem.isOwningCollection(myCollection)) {
            myCollection.addItem(myItem);
            try {
              IndexBrowse ib=new IndexBrowse(context);
              ib.itemChanged(myItem);
            }
 catch (            BrowseException e) {
              log.error(""String_Node_Str"",e);
              throw new ServletException(e);
            }
            addedItems.add(itemIDs[j]);
          }
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",addedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String name=(String)request.getParameter(""String_Node_Str"");
    String bidx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (bidx == null) {
      throw new ServletException(""String_Node_Str"");
    }
    Map items=new HashMap();
    try {
      BrowserScope bs=new BrowserScope(context);
      BrowseIndex bi=BrowseIndex.getBrowseIndex(bidx);
      bs.setBrowseIndex(bi);
      bs.setOrder(SortOption.ASCENDING);
      bs.setFilterValue(name);
      bs.setFilterValuePartial(true);
      bs.setJumpToValue(null);
      bs.setResultsPerPage(10000);
      bs.setBrowseLevel(1);
      BrowseEngine be=new BrowseEngine(context);
      BrowseInfo results=be.browse(bs);
      Item[] browseItems=results.getItemResults(context);
      ItemIterator itr=myCollection.getItems();
      ArrayList idslist=new ArrayList();
      while (itr.hasNext()) {
        idslist.add(new Integer(itr.nextID()));
      }
      for (int i=0; i < browseItems.length; i++) {
        if (!idslist.contains(new Integer(browseItems[i].getID()))) {
          if (AuthorizeManager.authorizeActionBoolean(context,browseItems[i],Constants.READ)) {
            items.put(new Integer(browseItems[i].getID()),browseItems[i]);
          }
        }
      }
    }
 catch (    BrowseException e) {
      log.error(""String_Node_Str"",e);
      throw new ServletException(e);
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",name);
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    int t=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection targetCollection=Collection.find(context,t);
    ItemIterator i=myCollection.getItems();
    Map items=new HashMap();
    while (i.hasNext()) {
      Item myItem=i.next();
      if (myItem.isOwningCollection(targetCollection)) {
        Integer myKey=new Integer(myItem.getID());
        items.put(myKey,myItem);
      }
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",targetCollection.getMetadata(""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
  context.complete();
}",0.9983394700743627
52456,"/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getIdentifier().getCanonicalForm();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getIdentifier().getCanonicalForm();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}","/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getIdentifier().getCanonicalForm();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getIdentifier().getCanonicalForm();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi != null && bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}",0.99140625
52457,"/** 
 * Translate the given HTML fragment into a DRI document. The translation is broken up into two steps, 1) recurse through all elements and either translate them into their DRI equivelents or remove them from the document. The second step, 2) is to iterate over all top level elements and ensure that they only consist of paragraphs. Also at this stage if linkBreaks is true then \n are treated as paragraph breaks.
 * @param parent The Element to translate into DRI.
 */
private void translate(Element parent){
  for (int i=0; i < parent.getContentSize(); i++) {
    Content decedent=parent.getContent(i);
    if (decedent instanceof org.jdom.Text) {
    }
 else     if (decedent instanceof Element) {
      Element element=(Element)decedent;
      String name=element.getName();
      if (""String_Node_Str"".equals(name)) {
        if (parent.isRootElement()) {
          moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
          limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
          translate(element);
        }
 else {
          removeContent(element);
        }
      }
 else       if (""String_Node_Str"".equals(name) || ""String_Node_Str"".equals(name) || ""String_Node_Str"".equals(name)|| ""String_Node_Str"".equals(name)|| ""String_Node_Str"".equals(name)) {
        if (parent.isRootElement()) {
          limitAttributes(element);
          element.setName(""String_Node_Str"");
          element.setAttribute(""String_Node_Str"",""String_Node_Str"");
          translate(element);
        }
 else {
          removeContent(element);
        }
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"");
        element.setName(""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        element.setName(""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element);
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element);
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element);
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"");
        element.setName(""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element,""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element,""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else {
        removeContent(decedent);
      }
    }
 else {
      removeContent(decedent);
    }
  }
  if (parent.isRootElement()) {
    List<Content> removed=new ArrayList<Content>();
    for (int i=0; i < parent.getContentSize(); i++) {
      Content current=parent.getContent(i);
      if ((current instanceof Element) && (""String_Node_Str"".equals(((Element)current).getName()))) {
        if (paragraphWrap(parent,i,removed)) {
          removed.clear();
          i++;
        }
      }
 else {
        if (this.blankLines && current instanceof Text) {
          String rawText=((Text)current).getText();
          @SuppressWarnings(""String_Node_Str"") List<String> parts=new ArrayList(Arrays.asList(rawText.split(""String_Node_Str"")));
          if (parts.size() > 0) {
            Collections.reverse(parts);
            String lastPart=parts.remove(0);
            for (            String part : parts) {
              removed.add(new Text(part));
              if (paragraphWrap(parent,i,removed)) {
                removed.clear();
                i++;
              }
            }
            removed.add(new Text(lastPart));
            parent.removeContent(current);
            i--;
          }
        }
 else {
          removed.add(current);
          parent.removeContent(current);
          i--;
        }
      }
    }
    if (removed.size() > 0) {
      paragraphWrap(parent,-1,removed);
      removed.clear();
    }
  }
}","/** 
 * Translate the given HTML fragment into a DRI document. The translation is broken up into two steps, 1) recurse through all elements and either translate them into their DRI equivelents or remove them from the document. The second step, 2) is to iterate over all top level elements and ensure that they only consist of paragraphs. Also at this stage if linkBreaks is true then \n are treated as paragraph breaks.
 * @param parent The Element to translate into DRI.
 */
private void translate(Element parent){
  for (int i=0; i < parent.getContentSize(); i++) {
    Content decedent=parent.getContent(i);
    if (decedent instanceof org.jdom.Text) {
    }
 else     if (decedent instanceof Element) {
      Element element=(Element)decedent;
      String name=element.getName();
      if (""String_Node_Str"".equals(name)) {
        if (parent.isRootElement()) {
          moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
          limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
          translate(element);
        }
 else {
          removeContent(element);
        }
      }
 else       if (""String_Node_Str"".equals(name) || ""String_Node_Str"".equals(name) || ""String_Node_Str"".equals(name)|| ""String_Node_Str"".equals(name)|| ""String_Node_Str"".equals(name)) {
        if (parent.isRootElement()) {
          limitAttributes(element);
          element.setName(""String_Node_Str"");
          element.setAttribute(""String_Node_Str"",""String_Node_Str"");
          translate(element);
        }
 else {
          removeContent(element);
        }
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"");
        element.setName(""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        element.setName(""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element);
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element);
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element);
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"");
        element.setName(""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element,""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element,""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else {
        removeContent(decedent);
      }
    }
 else {
      removeContent(decedent);
    }
  }
  if (parent.isRootElement()) {
    List<Content> removed=new ArrayList<Content>();
    for (int i=0; i < parent.getContentSize(); i++) {
      Content current=parent.getContent(i);
      if ((current instanceof Element) && (""String_Node_Str"".equals(((Element)current).getName()))) {
        if (paragraphWrap(parent,i,removed)) {
          removed.clear();
          i++;
        }
      }
 else       if ((current instanceof Element) && (""String_Node_Str"".equals(((Element)current).getName()))) {
        i++;
      }
 else {
        if (this.blankLines && current instanceof Text) {
          String rawText=((Text)current).getText();
          @SuppressWarnings(""String_Node_Str"") List<String> parts=new ArrayList(Arrays.asList(rawText.split(""String_Node_Str"")));
          if (parts.size() > 0) {
            Collections.reverse(parts);
            String lastPart=parts.remove(0);
            for (            String part : parts) {
              removed.add(new Text(part));
              if (paragraphWrap(parent,i,removed)) {
                removed.clear();
                i++;
              }
            }
            removed.add(new Text(lastPart));
            parent.removeContent(current);
            i--;
          }
        }
 else {
          removed.add(current);
          parent.removeContent(current);
          i--;
        }
      }
    }
    if (removed.size() > 0) {
      paragraphWrap(parent,-1,removed);
      removed.clear();
    }
  }
}",0.9880367244737086
52458,"/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        boolean itemMapped=false;
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  int distinctID=dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal);
                  if (!dao.updateDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID))                   dao.createDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID);
                  itemMapped=true;
                }
              }
            }
          }
        }
        if (!itemMapped)         removeIndex(item.getID(),bis[i].getMapTableName());
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        Set<Integer> distIDSet=new HashSet<Integer>();
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal));
                }
              }
            }
          }
        }
        if (distIDSet.isEmpty()) {
          removeIndex(item.getID(),bis[i].getMapTableName());
        }
 else {
          int[] distIDarr=new int[distIDSet.size()];
          int didx=0;
          for (          Integer distID : distIDSet) {
            distIDarr[didx++]=distID;
          }
          dao.updateDistinctMappings(bis[i].getMapTableName(),item.getID(),distIDarr);
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.8676567656765677
52459,"/** 
 * Return the focus value.
 * @return	the focus value to use
 * @throws BrowseException
 */
private String getJumpToValue() throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  if (scope.hasJumpToValue()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getJumpToValue()));
    return scope.getJumpToValue();
  }
  if (scope.hasStartsWith()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getStartsWith()));
    return scope.getStartsWith();
  }
  int id=scope.getJumpToItem();
  String tableName=browseIndex.getTableName();
  SortOption so=scope.getSortOption();
  String col=""String_Node_Str"";
  if (so.getNumber() > 0) {
    col=""String_Node_Str"" + Integer.toString(so.getNumber());
  }
  String max=dao.doMaxQuery(col,tableName,id);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + max));
  return max;
}","/** 
 * Return the focus value.
 * @return	the focus value to use
 * @throws BrowseException
 */
private String getJumpToValue() throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  if (scope.hasJumpToValue()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getJumpToValue()));
    return scope.getJumpToValue();
  }
  if (scope.hasStartsWith()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getStartsWith()));
    return scope.getStartsWith();
  }
  int id=scope.getJumpToItem();
  String tableName=browseIndex.getTableName();
  SortOption so=scope.getSortOption();
  if (so == null || so.getNumber() == 0) {
    if (browseIndex.getSortOption() != null)     so=browseIndex.getSortOption();
  }
  String col=""String_Node_Str"";
  if (so.getNumber() > 0) {
    col=""String_Node_Str"" + Integer.toString(so.getNumber());
  }
  String max=dao.doMaxQuery(col,tableName,id);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + max));
  return max;
}",0.9108341323106424
52460,"/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    dao.deleteCommunityMappings(item.getID());
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      dao.insertCommunityMappings(item.getID());
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        boolean itemMapped=false;
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  int distinctID=dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal);
                  if (!dao.updateDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID))                   dao.createDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID);
                  itemMapped=true;
                }
              }
            }
          }
        }
        if (!itemMapped)         removeIndex(item.getID(),bis[i].getMapTableName());
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        boolean itemMapped=false;
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  int distinctID=dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal);
                  if (!dao.updateDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID))                   dao.createDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID);
                  itemMapped=true;
                }
              }
            }
          }
        }
        if (!itemMapped)         removeIndex(item.getID(),bis[i].getMapTableName());
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9617823479005998
52461,"protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws java.sql.SQLException, javax.servlet.ServletException, java.io.IOException, AuthorizeException {
  ItemDAO itemDAO=ItemDAOFactory.getInstance(context);
  CollectionDAO collectionDAO=CollectionDAOFactory.getInstance(context);
  String jspPage=null;
  int myID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Collection myCollection=collectionDAO.retrieve(myID);
  AuthorizeManager.authorizeAction(context,myCollection,Constants.COLLECTION_ADMIN);
  String action=request.getParameter(""String_Node_Str"");
  if (action == null) {
    action=""String_Node_Str"";
  }
  String cancel=request.getParameter(""String_Node_Str"");
  if (cancel == null) {
    cancel=""String_Node_Str"";
  }
  if (action.equals(""String_Node_Str"") || !cancel.equals(""String_Node_Str"")) {
    int count_native=0;
    int count_import=0;
    Map myItems=new HashMap();
    Map myCollections=new HashMap();
    Map myCounts=new HashMap();
    ItemIterator i=myCollection.getItems();
    while (i.hasNext()) {
      Item myItem=i.next();
      Integer myKey=new Integer(myItem.getID());
      if (myItem.isOwningCollection(myCollection)) {
        count_native++;
      }
 else {
        count_import++;
      }
      Collection owningCollection=myItem.getOwningCollection();
      Integer cKey=new Integer(owningCollection.getID());
      if (myCollections.containsKey(cKey)) {
        Integer x=(Integer)myCounts.get(cKey);
        int myCount=x.intValue() + 1;
        myCounts.put(cKey,new Integer(myCount));
      }
 else {
        myCollections.put(cKey,owningCollection);
        myCounts.put(cKey,new Integer(1));
      }
      myItems.put(myKey,myItem);
    }
    myCollections.remove(new Integer(myCollection.getID()));
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",new Integer(count_native));
    request.setAttribute(""String_Node_Str"",new Integer(count_import));
    request.setAttribute(""String_Node_Str"",myItems);
    request.setAttribute(""String_Node_Str"",myCollections);
    request.setAttribute(""String_Node_Str"",myCounts);
    request.setAttribute(""String_Node_Str"",Collection.findAll(context));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList removedItems=new LinkedList();
    for (int j=0; j < itemIDs.length; j++) {
      int i=Integer.parseInt(itemIDs[j]);
      removedItems.add(itemIDs[j]);
      Item myItem=itemDAO.retrieve(i);
      if (!myItem.isOwningCollection(myCollection)) {
        myCollection.removeItem(myItem);
        try {
          IndexBrowse ib=new IndexBrowse(context);
          ib.itemChanged(myItem);
        }
 catch (        BrowseException e) {
          log.error(""String_Node_Str"",e);
          throw new ServletException(e);
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",removedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList addedItems=new LinkedList();
    if (itemIDs == null) {
      message=""String_Node_Str"";
    }
 else {
      for (int j=0; j < itemIDs.length; j++) {
        int i=Integer.parseInt(itemIDs[j]);
        Item myItem=itemDAO.retrieve(i);
        if (AuthorizeManager.authorizeActionBoolean(context,myItem,Constants.READ)) {
          if (!myItem.isOwningCollection(myCollection)) {
            myCollection.addItem(myItem);
            try {
              IndexBrowse ib=new IndexBrowse(context);
              ib.itemChanged(myItem);
            }
 catch (            BrowseException e) {
              log.error(""String_Node_Str"",e);
              throw new ServletException(e);
            }
            addedItems.add(itemIDs[j]);
          }
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",addedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String name=(String)request.getParameter(""String_Node_Str"");
    String bidx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (bidx == null) {
      throw new ServletException(""String_Node_Str"");
    }
    Map items=new HashMap();
    try {
      BrowserScope bs=new BrowserScope(context);
      BrowseIndex bi=BrowseIndex.getBrowseIndex(bidx);
      bs.setBrowseIndex(bi);
      bs.setOrder(SortOption.ASCENDING);
      bs.setFilterValue(name);
      bs.setFilterValuePartial(true);
      bs.setJumpToValue(null);
      bs.setResultsPerPage(10000);
      bs.setSortBy(0);
      bs.setBrowseLevel(1);
      BrowseEngine be=new BrowseEngine(context);
      BrowseInfo results=be.browse(bs);
      Item[] browseItems=results.getBrowseItemResults(context);
      ItemIterator itr=myCollection.getItems();
      ArrayList idslist=new ArrayList();
      while (itr.hasNext()) {
        idslist.add(new Integer(itr.nextID()));
      }
      for (int i=0; i < browseItems.length; i++) {
        if (!idslist.contains(new Integer(browseItems[i].getID()))) {
          if (AuthorizeManager.authorizeActionBoolean(context,browseItems[i],Constants.READ)) {
            items.put(new Integer(browseItems[i].getID()),browseItems[i]);
          }
        }
      }
    }
 catch (    BrowseException e) {
      log.error(""String_Node_Str"",e);
      throw new ServletException(e);
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",name);
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    int t=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection targetCollection=collectionDAO.retrieve(t);
    ItemIterator i=myCollection.getItems();
    Map items=new HashMap();
    while (i.hasNext()) {
      Item myItem=i.next();
      if (myItem.isOwningCollection(targetCollection)) {
        Integer myKey=new Integer(myItem.getID());
        items.put(myKey,myItem);
      }
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",targetCollection.getMetadata(""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
  context.complete();
}","protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws java.sql.SQLException, javax.servlet.ServletException, java.io.IOException, AuthorizeException {
  ItemDAO itemDAO=ItemDAOFactory.getInstance(context);
  CollectionDAO collectionDAO=CollectionDAOFactory.getInstance(context);
  String jspPage=null;
  int myID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Collection myCollection=collectionDAO.retrieve(myID);
  AuthorizeManager.authorizeAction(context,myCollection,Constants.COLLECTION_ADMIN);
  String action=request.getParameter(""String_Node_Str"");
  if (action == null) {
    action=""String_Node_Str"";
  }
  String cancel=request.getParameter(""String_Node_Str"");
  if (cancel == null) {
    cancel=""String_Node_Str"";
  }
  if (action.equals(""String_Node_Str"") || !cancel.equals(""String_Node_Str"")) {
    int count_native=0;
    int count_import=0;
    Map myItems=new HashMap();
    Map myCollections=new HashMap();
    Map myCounts=new HashMap();
    ItemIterator i=myCollection.getItems();
    while (i.hasNext()) {
      Item myItem=i.next();
      Integer myKey=new Integer(myItem.getID());
      if (myItem.isOwningCollection(myCollection)) {
        count_native++;
      }
 else {
        count_import++;
      }
      Collection owningCollection=myItem.getOwningCollection();
      Integer cKey=new Integer(owningCollection.getID());
      if (myCollections.containsKey(cKey)) {
        Integer x=(Integer)myCounts.get(cKey);
        int myCount=x.intValue() + 1;
        myCounts.put(cKey,new Integer(myCount));
      }
 else {
        myCollections.put(cKey,owningCollection);
        myCounts.put(cKey,new Integer(1));
      }
      myItems.put(myKey,myItem);
    }
    myCollections.remove(new Integer(myCollection.getID()));
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",new Integer(count_native));
    request.setAttribute(""String_Node_Str"",new Integer(count_import));
    request.setAttribute(""String_Node_Str"",myItems);
    request.setAttribute(""String_Node_Str"",myCollections);
    request.setAttribute(""String_Node_Str"",myCounts);
    request.setAttribute(""String_Node_Str"",Collection.findAll(context));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList removedItems=new LinkedList();
    for (int j=0; j < itemIDs.length; j++) {
      int i=Integer.parseInt(itemIDs[j]);
      removedItems.add(itemIDs[j]);
      Item myItem=itemDAO.retrieve(i);
      if (!myItem.isOwningCollection(myCollection)) {
        myCollection.removeItem(myItem);
        try {
          IndexBrowse ib=new IndexBrowse(context);
          ib.itemChanged(myItem);
        }
 catch (        BrowseException e) {
          log.error(""String_Node_Str"",e);
          throw new ServletException(e);
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",removedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList addedItems=new LinkedList();
    if (itemIDs == null) {
      message=""String_Node_Str"";
    }
 else {
      for (int j=0; j < itemIDs.length; j++) {
        int i=Integer.parseInt(itemIDs[j]);
        Item myItem=itemDAO.retrieve(i);
        if (AuthorizeManager.authorizeActionBoolean(context,myItem,Constants.READ)) {
          if (!myItem.isOwningCollection(myCollection)) {
            myCollection.addItem(myItem);
            try {
              IndexBrowse ib=new IndexBrowse(context);
              ib.itemChanged(myItem);
            }
 catch (            BrowseException e) {
              log.error(""String_Node_Str"",e);
              throw new ServletException(e);
            }
            addedItems.add(itemIDs[j]);
          }
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",addedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String name=(String)request.getParameter(""String_Node_Str"");
    String bidx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (bidx == null) {
      throw new ServletException(""String_Node_Str"");
    }
    Map items=new HashMap();
    try {
      BrowserScope bs=new BrowserScope(context);
      BrowseIndex bi=BrowseIndex.getBrowseIndex(bidx);
      bs.setBrowseIndex(bi);
      bs.setOrder(SortOption.ASCENDING);
      bs.setFilterValue(name);
      bs.setFilterValuePartial(true);
      bs.setJumpToValue(null);
      bs.setResultsPerPage(10000);
      bs.setBrowseLevel(1);
      BrowseEngine be=new BrowseEngine(context);
      BrowseInfo results=be.browse(bs);
      Item[] browseItems=results.getBrowseItemResults(context);
      ItemIterator itr=myCollection.getItems();
      ArrayList idslist=new ArrayList();
      while (itr.hasNext()) {
        idslist.add(new Integer(itr.nextID()));
      }
      for (int i=0; i < browseItems.length; i++) {
        if (!idslist.contains(new Integer(browseItems[i].getID()))) {
          if (AuthorizeManager.authorizeActionBoolean(context,browseItems[i],Constants.READ)) {
            items.put(new Integer(browseItems[i].getID()),browseItems[i]);
          }
        }
      }
    }
 catch (    BrowseException e) {
      log.error(""String_Node_Str"",e);
      throw new ServletException(e);
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",name);
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    int t=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection targetCollection=collectionDAO.retrieve(t);
    ItemIterator i=myCollection.getItems();
    Map items=new HashMap();
    while (i.hasNext()) {
      Item myItem=i.next();
      if (myItem.isOwningCollection(targetCollection)) {
        Integer myKey=new Integer(myItem.getID());
        items.put(myKey,myItem);
      }
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",targetCollection.getMetadata(""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
  context.complete();
}",0.9983700659060308
52462,"/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getHandle();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getHandle();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}","/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getHandle();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getHandle();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi != null && bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}",0.9913283405597162
52463,"/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        boolean itemMapped=false;
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  int distinctID=dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal);
                  if (!dao.updateDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID))                   dao.createDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID);
                  itemMapped=true;
                }
              }
            }
          }
        }
        if (!itemMapped)         removeIndex(item.getID(),bis[i].getMapTableName());
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        Set<Integer> distIDSet=new HashSet<Integer>();
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal));
                }
              }
            }
          }
        }
        if (distIDSet.isEmpty()) {
          removeIndex(item.getID(),bis[i].getMapTableName());
        }
 else {
          int[] distIDarr=new int[distIDSet.size()];
          int didx=0;
          for (          Integer distID : distIDSet) {
            distIDarr[didx++]=distID;
          }
          dao.updateDistinctMappings(bis[i].getMapTableName(),item.getID(),distIDarr);
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.8676567656765677
52464,"/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  ItemDAO itemDAO=ItemDAOFactory.getInstance(context);
  try {
    dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
    dao.setAscending(scope.isAscending());
    String focusValue=null;
    String rawFocusValue=null;
    String focusField=browseIndex.getSortField();
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      dao.setJumpToField(focusField);
      dao.setJumpToValue(focusValue);
    }
    String value=null;
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    String orderBy=browseIndex.getSortField();
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    Item next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(Item)results.get(lastIndex);
      results.remove(lastIndex);
    }
    Item prev=null;
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      int prevID=-1;
      if (showLast) {
        prevID=getPreviousPageID(results);
      }
 else {
        prevID=getPreviousPageID(null);
      }
      if (prevID != -1) {
        prev=itemDAO.retrieve(prevID);
      }
    }
    int offset=0;
    int total=getTotalResults();
    int position=-1;
    if (total > 0) {
      if (showLast) {
        position=total - scope.getResultsPerPage();
        if (position < 0)         position=0;
      }
 else {
        position=getPosition(false);
      }
    }
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextItem(next.getID());
    }
    if (prev != null) {
      browseInfo.setPrevItem(prev.getID());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  ItemDAO itemDAO=ItemDAOFactory.getInstance(context);
  try {
    dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
    dao.setAscending(scope.isAscending());
    String focusValue=null;
    String rawFocusValue=null;
    String focusField=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      dao.setJumpToField(focusField);
      dao.setJumpToValue(focusValue);
    }
    String value=null;
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    String orderBy=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    Item next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(Item)results.get(lastIndex);
      results.remove(lastIndex);
    }
    Item prev=null;
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      int prevID=-1;
      if (showLast) {
        prevID=getPreviousPageID(results);
      }
 else {
        prevID=getPreviousPageID(null);
      }
      if (prevID != -1) {
        prev=itemDAO.retrieve(prevID);
      }
    }
    int offset=0;
    int total=getTotalResults();
    int position=-1;
    if (total > 0) {
      if (showLast) {
        position=total - scope.getResultsPerPage();
        if (position < 0)         position=0;
      }
 else {
        position=getPosition(false);
      }
    }
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextItem(next.getID());
    }
    if (prev != null) {
      browseInfo.setPrevItem(prev.getID());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9952065738415888
52465,"/** 
 * Perform a limited browse, which only returns the results requested,  without any extraneous information.  To perform a full browse, use BrowseEngine.browse() above.  This supports Item browse only, and does not currently support focus or values.  This method is used, for example, to generate the Recently Submitted Items results.
 * @param bs	the scope of the browse
 * @return		the results of the browse
 */
public BrowseInfo browseMini(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
  dao.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    if (scope.inCollection()) {
      Collection col=(Collection)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(col.getID());
    }
 else     if (scope.inCommunity()) {
      Community com=(Community)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(com.getID());
    }
  }
  dao.setLimit(scope.getResultsPerPage());
  String orderBy=browseIndex.getSortField();
  if (scope.getSortBy() > 0) {
    orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
  }
  dao.setOrderField(orderBy);
  List results=dao.doQuery();
  BrowseInfo browseInfo=new BrowseInfo(results,0,scope.getResultsPerPage(),0);
  browseInfo.setBrowseIndex(browseIndex);
  browseInfo.setSortOption(scope.getSortOption());
  browseInfo.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    browseInfo.setBrowseContainer(scope.getBrowseContainer());
  }
  browseInfo.setResultsPerPage(scope.getResultsPerPage());
  browseInfo.setEtAl(scope.getEtAl());
  return browseInfo;
}","/** 
 * Perform a limited browse, which only returns the results requested,  without any extraneous information.  To perform a full browse, use BrowseEngine.browse() above.  This supports Item browse only, and does not currently support focus or values.  This method is used, for example, to generate the Recently Submitted Items results.
 * @param bs	the scope of the browse
 * @return		the results of the browse
 */
public BrowseInfo browseMini(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
  dao.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    if (scope.inCollection()) {
      Collection col=(Collection)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(col.getID());
    }
 else     if (scope.inCommunity()) {
      Community com=(Community)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(com.getID());
    }
  }
  dao.setLimit(scope.getResultsPerPage());
  String orderBy=browseIndex.getSortField(scope.isSecondLevel());
  if (scope.getSortBy() > 0) {
    orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
  }
  dao.setOrderField(orderBy);
  List results=dao.doQuery();
  BrowseInfo browseInfo=new BrowseInfo(results,0,scope.getResultsPerPage(),0);
  browseInfo.setBrowseIndex(browseIndex);
  browseInfo.setSortOption(scope.getSortOption());
  browseInfo.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    browseInfo.setBrowseContainer(scope.getBrowseContainer());
  }
  browseInfo.setResultsPerPage(scope.getResultsPerPage());
  browseInfo.setEtAl(scope.getEtAl());
  return browseInfo;
}",0.994492525570417
52466,"/** 
 * Get the field for sorting associated with this index
 * @return
 * @throws BrowseException
 */
public String getSortField() throws BrowseException {
  String focusField;
  if (isMetadataIndex()) {
    focusField=""String_Node_Str"";
  }
 else {
    if (sortOption != null)     focusField=""String_Node_Str"" + sortOption.getNumber();
 else     focusField=""String_Node_Str"";
  }
  return focusField;
}","/** 
 * Get the field for sorting associated with this index
 * @return
 * @throws BrowseException
 */
public String getSortField(boolean isSecondLevel) throws BrowseException {
  String focusField;
  if (isMetadataIndex() && !isSecondLevel) {
    focusField=""String_Node_Str"";
  }
 else {
    if (sortOption != null)     focusField=""String_Node_Str"" + sortOption.getNumber();
 else     focusField=""String_Node_Str"";
  }
  return focusField;
}",0.9539551357733176
52467,"/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getIdentifier().getCanonicalForm();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getIdentifier().getCanonicalForm();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}","/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getIdentifier().getCanonicalForm();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getIdentifier().getCanonicalForm();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}",0.988626248640095
52468,"/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
    dao.setAscending(scope.isAscending());
    String focusValue=null;
    String rawFocusValue=null;
    String focusField=browseIndex.getSortField();
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      dao.setJumpToField(focusField);
      dao.setJumpToValue(focusValue);
    }
    String value=null;
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    String orderBy=browseIndex.getSortField();
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    BrowseItem next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(BrowseItem)results.get(lastIndex);
      results.remove(lastIndex);
    }
    BrowseItem prev=null;
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      int prevID=-1;
      if (showLast) {
        prevID=getPreviousPageID(results);
      }
 else {
        prevID=getPreviousPageID(null);
      }
      if (prevID != -1) {
        if (bs.getBrowseIndex() == BrowseIndex.getWithdrawnBrowseIndex())         prev=new BrowseItem(context,prevID,false,true);
 else         prev=new BrowseItem(context,prevID,true,false);
      }
    }
    int offset=0;
    int total=getTotalResults();
    int position=-1;
    if (total > 0) {
      if (showLast) {
        position=total - scope.getResultsPerPage();
        if (position < 0)         position=0;
      }
 else {
        position=getPosition(false);
      }
    }
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextItem(next.getID());
    }
    if (prev != null) {
      browseInfo.setPrevItem(prev.getID());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
    dao.setAscending(scope.isAscending());
    String focusValue=null;
    String rawFocusValue=null;
    String focusField=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      dao.setJumpToField(focusField);
      dao.setJumpToValue(focusValue);
    }
    String value=null;
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    String orderBy=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    BrowseItem next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(BrowseItem)results.get(lastIndex);
      results.remove(lastIndex);
    }
    BrowseItem prev=null;
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      int prevID=-1;
      if (showLast) {
        prevID=getPreviousPageID(results);
      }
 else {
        prevID=getPreviousPageID(null);
      }
      if (prevID != -1) {
        if (bs.getBrowseIndex() == BrowseIndex.getWithdrawnBrowseIndex())         prev=new BrowseItem(context,prevID,false,true);
 else         prev=new BrowseItem(context,prevID,true,false);
      }
    }
    int offset=0;
    int total=getTotalResults();
    int position=-1;
    if (total > 0) {
      if (showLast) {
        position=total - scope.getResultsPerPage();
        if (position < 0)         position=0;
      }
 else {
        position=getPosition(false);
      }
    }
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextItem(next.getID());
    }
    if (prev != null) {
      browseInfo.setPrevItem(prev.getID());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9953302201467644
52469,"/** 
 * Perform a limited browse, which only returns the results requested,  without any extraneous information.  To perform a full browse, use BrowseEngine.browse() above.  This supports Item browse only, and does not currently support focus or values.  This method is used, for example, to generate the Recently Submitted Items results.
 * @param bs	the scope of the browse
 * @return		the results of the browse
 */
public BrowseInfo browseMini(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
  dao.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    if (scope.inCollection()) {
      Collection col=(Collection)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(col.getID());
    }
 else     if (scope.inCommunity()) {
      Community com=(Community)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(com.getID());
    }
  }
  dao.setLimit(scope.getResultsPerPage());
  String orderBy=browseIndex.getSortField();
  if (scope.getSortBy() > 0) {
    orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
  }
  dao.setOrderField(orderBy);
  List results=dao.doQuery();
  BrowseInfo browseInfo=new BrowseInfo(results,0,scope.getResultsPerPage(),0);
  browseInfo.setBrowseIndex(browseIndex);
  browseInfo.setSortOption(scope.getSortOption());
  browseInfo.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    browseInfo.setBrowseContainer(scope.getBrowseContainer());
  }
  browseInfo.setResultsPerPage(scope.getResultsPerPage());
  browseInfo.setEtAl(scope.getEtAl());
  return browseInfo;
}","/** 
 * Perform a limited browse, which only returns the results requested,  without any extraneous information.  To perform a full browse, use BrowseEngine.browse() above.  This supports Item browse only, and does not currently support focus or values.  This method is used, for example, to generate the Recently Submitted Items results.
 * @param bs	the scope of the browse
 * @return		the results of the browse
 */
public BrowseInfo browseMini(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
  dao.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    if (scope.inCollection()) {
      Collection col=(Collection)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(col.getID());
    }
 else     if (scope.inCommunity()) {
      Community com=(Community)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(com.getID());
    }
  }
  dao.setLimit(scope.getResultsPerPage());
  String orderBy=browseIndex.getSortField(scope.isSecondLevel());
  if (scope.getSortBy() > 0) {
    orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
  }
  dao.setOrderField(orderBy);
  List results=dao.doQuery();
  BrowseInfo browseInfo=new BrowseInfo(results,0,scope.getResultsPerPage(),0);
  browseInfo.setBrowseIndex(browseIndex);
  browseInfo.setSortOption(scope.getSortOption());
  browseInfo.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    browseInfo.setBrowseContainer(scope.getBrowseContainer());
  }
  browseInfo.setResultsPerPage(scope.getResultsPerPage());
  browseInfo.setEtAl(scope.getEtAl());
  return browseInfo;
}",0.994492525570417
52470,"/** 
 * Get the field for sorting associated with this index
 * @return
 * @throws BrowseException
 */
public String getSortField() throws BrowseException {
  String focusField;
  if (isMetadataIndex()) {
    focusField=""String_Node_Str"";
  }
 else {
    if (sortOption != null)     focusField=""String_Node_Str"" + sortOption.getNumber();
 else     focusField=""String_Node_Str"";
  }
  return focusField;
}","/** 
 * Get the field for sorting associated with this index
 * @return
 * @throws BrowseException
 */
public String getSortField(boolean isSecondLevel) throws BrowseException {
  String focusField;
  if (isMetadataIndex() && !isSecondLevel) {
    focusField=""String_Node_Str"";
  }
 else {
    if (sortOption != null)     focusField=""String_Node_Str"" + sortOption.getNumber();
 else     focusField=""String_Node_Str"";
  }
  return focusField;
}",0.9539551357733176
52471,"/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getHandle();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getHandle();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}","/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getHandle();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getHandle();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}",0.988521808563729
52472,"/** 
 * Get a sub-query to obtain the ids for a distinct browse within a given constraint.  This will produce something of the form: <code> id IN (SELECT distinct_id FROM [container table] WHERE [container field] = [container id]) </code> This is for use inside the overall WHERE clause only
 * @return  the sub-query
 */
private void buildWhereClauseDistinctConstraints(StringBuffer queryBuf,List params){
  if (containerIDField != null && containerID != -1 && containerTable != null) {
    buildWhereClauseOpInsert(queryBuf);
    queryBuf.append(""String_Node_Str"");
    queryBuf.append(containerTable);
    queryBuf.append(""String_Node_Str"");
    queryBuf.append(containerIDField);
    queryBuf.append(""String_Node_Str"" + table + ""String_Node_Str"");
    params.add(new Integer(containerID));
  }
}","/** 
 * Get a sub-query to obtain the ids for a distinct browse within a given constraint.  This will produce something of the form: <code> id IN (SELECT distinct_id FROM [container table] WHERE [container field] = [container id]) </code> This is for use inside the overall WHERE clause only
 * @return  the sub-query
 */
private void buildWhereClauseDistinctConstraints(StringBuffer queryBuf,List params){
  if (containerIDField != null && containerID != -1 && containerTable != null) {
    buildWhereClauseOpInsert(queryBuf);
    queryBuf.append(""String_Node_Str"");
    buildFocusedSelectTables(queryBuf);
    queryBuf.append(""String_Node_Str"");
    buildFocusedSelectClauses(queryBuf,params);
    queryBuf.append(""String_Node_Str"" + table + ""String_Node_Str"");
  }
}",0.8112244897959183
52473,"/** 
 * Get the count of the items in the given container.  If the configuration value webui.strengths.cache is equal to 'true' this will return the cached value if it exists.  If it is equal to 'false' it will count the number of items in the container in real time
 * @param dso
 * @return
 * @throws ItemCountException
 * @throws SQLException 
 */
public int getCount(DSpaceObject dso) throws ItemCountException {
  boolean useCache=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
  if (useCache) {
    return dao.getCount(dso);
  }
  if (dso instanceof Collection) {
    return ((Collection)dso).countItems();
  }
  if (dso instanceof Community) {
    return ((Collection)dso).countItems();
  }
  return 0;
}","/** 
 * Get the count of the items in the given container.  If the configuration value webui.strengths.cache is equal to 'true' this will return the cached value if it exists.  If it is equal to 'false' it will count the number of items in the container in real time
 * @param dso
 * @return
 * @throws ItemCountException
 * @throws SQLException 
 */
public int getCount(DSpaceObject dso) throws ItemCountException {
  boolean useCache=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
  if (useCache) {
    return dao.getCount(dso);
  }
  if (dso instanceof Collection) {
    return ((Collection)dso).countItems();
  }
  if (dso instanceof Community) {
    return ((Community)dso).countItems();
  }
  return 0;
}",0.9896337249481686
52474,"/** 
 * Create Lucene document with all the shared fields initialized.
 * @param type Type of DSpace Object
 * @param id
 * @param uri
 * @param location
 * @return
 */
private static Document buildDocument(int type,int id,String uri,String location){
  Document doc=new Document();
  doc.add(new Field(LAST_INDEXED_FIELD,Long.toString(System.currentTimeMillis()),Field.Store.YES,Field.Index.UN_TOKENIZED));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.NO));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.NO));
  doc.add(new Field(""String_Node_Str"",Integer.toString(id),Field.Store.YES,Field.Index.NO));
  if (uri != null) {
    doc.add(new Field(""String_Node_Str"",uri,Field.Store.YES,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",uri,Field.Store.YES,Field.Index.UN_TOKENIZED));
    doc.add(new Field(""String_Node_Str"",uri,Field.Store.NO,Field.Index.TOKENIZED));
  }
  if (location != null) {
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
  }
  return doc;
}","/** 
 * Create Lucene document with all the shared fields initialized.
 * @param type Type of DSpace Object
 * @param id
 * @param uri
 * @param location
 * @return
 */
private static Document buildDocument(int type,int id,String uri,String location){
  Document doc=new Document();
  doc.add(new Field(LAST_INDEXED_FIELD,Long.toString(System.currentTimeMillis()),Field.Store.YES,Field.Index.UN_TOKENIZED));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.NO));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.UN_TOKENIZED));
  doc.add(new Field(""String_Node_Str"",Integer.toString(id),Field.Store.YES,Field.Index.NO));
  if (uri != null) {
    doc.add(new Field(""String_Node_Str"",uri,Field.Store.YES,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",uri,Field.Store.YES,Field.Index.UN_TOKENIZED));
    doc.add(new Field(""String_Node_Str"",uri,Field.Store.NO,Field.Index.TOKENIZED));
  }
  if (location != null) {
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
  }
  return doc;
}",0.7960033305578684
52475,"/** 
 * Read metadata about a table from the database.
 * @param table The RDBMS table.
 * @return A map of information about the columns. The key is the name ofthe column, a String; the value is a ColumnInfo object.
 * @exception SQLException If there is a problem retrieving information from the RDBMS.
 */
private static Map retrieveColumnInfo(String table) throws SQLException {
  Connection connection=null;
  try {
    connection=getConnection();
    DatabaseMetaData metadata=connection.getMetaData();
    HashMap results=new HashMap();
    int max=metadata.getMaxTableNameLength();
    String tname=(table.length() >= max) ? table.substring(0,max - 1) : table;
    ResultSet pkcolumns=metadata.getPrimaryKeys(null,null,tname);
    Set pks=new HashSet();
    while (pkcolumns.next())     pks.add(pkcolumns.getString(4));
    ResultSet columns=metadata.getColumns(null,null,tname,null);
    while (columns.next()) {
      String column=columns.getString(4);
      ColumnInfo cinfo=new ColumnInfo();
      cinfo.setName(column);
      cinfo.setType((int)columns.getShort(5));
      if (pks.contains(column)) {
        cinfo.setIsPrimaryKey(true);
      }
      results.put(column,cinfo);
    }
    return results;
  }
  finally {
    if (connection != null) {
      connection.close();
    }
  }
}","/** 
 * Read metadata about a table from the database.
 * @param table The RDBMS table.
 * @return A map of information about the columns. The key is the name ofthe column, a String; the value is a ColumnInfo object.
 * @exception SQLException If there is a problem retrieving information from the RDBMS.
 */
private static Map retrieveColumnInfo(String table) throws SQLException {
  Connection connection=null;
  try {
    String schema=ConfigurationManager.getProperty(""String_Node_Str"");
    connection=getConnection();
    DatabaseMetaData metadata=connection.getMetaData();
    HashMap results=new HashMap();
    int max=metadata.getMaxTableNameLength();
    String tname=(table.length() >= max) ? table.substring(0,max - 1) : table;
    ResultSet pkcolumns=metadata.getPrimaryKeys(null,schema,tname);
    Set pks=new HashSet();
    while (pkcolumns.next())     pks.add(pkcolumns.getString(4));
    ResultSet columns=metadata.getColumns(null,schema,tname,null);
    while (columns.next()) {
      String column=columns.getString(4);
      ColumnInfo cinfo=new ColumnInfo();
      cinfo.setName(column);
      cinfo.setType((int)columns.getShort(5));
      if (pks.contains(column)) {
        cinfo.setIsPrimaryKey(true);
      }
      results.put(column,cinfo);
    }
    return results;
  }
  finally {
    if (connection != null) {
      connection.close();
    }
  }
}",0.9660321015304218
52476,"/** 
 * Read metadata about a table from the database.
 * @param table The RDBMS table.
 * @return A map of information about the columns. The key is the name ofthe column, a String; the value is a ColumnInfo object.
 * @exception SQLException If there is a problem retrieving information from the RDBMS.
 */
private static Map retrieveColumnInfo(String table) throws SQLException {
  Connection connection=null;
  try {
    connection=getConnection();
    DatabaseMetaData metadata=connection.getMetaData();
    HashMap results=new HashMap();
    int max=metadata.getMaxTableNameLength();
    String tname=(table.length() >= max) ? table.substring(0,max - 1) : table;
    ResultSet pkcolumns=metadata.getPrimaryKeys(null,null,tname);
    Set pks=new HashSet();
    while (pkcolumns.next())     pks.add(pkcolumns.getString(4));
    ResultSet columns=metadata.getColumns(null,null,tname,null);
    while (columns.next()) {
      String column=columns.getString(4);
      ColumnInfo cinfo=new ColumnInfo();
      cinfo.setName(column);
      cinfo.setType((int)columns.getShort(5));
      if (pks.contains(column)) {
        cinfo.setIsPrimaryKey(true);
      }
      results.put(column,cinfo);
    }
    return results;
  }
  finally {
    if (connection != null) {
      connection.close();
    }
  }
}","/** 
 * Read metadata about a table from the database.
 * @param table The RDBMS table.
 * @return A map of information about the columns. The key is the name ofthe column, a String; the value is a ColumnInfo object.
 * @exception SQLException If there is a problem retrieving information from the RDBMS.
 */
private static Map retrieveColumnInfo(String table) throws SQLException {
  Connection connection=null;
  try {
    String schema=ConfigurationManager.getProperty(""String_Node_Str"");
    connection=getConnection();
    DatabaseMetaData metadata=connection.getMetaData();
    HashMap results=new HashMap();
    int max=metadata.getMaxTableNameLength();
    String tname=(table.length() >= max) ? table.substring(0,max - 1) : table;
    ResultSet pkcolumns=metadata.getPrimaryKeys(null,schema,tname);
    Set pks=new HashSet();
    while (pkcolumns.next())     pks.add(pkcolumns.getString(4));
    ResultSet columns=metadata.getColumns(null,schema,tname,null);
    while (columns.next()) {
      String column=columns.getString(4);
      ColumnInfo cinfo=new ColumnInfo();
      cinfo.setName(column);
      cinfo.setType((int)columns.getShort(5));
      if (pks.contains(column)) {
        cinfo.setIsPrimaryKey(true);
      }
      results.put(column,cinfo);
    }
    return results;
  }
  finally {
    if (connection != null) {
      connection.close();
    }
  }
}",0.9660321015304218
52477,"/** 
 * Create Lucene document with all the shared fields initialized.
 * @param type Type of DSpace Object
 * @param id
 * @param handle
 * @param location @return
 */
private static Document buildDocument(int type,int id,String handle,String location){
  Document doc=new Document();
  doc.add(new Field(LAST_INDEXED_FIELD,Long.toString(System.currentTimeMillis()),Field.Store.YES,Field.Index.UN_TOKENIZED));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.NO));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.NO));
  doc.add(new Field(""String_Node_Str"",Integer.toString(id),Field.Store.YES,Field.Index.NO));
  if (handle != null) {
    doc.add(new Field(""String_Node_Str"",handle,Field.Store.YES,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",handle,Field.Store.YES,Field.Index.UN_TOKENIZED));
    doc.add(new Field(""String_Node_Str"",handle,Field.Store.NO,Field.Index.TOKENIZED));
  }
  if (location != null) {
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
  }
  return doc;
}","/** 
 * Create Lucene document with all the shared fields initialized.
 * @param type Type of DSpace Object
 * @param id
 * @param handle
 * @param location @return
 */
private static Document buildDocument(int type,int id,String handle,String location){
  Document doc=new Document();
  doc.add(new Field(LAST_INDEXED_FIELD,Long.toString(System.currentTimeMillis()),Field.Store.YES,Field.Index.UN_TOKENIZED));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.NO));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.UN_TOKENIZED));
  doc.add(new Field(""String_Node_Str"",Integer.toString(id),Field.Store.YES,Field.Index.NO));
  if (handle != null) {
    doc.add(new Field(""String_Node_Str"",handle,Field.Store.YES,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",handle,Field.Store.YES,Field.Index.UN_TOKENIZED));
    doc.add(new Field(""String_Node_Str"",handle,Field.Store.NO,Field.Index.TOKENIZED));
  }
  if (location != null) {
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
  }
  return doc;
}",0.7960526315789473
52478,"/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  if (buttonPressed.startsWith(PROGRESS_BAR_PREFIX)) {
    return STATUS_COMPLETE;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    if (buttonPressed.equals(CANCEL_EDIT_BUTTON)) {
      subInfo.setBitstream(null);
      return STATUS_EDIT_COMPLETE;
    }
 else {
      Bitstream b=Bitstream.find(context,Integer.parseInt(request.getParameter(""String_Node_Str"")));
      subInfo.setBitstream(b);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    String bitstreamID=buttonPressed.substring(""String_Node_Str"".length());
    Bitstream b=Bitstream.find(context,Integer.parseInt(bitstreamID));
    subInfo.setBitstream(b);
    return STATUS_EDIT_BITSTREAM;
  }
  if (buttonPressed.equalsIgnoreCase(""String_Node_Str"")) {
    if (request.getParameter(""String_Node_Str"") != null) {
      String[] removeIDs=request.getParameterValues(""String_Node_Str"");
      for (int i=0; i < removeIDs.length; i++) {
        int id=Integer.parseInt(removeIDs[i]);
        int status=processRemoveFile(context,item,id);
        if (status != STATUS_COMPLETE)         return status;
      }
      subInfo.setBitstream(null);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    int id=Integer.parseInt(buttonPressed.substring(14));
    int status=processRemoveFile(context,item,id);
    if (status != STATUS_COMPLETE)     return status;
    subInfo.setBitstream(null);
  }
  String contentType=request.getContentType();
  if (buttonPressed.equalsIgnoreCase(SUBMIT_UPLOAD_BUTTON)) {
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
      int status=processUploadFile(context,request,response,subInfo);
      if (status != STATUS_COMPLETE)       return status;
    }
  }
  String fileDescription=request.getParameter(""String_Node_Str"");
  if (fileDescription != null && fileDescription.length() > 0) {
    int status=processSaveFileDescription(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  int formatTypeID=Util.getIntParameter(request,""String_Node_Str"");
  String formatDesc=request.getParameter(""String_Node_Str"");
  if (formatTypeID >= 0 || (formatDesc != null && formatDesc.length() > 0)) {
    int status=processSaveFileFormat(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    bundles[0].setPrimaryBitstreamID(new Integer(request.getParameter(""String_Node_Str"")).intValue());
    bundles[0].update();
  }
  boolean allowEmptyItems=(request.getParameter(SUBMIT_SKIP_BUTTON) != null);
  if (!allowEmptyItems) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    if (bundles.length == 0) {
      return STATUS_NO_FILES_ERROR;
    }
 else {
      Bitstream[] bitstreams=bundles[0].getBitstreams();
      if (bitstreams.length == 0) {
        return STATUS_NO_FILES_ERROR;
      }
    }
  }
  context.commit();
  return STATUS_COMPLETE;
}","/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  if (buttonPressed.startsWith(PROGRESS_BAR_PREFIX)) {
    return STATUS_COMPLETE;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    if (buttonPressed.equals(CANCEL_EDIT_BUTTON)) {
      subInfo.setBitstream(null);
      return STATUS_EDIT_COMPLETE;
    }
 else {
      Bitstream b=Bitstream.find(context,Integer.parseInt(request.getParameter(""String_Node_Str"")));
      subInfo.setBitstream(b);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    String bitstreamID=buttonPressed.substring(""String_Node_Str"".length());
    Bitstream b=Bitstream.find(context,Integer.parseInt(bitstreamID));
    subInfo.setBitstream(b);
    return STATUS_EDIT_BITSTREAM;
  }
  if (buttonPressed.equalsIgnoreCase(""String_Node_Str"")) {
    if (request.getParameter(""String_Node_Str"") != null) {
      String[] removeIDs=request.getParameterValues(""String_Node_Str"");
      for (int i=0; i < removeIDs.length; i++) {
        int id=Integer.parseInt(removeIDs[i]);
        int status=processRemoveFile(context,item,id);
        if (status != STATUS_COMPLETE)         return status;
      }
      subInfo.setBitstream(null);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    int id=Integer.parseInt(buttonPressed.substring(14));
    int status=processRemoveFile(context,item,id);
    if (status != STATUS_COMPLETE)     return status;
    subInfo.setBitstream(null);
  }
  String contentType=request.getContentType();
  if (buttonPressed.equalsIgnoreCase(SUBMIT_UPLOAD_BUTTON)) {
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
      int status=processUploadFile(context,request,response,subInfo);
      if (status != STATUS_COMPLETE)       return status;
    }
  }
  String fileDescription=request.getParameter(""String_Node_Str"");
  if (fileDescription != null && fileDescription.length() > 0) {
    int status=processSaveFileDescription(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  int formatTypeID=Util.getIntParameter(request,""String_Node_Str"");
  String formatDesc=request.getParameter(""String_Node_Str"");
  if (formatTypeID >= 0 || (formatDesc != null && formatDesc.length() > 0)) {
    int status=processSaveFileFormat(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    bundles[0].setPrimaryBitstreamID(new Integer(request.getParameter(""String_Node_Str"")).intValue());
    bundles[0].update();
  }
  boolean fileRequired=ConfigurationManager.getBooleanProperty(""String_Node_Str"",true);
  if (fileRequired) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    if (bundles.length == 0) {
      return STATUS_NO_FILES_ERROR;
    }
 else {
      Bitstream[] bitstreams=bundles[0].getBitstreams();
      if (bitstreams.length == 0) {
        return STATUS_NO_FILES_ERROR;
      }
    }
  }
  context.commit();
  return STATUS_COMPLETE;
}",0.9787079603193806
52479,"/** 
 * Do any post-processing after the step's backend processing occurred (in the doProcessing() method). <P> It is this method's job to determine whether processing completed successfully, or display another JSP informing the users of any potential problems/errors. <P> If this step doesn't require user interaction OR you are solely using Manakin for your user interface, then this method may be left EMPTY, since all step processing should occur in the doProcessing() method.
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @param status any status/errors reported by doProcessing() method
 */
public void doPostProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo,int status) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,UploadStep.NEXT_BUTTON);
  if (buttonPressed.equalsIgnoreCase(UploadStep.SUBMIT_SKIP_BUTTON)) {
    Bundle[] bundles=subInfo.getSubmissionItem().getItem().getBundles(""String_Node_Str"");
    if (bundles.length > 0) {
      showUploadFileList(context,request,response,subInfo,true,false);
    }
    return;
  }
  if (buttonPressed.equalsIgnoreCase(""String_Node_Str"")) {
    showUploadPage(context,request,response,subInfo,false);
  }
  if (status != UploadStep.STATUS_COMPLETE) {
    if (status == UploadStep.STATUS_INTEGRITY_ERROR) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
 else     if (status == UploadStep.STATUS_UPLOAD_ERROR || status == UploadStep.STATUS_NO_FILES_ERROR) {
      if (buttonPressed.startsWith(""String_Node_Str"")) {
        showUploadPage(context,request,response,subInfo,false);
      }
 else {
        if (subInfo != null) {
          Collection c=subInfo.getSubmissionItem().getCollection();
          DCInputsReader inputsReader=new DCInputsReader();
          request.setAttribute(""String_Node_Str"",inputsReader.getInputs(c.getHandle()));
        }
        JSPStepManager.showJSP(request,response,subInfo,UPLOAD_ERROR_JSP);
      }
    }
 else     if (status == UploadStep.STATUS_UNKNOWN_FORMAT) {
      showGetFileFormat(context,request,response,subInfo);
    }
  }
  if (status == UploadStep.STATUS_COMPLETE && buttonPressed.equals(UploadStep.NEXT_BUTTON)) {
    return;
  }
  if (buttonPressed.equals(UploadStep.SUBMIT_MORE_BUTTON)) {
    showChooseFile(context,request,response,subInfo);
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    showUploadFileList(context,request,response,subInfo,false,true);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(16));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showFileDescription(context,request,response,subInfo);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(14));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showGetFileFormat(context,request,response,subInfo);
  }
 else {
    String contentType=request.getContentType();
    boolean fileUpload=false;
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1))     fileUpload=true;
    showUploadPage(context,request,response,subInfo,fileUpload);
  }
}","/** 
 * Do any post-processing after the step's backend processing occurred (in the doProcessing() method). <P> It is this method's job to determine whether processing completed successfully, or display another JSP informing the users of any potential problems/errors. <P> If this step doesn't require user interaction OR you are solely using Manakin for your user interface, then this method may be left EMPTY, since all step processing should occur in the doProcessing() method.
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @param status any status/errors reported by doProcessing() method
 */
public void doPostProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo,int status) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,UploadStep.NEXT_BUTTON);
  boolean fileRequired=ConfigurationManager.getBooleanProperty(""String_Node_Str"",true);
  if (buttonPressed.equalsIgnoreCase(UploadStep.SUBMIT_SKIP_BUTTON) || (buttonPressed.equalsIgnoreCase(UploadStep.SUBMIT_UPLOAD_BUTTON) && !fileRequired)) {
    Bundle[] bundles=subInfo.getSubmissionItem().getItem().getBundles(""String_Node_Str"");
    if (bundles.length > 0) {
      showUploadFileList(context,request,response,subInfo,true,false);
    }
    return;
  }
  if (buttonPressed.equalsIgnoreCase(""String_Node_Str"")) {
    showUploadPage(context,request,response,subInfo,false);
  }
  if (status != UploadStep.STATUS_COMPLETE) {
    if (status == UploadStep.STATUS_INTEGRITY_ERROR) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
 else     if (status == UploadStep.STATUS_UPLOAD_ERROR || status == UploadStep.STATUS_NO_FILES_ERROR) {
      if (buttonPressed.startsWith(""String_Node_Str"")) {
        showUploadPage(context,request,response,subInfo,false);
      }
 else {
        if (subInfo != null) {
          Collection c=subInfo.getSubmissionItem().getCollection();
          DCInputsReader inputsReader=new DCInputsReader();
          request.setAttribute(""String_Node_Str"",inputsReader.getInputs(c.getHandle()));
        }
        JSPStepManager.showJSP(request,response,subInfo,UPLOAD_ERROR_JSP);
      }
    }
 else     if (status == UploadStep.STATUS_UNKNOWN_FORMAT) {
      showGetFileFormat(context,request,response,subInfo);
    }
  }
  if (status == UploadStep.STATUS_COMPLETE && buttonPressed.equals(UploadStep.NEXT_BUTTON)) {
    return;
  }
  if (buttonPressed.equals(UploadStep.SUBMIT_MORE_BUTTON)) {
    showChooseFile(context,request,response,subInfo);
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    showUploadFileList(context,request,response,subInfo,false,true);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(16));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showFileDescription(context,request,response,subInfo);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(14));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showGetFileFormat(context,request,response,subInfo);
  }
 else {
    String contentType=request.getContentType();
    boolean fileUpload=false;
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1))     fileUpload=true;
    showUploadPage(context,request,response,subInfo,fileUpload);
  }
}",0.9794520547945206
52480,"public static DSpaceIdentifier resolve(Context context,String str){
  DSpaceIdentifier dsi=null;
  if (dsi == null) {
    dsi=IdentifierFactory.resolveAsURLSubstring(context,str);
  }
  if (dsi == null) {
    dsi=IdentifierFactory.resolve(context,str);
  }
  return dsi;
}","public static DSpaceIdentifier resolve(Context context,String str){
  DSpaceIdentifier dsi=null;
  if (dsi == null) {
    dsi=IdentifierFactory.resolveAsURLSubstring(context,str);
  }
  if (dsi == null) {
    dsi=IdentifierFactory.resolveCanonical(context,str);
  }
  return dsi;
}",0.9837251356238698
52481,"public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      TableRow row=DatabaseManager.create(context,""String_Node_Str"");
      row.setColumn(""String_Node_Str"",itemID);
      row.setColumn(""String_Node_Str"",commID[i]);
      DatabaseManager.update(context,row);
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      if (isFirstOccurrence(commID,i)) {
        TableRow row=DatabaseManager.create(context,""String_Node_Str"");
        row.setColumn(""String_Node_Str"",itemID);
        row.setColumn(""String_Node_Str"",commID[i]);
        DatabaseManager.update(context,row);
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9453499520613614
52482,"public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      TableRow row=DatabaseManager.create(context,""String_Node_Str"");
      row.setColumn(""String_Node_Str"",itemID);
      row.setColumn(""String_Node_Str"",commID[i]);
      DatabaseManager.update(context,row);
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      if (isFirstOccurrence(commID,i)) {
        TableRow row=DatabaseManager.create(context,""String_Node_Str"");
        row.setColumn(""String_Node_Str"",itemID);
        row.setColumn(""String_Node_Str"",commID[i]);
        DatabaseManager.update(context,row);
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9453499520613614
52483,"/** 
 * @deprecated
 * @return
 * @throws BrowseException
 */
public static String[] tables() throws BrowseException {
  BrowseIndex[] bis=getBrowseIndices();
  String[] returnTables=new String[bis.length + 1];
  for (int i=0; i < bis.length; i++) {
    returnTables[i]=bis[i].getTableName();
  }
  returnTables[bis.length]=""String_Node_Str"";
  return returnTables;
}","/** 
 * @deprecated
 * @return
 * @throws BrowseException
 */
public static String[] tables() throws BrowseException {
  BrowseIndex[] bis=getBrowseIndices();
  String[] returnTables=new String[bis.length];
  for (int i=0; i < bis.length; i++) {
    returnTables[i]=bis[i].getTableName();
  }
  return returnTables;
}",0.9064327485380116
52484,"public boolean itemRemoved(int itemID) throws BrowseException {
  for (int i=0; i < bis.length; i++) {
    log.debug(""String_Node_Str"" + itemID + ""String_Node_Str""+ bis[i].getTableName());
    removeIndex(itemID,bis[i]);
  }
  removeIndex(itemID,BrowseIndex.getItemBrowseIndex().getTableName());
  removeIndex(itemID,BrowseIndex.getWithdrawnBrowseIndex().getTableName());
  pruneIndexes();
  return true;
}","public boolean itemRemoved(int itemID) throws BrowseException {
  for (int i=0; i < bis.length; i++) {
    log.debug(""String_Node_Str"" + itemID + ""String_Node_Str""+ bis[i].getTableName());
    removeIndex(itemID,bis[i]);
  }
  removeIndex(itemID,BrowseIndex.getItemBrowseIndex().getTableName());
  removeIndex(itemID,BrowseIndex.getWithdrawnBrowseIndex().getTableName());
  dao.deleteCommunityMappings(itemID);
  pruneIndexes();
  return true;
}",0.954171562867215
52485,"/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
    removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    if (item.isArchived() && !item.isWithdrawn()) {
      Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
      dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
    }
 else     if (item.isWithdrawn()) {
      Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
      dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        removeIndex(item.getID(),bis[i]);
        if (item.isArchived() && !item.isWithdrawn()) {
          String[] md=bis[i].getMdBits();
          DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
          if (values != null) {
            for (int x=0; x < values.length; x++) {
              String nVal=BrowseOrder.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
              Map sortMap=getSortValues(item,itemMDMap);
              dao.insertIndex(bis[i].getTableName(),item.getID(),values[x].value,nVal,sortMap);
              if (bis[i].isMetadataIndex()) {
                int distinctID=dao.getDistinctID(bis[i].getTableName(true,false,false),values[x].value,nVal);
                dao.createDistinctMapping(bis[i].getMapName(),item.getID(),distinctID);
              }
            }
          }
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
    removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    dao.deleteCommunityMappings(item.getID());
    if (item.isArchived() && !item.isWithdrawn()) {
      Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
      dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      dao.insertCommunityMappings(item.getID());
    }
 else     if (item.isWithdrawn()) {
      Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
      dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        removeIndex(item.getID(),bis[i]);
        if (item.isArchived() && !item.isWithdrawn()) {
          String[] md=bis[i].getMdBits();
          DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
          if (values != null) {
            for (int x=0; x < values.length; x++) {
              String nVal=BrowseOrder.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
              Map sortMap=getSortValues(item,itemMDMap);
              dao.insertIndex(bis[i].getTableName(),item.getID(),values[x].value,nVal,sortMap);
              if (bis[i].isMetadataIndex()) {
                int distinctID=dao.getDistinctID(bis[i].getTableName(true,false,false),values[x].value,nVal);
                dao.createDistinctMapping(bis[i].getMapName(),item.getID(),distinctID);
              }
            }
          }
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9762140733399404
52486,"/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  if (buttonPressed.startsWith(PROGRESS_BAR_PREFIX)) {
    return STATUS_COMPLETE;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    if (buttonPressed.equals(CANCEL_EDIT_BUTTON)) {
      subInfo.setBitstream(null);
      return STATUS_EDIT_COMPLETE;
    }
 else {
      Bitstream b=Bitstream.find(context,Integer.parseInt(request.getParameter(""String_Node_Str"")));
      subInfo.setBitstream(b);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    String bitstreamID=buttonPressed.substring(""String_Node_Str"".length());
    Bitstream b=Bitstream.find(context,Integer.parseInt(bitstreamID));
    subInfo.setBitstream(b);
    return STATUS_EDIT_BITSTREAM;
  }
  if (buttonPressed.equalsIgnoreCase(""String_Node_Str"")) {
    if (request.getParameter(""String_Node_Str"") != null) {
      String[] removeIDs=request.getParameterValues(""String_Node_Str"");
      for (int i=0; i < removeIDs.length; i++) {
        int id=Integer.parseInt(removeIDs[i]);
        int status=processRemoveFile(context,item,id);
        if (status != STATUS_COMPLETE)         return status;
      }
      subInfo.setBitstream(null);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    int id=Integer.parseInt(buttonPressed.substring(14));
    int status=processRemoveFile(context,item,id);
    if (status != STATUS_COMPLETE)     return status;
    subInfo.setBitstream(null);
  }
  String contentType=request.getContentType();
  if (buttonPressed.equalsIgnoreCase(SUBMIT_UPLOAD_BUTTON)) {
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
      int status=processUploadFile(context,request,response,subInfo);
      if (status != STATUS_COMPLETE)       return status;
    }
  }
  String fileDescription=request.getParameter(""String_Node_Str"");
  if (fileDescription != null && fileDescription.length() > 0) {
    int status=processSaveFileDescription(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  int formatTypeID=Util.getIntParameter(request,""String_Node_Str"");
  String formatDesc=request.getParameter(""String_Node_Str"");
  if (formatTypeID >= 0 || (formatDesc != null && formatDesc.length() > 0)) {
    int status=processSaveFileFormat(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    bundles[0].setPrimaryBitstreamID(new Integer(request.getParameter(""String_Node_Str"")).intValue());
    bundles[0].update();
  }
  boolean allowEmptyItems=(request.getParameter(""String_Node_Str"") != null);
  if (!allowEmptyItems) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    if (bundles.length == 0) {
      return STATUS_NO_FILES_ERROR;
    }
 else {
      Bitstream[] bitstreams=bundles[0].getBitstreams();
      if (bitstreams.length == 0) {
        return STATUS_NO_FILES_ERROR;
      }
    }
  }
  context.commit();
  return STATUS_COMPLETE;
}","/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  if (buttonPressed.startsWith(PROGRESS_BAR_PREFIX)) {
    return STATUS_COMPLETE;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    if (buttonPressed.equals(CANCEL_EDIT_BUTTON)) {
      subInfo.setBitstream(null);
      return STATUS_EDIT_COMPLETE;
    }
 else {
      Bitstream b=Bitstream.find(context,Integer.parseInt(request.getParameter(""String_Node_Str"")));
      subInfo.setBitstream(b);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    String bitstreamID=buttonPressed.substring(""String_Node_Str"".length());
    Bitstream b=Bitstream.find(context,Integer.parseInt(bitstreamID));
    subInfo.setBitstream(b);
    return STATUS_EDIT_BITSTREAM;
  }
  if (buttonPressed.equalsIgnoreCase(""String_Node_Str"")) {
    if (request.getParameter(""String_Node_Str"") != null) {
      String[] removeIDs=request.getParameterValues(""String_Node_Str"");
      for (int i=0; i < removeIDs.length; i++) {
        int id=Integer.parseInt(removeIDs[i]);
        int status=processRemoveFile(context,item,id);
        if (status != STATUS_COMPLETE)         return status;
      }
      subInfo.setBitstream(null);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    int id=Integer.parseInt(buttonPressed.substring(14));
    int status=processRemoveFile(context,item,id);
    if (status != STATUS_COMPLETE)     return status;
    subInfo.setBitstream(null);
  }
  String contentType=request.getContentType();
  if (buttonPressed.equalsIgnoreCase(SUBMIT_UPLOAD_BUTTON)) {
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
      int status=processUploadFile(context,request,response,subInfo);
      if (status != STATUS_COMPLETE)       return status;
    }
  }
  String fileDescription=request.getParameter(""String_Node_Str"");
  if (fileDescription != null && fileDescription.length() > 0) {
    int status=processSaveFileDescription(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  int formatTypeID=Util.getIntParameter(request,""String_Node_Str"");
  String formatDesc=request.getParameter(""String_Node_Str"");
  if (formatTypeID >= 0 || (formatDesc != null && formatDesc.length() > 0)) {
    int status=processSaveFileFormat(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    bundles[0].setPrimaryBitstreamID(new Integer(request.getParameter(""String_Node_Str"")).intValue());
    bundles[0].update();
  }
  boolean allowEmptyItems=(request.getParameter(SUBMIT_SKIP_BUTTON) != null);
  if (!allowEmptyItems) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    if (bundles.length == 0) {
      return STATUS_NO_FILES_ERROR;
    }
 else {
      Bitstream[] bitstreams=bundles[0].getBitstreams();
      if (bitstreams.length == 0) {
        return STATUS_NO_FILES_ERROR;
      }
    }
  }
  context.commit();
  return STATUS_COMPLETE;
}",0.9960043588812204
52487,"/** 
 * Forward processing to the specified step.
 * @param context DSpace context
 * @param request the request object
 * @param response the response object
 * @param subInfo SubmissionInfo pertaining to this submission
 * @param stepNumber The number of the step to perform
 */
private void doStep(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo,int stepNumber) throws ServletException, IOException, SQLException, AuthorizeException {
  if (subInfo.getSubmissionConfig() != null) {
    currentStepConfig=subInfo.getSubmissionConfig().getStep(stepNumber);
  }
 else {
    log.fatal(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + stepNumber + ""String_Node_Str""));
    JSPManager.showInternalError(request,response);
  }
  if (!subInfo.isInWorkflow() && (currentStepConfig.getStepNumber() > getStepReached(subInfo))) {
    userHasReached(subInfo,currentStepConfig.getStepNumber());
    context.commit();
    setBeginningOfStep(request,true);
  }
  saveCurrentStepConfig(request,currentStepConfig);
  log.debug(""String_Node_Str"" + currentStepConfig.getProcessingClassName() + ""String_Node_Str"");
  try {
    JSPStepManager stepManager=JSPStepManager.loadStep(currentStepConfig.getProcessingClassName());
    boolean stepFinished=stepManager.processStep(context,request,response,subInfo);
    if (stepFinished) {
      subInfo=getSubmissionInfo(context,request);
      doNextStep(context,request,response,subInfo);
    }
 else {
      context.complete();
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + currentStepConfig.getProcessingClassName() + ""String_Node_Str"",e);
    JSPManager.showInternalError(request,response);
  }
}","/** 
 * Forward processing to the specified step.
 * @param context DSpace context
 * @param request the request object
 * @param response the response object
 * @param subInfo SubmissionInfo pertaining to this submission
 * @param stepNumber The number of the step to perform
 */
private void doStep(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo,int stepNumber) throws ServletException, IOException, SQLException, AuthorizeException {
  if (subInfo.getSubmissionConfig() != null) {
    currentStepConfig=subInfo.getSubmissionConfig().getStep(stepNumber);
  }
 else {
    log.fatal(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + stepNumber + ""String_Node_Str""));
    JSPManager.showInternalError(request,response);
  }
  if (!subInfo.isInWorkflow() && (currentStepConfig.getStepNumber() > getStepReached(subInfo))) {
    userHasReached(subInfo,currentStepConfig.getStepNumber());
    context.commit();
    setBeginningOfStep(request,true);
  }
  saveCurrentStepConfig(request,currentStepConfig);
  log.debug(""String_Node_Str"" + currentStepConfig.getProcessingClassName() + ""String_Node_Str"");
  try {
    JSPStepManager stepManager=JSPStepManager.loadStep(currentStepConfig.getProcessingClassName());
    boolean stepFinished=stepManager.processStep(context,request,response,subInfo);
    if (stepFinished) {
      if (request instanceof FileUploadRequest) {
        request=((FileUploadRequest)request).getOriginalRequest();
      }
      subInfo=getSubmissionInfo(context,request);
      doNextStep(context,request,response,subInfo);
    }
 else {
      context.complete();
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + currentStepConfig.getProcessingClassName() + ""String_Node_Str"",e);
    JSPManager.showInternalError(request,response);
  }
}",0.9647986482680936
52488,"/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  FileUploadRequest wrapper=null;
  String filePath=null;
  InputStream fileInputStream=null;
  String contentType=request.getContentType();
  if (buttonPressed.equalsIgnoreCase(SUBMIT_UPLOAD_BUTTON)) {
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
      try {
        if (Class.forName(""String_Node_Str"").isInstance(request)) {
          wrapper=(FileUploadRequest)request;
        }
 else {
          wrapper=new FileUploadRequest(request);
        }
        File temp=wrapper.getFile(""String_Node_Str"");
        if (temp != null && temp.length() > 0) {
          fileInputStream=new BufferedInputStream(new FileInputStream(temp));
          filePath=wrapper.getFilesystemName(""String_Node_Str"");
        }
        temp.delete();
        request.setAttribute(""String_Node_Str"",filePath);
        request.setAttribute(""String_Node_Str"",fileInputStream);
        request.setAttribute(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
      }
 catch (      IOException ie) {
        log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),ie);
      }
catch (      Exception e) {
        throw new ServletException(e);
      }
    }
  }
  return super.doProcessing(context,request,response,subInfo);
}","/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  FileUploadRequest wrapper=null;
  String filePath=null;
  InputStream fileInputStream=null;
  String contentType=request.getContentType();
  if (buttonPressed.equalsIgnoreCase(SUBMIT_UPLOAD_BUTTON)) {
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
      try {
        if (Class.forName(""String_Node_Str"").isInstance(request)) {
          wrapper=(FileUploadRequest)request;
        }
 else {
          wrapper=new FileUploadRequest(request);
        }
        File temp=wrapper.getFile(""String_Node_Str"");
        if (temp != null && temp.length() > 0) {
          fileInputStream=new BufferedInputStream(new FileInputStream(temp));
          filePath=wrapper.getFilesystemName(""String_Node_Str"");
          temp.delete();
        }
        request.setAttribute(""String_Node_Str"",filePath);
        request.setAttribute(""String_Node_Str"",fileInputStream);
        request.setAttribute(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
      }
 catch (      IOException ie) {
        log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),ie);
      }
catch (      Exception e) {
        throw new ServletException(e);
      }
    }
  }
  return super.doProcessing(context,request,response,subInfo);
}",0.9896640826873384
52489,"/** 
 * Do any post-processing after the step's backend processing occurred (in the doProcessing() method). <P> It is this method's job to determine whether processing completed successfully, or display another JSP informing the users of any potential problems/errors. <P> If this step doesn't require user interaction OR you are solely using Manakin for your user interface, then this method may be left EMPTY, since all step processing should occur in the doProcessing() method.
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @param status any status/errors reported by doProcessing() method
 */
public void doPostProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo,int status) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,NEXT_BUTTON);
  if (request.getParameter(""String_Node_Str"") != null) {
    Bundle[] bundles=subInfo.getSubmissionItem().getItem().getBundles(""String_Node_Str"");
    if (bundles.length > 0) {
      showUploadFileList(context,request,response,subInfo,true,false);
    }
    return;
  }
  if (status != STATUS_COMPLETE) {
    if (status == STATUS_INTEGRITY_ERROR) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
 else     if (status == STATUS_UPLOAD_ERROR) {
      if (subInfo != null) {
        Collection c=subInfo.getSubmissionItem().getCollection();
        DCInputsReader inputsReader=new DCInputsReader();
        request.setAttribute(""String_Node_Str"",inputsReader.getInputs(c.getHandle()));
      }
      JSPStepManager.showJSP(request,response,subInfo,UPLOAD_ERROR_JSP);
    }
 else     if (status == STATUS_UNKNOWN_FORMAT) {
      showGetFileFormat(context,request,response,subInfo);
    }
  }
  if (status == STATUS_COMPLETE && buttonPressed.equals(NEXT_BUTTON)) {
    return;
  }
  if (buttonPressed.equals(SUBMIT_MORE_BUTTON)) {
    showChooseFile(context,request,response,subInfo);
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    showUploadFileList(context,request,response,subInfo,false,true);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(16));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showFileDescription(context,request,response,subInfo);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(14));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showGetFileFormat(context,request,response,subInfo);
  }
 else {
    String contentType=request.getContentType();
    boolean fileUpload=false;
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1))     fileUpload=true;
    showUploadPage(context,request,response,subInfo,fileUpload);
  }
}","/** 
 * Do any post-processing after the step's backend processing occurred (in the doProcessing() method). <P> It is this method's job to determine whether processing completed successfully, or display another JSP informing the users of any potential problems/errors. <P> If this step doesn't require user interaction OR you are solely using Manakin for your user interface, then this method may be left EMPTY, since all step processing should occur in the doProcessing() method.
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @param status any status/errors reported by doProcessing() method
 */
public void doPostProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo,int status) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,NEXT_BUTTON);
  if (buttonPressed.equalsIgnoreCase(SUBMIT_SKIP_BUTTON)) {
    Bundle[] bundles=subInfo.getSubmissionItem().getItem().getBundles(""String_Node_Str"");
    if (bundles.length > 0) {
      showUploadFileList(context,request,response,subInfo,true,false);
    }
    return;
  }
  if (buttonPressed.equalsIgnoreCase(""String_Node_Str"")) {
    showUploadPage(context,request,response,subInfo,false);
  }
  if (status != STATUS_COMPLETE) {
    if (status == STATUS_INTEGRITY_ERROR) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
 else     if (status == STATUS_UPLOAD_ERROR || status == STATUS_NO_FILES_ERROR) {
      if (buttonPressed.startsWith(""String_Node_Str"")) {
        showUploadPage(context,request,response,subInfo,false);
      }
 else {
        if (subInfo != null) {
          Collection c=subInfo.getSubmissionItem().getCollection();
          DCInputsReader inputsReader=new DCInputsReader();
          request.setAttribute(""String_Node_Str"",inputsReader.getInputs(c.getHandle()));
        }
        JSPStepManager.showJSP(request,response,subInfo,UPLOAD_ERROR_JSP);
      }
    }
 else     if (status == STATUS_UNKNOWN_FORMAT) {
      showGetFileFormat(context,request,response,subInfo);
    }
  }
  if (status == STATUS_COMPLETE && buttonPressed.equals(NEXT_BUTTON)) {
    return;
  }
  if (buttonPressed.equals(SUBMIT_MORE_BUTTON)) {
    showChooseFile(context,request,response,subInfo);
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    showUploadFileList(context,request,response,subInfo,false,true);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(16));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showFileDescription(context,request,response,subInfo);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(14));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showGetFileFormat(context,request,response,subInfo);
  }
 else {
    String contentType=request.getContentType();
    boolean fileUpload=false;
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1))     fileUpload=true;
    showUploadPage(context,request,response,subInfo,fileUpload);
  }
}",0.9187725631768952
52490,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String extraPathInfo=null;
  DSpaceObject dso=null;
  String path=request.getPathInfo();
  DSpaceIdentifier di=IdentifierFactory.resolve(context,path);
  if (di == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + path));
    JSPManager.showInvalidIDError(request,response,path,-1);
  }
 else {
    String urlForm=di.getURLForm();
    int index=path.indexOf(urlForm);
    int startFrom=index + urlForm.length();
    if (startFrom < path.length()) {
      extraPathInfo=path.substring(startFrom);
    }
    dso=di.getObject(context);
    processDSpaceObject(context,request,response,dso,extraPathInfo);
  }
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String extraPathInfo=null;
  DSpaceObject dso=null;
  String path=request.getPathInfo();
  DSpaceIdentifier di=IdentifierFactory.resolve(context,path);
  if (di != null) {
    dso=di.getObject(context);
  }
  if (dso == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + path));
    JSPManager.showInvalidIDError(request,response,path,-1);
  }
 else {
    String urlForm=di.getURLForm();
    int index=path.indexOf(urlForm);
    int startFrom=index + urlForm.length();
    if (startFrom < path.length()) {
      extraPathInfo=path.substring(startFrom);
    }
    processDSpaceObject(context,request,response,dso,extraPathInfo);
  }
}",0.931804465902233
52491,"public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      TableRow row=DatabaseManager.create(context,""String_Node_Str"");
      row.setColumn(""String_Node_Str"",itemID);
      row.setColumn(""String_Node_Str"",commID[i]);
      DatabaseManager.update(context,row);
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      if (isFirstOccurrence(commID,i)) {
        TableRow row=DatabaseManager.create(context,""String_Node_Str"");
        row.setColumn(""String_Node_Str"",itemID);
        row.setColumn(""String_Node_Str"",commID[i]);
        DatabaseManager.update(context,row);
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9453499520613614
52492,"public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      TableRow row=DatabaseManager.create(context,""String_Node_Str"");
      row.setColumn(""String_Node_Str"",itemID);
      row.setColumn(""String_Node_Str"",commID[i]);
      DatabaseManager.update(context,row);
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      if (isFirstOccurrence(commID,i)) {
        TableRow row=DatabaseManager.create(context,""String_Node_Str"");
        row.setColumn(""String_Node_Str"",itemID);
        row.setColumn(""String_Node_Str"",commID[i]);
        DatabaseManager.update(context,row);
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9453499520613614
52493,"/** 
 * Setup the AspectGenerator. 
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  Integer aspectID=(Integer)request.getAttribute(ASPECT_ID);
  if (aspectID == null)   aspectID=0;
  aspectID++;
  request.setAttribute(ASPECT_ID,aspectID);
  String path=request.getServletPath();
  if (path.startsWith(PREFIX)) {
    path=path.substring(PREFIX.length());
  }
  String aspectPath=PROTOCOL + ""String_Node_Str"" + PREFIX+ aspectID+ ""String_Node_Str""+ path;
  getLogger().debug(""String_Node_Str"" + aspectPath);
  super.setup(resolver,objectModel,aspectPath,par);
}","/** 
 * Setup the AspectGenerator. 
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  Integer aspectID=(Integer)request.getAttribute(ASPECT_ID);
  if (aspectID == null)   aspectID=0;
  aspectID++;
  request.setAttribute(ASPECT_ID,aspectID);
  String path=request.getSitemapURI();
  String aspectPath=PROTOCOL + ""String_Node_Str"" + PREFIX+ aspectID+ ""String_Node_Str""+ path;
  getLogger().debug(""String_Node_Str"" + aspectPath);
  super.setup(resolver,objectModel,aspectPath,par);
}",0.9247787610619468
52494,"/** 
 * @deprecated
 * @return
 * @throws BrowseException
 */
public static String[] tables() throws BrowseException {
  BrowseIndex[] bis=getBrowseIndices();
  String[] returnTables=new String[bis.length + 1];
  for (int i=0; i < bis.length; i++) {
    returnTables[i]=bis[i].getTableName();
  }
  returnTables[bis.length]=""String_Node_Str"";
  return returnTables;
}","/** 
 * @deprecated
 * @return
 * @throws BrowseException
 */
public static String[] tables() throws BrowseException {
  BrowseIndex[] bis=getBrowseIndices();
  String[] returnTables=new String[bis.length];
  for (int i=0; i < bis.length; i++) {
    returnTables[i]=bis[i].getTableName();
  }
  return returnTables;
}",0.9064327485380116
52495,"public static void main(String[] argv) throws Exception {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  CommandLineParser parser=new PosixParser();
  int status=0;
  Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  OptionBuilder.withLongOpt(""String_Node_Str"");
  OptionBuilder.withValueSeparator(',');
  OptionBuilder.withDescription(""String_Node_Str"" + ""String_Node_Str"" + MEDIA_FILTER_PLUGINS_KEY + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  Option pluginOption=OptionBuilder.create('p');
  pluginOption.setArgs(Option.UNLIMITED_VALUES);
  options.addOption(pluginOption);
  CommandLine line=null;
  try {
    line=parser.parse(options,argv);
  }
 catch (  MissingArgumentException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    HelpFormatter myhelp=new HelpFormatter();
    myhelp.printHelp(""String_Node_Str"",options);
    System.exit(1);
  }
  if (line.hasOption('h')) {
    HelpFormatter myhelp=new HelpFormatter();
    myhelp.printHelp(""String_Node_Str"",options);
    System.exit(0);
  }
  if (line.hasOption('v')) {
    isVerbose=true;
  }
  if (line.hasOption('n')) {
    updateIndex=false;
  }
  if (line.hasOption('f')) {
    isForce=true;
  }
  if (line.hasOption('i')) {
    identifier=line.getOptionValue('i');
  }
  if (line.hasOption('m')) {
    max2Process=Integer.parseInt(line.getOptionValue('m'));
    if (max2Process <= 1) {
      System.out.println(""String_Node_Str"" + line.getOptionValue('m') + ""String_Node_Str"");
      max2Process=Integer.MAX_VALUE;
    }
  }
  String filterNames[]=null;
  if (line.hasOption('p')) {
    filterNames=line.getOptionValues('p');
    if (filterNames == null || filterNames.length == 0) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      HelpFormatter myhelp=new HelpFormatter();
      myhelp.printHelp(""String_Node_Str"",options);
      System.exit(1);
    }
  }
 else {
    String enabledPlugins=ConfigurationManager.getProperty(MEDIA_FILTER_PLUGINS_KEY);
    filterNames=enabledPlugins.split(""String_Node_Str"");
  }
  List filterList=new ArrayList();
  for (int i=0; i < filterNames.length; i++) {
    FormatFilter filter=(FormatFilter)PluginManager.getNamedPlugin(FormatFilter.class,filterNames[i]);
    if (filter == null) {
      System.err.println(""String_Node_Str"" + filterNames[i] + ""String_Node_Str"");
      System.exit(1);
    }
 else {
      filterList.add(filter);
      String filterClassName=filter.getClass().getName();
      String pluginName=null;
      if (SelfNamedPlugin.class.isAssignableFrom(filter.getClass())) {
        pluginName=((SelfNamedPlugin)filter).getPluginInstanceName();
      }
      String formats=ConfigurationManager.getProperty(FILTER_PREFIX + ""String_Node_Str"" + filterClassName+ (pluginName != null ? ""String_Node_Str"" + pluginName : ""String_Node_Str"")+ ""String_Node_Str""+ INPUT_FORMATS_SUFFIX);
      if (formats != null) {
        filterFormats.put(filterClassName + (pluginName != null ? FILTER_PLUGIN_SEPARATOR + pluginName : ""String_Node_Str""),Arrays.asList(formats.split(""String_Node_Str"")));
      }
    }
  }
  if (isVerbose) {
    System.out.println(""String_Node_Str"");
    java.util.Iterator i=filterFormats.keySet().iterator();
    while (i.hasNext()) {
      String filterName=(String)i.next();
      System.out.println(""String_Node_Str"" + filterName);
      String pluginName=null;
      if (filterName.contains(FILTER_PLUGIN_SEPARATOR)) {
        String[] fields=filterName.split(FILTER_PLUGIN_SEPARATOR);
        filterName=fields[0];
        pluginName=fields[1];
      }
      System.out.println(filterName + (pluginName != null ? ""String_Node_Str"" + pluginName + ""String_Node_Str"" : ""String_Node_Str""));
    }
  }
  filterClasses=(MediaFilter[])filterList.toArray(new MediaFilter[filterList.size()]);
  Context c=null;
  try {
    c=new Context();
    c.setIgnoreAuthorization(true);
    if (identifier == null) {
      applyFiltersAllItems(c);
    }
 else {
      DSpaceObject dso=HandleManager.resolveToObject(c,identifier);
      if (dso == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + identifier + ""String_Node_Str"");
      }
switch (dso.getType()) {
case Constants.COMMUNITY:
        applyFiltersCommunity(c,(Community)dso);
      break;
case Constants.COLLECTION:
    applyFiltersCollection(c,(Collection)dso);
  break;
case Constants.ITEM:
applyFiltersItem(c,(Item)dso);
break;
}
}
if (updateIndex) {
System.out.println(""String_Node_Str"");
DSIndexer.updateIndex(c);
}
c.complete();
c=null;
}
 catch (Exception e) {
status=1;
}
 finally {
if (c != null) {
c.abort();
}
}
System.exit(status);
}","public static void main(String[] argv) throws Exception {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  CommandLineParser parser=new PosixParser();
  int status=0;
  Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  OptionBuilder.withLongOpt(""String_Node_Str"");
  OptionBuilder.withValueSeparator(',');
  OptionBuilder.withDescription(""String_Node_Str"" + ""String_Node_Str"" + MEDIA_FILTER_PLUGINS_KEY + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  Option pluginOption=OptionBuilder.create('p');
  pluginOption.setArgs(Option.UNLIMITED_VALUES);
  options.addOption(pluginOption);
  CommandLine line=null;
  try {
    line=parser.parse(options,argv);
  }
 catch (  MissingArgumentException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    HelpFormatter myhelp=new HelpFormatter();
    myhelp.printHelp(""String_Node_Str"",options);
    System.exit(1);
  }
  if (line.hasOption('h')) {
    HelpFormatter myhelp=new HelpFormatter();
    myhelp.printHelp(""String_Node_Str"",options);
    System.exit(0);
  }
  if (line.hasOption('v')) {
    isVerbose=true;
  }
  if (line.hasOption('n')) {
    updateIndex=false;
  }
  if (line.hasOption('f')) {
    isForce=true;
  }
  if (line.hasOption('i')) {
    identifier=line.getOptionValue('i');
  }
  if (line.hasOption('m')) {
    max2Process=Integer.parseInt(line.getOptionValue('m'));
    if (max2Process <= 1) {
      System.out.println(""String_Node_Str"" + line.getOptionValue('m') + ""String_Node_Str"");
      max2Process=Integer.MAX_VALUE;
    }
  }
  String filterNames[]=null;
  if (line.hasOption('p')) {
    filterNames=line.getOptionValues('p');
    if (filterNames == null || filterNames.length == 0) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      HelpFormatter myhelp=new HelpFormatter();
      myhelp.printHelp(""String_Node_Str"",options);
      System.exit(1);
    }
  }
 else {
    String enabledPlugins=ConfigurationManager.getProperty(MEDIA_FILTER_PLUGINS_KEY);
    filterNames=enabledPlugins.split(""String_Node_Str"");
  }
  List filterList=new ArrayList();
  for (int i=0; i < filterNames.length; i++) {
    FormatFilter filter=(FormatFilter)PluginManager.getNamedPlugin(FormatFilter.class,filterNames[i]);
    if (filter == null) {
      System.err.println(""String_Node_Str"" + filterNames[i] + ""String_Node_Str"");
      System.exit(1);
    }
 else {
      filterList.add(filter);
      String filterClassName=filter.getClass().getName();
      String pluginName=null;
      if (SelfNamedPlugin.class.isAssignableFrom(filter.getClass())) {
        pluginName=((SelfNamedPlugin)filter).getPluginInstanceName();
      }
      String formats=ConfigurationManager.getProperty(FILTER_PREFIX + ""String_Node_Str"" + filterClassName+ (pluginName != null ? ""String_Node_Str"" + pluginName : ""String_Node_Str"")+ ""String_Node_Str""+ INPUT_FORMATS_SUFFIX);
      if (formats != null) {
        filterFormats.put(filterClassName + (pluginName != null ? FILTER_PLUGIN_SEPARATOR + pluginName : ""String_Node_Str""),Arrays.asList(formats.split(""String_Node_Str"")));
      }
    }
  }
  if (isVerbose) {
    System.out.println(""String_Node_Str"");
    java.util.Iterator i=filterFormats.keySet().iterator();
    while (i.hasNext()) {
      String filterName=(String)i.next();
      System.out.println(""String_Node_Str"" + filterName);
      String pluginName=null;
      if (filterName.contains(FILTER_PLUGIN_SEPARATOR)) {
        String[] fields=filterName.split(FILTER_PLUGIN_SEPARATOR);
        filterName=fields[0];
        pluginName=fields[1];
      }
      System.out.println(filterName + (pluginName != null ? ""String_Node_Str"" + pluginName + ""String_Node_Str"" : ""String_Node_Str""));
    }
  }
  filterClasses=(FormatFilter[])filterList.toArray(new FormatFilter[filterList.size()]);
  Context c=null;
  try {
    c=new Context();
    c.setIgnoreAuthorization(true);
    if (identifier == null) {
      applyFiltersAllItems(c);
    }
 else {
      DSpaceObject dso=HandleManager.resolveToObject(c,identifier);
      if (dso == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + identifier + ""String_Node_Str"");
      }
switch (dso.getType()) {
case Constants.COMMUNITY:
        applyFiltersCommunity(c,(Community)dso);
      break;
case Constants.COLLECTION:
    applyFiltersCollection(c,(Collection)dso);
  break;
case Constants.ITEM:
applyFiltersItem(c,(Item)dso);
break;
}
}
if (updateIndex) {
System.out.println(""String_Node_Str"");
DSIndexer.updateIndex(c);
}
c.complete();
c=null;
}
 catch (Exception e) {
status=1;
}
 finally {
if (c != null) {
c.abort();
}
}
System.exit(status);
}",0.9978388998035363
52496,"/** 
 * processBitstream is a utility class that calls the virtual methods from the current MediaFilter class. It scans the bitstreams in an item, and decides if a bitstream has  already been filtered, and if not or if overWrite is set, invokes the  filter.
 * @param c context
 * @param item item containing bitstream to process
 * @param source source bitstream to process
 * @param mediaFilter MediaFilter to perform filtering
 * @return true if new rendition is created, false if rendition alreadyexists and overWrite is not set
 */
public static boolean processBitstream(Context c,Item item,Bitstream source,FormatFilter formatFilter) throws Exception {
  if (!formatFilter.preProcessBitstream(c,item,source))   return false;
  boolean overWrite=MediaFilterManager.isForce;
  String newName=formatFilter.getFilteredName(source.getName());
  Bitstream existingBitstream=null;
  Bundle targetBundle=null;
  Bundle[] bundles=item.getBundles(formatFilter.getBundleName());
  if (bundles.length > 0) {
    for (int i=0; i < bundles.length; i++) {
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      for (int j=0; j < bitstreams.length; j++) {
        if (bitstreams[j].getName().equals(newName)) {
          targetBundle=bundles[i];
          existingBitstream=bitstreams[j];
        }
      }
    }
  }
  if (!overWrite && (existingBitstream != null)) {
    System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
    return false;
  }
  InputStream destStream=formatFilter.getDestinationStream(source.retrieve());
  if (bundles.length < 1) {
    targetBundle=item.createBundle(formatFilter.getBundleName());
  }
 else {
    targetBundle=bundles[0];
  }
  Bitstream b=targetBundle.createBitstream(destStream);
  b.setName(newName);
  b.setSource(""String_Node_Str"" + formatFilter.getClass().getName() + ""String_Node_Str""+ DCDate.getCurrent()+ ""String_Node_Str"");
  b.setDescription(formatFilter.getDescription());
  BitstreamFormat bf=BitstreamFormat.findByShortDescription(c,formatFilter.getFormatString());
  b.setFormat(bf);
  b.update();
  AuthorizeManager.removeAllPolicies(c,b);
  AuthorizeManager.inheritPolicies(c,source,b);
  if (existingBitstream != null) {
    targetBundle.removeBitstream(existingBitstream);
  }
  System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
  formatFilter.postProcessBitstream(c,item,b);
  return true;
}","/** 
 * processBitstream is a utility class that calls the virtual methods from the current MediaFilter class. It scans the bitstreams in an item, and decides if a bitstream has  already been filtered, and if not or if overWrite is set, invokes the  filter.
 * @param c context
 * @param item item containing bitstream to process
 * @param source source bitstream to process
 * @param formatFilter FormatFilter to perform filtering
 * @return true if new rendition is created, false if rendition alreadyexists and overWrite is not set
 */
public static boolean processBitstream(Context c,Item item,Bitstream source,FormatFilter formatFilter) throws Exception {
  if (!formatFilter.preProcessBitstream(c,item,source))   return false;
  boolean overWrite=MediaFilterManager.isForce;
  String newName=formatFilter.getFilteredName(source.getName());
  Bitstream existingBitstream=null;
  Bundle targetBundle=null;
  Bundle[] bundles=item.getBundles(formatFilter.getBundleName());
  if (bundles.length > 0) {
    for (int i=0; i < bundles.length; i++) {
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      for (int j=0; j < bitstreams.length; j++) {
        if (bitstreams[j].getName().equals(newName)) {
          targetBundle=bundles[i];
          existingBitstream=bitstreams[j];
        }
      }
    }
  }
  if (!overWrite && (existingBitstream != null)) {
    System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
    return false;
  }
  InputStream destStream=formatFilter.getDestinationStream(source.retrieve());
  if (bundles.length < 1) {
    targetBundle=item.createBundle(formatFilter.getBundleName());
  }
 else {
    targetBundle=bundles[0];
  }
  Bitstream b=targetBundle.createBitstream(destStream);
  b.setName(newName);
  b.setSource(""String_Node_Str"" + formatFilter.getClass().getName() + ""String_Node_Str""+ DCDate.getCurrent()+ ""String_Node_Str"");
  b.setDescription(formatFilter.getDescription());
  BitstreamFormat bf=BitstreamFormat.findByShortDescription(c,formatFilter.getFormatString());
  b.setFormat(bf);
  b.update();
  AuthorizeManager.removeAllPolicies(c,b);
  AuthorizeManager.inheritPolicies(c,source,b);
  if (existingBitstream != null) {
    targetBundle.removeBitstream(existingBitstream);
  }
  System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
  formatFilter.postProcessBitstream(c,item,b);
  return true;
}",0.995517522412388
52497,"/** 
 * Get the count of the items in the given container.  If the configuration value webui.strengths.cache is equal to 'true' this will return the cached value if it exists.  If it is equal to 'false' it will count the number of items in the container in real time
 * @param dso
 * @return
 * @throws ItemCountException
 * @throws SQLException 
 */
public int getCount(DSpaceObject dso) throws ItemCountException {
  boolean useCache=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
  if (useCache) {
    return dao.getCount(dso);
  }
  if (dso instanceof Collection) {
    try {
      return ((Collection)dso).countItems();
    }
 catch (    SQLException e) {
      log.error(""String_Node_Str"",e);
      throw new ItemCountException(e);
    }
  }
  if (dso instanceof Community) {
    try {
      return ((Collection)dso).countItems();
    }
 catch (    SQLException e) {
      log.error(""String_Node_Str"",e);
      throw new ItemCountException(e);
    }
  }
  return 0;
}","/** 
 * Get the count of the items in the given container.  If the configuration value webui.strengths.cache is equal to 'true' this will return the cached value if it exists.  If it is equal to 'false' it will count the number of items in the container in real time
 * @param dso
 * @return
 * @throws ItemCountException
 * @throws SQLException 
 */
public int getCount(DSpaceObject dso) throws ItemCountException {
  boolean useCache=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
  if (useCache) {
    return dao.getCount(dso);
  }
  if (dso instanceof Collection) {
    try {
      return ((Collection)dso).countItems();
    }
 catch (    SQLException e) {
      log.error(""String_Node_Str"",e);
      throw new ItemCountException(e);
    }
  }
  if (dso instanceof Community) {
    try {
      return ((Community)dso).countItems();
    }
 catch (    SQLException e) {
      log.error(""String_Node_Str"",e);
      throw new ItemCountException(e);
    }
  }
  return 0;
}",0.9923896499238964
52498,"/** 
 * Get the style using the owning collection handle
 */
public String getStyleForItem(Item item) throws SQLException {
  Collection c=item.getOwningCollection();
  return getFromMap(c.getHandle());
}","/** 
 * Get the style using the owning collection handle
 */
public String getStyleForItem(Item item) throws SQLException {
  Collection c=item.getOwningCollection();
  if (c != null) {
    return getFromMap(c.getHandle());
  }
 else   return ""String_Node_Str"";
}",0.8736616702355461
52499,"public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  final HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
  final HttpServletRequest httpRequest=(HttpServletRequest)objectModel.get(HttpEnvironment.HTTP_REQUEST_OBJECT);
  final Iterator authMethods=AuthenticationManager.authenticationMethodIterator();
  final String url=((AuthenticationMethod)authMethods.next()).loginPageURL(ContextUtil.obtainContext(objectModel),httpRequest,httpResponse);
  if (authMethods.hasNext()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (ConfigurationManager.getBooleanProperty(""String_Node_Str"")) {
    if (!httpRequest.isSecure()) {
      StringBuffer location=new StringBuffer(""String_Node_Str"");
      location.append(ConfigurationManager.getProperty(""String_Node_Str"")).append(url).append(httpRequest.getQueryString() == null ? ""String_Node_Str"" : (""String_Node_Str"" + httpRequest.getQueryString()));
      httpResponse.sendRedirect(location.toString());
    }
  }
 else {
    httpResponse.sendRedirect(url);
  }
  return new HashMap();
}","public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  final HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
  final HttpServletRequest httpRequest=(HttpServletRequest)objectModel.get(HttpEnvironment.HTTP_REQUEST_OBJECT);
  final Iterator authMethods=AuthenticationManager.authenticationMethodIterator();
  final String url=((AuthenticationMethod)authMethods.next()).loginPageURL(ContextUtil.obtainContext(objectModel),httpRequest,httpResponse);
  if (authMethods.hasNext()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (ConfigurationManager.getBooleanProperty(""String_Node_Str"")) {
    if (!httpRequest.isSecure()) {
      StringBuffer location=new StringBuffer(""String_Node_Str"");
      location.append(ConfigurationManager.getProperty(""String_Node_Str"")).append(url).append(httpRequest.getQueryString() == null ? ""String_Node_Str"" : (""String_Node_Str"" + httpRequest.getQueryString()));
      httpResponse.sendRedirect(location.toString());
    }
 else {
      httpResponse.sendRedirect(url);
    }
  }
 else {
    httpResponse.sendRedirect(url);
  }
  return new HashMap();
}",0.9786008230452676
52500,"/** 
 * Return a normalized focus value. If there is no normalization that can be performed, return the focus value that is passed in.
 * @param value a focus value to normalize
 * @return  the normalized focus value
 * @throws BrowseException
 */
private String normalizeJumpToValue(String value) throws BrowseException {
  if (scope.hasJumpToValue()) {
    return BrowseOrder.makeSortString(scope.getJumpToValue(),scope.setJumpToValueLang(),scope.getBrowseIndex().getDataType());
  }
  return value;
}","/** 
 * Return a normalized focus value. If there is no normalization that can be performed, return the focus value that is passed in.
 * @param value a focus value to normalize
 * @return  the normalized focus value
 * @throws BrowseException
 */
private String normalizeJumpToValue(String value) throws BrowseException {
  if (scope.hasJumpToValue()) {
    return BrowseOrder.makeSortString(scope.getJumpToValue(),scope.setJumpToValueLang(),scope.getBrowseIndex().getDataType());
  }
 else   if (scope.hasStartsWith()) {
    return BrowseOrder.makeSortString(scope.getStartsWith(),null,scope.getBrowseIndex().getDataType());
  }
  return value;
}",0.8514335360556038
52501,"public String createMetadata(Object nativeItem) throws CannotDisseminateFormatException {
  HarvestedItemInfo itemInfo=(HarvestedItemInfo)nativeItem;
  Item item=itemInfo.item;
  DCValue[] allDC=item.getDC(Item.ANY,Item.ANY,Item.ANY);
  StringBuffer metadata=new StringBuffer();
  metadata.append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  metadata.append(""String_Node_Str"").append(hostName).append(""String_Node_Str"").append(item.getHandle()).append(""String_Node_Str"");
  for (int i=0; i < allDC.length; i++) {
    if (screened(allDC[i])) {
      String element=allDC[i].element;
      if (allDC[i].element.equals(""String_Node_Str"") && (allDC[i].qualifier != null) && allDC[i].qualifier.equals(""String_Node_Str"")) {
        element=""String_Node_Str"";
      }
      String value=allDC[i].value;
      int c=-1;
      while ((c=value.indexOf(""String_Node_Str"",c + 1)) > -1) {
        value=value.substring(0,c) + ""String_Node_Str"" + value.substring(c + 1);
      }
      while ((c=value.indexOf(""String_Node_Str"")) > -1) {
        value=value.substring(0,c) + ""String_Node_Str"" + value.substring(c + 1);
      }
      while ((c=value.indexOf(""String_Node_Str"")) > -1) {
        value=value.substring(0,c) + ""String_Node_Str"" + value.substring(c + 1);
      }
      metadata.append(""String_Node_Str"").append(element).append(""String_Node_Str"").append(value).append(""String_Node_Str"").append(element).append(""String_Node_Str"");
    }
  }
  Collection[] colls=null;
  Community[] comms=null;
  Bundle[] origBundles=null;
  Bundle[] thumbBundles=null;
  try {
    colls=item.getCollections();
    comms=item.getCommunities();
    origBundles=item.getBundles(""String_Node_Str"");
    thumbBundles=item.getBundles(""String_Node_Str"");
  }
 catch (  SQLException sqlE) {
    ;
  }
  for (int i=0; i < comms.length; i++) {
    metadata.append(""String_Node_Str"").append(comms[i].getMetadata(""String_Node_Str"")).append(""String_Node_Str"");
  }
  for (int j=0; j < colls.length; j++) {
    metadata.append(""String_Node_Str"").append(colls[j].getMetadata(""String_Node_Str"")).append(""String_Node_Str"");
  }
  if (origBundles.length > 0) {
    Bitstream[] bitstreams=origBundles[0].getBitstreams();
    for (int j=0; j < bitstreams.length; j++) {
      String tName=bitstreams[j].getName() + ""String_Node_Str"";
      Bitstream tb=thumbBundles[0].getBitstreamByName(tName);
      if (tb != null) {
        String thumbUrl=null;
        try {
          thumbUrl=baseUrl + ""String_Node_Str"" + tb.getID()+ ""String_Node_Str""+ Util.encodeBitstreamName(tb.getName(),Constants.DEFAULT_ENCODING);
        }
 catch (        Exception e) {
        }
        metadata.append(""String_Node_Str"").append(thumbUrl).append(""String_Node_Str"");
      }
    }
  }
  metadata.append(""String_Node_Str"");
  metadata.append(""String_Node_Str"");
  return metadata.toString();
}","public String createMetadata(Object nativeItem) throws CannotDisseminateFormatException {
  HarvestedItemInfo itemInfo=(HarvestedItemInfo)nativeItem;
  Item item=itemInfo.item;
  DCValue[] allDC=item.getDC(Item.ANY,Item.ANY,Item.ANY);
  StringBuffer metadata=new StringBuffer();
  metadata.append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  metadata.append(""String_Node_Str"").append(hostName).append(""String_Node_Str"").append(item.getHandle()).append(""String_Node_Str"");
  for (int i=0; i < allDC.length; i++) {
    if (screened(allDC[i])) {
      String element=allDC[i].element;
      if (allDC[i].element.equals(""String_Node_Str"") && (allDC[i].qualifier != null) && allDC[i].qualifier.equals(""String_Node_Str"")) {
        element=""String_Node_Str"";
      }
      String value=allDC[i].value;
      int c=-1;
      while ((c=value.indexOf(""String_Node_Str"",c + 1)) > -1) {
        value=value.substring(0,c) + ""String_Node_Str"" + value.substring(c + 1);
      }
      while ((c=value.indexOf(""String_Node_Str"")) > -1) {
        value=value.substring(0,c) + ""String_Node_Str"" + value.substring(c + 1);
      }
      while ((c=value.indexOf(""String_Node_Str"")) > -1) {
        value=value.substring(0,c) + ""String_Node_Str"" + value.substring(c + 1);
      }
      metadata.append(""String_Node_Str"").append(element).append(""String_Node_Str"").append(value).append(""String_Node_Str"").append(element).append(""String_Node_Str"");
    }
  }
  Collection[] colls=null;
  Community[] comms=null;
  Bundle[] origBundles=null;
  Bundle[] thumbBundles=null;
  try {
    colls=item.getCollections();
    comms=item.getCommunities();
    origBundles=item.getBundles(""String_Node_Str"");
    thumbBundles=item.getBundles(""String_Node_Str"");
  }
 catch (  SQLException sqlE) {
    ;
  }
  for (int i=0; i < comms.length; i++) {
    metadata.append(""String_Node_Str"").append(comms[i].getMetadata(""String_Node_Str"")).append(""String_Node_Str"");
  }
  for (int j=0; j < colls.length; j++) {
    metadata.append(""String_Node_Str"").append(colls[j].getMetadata(""String_Node_Str"")).append(""String_Node_Str"");
  }
  if (origBundles.length > 0) {
    Bitstream[] bitstreams=origBundles[0].getBitstreams();
    for (int j=0; j < bitstreams.length; j++) {
      String tName=bitstreams[j].getName() + ""String_Node_Str"";
      Bitstream tb=null;
      if (thumbBundles.length > 0) {
        tb=thumbBundles[0].getBitstreamByName(tName);
      }
      if (tb != null) {
        String thumbUrl=null;
        try {
          thumbUrl=baseUrl + ""String_Node_Str"" + tb.getID()+ ""String_Node_Str""+ Util.encodeBitstreamName(tb.getName(),Constants.DEFAULT_ENCODING);
        }
 catch (        Exception e) {
        }
        metadata.append(""String_Node_Str"").append(thumbUrl).append(""String_Node_Str"");
      }
    }
  }
  metadata.append(""String_Node_Str"");
  metadata.append(""String_Node_Str"");
  return metadata.toString();
}",0.9894701086956522
52502,"/** 
 * Load Submission Configuration for a specific user interface(UI). The submission configuration file name is formatted as follows: item-submission-UIName.xml <P> E.g. for a value of ""XMLUI"", uses the config file named item-submission-XMLUI.xml
 * @param UIName the name of the UI to load the Submission configuration for
 */
public SubmissionConfigReader(String UIName) throws ServletException {
  buildInputs(configDir + SUBMIT_DEF_FILE_PREFIX + ""String_Node_Str""+ UIName+ SUBMIT_DEF_FILE_SUFFIX);
}","/** 
 * Load Submission Configuration for a specific user interface(UI). The submission configuration file name is formatted as follows: item-submission-UIName.xml <P> E.g. for a value of ""XMLUI"", uses the config file named item-submission-XMLUI.xml
 * @param UIName the name of the UI to load the Submission configuration for
 */
public SubmissionConfigReader(String UIName) throws ServletException {
  this.UIName=UIName;
  buildInputs(configDir + SUBMIT_DEF_FILE_PREFIX + ""String_Node_Str""+ UIName+ SUBMIT_DEF_FILE_SUFFIX);
}",0.9787234042553192
52503,"/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
    dao.setAscending(scope.isAscending());
    String focusValue=null;
    String rawFocusValue=null;
    String focusField=browseIndex.getSortField();
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      dao.setJumpToField(focusField);
      dao.setJumpToValue(focusValue);
    }
    String value=null;
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      value=scope.getFilterValue();
      rawValue=value;
      value=BrowseOrder.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    String orderBy=browseIndex.getSortField();
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    BrowseItem next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(BrowseItem)results.get(lastIndex);
      results.remove(lastIndex);
    }
    BrowseItem prev=null;
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      int prevID=-1;
      if (showLast) {
        prevID=getPreviousPageID(results);
      }
 else {
        prevID=getPreviousPageID(null);
      }
      if (prevID != -1) {
        if (bs.getBrowseIndex() == BrowseIndex.getWithdrawnBrowseIndex())         prev=new BrowseItem(context,prevID,false,true);
 else         prev=new BrowseItem(context,prevID,true,false);
      }
    }
    int offset=0;
    int total=getTotalResults();
    int position=-1;
    if (showLast) {
      position=total - scope.getResultsPerPage();
    }
 else {
      position=getPosition(false);
    }
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextItem(next.getID());
    }
    if (prev != null) {
      browseInfo.setPrevItem(prev.getID());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
    dao.setAscending(scope.isAscending());
    String focusValue=null;
    String rawFocusValue=null;
    String focusField=browseIndex.getSortField();
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      dao.setJumpToField(focusField);
      dao.setJumpToValue(focusValue);
    }
    String value=null;
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      value=scope.getFilterValue();
      rawValue=value;
      value=BrowseOrder.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    String orderBy=browseIndex.getSortField();
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    BrowseItem next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(BrowseItem)results.get(lastIndex);
      results.remove(lastIndex);
    }
    BrowseItem prev=null;
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      int prevID=-1;
      if (showLast) {
        prevID=getPreviousPageID(results);
      }
 else {
        prevID=getPreviousPageID(null);
      }
      if (prevID != -1) {
        if (bs.getBrowseIndex() == BrowseIndex.getWithdrawnBrowseIndex())         prev=new BrowseItem(context,prevID,false,true);
 else         prev=new BrowseItem(context,prevID,true,false);
      }
    }
    int offset=0;
    int total=getTotalResults();
    int position=-1;
    if (total > 0) {
      if (showLast) {
        position=total - scope.getResultsPerPage();
        if (position < 0)         position=0;
      }
 else {
        position=getPosition(false);
      }
    }
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextItem(next.getID());
    }
    if (prev != null) {
      browseInfo.setPrevItem(prev.getID());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9905045189337603
52504,"public void addOptions(Options options) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  options.addList(""String_Node_Str"");
  options.addList(""String_Node_Str"");
  List context=options.addList(""String_Node_Str"");
  List admin=options.addList(""String_Node_Str"");
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  if (dso instanceof Item) {
    Item item=(Item)dso;
    if (item.canEdit()) {
      context.setHead(T_context_head);
      context.addItem().addXref(contextPath + ""String_Node_Str"" + item.getID(),T_context_edit_item);
    }
  }
 else   if (dso instanceof Collection) {
    Collection collection=(Collection)dso;
    if (AuthorizeManager.authorizeActionBoolean(this.context,collection,Constants.COLLECTION_ADMIN)) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"" + collection.getID(),T_context_edit_collection);
      context.addItemXref(contextPath + ""String_Node_Str"" + collection.getID(),T_context_item_mapper);
    }
  }
 else   if (dso instanceof Community) {
    Community community=(Community)dso;
    if (community.canEditBoolean()) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"" + community.getID(),T_context_edit_community);
    }
    if (AuthorizeManager.authorizeActionBoolean(this.context,community,Constants.ADD)) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"" + community.getID(),T_context_create_collection);
      context.addItemXref(contextPath + ""String_Node_Str"" + community.getID(),T_context_create_subcommunity);
    }
  }
  if (""String_Node_Str"".equals(this.sitemapURI)) {
    if (AuthorizeManager.isAdmin(this.context)) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"",T_context_create_community);
    }
  }
  if (AuthorizeManager.isAdmin(this.context)) {
    admin.setHead(T_administrative_head);
    List epeople=admin.addList(""String_Node_Str"");
    List registries=admin.addList(""String_Node_Str"");
    epeople.setHead(T_administrative_access_control);
    epeople.addItemXref(contextPath + ""String_Node_Str"",T_administrative_people);
    epeople.addItemXref(contextPath + ""String_Node_Str"",T_administrative_groups);
    epeople.addItemXref(contextPath + ""String_Node_Str"",T_administrative_authorizations);
    registries.setHead(T_administrative_registries);
    registries.addItemXref(contextPath + ""String_Node_Str"",T_administrative_metadata);
    registries.addItemXref(contextPath + ""String_Node_Str"",T_administrative_format);
    admin.addItemXref(contextPath + ""String_Node_Str"",T_administrative_items);
    admin.addItemXref(contextPath + ""String_Node_Str"",T_administrative_control_panel);
  }
}","public void addOptions(Options options) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  options.addList(""String_Node_Str"");
  options.addList(""String_Node_Str"");
  List context=options.addList(""String_Node_Str"");
  List admin=options.addList(""String_Node_Str"");
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  if (dso instanceof Item) {
    Item item=(Item)dso;
    if (item.canEdit()) {
      context.setHead(T_context_head);
      context.addItem().addXref(contextPath + ""String_Node_Str"" + item.getID(),T_context_edit_item);
    }
  }
 else   if (dso instanceof Collection) {
    Collection collection=(Collection)dso;
    if (AuthorizeManager.authorizeActionBoolean(this.context,collection,Constants.COLLECTION_ADMIN)) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"" + collection.getID(),T_context_edit_collection);
      context.addItemXref(contextPath + ""String_Node_Str"" + collection.getID(),T_context_item_mapper);
    }
  }
 else   if (dso instanceof Community) {
    Community community=(Community)dso;
    if (community.canEditBoolean()) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"" + community.getID(),T_context_edit_community);
    }
    if (AuthorizeManager.authorizeActionBoolean(this.context,community,Constants.ADD)) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"" + community.getID(),T_context_create_collection);
      context.addItemXref(contextPath + ""String_Node_Str"" + community.getID(),T_context_create_subcommunity);
    }
  }
  if (""String_Node_Str"".equals(this.sitemapURI)) {
    if (AuthorizeManager.isAdmin(this.context)) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"",T_context_create_community);
    }
  }
  if (AuthorizeManager.isAdmin(this.context)) {
    admin.setHead(T_administrative_head);
    List epeople=admin.addList(""String_Node_Str"");
    List registries=admin.addList(""String_Node_Str"");
    epeople.setHead(T_administrative_access_control);
    epeople.addItemXref(contextPath + ""String_Node_Str"",T_administrative_people);
    epeople.addItemXref(contextPath + ""String_Node_Str"",T_administrative_groups);
    epeople.addItemXref(contextPath + ""String_Node_Str"",T_administrative_authorizations);
    registries.setHead(T_administrative_registries);
    registries.addItemXref(contextPath + ""String_Node_Str"",T_administrative_metadata);
    registries.addItemXref(contextPath + ""String_Node_Str"",T_administrative_format);
    admin.addItemXref(contextPath + ""String_Node_Str"",T_administrative_items);
    admin.addItemXref(contextPath + ""String_Node_Str"",T_administrative_withdrawn);
    admin.addItemXref(contextPath + ""String_Node_Str"",T_administrative_control_panel);
  }
}",0.9854258121158912
52505,"/** 
 * A sanity check that ensures a given element and qualifier are unique within a given schema. The check happens in code as we cannot use a database constraint.
 * @param context dspace context
 * @param schemaID
 * @param element
 * @param qualifier
 * @return true if unique
 * @throws AuthorizeException
 * @throws SQLException
 * @throws IOException
 */
private boolean unique(Context context,int schemaID,String element,String qualifier) throws IOException, SQLException, AuthorizeException {
  Connection con=context.getDBConnection();
  TableRow reg=DatabaseManager.row(""String_Node_Str"");
  String query=""String_Node_Str"" + reg.getTable() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  PreparedStatement statement=con.prepareStatement(query);
  statement.setInt(1,schemaID);
  statement.setInt(2,fieldID);
  statement.setString(3,element);
  statement.setString(4,qualifier);
  ResultSet rs=statement.executeQuery();
  int count=0;
  if (rs.next()) {
    count=rs.getInt(1);
  }
  return (count == 0);
}","/** 
 * A sanity check that ensures a given element and qualifier are unique within a given schema. The check happens in code as we cannot use a database constraint.
 * @param context dspace context
 * @param schemaID
 * @param element
 * @param qualifier
 * @return true if unique
 * @throws AuthorizeException
 * @throws SQLException
 * @throws IOException
 */
private boolean unique(Context context,int schemaID,String element,String qualifier) throws IOException, SQLException, AuthorizeException {
  Connection con=context.getDBConnection();
  TableRow reg=DatabaseManager.row(""String_Node_Str"");
  String qualifierClause=""String_Node_Str"";
  if (qualifier == null) {
    qualifierClause=""String_Node_Str"";
  }
 else {
    qualifierClause=""String_Node_Str"";
  }
  String query=""String_Node_Str"" + reg.getTable() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ qualifierClause;
  PreparedStatement statement=con.prepareStatement(query);
  statement.setInt(1,schemaID);
  statement.setInt(2,fieldID);
  statement.setString(3,element);
  if (qualifier != null) {
    statement.setString(4,qualifier);
  }
  ResultSet rs=statement.executeQuery();
  int count=0;
  if (rs.next()) {
    count=rs.getInt(1);
  }
  return (count == 0);
}",0.9054945054945056
52506,"/** 
 * Return true if there are more rows, false otherwise
 * @return - true if there are more rows, false otherwise
 * @exception SQLException -If a database error occurs while fetching values
 */
public boolean hasNext() throws SQLException {
  if (results == null) {
    return false;
  }
  if (hasAdvanced) {
    return hasNext;
  }
  hasAdvanced=true;
  hasNext=results.next();
  if (!hasNext) {
    close();
  }
  return hasNext;
}","/** 
 * Return true if there are more rows, false otherwise
 * @return - true if there are more rows, false otherwise
 * @exception SQLException -If a database error occurs while fetching values
 */
public boolean hasNext() throws SQLException {
  if (results == null) {
    close();
    return false;
  }
  if (hasAdvanced) {
    return hasNext;
  }
  hasAdvanced=true;
  hasNext=results.next();
  if (!hasNext) {
    close();
  }
  return hasNext;
}",0.9853768278965128
52507,"/** 
 * Close the Iterator and release any associated resources
 */
public void close(){
  try {
    results.close();
    if (results != null)     results.close();
  }
 catch (  SQLException sqle) {
  }
  try {
    if (statemt != null)     statemt.close();
    statemt=null;
  }
 catch (  SQLException sqle) {
  }
}","/** 
 * Close the Iterator and release any associated resources
 */
public void close(){
  try {
    if (results != null) {
      results.close();
      results=null;
    }
  }
 catch (  SQLException sqle) {
  }
  try {
    if (statemt != null) {
      statemt.close();
      statemt=null;
    }
  }
 catch (  SQLException sqle) {
  }
}",0.9032258064516128
52508,"/** 
 * get Set of Integers all of the group memberships for an eperson
 * @param c
 * @param e
 * @return Set of Integer groupIDs
 * @throws SQLException
 */
public static Set allMemberGroupIDs(Context c,EPerson e) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"",e.getID());
  Set groupIDs=new HashSet();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    int childID=row.getIntColumn(""String_Node_Str"");
    groupIDs.add(new Integer(childID));
  }
  tri.close();
  String groupQuery=""String_Node_Str"";
  Iterator i=groupIDs.iterator();
  Object[] parameters=new Object[groupIDs.size()];
  int idx=0;
  while (i.hasNext()) {
    int groupID=((Integer)i.next()).intValue();
    parameters[idx++]=new Integer(groupID);
    groupQuery+=""String_Node_Str"";
    if (i.hasNext())     groupQuery+=""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(groupQuery)) {
    return groupIDs;
  }
  tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"" + groupQuery,parameters);
  while (tri.hasNext()) {
    TableRow row=tri.next();
    int parentID=row.getIntColumn(""String_Node_Str"");
    groupIDs.add(new Integer(parentID));
  }
  tri.close();
  return groupIDs;
}","/** 
 * get Set of Integers all of the group memberships for an eperson
 * @param c
 * @param e
 * @return Set of Integer groupIDs
 * @throws SQLException
 */
public static Set allMemberGroupIDs(Context c,EPerson e) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"",e.getID());
  Set groupIDs=new HashSet();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    int childID=row.getIntColumn(""String_Node_Str"");
    groupIDs.add(new Integer(childID));
  }
  tri.close();
  Group[] specialGroups=c.getSpecialGroups();
  for (int j=0; j < specialGroups.length; j++)   groupIDs.add(new Integer(specialGroups[j].getID()));
  String groupQuery=""String_Node_Str"";
  Iterator i=groupIDs.iterator();
  Object[] parameters=new Object[groupIDs.size()];
  int idx=0;
  while (i.hasNext()) {
    int groupID=((Integer)i.next()).intValue();
    parameters[idx++]=new Integer(groupID);
    groupQuery+=""String_Node_Str"";
    if (i.hasNext())     groupQuery+=""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(groupQuery)) {
    return groupIDs;
  }
  tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"" + groupQuery,parameters);
  while (tri.hasNext()) {
    TableRow row=tri.next();
    int parentID=row.getIntColumn(""String_Node_Str"");
    groupIDs.add(new Integer(parentID));
  }
  tri.close();
  return groupIDs;
}",0.943683409436834
52509,"protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  int groupID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Group group=null;
  if (groupID >= 0) {
    group=Group.find(c,groupID);
  }
  if (group != null) {
    AuthorizeManager.authorizeAction(c,group,Constants.ADD);
    boolean submit_edit=(request.getParameter(""String_Node_Str"") != null);
    boolean submit_group_update=(request.getParameter(""String_Node_Str"") != null);
    boolean submit_group_delete=(request.getParameter(""String_Node_Str"") != null);
    if (submit_edit && !submit_group_update && !submit_group_delete) {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else     if (submit_group_update) {
      String newName=request.getParameter(""String_Node_Str"");
      if (!newName.equals(group.getName())) {
        group.setName(newName);
        group.update();
      }
      int[] eperson_ids=UIUtil.getIntParameters(request,""String_Node_Str"");
      int[] group_ids=UIUtil.getIntParameters(request,""String_Node_Str"");
      EPerson[] members=group.getMembers();
      Group[] membergroups=group.getMemberGroups();
      if (eperson_ids != null) {
        Set memberSet=new HashSet();
        Set epersonIDSet=new HashSet();
        for (int x=0; x < members.length; x++) {
          Integer epersonID=new Integer(members[x].getID());
          memberSet.add(epersonID);
        }
        for (int x=0; x < eperson_ids.length; x++) {
          epersonIDSet.add(new Integer(eperson_ids[x]));
        }
        Iterator i=epersonIDSet.iterator();
        while (i.hasNext()) {
          Integer currentID=(Integer)i.next();
          if (!memberSet.contains(currentID)) {
            group.addMember(EPerson.find(c,currentID.intValue()));
          }
        }
        for (int x=0; x < members.length; x++) {
          EPerson e=members[x];
          if (!epersonIDSet.contains(new Integer(e.getID()))) {
            group.removeMember(e);
          }
        }
      }
 else {
        for (int y=0; y < members.length; y++) {
          group.removeMember(members[y]);
        }
      }
      if (group_ids != null) {
        Set memberSet=new HashSet();
        Set groupIDSet=new HashSet();
        for (int x=0; x < membergroups.length; x++) {
          Integer myID=new Integer(membergroups[x].getID());
          memberSet.add(myID);
        }
        for (int x=0; x < group_ids.length; x++) {
          groupIDSet.add(new Integer(group_ids[x]));
        }
        Iterator i=groupIDSet.iterator();
        while (i.hasNext()) {
          Integer currentID=(Integer)i.next();
          if (!memberSet.contains(currentID)) {
            group.addMember(Group.find(c,currentID.intValue()));
          }
        }
        for (int x=0; x < membergroups.length; x++) {
          Group g=membergroups[x];
          if (!groupIDSet.contains(new Integer(g.getID()))) {
            group.removeMember(g);
          }
        }
      }
 else {
        for (int y=0; y < membergroups.length; y++) {
          group.removeMember(membergroups[y]);
        }
      }
      group.update();
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else     if (submit_group_delete) {
      AuthorizeManager.authorizeAction(c,group,Constants.WRITE);
      group.delete();
      showMainPage(c,request,response);
      c.complete();
    }
 else {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
    if (button.equals(""String_Node_Str"")) {
      group=Group.create(c);
      group.setName(""String_Node_Str"" + group.getID());
      group.update();
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else {
      showMainPage(c,request,response);
    }
  }
}","protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  int groupID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Group group=null;
  if (groupID >= 0) {
    group=Group.find(c,groupID);
  }
  if (group != null) {
    AuthorizeManager.authorizeAction(c,group,Constants.ADD);
    boolean submit_edit=(request.getParameter(""String_Node_Str"") != null);
    boolean submit_group_update=(request.getParameter(""String_Node_Str"") != null);
    boolean submit_group_delete=(request.getParameter(""String_Node_Str"") != null);
    if (submit_edit && !submit_group_update && !submit_group_delete) {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else     if (submit_group_update) {
      String newName=request.getParameter(""String_Node_Str"");
      if (!newName.equals(group.getName())) {
        group.setName(newName);
        group.update();
      }
      int[] eperson_ids=UIUtil.getIntParameters(request,""String_Node_Str"");
      int[] group_ids=UIUtil.getIntParameters(request,""String_Node_Str"");
      EPerson[] members=group.getMembers();
      Group[] membergroups=group.getMemberGroups();
      if (eperson_ids != null) {
        Set memberSet=new HashSet();
        Set epersonIDSet=new HashSet();
        for (int x=0; x < members.length; x++) {
          Integer epersonID=new Integer(members[x].getID());
          memberSet.add(epersonID);
        }
        for (int x=0; x < eperson_ids.length; x++) {
          epersonIDSet.add(new Integer(eperson_ids[x]));
        }
        Iterator i=epersonIDSet.iterator();
        while (i.hasNext()) {
          Integer currentID=(Integer)i.next();
          if (!memberSet.contains(currentID)) {
            group.addMember(EPerson.find(c,currentID.intValue()));
          }
        }
        for (int x=0; x < members.length; x++) {
          EPerson e=members[x];
          if (!epersonIDSet.contains(new Integer(e.getID()))) {
            group.removeMember(e);
          }
        }
      }
 else {
        for (int y=0; y < members.length; y++) {
          group.removeMember(members[y]);
        }
      }
      if (group_ids != null) {
        Set memberSet=new HashSet();
        Set groupIDSet=new HashSet();
        for (int x=0; x < membergroups.length; x++) {
          Integer myID=new Integer(membergroups[x].getID());
          memberSet.add(myID);
        }
        for (int x=0; x < group_ids.length; x++) {
          groupIDSet.add(new Integer(group_ids[x]));
        }
        Iterator i=groupIDSet.iterator();
        while (i.hasNext()) {
          Integer currentID=(Integer)i.next();
          if (!memberSet.contains(currentID)) {
            group.addMember(Group.find(c,currentID.intValue()));
          }
        }
        for (int x=0; x < membergroups.length; x++) {
          Group g=membergroups[x];
          if (!groupIDSet.contains(new Integer(g.getID()))) {
            group.removeMember(g);
          }
        }
      }
 else {
        for (int y=0; y < membergroups.length; y++) {
          group.removeMember(membergroups[y]);
        }
      }
      group.update();
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else     if (submit_group_delete) {
      AuthorizeManager.authorizeAction(c,group,Constants.WRITE);
      group.delete();
      showMainPage(c,request,response);
    }
 else {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
    if (button.equals(""String_Node_Str"")) {
      group=Group.create(c);
      group.setName(""String_Node_Str"" + group.getID());
      group.update();
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else {
      showMainPage(c,request,response);
    }
  }
}",0.9978614200171086
52510,"/** 
 * Retrieve all e-person records from the database, sorted by a particular field. Fields are: <<<<<<< EPerson.java <ul> <li><code>ID</code></li> <li><code>LASTNAME</code></li> <li><code>EMAIL</code></li> <li><code>NETID</code></li> </ul> ======= <UL> <LI><code>ID</code></LI> <LI><code>LASTNAME</code></LI> <LI><code>EMAIL</code></LI> <LI><code>NETID</code></LI> </UL>
 * @return array of EPerson objects >>>>>>> 1.27
 */
public static EPerson[] findAll(Context context,int sortField) throws SQLException {
  String s;
switch (sortField) {
case ID:
    s=""String_Node_Str"";
  break;
case EMAIL:
s=""String_Node_Str"";
break;
case NETID:
s=""String_Node_Str"";
break;
default :
s=""String_Node_Str"";
}
TableRowIterator rows=DatabaseManager.query(context,""String_Node_Str"" + s);
List epeopleRows=rows.toList();
EPerson[] epeople=new EPerson[epeopleRows.size()];
for (int i=0; i < epeopleRows.size(); i++) {
TableRow row=(TableRow)epeopleRows.get(i);
EPerson fromCache=(EPerson)context.fromCache(EPerson.class,row.getIntColumn(""String_Node_Str""));
if (fromCache != null) {
epeople[i]=fromCache;
}
 else {
epeople[i]=new EPerson(context,row);
}
}
return epeople;
}","/** 
 * Retrieve all e-person records from the database, sorted by a particular field. Fields are: <ul> <li><code>ID</code></li> <li><code>LASTNAME</code></li> <li><code>EMAIL</code></li> <li><code>NETID</code></li> </ul>
 * @return array of EPerson objects
 */
public static EPerson[] findAll(Context context,int sortField) throws SQLException {
  String s;
switch (sortField) {
case ID:
    s=""String_Node_Str"";
  break;
case EMAIL:
s=""String_Node_Str"";
break;
case NETID:
s=""String_Node_Str"";
break;
default :
s=""String_Node_Str"";
}
TableRowIterator rows=DatabaseManager.query(context,""String_Node_Str"" + s);
List epeopleRows=rows.toList();
EPerson[] epeople=new EPerson[epeopleRows.size()];
for (int i=0; i < epeopleRows.size(); i++) {
TableRow row=(TableRow)epeopleRows.get(i);
EPerson fromCache=(EPerson)context.fromCache(EPerson.class,row.getIntColumn(""String_Node_Str""));
if (fromCache != null) {
epeople[i]=fromCache;
}
 else {
epeople[i]=new EPerson(context,row);
}
}
return epeople;
}",0.9234338747099768
52511,"/** 
 * Prune the history records from the database.
 * @param interests set of results and the duration of time before they are removed from the database
 * @return number of bitstreams deleted
 */
public int prune(Map interests){
  Connection conn=null;
  try {
    conn=DatabaseManager.getConnection();
    long now=System.currentTimeMillis();
    int count=0;
    for (Iterator iter=interests.keySet().iterator(); iter.hasNext(); ) {
      String result=(String)iter.next();
      Long dur=(Long)interests.get(result);
      count+=deleteHistoryByDateAndCode(new Date(now - dur.longValue()),result,conn);
    }
    return count;
  }
 catch (  SQLException e) {
    LOG.error(""String_Node_Str"" + e.getMessage(),e);
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    DatabaseManager.freeConnection(conn);
  }
}","/** 
 * Prune the history records from the database.
 * @param interests set of results and the duration of time before they are removed from the database
 * @return number of bitstreams deleted
 */
public int prune(Map interests){
  Connection conn=null;
  try {
    conn=DatabaseManager.getConnection();
    long now=System.currentTimeMillis();
    int count=0;
    for (Iterator iter=interests.keySet().iterator(); iter.hasNext(); ) {
      String result=(String)iter.next();
      Long dur=(Long)interests.get(result);
      count+=deleteHistoryByDateAndCode(new Date(now - dur.longValue()),result,conn);
      conn.commit();
    }
    return count;
  }
 catch (  SQLException e) {
    LOG.error(""String_Node_Str"" + e.getMessage(),e);
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    DatabaseManager.freeConnection(conn);
  }
}",0.9877977919814062
52512,"private static boolean cacheMe(Class implClass){
  if (cacheMeCache.containsKey(implClass))   return ((Boolean)cacheMeCache.get(implClass)).booleanValue();
 else {
    boolean reusable=true;
    String key=REUSABLE_PREFIX + implClass.getName();
    if (ConfigurationManager.getProperty(key) != null)     reusable=ConfigurationManager.getBooleanProperty(key);
    cacheMeCache.put(implClass,new Boolean(reusable));
    return reusable;
  }
}","private static boolean cacheMe(Class implClass){
  if (cacheMeCache.containsKey(implClass)) {
    return ((Boolean)cacheMeCache.get(implClass)).booleanValue();
  }
 else {
    String key=REUSABLE_PREFIX + implClass.getName();
    boolean reusable=ConfigurationManager.getBooleanProperty(key,true);
    cacheMeCache.put(implClass,new Boolean(reusable));
    return reusable;
  }
}",0.6862026862026862
52513,"private static Object getAnonymousPlugin(String classname) throws PluginInstantiationException {
  try {
    Class pluginClass=Class.forName(classname);
    if (cacheMe(pluginClass)) {
      Object cached=anonymousInstanceCache.get(pluginClass);
      if (cached == null) {
        cached=pluginClass.newInstance();
        anonymousInstanceCache.put(pluginClass,cached);
      }
      return cached;
    }
 else     return pluginClass.newInstance();
  }
 catch (  ClassNotFoundException e) {
    throw new PluginInstantiationException(""String_Node_Str"",e);
  }
catch (  InstantiationException e) {
    throw new PluginInstantiationException(e);
  }
catch (  IllegalAccessException e) {
    throw new PluginInstantiationException(e);
  }
}","private static Object getAnonymousPlugin(String classname) throws PluginInstantiationException {
  try {
    Class pluginClass=Class.forName(classname);
    if (cacheMe(pluginClass)) {
      Object cached=anonymousInstanceCache.get(pluginClass);
      if (cached == null) {
        cached=pluginClass.newInstance();
        anonymousInstanceCache.put(pluginClass,cached);
      }
      return cached;
    }
 else     return pluginClass.newInstance();
  }
 catch (  ClassNotFoundException e) {
    throw new PluginInstantiationException(""String_Node_Str"" + e.toString(),e);
  }
catch (  InstantiationException e) {
    throw new PluginInstantiationException(e);
  }
catch (  IllegalAccessException e) {
    throw new PluginInstantiationException(e);
  }
}",0.9899531145344944
52514,"/** 
 * Returns an instance of a plugin that implements the interface intface and is bound to a name matching name.  If there is no matching plugin, it returns null.  The names are matched by String.equals().
 * @param intfc the interface class of the plugin
 * @param name under which the plugin implementation is configured.
 * @return instance of plugin implementation, or null if there is no match or an error.
 */
public static Object getNamedPlugin(Class intfc,String name) throws PluginInstantiationException {
  try {
    String iname=intfc.getName();
    configureNamedPlugin(iname);
    String key=iname + SEP + name;
    String cname=(String)namedPluginClasses.get(key);
    if (cname == null)     log.warn(""String_Node_Str"" + iname + ""String_Node_Str""+ name+ ""String_Node_Str"");
 else {
      Class pluginClass=Class.forName(cname);
      if (cacheMe(pluginClass)) {
        String nkey=pluginClass.getName() + SEP + name;
        Object cached=namedInstanceCache.get(nkey);
        if (cached == null) {
          cached=pluginClass.newInstance();
          if (cached instanceof SelfNamedPlugin)           ((SelfNamedPlugin)cached).setPluginInstanceName(name);
          namedInstanceCache.put(nkey,cached);
        }
        return cached;
      }
 else {
        Object result=pluginClass.newInstance();
        if (result instanceof SelfNamedPlugin)         ((SelfNamedPlugin)result).setPluginInstanceName(name);
      }
    }
  }
 catch (  ClassNotFoundException e) {
    throw new PluginInstantiationException(""String_Node_Str"",e);
  }
catch (  InstantiationException e) {
    throw new PluginInstantiationException(e);
  }
catch (  IllegalAccessException e) {
    throw new PluginInstantiationException(e);
  }
  return null;
}","/** 
 * Returns an instance of a plugin that implements the interface intface and is bound to a name matching name.  If there is no matching plugin, it returns null.  The names are matched by String.equals().
 * @param intfc the interface class of the plugin
 * @param name under which the plugin implementation is configured.
 * @return instance of plugin implementation, or null if there is no match or an error.
 */
public static Object getNamedPlugin(Class intfc,String name) throws PluginInstantiationException {
  try {
    String iname=intfc.getName();
    configureNamedPlugin(iname);
    String key=iname + SEP + name;
    String cname=(String)namedPluginClasses.get(key);
    if (cname == null)     log.warn(""String_Node_Str"" + iname + ""String_Node_Str""+ name+ ""String_Node_Str"");
 else {
      Class pluginClass=Class.forName(cname);
      if (cacheMe(pluginClass)) {
        String nkey=pluginClass.getName() + SEP + name;
        Object cached=namedInstanceCache.get(nkey);
        if (cached == null) {
          log.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ iname+ ""String_Node_Str""+ name);
          cached=pluginClass.newInstance();
          if (cached instanceof SelfNamedPlugin)           ((SelfNamedPlugin)cached).setPluginInstanceName(name);
          namedInstanceCache.put(nkey,cached);
        }
        return cached;
      }
 else {
        log.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ iname+ ""String_Node_Str""+ name);
        Object result=pluginClass.newInstance();
        if (result instanceof SelfNamedPlugin)         ((SelfNamedPlugin)result).setPluginInstanceName(name);
        return result;
      }
    }
  }
 catch (  ClassNotFoundException e) {
    throw new PluginInstantiationException(""String_Node_Str"" + e.toString(),e);
  }
catch (  InstantiationException e) {
    throw new PluginInstantiationException(e);
  }
catch (  IllegalAccessException e) {
    throw new PluginInstantiationException(e);
  }
  return null;
}",0.9367292225201072
52515,"private static void configureNamedPlugin(String iname) throws ClassNotFoundException {
  int found=0;
  if (!namedPluginClasses.containsKey(iname)) {
    String namedVal=ConfigurationManager.getProperty(NAMED_PREFIX + iname);
    if (namedVal != null) {
      log.debug(""String_Node_Str"" + iname + ""String_Node_Str""+ namedVal);
      Pattern classnameEqual=Pattern.compile(""String_Node_Str"");
      int prevEnd=-1;
      String prevClassName=null;
      Matcher classMatcher=classnameEqual.matcher(namedVal);
      while (classMatcher.find()) {
        if (prevClassName != null)         found+=installNamedConfigs(iname,prevClassName,namedVal.substring(prevEnd,classMatcher.start()).trim().split(""String_Node_Str""));
        prevClassName=classMatcher.group(1);
        prevEnd=classMatcher.end();
      }
      if (prevClassName != null)       found+=installNamedConfigs(iname,prevClassName,namedVal.substring(prevEnd).trim().split(""String_Node_Str""));
    }
    String selfNamedVal=ConfigurationManager.getProperty(SELFNAMED_PREFIX + iname);
    if (selfNamedVal != null) {
      String classnames[]=selfNamedVal.split(""String_Node_Str"");
      for (int i=0; i < classnames.length; ++i) {
        Class pluginClass=Class.forName(classnames[i]);
        try {
          String names[]=(String[])pluginClass.getMethod(""String_Node_Str"",null).invoke(null,null);
          if (names == null || names.length == 0)           log.error(""String_Node_Str"" + classnames[i] + ""String_Node_Str"");
 else           found+=installNamedConfigs(iname,classnames[i],names);
        }
 catch (        NoSuchMethodException e) {
          log.error(""String_Node_Str"" + classnames[i] + ""String_Node_Str"");
        }
catch (        Exception e) {
          log.error(e.toString());
        }
      }
    }
    namedPluginClasses.put(iname,""String_Node_Str"");
    if (found == 0)     log.error(""String_Node_Str"" + iname);
  }
}","private static void configureNamedPlugin(String iname) throws ClassNotFoundException {
  int found=0;
  if (!namedPluginClasses.containsKey(iname)) {
    String namedVal=ConfigurationManager.getProperty(NAMED_PREFIX + iname);
    if (namedVal != null) {
      log.debug(""String_Node_Str"" + iname + ""String_Node_Str""+ namedVal);
      Pattern classnameEqual=Pattern.compile(""String_Node_Str"");
      int prevEnd=-1;
      String prevClassName=null;
      Matcher classMatcher=classnameEqual.matcher(namedVal);
      while (classMatcher.find()) {
        if (prevClassName != null)         found+=installNamedConfigs(iname,prevClassName,namedVal.substring(prevEnd,classMatcher.start()).trim().split(""String_Node_Str""));
        prevClassName=classMatcher.group(1);
        prevEnd=classMatcher.end();
      }
      if (prevClassName != null)       found+=installNamedConfigs(iname,prevClassName,namedVal.substring(prevEnd).trim().split(""String_Node_Str""));
    }
    String selfNamedVal=ConfigurationManager.getProperty(SELFNAMED_PREFIX + iname);
    if (selfNamedVal != null) {
      String classnames[]=selfNamedVal.split(""String_Node_Str"");
      for (int i=0; i < classnames.length; ++i) {
        try {
          Class pluginClass=Class.forName(classnames[i]);
          String names[]=(String[])pluginClass.getMethod(""String_Node_Str"",null).invoke(null,null);
          if (names == null || names.length == 0)           log.error(""String_Node_Str"" + classnames[i] + ""String_Node_Str"");
 else           found+=installNamedConfigs(iname,classnames[i],names);
        }
 catch (        NoSuchMethodException e) {
          log.error(""String_Node_Str"" + classnames[i] + ""String_Node_Str"");
        }
catch (        Exception e) {
          log.error(""String_Node_Str"" + e.toString());
        }
      }
    }
    namedPluginClasses.put(iname,""String_Node_Str"");
    if (found == 0)     log.error(""String_Node_Str"" + iname);
  }
}",0.98696558915537
52516,"/** 
 * Export the object (Item, Collection, or Community) to a package file on the indicated OutputStream. Gets an exception of the object cannot be packaged or there is a failure creating the package.
 * @param context - DSpace context.
 * @param dso - DSpace object (item, collection, etc)
 * @param pkg - output stream on which to write package
 * @throws PackageException if package cannot be created or there isa fatal error in creating it.
 */
public void disseminate(Context context,DSpaceObject dso,PackageParameters params,OutputStream pkg) throws PackageValidationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (dso.getType() == Constants.ITEM) {
    Item item=(Item)dso;
    if (params != null && params.getProperty(""String_Node_Str"") != null) {
      extraFiles=null;
      writeManifest(context,item,params,pkg);
    }
 else {
      extraFiles=new HashMap();
      ZipOutputStream zip=new ZipOutputStream(pkg);
      zip.setComment(""String_Node_Str"");
      ZipEntry me=new ZipEntry(MANIFEST_FILE);
      zip.putNextEntry(me);
      writeManifest(context,item,params,zip);
      zip.closeEntry();
      Iterator fi=extraFiles.keySet().iterator();
      while (fi.hasNext()) {
        String fname=(String)fi.next();
        ZipEntry ze=new ZipEntry(fname);
        zip.putNextEntry(ze);
        Utils.copy((InputStream)extraFiles.get(fname),zip);
        zip.closeEntry();
      }
      Bundle bundles[]=item.getBundles();
      for (int i=0; i < bundles.length; i++) {
        if (!PackageUtils.isMetaInfoBundle(bundles[i])) {
          Bitstream[] bitstreams=bundles[i].getBitstreams();
          for (int k=0; k < bitstreams.length; k++) {
            if (AuthorizeManager.authorizeActionBoolean(context,bitstreams[k],Constants.READ)) {
              ZipEntry ze=new ZipEntry(makeBitstreamName(bitstreams[k]));
              ze.setSize(bitstreams[k].getSize());
              zip.putNextEntry(ze);
              Utils.copy(bitstreams[k].retrieve(),zip);
              zip.closeEntry();
            }
          }
        }
      }
      zip.close();
      extraFiles=null;
    }
  }
 else   throw new PackageValidationException(""String_Node_Str"");
}","/** 
 * Export the object (Item, Collection, or Community) to a package file on the indicated OutputStream. Gets an exception of the object cannot be packaged or there is a failure creating the package.
 * @param context - DSpace context.
 * @param dso - DSpace object (item, collection, etc)
 * @param pkg - output stream on which to write package
 * @throws PackageException if package cannot be created or there isa fatal error in creating it.
 */
public void disseminate(Context context,DSpaceObject dso,PackageParameters params,OutputStream pkg) throws PackageValidationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (dso.getType() == Constants.ITEM) {
    Item item=(Item)dso;
    long lmTime=item.getLastModified().getTime();
    String unauth=(params == null) ? null : params.getProperty(""String_Node_Str"");
    if (params != null && params.getProperty(""String_Node_Str"") != null) {
      extraFiles=null;
      writeManifest(context,item,params,pkg);
    }
 else {
      extraFiles=new HashMap();
      ZipOutputStream zip=new ZipOutputStream(pkg);
      zip.setComment(""String_Node_Str"");
      ZipEntry me=new ZipEntry(MANIFEST_FILE);
      me.setTime(lmTime);
      zip.putNextEntry(me);
      writeManifest(context,item,params,zip);
      zip.closeEntry();
      Iterator fi=extraFiles.keySet().iterator();
      while (fi.hasNext()) {
        String fname=(String)fi.next();
        ZipEntry ze=new ZipEntry(fname);
        ze.setTime(lmTime);
        zip.putNextEntry(ze);
        Utils.copy((InputStream)extraFiles.get(fname),zip);
        zip.closeEntry();
      }
      Bundle bundles[]=item.getBundles();
      for (int i=0; i < bundles.length; i++) {
        if (!PackageUtils.isMetaInfoBundle(bundles[i])) {
          if (!AuthorizeManager.authorizeActionBoolean(context,bundles[i],Constants.READ)) {
            if (unauth != null && (unauth.equalsIgnoreCase(""String_Node_Str""))) {
              log.warn(""String_Node_Str"" + bundles[i].getName() + ""String_Node_Str"");
              continue;
            }
 else             throw new AuthorizeException(""String_Node_Str"" + bundles[i].getName() + ""String_Node_Str"");
          }
          Bitstream[] bitstreams=bundles[i].getBitstreams();
          for (int k=0; k < bitstreams.length; k++) {
            boolean auth=AuthorizeManager.authorizeActionBoolean(context,bitstreams[k],Constants.READ);
            if (auth || (unauth != null && unauth.equalsIgnoreCase(""String_Node_Str""))) {
              ZipEntry ze=new ZipEntry(makeBitstreamName(bitstreams[k]));
              ze.setTime(lmTime);
              ze.setSize(auth ? bitstreams[k].getSize() : 0);
              zip.putNextEntry(ze);
              if (auth)               Utils.copy(bitstreams[k].retrieve(),zip);
 else               log.warn(""String_Node_Str"" + String.valueOf(bitstreams[k].getSequenceID()) + ""String_Node_Str"");
              zip.closeEntry();
            }
 else             if (unauth != null && unauth.equalsIgnoreCase(""String_Node_Str"")) {
              log.warn(""String_Node_Str"" + String.valueOf(bitstreams[k].getSequenceID()) + ""String_Node_Str"");
            }
 else {
              throw new AuthorizeException(""String_Node_Str"" + String.valueOf(bitstreams[k].getSequenceID()));
            }
          }
        }
      }
      zip.close();
      extraFiles=null;
    }
  }
 else   throw new PackageValidationException(""String_Node_Str"");
}",0.740911509132825
52517,"/** 
 * Write out a METS manifest. Mostly lifted from Rob Tansley's METS exporter.
 */
private void writeManifest(Context context,Item item,PackageParameters params,OutputStream out) throws PackageValidationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  try {
    Mets mets=new Mets();
    mets.setID(gensym(""String_Node_Str""));
    mets.setOBJID(""String_Node_Str"" + item.getHandle());
    mets.setLABEL(""String_Node_Str"");
    mets.setPROFILE(getProfile());
    MetsHdr metsHdr=new MetsHdr();
    metsHdr.setCREATEDATE(new Date());
    Agent agent=new Agent();
    agent.setROLE(Role.CUSTODIAN);
    agent.setTYPE(Type.ORGANIZATION);
    Name name=new Name();
    name.getContent().add(new PCData(ConfigurationManager.getProperty(""String_Node_Str"")));
    agent.getContent().add(name);
    metsHdr.getContent().add(agent);
    mets.getContent().add(metsHdr);
    String dmdTypes[]=getDmdTypes(params);
    String dmdGroup=gensym(""String_Node_Str"");
    String dmdId[]=new String[dmdTypes.length];
    for (int i=0; i < dmdTypes.length; ++i) {
      dmdId[i]=gensym(""String_Node_Str"");
      XmlData xmlData=new XmlData();
      String xwalkName, metsName;
      String parts[]=dmdTypes[i].split(""String_Node_Str"",2);
      if (parts.length > 1) {
        metsName=parts[0];
        xwalkName=parts[1];
      }
 else       xwalkName=metsName=dmdTypes[i];
      DisseminationCrosswalk xwalk=(DisseminationCrosswalk)PluginManager.getNamedPlugin(DisseminationCrosswalk.class,xwalkName);
      if (xwalk == null)       throw new PackageValidationException(""String_Node_Str"" + dmdTypes[i] + ""String_Node_Str"");
 else       crosswalkToMets(xwalk,item,xmlData);
      DmdSec dmdSec=new DmdSec();
      dmdSec.setID(dmdId[i]);
      dmdSec.setGROUPID(dmdGroup);
      MdWrap mdWrap=new MdWrap();
      setMdType(mdWrap,metsName);
      mdWrap.getContent().add(xmlData);
      dmdSec.getContent().add(mdWrap);
      mets.getContent().add(dmdSec);
    }
    String licenseID=null;
    AmdSec amdSec=new AmdSec();
    addRightsMd(context,item,amdSec);
    if (amdSec.getContent().size() > 0) {
      licenseID=gensym(""String_Node_Str"");
      amdSec.setID(licenseID);
      mets.getContent().add(amdSec);
    }
    FileSec fileSec=new FileSec();
    String techMdType=getTechMdType(params);
    String parts[]=techMdType.split(""String_Node_Str"",2);
    String xwalkName, metsName;
    if (parts.length > 1) {
      metsName=parts[0];
      xwalkName=parts[1];
    }
 else     xwalkName=metsName=techMdType;
    DisseminationCrosswalk xwalk=(DisseminationCrosswalk)PluginManager.getNamedPlugin(DisseminationCrosswalk.class,xwalkName);
    if (xwalk == null)     throw new PackageValidationException(""String_Node_Str"" + xwalkName + ""String_Node_Str"");
    String primaryBitstreamFileID=null;
    List contentDivs=new ArrayList();
    Bundle[] bundles=item.getBundles();
    for (int i=0; i < bundles.length; i++) {
      if (PackageUtils.isMetaInfoBundle(bundles[i]))       continue;
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      FileGrp fileGrp=new FileGrp();
      String bName=bundles[i].getName();
      if ((bName != null) && !bName.equals(""String_Node_Str""))       fileGrp.setUSE(bundleToFileGrp(bName));
      int primaryBitstreamID=-1;
      boolean isContentBundle=false;
      if ((bName != null) && bName.equals(""String_Node_Str"")) {
        isContentBundle=true;
        primaryBitstreamID=bundles[i].getPrimaryBitstreamID();
      }
      for (int bits=0; bits < bitstreams.length; bits++) {
        String sid=String.valueOf(bitstreams[bits].getSequenceID());
        edu.harvard.hul.ois.mets.File file=new edu.harvard.hul.ois.mets.File();
        String xmlIDstart=""String_Node_Str"";
        String fileID=xmlIDstart + sid;
        file.setID(fileID);
        if (bitstreams[bits].getID() == primaryBitstreamID)         primaryBitstreamFileID=fileID;
        if (isContentBundle) {
          Div div=new Div();
          div.setID(gensym(""String_Node_Str""));
          div.setTYPE(""String_Node_Str"");
          Fptr fptr=new Fptr();
          fptr.setFILEID(fileID);
          div.getContent().add(fptr);
          contentDivs.add(div);
        }
        file.setSEQ(bitstreams[bits].getSequenceID());
        String groupID=""String_Node_Str"" + xmlIDstart + sid;
        if ((bundles[i].getName() != null) && (bundles[i].getName().equals(""String_Node_Str"") || bundles[i].getName().startsWith(""String_Node_Str""))) {
          Bitstream original=findOriginalBitstream(item,bitstreams[bits]);
          if (original != null) {
            groupID=""String_Node_Str"" + xmlIDstart + original.getSequenceID();
          }
        }
        file.setGROUPID(groupID);
        file.setMIMETYPE(bitstreams[bits].getFormat().getMIMEType());
        file.setSIZE(bitstreams[bits].getSize());
        String csType=bitstreams[bits].getChecksumAlgorithm();
        String cs=bitstreams[bits].getChecksum();
        if (cs != null && csType != null) {
          try {
            file.setCHECKSUMTYPE(Checksumtype.parse(csType));
            file.setCHECKSUM(cs);
          }
 catch (          MetsException e) {
            log.warn(""String_Node_Str"" + csType + ""String_Node_Str"");
          }
        }
        FLocat flocat=new FLocat();
        flocat.setLOCTYPE(Loctype.URL);
        flocat.setXlinkHref(makeBitstreamName(bitstreams[bits]));
        String techID=""String_Node_Str"" + bitstreams[bits].getSequenceID();
        AmdSec fAmdSec=new AmdSec();
        fAmdSec.setID(techID);
        TechMD techMd=new TechMD();
        techMd.setID(gensym(""String_Node_Str""));
        MdWrap mdWrap=new MdWrap();
        setMdType(mdWrap,metsName);
        XmlData xmlData=new XmlData();
        mdWrap.getContent().add(xmlData);
        techMd.getContent().add(mdWrap);
        fAmdSec.getContent().add(techMd);
        mets.getContent().add(fAmdSec);
        crosswalkToMets(xwalk,bitstreams[bits],xmlData);
        file.setADMID(techID);
        file.getContent().add(flocat);
        fileGrp.getContent().add(file);
      }
      fileSec.getContent().add(fileGrp);
    }
    mets.getContent().add(fileSec);
    StringBuffer dmdIds=new StringBuffer();
    for (int i=0; i < dmdId.length; ++i)     dmdIds.append(""String_Node_Str"" + dmdId[i]);
    StructMap structMap=new StructMap();
    structMap.setID(gensym(""String_Node_Str""));
    structMap.setTYPE(""String_Node_Str"");
    structMap.setLABEL(""String_Node_Str"");
    Div div0=new Div();
    div0.setID(gensym(""String_Node_Str""));
    div0.setTYPE(""String_Node_Str"");
    div0.setDMDID(dmdIds.substring(1));
    if (licenseID != null)     div0.setADMID(licenseID);
    if (primaryBitstreamFileID != null) {
      Fptr fptr=new Fptr();
      fptr.setFILEID(primaryBitstreamFileID);
      div0.getContent().add(fptr);
    }
    div0.getContent().addAll(contentDivs);
    structMap.getContent().add(div0);
    addStructMap(context,item,params,mets);
    mets.getContent().add(structMap);
    mets.validate(new MetsValidator());
    mets.write(new MetsWriter(out));
  }
 catch (  MetsException e) {
    throw new PackageValidationException(e);
  }
}","/** 
 * Write out a METS manifest. Mostly lifted from Rob Tansley's METS exporter.
 */
private void writeManifest(Context context,Item item,PackageParameters params,OutputStream out) throws PackageValidationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  try {
    Mets mets=new Mets();
    mets.setID(gensym(""String_Node_Str""));
    mets.setOBJID(""String_Node_Str"" + item.getHandle());
    mets.setLABEL(""String_Node_Str"");
    mets.setPROFILE(getProfile());
    MetsHdr metsHdr=new MetsHdr();
    metsHdr.setCREATEDATE(new Date());
    Agent agent=new Agent();
    agent.setROLE(Role.CUSTODIAN);
    agent.setTYPE(Type.ORGANIZATION);
    Name name=new Name();
    name.getContent().add(new PCData(ConfigurationManager.getProperty(""String_Node_Str"")));
    agent.getContent().add(name);
    metsHdr.getContent().add(agent);
    mets.getContent().add(metsHdr);
    String dmdTypes[]=getDmdTypes(params);
    String dmdGroup=gensym(""String_Node_Str"");
    String dmdId[]=new String[dmdTypes.length];
    for (int i=0; i < dmdTypes.length; ++i) {
      dmdId[i]=gensym(""String_Node_Str"");
      XmlData xmlData=new XmlData();
      String xwalkName, metsName;
      String parts[]=dmdTypes[i].split(""String_Node_Str"",2);
      if (parts.length > 1) {
        metsName=parts[0];
        xwalkName=parts[1];
      }
 else       xwalkName=metsName=dmdTypes[i];
      DisseminationCrosswalk xwalk=(DisseminationCrosswalk)PluginManager.getNamedPlugin(DisseminationCrosswalk.class,xwalkName);
      if (xwalk == null)       throw new PackageValidationException(""String_Node_Str"" + dmdTypes[i] + ""String_Node_Str"");
 else       crosswalkToMets(xwalk,item,xmlData);
      DmdSec dmdSec=new DmdSec();
      dmdSec.setID(dmdId[i]);
      dmdSec.setGROUPID(dmdGroup);
      MdWrap mdWrap=new MdWrap();
      setMdType(mdWrap,metsName);
      mdWrap.getContent().add(xmlData);
      dmdSec.getContent().add(mdWrap);
      mets.getContent().add(dmdSec);
    }
    String licenseID=null;
    try {
      AmdSec amdSec=new AmdSec();
      addRightsMd(context,item,amdSec);
      if (amdSec.getContent().size() > 0) {
        licenseID=gensym(""String_Node_Str"");
        amdSec.setID(licenseID);
        mets.getContent().add(amdSec);
      }
    }
 catch (    AuthorizeException e) {
      String unauth=(params == null) ? null : params.getProperty(""String_Node_Str"");
      if (!(unauth != null && unauth.equalsIgnoreCase(""String_Node_Str"")))       throw e;
 else       log.warn(""String_Node_Str"" + e.toString());
    }
    FileSec fileSec=new FileSec();
    String techMdType=getTechMdType(params);
    String parts[]=techMdType.split(""String_Node_Str"",2);
    String xwalkName, metsName;
    if (parts.length > 1) {
      metsName=parts[0];
      xwalkName=parts[1];
    }
 else     xwalkName=metsName=techMdType;
    DisseminationCrosswalk xwalk=(DisseminationCrosswalk)PluginManager.getNamedPlugin(DisseminationCrosswalk.class,xwalkName);
    if (xwalk == null)     throw new PackageValidationException(""String_Node_Str"" + xwalkName + ""String_Node_Str"");
    String primaryBitstreamFileID=null;
    List contentDivs=new ArrayList();
    String unauth=(params == null) ? null : params.getProperty(""String_Node_Str"");
    Bundle[] bundles=item.getBundles();
    for (int i=0; i < bundles.length; i++) {
      if (PackageUtils.isMetaInfoBundle(bundles[i]))       continue;
      if (!AuthorizeManager.authorizeActionBoolean(context,bundles[i],Constants.READ)) {
        if (unauth != null && (unauth.equalsIgnoreCase(""String_Node_Str"")))         continue;
 else         throw new AuthorizeException(""String_Node_Str"" + bundles[i].getName() + ""String_Node_Str"");
      }
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      FileGrp fileGrp=new FileGrp();
      String bName=bundles[i].getName();
      if ((bName != null) && !bName.equals(""String_Node_Str""))       fileGrp.setUSE(bundleToFileGrp(bName));
      int primaryBitstreamID=-1;
      boolean isContentBundle=false;
      if ((bName != null) && bName.equals(""String_Node_Str"")) {
        isContentBundle=true;
        primaryBitstreamID=bundles[i].getPrimaryBitstreamID();
      }
      for (int bits=0; bits < bitstreams.length; bits++) {
        boolean auth=AuthorizeManager.authorizeActionBoolean(context,bitstreams[bits],Constants.READ);
        if (!auth) {
          if (unauth != null && unauth.equalsIgnoreCase(""String_Node_Str""))           continue;
 else           if (!(unauth != null && unauth.equalsIgnoreCase(""String_Node_Str"")))           throw new AuthorizeException(""String_Node_Str"" + String.valueOf(bitstreams[bits].getSequenceID()));
        }
        String sid=String.valueOf(bitstreams[bits].getSequenceID());
        edu.harvard.hul.ois.mets.File file=new edu.harvard.hul.ois.mets.File();
        String xmlIDstart=""String_Node_Str"";
        String fileID=xmlIDstart + sid;
        file.setID(fileID);
        if (bitstreams[bits].getID() == primaryBitstreamID)         primaryBitstreamFileID=fileID;
        if (isContentBundle) {
          Div div=new Div();
          div.setID(gensym(""String_Node_Str""));
          div.setTYPE(""String_Node_Str"");
          Fptr fptr=new Fptr();
          fptr.setFILEID(fileID);
          div.getContent().add(fptr);
          contentDivs.add(div);
        }
        file.setSEQ(bitstreams[bits].getSequenceID());
        String groupID=""String_Node_Str"" + xmlIDstart + sid;
        if ((bundles[i].getName() != null) && (bundles[i].getName().equals(""String_Node_Str"") || bundles[i].getName().startsWith(""String_Node_Str""))) {
          Bitstream original=findOriginalBitstream(item,bitstreams[bits]);
          if (original != null) {
            groupID=""String_Node_Str"" + xmlIDstart + original.getSequenceID();
          }
        }
        file.setGROUPID(groupID);
        file.setMIMETYPE(bitstreams[bits].getFormat().getMIMEType());
        file.setSIZE(auth ? bitstreams[bits].getSize() : 0);
        String csType=bitstreams[bits].getChecksumAlgorithm();
        String cs=bitstreams[bits].getChecksum();
        if (auth && cs != null && csType != null) {
          try {
            file.setCHECKSUMTYPE(Checksumtype.parse(csType));
            file.setCHECKSUM(cs);
          }
 catch (          MetsException e) {
            log.warn(""String_Node_Str"" + csType + ""String_Node_Str"");
          }
        }
        FLocat flocat=new FLocat();
        flocat.setLOCTYPE(Loctype.URL);
        flocat.setXlinkHref(makeBitstreamName(bitstreams[bits]));
        String techID=""String_Node_Str"" + bitstreams[bits].getSequenceID();
        AmdSec fAmdSec=new AmdSec();
        fAmdSec.setID(techID);
        TechMD techMd=new TechMD();
        techMd.setID(gensym(""String_Node_Str""));
        MdWrap mdWrap=new MdWrap();
        setMdType(mdWrap,metsName);
        XmlData xmlData=new XmlData();
        mdWrap.getContent().add(xmlData);
        techMd.getContent().add(mdWrap);
        fAmdSec.getContent().add(techMd);
        mets.getContent().add(fAmdSec);
        crosswalkToMets(xwalk,bitstreams[bits],xmlData);
        file.setADMID(techID);
        file.getContent().add(flocat);
        fileGrp.getContent().add(file);
      }
      fileSec.getContent().add(fileGrp);
    }
    mets.getContent().add(fileSec);
    StringBuffer dmdIds=new StringBuffer();
    for (int i=0; i < dmdId.length; ++i)     dmdIds.append(""String_Node_Str"" + dmdId[i]);
    StructMap structMap=new StructMap();
    structMap.setID(gensym(""String_Node_Str""));
    structMap.setTYPE(""String_Node_Str"");
    structMap.setLABEL(""String_Node_Str"");
    Div div0=new Div();
    div0.setID(gensym(""String_Node_Str""));
    div0.setTYPE(""String_Node_Str"");
    div0.setDMDID(dmdIds.substring(1));
    if (licenseID != null)     div0.setADMID(licenseID);
    if (primaryBitstreamFileID != null) {
      Fptr fptr=new Fptr();
      fptr.setFILEID(primaryBitstreamFileID);
      div0.getContent().add(fptr);
    }
    div0.getContent().addAll(contentDivs);
    structMap.getContent().add(div0);
    addStructMap(context,item,params,mets);
    mets.getContent().add(structMap);
    mets.validate(new MetsValidator());
    mets.write(new MetsWriter(out));
  }
 catch (  MetsException e) {
    throw new PackageValidationException(e);
  }
}",0.9268134294434704
52518,"public void init(){
  String config=getServletContext().getInitParameter(""String_Node_Str"");
  ConfigurationManager.loadConfig(config);
  String log4jConfProp=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
  String log4jConfXml=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
  File xmlFile=new File(log4jConfXml);
  if (xmlFile.exists()) {
    try {
      DOMConfigurator.configure(xmlFile.toURL());
      log.info(""String_Node_Str"");
    }
 catch (    MalformedURLException e) {
      PropertyConfigurator.configure(log4jConfProp);
      log.error(""String_Node_Str"" + ""String_Node_Str"" + e);
    }
  }
 else {
    PropertyConfigurator.configure(log4jConfProp);
    log.info(""String_Node_Str"");
  }
}","public void init(){
  String config=getServletContext().getInitParameter(""String_Node_Str"");
  ConfigurationManager.loadConfig(config);
}",0.2759315206445116
52519,"/** 
 * Create a PreparedStatement to run the correct query for scope.
 * @param scope The Browse scope
 * @param subqueryValue If the focus is an item, this is its value in the browse index (its title, author, date, etc). Otherwise null.
 * @param after If true, create SQL to find the items after the focus. Otherwise create SQL to find the items before the focus.
 * @param isCount If true, create SQL to count the number of matches for the query. Otherwise just the query.
 * @return a prepared statement
 * @throws SQLException
 */
private static PreparedStatement createSql(BrowseScope scope,String subqueryValue,boolean after,boolean isCount) throws SQLException {
  String sqli=createSqlInternal(scope,subqueryValue,isCount);
  String sql=formatSql(scope,sqli,subqueryValue,after);
  PreparedStatement statement=createStatement(scope,sql);
  if (scope.hasFocus()) {
    String value=(subqueryValue != null) ? subqueryValue : (String)scope.getFocus();
    statement.setString(1,value);
    if (subqueryValue != null) {
      statement.setString(2,value);
    }
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + sql + ""String_Node_Str"");
  }
  return statement;
}","/** 
 * Create a PreparedStatement to run the correct query for scope.
 * @param scope The Browse scope
 * @param subqueryValue If the focus is an item, this is its value in the browse index (its title, author, date, etc). Otherwise null.
 * @param after If true, create SQL to find the items after the focus. Otherwise create SQL to find the items before the focus.
 * @param isCount If true, create SQL to count the number of matches for the query. Otherwise just the query.
 * @return a prepared statement
 * @throws SQLException
 */
private static PreparedStatement createSql(BrowseScope scope,String subqueryValue,boolean after,boolean isCount) throws SQLException {
  String sqli=createSqlInternal(scope,subqueryValue,isCount);
  String sql=formatSql(scope,sqli,subqueryValue,after);
  PreparedStatement statement=createStatement(scope,sql);
  if (scope.hasFocus()) {
    String value=subqueryValue;
    if (value == null && scope.getFocus() instanceof String) {
      value=(String)scope.getFocus();
    }
    statement.setString(1,value);
    if (subqueryValue != null) {
      statement.setString(2,value);
    }
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + sql + ""String_Node_Str"");
  }
  return statement;
}",0.8871499176276771
52520,"/** 
 * Create a list of the found history records.
 * @param history the list of history records to be iterated over.
 * @param osw the output stream writer to write to.
 * @throws IOException if io error occurs
 */
private void printHistoryRecords(List history,OutputStreamWriter osw) throws IOException {
  Iterator iter=history.iterator();
  while (iter.hasNext()) {
    ChecksumHistory historyInfo=(ChecksumHistory)iter.next();
    StringBuilder buf=new StringBuilder(1000);
    buf.append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getBitstreamId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(DATE_FORMAT_MAX.format(historyInfo.getProcessStartDate())).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(DATE_FORMAT_MAX.format(historyInfo.getProcessEndDate())).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getChecksumExpected()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getChecksumCalculated()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getResult()).append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
    osw.write(buf.toString());
  }
}","/** 
 * Create a list of the found history records.
 * @param history the list of history records to be iterated over.
 * @param osw the output stream writer to write to.
 * @throws IOException if io error occurs
 */
private void printHistoryRecords(List history,OutputStreamWriter osw) throws IOException {
  Iterator iter=history.iterator();
  while (iter.hasNext()) {
    ChecksumHistory historyInfo=(ChecksumHistory)iter.next();
    StringBuffer buf=new StringBuffer(1000);
    buf.append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getBitstreamId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(DATE_FORMAT_MAX.format(historyInfo.getProcessStartDate())).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(DATE_FORMAT_MAX.format(historyInfo.getProcessEndDate())).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getChecksumExpected()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getChecksumCalculated()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getResult()).append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
    osw.write(buf.toString());
  }
}",0.9964838255977496
52521,"/** 
 * Create a list of the found history records.
 * @param bitstreams the list of history records to be iterated over.
 * @param osw the output stream to write to.
 * @throws IOException if io error occurs
 */
private void printDSpaceInfoRecords(List bitstreams,OutputStreamWriter osw) throws IOException {
  Iterator iter=bitstreams.iterator();
  while (iter.hasNext()) {
    DSpaceBitstreamInfo info=(DSpaceBitstreamInfo)iter.next();
    StringBuilder buf=new StringBuilder(1000);
    buf.append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getBitstreamFormatId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getDeleted()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getBitstreamId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getChecksumAlgorithm()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getInternalId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getName()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getSize()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getSource()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getStoredChecksum()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getStoreNumber()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getUserFormatDescription()).append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
    osw.write(buf.toString());
  }
}","/** 
 * Create a list of the found history records.
 * @param bitstreams the list of history records to be iterated over.
 * @param osw the output stream to write to.
 * @throws IOException if io error occurs
 */
private void printDSpaceInfoRecords(List bitstreams,OutputStreamWriter osw) throws IOException {
  Iterator iter=bitstreams.iterator();
  while (iter.hasNext()) {
    DSpaceBitstreamInfo info=(DSpaceBitstreamInfo)iter.next();
    StringBuffer buf=new StringBuffer(1000);
    buf.append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getBitstreamFormatId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getDeleted()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getBitstreamId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getChecksumAlgorithm()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getInternalId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getName()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getSize()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getSource()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getStoredChecksum()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getStoreNumber()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getUserFormatDescription()).append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
    osw.write(buf.toString());
  }
}",0.9974146845915202
52522,"/** 
 * Slightly convenient method that appends together a msg key and a class name together and retrieves the corresponding message from Messages.properties
 * @param msg final part of message key, omitting fully qualified class name
 * @param classname fully qualified class name.
 * @return Localized message
 */
public String getMessage(String msg,String classname){
  return messages.getString(new StringBuilder(50).append(classname).append(""String_Node_Str"").append(msg).toString());
}","/** 
 * <p> Convenience method to get localized messages in code. Usage will be of the form: - </p> <pre> I18N.message(&quot;my-key&quot;, this); </pre> <p> N.B. That this method uses the runtime type of the object, and hence should only be used in final classes. </p>
 * @param msg Key for the message, omitting the fully qualified class name
 * @param obj the calling object
 * @return Localized message 
 */
public String getMessage(String msg,Object obj){
  return getMessage(msg,obj.getClass());
}",0.3423967774420947
52523,"/** 
 * Return true if an index has changed
 * @param key
 * @return
 * @throws SQLException
 */
public static boolean indexHasChanged(BrowseScope key) throws SQLException {
  Context context=null;
  try {
    context=new Context();
    TableRow results=countAndMax(context,key);
    long count=-1;
    int max=-1;
    if (results != null) {
      count=results.getLongColumn(""String_Node_Str"");
      max=results.getIntColumn(""String_Node_Str"");
    }
    context.complete();
    if ((count == getCount(key)) && (max == getMaximum(key))) {
      return false;
    }
    setMaximum(key,max);
    setCount(key,count);
    return true;
  }
 catch (  SQLException sqle) {
    if (context != null) {
      context.abort();
    }
    throw sqle;
  }
}","/** 
 * Return true if an index has changed
 * @param key
 * @return
 * @throws SQLException
 */
public static boolean indexHasChanged(BrowseScope key) throws SQLException {
  Context context=null;
  try {
    context=new Context();
    TableRow results=countAndMax(context,key);
    long count=-1;
    int max=-1;
    if (results != null) {
      if (""String_Node_Str"".equals(ConfigurationManager.getProperty(""String_Node_Str""))) {
        count=results.getIntColumn(""String_Node_Str"");
      }
 else {
        count=results.getLongColumn(""String_Node_Str"");
      }
      max=results.getIntColumn(""String_Node_Str"");
    }
    context.complete();
    if ((count == getCount(key)) && (max == getMaximum(key))) {
      return false;
    }
    setMaximum(key,max);
    setCount(key,count);
    return true;
  }
 catch (  SQLException sqle) {
    if (context != null) {
      context.abort();
    }
    throw sqle;
  }
}",0.8617788461538461
52524,"/** 
 * Create both the bitstreams and the contents file. Any bitstreams that were originally registered will be marked in the contents file as such. However, the export directory will contain actual copies of the content files being exported.
 * @param c the DSpace context
 * @param i the item being exported
 * @param destDir the item's export directory
 * @throws Exception if there is any problem writing to the export directory
 */
private static void writeBitstreams(Context c,Item i,File destDir) throws Exception {
  File outFile=new File(destDir,""String_Node_Str"");
  if (outFile.createNewFile()) {
    PrintWriter out=new PrintWriter(new FileWriter(outFile));
    Bundle[] bundles=i.getBundles();
    for (int j=0; j < bundles.length; j++) {
      Bitstream[] bitstreams=bundles[j].getBitstreams();
      String bundleName=bundles[j].getName();
      for (int k=0; k < bitstreams.length; k++) {
        Bitstream b=bitstreams[k];
        String myName=b.getName();
        String oldName=myName;
        int myPrefix=1;
        InputStream is=b.retrieve();
        boolean isDone=false;
        while (!isDone) {
          File fout=new File(destDir,myName);
          if (fout.createNewFile()) {
            FileOutputStream fos=new FileOutputStream(fout);
            Utils.bufferedCopy(is,fos);
            if (b.isRegisteredBitstream()) {
              out.println(""String_Node_Str"" + b.getStoreNumber() + ""String_Node_Str""+ myName+ ""String_Node_Str""+ bundleName);
            }
 else {
              out.println(myName + ""String_Node_Str"" + bundleName);
            }
            isDone=true;
          }
 else {
            myName=myPrefix + ""String_Node_Str"" + oldName;
            myPrefix++;
          }
        }
      }
    }
    out.close();
  }
 else {
    throw new Exception(""String_Node_Str"" + destDir);
  }
}","/** 
 * Create both the bitstreams and the contents file. Any bitstreams that were originally registered will be marked in the contents file as such. However, the export directory will contain actual copies of the content files being exported.
 * @param c the DSpace context
 * @param i the item being exported
 * @param destDir the item's export directory
 * @throws Exception if there is any problem writing to the export directory
 */
private static void writeBitstreams(Context c,Item i,File destDir) throws Exception {
  File outFile=new File(destDir,""String_Node_Str"");
  if (outFile.createNewFile()) {
    PrintWriter out=new PrintWriter(new FileWriter(outFile));
    Bundle[] bundles=i.getBundles();
    for (int j=0; j < bundles.length; j++) {
      Bitstream[] bitstreams=bundles[j].getBitstreams();
      String bundleName=bundles[j].getName();
      for (int k=0; k < bitstreams.length; k++) {
        Bitstream b=bitstreams[k];
        String myName=b.getName();
        String oldName=myName;
        int myPrefix=1;
        InputStream is=b.retrieve();
        boolean isDone=false;
        while (!isDone) {
          File fout=new File(destDir,myName);
          if (fout.createNewFile()) {
            FileOutputStream fos=new FileOutputStream(fout);
            Utils.bufferedCopy(is,fos);
            is.close();
            fos.close();
            if (b.isRegisteredBitstream()) {
              out.println(""String_Node_Str"" + b.getStoreNumber() + ""String_Node_Str""+ myName+ ""String_Node_Str""+ bundleName);
            }
 else {
              out.println(myName + ""String_Node_Str"" + bundleName);
            }
            isDone=true;
          }
 else {
            myName=myPrefix + ""String_Node_Str"" + oldName;
            myPrefix++;
          }
        }
      }
    }
    out.close();
  }
 else {
    throw new Exception(""String_Node_Str"" + destDir);
  }
}",0.986831496909433
52525,"/** 
 * counts items in this community
 * @return  total items
 */
public int countItems() throws SQLException {
  int collitems=0;
  int commitems=0;
  Collection[] cols=getCollections();
  if (cols.length > 0) {
    for (int j=0; j < cols.length; j++) {
      collitems=cols[j].countItems();
      commitems+=collitems;
    }
  }
  return commitems;
}","/** 
 * counts items in this community
 * @return  total items
 */
public int countItems() throws SQLException {
  int total=0;
  Collection[] cols=getCollections();
  for (int i=0; i < cols.length; i++) {
    total+=cols[i].countItems();
  }
  Community[] comms=getSubcommunities();
  for (int j=0; j < comms.length; j++) {
    total+=comms[j].countItems();
  }
  return total;
}",0.572987721691678
52526,"/** 
 * Given a contents file and an item, stuffing it with bitstreams from the contents file
 */
private void processContentsFile(Context c,Item i,String path,String filename) throws SQLException, IOException, AuthorizeException {
  String contentspath=path + File.separatorChar + filename;
  String line=""String_Node_Str"";
  System.out.println(""String_Node_Str"" + contentspath);
  BufferedReader is=null;
  try {
    is=new BufferedReader(new FileReader(contentspath));
    while ((line=is.readLine()) != null) {
      if (""String_Node_Str"".equals(line.trim())) {
        continue;
      }
      if (line.trim().startsWith(""String_Node_Str"")) {
        String sRegistrationLine=line.trim();
        int iAssetstore=-1;
        String sFilePath=null;
        String sBundle=null;
        StringTokenizer tokenizer=new StringTokenizer(sRegistrationLine);
        while (tokenizer.hasMoreTokens()) {
          String sToken=tokenizer.nextToken();
          if (sToken.equals(""String_Node_Str"")) {
            continue;
          }
 else           if (sToken.equals(""String_Node_Str"") && tokenizer.hasMoreTokens()) {
            try {
              iAssetstore=Integer.parseInt(tokenizer.nextToken());
            }
 catch (            NumberFormatException e) {
            }
          }
 else           if (sToken.equals(""String_Node_Str"") && tokenizer.hasMoreTokens()) {
            sFilePath=tokenizer.nextToken();
          }
 else           if (sToken.startsWith(""String_Node_Str"")) {
            sBundle=sToken.substring(7);
          }
 else {
          }
        }
        if (iAssetstore == -1 || sFilePath == null) {
          System.out.println(""String_Node_Str"");
          System.out.println(""String_Node_Str"" + sRegistrationLine);
          continue;
        }
        registerBitstream(c,i,iAssetstore,sFilePath,sBundle);
        System.out.println(""String_Node_Str"" + sFilePath + ""String_Node_Str""+ iAssetstore+ ""String_Node_Str""+ sBundle);
        continue;
      }
      String bundleMarker=""String_Node_Str"";
      int markerIndex=line.indexOf(bundleMarker);
      if (markerIndex == -1) {
        processContentFileEntry(c,i,path,line,null);
        System.out.println(""String_Node_Str"" + line);
      }
 else {
        String bundleName=line.substring(markerIndex + bundleMarker.length());
        String bitstreamName=line.substring(0,markerIndex);
        processContentFileEntry(c,i,path,bitstreamName,bundleName);
        System.out.println(""String_Node_Str"" + bitstreamName + ""String_Node_Str""+ bundleName);
      }
    }
  }
  finally {
    if (is != null) {
      is.close();
    }
  }
}","/** 
 * Given a contents file and an item, stuffing it with bitstreams from the contents file
 */
private void processContentsFile(Context c,Item i,String path,String filename) throws SQLException, IOException, AuthorizeException {
  String contentspath=path + File.separatorChar + filename;
  String line=""String_Node_Str"";
  System.out.println(""String_Node_Str"" + contentspath);
  BufferedReader is=null;
  try {
    is=new BufferedReader(new FileReader(contentspath));
    while ((line=is.readLine()) != null) {
      if (""String_Node_Str"".equals(line.trim())) {
        continue;
      }
      if (line.trim().startsWith(""String_Node_Str"")) {
        String sRegistrationLine=line.trim();
        int iAssetstore=-1;
        String sFilePath=null;
        String sBundle=null;
        StringTokenizer tokenizer=new StringTokenizer(sRegistrationLine);
        while (tokenizer.hasMoreTokens()) {
          String sToken=tokenizer.nextToken();
          if (sToken.equals(""String_Node_Str"")) {
            continue;
          }
 else           if (sToken.equals(""String_Node_Str"") && tokenizer.hasMoreTokens()) {
            try {
              iAssetstore=Integer.parseInt(tokenizer.nextToken());
            }
 catch (            NumberFormatException e) {
            }
          }
 else           if (sToken.equals(""String_Node_Str"") && tokenizer.hasMoreTokens()) {
            sFilePath=tokenizer.nextToken();
          }
 else           if (sToken.startsWith(""String_Node_Str"")) {
            sBundle=sToken.substring(7);
          }
 else {
          }
        }
        if (iAssetstore == -1 || sFilePath == null) {
          System.out.println(""String_Node_Str"");
          System.out.println(""String_Node_Str"" + sRegistrationLine);
          continue;
        }
        registerBitstream(c,i,iAssetstore,sFilePath,sBundle);
        System.out.println(""String_Node_Str"" + sFilePath + ""String_Node_Str""+ iAssetstore+ ""String_Node_Str""+ sBundle);
        continue;
      }
      String bundleMarker=""String_Node_Str"";
      int markerIndex=line.indexOf(bundleMarker);
      if (markerIndex == -1) {
        processContentFileEntry(c,i,path,line,null);
        System.out.println(""String_Node_Str"" + line);
      }
 else {
        String bundleName=line.substring(markerIndex + bundleMarker.length());
        String bitstreamName=line.substring(0,markerIndex);
        bitstreamName=bitstreamName.trim();
        processContentFileEntry(c,i,path,bitstreamName,bundleName);
        System.out.println(""String_Node_Str"" + bitstreamName + ""String_Node_Str""+ bundleName);
      }
    }
  }
  finally {
    if (is != null) {
      is.close();
    }
  }
}",0.9916540212443096
52527,"/** 
 * read the input file and populate all the class globals with the contents The values that come from this file form the basis of the analysis report
 * @param input   the aggregator file
 */
public static void readInput(String input) throws IOException, ParseException {
  FileReader fr=null;
  BufferedReader br=null;
  String record=null;
  try {
    fr=new FileReader(input);
    br=new BufferedReader(fr);
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  while ((record=br.readLine()) != null) {
    Matcher matchReal=real.matcher(record);
    String section=null;
    String key=null;
    String value=null;
    String left=null;
    if (matchReal.matches()) {
      left=matchReal.group(1).trim();
      value=matchReal.group(2).trim();
      StringTokenizer tokens=new StringTokenizer(left,""String_Node_Str"");
      int numTokens=tokens.countTokens();
      if (tokens.hasMoreTokens()) {
        section=tokens.nextToken();
        if (numTokens > 1) {
          key=left.substring(section.length() + 1);
        }
 else {
          key=""String_Node_Str"";
        }
      }
    }
 else {
      continue;
    }
    DateFormat df=DateFormat.getInstance();
    if (section.equals(""String_Node_Str"")) {
      archiveStats.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      actionAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      userAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      searchAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      itemAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      userEmail=value;
    }
    if (section.equals(""String_Node_Str"")) {
      itemFloor=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      searchFloor=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      url=value;
    }
    if (section.equals(""String_Node_Str"")) {
      itemLookup=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      try {
        avgItemViews=Integer.parseInt(value);
      }
 catch (      NumberFormatException e) {
        avgItemViews=0;
      }
    }
    if (section.equals(""String_Node_Str"")) {
      serverName=value;
    }
    if (section.equals(""String_Node_Str"")) {
      name=value;
    }
    if (section.equals(""String_Node_Str"")) {
      startDate=df.parse(value);
    }
    if (section.equals(""String_Node_Str"")) {
      endDate=df.parse(value);
    }
    if (section.equals(""String_Node_Str"")) {
      processTime=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      generalSummary.add(value);
    }
    if (section.equals(""String_Node_Str"")) {
      logLines=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      warnings=Integer.parseInt(value);
    }
  }
  br.close();
  fr.close();
}","/** 
 * read the input file and populate all the class globals with the contents The values that come from this file form the basis of the analysis report
 * @param input   the aggregator file
 */
public static void readInput(String input) throws IOException, ParseException {
  FileReader fr=null;
  BufferedReader br=null;
  String record=null;
  try {
    fr=new FileReader(input);
    br=new BufferedReader(fr);
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  while ((record=br.readLine()) != null) {
    Matcher matchReal=real.matcher(record);
    String section=null;
    String key=null;
    String value=null;
    String left=null;
    if (matchReal.matches()) {
      left=matchReal.group(1).trim();
      value=matchReal.group(2).trim();
      StringTokenizer tokens=new StringTokenizer(left,""String_Node_Str"");
      int numTokens=tokens.countTokens();
      if (tokens.hasMoreTokens()) {
        section=tokens.nextToken();
        if (numTokens > 1) {
          key=left.substring(section.length() + 1);
        }
 else {
          key=""String_Node_Str"";
        }
      }
    }
 else {
      continue;
    }
    SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
    if (section.equals(""String_Node_Str"")) {
      archiveStats.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      actionAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      userAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      searchAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      itemAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      userEmail=value;
    }
    if (section.equals(""String_Node_Str"")) {
      itemFloor=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      searchFloor=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      url=value;
    }
    if (section.equals(""String_Node_Str"")) {
      itemLookup=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      try {
        avgItemViews=Integer.parseInt(value);
      }
 catch (      NumberFormatException e) {
        avgItemViews=0;
      }
    }
    if (section.equals(""String_Node_Str"")) {
      serverName=value;
    }
    if (section.equals(""String_Node_Str"")) {
      name=value;
    }
    if (section.equals(""String_Node_Str"")) {
      startDate=sdf.parse(value);
    }
    if (section.equals(""String_Node_Str"")) {
      endDate=sdf.parse(value);
    }
    if (section.equals(""String_Node_Str"")) {
      processTime=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      generalSummary.add(value);
    }
    if (section.equals(""String_Node_Str"")) {
      logLines=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      warnings=Integer.parseInt(value);
    }
  }
  br.close();
  fr.close();
}",0.9906229068988612
52528,"private void replaceItems(Context c,Collection[] mycollections,String sourceDir,String mapFile) throws Exception {
  File d=new java.io.File(sourceDir);
  if (d == null) {
    System.out.println(""String_Node_Str"" + sourceDir);
    System.exit(1);
  }
  Map myhash=readMapFile(mapFile);
  Iterator i=myhash.keySet().iterator();
  ArrayList itemsToDelete=new ArrayList();
  while (i.hasNext()) {
    String newItemName=(String)i.next();
    String oldHandle=(String)myhash.get(newItemName);
    Item oldItem=null;
    Item newItem=null;
    if (oldHandle.indexOf('/') != -1) {
      System.out.println(""String_Node_Str"" + oldHandle);
      oldItem=(Item)HandleManager.resolveToObject(c,oldHandle);
    }
 else {
      oldItem=Item.find(c,Integer.parseInt(oldHandle));
    }
    newItem=addItem(c,mycollections,sourceDir,newItemName,null);
    itemsToDelete.add(oldItem);
  }
  i=itemsToDelete.iterator();
  while (i.hasNext()) {
    deleteItem(c,(Item)i.next());
  }
}","private void replaceItems(Context c,Collection[] mycollections,String sourceDir,String mapFile) throws Exception {
  File d=new java.io.File(sourceDir);
  if (d == null) {
    System.out.println(""String_Node_Str"" + sourceDir);
    System.exit(1);
  }
  Map myhash=readMapFile(mapFile);
  Iterator i=myhash.keySet().iterator();
  ArrayList itemsToDelete=new ArrayList();
  while (i.hasNext()) {
    String newItemName=(String)i.next();
    String oldHandle=(String)myhash.get(newItemName);
    Item oldItem=null;
    Item newItem=null;
    if (oldHandle.indexOf('/') != -1) {
      System.out.println(""String_Node_Str"" + oldHandle);
      oldItem=(Item)HandleManager.resolveToObject(c,oldHandle);
    }
 else {
      oldItem=Item.find(c,Integer.parseInt(oldHandle));
    }
    File handleFile=new File(sourceDir + File.separatorChar + newItemName+ File.separatorChar+ ""String_Node_Str"");
    PrintWriter handleOut=new PrintWriter(new FileWriter(handleFile,true));
    if (handleOut == null) {
      throw new Exception(""String_Node_Str"" + handleFile.getCanonicalPath());
    }
    handleOut.println(oldHandle);
    handleOut.close();
    deleteItem(c,oldItem);
    newItem=addItem(c,mycollections,sourceDir,newItemName,null);
  }
}",0.7513661202185792
52529,"/** 
 * Set the short description of the bitstream format
 * @param s the new short description
 */
public void setShortDescription(String s) throws SQLException {
  BitstreamFormat unknown=findUnknown(bfContext);
  if (unknown.getID() != getID())   bfRow.setColumn(""String_Node_Str"",s);
}","/** 
 * Set the short description of the bitstream format
 * @param s the new short description
 */
public void setShortDescription(String s) throws SQLException {
  BitstreamFormat unknown=null;
  ;
  try {
    unknown=findUnknown(bfContext);
  }
 catch (  IllegalStateException e) {
  }
  if (unknown == null || unknown.getID() != getID()) {
    bfRow.setColumn(""String_Node_Str"",s);
  }
}",0.8382352941176471
52530,"public String buildHTTPQuery(HttpServletRequest request){
  String querystring=""String_Node_Str"";
  HashMap queryHash=buildQueryHash(request);
  Iterator i=queryHash.keySet().iterator();
  while (i.hasNext()) {
    String key=(String)i.next();
    String value=(String)queryHash.get(key);
    querystring=querystring + ""String_Node_Str"" + key+ ""String_Node_Str""+ value;
  }
  return (querystring);
}","public String buildHTTPQuery(HttpServletRequest request) throws UnsupportedEncodingException {
  String querystring=""String_Node_Str"";
  HashMap queryHash=buildQueryHash(request);
  Iterator i=queryHash.keySet().iterator();
  while (i.hasNext()) {
    String key=(String)i.next();
    String value=(String)queryHash.get(key);
    querystring=querystring + ""String_Node_Str"" + key+ ""String_Node_Str""+ URLEncoder.encode(value,Constants.DEFAULT_ENCODING);
  }
  return (querystring);
}",0.905788876276958
52531,"/** 
 * Process the input from the upload logo page
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processUploadLogo(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  FileUploadRequest wrapper=new FileUploadRequest(request);
  Community community=Community.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  Collection collection=Collection.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  File temp=wrapper.getFile(""String_Node_Str"");
  InputStream is=new BufferedInputStream(new FileInputStream(temp));
  Bitstream logoBS;
  if (community != null) {
    logoBS=community.setLogo(is);
  }
 else {
    logoBS=collection.setLogo(is);
  }
  String noPath=wrapper.getFilesystemName(""String_Node_Str"");
  while (noPath.indexOf('/') > -1) {
    noPath=noPath.substring(noPath.indexOf('/') + 1);
  }
  while (noPath.indexOf('\\') > -1) {
    noPath=noPath.substring(noPath.indexOf('\\') + 1);
  }
  logoBS.setName(noPath);
  logoBS.setSource(wrapper.getFilesystemName(""String_Node_Str""));
  BitstreamFormat bf=FormatIdentifier.guessFormat(context,logoBS);
  logoBS.setFormat(bf);
  logoBS.update();
  if (community != null) {
    community.update();
    request.setAttribute(""String_Node_Str"",community);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    collection.update();
    request.setAttribute(""String_Node_Str"",collection);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
  temp.delete();
  context.complete();
}","/** 
 * Process the input from the upload logo page
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processUploadLogo(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  FileUploadRequest wrapper=new FileUploadRequest(request);
  Community community=Community.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  Collection collection=Collection.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  File temp=wrapper.getFile(""String_Node_Str"");
  InputStream is=new BufferedInputStream(new FileInputStream(temp));
  Bitstream logoBS;
  if (collection == null) {
    logoBS=community.setLogo(is);
  }
 else {
    logoBS=collection.setLogo(is);
  }
  String noPath=wrapper.getFilesystemName(""String_Node_Str"");
  while (noPath.indexOf('/') > -1) {
    noPath=noPath.substring(noPath.indexOf('/') + 1);
  }
  while (noPath.indexOf('\\') > -1) {
    noPath=noPath.substring(noPath.indexOf('\\') + 1);
  }
  logoBS.setName(noPath);
  logoBS.setSource(wrapper.getFilesystemName(""String_Node_Str""));
  BitstreamFormat bf=FormatIdentifier.guessFormat(context,logoBS);
  logoBS.setFormat(bf);
  logoBS.update();
  if (collection == null) {
    community.update();
    request.setAttribute(""String_Node_Str"",community);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    collection.update();
    request.setAttribute(""String_Node_Str"",collection);
    request.setAttribute(""String_Node_Str"",community);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
  temp.delete();
  context.complete();
}",0.9731601731601732
52532,"/** 
 * Work out which page to show next, and show it
 * @param context
 * @param request
 * @param response
 * @param collection
 * @param stage  the stage the user just finished, or if PERMISSIONS, theparticular permissions page
 * @throws SQLException
 * @throws ServletException
 * @throws IOException
 * @throws AuthorizeException
 */
private void showNextPage(Context context,HttpServletRequest request,HttpServletResponse response,Collection collection,int stage) throws SQLException, ServletException, IOException, AuthorizeException {
  request.setAttribute(""String_Node_Str"",collection);
  if (Group.findByName(context,""String_Node_Str"") != null) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + stage));
switch (stage) {
case BASIC_INFO:
    List anonReadPols=AuthorizeManager.getPoliciesActionFilter(context,collection,Constants.DEFAULT_ITEM_READ);
  if (anonReadPols.size() == 0) {
    request.setAttribute(""String_Node_Str"",new Integer(PERM_READ));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    break;
  }
case PERM_READ:
if (collection.getSubmitters() != null) {
  request.setAttribute(""String_Node_Str"",new Integer(PERM_SUBMIT));
  JSPManager.showJSP(request,response,""String_Node_Str"");
  break;
}
case PERM_SUBMIT:
if (collection.getWorkflowGroup(1) != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_WF1));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_WF1:
if (collection.getWorkflowGroup(2) != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_WF2));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_WF2:
if (collection.getWorkflowGroup(3) != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_WF3));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_WF3:
if (collection.getAdministrators() != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_ADMIN));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_ADMIN:
if (collection.getTemplateItem() != null) {
DCType[] types=DCType.findAll(context);
request.setAttribute(""String_Node_Str"",types);
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case DEFAULT_ITEM:
if (collection != null) {
Community[] communities=collection.getCommunities();
request.setAttribute(""String_Node_Str"",communities[0]);
}
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
}","/** 
 * Work out which page to show next, and show it
 * @param context
 * @param request
 * @param response
 * @param collection
 * @param stage  the stage the user just finished, or if PERMISSIONS, theparticular permissions page
 * @throws SQLException
 * @throws ServletException
 * @throws IOException
 * @throws AuthorizeException
 */
private void showNextPage(Context context,HttpServletRequest request,HttpServletResponse response,Collection collection,int stage) throws SQLException, ServletException, IOException, AuthorizeException {
  request.setAttribute(""String_Node_Str"",collection);
  if (Group.findByName(context,""String_Node_Str"") != null) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + stage));
switch (stage) {
case BASIC_INFO:
    List anonReadPols=AuthorizeManager.getPoliciesActionFilter(context,collection,Constants.DEFAULT_ITEM_READ);
  if (anonReadPols.size() == 0) {
    request.setAttribute(""String_Node_Str"",new Integer(PERM_READ));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    break;
  }
case PERM_READ:
if (collection.getSubmitters() != null) {
  request.setAttribute(""String_Node_Str"",new Integer(PERM_SUBMIT));
  JSPManager.showJSP(request,response,""String_Node_Str"");
  break;
}
case PERM_SUBMIT:
if (collection.getWorkflowGroup(1) != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_WF1));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_WF1:
if (collection.getWorkflowGroup(2) != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_WF2));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_WF2:
if (collection.getWorkflowGroup(3) != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_WF3));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_WF3:
if (collection.getAdministrators() != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_ADMIN));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_ADMIN:
if (collection.getTemplateItem() != null) {
DCType[] types=DCType.findAll(context);
request.setAttribute(""String_Node_Str"",types);
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case DEFAULT_ITEM:
if (collection != null) {
Community[] communities=collection.getCommunities();
request.setAttribute(""String_Node_Str"",communities[0]);
if (AuthorizeManager.isAdmin(context)) {
request.setAttribute(""String_Node_Str"",new Boolean(true));
}
}
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
}",0.9802248933695232
52533,"/** 
 * writes an index record - the index record is a set of name/value hashes, which are sent to Lucene.
 */
private static void writeItemIndex(Context c,IndexWriter writer,Item myitem) throws SQLException, IOException {
  String location_text=buildItemLocationString(c,myitem);
  ArrayList indexes=new ArrayList();
  for (int i=1; ConfigurationManager.getProperty(""String_Node_Str"" + i) != null; i++) {
    indexes.add(ConfigurationManager.getProperty(""String_Node_Str"" + i));
  }
  int j, k=0;
  HashMap textvalues=new HashMap();
  if (indexes.size() > 0) {
    ArrayList fields=new ArrayList();
    ArrayList content=new ArrayList();
    DCValue[] mydc;
    for (int i=0; i < indexes.size(); i++) {
      String index=(String)indexes.get(i);
      String dc[]=index.split(""String_Node_Str"");
      String myindex=dc[0];
      String elements[]=dc[1].split(""String_Node_Str"");
      String element=elements[0];
      String qualifier=elements[1];
      if (qualifier.equals(""String_Node_Str"")) {
        mydc=myitem.getDC(element,Item.ANY,Item.ANY);
      }
 else {
        mydc=myitem.getDC(element,qualifier,Item.ANY);
      }
      String content_text=""String_Node_Str"";
      for (j=0; j < mydc.length; j++) {
        content_text=new String(content_text + mydc[j].value + ""String_Node_Str"");
      }
      k=fields.indexOf(myindex);
      if (k < 0) {
        fields.add(myindex);
        content.add(content_text);
      }
 else {
        content_text=new String(content_text + (String)content.get(k) + ""String_Node_Str"");
        content.set(k,content_text);
      }
    }
    for (int i=0; i < fields.size(); i++) {
      textvalues.put((String)fields.get(i),(String)content.get(i));
    }
  }
 else {
    DCValue[] authors=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] creators=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] titles=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] keywords=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] abstracts=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] sors=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] series=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] tocs=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] mimetypes=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] sponsors=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] identifiers=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    String author_text=""String_Node_Str"";
    String title_text=""String_Node_Str"";
    String keyword_text=""String_Node_Str"";
    String abstract_text=""String_Node_Str"";
    String sor_text=""String_Node_Str"";
    String series_text=""String_Node_Str"";
    String mime_text=""String_Node_Str"";
    String sponsor_text=""String_Node_Str"";
    String id_text=""String_Node_Str"";
    for (j=0; j < authors.length; j++) {
      author_text=new String(author_text + authors[j].value + ""String_Node_Str"");
    }
    for (j=0; j < creators.length; j++) {
      author_text=new String(author_text + creators[j].value + ""String_Node_Str"");
    }
    for (j=0; j < sors.length; j++) {
      author_text=new String(author_text + sors[j].value + ""String_Node_Str"");
    }
    for (j=0; j < titles.length; j++) {
      title_text=new String(title_text + titles[j].value + ""String_Node_Str"");
    }
    for (j=0; j < keywords.length; j++) {
      keyword_text=new String(keyword_text + keywords[j].value + ""String_Node_Str"");
    }
    for (j=0; j < abstracts.length; j++) {
      abstract_text=new String(abstract_text + abstracts[j].value + ""String_Node_Str"");
    }
    for (j=0; j < tocs.length; j++) {
      abstract_text=new String(abstract_text + tocs[j].value + ""String_Node_Str"");
    }
    for (j=0; j < series.length; j++) {
      series_text=new String(series_text + series[j].value + ""String_Node_Str"");
    }
    for (j=0; j < mimetypes.length; j++) {
      mime_text=new String(mime_text + mimetypes[j].value + ""String_Node_Str"");
    }
    for (j=0; j < sponsors.length; j++) {
      sponsor_text=new String(sponsor_text + sponsors[j].value + ""String_Node_Str"");
    }
    for (j=0; j < identifiers.length; j++) {
      id_text=new String(id_text + identifiers[j].value + ""String_Node_Str"");
    }
    textvalues.put(""String_Node_Str"",author_text);
    textvalues.put(""String_Node_Str"",title_text);
    textvalues.put(""String_Node_Str"",keyword_text);
    textvalues.put(""String_Node_Str"",location_text);
    textvalues.put(""String_Node_Str"",abstract_text);
    textvalues.put(""String_Node_Str"",series_text);
    textvalues.put(""String_Node_Str"",mime_text);
    textvalues.put(""String_Node_Str"",sponsor_text);
    textvalues.put(""String_Node_Str"",id_text);
  }
  String extractedText=""String_Node_Str"";
  Bundle[] myBundles=myitem.getBundles();
  for (int i=0; i < myBundles.length; i++) {
    if (myBundles[i].getName() != null && myBundles[i].getName().equals(""String_Node_Str"")) {
      Bitstream[] myBitstreams=myBundles[i].getBitstreams();
      for (j=0; j < myBitstreams.length; j++) {
        try {
          InputStreamReader is=new InputStreamReader(myBitstreams[j].retrieve());
          StringBuffer sb=new StringBuffer();
          char[] charBuffer=new char[1024];
          while (true) {
            int bytesIn=is.read(charBuffer);
            if (bytesIn == -1)             break;
            if (bytesIn > 0) {
              sb.append(charBuffer,0,bytesIn);
            }
          }
          extractedText=extractedText.concat(new String(sb));
        }
 catch (        AuthorizeException e) {
        }
      }
    }
  }
  String itemhandle=HandleManager.findHandle(c,myitem);
  textvalues.put(""String_Node_Str"",itemhandle);
  writeIndexRecord(writer,Constants.ITEM,itemhandle,textvalues,extractedText);
}","/** 
 * writes an index record - the index record is a set of name/value hashes, which are sent to Lucene.
 */
private static void writeItemIndex(Context c,IndexWriter writer,Item myitem) throws SQLException, IOException {
  String location_text=buildItemLocationString(c,myitem);
  ArrayList indexes=new ArrayList();
  for (int i=1; ConfigurationManager.getProperty(""String_Node_Str"" + i) != null; i++) {
    indexes.add(ConfigurationManager.getProperty(""String_Node_Str"" + i));
  }
  int j, k=0;
  HashMap textvalues=new HashMap();
  if (indexes.size() > 0) {
    ArrayList fields=new ArrayList();
    ArrayList content=new ArrayList();
    DCValue[] mydc;
    for (int i=0; i < indexes.size(); i++) {
      String index=(String)indexes.get(i);
      String dc[]=index.split(""String_Node_Str"");
      String myindex=dc[0];
      String elements[]=dc[1].split(""String_Node_Str"");
      String element=elements[0];
      String qualifier=elements[1];
      if (qualifier.equals(""String_Node_Str"")) {
        mydc=myitem.getDC(element,Item.ANY,Item.ANY);
      }
 else {
        mydc=myitem.getDC(element,qualifier,Item.ANY);
      }
      String content_text=""String_Node_Str"";
      for (j=0; j < mydc.length; j++) {
        content_text=new String(content_text + mydc[j].value + ""String_Node_Str"");
      }
      k=fields.indexOf(myindex);
      if (k < 0) {
        fields.add(myindex);
        content.add(content_text);
      }
 else {
        content_text=new String(content_text + (String)content.get(k) + ""String_Node_Str"");
        content.set(k,content_text);
      }
    }
    for (int i=0; i < fields.size(); i++) {
      textvalues.put((String)fields.get(i),(String)content.get(i));
    }
    textvalues.put(""String_Node_Str"",location_text);
  }
 else {
    DCValue[] authors=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] creators=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] titles=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] keywords=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] abstracts=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] sors=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] series=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] tocs=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] mimetypes=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] sponsors=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] identifiers=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    String author_text=""String_Node_Str"";
    String title_text=""String_Node_Str"";
    String keyword_text=""String_Node_Str"";
    String abstract_text=""String_Node_Str"";
    String sor_text=""String_Node_Str"";
    String series_text=""String_Node_Str"";
    String mime_text=""String_Node_Str"";
    String sponsor_text=""String_Node_Str"";
    String id_text=""String_Node_Str"";
    for (j=0; j < authors.length; j++) {
      author_text=new String(author_text + authors[j].value + ""String_Node_Str"");
    }
    for (j=0; j < creators.length; j++) {
      author_text=new String(author_text + creators[j].value + ""String_Node_Str"");
    }
    for (j=0; j < sors.length; j++) {
      author_text=new String(author_text + sors[j].value + ""String_Node_Str"");
    }
    for (j=0; j < titles.length; j++) {
      title_text=new String(title_text + titles[j].value + ""String_Node_Str"");
    }
    for (j=0; j < keywords.length; j++) {
      keyword_text=new String(keyword_text + keywords[j].value + ""String_Node_Str"");
    }
    for (j=0; j < abstracts.length; j++) {
      abstract_text=new String(abstract_text + abstracts[j].value + ""String_Node_Str"");
    }
    for (j=0; j < tocs.length; j++) {
      abstract_text=new String(abstract_text + tocs[j].value + ""String_Node_Str"");
    }
    for (j=0; j < series.length; j++) {
      series_text=new String(series_text + series[j].value + ""String_Node_Str"");
    }
    for (j=0; j < mimetypes.length; j++) {
      mime_text=new String(mime_text + mimetypes[j].value + ""String_Node_Str"");
    }
    for (j=0; j < sponsors.length; j++) {
      sponsor_text=new String(sponsor_text + sponsors[j].value + ""String_Node_Str"");
    }
    for (j=0; j < identifiers.length; j++) {
      id_text=new String(id_text + identifiers[j].value + ""String_Node_Str"");
    }
    textvalues.put(""String_Node_Str"",author_text);
    textvalues.put(""String_Node_Str"",title_text);
    textvalues.put(""String_Node_Str"",keyword_text);
    textvalues.put(""String_Node_Str"",location_text);
    textvalues.put(""String_Node_Str"",abstract_text);
    textvalues.put(""String_Node_Str"",series_text);
    textvalues.put(""String_Node_Str"",mime_text);
    textvalues.put(""String_Node_Str"",sponsor_text);
    textvalues.put(""String_Node_Str"",id_text);
  }
  String extractedText=""String_Node_Str"";
  Bundle[] myBundles=myitem.getBundles();
  for (int i=0; i < myBundles.length; i++) {
    if (myBundles[i].getName() != null && myBundles[i].getName().equals(""String_Node_Str"")) {
      Bitstream[] myBitstreams=myBundles[i].getBitstreams();
      for (j=0; j < myBitstreams.length; j++) {
        try {
          InputStreamReader is=new InputStreamReader(myBitstreams[j].retrieve());
          StringBuffer sb=new StringBuffer();
          char[] charBuffer=new char[1024];
          while (true) {
            int bytesIn=is.read(charBuffer);
            if (bytesIn == -1)             break;
            if (bytesIn > 0) {
              sb.append(charBuffer,0,bytesIn);
            }
          }
          extractedText=extractedText.concat(new String(sb));
        }
 catch (        AuthorizeException e) {
        }
      }
    }
  }
  String itemhandle=HandleManager.findHandle(c,myitem);
  textvalues.put(""String_Node_Str"",itemhandle);
  writeIndexRecord(writer,Constants.ITEM,itemhandle,textvalues,extractedText);
}",0.9955262935764329
52534,"private void getThumbSettings(){
  showThumbs=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
  if (showThumbs) {
    thumbItemListMaxHeight=ConfigurationManager.getIntProperty(""String_Node_Str"");
    thumbItemListMaxWidth=ConfigurationManager.getIntProperty(""String_Node_Str"");
    thumbMaxHeight=ConfigurationManager.getIntProperty(""String_Node_Str"");
    thumbMaxWidth=ConfigurationManager.getIntProperty(""String_Node_Str"");
  }
}","private void getThumbSettings(){
  showThumbs=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
  if (showThumbs) {
    thumbItemListMaxHeight=ConfigurationManager.getIntProperty(""String_Node_Str"");
    if (thumbItemListMaxHeight == 0) {
      thumbItemListMaxHeight=ConfigurationManager.getIntProperty(""String_Node_Str"");
    }
    thumbItemListMaxWidth=ConfigurationManager.getIntProperty(""String_Node_Str"");
    if (thumbItemListMaxWidth == 0) {
      thumbItemListMaxWidth=ConfigurationManager.getIntProperty(""String_Node_Str"");
    }
  }
}",0.7307307307307307
52535,"/** 
 * Attempt to filter a bitstream An exception will be thrown if the media filter class cannot be instantiated, exceptions from filtering will be logged to STDOUT and swallowed.
 */
public static void filterBitstream(Context c,Item myItem,Bitstream myBitstream) throws Exception {
  Integer formatID=new Integer(myBitstream.getFormat().getID());
  if (filterNames.containsKey(formatID)) {
    if (!filterCache.containsKey(formatID)) {
      Class f=Class.forName((String)filterNames.get(formatID));
      MediaFilter myFilter=(MediaFilter)f.newInstance();
      filterCache.put(formatID,myFilter);
    }
    MediaFilter myFilter=(MediaFilter)filterCache.get(formatID);
    try {
      myFilter.processBitstream(c,myItem,myBitstream);
      myItem.update();
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + myBitstream.getID() + ""String_Node_Str""+ e);
      e.printStackTrace();
    }
  }
}","/** 
 * Attempt to filter a bitstream An exception will be thrown if the media filter class cannot be instantiated, exceptions from filtering will be logged to STDOUT and swallowed.
 */
public static void filterBitstream(Context c,Item myItem,Bitstream myBitstream) throws Exception {
  Integer formatID=new Integer(myBitstream.getFormat().getID());
  if (filterNames.containsKey(formatID)) {
    if (!filterCache.containsKey(formatID)) {
      Class f=Class.forName((String)filterNames.get(formatID));
      MediaFilter myFilter=(MediaFilter)f.newInstance();
      filterCache.put(formatID,myFilter);
    }
    MediaFilter myFilter=(MediaFilter)filterCache.get(formatID);
    try {
      if (myFilter.processBitstream(c,myItem,myBitstream)) {
        myItem.update();
      }
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + myBitstream.getID() + ""String_Node_Str""+ e);
      e.printStackTrace();
    }
  }
}",0.9741935483870968
52536,"/** 
 * Write out the AIP for the given item to the given directory. A new directory will be created with the Handle (URL-encoded) as the directory name, and inside, a mets.xml file written, together with the bitstreams.
 * @param context   DSpace context to use
 * @param item      Item to write
 * @param dest      destination directory
 */
public static void writeAIP(Context context,Item item,String dest) throws SQLException, IOException, AuthorizeException, MetsException {
  System.out.println(""String_Node_Str"" + item.getHandle());
  java.io.File aipDir=new java.io.File(dest + URLEncoder.encode(""String_Node_Str"" + item.getHandle(),""String_Node_Str""));
  if (!aipDir.mkdir()) {
    throw new IOException(""String_Node_Str"" + aipDir.toString());
  }
  FileOutputStream out=new FileOutputStream(aipDir.toString() + java.io.File.separator + ""String_Node_Str"");
  writeMETS(context,item,out);
  out.close();
  Bundle[] bundles=item.getBundles();
  for (int i=0; i < bundles.length; i++) {
    Bitstream[] bitstreams=bundles[i].getBitstreams();
    for (int b=0; b < bitstreams.length; b++) {
      if (bitstreams[b].getFormat().getID() != licenseFormat) {
        out=new FileOutputStream(aipDir.toString() + java.io.File.separator + bitstreams[b].getChecksum());
        InputStream in=bitstreams[b].retrieve();
        Utils.bufferedCopy(in,out);
        out.close();
        in.close();
      }
    }
  }
}","/** 
 * Write out the AIP for the given item to the given directory. A new directory will be created with the Handle (URL-encoded) as the directory name, and inside, a mets.xml file written, together with the bitstreams.
 * @param context   DSpace context to use
 * @param item      Item to write
 * @param dest      destination directory
 */
public static void writeAIP(Context context,Item item,String dest) throws SQLException, IOException, AuthorizeException, MetsException {
  System.out.println(""String_Node_Str"" + item.getHandle());
  java.io.File aipDir=new java.io.File(dest + URLEncoder.encode(""String_Node_Str"" + item.getHandle(),""String_Node_Str""));
  if (!aipDir.mkdir()) {
    throw new IOException(""String_Node_Str"" + aipDir.toString());
  }
  FileOutputStream out=new FileOutputStream(aipDir.toString() + java.io.File.separator + ""String_Node_Str"");
  writeMETS(context,item,out);
  out.close();
  Bundle[] bundles=item.getBundles();
  for (int i=0; i < bundles.length; i++) {
    Bitstream[] bitstreams=bundles[i].getBitstreams();
    for (int b=0; b < bitstreams.length; b++) {
      if (bitstreams[b].getFormat().getID() != licenseFormat && AuthorizeManager.authorizeActionBoolean(context,bitstreams[b],Constants.READ)) {
        out=new FileOutputStream(aipDir.toString() + java.io.File.separator + bitstreams[b].getChecksum());
        InputStream in=bitstreams[b].retrieve();
        Utils.bufferedCopy(in,out);
        out.close();
        in.close();
      }
    }
  }
}",0.9721362229102168
52537,"/** 
 * Process input from ""verify prune"" step
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processVerifyPrune(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"") != null) {
    doStep(context,request,response,subInfo,INITIAL_QUESTIONS);
    return;
  }
  boolean multipleTitles=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean publishedBefore=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean multipleFiles=(isWorkflow(subInfo) || UIUtil.getBoolParameter(request,""String_Node_Str""));
  Item item=subInfo.submission.getItem();
  if (!multipleTitles) {
    item.clearDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  }
  if (publishedBefore == false) {
    item.clearDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    item.clearDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    item.clearDC(""String_Node_Str"",null,Item.ANY);
  }
  if (multipleFiles == false) {
    Bundle[] bundles=item.getBundles();
    Bitstream[] bitstreams=bundles[0].getBitstreams();
    for (int i=1; i < bitstreams.length; i++) {
      bundles[0].removeBitstream(bitstreams[i]);
    }
  }
  subInfo.submission.setMultipleTitles(multipleTitles);
  subInfo.submission.setPublishedBefore(publishedBefore);
  if (!isWorkflow(subInfo)) {
    subInfo.submission.setMultipleFiles(multipleFiles);
  }
  subInfo.submission.update();
  if (request.getParameter(""String_Node_Str"") != null) {
    userHasReached(subInfo,EDIT_METADATA_1);
    doStep(context,request,response,subInfo,EDIT_METADATA_1);
    context.complete();
  }
 else {
    doStepJump(context,request,response,subInfo);
    context.complete();
  }
}","/** 
 * Process input from ""verify prune"" step
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processVerifyPrune(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"") != null) {
    doStep(context,request,response,subInfo,INITIAL_QUESTIONS);
    return;
  }
  boolean multipleTitles=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean publishedBefore=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean multipleFiles=(isWorkflow(subInfo) || UIUtil.getBoolParameter(request,""String_Node_Str""));
  Item item=subInfo.submission.getItem();
  if (!multipleTitles) {
    item.clearDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  }
  if (publishedBefore == false) {
    item.clearDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    item.clearDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    item.clearDC(""String_Node_Str"",null,Item.ANY);
  }
  if (multipleFiles == false) {
    Bundle[] bundles=item.getBundles();
    if (bundles.length > 0) {
      Bitstream[] bitstreams=bundles[0].getBitstreams();
      for (int i=1; i < bitstreams.length; i++) {
        bundles[0].removeBitstream(bitstreams[i]);
      }
    }
  }
  subInfo.submission.setMultipleTitles(multipleTitles);
  subInfo.submission.setPublishedBefore(publishedBefore);
  if (!isWorkflow(subInfo)) {
    subInfo.submission.setMultipleFiles(multipleFiles);
  }
  subInfo.submission.update();
  if (request.getParameter(""String_Node_Str"") != null) {
    userHasReached(subInfo,EDIT_METADATA_1);
    doStep(context,request,response,subInfo,EDIT_METADATA_1);
    context.complete();
  }
 else {
    doStepJump(context,request,response,subInfo);
    context.complete();
  }
}",0.9887525562372188
52538,"/** 
 * Given a contents file and an item, stuffing it with bitstreams from the contents file
 */
private void processContentsFile(Context c,Item i,String path,String filename) throws SQLException, IOException, AuthorizeException {
  String contentspath=path + File.separatorChar + filename;
  String line=""String_Node_Str"";
  System.out.println(""String_Node_Str"" + contentspath);
  BufferedReader is=new BufferedReader(new FileReader(contentspath));
  while ((line=is.readLine()) != null) {
    String bundleMarker=""String_Node_Str"";
    int markerIndex=line.indexOf(bundleMarker);
    if (markerIndex == -1) {
      processContentFileEntry(c,i,path,line,null);
      System.out.println(""String_Node_Str"" + line);
    }
 else {
      String bundleName=line.substring(markerIndex + bundleMarker.length());
      String bitstreamName=line.substring(0,markerIndex);
      processContentFileEntry(c,i,path,bitstreamName,bundleName);
      System.out.println(""String_Node_Str"" + bitstreamName + ""String_Node_Str""+ bundleName);
    }
  }
  is.close();
}","/** 
 * Given a contents file and an item, stuffing it with bitstreams from the contents file
 */
private void processContentsFile(Context c,Item i,String path,String filename) throws SQLException, IOException, AuthorizeException {
  String contentspath=path + File.separatorChar + filename;
  String line=""String_Node_Str"";
  System.out.println(""String_Node_Str"" + contentspath);
  BufferedReader is=new BufferedReader(new FileReader(contentspath));
  while ((line=is.readLine()) != null) {
    if (""String_Node_Str"".equals(line.trim()))     continue;
    String bundleMarker=""String_Node_Str"";
    int markerIndex=line.indexOf(bundleMarker);
    if (markerIndex == -1) {
      processContentFileEntry(c,i,path,line,null);
      System.out.println(""String_Node_Str"" + line);
    }
 else {
      String bundleName=line.substring(markerIndex + bundleMarker.length());
      String bitstreamName=line.substring(0,markerIndex);
      processContentFileEntry(c,i,path,bitstreamName,bundleName);
      System.out.println(""String_Node_Str"" + bitstreamName + ""String_Node_Str""+ bundleName);
    }
  }
  is.close();
}",0.9717199814557256
52539,"private void addDCValue(Item i,Node n) throws TransformerException {
  String value=getStringValue(n);
  String element=getAttributeValue(n,""String_Node_Str"");
  String qualifier=getAttributeValue(n,""String_Node_Str"");
  String language=getAttributeValue(n,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + element + ""String_Node_Str""+ qualifier+ ""String_Node_Str""+ value);
  if (qualifier.equals(""String_Node_Str""))   qualifier=null;
  if (language.equals(""String_Node_Str"")) {
    language=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (language == null) {
    language=""String_Node_Str"";
  }
  i.addDC(element,qualifier,language,value);
}","private void addDCValue(Item i,Node n) throws TransformerException {
  String value=getStringValue(n);
  String element=getAttributeValue(n,""String_Node_Str"");
  String qualifier=getAttributeValue(n,""String_Node_Str"");
  String language=getAttributeValue(n,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + element + ""String_Node_Str""+ qualifier+ ""String_Node_Str""+ value);
  if (qualifier.equals(""String_Node_Str"") || ""String_Node_Str"".equals(qualifier))   qualifier=null;
  if (language.equals(""String_Node_Str"")) {
    language=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (language == null) {
    language=""String_Node_Str"";
  }
  i.addDC(element,qualifier,language,value);
}",0.9716363636363636
52540,"/** 
 * process input from basic info page
 * @param context
 * @param request
 * @param response
 * @param collection
 * @throws SQLException
 * @throws ServletException
 * @throws IOException
 * @throws AuthorizeException
 */
private void processBasicInfo(Context context,HttpServletRequest request,HttpServletResponse response) throws SQLException, ServletException, IOException, AuthorizeException {
  FileUploadRequest wrapper=new FileUploadRequest(request);
  Collection collection=Collection.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  if (collection == null) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(wrapper)));
    JSPManager.showIntegrityError(request,response);
    return;
  }
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  String license=wrapper.getParameter(""String_Node_Str"");
  if (license != null) {
    collection.setLicense(null);
  }
  File temp=wrapper.getFile(""String_Node_Str"");
  if (temp != null) {
    InputStream is=new BufferedInputStream(new FileInputStream(temp));
    Bitstream logoBS=collection.setLogo(is);
    String noPath=wrapper.getFilesystemName(""String_Node_Str"");
    while (noPath.indexOf('/') > -1) {
      noPath=noPath.substring(noPath.indexOf('/') + 1);
    }
    while (noPath.indexOf('\\') > -1) {
      noPath=noPath.substring(noPath.indexOf('\\') + 1);
    }
    logoBS.setName(noPath);
    logoBS.setSource(wrapper.getFilesystemName(""String_Node_Str""));
    BitstreamFormat bf=FormatIdentifier.guessFormat(context,logoBS);
    logoBS.setFormat(bf);
    logoBS.update();
    temp.delete();
  }
  collection.update();
  showNextPage(context,request,response,collection,BASIC_INFO);
  context.complete();
}","/** 
 * process input from basic info page
 * @param context
 * @param request
 * @param response
 * @param collection
 * @throws SQLException
 * @throws ServletException
 * @throws IOException
 * @throws AuthorizeException
 */
private void processBasicInfo(Context context,HttpServletRequest request,HttpServletResponse response) throws SQLException, ServletException, IOException, AuthorizeException {
  FileUploadRequest wrapper=new FileUploadRequest(request);
  Collection collection=Collection.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  if (collection == null) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(wrapper)));
    JSPManager.showIntegrityError(request,response);
    return;
  }
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  String license=wrapper.getParameter(""String_Node_Str"");
  if (license != null || license.equals(""String_Node_Str"")) {
    collection.setLicense(license);
  }
  File temp=wrapper.getFile(""String_Node_Str"");
  if (temp != null) {
    InputStream is=new BufferedInputStream(new FileInputStream(temp));
    Bitstream logoBS=collection.setLogo(is);
    String noPath=wrapper.getFilesystemName(""String_Node_Str"");
    while (noPath.indexOf('/') > -1) {
      noPath=noPath.substring(noPath.indexOf('/') + 1);
    }
    while (noPath.indexOf('\\') > -1) {
      noPath=noPath.substring(noPath.indexOf('\\') + 1);
    }
    logoBS.setName(noPath);
    logoBS.setSource(wrapper.getFilesystemName(""String_Node_Str""));
    BitstreamFormat bf=FormatIdentifier.guessFormat(context,logoBS);
    logoBS.setFormat(bf);
    logoBS.update();
    temp.delete();
  }
  collection.update();
  showNextPage(context,request,response,collection,BASIC_INFO);
  context.complete();
}",0.9891255097417307
52541,"/** 
 * Process input from one of the permissions pages
 * @param context     DSpace context
 * @param request     HTTP request
 * @param response    HTTP response
 * @param collection  Collection we're editing
 */
private void processPermissions(Context context,HttpServletRequest request,HttpServletResponse response,Collection collection) throws SQLException, ServletException, IOException, AuthorizeException {
  int permission=UIUtil.getIntParameter(request,""String_Node_Str"");
  if (UIUtil.getBoolParameter(request,""String_Node_Str"")) {
    Group mitGroup=Group.findByName(context,""String_Node_Str"");
    int action;
    if (permission == PERM_READ) {
      AuthorizeManager.addPolicy(context,collection,Constants.READ,mitGroup);
    }
 else {
      AuthorizeManager.addPolicy(context,collection,Constants.ADD,mitGroup);
    }
  }
  Group g=null;
switch (permission) {
case PERM_READ:
    g=Group.create(context);
  g.setName(""String_Node_Str"" + collection.getID() + ""String_Node_Str"");
AuthorizeManager.addPolicy(context,collection,Constants.READ,g);
break;
case PERM_SUBMIT:
g=collection.getSubmitters();
break;
case PERM_WF1:
g=collection.getWorkflowGroup(1);
break;
case PERM_WF2:
g=collection.getWorkflowGroup(2);
break;
case PERM_WF3:
g=collection.getWorkflowGroup(3);
break;
case PERM_EDITOR:
g=collection.getEditors();
break;
}
int[] ids=UIUtil.getIntParameters(request,""String_Node_Str"");
if (ids != null) {
for (int i=0; i < ids.length; i++) {
EPerson eperson=EPerson.find(context,ids[i]);
if (eperson != null) {
g.addMember(eperson);
}
}
}
g.update();
showNextPage(context,request,response,collection,permission);
context.complete();
}","/** 
 * Process input from one of the permissions pages
 * @param context     DSpace context
 * @param request     HTTP request
 * @param response    HTTP response
 * @param collection  Collection we're editing
 */
private void processPermissions(Context context,HttpServletRequest request,HttpServletResponse response,Collection collection) throws SQLException, ServletException, IOException, AuthorizeException {
  int permission=UIUtil.getIntParameter(request,""String_Node_Str"");
  if (UIUtil.getBoolParameter(request,""String_Node_Str"")) {
    Group mitGroup=Group.findByName(context,""String_Node_Str"");
    int action;
    if (permission == PERM_READ) {
      AuthorizeManager.addPolicy(context,collection,Constants.DEFAULT_ITEM_READ,mitGroup);
      AuthorizeManager.addPolicy(context,collection,Constants.DEFAULT_BITSTREAM_READ,mitGroup);
    }
 else {
      AuthorizeManager.addPolicy(context,collection,Constants.ADD,mitGroup);
    }
  }
  Group g=null;
switch (permission) {
case PERM_READ:
    g=Group.create(context);
  g.setName(""String_Node_Str"" + collection.getID() + ""String_Node_Str"");
AuthorizeManager.addPolicy(context,collection,Constants.DEFAULT_ITEM_READ,g);
AuthorizeManager.addPolicy(context,collection,Constants.DEFAULT_BITSTREAM_READ,g);
break;
case PERM_SUBMIT:
g=collection.getSubmitters();
break;
case PERM_WF1:
g=collection.getWorkflowGroup(1);
break;
case PERM_WF2:
g=collection.getWorkflowGroup(2);
break;
case PERM_WF3:
g=collection.getWorkflowGroup(3);
break;
case PERM_EDITOR:
g=collection.getEditors();
break;
}
int[] ids=UIUtil.getIntParameters(request,""String_Node_Str"");
if (ids != null) {
for (int i=0; i < ids.length; i++) {
EPerson eperson=EPerson.find(context,ids[i]);
if (eperson != null) {
g.addMember(eperson);
}
}
}
g.update();
showNextPage(context,request,response,collection,permission);
context.complete();
}",0.9415787973781704
52542,"protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  int groupID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Group group=null;
  if (groupID >= 0) {
    group=Group.find(c,groupID);
  }
  if (group != null) {
    AuthorizeManager.authorizeAction(c,group,Constants.ADD);
    String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
    if (button.equals(""String_Node_Str"")) {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else     if (button.equals(""String_Node_Str"")) {
      String newName=request.getParameter(""String_Node_Str"");
      if (!newName.equals(group.getName())) {
        group.setName(newName);
        group.update();
      }
      int[] eperson_ids=UIUtil.getIntParameters(request,""String_Node_Str"");
      if (eperson_ids != null) {
        EPerson[] members=group.getMembers();
        for (int x=0; x < eperson_ids.length; x++) {
          int foundIndex=-1;
          for (int y=0; y < members.length; y++) {
            if ((members[y] != null) && (members[y].getID() == eperson_ids[x])) {
              foundIndex=y;
              break;
            }
          }
          if (foundIndex == -1) {
            EPerson e=EPerson.find(c,eperson_ids[x]);
            group.addMember(e);
          }
 else {
            members[foundIndex]=null;
          }
        }
        for (int y=0; y < members.length; y++) {
          if (members[y] != null) {
            group.removeMember(members[y]);
          }
        }
        group.update();
      }
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else     if (button.equals(""String_Node_Str"")) {
      AuthorizeManager.authorizeAction(c,group,Constants.WRITE);
      group.delete();
      showMainPage(c,request,response);
      c.complete();
    }
 else {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
    if (button.equals(""String_Node_Str"")) {
      group=Group.create(c);
      group.setName(""String_Node_Str"" + group.getID());
      group.update();
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else {
      showMainPage(c,request,response);
    }
  }
}","protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  int groupID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Group group=null;
  if (groupID >= 0) {
    group=Group.find(c,groupID);
  }
  if (group != null) {
    AuthorizeManager.authorizeAction(c,group,Constants.ADD);
    String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
    if (button.equals(""String_Node_Str"")) {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else     if (button.equals(""String_Node_Str"")) {
      String newName=request.getParameter(""String_Node_Str"");
      if (!newName.equals(group.getName())) {
        group.setName(newName);
        group.update();
      }
      int[] eperson_ids=UIUtil.getIntParameters(request,""String_Node_Str"");
      EPerson[] members=group.getMembers();
      if (eperson_ids != null) {
        for (int x=0; x < eperson_ids.length; x++) {
          int foundIndex=-1;
          for (int y=0; y < members.length; y++) {
            if ((members[y] != null) && (members[y].getID() == eperson_ids[x])) {
              foundIndex=y;
              break;
            }
          }
          if (foundIndex == -1) {
            EPerson e=EPerson.find(c,eperson_ids[x]);
            group.addMember(e);
          }
 else {
            members[foundIndex]=null;
          }
        }
        for (int y=0; y < members.length; y++) {
          if (members[y] != null) {
            group.removeMember(members[y]);
          }
        }
      }
 else {
        for (int y=0; y < members.length; y++) {
          group.removeMember(members[y]);
        }
      }
      group.update();
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else     if (button.equals(""String_Node_Str"")) {
      AuthorizeManager.authorizeAction(c,group,Constants.WRITE);
      group.delete();
      showMainPage(c,request,response);
      c.complete();
    }
 else {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
    if (button.equals(""String_Node_Str"")) {
      group=Group.create(c);
      group.setName(""String_Node_Str"" + group.getID());
      group.update();
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else {
      showMainPage(c,request,response);
    }
  }
}",0.9564018611063244
52543,"protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String contentType=request.getContentType();
  if (contentType != null && contentType.indexOf(""String_Node_Str"") != -1) {
    processUploadLogo(context,request,response);
    return;
  }
  int action=UIUtil.getIntParameter(request,""String_Node_Str"");
  Community community=Community.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
  Collection collection=Collection.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
  request.setAttribute(""String_Node_Str"",community);
  request.setAttribute(""String_Node_Str"",collection);
  if (request.getParameter(""String_Node_Str"") != null) {
    showControls(context,request,response);
    return;
  }
switch (action) {
case START_EDIT_COMMUNITY:
    JSPManager.showJSP(request,response,""String_Node_Str"");
  break;
case START_DELETE_COMMUNITY:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_CREATE_COMMUNITY:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_EDIT_COLLECTION:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_DELETE_COLLECTION:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_CREATE_COLLECTION:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case CONFIRM_EDIT_COMMUNITY:
processConfirmEditCommunity(context,request,response,community);
break;
case CONFIRM_DELETE_COMMUNITY:
community.delete();
showControls(context,request,response);
context.complete();
break;
case CONFIRM_EDIT_COLLECTION:
processConfirmEditCollection(context,request,response,community,collection);
break;
case CONFIRM_DELETE_COLLECTION:
community.removeCollection(collection);
showControls(context,request,response);
context.complete();
break;
default :
log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
JSPManager.showIntegrityError(request,response);
}
}","protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String contentType=request.getContentType();
  if (contentType != null && contentType.indexOf(""String_Node_Str"") != -1) {
    processUploadLogo(context,request,response);
    return;
  }
  int action=UIUtil.getIntParameter(request,""String_Node_Str"");
  Community community=Community.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
  Collection collection=Collection.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
  request.setAttribute(""String_Node_Str"",community);
  request.setAttribute(""String_Node_Str"",collection);
  if (request.getParameter(""String_Node_Str"") != null) {
    showControls(context,request,response);
    return;
  }
switch (action) {
case START_EDIT_COMMUNITY:
    JSPManager.showJSP(request,response,""String_Node_Str"");
  break;
case START_DELETE_COMMUNITY:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_CREATE_COMMUNITY:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_EDIT_COLLECTION:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_DELETE_COLLECTION:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_CREATE_COLLECTION:
response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + community.getID()));
break;
case CONFIRM_EDIT_COMMUNITY:
processConfirmEditCommunity(context,request,response,community);
break;
case CONFIRM_DELETE_COMMUNITY:
community.delete();
showControls(context,request,response);
context.complete();
break;
case CONFIRM_EDIT_COLLECTION:
processConfirmEditCollection(context,request,response,community,collection);
break;
case CONFIRM_DELETE_COLLECTION:
community.removeCollection(collection);
showControls(context,request,response);
context.complete();
break;
default :
log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
JSPManager.showIntegrityError(request,response);
}
}",0.9607512641464002
52544,"/** 
 * Give the community a logo.  Passing in <code>null</code> removes any existing logo.  You will need to set the format of the new logo bitstream before it will work, for example to ""JPEG"".  Note that <code>update(/code> will need to be called for the change to take effect.  Setting a logo and not calling <code>update</code> later may result in a previous logo lying around as an ""orphaned"" bitstream.
 * @param is   the stream to use as the new logo
 * @return   the new logo bitstream, or <code>null</code> if there is nologo (<code>null</code> was passed in)
 */
public Bitstream setLogo(InputStream is) throws AuthorizeException, IOException, SQLException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.WRITE);
  if (logo != null) {
    log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
    communityRow.setColumnNull(""String_Node_Str"");
    logo.delete();
  }
  if (is != null) {
    Bitstream newLogo=Bitstream.create(ourContext,is);
    communityRow.setColumn(""String_Node_Str"",newLogo.getID());
    logo=newLogo;
    List policies=AuthorizeManager.getPoliciesActionFilter(ourContext,this,Constants.READ);
    AuthorizeManager.addPolicies(ourContext,policies,newLogo);
    log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID() + ""String_Node_Str""+ newLogo.getID()));
  }
  return logo;
}","/** 
 * Give the community a logo.  Passing in <code>null</code> removes any existing logo.  You will need to set the format of the new logo bitstream before it will work, for example to ""JPEG"".  Note that <code>update(/code> will need to be called for the change to take effect.  Setting a logo and not calling <code>update</code> later may result in a previous logo lying around as an ""orphaned"" bitstream.
 * @param is   the stream to use as the new logo
 * @return   the new logo bitstream, or <code>null</code> if there is nologo (<code>null</code> was passed in)
 */
public Bitstream setLogo(InputStream is) throws AuthorizeException, IOException, SQLException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.WRITE);
  if (logo != null) {
    log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
    communityRow.setColumnNull(""String_Node_Str"");
    logo.delete();
    logo=null;
  }
  if (is != null) {
    Bitstream newLogo=Bitstream.create(ourContext,is);
    communityRow.setColumn(""String_Node_Str"",newLogo.getID());
    logo=newLogo;
    List policies=AuthorizeManager.getPoliciesActionFilter(ourContext,this,Constants.READ);
    AuthorizeManager.addPolicies(ourContext,policies,newLogo);
    log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID() + ""String_Node_Str""+ newLogo.getID()));
  }
  return logo;
}",0.9946332737030412
52545,"/** 
 * Show an item page
 * @param context     Context object
 * @param request     the HTTP request
 * @param response    the HTTP response
 * @param item        the item
 * @param handle      the item's handle
 */
private void displayItem(Context context,HttpServletRequest request,HttpServletResponse response,Item item,String handle) throws ServletException, IOException, SQLException, AuthorizeException {
  if (item.isWithdrawn()) {
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  AuthorizeManager.authorizeAction(context,item,Constants.READ);
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + handle));
  if (item.canEdit()) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  Collection[] collections=item.getCollections();
  request.setAttribute(""String_Node_Str"",collections[0]);
  Community[] comms=collections[0].getCommunities();
  request.setAttribute(""String_Node_Str"",comms[0]);
  request.setAttribute(""String_Node_Str"",getParents(comms[0],true));
  boolean displayAll=false;
  String modeParam=request.getParameter(""String_Node_Str"");
  if (modeParam != null && modeParam.equalsIgnoreCase(""String_Node_Str"")) {
    displayAll=true;
  }
  request.setAttribute(""String_Node_Str"",new Boolean(displayAll));
  request.setAttribute(""String_Node_Str"",item);
  request.setAttribute(""String_Node_Str"",collections);
  JSPManager.showJSP(request,response,""String_Node_Str"");
}","/** 
 * Show an item page
 * @param context     Context object
 * @param request     the HTTP request
 * @param response    the HTTP response
 * @param item        the item
 * @param handle      the item's handle
 */
private void displayItem(Context context,HttpServletRequest request,HttpServletResponse response,Item item,String handle) throws ServletException, IOException, SQLException, AuthorizeException {
  if (item.isWithdrawn()) {
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  AuthorizeManager.authorizeAction(context,item,Constants.READ);
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + handle));
  if (item.canEdit()) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  Collection[] collections=item.getCollections();
  request.setAttribute(""String_Node_Str"",item.getOwningCollection());
  Community[] comms=item.getOwningCollection().getCommunities();
  request.setAttribute(""String_Node_Str"",comms[0]);
  request.setAttribute(""String_Node_Str"",getParents(comms[0],true));
  boolean displayAll=false;
  String modeParam=request.getParameter(""String_Node_Str"");
  if (modeParam != null && modeParam.equalsIgnoreCase(""String_Node_Str"")) {
    displayAll=true;
  }
  request.setAttribute(""String_Node_Str"",new Boolean(displayAll));
  request.setAttribute(""String_Node_Str"",item);
  request.setAttribute(""String_Node_Str"",collections);
  JSPManager.showJSP(request,response,""String_Node_Str"");
}",0.8770380434782609
52546,"/** 
 * Get the communities this item is in.  Returns an unordered array of the communities that house the collections this item is in.
 * @return  the communities this item is in.
 */
public Community[] getCommunities() throws SQLException {
  List communities=new ArrayList();
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow row=tri.next();
    Community fromCache=(Community)ourContext.fromCache(Community.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      communities.add(fromCache);
    }
 else {
      communities.add(new Community(ourContext,row));
    }
  }
  Community[] communityArray=new Community[communities.size()];
  communityArray=(Community[])communities.toArray(communityArray);
  return communityArray;
}","/** 
 * Get the communities this item is in.  Returns an unordered array of the communities that house the collections this item is in, including parent communities of the owning collections.
 * @return  the communities this item is in.
 */
public Community[] getCommunities() throws SQLException {
  List communities=new ArrayList();
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow row=tri.next();
    Community owner=(Community)ourContext.fromCache(Community.class,row.getIntColumn(""String_Node_Str""));
    if (owner == null) {
      owner=new Community(ourContext,row);
    }
    communities.add(owner);
    Community[] parents=owner.getAllParents();
    for (int i=0; i < parents.length; i++) {
      communities.add(parents[i]);
    }
  }
  Community[] communityArray=new Community[communities.size()];
  communityArray=(Community[])communities.toArray(communityArray);
  return communityArray;
}",0.6258637709772952
52547,"/** 
 * This method should be called whenever an item is added.
 * @param context The current DSpace context
 * @param item The item which has been added
 * @exception SQLException If a database error occurs
 */
public static void itemAdded(Context context,Item item) throws SQLException {
  Map table2dc=new HashMap();
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",null,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",Item.ANY,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  for (Iterator iterator=table2dc.keySet().iterator(); iterator.hasNext(); ) {
    String table=(String)iterator.next();
    DCValue[] dc=(DCValue[])table2dc.get(table);
    for (int i=0; i < dc.length; i++) {
      TableRow row=DatabaseManager.create(context,table);
      row.setColumn(""String_Node_Str"",item.getID());
      String value=dc[i].value;
      if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table)) {
        row.setColumn(""String_Node_Str"",value);
        row.setColumn(""String_Node_Str"",value.toLowerCase());
      }
 else       if (""String_Node_Str"".equals(table)) {
        String title=NormalizedTitle.normalize(value,dc[i].language);
        row.setColumn(""String_Node_Str"",value);
        row.setColumn(""String_Node_Str"",title.toLowerCase());
      }
      DatabaseManager.update(context,row);
    }
  }
}","/** 
 * This method should be called whenever an item is added.
 * @param context The current DSpace context
 * @param item The item which has been added
 * @exception SQLException If a database error occurs
 */
public static void itemAdded(Context context,Item item) throws SQLException {
  Community[] parents=item.getCommunities();
  for (int j=0; j < parents.length; j++) {
    TableRow row=DatabaseManager.create(context,""String_Node_Str"");
    row.setColumn(""String_Node_Str"",item.getID());
    row.setColumn(""String_Node_Str"",parents[j].getID());
    DatabaseManager.update(context,row);
  }
  Map table2dc=new HashMap();
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",null,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",Item.ANY,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  for (Iterator iterator=table2dc.keySet().iterator(); iterator.hasNext(); ) {
    String table=(String)iterator.next();
    DCValue[] dc=(DCValue[])table2dc.get(table);
    for (int i=0; i < dc.length; i++) {
      TableRow row=DatabaseManager.create(context,table);
      row.setColumn(""String_Node_Str"",item.getID());
      String value=dc[i].value;
      if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table)) {
        row.setColumn(""String_Node_Str"",value);
        row.setColumn(""String_Node_Str"",value.toLowerCase());
      }
 else       if (""String_Node_Str"".equals(table)) {
        String title=NormalizedTitle.normalize(value,dc[i].language);
        row.setColumn(""String_Node_Str"",value);
        row.setColumn(""String_Node_Str"",title.toLowerCase());
      }
      DatabaseManager.update(context,row);
    }
  }
}",0.9150865622423744
52548,"/** 
 * Get the communities this collection appears in
 * @return   array of <code>Community</code> objects
 */
public Community[] getCommunities() throws SQLException {
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + getID() + ""String_Node_Str"");
  List communities=new ArrayList();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    Community fromCache=(Community)ourContext.fromCache(Community.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      communities.add(fromCache);
    }
 else {
      communities.add(new Community(ourContext,row));
    }
  }
  Community[] communityArray=new Community[communities.size()];
  communityArray=(Community[])communities.toArray(communityArray);
  return communityArray;
}","/** 
 * Get the communities this collection appears in
 * @return   array of <code>Community</code> objects
 */
public Community[] getCommunities() throws SQLException {
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + getID() + ""String_Node_Str"");
  List communities=new ArrayList();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    Community owner=(Community)ourContext.fromCache(Community.class,row.getIntColumn(""String_Node_Str""));
    if (owner == null) {
      owner=new Community(ourContext,row);
    }
    communities.add(owner);
    Community[] parents=owner.getAllParents();
    for (int i=0; i < parents.length; i++) {
      communities.add(parents[i]);
    }
  }
  Community[] communityArray=new Community[communities.size()];
  communityArray=(Community[])communities.toArray(communityArray);
  return communityArray;
}",0.5988636363636364
52549,"/** 
 * Delete the community, including the metadata and logo.  Collections and subcommunities that are then orphans are deleted.
 */
public void delete() throws SQLException, AuthorizeException, IOException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.DELETE);
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
  DSIndexer.unIndexContent(ourContext,this);
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  ourContext.removeCached(this,getID());
  Collection[] cols=getCollections();
  for (int i=0; i < cols.length; i++) {
    removeCollection(cols[i]);
  }
  Community[] comms=getSubcommunities();
  for (int j=0; j < comms.length; j++) {
    removeSubcommunity(comms[j]);
  }
  setLogo(null);
  AuthorizeManager.removeAllPolicies(ourContext,this);
  DatabaseManager.delete(ourContext,communityRow);
}","/** 
 * Delete the community, including the metadata and logo.  Collections and subcommunities that are then orphans are deleted.
 */
public void delete() throws SQLException, AuthorizeException, IOException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.DELETE);
  Community parent=getParentCommunity();
  if (parent != null) {
    parent.removeSubcommunity(this);
    return;
  }
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
  DSIndexer.unIndexContent(ourContext,this);
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  ourContext.removeCached(this,getID());
  Collection[] cols=getCollections();
  for (int i=0; i < cols.length; i++) {
    removeCollection(cols[i]);
  }
  Community[] comms=getSubcommunities();
  for (int j=0; j < comms.length; j++) {
    removeSubcommunity(comms[j]);
  }
  setLogo(null);
  AuthorizeManager.removeAllPolicies(ourContext,this);
  DatabaseManager.delete(ourContext,communityRow);
}",0.941
52550,"protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.create(context);
    e.setEmail(""String_Node_Str"" + e.getID());
    e.update();
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    String oldEmail=e.getEmail();
    String newEmail=request.getParameter(""String_Node_Str"").trim();
    if (!newEmail.equals(oldEmail)) {
      if (EPerson.findByEmail(context,newEmail) == null) {
        e.setEmail(newEmail);
        e.setFirstName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setLastName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setCanLogIn(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.setRequireCertificate(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.update();
        showMain(context,request,response);
        context.complete();
      }
 else {
        request.setAttribute(""String_Node_Str"",e);
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        JSPManager.showJSP(request,response,""String_Node_Str"");
        context.complete();
      }
    }
 else {
      e.setFirstName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setLastName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setCanLogIn(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
      e.setRequireCertificate(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
      e.update();
      showMain(context,request,response);
      context.complete();
    }
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    e.delete();
    showMain(context,request,response);
    context.complete();
  }
 else {
    showMain(context,request,response);
  }
}","protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.create(context);
    e.setEmail(""String_Node_Str"" + e.getID());
    e.update();
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    String oldEmail=e.getEmail();
    String newEmail=request.getParameter(""String_Node_Str"").trim();
    if (!newEmail.equals(oldEmail)) {
      if (EPerson.findByEmail(context,newEmail) == null) {
        e.setEmail(newEmail);
        e.setFirstName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setLastName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setCanLogIn(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.setRequireCertificate(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.update();
        showMain(context,request,response);
        context.complete();
      }
 else {
        request.setAttribute(""String_Node_Str"",e);
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        JSPManager.showJSP(request,response,""String_Node_Str"");
        context.complete();
      }
    }
 else {
      e.setFirstName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setLastName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setCanLogIn(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
      e.setRequireCertificate(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
      e.update();
      showMain(context,request,response);
      context.complete();
    }
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    try {
      e.delete();
    }
 catch (    EPersonDeletionException ex) {
      request.setAttribute(""String_Node_Str"",e);
      request.setAttribute(""String_Node_Str"",ex.getTables());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
    showMain(context,request,response);
    context.complete();
  }
 else {
    showMain(context,request,response);
  }
}",0.9643051771117166
52551,"/** 
 * Delete an eperson
 */
public void delete() throws SQLException, AuthorizeException {
  if (!AuthorizeManager.isAdmin(myContext)) {
    throw new AuthorizeException(""String_Node_Str"");
  }
  HistoryManager.saveHistory(myContext,this,HistoryManager.REMOVE,myContext.getCurrentUser(),myContext.getExtraLogInfo());
  myContext.removeCached(this,getID());
  DatabaseManager.updateQuery(myContext,""String_Node_Str"" + getID());
  DatabaseManager.delete(myContext,myRow);
  log.info(LogManager.getHeader(myContext,""String_Node_Str"",""String_Node_Str"" + getID()));
}","/** 
 * Delete an eperson
 */
public void delete() throws SQLException, AuthorizeException, EPersonDeletionException {
  if (!AuthorizeManager.isAdmin(myContext)) {
    throw new AuthorizeException(""String_Node_Str"");
  }
  HistoryManager.saveHistory(myContext,this,HistoryManager.REMOVE,myContext.getCurrentUser(),myContext.getExtraLogInfo());
  Vector constraintList=getDeleteConstraints();
  if (constraintList.size() > 0)   throw new EPersonDeletionException(constraintList);
  myContext.removeCached(this,getID());
  DatabaseManager.updateQuery(myContext,""String_Node_Str"" + getID());
  DatabaseManager.updateQuery(myContext,""String_Node_Str"" + getID());
  DatabaseManager.delete(myContext,myRow);
  log.info(LogManager.getHeader(myContext,""String_Node_Str"",""String_Node_Str"" + getID()));
}",0.8300220750551877
52552,"/** 
 * Process the input from the upload bitstream page
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processUploadBitstream(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  FileUploadRequest wrapper=new FileUploadRequest(request);
  Bitstream b=null;
  Item item=Item.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  File temp=wrapper.getFile(""String_Node_Str"");
  InputStream is=new BufferedInputStream(new FileInputStream(temp));
  checkEditAuthorization(context,item);
  Bundle[] bundles=item.getBundles();
  if (bundles.length < 1) {
    b=item.createSingleBitstream(is,""String_Node_Str"");
  }
 else {
    b=bundles[0].createBitstream(is);
  }
  String noPath=wrapper.getFilesystemName(""String_Node_Str"");
  while (noPath.indexOf('/') > -1) {
    noPath=noPath.substring(noPath.indexOf('/') + 1);
  }
  while (noPath.indexOf('\\') > -1) {
    noPath=noPath.substring(noPath.indexOf('\\') + 1);
  }
  b.setName(noPath);
  b.setSource(wrapper.getFilesystemName(""String_Node_Str""));
  BitstreamFormat bf=FormatIdentifier.guessFormat(context,b);
  b.setFormat(bf);
  b.update();
  item.update();
  showEditForm(context,request,response,item);
  temp.delete();
  context.complete();
}","/** 
 * Process the input from the upload bitstream page
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processUploadBitstream(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  FileUploadRequest wrapper=new FileUploadRequest(request);
  Bitstream b=null;
  Item item=Item.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  File temp=wrapper.getFile(""String_Node_Str"");
  InputStream is=new BufferedInputStream(new FileInputStream(temp));
  checkEditAuthorization(context,item);
  Bundle[] bundles=item.getBundles(""String_Node_Str"");
  if (bundles.length < 1) {
    b=item.createSingleBitstream(is,""String_Node_Str"");
  }
 else {
    b=bundles[0].createBitstream(is);
  }
  String noPath=wrapper.getFilesystemName(""String_Node_Str"");
  while (noPath.indexOf('/') > -1) {
    noPath=noPath.substring(noPath.indexOf('/') + 1);
  }
  while (noPath.indexOf('\\') > -1) {
    noPath=noPath.substring(noPath.indexOf('\\') + 1);
  }
  b.setName(noPath);
  b.setSource(wrapper.getFilesystemName(""String_Node_Str""));
  BitstreamFormat bf=FormatIdentifier.guessFormat(context,b);
  b.setFormat(bf);
  b.update();
  item.update();
  showEditForm(context,request,response,item);
  temp.delete();
  context.complete();
}",0.9940455341506128
52553,"public static void main(String[] argv) throws Exception {
  Context c=new Context();
  c.setIgnoreAuthorization(true);
  ItemIterator ii=Item.findAll(c);
  while (ii.hasNext()) {
    boolean skipItem=false;
    Item myItem=ii.next();
    int licenseBundleIndex=-1;
    int primaryBundleIndex=-1;
    System.out.println(""String_Node_Str"" + myItem.getID());
    Bundle[] myBundles=myItem.getBundles();
    for (int i=0; i < myBundles.length; i++) {
      Bitstream[] bitstreams=myBundles[i].getBitstreams();
      if (bitstreams.length > 1) {
        System.out.println(""String_Node_Str"");
        skipItem=true;
        break;
      }
      BitstreamFormat bf=bitstreams[0].getFormat();
      if (bf.getShortDescription().equals(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"");
        if (licenseBundleIndex == -1) {
          licenseBundleIndex=i;
          System.out.println(""String_Node_Str"" + i);
        }
 else {
          System.out.println(""String_Node_Str"");
          skipItem=true;
          break;
        }
      }
 else {
        if (primaryBundleIndex == -1) {
          primaryBundleIndex=i;
          System.out.println(""String_Node_Str"" + i);
        }
      }
    }
    if (!skipItem) {
      if (primaryBundleIndex != -1) {
        myBundles[primaryBundleIndex].setName(""String_Node_Str"");
        myBundles[primaryBundleIndex].update();
      }
      if (licenseBundleIndex != -1) {
        myBundles[licenseBundleIndex].setName(""String_Node_Str"");
        myBundles[licenseBundleIndex].update();
      }
      for (int i=0; i < myBundles.length; i++) {
        Bitstream[] bitstreams=myBundles[i].getBitstreams();
        if (bitstreams.length > 0) {
          if ((i != primaryBundleIndex) && (i != licenseBundleIndex)) {
            myBundles[primaryBundleIndex].addBitstream(bitstreams[0]);
            myItem.removeBundle(myBundles[i]);
            System.out.println(""String_Node_Str"" + i + ""String_Node_Str"");
          }
        }
      }
    }
  }
  c.complete();
}","public static void main(String[] argv) throws Exception {
  Context c=new Context();
  c.setIgnoreAuthorization(true);
  ItemIterator ii=null;
  Collection[] collections=Collection.findAll(c);
  System.out.println(""String_Node_Str"");
  for (int q=0; q < collections.length; q++) {
    ii=collections[q].getItems();
    while (ii.hasNext()) {
      Item myItem=ii.next();
      if (myItem.getOwningCollection() == null) {
        myItem.setOwningCollection(collections[q]);
        myItem.update();
        System.out.println(""String_Node_Str"" + myItem.getID() + ""String_Node_Str""+ collections[q].getID());
      }
    }
  }
  c.commit();
  ii=Item.findAll(c);
  while (ii.hasNext()) {
    boolean skipItem=false;
    Item myItem=ii.next();
    int licenseBundleIndex=-1;
    int primaryBundleIndex=-1;
    System.out.println(""String_Node_Str"" + myItem.getID());
    Bundle[] myBundles=myItem.getBundles();
    for (int i=0; i < myBundles.length; i++) {
      if (myBundles[i].getName() != null) {
        System.out.println(""String_Node_Str"");
        skipItem=true;
        break;
      }
      Bitstream[] bitstreams=myBundles[i].getBitstreams();
      if (bitstreams.length > 1) {
        System.out.println(""String_Node_Str"");
        skipItem=true;
        break;
      }
      BitstreamFormat bf=bitstreams[0].getFormat();
      if (bf.getShortDescription().equals(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"");
        if (licenseBundleIndex == -1) {
          licenseBundleIndex=i;
          System.out.println(""String_Node_Str"" + i);
        }
 else {
          System.out.println(""String_Node_Str"");
          skipItem=true;
          break;
        }
      }
 else {
        if (primaryBundleIndex == -1) {
          primaryBundleIndex=i;
          System.out.println(""String_Node_Str"" + i);
        }
      }
    }
    if (!skipItem) {
      if (primaryBundleIndex != -1) {
        myBundles[primaryBundleIndex].setName(""String_Node_Str"");
        myBundles[primaryBundleIndex].update();
      }
      if (licenseBundleIndex != -1) {
        myBundles[licenseBundleIndex].setName(""String_Node_Str"");
        myBundles[licenseBundleIndex].update();
      }
      for (int i=0; i < myBundles.length; i++) {
        Bitstream[] bitstreams=myBundles[i].getBitstreams();
        if (bitstreams.length > 0) {
          if ((i != primaryBundleIndex) && (i != licenseBundleIndex)) {
            myBundles[primaryBundleIndex].addBitstream(bitstreams[0]);
            myItem.removeBundle(myBundles[i]);
            System.out.println(""String_Node_Str"" + i + ""String_Node_Str"");
          }
        }
      }
    }
  }
  c.complete();
}",0.8607486631016042
52554,"public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  boolean emphasiseDate=false;
  boolean emphasiseTitle=false;
  if (emphColumn != null) {
    emphasiseDate=emphColumn.equalsIgnoreCase(""String_Node_Str"");
    emphasiseTitle=emphColumn.equalsIgnoreCase(""String_Node_Str"");
  }
  try {
    out.println(""String_Node_Str"");
    out.print(""String_Node_Str"" + (emphasiseDate ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ (emphasiseDate ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    out.println(""String_Node_Str"" + (emphasiseTitle ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ (emphasiseTitle ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    out.println(""String_Node_Str"");
    String row=""String_Node_Str"";
    for (int i=0; i < items.length; i++) {
      DCValue[] titleArray=items[i].getDC(""String_Node_Str"",null,Item.ANY);
      String title=""String_Node_Str"";
      if (titleArray.length > 0) {
        title=titleArray[0].value;
      }
      DCValue[] authors=items[i].getDC(""String_Node_Str"",Item.ANY,Item.ANY);
      DCValue[] dateIssued=items[i].getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
      DCDate dd=null;
      if (dateIssued.length > 0) {
        dd=new DCDate(dateIssued[0].value);
      }
      out.print(""String_Node_Str"");
      out.print(i == highlightRow ? ""String_Node_Str"" : row);
      out.print(""String_Node_Str"");
      if (emphasiseDate) {
        out.print(""String_Node_Str"");
      }
      out.print(UIUtil.displayDate(dd,false,false));
      if (emphasiseDate) {
        out.print(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      out.print(i == highlightRow ? ""String_Node_Str"" : row);
      out.print(""String_Node_Str"");
      if (emphasiseTitle) {
        out.print(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
      out.print(hrq.getContextPath());
      out.print(""String_Node_Str"");
      out.print(items[i].getHandle());
      out.print(""String_Node_Str"");
      out.print(title);
      out.print(""String_Node_Str"");
      if (emphasiseTitle) {
        out.print(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      out.print(i == highlightRow ? ""String_Node_Str"" : row);
      out.print(""String_Node_Str"");
      for (int j=0; j < authors.length; j++) {
        out.print(""String_Node_Str"" + authors[j].value + ""String_Node_Str"");
        if (j < authors.length - 1) {
          out.print(""String_Node_Str"");
        }
      }
      out.println(""String_Node_Str"");
      row=(row.equals(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
  return SKIP_BODY;
}","public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  boolean emphasiseDate=false;
  boolean emphasiseTitle=false;
  if (emphColumn != null) {
    emphasiseDate=emphColumn.equalsIgnoreCase(""String_Node_Str"");
    emphasiseTitle=emphColumn.equalsIgnoreCase(""String_Node_Str"");
  }
  try {
    out.println(""String_Node_Str"");
    out.print(""String_Node_Str"" + (emphasiseDate ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ (emphasiseDate ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    out.println(""String_Node_Str"" + (emphasiseTitle ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ (emphasiseTitle ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    out.println(""String_Node_Str"");
    String row=""String_Node_Str"";
    for (int i=0; i < items.length; i++) {
      DCValue[] titleArray=items[i].getDC(""String_Node_Str"",null,Item.ANY);
      String title=""String_Node_Str"";
      if (titleArray.length > 0) {
        title=titleArray[0].value;
      }
      DCValue[] authors=items[i].getDC(""String_Node_Str"",Item.ANY,Item.ANY);
      DCValue[] dateIssued=items[i].getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
      DCDate dd=null;
      if (dateIssued.length > 0) {
        dd=new DCDate(dateIssued[0].value);
      }
      out.print(""String_Node_Str"");
      out.print(i == highlightRow ? ""String_Node_Str"" : row);
      out.print(""String_Node_Str"");
      if (emphasiseDate) {
        out.print(""String_Node_Str"");
      }
      out.print(UIUtil.displayDate(dd,false,false));
      if (emphasiseDate) {
        out.print(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      out.print(i == highlightRow ? ""String_Node_Str"" : row);
      out.print(""String_Node_Str"");
      if (emphasiseTitle) {
        out.print(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
      out.print(hrq.getContextPath());
      out.print(""String_Node_Str"");
      out.print(items[i].getHandle());
      out.print(""String_Node_Str"");
      out.print(Utils.addEntities(title));
      out.print(""String_Node_Str"");
      if (emphasiseTitle) {
        out.print(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      out.print(i == highlightRow ? ""String_Node_Str"" : row);
      out.print(""String_Node_Str"");
      for (int j=0; j < authors.length; j++) {
        out.print(""String_Node_Str"" + Utils.addEntities(authors[j].value) + ""String_Node_Str"");
        if (j < authors.length - 1) {
          out.print(""String_Node_Str"");
        }
      }
      out.println(""String_Node_Str"");
      row=(row.equals(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
  return SKIP_BODY;
}",0.9916579770594368
52555,"/** 
 * Render full item record
 */
private void renderFull() throws IOException, java.sql.SQLException {
  JspWriter out=pageContext.getOut();
  DCValue[] values=item.getDC(Item.ANY,Item.ANY,Item.ANY);
  out.println(""String_Node_Str"");
  HttpServletRequest request=(HttpServletRequest)pageContext.getRequest();
  out.println(""String_Node_Str"");
  out.println(""String_Node_Str"");
  for (int i=0; i < values.length; i++) {
    boolean hidden=false;
    if (values[i].element.equals(""String_Node_Str"") && (values[i].qualifier != null && values[i].qualifier.equals(""String_Node_Str""))) {
      hidden=true;
    }
    if (!hidden) {
      out.print(""String_Node_Str"");
      out.print(values[i].element);
      if (values[i].qualifier != null) {
        out.print(""String_Node_Str"" + values[i].qualifier);
      }
      out.print(""String_Node_Str"");
      out.print(values[i].value);
      out.print(""String_Node_Str"");
      if (values[i].language == null) {
        out.print(""String_Node_Str"");
      }
 else {
        out.print(values[i].language);
      }
      out.println(""String_Node_Str"");
    }
  }
  listCollections();
  out.println(""String_Node_Str"");
  listBitstreams();
}","/** 
 * Render full item record
 */
private void renderFull() throws IOException, java.sql.SQLException {
  JspWriter out=pageContext.getOut();
  DCValue[] values=item.getDC(Item.ANY,Item.ANY,Item.ANY);
  out.println(""String_Node_Str"");
  HttpServletRequest request=(HttpServletRequest)pageContext.getRequest();
  out.println(""String_Node_Str"");
  out.println(""String_Node_Str"");
  for (int i=0; i < values.length; i++) {
    boolean hidden=false;
    if (values[i].element.equals(""String_Node_Str"") && (values[i].qualifier != null && values[i].qualifier.equals(""String_Node_Str""))) {
      hidden=true;
    }
    if (!hidden) {
      out.print(""String_Node_Str"");
      out.print(values[i].element);
      if (values[i].qualifier != null) {
        out.print(""String_Node_Str"" + values[i].qualifier);
      }
      out.print(""String_Node_Str"");
      out.print(Utils.addEntities(values[i].value));
      out.print(""String_Node_Str"");
      if (values[i].language == null) {
        out.print(""String_Node_Str"");
      }
 else {
        out.print(values[i].language);
      }
      out.println(""String_Node_Str"");
    }
  }
  listCollections();
  out.println(""String_Node_Str"");
  listBitstreams();
}",0.992020159596808
52556,"/** 
 * Render an item in the default style
 */
private void renderDefault() throws IOException, java.sql.SQLException {
  JspWriter out=pageContext.getOut();
  List fields=new LinkedList();
  DCValue[] titleDC=item.getDC(""String_Node_Str"",null,Item.ANY);
  if (titleDC.length == 0) {
    fields.add(new String[]{""String_Node_Str"",""String_Node_Str""});
  }
 else {
    fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  }
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",Item.ANY});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  DCValue[] dateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCDate dd=null;
  if (dateIssued.length > 0) {
    dd=new DCDate(dateIssued[0].value);
  }
  String displayDate=UIUtil.displayDate(dd,false,false);
  fields.add(new String[]{""String_Node_Str"",displayDate});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  DCValue[] abstrDC=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  if (abstrDC.length > 0) {
    String abstr=abstrDC[0].value;
    if (abstr.length() > 1000) {
      abstr=abstr.substring(0,1000) + ""String_Node_Str"";
    }
    fields.add(new String[]{""String_Node_Str"",abstr});
  }
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  HttpServletRequest request=(HttpServletRequest)pageContext.getRequest();
  out.println(""String_Node_Str"");
  Iterator fieldIterator=fields.iterator();
  while (fieldIterator.hasNext()) {
    String[] fieldData=(String[])fieldIterator.next();
    DCValue[] values;
    if (fieldData.length == 2) {
      DCValue v=new DCValue();
      v.value=fieldData[1];
      values=new DCValue[1];
      values[0]=v;
    }
 else {
      values=item.getDC(fieldData[1],fieldData[2],Item.ANY);
    }
    if (values.length > 0) {
      out.print(""String_Node_Str"");
      out.print(fieldData[0]);
      out.print(""String_Node_Str"");
      out.print(values[0].value);
      for (int j=1; j < values.length; j++) {
        out.print(""String_Node_Str"");
        out.print(values[j].value);
      }
      out.println(""String_Node_Str"");
    }
  }
  listCollections();
  out.println(""String_Node_Str"");
  listBitstreams();
}","/** 
 * Render an item in the default style
 */
private void renderDefault() throws IOException, java.sql.SQLException {
  JspWriter out=pageContext.getOut();
  List fields=new LinkedList();
  DCValue[] titleDC=item.getDC(""String_Node_Str"",null,Item.ANY);
  if (titleDC.length == 0) {
    fields.add(new String[]{""String_Node_Str"",""String_Node_Str""});
  }
 else {
    fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  }
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",Item.ANY});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  DCValue[] dateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCDate dd=null;
  if (dateIssued.length > 0) {
    dd=new DCDate(dateIssued[0].value);
  }
  String displayDate=UIUtil.displayDate(dd,false,false);
  fields.add(new String[]{""String_Node_Str"",displayDate});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  DCValue[] abstrDC=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  if (abstrDC.length > 0) {
    String abstr=abstrDC[0].value;
    if (abstr.length() > 1000) {
      abstr=abstr.substring(0,1000) + ""String_Node_Str"";
    }
    fields.add(new String[]{""String_Node_Str"",abstr});
  }
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  HttpServletRequest request=(HttpServletRequest)pageContext.getRequest();
  out.println(""String_Node_Str"");
  Iterator fieldIterator=fields.iterator();
  while (fieldIterator.hasNext()) {
    String[] fieldData=(String[])fieldIterator.next();
    DCValue[] values;
    if (fieldData.length == 2) {
      DCValue v=new DCValue();
      v.value=fieldData[1];
      values=new DCValue[1];
      values[0]=v;
    }
 else {
      values=item.getDC(fieldData[1],fieldData[2],Item.ANY);
    }
    if (values.length > 0) {
      out.print(""String_Node_Str"");
      out.print(fieldData[0]);
      out.print(""String_Node_Str"");
      out.print(Utils.addEntities(values[0].value));
      for (int j=1; j < values.length; j++) {
        out.print(""String_Node_Str"");
        out.print(Utils.addEntities(values[j].value));
      }
      out.println(""String_Node_Str"");
    }
  }
  listCollections();
  out.println(""String_Node_Str"");
  listBitstreams();
}",0.993598382749326
52557,"/** 
 * Process input from the edit item form
 * @param context   DSpace context
 * @param request   the HTTP request containing posted info
 * @param response  the HTTP response
 * @param item      the item
 */
private void processUpdateItem(Context context,HttpServletRequest request,HttpServletResponse response,Item item) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  item.clearDC(Item.ANY,Item.ANY,Item.ANY);
  Enumeration unsortedParamNames=request.getParameterNames();
  List sortedParamNames=new LinkedList();
  while (unsortedParamNames.hasMoreElements()) {
    sortedParamNames.add(unsortedParamNames.nextElement());
  }
  Collections.sort(sortedParamNames);
  Iterator iterator=sortedParamNames.iterator();
  while (iterator.hasNext()) {
    String p=(String)iterator.next();
    if (p.startsWith(""String_Node_Str"")) {
      StringTokenizer st=new StringTokenizer(p,""String_Node_Str"");
      st.nextToken();
      String element=st.nextToken();
      String qualifier=null;
      if (st.countTokens() == 2) {
        qualifier=st.nextToken();
      }
      String sequenceNumber=st.nextToken();
      String key=element;
      if (qualifier != null) {
        key=element + ""String_Node_Str"" + qualifier;
      }
      String language=request.getParameter(""String_Node_Str"" + key + ""String_Node_Str""+ sequenceNumber);
      if (language != null && language.equals(""String_Node_Str"")) {
        language=null;
      }
      String value=request.getParameter(p).trim();
      if (value.equals(""String_Node_Str"") || !button.equals(""String_Node_Str"" + key + ""String_Node_Str""+ sequenceNumber)) {
        item.addDC(element,qualifier,language,value);
      }
    }
 else     if (p.startsWith(""String_Node_Str"")) {
      StringTokenizer st=new StringTokenizer(p,""String_Node_Str"");
      st.nextToken();
      st.nextToken();
      int bundleID=Integer.parseInt(st.nextToken());
      int bitstreamID=Integer.parseInt(st.nextToken());
      Bundle bundle=Bundle.find(context,bundleID);
      Bitstream bitstream=Bitstream.find(context,bitstreamID);
      String key=String.valueOf(bundleID) + ""String_Node_Str"" + bitstreamID;
      if (button.equals(""String_Node_Str"" + key)) {
        bundle.removeBitstream(bitstream);
        if (bundle.getBitstreams().length == 0) {
          item.removeBundle(bundle);
        }
      }
 else {
        String name=request.getParameter(p);
        String source=request.getParameter(""String_Node_Str"" + key);
        String desc=request.getParameter(""String_Node_Str"" + key);
        int formatID=UIUtil.getIntParameter(request,""String_Node_Str"" + key);
        String userFormatDesc=request.getParameter(""String_Node_Str"" + key);
        int primaryBitstreamID=UIUtil.getIntParameter(request,bundleID + ""String_Node_Str"");
        if (source.equals(""String_Node_Str""))         source=null;
        if (desc.equals(""String_Node_Str""))         desc=null;
        if (userFormatDesc.equals(""String_Node_Str""))         userFormatDesc=null;
        bitstream.setName(name);
        bitstream.setSource(source);
        bitstream.setDescription(desc);
        bitstream.setFormat(BitstreamFormat.find(context,formatID));
        bundle.setPrimaryBitstreamID(primaryBitstreamID);
        if (userFormatDesc != null) {
          bitstream.setUserFormatDescription(userFormatDesc);
        }
        bitstream.update();
        bundle.update();
      }
    }
  }
  item.update();
  if (button.equals(""String_Node_Str"")) {
    int dcTypeID=UIUtil.getIntParameter(request,""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"").trim();
    String lang=request.getParameter(""String_Node_Str"");
    if (lang.equals(""String_Node_Str""))     lang=null;
    DCType dcType=DCType.find(context,dcTypeID);
    item.addDC(dcType.getElement(),dcType.getQualifier(),lang,value);
    item.update();
  }
  if (button.equals(""String_Node_Str"")) {
    request.setAttribute(""String_Node_Str"",item);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showEditForm(context,request,response,item);
  }
  context.complete();
}","/** 
 * Process input from the edit item form
 * @param context   DSpace context
 * @param request   the HTTP request containing posted info
 * @param response  the HTTP response
 * @param item      the item
 */
private void processUpdateItem(Context context,HttpServletRequest request,HttpServletResponse response,Item item) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  item.clearDC(Item.ANY,Item.ANY,Item.ANY);
  Enumeration unsortedParamNames=request.getParameterNames();
  List sortedParamNames=new LinkedList();
  while (unsortedParamNames.hasMoreElements()) {
    sortedParamNames.add(unsortedParamNames.nextElement());
  }
  Collections.sort(sortedParamNames);
  Iterator iterator=sortedParamNames.iterator();
  while (iterator.hasNext()) {
    String p=(String)iterator.next();
    if (p.startsWith(""String_Node_Str"")) {
      StringTokenizer st=new StringTokenizer(p,""String_Node_Str"");
      st.nextToken();
      String element=st.nextToken();
      String qualifier=null;
      if (st.countTokens() == 2) {
        qualifier=st.nextToken();
      }
      String sequenceNumber=st.nextToken();
      String key=element;
      if (qualifier != null) {
        key=element + ""String_Node_Str"" + qualifier;
      }
      String language=request.getParameter(""String_Node_Str"" + key + ""String_Node_Str""+ sequenceNumber);
      if (language != null && language.equals(""String_Node_Str"")) {
        language=null;
      }
      String value=request.getParameter(p).trim();
      if (value.equals(""String_Node_Str"") || !button.equals(""String_Node_Str"" + key + ""String_Node_Str""+ sequenceNumber)) {
        item.addDC(element,qualifier,language,value);
      }
    }
 else     if (p.startsWith(""String_Node_Str"")) {
      StringTokenizer st=new StringTokenizer(p,""String_Node_Str"");
      st.nextToken();
      st.nextToken();
      int bundleID=Integer.parseInt(st.nextToken());
      int bitstreamID=Integer.parseInt(st.nextToken());
      Bundle bundle=Bundle.find(context,bundleID);
      Bitstream bitstream=Bitstream.find(context,bitstreamID);
      String key=String.valueOf(bundleID) + ""String_Node_Str"" + bitstreamID;
      if (button.equals(""String_Node_Str"" + key)) {
        bundle.removeBitstream(bitstream);
        if (bundle.getBitstreams().length == 0) {
          item.removeBundle(bundle);
        }
      }
 else {
        String name=request.getParameter(p);
        String source=request.getParameter(""String_Node_Str"" + key);
        String desc=request.getParameter(""String_Node_Str"" + key);
        int formatID=UIUtil.getIntParameter(request,""String_Node_Str"" + key);
        String userFormatDesc=request.getParameter(""String_Node_Str"" + key);
        int primaryBitstreamID=UIUtil.getIntParameter(request,bundleID + ""String_Node_Str"");
        if (source.equals(""String_Node_Str""))         source=null;
        if (desc.equals(""String_Node_Str""))         desc=null;
        if (userFormatDesc.equals(""String_Node_Str""))         userFormatDesc=null;
        bitstream.setName(name);
        bitstream.setSource(source);
        bitstream.setDescription(desc);
        bitstream.setFormat(BitstreamFormat.find(context,formatID));
        if (primaryBitstreamID > 0) {
          bundle.setPrimaryBitstreamID(primaryBitstreamID);
        }
        if (userFormatDesc != null) {
          bitstream.setUserFormatDescription(userFormatDesc);
        }
        bitstream.update();
        bundle.update();
      }
    }
  }
  item.update();
  if (button.equals(""String_Node_Str"")) {
    int dcTypeID=UIUtil.getIntParameter(request,""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"").trim();
    String lang=request.getParameter(""String_Node_Str"");
    if (lang.equals(""String_Node_Str""))     lang=null;
    DCType dcType=DCType.find(context,dcTypeID);
    item.addDC(dcType.getElement(),dcType.getQualifier(),lang,value);
    item.update();
  }
  if (button.equals(""String_Node_Str"")) {
    request.setAttribute(""String_Node_Str"",item);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showEditForm(context,request,response,item);
  }
  context.complete();
}",0.990489776509748
52558,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  int sortBy=EPerson.LASTNAME;
  String sbParam=request.getParameter(""String_Node_Str"");
  if (sbParam != null && sbParam.equals(""String_Node_Str"")) {
    sortBy=EPerson.LASTNAME;
  }
 else   if (sbParam != null && sbParam.equals(""String_Node_Str"")) {
    sortBy=EPerson.EMAIL;
  }
  int first=UIUtil.getIntParameter(request,""String_Node_Str"");
  if (first == -1)   first=0;
  EPerson[] epeople=EPerson.findAll(context,sortBy);
  request.setAttribute(""String_Node_Str"",new Integer(sortBy));
  request.setAttribute(""String_Node_Str"",new Integer(first));
  request.setAttribute(""String_Node_Str"",epeople);
  JSPManager.showJSP(request,response,""String_Node_Str"");
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  int sortBy=EPerson.LASTNAME;
  String sbParam=request.getParameter(""String_Node_Str"");
  if (sbParam != null && sbParam.equals(""String_Node_Str"")) {
    sortBy=EPerson.LASTNAME;
  }
 else   if (sbParam != null && sbParam.equals(""String_Node_Str"")) {
    sortBy=EPerson.EMAIL;
  }
 else   if (sbParam != null && sbParam.equals(""String_Node_Str"")) {
    sortBy=EPerson.ID;
  }
  int first=UIUtil.getIntParameter(request,""String_Node_Str"");
  if (first == -1)   first=0;
  EPerson[] epeople=EPerson.findAll(context,sortBy);
  request.setAttribute(""String_Node_Str"",new Integer(sortBy));
  request.setAttribute(""String_Node_Str"",new Integer(first));
  request.setAttribute(""String_Node_Str"",epeople);
  JSPManager.showJSP(request,response,""String_Node_Str"");
}",0.945992040932348
52559,"/** 
 * Create a workflow group for the given step if one does not already exist. Returns either the newly created group or the previously existing one. Note that while the new group is created in the database, the association between the group and the collection is not written until <code>update</code> is called.
 * @param step  the step (1-3) of the workflow to create or get the groupfor
 * @return  the workflow group associated with this collection
 */
public Group createWorkflowGroup(int step) throws SQLException, AuthorizeException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.WRITE);
  if (workflowGroup[step - 1] == null) {
    workflowGroup[step - 1]=Group.create(ourContext);
    workflowGroup[step - 1].setName(""String_Node_Str"" + getID() + ""String_Node_Str""+ step);
    workflowGroup[step - 1].update();
  }
  return workflowGroup[step - 1];
}","/** 
 * Create a workflow group for the given step if one does not already exist. Returns either the newly created group or the previously existing one. Note that while the new group is created in the database, the association between the group and the collection is not written until <code>update</code> is called.
 * @param step  the step (1-3) of the workflow to create or get the groupfor
 * @return  the workflow group associated with this collection
 */
public Group createWorkflowGroup(int step) throws SQLException, AuthorizeException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.WRITE);
  if (workflowGroup[step - 1] == null) {
    Group g=Group.create(ourContext);
    g.setName(""String_Node_Str"" + getID() + ""String_Node_Str""+ step);
    g.update();
    setWorkflowGroup(step,g);
  }
  return workflowGroup[step - 1];
}",0.9432213209733488
52560,"/** 
 * @param c context
 * @param item item containing bitstream to process
 * @param source source bitstream to process
 * @param boolean owerWrite false means do nothing if a matching filter rendition alreads exists
 * @return true if new rendition is created
 */
public boolean processBitstream(Context c,Item item,Bitstream source,boolean overWrite) throws Exception {
  String newName=getFilteredName(source.getName());
  Bitstream existingBitstream=null;
  Bundle targetBundle=null;
  Bundle[] bundles=item.getBundles(getBundleName());
  if (bundles.length > 0) {
    for (int i=0; i < bundles.length; i++) {
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      for (int j=0; j < bitstreams.length; j++) {
        if (bitstreams[j].getName().equals(newName)) {
          targetBundle=bundles[i];
          existingBitstream=bitstreams[j];
        }
      }
    }
  }
  if (!overWrite && (existingBitstream != null)) {
    System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
    return false;
  }
  if (bundles.length < 1) {
    targetBundle=item.createBundle(getBundleName());
  }
 else {
    targetBundle=bundles[0];
  }
  InputStream destStream=getDestinationStream(source.retrieve());
  Bitstream b=targetBundle.createBitstream(destStream);
  b.setName(newName);
  b.setSource(""String_Node_Str"" + this.getClass().getName());
  b.update();
  BitstreamFormat bf=BitstreamFormat.findByShortDescription(c,getFormatString());
  b.setFormat(bf);
  if (existingBitstream != null) {
    targetBundle.removeBitstream(existingBitstream);
  }
  System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
  return true;
}","/** 
 * @param c context
 * @param item item containing bitstream to process
 * @param source source bitstream to process
 * @param boolean owerWrite false means do nothing if a matching filter rendition alreads exists
 * @return true if new rendition is created
 */
public boolean processBitstream(Context c,Item item,Bitstream source,boolean overWrite) throws Exception {
  String newName=getFilteredName(source.getName());
  Bitstream existingBitstream=null;
  Bundle targetBundle=null;
  Bundle[] bundles=item.getBundles(getBundleName());
  if (bundles.length > 0) {
    for (int i=0; i < bundles.length; i++) {
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      for (int j=0; j < bitstreams.length; j++) {
        if (bitstreams[j].getName().equals(newName)) {
          targetBundle=bundles[i];
          existingBitstream=bitstreams[j];
        }
      }
    }
  }
  if (!overWrite && (existingBitstream != null)) {
    System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
    return false;
  }
  if (bundles.length < 1) {
    targetBundle=item.createBundle(getBundleName());
  }
 else {
    targetBundle=bundles[0];
  }
  InputStream destStream=getDestinationStream(source.retrieve());
  Bitstream b=targetBundle.createBitstream(destStream);
  b.setName(newName);
  b.setSource(""String_Node_Str"" + this.getClass().getName());
  BitstreamFormat bf=BitstreamFormat.findByShortDescription(c,getFormatString());
  b.setFormat(bf);
  b.update();
  if (existingBitstream != null) {
    targetBundle.removeBitstream(existingBitstream);
  }
  System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
  return true;
}",0.9918887601390498
52561,"/** 
 * Do a query, restricted to a community
 * @param querystring
 * @param community
 * @return HashMap results, same as full doQuery, only hits in a Community
 */
public static QueryResults doQuery(Context c,QueryArgs args,Community comm) throws IOException, ParseException {
  String querystring=args.getQuery();
  querystring=checkEmptyQuery(querystring);
  String location=""String_Node_Str"" + (comm.getID());
  String newquery=new String(""String_Node_Str"" + querystring + ""String_Node_Str""+ location+ ""String_Node_Str"");
  args.setQuery(newquery);
  return doQuery(c,args);
}","/** 
 * Do a query, restricted to a community
 * @param querystring
 * @param community
 * @return HashMap results, same as full doQuery, only hits in a Community
 */
public static QueryResults doQuery(Context c,QueryArgs args,Community comm) throws IOException {
  String querystring=args.getQuery();
  querystring=checkEmptyQuery(querystring);
  String location=""String_Node_Str"" + (comm.getID());
  String newquery=new String(""String_Node_Str"" + querystring + ""String_Node_Str""+ location+ ""String_Node_Str"");
  args.setQuery(newquery);
  return doQuery(c,args);
}",0.9860627177700348
52562,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String query=request.getParameter(""String_Node_Str"");
  int start=UIUtil.getIntParameter(request,""String_Node_Str"");
  String advanced=request.getParameter(""String_Node_Str"");
  String fromAdvanced=request.getParameter(""String_Node_Str"");
  String advancedQuery=""String_Node_Str"";
  HashMap queryHash=new HashMap();
  if (start < 0) {
    start=0;
  }
  List itemHandles=new ArrayList();
  List collectionHandles=new ArrayList();
  List communityHandles=new ArrayList();
  Item[] resultsItems;
  Collection[] resultsCollections;
  Community[] resultsCommunities;
  QueryResults qResults=null;
  QueryArgs qArgs=new QueryArgs();
  if (advanced != null) {
    query=qArgs.buildQuery(request);
    advancedQuery=qArgs.buildHTTPQuery(request);
  }
  if (query == null) {
    query=""String_Node_Str"";
  }
  String location=request.getParameter(""String_Node_Str"");
  String newURL;
  if (location != null && !location.equals(""String_Node_Str"")) {
    String url=""String_Node_Str"";
    if (!location.equals(""String_Node_Str"")) {
      url=""String_Node_Str"" + location;
    }
    query=URLEncoder.encode(query);
    if (advancedQuery.length() > 0) {
      query=query + ""String_Node_Str"" + advancedQuery;
    }
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + url + ""String_Node_Str""+ query));
    return;
  }
  String logInfo=""String_Node_Str"";
  Community community=UIUtil.getCommunityLocation(request);
  Collection collection=UIUtil.getCollectionLocation(request);
  qArgs.setQuery(query);
  qArgs.setStart(start);
  try {
    if (collection != null) {
      logInfo=""String_Node_Str"" + collection.getID() + ""String_Node_Str"";
      request.setAttribute(""String_Node_Str"",community);
      request.setAttribute(""String_Node_Str"",collection);
      qResults=DSQuery.doQuery(context,qArgs,collection);
    }
 else     if (community != null) {
      logInfo=""String_Node_Str"" + community.getID() + ""String_Node_Str"";
      request.setAttribute(""String_Node_Str"",community);
      request.setAttribute(""String_Node_Str"",community.getCollections());
      qResults=DSQuery.doQuery(context,qArgs,community);
    }
 else {
      Community[] communities=Community.findAll(context);
      request.setAttribute(""String_Node_Str"",communities);
      qResults=DSQuery.doQuery(context,qArgs);
    }
    for (int i=0; i < qResults.getHitHandles().size(); i++) {
      String myHandle=(String)qResults.getHitHandles().get(i);
      Integer myType=(Integer)qResults.getHitTypes().get(i);
switch (myType.intValue()) {
case Constants.ITEM:
        itemHandles.add(myHandle);
      break;
case Constants.COLLECTION:
    collectionHandles.add(myHandle);
  break;
case Constants.COMMUNITY:
communityHandles.add(myHandle);
break;
}
}
int numCommunities=communityHandles.size();
int numCollections=collectionHandles.size();
int numItems=itemHandles.size();
resultsCommunities=new Community[numCommunities];
resultsCollections=new Collection[numCollections];
resultsItems=new Item[numItems];
for (int i=0; i < numItems; i++) {
String myhandle=(String)itemHandles.get(i);
Object o=HandleManager.resolveToObject(context,myhandle);
resultsItems[i]=(Item)o;
if (resultsItems[i] == null) {
throw new SQLException(""String_Node_Str"" + query + ""String_Node_Str""+ myhandle);
}
}
for (int i=0; i < collectionHandles.size(); i++) {
String myhandle=(String)collectionHandles.get(i);
Object o=HandleManager.resolveToObject(context,myhandle);
resultsCollections[i]=(Collection)o;
if (resultsCollections[i] == null) {
throw new SQLException(""String_Node_Str"" + query + ""String_Node_Str""+ myhandle);
}
}
for (int i=0; i < communityHandles.size(); i++) {
String myhandle=(String)communityHandles.get(i);
Object o=HandleManager.resolveToObject(context,myhandle);
resultsCommunities[i]=(Community)o;
if (resultsCommunities[i] == null) {
throw new SQLException(""String_Node_Str"" + query + ""String_Node_Str""+ myhandle);
}
}
log.info(LogManager.getHeader(context,""String_Node_Str"",logInfo + ""String_Node_Str"" + query+ ""String_Node_Str""+ resultsCommunities.length+ ""String_Node_Str""+ resultsCollections.length+ ""String_Node_Str""+ resultsItems.length+ ""String_Node_Str""));
}
 catch (ParseException pe) {
log.warn(LogManager.getHeader(context,""String_Node_Str"",logInfo + ""String_Node_Str"" + query+ ""String_Node_Str""),pe);
resultsItems=new Item[0];
resultsCommunities=new Community[0];
resultsCollections=new Collection[0];
}
catch (TokenMgrError tme) {
log.warn(LogManager.getHeader(context,""String_Node_Str"",logInfo + ""String_Node_Str"" + query+ ""String_Node_Str""),tme);
resultsItems=new Item[0];
resultsCommunities=new Community[0];
resultsCollections=new Collection[0];
}
int pageTotal=1 + (qResults.getHitCount() - 1) / qResults.getPageSize();
int pageCurrent=1 + (qResults.getStart() / qResults.getPageSize());
int pageLast=(pageCurrent + 9) > pageTotal ? pageTotal : (pageCurrent + 9);
int pageFirst=(pageCurrent - 9) > 1 ? (pageCurrent - 9) : 1;
request.setAttribute(""String_Node_Str"",resultsItems);
request.setAttribute(""String_Node_Str"",resultsCommunities);
request.setAttribute(""String_Node_Str"",resultsCollections);
request.setAttribute(""String_Node_Str"",new Integer(pageTotal));
request.setAttribute(""String_Node_Str"",new Integer(pageCurrent));
request.setAttribute(""String_Node_Str"",new Integer(pageLast));
request.setAttribute(""String_Node_Str"",new Integer(pageFirst));
request.setAttribute(""String_Node_Str"",qResults);
request.setAttribute(""String_Node_Str"",query);
if ((fromAdvanced != null) && (qResults.getHitCount() == 0)) {
Community[] communities=Community.findAll(context);
request.setAttribute(""String_Node_Str"",communities);
request.setAttribute(""String_Node_Str"",""String_Node_Str"");
queryHash=qArgs.buildQueryHash(request);
Iterator i=queryHash.keySet().iterator();
while (i.hasNext()) {
String key=(String)i.next();
String value=(String)queryHash.get(key);
request.setAttribute(key,value);
}
JSPManager.showJSP(request,response,""String_Node_Str"");
}
 else {
JSPManager.showJSP(request,response,""String_Node_Str"");
}
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String query=request.getParameter(""String_Node_Str"");
  int start=UIUtil.getIntParameter(request,""String_Node_Str"");
  String advanced=request.getParameter(""String_Node_Str"");
  String fromAdvanced=request.getParameter(""String_Node_Str"");
  String advancedQuery=""String_Node_Str"";
  HashMap queryHash=new HashMap();
  if (start < 0) {
    start=0;
  }
  List itemHandles=new ArrayList();
  List collectionHandles=new ArrayList();
  List communityHandles=new ArrayList();
  Item[] resultsItems;
  Collection[] resultsCollections;
  Community[] resultsCommunities;
  QueryResults qResults=null;
  QueryArgs qArgs=new QueryArgs();
  if (advanced != null) {
    query=qArgs.buildQuery(request);
    advancedQuery=qArgs.buildHTTPQuery(request);
  }
  if (query == null) {
    query=""String_Node_Str"";
  }
  String location=request.getParameter(""String_Node_Str"");
  String newURL;
  if (location != null && !location.equals(""String_Node_Str"")) {
    String url=""String_Node_Str"";
    if (!location.equals(""String_Node_Str"")) {
      url=""String_Node_Str"" + location;
    }
    query=URLEncoder.encode(query);
    if (advancedQuery.length() > 0) {
      query=query + ""String_Node_Str"" + advancedQuery;
    }
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + url + ""String_Node_Str""+ query));
    return;
  }
  String logInfo=""String_Node_Str"";
  Community community=UIUtil.getCommunityLocation(request);
  Collection collection=UIUtil.getCollectionLocation(request);
  qArgs.setQuery(query);
  qArgs.setStart(start);
  if (collection != null) {
    logInfo=""String_Node_Str"" + collection.getID() + ""String_Node_Str"";
    request.setAttribute(""String_Node_Str"",community);
    request.setAttribute(""String_Node_Str"",collection);
    qResults=DSQuery.doQuery(context,qArgs,collection);
  }
 else   if (community != null) {
    logInfo=""String_Node_Str"" + community.getID() + ""String_Node_Str"";
    request.setAttribute(""String_Node_Str"",community);
    request.setAttribute(""String_Node_Str"",community.getCollections());
    qResults=DSQuery.doQuery(context,qArgs,community);
  }
 else {
    Community[] communities=Community.findAll(context);
    request.setAttribute(""String_Node_Str"",communities);
    qResults=DSQuery.doQuery(context,qArgs);
  }
  for (int i=0; i < qResults.getHitHandles().size(); i++) {
    String myHandle=(String)qResults.getHitHandles().get(i);
    Integer myType=(Integer)qResults.getHitTypes().get(i);
switch (myType.intValue()) {
case Constants.ITEM:
      itemHandles.add(myHandle);
    break;
case Constants.COLLECTION:
  collectionHandles.add(myHandle);
break;
case Constants.COMMUNITY:
communityHandles.add(myHandle);
break;
}
}
int numCommunities=communityHandles.size();
int numCollections=collectionHandles.size();
int numItems=itemHandles.size();
resultsCommunities=new Community[numCommunities];
resultsCollections=new Collection[numCollections];
resultsItems=new Item[numItems];
for (int i=0; i < numItems; i++) {
String myhandle=(String)itemHandles.get(i);
Object o=HandleManager.resolveToObject(context,myhandle);
resultsItems[i]=(Item)o;
if (resultsItems[i] == null) {
throw new SQLException(""String_Node_Str"" + query + ""String_Node_Str""+ myhandle);
}
}
for (int i=0; i < collectionHandles.size(); i++) {
String myhandle=(String)collectionHandles.get(i);
Object o=HandleManager.resolveToObject(context,myhandle);
resultsCollections[i]=(Collection)o;
if (resultsCollections[i] == null) {
throw new SQLException(""String_Node_Str"" + query + ""String_Node_Str""+ myhandle);
}
}
for (int i=0; i < communityHandles.size(); i++) {
String myhandle=(String)communityHandles.get(i);
Object o=HandleManager.resolveToObject(context,myhandle);
resultsCommunities[i]=(Community)o;
if (resultsCommunities[i] == null) {
throw new SQLException(""String_Node_Str"" + query + ""String_Node_Str""+ myhandle);
}
}
log.info(LogManager.getHeader(context,""String_Node_Str"",logInfo + ""String_Node_Str"" + query+ ""String_Node_Str""+ resultsCommunities.length+ ""String_Node_Str""+ resultsCollections.length+ ""String_Node_Str""+ resultsItems.length+ ""String_Node_Str""));
int pageTotal=1 + (qResults.getHitCount() - 1) / qResults.getPageSize();
int pageCurrent=1 + (qResults.getStart() / qResults.getPageSize());
int pageLast=(pageCurrent + 9) > pageTotal ? pageTotal : (pageCurrent + 9);
int pageFirst=(pageCurrent - 9) > 1 ? (pageCurrent - 9) : 1;
request.setAttribute(""String_Node_Str"",resultsItems);
request.setAttribute(""String_Node_Str"",resultsCommunities);
request.setAttribute(""String_Node_Str"",resultsCollections);
request.setAttribute(""String_Node_Str"",new Integer(pageTotal));
request.setAttribute(""String_Node_Str"",new Integer(pageCurrent));
request.setAttribute(""String_Node_Str"",new Integer(pageLast));
request.setAttribute(""String_Node_Str"",new Integer(pageFirst));
request.setAttribute(""String_Node_Str"",qResults);
request.setAttribute(""String_Node_Str"",query);
if ((fromAdvanced != null) && (qResults.getHitCount() == 0)) {
Community[] communities=Community.findAll(context);
request.setAttribute(""String_Node_Str"",communities);
request.setAttribute(""String_Node_Str"",""String_Node_Str"");
queryHash=qArgs.buildQueryHash(request);
Iterator i=queryHash.keySet().iterator();
while (i.hasNext()) {
String key=(String)i.next();
String value=(String)queryHash.get(key);
request.setAttribute(key,value);
}
JSPManager.showJSP(request,response,""String_Node_Str"");
}
 else {
JSPManager.showJSP(request,response,""String_Node_Str"");
}
}",0.9492729117348664
52563,"/** 
 * Format SQL according to the browse type.
 */
private static String formatSql(BrowseScope scope,String sql,String subqueryValue,boolean after){
  boolean before=!after;
  int browseType=scope.getBrowseType();
  boolean ascending=scope.getAscending();
  int numberDesired=before ? scope.getNumberBefore() : scope.getTotal();
  String beforeOperator=""String_Node_Str"";
  String afterOperator=""String_Node_Str"";
  if (browseType == ITEMS_BY_AUTHOR_BROWSE)   afterOperator=""String_Node_Str"";
  if (subqueryValue != null) {
    beforeOperator=""String_Node_Str"";
    afterOperator=""String_Node_Str"";
  }
  if (!ascending) {
    beforeOperator=""String_Node_Str"";
    afterOperator=""String_Node_Str"";
  }
  String beforeSubqueryOperator=""String_Node_Str"";
  String afterSubqueryOperator=""String_Node_Str"";
  if (browseType == ITEMS_BY_AUTHOR_BROWSE)   afterSubqueryOperator=""String_Node_Str"";
  if (!ascending) {
    beforeSubqueryOperator=""String_Node_Str"";
    afterSubqueryOperator=""String_Node_Str"";
  }
  String order=before ? ""String_Node_Str"" : ""String_Node_Str"";
  if (!ascending)   order=before ? ""String_Node_Str"" : ""String_Node_Str"";
  List args=new ArrayList();
  args.add(before ? beforeSubqueryOperator : afterSubqueryOperator);
  args.add(before ? beforeOperator : afterOperator);
  args.add(order);
  args.add(new Integer(numberDesired));
  return MessageFormat.format(sql,args.toArray());
}","/** 
 * Format SQL according to the browse type.
 */
private static String formatSql(BrowseScope scope,String sql,String subqueryValue,boolean after){
  boolean before=!after;
  int browseType=scope.getBrowseType();
  boolean ascending=scope.getAscending();
  int numberDesired=before ? scope.getNumberBefore() : scope.getTotal();
  String beforeOperator=""String_Node_Str"";
  String afterOperator=""String_Node_Str"";
  if (browseType == ITEMS_BY_AUTHOR_BROWSE)   afterOperator=""String_Node_Str"";
  if (subqueryValue != null) {
    beforeOperator=""String_Node_Str"";
    afterOperator=""String_Node_Str"";
  }
  if (!ascending) {
    beforeOperator=""String_Node_Str"";
    afterOperator=""String_Node_Str"";
  }
  if (browseType == ITEMS_BY_DATE_BROWSE) {
    if (!ascending) {
      beforeOperator=""String_Node_Str"";
      afterOperator=""String_Node_Str"";
    }
 else {
      beforeOperator=""String_Node_Str"";
      afterOperator=""String_Node_Str"";
    }
  }
  String beforeSubqueryOperator=""String_Node_Str"";
  String afterSubqueryOperator=""String_Node_Str"";
  if (browseType == ITEMS_BY_AUTHOR_BROWSE)   afterSubqueryOperator=""String_Node_Str"";
  if (!ascending) {
    beforeSubqueryOperator=""String_Node_Str"";
    afterSubqueryOperator=""String_Node_Str"";
  }
  String order=before ? ""String_Node_Str"" : ""String_Node_Str"";
  if (!ascending)   order=before ? ""String_Node_Str"" : ""String_Node_Str"";
  List args=new ArrayList();
  args.add(before ? beforeSubqueryOperator : afterSubqueryOperator);
  args.add(before ? beforeOperator : afterOperator);
  args.add(order);
  args.add(new Integer(numberDesired));
  return MessageFormat.format(sql,args.toArray());
}",0.8529411764705882
52564,"/** 
 * Create a SQL string to run the correct query.
 */
private static String createSqlInternal(BrowseScope scope,String itemValue,boolean isCount) throws SQLException {
  String tablename=BrowseTables.getTable(scope);
  String column=BrowseTables.getValueColumn(scope);
  int browseType=scope.getBrowseType();
  StringBuffer sqlb=new StringBuffer();
  sqlb.append(""String_Node_Str"");
  sqlb.append(isCount ? ""String_Node_Str"" : ""String_Node_Str"");
  sqlb.append(getTargetColumns(scope));
  sqlb.append(isCount ? ""String_Node_Str"" : ""String_Node_Str"");
  if (browseType == AUTHORS_BROWSE && !isCount) {
    sqlb.append(""String_Node_Str"");
  }
  sqlb.append(""String_Node_Str"");
  sqlb.append(tablename);
  boolean addedWhereClause=false;
  if (scope.hasFocus()) {
    String subquery=null;
    if (scope.focusIsItem())     subquery=new StringBuffer().append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(scope.getFocusItemId()).append(""String_Node_Str"").toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + subquery + ""String_Node_Str"");
    sqlb.append(""String_Node_Str"").append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(""String_Node_Str"").append(scope.focusIsItem() ? subquery : ""String_Node_Str"").append(""String_Node_Str"");
    addedWhereClause=true;
  }
  String connector=addedWhereClause ? ""String_Node_Str"" : ""String_Node_Str"";
  sqlb.append(getScopeClause(scope,connector));
  if (isCount)   return sqlb.toString();
  sqlb.append(""String_Node_Str"").append(column).append(""String_Node_Str"").append((scope.focusIsString() || (scope.getBrowseType() == AUTHORS_BROWSE)) ? ""String_Node_Str"" : ""String_Node_Str"");
  if (!scope.hasNoLimit())   sqlb.append(""String_Node_Str"");
  return sqlb.toString();
}","/** 
 * Create a SQL string to run the correct query.
 */
private static String createSqlInternal(BrowseScope scope,String itemValue,boolean isCount) throws SQLException {
  String tablename=BrowseTables.getTable(scope);
  String column=BrowseTables.getValueColumn(scope);
  int browseType=scope.getBrowseType();
  StringBuffer sqlb=new StringBuffer();
  sqlb.append(""String_Node_Str"");
  sqlb.append(isCount ? ""String_Node_Str"" : ""String_Node_Str"");
  sqlb.append(getTargetColumns(scope));
  sqlb.append(isCount ? ""String_Node_Str"" : ""String_Node_Str"");
  if (browseType == AUTHORS_BROWSE && !isCount) {
    sqlb.append(""String_Node_Str"");
  }
  sqlb.append(""String_Node_Str"");
  sqlb.append(tablename);
  boolean addedWhereClause=false;
  if (scope.hasFocus()) {
    String subquery=null;
    if (scope.focusIsItem())     subquery=new StringBuffer().append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(scope.getFocusItemId()).append(""String_Node_Str"").toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + subquery + ""String_Node_Str"");
    sqlb.append(""String_Node_Str"").append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(""String_Node_Str"").append(scope.focusIsItem() ? subquery : ""String_Node_Str"").append(""String_Node_Str"");
    addedWhereClause=true;
  }
  String connector=addedWhereClause ? ""String_Node_Str"" : ""String_Node_Str"";
  sqlb.append(getScopeClause(scope,connector));
  if (isCount)   return sqlb.toString();
  sqlb.append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(((scope.focusIsString() && (scope.getBrowseType() != ITEMS_BY_DATE_BROWSE)) || (scope.getBrowseType() == AUTHORS_BROWSE)) ? ""String_Node_Str"" : ""String_Node_Str"");
  if (!scope.hasNoLimit())   sqlb.append(""String_Node_Str"");
  return sqlb.toString();
}",0.9852818661482922
52565,"/** 
 * Construct an item with the given table row
 * @param context  the context this object exists in
 * @param row      the corresponding row in the table
 */
Item(Context context,TableRow row) throws SQLException {
  ourContext=context;
  itemRow=row;
  dublinCoreChanged=false;
  dublinCore=new ArrayList();
  bundles=new ArrayList();
  submitter=null;
  if (!itemRow.isColumnNull(""String_Node_Str"")) {
    submitter=EPerson.find(ourContext,itemRow.getIntColumn(""String_Node_Str""));
  }
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow r=(TableRow)tri.next();
    Bundle fromCache=(Bundle)context.fromCache(Bundle.class,r.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      bundles.add(fromCache);
    }
 else {
      bundles.add(new Bundle(ourContext,r));
    }
  }
  tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow resultRow=(TableRow)tri.next();
    String[] dcType=DCType.quickFind(context,resultRow.getIntColumn(""String_Node_Str""));
    DCValue dcv=new DCValue();
    dcv.element=dcType[0];
    dcv.qualifier=dcType[1];
    dcv.value=resultRow.getStringColumn(""String_Node_Str"");
    dcv.language=resultRow.getStringColumn(""String_Node_Str"");
    dublinCore.add(dcv);
  }
  handle=HandleManager.findHandle(context,this);
  context.cache(this,row.getIntColumn(""String_Node_Str""));
}","/** 
 * Construct an item with the given table row
 * @param context  the context this object exists in
 * @param row      the corresponding row in the table
 */
Item(Context context,TableRow row) throws SQLException {
  ourContext=context;
  itemRow=row;
  dublinCoreChanged=false;
  dublinCore=new ArrayList();
  bundles=new ArrayList();
  submitter=null;
  if (!itemRow.isColumnNull(""String_Node_Str"")) {
    submitter=EPerson.find(ourContext,itemRow.getIntColumn(""String_Node_Str""));
  }
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow r=(TableRow)tri.next();
    Bundle fromCache=(Bundle)context.fromCache(Bundle.class,r.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      bundles.add(fromCache);
    }
 else {
      bundles.add(new Bundle(ourContext,r));
    }
  }
  tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow resultRow=(TableRow)tri.next();
    String[] dcType=DCType.quickFind(context,resultRow.getIntColumn(""String_Node_Str""));
    DCValue dcv=new DCValue();
    dcv.element=dcType[0];
    dcv.qualifier=dcType[1];
    dcv.value=resultRow.getStringColumn(""String_Node_Str"");
    dcv.language=resultRow.getStringColumn(""String_Node_Str"");
    dublinCore.add(dcv);
  }
  itemRow.setColumn(""String_Node_Str"",new Date());
  handle=HandleManager.findHandle(context,this);
  context.cache(this,row.getIntColumn(""String_Node_Str""));
}",0.9845220030349012
52566,"static String stripAsterisk(String myquery){
  Perl5Util util=new Perl5Util();
  myquery=util.substitute(""String_Node_Str"",myquery);
  myquery=util.substitute(""String_Node_Str"",myquery);
  return myquery;
}","static String stripAsterisk(String myquery){
  Perl5Util util=new Perl5Util();
  myquery=util.substitute(""String_Node_Str"",myquery);
  myquery=util.substitute(""String_Node_Str"",myquery);
  myquery=util.substitute(""String_Node_Str"",myquery);
  myquery=util.substitute(""String_Node_Str"",myquery);
  return myquery;
}",0.7923076923076923
52567,"/** 
 * Command line interface to setPolicies - run to see arguments
 */
public static void main(String[] argv) throws Exception {
  Context c=new Context();
  c.setIgnoreAuthorization(true);
  Collection[] collections=Collection.findAll(c);
  for (int i=0; i < collections.length; i++) {
    Collection t=collections[i];
    System.out.println(""String_Node_Str"" + t + ""String_Node_Str""+ t.getMetadata(""String_Node_Str""));
    if (checkForPolicy(c,t,Constants.READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.READ);
    }
    if (checkForPolicy(c,t,Constants.DEFAULT_ITEM_READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.DEFAULT_ITEM_READ);
    }
    if (checkForPolicy(c,t,Constants.DEFAULT_BITSTREAM_READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.DEFAULT_BITSTREAM_READ);
    }
  }
  Community[] communities=Community.findAll(c);
  for (int i=0; i < collections.length; i++) {
    Community t=communities[i];
    System.out.println(""String_Node_Str"" + t + ""String_Node_Str""+ t.getMetadata(""String_Node_Str""));
    if (checkForPolicy(c,t,Constants.READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.READ);
    }
  }
  c.complete();
}","/** 
 * Command line interface to setPolicies - run to see arguments
 */
public static void main(String[] argv) throws Exception {
  Context c=new Context();
  c.setIgnoreAuthorization(true);
  Collection[] collections=Collection.findAll(c);
  for (int i=0; i < collections.length; i++) {
    Collection t=collections[i];
    System.out.println(""String_Node_Str"" + t + ""String_Node_Str""+ t.getMetadata(""String_Node_Str""));
    if (checkForPolicy(c,t,Constants.READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.READ);
    }
    if (checkForPolicy(c,t,Constants.DEFAULT_ITEM_READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.DEFAULT_ITEM_READ);
    }
    if (checkForPolicy(c,t,Constants.DEFAULT_BITSTREAM_READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.DEFAULT_BITSTREAM_READ);
    }
  }
  Community[] communities=Community.findAll(c);
  for (int i=0; i < communities.length; i++) {
    Community t=communities[i];
    System.out.println(""String_Node_Str"" + t + ""String_Node_Str""+ t.getMetadata(""String_Node_Str""));
    if (checkForPolicy(c,t,Constants.READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.READ);
    }
  }
  c.complete();
}",0.9948253557567918
52568,"/** 
 * Reinstate a withdrawn item
 */
public void reinstate() throws SQLException, AuthorizeException, IOException {
  String timestamp=DCDate.getCurrent().toString();
  String collectionProv=""String_Node_Str"";
  Collection[] colls=getCollections();
  for (int i=0; i < colls.length; i++) {
    collectionProv=collectionProv + colls[i].getMetadata(""String_Node_Str"") + ""String_Node_Str""+ colls[i].getID()+ ""String_Node_Str"";
    AuthorizeManager.authorizeAction(ourContext,colls[i],Constants.ADD);
  }
  itemRow.setColumn(""String_Node_Str"",false);
  itemRow.setColumn(""String_Node_Str"",true);
  EPerson e=ourContext.getCurrentUser();
  String prov=""String_Node_Str"" + e.getFullName() + ""String_Node_Str""+ e.getEmail()+ ""String_Node_Str""+ timestamp+ ""String_Node_Str""+ ""String_Node_Str""+ collectionProv+ InstallItem.getBitstreamProvenanceMessage(this);
  addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",prov);
  update();
  HistoryManager.saveHistory(ourContext,this,HistoryManager.MODIFY,e,ourContext.getExtraLogInfo());
  Browse.itemAdded(ourContext,this);
  DSIndexer.indexContent(ourContext,this);
  if (colls.length > 0) {
    inheritCollectionDefaultPolicies(colls[0]);
  }
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + e.getEmail() + ""String_Node_Str""+ getID()));
}","/** 
 * Reinstate a withdrawn item
 */
public void reinstate() throws SQLException, AuthorizeException, IOException {
  String timestamp=DCDate.getCurrent().toString();
  String collectionProv=""String_Node_Str"";
  Collection[] colls=getCollections();
  for (int i=0; i < colls.length; i++) {
    collectionProv=collectionProv + colls[i].getMetadata(""String_Node_Str"") + ""String_Node_Str""+ colls[i].getID()+ ""String_Node_Str"";
    AuthorizeManager.authorizeAction(ourContext,colls[i],Constants.ADD);
  }
  itemRow.setColumn(""String_Node_Str"",false);
  itemRow.setColumn(""String_Node_Str"",true);
  EPerson e=ourContext.getCurrentUser();
  String prov=""String_Node_Str"" + e.getFullName() + ""String_Node_Str""+ e.getEmail()+ ""String_Node_Str""+ timestamp+ ""String_Node_Str""+ ""String_Node_Str""+ collectionProv+ InstallItem.getBitstreamProvenanceMessage(this);
  addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",prov);
  update();
  HistoryManager.saveHistory(ourContext,this,HistoryManager.MODIFY,e,ourContext.getExtraLogInfo());
  DSIndexer.indexContent(ourContext,this);
  if (colls.length > 0) {
    inheritCollectionDefaultPolicies(colls[0]);
  }
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + e.getEmail() + ""String_Node_Str""+ getID()));
}",0.9857747020376778
52569,"/** 
 * Create a new item, with a new internal ID.  This method is not public, since items need to be created as workspace items.  Authorisation is the responsibility of the caller.
 * @param context  DSpace context object
 * @return  the newly created item
 */
static Item create(Context context) throws SQLException {
  TableRow row=DatabaseManager.create(context,""String_Node_Str"");
  Item i=new Item(context,row);
  HistoryManager.saveHistory(context,i,HistoryManager.CREATE,context.getCurrentUser(),context.getExtraLogInfo());
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + row.getIntColumn(""String_Node_Str"")));
  return i;
}","/** 
 * Create a new item, with a new internal ID.  This method is not public, since items need to be created as workspace items.  Authorisation is the responsibility of the caller.
 * @param context  DSpace context object
 * @return  the newly created item
 */
static Item create(Context context) throws SQLException, AuthorizeException {
  TableRow row=DatabaseManager.create(context,""String_Node_Str"");
  Item i=new Item(context,row);
  i.update();
  HistoryManager.saveHistory(context,i,HistoryManager.CREATE,context.getCurrentUser(),context.getExtraLogInfo());
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + row.getIntColumn(""String_Node_Str"")));
  return i;
}",0.974963181148748
52570,"protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.create(context);
    e.setEmail(""String_Node_Str"" + e.getID());
    e.update();
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    String oldEmail=e.getEmail();
    String newEmail=request.getParameter(""String_Node_Str"").trim();
    if (!newEmail.equals(oldEmail)) {
      if (EPerson.findByEmail(context,newEmail) == null) {
        e.setEmail(newEmail);
        e.setFirstName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setLastName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setCanLogIn(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.setRequireCertificate(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.update();
        showMain(context,request,response);
        context.complete();
      }
 else {
        request.setAttribute(""String_Node_Str"",e);
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        JSPManager.showJSP(request,response,""String_Node_Str"");
        context.complete();
      }
    }
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    e.delete();
    showMain(context,request,response);
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    String pageRequest=request.getParameter(""String_Node_Str"");
    int pageIndex=UIUtil.getIntParameter(request,""String_Node_Str"");
    String sortby=request.getParameter(""String_Node_Str"");
    int sortField=EPerson.EMAIL;
    int pageSize=50;
    if (sortby == null) {
    }
 else     if (sortby.equals(""String_Node_Str"")) {
      sortField=EPerson.LASTNAME;
    }
 else     if (sortby.equals(""String_Node_Str"")) {
      sortField=EPerson.ID;
    }
    if (pageIndex == -1) {
      pageIndex=0;
    }
    if (pageRequest != null) {
      if (pageRequest.equals(""String_Node_Str"")) {
        pageIndex++;
      }
 else {
        pageIndex--;
      }
    }
    EPerson[] epeople=EPerson.findAll(context,sortField);
    int pageCount=((epeople.length - 1) / pageSize) + 1;
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",new Integer(pageSize));
    request.setAttribute(""String_Node_Str"",new Integer(pageCount));
    request.setAttribute(""String_Node_Str"",new Integer(pageIndex));
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showMain(context,request,response);
  }
}","protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.create(context);
    e.setEmail(""String_Node_Str"" + e.getID());
    e.update();
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    String oldEmail=e.getEmail();
    String newEmail=request.getParameter(""String_Node_Str"").trim();
    if (!newEmail.equals(oldEmail)) {
      if (EPerson.findByEmail(context,newEmail) == null) {
        e.setEmail(newEmail);
        e.setFirstName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setLastName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setCanLogIn(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.setRequireCertificate(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.update();
        showMain(context,request,response);
        context.complete();
      }
 else {
        request.setAttribute(""String_Node_Str"",e);
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        JSPManager.showJSP(request,response,""String_Node_Str"");
        context.complete();
      }
    }
 else {
      e.setFirstName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setLastName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setCanLogIn(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
      e.setRequireCertificate(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
      e.update();
      showMain(context,request,response);
      context.complete();
    }
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    e.delete();
    showMain(context,request,response);
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    String pageRequest=request.getParameter(""String_Node_Str"");
    int pageIndex=UIUtil.getIntParameter(request,""String_Node_Str"");
    String sortby=request.getParameter(""String_Node_Str"");
    int sortField=EPerson.EMAIL;
    int pageSize=50;
    if (sortby == null) {
    }
 else     if (sortby.equals(""String_Node_Str"")) {
      sortField=EPerson.LASTNAME;
    }
 else     if (sortby.equals(""String_Node_Str"")) {
      sortField=EPerson.ID;
    }
    if (pageIndex == -1) {
      pageIndex=0;
    }
    if (pageRequest != null) {
      if (pageRequest.equals(""String_Node_Str"")) {
        pageIndex++;
      }
 else {
        pageIndex--;
      }
    }
    EPerson[] epeople=EPerson.findAll(context,sortField);
    int pageCount=((epeople.length - 1) / pageSize) + 1;
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",new Integer(pageSize));
    request.setAttribute(""String_Node_Str"",new Integer(pageCount));
    request.setAttribute(""String_Node_Str"",new Integer(pageIndex));
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showMain(context,request,response);
  }
}",0.9044838860345632
52571,"public String buildQuery(HttpServletRequest request){
  String newquery=""String_Node_Str"";
  String query1=request.getParameter(""String_Node_Str"");
  String query2=request.getParameter(""String_Node_Str"");
  String query3=request.getParameter(""String_Node_Str"");
  String field1=request.getParameter(""String_Node_Str"");
  String field2=request.getParameter(""String_Node_Str"");
  String field3=request.getParameter(""String_Node_Str"");
  String conjunction1=request.getParameter(""String_Node_Str"");
  String conjunction2=request.getParameter(""String_Node_Str"");
  if (query1.length() > 0) {
    if (!field1.equals(""String_Node_Str"")) {
      newquery=newquery + field1 + ""String_Node_Str"";
    }
    newquery=newquery + '""' + query1+ '""';
  }
  if (query2.length() > 0) {
    newquery=newquery + ""String_Node_Str"" + conjunction1+ ""String_Node_Str"";
    if (!field2.equals(""String_Node_Str"")) {
      newquery=newquery + field2 + ""String_Node_Str"";
    }
    newquery=newquery + '""' + query2+ '""';
  }
  newquery=newquery + ""String_Node_Str"";
  if (query3.length() > 0) {
    newquery=newquery + ""String_Node_Str"" + conjunction2+ ""String_Node_Str"";
    if (!field3.equals(""String_Node_Str"")) {
      newquery=newquery + field3 + ""String_Node_Str"";
    }
    newquery=newquery + ""String_Node_Str"" + query3+ ""String_Node_Str"";
  }
  return (newquery);
}","public String buildQuery(HttpServletRequest request){
  String newquery=""String_Node_Str"";
  String query1=request.getParameter(""String_Node_Str"");
  String query2=request.getParameter(""String_Node_Str"");
  String query3=request.getParameter(""String_Node_Str"");
  String field1=request.getParameter(""String_Node_Str"");
  String field2=request.getParameter(""String_Node_Str"");
  String field3=request.getParameter(""String_Node_Str"");
  String conjunction1=request.getParameter(""String_Node_Str"");
  String conjunction2=request.getParameter(""String_Node_Str"");
  if (query1.length() > 0) {
    newquery=newquery + buildQueryPart(query1,field1);
  }
  if (query2.length() > 0) {
    newquery=newquery + ""String_Node_Str"" + conjunction1+ ""String_Node_Str"";
    newquery=newquery + buildQueryPart(query2,field2);
  }
  newquery=newquery + ""String_Node_Str"";
  if (query3.length() > 0) {
    newquery=newquery + ""String_Node_Str"" + conjunction2+ ""String_Node_Str"";
    newquery=newquery + buildQueryPart(query3,field3);
  }
  return (newquery);
}",0.611646418098031
52572,"/** 
 * Delete the collection, including the metadata and logo.  Items that are then orphans are deleted. Groups associated with this collection (workflow participants and submitters) are NOT deleted.
 */
void delete() throws SQLException, AuthorizeException, IOException {
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
  DSIndexer.unIndexContent(ourContext,this);
  ourContext.removeCached(this,getID());
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  ItemIterator items=getItems();
  while (items.hasNext()) {
    removeItem(items.next());
  }
  setLogo(null);
  DatabaseManager.delete(ourContext,collectionRow);
  AuthorizeManager.removeAllPolicies(ourContext,this);
  Group g=null;
  g=getWorkflowGroup(1);
  if (g != null) {
    g.delete();
  }
  g=getWorkflowGroup(2);
  if (g != null) {
    g.delete();
  }
  g=getWorkflowGroup(3);
  if (g != null) {
    g.delete();
  }
}","/** 
 * Delete the collection, including the metadata and logo.  Items that are then orphans are deleted. Groups associated with this collection (workflow participants and submitters) are NOT deleted.
 */
void delete() throws SQLException, AuthorizeException, IOException {
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
  DSIndexer.unIndexContent(ourContext,this);
  ourContext.removeCached(this,getID());
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  ItemIterator items=getItems();
  while (items.hasNext()) {
    removeItem(items.next());
  }
  setLogo(null);
  AuthorizeManager.removeAllPolicies(ourContext,this);
  WorkflowItem[] wfarray=WorkflowItem.findByCollection(ourContext,this);
  for (int x=0; x < wfarray.length; x++) {
    Item myItem=wfarray[x].getItem();
    wfarray[x].deleteWrapper();
    myItem.delete();
  }
  WorkspaceItem[] wsarray=WorkspaceItem.findByCollection(ourContext,this);
  for (int x=0; x < wsarray.length; x++) {
    wsarray[x].deleteAll();
  }
  DatabaseManager.delete(ourContext,collectionRow);
  Group g=null;
  g=getWorkflowGroup(1);
  if (g != null) {
    g.delete();
  }
  g=getWorkflowGroup(2);
  if (g != null) {
    g.delete();
  }
  g=getWorkflowGroup(3);
  if (g != null) {
    g.delete();
  }
}",0.8015170670037927
52573,"/** 
 * delete the WorkflowItem, retaining the Item
 */
public void deleteWrapper() throws SQLException, IOException, AuthorizeException {
  ourContext.removeCached(this,getID());
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  DatabaseManager.delete(ourContext,wfRow);
}","/** 
 * delete the WorkflowItem, retaining the Item
 */
public void deleteWrapper() throws SQLException, IOException, AuthorizeException {
  ourContext.removeCached(this,getID());
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  WorkflowManager.deleteTasks(ourContext,this);
  DatabaseManager.delete(ourContext,wfRow);
}",0.936
52574,"private static void deleteTasks(Context c,WorkflowItem wi) throws SQLException {
  String myrequest=""String_Node_Str"" + wi.getID();
  DatabaseManager.updateQuery(c,myrequest);
}","static void deleteTasks(Context c,WorkflowItem wi) throws SQLException {
  String myrequest=""String_Node_Str"" + wi.getID();
  DatabaseManager.updateQuery(c,myrequest);
}",0.976878612716763
52575,"private void replaceItems(Context c,Collection mycollection,String sourceDir,String mapFile) throws Exception {
  HashMap myhash=readMapFile(mapFile);
  Iterator i=myhash.keySet().iterator();
  ArrayList itemsToDelete=new ArrayList();
  while (i.hasNext()) {
    String newItemName=(String)i.next();
    String oldHandle=(String)myhash.get(newItemName);
    System.out.println(""String_Node_Str"" + oldHandle);
    Item oldItem=(Item)HandleManager.resolveToObject(c,oldHandle);
    Item newItem=addItem(c,mycollection,sourceDir,newItemName,null);
    String newHandle=HandleManager.findHandle(c,newItem);
    String myquery=""String_Node_Str"" + Constants.ITEM + ""String_Node_Str""+ newItem.getID();
    DatabaseManager.updateQuery(c,myquery);
    myquery=""String_Node_Str"" + newItem.getID() + ""String_Node_Str""+ oldHandle+ ""String_Node_Str"";
    DatabaseManager.updateQuery(c,myquery);
    itemsToDelete.add(oldItem);
  }
  i=itemsToDelete.iterator();
  while (i.hasNext()) {
    removeItem(c,(Item)i.next());
  }
}","private void replaceItems(Context c,Collection mycollection,String sourceDir,String mapFile) throws Exception {
  HashMap myhash=readMapFile(mapFile);
  Iterator i=myhash.keySet().iterator();
  ArrayList itemsToDelete=new ArrayList();
  while (i.hasNext()) {
    String newItemName=(String)i.next();
    String oldHandle=(String)myhash.get(newItemName);
    System.out.println(""String_Node_Str"" + oldHandle);
    Item oldItem=(Item)HandleManager.resolveToObject(c,oldHandle);
    Item newItem=addItem(c,mycollection,sourceDir,newItemName,oldHandle,null);
    itemsToDelete.add(oldItem);
  }
  i=itemsToDelete.iterator();
  while (i.hasNext()) {
    removeItem(c,(Item)i.next());
  }
}",0.6584070796460177
52576,"private Item addItem(Context c,Collection mycollection,String path,String itemname,PrintWriter mapOut) throws Exception {
  Item myitem=null;
  System.out.println(""String_Node_Str"" + itemname);
  WorkspaceItem wi=WorkspaceItem.create(c,mycollection,false);
  myitem=wi.getItem();
  loadDublinCore(c,myitem,path + ""String_Node_Str"" + itemname+ ""String_Node_Str""+ ""String_Node_Str"");
  processContentsFile(c,myitem,path + ""String_Node_Str"" + itemname,""String_Node_Str"");
  String myhandle=processHandleFile(c,myitem,path + ""String_Node_Str"" + itemname,""String_Node_Str"");
  InstallItem.installItem(c,wi,myhandle);
  myhandle=HandleManager.findHandle(c,myitem);
  if (mapOut != null) {
    mapOut.println(itemname + ""String_Node_Str"" + myhandle);
  }
  return myitem;
}","/** 
 * item?  try and add it to the archive c mycollection path itemname  handle - non-null means we have a pre-defined handle already mapOut - mapfile we're writing
 */
private Item addItem(Context c,Collection mycollection,String path,String itemname,String handle,PrintWriter mapOut) throws Exception {
  Item myitem=null;
  System.out.println(""String_Node_Str"" + itemname);
  WorkspaceItem wi=WorkspaceItem.create(c,mycollection,false);
  myitem=wi.getItem();
  loadDublinCore(c,myitem,path + ""String_Node_Str"" + itemname+ ""String_Node_Str""+ ""String_Node_Str"");
  processContentsFile(c,myitem,path + ""String_Node_Str"" + itemname,""String_Node_Str"");
  String myhandle=processHandleFile(c,myitem,path + ""String_Node_Str"" + itemname,""String_Node_Str"");
  InstallItem.installItem(c,wi,myhandle);
  myhandle=HandleManager.findHandle(c,myitem);
  if (mapOut != null) {
    mapOut.println(itemname + ""String_Node_Str"" + myhandle);
  }
  return myitem;
}",0.8899242865463017
52577,"private void addDCValue(Item i,Node n) throws TransformerException {
  String value=getStringValue(n);
  String element=getAttributeValue(n,""String_Node_Str"");
  String qualifier=getAttributeValue(n,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + element + ""String_Node_Str""+ qualifier+ ""String_Node_Str""+ value);
  if (qualifier.equals(""String_Node_Str""))   qualifier=null;
  i.addDC(element,qualifier,""String_Node_Str"",value);
}","private void addDCValue(Item i,Node n) throws TransformerException {
  String value=getStringValue(n);
  String element=getAttributeValue(n,""String_Node_Str"");
  String qualifier=getAttributeValue(n,""String_Node_Str"");
  String language=getAttributeValue(n,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + element + ""String_Node_Str""+ qualifier+ ""String_Node_Str""+ value);
  if (qualifier.equals(""String_Node_Str""))   qualifier=null;
  if (language.equals(""String_Node_Str"")) {
    language=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (language == null) {
    language=""String_Node_Str"";
  }
  i.addDC(element,qualifier,language,value);
}",0.7668766876687669
52578,"private void addItems(Context c,Collection mycollection,String sourceDir,String mapFile) throws Exception {
  System.out.println(""String_Node_Str"" + sourceDir);
  System.out.println(""String_Node_Str"" + mapFile);
  File outFile=new File(mapFile);
  PrintWriter mapOut=new PrintWriter(new FileWriter(outFile));
  String[] dircontents=new java.io.File(sourceDir).list();
  for (int i=0; i < dircontents.length; i++) {
    addItem(c,mycollection,sourceDir,dircontents[i],mapOut);
    System.out.println(i + ""String_Node_Str"" + dircontents[i]);
  }
  mapOut.close();
}","private void addItems(Context c,Collection mycollection,String sourceDir,String mapFile) throws Exception {
  System.out.println(""String_Node_Str"" + sourceDir);
  System.out.println(""String_Node_Str"" + mapFile);
  File outFile=new File(mapFile);
  PrintWriter mapOut=new PrintWriter(new FileWriter(outFile));
  String[] dircontents=new java.io.File(sourceDir).list();
  for (int i=0; i < dircontents.length; i++) {
    addItem(c,mycollection,sourceDir,dircontents[i],null,mapOut);
    System.out.println(i + ""String_Node_Str"" + dircontents[i]);
  }
  mapOut.close();
}",0.995579133510168
52579,"/** 
 * Create a new workspace item, with a new ID.  An Item is also created.  The submitter is the current user in the context.
 * @param context   DSpace context object
 * @param coll      Collection being submitted to
 * @param template  if <code>true</code>, the workspace item starts as a copy of the collection's template item
 * @return  the newly created workspace item
 */
public static WorkspaceItem create(Context c,Collection coll,boolean template) throws AuthorizeException, SQLException {
  AuthorizeManager.authorizeAction(c,coll,Constants.ADD);
  Item i=Item.create(c);
  i.setSubmitter(c.getCurrentUser());
  Group step1group=coll.getWorkflowGroup(1);
  Group step2group=coll.getWorkflowGroup(2);
  Group step3group=coll.getWorkflowGroup(3);
  EPerson e=c.getCurrentUser();
  AuthorizeManager.addPolicy(c,i,Constants.READ,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.READ,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.READ,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.READ,step3group);
  AuthorizeManager.addPolicy(c,i,Constants.WRITE,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.WRITE,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.WRITE,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.WRITE,step3group);
  AuthorizeManager.addPolicy(c,i,Constants.ADD,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.ADD,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.ADD,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.ADD,step3group);
  AuthorizeManager.addPolicy(c,i,Constants.REMOVE,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.REMOVE,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.REMOVE,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.REMOVE,step3group);
  Item templateItem=coll.getTemplateItem();
  if (template && templateItem != null) {
    DCValue[] dc=templateItem.getDC(Item.ANY,Item.ANY,Item.ANY);
    for (int n=0; n < dc.length; n++) {
      i.addDC(dc[n].element,dc[n].qualifier,dc[n].language,dc[n].value);
    }
  }
 else {
    i.addDC(""String_Node_Str"",""String_Node_Str"",null,ConfigurationManager.getProperty(""String_Node_Str""));
  }
  i.update();
  TableRow row=DatabaseManager.create(c,""String_Node_Str"");
  row.setColumn(""String_Node_Str"",i.getID());
  row.setColumn(""String_Node_Str"",coll.getID());
  log.info(LogManager.getHeader(c,""String_Node_Str"",""String_Node_Str"" + row.getIntColumn(""String_Node_Str"") + ""String_Node_Str""+ i.getID()+ ""String_Node_Str""+ coll.getID()));
  DatabaseManager.update(c,row);
  WorkspaceItem wi=new WorkspaceItem(c,row);
  HistoryManager.saveHistory(c,wi,HistoryManager.CREATE,c.getCurrentUser(),c.getExtraLogInfo());
  return wi;
}","/** 
 * Create a new workspace item, with a new ID.  An Item is also created.  The submitter is the current user in the context.
 * @param context   DSpace context object
 * @param coll      Collection being submitted to
 * @param template  if <code>true</code>, the workspace item starts as a copy of the collection's template item
 * @return  the newly created workspace item
 */
public static WorkspaceItem create(Context c,Collection coll,boolean template) throws AuthorizeException, SQLException {
  AuthorizeManager.authorizeAction(c,coll,Constants.ADD);
  Item i=Item.create(c);
  i.setSubmitter(c.getCurrentUser());
  Group step1group=coll.getWorkflowGroup(1);
  Group step2group=coll.getWorkflowGroup(2);
  Group step3group=coll.getWorkflowGroup(3);
  EPerson e=c.getCurrentUser();
  AuthorizeManager.addPolicy(c,i,Constants.READ,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.READ,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.READ,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.READ,step3group);
  AuthorizeManager.addPolicy(c,i,Constants.WRITE,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.WRITE,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.WRITE,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.WRITE,step3group);
  AuthorizeManager.addPolicy(c,i,Constants.ADD,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.ADD,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.ADD,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.ADD,step3group);
  AuthorizeManager.addPolicy(c,i,Constants.REMOVE,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.REMOVE,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.REMOVE,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.REMOVE,step3group);
  Item templateItem=coll.getTemplateItem();
  if (template && templateItem != null) {
    DCValue[] dc=templateItem.getDC(Item.ANY,Item.ANY,Item.ANY);
    for (int n=0; n < dc.length; n++) {
      i.addDC(dc[n].element,dc[n].qualifier,dc[n].language,dc[n].value);
    }
  }
 else {
  }
  i.update();
  TableRow row=DatabaseManager.create(c,""String_Node_Str"");
  row.setColumn(""String_Node_Str"",i.getID());
  row.setColumn(""String_Node_Str"",coll.getID());
  log.info(LogManager.getHeader(c,""String_Node_Str"",""String_Node_Str"" + row.getIntColumn(""String_Node_Str"") + ""String_Node_Str""+ i.getID()+ ""String_Node_Str""+ coll.getID()));
  DatabaseManager.update(c,row);
  WorkspaceItem wi=new WorkspaceItem(c,row);
  HistoryManager.saveHistory(c,wi,HistoryManager.CREATE,c.getCurrentUser(),c.getExtraLogInfo());
  return wi;
}",0.9817000171027878
52580,"private static void recordApproval(Context c,WorkflowItem wi,EPerson e) throws SQLException, AuthorizeException {
  Item item=wi.getItem();
  String usersName=getEPersonName(e);
  String now=DCDate.getCurrent().toString();
  String provDescription=""String_Node_Str"" + usersName + ""String_Node_Str""+ now+ ""String_Node_Str"";
  provDescription+=InstallItem.getBitstreamProvenanceMessage(item);
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,provDescription);
  item.update();
}","private static void recordApproval(Context c,WorkflowItem wi,EPerson e) throws SQLException, AuthorizeException {
  Item item=wi.getItem();
  String usersName=getEPersonName(e);
  String now=DCDate.getCurrent().toString();
  String provDescription=""String_Node_Str"" + usersName + ""String_Node_Str""+ now+ ""String_Node_Str"";
  provDescription+=InstallItem.getBitstreamProvenanceMessage(item);
  item.addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",provDescription);
  item.update();
}",0.9251282051282051
52581,"/** 
 * rejects an item - rejection means undoing a submit - WorkspaceItem is created, and the WorkflowItem is removed, user is emailed rejection_message.
 * @param c  Context
 * @param wi WorkflowItem to operate on
 * @param e  EPerson doing the operation
 * @param rejection_message message to email to user
 */
public static WorkspaceItem reject(Context c,WorkflowItem wi,EPerson e,String rejection_message) throws SQLException, AuthorizeException, IOException {
  deleteTasks(c,wi);
  Item myitem=wi.getItem();
  String now=DCDate.getCurrent().toString();
  String usersName=getEPersonName(e);
  String provDescription=""String_Node_Str"" + usersName + ""String_Node_Str""+ rejection_message+ ""String_Node_Str""+ now+ ""String_Node_Str"";
  myitem.addDC(""String_Node_Str"",""String_Node_Str"",null,provDescription);
  myitem.update();
  WorkspaceItem wsi=returnToWorkspace(c,wi);
  notifyOfReject(c,wi,e,rejection_message);
  log.info(LogManager.getHeader(c,""String_Node_Str"",""String_Node_Str"" + wi.getID() + ""String_Node_Str""+ wi.getItem().getID()+ ""String_Node_Str""+ wi.getCollection().getID()+ ""String_Node_Str""+ e.getID()));
  return wsi;
}","/** 
 * rejects an item - rejection means undoing a submit - WorkspaceItem is created, and the WorkflowItem is removed, user is emailed rejection_message.
 * @param c  Context
 * @param wi WorkflowItem to operate on
 * @param e  EPerson doing the operation
 * @param rejection_message message to email to user
 */
public static WorkspaceItem reject(Context c,WorkflowItem wi,EPerson e,String rejection_message) throws SQLException, AuthorizeException, IOException {
  deleteTasks(c,wi);
  Item myitem=wi.getItem();
  String now=DCDate.getCurrent().toString();
  String usersName=getEPersonName(e);
  String provDescription=""String_Node_Str"" + usersName + ""String_Node_Str""+ rejection_message+ ""String_Node_Str""+ now+ ""String_Node_Str"";
  myitem.addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",provDescription);
  myitem.update();
  WorkspaceItem wsi=returnToWorkspace(c,wi);
  notifyOfReject(c,wi,e,rejection_message);
  log.info(LogManager.getHeader(c,""String_Node_Str"",""String_Node_Str"" + wi.getID() + ""String_Node_Str""+ wi.getItem().getID()+ ""String_Node_Str""+ wi.getCollection().getID()+ ""String_Node_Str""+ e.getID()));
  return wsi;
}",0.9908256880733946
52582,"protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    request.setAttribute(""String_Node_Str"",collections);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community[] communities=Community.findAll(c);
    request.setAttribute(""String_Node_Str"",communities);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    Group[] groups=Group.findAll(c,Group.NAME);
    request.setAttribute(""String_Node_Str"",collections);
    request.setAttribute(""String_Node_Str"",groups);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item item=null;
    int item_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    String handle=request.getParameter(""String_Node_Str"");
    if (item_id > 0) {
      item=Item.find(c,item_id);
    }
 else     if (handle != null && !handle.equals(""String_Node_Str"")) {
      DSpaceObject dso=HandleManager.resolveToObject(c,handle);
      if (dso != null && dso.getType() != Constants.ITEM) {
        item=(Item)dso;
      }
    }
    if (item == null) {
      request.setAttribute(""String_Node_Str"",new Boolean(true));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else {
      List item_policies=AuthorizeManager.getPolicies(c,item);
      request.setAttribute(""String_Node_Str"",item);
      request.setAttribute(""String_Node_Str"",item_policies);
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item item=Item.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(item);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + item.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + item.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item item=Item.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",item);
    List item_policies=AuthorizeManager.getPolicies(c,item);
    request.setAttribute(""String_Node_Str"",item_policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(collection);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community target=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,target);
    request.setAttribute(""String_Node_Str"",target);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",collection);
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",community);
    List policies=AuthorizeManager.getPolicies(c,community);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.setResource(collection);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.setResource(community);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(collection);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(community);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int item_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    Item item=null;
    Collection collection=null;
    Community community=null;
    String display_page=null;
    ResourcePolicy policy=ResourcePolicy.find(c,policy_id);
    Group group=Group.find(c,group_id);
    if (collection_id != -1) {
      collection=Collection.find(c,collection_id);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,collection,Constants.READ);
        Bitstream bs=collection.getLogo();
        if (bs != null) {
          AuthorizeManager.removeAllPolicies(c,bs);
          AuthorizeManager.addPolicies(c,rps,bs);
        }
      }
      request.setAttribute(""String_Node_Str"",collection);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,collection));
      display_page=""String_Node_Str"";
    }
 else     if (community_id != -1) {
      community=Community.find(c,community_id);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,community,Constants.READ);
        Bitstream bs=community.getLogo();
        if (bs != null) {
          AuthorizeManager.removeAllPolicies(c,bs);
          AuthorizeManager.addPolicies(c,rps,bs);
        }
      }
      request.setAttribute(""String_Node_Str"",community);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,community));
      display_page=""String_Node_Str"";
    }
 else     if (item_id != -1) {
      item=Item.find(c,item_id);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      request.setAttribute(""String_Node_Str"",item);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,item));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    String display_page=null;
    if (collection_id != -1) {
      Collection t=Collection.find(c,collection_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
 else     if (community_id != -1) {
      Community t=Community.find(c,community_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,0,0,false,true);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,0,0,false,true);
    }
    showMainPage(c,request,response);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,action_id,group_id,false,false);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,action_id,group_id,false,false);
    }
    showMainPage(c,request,response);
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showMainPage(c,request,response);
  }
  c.complete();
}","protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    request.setAttribute(""String_Node_Str"",collections);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community[] communities=Community.findAll(c);
    request.setAttribute(""String_Node_Str"",communities);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    Group[] groups=Group.findAll(c,Group.NAME);
    request.setAttribute(""String_Node_Str"",collections);
    request.setAttribute(""String_Node_Str"",groups);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item item=null;
    int item_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    String handle=request.getParameter(""String_Node_Str"");
    if (item_id > 0) {
      item=Item.find(c,item_id);
    }
 else     if (handle != null && !handle.equals(""String_Node_Str"")) {
      DSpaceObject dso=HandleManager.resolveToObject(c,handle);
      if (dso != null && dso.getType() == Constants.ITEM) {
        item=(Item)dso;
      }
    }
    if (item == null) {
      request.setAttribute(""String_Node_Str"",new Boolean(true));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else {
      List item_policies=AuthorizeManager.getPolicies(c,item);
      request.setAttribute(""String_Node_Str"",item);
      request.setAttribute(""String_Node_Str"",item_policies);
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item item=Item.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(item);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + item.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + item.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item item=Item.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",item);
    List item_policies=AuthorizeManager.getPolicies(c,item);
    request.setAttribute(""String_Node_Str"",item_policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(collection);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community target=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,target);
    request.setAttribute(""String_Node_Str"",target);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",collection);
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",community);
    List policies=AuthorizeManager.getPolicies(c,community);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.setResource(collection);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.setResource(community);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(collection);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(community);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int item_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    Item item=null;
    Collection collection=null;
    Community community=null;
    String display_page=null;
    ResourcePolicy policy=ResourcePolicy.find(c,policy_id);
    Group group=Group.find(c,group_id);
    if (collection_id != -1) {
      collection=Collection.find(c,collection_id);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,collection,Constants.READ);
        Bitstream bs=collection.getLogo();
        if (bs != null) {
          AuthorizeManager.removeAllPolicies(c,bs);
          AuthorizeManager.addPolicies(c,rps,bs);
        }
      }
      request.setAttribute(""String_Node_Str"",collection);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,collection));
      display_page=""String_Node_Str"";
    }
 else     if (community_id != -1) {
      community=Community.find(c,community_id);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,community,Constants.READ);
        Bitstream bs=community.getLogo();
        if (bs != null) {
          AuthorizeManager.removeAllPolicies(c,bs);
          AuthorizeManager.addPolicies(c,rps,bs);
        }
      }
      request.setAttribute(""String_Node_Str"",community);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,community));
      display_page=""String_Node_Str"";
    }
 else     if (item_id != -1) {
      item=Item.find(c,item_id);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      request.setAttribute(""String_Node_Str"",item);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,item));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    String display_page=null;
    if (collection_id != -1) {
      Collection t=Collection.find(c,collection_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
 else     if (community_id != -1) {
      Community t=Community.find(c,community_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,0,0,false,true);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,0,0,false,true);
    }
    showMainPage(c,request,response);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,action_id,group_id,false,false);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,action_id,group_id,false,false);
    }
    showMainPage(c,request,response);
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showMainPage(c,request,response);
  }
  c.complete();
}",0.9999276881914816
52583,"/** 
 * Return the file corresponding to ID, or null.
 * @param bitstream  the table row for the bitstream
 * @return The file corresponding to ID, or null
 * @exception IOException If a problem occurs while determining the file
 */
private static File getFile(TableRow bitstream) throws IOException {
  int storeNumber=bitstream.getIntColumn(""String_Node_Str"");
  if (storeNumber == -1) {
    storeNumber=0;
  }
  File store=assetStores[storeNumber];
  String id=bitstream.getStringColumn(""String_Node_Str"");
  BigInteger bigint=new BigInteger(id);
  StringBuffer result=new StringBuffer().append(store.getCanonicalPath());
  for (int i=0; i < directoryLevels; i++) {
    int digits=i * digitsPerLevel;
    result.append(File.separator).append(id.substring(digits,digits + digitsPerLevel));
  }
  String theName=result.append(File.separator).append(id).toString();
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + id + ""String_Node_Str""+ theName);
  return new File(theName);
}","/** 
 * Return the file corresponding to a bitstream.  It's safe to pass in <code>null</code>.
 * @param bitstream  the database table row for the bitstream.Can be <code>null</code>
 * @return  The corresponding file in the file system, or <code>null</code>
 * @exception IOException If a problem occurs while determining the file
 */
private static File getFile(TableRow bitstream) throws IOException {
  if (bitstream == null) {
    return null;
  }
  int storeNumber=bitstream.getIntColumn(""String_Node_Str"");
  if (storeNumber == -1) {
    storeNumber=0;
  }
  File store=assetStores[storeNumber];
  String id=bitstream.getStringColumn(""String_Node_Str"");
  BigInteger bigint=new BigInteger(id);
  StringBuffer result=new StringBuffer().append(store.getCanonicalPath());
  for (int i=0; i < directoryLevels; i++) {
    int digits=i * digitsPerLevel;
    result.append(File.separator).append(id.substring(digits,digits + digitsPerLevel));
  }
  String theName=result.append(File.separator).append(id).toString();
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + id + ""String_Node_Str""+ theName);
  return new File(theName);
}",0.893796992481203
52584,"/** 
 * Create/update collection metadata from a posted form
 * @param context     DSpace context
 * @param request     the HTTP request containing posted info
 * @param response    the HTTP response
 * @param community   the community the collection is in
 * @param collection  the collection to update (or null for creation)
 */
private void processConfirmEditCollection(Context context,HttpServletRequest request,HttpServletResponse response,Community community,Collection collection) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"").equals(""String_Node_Str"")) {
    collection=community.createCollection();
    request.setAttribute(""String_Node_Str"",collection);
  }
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  String intro=request.getParameter(""String_Node_Str"");
  if (intro.equals(""String_Node_Str"")) {
    intro=null;
  }
  String copy=request.getParameter(""String_Node_Str"");
  if (copy.equals(""String_Node_Str"")) {
    copy=null;
  }
  String side=request.getParameter(""String_Node_Str"");
  if (side.equals(""String_Node_Str"")) {
    side=null;
  }
  String license=request.getParameter(""String_Node_Str"");
  if (license.equals(""String_Node_Str"")) {
    license=null;
  }
  String provenance=request.getParameter(""String_Node_Str"");
  if (provenance.equals(""String_Node_Str"")) {
    provenance=null;
  }
  collection.setMetadata(""String_Node_Str"",intro);
  collection.setMetadata(""String_Node_Str"",copy);
  collection.setMetadata(""String_Node_Str"",side);
  collection.setMetadata(""String_Node_Str"",license);
  collection.setMetadata(""String_Node_Str"",provenance);
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group newGroup=Group.create(context);
    newGroup.setName(""String_Node_Str"" + collection.getID() + ""String_Node_Str""+ step);
    newGroup.update();
    collection.setWorkflowGroup(step,newGroup);
    collection.update();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + newGroup.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(15));
    Group g=collection.getWorkflowGroup(step);
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + g.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group g=collection.getWorkflowGroup(step);
    collection.setWorkflowGroup(step,null);
    collection.update();
    g.delete();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.createTemplateItem();
    Item i=collection.getTemplateItem();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item i=collection.getTemplateItem();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.removeTemplateItem();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showControls(context,request,response);
  }
  collection.update();
  context.complete();
}","/** 
 * Create/update collection metadata from a posted form
 * @param context     DSpace context
 * @param request     the HTTP request containing posted info
 * @param response    the HTTP response
 * @param community   the community the collection is in
 * @param collection  the collection to update (or null for creation)
 */
private void processConfirmEditCollection(Context context,HttpServletRequest request,HttpServletResponse response,Community community,Collection collection) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"").equals(""String_Node_Str"")) {
    collection=community.createCollection();
    request.setAttribute(""String_Node_Str"",collection);
  }
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  String intro=request.getParameter(""String_Node_Str"");
  if (intro.equals(""String_Node_Str"")) {
    intro=null;
  }
  String copy=request.getParameter(""String_Node_Str"");
  if (copy.equals(""String_Node_Str"")) {
    copy=null;
  }
  String side=request.getParameter(""String_Node_Str"");
  if (side.equals(""String_Node_Str"")) {
    side=null;
  }
  String license=request.getParameter(""String_Node_Str"");
  if (license.equals(""String_Node_Str"")) {
    license=null;
  }
  String provenance=request.getParameter(""String_Node_Str"");
  if (provenance.equals(""String_Node_Str"")) {
    provenance=null;
  }
  collection.setMetadata(""String_Node_Str"",intro);
  collection.setMetadata(""String_Node_Str"",copy);
  collection.setMetadata(""String_Node_Str"",side);
  collection.setMetadata(""String_Node_Str"",license);
  collection.setMetadata(""String_Node_Str"",provenance);
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group newGroup=Group.create(context);
    newGroup.setName(""String_Node_Str"" + collection.getID() + ""String_Node_Str""+ step);
    newGroup.update();
    collection.setWorkflowGroup(step,newGroup);
    collection.update();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + newGroup.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(15));
    Group g=collection.getWorkflowGroup(step);
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + g.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group g=collection.getWorkflowGroup(step);
    collection.setWorkflowGroup(step,null);
    collection.update();
    g.delete();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.createTemplateItem();
    Item i=collection.getTemplateItem();
    collection.update();
    context.complete();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
    return;
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item i=collection.getTemplateItem();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.removeTemplateItem();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showControls(context,request,response);
  }
  collection.update();
  context.complete();
}",0.992121916569805
52585,"/** 
 * Take an InProgressSubmission and turn it into a fully-archived Item.
 * @param Context
 * @param InProgressSubmission
 * @param EPerson (unused, should be removed from API) 
 */
public static Item installItem(Context c,InProgressSubmission is,EPerson e2) throws SQLException, IOException, AuthorizeException {
  Item item=is.getItem();
  DCDate now=DCDate.getCurrent();
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  DCValue[] currentDateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  if (currentDateIssued.length == 0) {
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  }
  String handle=HandleManager.createHandle(c,item);
  String handleref=HandleManager.getCanonicalForm(handle);
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,handleref);
  Bitstream[] bitstreams=item.getNonInternalBitstreams();
  for (int i=0; i < bitstreams.length; i++) {
    BitstreamFormat bf=bitstreams[i].getFormat();
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,String.valueOf(bitstreams[i].getSize()));
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,bf.getMIMEType());
  }
  String provDescription=""String_Node_Str"" + now + ""String_Node_Str""+ getBitstreamProvenanceMessage(item);
  if (currentDateIssued.length != 0) {
    DCDate d=new DCDate(currentDateIssued[0].value);
    provDescription=provDescription + ""String_Node_Str"" + d.toString();
  }
  item.addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",provDescription);
  is.getCollection().addItem(item);
  item.setArchived(true);
  item.update();
  DSIndexer.indexContent(c,item);
  is.deleteWrapper();
  List policies=AuthorizeManager.getPoliciesActionFilter(c,is.getCollection(),Constants.READ);
  item.replaceAllPolicies(policies);
  return item;
}","/** 
 * Take an InProgressSubmission and turn it into a fully-archived Item.
 * @param Context
 * @param InProgressSubmission
 * @param EPerson (unused, should be removed from API) 
 */
public static Item installItem(Context c,InProgressSubmission is,EPerson e2) throws SQLException, IOException, AuthorizeException {
  Item item=is.getItem();
  DCDate now=DCDate.getCurrent();
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  DCValue[] currentDateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  if (currentDateIssued.length == 0) {
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  }
  String handle=HandleManager.createHandle(c,item);
  String handleref=HandleManager.getCanonicalForm(handle);
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,handleref);
  Bitstream[] bitstreams=item.getNonInternalBitstreams();
  for (int i=0; i < bitstreams.length; i++) {
    BitstreamFormat bf=bitstreams[i].getFormat();
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,String.valueOf(bitstreams[i].getSize()) + ""String_Node_Str"");
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,bf.getMIMEType());
  }
  String provDescription=""String_Node_Str"" + now + ""String_Node_Str""+ getBitstreamProvenanceMessage(item);
  if (currentDateIssued.length != 0) {
    DCDate d=new DCDate(currentDateIssued[0].value);
    provDescription=provDescription + ""String_Node_Str"" + d.toString();
  }
  item.addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",provDescription);
  is.getCollection().addItem(item);
  item.setArchived(true);
  item.update();
  DSIndexer.indexContent(c,item);
  is.deleteWrapper();
  List policies=AuthorizeManager.getPoliciesActionFilter(c,is.getCollection(),Constants.READ);
  item.replaceAllPolicies(policies);
  return item;
}",0.9946949602122016
52586,"/** 
 * Create an empty template item for this collection.  If one already exists, no action is taken.  Caution:  Make sure you call <code>update</code> on the collection after doing this, or the item will have been created but the collection record will not refer to it.
 */
public void createTemplateItem() throws SQLException, AuthorizeException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.WRITE);
  if (template == null) {
    template=Item.create(ourContext);
    log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID() + ""String_Node_Str""+ template.getID()));
  }
}","/** 
 * Create an empty template item for this collection.  If one already exists, no action is taken.  Caution:  Make sure you call <code>update</code> on the collection after doing this, or the item will have been created but the collection record will not refer to it.
 */
public void createTemplateItem() throws SQLException, AuthorizeException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.WRITE);
  if (template == null) {
    template=Item.create(ourContext);
    collectionRow.setColumn(""String_Node_Str"",template.getID());
    log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID() + ""String_Node_Str""+ template.getID()));
  }
}",0.8171384850803366
52587,"/** 
 * Return the index of the first non-whitespace character in the character array, starting at position STARTAT.
 */
private static int firstWhitespace(char[] title,int startAt){
  int first=0;
  for (int j=startAt; j < title.length; j++) {
    if (Character.isWhitespace(title[j])) {
      first=j + 1;
      continue;
    }
    break;
  }
  return first;
}","/** 
 * Return the index of the first letter or number in the character array, starting at position STARTAT.
 */
private static int firstWhitespace(char[] title,int startAt){
  int first=0;
  for (int j=startAt; j < title.length; j++) {
    if (!Character.isLetterOrDigit(title[j])) {
      first=j + 1;
      continue;
    }
    break;
  }
  return first;
}",0.9166666666666666
52588,"/** 
 * Create/update collection metadata from a posted form
 * @param context     DSpace context
 * @param request     the HTTP request containing posted info
 * @param response    the HTTP response
 * @param community   the community the collection is in
 * @param collection  the collection to update (or null for creation)
 */
private void processConfirmEditCollection(Context context,HttpServletRequest request,HttpServletResponse response,Community community,Collection collection) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"").equals(""String_Node_Str"")) {
    collection=community.createCollection();
    request.setAttribute(""String_Node_Str"",collection);
  }
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  String intro=request.getParameter(""String_Node_Str"");
  if (intro.equals(""String_Node_Str"")) {
    intro=null;
  }
  String copy=request.getParameter(""String_Node_Str"");
  if (copy.equals(""String_Node_Str"")) {
    copy=null;
  }
  String side=request.getParameter(""String_Node_Str"");
  if (side.equals(""String_Node_Str"")) {
    side=null;
  }
  String license=request.getParameter(""String_Node_Str"");
  if (license.equals(""String_Node_Str"")) {
    license=null;
  }
  String provenance=request.getParameter(""String_Node_Str"");
  if (provenance.equals(""String_Node_Str"")) {
    provenance=null;
  }
  collection.setMetadata(""String_Node_Str"",intro);
  collection.setMetadata(""String_Node_Str"",copy);
  collection.setMetadata(""String_Node_Str"",side);
  collection.setMetadata(""String_Node_Str"",license);
  collection.setMetadata(""String_Node_Str"",license);
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group newGroup=Group.create(context);
    newGroup.setName(""String_Node_Str"" + collection.getID() + ""String_Node_Str""+ step);
    newGroup.update();
    collection.setWorkflowGroup(step,newGroup);
    collection.update();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + newGroup.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(15));
    Group g=collection.getWorkflowGroup(step);
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + g.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group g=collection.getWorkflowGroup(step);
    collection.setWorkflowGroup(step,null);
    collection.update();
    g.delete();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.createTemplateItem();
    Item i=collection.getTemplateItem();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item i=collection.getTemplateItem();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.removeTemplateItem();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showControls(context,request,response);
  }
  collection.update();
  context.complete();
}","/** 
 * Create/update collection metadata from a posted form
 * @param context     DSpace context
 * @param request     the HTTP request containing posted info
 * @param response    the HTTP response
 * @param community   the community the collection is in
 * @param collection  the collection to update (or null for creation)
 */
private void processConfirmEditCollection(Context context,HttpServletRequest request,HttpServletResponse response,Community community,Collection collection) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"").equals(""String_Node_Str"")) {
    collection=community.createCollection();
    request.setAttribute(""String_Node_Str"",collection);
  }
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  String intro=request.getParameter(""String_Node_Str"");
  if (intro.equals(""String_Node_Str"")) {
    intro=null;
  }
  String copy=request.getParameter(""String_Node_Str"");
  if (copy.equals(""String_Node_Str"")) {
    copy=null;
  }
  String side=request.getParameter(""String_Node_Str"");
  if (side.equals(""String_Node_Str"")) {
    side=null;
  }
  String license=request.getParameter(""String_Node_Str"");
  if (license.equals(""String_Node_Str"")) {
    license=null;
  }
  String provenance=request.getParameter(""String_Node_Str"");
  if (provenance.equals(""String_Node_Str"")) {
    provenance=null;
  }
  collection.setMetadata(""String_Node_Str"",intro);
  collection.setMetadata(""String_Node_Str"",copy);
  collection.setMetadata(""String_Node_Str"",side);
  collection.setMetadata(""String_Node_Str"",license);
  collection.setMetadata(""String_Node_Str"",provenance);
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group newGroup=Group.create(context);
    newGroup.setName(""String_Node_Str"" + collection.getID() + ""String_Node_Str""+ step);
    newGroup.update();
    collection.setWorkflowGroup(step,newGroup);
    collection.update();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + newGroup.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(15));
    Group g=collection.getWorkflowGroup(step);
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + g.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group g=collection.getWorkflowGroup(step);
    collection.setWorkflowGroup(step,null);
    collection.update();
    g.delete();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.createTemplateItem();
    Item i=collection.getTemplateItem();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item i=collection.getTemplateItem();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.removeTemplateItem();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showControls(context,request,response);
  }
  collection.update();
  context.complete();
}",0.998046620653731
52589,"/** 
 * List bitstreams in the item
 */
private void listBitstreams() throws IOException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest request=(HttpServletRequest)pageContext.getRequest();
  out.print(""String_Node_Str"");
  out.println(""String_Node_Str"");
  Bundle[] bundles=item.getBundles();
  if (bundles.length == 0) {
    out.println(""String_Node_Str"");
  }
 else {
    out.println(""String_Node_Str"");
    for (int i=0; i < bundles.length; i++) {
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      for (int k=0; k < bitstreams.length; k++) {
        if (!bitstreams[k].getFormat().isInternal()) {
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getName());
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getSize() / 1024);
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getFormatDescription());
          out.print(""String_Node_Str"");
          out.print(request.getContextPath());
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getID() + ""String_Node_Str"");
          out.print(URLEncoder.encode(bitstreams[k].getName()));
          out.print(""String_Node_Str"");
        }
      }
    }
    out.println(""String_Node_Str"");
  }
  out.println(""String_Node_Str"");
}","/** 
 * List bitstreams in the item
 */
private void listBitstreams() throws IOException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest request=(HttpServletRequest)pageContext.getRequest();
  out.print(""String_Node_Str"");
  out.println(""String_Node_Str"");
  Bundle[] bundles=item.getBundles();
  if (bundles.length == 0) {
    out.println(""String_Node_Str"");
  }
 else {
    boolean multiFile=(bundles.length > 2);
    out.println(""String_Node_Str"");
    if (multiFile) {
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
    for (int i=0; i < bundles.length; i++) {
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      for (int k=0; k < bitstreams.length; k++) {
        if (!bitstreams[k].getFormat().isInternal()) {
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getName());
          if (multiFile) {
            out.print(""String_Node_Str"");
            String desc=bitstreams[k].getDescription();
            out.print(desc != null ? desc : ""String_Node_Str"");
          }
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getSize() / 1024);
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getFormatDescription());
          out.print(""String_Node_Str"");
          out.print(request.getContextPath());
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getID() + ""String_Node_Str"");
          out.print(URLEncoder.encode(bitstreams[k].getName()));
          out.print(""String_Node_Str"");
        }
      }
    }
    out.println(""String_Node_Str"");
  }
  out.println(""String_Node_Str"");
}",0.8826322930800543
52590,"/** 
 * Process information from ""Personal information page""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processPersonalInfo(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String token=request.getParameter(""String_Node_Str"");
  String email=AccountManager.getEmail(context,token);
  if (email == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + token));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  EPerson eperson=EPerson.findByEmail(context,email);
  if (eperson == null) {
    context.setIgnoreAuthorization(true);
    eperson=EPerson.create(context);
    eperson.setEmail(email);
    eperson.update();
    context.setIgnoreAuthorization(false);
  }
  context.setCurrentUser(eperson);
  boolean infoOK=EditProfileServlet.updateUserProfile(eperson,request);
  eperson.setCanLogIn(true);
  eperson.setSelfRegistered(true);
  Authenticate.getSiteAuth().initEPerson(context,request,eperson);
  boolean passwordOK=true;
  if (eperson.getRequireCertificate() == false && Authenticate.getSiteAuth().allowSetPassword(context,request,eperson.getEmail())) {
    passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  }
  if (infoOK && passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,token);
    eperson.update();
    request.setAttribute(""String_Node_Str"",eperson);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",token);
    request.setAttribute(""String_Node_Str"",eperson);
    request.setAttribute(""String_Node_Str"",new Boolean(!infoOK));
    request.setAttribute(""String_Node_Str"",new Boolean(!infoOK));
    boolean setPassword=Authenticate.getSiteAuth().allowSetPassword(context,request,email);
    request.setAttribute(""String_Node_Str"",new Boolean(setPassword));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.abort();
  }
}","/** 
 * Process information from ""Personal information page""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processPersonalInfo(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String token=request.getParameter(""String_Node_Str"");
  String email=AccountManager.getEmail(context,token);
  if (email == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + token));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  EPerson eperson=EPerson.findByEmail(context,email);
  if (eperson == null) {
    context.setIgnoreAuthorization(true);
    eperson=EPerson.create(context);
    eperson.setEmail(email);
    eperson.update();
    context.setIgnoreAuthorization(false);
  }
  context.setCurrentUser(eperson);
  boolean infoOK=EditProfileServlet.updateUserProfile(eperson,request);
  eperson.setCanLogIn(true);
  eperson.setSelfRegistered(true);
  Authenticate.getSiteAuth().initEPerson(context,request,eperson);
  boolean passwordOK=true;
  if (eperson.getRequireCertificate() == false && Authenticate.getSiteAuth().allowSetPassword(context,request,eperson.getEmail())) {
    passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  }
  if (infoOK && passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,token);
    eperson.update();
    request.setAttribute(""String_Node_Str"",eperson);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",token);
    request.setAttribute(""String_Node_Str"",eperson);
    request.setAttribute(""String_Node_Str"",new Boolean(!infoOK));
    request.setAttribute(""String_Node_Str"",new Boolean(!passwordOK));
    boolean setPassword=Authenticate.getSiteAuth().allowSetPassword(context,request,email);
    request.setAttribute(""String_Node_Str"",new Boolean(setPassword));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.abort();
  }
}",0.997341603898981
52591,"/** 
 * process input from edit-metadata-1.jsp
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processEditMetadataOne(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (buttonPressed.equals(""String_Node_Str"")) {
    doCancellation(request,response,subInfo,EDIT_METADATA_1,EDIT_METADATA_1);
    return;
  }
  Item item=subInfo.submission.getItem();
  readNames(request,item,""String_Node_Str"",""String_Node_Str"",true);
  readText(request,item,""String_Node_Str"",null,false,""String_Node_Str"");
  if (subInfo.submission.hasMultipleTitles()) {
    readText(request,item,""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  }
  readSeriesNumbers(request,item,""String_Node_Str"",""String_Node_Str"",true);
  item.clearDC(""String_Node_Str"",null,Item.ANY);
  String[] types=request.getParameterValues(""String_Node_Str"");
  for (int i=0; i < types.length; i++) {
    item.addDC(""String_Node_Str"",null,""String_Node_Str"",types[i]);
  }
  readText(request,item,""String_Node_Str"",""String_Node_Str"",false,null);
  subInfo.submission.getItem().clearDC(""String_Node_Str"",Item.ANY,Item.ANY);
  List quals=getRepeatedParameter(request,""String_Node_Str"");
  List vals=getRepeatedParameter(request,""String_Node_Str"");
  for (int i=0; i < vals.size(); i++) {
    String thisQual=(String)quals.get(i);
    String thisVal=(String)vals.get(i);
    if (!buttonPressed.equals(""String_Node_Str"" + i) && !thisVal.equals(""String_Node_Str"")) {
      item.addDC(""String_Node_Str"",thisQual,null,thisVal);
    }
  }
  if (subInfo.submission.isPublishedBefore()) {
    readDate(request,item,""String_Node_Str"",""String_Node_Str"");
    readText(request,item,""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
    readText(request,item,""String_Node_Str"",null,false,""String_Node_Str"");
  }
  int nextStep=-1;
  if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (subInfo.submission.hasMultipleTitles() && buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    nextStep=INITIAL_QUESTIONS;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    userHasReached(subInfo,EDIT_METADATA_2);
    nextStep=EDIT_METADATA_2;
  }
 else   if (buttonPressed.indexOf(""String_Node_Str"") > -1) {
    nextStep=EDIT_METADATA_1;
  }
  subInfo.submission.update();
  if (nextStep != -1) {
    doStep(context,request,response,subInfo,nextStep);
  }
 else {
    doStepJump(context,request,response,subInfo);
  }
  context.complete();
}","/** 
 * process input from edit-metadata-1.jsp
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processEditMetadataOne(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (buttonPressed.equals(""String_Node_Str"")) {
    doCancellation(request,response,subInfo,EDIT_METADATA_1,EDIT_METADATA_1);
    return;
  }
  Item item=subInfo.submission.getItem();
  readNames(request,item,""String_Node_Str"",""String_Node_Str"",true);
  readText(request,item,""String_Node_Str"",null,false,""String_Node_Str"");
  if (subInfo.submission.hasMultipleTitles()) {
    readText(request,item,""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  }
  readSeriesNumbers(request,item,""String_Node_Str"",""String_Node_Str"",true);
  item.clearDC(""String_Node_Str"",null,Item.ANY);
  String[] types=request.getParameterValues(""String_Node_Str"");
  if (types != null) {
    for (int i=0; i < types.length; i++) {
      item.addDC(""String_Node_Str"",null,""String_Node_Str"",types[i]);
    }
  }
  readText(request,item,""String_Node_Str"",""String_Node_Str"",false,null);
  subInfo.submission.getItem().clearDC(""String_Node_Str"",Item.ANY,Item.ANY);
  List quals=getRepeatedParameter(request,""String_Node_Str"");
  List vals=getRepeatedParameter(request,""String_Node_Str"");
  for (int i=0; i < vals.size(); i++) {
    String thisQual=(String)quals.get(i);
    String thisVal=(String)vals.get(i);
    if (!buttonPressed.equals(""String_Node_Str"" + i) && !thisVal.equals(""String_Node_Str"")) {
      item.addDC(""String_Node_Str"",thisQual,null,thisVal);
    }
  }
  if (subInfo.submission.isPublishedBefore()) {
    readDate(request,item,""String_Node_Str"",""String_Node_Str"");
    readText(request,item,""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
    readText(request,item,""String_Node_Str"",null,false,""String_Node_Str"");
  }
  int nextStep=-1;
  if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (subInfo.submission.hasMultipleTitles() && buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    nextStep=INITIAL_QUESTIONS;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    userHasReached(subInfo,EDIT_METADATA_2);
    nextStep=EDIT_METADATA_2;
  }
 else   if (buttonPressed.indexOf(""String_Node_Str"") > -1) {
    nextStep=EDIT_METADATA_1;
  }
  subInfo.submission.update();
  if (nextStep != -1) {
    doStep(context,request,response,subInfo,nextStep);
  }
 else {
    doStepJump(context,request,response,subInfo);
  }
  context.complete();
}",0.995170496121762
52592,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  X509Certificate[] certs=(X509Certificate[])request.getAttribute(""String_Node_Str"");
  if (certs == null || certs.length == 0) {
    if (request.getParameter(""String_Node_Str"") != null) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else {
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    try {
      if (X509Manager.isValid(certs[0])) {
        EPerson eperson=X509Manager.getUser(context,certs[0]);
        if (eperson == null) {
          if (ConfigurationManager.getBooleanProperty(""String_Node_Str"")) {
            String email=X509Manager.getEmail(certs[0]);
            eperson=EPerson.create(context);
            eperson.setEmail(email);
            eperson.setCanLogIn(true);
            Authenticate.getSiteAuth().initEPerson(context,request,eperson);
            eperson.update();
            context.commit();
          }
 else {
            log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
            JSPManager.showJSP(request,response,""String_Node_Str"");
            return;
          }
        }
        if (eperson != null && eperson.canLogIn()) {
          Authenticate.loggedIn(context,request,eperson);
          log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          Authenticate.resumeInterruptedRequest(request,response);
          return;
        }
      }
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 catch (    CertificateException ce) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),ce);
      JSPManager.showInternalError(request,response);
    }
  }
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  X509Certificate[] certs=(X509Certificate[])request.getAttribute(""String_Node_Str"");
  if (certs == null || certs.length == 0) {
    if (request.getParameter(""String_Node_Str"") != null) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else {
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    try {
      if (X509Manager.isValid(certs[0])) {
        EPerson eperson=X509Manager.getUser(context,certs[0]);
        if (eperson == null) {
          if (ConfigurationManager.getBooleanProperty(""String_Node_Str"")) {
            String email=X509Manager.getEmail(certs[0]);
            log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + email));
            context.setIgnoreAuthorization(true);
            eperson=EPerson.create(context);
            eperson.setEmail(email);
            eperson.setCanLogIn(true);
            Authenticate.getSiteAuth().initEPerson(context,request,eperson);
            eperson.update();
            context.commit();
            context.setIgnoreAuthorization(false);
          }
 else {
            log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
            JSPManager.showJSP(request,response,""String_Node_Str"");
            return;
          }
        }
        if (eperson != null && eperson.canLogIn()) {
          Authenticate.loggedIn(context,request,eperson);
          log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          Authenticate.resumeInterruptedRequest(request,response);
          return;
        }
      }
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 catch (    CertificateException ce) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),ce);
      JSPManager.showInternalError(request,response);
    }
  }
}",0.952744630071599
52593,"/** 
 * Get the e-person's full name, combining first and last name in a displayable string.
 * @return  their full name
 */
public String getFullName(){
  String t=myRow.getStringColumn(""String_Node_Str"") + ""String_Node_Str"" + myRow.getStringColumn(""String_Node_Str"");
  return t;
}","/** 
 * Get the e-person's full name, combining first and last name in a displayable string.
 * @return  their full name
 */
public String getFullName(){
  String f=myRow.getStringColumn(""String_Node_Str"");
  String l=myRow.getStringColumn(""String_Node_Str"");
  if (l == null && f == null) {
    return getEmail();
  }
 else   if (f == null) {
    return l;
  }
 else {
    return (f + ""String_Node_Str"" + l);
  }
}",0.7191977077363897
52594,"protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    request.setAttribute(""String_Node_Str"",collections);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community[] communities=Community.findAll(c);
    request.setAttribute(""String_Node_Str"",communities);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    Group[] groups=Group.findAll(c,Group.NAME);
    request.setAttribute(""String_Node_Str"",collections);
    request.setAttribute(""String_Node_Str"",groups);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community target=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,target);
    request.setAttribute(""String_Node_Str"",target);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",collection);
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",community);
    List policies=AuthorizeManager.getPolicies(c,community);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.update();
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.update();
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    String display_page=null;
    ResourcePolicy policy=ResourcePolicy.find(c,policy_id);
    Group group=Group.find(c,group_id);
    if (collection_id != -1) {
      collection=Collection.find(c,collection_id);
      policy.setResource(collection);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,collection,Constants.READ);
        Bitstream bs=collection.getLogo();
        AuthorizeManager.removeAllPolicies(c,bs);
        AuthorizeManager.addPolicies(c,rps,bs);
      }
      request.setAttribute(""String_Node_Str"",collection);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,collection));
      display_page=""String_Node_Str"";
    }
    if (community_id != -1) {
      community=Community.find(c,community_id);
      policy.setResource(community);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,community,Constants.READ);
        Bitstream bs=community.getLogo();
        AuthorizeManager.removeAllPolicies(c,bs);
        AuthorizeManager.addPolicies(c,rps,bs);
      }
      request.setAttribute(""String_Node_Str"",community);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,community));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    String display_page=null;
    if (collection_id != -1) {
      Collection t=Collection.find(c,collection_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
 else     if (community_id != -1) {
      Community t=Community.find(c,community_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,0,0,false,true);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,0,0,false,true);
    }
    showMainPage(c,request,response);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,action_id,group_id,false,false);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,action_id,group_id,false,false);
    }
    showMainPage(c,request,response);
  }
 else {
    showMainPage(c,request,response);
  }
  c.complete();
}","protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    request.setAttribute(""String_Node_Str"",collections);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community[] communities=Community.findAll(c);
    request.setAttribute(""String_Node_Str"",communities);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    Group[] groups=Group.findAll(c,Group.NAME);
    request.setAttribute(""String_Node_Str"",collections);
    request.setAttribute(""String_Node_Str"",groups);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community target=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,target);
    request.setAttribute(""String_Node_Str"",target);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",collection);
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",community);
    List policies=AuthorizeManager.getPolicies(c,community);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.update();
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.update();
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    String display_page=null;
    ResourcePolicy policy=ResourcePolicy.find(c,policy_id);
    Group group=Group.find(c,group_id);
    if (collection_id != -1) {
      collection=Collection.find(c,collection_id);
      policy.setResource(collection);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,collection,Constants.READ);
        Bitstream bs=collection.getLogo();
        if (bs != null) {
          AuthorizeManager.removeAllPolicies(c,bs);
          AuthorizeManager.addPolicies(c,rps,bs);
        }
      }
      request.setAttribute(""String_Node_Str"",collection);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,collection));
      display_page=""String_Node_Str"";
    }
    if (community_id != -1) {
      community=Community.find(c,community_id);
      policy.setResource(community);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,community,Constants.READ);
        Bitstream bs=community.getLogo();
        if (bs != null) {
          AuthorizeManager.removeAllPolicies(c,bs);
          AuthorizeManager.addPolicies(c,rps,bs);
        }
      }
      request.setAttribute(""String_Node_Str"",community);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,community));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    String display_page=null;
    if (collection_id != -1) {
      Collection t=Collection.find(c,collection_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
 else     if (community_id != -1) {
      Community t=Community.find(c,community_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,0,0,false,true);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,0,0,false,true);
    }
    showMainPage(c,request,response);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,action_id,group_id,false,false);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,action_id,group_id,false,false);
    }
    showMainPage(c,request,response);
  }
 else {
    showMainPage(c,request,response);
  }
  c.complete();
}",0.99608533959679
52595,"/** 
 * Process input from remove item page
 * @param context   current context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processRemoveItem(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  WorkspaceItem workspaceItem;
  try {
    int wsID=Integer.parseInt(request.getParameter(""String_Node_Str""));
    workspaceItem=WorkspaceItem.find(context,wsID);
  }
 catch (  NumberFormatException nfe) {
    workspaceItem=null;
  }
  if (workspaceItem == null) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
    JSPManager.showIntegrityError(request,response);
    return;
  }
  if (buttonPressed.equals(""String_Node_Str"")) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workspaceItem.getID() + ""String_Node_Str""+ workspaceItem.getItem().getID()));
    workspaceItem.deleteWrapper();
    showMainPage(context,request,response);
    context.complete();
  }
 else {
    showMainPage(context,request,response);
  }
}","/** 
 * Process input from remove item page
 * @param context   current context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processRemoveItem(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  WorkspaceItem workspaceItem;
  try {
    int wsID=Integer.parseInt(request.getParameter(""String_Node_Str""));
    workspaceItem=WorkspaceItem.find(context,wsID);
  }
 catch (  NumberFormatException nfe) {
    workspaceItem=null;
  }
  if (workspaceItem == null) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
    JSPManager.showIntegrityError(request,response);
    return;
  }
  if (buttonPressed.equals(""String_Node_Str"")) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workspaceItem.getID() + ""String_Node_Str""+ workspaceItem.getItem().getID()));
    workspaceItem.deleteAll();
    showMainPage(context,request,response);
    context.complete();
  }
 else {
    showMainPage(context,request,response);
  }
}",0.9959612277867528
52596,"/** 
 * Delete the item.  Bundles and bitstreams are also deleted if they are not also included in another item.  The Dublin Core metadata is deleted.
 */
void delete() throws SQLException, AuthorizeException, IOException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.DELETE);
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
  ourContext.removeCached(this,getID());
  if (isArchived()) {
    Browse.itemRemoved(ourContext,getID());
  }
  removeDCFromDatabase();
  Bundle[] bundles=getBundles();
  for (int i=0; i < bundles.length; i++) {
    removeBundle(bundles[i]);
  }
  AuthorizeManager.removeAllPolicies(ourContext,this);
  DatabaseManager.updateQuery(ourContext,""String_Node_Str"" + Constants.ITEM + ""String_Node_Str""+ getID());
  DatabaseManager.delete(ourContext,itemRow);
}","/** 
 * Delete the item.  Bundles and bitstreams are also deleted if they are not also included in another item.  The Dublin Core metadata is deleted.
 */
void delete() throws SQLException, AuthorizeException, IOException {
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
  ourContext.removeCached(this,getID());
  if (isArchived()) {
    Browse.itemRemoved(ourContext,getID());
  }
  removeDCFromDatabase();
  Bundle[] bundles=getBundles();
  for (int i=0; i < bundles.length; i++) {
    removeBundle(bundles[i]);
  }
  AuthorizeManager.removeAllPolicies(ourContext,this);
  DatabaseManager.updateQuery(ourContext,""String_Node_Str"" + Constants.ITEM + ""String_Node_Str""+ getID());
  DatabaseManager.delete(ourContext,itemRow);
}",0.962486602357985
52597,"/** 
 * This method should be called whenever an item is added.
 * @param context The current DSpace context
 * @param item The item which has been added
 * @exception SQLException If a database error occurs
 */
public static void itemAdded(Context context,Item item) throws SQLException {
  Map table2dc=new HashMap();
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",null,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",Item.ANY,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  for (Iterator iterator=table2dc.keySet().iterator(); iterator.hasNext(); ) {
    String table=(String)iterator.next();
    DCValue[] dc=(DCValue[])table2dc.get(table);
    for (int i=0; i < dc.length; i++) {
      TableRow row=DatabaseManager.create(context,table);
      row.setColumn(""String_Node_Str"",item.getID());
      String value=dc[i].value;
      if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table)) {
        String title=NormalizedTitle.normalize(value,dc[i].language);
        row.setColumn(""String_Node_Str"",value);
        row.setColumn(""String_Node_Str"",title);
      }
      DatabaseManager.update(context,row);
    }
  }
}","/** 
 * This method should be called whenever an item is added.
 * @param context The current DSpace context
 * @param item The item which has been added
 * @exception SQLException If a database error occurs
 */
public static void itemAdded(Context context,Item item) throws SQLException {
  Map table2dc=new HashMap();
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",null,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",Item.ANY,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  for (Iterator iterator=table2dc.keySet().iterator(); iterator.hasNext(); ) {
    String table=(String)iterator.next();
    DCValue[] dc=(DCValue[])table2dc.get(table);
    for (int i=0; i < dc.length; i++) {
      TableRow row=DatabaseManager.create(context,table);
      row.setColumn(""String_Node_Str"",item.getID());
      String value=dc[i].value;
      if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table)) {
        row.setColumn(""String_Node_Str"",value);
        row.setColumn(""String_Node_Str"",value.toLowerCase());
      }
 else       if (""String_Node_Str"".equals(table)) {
        String title=NormalizedTitle.normalize(value,dc[i].language);
        row.setColumn(""String_Node_Str"",value);
        row.setColumn(""String_Node_Str"",title.toLowerCase());
      }
      DatabaseManager.update(context,row);
    }
  }
}",0.972856261566934
52598,"protected static int countTotalInIndex(BrowseScope scope,int numberOfResults) throws SQLException {
  int browseType=scope.getBrowseType();
  if ((browseType == ITEMS_BY_AUTHOR_BROWSE) && (scope.hasNoLimit() || ((scope.getTotal() > numberOfResults))))   return numberOfResults;
  PreparedStatement statement=null;
  Object obj=scope.getScope();
  try {
    String table=BrowseTables.getTable(scope);
    StringBuffer buffer=new StringBuffer().append(""String_Node_Str"").append(getTargetColumns(scope)).append(""String_Node_Str"").append(table);
    boolean hasWhere=false;
    if (browseType == ITEMS_BY_AUTHOR_BROWSE) {
      hasWhere=true;
      buffer.append(""String_Node_Str"");
    }
    String connector=hasWhere ? ""String_Node_Str"" : ""String_Node_Str"";
    String sql=buffer.append(getScopeClause(scope,connector)).toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + sql + ""String_Node_Str"");
    statement=createStatement(scope,sql);
    if (browseType == ITEMS_BY_AUTHOR_BROWSE)     statement.setString(1,(String)scope.getFocus());
    return getIntValue(statement);
  }
  finally {
    if (statement != null)     statement.close();
  }
}","protected static int countTotalInIndex(BrowseScope scope,int numberOfResults) throws SQLException {
  int browseType=scope.getBrowseType();
  if ((browseType == ITEMS_BY_AUTHOR_BROWSE) && (scope.hasNoLimit() || ((scope.getTotal() > numberOfResults))))   return numberOfResults;
  PreparedStatement statement=null;
  Object obj=scope.getScope();
  try {
    String table=BrowseTables.getTable(scope);
    StringBuffer buffer=new StringBuffer().append(""String_Node_Str"").append((getTargetColumns(scope) == ""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(table);
    boolean hasWhere=false;
    if (browseType == ITEMS_BY_AUTHOR_BROWSE) {
      hasWhere=true;
      buffer.append(""String_Node_Str"");
    }
    String connector=hasWhere ? ""String_Node_Str"" : ""String_Node_Str"";
    String sql=buffer.append(getScopeClause(scope,connector)).toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + sql + ""String_Node_Str"");
    statement=createStatement(scope,sql);
    if (browseType == ITEMS_BY_AUTHOR_BROWSE)     statement.setString(1,(String)scope.getFocus());
    return getIntValue(statement);
  }
  finally {
    if (statement != null)     statement.close();
  }
}",0.9737171464330412
52599,"/** 
 * Create a SQL string to run the correct query.
 */
private static String createSqlInternal(BrowseScope scope,String itemValue,boolean isCount) throws SQLException {
  String tablename=BrowseTables.getTable(scope);
  String column=BrowseTables.getValueColumn(scope);
  StringBuffer sqlb=new StringBuffer().append(""String_Node_Str"").append(isCount ? ""String_Node_Str"" : ""String_Node_Str"").append(getTargetColumns(scope)).append(isCount ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(tablename);
  boolean addedWhereClause=false;
  if (scope.hasFocus()) {
    String subquery=null;
    if (scope.focusIsItem())     subquery=new StringBuffer().append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(scope.getFocusItemId()).append(""String_Node_Str"").toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + subquery + ""String_Node_Str"");
    sqlb.append(""String_Node_Str"").append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(""String_Node_Str"").append(scope.focusIsItem() ? subquery : ""String_Node_Str"").append(""String_Node_Str"");
    addedWhereClause=true;
  }
  String connector=addedWhereClause ? ""String_Node_Str"" : ""String_Node_Str"";
  sqlb.append(getScopeClause(scope,connector));
  if (isCount)   return sqlb.toString();
  sqlb.append(""String_Node_Str"").append(column).append(""String_Node_Str"").append((scope.focusIsString() || (scope.getBrowseType() == AUTHORS_BROWSE)) ? ""String_Node_Str"" : ""String_Node_Str"");
  if (!scope.hasNoLimit())   sqlb.append(""String_Node_Str"");
  return sqlb.toString();
}","/** 
 * Create a SQL string to run the correct query.
 */
private static String createSqlInternal(BrowseScope scope,String itemValue,boolean isCount) throws SQLException {
  String tablename=BrowseTables.getTable(scope);
  String column=BrowseTables.getValueColumn(scope);
  StringBuffer sqlb=new StringBuffer().append(""String_Node_Str"").append(isCount ? ""String_Node_Str"" : ""String_Node_Str"").append((getTargetColumns(scope) == ""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"").append(isCount ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(tablename);
  boolean addedWhereClause=false;
  if (scope.hasFocus()) {
    String subquery=null;
    if (scope.focusIsItem())     subquery=new StringBuffer().append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(scope.getFocusItemId()).append(""String_Node_Str"").toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + subquery + ""String_Node_Str"");
    sqlb.append(""String_Node_Str"").append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(""String_Node_Str"").append(scope.focusIsItem() ? subquery : ""String_Node_Str"").append(""String_Node_Str"");
    addedWhereClause=true;
  }
  String connector=addedWhereClause ? ""String_Node_Str"" : ""String_Node_Str"";
  sqlb.append(getScopeClause(scope,connector));
  if (isCount)   return sqlb.toString();
  sqlb.append(""String_Node_Str"").append(column).append(""String_Node_Str"").append((scope.focusIsString() || (scope.getBrowseType() == AUTHORS_BROWSE)) ? ""String_Node_Str"" : ""String_Node_Str"");
  if (!scope.hasNoLimit())   sqlb.append(""String_Node_Str"");
  return sqlb.toString();
}",0.9806451612903224
52600,"/** 
 * Returns a normalized String corresponding to TITLE. The normalization is effected by: + first removing leading spaces, if any + then removing the first leading occurences of ""a"", ""an"" and ""the"" (in any case). + removing any whitespace following an occurence of a stop word This simple strategy is only expected to be used for English words.
 */
public static String normalizeEnglish(String title){
  if (title == null)   return null;
  if (title.length() == 0)   return title;
  int startAt=firstWhitespace(title);
  boolean modified=(startAt != 0);
  boolean usedStopWord=false;
  String stop=null;
  for (int i=0; i < STOP_WORDS.length; i++) {
    stop=STOP_WORDS[i];
    int stoplen=stop.length();
    boolean found=title.toLowerCase().startsWith(stop.toLowerCase(),startAt) && title.length() >= (startAt + stoplen + 1) && Character.isWhitespace(title.charAt(startAt + stoplen));
    if (found) {
      modified=true;
      usedStopWord=true;
      startAt+=stoplen;
      int firstw=firstWhitespace(title,startAt);
      if (firstw != 0)       startAt=firstw;
      break;
    }
  }
  if (!modified)   return title;
  if (!usedStopWord)   return title.substring(startAt);
  return new StringBuffer(title.substring(startAt)).append(""String_Node_Str"").append(stop).toString();
}","/** 
 * Returns a normalized String corresponding to TITLE. The normalization is effected by: + first removing leading spaces, if any + then removing the first leading occurences of ""a"", ""an"" and ""the"" (in any case). + removing any whitespace following an occurence of a stop word This simple strategy is only expected to be used for English words.
 */
public static String normalizeEnglish(String oldtitle){
  if (oldtitle == null)   return null;
  if (oldtitle.length() == 0)   return oldtitle;
  String title=oldtitle.toLowerCase();
  int startAt=firstWhitespace(title);
  boolean modified=(startAt != 0);
  boolean usedStopWord=false;
  String stop=null;
  for (int i=0; i < STOP_WORDS.length; i++) {
    stop=STOP_WORDS[i];
    int stoplen=stop.length();
    boolean found=title.toLowerCase().startsWith(stop.toLowerCase(),startAt) && title.length() >= (startAt + stoplen + 1) && Character.isWhitespace(title.charAt(startAt + stoplen));
    if (found) {
      modified=true;
      usedStopWord=true;
      startAt+=stoplen;
      int firstw=firstWhitespace(title,startAt);
      if (firstw != 0)       startAt=firstw;
      break;
    }
  }
  if (!modified)   return title;
  if (!usedStopWord)   return title.substring(startAt);
  return new StringBuffer(title.substring(startAt)).append(""String_Node_Str"").append(stop).toString();
}",0.949371907118386
52601,"/** 
 * Create a SQL string to run the correct query.
 */
private static String createSqlInternal(BrowseScope scope,String itemValue,boolean isCount) throws SQLException {
  String tablename=BrowseTables.getTable(scope);
  String column=BrowseTables.getValueColumn(scope);
  StringBuffer sqlb=new StringBuffer().append(""String_Node_Str"").append(isCount ? ""String_Node_Str"" : ""String_Node_Str"").append(getTargetColumns(scope)).append(isCount ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(tablename);
  boolean addedWhereClause=false;
  if (scope.hasFocus()) {
    String subquery=null;
    if (scope.focusIsItem())     subquery=new StringBuffer().append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(scope.getFocusItemId()).append(""String_Node_Str"").toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + subquery + ""String_Node_Str"");
    sqlb.append(""String_Node_Str"").append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(""String_Node_Str"").append(scope.focusIsItem() ? subquery : ""String_Node_Str"").append(""String_Node_Str"");
    addedWhereClause=true;
  }
  String connector=addedWhereClause ? ""String_Node_Str"" : ""String_Node_Str"";
  sqlb.append(getScopeClause(scope,connector));
  if (isCount)   return sqlb.toString();
  sqlb.append(""String_Node_Str"").append(column).append(""String_Node_Str"").append((scope.focusIsString() || (scope.getBrowseType() == AUTHORS_BROWSE)) ? ""String_Node_Str"" : ""String_Node_Str"");
  if (!scope.hasNoLimit())   sqlb.append(""String_Node_Str"");
  return sqlb.toString();
}","/** 
 * Create a SQL string to run the correct query.
 */
private static String createSqlInternal(BrowseScope scope,String itemValue,boolean isCount) throws SQLException {
  String tablename=BrowseTables.getTable(scope);
  String column=BrowseTables.getValueColumn(scope);
  int browseType=scope.getBrowseType();
  StringBuffer sqlb=new StringBuffer();
  sqlb.append(""String_Node_Str"");
  sqlb.append(isCount ? ""String_Node_Str"" : ""String_Node_Str"");
  sqlb.append(getTargetColumns(scope));
  sqlb.append(isCount ? ""String_Node_Str"" : ""String_Node_Str"");
  if (browseType == AUTHORS_BROWSE && !isCount) {
    sqlb.append(""String_Node_Str"");
  }
  sqlb.append(""String_Node_Str"");
  sqlb.append(tablename);
  boolean addedWhereClause=false;
  if (scope.hasFocus()) {
    String subquery=null;
    if (scope.focusIsItem())     subquery=new StringBuffer().append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(scope.getFocusItemId()).append(""String_Node_Str"").toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + subquery + ""String_Node_Str"");
    sqlb.append(""String_Node_Str"").append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(""String_Node_Str"").append(scope.focusIsItem() ? subquery : ""String_Node_Str"").append(""String_Node_Str"");
    addedWhereClause=true;
  }
  String connector=addedWhereClause ? ""String_Node_Str"" : ""String_Node_Str"";
  sqlb.append(getScopeClause(scope,connector));
  if (isCount)   return sqlb.toString();
  sqlb.append(""String_Node_Str"").append(column).append(""String_Node_Str"").append((scope.focusIsString() || (scope.getBrowseType() == AUTHORS_BROWSE)) ? ""String_Node_Str"" : ""String_Node_Str"");
  if (!scope.hasNoLimit())   sqlb.append(""String_Node_Str"");
  return sqlb.toString();
}",0.3548961424332344
52602,"/** 
 * Process information from ""Personal information page""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processPersonalInfo(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String key=request.getParameter(""String_Node_Str"");
  EPerson eperson=AccountManager.getEPerson(context,key);
  if (eperson == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + key));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  boolean infoOK=EditProfileServlet.updateUserProfile(eperson,request);
  boolean passwordOK=true;
  if (eperson.getRequireCertificate() == false) {
    passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  }
  if (!infoOK) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  if (!passwordOK) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  request.setAttribute(""String_Node_Str"",eperson);
  if (infoOK && passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,key);
    eperson.setActive(true);
    eperson.update();
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",key);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}","/** 
 * Process information from ""Personal information page""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processPersonalInfo(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String key=request.getParameter(""String_Node_Str"");
  EPerson eperson=AccountManager.getEPerson(context,key);
  if (eperson == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + key));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  context.setCurrentUser(eperson);
  boolean infoOK=EditProfileServlet.updateUserProfile(eperson,request);
  boolean passwordOK=true;
  if (eperson.getRequireCertificate() == false) {
    passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  }
  if (!infoOK) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  if (!passwordOK) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  request.setAttribute(""String_Node_Str"",eperson);
  if (infoOK && passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,key);
    eperson.setActive(true);
    eperson.update();
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",key);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}",0.9890316515198996
52603,"/** 
 * Process information from ""enter new password""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processNewPassword(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String key=request.getParameter(""String_Node_Str"");
  EPerson eperson=AccountManager.getEPerson(context,key);
  if (eperson == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + key));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  boolean passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  if (passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,key);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
    request.setAttribute(""String_Node_Str"",key);
    request.setAttribute(""String_Node_Str"",eperson);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}","/** 
 * Process information from ""enter new password""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processNewPassword(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String key=request.getParameter(""String_Node_Str"");
  EPerson eperson=AccountManager.getEPerson(context,key);
  if (eperson == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + key));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  context.setCurrentUser(eperson);
  boolean passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  if (passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,key);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
    request.setAttribute(""String_Node_Str"",key);
    request.setAttribute(""String_Node_Str"",eperson);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}",0.986247544204322
52604,"/** 
 * Fill out an item's DC values from a plain standard text field. If the field isn't repeatable, the input field name is called: element_qualifier or for an unqualified element: element Repeated elements are appended with an underscore then an integer. e.g.: title_alternative_0 title_alternative_1 The values will be put in separate DCValues, ordered as they appear in the list.  These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 * @param lang       language to set (ISO code)
 */
private void readText(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated,String lang){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List vals=new LinkedList();
  if (repeated) {
    vals=getRepeatedParameter(request,dcname);
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      vals.remove(valToRemove);
    }
  }
 else {
    String s=request.getParameter(dcname);
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < vals.size(); i++) {
    String s=(String)vals.get(i);
    if (s != null && !s.trim().equals(""String_Node_Str"")) {
      item.addDC(element,qualifier,lang,s);
    }
  }
}","/** 
 * Fill out an item's DC values from a plain standard text field. If the field isn't repeatable, the input field name is called: element_qualifier or for an unqualified element: element Repeated elements are appended with an underscore then an integer. e.g.: title_alternative_0 title_alternative_1 The values will be put in separate DCValues, ordered as they appear in the list.  These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 * @param lang       language to set (ISO code)
 */
private void readText(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated,String lang){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List vals=new LinkedList();
  if (repeated) {
    vals=getRepeatedParameter(request,dcname);
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      vals.remove(valToRemove);
    }
  }
 else {
    vals.add(request.getParameter(dcname).trim());
    ;
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < vals.size(); i++) {
    String s=(String)vals.get(i);
    if (s != null && !s.equals(""String_Node_Str"")) {
      item.addDC(element,qualifier,lang,s);
    }
  }
}",0.988340807174888
52605,"/** 
 * Get repeated values from a form.  If ""foo"" is passed in, values in the form of parameters ""foo_0"", ""foo_1"", etc. are returned.
 * @param request   the HTTP request containing the form information
 * @param param     the repeated parameter
 * @return a List of Strings
 */
private List getRepeatedParameter(HttpServletRequest request,String param){
  List vals=new LinkedList();
  int i=0;
  boolean foundLast=false;
  while (!foundLast) {
    String s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s != null) {
      vals.add(s);
    }
 else {
      foundLast=true;
    }
    i++;
  }
  return vals;
}","/** 
 * Get repeated values from a form.  If ""foo"" is passed in, values in the form of parameters ""foo_0"", ""foo_1"", etc. are returned.
 * @param request   the HTTP request containing the form information
 * @param param     the repeated parameter
 * @return a List of Strings
 */
private List getRepeatedParameter(HttpServletRequest request,String param){
  List vals=new LinkedList();
  int i=0;
  boolean foundLast=false;
  while (!foundLast) {
    String s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s != null) {
      vals.add(s.trim());
    }
 else {
      foundLast=true;
    }
    i++;
  }
  return vals;
}",0.994422310756972
52606,"/** 
 * Get all the items in this collection.  The order is indeterminate.
 * @return  an iterator over the items in the collection.
 */
public ItemIterator getItems() throws SQLException {
  TableRowIterator rows=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + getID() + ""String_Node_Str"");
  return new ItemIterator(ourContext,rows);
}","/** 
 * Get all the items in this collection.  The order is indeterminate.
 * @return  an iterator over the items in the collection.
 */
public ItemIterator getItems() throws SQLException {
  TableRowIterator rows=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + getID() + ""String_Node_Str"");
  return new ItemIterator(ourContext,rows);
}",0.9743589743589745
52607,"/** 
 * Fill out an item's DC values from a plain standard text field. If the field isn't repeatable, the input field name is called: element_qualifier or for an unqualified element: element Repeated elements are appended with an underscore then an integer. e.g.: title_alternative_0 title_alternative_1 The values will be put in separate DCValues, ordered as they appear in the list.  These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 * @param lang       language to set (ISO code)
 */
private void readText(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated,String lang){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List vals=new LinkedList();
  if (repeated) {
    vals=getRepeatedParameter(request,dcname);
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      vals.remove(valToRemove);
    }
  }
 else {
    String s=request.getParameter(dcname);
    if (s != null && !s.equals(""String_Node_Str"")) {
      vals.add(s);
    }
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < vals.size(); i++) {
    item.addDC(element,qualifier,lang,(String)vals.get(i));
  }
}","/** 
 * Fill out an item's DC values from a plain standard text field. If the field isn't repeatable, the input field name is called: element_qualifier or for an unqualified element: element Repeated elements are appended with an underscore then an integer. e.g.: title_alternative_0 title_alternative_1 The values will be put in separate DCValues, ordered as they appear in the list.  These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 * @param lang       language to set (ISO code)
 */
private void readText(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated,String lang){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List vals=new LinkedList();
  if (repeated) {
    vals=getRepeatedParameter(request,dcname);
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      vals.remove(valToRemove);
    }
  }
 else {
    String s=request.getParameter(dcname);
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < vals.size(); i++) {
    String s=(String)vals.get(i);
    if (s != null && !s.trim().equals(""String_Node_Str"")) {
      item.addDC(element,qualifier,lang,s);
    }
  }
}",0.9399759903961584
52608,"/** 
 * process input from edit-metadata-1.jsp
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processEditMetadataOne(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (buttonPressed.equals(""String_Node_Str"")) {
    doCancellation(request,response,subInfo,EDIT_METADATA_1,EDIT_METADATA_1);
    return;
  }
  Item item=subInfo.submission.getItem();
  readNames(request,item,""String_Node_Str"",""String_Node_Str"",true);
  readText(request,item,""String_Node_Str"",null,false,""String_Node_Str"");
  if (subInfo.submission.hasMultipleTitles()) {
    readText(request,item,""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  }
  if (subInfo.submission.isPublishedBefore()) {
    readDate(request,item,""String_Node_Str"",""String_Node_Str"");
  }
  readSeriesNumbers(request,item,""String_Node_Str"",""String_Node_Str"",true);
  readText(request,item,""String_Node_Str"",""String_Node_Str"",false,null);
  subInfo.submission.getItem().clearDC(""String_Node_Str"",Item.ANY,Item.ANY);
  List quals=getRepeatedParameter(request,""String_Node_Str"");
  List vals=getRepeatedParameter(request,""String_Node_Str"");
  for (int i=0; i < vals.size(); i++) {
    String thisQual=(String)quals.get(i);
    String thisVal=(String)vals.get(i);
    if (!buttonPressed.equals(""String_Node_Str"" + i)) {
      item.addDC(""String_Node_Str"",thisQual,null,thisVal);
    }
  }
  int nextStep=-1;
  if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (subInfo.submission.hasMultipleTitles() && buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    nextStep=INITIAL_QUESTIONS;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    userHasReached(subInfo,EDIT_METADATA_2);
    nextStep=EDIT_METADATA_2;
  }
 else   if (buttonPressed.indexOf(""String_Node_Str"") > -1) {
    nextStep=EDIT_METADATA_1;
  }
  subInfo.submission.update();
  if (nextStep != -1) {
    doStep(context,request,response,subInfo,nextStep);
  }
 else {
    doStepJump(context,request,response,subInfo);
  }
  context.complete();
}","/** 
 * process input from edit-metadata-1.jsp
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processEditMetadataOne(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (buttonPressed.equals(""String_Node_Str"")) {
    doCancellation(request,response,subInfo,EDIT_METADATA_1,EDIT_METADATA_1);
    return;
  }
  Item item=subInfo.submission.getItem();
  readNames(request,item,""String_Node_Str"",""String_Node_Str"",true);
  readText(request,item,""String_Node_Str"",null,false,""String_Node_Str"");
  if (subInfo.submission.hasMultipleTitles()) {
    readText(request,item,""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  }
  if (subInfo.submission.isPublishedBefore()) {
    readDate(request,item,""String_Node_Str"",""String_Node_Str"");
  }
  readSeriesNumbers(request,item,""String_Node_Str"",""String_Node_Str"",true);
  readText(request,item,""String_Node_Str"",""String_Node_Str"",false,null);
  subInfo.submission.getItem().clearDC(""String_Node_Str"",Item.ANY,Item.ANY);
  List quals=getRepeatedParameter(request,""String_Node_Str"");
  List vals=getRepeatedParameter(request,""String_Node_Str"");
  for (int i=0; i < vals.size(); i++) {
    String thisQual=(String)quals.get(i);
    String thisVal=(String)vals.get(i);
    if (!buttonPressed.equals(""String_Node_Str"" + i) && !thisVal.equals(""String_Node_Str"")) {
      item.addDC(""String_Node_Str"",thisQual,null,thisVal);
    }
  }
  int nextStep=-1;
  if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (subInfo.submission.hasMultipleTitles() && buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    nextStep=INITIAL_QUESTIONS;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    userHasReached(subInfo,EDIT_METADATA_2);
    nextStep=EDIT_METADATA_2;
  }
 else   if (buttonPressed.indexOf(""String_Node_Str"") > -1) {
    nextStep=EDIT_METADATA_1;
  }
  subInfo.submission.update();
  if (nextStep != -1) {
    doStep(context,request,response,subInfo,nextStep);
  }
 else {
    doStepJump(context,request,response,subInfo);
  }
  context.complete();
}",0.9936518543267624
52609,"/** 
 * Set relevant DC fields in an item from name values in the form. Some fields are repeatable in the form.  If this is the case, and the field is ""contributor.author"", the names in the request will be from the fields as follows: contributor_author_last_0       -> last name of first author contributor_author_first_0      -> first name(s) of first author contributor_author_last_1       -> last name of second author contributor_author_first_1      -> first name(s) of second author and so on.  If the field is unqualified: contributor_last_0        -> last name of first contributor contributor_first_0       -> first name(s) of first contributor If the parameter ""submit_contributor_author_remove_n"" is set, that value is removed. Otherwise the parameters are of the form: contributor_author_last contributor_author_first The values will be put in separate DCValues, in the form ""last name, first name(s)"", ordered as they appear in the list. These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 */
private void readNames(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List firsts=new LinkedList();
  List lasts=new LinkedList();
  if (repeated) {
    firsts=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    lasts=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      firsts.remove(valToRemove);
      lasts.remove(valToRemove);
    }
  }
 else {
    String lastName=request.getParameter(dcname + ""String_Node_Str"");
    String firstNames=request.getParameter(dcname + ""String_Node_Str"");
    if (lastName != null && !lastName.equals(""String_Node_Str"")) {
      lasts.add(lastName);
      firsts.add(firstNames);
    }
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < lasts.size(); i++) {
    String f=((String)firsts.get(i)).trim();
    String l=((String)lasts.get(i)).trim();
    int comma=l.indexOf(',');
    if (comma >= 0) {
      f=f + l.substring(comma + 1);
      l=l.substring(0,comma);
      while (f.startsWith(""String_Node_Str"")) {
        f=f.substring(1);
      }
    }
    item.addDC(element,qualifier,null,new DCPersonName(l,f).toString());
  }
}","/** 
 * Set relevant DC fields in an item from name values in the form. Some fields are repeatable in the form.  If this is the case, and the field is ""contributor.author"", the names in the request will be from the fields as follows: contributor_author_last_0       -> last name of first author contributor_author_first_0      -> first name(s) of first author contributor_author_last_1       -> last name of second author contributor_author_first_1      -> first name(s) of second author and so on.  If the field is unqualified: contributor_last_0        -> last name of first contributor contributor_first_0       -> first name(s) of first contributor If the parameter ""submit_contributor_author_remove_n"" is set, that value is removed. Otherwise the parameters are of the form: contributor_author_last contributor_author_first The values will be put in separate DCValues, in the form ""last name, first name(s)"", ordered as they appear in the list. These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 */
private void readNames(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List firsts=new LinkedList();
  List lasts=new LinkedList();
  if (repeated) {
    firsts=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    lasts=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      firsts.remove(valToRemove);
      lasts.remove(valToRemove);
    }
  }
 else {
    String lastName=request.getParameter(dcname + ""String_Node_Str"");
    String firstNames=request.getParameter(dcname + ""String_Node_Str"");
    lasts.add(lastName);
    firsts.add(firstNames);
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < lasts.size(); i++) {
    String f=(String)firsts.get(i);
    String l=(String)lasts.get(i);
    if (l != null && !((l.trim()).equals(""String_Node_Str""))) {
      if (f == null) {
        f=""String_Node_Str"";
      }
      int comma=l.indexOf(',');
      if (comma >= 0) {
        f=f + l.substring(comma + 1);
        l=l.substring(0,comma);
        while (f.startsWith(""String_Node_Str"")) {
          f=f.substring(1);
        }
      }
      item.addDC(element,qualifier,null,new DCPersonName(l,f).toString());
    }
  }
}",0.9326222222222222
52610,"/** 
 * Set relevant DC fields in an item from series/number values in the form. Some fields are repeatable in the form.  If this is the case, and the field is ""relation.ispartof"", the names in the request will be from the fields as follows: relation_ispartof_series_0 relation_ispartof_number_0 relation_ispartof_series_1 relation_ispartof_number_1 and so on.  If the field is unqualified: relation_series_0 relation_number_0 Otherwise the parameters are of the form: relation_ispartof_series relation_ispartof_number The values will be put in separate DCValues, in the form ""last name, first name(s)"", ordered as they appear in the list. These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 */
private void readSeriesNumbers(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List series=new LinkedList();
  List numbers=new LinkedList();
  if (repeated) {
    series=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    numbers=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      series.remove(valToRemove);
      numbers.remove(valToRemove);
    }
  }
 else {
    String s=request.getParameter(dcname + ""String_Node_Str"");
    String n=request.getParameter(dcname + ""String_Node_Str"");
    if (s != null && !s.equals(""String_Node_Str"")) {
      series.add(s);
      numbers.add(n);
    }
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < series.size(); i++) {
    String s=((String)series.get(i)).trim();
    String n=((String)numbers.get(i)).trim();
    item.addDC(element,qualifier,null,new DCSeriesNumber(s,n).toString());
  }
}","/** 
 * Set relevant DC fields in an item from series/number values in the form. Some fields are repeatable in the form.  If this is the case, and the field is ""relation.ispartof"", the names in the request will be from the fields as follows: relation_ispartof_series_0 relation_ispartof_number_0 relation_ispartof_series_1 relation_ispartof_number_1 and so on.  If the field is unqualified: relation_series_0 relation_number_0 Otherwise the parameters are of the form: relation_ispartof_series relation_ispartof_number The values will be put in separate DCValues, in the form ""last name, first name(s)"", ordered as they appear in the list. These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 */
private void readSeriesNumbers(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List series=new LinkedList();
  List numbers=new LinkedList();
  if (repeated) {
    series=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    numbers=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      series.remove(valToRemove);
      numbers.remove(valToRemove);
    }
  }
 else {
    String s=request.getParameter(dcname + ""String_Node_Str"");
    String n=request.getParameter(dcname + ""String_Node_Str"");
    if (s != null && !s.equals(""String_Node_Str"")) {
      series.add(s);
      numbers.add(n);
    }
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < series.size(); i++) {
    String s=((String)series.get(i)).trim();
    String n=((String)numbers.get(i)).trim();
    if (!s.equals(""String_Node_Str"") || !n.equals(""String_Node_Str"")) {
      item.addDC(element,qualifier,null,new DCSeriesNumber(s,n).toString());
    }
  }
}",0.9824945295404814
52611,"/** 
 * Get repeated values from a form.  If ""foo"" is passed in, values in the form of parameters ""foo_0"", ""foo_1"", etc. are returned.
 * @param request   the HTTP request containing the form information
 * @param param     the repeated parameter
 * @return a List of Strings
 */
private List getRepeatedParameter(HttpServletRequest request,String param){
  List vals=new LinkedList();
  int i=0;
  boolean foundLast=false;
  while (!foundLast) {
    String s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s != null && !s.equals(""String_Node_Str"")) {
      vals.add(s);
    }
    foundLast=(s == null);
    i++;
  }
  return vals;
}","/** 
 * Get repeated values from a form.  If ""foo"" is passed in, values in the form of parameters ""foo_0"", ""foo_1"", etc. are returned.
 * @param request   the HTTP request containing the form information
 * @param param     the repeated parameter
 * @return a List of Strings
 */
private List getRepeatedParameter(HttpServletRequest request,String param){
  List vals=new LinkedList();
  int i=0;
  boolean foundLast=false;
  while (!foundLast) {
    String s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s != null) {
      vals.add(s);
    }
 else {
      foundLast=true;
    }
    i++;
  }
  return vals;
}",0.912667191188041
52612,"/** 
 * Create/update community metadata from a posted form
 * @param context     DSpace context
 * @param request     the HTTP request containing posted info
 * @param response    the HTTP response
 * @param community   the community to update (or null for creation)
 */
private void processConfirmEditCommunity(Context context,HttpServletRequest request,HttpServletResponse response,Community community) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"").equals(""String_Node_Str"")) {
    community=Community.create(context);
  }
  community.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  community.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  String intro=request.getParameter(""String_Node_Str"");
  if (intro.equals(""String_Node_Str"")) {
    intro=null;
  }
  String copy=request.getParameter(""String_Node_Str"");
  if (copy.equals(""String_Node_Str"")) {
    copy=null;
  }
  String side=request.getParameter(""String_Node_Str"");
  if (side.equals(""String_Node_Str"")) {
    side=null;
  }
  community.setMetadata(""String_Node_Str"",intro);
  community.setMetadata(""String_Node_Str"",copy);
  community.setMetadata(""String_Node_Str"",side);
  community.update();
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    community.setLogo(null);
    community.update();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    community.setLogo(null);
    community.update();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showControls(context,request,response);
  }
  context.complete();
}","/** 
 * Create/update community metadata from a posted form
 * @param context     DSpace context
 * @param request     the HTTP request containing posted info
 * @param response    the HTTP response
 * @param community   the community to update (or null for creation)
 */
private void processConfirmEditCommunity(Context context,HttpServletRequest request,HttpServletResponse response,Community community) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"").equals(""String_Node_Str"")) {
    community=Community.create(context);
    request.setAttribute(""String_Node_Str"",community);
  }
  community.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  community.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  String intro=request.getParameter(""String_Node_Str"");
  if (intro.equals(""String_Node_Str"")) {
    intro=null;
  }
  String copy=request.getParameter(""String_Node_Str"");
  if (copy.equals(""String_Node_Str"")) {
    copy=null;
  }
  String side=request.getParameter(""String_Node_Str"");
  if (side.equals(""String_Node_Str"")) {
    side=null;
  }
  community.setMetadata(""String_Node_Str"",intro);
  community.setMetadata(""String_Node_Str"",copy);
  community.setMetadata(""String_Node_Str"",side);
  community.update();
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    community.setLogo(null);
    community.update();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    community.setLogo(null);
    community.update();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showControls(context,request,response);
  }
  context.complete();
}",0.9845462208485528
52613,"/** 
 * Return the request that the system should be dealing with, given the request that the browse just sent.  If the incoming request is from a redirect resulting from successful authentication, a request object corresponding to the original request that prompted authentication is returned.  Otherwise, the request passed in is returned.
 * @param request   the incoming HTTP request
 * @return   the HTTP request the DSpace system should deal with
 */
public static HttpServletRequest getRealRequest(HttpServletRequest request){
  HttpSession session=request.getSession();
  if (session.getAttribute(""String_Node_Str"") != null) {
    log.info(""String_Node_Str"");
    RequestInfo requestInfo=(RequestInfo)session.getAttribute(""String_Node_Str"");
    HttpServletRequest actualRequest=requestInfo.wrapRequest(request);
    session.removeAttribute(""String_Node_Str"");
    session.removeAttribute(""String_Node_Str"");
    session.removeAttribute(""String_Node_Str"");
    return actualRequest;
  }
 else {
    return request;
  }
}","/** 
 * Return the request that the system should be dealing with, given the request that the browse just sent.  If the incoming request is from a redirect resulting from successful authentication, a request object corresponding to the original request that prompted authentication is returned.  Otherwise, the request passed in is returned.
 * @param request   the incoming HTTP request
 * @return   the HTTP request the DSpace system should deal with
 */
public static HttpServletRequest getRealRequest(HttpServletRequest request){
  HttpSession session=request.getSession();
  if (session.getAttribute(""String_Node_Str"") != null) {
    RequestInfo requestInfo=(RequestInfo)session.getAttribute(""String_Node_Str"");
    HttpServletRequest actualRequest;
    if (requestInfo == null) {
      actualRequest=request;
    }
 else {
      actualRequest=requestInfo.wrapRequest(request);
    }
    session.removeAttribute(""String_Node_Str"");
    session.removeAttribute(""String_Node_Str"");
    session.removeAttribute(""String_Node_Str"");
    return actualRequest;
  }
 else {
    return request;
  }
}",0.7947269303201506
52614,"/** 
 * Update the ResourcePolicy
 */
public void update() throws SQLException, AuthorizeException {
  DatabaseManager.update(myContext,myRow);
}","/** 
 * Update the ResourcePolicy
 */
public void update() throws SQLException {
  DatabaseManager.update(myContext,myRow);
}",0.925925925925926
52615,"/** 
 * Process information from ""enter new password""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processNewPassword(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String key=request.getParameter(""String_Node_Str"");
  EPerson eperson=AccountManager.getEPerson(context,key);
  if (eperson == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + key));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  boolean passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  if (passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,key);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
    request.setAttribute(""String_Node_Str"",key);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}","/** 
 * Process information from ""enter new password""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processNewPassword(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String key=request.getParameter(""String_Node_Str"");
  EPerson eperson=AccountManager.getEPerson(context,key);
  if (eperson == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + key));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  boolean passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  if (passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,key);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
    request.setAttribute(""String_Node_Str"",key);
    request.setAttribute(""String_Node_Str"",eperson);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}",0.9784289784289784
52616,"/** 
 * process input from initial-questions.jsp
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processInitialQuestions(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (buttonPressed.equals(""String_Node_Str"")) {
    doCancellation(request,response,subInfo,INITIAL_QUESTIONS,INITIAL_QUESTIONS);
    return;
  }
  boolean multipleTitles=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean publishedBefore=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean multipleFiles=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean isThesis=UIUtil.getBoolParameter(request,""String_Node_Str"");
  if (isWorkflow(subInfo)) {
    isThesis=false;
  }
  if (isThesis) {
    WorkspaceItem wi=(WorkspaceItem)subInfo.submission;
    wi.deleteAll();
    request.getSession().setAttribute(""String_Node_Str"",new Boolean(true));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
    return;
  }
  boolean willRemoveTitles=false;
  boolean willRemoveDate=false;
  boolean willRemoveFiles=false;
  if (multipleTitles == false) {
    DCValue[] altTitles=subInfo.submission.getItem().getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    willRemoveTitles=altTitles.length > 0;
  }
  if (publishedBefore == false) {
    DCValue[] dateIssued=subInfo.submission.getItem().getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    willRemoveDate=dateIssued.length > 0;
  }
  if (multipleFiles == false) {
    Bundle[] bundles=subInfo.submission.getItem().getBundles();
    willRemoveFiles=bundles.length > 1;
  }
  if (willRemoveTitles || willRemoveDate || willRemoveFiles) {
    request.setAttribute(""String_Node_Str"",subInfo);
    request.setAttribute(""String_Node_Str"",new Boolean(multipleTitles));
    request.setAttribute(""String_Node_Str"",new Boolean(publishedBefore));
    request.setAttribute(""String_Node_Str"",new Boolean(multipleFiles));
    request.setAttribute(""String_Node_Str"",new Boolean(willRemoveTitles));
    request.setAttribute(""String_Node_Str"",new Boolean(willRemoveDate));
    request.setAttribute(""String_Node_Str"",new Boolean(willRemoveFiles));
    request.setAttribute(""String_Node_Str"",UIUtil.getSubmitButton(request,""String_Node_Str""));
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    subInfo.submission.setMultipleTitles(multipleTitles);
    subInfo.submission.setPublishedBefore(publishedBefore);
    if (!isWorkflow(subInfo)) {
      subInfo.submission.setMultipleFiles(multipleFiles);
    }
    subInfo.submission.update();
    if (buttonPressed.equals(""String_Node_Str"")) {
      userHasReached(subInfo,EDIT_METADATA_1);
      doStep(context,request,response,subInfo,EDIT_METADATA_1);
    }
 else {
      doStepJump(context,request,response,subInfo);
    }
    context.complete();
  }
}","/** 
 * process input from initial-questions.jsp
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processInitialQuestions(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (buttonPressed.equals(""String_Node_Str"")) {
    doCancellation(request,response,subInfo,INITIAL_QUESTIONS,INITIAL_QUESTIONS);
    return;
  }
  boolean multipleTitles=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean publishedBefore=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean multipleFiles=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean isThesis=UIUtil.getBoolParameter(request,""String_Node_Str"");
  if (isWorkflow(subInfo)) {
    isThesis=false;
    multipleFiles=true;
  }
  if (isThesis) {
    WorkspaceItem wi=(WorkspaceItem)subInfo.submission;
    wi.deleteAll();
    request.getSession().setAttribute(""String_Node_Str"",new Boolean(true));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
    return;
  }
  boolean willRemoveTitles=false;
  boolean willRemoveDate=false;
  boolean willRemoveFiles=false;
  if (multipleTitles == false) {
    DCValue[] altTitles=subInfo.submission.getItem().getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    willRemoveTitles=altTitles.length > 0;
  }
  if (publishedBefore == false) {
    DCValue[] dateIssued=subInfo.submission.getItem().getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    willRemoveDate=dateIssued.length > 0;
  }
  if (multipleFiles == false) {
    Bundle[] bundles=subInfo.submission.getItem().getBundles();
    willRemoveFiles=bundles.length > 1;
  }
  if (willRemoveTitles || willRemoveDate || willRemoveFiles) {
    request.setAttribute(""String_Node_Str"",subInfo);
    request.setAttribute(""String_Node_Str"",new Boolean(multipleTitles));
    request.setAttribute(""String_Node_Str"",new Boolean(publishedBefore));
    request.setAttribute(""String_Node_Str"",new Boolean(multipleFiles));
    request.setAttribute(""String_Node_Str"",new Boolean(willRemoveTitles));
    request.setAttribute(""String_Node_Str"",new Boolean(willRemoveDate));
    request.setAttribute(""String_Node_Str"",new Boolean(willRemoveFiles));
    request.setAttribute(""String_Node_Str"",UIUtil.getSubmitButton(request,""String_Node_Str""));
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    subInfo.submission.setMultipleTitles(multipleTitles);
    subInfo.submission.setPublishedBefore(publishedBefore);
    if (!isWorkflow(subInfo)) {
      subInfo.submission.setMultipleFiles(multipleFiles);
    }
    subInfo.submission.update();
    if (buttonPressed.equals(""String_Node_Str"")) {
      userHasReached(subInfo,EDIT_METADATA_1);
      doStep(context,request,response,subInfo,EDIT_METADATA_1);
    }
 else {
      doStepJump(context,request,response,subInfo);
    }
    context.complete();
  }
}",0.9961928934010152
52617,"private static void doState(Context c,WorkflowItem wi,int newstate,EPerson newowner) throws SQLException, IOException, AuthorizeException {
  Collection mycollection=wi.getCollection();
  Group mygroup=null;
  wi.setState(newstate);
switch (newstate) {
case WFSTATE_REVIEWPOOL:
    wi.setOwner(null);
  mygroup=mycollection.getWorkflowGroup(1);
if (mygroup != null) {
  createTasks(c,wi,mygroup);
  wi.update();
  notifyGroupOfTask(c,mygroup,wi);
}
 else {
  doState(c,wi,WFSTATE_ADMINPOOL,null);
}
break;
case WFSTATE_REVIEW:
deleteTasks(c,wi);
wi.setOwner(newowner);
break;
case WFSTATE_ADMINPOOL:
wi.setOwner(null);
mygroup=mycollection.getWorkflowGroup(2);
if (mygroup != null) {
createTasks(c,wi,mygroup);
notifyGroupOfTask(c,mygroup,wi);
}
 else {
doState(c,wi,WFSTATE_EDITPOOL,null);
}
break;
case WFSTATE_ADMIN:
deleteTasks(c,wi);
wi.setOwner(newowner);
break;
case WFSTATE_EDITPOOL:
wi.setOwner(null);
mygroup=mycollection.getWorkflowGroup(3);
if (mygroup != null) {
createTasks(c,wi,mygroup);
notifyGroupOfTask(c,mygroup,wi);
}
 else {
doState(c,wi,WFSTATE_ARCHIVE,newowner);
}
break;
case WFSTATE_EDIT:
deleteTasks(c,wi);
wi.setOwner(newowner);
break;
case WFSTATE_ARCHIVE:
try {
deleteTasks(c,wi);
mycollection=wi.getCollection();
Item myitem=archive(c,wi);
notifyOfArchive(c,myitem,mycollection);
DSIndexer.indexItem(c,myitem);
}
 catch (IOException e) {
throw e;
}
catch (SQLException e) {
throw e;
}
break;
}
if (wi != null) wi.update();
}","private static void doState(Context c,WorkflowItem wi,int newstate,EPerson newowner) throws SQLException, IOException, AuthorizeException {
  Collection mycollection=wi.getCollection();
  Group mygroup=null;
  wi.setState(newstate);
switch (newstate) {
case WFSTATE_REVIEWPOOL:
    wi.setOwner(null);
  mygroup=mycollection.getWorkflowGroup(1);
if (mygroup != null) {
  createTasks(c,wi,mygroup);
  wi.update();
  notifyGroupOfTask(c,mygroup,wi);
}
 else {
  doState(c,wi,WFSTATE_ADMINPOOL,null);
}
break;
case WFSTATE_REVIEW:
deleteTasks(c,wi);
wi.setOwner(newowner);
break;
case WFSTATE_ADMINPOOL:
wi.setOwner(null);
mygroup=mycollection.getWorkflowGroup(2);
if (mygroup != null) {
createTasks(c,wi,mygroup);
notifyGroupOfTask(c,mygroup,wi);
}
 else {
doState(c,wi,WFSTATE_EDITPOOL,null);
}
break;
case WFSTATE_ADMIN:
deleteTasks(c,wi);
wi.setOwner(newowner);
break;
case WFSTATE_EDITPOOL:
wi.setOwner(null);
mygroup=mycollection.getWorkflowGroup(3);
if (mygroup != null) {
createTasks(c,wi,mygroup);
notifyGroupOfTask(c,mygroup,wi);
}
 else {
doState(c,wi,WFSTATE_ARCHIVE,newowner);
}
break;
case WFSTATE_EDIT:
deleteTasks(c,wi);
wi.setOwner(newowner);
break;
case WFSTATE_ARCHIVE:
try {
deleteTasks(c,wi);
mycollection=wi.getCollection();
Item myitem=archive(c,wi);
notifyOfArchive(c,myitem,mycollection);
}
 catch (IOException e) {
throw e;
}
catch (SQLException e) {
throw e;
}
break;
}
if (wi != null) wi.update();
}",0.989224887035106
52618,"/** 
 * Set the e-person that originally submitted this item.  This is a public method since it is handled by the WorkspaceItem class in the ingest package. <code>update</code> must be called to write the change to the database.
 * @param sub  the submitter
 */
public void setSubmitter(EPerson sub){
  submitter=sub;
}","/** 
 * Set the e-person that originally submitted this item.  This is a public method since it is handled by the WorkspaceItem class in the ingest package. <code>update</code> must be called to write the change to the database.
 * @param sub  the submitter
 */
public void setSubmitter(EPerson sub){
  submitter=sub;
  if (submitter != null) {
    itemRow.setColumn(""String_Node_Str"",submitter.getID());
  }
 else {
    itemRow.setColumnNull(""String_Node_Str"");
  }
}",0.8106734434561627
52619,"protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  processRequest(request,response,true);
}","protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  processRequest(request,response);
}",0.984126984126984
52620,"protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  processRequest(request,response,false);
}","protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  processRequest(request,response);
}",0.9808917197452228
52621,"/** 
 * Process an incoming request
 * @param request    the request object
 * @param response   the response object
 * @param isPost     if true, this is a POST
 */
private void processRequest(HttpServletRequest request,HttpServletResponse response,boolean isPost) throws ServletException, IOException {
  Context context=null;
  UIUtil.storeOriginalURL(request);
  try {
    context=UIUtil.obtainContext(request);
    request=Authenticate.getRealRequest(request);
    if (isPost) {
      doDSPost(context,request,response);
    }
 else {
      doDSGet(context,request,response);
    }
  }
 catch (  SQLException se) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",se.toString()),se);
    UIUtil.sendAlert(request,se);
    JSPManager.showInternalError(request,response);
  }
catch (  AuthorizeException ae) {
    if (context.getCurrentUser() == null) {
      Authenticate.startAuthentication(context,request,response);
    }
 else {
      log.info(LogManager.getHeader(context,""String_Node_Str"",ae.toString()));
      JSPManager.showAuthorizeError(request,response,ae);
    }
  }
  if (context != null && context.isValid()) {
    context.abort();
  }
}","/** 
 * Process an incoming request
 * @param request    the request object
 * @param response   the response object
 */
private void processRequest(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  Context context=null;
  UIUtil.storeOriginalURL(request);
  try {
    context=UIUtil.obtainContext(request);
    request=Authenticate.getRealRequest(request);
    if (log.isDebugEnabled()) {
      log.debug(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
    }
    if (request.getMethod().equals(""String_Node_Str"")) {
      doDSPost(context,request,response);
    }
 else {
      doDSGet(context,request,response);
    }
  }
 catch (  SQLException se) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",se.toString()),se);
    UIUtil.sendAlert(request,se);
    JSPManager.showInternalError(request,response);
  }
catch (  AuthorizeException ae) {
    if (context.getCurrentUser() == null) {
      Authenticate.startAuthentication(context,request,response);
    }
 else {
      log.info(LogManager.getHeader(context,""String_Node_Str"",ae.toString()));
      JSPManager.showAuthorizeError(request,response,ae);
    }
  }
  if (context != null && context.isValid()) {
    context.abort();
  }
}",0.8984088127294981
52622,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  X509Certificate[] certs=(X509Certificate[])request.getAttribute(""String_Node_Str"");
  if (certs.length == 0) {
    if (request.getParameter(""String_Node_Str"") != null) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else {
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    try {
      if (X509Manager.isValid(certs[0])) {
        EPerson eperson=X509Manager.getUser(context,certs[0]);
        if (eperson != null && eperson.getActive()) {
          Authenticate.loggedIn(context,request,eperson);
          log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          Authenticate.resumeInterruptedRequest(request,response);
          return;
        }
 else {
          log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          JSPManager.showJSP(request,response,""String_Node_Str"");
        }
      }
 else {
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
        JSPManager.showJSP(request,response,""String_Node_Str"");
      }
    }
 catch (    CertificateException ce) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),ce);
      JSPManager.showInternalError(request,response);
    }
  }
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  X509Certificate[] certs=(X509Certificate[])request.getAttribute(""String_Node_Str"");
  if (certs == null || certs.length == 0) {
    if (request.getParameter(""String_Node_Str"") != null) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else {
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    try {
      if (X509Manager.isValid(certs[0])) {
        EPerson eperson=X509Manager.getUser(context,certs[0]);
        if (eperson != null && eperson.getActive()) {
          Authenticate.loggedIn(context,request,eperson);
          log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          Authenticate.resumeInterruptedRequest(request,response);
          return;
        }
 else {
          log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          JSPManager.showJSP(request,response,""String_Node_Str"");
        }
      }
 else {
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
        JSPManager.showJSP(request,response,""String_Node_Str"");
      }
    }
 catch (    CertificateException ce) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),ce);
      JSPManager.showInternalError(request,response);
    }
  }
}",0.994475138121547
52623,"/** 
 * Return the request that the system should be dealing with, given the request that the browse just sent.  If the incoming request is from a redirect resulting from successful authentication, a request object corresponding to the original request that prompted authentication is returned.  Otherwise, the request passed in is returned.
 * @param request   the incoming HTTP request
 * @return   the HTTP request the DSpace system should deal with
 */
public static HttpServletRequest getRealRequest(HttpServletRequest request){
  HttpSession session=request.getSession();
  if (session.getAttribute(""String_Node_Str"") != null) {
    HttpServletRequest actualRequest=(HttpServletRequest)session.getAttribute(""String_Node_Str"");
    session.removeAttribute(""String_Node_Str"");
    session.removeAttribute(""String_Node_Str"");
    return actualRequest;
  }
 else {
    return request;
  }
}","/** 
 * Return the request that the system should be dealing with, given the request that the browse just sent.  If the incoming request is from a redirect resulting from successful authentication, a request object corresponding to the original request that prompted authentication is returned.  Otherwise, the request passed in is returned.
 * @param request   the incoming HTTP request
 * @return   the HTTP request the DSpace system should deal with
 */
public static HttpServletRequest getRealRequest(HttpServletRequest request){
  HttpSession session=request.getSession();
  if (session.getAttribute(""String_Node_Str"") != null) {
    log.info(""String_Node_Str"");
    RequestInfo requestInfo=(RequestInfo)session.getAttribute(""String_Node_Str"");
    HttpServletRequest actualRequest=requestInfo.wrapRequest(request);
    session.removeAttribute(""String_Node_Str"");
    session.removeAttribute(""String_Node_Str"");
    session.removeAttribute(""String_Node_Str"");
    return actualRequest;
  }
 else {
    return request;
  }
}",0.8510416666666667
52624,"/** 
 * Start the authentication process.  This packages up the request that led to authentication being required, and then invokes the site-specific authentication method.
 * @param context   current DSpace context
 * @param request   current HTTP request - the one that promptedauthentication
 * @param response  current HTTP response
 */
public static void startAuthentication(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  HttpSession session=request.getSession();
  RequestMimic mimic=new RequestMimic(request);
  session.setAttribute(""String_Node_Str"",mimic);
  session.setAttribute(""String_Node_Str"",UIUtil.getOriginalURL(request));
  String siteAuthClassName=ConfigurationManager.getProperty(""String_Node_Str"");
  SiteAuthenticator siteAuth;
  try {
    Class siteAuthClass=Class.forName(siteAuthClassName);
    siteAuth=(SiteAuthenticator)siteAuthClass.newInstance();
  }
 catch (  Exception e) {
    if (siteAuthClassName == null) {
      siteAuthClassName=""String_Node_Str"";
    }
    log.fatal(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + siteAuthClassName),e);
    throw new ServletException(e);
  }
  siteAuth.startAuthentication(context,request,response);
}","/** 
 * Start the authentication process.  This packages up the request that led to authentication being required, and then invokes the site-specific authentication method.
 * @param context   current DSpace context
 * @param request   current HTTP request - the one that promptedauthentication
 * @param response  current HTTP response
 */
public static void startAuthentication(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  HttpSession session=request.getSession();
  RequestInfo info=new RequestInfo(request);
  session.setAttribute(""String_Node_Str"",info);
  session.setAttribute(""String_Node_Str"",UIUtil.getOriginalURL(request));
  String siteAuthClassName=ConfigurationManager.getProperty(""String_Node_Str"");
  SiteAuthenticator siteAuth;
  try {
    Class siteAuthClass=Class.forName(siteAuthClassName);
    siteAuth=(SiteAuthenticator)siteAuthClass.newInstance();
  }
 catch (  Exception e) {
    if (siteAuthClassName == null) {
      siteAuthClassName=""String_Node_Str"";
    }
    log.fatal(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + siteAuthClassName),e);
    throw new ServletException(e);
  }
  siteAuth.startAuthentication(context,request,response);
}",0.9849086576648134
52625,"/** 
 * Set the EPerson's password
 * @param s   the new email
 */
public void setPassword(String s){
  String encoded=encodePassword(s);
  myRow.setColumn(""String_Node_Str"",encoded);
}","/** 
 * Set the EPerson's password
 * @param s   the new email
 */
public void setPassword(String s){
  String encoded=Utils.getMD5(s);
  myRow.setColumn(""String_Node_Str"",encoded);
}",0.9347826086956522
52626,"/** 
 * Check EPerson's password
 * @param attempt the password attempt
 * @return boolean successful/unsuccessful
 */
public boolean checkPassword(String attempt){
  String encoded=encodePassword(attempt);
  if (attempt.equals(myRow.getStringColumn(""String_Node_Str"")))   return true;
  return false;
}","/** 
 * Check EPerson's password
 * @param attempt the password attempt
 * @return boolean successful/unsuccessful
 */
public boolean checkPassword(String attempt){
  String encoded=Utils.getMD5(attempt);
  return (encoded.equals(myRow.getStringColumn(""String_Node_Str"")));
}",0.8581314878892734
52627,"/** 
 * Construct an item with the given table row
 * @param context  the context this object exists in
 * @param row      the corresponding row in the table
 */
Item(Context context,TableRow row) throws SQLException {
  ourContext=context;
  itemRow=row;
  dublinCoreChanged=false;
  dublinCore=new ArrayList();
  bundlesChanged=false;
  bundles=new ArrayList();
  submitter=null;
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow r=(TableRow)tri.next();
    bundles.add(new Bundle(ourContext,r));
  }
  tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str""));
  while (tri.hasNext()) {
    TableRow resultRow=(TableRow)tri.next();
    TableRow typeRow=DatabaseManager.find(ourContext,""String_Node_Str"",resultRow.getIntColumn(""String_Node_Str""));
    DCValue dcv=new DCValue();
    dcv.element=typeRow.getStringColumn(""String_Node_Str"");
    dcv.qualifier=typeRow.getStringColumn(""String_Node_Str"");
    dcv.value=resultRow.getStringColumn(""String_Node_Str"");
    dcv.language=resultRow.getStringColumn(""String_Node_Str"");
    dublinCore.add(dcv);
  }
}","/** 
 * Construct an item with the given table row
 * @param context  the context this object exists in
 * @param row      the corresponding row in the table
 */
Item(Context context,TableRow row) throws SQLException {
  ourContext=context;
  itemRow=row;
  dublinCoreChanged=false;
  dublinCore=new ArrayList();
  bundlesChanged=false;
  bundles=new ArrayList();
  submitter=null;
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow r=(TableRow)tri.next();
    bundles.add(new Bundle(ourContext,r));
  }
  tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow resultRow=(TableRow)tri.next();
    TableRow typeRow=DatabaseManager.find(ourContext,""String_Node_Str"",resultRow.getIntColumn(""String_Node_Str""));
    DCValue dcv=new DCValue();
    dcv.element=typeRow.getStringColumn(""String_Node_Str"");
    dcv.qualifier=typeRow.getStringColumn(""String_Node_Str"");
    dcv.value=resultRow.getStringColumn(""String_Node_Str"");
    dcv.language=resultRow.getStringColumn(""String_Node_Str"");
    dublinCore.add(dcv);
  }
}",0.9923605805958748
52628,"/** 
 * Clear Dublin Core metadata values.  As with <code>addDC</code> above, passing in <code>null</code> only matches fields where the qualifier or language is actually <code>null</code>.  <code>Item.ANY</code> will match any element, qualifier or language, including <code>null</code>. Thus, <code>item.clearDC(Item.ANY, Item.ANY, Item.ANY)</code> will remove all Dublin Core metadata associated with an item.
 * @param element     the Dublin Core element to remove, or<code>Item.ANY</code>
 * @param qualifier   the qualifier.  <code>null</code> means unqualified,and <code>Item.ANY</code> means any qualifier (including unqualified.)
 * @param lang       the ISO639 language code, optionally followed byan underscore and the ISO3166 country code. <code>null</code> means only values with no language are removed, and <code>Item.ANY</code> means values with any country code or no country code are removed.
 */
public void clearDC(String element,String qualifier,String lang) throws AuthorizeException {
  List values=new ArrayList();
  Iterator i=dublinCore.iterator();
  while (i.hasNext()) {
    DCValue dcv=(DCValue)i.next();
    if (!match(element,qualifier,lang,dcv)) {
      values.add(dcv.value);
    }
  }
  dublinCore=values;
}","/** 
 * Clear Dublin Core metadata values.  As with <code>addDC</code> above, passing in <code>null</code> only matches fields where the qualifier or language is actually <code>null</code>.  <code>Item.ANY</code> will match any element, qualifier or language, including <code>null</code>. Thus, <code>item.clearDC(Item.ANY, Item.ANY, Item.ANY)</code> will remove all Dublin Core metadata associated with an item.
 * @param element     the Dublin Core element to remove, or<code>Item.ANY</code>
 * @param qualifier   the qualifier.  <code>null</code> means unqualified,and <code>Item.ANY</code> means any qualifier (including unqualified.)
 * @param lang       the ISO639 language code, optionally followed byan underscore and the ISO3166 country code. <code>null</code> means only values with no language are removed, and <code>Item.ANY</code> means values with any country code or no country code are removed.
 */
public void clearDC(String element,String qualifier,String lang) throws AuthorizeException {
  List values=new ArrayList();
  Iterator i=dublinCore.iterator();
  while (i.hasNext()) {
    DCValue dcv=(DCValue)i.next();
    if (!match(element,qualifier,lang,dcv)) {
      values.add(dcv);
    }
  }
  dublinCore=values;
}",0.9975767366720516
52629,"/** 
 * Assign an ID to row
 */
private static synchronized void assignId(TableRow row) throws SQLException {
  String table=canonicalize(row.getTable());
  String pk=getPrimaryKeyColumn(table);
  Integer id=(Integer)ids.get(table);
  int nid=id == null ? -1 : id.intValue() + 1;
  if (id == null) {
    String sql=MessageFormat.format(""String_Node_Str"",new Object[]{pk,table});
    Statement statement=null;
    try {
      statement=getConnection().createStatement();
      ResultSet results=statement.executeQuery(sql);
      nid=results.next() ? results.getInt(1) : -1;
    }
  finally {
      if (statement != null) {
        try {
          statement.close();
        }
 catch (        SQLException sqle) {
        }
      }
    }
  }
  row.setColumn(pk,nid);
  ids.put(table,new Integer(nid));
}","/** 
 * Assign an ID to row
 */
private static synchronized void assignId(TableRow row) throws SQLException {
  String table=canonicalize(row.getTable());
  String pk=getPrimaryKeyColumn(table);
  Integer id=(Integer)ids.get(table);
  int current_id=id == null ? -1 : id.intValue();
  if (id == null) {
    String sql=MessageFormat.format(""String_Node_Str"",new Object[]{pk,table});
    Statement statement=null;
    try {
      statement=getConnection().createStatement();
      ResultSet results=statement.executeQuery(sql);
      current_id=results.next() ? results.getInt(1) : -1;
    }
  finally {
      if (statement != null) {
        try {
          statement.close();
        }
 catch (        SQLException sqle) {
        }
      }
    }
  }
  int new_id=current_id + 1;
  row.setColumn(pk,new_id);
  ids.put(table,new Integer(new_id));
}",0.96543359611886
52630,"private Response upload0() throws QiniuException {
  if (host == null) {
    this.host=configuration.upHost(upToken);
  }
  long uploaded=0;
  int ret=0;
  boolean retry=false;
  int contextIndex=0;
  while (size == 0) {
    int bufferIndex=0;
    int blockSize=0;
    while (ret != -1 && bufferIndex != blockBuffer.length) {
      try {
        blockSize=blockBuffer.length - bufferIndex;
        ret=stream.read(blockBuffer,bufferIndex,blockSize);
      }
 catch (      IOException e) {
        close();
        throw new QiniuException(e);
      }
      if (ret != -1) {
        bufferIndex+=ret;
        if (ret == 0) {
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
 else {
        size=uploaded + bufferIndex;
      }
    }
    long crc=Crc32.bytes(blockBuffer,0,blockSize);
    Response response=null;
    QiniuException temp=null;
    try {
      response=makeBlock(blockBuffer,bufferIndex);
    }
 catch (    QiniuException e) {
      if (e.code() < 0) {
        host=configuration.upHostBackup(upToken);
      }
      if (e.response == null || e.response.needRetry()) {
        retry=true;
        temp=e;
      }
 else {
        close();
        throw e;
      }
    }
    if (!retry) {
      ResumeBlockInfo blockInfo0=response.jsonToObject(ResumeBlockInfo.class);
      if (blockInfo0.crc32 != crc) {
        retry=true;
        temp=new QiniuException(new Exception(""String_Node_Str""));
      }
    }
    if (retry) {
      if (retryMax > 0) {
        retryMax--;
        try {
          response=makeBlock(blockBuffer,bufferIndex);
          retry=false;
        }
 catch (        QiniuException e) {
          close();
          throw e;
        }
      }
 else {
        throw temp;
      }
    }
    ResumeBlockInfo blockInfo=response.jsonToObject(ResumeBlockInfo.class);
    contexts.add(blockInfo.ctx);
    uploaded+=bufferIndex;
  }
  close();
  try {
    return makeFile();
  }
 catch (  QiniuException e) {
    try {
      return makeFile();
    }
 catch (    QiniuException e1) {
      throw e1;
    }
  }
}","private Response upload0() throws QiniuException {
  if (host == null) {
    this.host=configuration.upHost(upToken);
  }
  long uploaded=0;
  int ret=0;
  boolean retry=false;
  while (size == 0) {
    int bufferIndex=0;
    int blockSize=0;
    while (ret != -1 && bufferIndex != blockBuffer.length) {
      try {
        blockSize=blockBuffer.length - bufferIndex;
        ret=stream.read(blockBuffer,bufferIndex,blockSize);
      }
 catch (      IOException e) {
        close();
        throw new QiniuException(e);
      }
      if (ret != -1) {
        bufferIndex+=ret;
        if (ret == 0) {
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
 else {
        size=uploaded + bufferIndex;
      }
    }
    long crc=Crc32.bytes(blockBuffer,0,bufferIndex);
    Response response=null;
    QiniuException temp=null;
    try {
      response=makeBlock(blockBuffer,bufferIndex);
    }
 catch (    QiniuException e) {
      if (e.code() < 0) {
        host=configuration.upHostBackup(upToken);
      }
      if (e.response == null || e.response.needRetry()) {
        retry=true;
        temp=e;
      }
 else {
        close();
        throw e;
      }
    }
    if (!retry) {
      ResumeBlockInfo blockInfo0=response.jsonToObject(ResumeBlockInfo.class);
      if (blockInfo0.crc32 != crc) {
        retry=true;
        temp=new QiniuException(new Exception(""String_Node_Str""));
      }
    }
    if (retry) {
      if (retryMax > 0) {
        retryMax--;
        try {
          response=makeBlock(blockBuffer,bufferIndex);
          retry=false;
        }
 catch (        QiniuException e) {
          close();
          throw e;
        }
      }
 else {
        throw temp;
      }
    }
    ResumeBlockInfo blockInfo=response.jsonToObject(ResumeBlockInfo.class);
    contexts.add(blockInfo.ctx);
    uploaded+=bufferIndex;
  }
  close();
  try {
    return makeFile();
  }
 catch (  QiniuException e) {
    try {
      return makeFile();
    }
 catch (    QiniuException e1) {
      throw e1;
    }
  }
}",0.9906542056074766
52631,"private Response upload0() throws QiniuException {
  if (host == null) {
    this.host=configuration.upHost(upToken);
  }
  long uploaded=0;
  int ret=0;
  boolean retry=false;
  while (size == 0) {
    int bufferIndex=0;
    int blockSize=0;
    while (ret != -1 && bufferIndex != blockBuffer.length) {
      try {
        blockSize=blockBuffer.length - bufferIndex;
        ret=stream.read(blockBuffer,bufferIndex,blockSize);
      }
 catch (      IOException e) {
        close();
        throw new QiniuException(e);
      }
      if (ret != -1) {
        bufferIndex+=ret;
        if (ret == 0) {
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
 else {
        size=uploaded + bufferIndex;
      }
    }
    long crc=Crc32.bytes(blockBuffer,0,bufferIndex);
    Response response=null;
    QiniuException temp=null;
    try {
      response=makeBlock(blockBuffer,bufferIndex);
    }
 catch (    QiniuException e) {
      if (e.code() < 0) {
        host=configuration.upHostBackup(upToken);
      }
      if (e.response == null || e.response.needRetry()) {
        retry=true;
        temp=e;
      }
 else {
        close();
        throw e;
      }
    }
    if (!retry) {
      ResumeBlockInfo blockInfo0=response.jsonToObject(ResumeBlockInfo.class);
      if (blockInfo0.crc32 != crc) {
        retry=true;
        temp=new QiniuException(new Exception(""String_Node_Str""));
      }
    }
    if (retry) {
      if (retryMax > 0) {
        retryMax--;
        try {
          response=makeBlock(blockBuffer,bufferIndex);
          retry=false;
        }
 catch (        QiniuException e) {
          close();
          throw e;
        }
      }
 else {
        throw temp;
      }
    }
    ResumeBlockInfo blockInfo=response.jsonToObject(ResumeBlockInfo.class);
    contexts.add(blockInfo.ctx);
    uploaded+=bufferIndex;
  }
  close();
  try {
    return makeFile();
  }
 catch (  QiniuException e) {
    try {
      return makeFile();
    }
 catch (    QiniuException e1) {
      throw e1;
    }
  }
}","private Response upload0() throws QiniuException {
  if (host == null) {
    this.host=configuration.upHost(upToken);
  }
  long uploaded=0;
  int ret=0;
  boolean retry=false;
  boolean eof=false;
  while (size == 0 && !eof) {
    int bufferIndex=0;
    int blockSize=0;
    while (ret != -1 && bufferIndex != blockBuffer.length) {
      try {
        blockSize=blockBuffer.length - bufferIndex;
        ret=stream.read(blockBuffer,bufferIndex,blockSize);
      }
 catch (      IOException e) {
        close();
        throw new QiniuException(e);
      }
      if (ret != -1) {
        bufferIndex+=ret;
        if (ret == 0) {
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
 else {
        eof=true;
        size=uploaded + bufferIndex;
      }
    }
    long crc=Crc32.bytes(blockBuffer,0,bufferIndex);
    Response response=null;
    QiniuException temp=null;
    try {
      response=makeBlock(blockBuffer,bufferIndex);
    }
 catch (    QiniuException e) {
      if (e.code() < 0) {
        host=configuration.upHostBackup(upToken);
      }
      if (e.response == null || e.response.needRetry()) {
        retry=true;
        temp=e;
      }
 else {
        close();
        throw e;
      }
    }
    if (!retry) {
      ResumeBlockInfo blockInfo0=response.jsonToObject(ResumeBlockInfo.class);
      if (blockInfo0.crc32 != crc) {
        retry=true;
        temp=new QiniuException(new Exception(""String_Node_Str""));
      }
    }
    if (retry) {
      if (retryMax > 0) {
        retryMax--;
        try {
          response=makeBlock(blockBuffer,bufferIndex);
          retry=false;
        }
 catch (        QiniuException e) {
          close();
          throw e;
        }
      }
 else {
        throw temp;
      }
    }
    ResumeBlockInfo blockInfo=response.jsonToObject(ResumeBlockInfo.class);
    contexts.add(blockInfo.ctx);
    uploaded+=bufferIndex;
  }
  close();
  try {
    return makeFile();
  }
 catch (  QiniuException e) {
    try {
      return makeFile();
    }
 catch (    QiniuException e1) {
      throw e1;
    }
  }
}",0.9890875319247736
52632,"/** 
 * 生成HTTP请求签名字符串
 * @param urlString
 * @param body
 * @param contentType
 * @return
 */
public String signRequestV2(String urlString,String method,byte[] body,String contentType){
  URI uri=URI.create(urlString);
  Mac mac=createMac();
  StringBuilder sb=new StringBuilder();
  sb.append(String.format(""String_Node_Str"",method,uri.getPath()));
  if (uri.getQuery() != null) {
    sb.append(String.format(""String_Node_Str"",uri.getQuery()));
  }
  sb.append(String.format(""String_Node_Str"",uri.getHost()));
  if (uri.getPort() > 0) {
    sb.append(String.format(""String_Node_Str"",uri.getPort()));
  }
  if (contentType != null) {
    sb.append(String.format(""String_Node_Str"",contentType));
  }
  sb.append(""String_Node_Str"");
  if (body != null && body.length > 0 && !StringUtils.isNullOrEmpty(contentType)) {
    if (contentType.equals(Client.FormMime) || contentType.equals(Client.JsonMime)) {
      sb.append(new String(body));
    }
  }
  mac.update(StringUtils.utf8Bytes(sb.toString()));
  String digest=UrlSafeBase64.encodeToString(mac.doFinal());
  return this.accessKey + ""String_Node_Str"" + digest;
}","/** 
 * 生成HTTP请求签名字符串
 * @param urlString
 * @param body
 * @param contentType
 * @return
 */
public String signRequestV2(String urlString,String method,byte[] body,String contentType){
  URI uri=URI.create(urlString);
  Mac mac=createMac();
  StringBuilder sb=new StringBuilder();
  sb.append(String.format(""String_Node_Str"",method,uri.getPath()));
  if (uri.getQuery() != null) {
    sb.append(String.format(""String_Node_Str"",uri.getQuery()));
  }
  sb.append(String.format(""String_Node_Str"",uri.getHost()));
  if (uri.getPort() > 0) {
    sb.append(String.format(""String_Node_Str"",uri.getPort()));
  }
  if (contentType != null) {
    sb.append(String.format(""String_Node_Str"",contentType));
  }
  sb.append(""String_Node_Str"");
  if (body != null && body.length > 0 && !StringUtils.isNullOrEmpty(contentType)) {
    if (contentType.equals(Client.FormMime) || contentType.equals(Client.JsonMime)) {
      sb.append(new String(body));
    }
  }
  System.out.println(sb.toString());
  mac.update(StringUtils.utf8Bytes(sb.toString()));
  String digest=UrlSafeBase64.encodeToString(mac.doFinal());
  return this.accessKey + ""String_Node_Str"" + digest;
}",0.983664459161148
52633,"/** 
 * 生成HTTP请求签名字符串
 * @param urlString
 * @param body
 * @param contentType
 * @return
 */
public String signRequest(String urlString,byte[] body,String contentType){
  URI uri=URI.create(urlString);
  String path=uri.getRawPath();
  String query=uri.getRawQuery();
  Mac mac=createMac();
  mac.update(StringUtils.utf8Bytes(path));
  if (query != null && query.length() != 0) {
    mac.update((byte)('?'));
    mac.update(StringUtils.utf8Bytes(query));
  }
  mac.update((byte)'\n');
  if (body != null && body.length > 0 && !StringUtils.isNullOrEmpty(contentType)) {
    if (contentType.equals(Client.FormMime) || contentType.equals(Client.JsonMime)) {
      mac.update(body);
    }
  }
  String digest=UrlSafeBase64.encodeToString(mac.doFinal());
  return this.accessKey + ""String_Node_Str"" + digest;
}","/** 
 * 生成HTTP请求签名字符串
 * @param urlString
 * @param body
 * @param contentType
 * @return
 */
public String signRequest(String urlString,byte[] body,String contentType){
  URI uri=URI.create(urlString);
  String path=uri.getRawPath();
  String query=uri.getRawQuery();
  Mac mac=createMac();
  mac.update(StringUtils.utf8Bytes(path));
  if (query != null && query.length() != 0) {
    mac.update((byte)('?'));
    mac.update(StringUtils.utf8Bytes(query));
  }
  mac.update((byte)'\n');
  if (body != null && Client.FormMime.equalsIgnoreCase(contentType)) {
    mac.update(body);
  }
  String digest=UrlSafeBase64.encodeToString(mac.doFinal());
  return this.accessKey + ""String_Node_Str"" + digest;
}",0.8637873754152824
52634,"@Test public void testCreateTimestampAntiLeechUrlWithQueryString(){
  String host=""String_Node_Str"";
  String fileName=""String_Node_Str"";
  String queryString=""String_Node_Str"";
  long deadline=System.currentTimeMillis() / 1000 + 3600;
  String encryptKey=""String_Node_Str"";
  String signedUrl;
  try {
    signedUrl=CdnManager.ceateTimestampAntiLeechUrl(host,fileName,queryString,encryptKey,deadline);
    System.out.println(signedUrl);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    Assert.fail();
  }
}","@Test public void testCreateTimestampAntiLeechUrlWithQueryString(){
  String host=""String_Node_Str"";
  String fileName=""String_Node_Str"";
  String queryString=""String_Node_Str"";
  long deadline=System.currentTimeMillis() / 1000 + 3600;
  String encryptKey=""String_Node_Str"";
  String signedUrl;
  try {
    signedUrl=CdnManager.createTimestampAntiLeechUrl(host,fileName,queryString,encryptKey,deadline);
    System.out.println(signedUrl);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    Assert.fail();
  }
}",0.9990356798457088
52635,"@Test public void testCreateTimestampAntiLeechUrlSimple(){
  String host=""String_Node_Str"";
  String fileName=""String_Node_Str"";
  String queryString=""String_Node_Str"";
  long deadline=System.currentTimeMillis() / 1000 + 3600;
  String encryptKey=""String_Node_Str"";
  String signedUrl;
  try {
    signedUrl=CdnManager.ceateTimestampAntiLeechUrl(host,fileName,queryString,encryptKey,deadline);
    System.out.println(signedUrl);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    Assert.fail();
  }
}","@Test public void testCreateTimestampAntiLeechUrlSimple(){
  String host=""String_Node_Str"";
  String fileName=""String_Node_Str"";
  String queryString=""String_Node_Str"";
  long deadline=System.currentTimeMillis() / 1000 + 3600;
  String encryptKey=""String_Node_Str"";
  String signedUrl;
  try {
    signedUrl=CdnManager.createTimestampAntiLeechUrl(host,fileName,queryString,encryptKey,deadline);
    System.out.println(signedUrl);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    Assert.fail();
  }
}",0.9990186457311088
52636,"private static PutRet putStream(String uptoken,String key,InputStream reader,PutExtra extra){
  MultipartEntity requestEntity=new MultipartEntity();
  try {
    requestEntity.addPart(""String_Node_Str"",new StringBody(uptoken));
    AbstractContentBody inputBody=buildInputStreamBody(reader,extra,key);
    requestEntity.addPart(""String_Node_Str"",inputBody);
    setKey(requestEntity,key);
    setParam(requestEntity,extra.params);
    if (extra.checkCrc != NO_CRC32) {
      if (extra.crc32 == 0) {
        return new PutRet(new CallRet(400,new Exception(""String_Node_Str"")));
      }
      requestEntity.addPart(""String_Node_Str"",new StringBody(extra.crc32 + ""String_Node_Str""));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    return new PutRet(new CallRet(400,e));
  }
  String url=Config.UP_HOST;
  CallRet ret=new Client().callWithMultiPart(url,requestEntity);
  return new PutRet(ret);
}","private static PutRet putStream(String uptoken,String key,InputStream reader,PutExtra extra,String fileName){
  MultipartEntity requestEntity=new MultipartEntity();
  try {
    requestEntity.addPart(""String_Node_Str"",new StringBody(uptoken));
    AbstractContentBody inputBody=buildInputStreamBody(reader,extra,fileName != null ? fileName : ""String_Node_Str"");
    requestEntity.addPart(""String_Node_Str"",inputBody);
    setKey(requestEntity,key);
    setParam(requestEntity,extra.params);
    if (extra.checkCrc != NO_CRC32) {
      if (extra.crc32 == 0) {
        return new PutRet(new CallRet(400,new Exception(""String_Node_Str"")));
      }
      requestEntity.addPart(""String_Node_Str"",new StringBody(extra.crc32 + ""String_Node_Str""));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    return new PutRet(new CallRet(400,e));
  }
  String url=Config.UP_HOST;
  CallRet ret=new Client().callWithMultiPart(url,requestEntity);
  return new PutRet(ret);
}",0.964818763326226
52637,"private static InputStreamBody buildInputStreamBody(InputStream reader,PutExtra extra,String key){
  if (extra.mimeType != null) {
    return new InputStreamBody(reader,extra.mimeType,key);
  }
 else {
    return new InputStreamBody(reader,key);
  }
}","private static InputStreamBody buildInputStreamBody(InputStream reader,PutExtra extra,String fileName){
  if (extra.mimeType != null) {
    return new InputStreamBody(reader,extra.mimeType,fileName);
  }
 else {
    return new InputStreamBody(reader,fileName);
  }
}",0.9361702127659576
52638,"private static PutRet put(String uptoken,String key,File file,PutExtra extra){
  if (!file.exists() || !file.canRead()) {
    return new PutRet(new CallRet(400,new Exception(""String_Node_Str"")));
  }
  MultipartEntity requestEntity=new MultipartEntity();
  try {
    requestEntity.addPart(""String_Node_Str"",new StringBody(uptoken));
    AbstractContentBody fileBody=buildFileBody(file,extra);
    requestEntity.addPart(""String_Node_Str"",fileBody);
    setKey(requestEntity,key);
    setParam(requestEntity,extra.params);
    if (extra.checkCrc != NO_CRC32) {
      if (extra.crc32 == 0) {
        return new PutRet(new CallRet(400,new Exception(""String_Node_Str"")));
      }
      requestEntity.addPart(""String_Node_Str"",new StringBody(extra.crc32 + ""String_Node_Str""));
    }
    if (extra.params != null) {
      for (      Map.Entry<String,String> xvar : extra.params.entrySet()) {
        requestEntity.addPart(xvar.getKey(),new StringBody(xvar.getValue()));
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    return new PutRet(new CallRet(400,e));
  }
  String url=Config.UP_HOST;
  CallRet ret=new Client().callWithMultiPart(url,requestEntity);
  return new PutRet(ret);
}","public static PutRet put(String uptoken,String key,InputStream reader,PutExtra extra,String fileName){
  return putStream(uptoken,key,reader,extra,fileName);
}",0.1458026509572901
52639,"public static PutRet Put(String uptoken,String key,InputStream reader,PutExtra extra){
  PutRet ret=putStream(uptoken,key,reader,extra);
  return ret;
}","public static PutRet Put(String uptoken,String key,InputStream reader,PutExtra extra){
  return put(uptoken,key,reader,extra);
}",0.8857142857142857
52640,"@Override public void setUp(){
  Config.ACCESS_KEY=System.getenv(""String_Node_Str"");
  Config.SECRET_KEY=System.getenv(""String_Node_Str"");
  Config.RS_HOST=System.getenv(""String_Node_Str"");
  bucketName=System.getenv(""String_Node_Str"");
  assertNotNull(Config.ACCESS_KEY);
  assertNotNull(Config.SECRET_KEY);
  assertNotNull(Config.RS_HOST);
  assertNotNull(bucketName);
  mac=new Mac(Config.ACCESS_KEY,Config.SECRET_KEY);
}","@Override public void setUp(){
  Config.ACCESS_KEY=System.getenv(""String_Node_Str"");
  Config.SECRET_KEY=System.getenv(""String_Node_Str"");
  bucketName=System.getenv(""String_Node_Str"");
  mac=new Mac(Config.ACCESS_KEY,Config.SECRET_KEY);
  key=UUID.randomUUID().toString();
  key2=UUID.randomUUID().toString();
}",0.6494565217391305
52641,"@Override public void tearDown(){
{
    RSClient rs=new RSClient(mac);
    Entry sr=rs.stat(bucketName,key);
    assertTrue(sr.ok());
    assertTrue(expectedHash.equals(sr.getHash()));
  }
{
    RSClient rs=new RSClient(mac);
    CallRet cr=rs.delete(bucketName,key);
    assertTrue(cr.ok());
  }
{
    RSClient rs=new RSClient(mac);
    Entry sr=rs.stat(bucketName,key);
    assertTrue(!sr.ok());
  }
}","@Override public void tearDown(){
  RSClient rs=new RSClient(mac);
  try {
    rs.delete(bucketName,key2);
  }
 catch (  Exception e) {
  }
  try {
    rs.delete(bucketName,key);
  }
 catch (  Exception e) {
  }
}",0.4090909090909091
52642,"public String marshal() throws JSONException {
  JSONStringer stringer=new JSONStringer();
  stringer.object();
  stringer.key(""String_Node_Str"").value(this.scope);
  if (this.callbackUrl != null && this.callbackUrl.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.callbackUrl);
  }
  if (this.callbackBody != null && this.callbackBody.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.callbackBody);
  }
  if (this.returnUrl != null && this.returnUrl.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.returnUrl);
  }
  if (this.returnBody != null && this.returnBody.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.returnBody);
  }
  if (this.asyncOps != null && this.asyncOps.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.asyncOps);
  }
  if (this.saveKey != null && this.saveKey.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.saveKey);
  }
  if (this.insertOnly > 0) {
    stringer.key(""String_Node_Str"").value(this.insertOnly);
  }
  if (this.detectMime > 0) {
    stringer.key(""String_Node_Str"").value(this.detectMime);
  }
  if (this.fsizeLimit > 0) {
    stringer.key(""String_Node_Str"").value(this.fsizeLimit);
  }
  if (this.endUser != null && this.endUser.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.endUser);
  }
  if (this.persistentNotifyUrl != null && this.persistentNotifyUrl.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.persistentNotifyUrl);
  }
  if (this.persistentOps != null && this.persistentOps.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.persistentOps);
  }
  if (this.transform != null && this.transform.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.transform);
  }
  if (this.fopTimeout > 0) {
    stringer.key(""String_Node_Str"").value(this.fopTimeout);
  }
  stringer.key(""String_Node_Str"").value(this.deadline);
  stringer.endObject();
  return stringer.toString();
}","public String marshal() throws JSONException {
  JSONStringer stringer=new JSONStringer();
  stringer.object();
  stringer.key(""String_Node_Str"").value(this.scope);
  if (this.callbackUrl != null && this.callbackUrl.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.callbackUrl);
  }
  if (this.callbackBody != null && this.callbackBody.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.callbackBody);
  }
  if (this.returnUrl != null && this.returnUrl.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.returnUrl);
  }
  if (this.returnBody != null && this.returnBody.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.returnBody);
  }
  if (this.asyncOps != null && this.asyncOps.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.asyncOps);
  }
  if (this.saveKey != null && this.saveKey.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.saveKey);
  }
  if (this.insertOnly > 0) {
    stringer.key(""String_Node_Str"").value(this.insertOnly);
  }
  if (this.detectMime > 0) {
    stringer.key(""String_Node_Str"").value(this.detectMime);
  }
  if (this.fsizeLimit > 0) {
    stringer.key(""String_Node_Str"").value(this.fsizeLimit);
  }
  if (this.mimeLimit != null && this.mimeLimit.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.mimeLimit);
  }
  if (this.endUser != null && this.endUser.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.endUser);
  }
  if (this.persistentNotifyUrl != null && this.persistentNotifyUrl.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.persistentNotifyUrl);
  }
  if (this.persistentOps != null && this.persistentOps.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.persistentOps);
  }
  if (this.transform != null && this.transform.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.transform);
  }
  if (this.fopTimeout > 0) {
    stringer.key(""String_Node_Str"").value(this.fopTimeout);
  }
  stringer.key(""String_Node_Str"").value(this.deadline);
  stringer.endObject();
  return stringer.toString();
}",0.96875
52643,"public static ExifRet call(String url){
  CallRet ret=new Client().call(makeRequest(url));
  return new ExifRet(ret);
}","public static ExifRet call(String url,Mac mac) throws AuthException {
  String pubUrl=makeRequest(url);
  GetPolicy policy=new GetPolicy();
  String priUrl=policy.makeRequest(pubUrl,mac);
  CallRet ret=new Client().call(priUrl);
  return new ExifRet(ret);
}",0.2765957446808511
52644,"public static ImageInfoRet call(String url){
  CallRet ret=new Client().call(makeRequest(url));
  return new ImageInfoRet(ret);
}","/** 
 */
public static ImageInfoRet call(String url,Mac mac) throws AuthException {
  String pubUrl=makeRequest(url);
  GetPolicy policy=new GetPolicy();
  String priUrl=policy.makeRequest(pubUrl,mac);
  CallRet ret=new Client().call(priUrl);
  return new ImageInfoRet(ret);
}",0.5530864197530864
52645,"public CallRet call(String url){
  CallRet ret=new Client().call(this.makeRequest(url));
  return ret;
}","public CallRet call(String url,Mac mac) throws AuthException {
  String pubUrl=makeRequest(url);
  GetPolicy policy=new GetPolicy();
  String priUrl=policy.makeRequest(pubUrl,mac);
  CallRet ret=new Client().call(priUrl);
  return ret;
}",0.4809384164222874
52646,"private String marshal() throws JSONException {
  JSONStringer stringer=new JSONStringer();
  stringer.object();
  stringer.key(""String_Node_Str"").value(this.scope);
  if (this.callbackUrl != null && this.callbackUrl.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.callbackUrl);
  }
  if (this.returnUrl != null && this.returnUrl.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.returnUrl);
  }
  if (this.asyncOps != null && this.asyncOps.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.asyncOps);
  }
  if (this.returnBody != null && this.returnBody.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.returnBody);
  }
  stringer.key(""String_Node_Str"").value(this.expires);
  stringer.endObject();
  return stringer.toString();
}","private String marshal() throws JSONException {
  JSONStringer stringer=new JSONStringer();
  stringer.object();
  stringer.key(""String_Node_Str"").value(this.scope);
  if (this.callbackUrl != null && this.callbackUrl.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.callbackUrl);
  }
  if (this.callbackBody != null && this.callbackBody.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.callbackBody);
  }
  if (this.returnUrl != null && this.returnUrl.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.returnUrl);
  }
  if (this.returnBody != null && this.returnBody.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.returnBody);
  }
  if (this.asyncOps != null && this.asyncOps.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.asyncOps);
  }
  stringer.key(""String_Node_Str"").value(this.expires);
  stringer.endObject();
  return stringer.toString();
}",0.7592267135325131
52647,"private String marshal() throws JSONException {
  JSONStringer stringer=new JSONStringer();
  stringer.object();
  stringer.key(""String_Node_Str"").value(this.scope);
  if (this.callbackUrl != null && this.callbackUrl.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.callbackUrl);
  }
  if (this.returnUrl != null && this.returnUrl.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.returnUrl);
  }
  if (this.asyncOps != null && this.asyncOps.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.asyncOps);
  }
  if (this.returnBody != null && this.returnBody.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.returnBody);
  }
  stringer.key(""String_Node_Str"").value(this.expires);
  stringer.endObject();
  return stringer.toString();
}","private String marshal() throws JSONException {
  JSONStringer stringer=new JSONStringer();
  stringer.object();
  stringer.key(""String_Node_Str"").value(this.scope);
  if (this.callbackUrl != null && this.callbackUrl.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.callbackUrl);
  }
  if (this.callbackBody != null && this.callbackBody.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.callbackBody);
  }
  if (this.returnUrl != null && this.returnUrl.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.returnUrl);
  }
  if (this.returnBody != null && this.returnBody.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.returnBody);
  }
  if (this.asyncOps != null && this.asyncOps.length() > 0) {
    stringer.key(""String_Node_Str"").value(this.asyncOps);
  }
  stringer.key(""String_Node_Str"").value(this.expires);
  stringer.endObject();
  return stringer.toString();
}",0.7592267135325131
52648,"public static CallRet call(String url){
  CallRet ret=new Client().call(url);
  return ret;
}","public static CallRet call(String url){
  CallRet ret=new Client().call(makeRequest(url));
  return ret;
}",0.9346733668341708
52649,"public static ImageInfoRet call(String url){
  CallRet ret=new Client().call(url);
  return new ImageInfoRet(ret);
}","public static ImageInfoRet call(String url){
  CallRet ret=new Client().call(makeRequest(url));
  return new ImageInfoRet(ret);
}",0.946938775510204
52650,"public CallRet call(String url){
  CallRet ret=new Client().call(url);
  return ret;
}","public CallRet call(String url){
  CallRet ret=new Client().call(this.makeRequest(url));
  return ret;
}",0.9052631578947368
52651,"public CallRet call(String url){
  CallRet ret=new Client().call(url);
  return ret;
}","public CallRet call(String url){
  CallRet ret=new Client().call(this.makeRequest(url));
  return ret;
}",0.9052631578947368
52652,"public static void main(String[] args) throws Exception {
  Config.ACCESS_KEY=""String_Node_Str"";
  Config.SECRET_KEY=""String_Node_Str"";
  String bucketName=""String_Node_Str"";
  String key=""String_Node_Str"";
  String path=System.getProperty(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + path + ""String_Node_Str""+ key+ ""String_Node_Str"");
  AuthPolicy policy=new AuthPolicy(bucketName,3600);
  String token=policy.makeAuthTokenString();
  PutFileRet putRet=RSClient.putFileWithToken(token,bucketName,key,path + ""String_Node_Str"" + key,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (putRet.ok()) {
    System.out.println(""String_Node_Str"" + path + ""String_Node_Str""+ key+ ""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"" + path + ""String_Node_Str""+ key+ ""String_Node_Str""+ putRet);
    return;
  }
  DigestAuthClient conn=new DigestAuthClient();
  RSService rs=new RSService(conn,bucketName);
  GetRet getRet=rs.get(key,key);
  if (!getRet.ok()) {
    System.out.println(""String_Node_Str"" + getRet);
    return;
  }
  String imageUrl=getRet.getUrl();
  System.out.println(""String_Node_Str"" + imageUrl + ""String_Node_Str"");
  String imgInfoRequestUrl=ImageInfo.makeRequest(imageUrl);
  System.out.println(""String_Node_Str"" + imgInfoRequestUrl);
  ImageInfoRet imgInfoRet=ImageInfo.call(imgInfoRequestUrl);
  if (imgInfoRet.ok()) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + imgInfoRet.format);
    System.out.println(""String_Node_Str"" + imgInfoRet.width);
    System.out.println(""String_Node_Str"" + imgInfoRet.height);
    System.out.println(""String_Node_Str"" + imgInfoRet.colorModel);
    System.out.println();
  }
 else {
    System.out.println(""String_Node_Str"" + imgInfoRet);
    return;
  }
  String imgExifRequestUrl=ImageExif.makeRequest(imageUrl);
  System.out.println(""String_Node_Str"" + imgExifRequestUrl);
  CallRet imgExifRet=ImageExif.call(imgExifRequestUrl);
  if (imgExifRet.ok()) {
    System.out.println(""String_Node_Str"");
    System.out.println(imgExifRet.getResponse());
    System.out.println();
  }
 else {
    System.out.println(""String_Node_Str"" + imgExifRet);
  }
  ImageView imgView=new ImageView();
  imgView.mode=1;
  imgView.width=100;
  imgView.height=200;
  imgView.quality=1;
  imgView.format=""String_Node_Str"";
  imgView.sharpen=100;
  String imgViewReuqestUrl=imgView.makeRequest(imageUrl);
  System.out.println(""String_Node_Str"" + imgViewReuqestUrl);
  CallRet imgViewRet=imgView.call(imgViewReuqestUrl);
  System.out.println(""String_Node_Str"" + (imgViewRet.ok() ? ""String_Node_Str"" : imgViewRet));
  ImageMogrify imgMogr=new ImageMogrify();
  imgMogr.thumbnail=""String_Node_Str"";
  imgMogr.gravity=""String_Node_Str"";
  imgMogr.crop=""String_Node_Str"";
  imgMogr.quality=85;
  imgMogr.rotate=45;
  imgMogr.format=""String_Node_Str"";
  imgMogr.autoOrient=true;
  String imgMogrRequestUrl=imgMogr.makeRequest(imageUrl);
  System.out.println(""String_Node_Str"" + imgMogrRequestUrl);
  CallRet imgMogrRet=imgMogr.call(imgMogrRequestUrl);
  System.out.println(""String_Node_Str"" + (imgMogrRet.ok() ? ""String_Node_Str"" : imgMogrRet));
}","public static void main(String[] args) throws Exception {
  Config.ACCESS_KEY=""String_Node_Str"";
  Config.SECRET_KEY=""String_Node_Str"";
  String bucketName=""String_Node_Str"";
  String key=""String_Node_Str"";
  String path=System.getProperty(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + path + ""String_Node_Str""+ key+ ""String_Node_Str"");
  AuthPolicy policy=new AuthPolicy(bucketName,3600);
  String token=policy.makeAuthTokenString();
  PutFileRet putRet=RSClient.putFileWithToken(token,bucketName,key,path + ""String_Node_Str"" + key,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (putRet.ok()) {
    System.out.println(""String_Node_Str"" + path + ""String_Node_Str""+ key+ ""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"" + path + ""String_Node_Str""+ key+ ""String_Node_Str""+ putRet);
    return;
  }
  DigestAuthClient conn=new DigestAuthClient();
  RSService rs=new RSService(conn,bucketName);
  GetRet getRet=rs.get(key,key);
  if (!getRet.ok()) {
    System.out.println(""String_Node_Str"" + getRet);
    return;
  }
  String imageUrl=getRet.getUrl();
  System.out.println(""String_Node_Str"" + imageUrl + ""String_Node_Str"");
  String imgInfoRequestUrl=ImageInfo.makeRequest(imageUrl);
  System.out.println(""String_Node_Str"" + imgInfoRequestUrl);
  ImageInfoRet imgInfoRet=ImageInfo.call(imageUrl);
  if (imgInfoRet.ok()) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + imgInfoRet.format);
    System.out.println(""String_Node_Str"" + imgInfoRet.width);
    System.out.println(""String_Node_Str"" + imgInfoRet.height);
    System.out.println(""String_Node_Str"" + imgInfoRet.colorModel);
    System.out.println();
  }
 else {
    System.out.println(""String_Node_Str"" + imgInfoRet);
    return;
  }
  String imgExifRequestUrl=ImageExif.makeRequest(imageUrl);
  System.out.println(""String_Node_Str"" + imgExifRequestUrl);
  CallRet imgExifRet=ImageExif.call(imageUrl);
  if (imgExifRet.ok()) {
    System.out.println(""String_Node_Str"");
    System.out.println(imgExifRet.getResponse());
    System.out.println();
  }
 else {
    System.out.println(""String_Node_Str"" + imgExifRet);
  }
  ImageView imgView=new ImageView();
  imgView.mode=1;
  imgView.width=100;
  imgView.height=200;
  imgView.quality=1;
  imgView.format=""String_Node_Str"";
  imgView.sharpen=100;
  String imgViewReuqestUrl=imgView.makeRequest(imageUrl);
  System.out.println(""String_Node_Str"" + imgViewReuqestUrl);
  CallRet imgViewRet=imgView.call(imageUrl);
  System.out.println(""String_Node_Str"" + (imgViewRet.ok() ? ""String_Node_Str"" : imgViewRet));
  ImageMogrify imgMogr=new ImageMogrify();
  imgMogr.thumbnail=""String_Node_Str"";
  imgMogr.gravity=""String_Node_Str"";
  imgMogr.crop=""String_Node_Str"";
  imgMogr.quality=85;
  imgMogr.rotate=45;
  imgMogr.format=""String_Node_Str"";
  imgMogr.autoOrient=true;
  String imgMogrRequestUrl=imgMogr.makeRequest(imageUrl);
  System.out.println(""String_Node_Str"" + imgMogrRequestUrl);
  CallRet imgMogrRet=imgMogr.call(imageUrl);
  System.out.println(""String_Node_Str"" + (imgMogrRet.ok() ? ""String_Node_Str"" : imgMogrRet));
}",0.965440710209258
52653,"public static PutFileRet resumablePutFile(UpService c,String[] checksums,BlockProgress[] progresses,ProgressNotifier progressNotifier,BlockProgressNotifier blockProgressNotifier,String bucketName,String key,String mimeType,RandomAccessFile f,long fsize,String customMeta,String callbackParams){
  ResumablePutRet ret=c.resumablePut(f,fsize,checksums,progresses,progressNotifier,blockProgressNotifier);
  if (!ret.ok()) {
    return new PutFileRet(ret);
  }
  if (mimeType == null || mimeType.isEmpty()) {
    mimeType=""String_Node_Str"";
  }
  String params=""String_Node_Str"" + Base64.encodeBase64String(mimeType.getBytes());
  if (customMeta != null && !customMeta.isEmpty()) {
    params+=""String_Node_Str"" + Base64.encodeBase64String(customMeta.getBytes());
  }
  String entryUri=bucketName + ""String_Node_Str"" + key;
  CallRet callRet=c.makeFile(""String_Node_Str"",entryUri,fsize,params,callbackParams,checksums);
  return new PutFileRet(callRet);
}","public static PutFileRet resumablePutFile(UpService c,String[] checksums,BlockProgress[] progresses,ProgressNotifier progressNotifier,BlockProgressNotifier blockProgressNotifier,String bucketName,String key,String mimeType,RandomAccessFile f,long fsize,String customMeta,String callbackParams){
  ResumablePutRet ret=c.resumablePut(f,fsize,checksums,progresses,progressNotifier,blockProgressNotifier);
  if (!ret.ok()) {
    return new PutFileRet(ret);
  }
  if (mimeType == null || mimeType.isEmpty()) {
    mimeType=""String_Node_Str"";
  }
  String params=""String_Node_Str"" + Base64.encodeBase64String(mimeType.getBytes());
  if (customMeta != null && !customMeta.isEmpty()) {
    params+=""String_Node_Str"" + Base64.encodeBase64String(customMeta.getBytes());
  }
  String entryUri=bucketName + ""String_Node_Str"" + key;
  String upHost=ret.getHost();
  CallRet callRet=c.makeFile(upHost,""String_Node_Str"",entryUri,fsize,params,callbackParams,checksums);
  return new PutFileRet(callRet);
}",0.9804123711340206
52654,"public ResumablePutRet makeBlock(long blockSize,byte[] body,long bodyLength){
  CallRet ret=this.conn.callWithBinary(upHost + ""String_Node_Str"" + String.valueOf(blockSize),""String_Node_Str"",body,bodyLength);
  ResumablePutRet putRet=new ResumablePutRet(ret);
  upHost=putRet.getHost();
  return putRet;
}","public ResumablePutRet makeBlock(String upHost,long blockSize,byte[] body,long bodyLength){
  CallRet ret=this.conn.callWithBinary(upHost + ""String_Node_Str"" + String.valueOf(blockSize),""String_Node_Str"",body,bodyLength);
  ResumablePutRet putRet=new ResumablePutRet(ret);
  return putRet;
}",0.8873949579831932
52655,"public CallRet makeFile(String cmd,String entry,long fsize,String params,String callbackParams,String[] checksums){
  if (callbackParams != null && !callbackParams.isEmpty()) {
    params+=""String_Node_Str"" + new String(Base64.encodeBase64(callbackParams.getBytes(),false,false));
  }
  String url=upHost + cmd + Client.urlsafeEncodeString(entry.getBytes())+ ""String_Node_Str""+ String.valueOf(fsize)+ params;
  byte[] body=new byte[20 * checksums.length];
  for (int i=0; i < checksums.length; i++) {
    byte[] buf=Base64.decodeBase64(checksums[i]);
    System.arraycopy(buf,0,body,i * 20,buf.length);
  }
  CallRet ret=this.conn.callWithBinary(url,null,body,body.length);
  return ret;
}","public CallRet makeFile(String upHost,String cmd,String entry,long fsize,String params,String callbackParams,String[] checksums){
  if (callbackParams != null && !callbackParams.isEmpty()) {
    params+=""String_Node_Str"" + new String(Base64.encodeBase64(callbackParams.getBytes(),false,false));
  }
  String url=upHost + cmd + Client.urlsafeEncodeString(entry.getBytes())+ ""String_Node_Str""+ String.valueOf(fsize)+ params;
  byte[] body=new byte[20 * checksums.length];
  for (int i=0; i < checksums.length; i++) {
    byte[] buf=Base64.decodeBase64(checksums[i]);
    System.arraycopy(buf,0,body,i * 20,buf.length);
  }
  CallRet ret=this.conn.callWithBinary(url,null,body,body.length);
  return ret;
}",0.9899425287356322
52656,"public ResumablePutRet putBlock(long blockSize,String ctx,long offset,byte[] body,long bodyLength){
  CallRet ret=this.conn.callWithBinary(upHost + ""String_Node_Str"" + ctx+ ""String_Node_Str""+ String.valueOf(offset),""String_Node_Str"",body,bodyLength);
  return new ResumablePutRet(ret);
}","public ResumablePutRet putBlock(String upHost,long blockSize,String ctx,long offset,byte[] body,long bodyLength){
  CallRet ret=this.conn.callWithBinary(upHost + ""String_Node_Str"" + ctx+ ""String_Node_Str""+ String.valueOf(offset),""String_Node_Str"",body,bodyLength);
  return new ResumablePutRet(ret);
}",0.9761904761904762
52657,"/** 
 * Put a single block.
 * @param in
 * @param blockIndex
 * @param blockSize
 * @param chunkSize
 * @param retries If fails, how many times should it retry to upload?
 * @param progress
 * @param notifier
 */
public ResumablePutRet resumablePutBlock(RandomAccessFile file,int blockIndex,long blockSize,long chunkSize,int retryTimes,BlockProgress progress,BlockProgressNotifier notifier){
  ResumablePutRet ret=null;
  if (progress.context == null || progress.context.isEmpty()) {
    int bodyLength=(int)((blockSize > chunkSize) ? chunkSize : blockSize);
    byte[] body=new byte[bodyLength];
    try {
      file.seek(Config.BLOCK_SIZE * blockIndex);
      int readBytes=file.read(body,0,bodyLength);
      if (readBytes != bodyLength) {
        return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
      }
      ret=makeBlock((int)blockSize,body,bodyLength);
      if (!ret.ok()) {
        return ret;
      }
      CRC32 crc32=new CRC32();
      crc32.update(body,0,bodyLength);
      if (ret.getCrc32() != crc32.getValue()) {
        ret.statusCode=400;
        return ret;
      }
      progress.context=ret.getCtx();
      progress.offset=bodyLength;
      progress.restSize=blockSize - bodyLength;
      notifier.notify(blockIndex,progress);
    }
 catch (    IOException e) {
      e.printStackTrace();
      return new ResumablePutRet(new CallRet(400,e));
    }
  }
 else   if (progress.offset + progress.restSize != blockSize) {
    return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
  }
  while (progress.restSize > 0) {
    int bodyLength=(int)((chunkSize < progress.restSize) ? chunkSize : progress.restSize);
    byte[] body=new byte[bodyLength];
    for (int retries=retryTimes; retries > 0; --retries) {
      try {
        file.seek(blockIndex * Config.BLOCK_SIZE + progress.offset);
        int readBytes=file.read(body,0,bodyLength);
        if (readBytes != bodyLength) {
          return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
        }
        ret=putBlock(blockSize,progress.context,progress.offset,body,bodyLength);
        if (ret.ok()) {
          CRC32 crc32=new CRC32();
          crc32.update(body,0,bodyLength);
          if (ret.getCrc32() == crc32.getValue()) {
            progress.context=ret.getCtx();
            progress.offset+=bodyLength;
            progress.restSize-=bodyLength;
            notifier.notify(blockIndex,progress);
            break;
          }
        }
 else         if (ret.getStatusCode() == INVALID_CTX) {
          progress.context=""String_Node_Str"";
          notifier.notify(blockIndex,progress);
          return ret;
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
        return new ResumablePutRet(new CallRet(400,e));
      }
    }
  }
  if (ret == null) {
    ret=new ResumablePutRet(new CallRet(400,(String)null));
  }
  return ret;
}","/** 
 * Put a single block.
 * @param in
 * @param blockIndex
 * @param blockSize
 * @param chunkSize
 * @param retries If fails, how many times should it retry to upload?
 * @param progress
 * @param notifier
 */
public ResumablePutRet resumablePutBlock(String upHost,RandomAccessFile file,int blockIndex,long blockSize,long chunkSize,int retryTimes,BlockProgress progress,BlockProgressNotifier notifier){
  System.out.println(""String_Node_Str"" + upHost);
  ResumablePutRet ret=null;
  if (progress.context == null || progress.context.isEmpty()) {
    int bodyLength=(int)((blockSize > chunkSize) ? chunkSize : blockSize);
    byte[] body=new byte[bodyLength];
    try {
      file.seek(Config.BLOCK_SIZE * blockIndex);
      int readBytes=file.read(body,0,bodyLength);
      if (readBytes != bodyLength) {
        return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
      }
      ret=makeBlock(upHost,(int)blockSize,body,bodyLength);
      upHost=ret.getHost();
      if (!ret.ok()) {
        return ret;
      }
      CRC32 crc32=new CRC32();
      crc32.update(body,0,bodyLength);
      if (ret.getCrc32() != crc32.getValue()) {
        ret.statusCode=400;
        return ret;
      }
      progress.context=ret.getCtx();
      progress.offset=bodyLength;
      progress.restSize=blockSize - bodyLength;
      notifier.notify(blockIndex,progress);
    }
 catch (    IOException e) {
      e.printStackTrace();
      return new ResumablePutRet(new CallRet(400,e));
    }
  }
 else   if (progress.offset + progress.restSize != blockSize) {
    return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
  }
  while (progress.restSize > 0) {
    int bodyLength=(int)((chunkSize < progress.restSize) ? chunkSize : progress.restSize);
    byte[] body=new byte[bodyLength];
    for (int retries=retryTimes; retries > 0; --retries) {
      try {
        file.seek(blockIndex * Config.BLOCK_SIZE + progress.offset);
        int readBytes=file.read(body,0,bodyLength);
        if (readBytes != bodyLength) {
          return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
        }
        ret=putBlock(upHost,blockSize,progress.context,progress.offset,body,bodyLength);
        if (ret.ok()) {
          CRC32 crc32=new CRC32();
          crc32.update(body,0,bodyLength);
          if (ret.getCrc32() == crc32.getValue()) {
            progress.context=ret.getCtx();
            progress.offset+=bodyLength;
            progress.restSize-=bodyLength;
            notifier.notify(blockIndex,progress);
            break;
          }
        }
 else         if (ret.getStatusCode() == INVALID_CTX) {
          progress.context=""String_Node_Str"";
          notifier.notify(blockIndex,progress);
          return ret;
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
        return new ResumablePutRet(new CallRet(400,e));
      }
    }
  }
  if (ret == null) {
    ret=new ResumablePutRet(new CallRet(400,(String)null));
  }
  return ret;
}",0.9819482288828338
52658,"public ResumablePutRet resumablePut(RandomAccessFile file,long fsize,String[] checksums,BlockProgress[] progresses,ProgressNotifier progressNotifier,BlockProgressNotifier blockProgressNotifier){
  int blockCount=blockCount(fsize);
  if (checksums.length != blockCount || progresses.length != blockCount) {
    return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
  }
  for (int i=0; i < blockCount; i++) {
    if (checksums[i] == null || checksums[i].isEmpty()) {
      int blockIndex=i;
      long blockSize=Config.BLOCK_SIZE;
      if (blockIndex == blockCount - 1) {
        blockSize=fsize - Config.BLOCK_SIZE * blockIndex;
      }
      if (progresses[i] == null) {
        progresses[i]=new BlockProgress();
      }
      ResumablePutRet ret=resumablePutBlock(file,blockIndex,blockSize,Config.PUT_CHUNK_SIZE,Config.PUT_RETRY_TIMES,progresses[i],blockProgressNotifier);
      if (!ret.ok()) {
        return ret;
      }
      checksums[i]=ret.getChecksum();
      progressNotifier.notify(i,checksums[i]);
    }
  }
  return new ResumablePutRet(new CallRet(200,(String)null));
}","public ResumablePutRet resumablePut(RandomAccessFile file,long fsize,String[] checksums,BlockProgress[] progresses,ProgressNotifier progressNotifier,BlockProgressNotifier blockProgressNotifier){
  String upHost=Config.UP_HOST;
  ResumablePutRet ret=null;
  int blockCount=blockCount(fsize);
  if (checksums.length != blockCount || progresses.length != blockCount) {
    return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
  }
  for (int i=0; i < blockCount; i++) {
    if (checksums[i] == null || checksums[i].isEmpty()) {
      int blockIndex=i;
      long blockSize=Config.BLOCK_SIZE;
      if (blockIndex == blockCount - 1) {
        blockSize=fsize - Config.BLOCK_SIZE * blockIndex;
      }
      if (progresses[i] == null) {
        progresses[i]=new BlockProgress();
      }
      ret=resumablePutBlock(upHost,file,blockIndex,blockSize,Config.PUT_CHUNK_SIZE,Config.PUT_RETRY_TIMES,progresses[i],blockProgressNotifier);
      if (i == 0) {
        upHost=ret.getHost();
      }
      if (!ret.ok()) {
        return ret;
      }
      checksums[i]=ret.getChecksum();
      progressNotifier.notify(i,checksums[i]);
    }
  }
  ret.setHost(upHost);
  return ret;
}",0.8966124065112187
52659,"public static PutFileRet resumablePutFile(UpService c,String[] checksums,BlockProgress[] progresses,ProgressNotifier progressNotifier,BlockProgressNotifier blockProgressNotifier,String bucketName,String key,String mimeType,RandomAccessFile f,long fsize,String customMeta,String callbackParams){
  ResumablePutRet ret=c.resumablePut(f,fsize,checksums,progresses,progressNotifier,blockProgressNotifier);
  if (!ret.ok()) {
    return new PutFileRet(ret);
  }
  if (mimeType == null || mimeType.isEmpty()) {
    mimeType=""String_Node_Str"";
  }
  String params=""String_Node_Str"" + Base64.encodeBase64String(mimeType.getBytes());
  if (customMeta != null && !customMeta.isEmpty()) {
    params+=""String_Node_Str"" + Base64.encodeBase64String(customMeta.getBytes());
  }
  String entryUri=bucketName + ""String_Node_Str"" + key;
  CallRet callRet=c.makeFile(""String_Node_Str"",entryUri,fsize,params,callbackParams,checksums);
  return new PutFileRet(callRet);
}","public static PutFileRet resumablePutFile(UpService c,String[] checksums,BlockProgress[] progresses,ProgressNotifier progressNotifier,BlockProgressNotifier blockProgressNotifier,String bucketName,String key,String mimeType,RandomAccessFile f,long fsize,String customMeta,String callbackParams){
  ResumablePutRet ret=c.resumablePut(f,fsize,checksums,progresses,progressNotifier,blockProgressNotifier);
  if (!ret.ok()) {
    return new PutFileRet(ret);
  }
  if (mimeType == null || mimeType.isEmpty()) {
    mimeType=""String_Node_Str"";
  }
  String params=""String_Node_Str"" + Base64.encodeBase64String(mimeType.getBytes());
  if (customMeta != null && !customMeta.isEmpty()) {
    params+=""String_Node_Str"" + Base64.encodeBase64String(customMeta.getBytes());
  }
  String entryUri=bucketName + ""String_Node_Str"" + key;
  String upHost=ret.getHost();
  CallRet callRet=c.makeFile(upHost,""String_Node_Str"",entryUri,fsize,params,callbackParams,checksums);
  return new PutFileRet(callRet);
}",0.9804123711340206
52660,"public ResumablePutRet makeBlock(long blockSize,byte[] body,long bodyLength){
  CallRet ret=this.conn.callWithBinary(upHost + ""String_Node_Str"" + String.valueOf(blockSize),""String_Node_Str"",body,bodyLength);
  ResumablePutRet putRet=new ResumablePutRet(ret);
  upHost=putRet.getHost();
  return putRet;
}","public ResumablePutRet makeBlock(String upHost,long blockSize,byte[] body,long bodyLength){
  CallRet ret=this.conn.callWithBinary(upHost + ""String_Node_Str"" + String.valueOf(blockSize),""String_Node_Str"",body,bodyLength);
  ResumablePutRet putRet=new ResumablePutRet(ret);
  return putRet;
}",0.8873949579831932
52661,"public CallRet makeFile(String cmd,String entry,long fsize,String params,String callbackParams,String[] checksums){
  if (callbackParams != null && !callbackParams.isEmpty()) {
    params+=""String_Node_Str"" + new String(Base64.encodeBase64(callbackParams.getBytes(),false,false));
  }
  String url=upHost + cmd + Client.urlsafeEncodeString(entry.getBytes())+ ""String_Node_Str""+ String.valueOf(fsize)+ params;
  byte[] body=new byte[20 * checksums.length];
  for (int i=0; i < checksums.length; i++) {
    byte[] buf=Base64.decodeBase64(checksums[i]);
    System.arraycopy(buf,0,body,i * 20,buf.length);
  }
  CallRet ret=this.conn.callWithBinary(url,null,body,body.length);
  return ret;
}","public CallRet makeFile(String upHost,String cmd,String entry,long fsize,String params,String callbackParams,String[] checksums){
  if (callbackParams != null && !callbackParams.isEmpty()) {
    params+=""String_Node_Str"" + new String(Base64.encodeBase64(callbackParams.getBytes(),false,false));
  }
  String url=upHost + cmd + Client.urlsafeEncodeString(entry.getBytes())+ ""String_Node_Str""+ String.valueOf(fsize)+ params;
  byte[] body=new byte[20 * checksums.length];
  for (int i=0; i < checksums.length; i++) {
    byte[] buf=Base64.decodeBase64(checksums[i]);
    System.arraycopy(buf,0,body,i * 20,buf.length);
  }
  CallRet ret=this.conn.callWithBinary(url,null,body,body.length);
  return ret;
}",0.9899425287356322
52662,"public ResumablePutRet putBlock(long blockSize,String ctx,long offset,byte[] body,long bodyLength){
  CallRet ret=this.conn.callWithBinary(upHost + ""String_Node_Str"" + ctx+ ""String_Node_Str""+ String.valueOf(offset),""String_Node_Str"",body,bodyLength);
  return new ResumablePutRet(ret);
}","public ResumablePutRet putBlock(String upHost,long blockSize,String ctx,long offset,byte[] body,long bodyLength){
  CallRet ret=this.conn.callWithBinary(upHost + ""String_Node_Str"" + ctx+ ""String_Node_Str""+ String.valueOf(offset),""String_Node_Str"",body,bodyLength);
  return new ResumablePutRet(ret);
}",0.9761904761904762
52663,"/** 
 * Put a single block.
 * @param in
 * @param blockIndex
 * @param blockSize
 * @param chunkSize
 * @param retries If fails, how many times should it retry to upload?
 * @param progress
 * @param notifier
 */
public ResumablePutRet resumablePutBlock(RandomAccessFile file,int blockIndex,long blockSize,long chunkSize,int retryTimes,BlockProgress progress,BlockProgressNotifier notifier){
  ResumablePutRet ret=null;
  if (progress.context == null || progress.context.isEmpty()) {
    int bodyLength=(int)((blockSize > chunkSize) ? chunkSize : blockSize);
    byte[] body=new byte[bodyLength];
    try {
      file.seek(Config.BLOCK_SIZE * blockIndex);
      int readBytes=file.read(body,0,bodyLength);
      if (readBytes != bodyLength) {
        return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
      }
      ret=makeBlock((int)blockSize,body,bodyLength);
      if (!ret.ok()) {
        return ret;
      }
      CRC32 crc32=new CRC32();
      crc32.update(body,0,bodyLength);
      if (ret.getCrc32() != crc32.getValue()) {
        ret.statusCode=400;
        return ret;
      }
      progress.context=ret.getCtx();
      progress.offset=bodyLength;
      progress.restSize=blockSize - bodyLength;
      notifier.notify(blockIndex,progress);
    }
 catch (    IOException e) {
      e.printStackTrace();
      return new ResumablePutRet(new CallRet(400,e));
    }
  }
 else   if (progress.offset + progress.restSize != blockSize) {
    return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
  }
  while (progress.restSize > 0) {
    int bodyLength=(int)((chunkSize < progress.restSize) ? chunkSize : progress.restSize);
    byte[] body=new byte[bodyLength];
    for (int retries=retryTimes; retries > 0; --retries) {
      try {
        file.seek(blockIndex * Config.BLOCK_SIZE + progress.offset);
        int readBytes=file.read(body,0,bodyLength);
        if (readBytes != bodyLength) {
          return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
        }
        ret=putBlock(blockSize,progress.context,progress.offset,body,bodyLength);
        if (ret.ok()) {
          CRC32 crc32=new CRC32();
          crc32.update(body,0,bodyLength);
          if (ret.getCrc32() == crc32.getValue()) {
            progress.context=ret.getCtx();
            progress.offset+=bodyLength;
            progress.restSize-=bodyLength;
            notifier.notify(blockIndex,progress);
            break;
          }
        }
 else         if (ret.getStatusCode() == INVALID_CTX) {
          progress.context=""String_Node_Str"";
          notifier.notify(blockIndex,progress);
          return ret;
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
        return new ResumablePutRet(new CallRet(400,e));
      }
    }
  }
  if (ret == null) {
    ret=new ResumablePutRet(new CallRet(400,(String)null));
  }
  return ret;
}","/** 
 * Put a single block.
 * @param in
 * @param blockIndex
 * @param blockSize
 * @param chunkSize
 * @param retries If fails, how many times should it retry to upload?
 * @param progress
 * @param notifier
 */
public ResumablePutRet resumablePutBlock(String upHost,RandomAccessFile file,int blockIndex,long blockSize,long chunkSize,int retryTimes,BlockProgress progress,BlockProgressNotifier notifier){
  ResumablePutRet ret=null;
  if (progress.context == null || progress.context.isEmpty()) {
    int bodyLength=(int)((blockSize > chunkSize) ? chunkSize : blockSize);
    byte[] body=new byte[bodyLength];
    try {
      file.seek(Config.BLOCK_SIZE * blockIndex);
      int readBytes=file.read(body,0,bodyLength);
      if (readBytes != bodyLength) {
        return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
      }
      ret=makeBlock(upHost,(int)blockSize,body,bodyLength);
      upHost=ret.getHost();
      if (!ret.ok()) {
        return ret;
      }
      CRC32 crc32=new CRC32();
      crc32.update(body,0,bodyLength);
      if (ret.getCrc32() != crc32.getValue()) {
        ret.statusCode=400;
        return ret;
      }
      progress.context=ret.getCtx();
      progress.offset=bodyLength;
      progress.restSize=blockSize - bodyLength;
      notifier.notify(blockIndex,progress);
    }
 catch (    IOException e) {
      e.printStackTrace();
      return new ResumablePutRet(new CallRet(400,e));
    }
  }
 else   if (progress.offset + progress.restSize != blockSize) {
    return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
  }
  while (progress.restSize > 0) {
    int bodyLength=(int)((chunkSize < progress.restSize) ? chunkSize : progress.restSize);
    byte[] body=new byte[bodyLength];
    for (int retries=retryTimes; retries > 0; --retries) {
      try {
        file.seek(blockIndex * Config.BLOCK_SIZE + progress.offset);
        int readBytes=file.read(body,0,bodyLength);
        if (readBytes != bodyLength) {
          return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
        }
        ret=putBlock(upHost,blockSize,progress.context,progress.offset,body,bodyLength);
        if (ret.ok()) {
          CRC32 crc32=new CRC32();
          crc32.update(body,0,bodyLength);
          if (ret.getCrc32() == crc32.getValue()) {
            progress.context=ret.getCtx();
            progress.offset+=bodyLength;
            progress.restSize-=bodyLength;
            notifier.notify(blockIndex,progress);
            break;
          }
        }
 else         if (ret.getStatusCode() == INVALID_CTX) {
          progress.context=""String_Node_Str"";
          notifier.notify(blockIndex,progress);
          return ret;
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
        return new ResumablePutRet(new CallRet(400,e));
      }
    }
  }
  if (ret == null) {
    ret=new ResumablePutRet(new CallRet(400,(String)null));
  }
  return ret;
}",0.9903813122638268
52664,"public ResumablePutRet resumablePut(RandomAccessFile file,long fsize,String[] checksums,BlockProgress[] progresses,ProgressNotifier progressNotifier,BlockProgressNotifier blockProgressNotifier){
  int blockCount=blockCount(fsize);
  if (checksums.length != blockCount || progresses.length != blockCount) {
    return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
  }
  for (int i=0; i < blockCount; i++) {
    if (checksums[i] == null || checksums[i].isEmpty()) {
      int blockIndex=i;
      long blockSize=Config.BLOCK_SIZE;
      if (blockIndex == blockCount - 1) {
        blockSize=fsize - Config.BLOCK_SIZE * blockIndex;
      }
      if (progresses[i] == null) {
        progresses[i]=new BlockProgress();
      }
      ResumablePutRet ret=resumablePutBlock(file,blockIndex,blockSize,Config.PUT_CHUNK_SIZE,Config.PUT_RETRY_TIMES,progresses[i],blockProgressNotifier);
      if (!ret.ok()) {
        return ret;
      }
      checksums[i]=ret.getChecksum();
      progressNotifier.notify(i,checksums[i]);
    }
  }
  return new ResumablePutRet(new CallRet(200,(String)null));
}","public ResumablePutRet resumablePut(RandomAccessFile file,long fsize,String[] checksums,BlockProgress[] progresses,ProgressNotifier progressNotifier,BlockProgressNotifier blockProgressNotifier){
  String upHost=Config.UP_HOST;
  ResumablePutRet ret=null;
  int blockCount=blockCount(fsize);
  if (checksums.length != blockCount || progresses.length != blockCount) {
    return new ResumablePutRet(new CallRet(400,""String_Node_Str""));
  }
  for (int i=0; i < blockCount; i++) {
    if (checksums[i] == null || checksums[i].isEmpty()) {
      int blockIndex=i;
      long blockSize=Config.BLOCK_SIZE;
      if (blockIndex == blockCount - 1) {
        blockSize=fsize - Config.BLOCK_SIZE * blockIndex;
      }
      if (progresses[i] == null) {
        progresses[i]=new BlockProgress();
      }
      ret=resumablePutBlock(upHost,file,blockIndex,blockSize,Config.PUT_CHUNK_SIZE,Config.PUT_RETRY_TIMES,progresses[i],blockProgressNotifier);
      if (i == 0) {
        upHost=ret.getHost();
      }
      if (!ret.ok()) {
        return ret;
      }
      checksums[i]=ret.getChecksum();
      progressNotifier.notify(i,checksums[i]);
    }
  }
  ret.setHost(upHost);
  return ret;
}",0.8966124065112187
52665,"public CallRet callWithBinary(String url,String contentType,byte[] body,long bodyLength){
  ByteArrayEntity entity=new ByteArrayEntity(body);
  if (contentType == null || contentType.length() == 0) {
    contentType=""String_Node_Str"";
  }
  entity.setContentType(contentType);
  HttpPost postMethod=new HttpPost(url);
  postMethod.setEntity(entity);
  DefaultHttpClient client=new DefaultHttpClient();
  try {
    setAuth(postMethod);
    HttpResponse response=client.execute(postMethod);
    return handleResult(response);
  }
 catch (  Exception e) {
    e.printStackTrace();
    return new CallRet(400,e);
  }
 finally {
    client.getConnectionManager().shutdown();
  }
}","public CallRet callWithBinary(String url,String contentType,byte[] body,long bodyLength){
  ByteArrayEntity entity=new ByteArrayEntity(body);
  if (contentType == null || contentType.isEmpty()) {
    contentType=""String_Node_Str"";
  }
  entity.setContentType(contentType);
  return callWithBinary(url,entity);
}",0.5517241379310345
52666,"/** 
 * @param args
 */
public static void main(String[] args){
  String tblName=""String_Node_Str"";
  String key=""String_Node_Str"";
  String path=RSDemo.class.getClassLoader().getResource(""String_Node_Str"").getPath();
  System.out.println(""String_Node_Str"" + path + key);
  AuthPolicy policy=new AuthPolicy(""String_Node_Str"",3600);
  String token=policy.makeAuthTokenString();
  UpTokenClient upTokenClient=new UpTokenClient(token);
  UpService upClient=new UpService(upTokenClient);
  try {
    RandomAccessFile f=new RandomAccessFile(path + key,""String_Node_Str"");
    long fsize=f.length();
    long blockCount=UpService.blockCount(fsize);
    String[] checksums=new String[(int)blockCount];
    BlockProgress[] progresses=new BlockProgress[(int)blockCount];
    Notifier notif=new Notifier();
    PutFileRet putFileRet=RSClient.resumablePutFile(upClient,checksums,progresses,(ProgressNotifier)notif,(BlockProgressNotifier)notif,tblName + ""String_Node_Str"" + key,""String_Node_Str"",f,fsize,""String_Node_Str"",""String_Node_Str"");
    if (putFileRet.ok()) {
      System.out.println(""String_Node_Str"" + putFileRet.getHash());
    }
 else {
      System.out.println(""String_Node_Str"" + putFileRet.getException());
    }
  }
 catch (  FileNotFoundException e1) {
    e1.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * @param args
 */
public static void main(String[] args){
  String bucketName=""String_Node_Str"";
  String key=""String_Node_Str"";
  String path=RSDemo.class.getClassLoader().getResource(""String_Node_Str"").getPath();
  System.out.println(""String_Node_Str"" + path + key);
  AuthPolicy policy=new AuthPolicy(""String_Node_Str"",3600);
  String token=policy.makeAuthTokenString();
  UpTokenClient upTokenClient=new UpTokenClient(token);
  UpService upClient=new UpService(upTokenClient);
  try {
    RandomAccessFile f=new RandomAccessFile(path + key,""String_Node_Str"");
    long fsize=f.length();
    long blockCount=UpService.blockCount(fsize);
    String[] checksums=new String[(int)blockCount];
    BlockProgress[] progresses=new BlockProgress[(int)blockCount];
    Notifier notif=new Notifier();
    PutFileRet putFileRet=RSClient.resumablePutFile(upClient,checksums,progresses,(ProgressNotifier)notif,(BlockProgressNotifier)notif,bucketName,key,""String_Node_Str"",f,fsize,""String_Node_Str"",""String_Node_Str"");
    if (putFileRet.ok()) {
      System.out.println(""String_Node_Str"" + putFileRet.getHash());
    }
 else {
      System.out.println(""String_Node_Str"" + putFileRet);
    }
  }
 catch (  FileNotFoundException e1) {
    e1.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9800826756858324
52667,"public static byte[] urlsafeEncodeBytes(byte[] src){
  return Base64.encodeBase64(src,false,false);
}","public static byte[] urlsafeEncodeBytes(byte[] src){
  if (src.length % 3 == 0) {
    return Base64.encodeBase64(src,false,true);
  }
  byte[] b=Base64.encodeBase64(src,false,true);
  int pad=4 - b.length % 4;
  byte[] b2=new byte[b.length + pad];
  System.arraycopy(b,0,b2,0,b.length);
  b2[b.length]='=';
  if (pad > 1) {
    b2[b.length + 1]='=';
  }
  return b2;
}",0.3965884861407249
52668,"public static String urlsafeEncode(String text){
  return new String(Base64.encodeBase64(text.getBytes(),false,false));
}","public static String urlsafeEncode(String text){
  return new String(urlsafeEncodeBytes(text.getBytes()));
}",0.8646288209606987
52669,"@Override public void setAuth(HttpMessage httpMessage){
  httpMessage.setHeader(""String_Node_Str"",""String_Node_Str"" + token);
}","@Override public void setAuth(HttpMessage httpMessage){
  httpMessage.setHeader(""String_Node_Str"",token);
}",0.9145299145299144
52670,"public UpTokenClient(String token){
  this.token=token;
}","public UpTokenClient(String token){
  this.token=""String_Node_Str"" + token;
}",0.8507462686567164
52671,"public static PutFileRet resumablePutFile(UpService c,String[] checksums,BlockProgress[] progresses,ProgressNotifier progressNotifier,BlockProgressNotifier blockProgressNotifier,String entryUri,String mimeType,RandomAccessFile f,long fsize,String customMeta,String callbackParams){
  ResumablePutRet ret=c.resumablePut(f,fsize,checksums,progresses,progressNotifier,blockProgressNotifier);
  if (!ret.ok()) {
    return new PutFileRet(ret);
  }
  if (mimeType == null || mimeType.isEmpty()) {
    mimeType=""String_Node_Str"";
  }
  String params=""String_Node_Str"" + Base64.encodeBase64String(mimeType.getBytes());
  if (customMeta != null && !customMeta.isEmpty()) {
    params+=""String_Node_Str"" + Base64.encodeBase64String(customMeta.getBytes());
  }
  PutFileRet putFileRet=c.makeFile(""String_Node_Str"",entryUri,fsize,params,callbackParams,checksums);
  return putFileRet;
}","public static PutFileRet resumablePutFile(UpService c,String[] checksums,BlockProgress[] progresses,ProgressNotifier progressNotifier,BlockProgressNotifier blockProgressNotifier,String bucketName,String key,String mimeType,RandomAccessFile f,long fsize,String customMeta,String callbackParams){
  ResumablePutRet ret=c.resumablePut(f,fsize,checksums,progresses,progressNotifier,blockProgressNotifier);
  if (!ret.ok()) {
    return new PutFileRet(ret);
  }
  if (mimeType == null || mimeType.isEmpty()) {
    mimeType=""String_Node_Str"";
  }
  String params=""String_Node_Str"" + Base64.encodeBase64String(mimeType.getBytes());
  if (customMeta != null && !customMeta.isEmpty()) {
    params+=""String_Node_Str"" + Base64.encodeBase64String(customMeta.getBytes());
  }
  String entryUri=bucketName + ""String_Node_Str"" + key;
  PutFileRet putFileRet=c.makeFile(""String_Node_Str"",entryUri,fsize,params,callbackParams,checksums);
  return putFileRet;
}",0.9532710280373832
52672,"/** 
 * func PutFile(url, key, mimeType, localFile, customMeta, callbackParams string) => (data PutRet, code int, err Error) 匿名上传一个文件(上传用的临时 url 通过 $rs->PutAuth 得到)
 * @throws IOException 
 * @throws RSException 
 * @throws JSONException 
 */
public static PutFileRet putFile(String url,String tblName,String key,String mimeType,String localFile,String customMeta,HashMap<String,String> callbackParams) throws RSException {
  File file=new File(localFile);
  if (!file.exists() || !file.canRead()) {
    return new PutFileRet(new CallRet(400,new Exception(""String_Node_Str"")));
  }
  if (mimeType == null || mimeType.isEmpty()) {
    mimeType=""String_Node_Str"";
  }
  String entryURI=tblName + ""String_Node_Str"" + key;
  String action=""String_Node_Str"" + Base64.encodeBase64String(entryURI.getBytes()) + ""String_Node_Str""+ Base64.encodeBase64String(mimeType.getBytes());
  if (customMeta != null && !customMeta.isEmpty()) {
    action+=""String_Node_Str"" + Base64.encodeBase64String(customMeta.getBytes());
  }
  MultipartEntity requestEntity=new MultipartEntity();
  try {
    requestEntity.addPart(""String_Node_Str"",new StringBody(action));
  }
 catch (  UnsupportedEncodingException e1) {
    e1.printStackTrace();
  }
  FileBody fileBody=new FileBody(new File(localFile));
  requestEntity.addPart(""String_Node_Str"",fileBody);
  if (callbackParams != null && !callbackParams.isEmpty()) {
    ArrayList<NameValuePair> callbackParamList=new ArrayList<NameValuePair>();
    for (    Entry<String,String> entry : callbackParams.entrySet()) {
      callbackParamList.add(new BasicNameValuePair(entry.getKey(),entry.getValue()));
    }
    try {
      requestEntity.addPart(""String_Node_Str"",new StringBody(URLEncodedUtils.format(callbackParamList,""String_Node_Str"")));
    }
 catch (    UnsupportedEncodingException e) {
      e.printStackTrace();
    }
  }
  HttpPost postMethod=new HttpPost(url);
  postMethod.setEntity(requestEntity);
  DefaultHttpClient client=new DefaultHttpClient();
  try {
    HttpResponse response=client.execute(postMethod);
    return handleResult(response);
  }
 catch (  Exception e) {
    e.printStackTrace();
    return new PutFileRet(new CallRet(400,e));
  }
 finally {
    client.getConnectionManager().shutdown();
  }
}","/** 
 * func PutFile(url, key, mimeType, localFile, customMeta, callbackParams string) => (data PutRet, code int, err Error) 匿名上传一个文件(上传用的临时 url 通过 $rs->PutAuth 得到)
 * @throws IOException 
 * @throws RSException 
 * @throws JSONException 
 */
public static PutFileRet putFile(String url,String bucketName,String key,String mimeType,String localFile,String customMeta,HashMap<String,String> callbackParams) throws RSException {
  File file=new File(localFile);
  if (!file.exists() || !file.canRead()) {
    return new PutFileRet(new CallRet(400,new Exception(""String_Node_Str"")));
  }
  if (mimeType == null || mimeType.isEmpty()) {
    mimeType=""String_Node_Str"";
  }
  String entryURI=bucketName + ""String_Node_Str"" + key;
  String action=""String_Node_Str"" + Base64.encodeBase64String(entryURI.getBytes()) + ""String_Node_Str""+ Base64.encodeBase64String(mimeType.getBytes());
  if (customMeta != null && !customMeta.isEmpty()) {
    action+=""String_Node_Str"" + Base64.encodeBase64String(customMeta.getBytes());
  }
  MultipartEntity requestEntity=new MultipartEntity();
  try {
    requestEntity.addPart(""String_Node_Str"",new StringBody(action));
  }
 catch (  UnsupportedEncodingException e1) {
    e1.printStackTrace();
  }
  FileBody fileBody=new FileBody(new File(localFile));
  requestEntity.addPart(""String_Node_Str"",fileBody);
  if (callbackParams != null && !callbackParams.isEmpty()) {
    ArrayList<NameValuePair> callbackParamList=new ArrayList<NameValuePair>();
    for (    Entry<String,String> entry : callbackParams.entrySet()) {
      callbackParamList.add(new BasicNameValuePair(entry.getKey(),entry.getValue()));
    }
    try {
      requestEntity.addPart(""String_Node_Str"",new StringBody(URLEncodedUtils.format(callbackParamList,""String_Node_Str"")));
    }
 catch (    UnsupportedEncodingException e) {
      e.printStackTrace();
    }
  }
  HttpPost postMethod=new HttpPost(url);
  postMethod.setEntity(requestEntity);
  DefaultHttpClient client=new DefaultHttpClient();
  try {
    HttpResponse response=client.execute(postMethod);
    return handleResult(response);
  }
 catch (  Exception e) {
    e.printStackTrace();
    return new PutFileRet(new CallRet(400,e));
  }
 finally {
    client.getConnectionManager().shutdown();
  }
}",0.9968944099378882
52673,"@Override protected void createFormElements(Composite editArea){
  Label lblName=new Label(editArea,SWT.RIGHT);
  lblName.setText(Messages.ColumnName);
  Text valueName=new Text(editArea,SWT.BORDER);
  IValidator validator=value -> {
    String v=(String)value;
    return v != null && v.trim().length() > 0 ? ValidationStatus.ok() : ValidationStatus.error(MessageFormat.format(Messages.MsgDialogInputRequired,Messages.ColumnName));
  }
;
  @SuppressWarnings(""String_Node_Str"") IObservableValue<?> nameObservable=BeanProperties.value(Properties.name.name()).observe(model);
  context.bindValue(WidgetProperties.text(SWT.Modify).observe(valueName),nameObservable,new UpdateValueStrategy().setAfterConvertValidator(validator),null);
  ComboInput securities=null;
  ComboInput portfolio=null;
  if (planType == PortfolioTransaction.class) {
    securities=new ComboInput(editArea,Messages.ColumnSecurity);
    securities.value.setInput(including(client.getActiveSecurities(),model().getSecurity()));
    securities.bindValue(Properties.security.name(),Messages.MsgMissingSecurity);
    securities.bindCurrency(Properties.securityCurrencyCode.name());
    portfolio=new ComboInput(editArea,Messages.ColumnPortfolio);
    List<Portfolio> portfolios=including(client.getActivePortfolios(),model().getPortfolio());
    portfolio.value.setInput(portfolios);
    portfolio.bindValue(Properties.portfolio.name(),Messages.MsgMissingPortfolio);
  }
  ComboInput account=new ComboInput(editArea,Messages.ColumnAccount);
  List<Account> accounts=including(client.getActiveAccounts(),model().getAccount());
  if (planType == PortfolioTransaction.class)   accounts=including(accounts,InvestmentPlanModel.DELIVERY);
  account.value.setInput(accounts);
  account.bindValue(Properties.account.name(),Messages.MsgMissingAccount);
  account.bindCurrency(Properties.accountCurrencyCode.name());
  Label labelAutoGenerate=new Label(editArea,SWT.NONE);
  labelAutoGenerate.setText(Messages.MsgCreateTransactionsAutomaticallyUponOpening);
  Button buttonAutoGenerate=new Button(editArea,SWT.CHECK);
  @SuppressWarnings(""String_Node_Str"") IObservableValue<?> generateObservable=BeanProperties.value(Properties.autoGenerate.name()).observe(model);
  context.bindValue(WidgetProperties.selection().observe(buttonAutoGenerate),generateObservable);
  Label lblDate=new Label(editArea,SWT.RIGHT);
  lblDate.setText(Messages.ColumnDate);
  DatePicker valueDate=new DatePicker(editArea);
  @SuppressWarnings(""String_Node_Str"") IObservableValue<?> dateObservable=BeanProperties.value(Properties.start.name()).observe(model);
  context.bindValue(new SimpleDateTimeDateSelectionProperty().observe(valueDate.getControl()),dateObservable);
  List<Integer> available=new ArrayList<>();
  for (int ii=1; ii <= 12; ii++)   available.add(ii);
  ComboInput interval=new ComboInput(editArea,Messages.ColumnInterval);
  interval.value.setInput(available);
  interval.value.setLabelProvider(new LabelProvider(){
    @Override public String getText(    Object element){
      int interval=(Integer)element;
      return MessageFormat.format(Messages.InvestmentPlanIntervalLabel,interval);
    }
  }
);
  interval.bindValue(Properties.interval.name(),MessageFormat.format(Messages.MsgDialogInputRequired,Messages.ColumnInterval));
  Input amount=new Input(editArea,Messages.ColumnAmount);
  amount.bindValue(Properties.amount.name(),Messages.ColumnAmount,Values.Amount,true);
  amount.bindCurrency(Properties.transactionCurrencyCode.name());
  Input fees=null;
  if (planType == PortfolioTransaction.class) {
    fees=new Input(editArea,Messages.ColumnFees);
    fees.bindValue(Properties.fees.name(),Messages.ColumnAmount,Values.Amount,false);
    fees.bindCurrency(Properties.transactionCurrencyCode.name());
  }
  int amountWidth=amountWidth(amount.value);
  int currencyWidth=currencyWidth(amount.currency);
  FormDataFactory factory=startingWith(valueName,lblName).width(3 * amountWidth);
  if (portfolio != null) {
    factory=factory.thenBelow(portfolio.value.getControl()).label(portfolio.label).thenBelow(securities.value.getControl()).label(securities.label).suffix(securities.currency,currencyWidth);
  }
  factory=factory.thenBelow(account.value.getControl()).label(account.label).suffix(account.currency,currencyWidth).thenBelow(labelAutoGenerate,10).thenBelow(valueDate.getControl(),10).label(lblDate).thenBelow(amount.value,10).width(amountWidth).label(amount.label).suffix(amount.currency,currencyWidth);
  if (fees != null) {
    factory.thenBelow(fees.value).width(amountWidth).label(fees.label).suffix(fees.currency,currencyWidth);
  }
  startingWith(labelAutoGenerate).thenLeft(buttonAutoGenerate);
  startingWith(valueDate.getControl()).thenRight(interval.label).thenRight(interval.value.getControl());
  int widest=widest(lblName,securities != null ? securities.label : null,portfolio != null ? portfolio.label : null,account.label,lblDate,interval.label,amount.label,fees != null ? fees.label : null);
  startingWith(lblName).width(widest);
  WarningMessages warnings=new WarningMessages(this);
  warnings.add(() -> model().getStart().isAfter(LocalDate.now()) ? Messages.MsgDateIsInTheFuture : null);
  model.addPropertyChangeListener(Properties.start.name(),e -> warnings.check());
}","@Override protected void createFormElements(Composite editArea){
  Label lblName=new Label(editArea,SWT.RIGHT);
  lblName.setText(Messages.ColumnName);
  Text valueName=new Text(editArea,SWT.BORDER);
  IValidator validator=value -> {
    String v=(String)value;
    return v != null && v.trim().length() > 0 ? ValidationStatus.ok() : ValidationStatus.error(MessageFormat.format(Messages.MsgDialogInputRequired,Messages.ColumnName));
  }
;
  @SuppressWarnings(""String_Node_Str"") IObservableValue<?> nameObservable=BeanProperties.value(Properties.name.name()).observe(model);
  context.bindValue(WidgetProperties.text(SWT.Modify).observe(valueName),nameObservable,new UpdateValueStrategy().setAfterConvertValidator(validator),null);
  ComboInput securities=null;
  ComboInput portfolio=null;
  if (planType == PortfolioTransaction.class) {
    portfolio=new ComboInput(editArea,Messages.ColumnPortfolio);
    List<Portfolio> portfolios=including(client.getActivePortfolios(),model().getPortfolio());
    portfolio.value.setInput(portfolios);
    portfolio.bindValue(Properties.portfolio.name(),Messages.MsgMissingPortfolio);
    securities=new ComboInput(editArea,Messages.ColumnSecurity);
    securities.value.setInput(including(client.getActiveSecurities(),model().getSecurity()));
    securities.bindValue(Properties.security.name(),Messages.MsgMissingSecurity);
    securities.bindCurrency(Properties.securityCurrencyCode.name());
  }
  ComboInput account=new ComboInput(editArea,Messages.ColumnAccount);
  List<Account> accounts=including(client.getActiveAccounts(),model().getAccount());
  if (planType == PortfolioTransaction.class)   accounts=including(accounts,InvestmentPlanModel.DELIVERY);
  account.value.setInput(accounts);
  account.bindValue(Properties.account.name(),Messages.MsgMissingAccount);
  account.bindCurrency(Properties.accountCurrencyCode.name());
  Label labelAutoGenerate=new Label(editArea,SWT.NONE);
  labelAutoGenerate.setText(Messages.MsgCreateTransactionsAutomaticallyUponOpening);
  Button buttonAutoGenerate=new Button(editArea,SWT.CHECK);
  @SuppressWarnings(""String_Node_Str"") IObservableValue<?> generateObservable=BeanProperties.value(Properties.autoGenerate.name()).observe(model);
  context.bindValue(WidgetProperties.selection().observe(buttonAutoGenerate),generateObservable);
  Label lblDate=new Label(editArea,SWT.RIGHT);
  lblDate.setText(Messages.ColumnDate);
  DatePicker valueDate=new DatePicker(editArea);
  @SuppressWarnings(""String_Node_Str"") IObservableValue<?> dateObservable=BeanProperties.value(Properties.start.name()).observe(model);
  context.bindValue(new SimpleDateTimeDateSelectionProperty().observe(valueDate.getControl()),dateObservable);
  List<Integer> available=new ArrayList<>();
  for (int ii=1; ii <= 12; ii++)   available.add(ii);
  ComboInput interval=new ComboInput(editArea,Messages.ColumnInterval);
  interval.value.setInput(available);
  interval.value.setLabelProvider(new LabelProvider(){
    @Override public String getText(    Object element){
      int interval=(Integer)element;
      return MessageFormat.format(Messages.InvestmentPlanIntervalLabel,interval);
    }
  }
);
  interval.bindValue(Properties.interval.name(),MessageFormat.format(Messages.MsgDialogInputRequired,Messages.ColumnInterval));
  Input amount=new Input(editArea,Messages.ColumnAmount);
  amount.bindValue(Properties.amount.name(),Messages.ColumnAmount,Values.Amount,true);
  amount.bindCurrency(Properties.transactionCurrencyCode.name());
  Input fees=null;
  if (planType == PortfolioTransaction.class) {
    fees=new Input(editArea,Messages.ColumnFees);
    fees.bindValue(Properties.fees.name(),Messages.ColumnAmount,Values.Amount,false);
    fees.bindCurrency(Properties.transactionCurrencyCode.name());
  }
  int amountWidth=amountWidth(amount.value);
  int currencyWidth=currencyWidth(amount.currency);
  FormDataFactory factory=startingWith(valueName,lblName).width(3 * amountWidth);
  if (portfolio != null) {
    factory=factory.thenBelow(portfolio.value.getControl()).label(portfolio.label).thenBelow(securities.value.getControl()).label(securities.label).suffix(securities.currency,currencyWidth);
  }
  factory=factory.thenBelow(account.value.getControl()).label(account.label).suffix(account.currency,currencyWidth).thenBelow(labelAutoGenerate,10).thenBelow(valueDate.getControl(),10).label(lblDate).thenBelow(amount.value,10).width(amountWidth).label(amount.label).suffix(amount.currency,currencyWidth);
  if (fees != null) {
    factory.thenBelow(fees.value).width(amountWidth).label(fees.label).suffix(fees.currency,currencyWidth);
  }
  startingWith(labelAutoGenerate).thenLeft(buttonAutoGenerate);
  startingWith(valueDate.getControl()).thenRight(interval.label).thenRight(interval.value.getControl());
  int widest=widest(lblName,securities != null ? securities.label : null,portfolio != null ? portfolio.label : null,account.label,lblDate,interval.label,amount.label,fees != null ? fees.label : null);
  startingWith(lblName).width(widest);
  WarningMessages warnings=new WarningMessages(this);
  warnings.add(() -> model().getStart().isAfter(LocalDate.now()) ? Messages.MsgDateIsInTheFuture : null);
  model.addPropertyChangeListener(Properties.start.name(),e -> warnings.check());
}",0.9227990112188628
52674,"@Inject public InvestmentPlanDialog(@Named(IServiceConstants.ACTIVE_SHELL) Shell parentShell,Client client,Class<? extends Transaction> planType){
  super(parentShell);
  this.client=client;
  this.planType=planType;
  setModel(new InvestmentPlanModel(client));
}","@Inject public InvestmentPlanDialog(@Named(IServiceConstants.ACTIVE_SHELL) Shell parentShell,Client client,Class<? extends Transaction> planType){
  super(parentShell);
  this.client=client;
  this.planType=planType;
  setModel(new InvestmentPlanModel(client,planType));
}",0.983177570093458
52675,"public InvestmentPlanModel(Client client){
  this.client=client;
}","public InvestmentPlanModel(Client client,Class<? extends Transaction> planType){
  this.client=client;
  if (planType == AccountTransaction.class)   portfolio=DEPOSIT;
}",0.5617021276595745
52676,"public void setPortfolio(Portfolio portfolio){
  String oldTransactionCurrency=getTransactionCurrencyCode();
  if (portfolio.equals(InvestmentPlanModel.DEPOSIT))   firePropertyChange(Properties.security.name(),this.security,this.security=null);
  firePropertyChange(Properties.portfolio.name(),this.portfolio,this.portfolio=portfolio);
  firePropertyChange(Properties.transactionCurrencyCode.name(),oldTransactionCurrency,getTransactionCurrencyCode());
  firePropertyChange(Properties.calculationStatus.name(),this.calculationStatus,this.calculationStatus=calculateStatus());
}","public void setPortfolio(Portfolio portfolio){
  String oldTransactionCurrency=getTransactionCurrencyCode();
  if (DEPOSIT.equals(portfolio))   firePropertyChange(Properties.security.name(),this.security,this.security=null);
  firePropertyChange(Properties.portfolio.name(),this.portfolio,this.portfolio=portfolio);
  firePropertyChange(Properties.transactionCurrencyCode.name(),oldTransactionCurrency,getTransactionCurrencyCode());
  firePropertyChange(Properties.calculationStatus.name(),this.calculationStatus,this.calculationStatus=calculateStatus());
}",0.9523809523809524
52677,"@Override public void onModified(Object element,Object newValue,Object oldValue){
  InvestmentPlan plan=(InvestmentPlan)element;
  if (plan.getAccount() != null && plan.getAccount().equals(InvestmentPlanModel.DELIVERY))   plan.setAccount(null);
  markDirty();
}","@Override public void onModified(Object element,Object newValue,Object oldValue){
  markDirty();
}",0.5459610027855153
52678,"private void addColumns(ShowHideColumnHelper support){
  Column column=new NameColumn(""String_Node_Str"",Messages.ColumnName,SWT.None,100);
  column.getEditingSupport().addListener(this);
  support.addColumn(column);
  column=new Column(Messages.ColumnSecurity,SWT.NONE,250);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return plan.getSecurity() != null ? plan.getSecurity().getName() : null;
    }
    @Override public Image getImage(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return (plan.getSecurity() != null ? Images.SECURITY.image() : null);
    }
  }
);
  ColumnViewerSorter.create(Security.class,""String_Node_Str"").attachTo(column);
  List<Security> securities=new ArrayList<>(getClient().getSecurities());
  Collections.sort(securities,new Security.ByName());
  new ListEditingSupport(InvestmentPlan.class,""String_Node_Str"",securities).addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnPortfolio,SWT.None,120);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return plan.getPortfolio() != null ? plan.getPortfolio().getName() : Messages.InvestmentPlanOptionDeposit;
    }
    @Override public Image getImage(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return plan.getPortfolio() != null ? Images.PORTFOLIO.image() : null;
    }
  }
);
  ColumnViewerSorter.create(InvestmentPlan.class,""String_Node_Str"").attachTo(column);
  new ListEditingSupport(InvestmentPlan.class,""String_Node_Str"",getClient().getActivePortfolios()).addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnAccount,SWT.None,120);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return plan.getAccount() != null ? plan.getAccount().getName() : Messages.InvestmentPlanOptionDelivery;
    }
    @Override public Image getImage(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return plan.getAccount() != null ? Images.ACCOUNT.image() : null;
    }
  }
);
  ColumnViewerSorter.create(Account.class,""String_Node_Str"").attachTo(column);
  List<Account> accounts=new ArrayList<>();
  accounts.add(InvestmentPlanModel.DELIVERY);
  accounts.addAll(getClient().getAccounts());
  new ListEditingSupport(InvestmentPlan.class,""String_Node_Str"",accounts).addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnStartDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      return Values.Date.format(((InvestmentPlan)e).getStart());
    }
  }
);
  ColumnViewerSorter.create(InvestmentPlan.class,""String_Node_Str"").attachTo(column);
  new DateEditingSupport(InvestmentPlan.class,""String_Node_Str"").addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnInterval,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      return MessageFormat.format(Messages.InvestmentPlanIntervalLabel,((InvestmentPlan)e).getInterval());
    }
  }
);
  ColumnViewerSorter.create(InvestmentPlan.class,""String_Node_Str"").attachTo(column);
  List<Integer> available=new ArrayList<>();
  for (int ii=1; ii <= 12; ii++)   available.add(ii);
  new ListEditingSupport(InvestmentPlan.class,""String_Node_Str"",available).addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnAmount,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return Values.Money.format(Money.of(plan.getCurrencyCode(),plan.getAmount()));
    }
  }
);
  ColumnViewerSorter.create(InvestmentPlan.class,""String_Node_Str"").attachTo(column);
  new ValueEditingSupport(InvestmentPlan.class,""String_Node_Str"",Values.Amount).addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnFees,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return Values.Money.format(Money.of(plan.getCurrencyCode(),plan.getFees()));
    }
  }
);
  ColumnViewerSorter.create(InvestmentPlan.class,""String_Node_Str"").attachTo(column);
  new ValueEditingSupport(InvestmentPlan.class,""String_Node_Str"",Values.Amount).addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnAutoGenerate,SWT.LEFT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      return ""String_Node_Str"";
    }
    @Override public Image getImage(    Object e){
      return ((InvestmentPlan)e).isAutoGenerate() ? Images.CHECK.image() : null;
    }
  }
);
  ColumnViewerSorter.create(InvestmentPlan.class,""String_Node_Str"").attachTo(column);
  new BooleanEditingSupport(InvestmentPlan.class,""String_Node_Str"").addListener(this).attachTo(column);
  support.addColumn(column);
  column=new NoteColumn();
  column.getEditingSupport().addListener(this);
  column.setVisible(false);
  support.addColumn(column);
}","private void addColumns(ShowHideColumnHelper support){
  Column column=new NameColumn(""String_Node_Str"",Messages.ColumnName,SWT.None,100);
  column.getEditingSupport().addListener(this);
  support.addColumn(column);
  column=new Column(Messages.ColumnSecurity,SWT.NONE,250);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return plan.getSecurity() != null ? plan.getSecurity().getName() : null;
    }
    @Override public Image getImage(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return (plan.getSecurity() != null ? Images.SECURITY.image() : null);
    }
  }
);
  ColumnViewerSorter.create(Security.class,""String_Node_Str"").attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnPortfolio,SWT.None,120);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return plan.getPortfolio() != null ? plan.getPortfolio().getName() : Messages.InvestmentPlanOptionDeposit;
    }
    @Override public Image getImage(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return plan.getPortfolio() != null ? Images.PORTFOLIO.image() : null;
    }
  }
);
  ColumnViewerSorter.create(InvestmentPlan.class,""String_Node_Str"").attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnAccount,SWT.None,120);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return plan.getAccount() != null ? plan.getAccount().getName() : Messages.InvestmentPlanOptionDelivery;
    }
    @Override public Image getImage(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return plan.getAccount() != null ? Images.ACCOUNT.image() : null;
    }
  }
);
  ColumnViewerSorter.create(Account.class,""String_Node_Str"").attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnStartDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      return Values.Date.format(((InvestmentPlan)e).getStart());
    }
  }
);
  ColumnViewerSorter.create(InvestmentPlan.class,""String_Node_Str"").attachTo(column);
  new DateEditingSupport(InvestmentPlan.class,""String_Node_Str"").addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnInterval,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      return MessageFormat.format(Messages.InvestmentPlanIntervalLabel,((InvestmentPlan)e).getInterval());
    }
  }
);
  ColumnViewerSorter.create(InvestmentPlan.class,""String_Node_Str"").attachTo(column);
  List<Integer> available=new ArrayList<>();
  for (int ii=1; ii <= 12; ii++)   available.add(ii);
  new ListEditingSupport(InvestmentPlan.class,""String_Node_Str"",available).addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnAmount,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return Values.Money.format(Money.of(plan.getCurrencyCode(),plan.getAmount()));
    }
  }
);
  ColumnViewerSorter.create(InvestmentPlan.class,""String_Node_Str"").attachTo(column);
  new ValueEditingSupport(InvestmentPlan.class,""String_Node_Str"",Values.Amount).addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnFees,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      InvestmentPlan plan=(InvestmentPlan)e;
      return Values.Money.format(Money.of(plan.getCurrencyCode(),plan.getFees()));
    }
  }
);
  ColumnViewerSorter.create(InvestmentPlan.class,""String_Node_Str"").attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnAutoGenerate,SWT.LEFT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      return ""String_Node_Str"";
    }
    @Override public Image getImage(    Object e){
      return ((InvestmentPlan)e).isAutoGenerate() ? Images.CHECK.image() : null;
    }
  }
);
  ColumnViewerSorter.create(InvestmentPlan.class,""String_Node_Str"").attachTo(column);
  new BooleanEditingSupport(InvestmentPlan.class,""String_Node_Str"").addListener(this).attachTo(column);
  support.addColumn(column);
  column=new NoteColumn();
  column.getEditingSupport().addListener(this);
  column.setVisible(false);
  support.addColumn(column);
}",0.928118599434312
52679,"protected void configureShell(Shell shell){
  super.configureShell(shell);
  shell.setText(Messages.LabelReportInterval);
}","@Override protected void configureShell(Shell shell){
  super.configureShell(shell);
  shell.setText(Messages.LabelReportInterval);
}",0.9609375
52680,"@Override protected Control createDialogArea(Composite parent){
  Composite container=(Composite)super.createDialogArea(parent);
  Composite tableArea=new Composite(container,SWT.NONE);
  GridDataFactory.fillDefaults().grab(true,true).minSize(SWT.DEFAULT,200).applyTo(tableArea);
  TableColumnLayout layout=new TableColumnLayout();
  tableArea.setLayout(layout);
  tableViewer=new TableViewer(tableArea,SWT.BORDER | SWT.MULTI | SWT.MULTI);
  final Table table=tableViewer.getTable();
  table.setHeaderVisible(false);
  table.setLinesVisible(false);
  TableViewerColumn column=new TableViewerColumn(tableViewer,SWT.None);
  layout.setColumnData(column.getColumn(),new ColumnWeightData(100));
  tableViewer.setLabelProvider(new LabelProvider(){
    @Override public Image getImage(    Object element){
      return Images.TEXT.image();
    }
  }
);
  tableViewer.setContentProvider(ArrayContentProvider.getInstance());
  tableViewer.setInput(periods);
  new ContextMenu(tableViewer.getTable(),m -> fillContextMenu(m)).hook();
  return container;
}","@Override protected Control createDialogArea(Composite parent){
  Composite container=(Composite)super.createDialogArea(parent);
  Composite tableArea=new Composite(container,SWT.NONE);
  GridDataFactory.fillDefaults().grab(true,true).minSize(SWT.DEFAULT,200).applyTo(tableArea);
  TableColumnLayout layout=new TableColumnLayout();
  tableArea.setLayout(layout);
  tableViewer=new TableViewer(tableArea,SWT.BORDER | SWT.MULTI);
  final Table table=tableViewer.getTable();
  table.setHeaderVisible(false);
  table.setLinesVisible(false);
  TableViewerColumn column=new TableViewerColumn(tableViewer,SWT.None);
  layout.setColumnData(column.getColumn(),new ColumnWeightData(100));
  tableViewer.setLabelProvider(new LabelProvider(){
    @Override public Image getImage(    Object element){
      return Images.TEXT.image();
    }
  }
);
  tableViewer.setContentProvider(ArrayContentProvider.getInstance());
  tableViewer.setInput(periods);
  new ContextMenu(tableViewer.getTable(),this::fillContextMenu).hook();
  return container;
}",0.98747591522158
52681,"public void setShares(long shares){
  firePropertyChange(Properties.shares.name(),this.shares,this.shares=shares);
  if (quote.doubleValue() != 0) {
    triggerGrossValue(Math.round(shares * quote.doubleValue() * Values.Amount.factor() / Values.Share.divider()));
  }
 else   if (grossValue != 0 && shares != 0) {
    setQuote(new BigDecimal(grossValue * Values.Share.factor() / (shares * Values.Amount.divider())));
  }
  firePropertyChange(Properties.calculationStatus.name(),this.calculationStatus,this.calculationStatus=calculateStatus());
}","public void setShares(long shares){
  firePropertyChange(Properties.shares.name(),this.shares,this.shares=shares);
  if (quote.doubleValue() != 0) {
    triggerGrossValue(Math.round(shares * quote.doubleValue() * Values.Amount.factor() / Values.Share.divider()));
  }
 else   if (grossValue != 0 && shares != 0) {
    setQuote(BigDecimal.valueOf(grossValue * Values.Share.factor() / (shares * Values.Amount.divider())));
  }
  firePropertyChange(Properties.calculationStatus.name(),this.calculationStatus,this.calculationStatus=calculateStatus());
}",0.9890310786106032
52682,"public void setGrossValue(long grossValue){
  triggerGrossValue(grossValue);
  if (shares != 0) {
    BigDecimal newQuote=new BigDecimal(grossValue * Values.Share.factor() / (shares * Values.Amount.divider()));
    firePropertyChange(Properties.quote.name(),this.quote,this.quote=newQuote);
  }
  firePropertyChange(Properties.calculationStatus.name(),this.calculationStatus,this.calculationStatus=calculateStatus());
}","public void setGrossValue(long grossValue){
  triggerGrossValue(grossValue);
  if (shares != 0) {
    BigDecimal newQuote=BigDecimal.valueOf(grossValue * Values.Share.factor() / (shares * Values.Amount.divider()));
    firePropertyChange(Properties.quote.name(),this.quote,this.quote=newQuote);
  }
  firePropertyChange(Properties.calculationStatus.name(),this.calculationStatus,this.calculationStatus=calculateStatus());
}",0.985748218527316
52683,"public void setTotal(long total){
  triggerTotal(total);
  firePropertyChange(Properties.convertedGrossValue.name(),this.convertedGrossValue,this.convertedGrossValue=calculateConvertedGrossValue());
  firePropertyChange(Properties.grossValue.name(),this.grossValue,this.grossValue=Math.round(convertedGrossValue / exchangeRate.doubleValue()));
  if (shares != 0)   firePropertyChange(Properties.quote.name(),this.quote,this.quote=new BigDecimal(grossValue * Values.Share.factor() / (shares * Values.Amount.divider())));
  firePropertyChange(Properties.calculationStatus.name(),this.calculationStatus,this.calculationStatus=calculateStatus());
}","public void setTotal(long total){
  triggerTotal(total);
  firePropertyChange(Properties.convertedGrossValue.name(),this.convertedGrossValue,this.convertedGrossValue=calculateConvertedGrossValue());
  firePropertyChange(Properties.grossValue.name(),this.grossValue,this.grossValue=Math.round(convertedGrossValue / exchangeRate.doubleValue()));
  if (shares != 0)   firePropertyChange(Properties.quote.name(),this.quote,this.quote=BigDecimal.valueOf(grossValue * Values.Share.factor() / (shares * Values.Amount.divider())));
  firePropertyChange(Properties.calculationStatus.name(),this.calculationStatus,this.calculationStatus=calculateStatus());
}",0.9907120743034056
52684,"protected void updateSharesAndQuote(){
  if (hasSource())   return;
  if (type == PortfolioTransaction.Type.SELL || type == PortfolioTransaction.Type.DELIVERY_OUTBOUND) {
    boolean hasPosition=false;
    if (portfolio != null) {
      CurrencyConverter converter=new CurrencyConverterImpl(getExchangeRateProviderFactory(),CurrencyUnit.EUR);
      PortfolioSnapshot snapshot=PortfolioSnapshot.create(portfolio,converter,date);
      SecurityPosition position=snapshot.getPositionsBySecurity().get(security);
      if (position != null) {
        setShares(position.getShares());
        setTotal(position.calculateValue().getAmount());
        hasPosition=true;
      }
    }
    if (!hasPosition) {
      setShares(0);
      setQuote(new BigDecimal(security.getSecurityPrice(date).getValue() / Values.Quote.divider()));
    }
  }
 else {
    setQuote(new BigDecimal(security.getSecurityPrice(date).getValue() / Values.Quote.divider()));
  }
}","protected void updateSharesAndQuote(){
  if (hasSource())   return;
  if (type == PortfolioTransaction.Type.SELL || type == PortfolioTransaction.Type.DELIVERY_OUTBOUND) {
    boolean hasPosition=false;
    if (portfolio != null) {
      CurrencyConverter converter=new CurrencyConverterImpl(getExchangeRateProviderFactory(),CurrencyUnit.EUR);
      PortfolioSnapshot snapshot=PortfolioSnapshot.create(portfolio,converter,date);
      SecurityPosition position=snapshot.getPositionsBySecurity().get(security);
      if (position != null) {
        setShares(position.getShares());
        setTotal(position.calculateValue().getAmount());
        hasPosition=true;
      }
    }
    if (!hasPosition) {
      setShares(0);
      setQuote(BigDecimal.valueOf(security.getSecurityPrice(date).getValue() / Values.Quote.divider()));
    }
  }
 else {
    setQuote(BigDecimal.valueOf(security.getSecurityPrice(date).getValue() / Values.Quote.divider()));
  }
}",0.9873417721518988
52685,"protected void fillFromTransaction(PortfolioTransaction transaction){
  this.security=transaction.getSecurity();
  LocalDateTime transactionDate=transaction.getDateTime();
  this.date=transactionDate.toLocalDate();
  this.time=transactionDate.toLocalTime();
  this.shares=transaction.getShares();
  this.total=transaction.getAmount();
  this.note=transaction.getNote();
  this.exchangeRate=BigDecimal.ONE;
  transaction.getUnits().forEach(unit -> {
switch (unit.getType()) {
case GROSS_VALUE:
      this.exchangeRate=unit.getExchangeRate();
    this.grossValue=unit.getForex().getAmount();
  this.quote=new BigDecimal(this.grossValue * Values.Share.factor() / (this.shares * Values.Amount.divider()));
break;
case FEE:
if (unit.getForex() != null) this.forexFees+=unit.getForex().getAmount();
 else this.fees+=unit.getAmount().getAmount();
break;
case TAX:
if (unit.getForex() != null) this.forexTaxes+=unit.getForex().getAmount();
 else this.taxes+=unit.getAmount().getAmount();
break;
default :
throw new UnsupportedOperationException();
}
}
);
this.convertedGrossValue=calculateConvertedGrossValue();
if (exchangeRate.equals(BigDecimal.ONE)) {
this.grossValue=convertedGrossValue;
this.quote=transaction.getGrossPricePerShare().toBigDecimal();
}
firePropertyChange(Properties.calculationStatus.name(),this.calculationStatus,this.calculationStatus=calculateStatus());
}","protected void fillFromTransaction(PortfolioTransaction transaction){
  this.security=transaction.getSecurity();
  LocalDateTime transactionDate=transaction.getDateTime();
  this.date=transactionDate.toLocalDate();
  this.time=transactionDate.toLocalTime();
  this.shares=transaction.getShares();
  this.total=transaction.getAmount();
  this.note=transaction.getNote();
  this.exchangeRate=BigDecimal.ONE;
  transaction.getUnits().forEach(unit -> {
switch (unit.getType()) {
case GROSS_VALUE:
      this.exchangeRate=unit.getExchangeRate();
    this.grossValue=unit.getForex().getAmount();
  this.quote=BigDecimal.valueOf(this.grossValue * Values.Share.factor() / (this.shares * Values.Amount.divider()));
break;
case FEE:
if (unit.getForex() != null) this.forexFees+=unit.getForex().getAmount();
 else this.fees+=unit.getAmount().getAmount();
break;
case TAX:
if (unit.getForex() != null) this.forexTaxes+=unit.getForex().getAmount();
 else this.taxes+=unit.getAmount().getAmount();
break;
default :
throw new UnsupportedOperationException();
}
}
);
this.convertedGrossValue=calculateConvertedGrossValue();
if (exchangeRate.equals(BigDecimal.ONE)) {
this.grossValue=convertedGrossValue;
this.quote=transaction.getGrossPricePerShare().toBigDecimal();
}
firePropertyChange(Properties.calculationStatus.name(),this.calculationStatus,this.calculationStatus=calculateStatus());
}",0.9956300072833212
52686,"public void setShares(long shares){
  firePropertyChange(Properties.shares.name(),this.shares,this.shares=shares);
  if (quote.doubleValue() != 0) {
    setAmount(Math.round(shares * quote.doubleValue() * Values.Amount.factor() / Values.Share.divider()));
  }
 else   if (amount != 0 && shares != 0) {
    setQuote(new BigDecimal(amount * Values.Share.factor() / (shares * Values.Amount.divider())));
  }
  firePropertyChange(Properties.calculationStatus.name(),this.calculationStatus,this.calculationStatus=calculateStatus());
}","public void setShares(long shares){
  firePropertyChange(Properties.shares.name(),this.shares,this.shares=shares);
  if (quote.doubleValue() != 0) {
    setAmount(Math.round(shares * quote.doubleValue() * Values.Amount.factor() / Values.Share.divider()));
  }
 else   if (amount != 0 && shares != 0) {
    setQuote(BigDecimal.valueOf(amount * Values.Share.factor() / (shares * Values.Amount.divider())));
  }
  firePropertyChange(Properties.calculationStatus.name(),this.calculationStatus,this.calculationStatus=calculateStatus());
}",0.9887005649717514
52687,"private void updateSharesAndQuote(){
  if (source != null)   return;
  SecurityPosition position=null;
  if (security != null) {
    CurrencyConverter converter=new CurrencyConverterImpl(getExchangeRateProviderFactory(),client.getBaseCurrency());
    PortfolioSnapshot snapshot=sourcePortfolio != null ? PortfolioSnapshot.create(sourcePortfolio,converter,date) : ClientSnapshot.create(client,converter,date).getJointPortfolio();
    position=snapshot.getPositionsBySecurity().get(security);
  }
  if (position != null) {
    setShares(position.getShares());
    setAmount(position.calculateValue().getAmount());
  }
 else   if (security != null) {
    setShares(0);
    setQuote(new BigDecimal(security.getSecurityPrice(date).getValue() / Values.Quote.divider()));
  }
 else {
    setShares(0);
    setQuote(BigDecimal.ZERO);
  }
}","private void updateSharesAndQuote(){
  if (source != null)   return;
  SecurityPosition position=null;
  if (security != null) {
    CurrencyConverter converter=new CurrencyConverterImpl(getExchangeRateProviderFactory(),client.getBaseCurrency());
    PortfolioSnapshot snapshot=sourcePortfolio != null ? PortfolioSnapshot.create(sourcePortfolio,converter,date) : ClientSnapshot.create(client,converter,date).getJointPortfolio();
    position=snapshot.getPositionsBySecurity().get(security);
  }
  if (position != null) {
    setShares(position.getShares());
    setAmount(position.calculateValue().getAmount());
  }
 else   if (security != null) {
    setShares(0);
    setQuote(BigDecimal.valueOf(security.getSecurityPrice(date).getValue() / Values.Quote.divider()));
  }
 else {
    setShares(0);
    setQuote(BigDecimal.ZERO);
  }
}",0.992797118847539
52688,"public void setAmount(long amount){
  triggerAmount(amount);
  if (shares != 0) {
    BigDecimal newQuote=new BigDecimal(amount * Values.Share.factor() / (shares * Values.Amount.divider()));
    firePropertyChange(Properties.quote.name(),this.quote,this.quote=newQuote);
  }
  firePropertyChange(Properties.calculationStatus.name(),this.calculationStatus,this.calculationStatus=calculateStatus());
}","public void setAmount(long amount){
  triggerAmount(amount);
  if (shares != 0) {
    BigDecimal newQuote=BigDecimal.valueOf(amount * Values.Share.factor() / (shares * Values.Amount.divider()));
    firePropertyChange(Properties.quote.name(),this.quote,this.quote=newQuote);
  }
  firePropertyChange(Properties.calculationStatus.name(),this.calculationStatus,this.calculationStatus=calculateStatus());
}",0.9850374064837906
52689,"public UpdateHelper(IWorkbench workbench,EPartService partService) throws CoreException {
  this.workbench=workbench;
  this.partService=partService;
  this.agent=getService(IProvisioningAgent.class,IProvisioningAgent.SERVICE_NAME);
  IProfileRegistry profileRegistry=(IProfileRegistry)agent.getService(IProfileRegistry.SERVICE_NAME);
  IProfile profile=profileRegistry.getProfile(IProfileRegistry.SELF);
  if (profile == null) {
    IStatus status=new Status(IStatus.ERROR,PortfolioPlugin.PLUGIN_ID,Messages.MsgNoProfileFound);
    throw new CoreException(status);
  }
}","public UpdateHelper(IWorkbench workbench,EPartService partService) throws CoreException {
  this.workbench=workbench;
  this.partService=partService;
  this.agent=getService(IProvisioningAgent.class,IProvisioningAgent.SERVICE_NAME);
  if (agent == null) {
    IStatus status=new Status(IStatus.ERROR,PortfolioPlugin.PLUGIN_ID,Messages.MsgNoProfileFound);
    throw new CoreException(status);
  }
  IProfileRegistry profileRegistry=(IProfileRegistry)agent.getService(IProfileRegistry.SERVICE_NAME);
  IProfile profile=profileRegistry.getProfile(IProfileRegistry.SELF);
  if (profile == null) {
    IStatus status=new Status(IStatus.ERROR,PortfolioPlugin.PLUGIN_ID,Messages.MsgNoProfileFound);
    throw new CoreException(status);
  }
}",0.8750957854406131
52690,"private void onTickerSymbolChanged(){
  boolean hasTicker=model.getTickerSymbol() != null && !model.getTickerSymbol().isEmpty();
  if (!hasTicker) {
    clearSampleQuotes();
    setStatus(""String_Node_Str"");
  }
 else {
    QuoteFeed feed=(QuoteFeed)((IStructuredSelection)comboProvider.getSelection()).getFirstElement();
    showSampleQuotes(feed,null);
    setStatus(null);
  }
}","private void onTickerSymbolChanged(){
  boolean hasTicker=model.getTickerSymbol() != null && !model.getTickerSymbol().isEmpty();
  if (!hasTicker) {
    clearSampleQuotes();
    setStatus(MessageFormat.format(Messages.MsgDialogInputRequired,Messages.ColumnTicker));
  }
 else {
    QuoteFeed feed=(QuoteFeed)((IStructuredSelection)comboProvider.getSelection()).getFirstElement();
    showSampleQuotes(feed,null);
    setStatus(null);
  }
}",0.8878048780487805
52691,"@Override public boolean updateHistoricalQuotes(Security security,List<Exception> errors){
  OutputSize outputSize=OutputSize.FULL;
  if (!security.getPrices().isEmpty()) {
    SecurityPrice lastHistoricalQuote=security.getPrices().get(security.getPrices().size() - 1);
    int days=Dates.daysBetween(lastHistoricalQuote.getTime(),LocalDate.now());
    outputSize=days >= DAYS_THRESHOLD ? OutputSize.FULL : OutputSize.COMPACT;
  }
  List<SecurityPrice> prices=getHistoricalQuotes(SecurityPrice.class,security,outputSize,errors);
  boolean isUpdated=false;
  for (  SecurityPrice p : prices) {
    boolean isAdded=security.addPrice(p);
    isUpdated=isUpdated || isAdded;
  }
  return isUpdated;
}","@Override public boolean updateHistoricalQuotes(Security security,List<Exception> errors){
  OutputSize outputSize=OutputSize.FULL;
  if (!security.getPrices().isEmpty()) {
    SecurityPrice lastHistoricalQuote=security.getPrices().get(security.getPrices().size() - 1);
    int days=Dates.daysBetween(lastHistoricalQuote.getDate(),LocalDate.now());
    outputSize=days >= DAYS_THRESHOLD ? OutputSize.FULL : OutputSize.COMPACT;
  }
  List<SecurityPrice> prices=getHistoricalQuotes(SecurityPrice.class,security,outputSize,errors);
  boolean isUpdated=false;
  for (  SecurityPrice p : prices) {
    boolean isAdded=security.addPrice(p);
    isUpdated=isUpdated || isAdded;
  }
  return isUpdated;
}",0.9956896551724138
52692,"@Override public boolean updateLatestQuotes(Security security,List<Exception> errors){
  if (apiKey == null)   throw new IllegalArgumentException(Messages.MsgAlphaVantageAPIKeyMissing);
  String wknUrl=MessageFormat.format(""String_Node_Str"" + ""String_Node_Str"",security.getTickerSymbol(),apiKey);
  try {
    URL obj=new URL(wknUrl);
    HttpURLConnection con=(HttpURLConnection)obj.openConnection();
    con.setConnectTimeout(1000);
    con.setReadTimeout(20000);
    int responseCode=con.getResponseCode();
    if (responseCode != HttpURLConnection.HTTP_OK)     throw new IOException(wknUrl + ""String_Node_Str"" + responseCode);
    try (Scanner scanner=new Scanner(con.getInputStream(),StandardCharsets.UTF_8.name())){
      String body=scanner.useDelimiter(""String_Node_Str"").next();
      String[] lines=body.split(""String_Node_Str"");
      if (lines.length <= 2)       return false;
      if (!""String_Node_Str"".equals(lines[0])) {
        errors.add(new IOException(MessageFormat.format(Messages.MsgUnexpectedHeader,body)));
        return false;
      }
      String line=lines[1];
      String[] values=line.split(""String_Node_Str"");
      if (values.length != 6)       throw new IOException(MessageFormat.format(Messages.MsgUnexpectedValue,line));
      DateTimeFormatter formatter=DateTimeFormatter.ofPattern(""String_Node_Str"");
      LatestSecurityPrice price=new LatestSecurityPrice();
      price.setTime(LocalDate.parse(values[0],formatter));
      price.setValue(asPrice(values[4]));
      price.setHigh(asPrice(values[2]));
      price.setLow(asPrice(values[3]));
      price.setVolume(Long.parseLong(values[5]));
      price.setPreviousClose(LatestSecurityPrice.NOT_AVAILABLE);
      security.setLatest(price);
      return true;
    }
   }
 catch (  IOException|ParseException e) {
    errors.add(e);
    return false;
  }
}","@Override public boolean updateLatestQuotes(Security security,List<Exception> errors){
  if (apiKey == null)   throw new IllegalArgumentException(Messages.MsgAlphaVantageAPIKeyMissing);
  String wknUrl=MessageFormat.format(""String_Node_Str"" + ""String_Node_Str"",security.getTickerSymbol(),apiKey);
  try {
    URL obj=new URL(wknUrl);
    HttpURLConnection con=(HttpURLConnection)obj.openConnection();
    con.setConnectTimeout(1000);
    con.setReadTimeout(20000);
    int responseCode=con.getResponseCode();
    if (responseCode != HttpURLConnection.HTTP_OK)     throw new IOException(wknUrl + ""String_Node_Str"" + responseCode);
    try (Scanner scanner=new Scanner(con.getInputStream(),StandardCharsets.UTF_8.name())){
      String body=scanner.useDelimiter(""String_Node_Str"").next();
      String[] lines=body.split(""String_Node_Str"");
      if (lines.length <= 2)       return false;
      if (!""String_Node_Str"".equals(lines[0])) {
        errors.add(new IOException(MessageFormat.format(Messages.MsgUnexpectedHeader,body)));
        return false;
      }
      String line=lines[1];
      String[] values=line.split(""String_Node_Str"");
      if (values.length != 6)       throw new IOException(MessageFormat.format(Messages.MsgUnexpectedValue,line));
      DateTimeFormatter formatter=DateTimeFormatter.ofPattern(""String_Node_Str"");
      LatestSecurityPrice price=new LatestSecurityPrice();
      price.setDate(LocalDate.parse(values[0],formatter));
      price.setValue(asPrice(values[4]));
      price.setHigh(asPrice(values[2]));
      price.setLow(asPrice(values[3]));
      price.setVolume(Long.parseLong(values[5]));
      price.setPreviousClose(LatestSecurityPrice.NOT_AVAILABLE);
      security.setLatest(price);
      return true;
    }
   }
 catch (  IOException|ParseException e) {
    errors.add(e);
    return false;
  }
}",0.998371335504886
52693,"@Override protected IStatus run(IProgressMonitor monitor){
  try {
    if (startAfterOtherJob != null)     startAfterOtherJob.join();
    Map<InvestmentPlan,List<PortfolioTransaction>> tx=new HashMap<>();
    CurrencyConverterImpl converter=new CurrencyConverterImpl(factory,getClient().getBaseCurrency());
    getClient().getPlans().stream().forEach(plan -> {
      List<PortfolioTransaction> transactions=plan.generateTransactions(converter);
      if (!transactions.isEmpty())       tx.put(plan,transactions);
    }
);
    if (!tx.isEmpty()) {
      Display.getDefault().asyncExec(() -> {
        String message;
        if (tx.size() == 1) {
          Entry<InvestmentPlan,List<PortfolioTransaction>> entry=tx.entrySet().iterator().next();
          message=MessageFormat.format(Messages.InvestmentPlanTxCreated,entry.getKey().getName(),entry.getValue().size());
        }
 else {
          int count=tx.values().stream().mapToInt(List::size).sum();
          StringBuilder builder=new StringBuilder();
          builder.append(MessageFormat.format(Messages.InvestmentPlanTxForMultiplePlansCreated,count));
          for (          Entry<InvestmentPlan,List<PortfolioTransaction>> entry : tx.entrySet())           builder.append(MessageFormat.format(""String_Node_Str"",entry.getKey().getName(),entry.getValue().size()));
          message=builder.toString();
        }
        int buttonIndex=MessageDialog.open(MessageDialog.INFORMATION,Display.getCurrent().getActiveShell(),Messages.LabelInfo,message,SWT.SHEET,IDialogConstants.OK_LABEL,Messages.BtnLabelOpenInvestmentPlanView);
        if (buttonIndex > 0) {
          part.activateView(""String_Node_Str"",null);
        }
      }
);
    }
  }
 catch (  InterruptedException ignore) {
  }
  return Status.OK_STATUS;
}","@Override protected IStatus run(IProgressMonitor monitor){
  try {
    if (startAfterOtherJob != null)     startAfterOtherJob.join();
    Map<InvestmentPlan,List<PortfolioTransaction>> tx=new HashMap<>();
    CurrencyConverterImpl converter=new CurrencyConverterImpl(factory,getClient().getBaseCurrency());
    getClient().getPlans().stream().forEach(plan -> {
      List<PortfolioTransaction> transactions=plan.generateTransactions(converter);
      if (!transactions.isEmpty())       tx.put(plan,transactions);
    }
);
    if (!tx.isEmpty()) {
      Display.getDefault().asyncExec(() -> {
        String message;
        if (tx.size() == 1) {
          Entry<InvestmentPlan,List<PortfolioTransaction>> entry=tx.entrySet().iterator().next();
          message=MessageFormat.format(Messages.InvestmentPlanTxCreated,entry.getKey().getName(),entry.getValue().size());
        }
 else {
          int count=tx.values().stream().mapToInt(List::size).sum();
          StringBuilder builder=new StringBuilder();
          builder.append(MessageFormat.format(Messages.InvestmentPlanTxForMultiplePlansCreated,count));
          for (          Entry<InvestmentPlan,List<PortfolioTransaction>> entry : tx.entrySet())           builder.append(MessageFormat.format(""String_Node_Str"",entry.getKey().getName(),entry.getValue().size()));
          message=builder.toString();
        }
        MessageDialog.openInformation(Display.getCurrent().getActiveShell(),Messages.LabelInfo,message);
      }
);
    }
  }
 catch (  InterruptedException ignore) {
  }
  return Status.OK_STATUS;
}",0.9225246784325456
52694,"/** 
 * Calculates the Simple Moving Average for the given range of days from the given startDate on. The method returns an object containing the X and Y Axes of the generated bollinger bands
 */
private void calculateBollingerBands(){
  if (security == null)   return;
  this.prices=security.getPricesIncludingLatest();
  int index;
  SecurityPrice startPrice=null;
  if (prices == null || prices.size() < calculatedMinimumDays)   return;
  if (startDate == null) {
    startPrice=this.getStartPrice();
    if (startPrice == null)     return;
    index=prices.indexOf(startPrice);
    if (index >= prices.size())     return;
  }
 else {
    startPrice=this.getStartPriceFromStartDate();
    if (startPrice == null)     return;
    index=prices.indexOf(startPrice);
    if (index >= prices.size())     return;
  }
  for (; index < prices.size(); index++) {
    if (index < BollingerBandsDays)     continue;
    LocalDate nextDate=prices.get(index).getTime();
    LocalDate isBefore=nextDate.plusDays(1);
    LocalDate isAfter=prices.get(index - BollingerBandsDays + 2).getTime();
    List<SecurityPrice> filteredPrices=this.getFilteredList(isBefore,isAfter);
    if (filteredPrices.size() < calculatedMinimumDays)     continue;
    double sum=filteredPrices.stream().mapToLong(SecurityPrice::getValue).sum();
    double QuotePriceAverage=sum / Values.Quote.divider() / filteredPrices.size();
    double tempQuotePriceVariance=0;
    for (int i=0; i < filteredPrices.size(); i++) {
      tempQuotePriceVariance+=((filteredPrices.get(i).getValue() / Values.Quote.divider()) - QuotePriceAverage) * ((filteredPrices.get(i).getValue() / Values.Quote.divider()) - QuotePriceAverage);
    }
    Double StandardDeviationBollingerBands=Math.sqrt(tempQuotePriceVariance / (filteredPrices.size() - 1)) * BollingerBandsFactor;
    Double valueBollingerBandsLowerBands=QuotePriceAverage;
    Double valueBollingerBandsUpperBands=QuotePriceAverage;
    valueBollingerBandsLowerBands-=StandardDeviationBollingerBands;
    valueBollingerBandsUpperBands+=StandardDeviationBollingerBands;
    valuesBollingerBandsLowerBands.add(valueBollingerBandsLowerBands);
    valuesBollingerBandsMiddleBands.add(QuotePriceAverage);
    valuesBollingerBandsUpperBands.add(valueBollingerBandsUpperBands);
    datesBollingerBands.add(prices.get(index).getTime());
  }
  LocalDate[] tmpDates=datesBollingerBands.toArray(new LocalDate[0]);
  Double[] tmpPricesLower=valuesBollingerBandsLowerBands.toArray(new Double[0]);
  Double[] tmpPricesMiddle=valuesBollingerBandsMiddleBands.toArray(new Double[0]);
  Double[] tmpPricesUpper=valuesBollingerBandsUpperBands.toArray(new Double[0]);
  this.BollingerBandsLowerBand.setDates(TimelineChart.toJavaUtilDate(tmpDates));
  this.BollingerBandsLowerBand.setValues(ArrayUtils.toPrimitive(tmpPricesLower));
  this.BollingerBandsMiddleBand.setDates(TimelineChart.toJavaUtilDate(tmpDates));
  this.BollingerBandsMiddleBand.setValues(ArrayUtils.toPrimitive(tmpPricesMiddle));
  this.BollingerBandsUpperBand.setDates(TimelineChart.toJavaUtilDate(tmpDates));
  this.BollingerBandsUpperBand.setValues(ArrayUtils.toPrimitive(tmpPricesUpper));
}","/** 
 * Calculates the Simple Moving Average for the given range of days from the given startDate on. The method returns an object containing the X and Y Axes of the generated bollinger bands
 */
private void calculateBollingerBands(){
  if (security == null)   return;
  this.prices=security.getPricesIncludingLatest();
  int index;
  SecurityPrice startPrice=null;
  if (prices == null || prices.size() < BollingerBandsDays + 3)   return;
  if (startDate == null) {
    startPrice=this.getStartPrice();
    if (startPrice == null)     return;
    index=prices.indexOf(startPrice);
    if (index >= prices.size())     return;
  }
 else {
    startPrice=this.getStartPriceFromStartDate();
    if (startPrice == null)     return;
    index=prices.indexOf(startPrice);
    if (index >= prices.size())     return;
  }
  for (; index < prices.size(); index++) {
    if (index < BollingerBandsDays)     continue;
    LocalDate nextDate=prices.get(index).getTime();
    LocalDate isBefore=nextDate.plusDays(1);
    LocalDate isAfter=prices.get(index - BollingerBandsDays + 2).getTime();
    List<SecurityPrice> filteredPrices=this.getFilteredList(isBefore,isAfter);
    if (filteredPrices.size() < calculatedMinimumDays)     continue;
    double sum=filteredPrices.stream().mapToLong(SecurityPrice::getValue).sum();
    double QuotePriceAverage=sum / Values.Quote.divider() / filteredPrices.size();
    double tempQuotePriceVariance=0;
    for (int i=0; i < filteredPrices.size(); i++) {
      tempQuotePriceVariance+=((filteredPrices.get(i).getValue() / Values.Quote.divider()) - QuotePriceAverage) * ((filteredPrices.get(i).getValue() / Values.Quote.divider()) - QuotePriceAverage);
    }
    Double StandardDeviationBollingerBands=Math.sqrt(tempQuotePriceVariance / (filteredPrices.size() - 1)) * BollingerBandsFactor;
    Double valueBollingerBandsLowerBands=QuotePriceAverage;
    Double valueBollingerBandsUpperBands=QuotePriceAverage;
    valueBollingerBandsLowerBands-=StandardDeviationBollingerBands;
    valueBollingerBandsUpperBands+=StandardDeviationBollingerBands;
    valuesBollingerBandsLowerBands.add(valueBollingerBandsLowerBands);
    valuesBollingerBandsMiddleBands.add(QuotePriceAverage);
    valuesBollingerBandsUpperBands.add(valueBollingerBandsUpperBands);
    datesBollingerBands.add(prices.get(index).getTime());
  }
  LocalDate[] tmpDates=datesBollingerBands.toArray(new LocalDate[0]);
  Double[] tmpPricesLower=valuesBollingerBandsLowerBands.toArray(new Double[0]);
  Double[] tmpPricesMiddle=valuesBollingerBandsMiddleBands.toArray(new Double[0]);
  Double[] tmpPricesUpper=valuesBollingerBandsUpperBands.toArray(new Double[0]);
  this.BollingerBandsLowerBand.setDates(TimelineChart.toJavaUtilDate(tmpDates));
  this.BollingerBandsLowerBand.setValues(ArrayUtils.toPrimitive(tmpPricesLower));
  this.BollingerBandsMiddleBand.setDates(TimelineChart.toJavaUtilDate(tmpDates));
  this.BollingerBandsMiddleBand.setValues(ArrayUtils.toPrimitive(tmpPricesMiddle));
  this.BollingerBandsUpperBand.setDates(TimelineChart.toJavaUtilDate(tmpDates));
  this.BollingerBandsUpperBand.setValues(ArrayUtils.toPrimitive(tmpPricesUpper));
}",0.9944329568951804
52695,"@Execute public void execute(@Named(IServiceConstants.ACTIVE_SHELL) Shell shell,final IWorkbench workbench,final EPartService partService){
  try {
    new ProgressMonitorDialog(shell).run(true,true,new IRunnableWithProgress(){
      @Override public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        try {
          UpdateHelper updateHelper=new UpdateHelper(workbench,partService);
          updateHelper.runUpdate(monitor,false);
        }
 catch (        CoreException e) {
          throw new InvocationTargetException(e);
        }
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    PortfolioPlugin.log(e.getCause());
    IStatus status=e.getCause() instanceof CoreException ? ((CoreException)e.getCause()).getStatus() : new Status(Status.ERROR,PortfolioPlugin.PLUGIN_ID,e.getCause().getMessage(),e.getCause());
    ErrorDialog.openError(Display.getDefault().getActiveShell(),Messages.LabelError,Messages.MsgErrorUpdating,status);
  }
catch (  InterruptedException ignore) {
  }
}","@Execute public void execute(@Named(IServiceConstants.ACTIVE_SHELL) Shell shell,final IWorkbench workbench,final EPartService partService){
  try {
    new ProgressMonitorDialog(shell).run(true,true,monitor -> {
      try {
        UpdateHelper updateHelper=new UpdateHelper(workbench,partService);
        updateHelper.runUpdate(monitor,false);
      }
 catch (      CoreException e) {
        PortfolioPlugin.log(e);
        Display.getDefault().asyncExec(() -> ErrorDialog.openError(Display.getDefault().getActiveShell(),Messages.LabelError,Messages.MsgErrorUpdating,e.getStatus()));
      }
    }
);
  }
 catch (  InvocationTargetException|InterruptedException e) {
    PortfolioPlugin.log(e);
  }
}",0.4738636363636364
52696,"private void runUpdateOperation(IProgressMonitor monitor) throws OperationCanceledException, CoreException {
  if (operation == null)   checkForUpdates(monitor);
  ProvisioningJob job=operation.getProvisioningJob(null);
  IStatus status=job.runModal(monitor);
  if (status.getSeverity() == IStatus.CANCEL)   throw new OperationCanceledException();
}","private void runUpdateOperation(IProgressMonitor monitor) throws OperationCanceledException, CoreException {
  if (operation == null)   checkForUpdates(monitor);
  ProvisioningJob job=operation.getProvisioningJob(null);
  IStatus status=job.runModal(monitor);
  if (status.getSeverity() == IStatus.CANCEL)   throw new OperationCanceledException();
  if (status.getSeverity() != IStatus.OK)   throw new CoreException(status);
}",0.9006451612903226
52697,"public void doSaveAs(MPart part,Shell shell,String extension,String encryptionMethod){
  FileDialog dialog=new FileDialog(shell,SWT.SAVE);
  String fileNameProposal=clientFile != null ? clientFile.getName() : part.getLabel();
  if (extension != null && !fileNameProposal.endsWith('.' + extension)) {
    int p=fileNameProposal.lastIndexOf('.');
    fileNameProposal=(p > 0 ? fileNameProposal.substring(0,p + 1) : fileNameProposal + '.') + extension;
  }
  dialog.setFileName(fileNameProposal);
  dialog.setFilterPath(clientFile != null ? clientFile.getAbsolutePath() : System.getProperty(""String_Node_Str""));
  String path=dialog.open();
  if (path == null)   return;
  if (extension != null && !path.endsWith('.' + extension))   path+='.' + extension;
  File localFile=new File(path);
  char[] password=null;
  if (ClientFactory.isEncrypted(localFile)) {
    PasswordDialog pwdDialog=new PasswordDialog(shell);
    if (pwdDialog.open() != PasswordDialog.OK)     return;
    password=pwdDialog.getPassword().toCharArray();
  }
  try {
    clientFile=localFile;
    part.getPersistedState().put(UIConstants.File.PERSISTED_STATE_KEY,clientFile.getAbsolutePath());
    ClientFactory.save(client,clientFile,encryptionMethod,password);
    broker.post(UIConstants.Event.File.SAVED,clientFile.getAbsolutePath());
    dirty.setDirty(false);
    part.setLabel(clientFile.getName());
    part.setTooltip(clientFile.getAbsolutePath());
    storePreferences();
  }
 catch (  IOException e) {
    ErrorDialog.openError(shell,Messages.LabelError,e.getMessage(),new Status(Status.ERROR,PortfolioPlugin.PLUGIN_ID,e.getMessage(),e));
  }
}","public void doSaveAs(MPart part,Shell shell,String extension,String encryptionMethod){
  FileDialog dialog=new FileDialog(shell,SWT.SAVE);
  String fileNameProposal=clientFile != null ? clientFile.getName() : part.getLabel();
  if (extension != null && !fileNameProposal.endsWith('.' + extension)) {
    int p=fileNameProposal.lastIndexOf('.');
    fileNameProposal=(p > 0 ? fileNameProposal.substring(0,p + 1) : fileNameProposal + '.') + extension;
  }
  dialog.setFileName(fileNameProposal);
  dialog.setFilterPath(clientFile != null ? clientFile.getAbsolutePath() : System.getProperty(""String_Node_Str""));
  String path=dialog.open();
  if (path == null)   return;
  if (extension != null && !path.endsWith('.' + extension))   path+='.' + extension;
  File localFile=new File(path);
  char[] password=null;
  if (ClientFactory.isEncrypted(localFile)) {
    PasswordDialog pwdDialog=new PasswordDialog(shell);
    if (pwdDialog.open() != PasswordDialog.OK)     return;
    password=pwdDialog.getPassword().toCharArray();
  }
  try {
    clientFile=localFile;
    part.getPersistedState().put(UIConstants.File.PERSISTED_STATE_KEY,clientFile.getAbsolutePath());
    ClientFactory.save(client,clientFile,encryptionMethod,password);
    broker.post(UIConstants.Event.File.SAVED,clientFile.getAbsolutePath());
    dirty.setDirty(false);
    part.setLabel(clientFile.getName());
    part.setTooltip(clientFile.getAbsolutePath());
    storePreferences();
  }
 catch (  IOException e) {
    PortfolioPlugin.log(e);
    ErrorDialog.openError(shell,Messages.LabelError,e.getMessage(),new Status(Status.ERROR,PortfolioPlugin.PLUGIN_ID,e.getMessage(),e));
  }
}",0.9914477703115456
52698,"private Values(String pattern,double divider,int factor){
  this.pattern=pattern;
  this.divider=divider;
  this.factor=factor;
}","private Values(String pattern,double divider,int factor){
  this.pattern=pattern;
  this.divider=divider;
  this.factor=factor;
  this.bdFactor=BigDecimal.valueOf(factor);
}",0.8543046357615894
52699,"@Override protected <T extends SecurityPrice>void fillValues(String[] values,T price,DecimalFormat priceFormat,DateTimeFormatter dateFormat) throws ParseException {
  super.fillValues(values,price,priceFormat,dateFormat);
  Number q=priceFormat.parse(values[6]);
  long v=(long)(q.doubleValue() * Values.Quote.factor());
  price.setValue(v);
}","@Override protected <T extends SecurityPrice>void fillValues(String[] values,T price,DateTimeFormatter dateFormat) throws ParseException {
  super.fillValues(values,price,dateFormat);
  price.setValue(YahooHelper.asPrice(values[6]));
}",0.7024221453287197
52700,"private <T extends SecurityPrice>List<T> internalGetQuotes(Class<T> klass,Security security,LocalDate startDate,List<Exception> errors){
  if (security.getTickerSymbol() == null) {
    errors.add(new IOException(MessageFormat.format(Messages.MsgMissingTickerSymbol,security.getName())));
    return Collections.emptyList();
  }
  LocalDate stopDate=LocalDate.now();
  String wknUrl=MessageFormat.format(HISTORICAL_URL,security.getTickerSymbol(),startDate.getMonth().getValue() - 1,startDate.getDayOfMonth(),Integer.toString(startDate.getYear()),stopDate.getMonth().getValue() - 1,stopDate.getDayOfMonth(),Integer.toString(stopDate.getYear()));
  List<T> answer=new ArrayList<>();
  String line=null;
  try (BufferedReader reader=openReader(wknUrl,errors)){
    if (reader == null)     return answer;
    line=reader.readLine();
    if (!""String_Node_Str"".equals(line))     throw new IOException(MessageFormat.format(Messages.MsgUnexpectedHeader,line));
    DecimalFormat priceFormat=FMT_PRICE.get();
    DateTimeFormatter dateFormat=DateTimeFormatter.ofPattern(""String_Node_Str"");
    while ((line=reader.readLine()) != null) {
      String[] values=line.split(""String_Node_Str"");
      if (values.length != 7)       throw new IOException(MessageFormat.format(Messages.MsgUnexpectedValue,line));
      T price=klass.newInstance();
      fillValues(values,price,priceFormat,dateFormat);
      answer.add(price);
    }
  }
 catch (  NumberFormatException|ParseException|DateTimeParseException e) {
    errors.add(new IOException(MessageFormat.format(Messages.MsgErrorsConvertingValue,line),e));
  }
catch (  InstantiationException|IllegalAccessException|IOException e) {
    errors.add(e);
  }
  return answer;
}","private <T extends SecurityPrice>List<T> internalGetQuotes(Class<T> klass,Security security,LocalDate startDate,List<Exception> errors){
  if (security.getTickerSymbol() == null) {
    errors.add(new IOException(MessageFormat.format(Messages.MsgMissingTickerSymbol,security.getName())));
    return Collections.emptyList();
  }
  LocalDate stopDate=LocalDate.now();
  String wknUrl=MessageFormat.format(HISTORICAL_URL,security.getTickerSymbol(),startDate.getMonth().getValue() - 1,startDate.getDayOfMonth(),Integer.toString(startDate.getYear()),stopDate.getMonth().getValue() - 1,stopDate.getDayOfMonth(),Integer.toString(stopDate.getYear()));
  List<T> answer=new ArrayList<>();
  String line=null;
  try (BufferedReader reader=openReader(wknUrl,errors)){
    if (reader == null)     return answer;
    line=reader.readLine();
    if (!""String_Node_Str"".equals(line))     throw new IOException(MessageFormat.format(Messages.MsgUnexpectedHeader,line));
    DateTimeFormatter dateFormat=DateTimeFormatter.ofPattern(""String_Node_Str"");
    while ((line=reader.readLine()) != null) {
      String[] values=line.split(""String_Node_Str"");
      if (values.length != 7)       throw new IOException(MessageFormat.format(Messages.MsgUnexpectedValue,line));
      T price=klass.newInstance();
      fillValues(values,price,dateFormat);
      answer.add(price);
    }
  }
 catch (  NumberFormatException|ParseException|DateTimeParseException e) {
    errors.add(new IOException(MessageFormat.format(Messages.MsgErrorsConvertingValue,line),e));
  }
catch (  InstantiationException|IllegalAccessException|IOException e) {
    errors.add(e);
  }
  return answer;
}",0.98244570068432
52701,"protected <T extends SecurityPrice>void fillValues(String[] values,T price,DecimalFormat priceFormat,DateTimeFormatter dateFormat) throws ParseException, DateTimeParseException {
  LocalDate date=LocalDate.parse(values[0],dateFormat);
  Number q=priceFormat.parse(values[4]);
  long v=(long)(q.doubleValue() * Values.Quote.factor());
  price.setTime(date);
  price.setValue(v);
  if (price instanceof LatestSecurityPrice) {
    LatestSecurityPrice latest=(LatestSecurityPrice)price;
    q=priceFormat.parse(values[5]);
    latest.setVolume(q.intValue());
    q=priceFormat.parse(values[2]);
    latest.setHigh((long)(q.doubleValue() * Values.Quote.factor()));
    q=priceFormat.parse(values[3]);
    latest.setLow((long)(q.doubleValue() * Values.Quote.factor()));
  }
}","protected <T extends SecurityPrice>void fillValues(String[] values,T price,DateTimeFormatter dateFormat) throws ParseException, DateTimeParseException {
  LocalDate date=LocalDate.parse(values[0],dateFormat);
  long v=asPrice(values[4]);
  price.setTime(date);
  price.setValue(v);
  if (price instanceof LatestSecurityPrice) {
    LatestSecurityPrice latest=(LatestSecurityPrice)price;
    latest.setVolume(asNumber(values[5]));
    latest.setHigh(asPrice(values[2]));
    latest.setLow(asPrice(values[3]));
  }
}",0.4785658612626656
52702,"static long asPrice(String s) throws ParseException {
  if (""String_Node_Str"".equals(s))   return -1;
  return (long)(FMT_PRICE.get().parse(s).doubleValue() * Values.Quote.factor());
}","static long asPrice(String s) throws ParseException {
  if (""String_Node_Str"".equals(s))   return -1;
  BigDecimal v=(BigDecimal)FMT_PRICE.get().parse(s);
  return v.multiply(Values.Quote.getBigDecimalFactor()).longValue();
}",0.6943765281173594
52703,"@Override protected DecimalFormat initialValue(){
  return new DecimalFormat(""String_Node_Str"",new DecimalFormatSymbols(Locale.US));
}","@Override protected DecimalFormat initialValue(){
  DecimalFormat fmt=new DecimalFormat(""String_Node_Str"",new DecimalFormatSymbols(Locale.US));
  fmt.setParseBigDecimal(true);
  return fmt;
}",0.8
52704,"public void bindBigDecimal(String property,String pattern){
  NumberFormat format=new DecimalFormat(pattern);
  context.bindValue(WidgetProperties.text(SWT.Modify).observe(value),BeanProperties.value(property).observe(model),new UpdateValueStrategy().setConverter(StringToNumberConverter.toBigDecimal()),new UpdateValueStrategy().setConverter(NumberToStringConverter.fromBigDecimal(format)));
}","public void bindBigDecimal(String property,String pattern){
  NumberFormat format=new DecimalFormat(pattern);
  IValidatingConverter converter=IValidatingConverter.wrap(StringToNumberConverter.toBigDecimal());
  context.bindValue(WidgetProperties.text(SWT.Modify).observe(value),BeanProperties.value(property).observe(model),new UpdateValueStrategy().setAfterGetValidator(converter).setConverter(converter),new UpdateValueStrategy().setConverter(NumberToStringConverter.fromBigDecimal(format)));
}",0.77665544332211
52705,"public final ComboViewer bindCurrencyCodeCombo(Composite editArea,String label,String property){
  Label l=new Label(editArea,SWT.NONE);
  l.setText(label);
  ComboViewer combo=new ComboViewer(editArea,SWT.READ_ONLY);
  combo.setContentProvider(ArrayContentProvider.getInstance());
  combo.setLabelProvider(new LabelProvider());
  List<CurrencyUnit> currencies=new ArrayList<CurrencyUnit>();
  currencies.add(CurrencyUnit.EMPTY);
  currencies.addAll(CurrencyUnit.getAvailableCurrencyUnits().stream().sorted().collect(Collectors.toList()));
  combo.setInput(currencies);
  GridDataFactory.fillDefaults().align(SWT.BEGINNING,SWT.FILL).applyTo(combo.getControl());
  UpdateValueStrategy targetToModel=new UpdateValueStrategy();
  targetToModel.setConverter(new CurrencyUnitToStringConverter());
  UpdateValueStrategy modelToTarget=new UpdateValueStrategy();
  modelToTarget.setConverter(new StringToCurrencyUnitConverter());
  context.bindValue(ViewersObservables.observeSingleSelection(combo),BeanProperties.value(property).observe(model),targetToModel,modelToTarget);
  return combo;
}","public final ComboViewer bindCurrencyCodeCombo(Composite editArea,String label,String property){
  Label l=new Label(editArea,SWT.NONE);
  l.setText(label);
  ComboViewer combo=new ComboViewer(editArea,SWT.READ_ONLY);
  combo.setContentProvider(ArrayContentProvider.getInstance());
  combo.setLabelProvider(new LabelProvider());
  List<CurrencyUnit> currencies=new ArrayList<>();
  currencies.add(CurrencyUnit.EMPTY);
  currencies.addAll(CurrencyUnit.getAvailableCurrencyUnits().stream().sorted().collect(Collectors.toList()));
  combo.setInput(currencies);
  GridDataFactory.fillDefaults().align(SWT.BEGINNING,SWT.FILL).applyTo(combo.getControl());
  UpdateValueStrategy targetToModel=new UpdateValueStrategy();
  targetToModel.setConverter(new CurrencyUnitToStringConverter());
  UpdateValueStrategy modelToTarget=new UpdateValueStrategy();
  modelToTarget.setConverter(new StringToCurrencyUnitConverter());
  context.bindValue(ViewersObservables.observeSingleSelection(combo),BeanProperties.value(property).observe(model),targetToModel,modelToTarget);
  return combo;
}",0.9944341372912802
52706,"private void bindMandatoryDecimalInput(final String label,String property,Text txtValue,Values<?> type){
  context.bindValue(WidgetProperties.text(SWT.Modify).observe(txtValue),BeanProperties.value(property).observe(model),new UpdateValueStrategy().setConverter(new StringToCurrencyConverter(type)).setAfterConvertValidator(new IValidator(){
    @Override public IStatus validate(    Object value){
      Long v=(Long)value;
      return v != null && v.longValue() > 0 ? ValidationStatus.ok() : ValidationStatus.error(MessageFormat.format(Messages.MsgDialogInputRequired,label));
    }
  }
),new UpdateValueStrategy().setConverter(new CurrencyToStringConverter(type)));
}","private void bindMandatoryDecimalInput(final String label,String property,Text txtValue,Values<?> type){
  StringToCurrencyConverter converter=new StringToCurrencyConverter(type);
  UpdateValueStrategy input2model=new UpdateValueStrategy().setAfterGetValidator(converter).setConverter(converter).setAfterConvertValidator(value -> {
    Long v=(Long)value;
    return v != null && v.longValue() > 0 ? ValidationStatus.ok() : ValidationStatus.error(MessageFormat.format(Messages.MsgDialogInputRequired,label));
  }
);
  context.bindValue(WidgetProperties.text(SWT.Modify).observe(txtValue),BeanProperties.value(property).observe(model),input2model,new UpdateValueStrategy().setConverter(new CurrencyToStringConverter(type)));
}",0.4355300859598854
52707,"private void addAttributeBlock(Composite container,final AttributeDesignation attribute){
  final Label label=new Label(container,SWT.NONE);
  label.setText(attribute.getType().getName());
  final Text value=new Text(container,SWT.BORDER);
  value.setText(attribute.getType().getConverter().toString(attribute.getValue()));
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).applyTo(value);
  final Button deleteButton=new Button(container,SWT.PUSH);
  deleteButton.setImage(Images.REMOVE.image());
  final Binding binding=bindings.getBindingContext().bindValue(WidgetProperties.text(SWT.Modify).observe(value),BeanProperties.value(""String_Node_Str"").observe(attribute),new UpdateValueStrategy().setConverter(new ToAttributeObjectConverter(attribute)),new UpdateValueStrategy().setConverter(new ToAttributeStringConverter(attribute)));
  deleteButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      model.getAttributes().remove(attribute);
      bindings.getBindingContext().removeBinding(binding);
      Composite parent=deleteButton.getParent();
      label.dispose();
      value.dispose();
      deleteButton.dispose();
      parent.getParent().layout(true);
    }
  }
);
}","private void addAttributeBlock(Composite container,final AttributeDesignation attribute){
  final Label label=new Label(container,SWT.NONE);
  label.setText(attribute.getType().getName());
  final Text value=new Text(container,SWT.BORDER);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.CENTER).grab(true,false).applyTo(value);
  final Button deleteButton=new Button(container,SWT.PUSH);
  deleteButton.setImage(Images.REMOVE.image());
  ToAttributeObjectConverter input2model=new ToAttributeObjectConverter(attribute);
  final Binding binding=bindings.getBindingContext().bindValue(WidgetProperties.text(SWT.Modify).observe(value),BeanProperties.value(""String_Node_Str"").observe(attribute),new UpdateValueStrategy().setAfterGetValidator(input2model).setConverter(input2model),new UpdateValueStrategy().setConverter(new ToAttributeStringConverter(attribute)));
  deleteButton.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      model.getAttributes().remove(attribute);
      bindings.getBindingContext().removeBinding(binding);
      Composite parent=deleteButton.getParent();
      label.dispose();
      value.dispose();
      deleteButton.dispose();
      parent.getParent().layout(true);
    }
  }
);
}",0.9001572327044025
52708,"public void internalSetClient(Client client){
  this.client=client;
  this.dirty.setDirty(false);
  this.context.set(Client.class,client);
  client.addPropertyChangeListener(event -> notifyModelUpdated());
  if (client.getFileVersionAfterRead() < Client.VERSION_WITH_CURRENCY_SUPPORT)   Display.getDefault().asyncExec(new ClientMigrationDialog(Display.getDefault().getActiveShell(),client)::open);
  new ConsistencyChecksJob(client,false).schedule(100);
  scheduleOnlineUpdateJobs();
}","public void internalSetClient(Client client){
  this.client=client;
  this.dirty.setDirty(false);
  this.context.set(Client.class,client);
  client.addPropertyChangeListener(event -> notifyModelUpdated());
  if (client.getFileVersionAfterRead() < Client.VERSION_WITH_CURRENCY_SUPPORT) {
    Display.getDefault().asyncExec(() -> {
      Dialog dialog=new ClientMigrationDialog(Display.getDefault().getActiveShell(),client);
      dialog.open();
    }
);
  }
  new ConsistencyChecksJob(client,false).schedule(100);
  scheduleOnlineUpdateJobs();
}",0.9271137026239068
52709,"@Override protected void addColumns(ShowHideColumnHelper support){
  addDimensionColumn(support);
  addDesiredAllocationColumn(support);
  Column column=new Column(""String_Node_Str"",Messages.ColumnTargetValue,SWT.RIGHT,100);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      return node.isClassification() ? Values.Money.format(node.getTarget(),getModel().getCurrencyCode()) : null;
    }
  }
);
  support.addColumn(column);
  addActualColumns(support);
  column=new Column(""String_Node_Str"",Messages.ColumnDeltaPercent,SWT.RIGHT,60);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      if (node.getTarget() == null)       return null;
      return Values.Percent.format(((double)node.getActual().getAmount() / (double)node.getTarget().getAmount()) - 1);
    }
    @Override public Color getForeground(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      if (node.getTarget() == null)       return null;
      return Display.getCurrent().getSystemColor(node.getActual().isGreaterOrEqualThan(node.getTarget()) ? SWT.COLOR_DARK_GREEN : SWT.COLOR_DARK_RED);
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnDeltaValue,SWT.RIGHT,100);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      if (node.getTarget() == null)       return null;
      return Values.Money.format(node.getActual().subtract(node.getTarget()),getModel().getCurrencyCode());
    }
    @Override public Color getForeground(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      if (node.getTarget() == null)       return null;
      return Display.getCurrent().getSystemColor(node.getActual().isGreaterOrEqualThan(node.getTarget()) ? SWT.COLOR_DARK_GREEN : SWT.COLOR_DARK_RED);
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnQuote,SWT.RIGHT,60);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      Security security=node.getBackingSecurity();
      if (security == null || security.getCurrencyCode() == null)       return null;
      SecurityPrice price=security.getSecurityPrice(LocalDate.now());
      return Values.Quote.format(security.getCurrencyCode(),price.getValue(),getModel().getCurrencyCode());
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnDeltaShares,SWT.RIGHT,100);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      if (node.getParent() != null && node.getParent().isUnassignedCategory())       return null;
      Security security=node.getBackingSecurity();
      if (security == null || security.getCurrencyCode() == null)       return null;
      String priceCurrency=security.getCurrencyCode();
      long price=security.getSecurityPrice(LocalDate.now()).getValue();
      long weightedPrice=Math.round(node.getWeight() * price / Classification.ONE_HUNDRED_PERCENT);
      if (weightedPrice == 0L)       return Values.Share.format(0L);
      String deltaCurrency=node.getActual().getCurrencyCode();
      long delta=node.getParent().getTarget().getAmount() - node.getParent().getActual().getAmount();
      if (!deltaCurrency.equals(priceCurrency)) {
        delta=getModel().getCurrencyConverter().with(priceCurrency).convert(LocalDate.now(),Money.of(deltaCurrency,delta)).getAmount();
      }
      long shares=Math.round(delta * Values.Share.factor() * Values.Quote.factorToMoney() / weightedPrice);
      return Values.Share.format(shares);
    }
  }
);
  support.addColumn(column);
  addAdditionalColumns(support);
}","@Override protected void addColumns(ShowHideColumnHelper support){
  addDimensionColumn(support);
  addDesiredAllocationColumn(support);
  Column column=new Column(""String_Node_Str"",Messages.ColumnTargetValue,SWT.RIGHT,100);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      return node.isClassification() ? Values.Money.format(node.getTarget(),getModel().getCurrencyCode()) : null;
    }
  }
);
  support.addColumn(column);
  addActualColumns(support);
  column=new Column(""String_Node_Str"",Messages.ColumnDeltaPercent,SWT.RIGHT,60);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      if (node.getTarget() == null)       return null;
      return Values.Percent.format(((double)node.getActual().getAmount() / (double)node.getTarget().getAmount()) - 1);
    }
    @Override public Color getForeground(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      if (node.getTarget() == null)       return null;
      return Display.getCurrent().getSystemColor(node.getActual().isGreaterOrEqualThan(node.getTarget()) ? SWT.COLOR_DARK_GREEN : SWT.COLOR_DARK_RED);
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnDeltaValue,SWT.RIGHT,100);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      if (node.getTarget() == null)       return null;
      return Values.Money.format(node.getActual().subtract(node.getTarget()),getModel().getCurrencyCode());
    }
    @Override public Color getForeground(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      if (node.getTarget() == null)       return null;
      return Display.getCurrent().getSystemColor(node.getActual().isGreaterOrEqualThan(node.getTarget()) ? SWT.COLOR_DARK_GREEN : SWT.COLOR_DARK_RED);
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnQuote,SWT.RIGHT,60);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      Security security=node.getBackingSecurity();
      if (security == null || security.getCurrencyCode() == null)       return null;
      SecurityPrice price=security.getSecurityPrice(LocalDate.now());
      return Values.Quote.format(security.getCurrencyCode(),price.getValue(),getModel().getCurrencyCode());
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnDeltaShares,SWT.RIGHT,100);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      if (node.getParent() != null && node.getParent().isUnassignedCategory())       return null;
      Security security=node.getBackingSecurity();
      if (security == null || security.getCurrencyCode() == null)       return null;
      String priceCurrency=security.getCurrencyCode();
      long price=security.getSecurityPrice(LocalDate.now()).getValue();
      long weightedPrice=Math.round(node.getWeight() * price / (double)Classification.ONE_HUNDRED_PERCENT);
      if (weightedPrice == 0L)       return Values.Share.format(0L);
      String deltaCurrency=node.getActual().getCurrencyCode();
      long delta=node.getParent().getTarget().getAmount() - node.getParent().getActual().getAmount();
      if (!deltaCurrency.equals(priceCurrency)) {
        delta=getModel().getCurrencyConverter().with(priceCurrency).convert(LocalDate.now(),Money.of(deltaCurrency,delta)).getAmount();
      }
      long shares=Math.round(delta * Values.Share.divider() * Values.Quote.dividerToMoney() / weightedPrice);
      return Values.Share.format(shares);
    }
  }
);
  support.addColumn(column);
  addAdditionalColumns(support);
}",0.9962962962962963
52710,"@Override protected void fillContextMenu(IMenuManager manager){
  super.fillContextMenu(manager);
  final TaxonomyNode node=(TaxonomyNode)((IStructuredSelection)getNodeViewer().getSelection()).getFirstElement();
  if (node == null || node.isUnassignedCategory())   return;
  if (node.isClassification() && getModel().hasWeightError(node)) {
    manager.appendToGroup(MENU_GROUP_CUSTOM_ACTIONS,new Action(Messages.MenuTaxonomyWeightFix){
      @Override public void run(){
        doFixClassificationWeights(node);
      }
    }
);
  }
}","@Override protected void fillContextMenu(IMenuManager manager){
  super.fillContextMenu(manager);
  final TaxonomyNode node=(TaxonomyNode)((IStructuredSelection)getNodeViewer().getSelection()).getFirstElement();
  if (node == null || node.isUnassignedCategory())   return;
  if (node.isClassification() && getModel().hasWeightError(node)) {
    manager.appendToGroup(MENU_GROUP_CUSTOM_ACTIONS,new SimpleAction(Messages.MenuTaxonomyWeightFix,a -> doFixClassificationWeights(node)));
  }
}",0.9266862170087976
52711,"private void addDesiredAllocationColumn(ShowHideColumnHelper support){
  Column column=new Column(""String_Node_Str"",Messages.ColumnDesiredAllocation,SWT.RIGHT,70);
  column.setDescription(Messages.ColumnDesiredAllocation_Description);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      return node.isClassification() ? Values.Weight.format(node.getWeight()) : node.isUnassignedCategory() ? Messages.LabelNotAvailable : null;
    }
    @Override public Color getForeground(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      return node.isClassification() && getModel().hasWeightError(node) ? Display.getDefault().getSystemColor(SWT.COLOR_BLACK) : null;
    }
    @Override public Color getBackground(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      return node.isClassification() && getModel().hasWeightError(node) ? getWarningColor() : null;
    }
    @Override public Image getImage(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      return node.isClassification() && getModel().hasWeightError(node) ? Images.QUICKFIX.image() : null;
    }
  }
);
  new ValueEditingSupport(TaxonomyNode.class,""String_Node_Str"",Values.Weight){
    @Override public boolean canEdit(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      if (node.isAssignment() || node.isUnassignedCategory())       return false;
      return super.canEdit(element);
    }
  }
.addListener(new ModificationListener(){
    @Override public void onModified(    Object element,    Object newValue,    Object oldValue){
      onWeightModified(element,newValue,oldValue);
    }
  }
).attachTo(column);
  support.addColumn(column);
}","private void addDesiredAllocationColumn(ShowHideColumnHelper support){
  Column column=new Column(""String_Node_Str"",Messages.ColumnDesiredAllocation,SWT.RIGHT,70);
  column.setDescription(Messages.ColumnDesiredAllocation_Description);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      return node.isClassification() ? Values.Weight.format(node.getWeight()) : node.isUnassignedCategory() ? Messages.LabelNotAvailable : null;
    }
    @Override public Color getForeground(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      return node.isClassification() && getModel().hasWeightError(node) ? Display.getDefault().getSystemColor(SWT.COLOR_BLACK) : null;
    }
    @Override public Color getBackground(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      return node.isClassification() && getModel().hasWeightError(node) ? getWarningColor() : null;
    }
    @Override public Image getImage(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      return node.isClassification() && getModel().hasWeightError(node) ? Images.QUICKFIX.image() : null;
    }
  }
);
  new ValueEditingSupport(TaxonomyNode.class,""String_Node_Str"",Values.Weight){
    @Override public boolean canEdit(    Object element){
      TaxonomyNode node=(TaxonomyNode)element;
      if (node.isAssignment() || node.isUnassignedCategory())       return false;
      return super.canEdit(element);
    }
  }
.addListener((element,newValue,oldValue) -> onWeightModified(element,newValue,oldValue)).attachTo(column);
  support.addColumn(column);
}",0.965179856115108
52712,"public Stream<Result> search(String query) throws IOException {
  String searchUrl=MessageFormat.format(SEARCH_URL,query);
  List<Result> answer=new ArrayList<>();
  try (Scanner scanner=new Scanner(new URL(searchUrl).openStream(),StandardCharsets.UTF_8.name())){
    String html=scanner.useDelimiter(""String_Node_Str"").next();
    int start=html.indexOf('(');
    int end=html.lastIndexOf(')');
    html=html.substring(start + 1,end);
    JSONObject response=(JSONObject)JSONValue.parse(html);
    if (response != null) {
      JSONObject resultSet=(JSONObject)response.get(""String_Node_Str"");
      if (resultSet != null) {
        JSONArray result=(JSONArray)resultSet.get(""String_Node_Str"");
        if (result != null) {
          for (int ii=0; ii < result.size(); ii++)           answer.add(Result.from((JSONObject)result.get(ii)));
        }
      }
    }
  }
   return answer.stream();
}","public Stream<Result> search(String query) throws IOException {
  String searchUrl=MessageFormat.format(SEARCH_URL,URLEncoder.encode(query,StandardCharsets.UTF_8.name()));
  List<Result> answer=new ArrayList<>();
  try (Scanner scanner=new Scanner(new URL(searchUrl).openStream(),StandardCharsets.UTF_8.name())){
    String html=scanner.useDelimiter(""String_Node_Str"").next();
    int start=html.indexOf('(');
    int end=html.lastIndexOf(')');
    html=html.substring(start + 1,end);
    JSONObject response=(JSONObject)JSONValue.parse(html);
    if (response != null) {
      JSONObject resultSet=(JSONObject)response.get(""String_Node_Str"");
      if (resultSet != null) {
        JSONArray result=(JSONArray)resultSet.get(""String_Node_Str"");
        if (result != null) {
          for (int ii=0; ii < result.size(); ii++)           answer.add(Result.from((JSONObject)result.get(ii)));
        }
      }
    }
  }
   return answer.stream();
}",0.8517110266159695
52713,"/** 
 * Export all transactions in 'aktienfreunde.net' Format
 */
public void exportAllTransactions(File file,Client client) throws IOException {
  List<Transaction> transactions=new ArrayList<Transaction>();
  for (  Account a : client.getAccounts())   transactions.addAll(a.getTransactions());
  for (  Portfolio p : client.getPortfolios())   transactions.addAll(p.getTransactions());
  Transaction.sortByDate(transactions);
  DateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  try (Writer writer=new OutputStreamWriter(new FileOutputStream(file),StandardCharsets.UTF_8)){
    CSVPrinter printer=new CSVPrinter(writer);
    printer.setStrategy(CSVExporter.STRATEGY);
    writeHeader(printer);
    for (    Transaction t : transactions) {
      if (t instanceof AccountTransaction) {
        AccountTransaction ta=(AccountTransaction)t;
        if (ta.getSecurity() != null && (ta.getType() == AccountTransaction.Type.INTEREST || ta.getType() == AccountTransaction.Type.DIVIDENDS))         writeDividend(printer,ta,dateFormat);
      }
 else       if (t instanceof PortfolioTransaction) {
        PortfolioTransaction tp=(PortfolioTransaction)t;
switch (tp.getType()) {
case BUY:
case DELIVERY_INBOUND:
          writeBuySell(printer,tp,""String_Node_Str"",dateFormat);
        break;
case SELL:
case DELIVERY_OUTBOUND:
      writeBuySell(printer,tp,""String_Node_Str"",dateFormat);
    break;
default :
}
}
}
}
 }","/** 
 * Export all transactions in 'aktienfreunde.net' Format
 */
public void exportAllTransactions(File file,Client client) throws IOException {
  List<? extends Transaction> transactions=Stream.concat(client.getAccounts().stream(),client.getPortfolios().stream()).flatMap(l -> l.getTransactions().stream()).sorted(new Transaction.ByDate()).collect(Collectors.toList());
  try (Writer writer=new OutputStreamWriter(new FileOutputStream(file),StandardCharsets.UTF_8)){
    CSVPrinter printer=new CSVPrinter(writer);
    printer.setStrategy(CSVExporter.STRATEGY);
    writeHeader(printer);
    for (    Transaction t : transactions) {
      if (t instanceof AccountTransaction)       writeDividend(printer,(AccountTransaction)t);
 else       if (t instanceof PortfolioTransaction)       writeBuySell(printer,(PortfolioTransaction)t);
    }
  }
 }",0.4810572687224669
52714,"@SuppressWarnings(""String_Node_Str"") private void writeDividend(CSVPrinter printer,AccountTransaction transaction,DateFormat dateFormat){
  printer.print(dateFormat.format(transaction.getDate()));
  printer.print(CSVExporter.escapeNull(transaction.getSecurity().getIsin()));
  printer.print(CSVExporter.escapeNull(transaction.getSecurity().getName()));
  printer.print(""String_Node_Str"");
  printer.print(""String_Node_Str"");
  printer.print(Values.Amount.format(transaction.getAmount()));
  printer.print(""String_Node_Str"");
  printer.print(""String_Node_Str"");
  printer.print(""String_Node_Str"");
  printer.println();
}","@SuppressWarnings(""String_Node_Str"") private void writeDividend(CSVPrinter printer,AccountTransaction transaction){
  if (transaction.getSecurity() == null)   return;
  if (transaction.getType() != AccountTransaction.Type.INTEREST && transaction.getType() != AccountTransaction.Type.DIVIDENDS)   return;
  printer.print(DATE_FORMAT.format(transaction.getDate()));
  printer.print(CSVExporter.escapeNull(transaction.getSecurity().getIsin()));
  printer.print(CSVExporter.escapeNull(transaction.getSecurity().getName()));
  printer.print(""String_Node_Str"");
  printer.print(""String_Node_Str"");
  printer.print(Values.Amount.format(transaction.getAmount()));
  printer.print(""String_Node_Str"");
  printer.print(""String_Node_Str"");
  printer.print(""String_Node_Str"");
  printer.println();
}",0.8113879003558719
52715,"@SuppressWarnings(""String_Node_Str"") private void writeBuySell(CSVPrinter printer,PortfolioTransaction transaction,String type,DateFormat dateFormat){
  printer.print(dateFormat.format(transaction.getDate()));
  printer.print(CSVExporter.escapeNull(transaction.getSecurity().getIsin()));
  printer.print(CSVExporter.escapeNull(transaction.getSecurity().getName()));
  printer.print(""String_Node_Str"");
  printer.print(type);
  printer.print(Values.Quote.format(transaction.getGrossPricePerShare().getAmount()));
  printer.print(Values.Share.format(transaction.getShares()));
  printer.print(Values.Amount.format(transaction.getUnitSum(Unit.Type.FEE).getAmount()));
  printer.print(Values.Amount.format(transaction.getUnitSum(Unit.Type.TAX).getAmount()));
  printer.println();
}","@SuppressWarnings(""String_Node_Str"") private void writeBuySell(CSVPrinter printer,PortfolioTransaction transaction){
  String type;
switch (transaction.getType()) {
case BUY:
case DELIVERY_INBOUND:
    type=""String_Node_Str"";
  break;
case SELL:
case DELIVERY_OUTBOUND:
type=""String_Node_Str"";
break;
default :
return;
}
printer.print(DATE_FORMAT.format(transaction.getDate()));
printer.print(CSVExporter.escapeNull(transaction.getSecurity().getIsin()));
printer.print(CSVExporter.escapeNull(transaction.getSecurity().getName()));
printer.print(""String_Node_Str"");
printer.print(type);
printer.print(Values.Quote.format(transaction.getGrossPricePerShare().getAmount()));
printer.print(Values.Share.format(transaction.getShares()));
printer.print(Values.Amount.format(transaction.getUnitSum(Unit.Type.FEE).getAmount()));
printer.print(Values.Amount.format(transaction.getUnitSum(Unit.Type.TAX).getAmount()));
printer.println();
}",0.8316715542521994
52716,"public ChartConfig(WidgetDelegate delegate,DataSeries.UseCase useCase){
  this.delegate=delegate;
  String configName=(useCase == DataSeries.UseCase.STATEMENT_OF_ASSETS ? StatementOfAssetsHistoryView.class : PerformanceChartView.class).getSimpleName() + DataSeriesConfigurator.IDENTIFIER_POSTFIX;
  configSet=delegate.getClient().getSettings().getConfigurationSet(configName);
  String uuid=delegate.getWidget().getConfiguration().get(Dashboard.Config.CONFIG_UUID.name());
  config=configSet.lookup(uuid).orElseGet(() -> configSet.getConfigurations().findFirst().get());
}","public ChartConfig(WidgetDelegate delegate,DataSeries.UseCase useCase){
  this.delegate=delegate;
  String configName=(useCase == DataSeries.UseCase.STATEMENT_OF_ASSETS ? StatementOfAssetsHistoryView.class : PerformanceChartView.class).getSimpleName() + DataSeriesConfigurator.IDENTIFIER_POSTFIX;
  configSet=delegate.getClient().getSettings().getConfigurationSet(configName);
  String uuid=delegate.getWidget().getConfiguration().get(Dashboard.Config.CONFIG_UUID.name());
  config=configSet.lookup(uuid).orElseGet(() -> configSet.getConfigurations().findFirst().orElseGet(() -> new ConfigurationSet.Configuration(Messages.LabelNoName,null)));
}",0.933442892358258
52717,"private Color colorFor(AccountTransaction t){
  if (EnumSet.of(Type.REMOVAL,Type.FEES,Type.TAXES,Type.BUY,Type.TRANSFER_OUT).contains(t.getType()))   return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_RED);
 else   return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_GREEN);
}","private Color colorFor(AccountTransaction t){
  if (t.getType().isNegative())   return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_RED);
 else   return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_GREEN);
}",0.7755905511811023
52718,"protected Control createTransactionTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  transactions=new TableViewer(container,SWT.FULL_SELECTION | SWT.MULTI);
  ColumnEditingSupport.prepare(transactions);
  transactionsColumns=new ShowHideColumnHelper(AccountListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),transactions,layout);
  Column column=new Column(Messages.ColumnDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return Values.Date.format(t.getDate());
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").attachTo(column,SWT.DOWN);
  new DateEditingSupport(AccountTransaction.class,""String_Node_Str"").addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnTransactionType,SWT.None,100);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return t.getType().toString();
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str""));
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnAmount,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      long v=t.getAmount();
      if (EnumSet.of(Type.REMOVAL,Type.FEES,Type.TAXES,Type.BUY,Type.TRANSFER_OUT).contains(t.getType()))       v=-v;
      return Values.Money.format(Money.of(t.getCurrencyCode(),v),getClient().getBaseCurrency());
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str""));
  transactionsColumns.addColumn(column);
  column=new Column(Messages.Balance,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Money balance=transaction2balance.get(e);
      return balance != null ? Values.Money.format(balance,getClient().getBaseCurrency()) : null;
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(new AccountTransaction.ByDateAmountAndType()));
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnSecurity,SWT.None,250);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return t.getSecurity() != null ? String.valueOf(t.getSecurity()) : null;
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str""));
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnShares,SWT.RIGHT,80);
  column.setLabelProvider(new SharesLabelProvider(){
    @Override public Long getValue(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      if (t.getCrossEntry() instanceof BuySellEntry) {
        return ((BuySellEntry)t.getCrossEntry()).getPortfolioTransaction().getShares();
      }
 else       if (t.getType() == Type.DIVIDENDS && t.getShares() != 0) {
        return t.getShares();
      }
 else {
        return null;
      }
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  new ValueEditingSupport(AccountTransaction.class,""String_Node_Str"",Values.Share){
    @Override public boolean canEdit(    Object element){
      AccountTransaction t=(AccountTransaction)element;
      return t.getType() == AccountTransaction.Type.DIVIDENDS;
    }
  }
.addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnPurchasePrice,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      if (t.getCrossEntry() instanceof BuySellEntry) {
        PortfolioTransaction pt=((BuySellEntry)t.getCrossEntry()).getPortfolioTransaction();
        return Values.Quote.format(pt.getGrossPricePerShare(),getClient().getBaseCurrency());
      }
 else       if (t.getType() == Type.DIVIDENDS && t.getShares() != 0) {
        long dividendPerShare=Math.round(t.getAmount() * Values.Share.divider() * Values.Quote.factorToMoney() / t.getShares());
        return Values.Quote.format(Quote.of(t.getCurrencyCode(),dividendPerShare),getClient().getBaseCurrency());
      }
 else {
        return null;
      }
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnOffsetAccount,SWT.None,120);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return t.getCrossEntry() != null ? t.getCrossEntry().getCrossOwner(t).toString() : null;
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnNote,SWT.None,200);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      return ((AccountTransaction)e).getNote();
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
    @Override public Image getImage(    Object e){
      String note=((AccountTransaction)e).getNote();
      return note != null && note.length() > 0 ? Images.NOTE.image() : null;
    }
  }
);
  ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str"").attachTo(column);
  new StringEditingSupport(AccountTransaction.class,""String_Node_Str"").addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  transactionsColumns.createColumns();
  transactions.getTable().setHeaderVisible(true);
  transactions.getTable().setLinesVisible(true);
  transactions.setContentProvider(new SimpleListContentProvider());
  hookContextMenu(transactions.getTable(),this::fillTransactionsContextMenu);
  hookKeyListener();
  return container;
}","protected Control createTransactionTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  transactions=new TableViewer(container,SWT.FULL_SELECTION | SWT.MULTI);
  ColumnEditingSupport.prepare(transactions);
  transactionsColumns=new ShowHideColumnHelper(AccountListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),transactions,layout);
  Column column=new Column(Messages.ColumnDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return Values.Date.format(t.getDate());
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").attachTo(column,SWT.DOWN);
  new DateEditingSupport(AccountTransaction.class,""String_Node_Str"").addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnTransactionType,SWT.None,100);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return t.getType().toString();
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str""));
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnAmount,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      long v=t.getAmount();
      if (t.getType().isNegative())       v=-v;
      return Values.Money.format(Money.of(t.getCurrencyCode(),v),getClient().getBaseCurrency());
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str""));
  transactionsColumns.addColumn(column);
  column=new Column(Messages.Balance,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Money balance=transaction2balance.get(e);
      return balance != null ? Values.Money.format(balance,getClient().getBaseCurrency()) : null;
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(new AccountTransaction.ByDateAmountAndType()));
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnSecurity,SWT.None,250);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return t.getSecurity() != null ? String.valueOf(t.getSecurity()) : null;
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str""));
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnShares,SWT.RIGHT,80);
  column.setLabelProvider(new SharesLabelProvider(){
    @Override public Long getValue(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      if (t.getCrossEntry() instanceof BuySellEntry) {
        return ((BuySellEntry)t.getCrossEntry()).getPortfolioTransaction().getShares();
      }
 else       if (t.getType() == Type.DIVIDENDS && t.getShares() != 0) {
        return t.getShares();
      }
 else {
        return null;
      }
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  new ValueEditingSupport(AccountTransaction.class,""String_Node_Str"",Values.Share){
    @Override public boolean canEdit(    Object element){
      AccountTransaction t=(AccountTransaction)element;
      return t.getType() == AccountTransaction.Type.DIVIDENDS;
    }
  }
.addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnPurchasePrice,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      if (t.getCrossEntry() instanceof BuySellEntry) {
        PortfolioTransaction pt=((BuySellEntry)t.getCrossEntry()).getPortfolioTransaction();
        return Values.Quote.format(pt.getGrossPricePerShare(),getClient().getBaseCurrency());
      }
 else       if (t.getType() == Type.DIVIDENDS && t.getShares() != 0) {
        long dividendPerShare=Math.round(t.getAmount() * Values.Share.divider() * Values.Quote.factorToMoney() / t.getShares());
        return Values.Quote.format(Quote.of(t.getCurrencyCode(),dividendPerShare),getClient().getBaseCurrency());
      }
 else {
        return null;
      }
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnOffsetAccount,SWT.None,120);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return t.getCrossEntry() != null ? t.getCrossEntry().getCrossOwner(t).toString() : null;
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnNote,SWT.None,200);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      return ((AccountTransaction)e).getNote();
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
    @Override public Image getImage(    Object e){
      String note=((AccountTransaction)e).getNote();
      return note != null && note.length() > 0 ? Images.NOTE.image() : null;
    }
  }
);
  ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str"").attachTo(column);
  new StringEditingSupport(AccountTransaction.class,""String_Node_Str"").addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  transactionsColumns.createColumns();
  transactions.getTable().setHeaderVisible(true);
  transactions.getTable().setLinesVisible(true);
  transactions.setContentProvider(new SimpleListContentProvider());
  hookContextMenu(transactions.getTable(),this::fillTransactionsContextMenu);
  hookKeyListener();
  return container;
}",0.9923410404624278
52719,"public static AccountSnapshot create(Account account,CurrencyConverter converter,LocalDate date){
  long funds=0;
  for (  AccountTransaction t : account.getTransactions()) {
    if (!t.getDate().isAfter(date)) {
switch (t.getType()) {
case DEPOSIT:
case DIVIDENDS:
case INTEREST:
case SELL:
case TRANSFER_IN:
case TAX_REFUND:
        funds+=t.getAmount();
      break;
case FEES:
case TAXES:
case REMOVAL:
case BUY:
case TRANSFER_OUT:
    funds-=t.getAmount();
  break;
default :
throw new RuntimeException(""String_Node_Str"" + t.getType());
}
}
}
return new AccountSnapshot(account,date,converter,Money.of(account.getCurrencyCode(),funds));
}","public static AccountSnapshot create(Account account,CurrencyConverter converter,LocalDate date){
  long funds=0;
  for (  AccountTransaction t : account.getTransactions()) {
    if (!t.getDate().isAfter(date)) {
      if (t.getType().isNegative())       funds-=t.getAmount();
 else       funds+=t.getAmount();
    }
  }
  return new AccountSnapshot(account,date,converter,Money.of(account.getCurrencyCode(),funds));
}",0.6767200754005656
52720,"@Override public Object convert(Object fromObject){
  String value=(String)fromObject;
  value=value.trim();
  try {
    long result=0;
    for (    String part : value.split(""String_Node_Str""))     result+=convertToLong(part);
    return Long.valueOf(result);
  }
 catch (  ParseException e) {
    throw new IllegalArgumentException(e);
  }
}","@Override public Object convert(Object fromObject){
  String value=(String)fromObject;
  value=value.trim();
  try {
    long result=0;
    for (    String part : value.split(""String_Node_Str""))     result+=convertToLong(part.trim());
    return Long.valueOf(result);
  }
 catch (  ParseException e) {
    throw new IllegalArgumentException(e);
  }
}",0.98989898989899
52721,"private long convertToLong(String part) throws ParseException {
  Matcher m=pattern.matcher(String.valueOf(part));
  if (!m.matches())   throw new IllegalArgumentException(String.format(Messages.CellEditor_NotANumber,part));
  String strBefore=m.group(1);
  Number before=strBefore.trim().length() > 0 ? full.parse(strBefore) : Long.valueOf(0);
  String strAfter=m.group(3);
  int after=0;
  if (strAfter != null && strAfter.length() > 0) {
    after=Integer.parseInt(strAfter);
    int length=(int)Math.log10(factor);
    for (int ii=strAfter.length(); ii > length; ii--)     after/=10;
    for (int ii=strAfter.length(); ii < length; ii++)     after*=10;
  }
  long resultValue=before.longValue() * (int)factor + after;
  return resultValue;
}","private long convertToLong(String part) throws ParseException {
  Matcher m=pattern.matcher(String.valueOf(part));
  if (!m.matches())   throw new IllegalArgumentException(String.format(Messages.CellEditor_NotANumber,part));
  String strBefore=m.group(1);
  Number before=strBefore.trim().length() > 0 ? full.parse(strBefore) : Long.valueOf(0);
  String strAfter=m.group(3);
  long after=0;
  if (strAfter != null && strAfter.length() > 0) {
    int length=(int)Math.log10(factor);
    if (strAfter.length() > length)     strAfter=strAfter.substring(0,length);
    after=Long.parseLong(strAfter);
    for (int ii=strAfter.length(); ii < length; ii++)     after*=10;
  }
  long resultValue=before.longValue() * factor + after;
  return resultValue;
}",0.6693440428380187
52722,"public StringToCurrencyConverter(Values<?> type){
  this.factor=type.divider();
  DecimalFormatSymbols symbols=new DecimalFormatSymbols();
  pattern=Pattern.compile(""String_Node_Str"" + symbols.getGroupingSeparator() + ""String_Node_Str""+ symbols.getDecimalSeparator()+ ""String_Node_Str"");
  full=new DecimalFormat(""String_Node_Str"");
}","public StringToCurrencyConverter(Values<?> type){
  this.factor=type.factor();
  DecimalFormatSymbols symbols=new DecimalFormatSymbols();
  pattern=Pattern.compile(""String_Node_Str"" + symbols.getGroupingSeparator() + ""String_Node_Str""+ symbols.getDecimalSeparator()+ ""String_Node_Str"");
  full=new DecimalFormat(""String_Node_Str"");
}",0.9835082458770614
52723,"private void assertDividendTransaction(Security security,Optional<Item> item){
}","private void assertDividendTransaction(Security security,Optional<Item> item){
  assertThat(item.isPresent(),is(true));
  assertThat(item.get().getSubject(),instanceOf(AccountTransaction.class));
  AccountTransaction transaction=(AccountTransaction)item.get().getSubject();
  assertThat(transaction.getType(),is(AccountTransaction.Type.DIVIDENDS));
  assertThat(transaction.getSecurity(),is(security));
  assertThat(transaction.getDate(),is(Dates.date(""String_Node_Str"")));
  assertThat(transaction.getAmount(),is(Values.Amount.factorize(444)));
  assertThat(transaction.getShares(),is(Values.Share.factorize(370)));
}",0.2292263610315186
52724,"@Test public void testWertpapierKauf() throws IOException {
}","@Test public void testWertpapierKauf() throws IOException {
  DABPDFExctractor extractor=new DABPDFExctractor(new Client()){
    @Override String strip(    File file) throws IOException {
      return from(file.getName());
    }
  }
;
  List<Exception> errors=new ArrayList<Exception>();
  List<Item> results=extractor.extract(Arrays.asList(new File(""String_Node_Str"")),errors);
  assertThat(errors,empty());
  assertThat(results.size(),is(2));
  Security security=getSecurity(results);
  assertThat(security.getIsin(),is(""String_Node_Str""));
  assertThat(security.getName(),is(""String_Node_Str""));
  Optional<Item> item=results.stream().filter(i -> i instanceof BuySellEntryItem).findFirst();
  assertThat(item.isPresent(),is(true));
  assertThat(item.get().getSubject(),instanceOf(BuySellEntry.class));
  BuySellEntry entry=(BuySellEntry)item.get().getSubject();
  assertThat(entry.getPortfolioTransaction().getType(),is(PortfolioTransaction.Type.BUY));
  assertThat(entry.getAccountTransaction().getType(),is(AccountTransaction.Type.BUY));
  assertThat(entry.getPortfolioTransaction().getAmount(),is(Values.Amount.factorize(150.00)));
  assertThat(entry.getPortfolioTransaction().getDate(),is(Dates.date(""String_Node_Str"")));
  assertThat(entry.getPortfolioTransaction().getShares(),is(Values.Share.factorize(0.91920)));
  assertThat(entry.getPortfolioTransaction().getFees(),is(0L));
}",0.0841379310344827
52725,"@Test public void testDividend() throws IOException {
}","@Test public void testDividend() throws IOException {
  DABPDFExctractor extractor=new DABPDFExctractor(new Client()){
    @Override String strip(    File file) throws IOException {
      return from(file.getName());
    }
  }
;
  List<Exception> errors=new ArrayList<Exception>();
  List<Item> results=extractor.extract(Arrays.asList(new File(""String_Node_Str"")),errors);
  assertThat(errors,empty());
  assertThat(results.size(),is(2));
  Security security=getSecurity(results);
  assertThat(security.getIsin(),is(""String_Node_Str""));
  assertThat(security.getName(),is(""String_Node_Str""));
  Optional<Item> item=results.stream().filter(i -> i instanceof TransactionItem).findFirst();
  assertThat(item.isPresent(),is(true));
  assertThat(item.get().getSubject(),instanceOf(AccountTransaction.class));
  AccountTransaction transaction=(AccountTransaction)item.get().getSubject();
  assertThat(transaction.getType(),is(AccountTransaction.Type.DIVIDENDS));
  assertThat(transaction.getSecurity(),is(security));
  assertThat(transaction.getAmount(),is(Values.Amount.factorize(326)));
  assertThat(transaction.getDate(),is(Dates.date(""String_Node_Str"")));
  assertThat(transaction.getShares(),is(Values.Share.factorize(100)));
}",0.0858704137392662
52726,"@Test public void testWertpapierKauf() throws IOException {
}","@Test public void testWertpapierKauf() throws IOException {
  DeutscheBankPDFExctractor extractor=new DeutscheBankPDFExctractor(new Client()){
    @Override String strip(    File file) throws IOException {
      return from(""String_Node_Str"");
    }
  }
;
  List<Exception> errors=new ArrayList<Exception>();
  List<Item> results=extractor.extract(Arrays.asList(new File(""String_Node_Str"")),errors);
  assertThat(errors,empty());
  assertThat(results.size(),is(2));
  assertSecurity(results);
  Optional<Item> item=results.stream().filter(i -> i instanceof BuySellEntryItem).findFirst();
  assertThat(item.isPresent(),is(true));
  assertThat(item.get().getSubject(),instanceOf(BuySellEntry.class));
  BuySellEntry entry=(BuySellEntry)item.get().getSubject();
  assertThat(entry.getPortfolioTransaction().getType(),is(PortfolioTransaction.Type.BUY));
  assertThat(entry.getAccountTransaction().getType(),is(AccountTransaction.Type.BUY));
  assertThat(entry.getPortfolioTransaction().getAmount(),is(Values.Amount.factorize(675.50)));
  assertThat(entry.getPortfolioTransaction().getDate(),is(Dates.date(""String_Node_Str"")));
  assertThat(entry.getPortfolioTransaction().getShares(),is(Values.Share.factorize(19)));
  assertThat(entry.getPortfolioTransaction().getFees(),is(Values.Amount.factorize(10.50)));
}",0.0892465252377468
52727,"@Test public void testWertpapierVerkauf() throws IOException {
}","@Test public void testWertpapierVerkauf() throws IOException {
  DeutscheBankPDFExctractor extractor=new DeutscheBankPDFExctractor(new Client()){
    @Override String strip(    File file) throws IOException {
      return from(""String_Node_Str"");
    }
  }
;
  List<Exception> errors=new ArrayList<Exception>();
  List<Item> results=extractor.extract(Arrays.asList(new File(""String_Node_Str"")),errors);
  assertThat(errors,empty());
  assertThat(results.size(),is(2));
  assertSecurity(results);
  Optional<Item> item=results.stream().filter(i -> i instanceof BuySellEntryItem).findFirst();
  assertThat(item.isPresent(),is(true));
  assertThat(item.get().getSubject(),instanceOf(BuySellEntry.class));
  BuySellEntry entry=(BuySellEntry)item.get().getSubject();
  assertThat(entry.getPortfolioTransaction().getType(),is(PortfolioTransaction.Type.SELL));
  assertThat(entry.getAccountTransaction().getType(),is(AccountTransaction.Type.SELL));
  assertThat(entry.getPortfolioTransaction().getAmount(),is(Values.Amount.factorize(2074.71)));
  assertThat(entry.getPortfolioTransaction().getDate(),is(Dates.date(""String_Node_Str"")));
  assertThat(entry.getPortfolioTransaction().getShares(),is(Values.Share.factorize(61)));
  assertThat(entry.getPortfolioTransaction().getTaxes(),is(Values.Amount.factorize(122.94) + Values.Amount.factorize(6.76)));
  assertThat(entry.getPortfolioTransaction().getFees(),is(Values.Amount.factorize(7.90) + Values.Amount.factorize(0.60) + Values.Amount.factorize(2)));
}",0.0819462227912932
52728,"@Test public void testErtragsgutschrift() throws IOException {
}","@Test public void testErtragsgutschrift() throws IOException {
  DeutscheBankPDFExctractor extractor=new DeutscheBankPDFExctractor(new Client()){
    @Override String strip(    File file) throws IOException {
      return from(""String_Node_Str"");
    }
  }
;
  List<Exception> errors=new ArrayList<Exception>();
  List<Item> results=extractor.extract(Arrays.asList(new File(""String_Node_Str"")),errors);
  assertThat(errors,empty());
  assertThat(results.size(),is(2));
  Security security=assertSecurity(results);
  Optional<Item> item=results.stream().filter(i -> i instanceof TransactionItem).findFirst();
  assertThat(item.isPresent(),is(true));
  assertThat(item.get().getSubject(),instanceOf(AccountTransaction.class));
  AccountTransaction transaction=(AccountTransaction)item.get().getSubject();
  assertThat(transaction.getType(),is(AccountTransaction.Type.DIVIDENDS));
  assertThat(transaction.getSecurity(),is(security));
  assertThat(transaction.getDate(),is(Dates.date(""String_Node_Str"")));
  assertThat(transaction.getAmount(),is(1495L));
  assertThat(transaction.getShares(),is(Values.Share.factorize(123)));
}",0.1077441077441077
52729,"@Test public void testWertpapierKauf2() throws IOException {
}","@Test public void testWertpapierKauf2() throws IOException {
  DeutscheBankPDFExctractor extractor=new DeutscheBankPDFExctractor(new Client()){
    @Override String strip(    File file) throws IOException {
      return from(""String_Node_Str"");
    }
  }
;
  List<Exception> errors=new ArrayList<Exception>();
  List<Item> results=extractor.extract(Arrays.asList(new File(""String_Node_Str"")),errors);
  assertThat(errors,empty());
  assertThat(results.size(),is(2));
  assertSecurity(results);
  Optional<Item> item=results.stream().filter(i -> i instanceof BuySellEntryItem).findFirst();
  assertThat(item.isPresent(),is(true));
  assertThat(item.get().getSubject(),instanceOf(BuySellEntry.class));
  BuySellEntry entry=(BuySellEntry)item.get().getSubject();
  assertThat(entry.getPortfolioTransaction().getType(),is(PortfolioTransaction.Type.BUY));
  assertThat(entry.getAccountTransaction().getType(),is(AccountTransaction.Type.BUY));
  assertThat(entry.getPortfolioTransaction().getAmount(),is(Values.Amount.factorize(3524.98)));
  assertThat(entry.getPortfolioTransaction().getDate(),is(Dates.date(""String_Node_Str"")));
  assertThat(entry.getPortfolioTransaction().getShares(),is(Values.Share.factorize(36)));
  assertThat(entry.getPortfolioTransaction().getFees(),is(Values.Amount.factorize(11.38)));
}",0.0905109489051095
52730,"@Test public void testErtragsgutschrift() throws IOException {
}","@Test public void testErtragsgutschrift() throws IOException {
  FlatexPDFExctractor extractor=new FlatexPDFExctractor(new Client()){
    @Override String strip(    File file) throws IOException {
      return from(""String_Node_Str"");
    }
  }
;
  List<Exception> errors=new ArrayList<Exception>();
  List<Item> results=extractor.extract(Arrays.asList(new File(""String_Node_Str"")),errors);
  assertThat(errors,empty());
  assertThat(results.size(),is(2));
  Optional<Item> item=results.stream().filter(i -> i instanceof SecurityItem).findFirst();
  assertThat(item.isPresent(),is(true));
  Security security=((SecurityItem)item.get()).getSecurity();
  assertThat(security.getIsin(),is(""String_Node_Str""));
  assertThat(security.getWkn(),is(""String_Node_Str""));
  assertThat(security.getName(),is(""String_Node_Str""));
  item=results.stream().filter(i -> i instanceof TransactionItem).findFirst();
  assertThat(item.isPresent(),is(true));
  assertThat(item.get().getSubject(),instanceOf(AccountTransaction.class));
  AccountTransaction transaction=(AccountTransaction)item.get().getSubject();
  assertThat(transaction.getType(),is(AccountTransaction.Type.DIVIDENDS));
  assertThat(transaction.getSecurity(),is(security));
  assertThat(transaction.getDate(),is(Dates.date(""String_Node_Str"")));
  assertThat(transaction.getAmount(),is(Values.Amount.factorize(795.15)));
  assertThat(transaction.getShares(),is(Values.Share.factorize(360)));
}",0.0851630073186959
52731,"@Test public void testCapitalGainsWithBuyDuringReportPeriod(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,1000000,100,0,0));
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2011,Calendar.JANUARY,15),security,PortfolioTransaction.Type.BUY,100000,9900,0,0));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  Map<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).getValuation());
  assertEquals(0,result.get(CategoryType.EARNINGS).getValuation());
  assertEquals(10000 + (11000 - 9900),result.get(CategoryType.CAPITAL_GAINS).getValuation());
  assertEquals(121000,result.get(CategoryType.FINAL_VALUE).getValuation());
}","@Test public void testCapitalGainsWithBuyDuringReportPeriod(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,Values.Share.factorize(10),100,0,0));
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2011,Calendar.JANUARY,15),security,PortfolioTransaction.Type.BUY,Values.Share.factorize(1),9900,0,0));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  Map<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).getValuation());
  assertEquals(0,result.get(CategoryType.EARNINGS).getValuation());
  assertEquals(10000 + (11000 - 9900),result.get(CategoryType.CAPITAL_GAINS).getValuation());
  assertEquals(121000,result.get(CategoryType.FINAL_VALUE).getValuation());
}",0.9729501267962808
52732,"@Test public void testEarningsFromSecurity(){
  Client client=new Client();
  Security security=new Security();
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,10,100,0,0));
  client.addPortfolio(portfolio);
  Account account=new Account();
  account.addTransaction(new AccountTransaction(Dates.date(2011,Calendar.JANUARY,31),security,AccountTransaction.Type.INTEREST,5000));
  client.addAccount(account);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  Map<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(5000,result.get(CategoryType.EARNINGS).getValuation());
}","@Test public void testEarningsFromSecurity(){
  Client client=new Client();
  Security security=new Security();
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,Values.Share.factorize(0.0001),100,0,0));
  client.addPortfolio(portfolio);
  Account account=new Account();
  account.addTransaction(new AccountTransaction(Dates.date(2011,Calendar.JANUARY,31),security,AccountTransaction.Type.INTEREST,5000));
  client.addAccount(account);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  Map<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(5000,result.get(CategoryType.EARNINGS).getValuation());
}",0.981226533166458
52733,"@Test public void testCapitalGains(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,1000000,100,0,0));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  Map<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).getValuation());
  assertEquals(0,result.get(CategoryType.EARNINGS).getValuation());
  assertEquals(10000,result.get(CategoryType.CAPITAL_GAINS).getValuation());
  assertEquals(110000,result.get(CategoryType.FINAL_VALUE).getValuation());
}","@Test public void testCapitalGains(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,Values.Share.factorize(10),100,0,0));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  Map<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).getValuation());
  assertEquals(0,result.get(CategoryType.EARNINGS).getValuation());
  assertEquals(10000,result.get(CategoryType.CAPITAL_GAINS).getValuation());
  assertEquals(110000,result.get(CategoryType.FINAL_VALUE).getValuation());
}",0.9832402234636872
52734,"@Test public void testCapitalGainsWithPartialSellDuringReportPeriod(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,1000000,100,0,0));
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2011,Calendar.JANUARY,15),security,PortfolioTransaction.Type.SELL,100000,9900,0,0));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  Map<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).getValuation());
  assertEquals(0,result.get(CategoryType.EARNINGS).getValuation());
  assertEquals(1000 * 9 + (9900 - 10000),result.get(CategoryType.CAPITAL_GAINS).getValuation());
  assertEquals(11000 * 9,result.get(CategoryType.FINAL_VALUE).getValuation());
}","@Test public void testCapitalGainsWithPartialSellDuringReportPeriod(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,Values.Share.factorize(10),100,0,0));
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2011,Calendar.JANUARY,15),security,PortfolioTransaction.Type.SELL,Values.Share.factorize(1),9900,0,0));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  Map<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).getValuation());
  assertEquals(0,result.get(CategoryType.EARNINGS).getValuation());
  assertEquals(1000 * 9 + (9900 - 10000),result.get(CategoryType.CAPITAL_GAINS).getValuation());
  assertEquals(11000 * 9,result.get(CategoryType.FINAL_VALUE).getValuation());
}",0.973288814691152
52735,"@Test public void testCapitalGainsWithPartialSellDuringReportPeriodWithFees(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,1000000,100,0,0));
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2011,Calendar.JANUARY,15),security,PortfolioTransaction.Type.SELL,100000,9900,1,0));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  Map<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(1000 * 9 + (9900 - 10000) + 1,result.get(CategoryType.CAPITAL_GAINS).getValuation());
  assertEquals(1,result.get(CategoryType.FEES).getValuation());
}","@Test public void testCapitalGainsWithPartialSellDuringReportPeriodWithFees(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,Values.Share.factorize(10),100,0,0));
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2011,Calendar.JANUARY,15),security,PortfolioTransaction.Type.SELL,Values.Share.factorize(1),9900,1,0));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  Map<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(1000 * 9 + (9900 - 10000) + 1,result.get(CategoryType.CAPITAL_GAINS).getValuation());
  assertEquals(1,result.get(CategoryType.FEES).getValuation());
}",0.969494756911344
52736,"@Test public void testSecuritiesWithoutAssignment(){
  Client client=new Client();
  Taxonomy taxonomy=new TaxonomyBuilder().addClassification(""String_Node_Str"").addTo(client);
  Security a=new SecurityBuilder().addPrice(""String_Node_Str"",1000).addTo(client);
  Portfolio portfolio=new PortfolioBuilder().inbound_delivery(a,""String_Node_Str"",1000000,10000).addTo(client);
  PortfolioSnapshot snapshot=PortfolioSnapshot.create(portfolio,new DateTime(""String_Node_Str"").toDate());
  assertNotNull(snapshot);
  GroupByTaxonomy grouping=snapshot.groupByTaxonomy(taxonomy);
  AssetCategory debt=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(debt,nullValue());
  List<AssetCategory> categories=grouping.asList();
  assertThat(categories.size(),is(1));
  AssetCategory unassigned=categories.get(0);
  assertThat(unassigned.getValuation(),is(10000L));
  assertThat(unassigned.getPositions().size(),is(1));
}","@Test public void testSecuritiesWithoutAssignment(){
  Client client=new Client();
  Taxonomy taxonomy=new TaxonomyBuilder().addClassification(""String_Node_Str"").addTo(client);
  Security a=new SecurityBuilder().addPrice(""String_Node_Str"",1000).addTo(client);
  Portfolio portfolio=new PortfolioBuilder().inbound_delivery(a,""String_Node_Str"",Values.Share.factorize(10),10000).addTo(client);
  PortfolioSnapshot snapshot=PortfolioSnapshot.create(portfolio,new DateTime(""String_Node_Str"").toDate());
  assertNotNull(snapshot);
  GroupByTaxonomy grouping=snapshot.groupByTaxonomy(taxonomy);
  AssetCategory debt=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(debt,nullValue());
  List<AssetCategory> categories=grouping.asList();
  assertThat(categories.size(),is(1));
  AssetCategory unassigned=categories.get(0);
  assertThat(unassigned.getValuation(),is(10000L));
  assertThat(unassigned.getPositions().size(),is(1));
}",0.984792868379654
52737,"@Test public void testThatSecuritiesAreGroupedIntoClassifications(){
  Client client=new Client();
  Taxonomy taxonomy=new TaxonomyBuilder().addClassification(""String_Node_Str"").addClassification(""String_Node_Str"").addClassification(""String_Node_Str"").addTo(client);
  Security a=new SecurityBuilder().addPrice(""String_Node_Str"",1000).assign(taxonomy,""String_Node_Str"").addTo(client);
  Security c=new SecurityBuilder().addPrice(""String_Node_Str"",1200).assign(taxonomy,""String_Node_Str"").addTo(client);
  Security d=new SecurityBuilder().addPrice(""String_Node_Str"",1200).assign(taxonomy,""String_Node_Str"").addTo(client);
  Portfolio portfolio=new PortfolioBuilder().inbound_delivery(a,""String_Node_Str"",1000000,10000).inbound_delivery(c,""String_Node_Str"",1000000,12000).inbound_delivery(d,""String_Node_Str"",1000000,12000).addTo(client);
  PortfolioSnapshot snapshot=PortfolioSnapshot.create(portfolio,new DateTime(""String_Node_Str"").toDate());
  assertNotNull(snapshot);
  GroupByTaxonomy grouping=snapshot.groupByTaxonomy(taxonomy);
  AssetCategory debt=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(debt.getValuation(),is(10000L));
  assertThat(debt.getPositions().size(),is(1));
  AssetCategory stocks=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(stocks.getValuation(),is(24000L));
  assertThat(stocks.getPositions().size(),is(2));
  AssetCategory realEstate=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(realEstate,nullValue());
}","@Test public void testThatSecuritiesAreGroupedIntoClassifications(){
  Client client=new Client();
  Taxonomy taxonomy=new TaxonomyBuilder().addClassification(""String_Node_Str"").addClassification(""String_Node_Str"").addClassification(""String_Node_Str"").addTo(client);
  Security a=new SecurityBuilder().addPrice(""String_Node_Str"",1000).assign(taxonomy,""String_Node_Str"").addTo(client);
  Security c=new SecurityBuilder().addPrice(""String_Node_Str"",1200).assign(taxonomy,""String_Node_Str"").addTo(client);
  Security d=new SecurityBuilder().addPrice(""String_Node_Str"",1200).assign(taxonomy,""String_Node_Str"").addTo(client);
  Portfolio portfolio=new PortfolioBuilder().inbound_delivery(a,""String_Node_Str"",Values.Share.factorize(10),10000).inbound_delivery(c,""String_Node_Str"",Values.Share.factorize(10),12000).inbound_delivery(d,""String_Node_Str"",Values.Share.factorize(10),12000).addTo(client);
  PortfolioSnapshot snapshot=PortfolioSnapshot.create(portfolio,new DateTime(""String_Node_Str"").toDate());
  assertNotNull(snapshot);
  GroupByTaxonomy grouping=snapshot.groupByTaxonomy(taxonomy);
  AssetCategory debt=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(debt.getValuation(),is(10000L));
  assertThat(debt.getPositions().size(),is(1));
  AssetCategory stocks=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(stocks.getValuation(),is(24000L));
  assertThat(stocks.getPositions().size(),is(2));
  AssetCategory realEstate=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(realEstate,nullValue());
}",0.9727869878010637
52738,"@Test public void testThatPartialAssignmentsInSubClassificationsAreMerged(){
  Client client=new Client();
  Taxonomy taxonomy=new TaxonomyBuilder().addClassification(""String_Node_Str"").addClassification(""String_Node_Str"",""String_Node_Str"").addClassification(""String_Node_Str"",""String_Node_Str"").addTo(client);
  Security a=new SecurityBuilder().addPrice(""String_Node_Str"",1000).assign(taxonomy,""String_Node_Str"",Classification.ONE_HUNDRED_PERCENT / 2).assign(taxonomy,""String_Node_Str"",Classification.ONE_HUNDRED_PERCENT / 2).addTo(client);
  Portfolio portfolio=new PortfolioBuilder().inbound_delivery(a,""String_Node_Str"",1000000,10000).addTo(client);
  PortfolioSnapshot snapshot=PortfolioSnapshot.create(portfolio,new DateTime(""String_Node_Str"").toDate());
  assertNotNull(snapshot);
  GroupByTaxonomy grouping=snapshot.groupByTaxonomy(taxonomy);
  assertThat(grouping.asList().size(),is(1));
  AssetCategory debt=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(debt.getPositions().size(),is(1));
  assertThat(debt.getValuation(),is(10000L));
}","@Test public void testThatPartialAssignmentsInSubClassificationsAreMerged(){
  Client client=new Client();
  Taxonomy taxonomy=new TaxonomyBuilder().addClassification(""String_Node_Str"").addClassification(""String_Node_Str"",""String_Node_Str"").addClassification(""String_Node_Str"",""String_Node_Str"").addTo(client);
  Security a=new SecurityBuilder().addPrice(""String_Node_Str"",1000).assign(taxonomy,""String_Node_Str"",Classification.ONE_HUNDRED_PERCENT / 2).assign(taxonomy,""String_Node_Str"",Classification.ONE_HUNDRED_PERCENT / 2).addTo(client);
  Portfolio portfolio=new PortfolioBuilder().inbound_delivery(a,""String_Node_Str"",Values.Share.factorize(10),10000).addTo(client);
  PortfolioSnapshot snapshot=PortfolioSnapshot.create(portfolio,new DateTime(""String_Node_Str"").toDate());
  assertNotNull(snapshot);
  GroupByTaxonomy grouping=snapshot.groupByTaxonomy(taxonomy);
  assertThat(grouping.asList().size(),is(1));
  AssetCategory debt=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(debt.getPositions().size(),is(1));
  assertThat(debt.getValuation(),is(10000L));
}",0.9868241708314404
52739,"@Test public void testSecuritiesWithPartialAssignment(){
  Client client=new Client();
  Taxonomy taxonomy=new TaxonomyBuilder().addClassification(""String_Node_Str"").addTo(client);
  Security a=new SecurityBuilder().addPrice(""String_Node_Str"",1000).assign(taxonomy,""String_Node_Str"",Classification.ONE_HUNDRED_PERCENT / 2).addTo(client);
  Portfolio portfolio=new PortfolioBuilder().inbound_delivery(a,""String_Node_Str"",1000000,10000).addTo(client);
  PortfolioSnapshot snapshot=PortfolioSnapshot.create(portfolio,new DateTime(""String_Node_Str"").toDate());
  assertNotNull(snapshot);
  GroupByTaxonomy grouping=snapshot.groupByTaxonomy(taxonomy);
  assertThat(grouping.asList().size(),is(2));
  AssetCategory debt=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(debt.getValuation(),is(5000L));
  assertThat(debt.getPositions().size(),is(1));
  AssetCategory unassigned=null;
  for (  AssetCategory category : grouping.asList())   if (category.getClassification().getId().equals(Classification.UNASSIGNED_ID))   unassigned=category;
  assertThat(unassigned,notNullValue());
  assertThat(unassigned.getValuation(),is(5000L));
  assertThat(unassigned.getPositions().size(),is(1));
}","@Test public void testSecuritiesWithPartialAssignment(){
  Client client=new Client();
  Taxonomy taxonomy=new TaxonomyBuilder().addClassification(""String_Node_Str"").addTo(client);
  Security a=new SecurityBuilder().addPrice(""String_Node_Str"",1000).assign(taxonomy,""String_Node_Str"",Classification.ONE_HUNDRED_PERCENT / 2).addTo(client);
  Portfolio portfolio=new PortfolioBuilder().inbound_delivery(a,""String_Node_Str"",Values.Share.factorize(10),10000).addTo(client);
  PortfolioSnapshot snapshot=PortfolioSnapshot.create(portfolio,new DateTime(""String_Node_Str"").toDate());
  assertNotNull(snapshot);
  GroupByTaxonomy grouping=snapshot.groupByTaxonomy(taxonomy);
  assertThat(grouping.asList().size(),is(2));
  AssetCategory debt=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(debt.getValuation(),is(5000L));
  assertThat(debt.getPositions().size(),is(1));
  AssetCategory unassigned=null;
  for (  AssetCategory category : grouping.asList())   if (category.getClassification().getId().equals(Classification.UNASSIGNED_ID))   unassigned=category;
  assertThat(unassigned,notNullValue());
  assertThat(unassigned.getValuation(),is(5000L));
  assertThat(unassigned.getPositions().size(),is(1));
}",0.9882257409663012
52740,"@Test public void testThatPartialAssignmentsAreSeparated(){
  Client client=new Client();
  Taxonomy taxonomy=new TaxonomyBuilder().addClassification(""String_Node_Str"").addClassification(""String_Node_Str"").addTo(client);
  Security a=new SecurityBuilder().addPrice(""String_Node_Str"",1000).assign(taxonomy,""String_Node_Str"",Classification.ONE_HUNDRED_PERCENT / 2).assign(taxonomy,""String_Node_Str"",Classification.ONE_HUNDRED_PERCENT / 2).addTo(client);
  Portfolio portfolio=new PortfolioBuilder().inbound_delivery(a,""String_Node_Str"",1000000,10000).addTo(client);
  PortfolioSnapshot snapshot=PortfolioSnapshot.create(portfolio,new DateTime(""String_Node_Str"").toDate());
  assertNotNull(snapshot);
  GroupByTaxonomy grouping=snapshot.groupByTaxonomy(taxonomy);
  AssetCategory debt=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(debt.getValuation(),is(5000L));
  assertThat(debt.getPositions().size(),is(1));
  AssetCategory equity=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(equity.getValuation(),is(5000L));
  assertThat(equity.getPositions().size(),is(1));
}","@Test public void testThatPartialAssignmentsAreSeparated(){
  Client client=new Client();
  Taxonomy taxonomy=new TaxonomyBuilder().addClassification(""String_Node_Str"").addClassification(""String_Node_Str"").addTo(client);
  Security a=new SecurityBuilder().addPrice(""String_Node_Str"",1000).assign(taxonomy,""String_Node_Str"",Classification.ONE_HUNDRED_PERCENT / 2).assign(taxonomy,""String_Node_Str"",Classification.ONE_HUNDRED_PERCENT / 2).addTo(client);
  Portfolio portfolio=new PortfolioBuilder().inbound_delivery(a,""String_Node_Str"",Values.Share.factorize(10),10000).addTo(client);
  PortfolioSnapshot snapshot=PortfolioSnapshot.create(portfolio,new DateTime(""String_Node_Str"").toDate());
  assertNotNull(snapshot);
  GroupByTaxonomy grouping=snapshot.groupByTaxonomy(taxonomy);
  AssetCategory debt=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(debt.getValuation(),is(5000L));
  assertThat(debt.getPositions().size(),is(1));
  AssetCategory equity=grouping.byClassification(taxonomy.getClassificationById(""String_Node_Str""));
  assertThat(equity.getValuation(),is(5000L));
  assertThat(equity.getPositions().size(),is(1));
}",0.9875161429186397
52741,"@Before public void setUpClient(){
  client=new Client();
  securityA=new Security();
  securityA.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),1000));
  client.addSecurity(securityA);
  securityB=new Security();
  securityB.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),1100));
  client.addSecurity(securityB);
  securityX=new Security();
  securityX.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),1200));
  client.addSecurity(securityX);
  Portfolio portfolioA=new Portfolio();
  portfolioA.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),securityA,PortfolioTransaction.Type.BUY,1000000,10000,0,0));
  portfolioA.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),securityX,PortfolioTransaction.Type.BUY,1000000,12100,100,0));
  client.addPortfolio(portfolioA);
  Portfolio portfolioB=new Portfolio();
  portfolioB.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),securityB,PortfolioTransaction.Type.BUY,1000000,11000,0,0));
  portfolioB.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),securityX,PortfolioTransaction.Type.BUY,1000000,10000,0,0));
  client.addPortfolio(portfolioB);
}","@Before public void setUpClient(){
  client=new Client();
  securityA=new Security();
  securityA.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),1000));
  client.addSecurity(securityA);
  securityB=new Security();
  securityB.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),1100));
  client.addSecurity(securityB);
  securityX=new Security();
  securityX.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),1200));
  client.addSecurity(securityX);
  Portfolio portfolioA=new Portfolio();
  portfolioA.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),securityA,PortfolioTransaction.Type.BUY,Values.Share.factorize(10),10000,0,0));
  portfolioA.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),securityX,PortfolioTransaction.Type.BUY,Values.Share.factorize(10),12100,100,0));
  client.addPortfolio(portfolioA);
  Portfolio portfolioB=new Portfolio();
  portfolioB.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),securityB,PortfolioTransaction.Type.BUY,Values.Share.factorize(10),11000,0,0));
  portfolioB.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),securityX,PortfolioTransaction.Type.BUY,Values.Share.factorize(10),10000,0,0));
  client.addPortfolio(portfolioB);
}",0.9484777517564404
52742,"@Test public void testMergingPortfolioSnapshots(){
  ClientSnapshot snapshot=ClientSnapshot.create(client,referenceDate);
  assertNotNull(snapshot);
  PortfolioSnapshot jointPortfolio=snapshot.getJointPortfolio();
  SecurityPosition positionA=jointPortfolio.getPositionsBySecurity().get(securityA);
  assertEquals(1000000,positionA.getShares());
  assertEquals(10000,positionA.calculateValue());
  SecurityPosition positionB=jointPortfolio.getPositionsBySecurity().get(securityB);
  assertEquals(1000000,positionB.getShares());
  assertEquals(11000,positionB.calculateValue());
  SecurityPosition positionX=jointPortfolio.getPositionsBySecurity().get(securityX);
  assertEquals(2000000,positionX.getShares());
  assertEquals(24000,positionX.calculateValue());
}","@Test public void testMergingPortfolioSnapshots(){
  ClientSnapshot snapshot=ClientSnapshot.create(client,referenceDate);
  assertNotNull(snapshot);
  PortfolioSnapshot jointPortfolio=snapshot.getJointPortfolio();
  SecurityPosition positionA=jointPortfolio.getPositionsBySecurity().get(securityA);
  assertEquals(Values.Share.factorize(10),positionA.getShares());
  assertEquals(10000,positionA.calculateValue());
  SecurityPosition positionB=jointPortfolio.getPositionsBySecurity().get(securityB);
  assertEquals(Values.Share.factorize(10),positionB.getShares());
  assertEquals(11000,positionB.calculateValue());
  SecurityPosition positionX=jointPortfolio.getPositionsBySecurity().get(securityX);
  assertEquals(Values.Share.factorize(10) * 2,positionX.getShares());
  assertEquals(24000,positionX.calculateValue());
}",0.941250789639924
52743,"@Test public void testThatTransactionsAreMergedOnSecurityPosition(){
  ClientSnapshot snapshot=ClientSnapshot.create(client,referenceDate);
  assertNotNull(snapshot);
  PortfolioSnapshot jointPortfolio=snapshot.getJointPortfolio();
  SecurityPosition positionX=jointPortfolio.getPositionsBySecurity().get(securityX);
  assertEquals(2000000,positionX.getShares());
  assertEquals(24000,positionX.calculateValue());
  assertEquals(1100,positionX.getFIFOPurchasePrice());
  assertEquals(22100,positionX.getFIFOPurchaseValue());
  assertEquals(1900,positionX.getProfitLoss());
}","@Test public void testThatTransactionsAreMergedOnSecurityPosition(){
  ClientSnapshot snapshot=ClientSnapshot.create(client,referenceDate);
  assertNotNull(snapshot);
  PortfolioSnapshot jointPortfolio=snapshot.getJointPortfolio();
  SecurityPosition positionX=jointPortfolio.getPositionsBySecurity().get(securityX);
  assertEquals(Values.Share.factorize(10) * 2,positionX.getShares());
  assertEquals(24000,positionX.calculateValue());
  assertEquals(1100,positionX.getFIFOPurchasePrice());
  assertEquals(22100,positionX.getFIFOPurchaseValue());
  assertEquals(1900,positionX.getProfitLoss());
}",0.9701110162254484
52744,"@Override public final boolean updateLatestQuotes(List<Security> securities,List<Exception> errors){
  Map<String,Security> requested=new HashMap<String,Security>();
  StringBuilder symbolString=new StringBuilder();
  for (  Security security : securities) {
    if (security.getTickerSymbol() == null)     continue;
    if (symbolString.length() > 0)     symbolString.append(""String_Node_Str"");
    symbolString.append(security.getTickerSymbol());
    requested.put(security.getTickerSymbol().toUpperCase(),security);
  }
  boolean isUpdated=false;
  String url=MessageFormat.format(LATEST_URL,symbolString.toString());
  String line=null;
  try (BufferedReader reader=openReader(url,errors)){
    if (reader == null)     return false;
    while ((line=reader.readLine()) != null) {
      String[] values=line.split(""String_Node_Str"");
      if (values.length != 7) {
        errors.add(new IOException(MessageFormat.format(Messages.MsgUnexpectedValue,line)));
        return false;
      }
      String symbol=stripQuotes(values[0]);
      Security security=requested.remove(symbol);
      if (security == null) {
        errors.add(new IOException(MessageFormat.format(Messages.MsgUnexpectedSymbol,symbol,line)));
        continue;
      }
      long lastTrade=asPrice(values[1]);
      Date lastTradeDate=asDate(values[2]);
      if (lastTradeDate == null)       lastTradeDate=Dates.today();
      long daysHigh=asPrice(values[3]);
      long daysLow=asPrice(values[4]);
      long previousClose=asPrice(values[5]);
      int volume=asNumber(values[6]);
      LatestSecurityPrice price=new LatestSecurityPrice(lastTradeDate,lastTrade);
      price.setHigh(daysHigh);
      price.setLow(daysLow);
      price.setPreviousClose(previousClose);
      price.setVolume(volume);
      boolean isAdded=security.setLatest(price);
      isUpdated=isUpdated || isAdded;
    }
    for (    Security s : requested.values())     errors.add(new IOException(MessageFormat.format(Messages.MsgMissingResponse,s.getTickerSymbol())));
  }
 catch (  NumberFormatException|ParseException e) {
    errors.add(new IOException(MessageFormat.format(Messages.MsgErrorsConvertingValue,line),e));
  }
catch (  IOException e) {
    errors.add(e);
  }
  return isUpdated;
}","@Override public final boolean updateLatestQuotes(List<Security> securities,List<Exception> errors){
  Map<String,List<Security>> symbol2security=securities.stream().filter(s -> s.getTickerSymbol() != null).collect(Collectors.groupingBy(s -> s.getTickerSymbol().toUpperCase(Locale.ROOT)));
  String symbolString=symbol2security.keySet().stream().collect(Collectors.joining(""String_Node_Str""));
  boolean isUpdated=false;
  String url=MessageFormat.format(LATEST_URL,symbolString.toString());
  String line=null;
  try (BufferedReader reader=openReader(url,errors)){
    if (reader == null)     return false;
    while ((line=reader.readLine()) != null) {
      String[] values=line.split(""String_Node_Str"");
      if (values.length != 7) {
        errors.add(new IOException(MessageFormat.format(Messages.MsgUnexpectedValue,line)));
        return false;
      }
      String symbol=stripQuotes(values[0]);
      List<Security> forSymbol=symbol2security.remove(symbol);
      if (forSymbol == null) {
        errors.add(new IOException(MessageFormat.format(Messages.MsgUnexpectedSymbol,symbol,line)));
        continue;
      }
      long lastTrade=asPrice(values[1]);
      Date lastTradeDate=asDate(values[2]);
      if (lastTradeDate == null)       lastTradeDate=Dates.today();
      long daysHigh=asPrice(values[3]);
      long daysLow=asPrice(values[4]);
      long previousClose=asPrice(values[5]);
      int volume=asNumber(values[6]);
      LatestSecurityPrice price=new LatestSecurityPrice(lastTradeDate,lastTrade);
      price.setHigh(daysHigh);
      price.setLow(daysLow);
      price.setPreviousClose(previousClose);
      price.setVolume(volume);
      for (      Security security : forSymbol) {
        boolean isAdded=security.setLatest(price);
        isUpdated=isUpdated || isAdded;
      }
    }
    for (    String symbol : symbol2security.keySet())     errors.add(new IOException(MessageFormat.format(Messages.MsgMissingResponse,symbol)));
  }
 catch (  NumberFormatException|ParseException e) {
    errors.add(new IOException(MessageFormat.format(Messages.MsgErrorsConvertingValue,line),e));
  }
catch (  IOException e) {
    errors.add(e);
  }
  return isUpdated;
}",0.8166854565952649
52745,"@Override public final boolean updateLatestQuotes(List<Security> securities,List<Exception> errors){
  Map<String,List<Security>> symbol2security=securities.stream().filter(s -> s.getTickerSymbol() != null).collect(Collectors.groupingBy(s -> s.getTickerSymbol().toUpperCase(Locale.ROOT)));
  String symbolString=symbol2security.keySet().stream().collect(Collectors.joining(""String_Node_Str""));
  boolean isUpdated=false;
  String url=MessageFormat.format(LATEST_URL,symbolString.toString());
  String line=null;
  try (BufferedReader reader=openReader(url,errors)){
    if (reader == null)     return false;
    while ((line=reader.readLine()) != null) {
      String[] values=line.split(""String_Node_Str"");
      if (values.length != 7) {
        errors.add(new IOException(MessageFormat.format(Messages.MsgUnexpectedValue,line)));
        return false;
      }
      String symbol=stripQuotes(values[0]);
      List<Security> forSymbol=symbol2security.remove(symbol);
      if (forSymbol == null) {
        errors.add(new IOException(MessageFormat.format(Messages.MsgUnexpectedSymbol,symbol,line)));
        continue;
      }
      long lastTrade=asPrice(values[1]);
      Date lastTradeDate=asDate(values[2]);
      if (lastTradeDate == null)       lastTradeDate=Dates.today();
      long daysHigh=asPrice(values[3]);
      long daysLow=asPrice(values[4]);
      long previousClose=asPrice(values[5]);
      int volume=asNumber(values[6]);
      LatestSecurityPrice price=new LatestSecurityPrice(lastTradeDate,lastTrade);
      price.setHigh(daysHigh);
      price.setLow(daysLow);
      price.setPreviousClose(previousClose);
      price.setVolume(volume);
      for (      Security security : forSymbol) {
        boolean isAdded=security.setLatest(price);
        isUpdated=isUpdated || isAdded;
      }
    }
    for (    String symbol : symbol2security.keySet())     errors.add(new IOException(MessageFormat.format(Messages.MsgMissingResponse,symbol)));
  }
 catch (  NumberFormatException|ParseException e) {
    errors.add(new IOException(MessageFormat.format(Messages.MsgErrorsConvertingValue,line),e));
  }
catch (  IOException e) {
    errors.add(e);
  }
  return isUpdated;
}","@Override public final boolean updateLatestQuotes(List<Security> securities,List<Exception> errors){
  Map<String,List<Security>> symbol2security=securities.stream().filter(s -> s.getTickerSymbol() != null).collect(Collectors.groupingBy(s -> s.getTickerSymbol().toUpperCase(Locale.ROOT)));
  String symbolString=symbol2security.keySet().stream().collect(Collectors.joining(""String_Node_Str""));
  boolean isUpdated=false;
  String url=MessageFormat.format(LATEST_URL,symbolString.toString());
  try (BufferedReader reader=openReader(url,errors)){
    if (reader == null)     return false;
    String line=null;
    while ((line=reader.readLine()) != null) {
      String[] values=line.split(""String_Node_Str"");
      if (values.length != 7) {
        errors.add(new IOException(MessageFormat.format(Messages.MsgUnexpectedValue,line)));
        return false;
      }
      String symbol=stripQuotes(values[0]);
      List<Security> forSymbol=symbol2security.remove(symbol);
      if (forSymbol == null) {
        errors.add(new IOException(MessageFormat.format(Messages.MsgUnexpectedSymbol,symbol,line)));
        continue;
      }
      try {
        LatestSecurityPrice price=buildPrice(values);
        for (        Security security : forSymbol) {
          boolean isAdded=security.setLatest(price);
          isUpdated=isUpdated || isAdded;
        }
      }
 catch (      NumberFormatException|ParseException e) {
        errors.add(new IOException(MessageFormat.format(Messages.MsgErrorsConvertingValue,line),e));
      }
    }
    for (    String symbol : symbol2security.keySet())     errors.add(new IOException(MessageFormat.format(Messages.MsgMissingResponse,symbol)));
  }
 catch (  IOException e) {
    errors.add(e);
  }
  return isUpdated;
}",0.7089249492900609
52746,"protected void createBottomTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  transactions=new TableViewer(container,SWT.FULL_SELECTION);
  ColumnEditingSupport.prepare(transactions);
  transactionsColumns=new ShowHideColumnHelper(AccountListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),transactions,layout);
  Column column=new Column(Messages.ColumnDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return Values.Date.format(t.getDate());
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str"").attachTo(column,SWT.DOWN);
  new DateEditingSupport(AccountTransaction.class,""String_Node_Str"").addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnTransactionType,SWT.None,100);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return t.getType().toString();
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str""));
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnAmount,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      long v=t.getAmount();
      if (EnumSet.of(Type.REMOVAL,Type.FEES,Type.TAXES,Type.BUY,Type.TRANSFER_OUT).contains(t.getType()))       v=-v;
      return Values.Amount.format(v);
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str""));
  new ValueEditingSupport(AccountTransaction.class,""String_Node_Str"",Values.Amount).addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnSecurity,SWT.None,250);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return t.getSecurity() != null ? String.valueOf(t.getSecurity()) : null;
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str""));
  List<Security> securities=new ArrayList<Security>(getClient().getSecurities());
  Collections.sort(securities,new Security.ByName());
  new ListEditingSupport(AccountTransaction.class,""String_Node_Str"",securities){
    @Override public boolean canEdit(    Object element){
      AccountTransaction t=(AccountTransaction)element;
      return t.getType() == AccountTransaction.Type.BUY || t.getType() == AccountTransaction.Type.SELL || t.getType() == AccountTransaction.Type.DIVIDENDS;
    }
  }
.addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnShares,SWT.RIGHT,80);
  column.setLabelProvider(new SharesLabelProvider(){
    @Override public Long getValue(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      if (t.getCrossEntry() instanceof BuySellEntry) {
        return ((BuySellEntry)t.getCrossEntry()).getPortfolioTransaction().getShares();
      }
 else       if (t.getType() == Type.DIVIDENDS && t.getShares() != 0) {
        return t.getShares();
      }
 else {
        return null;
      }
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  new ValueEditingSupport(AccountTransaction.class,""String_Node_Str"",Values.Share){
    @Override public boolean canEdit(    Object element){
      AccountTransaction t=(AccountTransaction)element;
      return t.getType() == AccountTransaction.Type.DIVIDENDS;
    }
  }
.addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnPurchasePrice,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      if (t.getCrossEntry() instanceof BuySellEntry) {
        PortfolioTransaction portfolioTransaction=((BuySellEntry)t.getCrossEntry()).getPortfolioTransaction();
        return Values.Amount.format(portfolioTransaction.getActualPurchasePrice());
      }
 else       if (t.getType() == Type.DIVIDENDS && t.getShares() != 0) {
        return Values.Amount.format(Math.round(t.getAmount() * Values.Share.divider() / t.getShares()));
      }
 else {
        return null;
      }
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnOffsetAccount,SWT.None,120);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return t.getCrossEntry() != null ? t.getCrossEntry().getCrossEntity(t).toString() : null;
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnNote,SWT.None,200);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      return ((AccountTransaction)e).getNote();
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
    @Override public Image getImage(    Object e){
      String note=((AccountTransaction)e).getNote();
      return note != null && note.length() > 0 ? PortfolioPlugin.image(PortfolioPlugin.IMG_NOTE) : null;
    }
  }
);
  ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str"").attachTo(column);
  new StringEditingSupport(AccountTransaction.class,""String_Node_Str"").addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  transactionsColumns.createColumns();
  transactions.getTable().setHeaderVisible(true);
  transactions.getTable().setLinesVisible(true);
  transactions.setContentProvider(new SimpleListContentProvider());
  hookContextMenu(transactions.getTable(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillTransactionsContextMenu(manager);
    }
  }
);
  if (!getClient().getAccounts().isEmpty())   accounts.setSelection(new StructuredSelection(accounts.getElementAt(0)),true);
  if (!transactionsColumns.isUserConfigured())   ViewerHelper.pack(transactions);
}","protected void createBottomTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  transactions=new TableViewer(container,SWT.FULL_SELECTION);
  ColumnEditingSupport.prepare(transactions);
  transactionsColumns=new ShowHideColumnHelper(AccountListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),transactions,layout);
  Column column=new Column(Messages.ColumnDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return Values.Date.format(t.getDate());
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str"").attachTo(column,SWT.DOWN);
  new DateEditingSupport(AccountTransaction.class,""String_Node_Str"").addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnTransactionType,SWT.None,100);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return t.getType().toString();
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str""));
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnAmount,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      long v=t.getAmount();
      if (EnumSet.of(Type.REMOVAL,Type.FEES,Type.TAXES,Type.BUY,Type.TRANSFER_OUT).contains(t.getType()))       v=-v;
      return Values.Amount.format(v);
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str""));
  new ValueEditingSupport(AccountTransaction.class,""String_Node_Str"",Values.Amount).addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnSecurity,SWT.None,250);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return t.getSecurity() != null ? String.valueOf(t.getSecurity()) : null;
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str""));
  List<Security> securities=new ArrayList<Security>(getClient().getSecurities());
  Collections.sort(securities,new Security.ByName());
  new ListEditingSupport(AccountTransaction.class,""String_Node_Str"",securities){
    @Override public boolean canEdit(    Object element){
      AccountTransaction t=(AccountTransaction)element;
      return t.getType() == AccountTransaction.Type.BUY || t.getType() == AccountTransaction.Type.SELL || t.getType() == AccountTransaction.Type.DIVIDENDS;
    }
  }
.addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnShares,SWT.RIGHT,80);
  column.setLabelProvider(new SharesLabelProvider(){
    @Override public Long getValue(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      if (t.getCrossEntry() instanceof BuySellEntry) {
        return ((BuySellEntry)t.getCrossEntry()).getPortfolioTransaction().getShares();
      }
 else       if (t.getType() == Type.DIVIDENDS && t.getShares() != 0) {
        return t.getShares();
      }
 else {
        return null;
      }
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  new ValueEditingSupport(AccountTransaction.class,""String_Node_Str"",Values.Share){
    @Override public boolean canEdit(    Object element){
      AccountTransaction t=(AccountTransaction)element;
      return t.getType() == AccountTransaction.Type.DIVIDENDS;
    }
  }
.addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnPurchasePrice,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      if (t.getCrossEntry() instanceof BuySellEntry) {
        PortfolioTransaction portfolioTransaction=((BuySellEntry)t.getCrossEntry()).getPortfolioTransaction();
        return Values.Amount.format(portfolioTransaction.getActualPurchasePrice());
      }
 else       if (t.getType() == Type.DIVIDENDS && t.getShares() != 0) {
        return Values.Amount.format(Math.round(t.getAmount() * Values.Share.divider() / t.getShares()));
      }
 else {
        return null;
      }
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnOffsetAccount,SWT.None,120);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      AccountTransaction t=(AccountTransaction)e;
      return t.getCrossEntry() != null ? t.getCrossEntry().getCrossEntity(t).toString() : null;
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
  }
);
  transactionsColumns.addColumn(column);
  column=new Column(Messages.ColumnNote,SWT.None,200);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      return ((AccountTransaction)e).getNote();
    }
    @Override public Color getForeground(    Object element){
      return colorFor((AccountTransaction)element);
    }
    @Override public Image getImage(    Object e){
      String note=((AccountTransaction)e).getNote();
      return note != null && note.length() > 0 ? PortfolioPlugin.image(PortfolioPlugin.IMG_NOTE) : null;
    }
  }
);
  ColumnViewerSorter.create(AccountTransaction.class,""String_Node_Str"").attachTo(column);
  new StringEditingSupport(AccountTransaction.class,""String_Node_Str"").addListener(this).attachTo(column);
  transactionsColumns.addColumn(column);
  transactionsColumns.createColumns();
  transactions.getTable().setHeaderVisible(true);
  transactions.getTable().setLinesVisible(true);
  transactions.setContentProvider(new SimpleListContentProvider());
  hookContextMenu(transactions.getTable(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillTransactionsContextMenu(manager);
    }
  }
);
  if (!getClient().getAccounts().isEmpty())   accounts.setSelection(new StructuredSelection(accounts.getElementAt(0)),true);
  ViewerHelper.pack(transactions);
}",0.9967304347826088
52747,"protected void createBottomTable(Composite parent){
  CTabFolder folder=new CTabFolder(parent,SWT.BORDER);
  CTabItem item=new CTabItem(folder,SWT.NONE);
  item.setText(Messages.LabelStatementOfAssets);
  statementOfAssets=new StatementOfAssetsViewer(folder,this,getClient());
  item.setControl(statementOfAssets.getControl());
  hookContextMenu(statementOfAssets.getTableViewer().getControl(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      statementOfAssets.hookMenuListener(manager,PortfolioListView.this);
    }
  }
);
  item=new CTabItem(folder,SWT.NONE);
  item.setText(Messages.TabTransactions);
  transactions=new PortfolioTransactionsViewer(folder,this);
  item.setControl(transactions.getControl());
  folder.setSelection(0);
  if (!getClient().getPortfolios().isEmpty())   portfolios.setSelection(new StructuredSelection(portfolios.getElementAt(0)),true);
  statementOfAssets.pack();
  transactions.pack();
}","protected void createBottomTable(Composite parent){
  CTabFolder folder=new CTabFolder(parent,SWT.BORDER);
  CTabItem item=new CTabItem(folder,SWT.NONE);
  item.setText(Messages.LabelStatementOfAssets);
  statementOfAssets=new StatementOfAssetsViewer(folder,this,getClient());
  item.setControl(statementOfAssets.getControl());
  hookContextMenu(statementOfAssets.getTableViewer().getControl(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      statementOfAssets.hookMenuListener(manager,PortfolioListView.this);
    }
  }
);
  item=new CTabItem(folder,SWT.NONE);
  item.setText(Messages.TabTransactions);
  transactions=new PortfolioTransactionsViewer(folder,this);
  item.setControl(transactions.getControl());
  folder.setSelection(0);
  statementOfAssets.pack();
  transactions.pack();
  if (!getClient().getPortfolios().isEmpty())   portfolios.setSelection(new StructuredSelection(portfolios.getElementAt(0)),true);
}",0.9467084639498432
52748,"public void pack(){
  if (!support.isUserConfigured())   ViewerHelper.pack(tableViewer);
}","public void pack(){
  ViewerHelper.pack(tableViewer);
}",0.7586206896551724
52749,"public void pack(){
  if (!support.isUserConfigured())   ViewerHelper.pack(assets);
}","public void pack(){
  ViewerHelper.pack(assets);
}",0.7407407407407407
52750,"@Override protected void createTopTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  indeces=new TableViewer(container,SWT.FULL_SELECTION);
  ColumnEditingSupport.prepare(indeces);
  ShowHideColumnHelper support=new ShowHideColumnHelper(ConsumerPriceIndexListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),indeces,layout);
  Column column=new Column(Messages.ColumnYear,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return String.valueOf(((ConsumerPriceIndex)element).getYear());
    }
  }
);
  ColumnViewerSorter.create(ConsumerPriceIndex.class,""String_Node_Str"",""String_Node_Str"").attachTo(column,SWT.DOWN);
  new ValueEditingSupport(ConsumerPriceIndex.class,""String_Node_Str"",Values.Year).addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnMonth,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    private final String[] MONTHS=new DateFormatSymbols().getMonths();
    @Override public String getText(    Object element){
      return String.valueOf(MONTHS[((ConsumerPriceIndex)element).getMonth()]);
    }
  }
);
  ColumnViewerSorter.create(ConsumerPriceIndex.class,""String_Node_Str"",""String_Node_Str"").attachTo(column);
  new MonthEditingSupport(ConsumerPriceIndex.class,""String_Node_Str"").addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnIndex,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return Values.Index.format(((ConsumerPriceIndex)element).getIndex());
    }
  }
);
  ColumnViewerSorter.create(ConsumerPriceIndex.class,""String_Node_Str"").attachTo(column);
  new ValueEditingSupport(ConsumerPriceIndex.class,""String_Node_Str"",Values.Index).addListener(this).attachTo(column);
  support.addColumn(column);
  support.createColumns();
  indeces.getTable().setHeaderVisible(true);
  indeces.getTable().setLinesVisible(true);
  indeces.setContentProvider(new SimpleListContentProvider());
  indeces.setInput(getClient().getConsumerPriceIndeces());
  indeces.refresh();
  ViewerHelper.pack(indeces);
  hookContextMenu(indeces.getTable(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillContextMenu(manager);
    }
  }
);
}","@Override protected void createTopTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  indeces=new TableViewer(container,SWT.FULL_SELECTION);
  ColumnEditingSupport.prepare(indeces);
  ShowHideColumnHelper support=new ShowHideColumnHelper(ConsumerPriceIndexListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),indeces,layout);
  Column column=new Column(Messages.ColumnYear,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return String.valueOf(((ConsumerPriceIndex)element).getYear());
    }
  }
);
  ColumnViewerSorter.create(ConsumerPriceIndex.class,""String_Node_Str"",""String_Node_Str"").attachTo(column,SWT.DOWN);
  new ValueEditingSupport(ConsumerPriceIndex.class,""String_Node_Str"",Values.Year).addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnMonth,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    private final String[] MONTHS=new DateFormatSymbols().getMonths();
    @Override public String getText(    Object element){
      return String.valueOf(MONTHS[((ConsumerPriceIndex)element).getMonth()]);
    }
  }
);
  ColumnViewerSorter.create(ConsumerPriceIndex.class,""String_Node_Str"",""String_Node_Str"").attachTo(column);
  new MonthEditingSupport(ConsumerPriceIndex.class,""String_Node_Str"").addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnIndex,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return Values.Index.format(((ConsumerPriceIndex)element).getIndex());
    }
  }
);
  ColumnViewerSorter.create(ConsumerPriceIndex.class,""String_Node_Str"").attachTo(column);
  new ValueEditingSupport(ConsumerPriceIndex.class,""String_Node_Str"",Values.Index).addListener(this).attachTo(column);
  support.addColumn(column);
  support.createColumns();
  indeces.getTable().setHeaderVisible(true);
  indeces.getTable().setLinesVisible(true);
  indeces.setContentProvider(new SimpleListContentProvider());
  ViewerHelper.pack(indeces);
  indeces.setInput(getClient().getConsumerPriceIndeces());
  indeces.refresh();
  hookContextMenu(indeces.getTable(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillContextMenu(manager);
    }
  }
);
}",0.9879566439181052
52751,"@Override protected void createBottomTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  transactions=new TableViewer(container,SWT.FULL_SELECTION);
  ShowHideColumnHelper support=new ShowHideColumnHelper(DividendsPerformanceView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),transactions,layout);
  Column column=new Column(Messages.ColumnDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Transaction t=(Transaction)e;
      return Values.Date.format(t.getDate());
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Transaction.class,""String_Node_Str""),SWT.DOWN);
  support.addColumn(column);
  column=new Column(Messages.ColumnTransactionType,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object t){
      if (t instanceof PortfolioTransaction)       return ((PortfolioTransaction)t).getType().toString();
 else       if (t instanceof AccountTransaction)       return ((AccountTransaction)t).getType().toString();
 else       if (t instanceof DividendTransaction)       return Messages.LabelDividends;
 else       return Messages.LabelQuote;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnShares,SWT.None,80);
  column.setLabelProvider(new SharesLabelProvider(){
    @Override public Long getValue(    Object t){
      if (t instanceof PortfolioTransaction)       return ((PortfolioTransaction)t).getShares();
 else       if (t instanceof DividendInitialTransaction)       return ((DividendInitialTransaction)t).getPosition().getShares();
 else       if (t instanceof DividendFinalTransaction)       return ((DividendFinalTransaction)t).getPosition().getShares();
 else       if (t instanceof DividendTransaction)       return ((DividendTransaction)t).getShares() != 0L ? ((DividendTransaction)t).getShares() : null;
 else       return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnDividendPayment,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object t){
      if (t instanceof DividendTransaction)       return Values.Amount.format(((DividendTransaction)t).getAmount());
 else       return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnDividendPerShare,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object t){
      if (t instanceof DividendTransaction)       return Values.AmountFraction.formatNonZero(((DividendTransaction)t).getDividendPerShare());
 else       return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnPersonalDividendYield,SWT.RIGHT,80);
  column.setDescription(Messages.ColumnPersonalDividendYield_Description);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object t){
      if (t instanceof DividendTransaction)       return Values.Percent2.formatNonZero(((DividendTransaction)t).getPersonalDividendYield());
 else       return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnAmount,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object t){
      if (t instanceof PortfolioTransaction)       return Values.Amount.format(((PortfolioTransaction)t).getAmount());
 else       if (t instanceof DividendInitialTransaction)       return Values.Amount.format(((DividendInitialTransaction)t).getAmount());
 else       if (t instanceof DividendFinalTransaction)       return Values.Amount.format(((DividendFinalTransaction)t).getAmount());
 else       return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnAccount,SWT.None,120);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object t){
      if (t instanceof PortfolioTransaction) {
        PortfolioTransaction p=(PortfolioTransaction)t;
        return p.getCrossEntry() != null ? p.getCrossEntry().getCrossEntity(p).toString() : null;
      }
 else       if (t instanceof DividendTransaction) {
        return ((DividendTransaction)t).getAccount().getName();
      }
 else {
        return null;
      }
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnNote,SWT.LEFT,22);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object r){
      return ((Transaction)r).getNote();
    }
    @Override public Image getImage(    Object r){
      String note=((Transaction)r).getNote();
      return note != null && note.length() > 0 ? PortfolioPlugin.image(PortfolioPlugin.IMG_NOTE) : null;
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Transaction.class,""String_Node_Str""));
  support.addColumn(column);
  support.createColumns();
  transactions.getTable().setHeaderVisible(true);
  transactions.getTable().setLinesVisible(true);
  transactions.setContentProvider(new SimpleListContentProvider());
}","@Override protected void createBottomTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  transactions=new TableViewer(container,SWT.FULL_SELECTION);
  ShowHideColumnHelper support=new ShowHideColumnHelper(DividendsPerformanceView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),transactions,layout);
  Column column=new Column(Messages.ColumnDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Transaction t=(Transaction)e;
      return Values.Date.format(t.getDate());
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Transaction.class,""String_Node_Str""),SWT.DOWN);
  support.addColumn(column);
  column=new Column(Messages.ColumnTransactionType,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object t){
      if (t instanceof PortfolioTransaction)       return ((PortfolioTransaction)t).getType().toString();
 else       if (t instanceof AccountTransaction)       return ((AccountTransaction)t).getType().toString();
 else       if (t instanceof DividendTransaction)       return Messages.LabelDividends;
 else       return Messages.LabelQuote;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnShares,SWT.None,80);
  column.setLabelProvider(new SharesLabelProvider(){
    @Override public Long getValue(    Object t){
      if (t instanceof PortfolioTransaction)       return ((PortfolioTransaction)t).getShares();
 else       if (t instanceof DividendInitialTransaction)       return ((DividendInitialTransaction)t).getPosition().getShares();
 else       if (t instanceof DividendFinalTransaction)       return ((DividendFinalTransaction)t).getPosition().getShares();
 else       if (t instanceof DividendTransaction)       return ((DividendTransaction)t).getShares() != 0L ? ((DividendTransaction)t).getShares() : null;
 else       return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnDividendPayment,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object t){
      if (t instanceof DividendTransaction)       return Values.Amount.format(((DividendTransaction)t).getAmount());
 else       return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnDividendPerShare,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object t){
      if (t instanceof DividendTransaction)       return Values.AmountFraction.formatNonZero(((DividendTransaction)t).getDividendPerShare());
 else       return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnPersonalDividendYield,SWT.RIGHT,80);
  column.setDescription(Messages.ColumnPersonalDividendYield_Description);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object t){
      if (t instanceof DividendTransaction)       return Values.Percent2.formatNonZero(((DividendTransaction)t).getPersonalDividendYield());
 else       return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnAmount,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object t){
      if (t instanceof PortfolioTransaction)       return Values.Amount.format(((PortfolioTransaction)t).getAmount());
 else       if (t instanceof DividendInitialTransaction)       return Values.Amount.format(((DividendInitialTransaction)t).getAmount());
 else       if (t instanceof DividendFinalTransaction)       return Values.Amount.format(((DividendFinalTransaction)t).getAmount());
 else       return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnAccount,SWT.None,120);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object t){
      if (t instanceof PortfolioTransaction) {
        PortfolioTransaction p=(PortfolioTransaction)t;
        return p.getCrossEntry() != null ? p.getCrossEntry().getCrossEntity(p).toString() : null;
      }
 else       if (t instanceof DividendTransaction) {
        return ((DividendTransaction)t).getAccount().getName();
      }
 else {
        return null;
      }
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnNote,SWT.LEFT,22);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object r){
      return ((Transaction)r).getNote();
    }
    @Override public Image getImage(    Object r){
      String note=((Transaction)r).getNote();
      return note != null && note.length() > 0 ? PortfolioPlugin.image(PortfolioPlugin.IMG_NOTE) : null;
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Transaction.class,""String_Node_Str""));
  support.addColumn(column);
  support.createColumns();
  transactions.getTable().setHeaderVisible(true);
  transactions.getTable().setLinesVisible(true);
  transactions.setContentProvider(new SimpleListContentProvider());
  ViewerHelper.pack(transactions);
}",0.9966599866399466
52752,"@Override protected void createTopTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  records=new TableViewer(container,SWT.FULL_SELECTION);
  recordColumns=new ShowHideColumnHelper(DividendsPerformanceView.class.getName(),getClient(),getPreferenceStore(),records,layout);
  ColumnViewerToolTipSupport.enableFor(records,ToolTip.NO_RECREATE);
  ColumnEditingSupport.prepare(records);
  createCommonColumns();
  createDividendColumns();
  createAdditionalColumns();
  recordColumns.createColumns();
  records.getTable().setHeaderVisible(true);
  records.getTable().setLinesVisible(true);
  records.setContentProvider(new SimpleListContentProvider());
  records.addDragSupport(DND.DROP_MOVE,new Transfer[]{SecurityTransfer.getTransfer()},new SecurityDragListener(records));
  hookContextMenu(records.getTable(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillContextMenu(manager);
    }
  }
);
  records.addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      SecurityPerformanceRecord record=(SecurityPerformanceRecord)((IStructuredSelection)event.getSelection()).getFirstElement();
      transactions.setInput(record != null ? record.getTransactions() : Collections.emptyList());
      transactions.refresh();
    }
  }
);
  reportingPeriodUpdated();
  ViewerHelper.pack(records);
}","@Override protected void createTopTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  records=new TableViewer(container,SWT.FULL_SELECTION);
  recordColumns=new ShowHideColumnHelper(DividendsPerformanceView.class.getName(),getClient(),getPreferenceStore(),records,layout);
  ColumnViewerToolTipSupport.enableFor(records,ToolTip.NO_RECREATE);
  ColumnEditingSupport.prepare(records);
  createCommonColumns();
  createDividendColumns();
  createAdditionalColumns();
  recordColumns.createColumns();
  records.getTable().setHeaderVisible(true);
  records.getTable().setLinesVisible(true);
  records.setContentProvider(new SimpleListContentProvider());
  ViewerHelper.pack(records);
  records.addDragSupport(DND.DROP_MOVE,new Transfer[]{SecurityTransfer.getTransfer()},new SecurityDragListener(records));
  hookContextMenu(records.getTable(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillContextMenu(manager);
    }
  }
);
  records.addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      SecurityPerformanceRecord record=(SecurityPerformanceRecord)((IStructuredSelection)event.getSelection()).getFirstElement();
      transactions.setInput(record != null ? record.getTransactions() : Collections.emptyList());
      transactions.refresh();
    }
  }
);
  reportingPeriodUpdated();
}",0.9801718440185064
52753,"@Override protected void createTopTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  plans=new TableViewer(container,SWT.FULL_SELECTION);
  ColumnEditingSupport.prepare(plans);
  planColumns=new ShowHideColumnHelper(InvestmentPlanListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),plans,layout);
  addColumns(planColumns);
  planColumns.createColumns();
  plans.getTable().setHeaderVisible(true);
  plans.getTable().setLinesVisible(true);
  plans.setContentProvider(ArrayContentProvider.getInstance());
  plans.setInput(getClient().getPlans());
  if (!planColumns.isUserConfigured())   ViewerHelper.pack(plans);
  plans.addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      InvestmentPlan plan=(InvestmentPlan)((IStructuredSelection)event.getSelection()).getFirstElement();
      if (plan != null)       transactions.setInput(plan.getPortfolio(),plan.getTransactions());
 else       transactions.setInput(null,null);
      transactions.refresh();
    }
  }
);
  hookContextMenu(plans.getTable(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillPlansContextMenu(manager);
    }
  }
);
}","@Override protected void createTopTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  plans=new TableViewer(container,SWT.FULL_SELECTION);
  ColumnEditingSupport.prepare(plans);
  planColumns=new ShowHideColumnHelper(InvestmentPlanListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),plans,layout);
  addColumns(planColumns);
  planColumns.createColumns();
  plans.getTable().setHeaderVisible(true);
  plans.getTable().setLinesVisible(true);
  plans.setContentProvider(ArrayContentProvider.getInstance());
  plans.setInput(getClient().getPlans());
  ViewerHelper.pack(plans);
  plans.addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      InvestmentPlan plan=(InvestmentPlan)((IStructuredSelection)event.getSelection()).getFirstElement();
      if (plan != null)       transactions.setInput(plan.getPortfolio(),plan.getTransactions());
 else       transactions.setInput(null,null);
      transactions.refresh();
    }
  }
);
  hookContextMenu(plans.getTable(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillPlansContextMenu(manager);
    }
  }
);
}",0.9852328663385082
52754,"private void createEarningsItem(CTabFolder folder,String title){
  Composite container=new Composite(folder,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  earnings=new TableViewer(container,SWT.FULL_SELECTION);
  ShowHideColumnHelper support=new ShowHideColumnHelper(PerformanceView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),earnings,layout);
  Column column=new Column(Messages.ColumnDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return Values.Date.format(((Transaction)element).getDate());
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Transaction.class,""String_Node_Str""),SWT.UP);
  support.addColumn(column);
  column=new Column(Messages.ColumnAmount,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return Values.Amount.format(((Transaction)element).getAmount());
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Transaction.class,""String_Node_Str""));
  support.addColumn(column);
  column=new Column(Messages.ColumnSource,SWT.LEFT,400);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      Transaction transaction=(Transaction)element;
      if (transaction.getSecurity() != null)       return transaction.getSecurity().getName();
      for (      Account account : getClient().getAccounts()) {
        if (account.getTransactions().contains(transaction))         return account.getName();
      }
      return null;
    }
    @Override public Image getImage(    Object element){
      Transaction transaction=(Transaction)element;
      return PortfolioPlugin.image(transaction.getSecurity() != null ? PortfolioPlugin.IMG_SECURITY : PortfolioPlugin.IMG_ACCOUNT);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Transaction.class,""String_Node_Str""));
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnNote,SWT.LEFT,22);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return ((Transaction)element).getNote();
    }
    @Override public Image getImage(    Object e){
      String note=((Transaction)e).getNote();
      return note != null && note.length() > 0 ? PortfolioPlugin.image(PortfolioPlugin.IMG_NOTE) : null;
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Transaction.class,""String_Node_Str""));
  support.addColumn(column);
  support.createColumns();
  earnings.getTable().setHeaderVisible(true);
  earnings.getTable().setLinesVisible(true);
  earnings.setContentProvider(new SimpleListContentProvider());
  CTabItem item=new CTabItem(folder,SWT.NONE);
  item.setText(title);
  item.setControl(container);
}","private void createEarningsItem(CTabFolder folder,String title){
  Composite container=new Composite(folder,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  earnings=new TableViewer(container,SWT.FULL_SELECTION);
  ShowHideColumnHelper support=new ShowHideColumnHelper(PerformanceView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),earnings,layout);
  Column column=new Column(Messages.ColumnDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return Values.Date.format(((Transaction)element).getDate());
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Transaction.class,""String_Node_Str""),SWT.UP);
  support.addColumn(column);
  column=new Column(Messages.ColumnAmount,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return Values.Amount.format(((Transaction)element).getAmount());
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Transaction.class,""String_Node_Str""));
  support.addColumn(column);
  column=new Column(Messages.ColumnSource,SWT.LEFT,400);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      Transaction transaction=(Transaction)element;
      if (transaction.getSecurity() != null)       return transaction.getSecurity().getName();
      for (      Account account : getClient().getAccounts()) {
        if (account.getTransactions().contains(transaction))         return account.getName();
      }
      return null;
    }
    @Override public Image getImage(    Object element){
      Transaction transaction=(Transaction)element;
      return PortfolioPlugin.image(transaction.getSecurity() != null ? PortfolioPlugin.IMG_SECURITY : PortfolioPlugin.IMG_ACCOUNT);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Transaction.class,""String_Node_Str""));
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnNote,SWT.LEFT,22);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return ((Transaction)element).getNote();
    }
    @Override public Image getImage(    Object e){
      String note=((Transaction)e).getNote();
      return note != null && note.length() > 0 ? PortfolioPlugin.image(PortfolioPlugin.IMG_NOTE) : null;
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Transaction.class,""String_Node_Str""));
  support.addColumn(column);
  support.createColumns();
  earnings.getTable().setHeaderVisible(true);
  earnings.getTable().setLinesVisible(true);
  earnings.setContentProvider(new SimpleListContentProvider());
  ViewerHelper.pack(earnings);
  CTabItem item=new CTabItem(folder,SWT.NONE);
  item.setText(title);
  item.setControl(container);
}",0.9946227233304424
52755,"private void createCalculationItem(CTabFolder folder,String title){
  Composite container=new Composite(folder,SWT.NONE);
  TreeColumnLayout layout=new TreeColumnLayout();
  container.setLayout(layout);
  calculation=new TreeViewer(container,SWT.FULL_SELECTION);
  final Font boldFont=JFaceResources.getFontRegistry().getBold(container.getFont().getFontData()[0].getName());
  TreeViewerColumn column=new TreeViewerColumn(calculation,SWT.NONE);
  column.getColumn().setText(Messages.ColumnLable);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      if (element instanceof ClientPerformanceSnapshot.Category) {
        ClientPerformanceSnapshot.Category cat=(ClientPerformanceSnapshot.Category)element;
        return cat.getLabel();
      }
 else       if (element instanceof ClientPerformanceSnapshot.Position) {
        ClientPerformanceSnapshot.Position pos=(ClientPerformanceSnapshot.Position)element;
        return pos.getLabel();
      }
      return null;
    }
    @Override public Image getImage(    Object element){
      if (element instanceof ClientPerformanceSnapshot.Category) {
        return PortfolioPlugin.image(PortfolioPlugin.IMG_CATEGORY);
      }
 else       if (element instanceof ClientPerformanceSnapshot.Position) {
        ClientPerformanceSnapshot.Position position=(ClientPerformanceSnapshot.Position)element;
        return position.getSecurity() != null ? PortfolioPlugin.image(PortfolioPlugin.IMG_SECURITY) : null;
      }
      return null;
    }
    @Override public Font getFont(    Object element){
      if (element instanceof ClientPerformanceSnapshot.Category)       return boldFont;
      return null;
    }
  }
);
  layout.setColumnData(column.getColumn(),new ColumnPixelData(350));
  column=new TreeViewerColumn(calculation,SWT.RIGHT);
  column.getColumn().setText(Messages.ColumnValue);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      if (element instanceof ClientPerformanceSnapshot.Category) {
        ClientPerformanceSnapshot.Category cat=(ClientPerformanceSnapshot.Category)element;
        return Values.Amount.format(cat.getValuation());
      }
 else       if (element instanceof ClientPerformanceSnapshot.Position) {
        ClientPerformanceSnapshot.Position pos=(ClientPerformanceSnapshot.Position)element;
        return Values.Amount.format(pos.getValuation());
      }
      return null;
    }
    @Override public Font getFont(    Object element){
      if (element instanceof ClientPerformanceSnapshot.Category)       return boldFont;
      return null;
    }
  }
);
  layout.setColumnData(column.getColumn(),new ColumnPixelData(80));
  calculation.getTree().setHeaderVisible(true);
  calculation.getTree().setLinesVisible(true);
  calculation.setContentProvider(new PerformanceContentProvider());
  CTabItem item=new CTabItem(folder,SWT.NONE);
  item.setText(title);
  item.setControl(container);
  hookContextMenu(calculation.getTree(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillContextMenu(manager);
    }
  }
);
}","private void createCalculationItem(CTabFolder folder,String title){
  Composite container=new Composite(folder,SWT.NONE);
  TreeColumnLayout layout=new TreeColumnLayout();
  container.setLayout(layout);
  calculation=new TreeViewer(container,SWT.FULL_SELECTION);
  final Font boldFont=JFaceResources.getFontRegistry().getBold(container.getFont().getFontData()[0].getName());
  TreeViewerColumn column=new TreeViewerColumn(calculation,SWT.NONE);
  column.getColumn().setText(Messages.ColumnLable);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      if (element instanceof ClientPerformanceSnapshot.Category) {
        ClientPerformanceSnapshot.Category cat=(ClientPerformanceSnapshot.Category)element;
        return cat.getLabel();
      }
 else       if (element instanceof ClientPerformanceSnapshot.Position) {
        ClientPerformanceSnapshot.Position pos=(ClientPerformanceSnapshot.Position)element;
        return pos.getLabel();
      }
      return null;
    }
    @Override public Image getImage(    Object element){
      if (element instanceof ClientPerformanceSnapshot.Category) {
        return PortfolioPlugin.image(PortfolioPlugin.IMG_CATEGORY);
      }
 else       if (element instanceof ClientPerformanceSnapshot.Position) {
        ClientPerformanceSnapshot.Position position=(ClientPerformanceSnapshot.Position)element;
        return position.getSecurity() != null ? PortfolioPlugin.image(PortfolioPlugin.IMG_SECURITY) : null;
      }
      return null;
    }
    @Override public Font getFont(    Object element){
      if (element instanceof ClientPerformanceSnapshot.Category)       return boldFont;
      return null;
    }
  }
);
  layout.setColumnData(column.getColumn(),new ColumnPixelData(350));
  column=new TreeViewerColumn(calculation,SWT.RIGHT);
  column.getColumn().setText(Messages.ColumnValue);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      if (element instanceof ClientPerformanceSnapshot.Category) {
        ClientPerformanceSnapshot.Category cat=(ClientPerformanceSnapshot.Category)element;
        return Values.Amount.format(cat.getValuation());
      }
 else       if (element instanceof ClientPerformanceSnapshot.Position) {
        ClientPerformanceSnapshot.Position pos=(ClientPerformanceSnapshot.Position)element;
        return Values.Amount.format(pos.getValuation());
      }
      return null;
    }
    @Override public Font getFont(    Object element){
      if (element instanceof ClientPerformanceSnapshot.Category)       return boldFont;
      return null;
    }
  }
);
  layout.setColumnData(column.getColumn(),new ColumnPixelData(80));
  calculation.getTree().setHeaderVisible(true);
  calculation.getTree().setLinesVisible(true);
  calculation.setContentProvider(new PerformanceContentProvider());
  ViewerHelper.pack(calculation);
  CTabItem item=new CTabItem(folder,SWT.NONE);
  item.setText(title);
  item.setControl(container);
  hookContextMenu(calculation.getTree(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillContextMenu(manager);
    }
  }
);
}",0.9946422943586511
52756,"private void createEarningsByAccountsItem(CTabFolder folder,String title){
  Composite container=new Composite(folder,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  earningsByAccount=new TableViewer(container,SWT.FULL_SELECTION);
  ShowHideColumnHelper support=new ShowHideColumnHelper(PerformanceView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),earningsByAccount,layout);
  Column column=new Column(Messages.ColumnSource,SWT.LEFT,400);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      GroupEarningsByAccount.Item item=(GroupEarningsByAccount.Item)element;
      return item.getAccount().getName();
    }
    @Override public Image getImage(    Object element){
      return PortfolioPlugin.image(PortfolioPlugin.IMG_ACCOUNT);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(GroupEarningsByAccount.Item.class,""String_Node_Str""));
  support.addColumn(column);
  column=new Column(Messages.ColumnAmount,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      GroupEarningsByAccount.Item item=(GroupEarningsByAccount.Item)element;
      return Values.Amount.format(item.getSum());
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(GroupEarningsByAccount.Item.class,""String_Node_Str""));
  support.addColumn(column);
  support.createColumns();
  earningsByAccount.getTable().setHeaderVisible(true);
  earningsByAccount.getTable().setLinesVisible(true);
  earningsByAccount.setContentProvider(new SimpleListContentProvider());
  CTabItem item=new CTabItem(folder,SWT.NONE);
  item.setText(title);
  item.setControl(container);
}","private void createEarningsByAccountsItem(CTabFolder folder,String title){
  Composite container=new Composite(folder,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  earningsByAccount=new TableViewer(container,SWT.FULL_SELECTION);
  ShowHideColumnHelper support=new ShowHideColumnHelper(PerformanceView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),earningsByAccount,layout);
  Column column=new Column(Messages.ColumnSource,SWT.LEFT,400);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      GroupEarningsByAccount.Item item=(GroupEarningsByAccount.Item)element;
      return item.getAccount().getName();
    }
    @Override public Image getImage(    Object element){
      return PortfolioPlugin.image(PortfolioPlugin.IMG_ACCOUNT);
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(GroupEarningsByAccount.Item.class,""String_Node_Str""));
  support.addColumn(column);
  column=new Column(Messages.ColumnAmount,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      GroupEarningsByAccount.Item item=(GroupEarningsByAccount.Item)element;
      return Values.Amount.format(item.getSum());
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(GroupEarningsByAccount.Item.class,""String_Node_Str""));
  support.addColumn(column);
  support.createColumns();
  earningsByAccount.getTable().setHeaderVisible(true);
  earningsByAccount.getTable().setLinesVisible(true);
  earningsByAccount.setContentProvider(new SimpleListContentProvider());
  ViewerHelper.pack(earningsByAccount);
  CTabItem item=new CTabItem(folder,SWT.NONE);
  item.setText(title);
  item.setControl(container);
}",0.9887005649717514
52757,"protected void createTopTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  portfolios=new TableViewer(container,SWT.FULL_SELECTION);
  ColumnEditingSupport.prepare(portfolios);
  portfolioColumns=new ShowHideColumnHelper(PortfolioListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),portfolios,layout);
  Column column=new NameColumn(""String_Node_Str"",Messages.ColumnPortfolio,SWT.None,100);
  column.getEditingSupport().addListener(this);
  portfolioColumns.addColumn(column);
  column=new Column(Messages.ColumnReferenceAccount,SWT.None,160);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Portfolio p=(Portfolio)e;
      return p.getReferenceAccount() != null ? p.getReferenceAccount().getName() : null;
    }
    @Override public Image getImage(    Object e){
      String note=((Portfolio)e).getNote();
      return note != null && note.length() > 0 ? PortfolioPlugin.image(PortfolioPlugin.IMG_NOTE) : null;
    }
  }
);
  ColumnViewerSorter.create(Portfolio.class,""String_Node_Str"").attachTo(column);
  new ListEditingSupport(Portfolio.class,""String_Node_Str"",getClient().getAccounts()).addListener(this).attachTo(column);
  portfolioColumns.addColumn(column);
  column=new NoteColumn();
  column.getEditingSupport().addListener(this);
  portfolioColumns.addColumn(column);
  portfolioColumns.createColumns();
  portfolios.getTable().setHeaderVisible(true);
  portfolios.getTable().setLinesVisible(true);
  portfolios.setContentProvider(new SimpleListContentProvider());
  portfolios.setInput(getClient().getPortfolios());
  if (!portfolioColumns.isUserConfigured())   ViewerHelper.pack(portfolios);
  portfolios.addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      Portfolio portfolio=(Portfolio)((IStructuredSelection)event.getSelection()).getFirstElement();
      if (portfolio != null) {
        transactions.setInput(portfolio,portfolio.getTransactions());
        transactions.refresh();
        statementOfAssets.setInput(PortfolioSnapshot.create(portfolio,Dates.today()));
      }
 else {
        transactions.setInput(null,null);
        transactions.refresh();
        statementOfAssets.setInput((PortfolioSnapshot)null);
      }
    }
  }
);
  hookContextMenu(portfolios.getTable(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillPortfolioContextMenu(manager);
    }
  }
);
}","protected void createTopTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  portfolios=new TableViewer(container,SWT.FULL_SELECTION);
  ColumnEditingSupport.prepare(portfolios);
  portfolioColumns=new ShowHideColumnHelper(PortfolioListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),portfolios,layout);
  Column column=new NameColumn(""String_Node_Str"",Messages.ColumnPortfolio,SWT.None,100);
  column.getEditingSupport().addListener(this);
  portfolioColumns.addColumn(column);
  column=new Column(Messages.ColumnReferenceAccount,SWT.None,160);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Portfolio p=(Portfolio)e;
      return p.getReferenceAccount() != null ? p.getReferenceAccount().getName() : null;
    }
    @Override public Image getImage(    Object e){
      String note=((Portfolio)e).getNote();
      return note != null && note.length() > 0 ? PortfolioPlugin.image(PortfolioPlugin.IMG_NOTE) : null;
    }
  }
);
  ColumnViewerSorter.create(Portfolio.class,""String_Node_Str"").attachTo(column);
  new ListEditingSupport(Portfolio.class,""String_Node_Str"",getClient().getAccounts()).addListener(this).attachTo(column);
  portfolioColumns.addColumn(column);
  column=new NoteColumn();
  column.getEditingSupport().addListener(this);
  portfolioColumns.addColumn(column);
  portfolioColumns.createColumns();
  portfolios.getTable().setHeaderVisible(true);
  portfolios.getTable().setLinesVisible(true);
  portfolios.setContentProvider(new SimpleListContentProvider());
  portfolios.setInput(getClient().getPortfolios());
  ViewerHelper.pack(portfolios);
  portfolios.addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      Portfolio portfolio=(Portfolio)((IStructuredSelection)event.getSelection()).getFirstElement();
      if (portfolio != null) {
        transactions.setInput(portfolio,portfolio.getTransactions());
        transactions.refresh();
        statementOfAssets.setInput(PortfolioSnapshot.create(portfolio,Dates.today()));
      }
 else {
        transactions.setInput(null,null);
        transactions.refresh();
        statementOfAssets.setInput((PortfolioSnapshot)null);
      }
    }
  }
);
  hookContextMenu(portfolios.getTable(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillPortfolioContextMenu(manager);
    }
  }
);
}",0.991499227202473
52758,"public SecuritiesTable(Composite parent,AbstractFinanceView view){
  this.view=view;
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  this.securities=new TableViewer(container,SWT.FULL_SELECTION);
  ColumnEditingSupport.prepare(securities);
  support=new ShowHideColumnHelper(SecuritiesTable.class.getName(),getClient(),view.getPreferenceStore(),securities,layout);
  addMasterDataColumns();
  addColumnLatestPrice();
  addDeltaColumn();
  addColumnDateOfLatestPrice();
  addColumnDateOfLatestHistoricalPrice();
  for (  Taxonomy taxonomy : getClient().getTaxonomies()) {
    Column column=new TaxonomyColumn(taxonomy);
    column.setVisible(false);
    support.addColumn(column);
  }
  addAttributeColumns();
  support.createColumns();
  securities.getTable().setHeaderVisible(true);
  securities.getTable().setLinesVisible(true);
  securities.setContentProvider(new SimpleListContentProvider());
  securities.addDragSupport(DND.DROP_MOVE,new Transfer[]{SecurityTransfer.getTransfer()},new SecurityDragListener(securities));
  if (!support.isUserConfigured())   ViewerHelper.pack(securities);
  securities.refresh();
  hookContextMenu();
}","public SecuritiesTable(Composite parent,AbstractFinanceView view){
  this.view=view;
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  this.securities=new TableViewer(container,SWT.FULL_SELECTION);
  ColumnEditingSupport.prepare(securities);
  support=new ShowHideColumnHelper(SecuritiesTable.class.getName(),getClient(),view.getPreferenceStore(),securities,layout);
  addMasterDataColumns();
  addColumnLatestPrice();
  addDeltaColumn();
  addColumnDateOfLatestPrice();
  addColumnDateOfLatestHistoricalPrice();
  for (  Taxonomy taxonomy : getClient().getTaxonomies()) {
    Column column=new TaxonomyColumn(taxonomy);
    column.setVisible(false);
    support.addColumn(column);
  }
  addAttributeColumns();
  support.createColumns();
  securities.getTable().setHeaderVisible(true);
  securities.getTable().setLinesVisible(true);
  securities.setContentProvider(new SimpleListContentProvider());
  securities.addDragSupport(DND.DROP_MOVE,new Transfer[]{SecurityTransfer.getTransfer()},new SecurityDragListener(securities));
  ViewerHelper.pack(securities);
  securities.refresh();
  hookContextMenu();
}",0.9369072164948452
52759,"protected Composite createEventsTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  events=new TableViewer(container,SWT.FULL_SELECTION);
  ShowHideColumnHelper support=new ShowHideColumnHelper(SecurityListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),events,layout);
  Column column=new Column(Messages.ColumnDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return Values.Date.format(((SecurityEvent)element).getDate());
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnTransactionType,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return ((SecurityEvent)element).getType().toString();
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnDetails,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return ((SecurityEvent)element).getDetails();
    }
  }
);
  support.addColumn(column);
  support.createColumns();
  events.getTable().setHeaderVisible(true);
  events.getTable().setLinesVisible(true);
  events.setContentProvider(new SimpleListContentProvider(true));
  return container;
}","protected Composite createEventsTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  events=new TableViewer(container,SWT.FULL_SELECTION);
  ShowHideColumnHelper support=new ShowHideColumnHelper(SecurityListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),events,layout);
  Column column=new Column(Messages.ColumnDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return Values.Date.format(((SecurityEvent)element).getDate());
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnTransactionType,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return ((SecurityEvent)element).getType().toString();
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnDetails,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return ((SecurityEvent)element).getDetails();
    }
  }
);
  support.addColumn(column);
  support.createColumns();
  events.getTable().setHeaderVisible(true);
  events.getTable().setLinesVisible(true);
  events.setContentProvider(new SimpleListContentProvider(true));
  ViewerHelper.pack(events);
  return container;
}",0.9899130434782608
52760,"protected Composite createPricesTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  prices=new TableViewer(container,SWT.FULL_SELECTION | SWT.MULTI);
  ColumnEditingSupport.prepare(prices);
  ShowHideColumnHelper support=new ShowHideColumnHelper(SecurityListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),prices,layout);
  Column column=new Column(Messages.ColumnDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return Values.Date.format(((SecurityPrice)element).getTime());
    }
  }
);
  ColumnViewerSorter.create(SecurityPrice.class,""String_Node_Str"").attachTo(column,SWT.UP);
  new DateEditingSupport(SecurityPrice.class,""String_Node_Str"").addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnQuote,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return Values.Quote.format(((SecurityPrice)element).getValue());
    }
  }
);
  ColumnViewerSorter.create(SecurityPrice.class,""String_Node_Str"").attachTo(column);
  new ValueEditingSupport(SecurityPrice.class,""String_Node_Str"",Values.Quote).addListener(this).attachTo(column);
  support.addColumn(column);
  support.createColumns();
  prices.getTable().setHeaderVisible(true);
  prices.getTable().setLinesVisible(true);
  prices.setContentProvider(new SimpleListContentProvider(true));
  hookContextMenu(prices.getTable(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillPricesContextMenu(manager);
    }
  }
);
  return container;
}","protected Composite createPricesTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  prices=new TableViewer(container,SWT.FULL_SELECTION | SWT.MULTI);
  ColumnEditingSupport.prepare(prices);
  ShowHideColumnHelper support=new ShowHideColumnHelper(SecurityListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),prices,layout);
  Column column=new Column(Messages.ColumnDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return Values.Date.format(((SecurityPrice)element).getTime());
    }
  }
);
  ColumnViewerSorter.create(SecurityPrice.class,""String_Node_Str"").attachTo(column,SWT.UP);
  new DateEditingSupport(SecurityPrice.class,""String_Node_Str"").addListener(this).attachTo(column);
  support.addColumn(column);
  column=new Column(Messages.ColumnQuote,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return Values.Quote.format(((SecurityPrice)element).getValue());
    }
  }
);
  ColumnViewerSorter.create(SecurityPrice.class,""String_Node_Str"").attachTo(column);
  new ValueEditingSupport(SecurityPrice.class,""String_Node_Str"",Values.Quote).addListener(this).attachTo(column);
  support.addColumn(column);
  support.createColumns();
  prices.getTable().setHeaderVisible(true);
  prices.getTable().setLinesVisible(true);
  prices.setContentProvider(new SimpleListContentProvider(true));
  ViewerHelper.pack(prices);
  hookContextMenu(prices.getTable(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillPricesContextMenu(manager);
    }
  }
);
  return container;
}",0.9918926474699468
52761,"protected Composite createTransactionTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  transactions=new TableViewer(container,SWT.FULL_SELECTION);
  ColumnViewerToolTipSupport.enableFor(transactions,ToolTip.NO_RECREATE);
  ShowHideColumnHelper support=new ShowHideColumnHelper(SecurityListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),transactions,layout);
  Column column=new Column(Messages.ColumnDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return Values.Date.format(((TransactionPair<?>)element).getTransaction().getDate());
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(new Comparator<Object>(){
    @Override public int compare(    Object o1,    Object o2){
      return ((TransactionPair<?>)o1).getTransaction().getDate().compareTo((((TransactionPair<?>)o2).getTransaction().getDate()));
    }
  }
),SWT.UP);
  support.addColumn(column);
  column=new Column(Messages.ColumnTransactionType,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      Transaction t=((TransactionPair<?>)element).getTransaction();
      if (t instanceof PortfolioTransaction)       return ((PortfolioTransaction)t).getType().toString();
 else       if (t instanceof AccountTransaction)       return ((AccountTransaction)t).getType().toString();
 else       return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnShares,SWT.RIGHT,80);
  column.setLabelProvider(new SharesLabelProvider(){
    @Override public Long getValue(    Object element){
      Transaction t=((TransactionPair<?>)element).getTransaction();
      if (t instanceof PortfolioTransaction) {
        return ((PortfolioTransaction)t).getShares();
      }
 else       if (t instanceof AccountTransaction) {
        long shares=((AccountTransaction)t).getShares();
        return shares != 0 ? shares : null;
      }
      return null;
    }
    @Override public String getToolTipText(    Object element){
      Long v=getValue(element);
      return v != null ? Values.Share.format(v) : null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnAmount,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      Transaction t=((TransactionPair<?>)element).getTransaction();
      return Values.Amount.format(t.getAmount());
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(new Comparator<Object>(){
    @Override public int compare(    Object o1,    Object o2){
      long a1=((TransactionPair<?>)o1).getTransaction().getAmount();
      long a2=((TransactionPair<?>)o2).getTransaction().getAmount();
      return a1 > a2 ? 1 : a1 < a2 ? -1 : 0;
    }
  }
));
  support.addColumn(column);
  column=new Column(Messages.ColumnQuote,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      Transaction t=((TransactionPair<?>)element).getTransaction();
      if (t instanceof PortfolioTransaction) {
        return Values.Amount.format(((PortfolioTransaction)t).getActualPurchasePrice());
      }
 else       if (t instanceof AccountTransaction) {
        long shares=((AccountTransaction)t).getShares();
        if (shares != 0)         return Values.Amount.format(Math.round(t.getAmount() * Values.Share.divider() / shares));
      }
      return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnPortfolio,SWT.NONE,120);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TransactionOwner<?> owner=((TransactionPair<?>)element).getOwner();
      if (owner instanceof Portfolio)       return owner.toString();
      return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnOffsetAccount,SWT.NONE,120);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TransactionPair<?> pair=(TransactionPair<?>)element;
      Transaction t=pair.getTransaction();
      if (t instanceof PortfolioTransaction)       return t.getCrossEntry() != null ? t.getCrossEntry().getCrossEntity(t).toString() : null;
 else       return pair.getOwner().toString();
    }
  }
);
  support.addColumn(column);
  support.createColumns();
  transactions.getTable().setHeaderVisible(true);
  transactions.getTable().setLinesVisible(true);
  transactions.setContentProvider(new SimpleListContentProvider(true));
  return container;
}","protected Composite createTransactionTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  transactions=new TableViewer(container,SWT.FULL_SELECTION);
  ColumnViewerToolTipSupport.enableFor(transactions,ToolTip.NO_RECREATE);
  ShowHideColumnHelper support=new ShowHideColumnHelper(SecurityListView.class.getSimpleName() + ""String_Node_Str"",getPreferenceStore(),transactions,layout);
  Column column=new Column(Messages.ColumnDate,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return Values.Date.format(((TransactionPair<?>)element).getTransaction().getDate());
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(new Comparator<Object>(){
    @Override public int compare(    Object o1,    Object o2){
      return ((TransactionPair<?>)o1).getTransaction().getDate().compareTo((((TransactionPair<?>)o2).getTransaction().getDate()));
    }
  }
),SWT.UP);
  support.addColumn(column);
  column=new Column(Messages.ColumnTransactionType,SWT.None,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      Transaction t=((TransactionPair<?>)element).getTransaction();
      if (t instanceof PortfolioTransaction)       return ((PortfolioTransaction)t).getType().toString();
 else       if (t instanceof AccountTransaction)       return ((AccountTransaction)t).getType().toString();
 else       return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnShares,SWT.RIGHT,80);
  column.setLabelProvider(new SharesLabelProvider(){
    @Override public Long getValue(    Object element){
      Transaction t=((TransactionPair<?>)element).getTransaction();
      if (t instanceof PortfolioTransaction) {
        return ((PortfolioTransaction)t).getShares();
      }
 else       if (t instanceof AccountTransaction) {
        long shares=((AccountTransaction)t).getShares();
        return shares != 0 ? shares : null;
      }
      return null;
    }
    @Override public String getToolTipText(    Object element){
      Long v=getValue(element);
      return v != null ? Values.Share.format(v) : null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnAmount,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      Transaction t=((TransactionPair<?>)element).getTransaction();
      return Values.Amount.format(t.getAmount());
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(new Comparator<Object>(){
    @Override public int compare(    Object o1,    Object o2){
      long a1=((TransactionPair<?>)o1).getTransaction().getAmount();
      long a2=((TransactionPair<?>)o2).getTransaction().getAmount();
      return a1 > a2 ? 1 : a1 < a2 ? -1 : 0;
    }
  }
));
  support.addColumn(column);
  column=new Column(Messages.ColumnQuote,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      Transaction t=((TransactionPair<?>)element).getTransaction();
      if (t instanceof PortfolioTransaction) {
        return Values.Amount.format(((PortfolioTransaction)t).getActualPurchasePrice());
      }
 else       if (t instanceof AccountTransaction) {
        long shares=((AccountTransaction)t).getShares();
        if (shares != 0)         return Values.Amount.format(Math.round(t.getAmount() * Values.Share.divider() / shares));
      }
      return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnPortfolio,SWT.NONE,120);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TransactionOwner<?> owner=((TransactionPair<?>)element).getOwner();
      if (owner instanceof Portfolio)       return owner.toString();
      return null;
    }
  }
);
  support.addColumn(column);
  column=new Column(Messages.ColumnOffsetAccount,SWT.NONE,120);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      TransactionPair<?> pair=(TransactionPair<?>)element;
      Transaction t=pair.getTransaction();
      if (t instanceof PortfolioTransaction)       return t.getCrossEntry() != null ? t.getCrossEntry().getCrossEntity(t).toString() : null;
 else       return pair.getOwner().toString();
    }
  }
);
  support.addColumn(column);
  support.createColumns();
  transactions.getTable().setHeaderVisible(true);
  transactions.getTable().setLinesVisible(true);
  transactions.setContentProvider(new SimpleListContentProvider(true));
  ViewerHelper.pack(transactions);
  return container;
}",0.9963400606504236
52762,"private void createColumns(Composite parent){
  container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  assets=new TableViewer(container,SWT.FULL_SELECTION);
  ColumnViewerToolTipSupport.enableFor(assets,ToolTip.NO_RECREATE);
  ColumnEditingSupport.prepare(assets);
  support=new ShowHideColumnHelper(StatementOfAssetsViewer.class.getName(),client,owner.getPreferenceStore(),assets,layout);
  Column column=new Column(""String_Node_Str"",Messages.ColumnSharesOwned,SWT.RIGHT,80);
  column.setLabelProvider(new SharesLabelProvider(){
    @Override public Long getValue(    Object e){
      Element element=(Element)e;
      return element.isSecurity() ? element.getSecurityPosition().getShares() : null;
    }
    @Override public String getToolTipText(    Object e){
      Element element=(Element)e;
      return element.isSecurity() ? Values.Share.format(element.getSecurityPosition().getShares()) : null;
    }
  }
);
  support.addColumn(column);
  column=new NameColumn(""String_Node_Str"");
  column.setLabelProvider(new NameColumnLabelProvider(){
    @Override public String getText(    Object e){
      if (((Element)e).isGroupByTaxonomy())       return Messages.LabelTotalSum;
      return super.getText(e);
    }
    @Override public Font getFont(    Object e){
      return ((Element)e).isGroupByTaxonomy() || ((Element)e).isCategory() ? boldFont : null;
    }
    @Override public Image getImage(    Object e){
      if (((Element)e).isCategory())       return null;
      return super.getImage(e);
    }
  }
);
  column.setEditingSupport(new StringEditingSupport(Named.class,""String_Node_Str""){
    @Override public boolean canEdit(    Object element){
      boolean isCategory=((Element)element).isCategory();
      boolean isUnassignedCategory=isCategory && Classification.UNASSIGNED_ID.equals(((Element)element).getCategory().getClassification().getId());
      return !isUnassignedCategory ? super.canEdit(element) : false;
    }
  }
.setMandatory(true).addListener(new MarkDirtyListener(this.owner)));
  column.setSorter(null);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnTicker,SWT.None,60);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      return element.isSecurity() ? element.getSecurity().getTickerSymbol() : null;
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnWKN,SWT.None,60);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      return element.isSecurity() ? element.getSecurity().getWkn() : null;
    }
  }
);
  column.setVisible(false);
  support.addColumn(column);
  column=new IsinColumn(""String_Node_Str"");
  column.getEditingSupport().addListener(new MarkDirtyListener(this.owner));
  column.setSorter(null);
  column.setVisible(false);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnQuote,SWT.RIGHT,60);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      return element.isSecurity() ? Values.Quote.format(element.getSecurityPosition().getPrice().getValue()) : null;
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnMarketValue,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      return Values.Amount.format(element.getValuation());
    }
    @Override public Font getFont(    Object e){
      return ((Element)e).isGroupByTaxonomy() || ((Element)e).isCategory() ? boldFont : null;
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnShareInPercent,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      if (element.isGroupByTaxonomy())       return Values.Percent.format(1d);
      if (element.isCategory())       return Values.Percent.format(element.getCategory().getShare());
 else       return Values.Percent.format(element.getPosition().getShare());
    }
    @Override public Font getFont(    Object e){
      return ((Element)e).isGroupByTaxonomy() || ((Element)e).isCategory() ? boldFont : null;
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnPurchasePrice,SWT.RIGHT,60);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      if (element.isSecurity()) {
        long purchasePrice=element.getSecurityPosition().getFIFOPurchasePrice();
        return purchasePrice == 0 ? null : Values.Amount.format(purchasePrice);
      }
      return null;
    }
  }
);
  column.setVisible(false);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnPurchaseValue,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      long purchaseValue=element.getFIFOPurchaseValue();
      return purchaseValue == 0 ? null : Values.Amount.format(purchaseValue);
    }
    @Override public Font getFont(    Object e){
      return ((Element)e).isGroupByTaxonomy() || ((Element)e).isCategory() ? boldFont : null;
    }
  }
);
  column.setVisible(false);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnProfitLoss,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      long profitLoss=element.getProfitLoss();
      return profitLoss == 0 ? null : Values.Amount.format(profitLoss);
    }
    @Override public Color getForeground(    Object e){
      Element element=(Element)e;
      long profitLoss=element.getProfitLoss();
      if (profitLoss < 0)       return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_RED);
 else       if (profitLoss > 0)       return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_GREEN);
 else       return null;
    }
    @Override public Font getFont(    Object e){
      return ((Element)e).isGroupByTaxonomy() || ((Element)e).isCategory() ? boldFont : null;
    }
  }
);
  column.setVisible(false);
  support.addColumn(column);
  column=new NoteColumn();
  column.getEditingSupport().addListener(new MarkDirtyListener(this.owner));
  column.setSorter(null);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnIRRPerformance,SWT.RIGHT,80);
  column.setOptions(Messages.LabelReportingYears,Messages.ColumnIRRPerformanceOption,1,2,3,4,5,10);
  column.setLabelProvider(new OptionLabelProvider(){
    @Override public String getText(    Object e,    Integer option){
      Element element=(Element)e;
      if (element.isSecurity()) {
        calculatePerformance(element,option);
        SecurityPerformanceRecord record=element.getPerformance(option);
        return Values.Percent.format(record.getIrr());
      }
      return null;
    }
    @Override public Color getForeground(    Object e,    Integer option){
      Element element=(Element)e;
      if (element.isSecurity()) {
        calculatePerformance(element,option);
        SecurityPerformanceRecord record=element.getPerformance(option);
        double irr=record.getIrr();
        if (irr < 0)         return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_RED);
 else         if (irr > 0)         return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_GREEN);
      }
      return null;
    }
  }
);
  column.setVisible(false);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnTotalProfitLoss,SWT.RIGHT,80);
  column.setOptions(Messages.LabelReportingYears,Messages.ColumnTotalProfitLossOption,1,2,3,4,5,10);
  column.setLabelProvider(new OptionLabelProvider(){
    @Override public String getText(    Object e,    Integer option){
      Element element=(Element)e;
      if (element.isSecurity()) {
        calculatePerformance(element,option);
        SecurityPerformanceRecord record=element.getPerformance(option);
        return Values.Amount.format(record.getDelta());
      }
      return null;
    }
    @Override public Color getForeground(    Object e,    Integer option){
      Element element=(Element)e;
      if (element.isSecurity()) {
        calculatePerformance(element,option);
        SecurityPerformanceRecord record=element.getPerformance(option);
        long delta=record.getDelta();
        if (delta < 0)         return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_RED);
 else         if (delta > 0)         return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_GREEN);
      }
      return null;
    }
  }
);
  column.setVisible(false);
  support.addColumn(column);
  addTaxonomyColumns();
  addAttributeColumns();
  support.createColumns();
  assets.getTable().setHeaderVisible(true);
  assets.getTable().setLinesVisible(true);
  assets.setContentProvider(new StatementOfAssetsContentProvider());
  assets.addDragSupport(DND.DROP_MOVE,new Transfer[]{SecurityTransfer.getTransfer()},new SecurityDragListener(assets));
  LocalResourceManager resources=new LocalResourceManager(JFaceResources.getResources(),assets.getTable());
  boldFont=resources.createFont(FontDescriptor.createFrom(assets.getTable().getFont()).setStyle(SWT.BOLD));
}","private void createColumns(Composite parent){
  container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  assets=new TableViewer(container,SWT.FULL_SELECTION);
  ColumnViewerToolTipSupport.enableFor(assets,ToolTip.NO_RECREATE);
  ColumnEditingSupport.prepare(assets);
  support=new ShowHideColumnHelper(StatementOfAssetsViewer.class.getName(),client,owner.getPreferenceStore(),assets,layout);
  Column column=new Column(""String_Node_Str"",Messages.ColumnSharesOwned,SWT.RIGHT,80);
  column.setLabelProvider(new SharesLabelProvider(){
    @Override public Long getValue(    Object e){
      Element element=(Element)e;
      return element.isSecurity() ? element.getSecurityPosition().getShares() : null;
    }
    @Override public String getToolTipText(    Object e){
      Element element=(Element)e;
      return element.isSecurity() ? Values.Share.format(element.getSecurityPosition().getShares()) : null;
    }
  }
);
  support.addColumn(column);
  column=new NameColumn(""String_Node_Str"");
  column.setLabelProvider(new NameColumnLabelProvider(){
    @Override public String getText(    Object e){
      if (((Element)e).isGroupByTaxonomy())       return Messages.LabelTotalSum;
      return super.getText(e);
    }
    @Override public Font getFont(    Object e){
      return ((Element)e).isGroupByTaxonomy() || ((Element)e).isCategory() ? boldFont : null;
    }
    @Override public Image getImage(    Object e){
      if (((Element)e).isCategory())       return null;
      return super.getImage(e);
    }
  }
);
  column.setEditingSupport(new StringEditingSupport(Named.class,""String_Node_Str""){
    @Override public boolean canEdit(    Object element){
      boolean isCategory=((Element)element).isCategory();
      boolean isUnassignedCategory=isCategory && Classification.UNASSIGNED_ID.equals(((Element)element).getCategory().getClassification().getId());
      return !isUnassignedCategory ? super.canEdit(element) : false;
    }
  }
.setMandatory(true).addListener(new MarkDirtyListener(this.owner)));
  column.setSorter(null);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnTicker,SWT.None,60);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      return element.isSecurity() ? element.getSecurity().getTickerSymbol() : null;
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnWKN,SWT.None,60);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      return element.isSecurity() ? element.getSecurity().getWkn() : null;
    }
  }
);
  column.setVisible(false);
  support.addColumn(column);
  column=new IsinColumn(""String_Node_Str"");
  column.getEditingSupport().addListener(new MarkDirtyListener(this.owner));
  column.setSorter(null);
  column.setVisible(false);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnQuote,SWT.RIGHT,60);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      return element.isSecurity() ? Values.Quote.format(element.getSecurityPosition().getPrice().getValue()) : null;
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnMarketValue,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      return Values.Amount.format(element.getValuation());
    }
    @Override public Font getFont(    Object e){
      return ((Element)e).isGroupByTaxonomy() || ((Element)e).isCategory() ? boldFont : null;
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnShareInPercent,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      if (element.isGroupByTaxonomy())       return Values.Percent.format(1d);
      if (element.isCategory())       return Values.Percent.format(element.getCategory().getShare());
 else       return Values.Percent.format(element.getPosition().getShare());
    }
    @Override public Font getFont(    Object e){
      return ((Element)e).isGroupByTaxonomy() || ((Element)e).isCategory() ? boldFont : null;
    }
  }
);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnPurchasePrice,SWT.RIGHT,60);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      if (element.isSecurity()) {
        long purchasePrice=element.getSecurityPosition().getFIFOPurchasePrice();
        return purchasePrice == 0 ? null : Values.Amount.format(purchasePrice);
      }
      return null;
    }
  }
);
  column.setVisible(false);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnPurchaseValue,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      long purchaseValue=element.getFIFOPurchaseValue();
      return purchaseValue == 0 ? null : Values.Amount.format(purchaseValue);
    }
    @Override public Font getFont(    Object e){
      return ((Element)e).isGroupByTaxonomy() || ((Element)e).isCategory() ? boldFont : null;
    }
  }
);
  column.setVisible(false);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnProfitLoss,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      Element element=(Element)e;
      long profitLoss=element.getProfitLoss();
      return profitLoss == 0 ? null : Values.Amount.format(profitLoss);
    }
    @Override public Color getForeground(    Object e){
      Element element=(Element)e;
      long profitLoss=element.getProfitLoss();
      if (profitLoss < 0)       return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_RED);
 else       if (profitLoss > 0)       return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_GREEN);
 else       return null;
    }
    @Override public Font getFont(    Object e){
      return ((Element)e).isGroupByTaxonomy() || ((Element)e).isCategory() ? boldFont : null;
    }
  }
);
  column.setVisible(false);
  support.addColumn(column);
  column=new NoteColumn();
  column.getEditingSupport().addListener(new MarkDirtyListener(this.owner));
  column.setSorter(null);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnIRRPerformance,SWT.RIGHT,80);
  column.setOptions(Messages.LabelReportingYears,Messages.ColumnIRRPerformanceOption,1,2,3,4,5,10);
  column.setLabelProvider(new OptionLabelProvider(){
    @Override public String getText(    Object e,    Integer option){
      Element element=(Element)e;
      if (element.isSecurity()) {
        calculatePerformance(element,option);
        SecurityPerformanceRecord record=element.getPerformance(option);
        return Values.Percent.format(record.getIrr());
      }
      return null;
    }
    @Override public Color getForeground(    Object e,    Integer option){
      Element element=(Element)e;
      if (element.isSecurity()) {
        calculatePerformance(element,option);
        SecurityPerformanceRecord record=element.getPerformance(option);
        double irr=record.getIrr();
        if (irr < 0)         return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_RED);
 else         if (irr > 0)         return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_GREEN);
      }
      return null;
    }
  }
);
  column.setVisible(false);
  support.addColumn(column);
  column=new Column(""String_Node_Str"",Messages.ColumnTotalProfitLoss,SWT.RIGHT,80);
  column.setOptions(Messages.LabelReportingYears,Messages.ColumnTotalProfitLossOption,1,2,3,4,5,10);
  column.setLabelProvider(new OptionLabelProvider(){
    @Override public String getText(    Object e,    Integer option){
      Element element=(Element)e;
      if (element.isSecurity()) {
        calculatePerformance(element,option);
        SecurityPerformanceRecord record=element.getPerformance(option);
        return Values.Amount.format(record.getDelta());
      }
      return null;
    }
    @Override public Color getForeground(    Object e,    Integer option){
      Element element=(Element)e;
      if (element.isSecurity()) {
        calculatePerformance(element,option);
        SecurityPerformanceRecord record=element.getPerformance(option);
        long delta=record.getDelta();
        if (delta < 0)         return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_RED);
 else         if (delta > 0)         return Display.getCurrent().getSystemColor(SWT.COLOR_DARK_GREEN);
      }
      return null;
    }
  }
);
  column.setVisible(false);
  support.addColumn(column);
  addTaxonomyColumns();
  addAttributeColumns();
  support.createColumns();
  assets.getTable().setHeaderVisible(true);
  assets.getTable().setLinesVisible(true);
  assets.setContentProvider(new StatementOfAssetsContentProvider());
  ViewerHelper.pack(assets);
  assets.addDragSupport(DND.DROP_MOVE,new Transfer[]{SecurityTransfer.getTransfer()},new SecurityDragListener(assets));
  LocalResourceManager resources=new LocalResourceManager(JFaceResources.getResources(),assets.getTable());
  boldFont=resources.createFont(FontDescriptor.createFrom(assets.getTable().getFont()).setStyle(SWT.BOLD));
}",0.9984967083095744
52763,"public void run(){
  markDirty();
  if (view != null)   view.notifyModelUpdated();
}","public void run(){
  markDirty();
  if (view != null && view.getControl() != null && !view.getControl().isDisposed())   view.notifyModelUpdated();
}",0.7241379310344828
52764,"@PreDestroy public void destroy(MPart part){
  if (clientFile != null)   storePreferences();
}","@PreDestroy public void destroy(MPart part){
  if (clientFile != null)   storePreferences();
  if (regularQuoteUpdateJob != null)   regularQuoteUpdateJob.cancel();
}",0.7258687258687259
52765,"private void scheduleOnlineUpdateJobs(){
  if (!""String_Node_Str"".equals(System.getProperty(""String_Node_Str""))) {
    new UpdateQuotesJob(client,false,1000 * 60 * 10){
      @Override protected void notifyFinished(){
        notifyModelUpdated();
      }
    }
.schedule(500);
    new UpdateQuotesJob(client){
      @Override protected void notifyFinished(){
        notifyModelUpdated();
      }
    }
.schedule(1000);
    new UpdateCPIJob(client){
      @Override protected void notifyFinished(){
        notifyModelUpdated();
      }
    }
.schedule(700);
  }
}","private void scheduleOnlineUpdateJobs(){
  if (!""String_Node_Str"".equals(System.getProperty(""String_Node_Str""))) {
    regularQuoteUpdateJob=new UpdateQuotesJob(client,false,1000 * 60 * 10){
      @Override protected void notifyFinished(){
        notifyModelUpdated();
      }
    }
;
    regularQuoteUpdateJob.schedule(500);
    new UpdateQuotesJob(client){
      @Override protected void notifyFinished(){
        notifyModelUpdated();
      }
    }
.schedule(1000);
    new UpdateCPIJob(client){
      @Override protected void notifyFinished(){
        notifyModelUpdated();
      }
    }
.schedule(700);
  }
}",0.9584393553859204
52766,"public void notifyModelUpdated(){
  Display.getDefault().asyncExec(new Runnable(){
    public void run(){
      markDirty();
      if (view != null)       view.notifyModelUpdated();
    }
  }
);
}","public void notifyModelUpdated(){
  Display.getDefault().asyncExec(new Runnable(){
    public void run(){
      markDirty();
      if (view != null && view.getControl() != null && !view.getControl().isDisposed())       view.notifyModelUpdated();
    }
  }
);
}",0.8596491228070176
52767,"protected long asQuote(Element value) throws ParseException {
  String text=value.text();
  double quote=decimalFormat.parse(text).doubleValue();
  return Math.round(quote * 100);
}","protected long asQuote(Element value) throws ParseException {
  String text=value.text();
  double quote=DECIMAL_FORMAT.get().parse(text).doubleValue();
  return Math.round(quote * 100);
}",0.9214092140921408
52768,"@Execute public void execute(@Named(IServiceConstants.ACTIVE_SHELL) Shell shell){
  try {
    new ProgressMonitorDialog(shell).run(true,true,new IRunnableWithProgress(){
      @Override public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        try {
          UpdateHelper updateHelper=new UpdateHelper();
          updateHelper.runUpdate(monitor,false);
        }
 catch (        CoreException e) {
          throw new InvocationTargetException(e);
        }
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    PortfolioPlugin.log(e.getCause());
    IStatus status=e.getCause() instanceof CoreException ? ((CoreException)e.getCause()).getStatus() : new Status(Status.ERROR,PortfolioPlugin.PLUGIN_ID,e.getCause().getMessage(),e.getCause());
    ErrorDialog.openError(Display.getDefault().getActiveShell(),Messages.LabelError,e.getCause().getMessage(),status);
  }
catch (  InterruptedException ignore) {
  }
}","@Execute public void execute(@Named(IServiceConstants.ACTIVE_SHELL) Shell shell){
  try {
    new ProgressMonitorDialog(shell).run(true,true,new IRunnableWithProgress(){
      @Override public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        try {
          UpdateHelper updateHelper=new UpdateHelper();
          updateHelper.runUpdate(monitor,false);
        }
 catch (        CoreException e) {
          throw new InvocationTargetException(e);
        }
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    PortfolioPlugin.log(e.getCause());
    IStatus status=e.getCause() instanceof CoreException ? ((CoreException)e.getCause()).getStatus() : new Status(Status.ERROR,PortfolioPlugin.PLUGIN_ID,e.getCause().getMessage(),e.getCause());
    ErrorDialog.openError(Display.getDefault().getActiveShell(),Messages.LabelError,Messages.MsgErrorUpdating,status);
  }
catch (  InterruptedException ignore) {
  }
}",0.98159509202454
52769,"public Object execute(ExecutionEvent event) throws ExecutionException {
  try {
    new ProgressMonitorDialog(null).run(true,true,new IRunnableWithProgress(){
      @Override public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        try {
          UpdateHelper updateHelper=new UpdateHelper();
          updateHelper.runUpdate(monitor,false);
        }
 catch (        CoreException e) {
          throw new InvocationTargetException(e);
        }
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    PortfolioPlugin.log(e.getCause());
    IStatus status=e.getCause() instanceof CoreException ? ((CoreException)e.getCause()).getStatus() : new Status(Status.ERROR,PortfolioPlugin.PLUGIN_ID,e.getCause().getMessage(),e.getCause());
    ErrorDialog.openError(Display.getDefault().getActiveShell(),Messages.LabelError,e.getCause().getMessage(),status);
    return false;
  }
catch (  InterruptedException e) {
    return false;
  }
  return true;
}","public Object execute(ExecutionEvent event) throws ExecutionException {
  try {
    new ProgressMonitorDialog(null).run(true,true,new IRunnableWithProgress(){
      @Override public void run(      IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
        try {
          UpdateHelper updateHelper=new UpdateHelper();
          updateHelper.runUpdate(monitor,false);
        }
 catch (        CoreException e) {
          throw new InvocationTargetException(e);
        }
      }
    }
);
  }
 catch (  InvocationTargetException e) {
    PortfolioPlugin.log(e.getCause());
    IStatus status=e.getCause() instanceof CoreException ? ((CoreException)e.getCause()).getStatus() : new Status(Status.ERROR,PortfolioPlugin.PLUGIN_ID,e.getCause().getMessage(),e.getCause());
    ErrorDialog.openError(Display.getDefault().getActiveShell(),Messages.LabelError,Messages.MsgErrorUpdating,status);
    return false;
  }
catch (  InterruptedException e) {
    return false;
  }
  return true;
}",0.9822309970384996
52770,"static public long amountFractionPerShare(long amount,long shares){
  if (shares == 0)   return 0;
  return Math.round((double)(amount * (Values.AmountFraction.factor() / Values.Amount.factor()) * Values.Share.divider()) / (double)shares);
}","static long amountFractionPerShare(long amount,long shares){
  if (shares == 0)   return 0;
  return Math.round((double)(amount * (Values.AmountFraction.factor() / Values.Amount.factor()) * Values.Share.divider()) / (double)shares);
}",0.9852631578947368
52771,"private static void extractSecurityRelatedAccountTransactions(Account account,Date startDate,Date endDate,Map<Security,SecurityPerformanceRecord> records){
  for (  AccountTransaction t : account.getTransactions()) {
    if (t.getDate().getTime() > startDate.getTime() && t.getDate().getTime() <= endDate.getTime()) {
switch (t.getType()) {
case INTEREST:
case DIVIDENDS:
        if (t.getSecurity() != null) {
          DividendTransaction dt=new DividendTransaction();
          dt.setDate(t.getDate());
          dt.setSecurity(t.getSecurity());
          dt.setAccount(account);
          dt.setAmount(t.getAmount());
          dt.setShares(t.getShares());
          dt.setNote(t.getNote());
          records.get(t.getSecurity()).addTransaction(dt);
        }
      break;
case FEES:
case TAXES:
case DEPOSIT:
case REMOVAL:
case BUY:
case SELL:
case TRANSFER_IN:
case TRANSFER_OUT:
    break;
default :
  throw new UnsupportedOperationException();
}
}
}
}","private static void extractSecurityRelatedAccountTransactions(Account account,Date startDate,Date endDate,Map<Security,SecurityPerformanceRecord> records){
  for (  AccountTransaction t : account.getTransactions()) {
    if (t.getSecurity() == null)     continue;
    if (t.getType() != AccountTransaction.Type.DIVIDENDS && t.getType() != AccountTransaction.Type.INTEREST)     continue;
    if (t.getDate().getTime() <= startDate.getTime())     continue;
    if (t.getDate().getTime() > endDate.getTime())     continue;
    DividendTransaction dt=new DividendTransaction();
    dt.setDate(t.getDate());
    dt.setSecurity(t.getSecurity());
    dt.setAccount(account);
    dt.setAmount(t.getAmount());
    dt.setShares(t.getShares());
    dt.setNote(t.getNote());
    records.get(t.getSecurity()).addTransaction(dt);
  }
}",0.5143177989893318
52772,"private static SecurityPerformanceSnapshot doCreateSnapshot(Map<Security,SecurityPerformanceRecord> records,ReportingPeriod period){
  List<SecurityPerformanceRecord> list=new ArrayList<SecurityPerformanceRecord>(records.values());
  for (Iterator<SecurityPerformanceRecord> iter=list.iterator(); iter.hasNext(); ) {
    SecurityPerformanceRecord record=iter.next();
    if (record.getTransactions().isEmpty()) {
      iter.remove();
    }
 else {
      record.calculate(client,period);
    }
  }
  return new SecurityPerformanceSnapshot(list);
}","private static SecurityPerformanceSnapshot doCreateSnapshot(Client client,Map<Security,SecurityPerformanceRecord> records,ReportingPeriod period){
  List<SecurityPerformanceRecord> list=new ArrayList<SecurityPerformanceRecord>(records.values());
  for (Iterator<SecurityPerformanceRecord> iter=list.iterator(); iter.hasNext(); ) {
    SecurityPerformanceRecord record=iter.next();
    if (record.getTransactions().isEmpty()) {
      iter.remove();
    }
 else {
      record.calculate(client,period);
    }
  }
  return new SecurityPerformanceSnapshot(list);
}",0.9873417721518988
52773,"public static SecurityPerformanceSnapshot create(Client client,Portfolio portfolio,ReportingPeriod period){
  Map<Security,SecurityPerformanceRecord> transactions=initRecords(client);
  Date startDate=period.getStartDate();
  Date endDate=period.getEndDate();
  if (portfolio.getReferenceAccount() != null)   extractSecurityRelatedAccountTransactions(portfolio.getReferenceAccount(),startDate,endDate,transactions);
  extractSecurityRelatedPortfolioTransactions(portfolio,startDate,endDate,transactions);
  addPseudoValuationTansactions(portfolio,startDate,endDate,transactions);
  return doCreateSnapshot(transactions,period);
}","public static SecurityPerformanceSnapshot create(Client client,Portfolio portfolio,ReportingPeriod period){
  Map<Security,SecurityPerformanceRecord> transactions=initRecords(client);
  Date startDate=period.getStartDate();
  Date endDate=period.getEndDate();
  if (portfolio.getReferenceAccount() != null)   extractSecurityRelatedAccountTransactions(portfolio.getReferenceAccount(),startDate,endDate,transactions);
  extractSecurityRelatedPortfolioTransactions(portfolio,startDate,endDate,transactions);
  addPseudoValuationTansactions(portfolio,startDate,endDate,transactions);
  return doCreateSnapshot(client,transactions,period);
}",0.9944664031620554
52774,"public void addMarkerLine(Date date,RGB color,String label){
  this.markerLines.add(new MarkerLine(date,color,label));
  Collections.sort(this.markerLines);
}","public void addMarkerLine(Date date,RGB color,String label){
  this.markerLines.add(new MarkerLine(date,color,label));
  Collections.sort(this.markerLines,new Comparator<MarkerLine>(){
    @Override public int compare(    MarkerLine ml1,    MarkerLine ml2){
      return ml1.date.compareTo(ml2.date);
    }
  }
);
}",0.6680761099365751
52775,"@Override protected void createTopTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  accounts=new TableViewer(container,SWT.FULL_SELECTION);
  ShowHideColumnHelper support=new ShowHideColumnHelper(AccountListView.class.getSimpleName() + ""String_Node_Str"",accounts,layout);
  Column column=new Column(Messages.ColumnAccount,SWT.None,150);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      return ((Account)e).getName();
    }
    @Override public Image getImage(    Object element){
      return PortfolioPlugin.image(PortfolioPlugin.IMG_ACCOUNT);
    }
    @Override public Color getForeground(    Object e){
      boolean isRetired=((Account)e).isRetired();
      return isRetired ? Display.getDefault().getSystemColor(SWT.COLOR_DARK_GRAY) : null;
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Account.class,""String_Node_Str""),SWT.DOWN);
  column.setMoveable(false);
  support.addColumn(column);
  column=new Column(Messages.ColumnBalance,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      return Values.Amount.format(((Account)e).getCurrentAmount());
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Account.class,""String_Node_Str""));
  column.setMoveable(false);
  support.addColumn(column);
  support.createColumns();
  accounts.getTable().setHeaderVisible(true);
  accounts.getTable().setLinesVisible(true);
  for (  Account account : getClient().getAccounts()) {
    Collections.sort(account.getTransactions());
  }
  accounts.setContentProvider(new SimpleListContentProvider());
  resetInput();
  accounts.refresh();
  ViewerHelper.pack(accounts);
  accounts.addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      Account account=(Account)((IStructuredSelection)event.getSelection()).getFirstElement();
      transactions.setData(Account.class.toString(),account);
      transactions.setInput(account != null ? account.getTransactions() : new ArrayList<AccountTransaction>(0));
      transactions.refresh();
    }
  }
);
  new CellEditorFactory(accounts,Account.class).notify(new CellEditorFactory.ModificationListener(){
    public void onModified(    Object element,    String property){
      markDirty();
      accounts.refresh(transactions.getData(Account.class.toString()));
    }
  }
).editable(""String_Node_Str"").readonly(""String_Node_Str"").apply();
  hookContextMenu(accounts.getTable(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillAccountsContextMenu(manager);
    }
  }
);
}","@Override protected void createTopTable(Composite parent){
  Composite container=new Composite(parent,SWT.NONE);
  TableColumnLayout layout=new TableColumnLayout();
  container.setLayout(layout);
  accounts=new TableViewer(container,SWT.FULL_SELECTION);
  ShowHideColumnHelper support=new ShowHideColumnHelper(AccountListView.class.getSimpleName() + ""String_Node_Str"",accounts,layout);
  Column column=new Column(Messages.ColumnAccount,SWT.None,150);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      return ((Account)e).getName();
    }
    @Override public Image getImage(    Object element){
      return PortfolioPlugin.image(PortfolioPlugin.IMG_ACCOUNT);
    }
    @Override public Color getForeground(    Object e){
      boolean isRetired=((Account)e).isRetired();
      return isRetired ? Display.getDefault().getSystemColor(SWT.COLOR_DARK_GRAY) : null;
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Account.class,""String_Node_Str""),SWT.DOWN);
  column.setMoveable(false);
  support.addColumn(column);
  column=new Column(Messages.ColumnBalance,SWT.RIGHT,80);
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object e){
      return Values.Amount.format(((Account)e).getCurrentAmount());
    }
  }
);
  column.setSorter(ColumnViewerSorter.create(Account.class,""String_Node_Str""));
  column.setMoveable(false);
  support.addColumn(column);
  support.createColumns();
  accounts.getTable().setHeaderVisible(true);
  accounts.getTable().setLinesVisible(true);
  for (  Account account : getClient().getAccounts()) {
    Collections.sort(account.getTransactions(),new Transaction.ByDate());
  }
  accounts.setContentProvider(new SimpleListContentProvider());
  resetInput();
  accounts.refresh();
  ViewerHelper.pack(accounts);
  accounts.addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      Account account=(Account)((IStructuredSelection)event.getSelection()).getFirstElement();
      transactions.setData(Account.class.toString(),account);
      transactions.setInput(account != null ? account.getTransactions() : new ArrayList<AccountTransaction>(0));
      transactions.refresh();
    }
  }
);
  new CellEditorFactory(accounts,Account.class).notify(new CellEditorFactory.ModificationListener(){
    public void onModified(    Object element,    String property){
      markDirty();
      accounts.refresh(transactions.getData(Account.class.toString()));
    }
  }
).editable(""String_Node_Str"").readonly(""String_Node_Str"").apply();
  hookContextMenu(accounts.getTable(),new IMenuListener(){
    public void menuAboutToShow(    IMenuManager manager){
      fillAccountsContextMenu(manager);
    }
  }
);
}",0.9955301269443948
52776,"private void refreshChart(){
  for (  ISeries s : chart.getSeriesSet().getSeries())   chart.getSeriesSet().deleteSeries(s.getId());
  if (getClient().getConsumerPriceIndeces() == null || getClient().getConsumerPriceIndeces().isEmpty())   return;
  List<ConsumerPriceIndex> indeces=new ArrayList<ConsumerPriceIndex>(getClient().getConsumerPriceIndeces());
  Collections.sort(indeces);
  Date[] dates=new Date[indeces.size()];
  double[] cpis=new double[indeces.size()];
  int ii=0;
  for (  ConsumerPriceIndex index : indeces) {
    dates[ii]=Dates.date(index.getYear(),index.getMonth(),1);
    cpis[ii]=(double)index.getIndex() / Values.Index.divider();
    ii++;
  }
  chart.addDateSeries(dates,cpis,Colors.CPI,Messages.LabelConsumerPriceIndex);
  chart.getAxisSet().adjustRange();
  chart.redraw();
}","private void refreshChart(){
  for (  ISeries s : chart.getSeriesSet().getSeries())   chart.getSeriesSet().deleteSeries(s.getId());
  if (getClient().getConsumerPriceIndeces() == null || getClient().getConsumerPriceIndeces().isEmpty())   return;
  List<ConsumerPriceIndex> indeces=new ArrayList<ConsumerPriceIndex>(getClient().getConsumerPriceIndeces());
  Collections.sort(indeces,new ConsumerPriceIndex.ByDate());
  Date[] dates=new Date[indeces.size()];
  double[] cpis=new double[indeces.size()];
  int ii=0;
  for (  ConsumerPriceIndex index : indeces) {
    dates[ii]=Dates.date(index.getYear(),index.getMonth(),1);
    cpis[ii]=(double)index.getIndex() / Values.Index.divider();
    ii++;
  }
  chart.addDateSeries(dates,cpis,Colors.CPI,Messages.LabelConsumerPriceIndex);
  chart.getAxisSet().adjustRange();
  chart.redraw();
}",0.980440097799511
52777,"@Override protected Control createBody(Composite parent){
  canvas=new PieChart(parent,SWT.NONE);
  ClientSnapshot snapshot=ClientSnapshot.create(getClient(),Dates.today());
  List<PieChart.Slice> slices=new ArrayList<PieChart.Slice>();
  for (  AccountSnapshot a : snapshot.getAccounts())   slices.add(new PieChart.Slice(a.getFunds(),a.getAccount().getName(),null));
  for (  SecurityPosition position : snapshot.getJointPortfolio().getPositions())   slices.add(new PieChart.Slice(position.calculateValue(),position.getSecurity().getName(),null));
  Collections.sort(slices);
  ColorWheel colors=new ColorWheel(canvas,slices.size());
  for (int ii=0; ii < slices.size(); ii++)   slices.get(ii).setColor(colors.getSegment(ii).getColor());
  canvas.setSlices(slices);
  canvas.redraw();
  return canvas;
}","@Override protected Control createBody(Composite parent){
  canvas=new PieChart(parent,SWT.NONE);
  ClientSnapshot snapshot=ClientSnapshot.create(getClient(),Dates.today());
  List<PieChart.Slice> slices=new ArrayList<PieChart.Slice>();
  for (  AccountSnapshot a : snapshot.getAccounts())   slices.add(new PieChart.Slice(a.getFunds(),a.getAccount().getName(),null));
  for (  SecurityPosition position : snapshot.getJointPortfolio().getPositions())   slices.add(new PieChart.Slice(position.calculateValue(),position.getSecurity().getName(),null));
  Collections.sort(slices,new Slice.ByValue());
  ColorWheel colors=new ColorWheel(canvas,slices.size());
  for (int ii=0; ii < slices.size(); ii++)   slices.get(ii).setColor(colors.getSegment(ii).getColor());
  canvas.setSlices(slices);
  canvas.redraw();
  return canvas;
}",0.9877149877149876
52778,"private void addTaxonomyColumn(ShowHideColumnHelper support,final Taxonomy taxonomy){
  String name=taxonomy.getName();
  List<String> labels=taxonomy.getDimensions();
  List<Integer> options=new ArrayList<Integer>();
  StringBuilder menuLabels=new StringBuilder(""String_Node_Str"");
  StringBuilder columnLabels=new StringBuilder(""String_Node_Str"");
  int heigth=taxonomy.getHeigth();
  for (int ii=1; ii < heigth; ii++) {
    options.add(ii);
    if (ii > 1) {
      menuLabels.append('|');
      columnLabels.append('|');
    }
    String label=null;
    if (labels != null && ii <= labels.size())     label=labels.get(ii - 1);
    menuLabels.append(ii).append('#');
    columnLabels.append(ii).append('#');
    if (label != null) {
      menuLabels.append(label);
      columnLabels.append(label);
    }
 else {
      menuLabels.append(MessageFormat.format(Messages.LabelLevelNumber,ii));
      columnLabels.append(MessageFormat.format(Messages.LabelLevelNameNumber,name,ii));
    }
  }
  options.add(100);
  menuLabels.append(""String_Node_Str"" + Messages.LabelFullClassification + ""String_Node_Str"");
  columnLabels.append(""String_Node_Str"").append(name).append(""String_Node_Str"");
  Column column=new Column(taxonomy.getId(),name,SWT.LEFT,120);
  column.setOptions(menuLabels.toString(),columnLabels.toString(),options.toArray(new Integer[0]));
  column.setLabelProvider(new OptionLabelProvider(){
    @Override public String getText(    Object e,    Integer option){
      Security security=(Security)e;
      List<Classification> classifications=taxonomy.getClassifications(security);
      if (classifications.isEmpty())       return null;
      StringBuilder answer=new StringBuilder();
      for (      Classification c : classifications) {
        if (answer.length() > 0)         answer.append(""String_Node_Str"");
switch (option) {
case 100:
          answer.append(c.getPathName(false));
        break;
default :
      List<Classification> path=c.getPathToRoot();
    if (option < path.size())     answer.append(path.get(option).getName());
}
}
return answer.toString();
}
}
);
column.setVisible(false);
support.addColumn(column);
}","private void addTaxonomyColumn(ShowHideColumnHelper support,final Taxonomy taxonomy){
  String name=taxonomy.getName();
  List<String> labels=taxonomy.getDimensions();
  List<Integer> options=new ArrayList<Integer>();
  StringBuilder menuLabels=new StringBuilder(""String_Node_Str"");
  StringBuilder columnLabels=new StringBuilder(""String_Node_Str"");
  int heigth=taxonomy.getHeigth();
  for (int ii=1; ii < heigth; ii++) {
    options.add(ii);
    if (ii > 1) {
      menuLabels.append('|');
      columnLabels.append('|');
    }
    String label=null;
    if (labels != null && ii <= labels.size())     label=labels.get(ii - 1);
    menuLabels.append(ii).append('#');
    columnLabels.append(ii).append('#');
    if (label != null) {
      menuLabels.append(label);
      columnLabels.append(label);
    }
 else {
      menuLabels.append(MessageFormat.format(Messages.LabelLevelNumber,ii));
      columnLabels.append(MessageFormat.format(Messages.LabelLevelNameNumber,name,ii));
    }
  }
  options.add(100);
  menuLabels.append(""String_Node_Str"" + Messages.LabelFullClassification + ""String_Node_Str"");
  columnLabels.append(""String_Node_Str"").append(name).append(""String_Node_Str"");
  Column column=new Column(taxonomy.getId(),name,SWT.LEFT,120);
  column.setOptions(menuLabels.toString(),columnLabels.toString(),options.toArray(new Integer[0]));
  column.setLabelProvider(new OptionLabelProvider(){
    @Override public String getText(    Object e,    Integer option){
      Security security=(Security)e;
      List<Classification> classifications=taxonomy.getClassifications(security);
      if (classifications.isEmpty())       return null;
      StringBuilder answer=new StringBuilder();
      for (      Classification c : classifications) {
        if (answer.length() > 0)         answer.append(""String_Node_Str"");
        if (option == 100) {
          answer.append(c.getPathName(false));
        }
 else {
          List<Classification> path=c.getPathToRoot();
          if (option < path.size())           answer.append(path.get(option).getName());
        }
      }
      return answer.toString();
    }
  }
);
  column.setVisible(false);
  support.addColumn(column);
}",0.9722863741339492
52779,"private void updatePieSlices(){
  List<PieChart.Slice> slices=new ArrayList<PieChart.Slice>();
  for (  TaxonomyNode child : getModel().getRootNode().getChildren()) {
    slices.add(new PieChart.Slice(child.getActual(),child.getName(),getRenderer().getColorFor(child)));
  }
  Collections.sort(slices);
  pieChart.setSlices(slices);
  pieChart.redraw();
}","private void updatePieSlices(){
  List<PieChart.Slice> slices=new ArrayList<PieChart.Slice>();
  for (  TaxonomyNode child : getModel().getRootNode().getChildren()) {
    slices.add(new PieChart.Slice(child.getActual(),child.getName(),getRenderer().getColorFor(child)));
  }
  Collections.sort(slices,new Slice.ByValue());
  pieChart.setSlices(slices);
  pieChart.redraw();
}",0.9726027397260274
52780,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public Object[] getElements(Object inputElement){
  if (mapFormat == null)   return new Object[0];
  Entry<?>[] elements=new Entry[mapFormat.map().size()];
  int ii=0;
  for (  Enum<?> entry : mapFormat.map().keySet())   elements[ii++]=new Entry(mapFormat.map(),entry);
  Arrays.sort(elements);
  return elements;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public Object[] getElements(Object inputElement){
  if (mapFormat == null)   return new Object[0];
  List<Entry<?>> elements=new ArrayList<Entry<?>>();
  for (  Enum<?> entry : mapFormat.map().keySet())   elements.add(new Entry(mapFormat.map(),entry));
  Collections.sort(elements,new Comparator<Entry<?>>(){
    @Override public int compare(    Entry<?> e1,    Entry<?> e2){
      return e1.key.name().compareTo(e2.key.name());
    }
  }
);
  return elements.toArray();
}",0.495114006514658
52781,"private void collectAccountTransactions(){
  for (  Account account : client.getAccounts()) {
    for (    AccountTransaction t : account.getTransactions()) {
      if (t.getCrossEntry() != null)       continue;
switch (t.getType()) {
case BUY:
case SELL:
case TRANSFER_IN:
case TRANSFER_OUT:
        accountTransactions.add(new AccountEntry(account,t));
      break;
default :
  }
}
}
}","private void collectAccountTransactions(){
  for (  Account account : client.getAccounts()) {
    for (    AccountTransaction t : account.getTransactions()) {
      if (t.getCrossEntry() != null)       continue;
switch (t.getType()) {
case BUY:
case SELL:
case TRANSFER_IN:
case TRANSFER_OUT:
        accountTransactions.add(new AccountEntry(account,t));
      break;
default :
    break;
}
}
}
}",0.9885057471264368
52782,"private void collectPortfolioTransactions(){
  for (  Portfolio portfolio : client.getPortfolios()) {
    for (    PortfolioTransaction t : portfolio.getTransactions()) {
      if (t.getCrossEntry() != null)       continue;
switch (t.getType()) {
case BUY:
case SELL:
case TRANSFER_IN:
case TRANSFER_OUT:
        portfolioTransactions.add(new PortfolioEntry(portfolio,t));
      break;
default :
  }
}
}
}","private void collectPortfolioTransactions(){
  for (  Portfolio portfolio : client.getPortfolios()) {
    for (    PortfolioTransaction t : portfolio.getTransactions()) {
      if (t.getCrossEntry() != null)       continue;
switch (t.getType()) {
case BUY:
case SELL:
case TRANSFER_IN:
case TRANSFER_OUT:
        portfolioTransactions.add(new PortfolioEntry(portfolio,t));
      break;
default :
    break;
}
}
}
}",0.989010989010989
52783,"public void setConsumerPriceIndeces(List<ConsumerPriceIndex> prices){
  this.consumerPriceIndeces=prices;
  Collections.sort(this.consumerPriceIndeces);
}","public void setConsumerPriceIndeces(List<ConsumerPriceIndex> prices){
  this.consumerPriceIndeces=prices;
  Collections.sort(this.consumerPriceIndeces,new ConsumerPriceIndex.ByDate());
}",0.9058823529411764
52784,"private static void assignSharesToDividendTransactions(Client client){
  for (  Security security : client.getSecurities()) {
    List<Transaction> transactions=security.getTransactions(client);
    Transaction.sortByDate(transactions);
    long shares=0;
    for (    Transaction t : transactions) {
      if (t instanceof AccountTransaction && ((AccountTransaction)t).getType() == AccountTransaction.Type.DIVIDENDS) {
        ((AccountTransaction)t).setShares(shares);
      }
 else       if (t instanceof PortfolioTransaction) {
switch (((PortfolioTransaction)t).getType()) {
case BUY:
case TRANSFER_IN:
          shares+=((PortfolioTransaction)t).getShares();
        break;
case SELL:
case TRANSFER_OUT:
      shares-=((PortfolioTransaction)t).getShares();
    break;
default :
}
}
}
}
}","private static void assignSharesToDividendTransactions(Client client){
  for (  Security security : client.getSecurities()) {
    List<Transaction> transactions=security.getTransactions(client);
    Transaction.sortByDate(transactions);
    long shares=0;
    for (    Transaction t : transactions) {
      if (t instanceof AccountTransaction && ((AccountTransaction)t).getType() == AccountTransaction.Type.DIVIDENDS) {
        ((AccountTransaction)t).setShares(shares);
      }
 else       if (t instanceof PortfolioTransaction) {
switch (((PortfolioTransaction)t).getType()) {
case BUY:
case TRANSFER_IN:
          shares+=((PortfolioTransaction)t).getShares();
        break;
case SELL:
case TRANSFER_OUT:
      shares-=((PortfolioTransaction)t).getShares();
    break;
default :
  break;
}
}
}
}
}",0.9943502824858758
52785,"public static final <E extends Transaction>List<E> sortByDate(List<E> transactions){
  Collections.sort(transactions,new ByDateComparator());
  return transactions;
}","public static final <E extends Transaction>List<E> sortByDate(List<E> transactions){
  Collections.sort(transactions,new ByDate());
  return transactions;
}",0.968944099378882
52786,"private boolean text(Text text) throws IOException {
  if (!insideColumn)   return true;
  String t=text.getText().trim();
  if (t.length() == 0)   t=null;
switch (columnIndex) {
case 0:
    item.setTime(parseDate(t));
  break;
case 1:
if (hasOnlyClosingQuote) item.setValue(parsePrice(t));
case 2:
if (!hasOnlyClosingQuote) item.setLow(parsePrice(t));
break;
case 3:
if (!hasOnlyClosingQuote) item.setHigh(parsePrice(t));
break;
case 4:
if (!hasOnlyClosingQuote) item.setValue(parsePrice(t));
break;
default :
}
return true;
}","private boolean text(Text text) throws IOException {
  if (!insideColumn)   return true;
  String t=text.getText().trim();
  if (t.length() == 0)   t=null;
switch (columnIndex) {
case 0:
    item.setTime(parseDate(t));
  break;
case 1:
if (hasOnlyClosingQuote) item.setValue(parsePrice(t));
break;
case 2:
if (!hasOnlyClosingQuote) item.setLow(parsePrice(t));
break;
case 3:
if (!hasOnlyClosingQuote) item.setHigh(parsePrice(t));
break;
case 4:
if (!hasOnlyClosingQuote) item.setValue(parsePrice(t));
break;
default :
break;
}
return true;
}",0.9868913857677902
52787,"public boolean text(Text text) throws IOException {
  if (!insideColumn)   return true;
  String t=text.getText().trim();
  if (t.length() == 0)   t=null;
switch (columnIndex) {
case 0:
    item.setSymbol(t);
  break;
case 1:
item.setName(t);
break;
case 2:
item.setIsin(t);
break;
case 3:
if (!""String_Node_Str"".equals(t)) item.setLastTrade(parseIndex(t));
break;
case 4:
item.setType(t);
break;
case 5:
item.setExchange(t);
break;
default :
}
return true;
}","public boolean text(Text text) throws IOException {
  if (!insideColumn)   return true;
  String t=text.getText().trim();
  if (t.length() == 0)   t=null;
switch (columnIndex) {
case 0:
    item.setSymbol(t);
  break;
case 1:
item.setName(t);
break;
case 2:
item.setIsin(t);
break;
case 3:
if (!""String_Node_Str"".equals(t)) item.setLastTrade(parseIndex(t));
break;
case 4:
item.setType(t);
break;
case 5:
item.setExchange(t);
break;
default :
break;
}
return true;
}",0.9924324324324324
52788,"void calculate(PerformanceIndex clientIndex){
  DateTime firstDataPoint=clientIndex.getFirstDataPoint();
  Interval interval=firstDataPoint != null ? new Interval(firstDataPoint,clientIndex.getReportInterval().toInterval().getEnd()) : clientIndex.getReportInterval().toInterval();
  List<ConsumerPriceIndex> cpiSeries=new ArrayList<ConsumerPriceIndex>(clientIndex.getClient().getConsumerPriceIndeces());
  Collections.sort(cpiSeries);
  List<Date> dates=new ArrayList<Date>();
  List<Double> accumulated=new ArrayList<Double>();
  int baseline=-1;
  for (  ConsumerPriceIndex cpi : cpiSeries) {
    DateMidnight date=new DateMidnight(cpi.getYear(),cpi.getMonth() + 1,1).dayOfMonth().withMaximumValue();
    if (interval.contains(date)) {
      if (baseline == -1)       baseline=cpi.getIndex();
      dates.add(date.toDate());
      accumulated.add(((double)cpi.getIndex() / (double)baseline) - 1);
    }
  }
  this.dates=dates.toArray(new Date[0]);
  this.accumulated=new double[accumulated.size()];
  for (int ii=0; ii < this.accumulated.length; ii++)   this.accumulated[ii]=accumulated.get(ii);
}","void calculate(PerformanceIndex clientIndex){
  DateTime firstDataPoint=clientIndex.getFirstDataPoint();
  Interval interval=firstDataPoint != null ? new Interval(firstDataPoint,clientIndex.getReportInterval().toInterval().getEnd()) : clientIndex.getReportInterval().toInterval();
  List<ConsumerPriceIndex> cpiSeries=new ArrayList<ConsumerPriceIndex>(clientIndex.getClient().getConsumerPriceIndeces());
  Collections.sort(cpiSeries,new ConsumerPriceIndex.ByDate());
  List<Date> dates=new ArrayList<Date>();
  List<Double> accumulated=new ArrayList<Double>();
  int baseline=-1;
  for (  ConsumerPriceIndex cpi : cpiSeries) {
    DateMidnight date=new DateMidnight(cpi.getYear(),cpi.getMonth() + 1,1).dayOfMonth().withMaximumValue();
    if (interval.contains(date)) {
      if (baseline == -1)       baseline=cpi.getIndex();
      dates.add(date.toDate());
      accumulated.add(((double)cpi.getIndex() / (double)baseline) - 1);
    }
  }
  this.dates=dates.toArray(new Date[0]);
  this.accumulated=new double[accumulated.size()];
  for (int ii=0; ii < this.accumulated.length; ii++)   this.accumulated[ii]=accumulated.get(ii);
}",0.9856502242152466
52789,"public static ClientIRRYield create(Client client,ClientSnapshot snapshotStart,ClientSnapshot snapshotEnd){
  Date start=snapshotStart.getTime();
  Date end=snapshotEnd.getTime();
  List<Transaction> transactions=new ArrayList<Transaction>();
  collectAccountTransactions(client,start,end,transactions);
  collectPortfolioTransactions(client,start,end,transactions);
  Collections.sort(transactions);
  List<Date> dates=new ArrayList<Date>();
  List<Double> values=new ArrayList<Double>();
  collectDatesAndValues(start,end,snapshotStart,snapshotEnd,transactions,dates,values);
  double irr=IRR.calculate(dates,values);
  return new ClientIRRYield(snapshotStart,snapshotEnd,transactions,irr * 100);
}","public static ClientIRRYield create(Client client,ClientSnapshot snapshotStart,ClientSnapshot snapshotEnd){
  Date start=snapshotStart.getTime();
  Date end=snapshotEnd.getTime();
  List<Transaction> transactions=new ArrayList<Transaction>();
  collectAccountTransactions(client,start,end,transactions);
  collectPortfolioTransactions(client,start,end,transactions);
  Collections.sort(transactions,new Transaction.ByDate());
  List<Date> dates=new ArrayList<Date>();
  List<Double> values=new ArrayList<Double>();
  collectDatesAndValues(start,end,snapshotStart,snapshotEnd,transactions,dates,values);
  double irr=IRR.calculate(dates,values);
  return new ClientIRRYield(snapshotStart,snapshotEnd,transactions,irr * 100);
}",0.9824561403508772
52790,"private void onMouseHover(Event event){
  Date hoverDate=getHoverDate(event);
  if (tip != null && !tip.isDisposed())   tip.dispose();
  tip=new Shell(Display.getDefault().getActiveShell(),SWT.ON_TOP | SWT.TOOL);
  tip.setLayout(new FillLayout());
  final Composite container=new Composite(tip,SWT.NONE);
  GridLayoutFactory.swtDefaults().numColumns(2).applyTo(container);
  container.setForeground(tip.getDisplay().getSystemColor(SWT.COLOR_INFO_FOREGROUND));
  container.setBackground(tip.getDisplay().getSystemColor(SWT.COLOR_INFO_BACKGROUND));
  Label left=new Label(container,SWT.NONE);
  left.setText(Messages.ColumnDate);
  Label right=new Label(container,SWT.NONE);
  right.setText(String.format(dateFormat,hoverDate));
  for (  ISeries series : chart.getSeriesSet().getSeries()) {
    int line=Arrays.binarySearch(series.getXDateSeries(),hoverDate);
    if (line < 0)     continue;
    double value=series.getYSeries()[line];
    left=new Label(container,SWT.NONE);
    left.setText(series.getId());
    right=new Label(container,SWT.RIGHT);
    right.setText(String.format(""String_Node_Str"",value));
    GridDataFactory.fillDefaults().align(SWT.END,SWT.FILL).applyTo(right);
  }
  Point size=tip.computeSize(SWT.DEFAULT,SWT.DEFAULT);
  Point pt=chart.getPlotArea().toDisplay(event.x,event.y);
  tip.setBounds(pt.x,pt.y,size.x,size.y);
  tip.setVisible(true);
  container.addListener(SWT.FocusOut,new Listener(){
    @Override public void handleEvent(    Event event){
      closeToolTip();
    }
  }
);
  container.forceFocus();
}","private void onMouseHover(Event event){
  Date hoverDate=getHoverDate(event);
  if (tip != null && !tip.isDisposed())   tip.dispose();
  tip=new Shell(Display.getDefault().getActiveShell(),SWT.ON_TOP | SWT.TOOL);
  tip.setLayout(new FillLayout());
  final Composite container=new Composite(tip,SWT.NONE);
  container.setBackgroundMode(SWT.INHERIT_FORCE);
  GridLayoutFactory.swtDefaults().numColumns(2).applyTo(container);
  Color foregroundColor=tip.getDisplay().getSystemColor(SWT.COLOR_INFO_FOREGROUND);
  container.setForeground(foregroundColor);
  container.setBackground(tip.getDisplay().getSystemColor(SWT.COLOR_INFO_BACKGROUND));
  Label left=new Label(container,SWT.NONE);
  left.setForeground(foregroundColor);
  left.setText(Messages.ColumnDate);
  Label right=new Label(container,SWT.NONE);
  right.setForeground(foregroundColor);
  right.setText(String.format(dateFormat,hoverDate));
  for (  ISeries series : chart.getSeriesSet().getSeries()) {
    int line=Arrays.binarySearch(series.getXDateSeries(),hoverDate);
    if (line < 0)     continue;
    double value=series.getYSeries()[line];
    left=new Label(container,SWT.NONE);
    left.setForeground(foregroundColor);
    left.setText(series.getId());
    right=new Label(container,SWT.RIGHT);
    right.setForeground(foregroundColor);
    right.setText(String.format(""String_Node_Str"",value));
    GridDataFactory.fillDefaults().align(SWT.END,SWT.FILL).applyTo(right);
  }
  Point size=tip.computeSize(SWT.DEFAULT,SWT.DEFAULT);
  Point pt=chart.getPlotArea().toDisplay(event.x,event.y);
  tip.setBounds(pt.x,pt.y,size.x,size.y);
  tip.setVisible(true);
  container.addListener(SWT.FocusOut,new Listener(){
    @Override public void handleEvent(    Event event){
      closeToolTip();
    }
  }
);
  container.forceFocus();
}",0.9096367457220054
52791,"private Control createHeader(Composite parent){
  Composite header=new Composite(parent,SWT.NONE);
  header.setBackground(parent.getDisplay().getSystemColor(SWT.COLOR_WHITE));
  Font boldFont=resourceManager.createFont(FontDescriptor.createFrom(JFaceResources.getFont(JFaceResources.HEADER_FONT)).setStyle(SWT.BOLD));
  Label title=new Label(header,SWT.NONE);
  title.setText(getTitle());
  title.setFont(boldFont);
  title.setForeground(resourceManager.createColor(Colors.HEADINGS.swt()));
  title.setBackground(header.getBackground());
  ToolBar toolBar=new ToolBar(header,SWT.FLAT);
  toolBar.setBackground(header.getBackground());
  addButtons(toolBar);
  GridLayoutFactory.fillDefaults().numColumns(2).margins(5,5).applyTo(header);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(title);
  GridDataFactory.fillDefaults().applyTo(toolBar);
  return header;
}","private Control createHeader(Composite parent){
  Composite header=new Composite(parent,SWT.NONE);
  header.setBackground(parent.getDisplay().getSystemColor(SWT.COLOR_WHITE));
  Font boldFont=resourceManager.createFont(FontDescriptor.createFrom(JFaceResources.getFont(JFaceResources.HEADER_FONT)).setStyle(SWT.BOLD));
  Label title=new Label(header,SWT.NONE);
  title.setText(getTitle());
  title.setFont(boldFont);
  title.setForeground(resourceManager.createColor(Colors.HEADINGS.swt()));
  title.setBackground(header.getBackground());
  ToolBar toolBar=new ToolBar(header,SWT.FLAT | SWT.RIGHT);
  toolBar.setBackground(header.getBackground());
  addButtons(toolBar);
  GridLayoutFactory.fillDefaults().numColumns(2).margins(5,5).applyTo(header);
  GridDataFactory.fillDefaults().grab(true,false).applyTo(title);
  GridDataFactory.fillDefaults().applyTo(toolBar);
  return header;
}",0.9931662870159452
52792,"public IndustryClassificationTreeViewer(Composite parent,int style){
  container=new Composite(parent,style);
  TreeColumnLayout layout=new TreeColumnLayout();
  container.setLayout(layout);
  viewer=new TreeViewer(container);
  TreeViewerColumn column=new TreeViewerColumn(viewer,SWT.NONE);
  column.getColumn().setText(Messages.ShortLabelIndustry);
  column.getColumn().setWidth(400);
  layout.setColumnData(column.getColumn(),new ColumnPixelData(400));
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return ((TreeMapItem)element).getLabel();
    }
    @Override public Image getImage(    Object element){
      TreeMapItem node=(TreeMapItem)element;
      if (node.isCategory())       return PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJ_FOLDER);
 else       if (node.isSecurity())       return PortfolioPlugin.image(PortfolioPlugin.IMG_SECURITY);
 else       if (node.isAccount())       return PortfolioPlugin.image(PortfolioPlugin.IMG_ACCOUNT);
 else       return null;
    }
  }
);
  ColumnViewerSorter.create(TreeMapItem.class,""String_Node_Str"").attachTo(viewer,column);
  column=new TreeViewerColumn(viewer,SWT.RIGHT);
  column.getColumn().setText(Messages.ColumnActualPercent);
  column.getColumn().setWidth(60);
  layout.setColumnData(column.getColumn(),new ColumnPixelData(60));
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      double percentage=((TreeMapItem)element).getPercentage();
      return String.format(""String_Node_Str"",percentage * 100d);
    }
  }
);
  ColumnViewerSorter.create(TreeMapItem.class,""String_Node_Str"").attachTo(viewer,column,true);
  column=new TreeViewerColumn(viewer,SWT.RIGHT);
  column.getColumn().setText(Messages.ColumnActualValue);
  column.getColumn().setWidth(100);
  layout.setColumnData(column.getColumn(),new ColumnPixelData(100));
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      long valuation=((TreeMapItem)element).getValuation();
      return Values.Amount.format(valuation);
    }
  }
);
  ColumnViewerSorter.create(TreeMapItem.class,""String_Node_Str"").attachTo(viewer,column);
  viewer.getTree().setHeaderVisible(true);
  viewer.getTree().setLinesVisible(true);
  viewer.setContentProvider(new ItemContentProvider());
}","public IndustryClassificationTreeViewer(Composite parent,int style){
  container=new Composite(parent,style);
  TreeColumnLayout layout=new TreeColumnLayout();
  container.setLayout(layout);
  viewer=new TreeViewer(container,SWT.FULL_SELECTION);
  TreeViewerColumn column=new TreeViewerColumn(viewer,SWT.NONE);
  column.getColumn().setText(Messages.ShortLabelIndustry);
  column.getColumn().setWidth(400);
  layout.setColumnData(column.getColumn(),new ColumnPixelData(400));
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      return ((TreeMapItem)element).getLabel();
    }
    @Override public Image getImage(    Object element){
      TreeMapItem node=(TreeMapItem)element;
      if (node.isCategory())       return PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJ_FOLDER);
 else       if (node.isSecurity())       return PortfolioPlugin.image(PortfolioPlugin.IMG_SECURITY);
 else       if (node.isAccount())       return PortfolioPlugin.image(PortfolioPlugin.IMG_ACCOUNT);
 else       return null;
    }
  }
);
  ColumnViewerSorter.create(TreeMapItem.class,""String_Node_Str"").attachTo(viewer,column);
  column=new TreeViewerColumn(viewer,SWT.RIGHT);
  column.getColumn().setText(Messages.ColumnActualPercent);
  column.getColumn().setWidth(60);
  layout.setColumnData(column.getColumn(),new ColumnPixelData(60));
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      double percentage=((TreeMapItem)element).getPercentage();
      return String.format(""String_Node_Str"",percentage * 100d);
    }
  }
);
  ColumnViewerSorter.create(TreeMapItem.class,""String_Node_Str"").attachTo(viewer,column,true);
  column=new TreeViewerColumn(viewer,SWT.RIGHT);
  column.getColumn().setText(Messages.ColumnActualValue);
  column.getColumn().setWidth(100);
  layout.setColumnData(column.getColumn(),new ColumnPixelData(100));
  column.setLabelProvider(new ColumnLabelProvider(){
    @Override public String getText(    Object element){
      long valuation=((TreeMapItem)element).getValuation();
      return Values.Amount.format(valuation);
    }
  }
);
  ColumnViewerSorter.create(TreeMapItem.class,""String_Node_Str"").attachTo(viewer,column);
  viewer.getTree().setHeaderVisible(true);
  viewer.getTree().setLinesVisible(true);
  viewer.setContentProvider(new ItemContentProvider());
}",0.9960703205791106
52793,"@Override Control createViewControl(Composite parent){
  Composite composite=new Composite(parent,SWT.NONE);
  composite.setBackground(parent.getBackground());
  Label headingClassification=createHeading(composite,taxonomy.getRootCategory().getLabel());
  valueSector=new Label(composite,SWT.NONE);
  valueIndustryGroup=new Label(composite,SWT.NONE);
  valueIndustry=new Label(composite,SWT.NONE);
  valueSubIndustry=new Label(composite,SWT.NONE);
  FormLayout layout=new FormLayout();
  layout.marginLeft=5;
  layout.marginRight=5;
  composite.setLayout(layout);
  FormData data=new FormData();
  data.top=new FormAttachment(0,5);
  headingClassification.setLayoutData(data);
  data=new FormData();
  data.top=new FormAttachment(headingClassification,5);
  data.left=new FormAttachment(0);
  data.right=new FormAttachment(100);
  valueSector.setLayoutData(data);
  below(valueSector,valueIndustryGroup);
  below(valueIndustryGroup,valueIndustry);
  below(valueIndustry,valueSubIndustry);
  return composite;
}","@Override Control createViewControl(Composite parent){
  Composite composite=new Composite(parent,SWT.NONE);
  Label headingClassification=createHeading(composite,taxonomy.getRootCategory().getLabel());
  valueSector=new Label(composite,SWT.NONE);
  valueIndustryGroup=new Label(composite,SWT.NONE);
  valueIndustry=new Label(composite,SWT.NONE);
  valueSubIndustry=new Label(composite,SWT.NONE);
  FormLayout layout=new FormLayout();
  layout.marginLeft=5;
  layout.marginRight=5;
  composite.setLayout(layout);
  FormData data=new FormData();
  data.top=new FormAttachment(0,5);
  headingClassification.setLayoutData(data);
  data=new FormData();
  data.top=new FormAttachment(headingClassification,5);
  data.left=new FormAttachment(0);
  data.right=new FormAttachment(100);
  valueSector.setLayoutData(data);
  below(valueSector,valueIndustryGroup);
  below(valueIndustryGroup,valueIndustry);
  below(valueIndustry,valueSubIndustry);
  return composite;
}",0.9740985271711528
52794,"public void SecurityDetailsViewer(Composite parent,int style,Facet... facets){
  container=new Composite(parent,style);
  container.setBackground(Display.getDefault().getSystemColor(SWT.COLOR_WHITE));
  LocalResourceManager resources=new LocalResourceManager(JFaceResources.getResources(),container);
  Font boldFont=resources.createFont(FontDescriptor.createFrom(container.getFont()).setStyle(SWT.BOLD));
  Color color=resources.createColor(Colors.HEADINGS.swt());
  GridLayoutFactory.fillDefaults().numColumns(1).applyTo(container);
  for (  Facet facet : facets) {
    try {
      SecurityFacet child=facet.create(boldFont,color);
      Control control=child.createViewControl(container);
      GridDataFactory.fillDefaults().grab(true,false).applyTo(control);
      children.add(child);
    }
 catch (    Exception e) {
      PortfolioPlugin.log(e);
    }
  }
}","public void SecurityDetailsViewer(Composite parent,int style,Facet... facets){
  container=new Composite(parent,style);
  container.setBackground(Display.getDefault().getSystemColor(SWT.COLOR_WHITE));
  container.setBackgroundMode(SWT.INHERIT_FORCE);
  LocalResourceManager resources=new LocalResourceManager(JFaceResources.getResources(),container);
  Font boldFont=resources.createFont(FontDescriptor.createFrom(container.getFont()).setStyle(SWT.BOLD));
  Color color=resources.createColor(Colors.HEADINGS.swt());
  GridLayoutFactory.fillDefaults().numColumns(1).applyTo(container);
  for (  Facet facet : facets) {
    try {
      SecurityFacet child=facet.create(boldFont,color);
      Control control=child.createViewControl(container);
      GridDataFactory.fillDefaults().grab(true,false).applyTo(control);
      children.add(child);
    }
 catch (    Exception e) {
      PortfolioPlugin.log(e);
    }
  }
}",0.9719101123595506
52795,"public void setRootItem(TreeMapItem rootItem){
  this.rootItem=rootItem;
  for (  Control control : this.getChildren())   control.dispose();
  boolean hasParent=false;
  List<TreeMapItem> path=rootItem.getPath();
  for (int ii=1; ii < path.size(); ii++) {
    hasParent=true;
    TreeMapItem item=path.get(ii);
    new LegendItem(this,item);
  }
  if (hasParent && !rootItem.getChildren().isEmpty()) {
    Label l=new Label(this,SWT.NONE);
    l.setText(""String_Node_Str"");
  }
  for (  TreeMapItem child : rootItem.getChildren())   new LegendItem(this,child);
  pack();
  getParent().layout();
}","public void setRootItem(TreeMapItem rootItem){
  this.rootItem=rootItem;
  for (  Control control : this.getChildren())   control.dispose();
  boolean hasParent=false;
  List<TreeMapItem> path=rootItem.getPath();
  for (int ii=1; ii < path.size(); ii++) {
    hasParent=true;
    TreeMapItem item=path.get(ii);
    new LegendItem(this,item);
  }
  if (hasParent && !rootItem.getChildren().isEmpty()) {
    Label l=new Label(this,SWT.NONE);
    l.setText(""String_Node_Str"");
    l.setBackground(this.getBackground());
  }
  for (  TreeMapItem child : rootItem.getChildren())   new LegendItem(this,child);
  pack();
  getParent().layout();
}",0.9651821862348178
52796,"@Test public void testCapitalGainsWithBuyDuringReportPeriod(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,1000000,100,0));
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2011,Calendar.JANUARY,15),security,PortfolioTransaction.Type.BUY,100000,9900,0));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).valuation);
  assertEquals(0,result.get(CategoryType.EARNINGS).valuation);
  assertEquals(10000 + (11000 - 9900),result.get(CategoryType.CAPITAL_GAINS).valuation);
  assertEquals(121000,result.get(CategoryType.FINAL_VALUE).valuation);
}","@Test public void testCapitalGainsWithBuyDuringReportPeriod(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,1000000,100,0));
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2011,Calendar.JANUARY,15),security,PortfolioTransaction.Type.BUY,100000,9900,0));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).getValuation());
  assertEquals(0,result.get(CategoryType.EARNINGS).getValuation());
  assertEquals(10000 + (11000 - 9900),result.get(CategoryType.CAPITAL_GAINS).getValuation());
  assertEquals(121000,result.get(CategoryType.FINAL_VALUE).getValuation());
}",0.9601386481802426
52797,"@Test public void testEarningsFromSecurity(){
  Client client=new Client();
  Security security=new Security();
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,10,100,0));
  client.addPortfolio(portfolio);
  Account account=new Account();
  account.addTransaction(new AccountTransaction(Dates.date(2011,Calendar.JANUARY,31),security,AccountTransaction.Type.INTEREST,5000));
  client.addAccount(account);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(5000,result.get(CategoryType.EARNINGS).valuation);
}","@Test public void testEarningsFromSecurity(){
  Client client=new Client();
  Security security=new Security();
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,10,100,0));
  client.addPortfolio(portfolio);
  Account account=new Account();
  account.addTransaction(new AccountTransaction(Dates.date(2011,Calendar.JANUARY,31),security,AccountTransaction.Type.INTEREST,5000));
  client.addAccount(account);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(5000,result.get(CategoryType.EARNINGS).getValuation());
}",0.9853409815168898
52798,"@Test public void testDepositPlusInterest(){
  Client client=new Client();
  Account account=new Account();
  account.addTransaction(new AccountTransaction(Dates.date(2010,Calendar.JANUARY,1),null,AccountTransaction.Type.DEPOSIT,100000));
  account.addTransaction(new AccountTransaction(Dates.date(2011,Calendar.JUNE,1),null,AccountTransaction.Type.INTEREST,5000));
  client.addAccount(account);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  assertNotNull(snapshot);
  assertNotNull(snapshot.getStartClientSnapshot());
  assertEquals(startDate,snapshot.getStartClientSnapshot().getTime());
  assertNotNull(snapshot.getEndClientSnapshot());
  assertEquals(endDate,snapshot.getEndClientSnapshot().getTime());
  List<Category> categories=snapshot.getCategories();
  assertNotNull(categories);
  assertEquals(8,categories.size());
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).valuation);
  assertEquals(5000,result.get(CategoryType.EARNINGS).valuation);
  assertEquals(105000,result.get(CategoryType.FINAL_VALUE).valuation);
}","@Test public void testDepositPlusInterest(){
  Client client=new Client();
  Account account=new Account();
  account.addTransaction(new AccountTransaction(Dates.date(2010,Calendar.JANUARY,1),null,AccountTransaction.Type.DEPOSIT,100000));
  account.addTransaction(new AccountTransaction(Dates.date(2011,Calendar.JUNE,1),null,AccountTransaction.Type.INTEREST,5000));
  client.addAccount(account);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  assertNotNull(snapshot);
  assertNotNull(snapshot.getStartClientSnapshot());
  assertEquals(startDate,snapshot.getStartClientSnapshot().getTime());
  assertNotNull(snapshot.getEndClientSnapshot());
  assertEquals(endDate,snapshot.getEndClientSnapshot().getTime());
  List<Category> categories=snapshot.getCategories();
  assertNotNull(categories);
  assertEquals(8,categories.size());
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).getValuation());
  assertEquals(5000,result.get(CategoryType.EARNINGS).getValuation());
  assertEquals(105000,result.get(CategoryType.FINAL_VALUE).getValuation());
}",0.9703225806451612
52799,"@Test public void testCapitalGains(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,1000000,100,0));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).valuation);
  assertEquals(0,result.get(CategoryType.EARNINGS).valuation);
  assertEquals(10000,result.get(CategoryType.CAPITAL_GAINS).valuation);
  assertEquals(110000,result.get(CategoryType.FINAL_VALUE).valuation);
}","@Test public void testCapitalGains(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,1000000,100,0));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).getValuation());
  assertEquals(0,result.get(CategoryType.EARNINGS).getValuation());
  assertEquals(10000,result.get(CategoryType.CAPITAL_GAINS).getValuation());
  assertEquals(110000,result.get(CategoryType.FINAL_VALUE).getValuation());
}",0.9524301964839712
52800,"@Test public void testDepositPlusInterestFirstDay(){
  Client client=new Client();
  Account account=new Account();
  account.addTransaction(new AccountTransaction(Dates.date(2010,Calendar.JANUARY,1),null,AccountTransaction.Type.DEPOSIT,100000));
  account.addTransaction(new AccountTransaction(Dates.date(2010,Calendar.DECEMBER,31),null,AccountTransaction.Type.INTEREST,5000));
  client.addAccount(account);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(105000,result.get(CategoryType.INITIAL_VALUE).valuation);
  assertEquals(0,result.get(CategoryType.EARNINGS).valuation);
  assertEquals(105000,result.get(CategoryType.FINAL_VALUE).valuation);
}","@Test public void testDepositPlusInterestFirstDay(){
  Client client=new Client();
  Account account=new Account();
  account.addTransaction(new AccountTransaction(Dates.date(2010,Calendar.JANUARY,1),null,AccountTransaction.Type.DEPOSIT,100000));
  account.addTransaction(new AccountTransaction(Dates.date(2010,Calendar.DECEMBER,31),null,AccountTransaction.Type.INTEREST,5000));
  client.addAccount(account);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(105000,result.get(CategoryType.INITIAL_VALUE).getValuation());
  assertEquals(0,result.get(CategoryType.EARNINGS).getValuation());
  assertEquals(105000,result.get(CategoryType.FINAL_VALUE).getValuation());
}",0.9560789306174412
52801,"@Test public void testCapitalGainsWithPartialSellDuringReportPeriod(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,1000000,100,0));
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2011,Calendar.JANUARY,15),security,PortfolioTransaction.Type.SELL,100000,9900,0));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).valuation);
  assertEquals(0,result.get(CategoryType.EARNINGS).valuation);
  assertEquals(1000 * 9 + (9900 - 10000),result.get(CategoryType.CAPITAL_GAINS).valuation);
  assertEquals(11000 * 9,result.get(CategoryType.FINAL_VALUE).valuation);
}","@Test public void testCapitalGainsWithPartialSellDuringReportPeriod(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,1000000,100,0));
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2011,Calendar.JANUARY,15),security,PortfolioTransaction.Type.SELL,100000,9900,0));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).getValuation());
  assertEquals(0,result.get(CategoryType.EARNINGS).getValuation());
  assertEquals(1000 * 9 + (9900 - 10000),result.get(CategoryType.CAPITAL_GAINS).getValuation());
  assertEquals(11000 * 9,result.get(CategoryType.FINAL_VALUE).getValuation());
}",0.960650128314799
52802,"@Test public void testCapitalGainsWithPartialSellDuringReportPeriodWithFees(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,1000000,100,0));
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2011,Calendar.JANUARY,15),security,PortfolioTransaction.Type.SELL,100000,9900,1));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(1000 * 9 + (9900 - 10000),result.get(CategoryType.CAPITAL_GAINS).valuation);
}","@Test public void testCapitalGainsWithPartialSellDuringReportPeriodWithFees(){
  Client client=new Client();
  Security security=new Security();
  security.addPrice(new SecurityPrice(Dates.date(2010,Calendar.JANUARY,1),10000));
  security.addPrice(new SecurityPrice(Dates.date(2011,Calendar.JUNE,1),11000));
  client.addSecurity(security);
  Portfolio portfolio=new Portfolio();
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2010,Calendar.JANUARY,1),security,PortfolioTransaction.Type.BUY,1000000,100,0));
  portfolio.addTransaction(new PortfolioTransaction(Dates.date(2011,Calendar.JANUARY,15),security,PortfolioTransaction.Type.SELL,100000,9900,1));
  client.addPortfolio(portfolio);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(1000 * 9 + (9900 - 10000),result.get(CategoryType.CAPITAL_GAINS).getValuation());
}",0.9880145909327774
52803,"@Test public void testDepositPlusInterestLastDay(){
  Client client=new Client();
  Account account=new Account();
  account.addTransaction(new AccountTransaction(Dates.date(2010,Calendar.JANUARY,1),null,AccountTransaction.Type.DEPOSIT,100000));
  account.addTransaction(new AccountTransaction(Dates.date(2011,Calendar.DECEMBER,31),null,AccountTransaction.Type.INTEREST,5000));
  client.addAccount(account);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).valuation);
  assertEquals(5000,result.get(CategoryType.EARNINGS).valuation);
  assertEquals(0,result.get(CategoryType.CAPITAL_GAINS).valuation);
  assertEquals(105000,result.get(CategoryType.FINAL_VALUE).valuation);
}","@Test public void testDepositPlusInterestLastDay(){
  Client client=new Client();
  Account account=new Account();
  account.addTransaction(new AccountTransaction(Dates.date(2010,Calendar.JANUARY,1),null,AccountTransaction.Type.DEPOSIT,100000));
  account.addTransaction(new AccountTransaction(Dates.date(2011,Calendar.DECEMBER,31),null,AccountTransaction.Type.INTEREST,5000));
  client.addAccount(account);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(client,startDate,endDate);
  EnumMap<CategoryType,Category> result=snapshot.getCategoryMap();
  assertEquals(100000,result.get(CategoryType.INITIAL_VALUE).getValuation());
  assertEquals(5000,result.get(CategoryType.EARNINGS).getValuation());
  assertEquals(0,result.get(CategoryType.CAPITAL_GAINS).getValuation());
  assertEquals(105000,result.get(CategoryType.FINAL_VALUE).getValuation());
}",0.9463869463869464
52804,"public Object start(IApplicationContext context) throws Exception {
  Display display=PlatformUI.createDisplay();
  try {
    int returnCode=PlatformUI.createAndRunWorkbench(display,new ApplicationWorkbenchAdvisor());
    if (returnCode == PlatformUI.RETURN_RESTART)     return IApplication.EXIT_RESTART;
 else     return IApplication.EXIT_OK;
  }
  finally {
    display.dispose();
  }
}","public Object start(IApplicationContext context){
  Display display=PlatformUI.createDisplay();
  try {
    int returnCode=PlatformUI.createAndRunWorkbench(display,new ApplicationWorkbenchAdvisor());
    if (returnCode == PlatformUI.RETURN_RESTART)     return IApplication.EXIT_RESTART;
 else     return IApplication.EXIT_OK;
  }
  finally {
    display.dispose();
  }
}",0.9762532981530344
52805,"public Object start(IApplicationContext context) throws Exception {
  String[] args=(String[])context.getArguments().get(IApplicationContext.APPLICATION_ARGS);
  if (""String_Node_Str"".equals(args[0])) {
    return doExport(args);
  }
 else {
    return error(""String_Node_Str"");
  }
}","public Object start(IApplicationContext context){
  String[] args=(String[])context.getArguments().get(IApplicationContext.APPLICATION_ARGS);
  if (""String_Node_Str"".equals(args[0])) {
    return doExport(args);
  }
 else {
    return error(""String_Node_Str"");
  }
}",0.9672727272727272
52806,"@Override protected void createFormElements(Composite editArea){
  bindings.createLabel(editArea,type.name());
  if (!allowSelectionOfSecurity) {
    bindings.createLabel(editArea,((Model)getModel()).getSecurity().getName());
  }
 else {
    bindings.bindComboViewer(editArea,Messages.ColumnSecurity,""String_Node_Str"",new LabelProvider(){
      @Override public String getText(      Object element){
        return ((Security)element).getName();
      }
    }
,getModel().getClient().getSecurities().toArray());
  }
  bindings.bindComboViewer(editArea,Messages.ColumnPortfolio,""String_Node_Str"",new LabelProvider(){
    @Override public String getText(    Object element){
      return ((Portfolio)element).getName();
    }
  }
,getModel().getClient().getPortfolios().toArray());
  bindings.bindMandatorySharesInput(editArea,Messages.ColumnShares,""String_Node_Str"").setFocus();
  Label label=new Label(editArea,SWT.NONE);
  label.setText(Messages.ColumnPrice);
  Label lblPrice=new Label(editArea,SWT.BORDER | SWT.READ_ONLY | SWT.NO_FOCUS);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,false).applyTo(lblPrice);
  getBindingContext().bindValue(SWTObservables.observeText(lblPrice),BeansObservables.observeValue(getModel(),""String_Node_Str""),new UpdateValueStrategy(false,UpdateValueStrategy.POLICY_UPDATE).setConverter(new StringToCurrencyConverter(Values.Amount)),new UpdateValueStrategy(false,UpdateValueStrategy.POLICY_UPDATE).setConverter(new CurrencyToStringConverter(Values.Amount)));
  bindings.bindAmountInput(editArea,Messages.ColumnFees,""String_Node_Str"");
  bindings.bindMandatoryAmountInput(editArea,Messages.ColumnTotal,""String_Node_Str"");
  bindings.bindDatePicker(editArea,Messages.ColumnDate,""String_Node_Str"");
}","@Override protected void createFormElements(Composite editArea){
  bindings().createLabel(editArea,type.name());
  if (!allowSelectionOfSecurity) {
    bindings().createLabel(editArea,((Model)getModel()).getSecurity().getName());
  }
 else {
    bindings().bindComboViewer(editArea,Messages.ColumnSecurity,""String_Node_Str"",new LabelProvider(){
      @Override public String getText(      Object element){
        return ((Security)element).getName();
      }
    }
,getModel().getClient().getSecurities().toArray());
  }
  bindings().bindComboViewer(editArea,Messages.ColumnPortfolio,""String_Node_Str"",new LabelProvider(){
    @Override public String getText(    Object element){
      return ((Portfolio)element).getName();
    }
  }
,getModel().getClient().getPortfolios().toArray());
  bindings().bindMandatorySharesInput(editArea,Messages.ColumnShares,""String_Node_Str"").setFocus();
  Label label=new Label(editArea,SWT.NONE);
  label.setText(Messages.ColumnPrice);
  Label lblPrice=new Label(editArea,SWT.BORDER | SWT.READ_ONLY | SWT.NO_FOCUS);
  GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,false).applyTo(lblPrice);
  getBindingContext().bindValue(SWTObservables.observeText(lblPrice),BeansObservables.observeValue(getModel(),""String_Node_Str""),new UpdateValueStrategy(false,UpdateValueStrategy.POLICY_UPDATE).setConverter(new StringToCurrencyConverter(Values.Amount)),new UpdateValueStrategy(false,UpdateValueStrategy.POLICY_UPDATE).setConverter(new CurrencyToStringConverter(Values.Amount)));
  bindings().bindAmountInput(editArea,Messages.ColumnFees,""String_Node_Str"");
  bindings().bindMandatoryAmountInput(editArea,Messages.ColumnTotal,""String_Node_Str"");
  bindings().bindDatePicker(editArea,Messages.ColumnDate,""String_Node_Str"");
}",0.9954545454545456
52807,"@Override protected void createFormElements(Composite editArea){
  if (!allowSelectionOfSecurity) {
    bindings.createLabel(editArea,((Model)getModel()).getSecurity().getName());
  }
 else {
    bindings.bindComboViewer(editArea,Messages.ColumnSecurity,""String_Node_Str"",new LabelProvider(){
      @Override public String getText(      Object element){
        return ((Security)element).getName();
      }
    }
,getModel().getClient().getSecurities().toArray());
  }
  bindings.bindComboViewer(editArea,Messages.ColumnAccount,""String_Node_Str"",new LabelProvider(){
    @Override public String getText(    Object element){
      return ((Account)element).getName();
    }
  }
,getModel().getClient().getAccounts().toArray());
  bindings.bindMandatoryAmountInput(editArea,Messages.ColumnAmount,""String_Node_Str"");
  bindings.bindDatePicker(editArea,Messages.ColumnDate,""String_Node_Str"");
}","@Override protected void createFormElements(Composite editArea){
  if (!allowSelectionOfSecurity) {
    bindings().createLabel(editArea,((Model)getModel()).getSecurity().getName());
  }
 else {
    bindings().bindComboViewer(editArea,Messages.ColumnSecurity,""String_Node_Str"",new LabelProvider(){
      @Override public String getText(      Object element){
        return ((Security)element).getName();
      }
    }
,getModel().getClient().getSecurities().toArray());
  }
  bindings().bindComboViewer(editArea,Messages.ColumnAccount,""String_Node_Str"",new LabelProvider(){
    @Override public String getText(    Object element){
      return ((Account)element).getName();
    }
  }
,getModel().getClient().getAccounts().toArray());
  bindings().bindMandatoryAmountInput(editArea,Messages.ColumnAmount,""String_Node_Str"");
  bindings().bindDatePicker(editArea,Messages.ColumnDate,""String_Node_Str"");
}",0.9944196428571428
52808,"@Override protected void createFormElements(Composite editArea){
  bindings.bindComboViewer(editArea,Messages.ColumnTransactionType,""String_Node_Str"",new LabelProvider(){
    @Override public String getText(    Object element){
      return ((AccountTransaction.Type)element).name();
    }
  }
,EnumSet.of(AccountTransaction.Type.INTEREST,AccountTransaction.Type.DEPOSIT,AccountTransaction.Type.REMOVAL,AccountTransaction.Type.TAXES,AccountTransaction.Type.FEES).toArray());
  bindings.bindMandatoryAmountInput(editArea,Messages.ColumnAmount,""String_Node_Str"");
  bindings.bindDatePicker(editArea,Messages.ColumnDate,""String_Node_Str"");
}","@Override protected void createFormElements(Composite editArea){
  bindings().bindComboViewer(editArea,Messages.ColumnTransactionType,""String_Node_Str"",new LabelProvider(){
    @Override public String getText(    Object element){
      return ((AccountTransaction.Type)element).name();
    }
  }
,EnumSet.of(AccountTransaction.Type.INTEREST,AccountTransaction.Type.DEPOSIT,AccountTransaction.Type.REMOVAL,AccountTransaction.Type.TAXES,AccountTransaction.Type.FEES).toArray());
  bindings().bindMandatoryAmountInput(editArea,Messages.ColumnAmount,""String_Node_Str"");
  bindings().bindDatePicker(editArea,Messages.ColumnDate,""String_Node_Str"");
}",0.9953198127925116
52809,"@Override protected void createFormElements(Composite editArea){
  GridDataFactory gdf=GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,false);
  Label label=new Label(editArea,SWT.NONE);
  label.setText(Messages.ColumnAccountFrom);
  ComboViewer comboFrom=new ComboViewer(editArea,SWT.READ_ONLY);
  comboFrom.setContentProvider(ArrayContentProvider.getInstance());
  comboFrom.setLabelProvider(new LabelProvider(){
    @Override public String getText(    Object element){
      return ((Account)element).getName();
    }
  }
);
  comboFrom.setInput(getModel().getClient().getAccounts().toArray());
  gdf.applyTo(comboFrom.getControl());
  final IViewerObservableValue observableFrom=ViewersObservables.observeSingleSelection(comboFrom);
  label=new Label(editArea,SWT.NONE);
  label.setText(Messages.ColumnAccountTo);
  ComboViewer comboTo=new ComboViewer(editArea,SWT.READ_ONLY);
  comboTo.setContentProvider(ArrayContentProvider.getInstance());
  comboTo.setLabelProvider(new LabelProvider(){
    @Override public String getText(    Object element){
      return ((Account)element).getName();
    }
  }
);
  comboTo.setInput(getModel().getClient().getAccounts().toArray());
  gdf.applyTo(comboTo.getControl());
  final IViewerObservableValue observableTo=ViewersObservables.observeSingleSelection(comboTo);
  bindings.bindMandatoryAmountInput(editArea,Messages.ColumnAmount,""String_Node_Str"");
  bindings.bindDatePicker(editArea,Messages.ColumnDate,""String_Node_Str"");
  DataBindingContext context=getBindingContext();
  MultiValidator validator=new MultiValidator(){
    @Override protected IStatus validate(){
      Object from=observableFrom.getValue();
      Object to=observableTo.getValue();
      return from != null && to != null && from != to ? ValidationStatus.ok() : ValidationStatus.error(Messages.MsgAccountMustBeDifferent);
    }
  }
;
  context.addValidationStatusProvider(validator);
  context.bindValue(validator.observeValidatedValue(observableFrom),BeansObservables.observeValue(getModel(),""String_Node_Str""));
  context.bindValue(validator.observeValidatedValue(observableTo),BeansObservables.observeValue(getModel(),""String_Node_Str""));
}","@Override protected void createFormElements(Composite editArea){
  GridDataFactory gdf=GridDataFactory.fillDefaults().align(SWT.FILL,SWT.FILL).grab(true,false);
  Label label=new Label(editArea,SWT.NONE);
  label.setText(Messages.ColumnAccountFrom);
  ComboViewer comboFrom=new ComboViewer(editArea,SWT.READ_ONLY);
  comboFrom.setContentProvider(ArrayContentProvider.getInstance());
  comboFrom.setLabelProvider(new LabelProvider(){
    @Override public String getText(    Object element){
      return ((Account)element).getName();
    }
  }
);
  comboFrom.setInput(getModel().getClient().getAccounts().toArray());
  gdf.applyTo(comboFrom.getControl());
  final IViewerObservableValue observableFrom=ViewersObservables.observeSingleSelection(comboFrom);
  label=new Label(editArea,SWT.NONE);
  label.setText(Messages.ColumnAccountTo);
  ComboViewer comboTo=new ComboViewer(editArea,SWT.READ_ONLY);
  comboTo.setContentProvider(ArrayContentProvider.getInstance());
  comboTo.setLabelProvider(new LabelProvider(){
    @Override public String getText(    Object element){
      return ((Account)element).getName();
    }
  }
);
  comboTo.setInput(getModel().getClient().getAccounts().toArray());
  gdf.applyTo(comboTo.getControl());
  final IViewerObservableValue observableTo=ViewersObservables.observeSingleSelection(comboTo);
  bindings().bindMandatoryAmountInput(editArea,Messages.ColumnAmount,""String_Node_Str"");
  bindings().bindDatePicker(editArea,Messages.ColumnDate,""String_Node_Str"");
  DataBindingContext context=getBindingContext();
  MultiValidator validator=new MultiValidator(){
    @Override protected IStatus validate(){
      Object from=observableFrom.getValue();
      Object to=observableTo.getValue();
      return from != null && to != null && from != to ? ValidationStatus.ok() : ValidationStatus.error(Messages.MsgAccountMustBeDifferent);
    }
  }
;
  context.addValidationStatusProvider(validator);
  context.bindValue(validator.observeValidatedValue(observableFrom),BeansObservables.observeValue(getModel(),""String_Node_Str""));
  context.bindValue(validator.observeValidatedValue(observableTo),BeansObservables.observeValue(getModel(),""String_Node_Str""));
}",0.9990829894543788
52810,"private Rectangle getSize(Event event,String s){
  int p=s.indexOf(POINT);
  if (p >= 0)   s=s.substring(0,p);
  TextLayout textLayout=getSharedTextLayout(event.display);
  textLayout.setText(s + ""String_Node_Str"");
  return textLayout.getBounds();
}","private Rectangle getSize(Event event,String text){
  String s=text;
  int p=s.indexOf(POINT);
  if (p >= 0)   s=s.substring(0,p);
  TextLayout textLayout=getSharedTextLayout(event.display);
  textLayout.setText(s + ""String_Node_Str"");
  return textLayout.getBounds();
}",0.9576923076923076
52811,"public static final void attachPageListenerTo(final IWizardContainer c){
  if (c instanceof IPageChangeProvider) {
    ((IPageChangeProvider)c).addPageChangedListener(new IPageChangedListener(){
      AbstractWizardPage currentPage;
      @Override public void pageChanged(      PageChangedEvent event){
        if (currentPage != null)         currentPage.afterPage();
        currentPage=(AbstractWizardPage)event.getSelectedPage();
        currentPage.beforePage();
      }
    }
);
  }
}","public static final void attachPageListenerTo(final IWizardContainer c){
  if (c instanceof IPageChangeProvider) {
    ((IPageChangeProvider)c).addPageChangedListener(new IPageChangedListener(){
      private AbstractWizardPage currentPage;
      @Override public void pageChanged(      PageChangedEvent event){
        if (currentPage != null)         currentPage.afterPage();
        currentPage=(AbstractWizardPage)event.getSelectedPage();
        currentPage.beforePage();
      }
    }
);
  }
}",0.991919191919192
52812,"public TotalsCategory(long valuation){
  super(null,valuation);
  this.valuation=valuation;
}","public TotalsCategory(long valuation){
  super(null,valuation);
  this.setValuation(valuation);
}",0.8736842105263158
52813,"public TotalsCategory(long valuation){
  super(null,valuation);
  this.valuation=valuation;
}","public TotalsCategory(long valuation){
  super(null,valuation);
  this.setValuation(valuation);
}",0.8736842105263158
52814,"private long asPrice(String s) throws ParseException {
  if (""String_Node_Str"".equals(s))   return -1;
  return (long)(FMT_PRICE.parse(s).doubleValue() * 100);
}","private long asPrice(String s) throws ParseException {
  if (""String_Node_Str"".equals(s))   return -1;
  return (long)(FMT_PRICE.get().parse(s).doubleValue() * 100);
}",0.9817073170731708
52815,"private int asNumber(String s) throws ParseException {
  if (""String_Node_Str"".equals(s))   return -1;
  return FMT_PRICE.parse(s).intValue();
}","private int asNumber(String s) throws ParseException {
  if (""String_Node_Str"".equals(s))   return -1;
  return FMT_PRICE.get().parse(s).intValue();
}",0.979591836734694
52816,"private <T extends SecurityPrice>List<T> internalGetQuotes(Class<T> klass,Security security,Date startDate) throws IOException {
  if (security.getTickerSymbol() == null)   throw new IOException(MessageFormat.format(Messages.MsgMissingTickerSymbol,security.getName()));
  Calendar start=Calendar.getInstance();
  start.setTime(startDate);
  Calendar stop=Calendar.getInstance();
  String wknUrl=MessageFormat.format(HISTORICAL_URL,security.getTickerSymbol(),start.get(Calendar.MONTH),start.get(Calendar.DATE),Integer.toString(start.get(Calendar.YEAR)),stop.get(Calendar.MONTH),stop.get(Calendar.DATE),Integer.toString(stop.get(Calendar.YEAR)));
  List<T> answer=new ArrayList<T>();
  InputStream is=null;
  String line=null;
  try {
    is=openStream(wknUrl);
    BufferedReader dis=new BufferedReader(new InputStreamReader(is));
    line=dis.readLine();
    if (!""String_Node_Str"".equals(line))     throw new IOException(MessageFormat.format(Messages.MsgUnexpectedHeader,line));
    while ((line=dis.readLine()) != null) {
      String[] values=line.split(""String_Node_Str"");
      if (values.length != 7)       throw new IOException(MessageFormat.format(Messages.MsgUnexpectedValue,line));
      T price=klass.newInstance();
      SimpleDateFormat dfmt=new SimpleDateFormat(""String_Node_Str"");
      Date date=dfmt.parse(values[0]);
      Number q=FMT_PRICE.parse(values[6]);
      long v=(long)(q.doubleValue() * 100);
      price.setTime(date);
      price.setValue(v);
      if (price instanceof LatestSecurityPrice) {
        LatestSecurityPrice latest=(LatestSecurityPrice)price;
        q=FMT_PRICE.parse(values[5]);
        latest.setVolume(q.intValue());
        q=FMT_PRICE.parse(values[2]);
        latest.setHigh((long)(q.doubleValue() * 100));
        q=FMT_PRICE.parse(values[3]);
        latest.setLow((long)(q.doubleValue() * 100));
      }
      answer.add(price);
    }
  }
 catch (  NumberFormatException e) {
    throw new IOException(MessageFormat.format(Messages.MsgErrorsConvertingValue,line),e);
  }
catch (  ParseException e) {
    throw new IOException(MessageFormat.format(Messages.MsgErrorsConvertingValue,line),e);
  }
catch (  InstantiationException e) {
    throw new IOException(e);
  }
catch (  IllegalAccessException e) {
    throw new IOException(e);
  }
 finally {
    if (is != null)     is.close();
  }
  return answer;
}","private <T extends SecurityPrice>List<T> internalGetQuotes(Class<T> klass,Security security,Date startDate) throws IOException {
  if (security.getTickerSymbol() == null)   throw new IOException(MessageFormat.format(Messages.MsgMissingTickerSymbol,security.getName()));
  Calendar start=Calendar.getInstance();
  start.setTime(startDate);
  Calendar stop=Calendar.getInstance();
  String wknUrl=MessageFormat.format(HISTORICAL_URL,security.getTickerSymbol(),start.get(Calendar.MONTH),start.get(Calendar.DATE),Integer.toString(start.get(Calendar.YEAR)),stop.get(Calendar.MONTH),stop.get(Calendar.DATE),Integer.toString(stop.get(Calendar.YEAR)));
  List<T> answer=new ArrayList<T>();
  InputStream is=null;
  String line=null;
  try {
    is=openStream(wknUrl);
    BufferedReader dis=new BufferedReader(new InputStreamReader(is));
    line=dis.readLine();
    if (!""String_Node_Str"".equals(line))     throw new IOException(MessageFormat.format(Messages.MsgUnexpectedHeader,line));
    DecimalFormat priceFormat=FMT_PRICE.get();
    while ((line=dis.readLine()) != null) {
      String[] values=line.split(""String_Node_Str"");
      if (values.length != 7)       throw new IOException(MessageFormat.format(Messages.MsgUnexpectedValue,line));
      T price=klass.newInstance();
      SimpleDateFormat dfmt=new SimpleDateFormat(""String_Node_Str"");
      Date date=dfmt.parse(values[0]);
      Number q=priceFormat.parse(values[6]);
      long v=(long)(q.doubleValue() * 100);
      price.setTime(date);
      price.setValue(v);
      if (price instanceof LatestSecurityPrice) {
        LatestSecurityPrice latest=(LatestSecurityPrice)price;
        q=priceFormat.parse(values[5]);
        latest.setVolume(q.intValue());
        q=priceFormat.parse(values[2]);
        latest.setHigh((long)(q.doubleValue() * 100));
        q=priceFormat.parse(values[3]);
        latest.setLow((long)(q.doubleValue() * 100));
      }
      answer.add(price);
    }
  }
 catch (  NumberFormatException e) {
    throw new IOException(MessageFormat.format(Messages.MsgErrorsConvertingValue,line),e);
  }
catch (  ParseException e) {
    throw new IOException(MessageFormat.format(Messages.MsgErrorsConvertingValue,line),e);
  }
catch (  InstantiationException e) {
    throw new IOException(e);
  }
catch (  IllegalAccessException e) {
    throw new IOException(e);
  }
 finally {
    if (is != null)     is.close();
  }
  return answer;
}",0.5821989528795811
52817,"private Date asDate(String s) throws ParseException {
  if (""String_Node_Str"".equals(s))   return null;
  return fmtTradeDate.parse(s);
}","private Date asDate(String s) throws ParseException {
  if (""String_Node_Str"".equals(s))   return null;
  return FMT_TRADE_DATET.get().parse(s);
}",0.8904593639575972
52818,"private long parseIndex(String text) throws IOException {
  try {
    DecimalFormat fmt=new DecimalFormat(""String_Node_Str"",new DecimalFormatSymbols(Locale.GERMANY));
    Number q=fmt.parse(text);
    return (long)(q.doubleValue() * 100);
  }
 catch (  ParseException e) {
    throw new IOException(e);
  }
}","private long parseIndex(String text) throws IOException {
  try {
    Number q=FMT_INDEX.get().parse(text);
    return (long)(q.doubleValue() * Values.Quote.factor());
  }
 catch (  ParseException e) {
    throw new IOException(e);
  }
}",0.3376146788990826
52819,"public static void pack(Tree tree){
  for (int i=0, n=tree.getColumnCount(); i < n; i++) {
    TreeColumn column=tree.getColumn(i);
    int originalWidth=column.getWidth();
    column.pack();
    int packedWidth=column.getWidth();
    if (packedWidth < originalWidth)     column.setWidth(originalWidth);
  }
  tree.pack();
}","public static void pack(Tree tree){
  for (int i=0, n=tree.getColumnCount(); i < n; i++) {
    TreeColumn column=tree.getColumn(i);
    int originalWidth=getOriginalWidth(column,column.getWidth());
    column.pack();
    int packedWidth=column.getWidth();
    if (packedWidth < originalWidth)     column.setWidth(originalWidth);
  }
  tree.pack();
}",0.9153046062407132
52820,"@Override protected void reportingPeriodUpdated(){
  Calendar startDate=Calendar.getInstance();
  startDate.setTime(Dates.today());
  startDate.add(Calendar.YEAR,-getReportingYears());
  startDate.set(Calendar.DAY_OF_MONTH,1);
  startDate.add(Calendar.DATE,-1);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(getClient(),startDate.getTime(),Dates.today());
  calculation.setInput(snapshot);
  calculation.refresh();
  calculation.expandAll();
  ViewerHelper.pack(calculation);
  snapshotStart.setInput(snapshot.getStartClientSnapshot());
  snapshotStart.pack();
  snapshotEnd.setInput(snapshot.getEndClientSnapshot());
  snapshotEnd.pack();
}","@Override protected void reportingPeriodUpdated(){
  Calendar startDate=Calendar.getInstance();
  startDate.setTime(Dates.today());
  startDate.add(Calendar.YEAR,-getReportingYears());
  startDate.set(Calendar.DAY_OF_MONTH,1);
  startDate.add(Calendar.DATE,-1);
  ClientPerformanceSnapshot snapshot=new ClientPerformanceSnapshot(getClient(),startDate.getTime(),Dates.today());
  try {
    calculation.getTree().setRedraw(false);
    calculation.setInput(snapshot);
    calculation.expandAll();
    ViewerHelper.pack(calculation);
    calculation.getTree().getParent().layout();
  }
  finally {
    calculation.getTree().setRedraw(true);
  }
  snapshotStart.setInput(snapshot.getStartClientSnapshot());
  snapshotStart.pack();
  snapshotEnd.setInput(snapshot.getEndClientSnapshot());
  snapshotEnd.pack();
}",0.5899182561307902
52821,"private boolean shouldInvalidateParentChain(TargetNode<?,?> targetNode){
  if (lastTargetGraph != null) {
    Optional<TargetNode<?,?>> previousTargetNode=lastTargetGraph.getExactOptional(targetNode.getBuildTarget());
    if (previousTargetNode.isPresent()) {
      Preconditions.checkState(lastActionGraphBuilder.getRuleOptional(targetNode.getBuildTarget()).isPresent());
      if (!targetNode.equals(previousTargetNode.get())) {
        if (LOG.isVerboseEnabled()) {
          LOG.verbose(""String_Node_Str"",targetNode.getBuildTarget().toString());
        }
        return true;
      }
    }
  }
  if (!targetNode.getDescription().producesCacheableSubgraph()) {
    if (LOG.isVerboseEnabled()) {
      LOG.verbose(""String_Node_Str"",targetNode.getBuildTarget().toString());
    }
    return true;
  }
  return false;
}","private boolean shouldInvalidateParentChain(TargetNode<?,?> targetNode){
  if (lastTargetGraph != null) {
    Optional<TargetNode<?,?>> previousTargetNode=lastTargetGraph.getExactOptional(targetNode.getBuildTarget());
    if (previousTargetNode.isPresent()) {
      Preconditions.checkState(lastActionGraphBuilder.getRuleOptional(targetNode.getBuildTarget()).isPresent());
      if (!targetNode.equals(previousTargetNode.get())) {
        if (LOG.isVerboseEnabled()) {
          LOG.verbose(""String_Node_Str"",targetNode.getBuildTarget().toString());
        }
        return true;
      }
    }
 else {
      return true;
    }
  }
  if (!targetNode.getDescription().producesCacheableSubgraph()) {
    if (LOG.isVerboseEnabled()) {
      LOG.verbose(""String_Node_Str"",targetNode.getBuildTarget().toString());
    }
    return true;
  }
  return false;
}",0.9802749551703528
52822,"private boolean invalidateChangedTargets(TargetNode<?,?> node,TargetGraph targetGraph,Map<BuildTarget,Boolean> explored,Set<UnflavoredBuildTarget> validTargets){
  if (explored.containsKey(node.getBuildTarget())) {
    return explored.get(node.getBuildTarget());
  }
  boolean ancestorInvalidated=false;
  for (  TargetNode<?,?> child : targetGraph.getOutgoingNodesFor(node)) {
    ancestorInvalidated|=invalidateChangedTargets(child,targetGraph,explored,validTargets);
  }
  boolean invalidateParent=false;
  if (ancestorInvalidated || shouldInvalidateParentChain(node)) {
    if (LOG.isVerboseEnabled()) {
      LOG.verbose(""String_Node_Str"",node.getBuildTarget().toString());
    }
    invalidateParent=true;
  }
 else {
    validTargets.add(node.getBuildTarget().getUnflavoredBuildTarget());
  }
  explored.put(node.getBuildTarget(),invalidateParent);
  return invalidateParent;
}","private boolean invalidateChangedTargets(TargetNode<?,?> node,TargetGraph targetGraph,Map<BuildTarget,Boolean> explored,Set<UnflavoredBuildTarget> invalidTargets){
  if (explored.containsKey(node.getBuildTarget())) {
    return explored.get(node.getBuildTarget());
  }
  boolean ancestorInvalidated=false;
  for (  TargetNode<?,?> child : targetGraph.getOutgoingNodesFor(node)) {
    ancestorInvalidated|=invalidateChangedTargets(child,targetGraph,explored,invalidTargets);
  }
  boolean invalidateParent=false;
  if (ancestorInvalidated || shouldInvalidateParentChain(node)) {
    if (LOG.isVerboseEnabled()) {
      LOG.verbose(""String_Node_Str"",node.getBuildTarget().toString());
    }
    invalidateParent=true;
    invalidTargets.add(node.getBuildTarget().getUnflavoredBuildTarget());
  }
  explored.put(node.getBuildTarget(),invalidateParent);
  return invalidateParent;
}",0.8456299659477866
52823,"/** 
 * Populates the given   {@link ActionGraphBuilder} with the rules from the previously used {@link ActionGraphBuilder} that are deemed usable after checking for invalidations with a target graphwalk.
 */
public void populateActionGraphBuilderWithCachedRules(BuckEventBus eventBus,TargetGraph targetGraph,ActionGraphBuilder graphBuilder){
  int reusedRuleCount=0;
  if (lastActionGraphBuilder != null) {
    Map<BuildTarget,Boolean> explored=new HashMap<>();
    Set<UnflavoredBuildTarget> validTargets=new HashSet<>();
    for (    TargetNode<?,?> root : targetGraph.getNodesWithNoIncomingEdges()) {
      invalidateChangedTargets(root,targetGraph,explored,validTargets);
    }
    reusedRuleCount=addValidRulesToActionGraphBuilder(graphBuilder,validTargets);
    lastActionGraphBuilder.invalidate();
  }
  lastTargetGraph=targetGraph;
  lastActionGraphBuilder=graphBuilder;
  eventBus.post(new ActionGraphEvent.IncrementalLoad(reusedRuleCount));
}","/** 
 * Populates the given   {@link ActionGraphBuilder} with the rules from the previously used {@link ActionGraphBuilder} that are deemed usable after checking for invalidations with a target graphwalk.
 */
public void populateActionGraphBuilderWithCachedRules(BuckEventBus eventBus,TargetGraph targetGraph,ActionGraphBuilder graphBuilder){
  int reusedRuleCount=0;
  if (lastActionGraphBuilder != null) {
    Map<BuildTarget,Boolean> explored=new HashMap<>();
    Set<UnflavoredBuildTarget> invalidTargets=new HashSet<>();
    for (    TargetNode<?,?> root : targetGraph.getNodesWithNoIncomingEdges()) {
      invalidateChangedTargets(root,targetGraph,explored,invalidTargets);
    }
    reusedRuleCount=addValidRulesToActionGraphBuilder(graphBuilder,invalidTargets);
    lastActionGraphBuilder.invalidate();
  }
  lastTargetGraph=targetGraph;
  lastActionGraphBuilder=graphBuilder;
  eventBus.post(new ActionGraphEvent.IncrementalLoad(reusedRuleCount));
}",0.9968619246861924
52824,"private int addValidRulesToActionGraphBuilder(ActionGraphBuilder graphBuilder,Set<UnflavoredBuildTarget> validTargets){
  SourcePathRuleFinder ruleFinder=new SourcePathRuleFinder(graphBuilder);
  SourcePathResolver pathResolver=DefaultSourcePathResolver.from(ruleFinder);
  int totalRuleCount=0;
  int reusedRuleCount=0;
  for (  BuildRule buildRule : lastActionGraphBuilder.getBuildRules()) {
    if (validTargets.contains(buildRule.getBuildTarget().getUnflavoredBuildTarget())) {
      graphBuilder.addToIndex(buildRule);
      buildRule.updateBuildRuleResolver(graphBuilder,ruleFinder,pathResolver);
      reusedRuleCount++;
    }
    totalRuleCount++;
  }
  LOG.debug(""String_Node_Str"",reusedRuleCount,totalRuleCount);
  return reusedRuleCount;
}","private int addValidRulesToActionGraphBuilder(ActionGraphBuilder graphBuilder,Set<UnflavoredBuildTarget> invalidTargets){
  SourcePathRuleFinder ruleFinder=new SourcePathRuleFinder(graphBuilder);
  SourcePathResolver pathResolver=DefaultSourcePathResolver.from(ruleFinder);
  int totalRuleCount=0;
  int reusedRuleCount=0;
  for (  BuildRule buildRule : lastActionGraphBuilder.getBuildRules()) {
    if (!invalidTargets.contains(buildRule.getBuildTarget().getUnflavoredBuildTarget())) {
      graphBuilder.addToIndex(buildRule);
      buildRule.updateBuildRuleResolver(graphBuilder,ruleFinder,pathResolver);
      reusedRuleCount++;
    }
    totalRuleCount++;
  }
  LOG.debug(""String_Node_Str"",reusedRuleCount,totalRuleCount);
  return reusedRuleCount;
}",0.9966777408637874
52825,"private void setUpTargetGraphAndResolver(TargetNode<?,?>... nodes){
  targetGraph=TargetGraphFactory.newInstance(nodes);
  graphBuilder=createActionGraphBuilder(targetGraph);
}","private void setUpTargetGraphAndResolver(TargetNode<?,?>... nodes){
  targetGraph=TargetGraphFactory.newInstanceExact(nodes);
  graphBuilder=createActionGraphBuilder(targetGraph);
}",0.9859943977591036
52826,"@Override public void run() throws Throwable {
  for (  String className : testClassNames) {
    if (!shouldIncludeTest(className)) {
      continue;
    }
    Class<?> testClass=Class.forName(className);
    List<TestResult> results;
    if (!mightBeATestClass(testClass)) {
      results=Collections.emptyList();
    }
 else {
      results=new ArrayList<>();
      TestNG testng=new TestNG();
      testng.setUseDefaultListeners(false);
      testng.setAnnotationTransformer(new FilteringAnnotationTransformer(results));
      testng.setTestClasses(new Class<?>[]{testClass});
      testng.addListener(new TestListener(results));
      testng.addListener(new SuiteHTMLReporter());
      testng.addListener((IReporter)new FailedReporter());
      testng.addListener(new XMLReporter());
      testng.addListener(new EmailableReporter());
      testng.addListener(new JUnitReportReporterWithMethodParameters());
      testng.run();
    }
    writeResult(className,results);
  }
}","@Override public void run() throws Throwable {
  for (  String className : testClassNames) {
    Class<?> testClass=Class.forName(className);
    List<TestResult> results;
    if (!mightBeATestClass(testClass)) {
      results=Collections.emptyList();
    }
 else {
      results=new ArrayList<>();
      TestNG testng=new TestNG();
      testng.setUseDefaultListeners(false);
      testng.setAnnotationTransformer(new FilteringAnnotationTransformer(results));
      testng.setTestClasses(new Class<?>[]{testClass});
      testng.addListener(new TestListener(results));
      testng.addListener(new SuiteHTMLReporter());
      testng.addListener((IReporter)new FailedReporter());
      testng.addListener(new XMLReporter());
      testng.addListener(new EmailableReporter());
      testng.addListener(new JUnitReportReporterWithMethodParameters());
      testng.run();
    }
    writeResult(className,results);
  }
}",0.966754617414248
52827,"@VisibleForTesting static NdkCxxPlatform build(CxxBuckConfig config,AndroidBuckConfig androidConfig,ProjectFilesystem filesystem,Flavor flavor,Platform platform,Path ndkRoot,NdkCxxPlatformTargetConfiguration targetConfiguration,NdkCxxRuntime cxxRuntime,NdkCxxRuntimeType runtimeType,ExecutableFinder executableFinder,boolean strictToolchainPaths){
  NdkCompilerType compilerType=targetConfiguration.getCompiler().getType();
  String version=Joiner.on('-').join(ImmutableList.of(readVersion(ndkRoot),targetConfiguration.getToolchain(),targetConfiguration.getTargetAppPlatform(),compilerType,targetConfiguration.getCompiler().getVersion(),targetConfiguration.getCompiler().getGccVersion(),cxxRuntime));
  Host host=Preconditions.checkNotNull(BUILD_PLATFORMS.get(platform));
  String ndkVersion=readVersion(ndkRoot);
  NdkCxxToolchainPaths toolchainPaths=new NdkCxxToolchainPaths(filesystem,ndkRoot,targetConfiguration,host.toString(),cxxRuntime,strictToolchainPaths,getUseUnifiedHeaders(androidConfig,ndkVersion));
  NdkCxxToolchainPaths sanitizedPaths=toolchainPaths.getSanitizedPaths();
  ImmutableBiMap.Builder<Path,String> sanitizePathsBuilder=ImmutableBiMap.builder();
  sanitizePathsBuilder.put(toolchainPaths.getNdkToolRoot(),sanitizedPaths.getNdkToolRoot().toString());
  if (compilerType != NdkCompilerType.GCC) {
    sanitizePathsBuilder.put(toolchainPaths.getNdkGccToolRoot(),sanitizedPaths.getNdkGccToolRoot().toString());
  }
  sanitizePathsBuilder.put(ndkRoot,AndroidNdkConstants.ANDROID_NDK_ROOT);
  CxxToolProvider.Type type=compilerType == NdkCompilerType.CLANG ? CxxToolProvider.Type.CLANG : CxxToolProvider.Type.GCC;
  ToolProvider ccTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.cc,version,executableFinder));
  ToolProvider cxxTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.cxx,version,executableFinder));
  CompilerProvider cc=new CompilerProvider(ccTool,type);
  PreprocessorProvider cpp=new PreprocessorProvider(ccTool,type);
  CompilerProvider cxx=new CompilerProvider(cxxTool,type);
  PreprocessorProvider cxxpp=new PreprocessorProvider(cxxTool,type);
  CxxPlatform.Builder cxxPlatformBuilder=CxxPlatform.builder();
  ImmutableBiMap<Path,String> sanitizePaths=sanitizePathsBuilder.build();
  PrefixMapDebugPathSanitizer compilerDebugPathSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",sanitizePaths);
  MungingDebugPathSanitizer assemblerDebugPathSanitizer=new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizePaths);
  cxxPlatformBuilder.setFlavor(flavor).setAs(cc).addAllAsflags(getAsflags(targetConfiguration,toolchainPaths)).setAspp(cpp).setCc(cc).addAllCflags(getCCompilationFlags(targetConfiguration,toolchainPaths,androidConfig)).setCpp(cpp).addAllCppflags(getCPreprocessorFlags(targetConfiguration,toolchainPaths,androidConfig)).setCxx(cxx).addAllCxxflags(getCxxCompilationFlags(targetConfiguration,toolchainPaths,androidConfig)).setCxxpp(cxxpp).addAllCxxppflags(getCxxPreprocessorFlags(targetConfiguration,toolchainPaths,androidConfig)).setLd(new DefaultLinkerProvider(LinkerProvider.Type.GNU,new ConstantToolProvider(getCcLinkTool(targetConfiguration,toolchainPaths,compilerType.cxx,version,cxxRuntime,executableFinder)))).addAllLdflags(getLdFlags(targetConfiguration,androidConfig)).setStrip(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).setSymbolNameTool(new PosixNmSymbolNameTool(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setAr(ArchiverProvider.from(new GnuArchiver(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)))).setRanlib(new ConstantToolProvider(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setCompilerDebugPathSanitizer(compilerDebugPathSanitizer).setAssemblerDebugPathSanitizer(assemblerDebugPathSanitizer).setSharedLibraryExtension(""String_Node_Str"").setSharedLibraryVersionedExtensionFormat(""String_Node_Str"").setStaticLibraryExtension(""String_Node_Str"").setObjectFileExtension(""String_Node_Str"").setSharedLibraryInterfaceParams(config.getSharedLibraryInterfaces() != SharedLibraryInterfaceParams.Type.DISABLED ? Optional.of(ElfSharedLibraryInterfaceParams.of(new ConstantToolProvider(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)),ImmutableList.of(),config.getSharedLibraryInterfaces() == SharedLibraryInterfaceParams.Type.DEFINED_ONLY)) : Optional.empty()).setPublicHeadersSymlinksEnabled(config.getPublicHeadersSymlinksEnabled()).setPrivateHeadersSymlinksEnabled(config.getPrivateHeadersSymlinksEnabled());
  HeaderVerification headerVerification=config.getHeaderVerificationOrIgnore();
  try {
    headerVerification=headerVerification.withPlatformWhitelist(ImmutableList.of(""String_Node_Str"" + Pattern.quote(ndkRoot.toRealPath().toString() + File.separatorChar) + ""String_Node_Str""));
  }
 catch (  IOException e) {
    LOG.warn(e,""String_Node_Str"",ndkRoot);
  }
  cxxPlatformBuilder.setHeaderVerification(headerVerification);
  LOG.debug(""String_Node_Str"",ndkRoot.toString());
  LOG.debug(""String_Node_Str"",headerVerification.getPlatformWhitelist());
  if (cxxRuntime != NdkCxxRuntime.SYSTEM) {
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.SHARED,""String_Node_Str"" + cxxRuntime.sharedName);
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.STATIC,""String_Node_Str"" + cxxRuntime.staticName);
    if (getNdkMajorVersion(ndkVersion) >= 12 && cxxRuntime == NdkCxxRuntime.LIBCXX) {
      cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.STATIC,""String_Node_Str"");
      if (targetConfiguration.getTargetArchAbi() == NdkTargetArchAbi.ARMEABI) {
        cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.STATIC,""String_Node_Str"");
      }
    }
  }
  CxxPlatform cxxPlatform=cxxPlatformBuilder.build();
  NdkCxxPlatform.Builder builder=NdkCxxPlatform.builder();
  builder.setCxxPlatform(cxxPlatform).setCxxRuntime(cxxRuntime).setCxxRuntimeType(runtimeType).setObjdump(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder));
  if ((cxxRuntime != NdkCxxRuntime.SYSTEM) && (runtimeType != NdkCxxRuntimeType.STATIC)) {
    builder.setCxxSharedRuntimePath(toolchainPaths.getCxxRuntimeLibsDirectory().resolve(cxxRuntime.getSoname()));
  }
  return builder.build();
}","@VisibleForTesting static NdkCxxPlatform build(CxxBuckConfig config,AndroidBuckConfig androidConfig,ProjectFilesystem filesystem,Flavor flavor,Platform platform,Path ndkRoot,NdkCxxPlatformTargetConfiguration targetConfiguration,NdkCxxRuntime cxxRuntime,NdkCxxRuntimeType runtimeType,ExecutableFinder executableFinder,boolean strictToolchainPaths){
  NdkCompilerType compilerType=targetConfiguration.getCompiler().getType();
  String version=Joiner.on('-').join(ImmutableList.of(readVersion(ndkRoot),targetConfiguration.getToolchain(),targetConfiguration.getTargetAppPlatform(),compilerType,targetConfiguration.getCompiler().getVersion(),targetConfiguration.getCompiler().getGccVersion(),cxxRuntime));
  Host host=Preconditions.checkNotNull(BUILD_PLATFORMS.get(platform));
  String ndkVersion=readVersion(ndkRoot);
  NdkCxxToolchainPaths toolchainPaths=new NdkCxxToolchainPaths(filesystem,ndkRoot,targetConfiguration,host.toString(),cxxRuntime,strictToolchainPaths,getUseUnifiedHeaders(androidConfig,ndkVersion));
  NdkCxxToolchainPaths sanitizedPaths=toolchainPaths.getSanitizedPaths();
  ImmutableBiMap.Builder<Path,String> sanitizePathsBuilder=ImmutableBiMap.builder();
  sanitizePathsBuilder.put(toolchainPaths.getNdkToolRoot(),sanitizedPaths.getNdkToolRoot().toString());
  if (compilerType != NdkCompilerType.GCC) {
    sanitizePathsBuilder.put(toolchainPaths.getNdkGccToolRoot(),sanitizedPaths.getNdkGccToolRoot().toString());
  }
  sanitizePathsBuilder.put(ndkRoot,AndroidNdkConstants.ANDROID_NDK_ROOT);
  CxxToolProvider.Type type=compilerType == NdkCompilerType.CLANG ? CxxToolProvider.Type.CLANG : CxxToolProvider.Type.GCC;
  ToolProvider ccTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.cc,version,executableFinder));
  ToolProvider cxxTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.cxx,version,executableFinder));
  CompilerProvider cc=new CompilerProvider(ccTool,type);
  PreprocessorProvider cpp=new PreprocessorProvider(ccTool,type);
  CompilerProvider cxx=new CompilerProvider(cxxTool,type);
  PreprocessorProvider cxxpp=new PreprocessorProvider(cxxTool,type);
  CxxPlatform.Builder cxxPlatformBuilder=CxxPlatform.builder();
  ImmutableBiMap<Path,String> sanitizePaths=sanitizePathsBuilder.build();
  PrefixMapDebugPathSanitizer compilerDebugPathSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",sanitizePaths);
  cxxPlatformBuilder.setFlavor(flavor).setAs(cc).addAllAsflags(getAsflags(targetConfiguration,toolchainPaths)).setAspp(cpp).setCc(cc).addAllCflags(getCCompilationFlags(targetConfiguration,toolchainPaths,androidConfig)).setCpp(cpp).addAllCppflags(getCPreprocessorFlags(targetConfiguration,toolchainPaths,androidConfig)).setCxx(cxx).addAllCxxflags(getCxxCompilationFlags(targetConfiguration,toolchainPaths,androidConfig)).setCxxpp(cxxpp).addAllCxxppflags(getCxxPreprocessorFlags(targetConfiguration,toolchainPaths,androidConfig)).setLd(new DefaultLinkerProvider(LinkerProvider.Type.GNU,new ConstantToolProvider(getCcLinkTool(targetConfiguration,toolchainPaths,compilerType.cxx,version,cxxRuntime,executableFinder)))).addAllLdflags(getLdFlags(targetConfiguration,androidConfig)).setStrip(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).setSymbolNameTool(new PosixNmSymbolNameTool(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setAr(ArchiverProvider.from(new GnuArchiver(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)))).setRanlib(new ConstantToolProvider(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setCompilerDebugPathSanitizer(compilerDebugPathSanitizer).setAssemblerDebugPathSanitizer(compilerDebugPathSanitizer).setSharedLibraryExtension(""String_Node_Str"").setSharedLibraryVersionedExtensionFormat(""String_Node_Str"").setStaticLibraryExtension(""String_Node_Str"").setObjectFileExtension(""String_Node_Str"").setSharedLibraryInterfaceParams(config.getSharedLibraryInterfaces() != SharedLibraryInterfaceParams.Type.DISABLED ? Optional.of(ElfSharedLibraryInterfaceParams.of(new ConstantToolProvider(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)),ImmutableList.of(),config.getSharedLibraryInterfaces() == SharedLibraryInterfaceParams.Type.DEFINED_ONLY)) : Optional.empty()).setPublicHeadersSymlinksEnabled(config.getPublicHeadersSymlinksEnabled()).setPrivateHeadersSymlinksEnabled(config.getPrivateHeadersSymlinksEnabled());
  HeaderVerification headerVerification=config.getHeaderVerificationOrIgnore();
  try {
    headerVerification=headerVerification.withPlatformWhitelist(ImmutableList.of(""String_Node_Str"" + Pattern.quote(ndkRoot.toRealPath().toString() + File.separatorChar) + ""String_Node_Str""));
  }
 catch (  IOException e) {
    LOG.warn(e,""String_Node_Str"",ndkRoot);
  }
  cxxPlatformBuilder.setHeaderVerification(headerVerification);
  LOG.debug(""String_Node_Str"",ndkRoot.toString());
  LOG.debug(""String_Node_Str"",headerVerification.getPlatformWhitelist());
  if (cxxRuntime != NdkCxxRuntime.SYSTEM) {
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.SHARED,""String_Node_Str"" + cxxRuntime.sharedName);
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.STATIC,""String_Node_Str"" + cxxRuntime.staticName);
    if (getNdkMajorVersion(ndkVersion) >= 12 && cxxRuntime == NdkCxxRuntime.LIBCXX) {
      cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.STATIC,""String_Node_Str"");
      if (targetConfiguration.getTargetArchAbi() == NdkTargetArchAbi.ARMEABI) {
        cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.STATIC,""String_Node_Str"");
      }
    }
  }
  CxxPlatform cxxPlatform=cxxPlatformBuilder.build();
  NdkCxxPlatform.Builder builder=NdkCxxPlatform.builder();
  builder.setCxxPlatform(cxxPlatform).setCxxRuntime(cxxRuntime).setCxxRuntimeType(runtimeType).setObjdump(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder));
  if ((cxxRuntime != NdkCxxRuntime.SYSTEM) && (runtimeType != NdkCxxRuntimeType.STATIC)) {
    builder.setCxxSharedRuntimePath(toolchainPaths.getCxxRuntimeLibsDirectory().resolve(cxxRuntime.getSoname()));
  }
  return builder.build();
}",0.9841982834683564
52828,"/** 
 * Given a file at `a/b/c/D.java`, and full name of the class is `b.c.D`, the source root for that file is `a`. Returns empty if either the file could not be parsed or the directory structure does not match the package.
 * @param sourcePath path to the java source file.
 * @return the path to source root.
 */
public Optional<Path> getSourceRootFromSource(Path sourcePath){
  Path normalizedSourcePath=sourcePath.normalize();
  Path sourceDirectoryPath=normalizedSourcePath.getParent();
  return getPackagePathFromSource(normalizedSourcePath).flatMap(packagePath -> sourceDirectoryPath.endsWith(packagePath) ? Optional.of(sourceDirectoryPath.subpath(0,sourceDirectoryPath.getNameCount() - packagePath.getNameCount())) : Optional.empty());
}","/** 
 * Given a file at `a/b/c/D.java`, and full name of the class is `b.c.D`, the source root for that file is `a`. Returns empty if either the file could not be parsed or the directory structure does not match the package.
 * @param sourcePath path to the java source file.
 * @return the path to source root.
 */
public Optional<Path> getSourceRootFromSource(Path sourcePath){
  Path normalizedSourcePath=sourcePath.normalize();
  if (!normalizedSourcePath.toString().endsWith(""String_Node_Str"")) {
    return Optional.empty();
  }
  Path sourceDirectoryPath=normalizedSourcePath.getParent();
  return getPackagePathFromSource(normalizedSourcePath).flatMap(packagePath -> sourceDirectoryPath.endsWith(packagePath) ? Optional.of(sourceDirectoryPath.subpath(0,sourceDirectoryPath.getNameCount() - packagePath.getNameCount())) : Optional.empty());
}",0.935423197492163
52829,"/** 
 * Blocking call 
 */
private int processFileBuffer(boolean onlyIfBufferIsFull){
  Set<String> hashCodes;
  SettableFuture<Map<String,byte[]>> resultFuture;
synchronized (multiFetchLock) {
    if (onlyIfBufferIsFull && hashCodesToFetch.size() < multiFetchBufferMaxSize) {
      return 0;
    }
    if (hashCodesToFetch.isEmpty()) {
      return 0;
    }
    hashCodes=hashCodesToFetch;
    hashCodesToFetch=new HashSet<>();
    resultFuture=multiFetchFuture;
    multiFetchFuture=SettableFuture.create();
  }
  try {
    LOG.info(""String_Node_Str"",hashCodes.size(),onlyIfBufferIsFull ? ""String_Node_Str"" : ""String_Node_Str"");
    resultFuture.set(service.multiFetchSourceFiles(hashCodes));
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  return hashCodes.size();
}","/** 
 * Blocking call 
 */
private int processFileBuffer(boolean onlyIfBufferIsFull){
  Set<String> hashCodes;
  SettableFuture<Map<String,byte[]>> resultFuture;
synchronized (multiFetchLock) {
    if (onlyIfBufferIsFull && hashCodesToFetch.size() < multiFetchBufferMaxSize) {
      return 0;
    }
    if (hashCodesToFetch.isEmpty()) {
      return 0;
    }
    hashCodes=hashCodesToFetch;
    hashCodesToFetch=new HashSet<>();
    resultFuture=multiFetchFuture;
    multiFetchFuture=SettableFuture.create();
  }
  try {
    LOG.info(""String_Node_Str"",hashCodes.size(),onlyIfBufferIsFull ? ""String_Node_Str"" : ""String_Node_Str"");
    resultFuture.set(service.multiFetchSourceFiles(hashCodes));
  }
 catch (  IOException e) {
    LOG.error(e);
    resultFuture.setException(e);
    return 0;
  }
  return hashCodes.size();
}",0.9598021026592456
52830,"private ImmutableList<String> getFlags(String platform,String field,char delim){
  return delegate.getValue(platform,field).isPresent() ? delegate.getListWithoutComments(SECTION + '#' + platform,field,delim) : delegate.getListWithoutComments(SECTION,field,delim);
}","private ImmutableList<String> getFlags(String platform,String field,char delim){
  return delegate.getValue(SECTION + '#' + platform,field).isPresent() ? delegate.getListWithoutComments(SECTION + '#' + platform,field,delim) : delegate.getListWithoutComments(SECTION,field,delim);
}",0.9706959706959708
52831,"/** 
 * @return a {@link SourcePath} identified by a {@link Path}. 
 */
public PathSourcePath getPathSourcePath(@PropagatesNullable Path path){
  if (path == null) {
    return null;
  }
  if (path.isAbsolute()) {
    return PathSourcePath.of(projectFilesystem,path);
  }
  return PathSourcePath.of(projectFilesystem,checkPathExists(path.toString(),String.format(""String_Node_Str"",path)));
}","/** 
 * @return a {@link SourcePath} identified by a {@link Path}. 
 */
public PathSourcePath getPathSourcePath(@PropagatesNullable Path path){
  if (path == null) {
    return null;
  }
  if (path.isAbsolute()) {
    return PathSourcePath.of(projectFilesystem,path);
  }
  return PathSourcePath.of(projectFilesystem,checkPathExists(path.toString(),""String_Node_Str""));
}",0.973753280839895
52832,"@Override public LocationMacro coerce(CellPathResolver cellRoots,ProjectFilesystem filesystem,Path pathRelativeToProjectRoot,ImmutableList<String> args) throws CoerceFailedException {
  if (args.size() != 1) {
    throw new CoerceFailedException(String.format(""String_Node_Str"",args.size()));
  }
  LocationMacro.SplitResult parts=LocationMacro.splitSupplementaryOutputPart(args.get(0));
  BuildTarget target=buildTargetTypeCoercer.coerce(cellRoots,filesystem,pathRelativeToProjectRoot,parts.target);
  return LocationMacro.of(target,parts.supplementaryOutput);
}","@Override public LocationMacro coerce(CellPathResolver cellRoots,ProjectFilesystem filesystem,Path pathRelativeToProjectRoot,ImmutableList<String> args) throws CoerceFailedException {
  if (args.size() != 1 || args.get(0).isEmpty()) {
    throw new CoerceFailedException(String.format(""String_Node_Str"",args.size()));
  }
  LocationMacro.SplitResult parts=LocationMacro.splitSupplementaryOutputPart(args.get(0));
  BuildTarget target=buildTargetTypeCoercer.coerce(cellRoots,filesystem,pathRelativeToProjectRoot,parts.target);
  return LocationMacro.of(target,parts.supplementaryOutput);
}",0.9782797567332754
52833,"@Override protected LocationMacro parse(BuildTarget target,CellPathResolver cellNames,ImmutableList<String> input) throws MacroException {
  if (input.size() != 1) {
    throw new MacroException(String.format(""String_Node_Str"",input));
  }
  LocationMacro.SplitResult parts=LocationMacro.splitSupplementaryOutputPart(input.get(0));
  return LocationMacro.of(parseBuildTarget(target,cellNames,ImmutableList.of(parts.target)),parts.supplementaryOutput);
}","@Override protected LocationMacro parse(BuildTarget target,CellPathResolver cellNames,ImmutableList<String> input) throws MacroException {
  if (input.size() != 1 || input.get(0).isEmpty()) {
    throw new MacroException(String.format(""String_Node_Str"",input));
  }
  LocationMacro.SplitResult parts=LocationMacro.splitSupplementaryOutputPart(input.get(0));
  return LocationMacro.of(parseBuildTarget(target,cellNames,ImmutableList.of(parts.target)),parts.supplementaryOutput);
}",0.9721030042918456
52834,"/** 
 * Exposes information about the BuildRule to BuildRules that depend on this BuildRule during action graph construction. If   {@link #hasProviders()} is {@code false}, UnsupportedOperationException will be thrown.
 * @param providerKey the key to the provider desired
 * @param < T > the type of the provider
 * @return the provider of the type desired from this BuildRule
 * @throws MissingProviderException if the required provider is not present
 */
<T extends BuildRuleInfoProvider>T getProvider(T.ProviderKey providerKey) throws MissingProviderException ;","/** 
 * Exposes information about the BuildRule to BuildRules that depend on this BuildRule during action graph construction. If   {@link #hasProviders()} is {@code false}, UnsupportedOperationException will be thrown.
 * @param providerKey the key to the provider desired
 * @param < T > the type of the provider
 * @return the provider of the type desired from this BuildRule
 * @throws MissingProviderException if the required provider is not present
 */
<T extends BuildRuleInfoProvider>T getProvider(BuildRuleInfoProvider.ProviderKey providerKey) throws MissingProviderException ;",0.9808695652173912
52835,"/** 
 * Executes the tbuild and prints failures to the event bus. 
 */
public ExecutionResult executeAndPrintFailuresToEventBus(ListeningExecutorService executorService,ProjectFilesystem projectFilesystem,FileHashCache fileHashCache,InvocationInfo invocationInfo,BuildMode buildMode,int numberOfMinions,String repository,String tenantId,ListenableFuture<ParallelRuleKeyCalculator<RuleKey>> ruleKeyCalculatorFuture) throws InterruptedException {
  Pair<StampedeId,ListenableFuture<Void>> stampedeIdAndPendingPrepFuture=null;
  try {
    stampedeIdAndPendingPrepFuture=preBuildPhase.runPreDistBuildLocalStepsAsync(executorService,projectFilesystem,fileHashCache,eventBus,invocationInfo.getBuildId(),buildMode,numberOfMinions,repository,tenantId,ruleKeyCalculatorFuture);
  }
 catch (  DistBuildService.DistBuildRejectedException ex) {
    eventBus.post(ConsoleEvent.createForMessageWithAnsiEscapeCodes(Level.WARNING,console.getAnsi().asWarningText(ex.getMessage())));
    return createFailedExecutionResult(Preconditions.checkNotNull(stampedeIdReference.get()),ExitCode.PREPARATION_STEP_FAILED);
  }
catch (  IOException|RuntimeException ex) {
    LOG.error(ex,""String_Node_Str"");
    return createFailedExecutionResult(Preconditions.checkNotNull(stampedeIdReference.get()),ExitCode.PREPARATION_STEP_FAILED);
  }
  stampedeIdAndPendingPrepFuture=Preconditions.checkNotNull(stampedeIdAndPendingPrepFuture);
  stampedeIdReference.set(stampedeIdAndPendingPrepFuture.getFirst());
  ListenableFuture<Void> pendingPrepFuture=stampedeIdAndPendingPrepFuture.getSecond();
  try {
    LOG.info(""String_Node_Str"");
    pendingPrepFuture.get();
    LOG.info(""String_Node_Str"");
  }
 catch (  InterruptedException ex) {
    pendingPrepFuture.cancel(true);
    Thread.currentThread().interrupt();
    throw ex;
  }
catch (  ExecutionException ex) {
    LOG.error(ex,""String_Node_Str"");
    return createFailedExecutionResult(stampedeIdReference.get(),ExitCode.PREPARATION_ASYNC_STEP_FAILED);
  }
  BuildPhase.BuildResult buildResult=null;
  try {
    buildResult=buildPhase.runDistBuildAndUpdateConsoleStatus(executorService,Preconditions.checkNotNull(stampedeIdReference.get()),buildMode,invocationInfo,ruleKeyCalculatorFuture);
  }
 catch (  IOException|RuntimeException ex) {
    LOG.error(ex,""String_Node_Str"");
    return createFailedExecutionResult(Preconditions.checkNotNull(stampedeIdReference.get()),ExitCode.DISTRIBUTED_BUILD_STEP_LOCAL_EXCEPTION);
  }
  return postBuildPhase.runPostDistBuildLocalSteps(executorService,buildResult.getBuildSlaveStatusList(),buildResult.getFinalBuildJob(),consoleEventsDispatcher);
}","/** 
 * Executes the tbuild and prints failures to the event bus. 
 */
public ExecutionResult executeAndPrintFailuresToEventBus(ListeningExecutorService executorService,ProjectFilesystem projectFilesystem,FileHashCache fileHashCache,InvocationInfo invocationInfo,BuildMode buildMode,int numberOfMinions,String repository,String tenantId,ListenableFuture<ParallelRuleKeyCalculator<RuleKey>> ruleKeyCalculatorFuture) throws InterruptedException {
  Pair<StampedeId,ListenableFuture<Void>> stampedeIdAndPendingPrepFuture=null;
  try {
    stampedeIdAndPendingPrepFuture=Preconditions.checkNotNull(preBuildPhase.runPreDistBuildLocalStepsAsync(executorService,projectFilesystem,fileHashCache,eventBus,invocationInfo.getBuildId(),buildMode,numberOfMinions,repository,tenantId,ruleKeyCalculatorFuture));
  }
 catch (  DistBuildService.DistBuildRejectedException ex) {
    eventBus.post(ConsoleEvent.createForMessageWithAnsiEscapeCodes(Level.WARNING,console.getAnsi().asWarningText(ex.getMessage())));
    return createFailedExecutionResult(Preconditions.checkNotNull(stampedeIdReference.get()),ExitCode.PREPARATION_STEP_FAILED);
  }
catch (  IOException|RuntimeException ex) {
    LOG.error(ex,""String_Node_Str"");
    return createFailedExecutionResult(Preconditions.checkNotNull(stampedeIdReference.get()),ExitCode.PREPARATION_STEP_FAILED);
  }
  stampedeIdReference.set(stampedeIdAndPendingPrepFuture.getFirst());
  ListenableFuture<Void> pendingPrepFuture=stampedeIdAndPendingPrepFuture.getSecond();
  try {
    LOG.info(""String_Node_Str"");
    pendingPrepFuture.get();
    LOG.info(""String_Node_Str"");
  }
 catch (  InterruptedException ex) {
    pendingPrepFuture.cancel(true);
    Thread.currentThread().interrupt();
    throw ex;
  }
catch (  ExecutionException ex) {
    LOG.error(ex,""String_Node_Str"");
    return createFailedExecutionResult(stampedeIdReference.get(),ExitCode.PREPARATION_ASYNC_STEP_FAILED);
  }
  BuildPhase.BuildResult buildResult=null;
  try {
    buildResult=buildPhase.runDistBuildAndUpdateConsoleStatus(executorService,Preconditions.checkNotNull(stampedeIdReference.get()),buildMode,invocationInfo,ruleKeyCalculatorFuture);
  }
 catch (  IOException|RuntimeException ex) {
    LOG.error(ex,""String_Node_Str"");
    return createFailedExecutionResult(Preconditions.checkNotNull(stampedeIdReference.get()),ExitCode.DISTRIBUTED_BUILD_STEP_LOCAL_EXCEPTION);
  }
  return postBuildPhase.runPostDistBuildLocalSteps(executorService,buildResult.getBuildSlaveStatusList(),buildResult.getFinalBuildJob(),consoleEventsDispatcher);
}",0.9765276430649854
52836,"private void performStampedeDistributedBuild(DistBuildService distBuildService,CommandRunnerParams params,DistBuildConfig distBuildConfig,ListeningExecutorService executorService,ProjectFilesystem filesystem,FileHashCache fileHashCache,BuildEvent.DistBuildStarted started,Object distributedBuildExitCodeLock,AtomicReference<StampedeId> stampedeIdReference,AtomicInteger distributedBuildExitCode,CountDownLatch localBuildInitializationLatch,AtomicInteger localBuildExitCode,RemoteBuildRuleSynchronizer remoteBuildSynchronizer,BuildController build){
  int exitCode=com.facebook.buck.distributed.ExitCode.DISTRIBUTED_PENDING_EXIT_CODE.getCode();
  try {
    BuildController.ExecutionResult distBuildResult=build.executeAndPrintFailuresToEventBus(executorService,filesystem,fileHashCache,params.getBuckEventBus(),params.getInvocationInfo().get(),distBuildConfig.getBuildMode(),distBuildConfig.getNumberOfMinions(),distBuildConfig.getRepository(),distBuildConfig.getTenantId(),localRuleKeyCalculator);
    exitCode=distBuildResult.exitCode;
    if (exitCode == com.facebook.buck.distributed.ExitCode.DISTRIBUTED_BUILD_STEP_LOCAL_EXCEPTION.getCode()) {
      LOG.warn(""String_Node_Str"");
      terminateStampedeBuild(distBuildService,Preconditions.checkNotNull(stampedeIdReference.get()),BuildStatus.FAILED,""String_Node_Str"");
    }
    String finishedMessage=String.format(""String_Node_Str"",exitCode);
    if (exitCode == 0 || localBuildExitCode.get() == 0) {
      params.getConsole().printSuccess(finishedMessage);
    }
 else {
      params.getConsole().printErrorText(finishedMessage);
    }
    if (exitCode != 0 && !distBuildConfig.isSlowLocalBuildFallbackModeEnabled() && !distBuildConfig.shouldAlwaysWaitForRemoteBuildBeforeProceedingLocally()) {
      localBuildInitializationLatch.await();
      String message=""String_Node_Str"";
      LOG.warn(message);
      Preconditions.checkNotNull(lastBuild).terminateBuildWithFailure(new Exception(message));
    }
    if (exitCode != 0 && (distBuildConfig.isSlowLocalBuildFallbackModeEnabled() || distBuildConfig.shouldAlwaysWaitForRemoteBuildBeforeProceedingLocally())) {
      String errorMessage=String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",distBuildResult.stampedeId,exitCode,Joiner.on(""String_Node_Str"").join(arguments),distBuildConfig.isSlowLocalBuildFallbackModeEnabled(),distBuildConfig.shouldAlwaysWaitForRemoteBuildBeforeProceedingLocally());
      params.getConsole().printErrorText(errorMessage);
      LOG.error(errorMessage);
    }
  }
 catch (  IOException e) {
    LOG.error(e,""String_Node_Str"");
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    LOG.warn(e,""String_Node_Str"");
    Thread.currentThread().interrupt();
    return;
  }
 finally {
synchronized (distributedBuildExitCodeLock) {
      if (distributedBuildExitCode.get() == com.facebook.buck.distributed.ExitCode.DISTRIBUTED_PENDING_EXIT_CODE.getCode()) {
        distributedBuildExitCode.set(exitCode);
      }
    }
    remoteBuildSynchronizer.signalCompletionOfRemoteBuild();
    BuildEvent.DistBuildFinished finished=BuildEvent.distBuildFinished(Preconditions.checkNotNull(started),ExitCode.map(exitCode));
    params.getBuckEventBus().post(finished);
  }
}","private void performStampedeDistributedBuild(DistBuildService distBuildService,CommandRunnerParams params,DistBuildConfig distBuildConfig,ListeningExecutorService executorService,ProjectFilesystem filesystem,FileHashCache fileHashCache,BuildEvent.DistBuildStarted started,Object distributedBuildExitCodeLock,AtomicReference<StampedeId> stampedeIdReference,AtomicInteger distributedBuildExitCode,CountDownLatch localBuildInitializationLatch,AtomicInteger localBuildExitCode,RemoteBuildRuleSynchronizer remoteBuildSynchronizer,BuildController build){
  int exitCode=com.facebook.buck.distributed.ExitCode.DISTRIBUTED_PENDING_EXIT_CODE.getCode();
  try {
    BuildController.ExecutionResult distBuildResult=build.executeAndPrintFailuresToEventBus(executorService,filesystem,fileHashCache,params.getBuckEventBus(),params.getInvocationInfo().get(),distBuildConfig.getBuildMode(),distBuildConfig.getNumberOfMinions(),distBuildConfig.getRepository(),distBuildConfig.getTenantId(),localRuleKeyCalculator);
    exitCode=distBuildResult.exitCode;
    if (exitCode == com.facebook.buck.distributed.ExitCode.DISTRIBUTED_BUILD_STEP_LOCAL_EXCEPTION.getCode()) {
      LOG.warn(""String_Node_Str"");
      terminateStampedeBuild(distBuildService,Preconditions.checkNotNull(stampedeIdReference.get()),BuildStatus.FAILED,""String_Node_Str"");
    }
    String finishedMessage=String.format(""String_Node_Str"",exitCode);
    if (exitCode == 0 || localBuildExitCode.get() == 0) {
      params.getConsole().printSuccess(finishedMessage);
    }
 else {
      params.getConsole().printErrorText(finishedMessage);
    }
    if (exitCode != 0) {
      if (!distBuildConfig.isSlowLocalBuildFallbackModeEnabled()) {
        localBuildInitializationLatch.await();
        String message=""String_Node_Str"";
        LOG.warn(message);
        Preconditions.checkNotNull(lastBuild).terminateBuildWithFailure(new Exception(message));
      }
 else {
        String errorMessage=String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",distBuildResult.stampedeId,exitCode,Joiner.on(""String_Node_Str"").join(arguments),distBuildConfig.isSlowLocalBuildFallbackModeEnabled());
        params.getConsole().printErrorText(errorMessage);
        LOG.error(errorMessage);
      }
    }
  }
 catch (  IOException e) {
    LOG.error(e,""String_Node_Str"");
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    LOG.warn(e,""String_Node_Str"");
    Thread.currentThread().interrupt();
    return;
  }
 finally {
synchronized (distributedBuildExitCodeLock) {
      if (distributedBuildExitCode.get() == com.facebook.buck.distributed.ExitCode.DISTRIBUTED_PENDING_EXIT_CODE.getCode()) {
        distributedBuildExitCode.set(exitCode);
      }
    }
    remoteBuildSynchronizer.signalCompletionOfRemoteBuild();
    BuildEvent.DistBuildFinished finished=BuildEvent.distBuildFinished(Preconditions.checkNotNull(started),ExitCode.map(exitCode));
    params.getBuckEventBus().post(finished);
  }
}",0.8463244613434727
52837,"private ExitCode executeDistBuild(CommandRunnerParams params,DistBuildConfig distBuildConfig,ActionAndTargetGraphs graphs,WeightedListeningExecutorService executorService,ProjectFilesystem filesystem,FileHashCache fileHashCache,ClientStatsTracker distBuildClientStats,RuleKeyCacheScope<RuleKey> ruleKeyCacheScope) throws IOException, InterruptedException {
  Preconditions.checkNotNull(distBuildClientEventListener);
  if (distributedBuildStateFile == null && distBuildConfig.getBuildMode().equals(BuildMode.DISTRIBUTED_BUILD_WITH_LOCAL_COORDINATOR) && !distBuildConfig.getMinionQueue().isPresent()) {
    throw new HumanReadableException(""String_Node_Str"");
  }
  BuildEvent.DistBuildStarted started=BuildEvent.distBuildStarted();
  params.getBuckEventBus().post(started);
  LOG.info(""String_Node_Str"");
  AsyncJobStateAndCells stateAndCells=computeDistBuildState(params,graphs,executorService,Optional.of(distBuildClientStats));
  ListenableFuture<BuildJobState> asyncJobState=stateAndCells.asyncJobState;
  DistBuildCellIndexer distBuildCellIndexer=stateAndCells.distBuildCellIndexer;
  if (distributedBuildStateFile != null) {
    BuildJobState jobState;
    try {
      jobState=asyncJobState.get();
    }
 catch (    ExecutionException e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
    for (    BuildJobStateFileHashes cell : jobState.getFileHashes()) {
      ProjectFilesystem cellFilesystem=Preconditions.checkNotNull(distBuildCellIndexer.getLocalFilesystemsByCellIndex().get(cell.getCellIndex()));
      for (      BuildJobStateFileHashEntry entry : cell.getEntries()) {
        cellFilesystem.readFileIfItExists(cellFilesystem.resolve(entry.getPath().getPath())).ifPresent(contents -> entry.setContents(contents.getBytes()));
      }
    }
    Path stateDumpPath=Paths.get(distributedBuildStateFile);
    BuildJobStateSerializer.serialize(jobState,filesystem.newFileOutputStream(stateDumpPath));
    return ExitCode.SUCCESS;
  }
  BuckVersion buckVersion=getBuckVersion();
  Preconditions.checkArgument(params.getInvocationInfo().isPresent());
  distBuildClientStats.setIsLocalFallbackBuildEnabled(distBuildConfig.isSlowLocalBuildFallbackModeEnabled());
  ListenableFuture<?> localBuildFuture;
  ListenableFuture<?> distributedBuildFuture;
  Object distributedBuildExitCodeLock=new Object();
  AtomicReference<StampedeId> stampedeIdReference=new AtomicReference<>(createPendingStampedeId());
  AtomicInteger distributedBuildExitCode=new AtomicInteger(com.facebook.buck.distributed.ExitCode.DISTRIBUTED_PENDING_EXIT_CODE.getCode());
  CountDownLatch localBuildInitializationLatch=new CountDownLatch(com.facebook.buck.distributed.ExitCode.DISTRIBUTED_PENDING_EXIT_CODE.getCode());
  AtomicInteger localBuildExitCode=new AtomicInteger(com.facebook.buck.distributed.ExitCode.LOCAL_PENDING_EXIT_CODE.getCode());
  try (DistBuildService distBuildService=DistBuildFactory.newDistBuildService(params)){
    ListeningExecutorService stampedeControllerExecutor=createStampedeControllerExecutorService(distBuildConfig.getControllerMaxThreadCount());
    LogStateTracker distBuildLogStateTracker=DistBuildFactory.newDistBuildLogStateTracker(params.getInvocationInfo().get().getLogDirectoryPath(),filesystem,distBuildService);
    final RemoteBuildRuleSynchronizer remoteBuildSynchronizer=new RemoteBuildRuleSynchronizer(distBuildConfig.shouldAlwaysWaitForRemoteBuildBeforeProceedingLocally());
    BuildController build=new BuildController(BuildControllerArgs.builder().setBuilderExecutorArgs(params.createBuilderArgs()).setTopLevelTargets(buildTargets).setBuildGraphs(graphs).setCachingBuildEngineDelegate(Optional.of(new LocalCachingBuildEngineDelegate(params.getFileHashCache()))).setAsyncJobState(asyncJobState).setDistBuildCellIndexer(distBuildCellIndexer).setDistBuildService(distBuildService).setDistBuildLogStateTracker(distBuildLogStateTracker).setBuckVersion(buckVersion).setDistBuildClientStats(distBuildClientStats).setScheduler(params.getScheduledExecutor()).setMaxTimeoutWaitingForLogsMillis(distBuildConfig.getMaxWaitForRemoteLogsToBeAvailableMillis()).setLogMaterializationEnabled(distBuildConfig.getLogMaterializationEnabled()).setRemoteBuildRuleCompletionNotifier(remoteBuildSynchronizer).setStampedeIdReference(stampedeIdReference).setBuildLabel(distBuildConfig.getBuildLabel()).build());
    localBuildFuture=Preconditions.checkNotNull(params.getExecutors().get(ExecutorPool.CPU)).submit(() -> {
      performStampedeLocalBuild(params,graphs,executorService,distBuildClientStats,ruleKeyCacheScope,distributedBuildExitCodeLock,distributedBuildExitCode,localBuildInitializationLatch,localBuildExitCode,remoteBuildSynchronizer);
    }
);
    distributedBuildFuture=Preconditions.checkNotNull(params.getExecutors().get(ExecutorPool.CPU)).submit(() -> {
      performStampedeDistributedBuild(distBuildService,params,distBuildConfig,stampedeControllerExecutor,filesystem,fileHashCache,started,distributedBuildExitCodeLock,stampedeIdReference,distributedBuildExitCode,localBuildInitializationLatch,localBuildExitCode,remoteBuildSynchronizer,build);
    }
);
    try {
      localBuildFuture.get();
    }
 catch (    ExecutionException e) {
      LOG.error(e);
      throw new RuntimeException(e);
    }
    if (distributedBuildExitCode.get() == com.facebook.buck.distributed.ExitCode.LOCAL_BUILD_FINISHED_FIRST.getCode()) {
      LOG.warn(""String_Node_Str"");
      boolean succeededLocally=localBuildExitCode.get() == 0;
      terminateStampedeBuild(distBuildService,Preconditions.checkNotNull(stampedeIdReference.get()),succeededLocally ? BuildStatus.FINISHED_SUCCESSFULLY : BuildStatus.FAILED,(succeededLocally ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
    distBuildClientStats.setStampedeId(Preconditions.checkNotNull(stampedeIdReference.get()).getId());
    distBuildClientStats.setDistributedBuildExitCode(distributedBuildExitCode.get());
    distributedBuildFuture.cancel(true);
    stateAndCells.cancel();
    stampedeControllerExecutor.shutdown();
    if (!stampedeControllerExecutor.awaitTermination(STAMPEDE_EXECUTOR_SHUTDOWN_TIMEOUT_MILLIS,TimeUnit.MILLISECONDS)) {
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"");
      stampedeControllerExecutor.shutdownNow();
    }
    try {
      Set<String> cacheMissRequestKeys=distBuildClientEventListener.getDefaultCacheMissRequestKeys();
      ArtifactCacheBuckConfig artifactCacheBuckConfig=ArtifactCacheBuckConfig.of(distBuildConfig.getBuckConfig());
      List<RuleKeyLogEntry> ruleKeyLogs=distBuildService.fetchRuleKeyLogs(cacheMissRequestKeys,artifactCacheBuckConfig.getRepository(),artifactCacheBuckConfig.getScheduleType(),true);
      params.getBuckEventBus().post(distBuildClientEventListener.createDistBuildClientCacheResultsEvent(ruleKeyLogs));
    }
 catch (    Exception ex) {
      LOG.error(""String_Node_Str"",ex);
    }
    performStampedePostBuildAnalysis(params,distBuildConfig,filesystem,distBuildClientStats,stampedeIdReference,distributedBuildExitCode,localBuildExitCode,distBuildLogStateTracker);
    if (distributedBuildExitCode.get() == 0) {
      distBuildClientStats.stopTimer(POST_DISTRIBUTED_BUILD_LOCAL_STEPS);
    }
    if (distBuildClientStats.hasStampedeId()) {
      params.getBuckEventBus().post(new DistBuildClientStatsEvent(distBuildClientStats.generateStats()));
    }
    return ExitCode.map(localBuildExitCode.get());
  }
 }","private ExitCode executeDistBuild(CommandRunnerParams params,DistBuildConfig distBuildConfig,ActionAndTargetGraphs graphs,WeightedListeningExecutorService executorService,ProjectFilesystem filesystem,FileHashCache fileHashCache,ClientStatsTracker distBuildClientStats,RuleKeyCacheScope<RuleKey> ruleKeyCacheScope) throws IOException, InterruptedException {
  Preconditions.checkNotNull(distBuildClientEventListener);
  if (distributedBuildStateFile == null && distBuildConfig.getBuildMode().equals(BuildMode.DISTRIBUTED_BUILD_WITH_LOCAL_COORDINATOR) && !distBuildConfig.getMinionQueue().isPresent()) {
    throw new HumanReadableException(""String_Node_Str"");
  }
  BuildEvent.DistBuildStarted started=BuildEvent.distBuildStarted();
  params.getBuckEventBus().post(started);
  LOG.info(""String_Node_Str"");
  AsyncJobStateAndCells stateAndCells=computeDistBuildState(params,graphs,executorService,Optional.of(distBuildClientStats));
  ListenableFuture<BuildJobState> asyncJobState=stateAndCells.asyncJobState;
  DistBuildCellIndexer distBuildCellIndexer=stateAndCells.distBuildCellIndexer;
  if (distributedBuildStateFile != null) {
    BuildJobState jobState;
    try {
      jobState=asyncJobState.get();
    }
 catch (    ExecutionException e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
    for (    BuildJobStateFileHashes cell : jobState.getFileHashes()) {
      ProjectFilesystem cellFilesystem=Preconditions.checkNotNull(distBuildCellIndexer.getLocalFilesystemsByCellIndex().get(cell.getCellIndex()));
      for (      BuildJobStateFileHashEntry entry : cell.getEntries()) {
        cellFilesystem.readFileIfItExists(cellFilesystem.resolve(entry.getPath().getPath())).ifPresent(contents -> entry.setContents(contents.getBytes()));
      }
    }
    Path stateDumpPath=Paths.get(distributedBuildStateFile);
    BuildJobStateSerializer.serialize(jobState,filesystem.newFileOutputStream(stateDumpPath));
    return ExitCode.SUCCESS;
  }
  BuckVersion buckVersion=getBuckVersion();
  Preconditions.checkArgument(params.getInvocationInfo().isPresent());
  distBuildClientStats.setIsLocalFallbackBuildEnabled(distBuildConfig.isSlowLocalBuildFallbackModeEnabled());
  ListenableFuture<?> localBuildFuture;
  ListenableFuture<?> distributedBuildFuture;
  Object distributedBuildExitCodeLock=new Object();
  AtomicReference<StampedeId> stampedeIdReference=new AtomicReference<>(createPendingStampedeId());
  AtomicInteger distributedBuildExitCode=new AtomicInteger(com.facebook.buck.distributed.ExitCode.DISTRIBUTED_PENDING_EXIT_CODE.getCode());
  CountDownLatch localBuildInitializationLatch=new CountDownLatch(1);
  AtomicInteger localBuildExitCode=new AtomicInteger(com.facebook.buck.distributed.ExitCode.LOCAL_PENDING_EXIT_CODE.getCode());
  try (DistBuildService distBuildService=DistBuildFactory.newDistBuildService(params)){
    ListeningExecutorService stampedeControllerExecutor=createStampedeControllerExecutorService(distBuildConfig.getControllerMaxThreadCount());
    LogStateTracker distBuildLogStateTracker=DistBuildFactory.newDistBuildLogStateTracker(params.getInvocationInfo().get().getLogDirectoryPath(),filesystem,distBuildService);
    final RemoteBuildRuleSynchronizer remoteBuildSynchronizer=new RemoteBuildRuleSynchronizer(distBuildConfig.shouldAlwaysWaitForRemoteBuildBeforeProceedingLocally());
    BuildController build=new BuildController(BuildControllerArgs.builder().setBuilderExecutorArgs(params.createBuilderArgs()).setTopLevelTargets(buildTargets).setBuildGraphs(graphs).setCachingBuildEngineDelegate(Optional.of(new LocalCachingBuildEngineDelegate(params.getFileHashCache()))).setAsyncJobState(asyncJobState).setDistBuildCellIndexer(distBuildCellIndexer).setDistBuildService(distBuildService).setDistBuildLogStateTracker(distBuildLogStateTracker).setBuckVersion(buckVersion).setDistBuildClientStats(distBuildClientStats).setScheduler(params.getScheduledExecutor()).setMaxTimeoutWaitingForLogsMillis(distBuildConfig.getMaxWaitForRemoteLogsToBeAvailableMillis()).setLogMaterializationEnabled(distBuildConfig.getLogMaterializationEnabled()).setRemoteBuildRuleCompletionNotifier(remoteBuildSynchronizer).setStampedeIdReference(stampedeIdReference).setBuildLabel(distBuildConfig.getBuildLabel()).build());
    localBuildFuture=Preconditions.checkNotNull(params.getExecutors().get(ExecutorPool.CPU)).submit(() -> {
      performStampedeLocalBuild(params,graphs,executorService,distBuildClientStats,ruleKeyCacheScope,distributedBuildExitCodeLock,distributedBuildExitCode,localBuildInitializationLatch,localBuildExitCode,remoteBuildSynchronizer);
    }
);
    distributedBuildFuture=Preconditions.checkNotNull(params.getExecutors().get(ExecutorPool.CPU)).submit(() -> {
      performStampedeDistributedBuild(distBuildService,params,distBuildConfig,stampedeControllerExecutor,filesystem,fileHashCache,started,distributedBuildExitCodeLock,stampedeIdReference,distributedBuildExitCode,localBuildInitializationLatch,localBuildExitCode,remoteBuildSynchronizer,build);
    }
);
    try {
      localBuildFuture.get();
    }
 catch (    ExecutionException e) {
      LOG.error(e);
      throw new RuntimeException(e);
    }
    if (distributedBuildExitCode.get() == com.facebook.buck.distributed.ExitCode.LOCAL_BUILD_FINISHED_FIRST.getCode()) {
      LOG.warn(""String_Node_Str"");
      boolean succeededLocally=localBuildExitCode.get() == 0;
      terminateStampedeBuild(distBuildService,Preconditions.checkNotNull(stampedeIdReference.get()),succeededLocally ? BuildStatus.FINISHED_SUCCESSFULLY : BuildStatus.FAILED,(succeededLocally ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
    distBuildClientStats.setStampedeId(Preconditions.checkNotNull(stampedeIdReference.get()).getId());
    distBuildClientStats.setDistributedBuildExitCode(distributedBuildExitCode.get());
    distributedBuildFuture.cancel(true);
    stateAndCells.cancel();
    stampedeControllerExecutor.shutdown();
    if (!stampedeControllerExecutor.awaitTermination(STAMPEDE_EXECUTOR_SHUTDOWN_TIMEOUT_MILLIS,TimeUnit.MILLISECONDS)) {
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"");
      stampedeControllerExecutor.shutdownNow();
    }
    try {
      Set<String> cacheMissRequestKeys=distBuildClientEventListener.getDefaultCacheMissRequestKeys();
      ArtifactCacheBuckConfig artifactCacheBuckConfig=ArtifactCacheBuckConfig.of(distBuildConfig.getBuckConfig());
      List<RuleKeyLogEntry> ruleKeyLogs=distBuildService.fetchRuleKeyLogs(cacheMissRequestKeys,artifactCacheBuckConfig.getRepository(),artifactCacheBuckConfig.getScheduleType(),true);
      params.getBuckEventBus().post(distBuildClientEventListener.createDistBuildClientCacheResultsEvent(ruleKeyLogs));
    }
 catch (    Exception ex) {
      LOG.error(""String_Node_Str"",ex);
    }
    performStampedePostBuildAnalysis(params,distBuildConfig,filesystem,distBuildClientStats,stampedeIdReference,distributedBuildExitCode,localBuildExitCode,distBuildLogStateTracker);
    if (distributedBuildExitCode.get() == 0) {
      distBuildClientStats.stopTimer(POST_DISTRIBUTED_BUILD_LOCAL_STEPS);
    }
    if (distBuildClientStats.hasStampedeId()) {
      params.getBuckEventBus().post(new DistBuildClientStatsEvent(distBuildClientStats.generateStats()));
    }
    return ExitCode.map(localBuildExitCode.get());
  }
 }",0.994619628141388
52838,"private void publishPendingBuildRuleFinishedEvents(){
synchronized (buildRuleFinishedEventsLock) {
    if (pendingBuildRuleFinishedEvent.size() == 0) {
      return;
    }
    LOG.info(String.format(""String_Node_Str"",pendingBuildRuleFinishedEvent.size()));
    long currentTimestampMillis=clock.currentTimeMillis();
    Iterator<TimestampedEvent<BuildRuleFinishedEvent>> eventsIterator=pendingBuildRuleFinishedEvent.iterator();
    while (eventsIterator.hasNext()) {
      TimestampedEvent<BuildRuleFinishedEvent> timestampedEvent=eventsIterator.next();
      long elapsedMillisSinceEvent=currentTimestampMillis - timestampedEvent.eventTimestampMillis;
      if (elapsedMillisSinceEvent < CACHE_SYNCHRONIZATION_SAFETY_MARGIN_MILLIS) {
        if (allBuildRuleFinishedEventsRecieved) {
          try {
            Thread.sleep(CACHE_SYNCHRONIZATION_SAFETY_MARGIN_MILLIS - elapsedMillisSinceEvent);
          }
 catch (          InterruptedException e) {
            LOG.error(e);
            Thread.currentThread().interrupt();
            return;
          }
        }
 else {
          break;
        }
      }
      String buildTarget=timestampedEvent.event.getBuildTarget();
      remoteBuildRuleCompletionNotifier.signalCompletionOfBuildRule(buildTarget);
      eventsIterator.remove();
    }
  }
}","private void publishPendingBuildRuleFinishedEvents(){
synchronized (buildRuleFinishedEventsLock) {
    if (pendingBuildRuleFinishedEvent.size() == 0) {
      return;
    }
    LOG.info(String.format(""String_Node_Str"",pendingBuildRuleFinishedEvent.size()));
    Iterator<TimestampedEvent<BuildRuleFinishedEvent>> eventsIterator=pendingBuildRuleFinishedEvent.iterator();
    while (eventsIterator.hasNext()) {
      TimestampedEvent<BuildRuleFinishedEvent> timestampedEvent=eventsIterator.next();
      long elapsedMillisSinceEvent=clock.currentTimeMillis() - timestampedEvent.eventTimestampMillis;
      if (elapsedMillisSinceEvent < CACHE_SYNCHRONIZATION_SAFETY_MARGIN_MILLIS) {
        if (allBuildRuleFinishedEventsRecieved) {
          try {
            long sleepMillis=CACHE_SYNCHRONIZATION_SAFETY_MARGIN_MILLIS - elapsedMillisSinceEvent;
            LOG.info(String.format(""String_Node_Str"",sleepMillis,timestampedEvent.event.getBuildTarget()));
            Thread.sleep(sleepMillis);
          }
 catch (          InterruptedException e) {
            LOG.error(e);
            Thread.currentThread().interrupt();
            return;
          }
        }
 else {
          break;
        }
      }
      String buildTarget=timestampedEvent.event.getBuildTarget();
      remoteBuildRuleCompletionNotifier.signalCompletionOfBuildRule(buildTarget);
      eventsIterator.remove();
    }
  }
}",0.6730911786508524
52839,"/** 
 * @param path Absolute path or path relative to the project root.
 * @return If {@code path} is relative, it is returned. If it is absolute and is inside theproject root, it is relativized to the project root and returned. Otherwise an absent value is returned.
 */
@Override public Optional<Path> getPathRelativeToProjectRoot(Path path){
  path=MorePaths.normalize(path);
  if (path.isAbsolute()) {
    if (path.startsWith(projectRoot)) {
      return Optional.of(MorePaths.relativize(projectRoot,path));
    }
 else {
      return Optional.empty();
    }
  }
 else {
    return Optional.of(path);
  }
}","/** 
 * @param path Absolute path or path relative to the project root.
 * @return If {@code path} is relative, it is returned. If it is absolute and is inside theproject root, it is relativized to the project root and returned. Otherwise an absent value is returned.
 */
@Override public Optional<Path> getPathRelativeToProjectRoot(Path path){
  path=MorePaths.normalize(path);
  if (path.isAbsolute()) {
    Path configuredBuckOut=MorePaths.normalize(projectRoot.resolve(buckPaths.getConfiguredBuckOut()));
    if (path.startsWith(configuredBuckOut) || path.startsWith(projectRoot)) {
      return Optional.of(MorePaths.relativize(projectRoot,path));
    }
 else {
      return Optional.empty();
    }
  }
 else {
    return Optional.of(path);
  }
}",0.896399706098457
52840,"private static BuckPaths getConfiguredBuckPaths(Path rootPath,Config config,Optional<EmbeddedCellBuckOutInfo> embeddedCellBuckOutInfo){
  BuckPaths buckPaths=BuckPaths.createDefaultBuckPaths(rootPath);
  Optional<String> configuredBuckOut=config.getValue(""String_Node_Str"",""String_Node_Str"");
  if (embeddedCellBuckOutInfo.isPresent()) {
    Path cellBuckOut=embeddedCellBuckOutInfo.get().getRootCellBuckOut().resolve(""String_Node_Str"").resolve(embeddedCellBuckOutInfo.get().getCellName());
    buckPaths=buckPaths.withConfiguredBuckOut(rootPath.relativize(cellBuckOut));
  }
 else   if (configuredBuckOut.isPresent()) {
    buckPaths=buckPaths.withConfiguredBuckOut(rootPath.getFileSystem().getPath(configuredBuckOut.get()));
  }
  return buckPaths;
}","private static BuckPaths getConfiguredBuckPaths(Path rootPath,Config config,Optional<EmbeddedCellBuckOutInfo> embeddedCellBuckOutInfo){
  BuckPaths buckPaths=BuckPaths.createDefaultBuckPaths(rootPath);
  Optional<String> configuredBuckOut=config.getValue(""String_Node_Str"",""String_Node_Str"");
  if (embeddedCellBuckOutInfo.isPresent()) {
    Path cellBuckOut=embeddedCellBuckOutInfo.get().getEmbeddedCellsBuckOutBaseDir().resolve(embeddedCellBuckOutInfo.get().getCellName());
    buckPaths=buckPaths.withConfiguredBuckOut(rootPath.relativize(cellBuckOut));
  }
 else   if (configuredBuckOut.isPresent()) {
    buckPaths=buckPaths.withConfiguredBuckOut(rootPath.getFileSystem().getPath(configuredBuckOut.get()));
  }
  return buckPaths;
}",0.9523169912693082
52841,"/** 
 * Create a cell provider at a given root. 
 */
public static CellProvider createForLocalBuild(ProjectFilesystem rootFilesystem,Watchman watchman,BuckConfig rootConfig,CellConfig rootCellConfigOverrides,PluginManager pluginManager,ImmutableMap<String,String> environment,ProcessExecutor processExecutor,ExecutableFinder executableFinder,ProjectFilesystemFactory projectFilesystemFactory){
  DefaultCellPathResolver rootCellCellPathResolver=DefaultCellPathResolver.of(rootFilesystem.getRootPath(),rootConfig.getConfig());
  ImmutableMap<RelativeCellName,Path> cellPathMapping=rootCellCellPathResolver.getPathMapping();
  ImmutableMap<Path,RawConfig> pathToConfigOverrides;
  try {
    pathToConfigOverrides=rootCellConfigOverrides.getOverridesByPath(cellPathMapping);
  }
 catch (  CellConfig.MalformedOverridesException e) {
    throw new HumanReadableException(e.getMessage());
  }
  ImmutableSet<Path> allRoots=ImmutableSet.copyOf(cellPathMapping.values());
  return new CellProvider(cellProvider -> new CacheLoader<Path,Cell>(){
    @Override public Cell load(    Path cellPath) throws IOException, InterruptedException {
      Path normalizedCellPath=cellPath.toRealPath().normalize();
      Preconditions.checkState(allRoots.contains(normalizedCellPath),""String_Node_Str"",normalizedCellPath,allRoots);
      RawConfig configOverrides=Optional.ofNullable(pathToConfigOverrides.get(normalizedCellPath)).orElse(RawConfig.of(ImmutableMap.of()));
      Config config=Configs.createDefaultConfig(normalizedCellPath,configOverrides);
      ImmutableMap<String,Path> cellMapping=DefaultCellPathResolver.getCellPathsFromConfigRepositoriesSection(cellPath,config.get(DefaultCellPathResolver.REPOSITORIES_SECTION));
      cellMapping.forEach((name,path) -> {
        Path pathInRootResolver=rootCellCellPathResolver.getCellPaths().get(name);
        if (pathInRootResolver == null) {
          throw new HumanReadableException(""String_Node_Str"",cellPath.toString(),DefaultCellPathResolver.REPOSITORIES_SECTION,name);
        }
 else         if (!pathInRootResolver.equals(path)) {
          throw new HumanReadableException(""String_Node_Str"" + ""String_Node_Str"",cellPath.toString(),DefaultCellPathResolver.REPOSITORIES_SECTION,name,pathInRootResolver,path);
        }
      }
);
      CellPathResolver cellPathResolver=new CellPathResolverView(rootCellCellPathResolver,cellMapping.keySet(),cellPath);
      Optional<EmbeddedCellBuckOutInfo> embeddedCellBuckOutInfo=Optional.empty();
      Optional<String> canonicalCellName=cellPathResolver.getCanonicalCellName(normalizedCellPath);
      if (rootConfig.isEmbeddedCellBuckOutEnabled() && canonicalCellName.isPresent()) {
        embeddedCellBuckOutInfo=Optional.of(EmbeddedCellBuckOutInfo.of(rootFilesystem.resolve(rootFilesystem.getBuckPaths().getBuckOut()),canonicalCellName.get()));
      }
      ProjectFilesystem cellFilesystem=projectFilesystemFactory.createProjectFilesystem(normalizedCellPath,config,embeddedCellBuckOutInfo);
      BuckConfig buckConfig=new BuckConfig(config,cellFilesystem,rootConfig.getArchitecture(),rootConfig.getPlatform(),rootConfig.getEnvironment(),cellPathResolver);
      RuleKeyConfiguration ruleKeyConfiguration=ConfigRuleKeyConfigurationFactory.create(buckConfig,pluginManager);
      ToolchainProvider toolchainProvider=new DefaultToolchainProvider(pluginManager,environment,buckConfig,cellFilesystem,processExecutor,executableFinder,ruleKeyConfiguration);
      return Cell.of(getKnownRoots(cellPathResolver),canonicalCellName,cellFilesystem,watchman,buckConfig,cellProvider,toolchainProvider,ruleKeyConfiguration);
    }
  }
,cellProvider -> {
    Preconditions.checkState(!rootCellCellPathResolver.getCanonicalCellName(rootFilesystem.getRootPath()).isPresent(),""String_Node_Str"");
    RuleKeyConfiguration ruleKeyConfiguration=ConfigRuleKeyConfigurationFactory.create(rootConfig,pluginManager);
    ToolchainProvider toolchainProvider=new DefaultToolchainProvider(pluginManager,environment,rootConfig,rootFilesystem,processExecutor,executableFinder,ruleKeyConfiguration);
    return Cell.of(getKnownRoots(rootCellCellPathResolver),Optional.empty(),rootFilesystem,watchman,rootConfig,cellProvider,toolchainProvider,ruleKeyConfiguration);
  }
);
}","/** 
 * Create a cell provider at a given root. 
 */
public static CellProvider createForLocalBuild(ProjectFilesystem rootFilesystem,Watchman watchman,BuckConfig rootConfig,CellConfig rootCellConfigOverrides,PluginManager pluginManager,ImmutableMap<String,String> environment,ProcessExecutor processExecutor,ExecutableFinder executableFinder,ProjectFilesystemFactory projectFilesystemFactory){
  DefaultCellPathResolver rootCellCellPathResolver=DefaultCellPathResolver.of(rootFilesystem.getRootPath(),rootConfig.getConfig());
  ImmutableMap<RelativeCellName,Path> cellPathMapping=rootCellCellPathResolver.getPathMapping();
  ImmutableMap<Path,RawConfig> pathToConfigOverrides;
  try {
    pathToConfigOverrides=rootCellConfigOverrides.getOverridesByPath(cellPathMapping);
  }
 catch (  CellConfig.MalformedOverridesException e) {
    throw new HumanReadableException(e.getMessage());
  }
  ImmutableSet<Path> allRoots=ImmutableSet.copyOf(cellPathMapping.values());
  return new CellProvider(cellProvider -> new CacheLoader<Path,Cell>(){
    @Override public Cell load(    Path cellPath) throws IOException, InterruptedException {
      Path normalizedCellPath=cellPath.toRealPath().normalize();
      Preconditions.checkState(allRoots.contains(normalizedCellPath),""String_Node_Str"",normalizedCellPath,allRoots);
      RawConfig configOverrides=Optional.ofNullable(pathToConfigOverrides.get(normalizedCellPath)).orElse(RawConfig.of(ImmutableMap.of()));
      Config config=Configs.createDefaultConfig(normalizedCellPath,configOverrides);
      ImmutableMap<String,Path> cellMapping=DefaultCellPathResolver.getCellPathsFromConfigRepositoriesSection(cellPath,config.get(DefaultCellPathResolver.REPOSITORIES_SECTION));
      cellMapping.forEach((name,path) -> {
        Path pathInRootResolver=rootCellCellPathResolver.getCellPaths().get(name);
        if (pathInRootResolver == null) {
          throw new HumanReadableException(""String_Node_Str"",cellPath.toString(),DefaultCellPathResolver.REPOSITORIES_SECTION,name);
        }
 else         if (!pathInRootResolver.equals(path)) {
          throw new HumanReadableException(""String_Node_Str"" + ""String_Node_Str"",cellPath.toString(),DefaultCellPathResolver.REPOSITORIES_SECTION,name,pathInRootResolver,path);
        }
      }
);
      CellPathResolver cellPathResolver=new CellPathResolverView(rootCellCellPathResolver,cellMapping.keySet(),cellPath);
      Optional<EmbeddedCellBuckOutInfo> embeddedCellBuckOutInfo=Optional.empty();
      Optional<String> canonicalCellName=cellPathResolver.getCanonicalCellName(normalizedCellPath);
      if (rootConfig.isEmbeddedCellBuckOutEnabled() && canonicalCellName.isPresent()) {
        embeddedCellBuckOutInfo=Optional.of(EmbeddedCellBuckOutInfo.of(rootFilesystem.resolve(rootFilesystem.getBuckPaths().getEmbeddedCellsBuckOutBaseDir()),canonicalCellName.get()));
      }
      ProjectFilesystem cellFilesystem=projectFilesystemFactory.createProjectFilesystem(normalizedCellPath,config,embeddedCellBuckOutInfo);
      BuckConfig buckConfig=new BuckConfig(config,cellFilesystem,rootConfig.getArchitecture(),rootConfig.getPlatform(),rootConfig.getEnvironment(),cellPathResolver);
      RuleKeyConfiguration ruleKeyConfiguration=ConfigRuleKeyConfigurationFactory.create(buckConfig,pluginManager);
      ToolchainProvider toolchainProvider=new DefaultToolchainProvider(pluginManager,environment,buckConfig,cellFilesystem,processExecutor,executableFinder,ruleKeyConfiguration);
      return Cell.of(getKnownRoots(cellPathResolver),canonicalCellName,cellFilesystem,watchman,buckConfig,cellProvider,toolchainProvider,ruleKeyConfiguration);
    }
  }
,cellProvider -> {
    Preconditions.checkState(!rootCellCellPathResolver.getCanonicalCellName(rootFilesystem.getRootPath()).isPresent(),""String_Node_Str"");
    RuleKeyConfiguration ruleKeyConfiguration=ConfigRuleKeyConfigurationFactory.create(rootConfig,pluginManager);
    ToolchainProvider toolchainProvider=new DefaultToolchainProvider(pluginManager,environment,rootConfig,rootFilesystem,processExecutor,executableFinder,ruleKeyConfiguration);
    return Cell.of(getKnownRoots(rootCellCellPathResolver),Optional.empty(),rootFilesystem,watchman,rootConfig,cellProvider,toolchainProvider,ruleKeyConfiguration);
  }
);
}",0.9976442873969376
52842,"@Override public Cell load(Path cellPath) throws IOException, InterruptedException {
  Path normalizedCellPath=cellPath.toRealPath().normalize();
  Preconditions.checkState(allRoots.contains(normalizedCellPath),""String_Node_Str"",normalizedCellPath,allRoots);
  RawConfig configOverrides=Optional.ofNullable(pathToConfigOverrides.get(normalizedCellPath)).orElse(RawConfig.of(ImmutableMap.of()));
  Config config=Configs.createDefaultConfig(normalizedCellPath,configOverrides);
  ImmutableMap<String,Path> cellMapping=DefaultCellPathResolver.getCellPathsFromConfigRepositoriesSection(cellPath,config.get(DefaultCellPathResolver.REPOSITORIES_SECTION));
  cellMapping.forEach((name,path) -> {
    Path pathInRootResolver=rootCellCellPathResolver.getCellPaths().get(name);
    if (pathInRootResolver == null) {
      throw new HumanReadableException(""String_Node_Str"",cellPath.toString(),DefaultCellPathResolver.REPOSITORIES_SECTION,name);
    }
 else     if (!pathInRootResolver.equals(path)) {
      throw new HumanReadableException(""String_Node_Str"" + ""String_Node_Str"",cellPath.toString(),DefaultCellPathResolver.REPOSITORIES_SECTION,name,pathInRootResolver,path);
    }
  }
);
  CellPathResolver cellPathResolver=new CellPathResolverView(rootCellCellPathResolver,cellMapping.keySet(),cellPath);
  Optional<EmbeddedCellBuckOutInfo> embeddedCellBuckOutInfo=Optional.empty();
  Optional<String> canonicalCellName=cellPathResolver.getCanonicalCellName(normalizedCellPath);
  if (rootConfig.isEmbeddedCellBuckOutEnabled() && canonicalCellName.isPresent()) {
    embeddedCellBuckOutInfo=Optional.of(EmbeddedCellBuckOutInfo.of(rootFilesystem.resolve(rootFilesystem.getBuckPaths().getBuckOut()),canonicalCellName.get()));
  }
  ProjectFilesystem cellFilesystem=projectFilesystemFactory.createProjectFilesystem(normalizedCellPath,config,embeddedCellBuckOutInfo);
  BuckConfig buckConfig=new BuckConfig(config,cellFilesystem,rootConfig.getArchitecture(),rootConfig.getPlatform(),rootConfig.getEnvironment(),cellPathResolver);
  RuleKeyConfiguration ruleKeyConfiguration=ConfigRuleKeyConfigurationFactory.create(buckConfig,pluginManager);
  ToolchainProvider toolchainProvider=new DefaultToolchainProvider(pluginManager,environment,buckConfig,cellFilesystem,processExecutor,executableFinder,ruleKeyConfiguration);
  return Cell.of(getKnownRoots(cellPathResolver),canonicalCellName,cellFilesystem,watchman,buckConfig,cellProvider,toolchainProvider,ruleKeyConfiguration);
}","@Override public Cell load(Path cellPath) throws IOException, InterruptedException {
  Path normalizedCellPath=cellPath.toRealPath().normalize();
  Preconditions.checkState(allRoots.contains(normalizedCellPath),""String_Node_Str"",normalizedCellPath,allRoots);
  RawConfig configOverrides=Optional.ofNullable(pathToConfigOverrides.get(normalizedCellPath)).orElse(RawConfig.of(ImmutableMap.of()));
  Config config=Configs.createDefaultConfig(normalizedCellPath,configOverrides);
  ImmutableMap<String,Path> cellMapping=DefaultCellPathResolver.getCellPathsFromConfigRepositoriesSection(cellPath,config.get(DefaultCellPathResolver.REPOSITORIES_SECTION));
  cellMapping.forEach((name,path) -> {
    Path pathInRootResolver=rootCellCellPathResolver.getCellPaths().get(name);
    if (pathInRootResolver == null) {
      throw new HumanReadableException(""String_Node_Str"",cellPath.toString(),DefaultCellPathResolver.REPOSITORIES_SECTION,name);
    }
 else     if (!pathInRootResolver.equals(path)) {
      throw new HumanReadableException(""String_Node_Str"" + ""String_Node_Str"",cellPath.toString(),DefaultCellPathResolver.REPOSITORIES_SECTION,name,pathInRootResolver,path);
    }
  }
);
  CellPathResolver cellPathResolver=new CellPathResolverView(rootCellCellPathResolver,cellMapping.keySet(),cellPath);
  Optional<EmbeddedCellBuckOutInfo> embeddedCellBuckOutInfo=Optional.empty();
  Optional<String> canonicalCellName=cellPathResolver.getCanonicalCellName(normalizedCellPath);
  if (rootConfig.isEmbeddedCellBuckOutEnabled() && canonicalCellName.isPresent()) {
    embeddedCellBuckOutInfo=Optional.of(EmbeddedCellBuckOutInfo.of(rootFilesystem.resolve(rootFilesystem.getBuckPaths().getEmbeddedCellsBuckOutBaseDir()),canonicalCellName.get()));
  }
  ProjectFilesystem cellFilesystem=projectFilesystemFactory.createProjectFilesystem(normalizedCellPath,config,embeddedCellBuckOutInfo);
  BuckConfig buckConfig=new BuckConfig(config,cellFilesystem,rootConfig.getArchitecture(),rootConfig.getPlatform(),rootConfig.getEnvironment(),cellPathResolver);
  RuleKeyConfiguration ruleKeyConfiguration=ConfigRuleKeyConfigurationFactory.create(buckConfig,pluginManager);
  ToolchainProvider toolchainProvider=new DefaultToolchainProvider(pluginManager,environment,buckConfig,cellFilesystem,processExecutor,executableFinder,ruleKeyConfiguration);
  return Cell.of(getKnownRoots(cellPathResolver),canonicalCellName,cellFilesystem,watchman,buckConfig,cellProvider,toolchainProvider,ruleKeyConfiguration);
}",0.9959514170040484
52843,"protected static Predicate<Path> getDefaultPathPredicate(ProjectFilesystem projectFilesystem){
  return path -> path.startsWith(projectFilesystem.getBuckPaths().getBuckOut()) || projectFilesystem.isIgnored(path);
}","/** 
 * This predicate matches files that might be result of builds or files that are explicitly ignored.
 */
protected static Predicate<Path> getDefaultPathPredicate(ProjectFilesystem projectFilesystem){
  return path -> isInBuckOut(projectFilesystem,path) || isInEmbeddedCellBuckOut(projectFilesystem,path) || projectFilesystem.isIgnored(path);
}",0.5729537366548043
52844,"public static DefaultFileHashCache createBuckOutFileHashCache(ProjectFilesystem projectFilesystem,FileHashCacheMode fileHashCacheMode){
  return new DefaultFileHashCache(projectFilesystem,(path) -> !(path.startsWith(projectFilesystem.getBuckPaths().getBuckOut())),fileHashCacheMode);
}","public static DefaultFileHashCache createBuckOutFileHashCache(ProjectFilesystem projectFilesystem,FileHashCacheMode fileHashCacheMode){
  return new DefaultFileHashCache(projectFilesystem,(path) -> !isInBuckOut(projectFilesystem,path),fileHashCacheMode);
}",0.8502772643253235
52845,"@Test public void thatBuckoutCacheWillGetIsCorrect() throws IOException, InterruptedException {
  ProjectFilesystem filesystem=TestProjectFilesystems.createProjectFilesystem(tmp.getRoot());
  Path buckOut=filesystem.getBuckPaths().getBuckOut();
  filesystem.mkdirs(buckOut);
  Path buckOutFile=buckOut.resolve(""String_Node_Str"");
  Path otherFile=Paths.get(""String_Node_Str"");
  filesystem.writeContentsToPath(""String_Node_Str"",buckOutFile);
  filesystem.writeContentsToPath(""String_Node_Str"",otherFile);
  DefaultFileHashCache cache=DefaultFileHashCache.createBuckOutFileHashCache(filesystem,fileHashCacheMode);
  assertTrue(cache.willGet(filesystem.getPath(""String_Node_Str"")));
  assertFalse(cache.willGet(filesystem.getPath(""String_Node_Str"")));
}","@Test public void thatBuckoutCacheWillGetIsCorrect() throws IOException, InterruptedException {
  ProjectFilesystem filesystem=TestProjectFilesystems.createProjectFilesystem(tmp.getRoot());
  Path buckOut=filesystem.getBuckPaths().getBuckOut();
  filesystem.mkdirs(buckOut);
  Path buckOutFile=buckOut.resolve(""String_Node_Str"");
  Path otherFile=Paths.get(""String_Node_Str"");
  filesystem.writeContentsToPath(""String_Node_Str"",buckOutFile);
  filesystem.writeContentsToPath(""String_Node_Str"",otherFile);
  DefaultFileHashCache cache=DefaultFileHashCache.createBuckOutFileHashCache(filesystem,fileHashCacheMode);
  assertTrue(cache.willGet(filesystem.getPath(""String_Node_Str"")));
  assertFalse(cache.willGet(filesystem.getPath(""String_Node_Str"")));
  assertFalse(cache.willGet(filesystem.getPath(""String_Node_Str"")));
}",0.9560789306174412
52846,"@Test public void thatNonBuckoutCacheWillGetIsCorrect() throws IOException, InterruptedException {
  ProjectFilesystem filesystem=TestProjectFilesystems.createProjectFilesystem(tmp.getRoot());
  Path buckOut=filesystem.getBuckPaths().getBuckOut();
  filesystem.mkdirs(buckOut);
  Path buckOutFile=buckOut.resolve(""String_Node_Str"");
  Path otherFile=Paths.get(""String_Node_Str"");
  filesystem.writeContentsToPath(""String_Node_Str"",buckOutFile);
  filesystem.writeContentsToPath(""String_Node_Str"",otherFile);
  DefaultFileHashCache cache=DefaultFileHashCache.createDefaultFileHashCache(filesystem,fileHashCacheMode);
  assertFalse(cache.willGet(filesystem.getPath(""String_Node_Str"")));
  assertTrue(cache.willGet(filesystem.getPath(""String_Node_Str"")));
}","@Test public void thatNonBuckoutCacheWillGetIsCorrect() throws IOException, InterruptedException {
  ProjectFilesystem filesystem=TestProjectFilesystems.createProjectFilesystem(tmp.getRoot());
  Path buckOut=filesystem.getBuckPaths().getBuckOut();
  filesystem.mkdirs(buckOut);
  Path buckOutFile=buckOut.resolve(""String_Node_Str"");
  Path otherFile=Paths.get(""String_Node_Str"");
  filesystem.writeContentsToPath(""String_Node_Str"",buckOutFile);
  filesystem.writeContentsToPath(""String_Node_Str"",otherFile);
  DefaultFileHashCache cache=DefaultFileHashCache.createDefaultFileHashCache(filesystem,fileHashCacheMode);
  assertFalse(cache.willGet(filesystem.getPath(""String_Node_Str"")));
  assertFalse(cache.willGet(filesystem.getPath(""String_Node_Str"")));
  assertTrue(cache.willGet(filesystem.getPath(""String_Node_Str"")));
}",0.9562460367786936
52847,"private int executeInProcess(ExecutionContext context){
  if (D8.equals(dexTool)) {
    D8DiagnosticsHandler diagnosticsHandler=new D8DiagnosticsHandler();
    try {
      Set<Path> inputs=new HashSet<>();
      for (      Path rawFile : filesToDex) {
        Path toDex=filesystem.resolve(rawFile);
        if (Files.isRegularFile(toDex)) {
          inputs.add(toDex);
        }
 else {
          Files.newDirectoryStream(toDex,path -> path.toFile().isFile()).forEach(inputs::add);
        }
      }
      boolean outputToDex=outputDexFile.getFileName().toString().endsWith(""String_Node_Str"");
      Path output=outputToDex ? Files.createTempDirectory(""String_Node_Str"") : outputDexFile;
      D8Command.Builder builder=D8Command.builder(diagnosticsHandler).addProgramFiles(inputs).setIntermediate(intermediate).setMode(options.contains(Option.NO_OPTIMIZE) ? CompilationMode.DEBUG : CompilationMode.RELEASE).setOutputPath(output);
      D8Output d8Output=com.android.tools.r8.D8.run(builder.build());
      if (outputToDex) {
        File[] outputs=output.toFile().listFiles();
        if (outputs != null && (outputs.length > 0)) {
          Files.move(outputs[0].toPath(),outputDexFile,StandardCopyOption.REPLACE_EXISTING);
        }
      }
      resourcesReferencedInCode=d8Output.getReferencedResources();
      return 0;
    }
 catch (    CompilationFailedException|IOException e) {
      context.postEvent(ConsoleEvent.severe(String.join(System.lineSeparator(),diagnosticsHandler.diagnostics.stream().map(Diagnostic::getDiagnosticMessage).collect(ImmutableList.toImmutableList()))));
      e.printStackTrace(context.getStdErr());
      return 1;
    }
  }
 else   if (DX.equals(dexTool)) {
    ImmutableList<String> argv=getShellCommandInternal(context);
    Preconditions.checkState(argv.get(0).endsWith(File.separator + ""String_Node_Str"") || argv.get(0).endsWith(""String_Node_Str""));
    Preconditions.checkState(argv.get(1).equals(""String_Node_Str""));
    ImmutableList<String> args=argv.subList(2,argv.size());
    ByteArrayOutputStream stderr=new ByteArrayOutputStream();
    PrintStream stderrStream=new PrintStream(stderr);
    try {
      com.android.dx.command.dexer.DxContext dxContext=new com.android.dx.command.dexer.DxContext(context.getStdOut(),stderrStream);
      com.android.dx.command.dexer.Main.Arguments arguments=new com.android.dx.command.dexer.Main.Arguments();
      com.android.dx.command.dexer.Main dexer=new com.android.dx.command.dexer.Main(dxContext);
      arguments.parseCommandLine(args.toArray(new String[args.size()]),dxContext);
      int returncode=dexer.run(arguments);
      String stdErrOutput=stderr.toString();
      if (!stdErrOutput.isEmpty()) {
        context.postEvent(ConsoleEvent.warning(""String_Node_Str"",stdErrOutput));
      }
      if (returncode == 0) {
        resourcesReferencedInCode=dexer.getReferencedResourceNames();
      }
      return returncode;
    }
 catch (    IOException e) {
      e.printStackTrace(context.getStdErr());
      return 1;
    }
  }
 else {
    return 1;
  }
}","private int executeInProcess(ExecutionContext context){
  if (D8.equals(dexTool)) {
    D8DiagnosticsHandler diagnosticsHandler=new D8DiagnosticsHandler();
    try {
      Set<Path> inputs=new HashSet<>();
      for (      Path rawFile : filesToDex) {
        Path toDex=filesystem.resolve(rawFile);
        if (Files.isRegularFile(toDex)) {
          inputs.add(toDex);
        }
 else {
          Files.newDirectoryStream(toDex,path -> path.toFile().isFile()).forEach(inputs::add);
        }
      }
      boolean outputToDex=outputDexFile.getFileName().toString().endsWith(""String_Node_Str"");
      Path output=outputToDex ? Files.createTempDirectory(""String_Node_Str"") : outputDexFile;
      D8Command.Builder builder=D8Command.builder(diagnosticsHandler).addProgramFiles(inputs).setIntermediate(intermediate).setMode(options.contains(Option.NO_OPTIMIZE) ? CompilationMode.DEBUG : CompilationMode.RELEASE).setOutputPath(output);
      D8Command d8Command=builder.build();
      com.android.tools.r8.D8.run(d8Command);
      if (outputToDex) {
        File[] outputs=output.toFile().listFiles();
        if (outputs != null && (outputs.length > 0)) {
          Files.move(outputs[0].toPath(),outputDexFile,StandardCopyOption.REPLACE_EXISTING);
        }
      }
      resourcesReferencedInCode=d8Command.getDexItemFactory().computeReferencedResources();
      return 0;
    }
 catch (    CompilationFailedException|IOException e) {
      context.postEvent(ConsoleEvent.severe(String.join(System.lineSeparator(),diagnosticsHandler.diagnostics.stream().map(Diagnostic::getDiagnosticMessage).collect(ImmutableList.toImmutableList()))));
      e.printStackTrace(context.getStdErr());
      return 1;
    }
  }
 else   if (DX.equals(dexTool)) {
    ImmutableList<String> argv=getShellCommandInternal(context);
    Preconditions.checkState(argv.get(0).endsWith(File.separator + ""String_Node_Str"") || argv.get(0).endsWith(""String_Node_Str""));
    Preconditions.checkState(argv.get(1).equals(""String_Node_Str""));
    ImmutableList<String> args=argv.subList(2,argv.size());
    ByteArrayOutputStream stderr=new ByteArrayOutputStream();
    PrintStream stderrStream=new PrintStream(stderr);
    try {
      com.android.dx.command.dexer.DxContext dxContext=new com.android.dx.command.dexer.DxContext(context.getStdOut(),stderrStream);
      com.android.dx.command.dexer.Main.Arguments arguments=new com.android.dx.command.dexer.Main.Arguments();
      com.android.dx.command.dexer.Main dexer=new com.android.dx.command.dexer.Main(dxContext);
      arguments.parseCommandLine(args.toArray(new String[args.size()]),dxContext);
      int returncode=dexer.run(arguments);
      String stdErrOutput=stderr.toString();
      if (!stdErrOutput.isEmpty()) {
        context.postEvent(ConsoleEvent.warning(""String_Node_Str"",stdErrOutput));
      }
      if (returncode == 0) {
        resourcesReferencedInCode=dexer.getReferencedResourceNames();
      }
      return returncode;
    }
 catch (    IOException e) {
      e.printStackTrace(context.getStdErr());
      return 1;
    }
  }
 else {
    return 1;
  }
}",0.9808130081300812
52848,"private void writeUmbrellaHeaderIfNeeded(String moduleName,ImmutableSortedSet<Path> headerPaths,Path headerSymlinkTreeRoot) throws IOException {
  ImmutableList<String> headerPathStrings=headerPaths.stream().map(Path::getFileName).map(Path::toString).collect(ImmutableList.toImmutableList());
  if (!headerPaths.contains(moduleName + ""String_Node_Str"")) {
    projectFilesystem.writeContentsToPath(new UmbrellaHeader(moduleName,headerPathStrings).render(),headerSymlinkTreeRoot.resolve(Paths.get(moduleName,moduleName + ""String_Node_Str"")));
  }
}","private void writeUmbrellaHeaderIfNeeded(String moduleName,ImmutableSortedSet<Path> headerPaths,Path headerSymlinkTreeRoot) throws IOException {
  ImmutableList<String> headerPathStrings=headerPaths.stream().map(Path::getFileName).map(Path::toString).collect(ImmutableList.toImmutableList());
  if (!headerPathStrings.contains(moduleName + ""String_Node_Str"")) {
    Path umbrellaPath=headerSymlinkTreeRoot.resolve(Paths.get(moduleName,moduleName + ""String_Node_Str""));
    Preconditions.checkState(!projectFilesystem.exists(umbrellaPath));
    projectFilesystem.writeContentsToPath(new UmbrellaHeader(moduleName,headerPathStrings).render(),umbrellaPath);
  }
}",0.7473073736536868
52849,"private ImmutableMap<BuildTarget,Version> selectVersions(BuildTarget root,ImmutableMap<BuildTarget,ImmutableSet<Version>> domain) throws VersionException {
  TargetNode<?,?> node=targetGraph.get(root);
  ImmutableMap.Builder<BuildTarget,Version> selectedVersions=ImmutableMap.builder();
  Optional<Map.Entry<String,VersionUniverse>> universe=getVersionUniverse(node);
  LOG.verbose(""String_Node_Str"",root,universe);
  for (  Map.Entry<BuildTarget,ImmutableSet<Version>> ent : domain.entrySet()) {
    Version version;
    if (universe.isPresent() && ((version=universe.get().getValue().getVersions().get(ent.getKey())) != null)) {
      if (!ent.getValue().contains(version)) {
        throw new VersionException(root,String.format(""String_Node_Str"",version,ent.getKey(),universe.get().getKey(),Joiner.on(""String_Node_Str"").join(ent.getValue())));
      }
    }
 else {
      version=Iterables.get(ent.getValue(),0);
    }
    selectedVersions.put(ent.getKey(),version);
  }
  return selectedVersions.build();
}","private ImmutableMap<BuildTarget,Version> selectVersions(BuildTarget root,ImmutableMap<BuildTarget,ImmutableSet<Version>> domain) throws VersionException {
  TargetNode<?,?> node=targetGraph.get(root);
  ImmutableMap.Builder<BuildTarget,Version> selectedVersions=ImmutableMap.builder();
  Optional<Map.Entry<String,VersionUniverse>> universe=getVersionUniverse(node);
  LOG.verbose(""String_Node_Str"",root,universe);
  for (  Map.Entry<BuildTarget,ImmutableSet<Version>> ent : domain.entrySet()) {
    Version version;
    if (universe.isPresent() && ((version=universe.get().getValue().getVersions().get(ent.getKey())) != null)) {
      if (!ent.getValue().contains(version)) {
        throw new VersionException(root,String.format(""String_Node_Str"",ent.getKey(),version,universe.get().getKey(),Joiner.on(""String_Node_Str"").join(ent.getValue())));
      }
    }
 else {
      version=Iterables.get(ent.getValue(),0);
    }
    selectedVersions.put(ent.getKey(),version);
  }
  return selectedVersions.build();
}",0.9920870425321464
52850,"private int executeInProcess(ExecutionContext context){
  if (D8.equals(dexTool)) {
    D8DiagnosticsHandler diagnosticsHandler=new D8DiagnosticsHandler();
    try {
      Set<Path> inputs=new HashSet<>();
      for (      Path rawFile : filesToDex) {
        Path toDex=filesystem.resolve(rawFile);
        if (Files.isRegularFile(toDex)) {
          inputs.add(toDex);
        }
 else {
          Files.newDirectoryStream(toDex,path -> path.toFile().isFile()).forEach(inputs::add);
        }
      }
      boolean outputToDex=outputDexFile.getFileName().toString().endsWith(""String_Node_Str"");
      Path output=outputToDex ? Files.createTempDirectory(""String_Node_Str"") : outputDexFile;
      D8Command.Builder builder=D8Command.builder().addProgramFiles(inputs).setIntermediate(intermediate).setMode(options.contains(Option.NO_OPTIMIZE) ? CompilationMode.DEBUG : CompilationMode.RELEASE).setDiagnosticsHandler(diagnosticsHandler).setOutputPath(output);
      D8Output d8Output=com.android.tools.r8.D8.run(builder.build());
      if (outputToDex) {
        File[] outputs=output.toFile().listFiles();
        if (outputs != null && (outputs.length > 0)) {
          Files.move(outputs[0].toPath(),outputDexFile,StandardCopyOption.REPLACE_EXISTING);
        }
      }
      resourcesReferencedInCode=d8Output.getReferencedResources();
      return 0;
    }
 catch (    CompilationException|IOException e) {
      context.postEvent(ConsoleEvent.severe(String.join(System.lineSeparator(),diagnosticsHandler.diagnostics.stream().map(Diagnostic::getDiagnosticMessage).collect(MoreCollectors.toImmutableList()))));
      e.printStackTrace(context.getStdErr());
      return 1;
    }
  }
 else   if (DX.equals(dexTool)) {
    ImmutableList<String> argv=getShellCommandInternal(context);
    Preconditions.checkState(argv.get(0).endsWith(File.separator + ""String_Node_Str"") || argv.get(0).endsWith(""String_Node_Str""));
    Preconditions.checkState(argv.get(1).equals(""String_Node_Str""));
    ImmutableList<String> args=argv.subList(2,argv.size());
    ByteArrayOutputStream stderr=new ByteArrayOutputStream();
    PrintStream stderrStream=new PrintStream(stderr);
    try {
      com.android.dx.command.dexer.DxContext dxContext=new com.android.dx.command.dexer.DxContext(context.getStdOut(),stderrStream);
      com.android.dx.command.dexer.Main.Arguments arguments=new com.android.dx.command.dexer.Main.Arguments();
      com.android.dx.command.dexer.Main dexer=new com.android.dx.command.dexer.Main(dxContext);
      arguments.parseCommandLine(args.toArray(new String[args.size()]),dxContext);
      int returncode=dexer.run(arguments);
      String stdErrOutput=stderr.toString();
      if (!stdErrOutput.isEmpty()) {
        context.postEvent(ConsoleEvent.warning(""String_Node_Str"",stdErrOutput));
      }
      if (returncode == 0) {
        resourcesReferencedInCode=dexer.getReferencedResourceNames();
      }
      return returncode;
    }
 catch (    IOException e) {
      e.printStackTrace(context.getStdErr());
      return 1;
    }
  }
 else {
    return 1;
  }
}","private int executeInProcess(ExecutionContext context){
  if (D8.equals(dexTool)) {
    D8DiagnosticsHandler diagnosticsHandler=new D8DiagnosticsHandler();
    try {
      Set<Path> inputs=new HashSet<>();
      for (      Path rawFile : filesToDex) {
        Path toDex=filesystem.resolve(rawFile);
        if (Files.isRegularFile(toDex)) {
          inputs.add(toDex);
        }
 else {
          Files.newDirectoryStream(toDex,path -> path.toFile().isFile()).forEach(inputs::add);
        }
      }
      boolean outputToDex=outputDexFile.getFileName().toString().endsWith(""String_Node_Str"");
      Path output=outputToDex ? Files.createTempDirectory(""String_Node_Str"") : outputDexFile;
      D8Command.Builder builder=D8Command.builder(diagnosticsHandler).addProgramFiles(inputs).setIntermediate(intermediate).setMode(options.contains(Option.NO_OPTIMIZE) ? CompilationMode.DEBUG : CompilationMode.RELEASE).setOutputPath(output);
      D8Output d8Output=com.android.tools.r8.D8.run(builder.build());
      if (outputToDex) {
        File[] outputs=output.toFile().listFiles();
        if (outputs != null && (outputs.length > 0)) {
          Files.move(outputs[0].toPath(),outputDexFile,StandardCopyOption.REPLACE_EXISTING);
        }
      }
      resourcesReferencedInCode=d8Output.getReferencedResources();
      return 0;
    }
 catch (    CompilationFailedException|IOException e) {
      context.postEvent(ConsoleEvent.severe(String.join(System.lineSeparator(),diagnosticsHandler.diagnostics.stream().map(Diagnostic::getDiagnosticMessage).collect(MoreCollectors.toImmutableList()))));
      e.printStackTrace(context.getStdErr());
      return 1;
    }
  }
 else   if (DX.equals(dexTool)) {
    ImmutableList<String> argv=getShellCommandInternal(context);
    Preconditions.checkState(argv.get(0).endsWith(File.separator + ""String_Node_Str"") || argv.get(0).endsWith(""String_Node_Str""));
    Preconditions.checkState(argv.get(1).equals(""String_Node_Str""));
    ImmutableList<String> args=argv.subList(2,argv.size());
    ByteArrayOutputStream stderr=new ByteArrayOutputStream();
    PrintStream stderrStream=new PrintStream(stderr);
    try {
      com.android.dx.command.dexer.DxContext dxContext=new com.android.dx.command.dexer.DxContext(context.getStdOut(),stderrStream);
      com.android.dx.command.dexer.Main.Arguments arguments=new com.android.dx.command.dexer.Main.Arguments();
      com.android.dx.command.dexer.Main dexer=new com.android.dx.command.dexer.Main(dxContext);
      arguments.parseCommandLine(args.toArray(new String[args.size()]),dxContext);
      int returncode=dexer.run(arguments);
      String stdErrOutput=stderr.toString();
      if (!stdErrOutput.isEmpty()) {
        context.postEvent(ConsoleEvent.warning(""String_Node_Str"",stdErrOutput));
      }
      if (returncode == 0) {
        resourcesReferencedInCode=dexer.getReferencedResourceNames();
      }
      return returncode;
    }
 catch (    IOException e) {
      e.printStackTrace(context.getStdErr());
      return 1;
    }
  }
 else {
    return 1;
  }
}",0.98922624877571
52851,"public BuildRule buildAbi(){
  getLibraryRule();
  BuildRule result=getCompareAbisRule();
  if (result == null) {
    result=getClassAbiRule();
  }
  if (result == null) {
    result=getSourceAbiRule();
  }
  return Preconditions.checkNotNull(result);
}","public BuildRule buildAbi(){
  getLibraryRule();
  BuildTarget requestedTarget=getInitialBuildTarget();
  if (HasJavaAbi.isSourceAbiTarget(requestedTarget)) {
    return getSourceAbiRule();
  }
 else   if (HasJavaAbi.isClassAbiTarget(requestedTarget)) {
    return getClassAbiRule();
  }
 else   if (HasJavaAbi.isVerifiedSourceAbiTarget(requestedTarget)) {
    return getCompareAbisRule();
  }
  throw new AssertionError();
}",0.2625368731563421
52852,"private void buildAllDirectoriesAndSymlinks(){
  Set<Path> deletedDirectories=new HashSet<>();
  Set<Path> absoluteDirectoriesToMake=directoriesToMake.stream().map(Path::toAbsolutePath).collect(Collectors.toSet());
  for (  Path path : existingDirectories) {
    if (!absoluteDirectoriesToMake.contains(path)) {
      if (dryRun) {
        stderr(""String_Node_Str"",path);
      }
 else {
        deleteAll(path);
        deletedDirectories.add(path);
      }
    }
  }
  existingSymlinks.forEach((filePath,linkPath) -> {
    if (linkPath.equals(symlinksToCreate.get(filePath))) {
      symlinksToCreate.remove(filePath);
    }
 else {
      if (dryRun) {
        stderr(""String_Node_Str"",linkPath);
      }
 else {
        try {
          Files.delete(linkPath);
        }
 catch (        IOException e) {
          if (!linkInDeletedDirectories(deletedDirectories,linkPath)) {
            stderr(""String_Node_Str"",e.getClass().getSimpleName(),linkPath);
          }
        }
      }
    }
  }
);
  symlinksToCreate.forEach((filePath,linkPath) -> {
    if (dryRun) {
      stderr(""String_Node_Str"",filePath,linkPath);
    }
 else {
      createSymbolicLink(filePath,linkPath);
    }
  }
);
}","private void buildAllDirectoriesAndSymlinks(){
  Set<Path> deletedDirectories=new HashSet<>();
  Set<Path> absoluteDirectoriesToMake=directoriesToMake.stream().map(Path::toAbsolutePath).collect(Collectors.toSet());
  for (  Path path : existingDirectories) {
    if (!absoluteDirectoriesToMake.contains(path)) {
      if (dryRun) {
        stderr(""String_Node_Str"",path);
      }
 else {
        deleteAll(path);
        deletedDirectories.add(path);
      }
    }
  }
  existingSymlinks.forEach((filePath,linkPath) -> {
    if (linkPath.equals(symlinksToCreate.get(filePath))) {
      symlinksToCreate.remove(filePath);
    }
 else {
      if (dryRun) {
        stderr(""String_Node_Str"",linkPath);
      }
 else {
        try {
          Files.delete(linkPath);
        }
 catch (        IOException e) {
          if (!linkInDeletedDirectories(deletedDirectories,linkPath.toAbsolutePath())) {
            stderr(""String_Node_Str"",e.getClass().getSimpleName(),linkPath);
          }
        }
      }
    }
  }
);
  symlinksToCreate.forEach((filePath,linkPath) -> {
    if (dryRun) {
      stderr(""String_Node_Str"",filePath,linkPath);
    }
 else {
      createSymbolicLink(filePath,linkPath);
    }
  }
);
}",0.9929196168263223
52853,"private Optional<String> unableToFindTargetBuildTools(Path sdkPath){
  return Optional.of(""String_Node_Str"" + targetBuildToolsVersion.get() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ Escaper.escapeAsShellString(sdkPath.resolve(""String_Node_Str"").toString())+ ""String_Node_Str""+ ""String_Node_Str""+ targetBuildToolsVersion.get()+ ""String_Node_Str"");
}","private Optional<String> unableToFindTargetBuildTools(Path sdkPath){
  return Optional.of(""String_Node_Str"" + targetBuildToolsVersion.get() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ Escaper.escapeAsShellString(sdkPath.resolve(""String_Node_Str"").toString())+ ""String_Node_Str""+ targetBuildToolsVersion.get()+ ""String_Node_Str"");
}",0.9732770745428974
52854,"@Nullable private String getOwningTarget(Elements elements,Element element,ImmutableList<HasJavaAbi> classpath){
  TypeElement enclosingType=MoreElements.getTypeElement(element);
  String classFilePath=elements.getBinaryName(enclosingType).toString().replace('.','/') + ""String_Node_Str"";
  for (  HasJavaAbi classpathRule : classpath) {
    if (classpathRule.jarContains(classFilePath)) {
      return classpathRule.getBuildTarget().getUnflavoredBuildTarget().toString();
    }
  }
  return null;
}","@Nullable private String getOwningTarget(Elements elements,Element element,ImmutableList<HasJavaAbi> classpath){
  TypeElement enclosingType=MoreElements.getTypeElement(element);
  String classFilePath=elements.getBinaryName(enclosingType).toString().replace('.',File.separatorChar) + ""String_Node_Str"";
  for (  HasJavaAbi classpathRule : classpath) {
    if (classpathRule.jarContains(classFilePath)) {
      return classpathRule.getBuildTarget().getUnflavoredBuildTarget().toString();
    }
  }
  return null;
}",0.979269496544916
52855,"private GetWorkResponse getWorkUnsafe(GetWorkRequest request){
  LOG.info(String.format(""String_Node_Str"",request.getMinionId(),request.getFinishedTargets().size(),request.getMaxWorkUnitsToFetch()));
  checkBuildId(request.getStampedeId());
  Preconditions.checkArgument(request.isSetMinionId());
  Preconditions.checkArgument(request.isSetLastExitCode());
  GetWorkResponse response=new GetWorkResponse();
  response.setContinueBuilding(true);
  response.setWorkUnits(new ArrayList<>());
synchronized (lock) {
    Preconditions.checkArgument(!exitCodeFuture.isDone());
    if (request.getLastExitCode() != 0) {
      LOG.error(String.format(""String_Node_Str"",request.getMinionId(),request.getLastExitCode()));
      exitCodeFuture.complete(request.getLastExitCode());
      response.setContinueBuilding(false);
      return response;
    }
    List<WorkUnit> newWorkUnitsForMinion=allocator.dequeueZeroDependencyNodes(request.getMinionId(),request.getFinishedTargets(),request.getMaxWorkUnitsToFetch());
    if (allocator.isBuildFinished()) {
      exitCodeFuture.complete(0);
      LOG.info(String.format(""String_Node_Str"",request.minionId));
      response.setContinueBuilding(false);
    }
 else {
      response.setWorkUnits(newWorkUnitsForMinion);
    }
    return response;
  }
}","private GetWorkResponse getWorkUnsafe(GetWorkRequest request){
  LOG.info(String.format(""String_Node_Str"",request.getMinionId(),request.getFinishedTargets().size(),request.getMaxWorkUnitsToFetch()));
  checkBuildId(request.getStampedeId());
  Preconditions.checkArgument(request.isSetMinionId());
  Preconditions.checkArgument(request.isSetLastExitCode());
  GetWorkResponse response=new GetWorkResponse();
  response.setContinueBuilding(true);
  response.setWorkUnits(new ArrayList<>());
synchronized (lock) {
    if (exitCodeFuture.isDone()) {
      response.setContinueBuilding(false);
      return response;
    }
    if (request.getLastExitCode() != 0) {
      LOG.error(String.format(""String_Node_Str"",request.getMinionId(),request.getLastExitCode()));
      exitCodeFuture.complete(request.getLastExitCode());
      response.setContinueBuilding(false);
      return response;
    }
    List<WorkUnit> newWorkUnitsForMinion=allocator.dequeueZeroDependencyNodes(request.getMinionId(),request.getFinishedTargets(),request.getMaxWorkUnitsToFetch());
    if (allocator.isBuildFinished()) {
      exitCodeFuture.complete(0);
      LOG.info(String.format(""String_Node_Str"",request.minionId));
      response.setContinueBuilding(false);
    }
 else {
      response.setWorkUnits(newWorkUnitsForMinion);
    }
    return response;
  }
}",0.9587786259541984
52856,"@Test public void testThriftServerWithDiamondGraph() throws IOException, NoSuchBuildTargetException {
  int port=findRandomOpenPortOnAllLocalInterfaces();
  BuildTargetsQueue diamondQueue=BuildTargetsQueueTest.createDiamondDependencyQueue();
  ThriftCoordinatorServer.EventListener eventListener=EasyMock.createMock(ThriftCoordinatorServer.EventListener.class);
  eventListener.onThriftServerStarted(EasyMock.anyString(),EasyMock.eq(port));
  EasyMock.expectLastCall().once();
  eventListener.onThriftServerClosing(0);
  EasyMock.expectLastCall().once();
  EasyMock.replay(eventListener);
  try (ThriftCoordinatorServer server=createCoordinatorServer(port,diamondQueue,eventListener);ThriftCoordinatorClient client=new ThriftCoordinatorClient(""String_Node_Str"",port,STAMPEDE_ID)){
    server.start();
    client.start();
    GetWorkResponse responseOne=client.getWork(MINION_ID,0,ImmutableList.of(),MAX_WORK_UNITS_TO_FETCH);
    Assert.assertEquals(responseOne.getWorkUnitsSize(),1);
    Assert.assertTrue(responseOne.isContinueBuilding());
    GetWorkResponse responseTwo=client.getWork(MINION_ID,0,ImmutableList.of(BuildTargetsQueueTest.LEAF_TARGET),MAX_WORK_UNITS_TO_FETCH);
    Assert.assertEquals(responseTwo.getWorkUnitsSize(),2);
    Assert.assertTrue(responseTwo.isContinueBuilding());
    GetWorkResponse responseThree=client.getWork(MINION_ID,0,ImmutableList.of(BuildTargetsQueueTest.LEFT_TARGET,BuildTargetsQueueTest.RIGHT_TARGET),MAX_WORK_UNITS_TO_FETCH);
    Assert.assertEquals(responseThree.getWorkUnitsSize(),1);
    Assert.assertTrue(responseThree.isContinueBuilding());
    GetWorkResponse responseFour=client.getWork(MINION_ID,0,ImmutableList.of(BuildTargetsQueueTest.TARGET_NAME),MAX_WORK_UNITS_TO_FETCH);
    Assert.assertEquals(responseFour.getWorkUnitsSize(),0);
    Assert.assertFalse(responseFour.isContinueBuilding());
  }
   EasyMock.verify(eventListener);
}","@Test public void testThriftServerWithDiamondGraph() throws IOException, NoSuchBuildTargetException {
  int port=findRandomOpenPortOnAllLocalInterfaces();
  BuildTargetsQueue diamondQueue=BuildTargetsQueueTest.createDiamondDependencyQueue();
  ThriftCoordinatorServer.EventListener eventListener=EasyMock.createMock(ThriftCoordinatorServer.EventListener.class);
  eventListener.onThriftServerStarted(EasyMock.anyString(),EasyMock.eq(port));
  EasyMock.expectLastCall().once();
  eventListener.onThriftServerClosing(0);
  EasyMock.expectLastCall().once();
  EasyMock.replay(eventListener);
  try (ThriftCoordinatorServer server=createCoordinatorServer(port,diamondQueue,eventListener);ThriftCoordinatorClient client=new ThriftCoordinatorClient(""String_Node_Str"",port,STAMPEDE_ID)){
    server.start();
    client.start();
    GetWorkResponse responseOne=client.getWork(MINION_ID,0,ImmutableList.of(),MAX_WORK_UNITS_TO_FETCH);
    Assert.assertEquals(responseOne.getWorkUnitsSize(),1);
    Assert.assertTrue(responseOne.isContinueBuilding());
    GetWorkResponse responseTwo=client.getWork(MINION_ID,0,ImmutableList.of(BuildTargetsQueueTest.LEAF_TARGET),MAX_WORK_UNITS_TO_FETCH);
    Assert.assertEquals(responseTwo.getWorkUnitsSize(),2);
    Assert.assertTrue(responseTwo.isContinueBuilding());
    GetWorkResponse responseThree=client.getWork(MINION_ID,0,ImmutableList.of(BuildTargetsQueueTest.LEFT_TARGET,BuildTargetsQueueTest.RIGHT_TARGET),MAX_WORK_UNITS_TO_FETCH);
    Assert.assertEquals(responseThree.getWorkUnitsSize(),1);
    Assert.assertTrue(responseThree.isContinueBuilding());
    GetWorkResponse responseFour=client.getWork(MINION_ID,0,ImmutableList.of(BuildTargetsQueueTest.TARGET_NAME),MAX_WORK_UNITS_TO_FETCH);
    Assert.assertEquals(responseFour.getWorkUnitsSize(),0);
    Assert.assertFalse(responseFour.isContinueBuilding());
    GetWorkResponse responseFive=client.getWork(MINION_ID,0,ImmutableList.of(BuildTargetsQueueTest.TARGET_NAME),MAX_WORK_UNITS_TO_FETCH);
    Assert.assertEquals(responseFive.getWorkUnitsSize(),0);
    Assert.assertFalse(responseFive.isContinueBuilding());
  }
   EasyMock.verify(eventListener);
}",0.9361807797367768
52857,"private void buildAllDirectoriesAndSymlinks(){
  Set<Path> deletedDirectories=new HashSet<>();
  for (  Path path : existingDirectories) {
    if (!directoriesToMake.contains(path)) {
      if (dryRun) {
        stderr(""String_Node_Str"",path);
      }
 else {
        deleteAll(path);
        deletedDirectories.add(path);
      }
    }
  }
  existingSymlinks.forEach((filePath,linkPath) -> {
    if (linkPath.equals(symlinksToCreate.get(filePath))) {
      symlinksToCreate.remove(filePath);
    }
 else {
      if (dryRun) {
        stderr(""String_Node_Str"",linkPath);
      }
 else {
        try {
          Files.delete(linkPath);
        }
 catch (        IOException e) {
          if (!linkInDeletedDirectories(deletedDirectories,linkPath)) {
            stderr(""String_Node_Str"",e.getMessage(),linkPath);
          }
        }
      }
    }
  }
);
  symlinksToCreate.forEach((filePath,linkPath) -> {
    if (dryRun) {
      stderr(""String_Node_Str"",filePath,linkPath);
    }
 else {
      createSymbolicLink(filePath,linkPath);
    }
  }
);
}","private void buildAllDirectoriesAndSymlinks(){
  Set<Path> deletedDirectories=new HashSet<>();
  Set<Path> absoluteDirectoriesToMake=directoriesToMake.stream().map(Path::toAbsolutePath).collect(Collectors.toSet());
  for (  Path path : existingDirectories) {
    if (!absoluteDirectoriesToMake.contains(path)) {
      if (dryRun) {
        stderr(""String_Node_Str"",path);
      }
 else {
        deleteAll(path);
        deletedDirectories.add(path);
      }
    }
  }
  existingSymlinks.forEach((filePath,linkPath) -> {
    if (linkPath.equals(symlinksToCreate.get(filePath))) {
      symlinksToCreate.remove(filePath);
    }
 else {
      if (dryRun) {
        stderr(""String_Node_Str"",linkPath);
      }
 else {
        try {
          Files.delete(linkPath);
        }
 catch (        IOException e) {
          if (!linkInDeletedDirectories(deletedDirectories,linkPath)) {
            stderr(""String_Node_Str"",e.getClass().getSimpleName(),linkPath);
          }
        }
      }
    }
  }
);
  symlinksToCreate.forEach((filePath,linkPath) -> {
    if (dryRun) {
      stderr(""String_Node_Str"",filePath,linkPath);
    }
 else {
      createSymbolicLink(filePath,linkPath);
    }
  }
);
}",0.9313113291703836
52858,"private void createWorkUnitsStartingAtNodes(Set<EnqueuedTarget> nodes,List<WorkUnit> newUnitsOfWork,int maxUnitsOfWork){
  for (  EnqueuedTarget node : nodes) {
    if (newUnitsOfWork.size() == maxUnitsOfWork) {
      return;
    }
    if (node.partOfBuildingUnitOfWork) {
      continue;
    }
    LOG.debug(String.format(""String_Node_Str"",node.getBuildTarget()));
    newUnitsOfWork.add(getUnitOfWorkStartingAtLeafNode(node));
  }
}","private void createWorkUnitsStartingAtNodes(Set<EnqueuedTarget> nodes,List<WorkUnit> newUnitsOfWork,int maxUnitsOfWork){
  for (  EnqueuedTarget node : nodes) {
    if (newUnitsOfWork.size() >= maxUnitsOfWork) {
      return;
    }
    if (node.partOfBuildingUnitOfWork) {
      continue;
    }
    LOG.debug(String.format(""String_Node_Str"",node.getBuildTarget()));
    newUnitsOfWork.add(getUnitOfWorkStartingAtLeafNode(node));
  }
}",0.9976958525345622
52859,"/** 
 * Returns nodes that have all their dependencies satisfied. 
 */
public List<WorkUnit> dequeueZeroDependencyNodes(List<String> finishedNodes,int maxUnitsOfWork){
  LOG.info(String.format(""String_Node_Str"",finishedNodes.size(),maxUnitsOfWork));
  processFinishedNodes(finishedNodes);
  if (maxUnitsOfWork == 0) {
    return Lists.newArrayList();
  }
  List<WorkUnit> newUnitsOfWork=new ArrayList<>();
  createWorkUnitsStartingAtNodes(new HashSet<>(zeroDependencyTargets),newUnitsOfWork,maxUnitsOfWork);
  if (newUnitsOfWork.size() > 0) {
    LOG.info(String.format(""String_Node_Str"",newUnitsOfWork.size()));
  }
  return Lists.newArrayList(newUnitsOfWork);
}","/** 
 * Returns nodes that have all their dependencies satisfied. 
 */
public List<WorkUnit> dequeueZeroDependencyNodes(List<String> finishedNodes,int maxUnitsOfWork){
  Preconditions.checkArgument(maxUnitsOfWork >= 0);
  LOG.info(String.format(""String_Node_Str"",finishedNodes.size(),maxUnitsOfWork));
  processFinishedNodes(finishedNodes);
  if (maxUnitsOfWork == 0) {
    return Lists.newArrayList();
  }
  List<WorkUnit> newUnitsOfWork=new ArrayList<>();
  createWorkUnitsStartingAtNodes(new HashSet<>(zeroDependencyTargets),newUnitsOfWork,maxUnitsOfWork);
  if (newUnitsOfWork.size() > 0) {
    LOG.info(String.format(""String_Node_Str"",newUnitsOfWork.size()));
  }
  return Lists.newArrayList(newUnitsOfWork);
}",0.9622641509433962
52860,"/** 
 * Once a target has been built and uploaded to the cache, it is now safe to signal to the coordinator that the target is finished.
 * @param target
 */
public synchronized void recordUploadedTarget(String target){
  finishedTargetsToSignal.add(target);
}","/** 
 * Once a target has been built and uploaded to the cache, it is now safe to signal to the coordinator that the target is finished.
 * @param target
 */
public synchronized void recordUploadedTarget(String target){
  Preconditions.checkArgument(knownTargets.contains(target));
  Preconditions.checkArgument(!uploadedTargets.contains(target));
  uploadedTargets.add(target);
  uploadedTargetsToSignal.add(target);
}",0.748159057437408
52861,"/** 
 * @return Targets that have finished building at minion that need to be signalled to coordinator.
 */
public synchronized List<String> getTargetsToSignal(){
  List<String> targets=Lists.newArrayList(finishedTargetsToSignal);
  finishedTargetsToSignal.clear();
  return targets;
}","/** 
 * @return Targets that have finished building at minion that need to be signalled to coordinator.
 */
public synchronized List<String> getTargetsToSignal(){
  List<String> targets=Lists.newArrayList(uploadedTargetsToSignal);
  uploadedTargetsToSignal.clear();
  return targets;
}",0.9578947368421052
52862,"/** 
 * @param newWorkUnits Work Units that have just been fetched from the coordinator 
 */
public synchronized void enqueueWorkUnitsForBuilding(List<WorkUnit> newWorkUnits){
  for (  WorkUnit workUnit : newWorkUnits) {
    List<String> buildTargetsInWorkUnit=workUnit.getBuildTargets();
    Preconditions.checkArgument(buildTargetsInWorkUnit.size() > 0);
    recordTerminalTarget(buildTargetsInWorkUnit);
    workUnitsToBuild.add(workUnit);
  }
  LOG.info(String.format(""String_Node_Str"",newWorkUnits.size()));
}","/** 
 * @param newWorkUnits Work Units that have just been fetched from the coordinator 
 */
public synchronized void enqueueWorkUnitsForBuilding(List<WorkUnit> newWorkUnits){
  if (newWorkUnits.size() == 0) {
    return;
  }
  for (  WorkUnit workUnit : newWorkUnits) {
    List<String> buildTargetsInWorkUnit=workUnit.getBuildTargets();
    Preconditions.checkArgument(buildTargetsInWorkUnit.size() > 0);
    recordTerminalTarget(buildTargetsInWorkUnit);
    workUnitsToBuild.add(workUnit);
  }
  availableWorkUnitCapacity-=newWorkUnits.size();
  LOG.info(String.format(""String_Node_Str"",newWorkUnits.size(),availableWorkUnitCapacity));
}",0.8908145580589255
52863,"/** 
 * @return Targets that minion should build, extracted from queued work units. 
 */
public synchronized List<String> getTargetsToBuild(){
  List<String> targetsToBuild=Lists.newArrayList();
  for (  WorkUnit workUnit : workUnitsToBuild) {
    targetsToBuild.addAll(workUnit.getBuildTargets());
  }
  LOG.debug(String.format(""String_Node_Str"",targetsToBuild.size(),workUnitsToBuild.size()));
  availableWorkUnitCapacity-=workUnitsToBuild.size();
  workUnitsToBuild.clear();
  return targetsToBuild;
}","/** 
 * @return Targets that minion should build, extracted from queued work units. 
 */
public synchronized List<String> getTargetsToBuild(){
  List<String> targetsToBuild=Lists.newArrayList();
  for (  WorkUnit workUnit : workUnitsToBuild) {
    targetsToBuild.addAll(workUnit.getBuildTargets());
  }
  knownTargets.addAll(targetsToBuild);
  LOG.debug(String.format(""String_Node_Str"",targetsToBuild.size(),workUnitsToBuild.size()));
  workUnitsToBuild.clear();
  return targetsToBuild;
}",0.8721047331319235
52864,"/** 
 * Increases available capacity if the given target was at the end of a work unit.
 * @param target
 */
public synchronized void recordFinishedTarget(String target){
  if (!workUnitTerminalTargets.contains(target)) {
    return;
  }
  availableWorkUnitCapacity++;
  workUnitTerminalTargets.remove(target);
}","/** 
 * Increases available capacity if the given target was at the end of a work unit.
 * @param target
 */
public synchronized void recordFinishedTarget(String target){
  Preconditions.checkArgument(knownTargets.contains(target));
  Preconditions.checkArgument(!finishedTargets.contains(target));
  finishedTargets.add(target);
  if (!workUnitTerminalTargets.contains(target)) {
    return;
  }
  availableWorkUnitCapacity++;
  workUnitTerminalTargets.remove(target);
}",0.7969348659003831
52865,"public void removeRule(SupportsPipelining<?> rule){
  rules.remove(rule);
}","/** 
 * Removes a rule from pipeline eligibility. If a pipeline is already running the rule, waits for it to complete before returning.
 */
public void removeRule(SupportsPipelining<?> rule){
  BuildRulePipelineStage<? extends RulePipelineState> pipelineStage=rules.remove(rule);
  if (pipelineStage != null && pipelineStage.pipelineBuilt()) {
    pipelineStage.cancelAndWait();
  }
}",0.326797385620915
52866,"private PBXNativeTarget generateBinaryTarget(PBXProject project,Optional<? extends TargetNode<? extends HasAppleBundleFields,?>> bundle,TargetNode<? extends CxxLibraryDescription.CommonArg,?> targetNode,ProductType productType,String productOutputFormat,Optional<Path> infoPlistOptional,boolean includeFrameworks,ImmutableSet<AppleResourceDescriptionArg> recursiveResources,ImmutableSet<AppleResourceDescriptionArg> directResources,ImmutableSet<AppleAssetCatalogDescriptionArg> recursiveAssetCatalogs,ImmutableSet<AppleAssetCatalogDescriptionArg> directAssetCatalogs,ImmutableSet<AppleWrapperResourceArg> wrapperResources,Optional<Iterable<PBXBuildPhase>> copyFilesPhases,Optional<TargetNode<AppleBundleDescriptionArg,?>> bundleLoaderNode) throws IOException {
  LOG.debug(""String_Node_Str"",targetNode);
  TargetNode<?,?> buildTargetNode=bundle.isPresent() ? bundle.get() : targetNode;
  final BuildTarget buildTarget=buildTargetNode.getBuildTarget();
  final boolean containsSwiftCode=projGenerationStateCache.targetContainsSwiftSourceCode(targetNode);
  String buildTargetName=getProductNameForBuildTargetNode(buildTargetNode);
  CxxLibraryDescription.CommonArg arg=targetNode.getConstructorArg();
  NewNativeTargetProjectMutator mutator=new NewNativeTargetProjectMutator(pathRelativizer,this::resolveSourcePath);
  ImmutableSet<SourcePath> exportedHeaders=ImmutableSet.copyOf(getHeaderSourcePaths(arg.getExportedHeaders()));
  ImmutableSet<SourcePath> headers=ImmutableSet.copyOf(getHeaderSourcePaths(arg.getHeaders()));
  ImmutableMap<CxxSource.Type,ImmutableList<StringWithMacros>> langPreprocessorFlags=targetNode.getConstructorArg().getLangPreprocessorFlags();
  boolean isFocusedOnTarget=focusModules.isFocusedOn(buildTarget);
  Optional<String> swiftVersion=(arg instanceof SwiftCommonArg) ? ((SwiftCommonArg)arg).getSwiftVersion() : Optional.empty();
  final boolean hasSwiftVersionArg=swiftVersion.isPresent();
  if (!swiftVersion.isPresent()) {
    swiftVersion=swiftBuckConfig.getVersion();
  }
  mutator.setTargetName(getXcodeTargetName(buildTarget)).setProduct(productType,buildTargetName,Paths.get(String.format(productOutputFormat,buildTargetName)));
  boolean isModularAppleLibrary=isModularAppleLibrary(targetNode) && isFocusedOnTarget;
  mutator.setFrameworkHeadersEnabled(isModularAppleLibrary);
  if (!shouldGenerateHeaderSymlinkTreesOnly()) {
    if (isFocusedOnTarget) {
      mutator.setLangPreprocessorFlags(ImmutableMap.copyOf(Maps.transformValues(langPreprocessorFlags,f -> convertStringWithMacros(targetNode,f)))).setPublicHeaders(exportedHeaders).setPrefixHeader(getPrefixHeaderSourcePath(arg)).setSourcesWithFlags(ImmutableSet.copyOf(arg.getSrcs())).setPrivateHeaders(headers).setRecursiveResources(recursiveResources).setDirectResources(directResources).setWrapperResources(wrapperResources).setExtraXcodeSources(ImmutableSet.copyOf(arg.getExtraXcodeSources())).setExtraXcodeFiles(ImmutableSet.copyOf(arg.getExtraXcodeFiles()));
    }
    if (bundle.isPresent() && isFocusedOnTarget) {
      HasAppleBundleFields bundleArg=bundle.get().getConstructorArg();
      mutator.setInfoPlist(Optional.of(bundleArg.getInfoPlist()));
    }
    mutator.setBridgingHeader(arg.getBridgingHeader());
    if (options.contains(Option.CREATE_DIRECTORY_STRUCTURE) && isFocusedOnTarget) {
      mutator.setTargetGroupPath(RichStream.from(buildTarget.getBasePath()).map(Object::toString).toImmutableList());
    }
    if (!recursiveAssetCatalogs.isEmpty() && isFocusedOnTarget) {
      mutator.setRecursiveAssetCatalogs(recursiveAssetCatalogs);
    }
    if (!directAssetCatalogs.isEmpty() && isFocusedOnTarget) {
      mutator.setDirectAssetCatalogs(directAssetCatalogs);
    }
    if (includeFrameworks && isFocusedOnTarget) {
      ImmutableSet.Builder<FrameworkPath> frameworksBuilder=ImmutableSet.builder();
      frameworksBuilder.addAll(targetNode.getConstructorArg().getFrameworks());
      frameworksBuilder.addAll(targetNode.getConstructorArg().getLibraries());
      frameworksBuilder.addAll(collectRecursiveFrameworkDependencies(targetNode));
      mutator.setFrameworks(frameworksBuilder.build());
      ImmutableSet<PBXFileReference> targetNodeDeps=collectRecursiveLibraryDependencies(targetNode);
      ImmutableSet<PBXFileReference> excludedDeps=targetNode.castArg(AppleTestDescriptionArg.class).flatMap(testNode -> {
        return testNode.getConstructorArg().getIsUiTest() ? Optional.empty() : bundleLoaderNode;
      }
).map(this::collectRecursiveLibraryDependencies).orElse(ImmutableSet.of());
      mutator.setArchives(Sets.difference(targetNodeDeps,excludedDeps));
    }
    if (!includeFrameworks && isFocusedOnTarget) {
      ImmutableSet<PBXFileReference> swiftDeps=collectRecursiveLibraryDependenciesWithSwiftSources(targetNode);
      if (!swiftDeps.isEmpty()) {
        CopyFilePhaseDestinationSpec.Builder destSpecBuilder=CopyFilePhaseDestinationSpec.builder();
        destSpecBuilder.setDestination(PBXCopyFilesBuildPhase.Destination.PRODUCTS);
        PBXCopyFilesBuildPhase copyFiles=new PBXCopyFilesBuildPhase(destSpecBuilder.build());
        copyFiles.setRunOnlyForDeploymentPostprocessing(Optional.of(Boolean.TRUE));
        copyFiles.setName(Optional.of(""String_Node_Str""));
        for (        PBXFileReference fileRef : swiftDeps) {
          PBXBuildFile buildFile=new PBXBuildFile(fileRef);
          copyFiles.getFiles().add(buildFile);
        }
        mutator.setSwiftDependenciesBuildPhase(copyFiles);
      }
    }
    ImmutableList.Builder<TargetNode<?,?>> preScriptPhasesBuilder=ImmutableList.builder();
    ImmutableList.Builder<TargetNode<?,?>> postScriptPhasesBuilder=ImmutableList.builder();
    if (bundle.isPresent() && targetNode != bundle.get() && isFocusedOnTarget) {
      collectBuildScriptDependencies(targetGraph.getAll(bundle.get().getDeclaredDeps()),preScriptPhasesBuilder,postScriptPhasesBuilder);
    }
    collectBuildScriptDependencies(targetGraph.getAll(targetNode.getDeclaredDeps()),preScriptPhasesBuilder,postScriptPhasesBuilder);
    if (isFocusedOnTarget) {
      ImmutableList<TargetNode<?,?>> preScriptPhases=preScriptPhasesBuilder.build();
      ImmutableList<TargetNode<?,?>> postScriptPhases=postScriptPhasesBuilder.build();
      mutator.setPreBuildRunScriptPhasesFromTargetNodes(preScriptPhases,buildRuleResolverForNode);
      if (copyFilesPhases.isPresent()) {
        mutator.setCopyFilesPhases(copyFilesPhases.get());
      }
      mutator.setPostBuildRunScriptPhasesFromTargetNodes(postScriptPhases,buildRuleResolverForNode);
      ImmutableList<TargetNode<?,?>> scriptPhases=Stream.concat(preScriptPhases.stream(),postScriptPhases.stream()).collect(MoreCollectors.toImmutableList());
      mutator.collectFilesToCopyInXcode(filesToCopyInXcodeBuilder,scriptPhases,projectCell,buildRuleResolverForNode);
    }
  }
  NewNativeTargetProjectMutator.Result targetBuilderResult=mutator.buildTargetAndAddToProject(project,isFocusedOnTarget);
  PBXNativeTarget target=targetBuilderResult.target;
  Optional<PBXGroup> targetGroup=targetBuilderResult.targetGroup;
  ImmutableMap.Builder<String,String> extraSettingsBuilder=ImmutableMap.builder();
  ImmutableMap.Builder<String,String> defaultSettingsBuilder=ImmutableMap.builder();
  ImmutableSortedMap<Path,SourcePath> publicCxxHeaders=getPublicCxxHeaders(targetNode);
  if (isModularAppleLibrary(targetNode) && isFrameworkProductType(productType)) {
    publicCxxHeaders=ImmutableSortedMap.of();
  }
  if (!shouldGenerateHeaderSymlinkTreesOnly()) {
    if (isFocusedOnTarget) {
      SourceTreePath buckFilePath=new SourceTreePath(PBXReference.SourceTree.SOURCE_ROOT,pathRelativizer.outputPathToBuildTargetPath(buildTarget).resolve(buildFileName),Optional.empty());
      PBXFileReference buckReference=targetGroup.get().getOrCreateFileReferenceBySourceTreePath(buckFilePath);
      buckReference.setExplicitFileType(Optional.of(""String_Node_Str""));
    }
    extraSettingsBuilder.put(""String_Node_Str"",buildTargetName).put(""String_Node_Str"",pathRelativizer.outputPathToBuildTargetPath(buildTarget).toString());
    if (productType == ProductType.UI_TEST && isFocusedOnTarget) {
      if (bundleLoaderNode.isPresent()) {
        BuildTarget testTarget=bundleLoaderNode.get().getBuildTarget();
        extraSettingsBuilder.put(""String_Node_Str"",getXcodeTargetName(testTarget));
        addPBXTargetDependency(target,testTarget);
      }
 else {
        throw new HumanReadableException(""String_Node_Str"",buildTargetName);
      }
    }
 else     if (bundleLoaderNode.isPresent() && isFocusedOnTarget) {
      TargetNode<AppleBundleDescriptionArg,?> bundleLoader=bundleLoaderNode.get();
      String bundleLoaderProductName=getProductName(bundleLoader);
      String bundleLoaderBundleName=bundleLoaderProductName + ""String_Node_Str"" + getExtensionString(bundleLoader.getConstructorArg().getExtension());
      String bundleLoaderOutputPathConditional=""String_Node_Str"";
      String bundleLoaderOutputPathDeepSetting=""String_Node_Str"";
      String bundleLoaderOutputPathDeepValue=""String_Node_Str"";
      String bundleLoaderOutputPathValue=Joiner.on('/').join(getTargetOutputPath(bundleLoader),bundleLoaderBundleName,bundleLoaderOutputPathConditional,bundleLoaderProductName);
      extraSettingsBuilder.put(bundleLoaderOutputPathDeepSetting,bundleLoaderOutputPathDeepValue).put(""String_Node_Str"",bundleLoaderOutputPathValue).put(""String_Node_Str"",""String_Node_Str"");
      addPBXTargetDependency(target,bundleLoader.getBuildTarget());
    }
    if (infoPlistOptional.isPresent()) {
      Path infoPlistPath=pathRelativizer.outputDirToRootRelative(infoPlistOptional.get());
      extraSettingsBuilder.put(""String_Node_Str"",infoPlistPath.toString());
    }
    if (arg.getBridgingHeader().isPresent()) {
      Path bridgingHeaderPath=pathRelativizer.outputDirToRootRelative(resolveSourcePath(arg.getBridgingHeader().get()));
      extraSettingsBuilder.put(""String_Node_Str"",Joiner.on('/').join(""String_Node_Str"",bridgingHeaderPath.toString()));
    }
    swiftVersion.ifPresent(s -> extraSettingsBuilder.put(""String_Node_Str"",s));
    if (hasSwiftVersionArg && containsSwiftCode && isFocusedOnTarget) {
      extraSettingsBuilder.put(""String_Node_Str"",getSwiftObjCGeneratedHeaderName(buildTargetNode));
    }
    Optional<SourcePath> prefixHeaderOptional=getPrefixHeaderSourcePath(targetNode.getConstructorArg());
    if (prefixHeaderOptional.isPresent()) {
      Path prefixHeaderRelative=resolveSourcePath(prefixHeaderOptional.get());
      Path prefixHeaderPath=pathRelativizer.outputDirToRootRelative(prefixHeaderRelative);
      extraSettingsBuilder.put(""String_Node_Str"",prefixHeaderPath.toString());
      extraSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
    }
    boolean shouldSetUseHeadermap=false;
    if (isModularAppleLibrary) {
      extraSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
      extraSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
      if (isFrameworkProductType(productType)) {
        shouldSetUseHeadermap=true;
      }
    }
    extraSettingsBuilder.put(""String_Node_Str"",shouldSetUseHeadermap ? ""String_Node_Str"" : ""String_Node_Str"");
    defaultSettingsBuilder.put(""String_Node_Str"",projectFilesystem.getRootPath().toAbsolutePath().normalize().toString());
    if (hasSwiftVersionArg && containsSwiftCode && isFocusedOnTarget) {
      Path derivedSourcesDir=getDerivedSourcesDirectoryForBuildTarget(buildTarget,projectFilesystem);
      Path derivedSourceDirRelativeToProjectRoot=getRelativeToProjectPathForTargetNode(targetNode,derivedSourcesDir);
      defaultSettingsBuilder.put(""String_Node_Str"",derivedSourceDirRelativeToProjectRoot.toString());
    }
    defaultSettingsBuilder.put(PRODUCT_NAME,getProductName(buildTargetNode));
    bundle.ifPresent(bundleNode -> defaultSettingsBuilder.put(""String_Node_Str"",getExtensionString(bundleNode.getConstructorArg().getExtension())));
    defaultSettingsBuilder.put(""String_Node_Str"",Joiner.on('/').join(""String_Node_Str"",""String_Node_Str""));
    defaultSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
    boolean nodeIsAppleLibrary=targetNode.getDescription() instanceof AppleLibraryDescription;
    boolean nodeIsCxxLibrary=targetNode.getDescription() instanceof CxxLibraryDescription;
    if (!bundle.isPresent() && (nodeIsAppleLibrary || nodeIsCxxLibrary)) {
      defaultSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
    }
    if (isFocusedOnTarget) {
      ImmutableSet<Path> recursiveHeaderSearchPaths=collectRecursiveHeaderSearchPaths(targetNode);
      ImmutableSet<Path> headerMapBases=recursiveHeaderSearchPaths.isEmpty() ? ImmutableSet.of() : ImmutableSet.of(pathRelativizer.outputDirToRootRelative(buildTargetNode.getFilesystem().getBuckPaths().getBuckOut()));
      ImmutableMap.Builder<String,String> appendConfigsBuilder=ImmutableMap.builder();
      appendConfigsBuilder.putAll(getFrameworkAndLibrarySearchPathConfigs(targetNode,includeFrameworks));
      appendConfigsBuilder.put(""String_Node_Str"",Joiner.on(' ').join(Iterables.concat(recursiveHeaderSearchPaths,headerMapBases)));
      if (hasSwiftVersionArg && containsSwiftCode && isFocusedOnTarget) {
        appendConfigsBuilder.put(""String_Node_Str"",""String_Node_Str"");
      }
      ImmutableList.Builder<String> targetSpecificSwiftFlags=ImmutableList.builder();
      Optional<TargetNode<SwiftCommonArg,?>> swiftTargetNode=targetNode.castArg(SwiftCommonArg.class);
      targetSpecificSwiftFlags.addAll(swiftTargetNode.map(x -> convertStringWithMacros(targetNode,x.getConstructorArg().getSwiftCompilerFlags())).orElse(ImmutableList.of()));
      if (containsSwiftCode && isModularAppleLibrary && publicCxxHeaders.size() > 0) {
        targetSpecificSwiftFlags.add(""String_Node_Str"");
      }
      Iterable<String> otherSwiftFlags=Iterables.concat(swiftBuckConfig.getCompilerFlags().orElse(DEFAULT_SWIFTFLAGS),targetSpecificSwiftFlags.build());
      Iterable<String> otherCFlags=Iterables.concat(cxxBuckConfig.getFlags(""String_Node_Str"").orElse(DEFAULT_CFLAGS),convertStringWithMacros(targetNode,collectRecursiveExportedPreprocessorFlags(targetNode)),convertStringWithMacros(targetNode,targetNode.getConstructorArg().getCompilerFlags()),convertStringWithMacros(targetNode,targetNode.getConstructorArg().getPreprocessorFlags()));
      Iterable<String> otherCxxFlags=Iterables.concat(cxxBuckConfig.getFlags(""String_Node_Str"").orElse(DEFAULT_CXXFLAGS),convertStringWithMacros(targetNode,collectRecursiveExportedPreprocessorFlags(targetNode)),convertStringWithMacros(targetNode,targetNode.getConstructorArg().getCompilerFlags()),convertStringWithMacros(targetNode,targetNode.getConstructorArg().getPreprocessorFlags()));
      ImmutableList<String> otherLdFlags=convertStringWithMacros(targetNode,Iterables.concat(targetNode.getConstructorArg().getLinkerFlags(),collectRecursiveExportedLinkerFlags(targetNode)));
      appendConfigsBuilder.put(""String_Node_Str"",Joiner.on(' ').join(Iterables.transform(otherSwiftFlags,Escaper.BASH_ESCAPER))).put(""String_Node_Str"",Joiner.on(' ').join(Iterables.transform(otherCFlags,Escaper.BASH_ESCAPER))).put(""String_Node_Str"",Joiner.on(' ').join(Iterables.transform(otherCxxFlags,Escaper.BASH_ESCAPER))).put(""String_Node_Str"",Joiner.on(' ').join(Iterables.transform(otherLdFlags,Escaper.BASH_ESCAPER)));
      ImmutableMultimap.Builder<String,ImmutableList<String>> platformFlagsBuilder=ImmutableMultimap.builder();
      for (      Pair<Pattern,ImmutableList<StringWithMacros>> flags : Iterables.concat(targetNode.getConstructorArg().getPlatformCompilerFlags().getPatternsAndValues(),targetNode.getConstructorArg().getPlatformPreprocessorFlags().getPatternsAndValues(),collectRecursiveExportedPlatformPreprocessorFlags(targetNode))) {
        String sdk=flags.getFirst().pattern().replaceAll(""String_Node_Str"",""String_Node_Str"");
        platformFlagsBuilder.put(sdk,convertStringWithMacros(targetNode,flags.getSecond()));
      }
      ImmutableMultimap<String,ImmutableList<String>> platformFlags=platformFlagsBuilder.build();
      for (      String sdk : platformFlags.keySet()) {
        appendConfigsBuilder.put(String.format(""String_Node_Str"",sdk),Joiner.on(' ').join(Iterables.transform(Iterables.concat(otherCFlags,Iterables.concat(platformFlags.get(sdk))),Escaper.BASH_ESCAPER))).put(String.format(""String_Node_Str"",sdk),Joiner.on(' ').join(Iterables.transform(Iterables.concat(otherCxxFlags,Iterables.concat(platformFlags.get(sdk))),Escaper.BASH_ESCAPER)));
      }
      ImmutableMultimap.Builder<String,ImmutableList<String>> platformLinkerFlagsBuilder=ImmutableMultimap.builder();
      for (      Pair<Pattern,ImmutableList<StringWithMacros>> flags : Iterables.concat(targetNode.getConstructorArg().getPlatformLinkerFlags().getPatternsAndValues(),collectRecursiveExportedPlatformLinkerFlags(targetNode))) {
        String sdk=flags.getFirst().pattern().replaceAll(""String_Node_Str"",""String_Node_Str"");
        platformLinkerFlagsBuilder.put(sdk,convertStringWithMacros(targetNode,flags.getSecond()));
      }
      ImmutableMultimap<String,ImmutableList<String>> platformLinkerFlags=platformLinkerFlagsBuilder.build();
      for (      String sdk : platformLinkerFlags.keySet()) {
        appendConfigsBuilder.put(String.format(""String_Node_Str"",sdk),Joiner.on(' ').join(Iterables.transform(Iterables.concat(otherLdFlags,Iterables.concat(platformLinkerFlags.get(sdk))),Escaper.BASH_ESCAPER)));
      }
      ImmutableMap<String,String> appendedConfig=appendConfigsBuilder.build();
      Optional<ImmutableSortedMap<String,ImmutableMap<String,String>>> configs=getXcodeBuildConfigurationsForTargetNode(targetNode,appendedConfig);
      setTargetBuildConfigurations(buildTarget,target,project.getMainGroup(),configs.get(),extraSettingsBuilder.build(),defaultSettingsBuilder.build(),appendedConfig);
    }
  }
  createHeaderSymlinkTree(publicCxxHeaders,getSwiftPublicHeaderMapEntriesForTarget(targetNode,isFocusedOnTarget,hasSwiftVersionArg),getPathToHeaderSymlinkTree(targetNode,HeaderVisibility.PUBLIC),arg.getXcodePublicHeadersSymlinks().orElse(cxxBuckConfig.getPublicHeadersSymlinksEnabled()) || isHeaderMapDisabled(),!shouldMergeHeaderMaps());
  if (isFocusedOnTarget) {
    createHeaderSymlinkTree(getPrivateCxxHeaders(targetNode),ImmutableMap.of(),getPathToHeaderSymlinkTree(targetNode,HeaderVisibility.PRIVATE),arg.getXcodePrivateHeadersSymlinks().orElse(cxxBuckConfig.getPrivateHeadersSymlinksEnabled()) || isHeaderMapDisabled(),!isHeaderMapDisabled());
  }
  if (shouldMergeHeaderMaps() && isMainProject) {
    createMergedHeaderMap();
  }
  Optional<TargetNode<AppleNativeTargetDescriptionArg,?>> appleTargetNode=targetNode.castArg(AppleNativeTargetDescriptionArg.class);
  if (appleTargetNode.isPresent() && isFocusedOnTarget && !shouldGenerateHeaderSymlinkTreesOnly()) {
    addCoreDataModelsIntoTarget(appleTargetNode.get(),targetGroup.get());
    addSceneKitAssetsIntoTarget(appleTargetNode.get(),targetGroup.get());
  }
  if (bundle.isPresent() && isFocusedOnTarget && !shouldGenerateHeaderSymlinkTreesOnly()) {
    addEntitlementsPlistIntoTarget(bundle.get(),targetGroup.get());
  }
  return target;
}","private PBXNativeTarget generateBinaryTarget(PBXProject project,Optional<? extends TargetNode<? extends HasAppleBundleFields,?>> bundle,TargetNode<? extends CxxLibraryDescription.CommonArg,?> targetNode,ProductType productType,String productOutputFormat,Optional<Path> infoPlistOptional,boolean includeFrameworks,ImmutableSet<AppleResourceDescriptionArg> recursiveResources,ImmutableSet<AppleResourceDescriptionArg> directResources,ImmutableSet<AppleAssetCatalogDescriptionArg> recursiveAssetCatalogs,ImmutableSet<AppleAssetCatalogDescriptionArg> directAssetCatalogs,ImmutableSet<AppleWrapperResourceArg> wrapperResources,Optional<Iterable<PBXBuildPhase>> copyFilesPhases,Optional<TargetNode<AppleBundleDescriptionArg,?>> bundleLoaderNode) throws IOException {
  LOG.debug(""String_Node_Str"",targetNode);
  TargetNode<?,?> buildTargetNode=bundle.isPresent() ? bundle.get() : targetNode;
  final BuildTarget buildTarget=buildTargetNode.getBuildTarget();
  final boolean containsSwiftCode=projGenerationStateCache.targetContainsSwiftSourceCode(targetNode);
  String buildTargetName=getProductNameForBuildTargetNode(buildTargetNode);
  CxxLibraryDescription.CommonArg arg=targetNode.getConstructorArg();
  NewNativeTargetProjectMutator mutator=new NewNativeTargetProjectMutator(pathRelativizer,this::resolveSourcePath);
  ImmutableSet<SourcePath> exportedHeaders=ImmutableSet.copyOf(getHeaderSourcePaths(arg.getExportedHeaders()));
  ImmutableSet<SourcePath> headers=ImmutableSet.copyOf(getHeaderSourcePaths(arg.getHeaders()));
  ImmutableMap<CxxSource.Type,ImmutableList<StringWithMacros>> langPreprocessorFlags=targetNode.getConstructorArg().getLangPreprocessorFlags();
  boolean isFocusedOnTarget=focusModules.isFocusedOn(buildTarget);
  Optional<String> swiftVersion=(arg instanceof SwiftCommonArg) ? ((SwiftCommonArg)arg).getSwiftVersion() : Optional.empty();
  final boolean hasSwiftVersionArg=swiftVersion.isPresent();
  if (!swiftVersion.isPresent()) {
    swiftVersion=swiftBuckConfig.getVersion();
  }
  mutator.setTargetName(getXcodeTargetName(buildTarget)).setProduct(productType,buildTargetName,Paths.get(String.format(productOutputFormat,buildTargetName)));
  boolean isModularAppleLibrary=isModularAppleLibrary(targetNode) && isFocusedOnTarget;
  mutator.setFrameworkHeadersEnabled(isModularAppleLibrary);
  Optional<ImmutableMap<String,String>> swiftDepsSettings=Optional.empty();
  if (!shouldGenerateHeaderSymlinkTreesOnly()) {
    if (isFocusedOnTarget) {
      mutator.setLangPreprocessorFlags(ImmutableMap.copyOf(Maps.transformValues(langPreprocessorFlags,f -> convertStringWithMacros(targetNode,f)))).setPublicHeaders(exportedHeaders).setPrefixHeader(getPrefixHeaderSourcePath(arg)).setSourcesWithFlags(ImmutableSet.copyOf(arg.getSrcs())).setPrivateHeaders(headers).setRecursiveResources(recursiveResources).setDirectResources(directResources).setWrapperResources(wrapperResources).setExtraXcodeSources(ImmutableSet.copyOf(arg.getExtraXcodeSources())).setExtraXcodeFiles(ImmutableSet.copyOf(arg.getExtraXcodeFiles()));
    }
    if (bundle.isPresent() && isFocusedOnTarget) {
      HasAppleBundleFields bundleArg=bundle.get().getConstructorArg();
      mutator.setInfoPlist(Optional.of(bundleArg.getInfoPlist()));
    }
    mutator.setBridgingHeader(arg.getBridgingHeader());
    if (options.contains(Option.CREATE_DIRECTORY_STRUCTURE) && isFocusedOnTarget) {
      mutator.setTargetGroupPath(RichStream.from(buildTarget.getBasePath()).map(Object::toString).toImmutableList());
    }
    if (!recursiveAssetCatalogs.isEmpty() && isFocusedOnTarget) {
      mutator.setRecursiveAssetCatalogs(recursiveAssetCatalogs);
    }
    if (!directAssetCatalogs.isEmpty() && isFocusedOnTarget) {
      mutator.setDirectAssetCatalogs(directAssetCatalogs);
    }
    if (includeFrameworks && isFocusedOnTarget) {
      ImmutableSet.Builder<FrameworkPath> frameworksBuilder=ImmutableSet.builder();
      frameworksBuilder.addAll(targetNode.getConstructorArg().getFrameworks());
      frameworksBuilder.addAll(targetNode.getConstructorArg().getLibraries());
      frameworksBuilder.addAll(collectRecursiveFrameworkDependencies(targetNode));
      mutator.setFrameworks(frameworksBuilder.build());
      ImmutableSet<PBXFileReference> targetNodeDeps=collectRecursiveLibraryDependencies(targetNode);
      ImmutableSet<PBXFileReference> excludedDeps=targetNode.castArg(AppleTestDescriptionArg.class).flatMap(testNode -> {
        return testNode.getConstructorArg().getIsUiTest() ? Optional.empty() : bundleLoaderNode;
      }
).map(this::collectRecursiveLibraryDependencies).orElse(ImmutableSet.of());
      mutator.setArchives(Sets.difference(targetNodeDeps,excludedDeps));
    }
    if (!includeFrameworks && isFocusedOnTarget) {
      ImmutableSet<PBXFileReference> swiftDeps=collectRecursiveLibraryDependenciesWithSwiftSources(targetNode);
      if (!swiftDeps.isEmpty()) {
        CopyFilePhaseDestinationSpec.Builder destSpecBuilder=CopyFilePhaseDestinationSpec.builder();
        destSpecBuilder.setDestination(PBXCopyFilesBuildPhase.Destination.PRODUCTS);
        PBXCopyFilesBuildPhase copyFiles=new PBXCopyFilesBuildPhase(destSpecBuilder.build());
        copyFiles.setRunOnlyForDeploymentPostprocessing(Optional.of(Boolean.TRUE));
        copyFiles.setName(Optional.of(""String_Node_Str""));
        for (        PBXFileReference fileRef : swiftDeps) {
          PBXBuildFile buildFile=new PBXBuildFile(fileRef);
          copyFiles.getFiles().add(buildFile);
        }
        swiftDepsSettings=Optional.of(ImmutableMap.of(""String_Node_Str"",""String_Node_Str""));
        mutator.setSwiftDependenciesBuildPhase(copyFiles);
      }
    }
    ImmutableList.Builder<TargetNode<?,?>> preScriptPhasesBuilder=ImmutableList.builder();
    ImmutableList.Builder<TargetNode<?,?>> postScriptPhasesBuilder=ImmutableList.builder();
    if (bundle.isPresent() && targetNode != bundle.get() && isFocusedOnTarget) {
      collectBuildScriptDependencies(targetGraph.getAll(bundle.get().getDeclaredDeps()),preScriptPhasesBuilder,postScriptPhasesBuilder);
    }
    collectBuildScriptDependencies(targetGraph.getAll(targetNode.getDeclaredDeps()),preScriptPhasesBuilder,postScriptPhasesBuilder);
    if (isFocusedOnTarget) {
      ImmutableList<TargetNode<?,?>> preScriptPhases=preScriptPhasesBuilder.build();
      ImmutableList<TargetNode<?,?>> postScriptPhases=postScriptPhasesBuilder.build();
      mutator.setPreBuildRunScriptPhasesFromTargetNodes(preScriptPhases,buildRuleResolverForNode);
      if (copyFilesPhases.isPresent()) {
        mutator.setCopyFilesPhases(copyFilesPhases.get());
      }
      mutator.setPostBuildRunScriptPhasesFromTargetNodes(postScriptPhases,buildRuleResolverForNode);
      ImmutableList<TargetNode<?,?>> scriptPhases=Stream.concat(preScriptPhases.stream(),postScriptPhases.stream()).collect(MoreCollectors.toImmutableList());
      mutator.collectFilesToCopyInXcode(filesToCopyInXcodeBuilder,scriptPhases,projectCell,buildRuleResolverForNode);
    }
  }
  NewNativeTargetProjectMutator.Result targetBuilderResult=mutator.buildTargetAndAddToProject(project,isFocusedOnTarget);
  PBXNativeTarget target=targetBuilderResult.target;
  Optional<PBXGroup> targetGroup=targetBuilderResult.targetGroup;
  ImmutableMap.Builder<String,String> extraSettingsBuilder=ImmutableMap.builder();
  ImmutableMap.Builder<String,String> defaultSettingsBuilder=ImmutableMap.builder();
  swiftDepsSettings.ifPresent(settings -> extraSettingsBuilder.putAll(settings));
  ImmutableSortedMap<Path,SourcePath> publicCxxHeaders=getPublicCxxHeaders(targetNode);
  if (isModularAppleLibrary(targetNode) && isFrameworkProductType(productType)) {
    publicCxxHeaders=ImmutableSortedMap.of();
  }
  if (!shouldGenerateHeaderSymlinkTreesOnly()) {
    if (isFocusedOnTarget) {
      SourceTreePath buckFilePath=new SourceTreePath(PBXReference.SourceTree.SOURCE_ROOT,pathRelativizer.outputPathToBuildTargetPath(buildTarget).resolve(buildFileName),Optional.empty());
      PBXFileReference buckReference=targetGroup.get().getOrCreateFileReferenceBySourceTreePath(buckFilePath);
      buckReference.setExplicitFileType(Optional.of(""String_Node_Str""));
    }
    extraSettingsBuilder.put(""String_Node_Str"",buildTargetName).put(""String_Node_Str"",pathRelativizer.outputPathToBuildTargetPath(buildTarget).toString());
    if (productType == ProductType.UI_TEST && isFocusedOnTarget) {
      if (bundleLoaderNode.isPresent()) {
        BuildTarget testTarget=bundleLoaderNode.get().getBuildTarget();
        extraSettingsBuilder.put(""String_Node_Str"",getXcodeTargetName(testTarget));
        addPBXTargetDependency(target,testTarget);
      }
 else {
        throw new HumanReadableException(""String_Node_Str"",buildTargetName);
      }
    }
 else     if (bundleLoaderNode.isPresent() && isFocusedOnTarget) {
      TargetNode<AppleBundleDescriptionArg,?> bundleLoader=bundleLoaderNode.get();
      String bundleLoaderProductName=getProductName(bundleLoader);
      String bundleLoaderBundleName=bundleLoaderProductName + ""String_Node_Str"" + getExtensionString(bundleLoader.getConstructorArg().getExtension());
      String bundleLoaderOutputPathConditional=""String_Node_Str"";
      String bundleLoaderOutputPathDeepSetting=""String_Node_Str"";
      String bundleLoaderOutputPathDeepValue=""String_Node_Str"";
      String bundleLoaderOutputPathValue=Joiner.on('/').join(getTargetOutputPath(bundleLoader),bundleLoaderBundleName,bundleLoaderOutputPathConditional,bundleLoaderProductName);
      extraSettingsBuilder.put(bundleLoaderOutputPathDeepSetting,bundleLoaderOutputPathDeepValue).put(""String_Node_Str"",bundleLoaderOutputPathValue).put(""String_Node_Str"",""String_Node_Str"");
      addPBXTargetDependency(target,bundleLoader.getBuildTarget());
    }
    if (infoPlistOptional.isPresent()) {
      Path infoPlistPath=pathRelativizer.outputDirToRootRelative(infoPlistOptional.get());
      extraSettingsBuilder.put(""String_Node_Str"",infoPlistPath.toString());
    }
    if (arg.getBridgingHeader().isPresent()) {
      Path bridgingHeaderPath=pathRelativizer.outputDirToRootRelative(resolveSourcePath(arg.getBridgingHeader().get()));
      extraSettingsBuilder.put(""String_Node_Str"",Joiner.on('/').join(""String_Node_Str"",bridgingHeaderPath.toString()));
    }
    swiftVersion.ifPresent(s -> extraSettingsBuilder.put(""String_Node_Str"",s));
    if (hasSwiftVersionArg && containsSwiftCode && isFocusedOnTarget) {
      extraSettingsBuilder.put(""String_Node_Str"",getSwiftObjCGeneratedHeaderName(buildTargetNode));
    }
    Optional<SourcePath> prefixHeaderOptional=getPrefixHeaderSourcePath(targetNode.getConstructorArg());
    if (prefixHeaderOptional.isPresent()) {
      Path prefixHeaderRelative=resolveSourcePath(prefixHeaderOptional.get());
      Path prefixHeaderPath=pathRelativizer.outputDirToRootRelative(prefixHeaderRelative);
      extraSettingsBuilder.put(""String_Node_Str"",prefixHeaderPath.toString());
      extraSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
    }
    boolean shouldSetUseHeadermap=false;
    if (isModularAppleLibrary) {
      extraSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
      extraSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
      if (isFrameworkProductType(productType)) {
        shouldSetUseHeadermap=true;
      }
    }
    extraSettingsBuilder.put(""String_Node_Str"",shouldSetUseHeadermap ? ""String_Node_Str"" : ""String_Node_Str"");
    defaultSettingsBuilder.put(""String_Node_Str"",projectFilesystem.getRootPath().toAbsolutePath().normalize().toString());
    if (hasSwiftVersionArg && containsSwiftCode && isFocusedOnTarget) {
      Path derivedSourcesDir=getDerivedSourcesDirectoryForBuildTarget(buildTarget,projectFilesystem);
      Path derivedSourceDirRelativeToProjectRoot=getRelativeToProjectPathForTargetNode(targetNode,derivedSourcesDir);
      defaultSettingsBuilder.put(""String_Node_Str"",derivedSourceDirRelativeToProjectRoot.toString());
    }
    defaultSettingsBuilder.put(PRODUCT_NAME,getProductName(buildTargetNode));
    bundle.ifPresent(bundleNode -> defaultSettingsBuilder.put(""String_Node_Str"",getExtensionString(bundleNode.getConstructorArg().getExtension())));
    defaultSettingsBuilder.put(""String_Node_Str"",Joiner.on('/').join(""String_Node_Str"",""String_Node_Str""));
    defaultSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
    boolean nodeIsAppleLibrary=targetNode.getDescription() instanceof AppleLibraryDescription;
    boolean nodeIsCxxLibrary=targetNode.getDescription() instanceof CxxLibraryDescription;
    if (!bundle.isPresent() && (nodeIsAppleLibrary || nodeIsCxxLibrary)) {
      defaultSettingsBuilder.put(""String_Node_Str"",""String_Node_Str"");
    }
    if (isFocusedOnTarget) {
      ImmutableSet<Path> recursiveHeaderSearchPaths=collectRecursiveHeaderSearchPaths(targetNode);
      ImmutableSet<Path> headerMapBases=recursiveHeaderSearchPaths.isEmpty() ? ImmutableSet.of() : ImmutableSet.of(pathRelativizer.outputDirToRootRelative(buildTargetNode.getFilesystem().getBuckPaths().getBuckOut()));
      ImmutableMap.Builder<String,String> appendConfigsBuilder=ImmutableMap.builder();
      appendConfigsBuilder.putAll(getFrameworkAndLibrarySearchPathConfigs(targetNode,includeFrameworks));
      appendConfigsBuilder.put(""String_Node_Str"",Joiner.on(' ').join(Iterables.concat(recursiveHeaderSearchPaths,headerMapBases)));
      if (hasSwiftVersionArg && containsSwiftCode && isFocusedOnTarget) {
        appendConfigsBuilder.put(""String_Node_Str"",""String_Node_Str"");
      }
      ImmutableList.Builder<String> targetSpecificSwiftFlags=ImmutableList.builder();
      Optional<TargetNode<SwiftCommonArg,?>> swiftTargetNode=targetNode.castArg(SwiftCommonArg.class);
      targetSpecificSwiftFlags.addAll(swiftTargetNode.map(x -> convertStringWithMacros(targetNode,x.getConstructorArg().getSwiftCompilerFlags())).orElse(ImmutableList.of()));
      if (containsSwiftCode && isModularAppleLibrary && publicCxxHeaders.size() > 0) {
        targetSpecificSwiftFlags.add(""String_Node_Str"");
      }
      Iterable<String> otherSwiftFlags=Iterables.concat(swiftBuckConfig.getCompilerFlags().orElse(DEFAULT_SWIFTFLAGS),targetSpecificSwiftFlags.build());
      Iterable<String> otherCFlags=Iterables.concat(cxxBuckConfig.getFlags(""String_Node_Str"").orElse(DEFAULT_CFLAGS),convertStringWithMacros(targetNode,collectRecursiveExportedPreprocessorFlags(targetNode)),convertStringWithMacros(targetNode,targetNode.getConstructorArg().getCompilerFlags()),convertStringWithMacros(targetNode,targetNode.getConstructorArg().getPreprocessorFlags()));
      Iterable<String> otherCxxFlags=Iterables.concat(cxxBuckConfig.getFlags(""String_Node_Str"").orElse(DEFAULT_CXXFLAGS),convertStringWithMacros(targetNode,collectRecursiveExportedPreprocessorFlags(targetNode)),convertStringWithMacros(targetNode,targetNode.getConstructorArg().getCompilerFlags()),convertStringWithMacros(targetNode,targetNode.getConstructorArg().getPreprocessorFlags()));
      ImmutableList<String> otherLdFlags=convertStringWithMacros(targetNode,Iterables.concat(targetNode.getConstructorArg().getLinkerFlags(),collectRecursiveExportedLinkerFlags(targetNode)));
      appendConfigsBuilder.put(""String_Node_Str"",Joiner.on(' ').join(Iterables.transform(otherSwiftFlags,Escaper.BASH_ESCAPER))).put(""String_Node_Str"",Joiner.on(' ').join(Iterables.transform(otherCFlags,Escaper.BASH_ESCAPER))).put(""String_Node_Str"",Joiner.on(' ').join(Iterables.transform(otherCxxFlags,Escaper.BASH_ESCAPER))).put(""String_Node_Str"",Joiner.on(' ').join(Iterables.transform(otherLdFlags,Escaper.BASH_ESCAPER)));
      ImmutableMultimap.Builder<String,ImmutableList<String>> platformFlagsBuilder=ImmutableMultimap.builder();
      for (      Pair<Pattern,ImmutableList<StringWithMacros>> flags : Iterables.concat(targetNode.getConstructorArg().getPlatformCompilerFlags().getPatternsAndValues(),targetNode.getConstructorArg().getPlatformPreprocessorFlags().getPatternsAndValues(),collectRecursiveExportedPlatformPreprocessorFlags(targetNode))) {
        String sdk=flags.getFirst().pattern().replaceAll(""String_Node_Str"",""String_Node_Str"");
        platformFlagsBuilder.put(sdk,convertStringWithMacros(targetNode,flags.getSecond()));
      }
      ImmutableMultimap<String,ImmutableList<String>> platformFlags=platformFlagsBuilder.build();
      for (      String sdk : platformFlags.keySet()) {
        appendConfigsBuilder.put(String.format(""String_Node_Str"",sdk),Joiner.on(' ').join(Iterables.transform(Iterables.concat(otherCFlags,Iterables.concat(platformFlags.get(sdk))),Escaper.BASH_ESCAPER))).put(String.format(""String_Node_Str"",sdk),Joiner.on(' ').join(Iterables.transform(Iterables.concat(otherCxxFlags,Iterables.concat(platformFlags.get(sdk))),Escaper.BASH_ESCAPER)));
      }
      ImmutableMultimap.Builder<String,ImmutableList<String>> platformLinkerFlagsBuilder=ImmutableMultimap.builder();
      for (      Pair<Pattern,ImmutableList<StringWithMacros>> flags : Iterables.concat(targetNode.getConstructorArg().getPlatformLinkerFlags().getPatternsAndValues(),collectRecursiveExportedPlatformLinkerFlags(targetNode))) {
        String sdk=flags.getFirst().pattern().replaceAll(""String_Node_Str"",""String_Node_Str"");
        platformLinkerFlagsBuilder.put(sdk,convertStringWithMacros(targetNode,flags.getSecond()));
      }
      ImmutableMultimap<String,ImmutableList<String>> platformLinkerFlags=platformLinkerFlagsBuilder.build();
      for (      String sdk : platformLinkerFlags.keySet()) {
        appendConfigsBuilder.put(String.format(""String_Node_Str"",sdk),Joiner.on(' ').join(Iterables.transform(Iterables.concat(otherLdFlags,Iterables.concat(platformLinkerFlags.get(sdk))),Escaper.BASH_ESCAPER)));
      }
      ImmutableMap<String,String> appendedConfig=appendConfigsBuilder.build();
      Optional<ImmutableSortedMap<String,ImmutableMap<String,String>>> configs=getXcodeBuildConfigurationsForTargetNode(targetNode,appendedConfig);
      setTargetBuildConfigurations(buildTarget,target,project.getMainGroup(),configs.get(),extraSettingsBuilder.build(),defaultSettingsBuilder.build(),appendedConfig);
    }
  }
  createHeaderSymlinkTree(publicCxxHeaders,getSwiftPublicHeaderMapEntriesForTarget(targetNode,isFocusedOnTarget,hasSwiftVersionArg),getPathToHeaderSymlinkTree(targetNode,HeaderVisibility.PUBLIC),arg.getXcodePublicHeadersSymlinks().orElse(cxxBuckConfig.getPublicHeadersSymlinksEnabled()) || isHeaderMapDisabled(),!shouldMergeHeaderMaps());
  if (isFocusedOnTarget) {
    createHeaderSymlinkTree(getPrivateCxxHeaders(targetNode),ImmutableMap.of(),getPathToHeaderSymlinkTree(targetNode,HeaderVisibility.PRIVATE),arg.getXcodePrivateHeadersSymlinks().orElse(cxxBuckConfig.getPrivateHeadersSymlinksEnabled()) || isHeaderMapDisabled(),!isHeaderMapDisabled());
  }
  if (shouldMergeHeaderMaps() && isMainProject) {
    createMergedHeaderMap();
  }
  Optional<TargetNode<AppleNativeTargetDescriptionArg,?>> appleTargetNode=targetNode.castArg(AppleNativeTargetDescriptionArg.class);
  if (appleTargetNode.isPresent() && isFocusedOnTarget && !shouldGenerateHeaderSymlinkTreesOnly()) {
    addCoreDataModelsIntoTarget(appleTargetNode.get(),targetGroup.get());
    addSceneKitAssetsIntoTarget(appleTargetNode.get(),targetGroup.get());
  }
  if (bundle.isPresent() && isFocusedOnTarget && !shouldGenerateHeaderSymlinkTreesOnly()) {
    addEntitlementsPlistIntoTarget(bundle.get(),targetGroup.get());
  }
  return target;
}",0.993480011429462
52867,"@Test public void testSwiftDependencyBuildPhase() throws IOException {
  BuildTarget fooBuildTarget=BuildTargetFactory.newInstance(rootPath,""String_Node_Str"",""String_Node_Str"");
  BuildTarget barBuildTarget=BuildTargetFactory.newInstance(rootPath,""String_Node_Str"",""String_Node_Str"");
  TargetNode<?,?> fooNode=AppleLibraryBuilder.createBuilder(fooBuildTarget).setConfigs(ImmutableSortedMap.of(""String_Node_Str"",ImmutableMap.of())).setSrcs(ImmutableSortedSet.of(SourceWithFlags.of(FakeSourcePath.of(""String_Node_Str"")))).setSwiftVersion(Optional.of(""String_Node_Str"")).setXcodePublicHeadersSymlinks(false).setXcodePrivateHeadersSymlinks(false).build();
  TargetNode<?,?> barNode=AppleLibraryBuilder.createBuilder(barBuildTarget).setConfigs(ImmutableSortedMap.of(""String_Node_Str"",ImmutableMap.of())).setSrcs(ImmutableSortedSet.of(SourceWithFlags.of(FakeSourcePath.of(""String_Node_Str"")))).setDeps(ImmutableSortedSet.of(fooBuildTarget)).setSwiftVersion(Optional.of(""String_Node_Str"")).setXcodePublicHeadersSymlinks(false).setXcodePrivateHeadersSymlinks(false).build();
  ImmutableSet.Builder<ProjectGenerator.Option> optionsBuilder=ImmutableSet.builder();
  ImmutableSet<ProjectGenerator.Option> projectGeneratorOptions=optionsBuilder.build();
  ProjectGenerator projectGenerator=createProjectGeneratorForCombinedProject(ImmutableSet.of(fooNode,barNode),projectGeneratorOptions);
  projectGenerator.createXcodeProjects();
  PBXProject pbxProject=projectGenerator.getGeneratedProject();
  PBXTarget pbxTarget=assertTargetExistsAndReturnTarget(pbxProject,""String_Node_Str"");
  ImmutableSet<PBXBuildPhase> fakeDepPhases=FluentIterable.from(pbxTarget.getBuildPhases()).filter(phase -> {
    return phase.getName().equals(Optional.of(""String_Node_Str""));
  }
).toSet();
  assertThat(fakeDepPhases.size(),equalTo(1));
}","@Test public void testSwiftDependencyBuildPhase() throws IOException {
  BuildTarget fooBuildTarget=BuildTargetFactory.newInstance(rootPath,""String_Node_Str"",""String_Node_Str"");
  BuildTarget barBuildTarget=BuildTargetFactory.newInstance(rootPath,""String_Node_Str"",""String_Node_Str"");
  TargetNode<?,?> fooNode=AppleLibraryBuilder.createBuilder(fooBuildTarget).setConfigs(ImmutableSortedMap.of(""String_Node_Str"",ImmutableMap.of())).setSrcs(ImmutableSortedSet.of(SourceWithFlags.of(FakeSourcePath.of(""String_Node_Str"")))).setSwiftVersion(Optional.of(""String_Node_Str"")).setXcodePublicHeadersSymlinks(false).setXcodePrivateHeadersSymlinks(false).build();
  TargetNode<?,?> barNode=AppleLibraryBuilder.createBuilder(barBuildTarget).setConfigs(ImmutableSortedMap.of(""String_Node_Str"",ImmutableMap.of())).setSrcs(ImmutableSortedSet.of(SourceWithFlags.of(FakeSourcePath.of(""String_Node_Str"")))).setDeps(ImmutableSortedSet.of(fooBuildTarget)).setSwiftVersion(Optional.of(""String_Node_Str"")).setXcodePublicHeadersSymlinks(false).setXcodePrivateHeadersSymlinks(false).build();
  ImmutableSet.Builder<ProjectGenerator.Option> optionsBuilder=ImmutableSet.builder();
  ImmutableSet<ProjectGenerator.Option> projectGeneratorOptions=optionsBuilder.build();
  ProjectGenerator projectGenerator=createProjectGeneratorForCombinedProject(ImmutableSet.of(fooNode,barNode),projectGeneratorOptions);
  projectGenerator.createXcodeProjects();
  PBXProject pbxProject=projectGenerator.getGeneratedProject();
  PBXTarget pbxTarget=assertTargetExistsAndReturnTarget(pbxProject,""String_Node_Str"");
  ImmutableSet<PBXBuildPhase> fakeDepPhases=FluentIterable.from(pbxTarget.getBuildPhases()).filter(phase -> {
    return phase.getName().equals(Optional.of(""String_Node_Str""));
  }
).toSet();
  assertThat(fakeDepPhases.size(),equalTo(1));
  ImmutableMap<String,String> buildSettings=getBuildSettings(barBuildTarget,pbxTarget,""String_Node_Str"");
  assertThat(buildSettings.get(""String_Node_Str""),equalTo(""String_Node_Str""));
}",0.951430821737989
52868,"public CoordinatorAndMinionInfoSetter(DistBuildService service,StampedeId stampedeId,String minionQueue){
  this.service=service;
  this.stampedeId=stampedeId;
  this.minionQueue=minionQueue;
}","public CoordinatorAndMinionInfoSetter(DistBuildService service,StampedeId stampedeId,String minionQueue,boolean islocalMinionAlsoRunning){
  this.service=service;
  this.stampedeId=stampedeId;
  this.minionQueue=minionQueue;
  this.islocalMinionAlsoRunning=islocalMinionAlsoRunning;
}",0.8092243186582809
52869,"@Override public void onThriftServerStarted(String address,int port) throws IOException {
  service.setCoordinator(stampedeId,port,address);
  BuildJob buildJob=service.getCurrentBuildJobState(stampedeId);
  Preconditions.checkArgument(buildJob.isSetBuildModeInfo());
  BuildModeInfo buildModeInfo=buildJob.getBuildModeInfo();
  if (buildModeInfo.isSetNumberOfMinions() && buildModeInfo.getNumberOfMinions() > 0) {
    service.enqueueMinions(stampedeId,buildModeInfo.getNumberOfMinions(),minionQueue);
  }
}","@Override public void onThriftServerStarted(String address,int port) throws IOException {
  service.setCoordinator(stampedeId,port,address);
  BuildJob buildJob=service.getCurrentBuildJobState(stampedeId);
  Preconditions.checkArgument(buildJob.isSetBuildModeInfo());
  BuildModeInfo buildModeInfo=buildJob.getBuildModeInfo();
  if (!buildModeInfo.isSetNumberOfMinions()) {
    return;
  }
  int requiredNumberOfMinions=islocalMinionAlsoRunning ? buildModeInfo.getNumberOfMinions() - 1 : buildModeInfo.getNumberOfMinions();
  if (requiredNumberOfMinions > 0) {
    service.enqueueMinions(stampedeId,requiredNumberOfMinions,minionQueue);
  }
}",0.8181026979982594
52870,"public int buildAndReturnExitCode() throws IOException, InterruptedException {
  LocalBuilder localBuilder=new LocalBuilderImpl();
  DistBuildModeRunner runner=null;
switch (args.getDistBuildMode()) {
case REMOTE_BUILD:
    runner=new RemoteBuildModeRunner(localBuilder,args.getState().getRemoteState().getTopLevelTargets());
  break;
case COORDINATOR:
runner=newCoordinatorMode(getFreePortForCoordinator());
break;
case MINION:
runner=newMinionMode(localBuilder,args.getRemoteCoordinatorAddress(),args.getRemoteCoordinatorPort());
break;
case COORDINATOR_AND_MINION:
int localCoordinatorPort=getFreePortForCoordinator();
runner=new CoordinatorAndMinionModeRunner(newCoordinatorMode(localCoordinatorPort),newMinionMode(localBuilder,LOCALHOST_ADDRESS,localCoordinatorPort));
break;
default :
LOG.error(""String_Node_Str"",args.getDistBuildMode().toString());
return -1;
}
return runner.runAndReturnExitCode();
}","public int buildAndReturnExitCode() throws IOException, InterruptedException {
  LocalBuilder localBuilder=new LocalBuilderImpl();
  DistBuildModeRunner runner=null;
switch (args.getDistBuildMode()) {
case REMOTE_BUILD:
    runner=new RemoteBuildModeRunner(localBuilder,args.getState().getRemoteState().getTopLevelTargets());
  break;
case COORDINATOR:
runner=newCoordinatorMode(getFreePortForCoordinator(),false);
break;
case MINION:
runner=newMinionMode(localBuilder,args.getRemoteCoordinatorAddress(),args.getRemoteCoordinatorPort());
break;
case COORDINATOR_AND_MINION:
int localCoordinatorPort=getFreePortForCoordinator();
runner=new CoordinatorAndMinionModeRunner(newCoordinatorMode(localCoordinatorPort,true),newMinionMode(localBuilder,LOCALHOST_ADDRESS,localCoordinatorPort));
break;
default :
LOG.error(""String_Node_Str"",args.getDistBuildMode().toString());
return -1;
}
return runner.runAndReturnExitCode();
}",0.9939792008757526
52871,"private CoordinatorModeRunner newCoordinatorMode(int coordinatorPort){
  BuildTargetsQueue queue=BuildTargetsQueue.newQueue(Preconditions.checkNotNull(actionGraphAndResolver).getResolver(),fullyQualifiedNameToBuildTarget(args.getState().getRemoteState().getTopLevelTargets()));
  Optional<String> minionQueue=args.getDistBuildConfig().getMinionQueue();
  Preconditions.checkArgument(minionQueue.isPresent(),""String_Node_Str"");
  CoordinatorModeRunner.EventListener listener=new CoordinatorAndMinionInfoSetter(args.getDistBuildService(),args.getStampedeId(),minionQueue.get());
  return new CoordinatorModeRunner(coordinatorPort,queue,args.getStampedeId(),listener,args.getDistBuildConfig().getMaxBuildNodesPerMinion());
}","private CoordinatorModeRunner newCoordinatorMode(int coordinatorPort,boolean isLocalMinionAlsoRunning){
  BuildTargetsQueue queue=BuildTargetsQueue.newQueue(Preconditions.checkNotNull(actionGraphAndResolver).getResolver(),fullyQualifiedNameToBuildTarget(args.getState().getRemoteState().getTopLevelTargets()));
  Optional<String> minionQueue=args.getDistBuildConfig().getMinionQueue();
  Preconditions.checkArgument(minionQueue.isPresent(),""String_Node_Str"");
  CoordinatorModeRunner.EventListener listener=new CoordinatorAndMinionInfoSetter(args.getDistBuildService(),args.getStampedeId(),minionQueue.get(),isLocalMinionAlsoRunning);
  return new CoordinatorModeRunner(coordinatorPort,queue,args.getStampedeId(),listener,args.getDistBuildConfig().getMaxBuildNodesPerMinion());
}",0.9613333333333334
52872,"@Override public int buildSourceAbiJar(Path sourceAbiJar) throws InterruptedException {
  BuckTracing.setCurrentThreadTracingInterfaceFromJsr199Javac(new Jsr199TracingBridge(context.getEventSink(),invokingRule));
  try {
    BuckJavacTaskProxy javacTask=getJavacTask();
    javacTask.addPostEnterCallback(topLevelTypes -> {
      try {
        JarBuilder jarBuilder=newJarBuilder().setShouldHashEntries(true);
        StubGenerator stubGenerator=new StubGenerator(getTargetVersion(options),javacTask.getElements(),javacTask.getMessager(),jarBuilder,context.getEventSink());
        stubGenerator.generate(topLevelTypes);
        jarBuilder.createJarFile(sourceAbiJar);
      }
 catch (      IOException e) {
        throw new HumanReadableException(""String_Node_Str"",e.getMessage());
      }
    }
);
    try {
      javacTask.parse();
      if (buildSuccessful()) {
        javacTask.enter();
      }
    }
 catch (    RuntimeException e) {
      throw new HumanReadableException(String.format(""String_Node_Str"",invokingRule.getUnflavoredBuildTarget().toString()),e);
    }
    frontendRunAttempted=true;
    debugLogDiagnostics();
    if (!buildSuccessful()) {
      reportDiagnosticsToUser();
      return 1;
    }
    return 0;
  }
 catch (  IOException e) {
    LOG.error(e);
    throw new HumanReadableException(""String_Node_Str"",e.getMessage());
  }
 finally {
    BuckTracing.clearCurrentThreadTracingInterfaceFromJsr199Javac();
  }
}","@Override public int buildSourceAbiJar(Path sourceAbiJar) throws InterruptedException {
  BuckTracing.setCurrentThreadTracingInterfaceFromJsr199Javac(new Jsr199TracingBridge(context.getEventSink(),invokingRule));
  try {
    BuckJavacTaskProxy javacTask=getJavacTask();
    javacTask.addPostEnterCallback(topLevelTypes -> {
      try {
        JarBuilder jarBuilder=newJarBuilder().setShouldHashEntries(true);
        StubGenerator stubGenerator=new StubGenerator(getTargetVersion(options),javacTask.getElements(),javacTask.getMessager(),jarBuilder,context.getEventSink());
        stubGenerator.generate(topLevelTypes);
        jarBuilder.createJarFile(sourceAbiJar);
      }
 catch (      IOException e) {
        throw new HumanReadableException(""String_Node_Str"",e.getMessage());
      }
    }
);
    try {
      javacTask.parse();
      if (buildSuccessful()) {
        javacTask.enter();
      }
    }
 catch (    RuntimeException e) {
      throw new HumanReadableException(e,String.format(""String_Node_Str"",invokingRule.getUnflavoredBuildTarget().toString()));
    }
    frontendRunAttempted=true;
    debugLogDiagnostics();
    if (!buildSuccessful()) {
      reportDiagnosticsToUser();
      return 1;
    }
    return 0;
  }
 catch (  IOException e) {
    LOG.error(e);
    throw new HumanReadableException(""String_Node_Str"",e.getMessage());
  }
 finally {
    BuckTracing.clearCurrentThreadTracingInterfaceFromJsr199Javac();
  }
}",0.9986130374479888
52873,"@Override public int runAndReturnExitCode() throws IOException, InterruptedException {
  try (ThriftCoordinatorClient client=new ThriftCoordinatorClient(coordinatorAddress,coordinatorPort,stampedeId)){
    client.start();
    final String minionId=generateNewMinionId();
    while (true) {
      GetTargetsToBuildResponse response=client.getTargetsToBuild(minionId);
switch (response.getAction()) {
case BUILD_TARGETS:
        List<String> targetsToBuild=Lists.newArrayList(response.getBuildTargets());
      LOG.debug(String.format(""String_Node_Str"",minionId,targetsToBuild.size(),Joiner.on(""String_Node_Str"").join(targetsToBuild)));
    int buildExitCode=builder.buildLocallyAndReturnExitCode(targetsToBuild);
  LOG.debug(String.format(""String_Node_Str"",minionId,buildExitCode));
FinishedBuildingResponse finishedResponse=client.finishedBuilding(minionId,buildExitCode);
if (!finishedResponse.isContinueBuilding()) {
return 0;
}
break;
case RETRY_LATER:
try {
Thread.sleep(RETRY_BACKOFF_MILLIS);
}
 catch (InterruptedException e) {
throw new RuntimeException(e);
}
break;
case CLOSE_CLIENT:
return 0;
case UNKNOWN:
default :
throw new RuntimeException(String.format(""String_Node_Str"",response.getAction()));
}
}
}
 }","@Override public int runAndReturnExitCode() throws IOException, InterruptedException {
  try (ThriftCoordinatorClient client=new ThriftCoordinatorClient(coordinatorAddress,coordinatorPort,stampedeId)){
    client.start();
    final String minionId=generateNewMinionId();
    while (true) {
      GetTargetsToBuildResponse response=client.getTargetsToBuild(minionId);
switch (response.getAction()) {
case BUILD_TARGETS:
        List<String> targetsToBuild=Lists.newArrayList(response.getBuildTargets());
      LOG.debug(String.format(""String_Node_Str"",minionId,targetsToBuild.size(),Joiner.on(""String_Node_Str"").join(targetsToBuild)));
    int buildExitCode=builder.buildLocallyAndReturnExitCode(targetsToBuild);
  LOG.debug(String.format(""String_Node_Str"",minionId,buildExitCode));
FinishedBuildingResponse finishedResponse=client.finishedBuilding(minionId,buildExitCode);
if (!finishedResponse.isContinueBuilding()) {
LOG.debug(String.format(""String_Node_Str"",minionId));
return 0;
}
break;
case RETRY_LATER:
try {
LOG.debug(String.format(""String_Node_Str"",minionId));
Thread.sleep(RETRY_BACKOFF_MILLIS);
}
 catch (InterruptedException e) {
throw new RuntimeException(e);
}
break;
case CLOSE_CLIENT:
LOG.debug(String.format(""String_Node_Str"",minionId));
return 0;
case UNKNOWN:
default :
throw new RuntimeException(String.format(""String_Node_Str"",response.getAction()));
}
}
}
 }",0.9376443418013856
52874,"@Override public FinishedBuildingResponse finishedBuilding(FinishedBuildingRequest request) throws TException {
  LOG.info(String.format(""String_Node_Str"",request.getMinionId()));
  checkBuildId(request.getStampedeId());
synchronized (lock) {
    Preconditions.checkArgument(request.isSetMinionId());
    Preconditions.checkArgument(request.isSetBuildExitCode());
    FinishedBuildingResponse response=new FinishedBuildingResponse();
    if (request.getBuildExitCode() != 0) {
      setBuildExitCode(request.getBuildExitCode());
      response.setContinueBuilding(false);
    }
 else {
      allocator.finishedBuildingTargets(request.getMinionId());
      if (getExitCode().isDone()) {
        response.setContinueBuilding(false);
      }
 else {
        if (allocator.isBuildFinished()) {
          setBuildExitCode(0);
          response.setContinueBuilding(false);
        }
 else {
          response.setContinueBuilding(true);
        }
      }
    }
    return response;
  }
}","@Override public FinishedBuildingResponse finishedBuilding(FinishedBuildingRequest request) throws TException {
  LOG.info(String.format(""String_Node_Str"",request.getMinionId()));
  checkBuildId(request.getStampedeId());
synchronized (lock) {
    Preconditions.checkArgument(request.isSetMinionId());
    Preconditions.checkArgument(request.isSetBuildExitCode());
    FinishedBuildingResponse response=new FinishedBuildingResponse();
    if (request.getBuildExitCode() != 0) {
      exitCode=request.getBuildExitCode();
      removeRunningMinion(request.getMinionId());
      response.setContinueBuilding(false);
    }
 else {
      allocator.finishedBuildingTargets(request.getMinionId());
      if (allocator.isBuildFinished()) {
        removeRunningMinion(request.getMinionId());
        response.setContinueBuilding(false);
      }
 else {
        response.setContinueBuilding(true);
      }
    }
    return response;
  }
}",0.7702773417059131
52875,"@Override public GetTargetsToBuildResponse getTargetsToBuild(GetTargetsToBuildRequest request) throws TException {
  LOG.debug(String.format(""String_Node_Str"",request.minionId));
  checkBuildId(request.getStampedeId());
synchronized (lock) {
    Preconditions.checkArgument(request.isSetMinionId());
    GetTargetsToBuildResponse response=new GetTargetsToBuildResponse();
    if (allocator.isBuildFinished()) {
      LOG.debug(String.format(""String_Node_Str"",request.minionId));
      return response.setAction(GetTargetsToBuildAction.CLOSE_CLIENT);
    }
    ImmutableList<String> targets=allocator.getTargetsToBuild(request.getMinionId());
    if (targets.isEmpty()) {
      LOG.debug(String.format(""String_Node_Str"",request.minionId));
      return response.setAction(GetTargetsToBuildAction.RETRY_LATER);
    }
 else {
      LOG.debug(String.format(""String_Node_Str"",request.minionId,targets.size(),Joiner.on(""String_Node_Str"").join(targets)));
      return response.setAction(GetTargetsToBuildAction.BUILD_TARGETS).setBuildTargets(targets);
    }
  }
}","@Override public GetTargetsToBuildResponse getTargetsToBuild(GetTargetsToBuildRequest request) throws TException {
  LOG.debug(String.format(""String_Node_Str"",request.minionId));
  checkBuildId(request.getStampedeId());
synchronized (lock) {
    Preconditions.checkArgument(request.isSetMinionId());
    runningMinions.add(request.getMinionId());
    GetTargetsToBuildResponse response=new GetTargetsToBuildResponse();
    if (allocator.isBuildFinished()) {
      LOG.debug(String.format(""String_Node_Str"",request.minionId));
      removeRunningMinion(request.getMinionId());
      return response.setAction(GetTargetsToBuildAction.CLOSE_CLIENT);
    }
    ImmutableList<String> targets=allocator.getTargetsToBuild(request.getMinionId());
    if (targets.isEmpty()) {
      LOG.debug(String.format(""String_Node_Str"",request.minionId));
      return response.setAction(GetTargetsToBuildAction.RETRY_LATER);
    }
 else {
      LOG.debug(String.format(""String_Node_Str"",request.minionId,targets.size(),Joiner.on(""String_Node_Str"").join(targets)));
      return response.setAction(GetTargetsToBuildAction.BUILD_TARGETS).setBuildTargets(targets);
    }
  }
}",0.956128448665762
52876,"@Override public Object visitString(String s,Void aVoid){
  if (getUnderlyingType(valueTreePath).getKind() == TypeKind.ERROR) {
    Tree leaf=valueTreePath.getLeaf();
    if (leaf instanceof MemberSelectTree && ((MemberSelectTree)leaf).getIdentifier().contentEquals(""String_Node_Str"")) {
      TreePath classNamePath=new TreePath(valueTreePath,((MemberSelectTree)leaf).getExpression());
      return getCanonicalType(getUnderlyingType(classNamePath),classNamePath);
    }
  }
  return super.visitString(s,aVoid);
}","@Override public Object visitString(String s,Void aVoid){
  if (getUnderlyingType(valueTreePath).getKind() == TypeKind.ERROR) {
    Tree leaf=valueTreePath.getLeaf();
    if (leaf instanceof MemberSelectTree && ((MemberSelectTree)leaf).getIdentifier().contentEquals(""String_Node_Str"")) {
      TreePath classNamePath=new TreePath(valueTreePath,((MemberSelectTree)leaf).getExpression());
      return getCanonicalType(getUnderlyingType(classNamePath),classNamePath);
    }
 else {
      javacTrees.printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"",leaf,valueTreePath.getCompilationUnit());
    }
  }
  return super.visitString(s,aVoid);
}",0.8908145580589255
52877,"/** 
 * Canonicalizes any   {@link javax.lang.model.element.Element}s,   {@link TypeMirror}s, or   {@link AnnotationValue}s found in the given object, which is expected to have been obtained by calling  {@link AnnotationValue#getValue()}.
 */
Object getCanonicalValue(AnnotationValue annotationValue,TreePath valueTreePath){
  return annotationValue.accept(new SimpleAnnotationValueVisitor8<Object,Void>(){
    @Override public Object visitType(    TypeMirror t,    Void aVoid){
      return getCanonicalType(t,valueTreePath);
    }
    @Override public Object visitEnumConstant(    VariableElement c,    Void aVoid){
      return Preconditions.checkNotNull(elements.getCanonicalElement(c));
    }
    @Override public Object visitAnnotation(    AnnotationMirror a,    Void aVoid){
      return new TreeBackedAnnotationMirror(a,valueTreePath,PostEnterCanonicalizer.this);
    }
    @Override public Object visitArray(    List<? extends AnnotationValue> values,    Void aVoid){
      Tree valueTree=valueTreePath.getLeaf();
      if (valueTree instanceof NewArrayTree) {
        NewArrayTree tree=(NewArrayTree)valueTree;
        List<? extends ExpressionTree> valueTrees=tree.getInitializers();
        List<TreeBackedAnnotationValue> result=new ArrayList<>();
        for (int i=0; i < values.size(); i++) {
          result.add(new TreeBackedAnnotationValue(values.get(i),new TreePath(valueTreePath,valueTrees.get(i)),PostEnterCanonicalizer.this));
        }
        return result;
      }
 else {
        return Collections.singletonList(new TreeBackedAnnotationValue(values.get(0),new TreePath(valueTreePath,valueTree),PostEnterCanonicalizer.this));
      }
    }
    @Override public Object visitString(    String s,    Void aVoid){
      if (getUnderlyingType(valueTreePath).getKind() == TypeKind.ERROR) {
        Tree leaf=valueTreePath.getLeaf();
        if (leaf instanceof MemberSelectTree && ((MemberSelectTree)leaf).getIdentifier().contentEquals(""String_Node_Str"")) {
          TreePath classNamePath=new TreePath(valueTreePath,((MemberSelectTree)leaf).getExpression());
          return getCanonicalType(getUnderlyingType(classNamePath),classNamePath);
        }
      }
      return super.visitString(s,aVoid);
    }
    @Override protected Object defaultAction(    Object o,    Void aVoid){
      return o;
    }
  }
,null);
}","/** 
 * Canonicalizes any   {@link javax.lang.model.element.Element}s,   {@link TypeMirror}s, or   {@link AnnotationValue}s found in the given object, which is expected to have been obtained by calling  {@link AnnotationValue#getValue()}.
 */
Object getCanonicalValue(AnnotationValue annotationValue,TreePath valueTreePath){
  return annotationValue.accept(new SimpleAnnotationValueVisitor8<Object,Void>(){
    @Override public Object visitType(    TypeMirror t,    Void aVoid){
      return getCanonicalType(t,valueTreePath);
    }
    @Override public Object visitEnumConstant(    VariableElement c,    Void aVoid){
      return Preconditions.checkNotNull(elements.getCanonicalElement(c));
    }
    @Override public Object visitAnnotation(    AnnotationMirror a,    Void aVoid){
      return new TreeBackedAnnotationMirror(a,valueTreePath,PostEnterCanonicalizer.this);
    }
    @Override public Object visitArray(    List<? extends AnnotationValue> values,    Void aVoid){
      Tree valueTree=valueTreePath.getLeaf();
      if (valueTree instanceof NewArrayTree) {
        NewArrayTree tree=(NewArrayTree)valueTree;
        List<? extends ExpressionTree> valueTrees=tree.getInitializers();
        List<TreeBackedAnnotationValue> result=new ArrayList<>();
        for (int i=0; i < values.size(); i++) {
          result.add(new TreeBackedAnnotationValue(values.get(i),new TreePath(valueTreePath,valueTrees.get(i)),PostEnterCanonicalizer.this));
        }
        return result;
      }
 else {
        return Collections.singletonList(new TreeBackedAnnotationValue(values.get(0),new TreePath(valueTreePath,valueTree),PostEnterCanonicalizer.this));
      }
    }
    @Override public Object visitString(    String s,    Void aVoid){
      if (getUnderlyingType(valueTreePath).getKind() == TypeKind.ERROR) {
        Tree leaf=valueTreePath.getLeaf();
        if (leaf instanceof MemberSelectTree && ((MemberSelectTree)leaf).getIdentifier().contentEquals(""String_Node_Str"")) {
          TreePath classNamePath=new TreePath(valueTreePath,((MemberSelectTree)leaf).getExpression());
          return getCanonicalType(getUnderlyingType(classNamePath),classNamePath);
        }
 else {
          javacTrees.printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"",leaf,valueTreePath.getCompilationUnit());
        }
      }
      return super.visitString(s,aVoid);
    }
    @Override protected Object defaultAction(    Object o,    Void aVoid){
      return o;
    }
  }
,null);
}",0.9721760797342192
52878,"private Tester createAnnotationFullJar() throws IOException {
  return tester.setSourceFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").compileFullJar();
}","private Tester createAnnotationFullJar() throws IOException {
  return tester.setSourceFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").compileFullJar();
}",0.9779951100244498
52879,"private static void writeZipContents(ZipFile zip,ZipArchiveEntry entry,ProjectFilesystem filesystem,Path target) throws IOException {
  try (InputStream is=zip.getInputStream(entry)){
    if (entry.isUnixSymlink()) {
      filesystem.createSymLink(target,filesystem.getPath(new String(ByteStreams.toByteArray(is),Charsets.UTF_8)),true);
    }
 else {
      try (OutputStream out=filesystem.newFileOutputStream(target)){
        ByteStreams.copy(is,out);
      }
     }
  }
   filesystem.resolve(target).toFile().setLastModified(entry.getTime());
  Set<PosixFilePermission> permissions=MorePosixFilePermissions.fromMode(entry.getExternalAttributes() >> 16);
  if (permissions.contains(PosixFilePermission.OWNER_EXECUTE)) {
    MoreFiles.makeExecutable(filesystem.resolve(target));
  }
}","private static void writeZipContents(ZipFile zip,ZipArchiveEntry entry,ProjectFilesystem filesystem,Path target) throws IOException {
  try (InputStream is=zip.getInputStream(entry)){
    if (entry.isUnixSymlink()) {
      filesystem.createSymLink(target,filesystem.getPath(new String(ByteStreams.toByteArray(is),Charsets.UTF_8)),true);
    }
 else {
      try (OutputStream out=filesystem.newFileOutputStream(target)){
        ByteStreams.copy(is,out);
      }
     }
  }
   Path filePath=filesystem.resolve(target);
  File file=filePath.toFile();
  file.setLastModified(entry.getTime());
  Set<PosixFilePermission> permissions=MorePosixFilePermissions.fromMode(entry.getExternalAttributes() >> 16);
  if (permissions.contains(PosixFilePermission.OWNER_EXECUTE) && file.getCanonicalFile().exists()) {
    MoreFiles.makeExecutable(filePath);
  }
}",0.9240196078431372
52880,@Value.NaturalOrder ImmutableSortedSet<BuildTarget> getDeps();,@Value.NaturalOrder @Override ImmutableSortedSet<BuildTarget> getDeps();,0.9253731343283582
52881,"public FrontendOnlyJavacTask(JavacTask task){
  super(task);
  javacTask=task;
  addPlugin(new EnteringPlugin());
}","public FrontendOnlyJavacTask(JavacTask task){
  super(task);
  javacTask=task;
  addTaskListener(new SuppressEnterErrorsTaskListener(task));
  addPlugin(new EnteringPlugin());
}",0.7876712328767124
52882,"private ListenableFuture<Void> storeContent(ImmutableSet<RuleKey> contentHashes,BorrowablePath content){
  try {
    ImmutableSet<RuleKey> toStore=notPreexisting(contentHashes);
    long size=filesystem.getFileSize(content.getPath());
    if (size <= maxInlinedBytes) {
      db.storeArtifact(toStore,Files.readAllBytes(content.getPath()),size);
    }
 else     if (!toStore.isEmpty()) {
      Path artifactPath=getArtifactPath(toStore.iterator().next());
      filesystem.mkdirs(artifactPath.getParent());
      if (content.canBorrow()) {
        filesystem.move(content.getPath(),artifactPath,StandardCopyOption.REPLACE_EXISTING);
      }
 else {
        storeArtifactOutput(content.getPath(),artifactPath);
      }
      db.storeFilepath(toStore,artifactPath.toString(),size);
    }
  }
 catch (  IOException|SQLException e) {
    LOG.warn(e,""String_Node_Str"",contentHashes,content);
  }
  return Futures.immediateFuture(null);
}","private ListenableFuture<Void> storeContent(ImmutableSet<RuleKey> contentHashes,BorrowablePath content){
  try {
    ImmutableSet<RuleKey> toStore=notPreexisting(contentHashes);
    if (toStore.size() == 0) {
      return Futures.immediateFuture(null);
    }
    long size=filesystem.getFileSize(content.getPath());
    if (size <= maxInlinedBytes) {
      db.storeArtifact(toStore,Files.readAllBytes(content.getPath()),size);
    }
 else     if (!toStore.isEmpty()) {
      Path artifactPath=getArtifactPath(toStore.iterator().next());
      filesystem.mkdirs(artifactPath.getParent());
      if (content.canBorrow()) {
        filesystem.move(content.getPath(),artifactPath,StandardCopyOption.REPLACE_EXISTING);
      }
 else {
        storeArtifactOutput(content.getPath(),artifactPath);
      }
      db.storeFilepath(toStore,artifactPath.toString(),size);
    }
  }
 catch (  IOException|SQLException e) {
    LOG.warn(e,""String_Node_Str"",contentHashes,content);
  }
  return Futures.immediateFuture(null);
}",0.9583547557840616
52883,"@Override public ListenableFuture<Void> store(ArtifactInfo info,BorrowablePath content){
  if (!getCacheReadMode().isWritable()) {
    return Futures.immediateFuture(null);
  }
  if (info.getMetadata().containsKey(TwoLevelArtifactCacheDecorator.METADATA_KEY)) {
    return Futures.transformAsync(storeMetadata(info),result -> removeOldMetadata());
  }
 else {
    return Futures.transformAsync(storeContent(info.getRuleKeys(),content),result -> removeOldContent());
  }
}","@Override public ListenableFuture<Void> store(ArtifactInfo info,BorrowablePath content){
  if (!getCacheReadMode().isWritable()) {
    return Futures.immediateFuture(null);
  }
  ListenableFuture<Void> metadataResult=Futures.immediateFuture(null);
  if (!info.getMetadata().isEmpty()) {
    metadataResult=Futures.transformAsync(storeMetadata(info),result -> removeOldMetadata());
  }
  ListenableFuture<Void> contentResult=Futures.immediateFuture(null);
  if (!info.getMetadata().containsKey(TwoLevelArtifactCacheDecorator.METADATA_KEY)) {
    contentResult=Futures.transformAsync(storeContent(info.getRuleKeys(),content),result -> removeOldContent());
  }
  return Futures.transform(Futures.allAsList(metadataResult,contentResult),Functions.constant(null));
}",0.5503246753246753
52884,"private CacheResult fetch(RuleKey ruleKey,LazyPath output){
  CacheResult artifactFetchResult=maybeFetchArtifact(ruleKey,output);
  if (artifactFetchResult.getType() == CacheResultType.HIT || artifactFetchResult.getType() == CacheResultType.ERROR) {
    return artifactFetchResult;
  }
 else {
    return fetchMetadata(ruleKey,output);
  }
}","private CacheResult fetch(RuleKey ruleKey,LazyPath output){
  CacheResult artifactResult=fetchContent(ruleKey,output);
  CacheResult metadataResult=fetchMetadata(ruleKey,output);
  if (artifactResult.getType().isSuccess() && metadataResult.getType().isSuccess()) {
    return CacheResult.hit(name,CACHE_MODE,metadataResult.getMetadata(),artifactResult.getArtifactSizeBytes());
  }
 else   if (artifactResult.getType() == CacheResultType.HIT || artifactResult.getType() == CacheResultType.ERROR) {
    return artifactResult;
  }
 else {
    return metadataResult;
  }
}",0.594059405940594
52885,"static AppleDebuggableBinary createAppleDebuggableBinary(BuildTarget buildTarget,ProjectFilesystem projectFilesystem,BuildRuleParams params,BuildRuleResolver resolver,BuildRule strippedBinaryRule,ProvidesLinkedBinaryDeps unstrippedBinaryRule,AppleDebugFormat debugFormat,FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain,Flavor defaultCxxFlavor,FlavorDomain<AppleCxxPlatform> appleCxxPlatforms){
  Optional<AppleDsym> appleDsym=createAppleDsymForDebugFormat(debugFormat,buildTarget,projectFilesystem,params,resolver,unstrippedBinaryRule,cxxPlatformFlavorDomain,defaultCxxFlavor,appleCxxPlatforms);
  BuildRule buildRuleForDebugFormat;
  if (debugFormat == AppleDebugFormat.DWARF) {
    buildRuleForDebugFormat=unstrippedBinaryRule;
  }
 else {
    buildRuleForDebugFormat=strippedBinaryRule;
  }
  AppleDebuggableBinary rule=new AppleDebuggableBinary(strippedBinaryRule.getBuildTarget().withAppendedFlavors(AppleDebuggableBinary.RULE_FLAVOR,debugFormat.getFlavor()),projectFilesystem,params.withDeclaredDeps(AppleDebuggableBinary.getRequiredRuntimeDeps(debugFormat,strippedBinaryRule,unstrippedBinaryRule,appleDsym)).withoutExtraDeps(),buildRuleForDebugFormat);
  return rule;
}","static AppleDebuggableBinary createAppleDebuggableBinary(BuildTarget buildTarget,ProjectFilesystem projectFilesystem,BuildRuleParams params,BuildRuleResolver resolver,BuildRule strippedBinaryRule,ProvidesLinkedBinaryDeps unstrippedBinaryRule,AppleDebugFormat debugFormat,FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain,Flavor defaultCxxFlavor,FlavorDomain<AppleCxxPlatform> appleCxxPlatforms){
  Optional<AppleDsym> appleDsym=debugFormat == AppleDebugFormat.DWARF_AND_DSYM ? Optional.of(requireAppleDsym(buildTarget,projectFilesystem,params,resolver,unstrippedBinaryRule,cxxPlatformFlavorDomain,defaultCxxFlavor,appleCxxPlatforms)) : Optional.empty();
  BuildRule buildRuleForDebugFormat;
  if (debugFormat == AppleDebugFormat.DWARF) {
    buildRuleForDebugFormat=unstrippedBinaryRule;
  }
 else {
    buildRuleForDebugFormat=strippedBinaryRule;
  }
  AppleDebuggableBinary rule=new AppleDebuggableBinary(strippedBinaryRule.getBuildTarget().withAppendedFlavors(AppleDebuggableBinary.RULE_FLAVOR,debugFormat.getFlavor()),projectFilesystem,params.withDeclaredDeps(AppleDebuggableBinary.getRequiredRuntimeDeps(debugFormat,strippedBinaryRule,unstrippedBinaryRule,appleDsym)).withoutExtraDeps(),buildRuleForDebugFormat);
  return rule;
}",0.8399668325041459
52886,"static AppleBundle createAppleBundle(FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain,Flavor defaultCxxFlavor,FlavorDomain<AppleCxxPlatform> appleCxxPlatforms,TargetGraph targetGraph,BuildTarget buildTarget,ProjectFilesystem projectFilesystem,BuildRuleParams params,BuildRuleResolver resolver,CodeSignIdentityStore codeSignIdentityStore,ProvisioningProfileStore provisioningProfileStore,BuildTarget binary,Either<AppleBundleExtension,String> extension,Optional<String> productName,final SourcePath infoPlist,ImmutableMap<String,String> infoPlistSubstitutions,ImmutableSortedSet<BuildTarget> deps,ImmutableSortedSet<BuildTarget> tests,AppleDebugFormat debugFormat,boolean dryRunCodeSigning,boolean cacheable) throws NoSuchBuildTargetException {
  AppleCxxPlatform appleCxxPlatform=ApplePlatforms.getAppleCxxPlatformForBuildTarget(cxxPlatformFlavorDomain,defaultCxxFlavor,appleCxxPlatforms,buildTarget,MultiarchFileInfos.create(appleCxxPlatforms,buildTarget));
  AppleBundleDestinations destinations;
  if (extension.isLeft() && extension.getLeft().equals(AppleBundleExtension.FRAMEWORK)) {
    destinations=AppleBundleDestinations.platformFrameworkDestinations(appleCxxPlatform.getAppleSdk().getApplePlatform());
  }
 else {
    destinations=AppleBundleDestinations.platformDestinations(appleCxxPlatform.getAppleSdk().getApplePlatform());
  }
  AppleBundleResources collectedResources=AppleResources.collectResourceDirsAndFiles(targetGraph,resolver,Optional.empty(),targetGraph.get(buildTarget));
  ImmutableSet.Builder<SourcePath> frameworksBuilder=ImmutableSet.builder();
  if (INCLUDE_FRAMEWORKS.getRequiredValue(buildTarget)) {
    for (    BuildTarget dep : deps) {
      Optional<FrameworkDependencies> frameworkDependencies=resolver.requireMetadata(dep.withAppendedFlavors(FRAMEWORK_FLAVOR,NO_INCLUDE_FRAMEWORKS_FLAVOR,appleCxxPlatform.getCxxPlatform().getFlavor()),FrameworkDependencies.class);
      if (frameworkDependencies.isPresent()) {
        frameworksBuilder.addAll(frameworkDependencies.get().getSourcePaths());
      }
    }
  }
  for (  BuildTarget dep : deps) {
    Optional<TargetNode<PrebuiltAppleFrameworkDescriptionArg,?>> prebuiltNode=targetGraph.getOptional(dep).flatMap(node -> node.castArg(PrebuiltAppleFrameworkDescriptionArg.class));
    if (prebuiltNode.isPresent() && !prebuiltNode.get().getConstructorArg().getPreferredLinkage().equals(NativeLinkable.Linkage.STATIC)) {
      frameworksBuilder.add(resolver.requireRule(dep).getSourcePathToOutput());
    }
  }
  ImmutableSet<SourcePath> frameworks=frameworksBuilder.build();
  SourcePathRuleFinder ruleFinder=new SourcePathRuleFinder(resolver);
  SourcePathResolver sourcePathResolver=DefaultSourcePathResolver.from(ruleFinder);
  BuildTarget buildTargetWithoutBundleSpecificFlavors=stripBundleSpecificFlavors(buildTarget);
  Optional<AppleAssetCatalog> assetCatalog=createBuildRuleForTransitiveAssetCatalogDependencies(targetGraph,buildTargetWithoutBundleSpecificFlavors,projectFilesystem,params,sourcePathResolver,appleCxxPlatform.getAppleSdk().getApplePlatform(),appleCxxPlatform.getMinVersion(),appleCxxPlatform.getActool());
  addToIndex(resolver,assetCatalog);
  Optional<CoreDataModel> coreDataModel=createBuildRulesForCoreDataDependencies(targetGraph,buildTargetWithoutBundleSpecificFlavors,projectFilesystem,params,AppleBundle.getBinaryName(buildTarget,productName),appleCxxPlatform);
  addToIndex(resolver,coreDataModel);
  Optional<SceneKitAssets> sceneKitAssets=createBuildRulesForSceneKitAssetsDependencies(targetGraph,buildTargetWithoutBundleSpecificFlavors,projectFilesystem,params,appleCxxPlatform);
  addToIndex(resolver,sceneKitAssets);
  BuildRule flavoredBinaryRule=getFlavoredBinaryRule(cxxPlatformFlavorDomain,defaultCxxFlavor,targetGraph,buildTargetWithoutBundleSpecificFlavors.getFlavors(),resolver,binary);
  if (!AppleDebuggableBinary.isBuildRuleDebuggable(flavoredBinaryRule)) {
    debugFormat=AppleDebugFormat.NONE;
  }
  BuildTarget unstrippedTarget=flavoredBinaryRule.getBuildTarget().withoutFlavors(CxxStrip.RULE_FLAVOR,AppleDebuggableBinary.RULE_FLAVOR,AppleBinaryDescription.APP_FLAVOR).withoutFlavors(StripStyle.FLAVOR_DOMAIN.getFlavors()).withoutFlavors(AppleDebugFormat.FLAVOR_DOMAIN.getFlavors()).withoutFlavors(AppleDebuggableBinary.RULE_FLAVOR).withoutFlavors(ImmutableSet.of(AppleBinaryDescription.APP_FLAVOR));
  Optional<LinkerMapMode> linkerMapMode=LinkerMapMode.FLAVOR_DOMAIN.getValue(buildTarget);
  if (linkerMapMode.isPresent()) {
    unstrippedTarget=unstrippedTarget.withAppendedFlavors(linkerMapMode.get().getFlavor());
  }
  BuildRule unstrippedBinaryRule=resolver.requireRule(unstrippedTarget);
  BuildRule targetDebuggableBinaryRule;
  Optional<AppleDsym> appleDsym;
  if (unstrippedBinaryRule instanceof ProvidesLinkedBinaryDeps) {
    BuildTarget binaryBuildTarget=getBinaryFromBuildRuleWithBinary(flavoredBinaryRule).getBuildTarget().withoutFlavors(AppleDebugFormat.FLAVOR_DOMAIN.getFlavors());
    targetDebuggableBinaryRule=createAppleDebuggableBinary(binaryBuildTarget,projectFilesystem,params,resolver,getBinaryFromBuildRuleWithBinary(flavoredBinaryRule),(ProvidesLinkedBinaryDeps)unstrippedBinaryRule,debugFormat,cxxPlatformFlavorDomain,defaultCxxFlavor,appleCxxPlatforms);
    appleDsym=createAppleDsymForDebugFormat(debugFormat,binaryBuildTarget,projectFilesystem,params,resolver,(ProvidesLinkedBinaryDeps)unstrippedBinaryRule,cxxPlatformFlavorDomain,defaultCxxFlavor,appleCxxPlatforms);
  }
 else {
    targetDebuggableBinaryRule=unstrippedBinaryRule;
    appleDsym=Optional.empty();
  }
  BuildRuleParams bundleParamsWithFlavoredBinaryDep=getBundleParamsWithUpdatedDeps(params,binary,ImmutableSet.<BuildRule>builder().add(targetDebuggableBinaryRule).addAll(Optionals.toStream(assetCatalog).iterator()).addAll(Optionals.toStream(coreDataModel).iterator()).addAll(Optionals.toStream(sceneKitAssets).iterator()).addAll(BuildRules.toBuildRulesFor(buildTarget,resolver,RichStream.from(collectedResources.getAll()).concat(frameworks.stream()).filter(BuildTargetSourcePath.class).map(BuildTargetSourcePath::getTarget).collect(MoreCollectors.toImmutableSet()))).addAll(Optionals.toStream(appleDsym).iterator()).build());
  ImmutableMap<SourcePath,String> extensionBundlePaths=collectFirstLevelAppleDependencyBundles(params.getBuildDeps(),destinations);
  return new AppleBundle(buildTarget,projectFilesystem,bundleParamsWithFlavoredBinaryDep,resolver,extension,productName,infoPlist,infoPlistSubstitutions,Optional.of(getBinaryFromBuildRuleWithBinary(flavoredBinaryRule)),appleDsym,destinations,collectedResources,extensionBundlePaths,frameworks,appleCxxPlatform,assetCatalog,coreDataModel,sceneKitAssets,tests,codeSignIdentityStore,provisioningProfileStore,dryRunCodeSigning,cacheable);
}","static AppleBundle createAppleBundle(FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain,Flavor defaultCxxFlavor,FlavorDomain<AppleCxxPlatform> appleCxxPlatforms,TargetGraph targetGraph,BuildTarget buildTarget,ProjectFilesystem projectFilesystem,BuildRuleParams params,BuildRuleResolver resolver,CodeSignIdentityStore codeSignIdentityStore,ProvisioningProfileStore provisioningProfileStore,BuildTarget binary,Either<AppleBundleExtension,String> extension,Optional<String> productName,final SourcePath infoPlist,ImmutableMap<String,String> infoPlistSubstitutions,ImmutableSortedSet<BuildTarget> deps,ImmutableSortedSet<BuildTarget> tests,AppleDebugFormat debugFormat,boolean dryRunCodeSigning,boolean cacheable) throws NoSuchBuildTargetException {
  AppleCxxPlatform appleCxxPlatform=ApplePlatforms.getAppleCxxPlatformForBuildTarget(cxxPlatformFlavorDomain,defaultCxxFlavor,appleCxxPlatforms,buildTarget,MultiarchFileInfos.create(appleCxxPlatforms,buildTarget));
  AppleBundleDestinations destinations;
  if (extension.isLeft() && extension.getLeft().equals(AppleBundleExtension.FRAMEWORK)) {
    destinations=AppleBundleDestinations.platformFrameworkDestinations(appleCxxPlatform.getAppleSdk().getApplePlatform());
  }
 else {
    destinations=AppleBundleDestinations.platformDestinations(appleCxxPlatform.getAppleSdk().getApplePlatform());
  }
  AppleBundleResources collectedResources=AppleResources.collectResourceDirsAndFiles(targetGraph,resolver,Optional.empty(),targetGraph.get(buildTarget));
  ImmutableSet.Builder<SourcePath> frameworksBuilder=ImmutableSet.builder();
  if (INCLUDE_FRAMEWORKS.getRequiredValue(buildTarget)) {
    for (    BuildTarget dep : deps) {
      Optional<FrameworkDependencies> frameworkDependencies=resolver.requireMetadata(dep.withAppendedFlavors(FRAMEWORK_FLAVOR,NO_INCLUDE_FRAMEWORKS_FLAVOR,appleCxxPlatform.getCxxPlatform().getFlavor()),FrameworkDependencies.class);
      if (frameworkDependencies.isPresent()) {
        frameworksBuilder.addAll(frameworkDependencies.get().getSourcePaths());
      }
    }
  }
  for (  BuildTarget dep : deps) {
    Optional<TargetNode<PrebuiltAppleFrameworkDescriptionArg,?>> prebuiltNode=targetGraph.getOptional(dep).flatMap(node -> node.castArg(PrebuiltAppleFrameworkDescriptionArg.class));
    if (prebuiltNode.isPresent() && !prebuiltNode.get().getConstructorArg().getPreferredLinkage().equals(NativeLinkable.Linkage.STATIC)) {
      frameworksBuilder.add(resolver.requireRule(dep).getSourcePathToOutput());
    }
  }
  ImmutableSet<SourcePath> frameworks=frameworksBuilder.build();
  SourcePathRuleFinder ruleFinder=new SourcePathRuleFinder(resolver);
  SourcePathResolver sourcePathResolver=DefaultSourcePathResolver.from(ruleFinder);
  BuildTarget buildTargetWithoutBundleSpecificFlavors=stripBundleSpecificFlavors(buildTarget);
  Optional<AppleAssetCatalog> assetCatalog=createBuildRuleForTransitiveAssetCatalogDependencies(targetGraph,buildTargetWithoutBundleSpecificFlavors,projectFilesystem,params,sourcePathResolver,appleCxxPlatform.getAppleSdk().getApplePlatform(),appleCxxPlatform.getMinVersion(),appleCxxPlatform.getActool());
  addToIndex(resolver,assetCatalog);
  Optional<CoreDataModel> coreDataModel=createBuildRulesForCoreDataDependencies(targetGraph,buildTargetWithoutBundleSpecificFlavors,projectFilesystem,params,AppleBundle.getBinaryName(buildTarget,productName),appleCxxPlatform);
  addToIndex(resolver,coreDataModel);
  Optional<SceneKitAssets> sceneKitAssets=createBuildRulesForSceneKitAssetsDependencies(targetGraph,buildTargetWithoutBundleSpecificFlavors,projectFilesystem,params,appleCxxPlatform);
  addToIndex(resolver,sceneKitAssets);
  BuildRule flavoredBinaryRule=getFlavoredBinaryRule(cxxPlatformFlavorDomain,defaultCxxFlavor,targetGraph,buildTargetWithoutBundleSpecificFlavors.getFlavors(),resolver,binary);
  if (!AppleDebuggableBinary.isBuildRuleDebuggable(flavoredBinaryRule)) {
    debugFormat=AppleDebugFormat.NONE;
  }
  BuildTarget unstrippedTarget=flavoredBinaryRule.getBuildTarget().withoutFlavors(CxxStrip.RULE_FLAVOR,AppleDebuggableBinary.RULE_FLAVOR,AppleBinaryDescription.APP_FLAVOR).withoutFlavors(StripStyle.FLAVOR_DOMAIN.getFlavors()).withoutFlavors(AppleDebugFormat.FLAVOR_DOMAIN.getFlavors()).withoutFlavors(AppleDebuggableBinary.RULE_FLAVOR).withoutFlavors(ImmutableSet.of(AppleBinaryDescription.APP_FLAVOR));
  Optional<LinkerMapMode> linkerMapMode=LinkerMapMode.FLAVOR_DOMAIN.getValue(buildTarget);
  if (linkerMapMode.isPresent()) {
    unstrippedTarget=unstrippedTarget.withAppendedFlavors(linkerMapMode.get().getFlavor());
  }
  BuildRule unstrippedBinaryRule=resolver.requireRule(unstrippedTarget);
  BuildRule targetDebuggableBinaryRule;
  Optional<AppleDsym> appleDsym;
  if (unstrippedBinaryRule instanceof ProvidesLinkedBinaryDeps) {
    BuildTarget binaryBuildTarget=getBinaryFromBuildRuleWithBinary(flavoredBinaryRule).getBuildTarget().withoutFlavors(AppleDebugFormat.FLAVOR_DOMAIN.getFlavors());
    targetDebuggableBinaryRule=createAppleDebuggableBinary(binaryBuildTarget,projectFilesystem,params,resolver,getBinaryFromBuildRuleWithBinary(flavoredBinaryRule),(ProvidesLinkedBinaryDeps)unstrippedBinaryRule,debugFormat,cxxPlatformFlavorDomain,defaultCxxFlavor,appleCxxPlatforms);
    if (debugFormat == AppleDebugFormat.DWARF_AND_DSYM) {
      appleDsym=Optional.of(requireAppleDsym(binaryBuildTarget,projectFilesystem,params,resolver,(ProvidesLinkedBinaryDeps)unstrippedBinaryRule,cxxPlatformFlavorDomain,defaultCxxFlavor,appleCxxPlatforms));
    }
 else {
      appleDsym=Optional.empty();
    }
  }
 else {
    targetDebuggableBinaryRule=unstrippedBinaryRule;
    appleDsym=Optional.empty();
  }
  BuildRuleParams bundleParamsWithFlavoredBinaryDep=getBundleParamsWithUpdatedDeps(params,binary,ImmutableSet.<BuildRule>builder().add(targetDebuggableBinaryRule).addAll(Optionals.toStream(assetCatalog).iterator()).addAll(Optionals.toStream(coreDataModel).iterator()).addAll(Optionals.toStream(sceneKitAssets).iterator()).addAll(BuildRules.toBuildRulesFor(buildTarget,resolver,RichStream.from(collectedResources.getAll()).concat(frameworks.stream()).filter(BuildTargetSourcePath.class).map(BuildTargetSourcePath::getTarget).collect(MoreCollectors.toImmutableSet()))).addAll(Optionals.toStream(appleDsym).iterator()).build());
  ImmutableMap<SourcePath,String> extensionBundlePaths=collectFirstLevelAppleDependencyBundles(params.getBuildDeps(),destinations);
  return new AppleBundle(buildTarget,projectFilesystem,bundleParamsWithFlavoredBinaryDep,resolver,extension,productName,infoPlist,infoPlistSubstitutions,Optional.of(getBinaryFromBuildRuleWithBinary(flavoredBinaryRule)),appleDsym,destinations,collectedResources,extensionBundlePaths,frameworks,appleCxxPlatform,assetCatalog,coreDataModel,sceneKitAssets,tests,codeSignIdentityStore,provisioningProfileStore,dryRunCodeSigning,cacheable);
}",0.987761722205839
52887,"private Exception maybeAttachBuildRuleNameToException(@Nonnull Exception thrown){
  if ((thrown instanceof HumanReadableException) || (thrown instanceof InterruptedException)) {
    return thrown;
  }
  String message=thrown.getMessage();
  if (message != null && message.contains(rule.toString())) {
    return thrown;
  }
  return new RuntimeException(getErrorMessageIncludingBuildRule(thrown),thrown);
}","private Throwable maybeAttachBuildRuleNameToException(@Nonnull Throwable thrown){
  if ((thrown instanceof HumanReadableException) || (thrown instanceof InterruptedException)) {
    return thrown;
  }
  String message=thrown.getMessage();
  if (message != null && message.contains(rule.toString())) {
    return thrown;
  }
  return new RuntimeException(getErrorMessageIncludingBuildRule(thrown),thrown);
}",0.8891625615763546
52888,"ListenableFuture<BuildResult> build(){
  final AtomicReference<Long> outputSize=Atomics.newReference();
  ListenableFuture<List<BuildResult>> depResults=Futures.immediateFuture(Collections.emptyList());
  if (buildMode == CachingBuildEngine.BuildMode.DEEP || buildMode == CachingBuildEngine.BuildMode.POPULATE_FROM_REMOTE_CACHE) {
    depResults=buildRuleBuilderDelegate.getDepResults(rule,buildContext,executionContext);
  }
  ListenableFuture<BuildResult> buildResult=Futures.transformAsync(depResults,input -> buildOrFetchFromCache(),serviceByAdjustingDefaultWeightsTo(CachingBuildEngine.SCHEDULING_MORE_WORK_RESOURCE_AMOUNTS));
  buildResult=Futures.catchingAsync(buildResult,Throwable.class,throwable -> {
    Preconditions.checkNotNull(throwable);
    buildRuleBuilderDelegate.setFirstFailure(throwable);
    Throwables.throwIfInstanceOf(throwable,Exception.class);
    throw new RuntimeException(throwable);
  }
);
  buildResult=Futures.transform(buildResult,(result) -> {
    buildRuleBuilderDelegate.markRuleAsUsed(rule,buildContext.getEventBus());
    return result;
  }
,MoreExecutors.directExecutor());
  AsyncFunction<BuildResult,BuildResult> callback=input -> {
    if (input.getStatus() != BuildRuleStatus.SUCCESS) {
      return Futures.immediateFuture(input);
    }
    try (Scope scope=LeafEvents.scope(buildContext.getEventBus(),""String_Node_Str"")){
      BuildRuleSuccessType success=Preconditions.checkNotNull(input.getSuccess());
      if (success != BuildRuleSuccessType.BUILT_LOCALLY) {
        try {
          for (          String str : onDiskBuildInfo.getValuesOrThrow(BuildInfo.MetadataKey.RECORDED_PATHS)) {
            buildInfoRecorder.recordArtifact(Paths.get(str));
          }
        }
 catch (        IOException e) {
          LOG.error(e,""String_Node_Str"",rule);
          throw e;
        }
      }
      if (success == BuildRuleSuccessType.BUILT_LOCALLY) {
        outputSize.set(buildInfoRecorder.getOutputSize());
      }
      if (success.outputsHaveChanged()) {
        if (rule instanceof HasPostBuildSteps) {
          executePostBuildSteps(((HasPostBuildSteps)rule).getPostBuildSteps(buildContext.getBuildContext()));
        }
        for (        Path path : buildInfoRecorder.getRecordedPaths()) {
          fileHashCache.invalidate(rule.getProjectFilesystem().resolve(path));
        }
      }
      if (SupportsInputBasedRuleKey.isSupported(rule) && success == BuildRuleSuccessType.BUILT_LOCALLY && !buildInfoRecorder.getBuildMetadataFor(BuildInfo.MetadataKey.INPUT_BASED_RULE_KEY).isPresent()) {
        Optional<RuleKey> inputRuleKey=calculateInputBasedRuleKey(buildContext.getEventBus());
        if (inputRuleKey.isPresent()) {
          buildInfoRecorder.addBuildMetadata(BuildInfo.MetadataKey.INPUT_BASED_RULE_KEY,inputRuleKey.get().toString());
        }
      }
      if (useDependencyFileRuleKey() && success == BuildRuleSuccessType.BUILT_LOCALLY) {
        ImmutableList<SourcePath> inputs=((SupportsDependencyFileRuleKey)rule).getInputsAfterBuildingLocally(buildContext.getBuildContext(),executionContext.getCellPathResolver());
        ImmutableList<String> inputStrings=inputs.stream().map(inputString -> DependencyFileEntry.fromSourcePath(inputString,pathResolver)).map(MoreFunctions.toJsonFunction()).collect(MoreCollectors.toImmutableList());
        buildInfoRecorder.addMetadata(BuildInfo.MetadataKey.DEP_FILE,inputStrings);
        Optional<RuleKeyAndInputs> depFileRuleKeyAndInputs=calculateDepFileRuleKey(Optional.of(inputStrings),false);
        if (depFileRuleKeyAndInputs.isPresent()) {
          RuleKey depFileRuleKey=depFileRuleKeyAndInputs.get().getRuleKey();
          buildInfoRecorder.addBuildMetadata(BuildInfo.MetadataKey.DEP_FILE_RULE_KEY,depFileRuleKey.toString());
          if (useManifestCaching()) {
            Optional<RuleKeyAndInputs> manifestKey=calculateManifestKey(buildContext.getEventBus());
            if (manifestKey.isPresent()) {
              buildInfoRecorder.addBuildMetadata(BuildInfo.MetadataKey.MANIFEST_KEY,manifestKey.get().getRuleKey().toString());
              updateAndStoreManifest(depFileRuleKeyAndInputs.get().getRuleKey(),depFileRuleKeyAndInputs.get().getInputs(),manifestKey.get(),buildContext.getArtifactCache());
            }
          }
        }
      }
      if (success == BuildRuleSuccessType.BUILT_LOCALLY && shouldUploadToCache(success,Preconditions.checkNotNull(outputSize.get()))) {
        ImmutableSortedMap.Builder<String,String> outputHashes=ImmutableSortedMap.naturalOrder();
        for (        Path path : buildInfoRecorder.getOutputPaths()) {
          outputHashes.put(path.toString(),fileHashCache.get(rule.getProjectFilesystem().resolve(path)).toString());
        }
        buildInfoRecorder.addBuildMetadata(BuildInfo.MetadataKey.RECORDED_PATH_HASHES,outputHashes.build());
      }
      if (success != BuildRuleSuccessType.BUILT_LOCALLY && success.outputsHaveChanged()) {
        Optional<ImmutableMap<String,String>> hashes=onDiskBuildInfo.getBuildMap(BuildInfo.MetadataKey.RECORDED_PATH_HASHES);
        if (hashes.isPresent() && verifyRecordedPathHashes(rule.getBuildTarget(),rule.getProjectFilesystem(),hashes.get())) {
          for (          Map.Entry<String,String> ent : hashes.get().entrySet()) {
            Path path=rule.getProjectFilesystem().getPath(ent.getKey());
            HashCode hashCode=HashCode.fromString(ent.getValue());
            fileHashCache.set(rule.getProjectFilesystem().resolve(path),hashCode);
          }
        }
      }
      BuildId buildId=buildContext.getBuildId();
      if (success == BuildRuleSuccessType.BUILT_LOCALLY) {
        buildInfoRecorder.addBuildMetadata(BuildInfo.MetadataKey.ORIGIN_BUILD_ID,buildId.toString());
      }
 else       if (success.outputsHaveChanged()) {
        Preconditions.checkState(buildInfoRecorder.getBuildMetadataFor(BuildInfo.MetadataKey.ORIGIN_BUILD_ID).isPresent(),""String_Node_Str"",BuildInfo.MetadataKey.ORIGIN_BUILD_ID,success);
      }
      buildInfoRecorder.addBuildMetadata(BuildInfo.MetadataKey.TARGET,rule.getBuildTarget().toString());
      buildInfoRecorder.addMetadata(BuildInfo.MetadataKey.RECORDED_PATHS,buildInfoRecorder.getRecordedPaths().stream().map(Object::toString).collect(MoreCollectors.toImmutableList()));
      if (success.shouldWriteRecordedMetadataToDiskAfterBuilding()) {
        try {
          boolean clearExistingMetadata=success.shouldClearAndOverwriteMetadataOnDisk();
          buildInfoRecorder.writeMetadataToDisk(clearExistingMetadata);
        }
 catch (        IOException e) {
          throw new IOException(String.format(""String_Node_Str"",rule),e);
        }
      }
      try {
        if (rule instanceof InitializableFromDisk) {
          doInitializeFromDisk((InitializableFromDisk<?>)rule);
        }
      }
 catch (      IOException e) {
        throw new IOException(String.format(""String_Node_Str"",rule,e.getMessage()),e);
      }
    }
     return Futures.immediateFuture(input);
  }
;
  buildResult=Futures.transformAsync(buildResult,ruleAsyncFunction(buildContext.getEventBus(),callback),serviceByAdjustingDefaultWeightsTo(CachingBuildEngine.RULE_KEY_COMPUTATION_RESOURCE_AMOUNTS));
  buildResult=Futures.catchingAsync(buildResult,Exception.class,thrown -> {
    LOG.debug(thrown,""String_Node_Str"",rule.getBuildTarget());
    if (consoleLogBuildFailuresInline) {
      buildContext.getEventBus().post(ConsoleEvent.severe(getErrorMessageIncludingBuildRule(thrown)));
    }
    thrown=maybeAttachBuildRuleNameToException(thrown);
    recordFailureAndCleanUp(thrown);
    return Futures.immediateFuture(BuildResult.failure(rule,thrown));
  }
);
  buildRuleBuilderDelegate.addAsyncCallback(MoreFutures.addListenableCallback(buildResult,new FutureCallback<BuildResult>(){
    private void uploadToCache(    BuildRuleSuccessType success){
      Set<RuleKey> ruleKeys=new HashSet<>();
      ruleKeys.add(ruleKeyFactories.getDefaultRuleKeyFactory().build(rule));
      if (SupportsInputBasedRuleKey.isSupported(rule)) {
        Optional<RuleKey> calculatedRuleKey=calculateInputBasedRuleKey(buildContext.getEventBus());
        Optional<RuleKey> onDiskRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.MetadataKey.INPUT_BASED_RULE_KEY);
        Optional<RuleKey> metaDataRuleKey=buildInfoRecorder.getBuildMetadataFor(BuildInfo.MetadataKey.INPUT_BASED_RULE_KEY).map(RuleKey::new);
        Preconditions.checkState(calculatedRuleKey.equals(onDiskRuleKey),""String_Node_Str"",rule.getBuildTarget(),rule.getType(),success,calculatedRuleKey,onDiskRuleKey);
        Preconditions.checkState(calculatedRuleKey.equals(metaDataRuleKey),""String_Node_Str"",rule.getBuildTarget(),success,calculatedRuleKey,metaDataRuleKey);
        if (calculatedRuleKey.isPresent()) {
          ruleKeys.add(calculatedRuleKey.get());
        }
      }
      if (useManifestCaching()) {
        Optional<RuleKey> onDiskRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.MetadataKey.DEP_FILE_RULE_KEY);
        Optional<RuleKey> metaDataRuleKey=buildInfoRecorder.getBuildMetadataFor(BuildInfo.MetadataKey.DEP_FILE_RULE_KEY).map(RuleKey::new);
        Preconditions.checkState(onDiskRuleKey.equals(metaDataRuleKey),""String_Node_Str"",rule.getBuildTarget(),success,onDiskRuleKey,metaDataRuleKey);
        if (onDiskRuleKey.isPresent()) {
          ruleKeys.add(onDiskRuleKey.get());
        }
      }
      try {
        Optional<String> recordedPathHashes=buildInfoRecorder.getBuildMetadataFor(BuildInfo.MetadataKey.RECORDED_PATH_HASHES);
        if (recordedPathHashes.isPresent() && !verifyRecordedPathHashes(rule.getBuildTarget(),rule.getProjectFilesystem(),recordedPathHashes.get())) {
          return;
        }
        buildInfoRecorder.performUploadToArtifactCache(ImmutableSet.copyOf(ruleKeys),buildContext.getArtifactCache(),buildContext.getEventBus());
      }
 catch (      Throwable t) {
        buildContext.getEventBus().post(ThrowableConsoleEvent.create(t,""String_Node_Str"",rule));
      }
    }
    private void handleResult(    BuildResult input){
      Optional<Long> outputSize=Optional.empty();
      Optional<HashCode> outputHash=Optional.empty();
      Optional<BuildRuleSuccessType> successType=Optional.empty();
      boolean shouldUploadToCache=false;
      BuildRuleEvent.Resumed resumedEvent=BuildRuleEvent.resumed(rule,buildRuleDurationTracker,ruleKeyFactories.getDefaultRuleKeyFactory());
      LOG.verbose(resumedEvent.toString());
      buildContext.getEventBus().post(resumedEvent);
      if (input.getStatus() == BuildRuleStatus.SUCCESS) {
        BuildRuleSuccessType success=Preconditions.checkNotNull(input.getSuccess());
        successType=Optional.of(success);
        if (success == BuildRuleSuccessType.BUILT_LOCALLY || success.shouldUploadResultingArtifact()) {
          try {
            outputSize=Optional.of(buildInfoRecorder.getOutputSize());
          }
 catch (          IOException e) {
            buildContext.getEventBus().post(ThrowableConsoleEvent.create(e,""String_Node_Str"",rule));
          }
        }
        if (outputSize.isPresent() && shouldHashOutputs(success,outputSize.get())) {
          try {
            outputHash=Optional.of(buildInfoRecorder.getOutputHash(fileHashCache));
          }
 catch (          IOException e) {
            buildContext.getEventBus().post(ThrowableConsoleEvent.create(e,""String_Node_Str"",rule));
          }
        }
        shouldUploadToCache=outputSize.isPresent() && shouldUploadToCache(success,outputSize.get());
        if (shouldUploadToCache) {
          uploadToCache(success);
        }
      }
      boolean failureOrBuiltLocally=input.getStatus() == BuildRuleStatus.FAIL || input.getSuccess() == BuildRuleSuccessType.BUILT_LOCALLY;
      BuildRuleEvent.Finished finished=BuildRuleEvent.finished(resumedEvent,getBuildRuleKeys(),input.getStatus(),input.getCacheResult(),onDiskBuildInfo.getBuildValue(BuildInfo.MetadataKey.ORIGIN_BUILD_ID).map(BuildId::new),successType,shouldUploadToCache,outputHash,outputSize,getBuildRuleDiagnosticData(failureOrBuiltLocally));
      LOG.verbose(finished.toString());
      buildContext.getEventBus().post(finished);
    }
    @Override public void onSuccess(    BuildResult input){
      handleResult(input);
      if (input.getFailure() instanceof InterruptedException) {
        Threads.interruptCurrentThread();
      }
    }
    @Override public void onFailure(    @Nonnull Throwable thrown){
      throw new AssertionError(""String_Node_Str"");
    }
  }
,serviceByAdjustingDefaultWeightsTo(CachingBuildEngine.RULE_KEY_COMPUTATION_RESOURCE_AMOUNTS)));
  return buildResult;
}","ListenableFuture<BuildResult> build(){
  final AtomicReference<Long> outputSize=Atomics.newReference();
  ListenableFuture<List<BuildResult>> depResults=Futures.immediateFuture(Collections.emptyList());
  if (buildMode == CachingBuildEngine.BuildMode.DEEP || buildMode == CachingBuildEngine.BuildMode.POPULATE_FROM_REMOTE_CACHE) {
    depResults=buildRuleBuilderDelegate.getDepResults(rule,buildContext,executionContext);
  }
  ListenableFuture<BuildResult> buildResult=Futures.transformAsync(depResults,input -> buildOrFetchFromCache(),serviceByAdjustingDefaultWeightsTo(CachingBuildEngine.SCHEDULING_MORE_WORK_RESOURCE_AMOUNTS));
  buildResult=Futures.catchingAsync(buildResult,Throwable.class,throwable -> {
    Preconditions.checkNotNull(throwable);
    buildRuleBuilderDelegate.setFirstFailure(throwable);
    Throwables.throwIfInstanceOf(throwable,Exception.class);
    throw new RuntimeException(throwable);
  }
);
  buildResult=Futures.transform(buildResult,(result) -> {
    buildRuleBuilderDelegate.markRuleAsUsed(rule,buildContext.getEventBus());
    return result;
  }
,MoreExecutors.directExecutor());
  AsyncFunction<BuildResult,BuildResult> callback=input -> {
    if (input.getStatus() != BuildRuleStatus.SUCCESS) {
      return Futures.immediateFuture(input);
    }
    try (Scope scope=LeafEvents.scope(buildContext.getEventBus(),""String_Node_Str"")){
      BuildRuleSuccessType success=Preconditions.checkNotNull(input.getSuccess());
      if (success != BuildRuleSuccessType.BUILT_LOCALLY) {
        try {
          for (          String str : onDiskBuildInfo.getValuesOrThrow(BuildInfo.MetadataKey.RECORDED_PATHS)) {
            buildInfoRecorder.recordArtifact(Paths.get(str));
          }
        }
 catch (        IOException e) {
          LOG.error(e,""String_Node_Str"",rule);
          throw e;
        }
      }
      if (success == BuildRuleSuccessType.BUILT_LOCALLY) {
        outputSize.set(buildInfoRecorder.getOutputSize());
      }
      if (success.outputsHaveChanged()) {
        if (rule instanceof HasPostBuildSteps) {
          executePostBuildSteps(((HasPostBuildSteps)rule).getPostBuildSteps(buildContext.getBuildContext()));
        }
        for (        Path path : buildInfoRecorder.getRecordedPaths()) {
          fileHashCache.invalidate(rule.getProjectFilesystem().resolve(path));
        }
      }
      if (SupportsInputBasedRuleKey.isSupported(rule) && success == BuildRuleSuccessType.BUILT_LOCALLY && !buildInfoRecorder.getBuildMetadataFor(BuildInfo.MetadataKey.INPUT_BASED_RULE_KEY).isPresent()) {
        Optional<RuleKey> inputRuleKey=calculateInputBasedRuleKey(buildContext.getEventBus());
        if (inputRuleKey.isPresent()) {
          buildInfoRecorder.addBuildMetadata(BuildInfo.MetadataKey.INPUT_BASED_RULE_KEY,inputRuleKey.get().toString());
        }
      }
      if (useDependencyFileRuleKey() && success == BuildRuleSuccessType.BUILT_LOCALLY) {
        ImmutableList<SourcePath> inputs=((SupportsDependencyFileRuleKey)rule).getInputsAfterBuildingLocally(buildContext.getBuildContext(),executionContext.getCellPathResolver());
        ImmutableList<String> inputStrings=inputs.stream().map(inputString -> DependencyFileEntry.fromSourcePath(inputString,pathResolver)).map(MoreFunctions.toJsonFunction()).collect(MoreCollectors.toImmutableList());
        buildInfoRecorder.addMetadata(BuildInfo.MetadataKey.DEP_FILE,inputStrings);
        Optional<RuleKeyAndInputs> depFileRuleKeyAndInputs=calculateDepFileRuleKey(Optional.of(inputStrings),false);
        if (depFileRuleKeyAndInputs.isPresent()) {
          RuleKey depFileRuleKey=depFileRuleKeyAndInputs.get().getRuleKey();
          buildInfoRecorder.addBuildMetadata(BuildInfo.MetadataKey.DEP_FILE_RULE_KEY,depFileRuleKey.toString());
          if (useManifestCaching()) {
            Optional<RuleKeyAndInputs> manifestKey=calculateManifestKey(buildContext.getEventBus());
            if (manifestKey.isPresent()) {
              buildInfoRecorder.addBuildMetadata(BuildInfo.MetadataKey.MANIFEST_KEY,manifestKey.get().getRuleKey().toString());
              updateAndStoreManifest(depFileRuleKeyAndInputs.get().getRuleKey(),depFileRuleKeyAndInputs.get().getInputs(),manifestKey.get(),buildContext.getArtifactCache());
            }
          }
        }
      }
      if (success == BuildRuleSuccessType.BUILT_LOCALLY && shouldUploadToCache(success,Preconditions.checkNotNull(outputSize.get()))) {
        ImmutableSortedMap.Builder<String,String> outputHashes=ImmutableSortedMap.naturalOrder();
        for (        Path path : buildInfoRecorder.getOutputPaths()) {
          outputHashes.put(path.toString(),fileHashCache.get(rule.getProjectFilesystem().resolve(path)).toString());
        }
        buildInfoRecorder.addBuildMetadata(BuildInfo.MetadataKey.RECORDED_PATH_HASHES,outputHashes.build());
      }
      if (success != BuildRuleSuccessType.BUILT_LOCALLY && success.outputsHaveChanged()) {
        Optional<ImmutableMap<String,String>> hashes=onDiskBuildInfo.getBuildMap(BuildInfo.MetadataKey.RECORDED_PATH_HASHES);
        if (hashes.isPresent() && verifyRecordedPathHashes(rule.getBuildTarget(),rule.getProjectFilesystem(),hashes.get())) {
          for (          Map.Entry<String,String> ent : hashes.get().entrySet()) {
            Path path=rule.getProjectFilesystem().getPath(ent.getKey());
            HashCode hashCode=HashCode.fromString(ent.getValue());
            fileHashCache.set(rule.getProjectFilesystem().resolve(path),hashCode);
          }
        }
      }
      BuildId buildId=buildContext.getBuildId();
      if (success == BuildRuleSuccessType.BUILT_LOCALLY) {
        buildInfoRecorder.addBuildMetadata(BuildInfo.MetadataKey.ORIGIN_BUILD_ID,buildId.toString());
      }
 else       if (success.outputsHaveChanged()) {
        Preconditions.checkState(buildInfoRecorder.getBuildMetadataFor(BuildInfo.MetadataKey.ORIGIN_BUILD_ID).isPresent(),""String_Node_Str"",BuildInfo.MetadataKey.ORIGIN_BUILD_ID,success);
      }
      buildInfoRecorder.addBuildMetadata(BuildInfo.MetadataKey.TARGET,rule.getBuildTarget().toString());
      buildInfoRecorder.addMetadata(BuildInfo.MetadataKey.RECORDED_PATHS,buildInfoRecorder.getRecordedPaths().stream().map(Object::toString).collect(MoreCollectors.toImmutableList()));
      if (success.shouldWriteRecordedMetadataToDiskAfterBuilding()) {
        try {
          boolean clearExistingMetadata=success.shouldClearAndOverwriteMetadataOnDisk();
          buildInfoRecorder.writeMetadataToDisk(clearExistingMetadata);
        }
 catch (        IOException e) {
          throw new IOException(String.format(""String_Node_Str"",rule),e);
        }
      }
      try {
        if (rule instanceof InitializableFromDisk) {
          doInitializeFromDisk((InitializableFromDisk<?>)rule);
        }
      }
 catch (      IOException e) {
        throw new IOException(String.format(""String_Node_Str"",rule,e.getMessage()),e);
      }
    }
     return Futures.immediateFuture(input);
  }
;
  buildResult=Futures.transformAsync(buildResult,ruleAsyncFunction(buildContext.getEventBus(),callback),serviceByAdjustingDefaultWeightsTo(CachingBuildEngine.RULE_KEY_COMPUTATION_RESOURCE_AMOUNTS));
  buildResult=Futures.catchingAsync(buildResult,Throwable.class,thrown -> {
    LOG.debug(thrown,""String_Node_Str"",rule.getBuildTarget());
    if (consoleLogBuildFailuresInline) {
      buildContext.getEventBus().post(ConsoleEvent.severe(getErrorMessageIncludingBuildRule(thrown)));
    }
    thrown=maybeAttachBuildRuleNameToException(thrown);
    recordFailureAndCleanUp(thrown);
    return Futures.immediateFuture(BuildResult.failure(rule,thrown));
  }
);
  buildRuleBuilderDelegate.addAsyncCallback(MoreFutures.addListenableCallback(buildResult,new FutureCallback<BuildResult>(){
    private void uploadToCache(    BuildRuleSuccessType success){
      Set<RuleKey> ruleKeys=new HashSet<>();
      ruleKeys.add(ruleKeyFactories.getDefaultRuleKeyFactory().build(rule));
      if (SupportsInputBasedRuleKey.isSupported(rule)) {
        Optional<RuleKey> calculatedRuleKey=calculateInputBasedRuleKey(buildContext.getEventBus());
        Optional<RuleKey> onDiskRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.MetadataKey.INPUT_BASED_RULE_KEY);
        Optional<RuleKey> metaDataRuleKey=buildInfoRecorder.getBuildMetadataFor(BuildInfo.MetadataKey.INPUT_BASED_RULE_KEY).map(RuleKey::new);
        Preconditions.checkState(calculatedRuleKey.equals(onDiskRuleKey),""String_Node_Str"",rule.getBuildTarget(),rule.getType(),success,calculatedRuleKey,onDiskRuleKey);
        Preconditions.checkState(calculatedRuleKey.equals(metaDataRuleKey),""String_Node_Str"",rule.getBuildTarget(),success,calculatedRuleKey,metaDataRuleKey);
        if (calculatedRuleKey.isPresent()) {
          ruleKeys.add(calculatedRuleKey.get());
        }
      }
      if (useManifestCaching()) {
        Optional<RuleKey> onDiskRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.MetadataKey.DEP_FILE_RULE_KEY);
        Optional<RuleKey> metaDataRuleKey=buildInfoRecorder.getBuildMetadataFor(BuildInfo.MetadataKey.DEP_FILE_RULE_KEY).map(RuleKey::new);
        Preconditions.checkState(onDiskRuleKey.equals(metaDataRuleKey),""String_Node_Str"",rule.getBuildTarget(),success,onDiskRuleKey,metaDataRuleKey);
        if (onDiskRuleKey.isPresent()) {
          ruleKeys.add(onDiskRuleKey.get());
        }
      }
      try {
        Optional<String> recordedPathHashes=buildInfoRecorder.getBuildMetadataFor(BuildInfo.MetadataKey.RECORDED_PATH_HASHES);
        if (recordedPathHashes.isPresent() && !verifyRecordedPathHashes(rule.getBuildTarget(),rule.getProjectFilesystem(),recordedPathHashes.get())) {
          return;
        }
        buildInfoRecorder.performUploadToArtifactCache(ImmutableSet.copyOf(ruleKeys),buildContext.getArtifactCache(),buildContext.getEventBus());
      }
 catch (      Throwable t) {
        buildContext.getEventBus().post(ThrowableConsoleEvent.create(t,""String_Node_Str"",rule));
      }
    }
    private void handleResult(    BuildResult input){
      Optional<Long> outputSize=Optional.empty();
      Optional<HashCode> outputHash=Optional.empty();
      Optional<BuildRuleSuccessType> successType=Optional.empty();
      boolean shouldUploadToCache=false;
      BuildRuleEvent.Resumed resumedEvent=BuildRuleEvent.resumed(rule,buildRuleDurationTracker,ruleKeyFactories.getDefaultRuleKeyFactory());
      LOG.verbose(resumedEvent.toString());
      buildContext.getEventBus().post(resumedEvent);
      if (input.getStatus() == BuildRuleStatus.SUCCESS) {
        BuildRuleSuccessType success=Preconditions.checkNotNull(input.getSuccess());
        successType=Optional.of(success);
        if (success == BuildRuleSuccessType.BUILT_LOCALLY || success.shouldUploadResultingArtifact()) {
          try {
            outputSize=Optional.of(buildInfoRecorder.getOutputSize());
          }
 catch (          IOException e) {
            buildContext.getEventBus().post(ThrowableConsoleEvent.create(e,""String_Node_Str"",rule));
          }
        }
        if (outputSize.isPresent() && shouldHashOutputs(success,outputSize.get())) {
          try {
            outputHash=Optional.of(buildInfoRecorder.getOutputHash(fileHashCache));
          }
 catch (          IOException e) {
            buildContext.getEventBus().post(ThrowableConsoleEvent.create(e,""String_Node_Str"",rule));
          }
        }
        shouldUploadToCache=outputSize.isPresent() && shouldUploadToCache(success,outputSize.get());
        if (shouldUploadToCache) {
          uploadToCache(success);
        }
      }
      boolean failureOrBuiltLocally=input.getStatus() == BuildRuleStatus.FAIL || input.getSuccess() == BuildRuleSuccessType.BUILT_LOCALLY;
      BuildRuleEvent.Finished finished=BuildRuleEvent.finished(resumedEvent,getBuildRuleKeys(),input.getStatus(),input.getCacheResult(),onDiskBuildInfo.getBuildValue(BuildInfo.MetadataKey.ORIGIN_BUILD_ID).map(BuildId::new),successType,shouldUploadToCache,outputHash,outputSize,getBuildRuleDiagnosticData(failureOrBuiltLocally));
      LOG.verbose(finished.toString());
      buildContext.getEventBus().post(finished);
    }
    @Override public void onSuccess(    BuildResult input){
      handleResult(input);
      if (input.getFailure() instanceof InterruptedException) {
        Threads.interruptCurrentThread();
      }
    }
    @Override public void onFailure(    @Nonnull Throwable thrown){
      throw new AssertionError(""String_Node_Str"");
    }
  }
,serviceByAdjustingDefaultWeightsTo(CachingBuildEngine.RULE_KEY_COMPUTATION_RESOURCE_AMOUNTS)));
  return buildResult;
}",0.9992832112137624
52889,"private CacheResult fetch(ArtifactCache artifactCache,RuleKey ruleKey,LazyPath outputPath){
  CacheResult cacheResult=Futures.getUnchecked(artifactCache.fetchAsync(ruleKey,outputPath));
  if (cacheResult.getType() != CacheResultType.HIT) {
    return cacheResult;
  }
  for (  String ruleKeyName : BuildInfo.RULE_KEY_NAMES) {
    if (!cacheResult.getMetadata().containsKey(ruleKeyName)) {
      continue;
    }
    String ruleKeyValue=cacheResult.getMetadata().get(ruleKeyName);
    try {
      HashCode.fromString(ruleKeyValue);
    }
 catch (    IllegalArgumentException e) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",ruleKeyName,ruleKey,artifactCache.getClass(),ruleKeyValue),e);
    }
  }
  return cacheResult;
}","private CacheResult fetch(ArtifactCache artifactCache,RuleKey ruleKey,LazyPath outputPath){
  CacheResult cacheResult=Futures.getUnchecked(artifactCache.fetchAsync(ruleKey,outputPath));
  if (cacheResult.getType() != CacheResultType.HIT) {
    return cacheResult;
  }
  for (  String ruleKeyName : BuildInfo.RULE_KEY_NAMES) {
    if (!cacheResult.getMetadata().containsKey(ruleKeyName)) {
      continue;
    }
    String ruleKeyValue=cacheResult.getMetadata().get(ruleKeyName);
    try {
      verify(ruleKeyValue);
    }
 catch (    IllegalArgumentException e) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",ruleKeyName,ruleKey,artifactCache.getClass(),ruleKeyValue),e);
    }
  }
  return cacheResult;
}",0.9831195138419988
52890,"private void forEachBuildFileFilesystem(final ProjectFilesystem filesystem,final String buildFileName,final Consumer<Path> function) throws IOException {
  filesystem.walkRelativeFileTree(getBasePath(),new FileVisitor<Path>(){
    @Override public FileVisitResult preVisitDirectory(    Path dir,    BasicFileAttributes attrs) throws IOException {
      if (filesystem.isIgnored(dir)) {
        return FileVisitResult.SKIP_SUBTREE;
      }
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attrs) throws IOException {
      if (buildFileName.equals(file.getFileName().toString()) && !filesystem.isIgnored(file)) {
        function.accept(filesystem.resolve(file));
      }
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult visitFileFailed(    Path file,    IOException exc) throws IOException {
      throw exc;
    }
    @Override public FileVisitResult postVisitDirectory(    Path dir,    IOException exc) throws IOException {
      if (exc != null) {
        throw exc;
      }
      return FileVisitResult.CONTINUE;
    }
  }
);
}","private void forEachBuildFileFilesystem(final ProjectFilesystem filesystem,final String buildFileName,final Consumer<Path> function) throws IOException {
  if (!filesystem.isDirectory(getBasePath())) {
    throw new HumanReadableException(""String_Node_Str"" + ""String_Node_Str"",getBasePath());
  }
  filesystem.walkRelativeFileTree(getBasePath(),new FileVisitor<Path>(){
    @Override public FileVisitResult preVisitDirectory(    Path dir,    BasicFileAttributes attrs) throws IOException {
      if (filesystem.isIgnored(dir)) {
        return FileVisitResult.SKIP_SUBTREE;
      }
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attrs) throws IOException {
      if (buildFileName.equals(file.getFileName().toString()) && !filesystem.isIgnored(file)) {
        function.accept(filesystem.resolve(file));
      }
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult visitFileFailed(    Path file,    IOException exc) throws IOException {
      throw exc;
    }
    @Override public FileVisitResult postVisitDirectory(    Path dir,    IOException exc) throws IOException {
      if (exc != null) {
        throw exc;
      }
      return FileVisitResult.CONTINUE;
    }
  }
);
}",0.9412248253185368
52891,"public static AppleCxxPlatform getAppleCxxPlatformForBuildTarget(FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain,CxxPlatform defaultCxxPlatform,FlavorDomain<AppleCxxPlatform> appleCxxPlatformFlavorDomain,BuildTarget target,Optional<MultiarchFileInfo> fatBinaryInfo){
  AppleCxxPlatform appleCxxPlatform;
  if (fatBinaryInfo.isPresent()) {
    appleCxxPlatform=fatBinaryInfo.get().getRepresentativePlatform();
  }
 else {
    CxxPlatform cxxPlatform=getCxxPlatformForBuildTarget(cxxPlatformFlavorDomain,defaultCxxPlatform,target);
    try {
      appleCxxPlatform=appleCxxPlatformFlavorDomain.getValue(cxxPlatform.getFlavor());
    }
 catch (    FlavorDomainException e) {
      throw new HumanReadableException(e,""String_Node_Str"",target,cxxPlatform.getFlavor().getName());
    }
  }
  return appleCxxPlatform;
}","public static AppleCxxPlatform getAppleCxxPlatformForBuildTarget(FlavorDomain<CxxPlatform> cxxPlatformFlavorDomain,CxxPlatform defaultCxxPlatform,FlavorDomain<AppleCxxPlatform> appleCxxPlatformFlavorDomain,BuildTarget target,Optional<MultiarchFileInfo> fatBinaryInfo){
  AppleCxxPlatform appleCxxPlatform;
  if (fatBinaryInfo.isPresent()) {
    appleCxxPlatform=fatBinaryInfo.get().getRepresentativePlatform();
  }
 else {
    CxxPlatform cxxPlatform=getCxxPlatformForBuildTarget(cxxPlatformFlavorDomain,defaultCxxPlatform,target);
    try {
      appleCxxPlatform=appleCxxPlatformFlavorDomain.getValue(cxxPlatform.getFlavor());
    }
 catch (    FlavorDomainException e) {
      throw new HumanReadableException(e,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",target,cxxPlatform.getFlavor().getName());
    }
  }
  return appleCxxPlatform;
}",0.9760191846522782
52892,"@NotNull @Override public FoldingDescriptor[] buildFoldRegions(@NotNull PsiElement root,@NotNull Document document,boolean quick){
  List<FoldingDescriptor> descriptors=new ArrayList<>();
  PsiTreeUtil.findChildrenOfAnyType(root,BuckRuleBlockImpl.class,BuckValueArrayImpl.class).stream().forEach(element -> {
    int offset=element instanceof BuckRuleBlockImpl ? 0 : 1;
    descriptors.add(new FoldingDescriptor(element.getNode(),new TextRange(element.getTextRange().getStartOffset() + offset,element.getTextRange().getEndOffset() - offset)));
  }
);
  return descriptors.toArray(new FoldingDescriptor[descriptors.size()]);
}","@NotNull @Override public FoldingDescriptor[] buildFoldRegions(@NotNull PsiElement root,@NotNull Document document,boolean quick){
  List<FoldingDescriptor> descriptors=new ArrayList<>();
  PsiTreeUtil.findChildrenOfAnyType(root,BuckRuleBlockImpl.class,BuckValueArrayImpl.class).stream().forEach(element -> {
    int offset=element instanceof BuckRuleBlockImpl ? 0 : 1;
    TextRange elementTextRange=element.getTextRange();
    TextRange foldingRange=new TextRange(elementTextRange.getStartOffset() + offset,elementTextRange.getEndOffset() - offset);
    if (foldingRange.getLength() > 0) {
      descriptors.add(new FoldingDescriptor(element.getNode(),foldingRange));
    }
  }
);
  return descriptors.toArray(new FoldingDescriptor[descriptors.size()]);
}",0.6107091172214182
52893,"@Override public void consumeTestResultsAvailable(long timestamp,TestResults testResults){
  final GeneralTestEventsProcessor processor=getProcessor();
  if (processor == null) {
    return;
  }
  for (  TestCaseSummary suite : testResults.getTestCases()) {
    if (suite.getTestResults().isEmpty()) {
      continue;
    }
    final String locationUrl=null;
    processor.onSuiteStarted(new TestSuiteStartedEvent(suite.getTestCaseName(),locationUrl));
    for (    TestResultsSummary test : suite.getTestResults()) {
      final String testName=test.getTestName();
      processor.onTestStarted(new TestStartedEvent(testName,null));
      final String stdOut=test.getStdOut();
      if (stdOut != null) {
        processor.onTestOutput(new TestOutputEvent(testName,stdOut,true));
      }
      final String stdErr=test.getStdErr();
      if (stdErr != null) {
        processor.onTestOutput(new TestOutputEvent(testName,stdErr,false));
      }
      if (test.getType() == ResultType.FAILURE) {
        processor.onTestFailure(new TestFailedEvent(testName,""String_Node_Str"",test.getStacktrace(),true,null,null));
      }
 else {
        processor.onTestFinished(new TestFinishedEvent(testName,test.getTime()));
      }
    }
    processor.onSuiteFinished(new TestSuiteFinishedEvent(suite.getTestCaseName()));
  }
}","@Override public void consumeTestResultsAvailable(long timestamp,TestResults testResults){
  final GeneralTestEventsProcessor processor=getProcessor();
  if (processor == null) {
    return;
  }
  for (  TestCaseSummary suite : testResults.getTestCases()) {
    if (suite.getTestResults().isEmpty()) {
      continue;
    }
    final String locationUrl=null;
    processor.onSuiteStarted(new TestSuiteStartedEvent(suite.getTestCaseName(),locationUrl));
    for (    TestResultsSummary test : suite.getTestResults()) {
      final String testName=test.getTestName();
      processor.onTestStarted(new TestStartedEvent(testName,null));
      final String stdOut=test.getStdOut();
      if (stdOut != null) {
        processor.onTestOutput(new TestOutputEvent(testName,stdOut,true));
      }
      final String stdErr=test.getStdErr();
      if (stdErr != null) {
        processor.onTestOutput(new TestOutputEvent(testName,stdErr,false));
      }
      if (test.getType() == ResultType.FAILURE) {
        processor.onTestFailure(new TestFailedEvent(testName,""String_Node_Str"",test.getStacktrace(),true,null,null));
      }
      processor.onTestFinished(new TestFinishedEvent(testName,test.getTime()));
    }
    processor.onSuiteFinished(new TestSuiteFinishedEvent(suite.getTestCaseName()));
  }
}",0.9302681992337164
52894,"@VisibleForTesting static NdkCxxPlatform build(CxxBuckConfig config,AndroidBuckConfig androidConfig,ProjectFilesystem filesystem,Flavor flavor,Platform platform,Path ndkRoot,NdkCxxPlatformTargetConfiguration targetConfiguration,NdkCxxRuntime cxxRuntime,ExecutableFinder executableFinder,boolean strictToolchainPaths){
  NdkCxxPlatformCompiler.Type compilerType=targetConfiguration.getCompiler().getType();
  String version=Joiner.on('-').join(ImmutableList.of(readVersion(ndkRoot),targetConfiguration.getToolchain(),targetConfiguration.getTargetAppPlatform(),compilerType,targetConfiguration.getCompiler().getVersion(),targetConfiguration.getCompiler().getGccVersion(),cxxRuntime));
  Host host=Preconditions.checkNotNull(BUILD_PLATFORMS.get(platform));
  NdkCxxToolchainPaths toolchainPaths=new NdkCxxToolchainPaths(filesystem,ndkRoot,targetConfiguration,host.toString(),cxxRuntime,strictToolchainPaths);
  NdkCxxToolchainPaths sanitizedPaths=toolchainPaths.getSanitizedPaths();
  ImmutableBiMap.Builder<Path,String> sanitizePathsBuilder=ImmutableBiMap.builder();
  sanitizePathsBuilder.put(toolchainPaths.getNdkToolRoot(),sanitizedPaths.getNdkToolRoot().toString());
  if (compilerType != NdkCxxPlatformCompiler.Type.GCC) {
    sanitizePathsBuilder.put(toolchainPaths.getNdkGccToolRoot(),sanitizedPaths.getNdkGccToolRoot().toString());
  }
  sanitizePathsBuilder.put(ndkRoot,ANDROID_NDK_ROOT);
  CxxToolProvider.Type type=compilerType == NdkCxxPlatformCompiler.Type.CLANG ? CxxToolProvider.Type.CLANG : CxxToolProvider.Type.GCC;
  ToolProvider ccTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.getCc(),version,executableFinder));
  ToolProvider cxxTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.getCxx(),version,executableFinder));
  CompilerProvider cc=new CompilerProvider(ccTool,type);
  PreprocessorProvider cpp=new PreprocessorProvider(ccTool,type);
  CompilerProvider cxx=new CompilerProvider(cxxTool,type);
  PreprocessorProvider cxxpp=new PreprocessorProvider(cxxTool,type);
  CxxPlatform.Builder cxxPlatformBuilder=CxxPlatform.builder();
  ImmutableBiMap<Path,String> sanitizePaths=sanitizePathsBuilder.build();
  PrefixMapDebugPathSanitizer compilerDebugPathSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",sanitizePaths,type);
  MungingDebugPathSanitizer assemblerDebugPathSanitizer=new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizePaths);
  cxxPlatformBuilder.setFlavor(flavor).setAs(cc).addAllAsflags(getAsflags(targetConfiguration,toolchainPaths)).setAspp(cpp).setCc(cc).addAllCflags(getCCompilationFlags(targetConfiguration,toolchainPaths,androidConfig)).setCpp(cpp).addAllCppflags(getCPreprocessorFlags(targetConfiguration,toolchainPaths,androidConfig)).setCxx(cxx).addAllCxxflags(getCxxCompilationFlags(targetConfiguration,toolchainPaths,androidConfig)).setCxxpp(cxxpp).addAllCxxppflags(getCxxPreprocessorFlags(targetConfiguration,toolchainPaths,androidConfig)).setLd(new DefaultLinkerProvider(LinkerProvider.Type.GNU,new ConstantToolProvider(getCcLinkTool(targetConfiguration,toolchainPaths,compilerType.getCxx(),version,cxxRuntime,executableFinder)))).addAllLdflags(getLdFlags(targetConfiguration,androidConfig)).setStrip(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).setSymbolNameTool(new PosixNmSymbolNameTool(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setAr(new GnuArchiver(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setRanlib(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).setCompilerDebugPathSanitizer(compilerDebugPathSanitizer).setAssemblerDebugPathSanitizer(assemblerDebugPathSanitizer).setSharedLibraryExtension(""String_Node_Str"").setSharedLibraryVersionedExtensionFormat(""String_Node_Str"").setStaticLibraryExtension(""String_Node_Str"").setObjectFileExtension(""String_Node_Str"").setSharedLibraryInterfaceFactory(config.shouldUseSharedLibraryInterfaces() ? Optional.of(ElfSharedLibraryInterfaceFactory.of(new ConstantToolProvider(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)))) : Optional.empty()).setPublicHeadersSymlinksEnabled(config.getPublicHeadersSymlinksEnabled()).setPrivateHeadersSymlinksEnabled(config.getPrivateHeadersSymlinksEnabled());
  HeaderVerification headerVerification=config.getHeaderVerification();
  try {
    headerVerification=headerVerification.withPlatformWhitelist(ImmutableList.of(""String_Node_Str"" + Pattern.quote(ndkRoot.toRealPath().toString() + File.separatorChar) + ""String_Node_Str""));
  }
 catch (  IOException e) {
    LOG.warn(e,""String_Node_Str"",ndkRoot);
  }
  cxxPlatformBuilder.setHeaderVerification(headerVerification);
  LOG.debug(""String_Node_Str"",ndkRoot.toString());
  LOG.debug(""String_Node_Str"",headerVerification.getPlatformWhitelist());
  if (cxxRuntime != NdkCxxRuntime.SYSTEM) {
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.SHARED,""String_Node_Str"" + cxxRuntime.getSharedName());
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.STATIC,""String_Node_Str"" + cxxRuntime.getStaticName());
  }
  CxxPlatform cxxPlatform=cxxPlatformBuilder.build();
  NdkCxxPlatform.Builder builder=NdkCxxPlatform.builder();
  builder.setCxxPlatform(cxxPlatform).setCxxRuntime(cxxRuntime).setObjdump(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder));
  if (cxxRuntime != NdkCxxRuntime.SYSTEM) {
    builder.setCxxSharedRuntimePath(toolchainPaths.getCxxRuntimeLibsDirectory().resolve(cxxRuntime.getSoname()));
  }
  return builder.build();
}","@VisibleForTesting static NdkCxxPlatform build(CxxBuckConfig config,AndroidBuckConfig androidConfig,ProjectFilesystem filesystem,Flavor flavor,Platform platform,Path ndkRoot,NdkCxxPlatformTargetConfiguration targetConfiguration,NdkCxxRuntime cxxRuntime,ExecutableFinder executableFinder,boolean strictToolchainPaths){
  NdkCxxPlatformCompiler.Type compilerType=targetConfiguration.getCompiler().getType();
  String version=Joiner.on('-').join(ImmutableList.of(readVersion(ndkRoot),targetConfiguration.getToolchain(),targetConfiguration.getTargetAppPlatform(),compilerType,targetConfiguration.getCompiler().getVersion(),targetConfiguration.getCompiler().getGccVersion(),cxxRuntime));
  Host host=Preconditions.checkNotNull(BUILD_PLATFORMS.get(platform));
  NdkCxxToolchainPaths toolchainPaths=new NdkCxxToolchainPaths(filesystem,ndkRoot,targetConfiguration,host.toString(),cxxRuntime,strictToolchainPaths);
  NdkCxxToolchainPaths sanitizedPaths=toolchainPaths.getSanitizedPaths();
  ImmutableBiMap.Builder<Path,String> sanitizePathsBuilder=ImmutableBiMap.builder();
  sanitizePathsBuilder.put(toolchainPaths.getNdkToolRoot(),sanitizedPaths.getNdkToolRoot().toString());
  if (compilerType != NdkCxxPlatformCompiler.Type.GCC) {
    sanitizePathsBuilder.put(toolchainPaths.getNdkGccToolRoot(),sanitizedPaths.getNdkGccToolRoot().toString());
  }
  sanitizePathsBuilder.put(ndkRoot,ANDROID_NDK_ROOT);
  CxxToolProvider.Type type=compilerType == NdkCxxPlatformCompiler.Type.CLANG ? CxxToolProvider.Type.CLANG : CxxToolProvider.Type.GCC;
  ToolProvider ccTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.getCc(),version,executableFinder));
  ToolProvider cxxTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.getCxx(),version,executableFinder));
  CompilerProvider cc=new CompilerProvider(ccTool,type);
  PreprocessorProvider cpp=new PreprocessorProvider(ccTool,type);
  CompilerProvider cxx=new CompilerProvider(cxxTool,type);
  PreprocessorProvider cxxpp=new PreprocessorProvider(cxxTool,type);
  CxxPlatform.Builder cxxPlatformBuilder=CxxPlatform.builder();
  ImmutableBiMap<Path,String> sanitizePaths=sanitizePathsBuilder.build();
  PrefixMapDebugPathSanitizer compilerDebugPathSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",sanitizePaths);
  MungingDebugPathSanitizer assemblerDebugPathSanitizer=new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizePaths);
  cxxPlatformBuilder.setFlavor(flavor).setAs(cc).addAllAsflags(getAsflags(targetConfiguration,toolchainPaths)).setAspp(cpp).setCc(cc).addAllCflags(getCCompilationFlags(targetConfiguration,toolchainPaths,androidConfig)).setCpp(cpp).addAllCppflags(getCPreprocessorFlags(targetConfiguration,toolchainPaths,androidConfig)).setCxx(cxx).addAllCxxflags(getCxxCompilationFlags(targetConfiguration,toolchainPaths,androidConfig)).setCxxpp(cxxpp).addAllCxxppflags(getCxxPreprocessorFlags(targetConfiguration,toolchainPaths,androidConfig)).setLd(new DefaultLinkerProvider(LinkerProvider.Type.GNU,new ConstantToolProvider(getCcLinkTool(targetConfiguration,toolchainPaths,compilerType.getCxx(),version,cxxRuntime,executableFinder)))).addAllLdflags(getLdFlags(targetConfiguration,androidConfig)).setStrip(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).setSymbolNameTool(new PosixNmSymbolNameTool(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setAr(new GnuArchiver(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setRanlib(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).setCompilerDebugPathSanitizer(compilerDebugPathSanitizer).setAssemblerDebugPathSanitizer(assemblerDebugPathSanitizer).setSharedLibraryExtension(""String_Node_Str"").setSharedLibraryVersionedExtensionFormat(""String_Node_Str"").setStaticLibraryExtension(""String_Node_Str"").setObjectFileExtension(""String_Node_Str"").setSharedLibraryInterfaceFactory(config.shouldUseSharedLibraryInterfaces() ? Optional.of(ElfSharedLibraryInterfaceFactory.of(new ConstantToolProvider(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)))) : Optional.empty()).setPublicHeadersSymlinksEnabled(config.getPublicHeadersSymlinksEnabled()).setPrivateHeadersSymlinksEnabled(config.getPrivateHeadersSymlinksEnabled());
  HeaderVerification headerVerification=config.getHeaderVerification();
  try {
    headerVerification=headerVerification.withPlatformWhitelist(ImmutableList.of(""String_Node_Str"" + Pattern.quote(ndkRoot.toRealPath().toString() + File.separatorChar) + ""String_Node_Str""));
  }
 catch (  IOException e) {
    LOG.warn(e,""String_Node_Str"",ndkRoot);
  }
  cxxPlatformBuilder.setHeaderVerification(headerVerification);
  LOG.debug(""String_Node_Str"",ndkRoot.toString());
  LOG.debug(""String_Node_Str"",headerVerification.getPlatformWhitelist());
  if (cxxRuntime != NdkCxxRuntime.SYSTEM) {
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.SHARED,""String_Node_Str"" + cxxRuntime.getSharedName());
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.STATIC,""String_Node_Str"" + cxxRuntime.getStaticName());
  }
  CxxPlatform cxxPlatform=cxxPlatformBuilder.build();
  NdkCxxPlatform.Builder builder=NdkCxxPlatform.builder();
  builder.setCxxPlatform(cxxPlatform).setCxxRuntime(cxxRuntime).setObjdump(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder));
  if (cxxRuntime != NdkCxxRuntime.SYSTEM) {
    builder.setCxxSharedRuntimePath(toolchainPaths.getCxxRuntimeLibsDirectory().resolve(cxxRuntime.getSoname()));
  }
  return builder.build();
}",0.9995540094549996
52895,"@VisibleForTesting static AppleCxxPlatform buildWithExecutableChecker(ProjectFilesystem filesystem,AppleSdk targetSdk,String minVersion,String targetArchitecture,final AppleSdkPaths sdkPaths,BuckConfig buckConfig,XcodeToolFinder xcodeToolFinder,XcodeBuildVersionCache xcodeBuildVersionCache,Optional<AppleToolchain> swiftToolChain){
  AppleCxxPlatform.Builder platformBuilder=AppleCxxPlatform.builder();
  ImmutableList.Builder<Path> toolSearchPathsBuilder=ImmutableList.builder();
  toolSearchPathsBuilder.add(sdkPaths.getSdkPath().resolve(USR_BIN)).add(sdkPaths.getSdkPath().resolve(""String_Node_Str"").resolve(USR_BIN)).add(sdkPaths.getPlatformPath().resolve(""String_Node_Str"").resolve(USR_BIN));
  for (  Path toolchainPath : sdkPaths.getToolchainPaths()) {
    toolSearchPathsBuilder.add(toolchainPath.resolve(USR_BIN));
  }
  if (sdkPaths.getDeveloperPath().isPresent()) {
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(USR_BIN));
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(""String_Node_Str""));
  }
  ImmutableList.Builder<String> cflagsBuilder=ImmutableList.builder();
  cflagsBuilder.add(""String_Node_Str"",sdkPaths.getSdkPath().toString());
  cflagsBuilder.add(""String_Node_Str"",filesystem.getRootPath().toString());
  cflagsBuilder.add(""String_Node_Str"",targetArchitecture);
  cflagsBuilder.add(targetSdk.getApplePlatform().getMinVersionFlagPrefix() + minVersion);
  if (targetSdk.getApplePlatform().equals(ApplePlatform.WATCHOS)) {
    cflagsBuilder.add(""String_Node_Str"");
  }
  ImmutableList.Builder<String> ldflagsBuilder=ImmutableList.builder();
  ldflagsBuilder.addAll(Linkers.iXlinker(""String_Node_Str"",targetSdk.getVersion(),""String_Node_Str""));
  if (targetSdk.getApplePlatform().equals(ApplePlatform.WATCHOS)) {
    ldflagsBuilder.addAll(Linkers.iXlinker(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  Optional<String> xcodeBuildVersion=Optional.empty();
  Optional<Path> developerPath=sdkPaths.getDeveloperPath();
  if (developerPath.isPresent()) {
    Path xcodeBundlePath=developerPath.get().getParent();
    if (xcodeBundlePath != null) {
      Path xcodeInfoPlistPath=xcodeBundlePath.resolve(""String_Node_Str"");
      try (InputStream stream=Files.newInputStream(xcodeInfoPlistPath)){
        NSDictionary parsedXcodeInfoPlist=(NSDictionary)PropertyListParser.parse(stream);
        NSObject xcodeVersionObject=parsedXcodeInfoPlist.objectForKey(""String_Node_Str"");
        if (xcodeVersionObject != null) {
          Optional<String> xcodeVersion=Optional.of(xcodeVersionObject.toString());
          platformBuilder.setXcodeVersion(xcodeVersion);
        }
      }
 catch (      IOException e) {
        LOG.warn(""String_Node_Str"",xcodeInfoPlistPath);
      }
catch (      PropertyListFormatException|ParseException|ParserConfigurationException|SAXException e) {
        LOG.warn(""String_Node_Str"",xcodeInfoPlistPath);
      }
    }
    xcodeBuildVersion=xcodeBuildVersionCache.lookup(developerPath.get());
    platformBuilder.setXcodeBuildVersion(xcodeBuildVersion);
    LOG.debug(""String_Node_Str"" + xcodeBuildVersion.orElse(""String_Node_Str""));
  }
  ImmutableList.Builder<String> versions=ImmutableList.builder();
  versions.add(targetSdk.getVersion());
  ImmutableList<String> toolchainVersions=targetSdk.getToolchains().stream().map(AppleToolchain::getVersion).flatMap(Optionals::toStream).collect(MoreCollectors.toImmutableList());
  if (toolchainVersions.isEmpty()) {
    if (!xcodeBuildVersion.isPresent()) {
      throw new HumanReadableException(""String_Node_Str"");
    }
    versions.add(xcodeBuildVersion.get());
  }
 else {
    versions.addAll(toolchainVersions);
  }
  String version=Joiner.on(':').join(versions.build());
  ImmutableList<Path> toolSearchPaths=toolSearchPathsBuilder.build();
  Tool clangPath=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool clangXxPath=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool ar=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool ranlib=VersionedTool.builder().setPath(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder)).setName(""String_Node_Str"").setVersion(version).build();
  Tool strip=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool nm=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool actool=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool ibtool=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool momc=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool xctest=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool dsymutil=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool lipo=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool lldb=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Optional<Path> stubBinaryPath=targetSdk.getApplePlatform().getStubBinaryPath().map(input -> sdkPaths.getSdkPath().resolve(input));
  CxxBuckConfig config=new CxxBuckConfig(buckConfig);
  UserFlavor targetFlavor=UserFlavor.of(Flavor.replaceInvalidCharacters(targetSdk.getName() + ""String_Node_Str"" + targetArchitecture),String.format(""String_Node_Str"",targetSdk.getName(),targetArchitecture));
  ImmutableBiMap.Builder<Path,String> sanitizerPaths=ImmutableBiMap.builder();
  sanitizerPaths.put(sdkPaths.getSdkPath(),""String_Node_Str"");
  sanitizerPaths.put(sdkPaths.getPlatformPath(),""String_Node_Str"");
  if (sdkPaths.getDeveloperPath().isPresent()) {
    sanitizerPaths.put(sdkPaths.getDeveloperPath().get(),""String_Node_Str"");
  }
  DebugPathSanitizer compilerDebugPathSanitizer=new PrefixMapDebugPathSanitizer(DebugPathSanitizer.getPaddedDir(""String_Node_Str"",config.getDebugPathSanitizerLimit(),File.separatorChar),sanitizerPaths.build(),CxxToolProvider.Type.CLANG);
  DebugPathSanitizer assemblerDebugPathSanitizer=new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizerPaths.build());
  ImmutableList<String> cflags=cflagsBuilder.build();
  ImmutableMap.Builder<String,String> macrosBuilder=ImmutableMap.builder();
  macrosBuilder.put(""String_Node_Str"",sdkPaths.getSdkPath().toString());
  macrosBuilder.put(""String_Node_Str"",sdkPaths.getPlatformPath().toString());
  macrosBuilder.put(""String_Node_Str"",targetArchitecture);
  if (sdkPaths.getDeveloperPath().isPresent()) {
    macrosBuilder.put(""String_Node_Str"",sdkPaths.getDeveloperPath().get().toString());
  }
  ImmutableMap<String,String> macros=macrosBuilder.build();
  Optional<String> buildVersion=Optional.empty();
  Path platformVersionPlistPath=sdkPaths.getPlatformPath().resolve(""String_Node_Str"");
  try (InputStream versionPlist=Files.newInputStream(platformVersionPlistPath)){
    NSDictionary versionInfo=(NSDictionary)PropertyListParser.parse(versionPlist);
    if (versionInfo != null) {
      NSObject productBuildVersion=versionInfo.objectForKey(""String_Node_Str"");
      if (productBuildVersion != null) {
        buildVersion=Optional.of(productBuildVersion.toString());
      }
 else {
        LOG.warn(""String_Node_Str"",platformVersionPlistPath);
      }
    }
 else {
      LOG.warn(""String_Node_Str"",platformVersionPlistPath);
    }
  }
 catch (  NoSuchFileException e) {
    LOG.warn(""String_Node_Str"",platformVersionPlistPath);
  }
catch (  PropertyListFormatException|SAXException|ParserConfigurationException|ParseException|IOException e) {
    LOG.warn(e,""String_Node_Str"",platformVersionPlistPath);
  }
  PreprocessorProvider aspp=new PreprocessorProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  CompilerProvider as=new CompilerProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  PreprocessorProvider cpp=new PreprocessorProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  CompilerProvider cc=new CompilerProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  PreprocessorProvider cxxpp=new PreprocessorProvider(new ConstantToolProvider(clangXxPath),CxxToolProvider.Type.CLANG);
  CompilerProvider cxx=new CompilerProvider(new ConstantToolProvider(clangXxPath),CxxToolProvider.Type.CLANG);
  ImmutableList.Builder<String> whitelistBuilder=ImmutableList.builder();
  whitelistBuilder.add(""String_Node_Str"" + Pattern.quote(sdkPaths.getSdkPath().toString()) + ""String_Node_Str"");
  whitelistBuilder.add(""String_Node_Str"" + Pattern.quote(sdkPaths.getPlatformPath().toString() + ""String_Node_Str"") + ""String_Node_Str"");
  for (  Path toolchainPath : sdkPaths.getToolchainPaths()) {
    LOG.debug(""String_Node_Str"",toolchainPath);
    try {
      whitelistBuilder.add(""String_Node_Str"" + Pattern.quote(toolchainPath.toRealPath().toString()) + ""String_Node_Str"");
    }
 catch (    IOException e) {
      LOG.warn(e,""String_Node_Str"",toolchainPath);
    }
  }
  HeaderVerification headerVerification=config.getHeaderVerification().withPlatformWhitelist(whitelistBuilder.build());
  LOG.debug(""String_Node_Str"",headerVerification.getPlatformWhitelist());
  CxxPlatform cxxPlatform=CxxPlatforms.build(targetFlavor,Platform.MACOS,config,as,aspp,cc,cxx,cpp,cxxpp,new DefaultLinkerProvider(LinkerProvider.Type.DARWIN,new ConstantToolProvider(clangXxPath)),ImmutableList.<String>builder().addAll(cflags).addAll(ldflagsBuilder.build()).build(),strip,new BsdArchiver(ar),ranlib,new PosixNmSymbolNameTool(nm),cflagsBuilder.build(),ImmutableList.of(),cflags,ImmutableList.of(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",compilerDebugPathSanitizer,assemblerDebugPathSanitizer,macros,Optional.empty(),headerVerification);
  ApplePlatform applePlatform=targetSdk.getApplePlatform();
  ImmutableList.Builder<Path> swiftOverrideSearchPathBuilder=ImmutableList.builder();
  AppleSdkPaths.Builder swiftSdkPathsBuilder=AppleSdkPaths.builder().from(sdkPaths);
  if (swiftToolChain.isPresent()) {
    swiftOverrideSearchPathBuilder.add(swiftToolChain.get().getPath().resolve(USR_BIN));
    swiftSdkPathsBuilder.setToolchainPaths(ImmutableList.of(swiftToolChain.get().getPath()));
  }
  Optional<SwiftPlatform> swiftPlatform=getSwiftPlatform(applePlatform.getName(),targetArchitecture + ""String_Node_Str"" + applePlatform.getSwiftName().orElse(applePlatform.getName())+ minVersion,version,swiftSdkPathsBuilder.build(),swiftOverrideSearchPathBuilder.addAll(toolSearchPaths).build(),xcodeToolFinder);
  AppleConfig appleConfig=buckConfig.getView(AppleConfig.class);
  platformBuilder.setCxxPlatform(cxxPlatform).setSwiftPlatform(swiftPlatform).setAppleSdk(targetSdk).setAppleSdkPaths(sdkPaths).setMinVersion(minVersion).setBuildVersion(buildVersion).setActool(actool).setIbtool(ibtool).setMomc(momc).setCopySceneKitAssets(getOptionalTool(""String_Node_Str"",toolSearchPaths,xcodeToolFinder,version)).setXctest(xctest).setDsymutil(dsymutil).setLipo(lipo).setStubBinary(stubBinaryPath).setLldb(lldb).setCodesignAllocate(getOptionalTool(""String_Node_Str"",toolSearchPaths,xcodeToolFinder,version)).setCodesignProvider(appleConfig.getCodesignProvider());
  return platformBuilder.build();
}","@VisibleForTesting static AppleCxxPlatform buildWithExecutableChecker(ProjectFilesystem filesystem,AppleSdk targetSdk,String minVersion,String targetArchitecture,final AppleSdkPaths sdkPaths,BuckConfig buckConfig,XcodeToolFinder xcodeToolFinder,XcodeBuildVersionCache xcodeBuildVersionCache,Optional<AppleToolchain> swiftToolChain){
  AppleCxxPlatform.Builder platformBuilder=AppleCxxPlatform.builder();
  ImmutableList.Builder<Path> toolSearchPathsBuilder=ImmutableList.builder();
  toolSearchPathsBuilder.add(sdkPaths.getSdkPath().resolve(USR_BIN)).add(sdkPaths.getSdkPath().resolve(""String_Node_Str"").resolve(USR_BIN)).add(sdkPaths.getPlatformPath().resolve(""String_Node_Str"").resolve(USR_BIN));
  for (  Path toolchainPath : sdkPaths.getToolchainPaths()) {
    toolSearchPathsBuilder.add(toolchainPath.resolve(USR_BIN));
  }
  if (sdkPaths.getDeveloperPath().isPresent()) {
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(USR_BIN));
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(""String_Node_Str""));
  }
  ImmutableList.Builder<String> cflagsBuilder=ImmutableList.builder();
  cflagsBuilder.add(""String_Node_Str"",sdkPaths.getSdkPath().toString());
  cflagsBuilder.add(""String_Node_Str"",filesystem.getRootPath().toString());
  cflagsBuilder.add(""String_Node_Str"",targetArchitecture);
  cflagsBuilder.add(targetSdk.getApplePlatform().getMinVersionFlagPrefix() + minVersion);
  if (targetSdk.getApplePlatform().equals(ApplePlatform.WATCHOS)) {
    cflagsBuilder.add(""String_Node_Str"");
  }
  ImmutableList.Builder<String> ldflagsBuilder=ImmutableList.builder();
  ldflagsBuilder.addAll(Linkers.iXlinker(""String_Node_Str"",targetSdk.getVersion(),""String_Node_Str""));
  if (targetSdk.getApplePlatform().equals(ApplePlatform.WATCHOS)) {
    ldflagsBuilder.addAll(Linkers.iXlinker(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  Optional<String> xcodeBuildVersion=Optional.empty();
  Optional<Path> developerPath=sdkPaths.getDeveloperPath();
  if (developerPath.isPresent()) {
    Path xcodeBundlePath=developerPath.get().getParent();
    if (xcodeBundlePath != null) {
      Path xcodeInfoPlistPath=xcodeBundlePath.resolve(""String_Node_Str"");
      try (InputStream stream=Files.newInputStream(xcodeInfoPlistPath)){
        NSDictionary parsedXcodeInfoPlist=(NSDictionary)PropertyListParser.parse(stream);
        NSObject xcodeVersionObject=parsedXcodeInfoPlist.objectForKey(""String_Node_Str"");
        if (xcodeVersionObject != null) {
          Optional<String> xcodeVersion=Optional.of(xcodeVersionObject.toString());
          platformBuilder.setXcodeVersion(xcodeVersion);
        }
      }
 catch (      IOException e) {
        LOG.warn(""String_Node_Str"",xcodeInfoPlistPath);
      }
catch (      PropertyListFormatException|ParseException|ParserConfigurationException|SAXException e) {
        LOG.warn(""String_Node_Str"",xcodeInfoPlistPath);
      }
    }
    xcodeBuildVersion=xcodeBuildVersionCache.lookup(developerPath.get());
    platformBuilder.setXcodeBuildVersion(xcodeBuildVersion);
    LOG.debug(""String_Node_Str"" + xcodeBuildVersion.orElse(""String_Node_Str""));
  }
  ImmutableList.Builder<String> versions=ImmutableList.builder();
  versions.add(targetSdk.getVersion());
  ImmutableList<String> toolchainVersions=targetSdk.getToolchains().stream().map(AppleToolchain::getVersion).flatMap(Optionals::toStream).collect(MoreCollectors.toImmutableList());
  if (toolchainVersions.isEmpty()) {
    if (!xcodeBuildVersion.isPresent()) {
      throw new HumanReadableException(""String_Node_Str"");
    }
    versions.add(xcodeBuildVersion.get());
  }
 else {
    versions.addAll(toolchainVersions);
  }
  String version=Joiner.on(':').join(versions.build());
  ImmutableList<Path> toolSearchPaths=toolSearchPathsBuilder.build();
  Tool clangPath=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool clangXxPath=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool ar=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool ranlib=VersionedTool.builder().setPath(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder)).setName(""String_Node_Str"").setVersion(version).build();
  Tool strip=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool nm=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool actool=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool ibtool=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool momc=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool xctest=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool dsymutil=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool lipo=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool lldb=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Optional<Path> stubBinaryPath=targetSdk.getApplePlatform().getStubBinaryPath().map(input -> sdkPaths.getSdkPath().resolve(input));
  CxxBuckConfig config=new CxxBuckConfig(buckConfig);
  UserFlavor targetFlavor=UserFlavor.of(Flavor.replaceInvalidCharacters(targetSdk.getName() + ""String_Node_Str"" + targetArchitecture),String.format(""String_Node_Str"",targetSdk.getName(),targetArchitecture));
  ImmutableBiMap.Builder<Path,String> sanitizerPaths=ImmutableBiMap.builder();
  sanitizerPaths.put(sdkPaths.getSdkPath(),""String_Node_Str"");
  sanitizerPaths.put(sdkPaths.getPlatformPath(),""String_Node_Str"");
  if (sdkPaths.getDeveloperPath().isPresent()) {
    sanitizerPaths.put(sdkPaths.getDeveloperPath().get(),""String_Node_Str"");
  }
  DebugPathSanitizer compilerDebugPathSanitizer=new PrefixMapDebugPathSanitizer(DebugPathSanitizer.getPaddedDir(""String_Node_Str"",config.getDebugPathSanitizerLimit(),File.separatorChar),sanitizerPaths.build());
  DebugPathSanitizer assemblerDebugPathSanitizer=new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizerPaths.build());
  ImmutableList<String> cflags=cflagsBuilder.build();
  ImmutableMap.Builder<String,String> macrosBuilder=ImmutableMap.builder();
  macrosBuilder.put(""String_Node_Str"",sdkPaths.getSdkPath().toString());
  macrosBuilder.put(""String_Node_Str"",sdkPaths.getPlatformPath().toString());
  macrosBuilder.put(""String_Node_Str"",targetArchitecture);
  if (sdkPaths.getDeveloperPath().isPresent()) {
    macrosBuilder.put(""String_Node_Str"",sdkPaths.getDeveloperPath().get().toString());
  }
  ImmutableMap<String,String> macros=macrosBuilder.build();
  Optional<String> buildVersion=Optional.empty();
  Path platformVersionPlistPath=sdkPaths.getPlatformPath().resolve(""String_Node_Str"");
  try (InputStream versionPlist=Files.newInputStream(platformVersionPlistPath)){
    NSDictionary versionInfo=(NSDictionary)PropertyListParser.parse(versionPlist);
    if (versionInfo != null) {
      NSObject productBuildVersion=versionInfo.objectForKey(""String_Node_Str"");
      if (productBuildVersion != null) {
        buildVersion=Optional.of(productBuildVersion.toString());
      }
 else {
        LOG.warn(""String_Node_Str"",platformVersionPlistPath);
      }
    }
 else {
      LOG.warn(""String_Node_Str"",platformVersionPlistPath);
    }
  }
 catch (  NoSuchFileException e) {
    LOG.warn(""String_Node_Str"",platformVersionPlistPath);
  }
catch (  PropertyListFormatException|SAXException|ParserConfigurationException|ParseException|IOException e) {
    LOG.warn(e,""String_Node_Str"",platformVersionPlistPath);
  }
  PreprocessorProvider aspp=new PreprocessorProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  CompilerProvider as=new CompilerProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  PreprocessorProvider cpp=new PreprocessorProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  CompilerProvider cc=new CompilerProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  PreprocessorProvider cxxpp=new PreprocessorProvider(new ConstantToolProvider(clangXxPath),CxxToolProvider.Type.CLANG);
  CompilerProvider cxx=new CompilerProvider(new ConstantToolProvider(clangXxPath),CxxToolProvider.Type.CLANG);
  ImmutableList.Builder<String> whitelistBuilder=ImmutableList.builder();
  whitelistBuilder.add(""String_Node_Str"" + Pattern.quote(sdkPaths.getSdkPath().toString()) + ""String_Node_Str"");
  whitelistBuilder.add(""String_Node_Str"" + Pattern.quote(sdkPaths.getPlatformPath().toString() + ""String_Node_Str"") + ""String_Node_Str"");
  for (  Path toolchainPath : sdkPaths.getToolchainPaths()) {
    LOG.debug(""String_Node_Str"",toolchainPath);
    try {
      whitelistBuilder.add(""String_Node_Str"" + Pattern.quote(toolchainPath.toRealPath().toString()) + ""String_Node_Str"");
    }
 catch (    IOException e) {
      LOG.warn(e,""String_Node_Str"",toolchainPath);
    }
  }
  HeaderVerification headerVerification=config.getHeaderVerification().withPlatformWhitelist(whitelistBuilder.build());
  LOG.debug(""String_Node_Str"",headerVerification.getPlatformWhitelist());
  CxxPlatform cxxPlatform=CxxPlatforms.build(targetFlavor,Platform.MACOS,config,as,aspp,cc,cxx,cpp,cxxpp,new DefaultLinkerProvider(LinkerProvider.Type.DARWIN,new ConstantToolProvider(clangXxPath)),ImmutableList.<String>builder().addAll(cflags).addAll(ldflagsBuilder.build()).build(),strip,new BsdArchiver(ar),ranlib,new PosixNmSymbolNameTool(nm),cflagsBuilder.build(),ImmutableList.of(),cflags,ImmutableList.of(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",compilerDebugPathSanitizer,assemblerDebugPathSanitizer,macros,Optional.empty(),headerVerification);
  ApplePlatform applePlatform=targetSdk.getApplePlatform();
  ImmutableList.Builder<Path> swiftOverrideSearchPathBuilder=ImmutableList.builder();
  AppleSdkPaths.Builder swiftSdkPathsBuilder=AppleSdkPaths.builder().from(sdkPaths);
  if (swiftToolChain.isPresent()) {
    swiftOverrideSearchPathBuilder.add(swiftToolChain.get().getPath().resolve(USR_BIN));
    swiftSdkPathsBuilder.setToolchainPaths(ImmutableList.of(swiftToolChain.get().getPath()));
  }
  Optional<SwiftPlatform> swiftPlatform=getSwiftPlatform(applePlatform.getName(),targetArchitecture + ""String_Node_Str"" + applePlatform.getSwiftName().orElse(applePlatform.getName())+ minVersion,version,swiftSdkPathsBuilder.build(),swiftOverrideSearchPathBuilder.addAll(toolSearchPaths).build(),xcodeToolFinder);
  AppleConfig appleConfig=buckConfig.getView(AppleConfig.class);
  platformBuilder.setCxxPlatform(cxxPlatform).setSwiftPlatform(swiftPlatform).setAppleSdk(targetSdk).setAppleSdkPaths(sdkPaths).setMinVersion(minVersion).setBuildVersion(buildVersion).setActool(actool).setIbtool(ibtool).setMomc(momc).setCopySceneKitAssets(getOptionalTool(""String_Node_Str"",toolSearchPaths,xcodeToolFinder,version)).setXctest(xctest).setDsymutil(dsymutil).setLipo(lipo).setStubBinary(stubBinaryPath).setLldb(lldb).setCodesignAllocate(getOptionalTool(""String_Node_Str"",toolSearchPaths,xcodeToolFinder,version)).setCodesignProvider(appleConfig.getCodesignProvider());
  return platformBuilder.build();
}",0.998841350899026
52896,"@SuppressWarnings(""String_Node_Str"") ImmutableList<String> getCompilationFlags(Path workingDir,ImmutableMap<Path,Path> prefixMap){
  return ImmutableList.of();
}","@SuppressWarnings(""String_Node_Str"") ImmutableList<String> getCompilationFlags(Compiler compiler,Path workingDir,ImmutableMap<Path,Path> prefixMap){
  return ImmutableList.of();
}",0.9470588235294116
52897,"public static CxxPlatform build(Platform platform,CxxBuckConfig config){
  String sharedLibraryExtension;
  String sharedLibraryVersionedExtensionFormat;
  String staticLibraryExtension;
  String objectFileExtension;
  Path defaultCFrontend;
  Path defaultCxxFrontend;
  Path defaultLinker;
  LinkerProvider.Type linkerType;
  Archiver archiver;
  DebugPathSanitizer compilerSanitizer;
  Optional<String> binaryExtension;
  ImmutableMap<String,String> env=config.getEnvironment();
  Optional<CxxToolProvider.Type> defaultToolType=Optional.empty();
  String ranlibCommand;
switch (platform) {
case LINUX:
    sharedLibraryExtension=""String_Node_Str"";
  sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_C_FRONTEND,env);
defaultCxxFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_CXX_FRONTEND,env);
defaultLinker=defaultCxxFrontend;
linkerType=LinkerProvider.Type.GNU;
archiver=new GnuArchiver(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_AR,env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",ImmutableBiMap.of(),CxxToolProvider.Type.GCC);
binaryExtension=Optional.empty();
ranlibCommand=DEFAULT_UNIX_RANLIB;
break;
case MACOS:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_OSX_C_FRONTEND,env);
defaultCxxFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_OSX_CXX_FRONTEND,env);
defaultLinker=defaultCxxFrontend;
linkerType=LinkerProvider.Type.DARWIN;
archiver=new BsdArchiver(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_AR,env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",ImmutableBiMap.of(),CxxToolProvider.Type.CLANG);
binaryExtension=Optional.empty();
ranlibCommand=DEFAULT_UNIX_RANLIB;
break;
case WINDOWS:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(DEFAULT_WINDOWS_CXX_FRONTEND,Paths.get(DEFAULT_WINDOWS_CXX_FRONTEND),env);
defaultCxxFrontend=getExecutablePath(DEFAULT_WINDOWS_CXX_FRONTEND,Paths.get(DEFAULT_WINDOWS_CXX_FRONTEND),env);
defaultLinker=getExecutablePath(DEFAULT_WINDOWS_LINK,Paths.get(DEFAULT_WINDOWS_LINK),env);
linkerType=LinkerProvider.Type.WINDOWS;
archiver=new WindowsArchiver(new HashedFileTool(getExecutablePath(DEFAULT_WINDOWS_LIB,Paths.get(DEFAULT_WINDOWS_LIB),env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",ImmutableBiMap.of(),CxxToolProvider.Type.WINDOWS);
binaryExtension=Optional.of(""String_Node_Str"");
defaultToolType=Optional.of(CxxToolProvider.Type.WINDOWS);
ranlibCommand=DEFAULT_WINDOWS_RANLIB;
break;
case FREEBSD:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_C_FRONTEND,env);
defaultCxxFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_CXX_FRONTEND,env);
defaultLinker=defaultCxxFrontend;
linkerType=LinkerProvider.Type.GNU;
archiver=new BsdArchiver(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_AR,env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",ImmutableBiMap.of(),CxxToolProvider.Type.GCC);
binaryExtension=Optional.empty();
ranlibCommand=DEFAULT_UNIX_RANLIB;
break;
default :
throw new RuntimeException(String.format(""String_Node_Str"",platform));
}
PreprocessorProvider aspp=new PreprocessorProvider(defaultCFrontend,defaultToolType);
CompilerProvider as=new CompilerProvider(defaultCFrontend,defaultToolType);
PreprocessorProvider cpp=new PreprocessorProvider(defaultCFrontend,defaultToolType);
CompilerProvider cc=new CompilerProvider(defaultCFrontend,defaultToolType);
PreprocessorProvider cxxpp=new PreprocessorProvider(defaultCxxFrontend,defaultToolType);
CompilerProvider cxx=new CompilerProvider(defaultCxxFrontend,defaultToolType);
return CxxPlatforms.build(FLAVOR,platform,config,as,aspp,cc,cxx,cpp,cxxpp,new DefaultLinkerProvider(linkerType,new ConstantToolProvider(new HashedFileTool(defaultLinker))),ImmutableList.of(),new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_STRIP,env)),archiver,new HashedFileTool(getExecutablePath(ranlibCommand,DEFAULT_RANLIB,env)),new PosixNmSymbolNameTool(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_NM,env))),ImmutableList.of(),ImmutableList.of(),ImmutableList.of(),ImmutableList.of(),sharedLibraryExtension,sharedLibraryVersionedExtensionFormat,staticLibraryExtension,objectFileExtension,compilerSanitizer,new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),ImmutableBiMap.of()),ImmutableMap.of(),binaryExtension,config.getHeaderVerification());
}","public static CxxPlatform build(Platform platform,CxxBuckConfig config){
  String sharedLibraryExtension;
  String sharedLibraryVersionedExtensionFormat;
  String staticLibraryExtension;
  String objectFileExtension;
  Path defaultCFrontend;
  Path defaultCxxFrontend;
  Path defaultLinker;
  LinkerProvider.Type linkerType;
  Archiver archiver;
  DebugPathSanitizer compilerSanitizer;
  Optional<String> binaryExtension;
  ImmutableMap<String,String> env=config.getEnvironment();
  Optional<CxxToolProvider.Type> defaultToolType=Optional.empty();
  String ranlibCommand;
switch (platform) {
case LINUX:
    sharedLibraryExtension=""String_Node_Str"";
  sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_C_FRONTEND,env);
defaultCxxFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_CXX_FRONTEND,env);
defaultLinker=defaultCxxFrontend;
linkerType=LinkerProvider.Type.GNU;
archiver=new GnuArchiver(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_AR,env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",ImmutableBiMap.of());
binaryExtension=Optional.empty();
ranlibCommand=DEFAULT_UNIX_RANLIB;
break;
case MACOS:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_OSX_C_FRONTEND,env);
defaultCxxFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_OSX_CXX_FRONTEND,env);
defaultLinker=defaultCxxFrontend;
linkerType=LinkerProvider.Type.DARWIN;
archiver=new BsdArchiver(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_AR,env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",ImmutableBiMap.of());
binaryExtension=Optional.empty();
ranlibCommand=DEFAULT_UNIX_RANLIB;
break;
case WINDOWS:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(DEFAULT_WINDOWS_CXX_FRONTEND,Paths.get(DEFAULT_WINDOWS_CXX_FRONTEND),env);
defaultCxxFrontend=getExecutablePath(DEFAULT_WINDOWS_CXX_FRONTEND,Paths.get(DEFAULT_WINDOWS_CXX_FRONTEND),env);
defaultLinker=getExecutablePath(DEFAULT_WINDOWS_LINK,Paths.get(DEFAULT_WINDOWS_LINK),env);
linkerType=LinkerProvider.Type.WINDOWS;
archiver=new WindowsArchiver(new HashedFileTool(getExecutablePath(DEFAULT_WINDOWS_LIB,Paths.get(DEFAULT_WINDOWS_LIB),env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",ImmutableBiMap.of());
binaryExtension=Optional.of(""String_Node_Str"");
defaultToolType=Optional.of(CxxToolProvider.Type.WINDOWS);
ranlibCommand=DEFAULT_WINDOWS_RANLIB;
break;
case FREEBSD:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_C_FRONTEND,env);
defaultCxxFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_CXX_FRONTEND,env);
defaultLinker=defaultCxxFrontend;
linkerType=LinkerProvider.Type.GNU;
archiver=new BsdArchiver(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_AR,env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",ImmutableBiMap.of());
binaryExtension=Optional.empty();
ranlibCommand=DEFAULT_UNIX_RANLIB;
break;
default :
throw new RuntimeException(String.format(""String_Node_Str"",platform));
}
PreprocessorProvider aspp=new PreprocessorProvider(defaultCFrontend,defaultToolType);
CompilerProvider as=new CompilerProvider(defaultCFrontend,defaultToolType);
PreprocessorProvider cpp=new PreprocessorProvider(defaultCFrontend,defaultToolType);
CompilerProvider cc=new CompilerProvider(defaultCFrontend,defaultToolType);
PreprocessorProvider cxxpp=new PreprocessorProvider(defaultCxxFrontend,defaultToolType);
CompilerProvider cxx=new CompilerProvider(defaultCxxFrontend,defaultToolType);
return CxxPlatforms.build(FLAVOR,platform,config,as,aspp,cc,cxx,cpp,cxxpp,new DefaultLinkerProvider(linkerType,new ConstantToolProvider(new HashedFileTool(defaultLinker))),ImmutableList.of(),new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_STRIP,env)),archiver,new HashedFileTool(getExecutablePath(ranlibCommand,DEFAULT_RANLIB,env)),new PosixNmSymbolNameTool(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_NM,env))),ImmutableList.of(),ImmutableList.of(),ImmutableList.of(),ImmutableList.of(),sharedLibraryExtension,sharedLibraryVersionedExtensionFormat,staticLibraryExtension,objectFileExtension,compilerSanitizer,new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),ImmutableBiMap.of()),ImmutableMap.of(),binaryExtension,config.getHeaderVerification());
}",0.9739130434782608
52898,"public PrefixMapDebugPathSanitizer(String fakeCompilationDirectory,ImmutableBiMap<Path,String> other,CxxToolProvider.Type cxxType){
  this.fakeCompilationDirectory=fakeCompilationDirectory;
  this.isGcc=cxxType == CxxToolProvider.Type.GCC;
  this.cxxType=cxxType;
  this.other=other;
}","public PrefixMapDebugPathSanitizer(String fakeCompilationDirectory,ImmutableBiMap<Path,String> other){
  this.fakeCompilationDirectory=fakeCompilationDirectory;
  this.other=other;
}",0.7794432548179872
52899,"@Override ImmutableList<String> getCompilationFlags(Path workingDir,ImmutableMap<Path,Path> prefixMap){
  if (cxxType == CxxToolProvider.Type.WINDOWS) {
    return ImmutableList.of();
  }
  ImmutableList.Builder<String> flags=ImmutableList.builder();
  RichStream.<Map.Entry<Path,String>>empty().concat(isGcc ? Stream.empty() : prefixMap.entrySet().stream().map(e -> new AbstractMap.SimpleEntry<>(e.getKey(),e.getValue().toString()))).concat(RichStream.from(getAllPaths(Optional.of(workingDir)))).sorted(Comparator.comparingInt(entry -> entry.getKey().toString().length())).map(p -> getDebugPrefixMapFlag(p.getKey(),p.getValue())).forEach(flags::add);
  if (isGcc) {
    flags.add(""String_Node_Str"");
  }
  return flags.build();
}","@Override ImmutableList<String> getCompilationFlags(Compiler compiler,Path workingDir,ImmutableMap<Path,Path> prefixMap){
  if (compiler instanceof WindowsCompiler) {
    return ImmutableList.of();
  }
  ImmutableList.Builder<String> flags=ImmutableList.builder();
  RichStream.<Map.Entry<Path,String>>empty().concat(compiler instanceof GccCompiler ? Stream.empty() : prefixMap.entrySet().stream().map(e -> new AbstractMap.SimpleEntry<>(e.getKey(),e.getValue().toString()))).concat(RichStream.from(getAllPaths(Optional.of(workingDir)))).sorted(Comparator.comparingInt(entry -> entry.getKey().toString().length())).map(p -> getDebugPrefixMapFlag(p.getKey(),p.getValue())).forEach(flags::add);
  if (compiler instanceof GccCompiler) {
    flags.add(""String_Node_Str"");
  }
  return flags.build();
}",0.9030144167758848
52900,"@Override ImmutableList<String> getCompilationFlags(Path workingDir,ImmutableMap<Path,Path> prefixMap){
  if (cxxType == CxxToolProvider.Type.WINDOWS) {
    return ImmutableList.of();
  }
  ImmutableList.Builder<String> flags=ImmutableList.builder();
  RichStream.from(prefixMap.entrySet()).<Map.Entry<Path,String>>map(e -> new AbstractMap.SimpleEntry<>(e.getKey(),e.getValue().toString())).concat(RichStream.from(getAllPaths(Optional.of(workingDir)))).sorted(Comparator.comparingInt(entry -> entry.getKey().toString().length())).map(p -> getDebugPrefixMapFlag(p.getKey(),p.getValue())).forEach(flags::add);
  if (isGcc) {
    flags.add(""String_Node_Str"");
  }
  return flags.build();
}","@Override ImmutableList<String> getCompilationFlags(Path workingDir,ImmutableMap<Path,Path> prefixMap){
  if (cxxType == CxxToolProvider.Type.WINDOWS) {
    return ImmutableList.of();
  }
  ImmutableList.Builder<String> flags=ImmutableList.builder();
  RichStream.<Map.Entry<Path,String>>empty().concat(isGcc ? Stream.empty() : prefixMap.entrySet().stream().map(e -> new AbstractMap.SimpleEntry<>(e.getKey(),e.getValue().toString()))).concat(RichStream.from(getAllPaths(Optional.of(workingDir)))).sorted(Comparator.comparingInt(entry -> entry.getKey().toString().length())).map(p -> getDebugPrefixMapFlag(p.getKey(),p.getValue())).forEach(flags::add);
  if (isGcc) {
    flags.add(""String_Node_Str"");
  }
  return flags.build();
}",0.8573446327683616
52901,"@Test public void testUberCompilationDatabase() throws IOException {
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  ProjectFilesystem filesystem=new FakeProjectFilesystem();
  Path compilationDatabase=workspace.buildAndReturnOutput(target.getFullyQualifiedName());
  Path rootPath=tmp.getRoot();
  assertEquals(BuildTargets.getGenPath(filesystem,target,""String_Node_Str""),rootPath.relativize(compilationDatabase));
  Path binaryHeaderSymlinkTreeFolder=BuildTargets.getGenPath(filesystem,target.withFlavors(InternalFlavor.of(""String_Node_Str""),CxxDescriptionEnhancer.HEADER_SYMLINK_TREE_FLAVOR),""String_Node_Str"");
  Map<String,CxxCompilationDatabaseEntry> fileToEntry=CxxCompilationDatabaseUtils.parseCompilationDatabaseJsonFile(compilationDatabase);
  assertEquals(1,fileToEntry.size());
  String path=sandboxSources ? ""String_Node_Str"" : ""String_Node_Str"";
  BuildTarget compilationTarget=target.withFlavors(InternalFlavor.of(""String_Node_Str""),InternalFlavor.of(""String_Node_Str"" + sanitize(""String_Node_Str"")));
  assertHasEntry(fileToEntry,path,new ImmutableList.Builder<String>().add(COMPILER_PATH).add(""String_Node_Str"").add(headerSymlinkTreePath(binaryHeaderSymlinkTreeFolder).toString()).addAll(getExtraFlagsForHeaderMaps(filesystem)).addAll(COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").addAll(sandboxSources ? ImmutableList.of(""String_Node_Str"") : ImmutableList.of()).add(""String_Node_Str"" + rootPath + ""String_Node_Str"").addAll(MORE_COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).add(Paths.get(path).toString()).add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).build());
}","@Test public void testUberCompilationDatabase() throws IOException {
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  ProjectFilesystem filesystem=new FakeProjectFilesystem();
  Path compilationDatabase=workspace.buildAndReturnOutput(target.getFullyQualifiedName());
  Path rootPath=tmp.getRoot();
  assertEquals(BuildTargets.getGenPath(filesystem,target,""String_Node_Str""),rootPath.relativize(compilationDatabase));
  Path binaryHeaderSymlinkTreeFolder=BuildTargets.getGenPath(filesystem,target.withFlavors(InternalFlavor.of(""String_Node_Str""),CxxDescriptionEnhancer.HEADER_SYMLINK_TREE_FLAVOR),""String_Node_Str"");
  Map<String,CxxCompilationDatabaseEntry> fileToEntry=CxxCompilationDatabaseUtils.parseCompilationDatabaseJsonFile(compilationDatabase);
  assertEquals(1,fileToEntry.size());
  String path=sandboxSources ? ""String_Node_Str"" : ""String_Node_Str"";
  BuildTarget compilationTarget=target.withFlavors(InternalFlavor.of(""String_Node_Str""),InternalFlavor.of(""String_Node_Str"" + sanitize(""String_Node_Str"")));
  assertHasEntry(fileToEntry,path,new ImmutableList.Builder<String>().add(COMPILER_PATH).add(""String_Node_Str"").add(headerSymlinkTreePath(binaryHeaderSymlinkTreeFolder).toString()).addAll(getExtraFlagsForHeaderMaps(filesystem)).addAll(COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").addAll(sandboxSources && Platform.detect() == Platform.MACOS ? ImmutableList.of(""String_Node_Str"") : ImmutableList.of()).add(""String_Node_Str"" + rootPath + ""String_Node_Str"").addAll(MORE_COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).add(Paths.get(path).toString()).add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).build());
}",0.990154001514769
52902,"@Test public void testCompilationDatabase() throws IOException {
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  ProjectFilesystem filesystem=new FakeProjectFilesystem();
  Path compilationDatabase=workspace.buildAndReturnOutput(target.getFullyQualifiedName());
  Path rootPath=tmp.getRoot();
  assertEquals(BuildTargets.getGenPath(filesystem,target,""String_Node_Str""),rootPath.relativize(compilationDatabase));
  Path binaryHeaderSymlinkTreeFolder=BuildTargets.getGenPath(filesystem,target.withFlavors(InternalFlavor.of(""String_Node_Str""),CxxDescriptionEnhancer.HEADER_SYMLINK_TREE_FLAVOR),""String_Node_Str"");
  Map<String,CxxCompilationDatabaseEntry> fileToEntry=CxxCompilationDatabaseUtils.parseCompilationDatabaseJsonFile(compilationDatabase);
  assertEquals(1,fileToEntry.size());
  String path=sandboxSources ? ""String_Node_Str"" : ""String_Node_Str"";
  BuildTarget compilationTarget=target.withFlavors(InternalFlavor.of(""String_Node_Str""),InternalFlavor.of(""String_Node_Str"" + sanitize(""String_Node_Str"")));
  assertHasEntry(fileToEntry,path,new ImmutableList.Builder<String>().add(COMPILER_PATH).add(""String_Node_Str"").add(headerSymlinkTreePath(binaryHeaderSymlinkTreeFolder).toString()).addAll(getExtraFlagsForHeaderMaps(filesystem)).addAll(COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").addAll(sandboxSources ? ImmutableList.of(""String_Node_Str"") : ImmutableList.of()).add(""String_Node_Str"" + rootPath + ""String_Node_Str"").addAll(MORE_COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).add(Paths.get(path).toString()).add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).build());
}","@Test public void testCompilationDatabase() throws IOException {
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  ProjectFilesystem filesystem=new FakeProjectFilesystem();
  Path compilationDatabase=workspace.buildAndReturnOutput(target.getFullyQualifiedName());
  Path rootPath=tmp.getRoot();
  assertEquals(BuildTargets.getGenPath(filesystem,target,""String_Node_Str""),rootPath.relativize(compilationDatabase));
  Path binaryHeaderSymlinkTreeFolder=BuildTargets.getGenPath(filesystem,target.withFlavors(InternalFlavor.of(""String_Node_Str""),CxxDescriptionEnhancer.HEADER_SYMLINK_TREE_FLAVOR),""String_Node_Str"");
  Map<String,CxxCompilationDatabaseEntry> fileToEntry=CxxCompilationDatabaseUtils.parseCompilationDatabaseJsonFile(compilationDatabase);
  assertEquals(1,fileToEntry.size());
  String path=sandboxSources ? ""String_Node_Str"" : ""String_Node_Str"";
  BuildTarget compilationTarget=target.withFlavors(InternalFlavor.of(""String_Node_Str""),InternalFlavor.of(""String_Node_Str"" + sanitize(""String_Node_Str"")));
  assertHasEntry(fileToEntry,path,new ImmutableList.Builder<String>().add(COMPILER_PATH).add(""String_Node_Str"").add(headerSymlinkTreePath(binaryHeaderSymlinkTreeFolder).toString()).addAll(getExtraFlagsForHeaderMaps(filesystem)).addAll(COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").addAll(sandboxSources && Platform.detect() == Platform.MACOS ? ImmutableList.of(""String_Node_Str"") : ImmutableList.of()).add(""String_Node_Str"" + rootPath + ""String_Node_Str"").addAll(MORE_COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).add(Paths.get(path).toString()).add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).build());
}",0.9901340753857828
52903,"@Test public void binaryWithDependenciesCompilationDatabase() throws InterruptedException, IOException {
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  Path compilationDatabase=workspace.buildAndReturnOutput(target.getFullyQualifiedName());
  ProjectFilesystem filesystem=new FakeProjectFilesystem();
  Path rootPath=tmp.getRoot();
  assertEquals(BuildTargets.getGenPath(filesystem,target,""String_Node_Str""),rootPath.relativize(compilationDatabase));
  Path binaryHeaderSymlinkTreeFolder=BuildTargets.getGenPath(filesystem,target.withFlavors(InternalFlavor.of(""String_Node_Str""),CxxDescriptionEnhancer.HEADER_SYMLINK_TREE_FLAVOR),""String_Node_Str"");
  assertTrue(Files.exists(rootPath.resolve(binaryHeaderSymlinkTreeFolder)));
  BuildTarget libraryTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  Path libraryExportedHeaderSymlinkTreeFolder=CxxDescriptionEnhancer.getHeaderSymlinkTreePath(filesystem,libraryTarget,HeaderVisibility.PUBLIC,CxxPlatformUtils.getHeaderModeForDefaultPlatform(tmp.getRoot()).getFlavor());
  assertTrue(Files.exists(rootPath.resolve(libraryExportedHeaderSymlinkTreeFolder)));
  assertTrue(Files.exists(rootPath.resolve(libraryExportedHeaderSymlinkTreeFolder + ""String_Node_Str"")));
  Map<String,CxxCompilationDatabaseEntry> fileToEntry=CxxCompilationDatabaseUtils.parseCompilationDatabaseJsonFile(compilationDatabase);
  assertEquals(1,fileToEntry.size());
  String path=sandboxSources ? ""String_Node_Str"" : ""String_Node_Str"";
  BuildTarget compilationTarget=target.withFlavors(InternalFlavor.of(""String_Node_Str""),InternalFlavor.of(""String_Node_Str"" + sanitize(""String_Node_Str"")));
  Map<String,String> prefixMap=new TreeMap<>(Comparator.comparingInt(String::length));
  prefixMap.put(libraryExportedHeaderSymlinkTreeFolder + ""String_Node_Str"",""String_Node_Str"");
  prefixMap.put(rootPath.toString(),""String_Node_Str"");
  if (sandboxSources) {
    prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  }
  assertHasEntry(fileToEntry,path,new ImmutableList.Builder<String>().add(COMPILER_PATH).add(""String_Node_Str"").add(headerSymlinkTreePath(binaryHeaderSymlinkTreeFolder).toString()).add(""String_Node_Str"").add(headerSymlinkTreePath(libraryExportedHeaderSymlinkTreeFolder).toString()).addAll(getExtraFlagsForHeaderMaps(filesystem)).addAll(COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").addAll(prefixMap.entrySet().stream().map(e -> String.format(""String_Node_Str"",e.getKey(),e.getValue())).collect(Collectors.toList())).addAll(MORE_COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).add(Paths.get(path).toString()).add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).build());
}","@Test public void binaryWithDependenciesCompilationDatabase() throws InterruptedException, IOException {
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  Path compilationDatabase=workspace.buildAndReturnOutput(target.getFullyQualifiedName());
  ProjectFilesystem filesystem=new FakeProjectFilesystem();
  Path rootPath=tmp.getRoot();
  assertEquals(BuildTargets.getGenPath(filesystem,target,""String_Node_Str""),rootPath.relativize(compilationDatabase));
  Path binaryHeaderSymlinkTreeFolder=BuildTargets.getGenPath(filesystem,target.withFlavors(InternalFlavor.of(""String_Node_Str""),CxxDescriptionEnhancer.HEADER_SYMLINK_TREE_FLAVOR),""String_Node_Str"");
  assertTrue(Files.exists(rootPath.resolve(binaryHeaderSymlinkTreeFolder)));
  BuildTarget libraryTarget=BuildTargetFactory.newInstance(""String_Node_Str"");
  Path libraryExportedHeaderSymlinkTreeFolder=CxxDescriptionEnhancer.getHeaderSymlinkTreePath(filesystem,libraryTarget,HeaderVisibility.PUBLIC,CxxPlatformUtils.getHeaderModeForDefaultPlatform(tmp.getRoot()).getFlavor());
  assertTrue(Files.exists(rootPath.resolve(libraryExportedHeaderSymlinkTreeFolder)));
  assertTrue(Files.exists(rootPath.resolve(libraryExportedHeaderSymlinkTreeFolder + ""String_Node_Str"")));
  Map<String,CxxCompilationDatabaseEntry> fileToEntry=CxxCompilationDatabaseUtils.parseCompilationDatabaseJsonFile(compilationDatabase);
  assertEquals(1,fileToEntry.size());
  String path=sandboxSources ? ""String_Node_Str"" : ""String_Node_Str"";
  BuildTarget compilationTarget=target.withFlavors(InternalFlavor.of(""String_Node_Str""),InternalFlavor.of(""String_Node_Str"" + sanitize(""String_Node_Str"")));
  Map<String,String> prefixMap=new TreeMap<>(Comparator.comparingInt(String::length));
  prefixMap.put(rootPath.toString(),""String_Node_Str"");
  if (Platform.detect() == Platform.MACOS) {
    prefixMap.put(libraryExportedHeaderSymlinkTreeFolder + ""String_Node_Str"",""String_Node_Str"");
    if (sandboxSources) {
      prefixMap.put(""String_Node_Str"",""String_Node_Str"");
    }
  }
  assertHasEntry(fileToEntry,path,new ImmutableList.Builder<String>().add(COMPILER_PATH).add(""String_Node_Str"").add(headerSymlinkTreePath(binaryHeaderSymlinkTreeFolder).toString()).add(""String_Node_Str"").add(headerSymlinkTreePath(libraryExportedHeaderSymlinkTreeFolder).toString()).addAll(getExtraFlagsForHeaderMaps(filesystem)).addAll(COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").addAll(prefixMap.entrySet().stream().map(e -> String.format(""String_Node_Str"",e.getKey(),e.getValue())).collect(Collectors.toList())).addAll(MORE_COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).add(Paths.get(path).toString()).add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).build());
}",0.9568831168831168
52904,"@Test public void libraryCompilationDatabase() throws InterruptedException, IOException {
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  ProjectFilesystem filesystem=new FakeProjectFilesystem();
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  Path compilationDatabase=workspace.buildAndReturnOutput(target.getFullyQualifiedName());
  Path rootPath=tmp.getRoot();
  assertEquals(BuildTargets.getGenPath(filesystem,target,""String_Node_Str""),rootPath.relativize(compilationDatabase));
  Path headerSymlinkTreeFolder=BuildTargets.getGenPath(filesystem,target.withFlavors(InternalFlavor.of(""String_Node_Str""),CxxDescriptionEnhancer.HEADER_SYMLINK_TREE_FLAVOR),""String_Node_Str"");
  Path exportedHeaderSymlinkTreeFolder=CxxDescriptionEnhancer.getHeaderSymlinkTreePath(filesystem,target.withFlavors(),HeaderVisibility.PUBLIC,CxxPlatformUtils.getHeaderModeForDefaultPlatform(tmp.getRoot()).getFlavor());
  System.out.println(workspace.getBuildLog().getAllTargets());
  assertTrue(Files.exists(rootPath.resolve(headerSymlinkTreeFolder)));
  assertTrue(Files.exists(rootPath.resolve(exportedHeaderSymlinkTreeFolder)));
  Map<String,CxxCompilationDatabaseEntry> fileToEntry=CxxCompilationDatabaseUtils.parseCompilationDatabaseJsonFile(compilationDatabase);
  assertEquals(1,fileToEntry.size());
  String path=sandboxSources ? ""String_Node_Str"" : ""String_Node_Str"";
  BuildTarget compilationTarget=target.withFlavors(InternalFlavor.of(""String_Node_Str""),InternalFlavor.of(""String_Node_Str"" + sanitize(""String_Node_Str"")));
  Map<String,String> prefixMap=new TreeMap<>(Comparator.comparingInt(String::length));
  prefixMap.put(headerSymlinkTreeFolder + ""String_Node_Str"",""String_Node_Str"");
  prefixMap.put(exportedHeaderSymlinkTreeFolder + ""String_Node_Str"",""String_Node_Str"");
  prefixMap.put(rootPath.toString(),""String_Node_Str"");
  if (sandboxSources) {
    prefixMap.put(""String_Node_Str"",""String_Node_Str"");
  }
  assertHasEntry(fileToEntry,path,new ImmutableList.Builder<String>().add(COMPILER_PATH).add(""String_Node_Str"").add(""String_Node_Str"").add(""String_Node_Str"").add(headerSymlinkTreePath(headerSymlinkTreeFolder).toString()).add(""String_Node_Str"").add(headerSymlinkTreePath(exportedHeaderSymlinkTreeFolder).toString()).addAll(getExtraFlagsForHeaderMaps(filesystem)).addAll(COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").addAll(prefixMap.entrySet().stream().map(e -> String.format(""String_Node_Str"",e.getKey(),e.getValue())).collect(Collectors.toList())).addAll(MORE_COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).add(Paths.get(path).toString()).add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).build());
}","@Test public void libraryCompilationDatabase() throws InterruptedException, IOException {
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,""String_Node_Str"",tmp);
  workspace.setUp();
  ProjectFilesystem filesystem=new FakeProjectFilesystem();
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  Path compilationDatabase=workspace.buildAndReturnOutput(target.getFullyQualifiedName());
  Path rootPath=tmp.getRoot();
  assertEquals(BuildTargets.getGenPath(filesystem,target,""String_Node_Str""),rootPath.relativize(compilationDatabase));
  Path headerSymlinkTreeFolder=BuildTargets.getGenPath(filesystem,target.withFlavors(InternalFlavor.of(""String_Node_Str""),CxxDescriptionEnhancer.HEADER_SYMLINK_TREE_FLAVOR),""String_Node_Str"");
  Path exportedHeaderSymlinkTreeFolder=CxxDescriptionEnhancer.getHeaderSymlinkTreePath(filesystem,target.withFlavors(),HeaderVisibility.PUBLIC,CxxPlatformUtils.getHeaderModeForDefaultPlatform(tmp.getRoot()).getFlavor());
  System.out.println(workspace.getBuildLog().getAllTargets());
  assertTrue(Files.exists(rootPath.resolve(headerSymlinkTreeFolder)));
  assertTrue(Files.exists(rootPath.resolve(exportedHeaderSymlinkTreeFolder)));
  Map<String,CxxCompilationDatabaseEntry> fileToEntry=CxxCompilationDatabaseUtils.parseCompilationDatabaseJsonFile(compilationDatabase);
  assertEquals(1,fileToEntry.size());
  String path=sandboxSources ? ""String_Node_Str"" : ""String_Node_Str"";
  BuildTarget compilationTarget=target.withFlavors(InternalFlavor.of(""String_Node_Str""),InternalFlavor.of(""String_Node_Str"" + sanitize(""String_Node_Str"")));
  Map<String,String> prefixMap=new TreeMap<>(Comparator.comparingInt(String::length));
  prefixMap.put(rootPath.toString(),""String_Node_Str"");
  if (Platform.detect() == Platform.MACOS) {
    prefixMap.put(headerSymlinkTreeFolder + ""String_Node_Str"",""String_Node_Str"");
    prefixMap.put(exportedHeaderSymlinkTreeFolder + ""String_Node_Str"",""String_Node_Str"");
    if (sandboxSources) {
      prefixMap.put(""String_Node_Str"",""String_Node_Str"");
    }
  }
  assertHasEntry(fileToEntry,path,new ImmutableList.Builder<String>().add(COMPILER_PATH).add(""String_Node_Str"").add(""String_Node_Str"").add(""String_Node_Str"").add(headerSymlinkTreePath(headerSymlinkTreeFolder).toString()).add(""String_Node_Str"").add(headerSymlinkTreePath(exportedHeaderSymlinkTreeFolder).toString()).addAll(getExtraFlagsForHeaderMaps(filesystem)).addAll(COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").addAll(prefixMap.entrySet().stream().map(e -> String.format(""String_Node_Str"",e.getKey(),e.getValue())).collect(Collectors.toList())).addAll(MORE_COMPILER_SPECIFIC_FLAGS).add(""String_Node_Str"").add(""String_Node_Str"").add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).add(Paths.get(path).toString()).add(""String_Node_Str"").add(BuildTargets.getGenPath(filesystem,compilationTarget,""String_Node_Str"").toString()).build());
}",0.9661216922299004
52905,"@VisibleForTesting static NdkCxxPlatform build(CxxBuckConfig config,AndroidBuckConfig androidConfig,ProjectFilesystem filesystem,Flavor flavor,Platform platform,Path ndkRoot,NdkCxxPlatformTargetConfiguration targetConfiguration,NdkCxxRuntime cxxRuntime,ExecutableFinder executableFinder,boolean strictToolchainPaths){
  NdkCxxPlatformCompiler.Type compilerType=targetConfiguration.getCompiler().getType();
  String version=Joiner.on('-').join(ImmutableList.of(readVersion(ndkRoot),targetConfiguration.getToolchain(),targetConfiguration.getTargetAppPlatform(),compilerType,targetConfiguration.getCompiler().getVersion(),targetConfiguration.getCompiler().getGccVersion(),cxxRuntime));
  Host host=Preconditions.checkNotNull(BUILD_PLATFORMS.get(platform));
  NdkCxxToolchainPaths toolchainPaths=new NdkCxxToolchainPaths(filesystem,ndkRoot,targetConfiguration,host.toString(),cxxRuntime,strictToolchainPaths);
  NdkCxxToolchainPaths sanitizedPaths=toolchainPaths.getSanitizedPaths();
  ImmutableBiMap.Builder<Path,String> sanitizePathsBuilder=ImmutableBiMap.builder();
  sanitizePathsBuilder.put(toolchainPaths.getNdkToolRoot(),sanitizedPaths.getNdkToolRoot().toString());
  if (compilerType != NdkCxxPlatformCompiler.Type.GCC) {
    sanitizePathsBuilder.put(toolchainPaths.getNdkGccToolRoot(),sanitizedPaths.getNdkGccToolRoot().toString());
  }
  sanitizePathsBuilder.put(ndkRoot,ANDROID_NDK_ROOT);
  CxxToolProvider.Type type=compilerType == NdkCxxPlatformCompiler.Type.CLANG ? CxxToolProvider.Type.CLANG : CxxToolProvider.Type.GCC;
  ToolProvider ccTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.getCc(),version,executableFinder));
  ToolProvider cxxTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.getCxx(),version,executableFinder));
  CompilerProvider cc=new CompilerProvider(ccTool,type);
  PreprocessorProvider cpp=new PreprocessorProvider(ccTool,type);
  CompilerProvider cxx=new CompilerProvider(cxxTool,type);
  PreprocessorProvider cxxpp=new PreprocessorProvider(cxxTool,type);
  CxxPlatform.Builder cxxPlatformBuilder=CxxPlatform.builder();
  ImmutableBiMap<Path,String> sanitizePaths=sanitizePathsBuilder.build();
  PrefixMapDebugPathSanitizer compilerDebugPathSanitizer=new PrefixMapDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizePaths,type);
  MungingDebugPathSanitizer assemblerDebugPathSanitizer=new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizePaths);
  cxxPlatformBuilder.setFlavor(flavor).setAs(cc).addAllAsflags(getAsflags(targetConfiguration,toolchainPaths)).setAspp(cpp).setCc(cc).addAllCflags(getCCompilationFlags(targetConfiguration,toolchainPaths,androidConfig)).setCpp(cpp).addAllCppflags(getCPreprocessorFlags(targetConfiguration,toolchainPaths,androidConfig)).setCxx(cxx).addAllCxxflags(getCxxCompilationFlags(targetConfiguration,toolchainPaths,androidConfig)).setCxxpp(cxxpp).addAllCxxppflags(getCxxPreprocessorFlags(targetConfiguration,toolchainPaths,androidConfig)).setLd(new DefaultLinkerProvider(LinkerProvider.Type.GNU,new ConstantToolProvider(getCcLinkTool(targetConfiguration,toolchainPaths,compilerType.getCxx(),version,cxxRuntime,executableFinder)))).addAllLdflags(getLdFlags(targetConfiguration,androidConfig)).setStrip(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).setSymbolNameTool(new PosixNmSymbolNameTool(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setAr(new GnuArchiver(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setRanlib(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).setCompilerDebugPathSanitizer(compilerDebugPathSanitizer).setAssemblerDebugPathSanitizer(assemblerDebugPathSanitizer).setSharedLibraryExtension(""String_Node_Str"").setSharedLibraryVersionedExtensionFormat(""String_Node_Str"").setStaticLibraryExtension(""String_Node_Str"").setObjectFileExtension(""String_Node_Str"").setSharedLibraryInterfaceFactory(config.shouldUseSharedLibraryInterfaces() ? Optional.of(ElfSharedLibraryInterfaceFactory.of(new ConstantToolProvider(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)))) : Optional.empty()).setPublicHeadersSymlinksEnabled(config.getPublicHeadersSymlinksEnabled()).setPrivateHeadersSymlinksEnabled(config.getPrivateHeadersSymlinksEnabled());
  HeaderVerification headerVerification=config.getHeaderVerification();
  try {
    headerVerification=headerVerification.withPlatformWhitelist(ImmutableList.of(""String_Node_Str"" + Pattern.quote(ndkRoot.toRealPath().toString() + File.separatorChar) + ""String_Node_Str""));
  }
 catch (  IOException e) {
    LOG.warn(e,""String_Node_Str"",ndkRoot);
  }
  cxxPlatformBuilder.setHeaderVerification(headerVerification);
  LOG.debug(""String_Node_Str"",ndkRoot.toString());
  LOG.debug(""String_Node_Str"",headerVerification.getPlatformWhitelist());
  if (cxxRuntime != NdkCxxRuntime.SYSTEM) {
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.SHARED,""String_Node_Str"" + cxxRuntime.getSharedName());
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.STATIC,""String_Node_Str"" + cxxRuntime.getStaticName());
  }
  CxxPlatform cxxPlatform=cxxPlatformBuilder.build();
  NdkCxxPlatform.Builder builder=NdkCxxPlatform.builder();
  builder.setCxxPlatform(cxxPlatform).setCxxRuntime(cxxRuntime).setObjdump(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder));
  if (cxxRuntime != NdkCxxRuntime.SYSTEM) {
    builder.setCxxSharedRuntimePath(toolchainPaths.getCxxRuntimeLibsDirectory().resolve(cxxRuntime.getSoname()));
  }
  return builder.build();
}","@VisibleForTesting static NdkCxxPlatform build(CxxBuckConfig config,AndroidBuckConfig androidConfig,ProjectFilesystem filesystem,Flavor flavor,Platform platform,Path ndkRoot,NdkCxxPlatformTargetConfiguration targetConfiguration,NdkCxxRuntime cxxRuntime,ExecutableFinder executableFinder,boolean strictToolchainPaths){
  NdkCxxPlatformCompiler.Type compilerType=targetConfiguration.getCompiler().getType();
  String version=Joiner.on('-').join(ImmutableList.of(readVersion(ndkRoot),targetConfiguration.getToolchain(),targetConfiguration.getTargetAppPlatform(),compilerType,targetConfiguration.getCompiler().getVersion(),targetConfiguration.getCompiler().getGccVersion(),cxxRuntime));
  Host host=Preconditions.checkNotNull(BUILD_PLATFORMS.get(platform));
  NdkCxxToolchainPaths toolchainPaths=new NdkCxxToolchainPaths(filesystem,ndkRoot,targetConfiguration,host.toString(),cxxRuntime,strictToolchainPaths);
  NdkCxxToolchainPaths sanitizedPaths=toolchainPaths.getSanitizedPaths();
  ImmutableBiMap.Builder<Path,String> sanitizePathsBuilder=ImmutableBiMap.builder();
  sanitizePathsBuilder.put(toolchainPaths.getNdkToolRoot(),sanitizedPaths.getNdkToolRoot().toString());
  if (compilerType != NdkCxxPlatformCompiler.Type.GCC) {
    sanitizePathsBuilder.put(toolchainPaths.getNdkGccToolRoot(),sanitizedPaths.getNdkGccToolRoot().toString());
  }
  sanitizePathsBuilder.put(ndkRoot,ANDROID_NDK_ROOT);
  CxxToolProvider.Type type=compilerType == NdkCxxPlatformCompiler.Type.CLANG ? CxxToolProvider.Type.CLANG : CxxToolProvider.Type.GCC;
  ToolProvider ccTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.getCc(),version,executableFinder));
  ToolProvider cxxTool=new ConstantToolProvider(getCTool(toolchainPaths,compilerType.getCxx(),version,executableFinder));
  CompilerProvider cc=new CompilerProvider(ccTool,type);
  PreprocessorProvider cpp=new PreprocessorProvider(ccTool,type);
  CompilerProvider cxx=new CompilerProvider(cxxTool,type);
  PreprocessorProvider cxxpp=new PreprocessorProvider(cxxTool,type);
  CxxPlatform.Builder cxxPlatformBuilder=CxxPlatform.builder();
  ImmutableBiMap<Path,String> sanitizePaths=sanitizePathsBuilder.build();
  PrefixMapDebugPathSanitizer compilerDebugPathSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",sanitizePaths,type);
  MungingDebugPathSanitizer assemblerDebugPathSanitizer=new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizePaths);
  cxxPlatformBuilder.setFlavor(flavor).setAs(cc).addAllAsflags(getAsflags(targetConfiguration,toolchainPaths)).setAspp(cpp).setCc(cc).addAllCflags(getCCompilationFlags(targetConfiguration,toolchainPaths,androidConfig)).setCpp(cpp).addAllCppflags(getCPreprocessorFlags(targetConfiguration,toolchainPaths,androidConfig)).setCxx(cxx).addAllCxxflags(getCxxCompilationFlags(targetConfiguration,toolchainPaths,androidConfig)).setCxxpp(cxxpp).addAllCxxppflags(getCxxPreprocessorFlags(targetConfiguration,toolchainPaths,androidConfig)).setLd(new DefaultLinkerProvider(LinkerProvider.Type.GNU,new ConstantToolProvider(getCcLinkTool(targetConfiguration,toolchainPaths,compilerType.getCxx(),version,cxxRuntime,executableFinder)))).addAllLdflags(getLdFlags(targetConfiguration,androidConfig)).setStrip(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).setSymbolNameTool(new PosixNmSymbolNameTool(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setAr(new GnuArchiver(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder))).setRanlib(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)).setCompilerDebugPathSanitizer(compilerDebugPathSanitizer).setAssemblerDebugPathSanitizer(assemblerDebugPathSanitizer).setSharedLibraryExtension(""String_Node_Str"").setSharedLibraryVersionedExtensionFormat(""String_Node_Str"").setStaticLibraryExtension(""String_Node_Str"").setObjectFileExtension(""String_Node_Str"").setSharedLibraryInterfaceFactory(config.shouldUseSharedLibraryInterfaces() ? Optional.of(ElfSharedLibraryInterfaceFactory.of(new ConstantToolProvider(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder)))) : Optional.empty()).setPublicHeadersSymlinksEnabled(config.getPublicHeadersSymlinksEnabled()).setPrivateHeadersSymlinksEnabled(config.getPrivateHeadersSymlinksEnabled());
  HeaderVerification headerVerification=config.getHeaderVerification();
  try {
    headerVerification=headerVerification.withPlatformWhitelist(ImmutableList.of(""String_Node_Str"" + Pattern.quote(ndkRoot.toRealPath().toString() + File.separatorChar) + ""String_Node_Str""));
  }
 catch (  IOException e) {
    LOG.warn(e,""String_Node_Str"",ndkRoot);
  }
  cxxPlatformBuilder.setHeaderVerification(headerVerification);
  LOG.debug(""String_Node_Str"",ndkRoot.toString());
  LOG.debug(""String_Node_Str"",headerVerification.getPlatformWhitelist());
  if (cxxRuntime != NdkCxxRuntime.SYSTEM) {
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.SHARED,""String_Node_Str"" + cxxRuntime.getSharedName());
    cxxPlatformBuilder.putRuntimeLdflags(Linker.LinkableDepType.STATIC,""String_Node_Str"" + cxxRuntime.getStaticName());
  }
  CxxPlatform cxxPlatform=cxxPlatformBuilder.build();
  NdkCxxPlatform.Builder builder=NdkCxxPlatform.builder();
  builder.setCxxPlatform(cxxPlatform).setCxxRuntime(cxxRuntime).setObjdump(getGccTool(toolchainPaths,""String_Node_Str"",version,executableFinder));
  if (cxxRuntime != NdkCxxRuntime.SYSTEM) {
    builder.setCxxSharedRuntimePath(toolchainPaths.getCxxRuntimeLibsDirectory().resolve(cxxRuntime.getSoname()));
  }
  return builder.build();
}",0.99414997340897
52906,"@VisibleForTesting static AppleCxxPlatform buildWithExecutableChecker(ProjectFilesystem filesystem,AppleSdk targetSdk,String minVersion,String targetArchitecture,final AppleSdkPaths sdkPaths,BuckConfig buckConfig,XcodeToolFinder xcodeToolFinder,XcodeBuildVersionCache xcodeBuildVersionCache,Optional<AppleToolchain> swiftToolChain){
  AppleCxxPlatform.Builder platformBuilder=AppleCxxPlatform.builder();
  ImmutableList.Builder<Path> toolSearchPathsBuilder=ImmutableList.builder();
  toolSearchPathsBuilder.add(sdkPaths.getSdkPath().resolve(USR_BIN)).add(sdkPaths.getSdkPath().resolve(""String_Node_Str"").resolve(USR_BIN)).add(sdkPaths.getPlatformPath().resolve(""String_Node_Str"").resolve(USR_BIN));
  for (  Path toolchainPath : sdkPaths.getToolchainPaths()) {
    toolSearchPathsBuilder.add(toolchainPath.resolve(USR_BIN));
  }
  if (sdkPaths.getDeveloperPath().isPresent()) {
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(USR_BIN));
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(""String_Node_Str""));
  }
  ImmutableList.Builder<String> cflagsBuilder=ImmutableList.builder();
  cflagsBuilder.add(""String_Node_Str"",sdkPaths.getSdkPath().toString());
  cflagsBuilder.add(""String_Node_Str"",filesystem.getRootPath().toString());
  cflagsBuilder.add(""String_Node_Str"",targetArchitecture);
  cflagsBuilder.add(targetSdk.getApplePlatform().getMinVersionFlagPrefix() + minVersion);
  if (targetSdk.getApplePlatform().equals(ApplePlatform.WATCHOS)) {
    cflagsBuilder.add(""String_Node_Str"");
  }
  ImmutableList.Builder<String> ldflagsBuilder=ImmutableList.builder();
  ldflagsBuilder.addAll(Linkers.iXlinker(""String_Node_Str"",targetSdk.getVersion(),""String_Node_Str""));
  if (targetSdk.getApplePlatform().equals(ApplePlatform.WATCHOS)) {
    ldflagsBuilder.addAll(Linkers.iXlinker(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  Optional<String> xcodeBuildVersion=Optional.empty();
  Optional<Path> developerPath=sdkPaths.getDeveloperPath();
  if (developerPath.isPresent()) {
    Path xcodeBundlePath=developerPath.get().getParent();
    if (xcodeBundlePath != null) {
      Path xcodeInfoPlistPath=xcodeBundlePath.resolve(""String_Node_Str"");
      try (InputStream stream=Files.newInputStream(xcodeInfoPlistPath)){
        NSDictionary parsedXcodeInfoPlist=(NSDictionary)PropertyListParser.parse(stream);
        NSObject xcodeVersionObject=parsedXcodeInfoPlist.objectForKey(""String_Node_Str"");
        if (xcodeVersionObject != null) {
          Optional<String> xcodeVersion=Optional.of(xcodeVersionObject.toString());
          platformBuilder.setXcodeVersion(xcodeVersion);
        }
      }
 catch (      IOException e) {
        LOG.warn(""String_Node_Str"",xcodeInfoPlistPath);
      }
catch (      PropertyListFormatException|ParseException|ParserConfigurationException|SAXException e) {
        LOG.warn(""String_Node_Str"",xcodeInfoPlistPath);
      }
    }
    xcodeBuildVersion=xcodeBuildVersionCache.lookup(developerPath.get());
    platformBuilder.setXcodeBuildVersion(xcodeBuildVersion);
    LOG.debug(""String_Node_Str"" + xcodeBuildVersion.orElse(""String_Node_Str""));
  }
  ImmutableList.Builder<String> versions=ImmutableList.builder();
  versions.add(targetSdk.getVersion());
  ImmutableList<String> toolchainVersions=targetSdk.getToolchains().stream().map(AppleToolchain::getVersion).flatMap(Optionals::toStream).collect(MoreCollectors.toImmutableList());
  if (toolchainVersions.isEmpty()) {
    if (!xcodeBuildVersion.isPresent()) {
      throw new HumanReadableException(""String_Node_Str"");
    }
    versions.add(xcodeBuildVersion.get());
  }
 else {
    versions.addAll(toolchainVersions);
  }
  String version=Joiner.on(':').join(versions.build());
  ImmutableList<Path> toolSearchPaths=toolSearchPathsBuilder.build();
  Tool clangPath=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool clangXxPath=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool ar=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool ranlib=VersionedTool.builder().setPath(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder)).setName(""String_Node_Str"").setVersion(version).build();
  Tool strip=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool nm=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool actool=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool ibtool=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool momc=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool xctest=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool dsymutil=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool lipo=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool lldb=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Optional<Path> stubBinaryPath=targetSdk.getApplePlatform().getStubBinaryPath().map(input -> sdkPaths.getSdkPath().resolve(input));
  CxxBuckConfig config=new CxxBuckConfig(buckConfig);
  UserFlavor targetFlavor=UserFlavor.of(Flavor.replaceInvalidCharacters(targetSdk.getName() + ""String_Node_Str"" + targetArchitecture),String.format(""String_Node_Str"",targetSdk.getName(),targetArchitecture));
  ImmutableBiMap.Builder<Path,String> sanitizerPaths=ImmutableBiMap.builder();
  sanitizerPaths.put(sdkPaths.getSdkPath(),""String_Node_Str"");
  sanitizerPaths.put(sdkPaths.getPlatformPath(),""String_Node_Str"");
  if (sdkPaths.getDeveloperPath().isPresent()) {
    sanitizerPaths.put(sdkPaths.getDeveloperPath().get(),""String_Node_Str"");
  }
  DebugPathSanitizer compilerDebugPathSanitizer=new PrefixMapDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizerPaths.build(),CxxToolProvider.Type.CLANG);
  DebugPathSanitizer assemblerDebugPathSanitizer=new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizerPaths.build());
  ImmutableList<String> cflags=cflagsBuilder.build();
  ImmutableMap.Builder<String,String> macrosBuilder=ImmutableMap.builder();
  macrosBuilder.put(""String_Node_Str"",sdkPaths.getSdkPath().toString());
  macrosBuilder.put(""String_Node_Str"",sdkPaths.getPlatformPath().toString());
  macrosBuilder.put(""String_Node_Str"",targetArchitecture);
  if (sdkPaths.getDeveloperPath().isPresent()) {
    macrosBuilder.put(""String_Node_Str"",sdkPaths.getDeveloperPath().get().toString());
  }
  ImmutableMap<String,String> macros=macrosBuilder.build();
  Optional<String> buildVersion=Optional.empty();
  Path platformVersionPlistPath=sdkPaths.getPlatformPath().resolve(""String_Node_Str"");
  try (InputStream versionPlist=Files.newInputStream(platformVersionPlistPath)){
    NSDictionary versionInfo=(NSDictionary)PropertyListParser.parse(versionPlist);
    if (versionInfo != null) {
      NSObject productBuildVersion=versionInfo.objectForKey(""String_Node_Str"");
      if (productBuildVersion != null) {
        buildVersion=Optional.of(productBuildVersion.toString());
      }
 else {
        LOG.warn(""String_Node_Str"",platformVersionPlistPath);
      }
    }
 else {
      LOG.warn(""String_Node_Str"",platformVersionPlistPath);
    }
  }
 catch (  NoSuchFileException e) {
    LOG.warn(""String_Node_Str"",platformVersionPlistPath);
  }
catch (  PropertyListFormatException|SAXException|ParserConfigurationException|ParseException|IOException e) {
    LOG.warn(e,""String_Node_Str"",platformVersionPlistPath);
  }
  PreprocessorProvider aspp=new PreprocessorProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  CompilerProvider as=new CompilerProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  PreprocessorProvider cpp=new PreprocessorProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  CompilerProvider cc=new CompilerProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  PreprocessorProvider cxxpp=new PreprocessorProvider(new ConstantToolProvider(clangXxPath),CxxToolProvider.Type.CLANG);
  CompilerProvider cxx=new CompilerProvider(new ConstantToolProvider(clangXxPath),CxxToolProvider.Type.CLANG);
  ImmutableList.Builder<String> whitelistBuilder=ImmutableList.builder();
  whitelistBuilder.add(""String_Node_Str"" + Pattern.quote(sdkPaths.getSdkPath().toString()) + ""String_Node_Str"");
  whitelistBuilder.add(""String_Node_Str"" + Pattern.quote(sdkPaths.getPlatformPath().toString() + ""String_Node_Str"") + ""String_Node_Str"");
  for (  Path toolchainPath : sdkPaths.getToolchainPaths()) {
    LOG.debug(""String_Node_Str"",toolchainPath);
    try {
      whitelistBuilder.add(""String_Node_Str"" + Pattern.quote(toolchainPath.toRealPath().toString()) + ""String_Node_Str"");
    }
 catch (    IOException e) {
      LOG.warn(e,""String_Node_Str"",toolchainPath);
    }
  }
  HeaderVerification headerVerification=config.getHeaderVerification().withPlatformWhitelist(whitelistBuilder.build());
  LOG.debug(""String_Node_Str"",headerVerification.getPlatformWhitelist());
  CxxPlatform cxxPlatform=CxxPlatforms.build(targetFlavor,Platform.MACOS,config,as,aspp,cc,cxx,cpp,cxxpp,new DefaultLinkerProvider(LinkerProvider.Type.DARWIN,new ConstantToolProvider(clangXxPath)),ImmutableList.<String>builder().addAll(cflags).addAll(ldflagsBuilder.build()).build(),strip,new BsdArchiver(ar),ranlib,new PosixNmSymbolNameTool(nm),cflagsBuilder.build(),ImmutableList.of(),cflags,ImmutableList.of(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",compilerDebugPathSanitizer,assemblerDebugPathSanitizer,macros,Optional.empty(),headerVerification);
  ApplePlatform applePlatform=targetSdk.getApplePlatform();
  ImmutableList.Builder<Path> swiftOverrideSearchPathBuilder=ImmutableList.builder();
  AppleSdkPaths.Builder swiftSdkPathsBuilder=AppleSdkPaths.builder().from(sdkPaths);
  if (swiftToolChain.isPresent()) {
    swiftOverrideSearchPathBuilder.add(swiftToolChain.get().getPath().resolve(USR_BIN));
    swiftSdkPathsBuilder.setToolchainPaths(ImmutableList.of(swiftToolChain.get().getPath()));
  }
  Optional<SwiftPlatform> swiftPlatform=getSwiftPlatform(applePlatform.getName(),targetArchitecture + ""String_Node_Str"" + applePlatform.getSwiftName().orElse(applePlatform.getName())+ minVersion,version,swiftSdkPathsBuilder.build(),swiftOverrideSearchPathBuilder.addAll(toolSearchPaths).build(),xcodeToolFinder);
  AppleConfig appleConfig=buckConfig.getView(AppleConfig.class);
  platformBuilder.setCxxPlatform(cxxPlatform).setSwiftPlatform(swiftPlatform).setAppleSdk(targetSdk).setAppleSdkPaths(sdkPaths).setMinVersion(minVersion).setBuildVersion(buildVersion).setActool(actool).setIbtool(ibtool).setMomc(momc).setCopySceneKitAssets(getOptionalTool(""String_Node_Str"",toolSearchPaths,xcodeToolFinder,version)).setXctest(xctest).setDsymutil(dsymutil).setLipo(lipo).setStubBinary(stubBinaryPath).setLldb(lldb).setCodesignAllocate(getOptionalTool(""String_Node_Str"",toolSearchPaths,xcodeToolFinder,version)).setCodesignProvider(appleConfig.getCodesignProvider());
  return platformBuilder.build();
}","@VisibleForTesting static AppleCxxPlatform buildWithExecutableChecker(ProjectFilesystem filesystem,AppleSdk targetSdk,String minVersion,String targetArchitecture,final AppleSdkPaths sdkPaths,BuckConfig buckConfig,XcodeToolFinder xcodeToolFinder,XcodeBuildVersionCache xcodeBuildVersionCache,Optional<AppleToolchain> swiftToolChain){
  AppleCxxPlatform.Builder platformBuilder=AppleCxxPlatform.builder();
  ImmutableList.Builder<Path> toolSearchPathsBuilder=ImmutableList.builder();
  toolSearchPathsBuilder.add(sdkPaths.getSdkPath().resolve(USR_BIN)).add(sdkPaths.getSdkPath().resolve(""String_Node_Str"").resolve(USR_BIN)).add(sdkPaths.getPlatformPath().resolve(""String_Node_Str"").resolve(USR_BIN));
  for (  Path toolchainPath : sdkPaths.getToolchainPaths()) {
    toolSearchPathsBuilder.add(toolchainPath.resolve(USR_BIN));
  }
  if (sdkPaths.getDeveloperPath().isPresent()) {
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(USR_BIN));
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(""String_Node_Str""));
  }
  ImmutableList.Builder<String> cflagsBuilder=ImmutableList.builder();
  cflagsBuilder.add(""String_Node_Str"",sdkPaths.getSdkPath().toString());
  cflagsBuilder.add(""String_Node_Str"",filesystem.getRootPath().toString());
  cflagsBuilder.add(""String_Node_Str"",targetArchitecture);
  cflagsBuilder.add(targetSdk.getApplePlatform().getMinVersionFlagPrefix() + minVersion);
  if (targetSdk.getApplePlatform().equals(ApplePlatform.WATCHOS)) {
    cflagsBuilder.add(""String_Node_Str"");
  }
  ImmutableList.Builder<String> ldflagsBuilder=ImmutableList.builder();
  ldflagsBuilder.addAll(Linkers.iXlinker(""String_Node_Str"",targetSdk.getVersion(),""String_Node_Str""));
  if (targetSdk.getApplePlatform().equals(ApplePlatform.WATCHOS)) {
    ldflagsBuilder.addAll(Linkers.iXlinker(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  Optional<String> xcodeBuildVersion=Optional.empty();
  Optional<Path> developerPath=sdkPaths.getDeveloperPath();
  if (developerPath.isPresent()) {
    Path xcodeBundlePath=developerPath.get().getParent();
    if (xcodeBundlePath != null) {
      Path xcodeInfoPlistPath=xcodeBundlePath.resolve(""String_Node_Str"");
      try (InputStream stream=Files.newInputStream(xcodeInfoPlistPath)){
        NSDictionary parsedXcodeInfoPlist=(NSDictionary)PropertyListParser.parse(stream);
        NSObject xcodeVersionObject=parsedXcodeInfoPlist.objectForKey(""String_Node_Str"");
        if (xcodeVersionObject != null) {
          Optional<String> xcodeVersion=Optional.of(xcodeVersionObject.toString());
          platformBuilder.setXcodeVersion(xcodeVersion);
        }
      }
 catch (      IOException e) {
        LOG.warn(""String_Node_Str"",xcodeInfoPlistPath);
      }
catch (      PropertyListFormatException|ParseException|ParserConfigurationException|SAXException e) {
        LOG.warn(""String_Node_Str"",xcodeInfoPlistPath);
      }
    }
    xcodeBuildVersion=xcodeBuildVersionCache.lookup(developerPath.get());
    platformBuilder.setXcodeBuildVersion(xcodeBuildVersion);
    LOG.debug(""String_Node_Str"" + xcodeBuildVersion.orElse(""String_Node_Str""));
  }
  ImmutableList.Builder<String> versions=ImmutableList.builder();
  versions.add(targetSdk.getVersion());
  ImmutableList<String> toolchainVersions=targetSdk.getToolchains().stream().map(AppleToolchain::getVersion).flatMap(Optionals::toStream).collect(MoreCollectors.toImmutableList());
  if (toolchainVersions.isEmpty()) {
    if (!xcodeBuildVersion.isPresent()) {
      throw new HumanReadableException(""String_Node_Str"");
    }
    versions.add(xcodeBuildVersion.get());
  }
 else {
    versions.addAll(toolchainVersions);
  }
  String version=Joiner.on(':').join(versions.build());
  ImmutableList<Path> toolSearchPaths=toolSearchPathsBuilder.build();
  Tool clangPath=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool clangXxPath=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool ar=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool ranlib=VersionedTool.builder().setPath(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder)).setName(""String_Node_Str"").setVersion(version).build();
  Tool strip=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool nm=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool actool=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool ibtool=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool momc=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool xctest=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool dsymutil=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool lipo=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Tool lldb=VersionedTool.of(getToolPath(""String_Node_Str"",toolSearchPaths,xcodeToolFinder),""String_Node_Str"",version);
  Optional<Path> stubBinaryPath=targetSdk.getApplePlatform().getStubBinaryPath().map(input -> sdkPaths.getSdkPath().resolve(input));
  CxxBuckConfig config=new CxxBuckConfig(buckConfig);
  UserFlavor targetFlavor=UserFlavor.of(Flavor.replaceInvalidCharacters(targetSdk.getName() + ""String_Node_Str"" + targetArchitecture),String.format(""String_Node_Str"",targetSdk.getName(),targetArchitecture));
  ImmutableBiMap.Builder<Path,String> sanitizerPaths=ImmutableBiMap.builder();
  sanitizerPaths.put(sdkPaths.getSdkPath(),""String_Node_Str"");
  sanitizerPaths.put(sdkPaths.getPlatformPath(),""String_Node_Str"");
  if (sdkPaths.getDeveloperPath().isPresent()) {
    sanitizerPaths.put(sdkPaths.getDeveloperPath().get(),""String_Node_Str"");
  }
  DebugPathSanitizer compilerDebugPathSanitizer=new PrefixMapDebugPathSanitizer(DebugPathSanitizer.getPaddedDir(""String_Node_Str"",config.getDebugPathSanitizerLimit(),File.separatorChar),sanitizerPaths.build(),CxxToolProvider.Type.CLANG);
  DebugPathSanitizer assemblerDebugPathSanitizer=new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),sanitizerPaths.build());
  ImmutableList<String> cflags=cflagsBuilder.build();
  ImmutableMap.Builder<String,String> macrosBuilder=ImmutableMap.builder();
  macrosBuilder.put(""String_Node_Str"",sdkPaths.getSdkPath().toString());
  macrosBuilder.put(""String_Node_Str"",sdkPaths.getPlatformPath().toString());
  macrosBuilder.put(""String_Node_Str"",targetArchitecture);
  if (sdkPaths.getDeveloperPath().isPresent()) {
    macrosBuilder.put(""String_Node_Str"",sdkPaths.getDeveloperPath().get().toString());
  }
  ImmutableMap<String,String> macros=macrosBuilder.build();
  Optional<String> buildVersion=Optional.empty();
  Path platformVersionPlistPath=sdkPaths.getPlatformPath().resolve(""String_Node_Str"");
  try (InputStream versionPlist=Files.newInputStream(platformVersionPlistPath)){
    NSDictionary versionInfo=(NSDictionary)PropertyListParser.parse(versionPlist);
    if (versionInfo != null) {
      NSObject productBuildVersion=versionInfo.objectForKey(""String_Node_Str"");
      if (productBuildVersion != null) {
        buildVersion=Optional.of(productBuildVersion.toString());
      }
 else {
        LOG.warn(""String_Node_Str"",platformVersionPlistPath);
      }
    }
 else {
      LOG.warn(""String_Node_Str"",platformVersionPlistPath);
    }
  }
 catch (  NoSuchFileException e) {
    LOG.warn(""String_Node_Str"",platformVersionPlistPath);
  }
catch (  PropertyListFormatException|SAXException|ParserConfigurationException|ParseException|IOException e) {
    LOG.warn(e,""String_Node_Str"",platformVersionPlistPath);
  }
  PreprocessorProvider aspp=new PreprocessorProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  CompilerProvider as=new CompilerProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  PreprocessorProvider cpp=new PreprocessorProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  CompilerProvider cc=new CompilerProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  PreprocessorProvider cxxpp=new PreprocessorProvider(new ConstantToolProvider(clangXxPath),CxxToolProvider.Type.CLANG);
  CompilerProvider cxx=new CompilerProvider(new ConstantToolProvider(clangXxPath),CxxToolProvider.Type.CLANG);
  ImmutableList.Builder<String> whitelistBuilder=ImmutableList.builder();
  whitelistBuilder.add(""String_Node_Str"" + Pattern.quote(sdkPaths.getSdkPath().toString()) + ""String_Node_Str"");
  whitelistBuilder.add(""String_Node_Str"" + Pattern.quote(sdkPaths.getPlatformPath().toString() + ""String_Node_Str"") + ""String_Node_Str"");
  for (  Path toolchainPath : sdkPaths.getToolchainPaths()) {
    LOG.debug(""String_Node_Str"",toolchainPath);
    try {
      whitelistBuilder.add(""String_Node_Str"" + Pattern.quote(toolchainPath.toRealPath().toString()) + ""String_Node_Str"");
    }
 catch (    IOException e) {
      LOG.warn(e,""String_Node_Str"",toolchainPath);
    }
  }
  HeaderVerification headerVerification=config.getHeaderVerification().withPlatformWhitelist(whitelistBuilder.build());
  LOG.debug(""String_Node_Str"",headerVerification.getPlatformWhitelist());
  CxxPlatform cxxPlatform=CxxPlatforms.build(targetFlavor,Platform.MACOS,config,as,aspp,cc,cxx,cpp,cxxpp,new DefaultLinkerProvider(LinkerProvider.Type.DARWIN,new ConstantToolProvider(clangXxPath)),ImmutableList.<String>builder().addAll(cflags).addAll(ldflagsBuilder.build()).build(),strip,new BsdArchiver(ar),ranlib,new PosixNmSymbolNameTool(nm),cflagsBuilder.build(),ImmutableList.of(),cflags,ImmutableList.of(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",compilerDebugPathSanitizer,assemblerDebugPathSanitizer,macros,Optional.empty(),headerVerification);
  ApplePlatform applePlatform=targetSdk.getApplePlatform();
  ImmutableList.Builder<Path> swiftOverrideSearchPathBuilder=ImmutableList.builder();
  AppleSdkPaths.Builder swiftSdkPathsBuilder=AppleSdkPaths.builder().from(sdkPaths);
  if (swiftToolChain.isPresent()) {
    swiftOverrideSearchPathBuilder.add(swiftToolChain.get().getPath().resolve(USR_BIN));
    swiftSdkPathsBuilder.setToolchainPaths(ImmutableList.of(swiftToolChain.get().getPath()));
  }
  Optional<SwiftPlatform> swiftPlatform=getSwiftPlatform(applePlatform.getName(),targetArchitecture + ""String_Node_Str"" + applePlatform.getSwiftName().orElse(applePlatform.getName())+ minVersion,version,swiftSdkPathsBuilder.build(),swiftOverrideSearchPathBuilder.addAll(toolSearchPaths).build(),xcodeToolFinder);
  AppleConfig appleConfig=buckConfig.getView(AppleConfig.class);
  platformBuilder.setCxxPlatform(cxxPlatform).setSwiftPlatform(swiftPlatform).setAppleSdk(targetSdk).setAppleSdkPaths(sdkPaths).setMinVersion(minVersion).setBuildVersion(buildVersion).setActool(actool).setIbtool(ibtool).setMomc(momc).setCopySceneKitAssets(getOptionalTool(""String_Node_Str"",toolSearchPaths,xcodeToolFinder,version)).setXctest(xctest).setDsymutil(dsymutil).setLipo(lipo).setStubBinary(stubBinaryPath).setLldb(lldb).setCodesignAllocate(getOptionalTool(""String_Node_Str"",toolSearchPaths,xcodeToolFinder,version)).setCodesignProvider(appleConfig.getCodesignProvider());
  return platformBuilder.build();
}",0.9957954350437618
52907,"public String getCompilationDirectory(){
  return getExpandedPath(compilationDirectory);
}",public abstract String getCompilationDirectory();,0.5755395683453237
52908,"public static CxxPlatform build(Platform platform,CxxBuckConfig config){
  String sharedLibraryExtension;
  String sharedLibraryVersionedExtensionFormat;
  String staticLibraryExtension;
  String objectFileExtension;
  Path defaultCFrontend;
  Path defaultCxxFrontend;
  Path defaultLinker;
  LinkerProvider.Type linkerType;
  Archiver archiver;
  DebugPathSanitizer compilerSanitizer;
  Optional<String> binaryExtension;
  ImmutableMap<String,String> env=config.getEnvironment();
  Optional<CxxToolProvider.Type> defaultToolType=Optional.empty();
  String ranlibCommand;
switch (platform) {
case LINUX:
    sharedLibraryExtension=""String_Node_Str"";
  sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_C_FRONTEND,env);
defaultCxxFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_CXX_FRONTEND,env);
defaultLinker=defaultCxxFrontend;
linkerType=LinkerProvider.Type.GNU;
archiver=new GnuArchiver(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_AR,env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),ImmutableBiMap.of(),CxxToolProvider.Type.GCC);
binaryExtension=Optional.empty();
ranlibCommand=DEFAULT_UNIX_RANLIB;
break;
case MACOS:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_OSX_C_FRONTEND,env);
defaultCxxFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_OSX_CXX_FRONTEND,env);
defaultLinker=defaultCxxFrontend;
linkerType=LinkerProvider.Type.DARWIN;
archiver=new BsdArchiver(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_AR,env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),ImmutableBiMap.of(),CxxToolProvider.Type.CLANG);
binaryExtension=Optional.empty();
ranlibCommand=DEFAULT_UNIX_RANLIB;
break;
case WINDOWS:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(DEFAULT_WINDOWS_CXX_FRONTEND,Paths.get(DEFAULT_WINDOWS_CXX_FRONTEND),env);
defaultCxxFrontend=getExecutablePath(DEFAULT_WINDOWS_CXX_FRONTEND,Paths.get(DEFAULT_WINDOWS_CXX_FRONTEND),env);
defaultLinker=getExecutablePath(DEFAULT_WINDOWS_LINK,Paths.get(DEFAULT_WINDOWS_LINK),env);
linkerType=LinkerProvider.Type.WINDOWS;
archiver=new WindowsArchiver(new HashedFileTool(getExecutablePath(DEFAULT_WINDOWS_LIB,Paths.get(DEFAULT_WINDOWS_LIB),env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),ImmutableBiMap.of(),CxxToolProvider.Type.WINDOWS);
binaryExtension=Optional.of(""String_Node_Str"");
defaultToolType=Optional.of(CxxToolProvider.Type.WINDOWS);
ranlibCommand=DEFAULT_WINDOWS_RANLIB;
break;
case FREEBSD:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_C_FRONTEND,env);
defaultCxxFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_CXX_FRONTEND,env);
defaultLinker=defaultCxxFrontend;
linkerType=LinkerProvider.Type.GNU;
archiver=new BsdArchiver(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_AR,env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),ImmutableBiMap.of(),CxxToolProvider.Type.GCC);
binaryExtension=Optional.empty();
ranlibCommand=DEFAULT_UNIX_RANLIB;
break;
default :
throw new RuntimeException(String.format(""String_Node_Str"",platform));
}
PreprocessorProvider aspp=new PreprocessorProvider(defaultCFrontend,defaultToolType);
CompilerProvider as=new CompilerProvider(defaultCFrontend,defaultToolType);
PreprocessorProvider cpp=new PreprocessorProvider(defaultCFrontend,defaultToolType);
CompilerProvider cc=new CompilerProvider(defaultCFrontend,defaultToolType);
PreprocessorProvider cxxpp=new PreprocessorProvider(defaultCxxFrontend,defaultToolType);
CompilerProvider cxx=new CompilerProvider(defaultCxxFrontend,defaultToolType);
return CxxPlatforms.build(FLAVOR,platform,config,as,aspp,cc,cxx,cpp,cxxpp,new DefaultLinkerProvider(linkerType,new ConstantToolProvider(new HashedFileTool(defaultLinker))),ImmutableList.of(),new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_STRIP,env)),archiver,new HashedFileTool(getExecutablePath(ranlibCommand,DEFAULT_RANLIB,env)),new PosixNmSymbolNameTool(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_NM,env))),ImmutableList.of(),ImmutableList.of(),ImmutableList.of(),ImmutableList.of(),sharedLibraryExtension,sharedLibraryVersionedExtensionFormat,staticLibraryExtension,objectFileExtension,compilerSanitizer,new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),ImmutableBiMap.of()),ImmutableMap.of(),binaryExtension,config.getHeaderVerification());
}","public static CxxPlatform build(Platform platform,CxxBuckConfig config){
  String sharedLibraryExtension;
  String sharedLibraryVersionedExtensionFormat;
  String staticLibraryExtension;
  String objectFileExtension;
  Path defaultCFrontend;
  Path defaultCxxFrontend;
  Path defaultLinker;
  LinkerProvider.Type linkerType;
  Archiver archiver;
  DebugPathSanitizer compilerSanitizer;
  Optional<String> binaryExtension;
  ImmutableMap<String,String> env=config.getEnvironment();
  Optional<CxxToolProvider.Type> defaultToolType=Optional.empty();
  String ranlibCommand;
switch (platform) {
case LINUX:
    sharedLibraryExtension=""String_Node_Str"";
  sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_C_FRONTEND,env);
defaultCxxFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_CXX_FRONTEND,env);
defaultLinker=defaultCxxFrontend;
linkerType=LinkerProvider.Type.GNU;
archiver=new GnuArchiver(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_AR,env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",ImmutableBiMap.of(),CxxToolProvider.Type.GCC);
binaryExtension=Optional.empty();
ranlibCommand=DEFAULT_UNIX_RANLIB;
break;
case MACOS:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_OSX_C_FRONTEND,env);
defaultCxxFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_OSX_CXX_FRONTEND,env);
defaultLinker=defaultCxxFrontend;
linkerType=LinkerProvider.Type.DARWIN;
archiver=new BsdArchiver(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_AR,env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",ImmutableBiMap.of(),CxxToolProvider.Type.CLANG);
binaryExtension=Optional.empty();
ranlibCommand=DEFAULT_UNIX_RANLIB;
break;
case WINDOWS:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(DEFAULT_WINDOWS_CXX_FRONTEND,Paths.get(DEFAULT_WINDOWS_CXX_FRONTEND),env);
defaultCxxFrontend=getExecutablePath(DEFAULT_WINDOWS_CXX_FRONTEND,Paths.get(DEFAULT_WINDOWS_CXX_FRONTEND),env);
defaultLinker=getExecutablePath(DEFAULT_WINDOWS_LINK,Paths.get(DEFAULT_WINDOWS_LINK),env);
linkerType=LinkerProvider.Type.WINDOWS;
archiver=new WindowsArchiver(new HashedFileTool(getExecutablePath(DEFAULT_WINDOWS_LIB,Paths.get(DEFAULT_WINDOWS_LIB),env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",ImmutableBiMap.of(),CxxToolProvider.Type.WINDOWS);
binaryExtension=Optional.of(""String_Node_Str"");
defaultToolType=Optional.of(CxxToolProvider.Type.WINDOWS);
ranlibCommand=DEFAULT_WINDOWS_RANLIB;
break;
case FREEBSD:
sharedLibraryExtension=""String_Node_Str"";
sharedLibraryVersionedExtensionFormat=""String_Node_Str"";
staticLibraryExtension=""String_Node_Str"";
objectFileExtension=""String_Node_Str"";
defaultCFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_C_FRONTEND,env);
defaultCxxFrontend=getExecutablePath(""String_Node_Str"",DEFAULT_CXX_FRONTEND,env);
defaultLinker=defaultCxxFrontend;
linkerType=LinkerProvider.Type.GNU;
archiver=new BsdArchiver(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_AR,env)));
compilerSanitizer=new PrefixMapDebugPathSanitizer(""String_Node_Str"",ImmutableBiMap.of(),CxxToolProvider.Type.GCC);
binaryExtension=Optional.empty();
ranlibCommand=DEFAULT_UNIX_RANLIB;
break;
default :
throw new RuntimeException(String.format(""String_Node_Str"",platform));
}
PreprocessorProvider aspp=new PreprocessorProvider(defaultCFrontend,defaultToolType);
CompilerProvider as=new CompilerProvider(defaultCFrontend,defaultToolType);
PreprocessorProvider cpp=new PreprocessorProvider(defaultCFrontend,defaultToolType);
CompilerProvider cc=new CompilerProvider(defaultCFrontend,defaultToolType);
PreprocessorProvider cxxpp=new PreprocessorProvider(defaultCxxFrontend,defaultToolType);
CompilerProvider cxx=new CompilerProvider(defaultCxxFrontend,defaultToolType);
return CxxPlatforms.build(FLAVOR,platform,config,as,aspp,cc,cxx,cpp,cxxpp,new DefaultLinkerProvider(linkerType,new ConstantToolProvider(new HashedFileTool(defaultLinker))),ImmutableList.of(),new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_STRIP,env)),archiver,new HashedFileTool(getExecutablePath(ranlibCommand,DEFAULT_RANLIB,env)),new PosixNmSymbolNameTool(new HashedFileTool(getExecutablePath(""String_Node_Str"",DEFAULT_NM,env))),ImmutableList.of(),ImmutableList.of(),ImmutableList.of(),ImmutableList.of(),sharedLibraryExtension,sharedLibraryVersionedExtensionFormat,staticLibraryExtension,objectFileExtension,compilerSanitizer,new MungingDebugPathSanitizer(config.getDebugPathSanitizerLimit(),File.separatorChar,Paths.get(""String_Node_Str""),ImmutableBiMap.of()),ImmutableMap.of(),binaryExtension,config.getHeaderVerification());
}",0.9618684461391802
52909,"/** 
 * @return a {@link ByteBufferReplacer} suitable for replacing {@code workingDir} with {@code compilationDirectory}.
 */
protected ByteBufferReplacer getCompilationDirectoryReplacer(Path workingDir){
  return new ByteBufferReplacer(ImmutableMap.of(getExpandedPath(workingDir).getBytes(Charsets.US_ASCII),getExpandedPath(compilationDirectory).getBytes(Charsets.US_ASCII)));
}","/** 
 * @return a {@link ByteBufferReplacer} suitable for replacing {@code workingDir} with {@code compilationDirectory}.
 */
private ByteBufferReplacer getCompilationDirectoryReplacer(Path workingDir){
  return new ByteBufferReplacer(ImmutableMap.of(getExpandedPath(workingDir).getBytes(Charsets.US_ASCII),getExpandedPath(compilationDirectory).getBytes(Charsets.US_ASCII)));
}",0.984126984126984
52910,"/** 
 * @param pathSize fix paths to this size for in-place replacements.
 * @param separator the path separator used to fill paths aren't of {@code pathSize} length.
 * @param compilationDirectory the desired path to replace the actual compilation directory with.
 */
public MungingDebugPathSanitizer(int pathSize,char separator,Path compilationDirectory,ImmutableBiMap<Path,String> other){
  super(separator,pathSize,compilationDirectory);
  this.other=other;
}","/** 
 * @param pathSize fix paths to this size for in-place replacements.
 * @param separator the path separator used to fill paths aren't of {@code pathSize} length.
 * @param compilationDirectory the desired path to replace the actual compilation directory with.
 */
public MungingDebugPathSanitizer(int pathSize,char separator,Path compilationDirectory,ImmutableBiMap<Path,String> other){
  this.compilationDirectory=compilationDirectory;
  this.pathSize=pathSize;
  this.separator=separator;
  this.other=other;
}",0.8714285714285714
52911,"public PrefixMapDebugPathSanitizer(int pathSize,char separator,Path fakeCompilationDirectory,ImmutableBiMap<Path,String> other,CxxToolProvider.Type cxxType){
  super(separator,pathSize,fakeCompilationDirectory);
  this.isGcc=cxxType == CxxToolProvider.Type.GCC;
  this.cxxType=cxxType;
  ImmutableBiMap.Builder<Path,String> pathsBuilder=ImmutableBiMap.builder();
  pathsBuilder.putAll(FluentIterable.from(other.entrySet()).toSortedList((left,right) -> right.getKey().toString().length() - left.getKey().toString().length()));
  this.other=pathsBuilder.build();
}","public PrefixMapDebugPathSanitizer(String fakeCompilationDirectory,ImmutableBiMap<Path,String> other,CxxToolProvider.Type cxxType){
  this.fakeCompilationDirectory=fakeCompilationDirectory;
  this.isGcc=cxxType == CxxToolProvider.Type.GCC;
  this.cxxType=cxxType;
  ImmutableBiMap.Builder<Path,String> pathsBuilder=ImmutableBiMap.builder();
  other.entrySet().stream().sorted((left,right) -> right.getKey().toString().length() - left.getKey().toString().length()).forEach(e -> pathsBuilder.put(e.getKey(),e.getValue()));
  this.other=pathsBuilder.build();
}",0.775692582663092
52912,"@Override protected Iterable<Map.Entry<Path,String>> getAllPaths(Optional<Path> workingDir){
  if (!workingDir.isPresent()) {
    return other.entrySet();
  }
  return Iterables.concat(other.entrySet(),ImmutableList.of(new AbstractMap.SimpleEntry<>(workingDir.get(),compilationDirectory.toString())));
}","@Override protected Iterable<Map.Entry<Path,String>> getAllPaths(Optional<Path> workingDir){
  if (!workingDir.isPresent()) {
    return other.entrySet();
  }
  return Iterables.concat(other.entrySet(),ImmutableList.of(new AbstractMap.SimpleEntry<>(workingDir.get(),fakeCompilationDirectory)));
}",0.9081803005008348
52913,"@Test public void runtimeSupportsStl() throws InterruptedException, IOException {
  assumeTrue(""String_Node_Str"",NdkCxxPlatforms.isSupportedConfiguration(getNdkRoot(),cxxRuntime));
  ProjectWorkspace workspace=setupWorkspace(""String_Node_Str"");
  workspace.runBuckCommand(""String_Node_Str"",String.format(""String_Node_Str"",arch)).assertSuccess();
}","@Test public void runtimeSupportsStl() throws InterruptedException, IOException {
  assumeTrue(""String_Node_Str"",NdkCxxPlatforms.isSupportedConfiguration(getNdkRoot(),cxxRuntime));
  ProjectWorkspace workspace=setupWorkspace(""String_Node_Str"",tmp);
  workspace.runBuckCommand(""String_Node_Str"",String.format(""String_Node_Str"",arch)).assertSuccess();
}",0.994269340974212
52914,"private ProjectWorkspace setupWorkspace(String name) throws IOException {
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,name,tmp);
  workspace.setUp();
  workspace.writeContentsToPath(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",compiler,cxxRuntime),""String_Node_Str"");
  return workspace;
}","private ProjectWorkspace setupWorkspace(String name,TemporaryPaths tmp) throws IOException {
  ProjectWorkspace workspace=TestDataHelper.createProjectWorkspaceForScenario(this,name,tmp);
  workspace.setUp();
  workspace.writeContentsToPath(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",compiler,cxxRuntime),""String_Node_Str"");
  return workspace;
}",0.9774614472123369
52915,"@Test public void testWorkingDirectoryAndNdkHeaderPathsAreSanitized() throws InterruptedException, IOException {
  ProjectWorkspace workspace=setupWorkspace(""String_Node_Str"");
  workspace.writeContentsToPath(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  ProjectFilesystem filesystem=new ProjectFilesystem(workspace.getDestPath());
  BuildTarget target=BuildTargetFactory.newInstance(String.format(""String_Node_Str"",arch));
  workspace.runBuckBuild(target.getFullyQualifiedName()).assertSuccess();
  Path lib=workspace.getPath(BuildTargets.getGenPath(filesystem,target,""String_Node_Str"" + target.getShortName() + ""String_Node_Str""));
  String contents=MorePaths.asByteSource(lib).asCharSource(Charsets.ISO_8859_1).read();
  assertFalse(contents.contains(tmp.getRoot().toString()));
  for (  NdkCxxPlatforms.Host host : NdkCxxPlatforms.Host.values()) {
    assertFalse(contents.contains(host.toString()));
  }
  assertFalse(contents.contains(getNdkRoot().toString()));
}","@Test public void testWorkingDirectoryAndNdkHeaderPathsAreSanitized() throws InterruptedException, IOException {
  String buckConfig=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  ProjectWorkspace workspace=setupWorkspace(""String_Node_Str"",tmp);
  ProjectFilesystem filesystem=new ProjectFilesystem(workspace.getDestPath());
  workspace.writeContentsToPath(buckConfig,""String_Node_Str"");
  BuildTarget target=BuildTargetFactory.newInstance(String.format(""String_Node_Str"",arch));
  workspace.runBuckBuild(target.getFullyQualifiedName()).assertSuccess();
  Path lib=workspace.getPath(BuildTargets.getGenPath(filesystem,target,""String_Node_Str"" + target.getShortName() + ""String_Node_Str""));
  String contents=MorePaths.asByteSource(lib).asCharSource(Charsets.ISO_8859_1).read();
  assertFalse(contents.contains(tmp.getRoot().toString()));
  for (  NdkCxxPlatforms.Host host : NdkCxxPlatforms.Host.values()) {
    assertFalse(contents.contains(host.toString()));
  }
  assertFalse(contents.contains(getNdkRoot().toString()));
  ProjectWorkspace longPwdWorkspace=setupWorkspace(""String_Node_Str"",tmp_long_pwd);
  ProjectFilesystem longPwdFilesystem=new ProjectFilesystem(workspace.getDestPath());
  longPwdWorkspace.writeContentsToPath(buckConfig,""String_Node_Str"");
  longPwdWorkspace.runBuckBuild(target.getFullyQualifiedName()).assertSuccess();
  lib=longPwdWorkspace.getPath(BuildTargets.getGenPath(longPwdFilesystem,target,""String_Node_Str"" + target.getShortName() + ""String_Node_Str""));
  String movedContents=MorePaths.asByteSource(lib).asCharSource(Charsets.ISO_8859_1).read();
  assertEquals(contents,movedContents);
}",0.6472564389697648
52916,"@Test public void changedPlatformTarget() throws InterruptedException, IOException {
  assumeTrue(""String_Node_Str"",NdkCxxPlatforms.isSupportedConfiguration(getNdkRoot(),cxxRuntime));
  assumeThat(""String_Node_Str"",arch,not(anyOf(equalTo(""String_Node_Str""),equalTo(""String_Node_Str""))));
  ProjectWorkspace workspace=setupWorkspace(""String_Node_Str"");
  BuildTarget target=BuildTargetFactory.newInstance(String.format(""String_Node_Str"",arch));
  BuildTarget linkTarget=CxxDescriptionEnhancer.createCxxLinkTarget(target,Optional.empty());
  workspace.runBuckCommand(""String_Node_Str"",target.toString()).assertSuccess();
  workspace.getBuildLog().assertTargetBuiltLocally(linkTarget.toString());
  workspace.writeContentsToPath(""String_Node_Str"",""String_Node_Str"");
  workspace.runBuckCommand(""String_Node_Str"",target.toString()).assertSuccess();
  workspace.getBuildLog().assertTargetBuiltLocally(linkTarget.toString());
}","@Test public void changedPlatformTarget() throws InterruptedException, IOException {
  assumeTrue(""String_Node_Str"",NdkCxxPlatforms.isSupportedConfiguration(getNdkRoot(),cxxRuntime));
  assumeThat(""String_Node_Str"",arch,not(anyOf(equalTo(""String_Node_Str""),equalTo(""String_Node_Str""))));
  ProjectWorkspace workspace=setupWorkspace(""String_Node_Str"",tmp);
  BuildTarget target=BuildTargetFactory.newInstance(String.format(""String_Node_Str"",arch));
  BuildTarget linkTarget=CxxDescriptionEnhancer.createCxxLinkTarget(target,Optional.empty());
  workspace.runBuckCommand(""String_Node_Str"",target.toString()).assertSuccess();
  workspace.getBuildLog().assertTargetBuiltLocally(linkTarget.toString());
  workspace.writeContentsToPath(""String_Node_Str"",""String_Node_Str"");
  workspace.runBuckCommand(""String_Node_Str"",target.toString()).assertSuccess();
  workspace.getBuildLog().assertTargetBuiltLocally(linkTarget.toString());
}",0.9978331527627302
52917,"public static CxxSandboxInclude from(SymlinkTree symlinkTree,String includeDir,CxxPreprocessables.IncludeType includeType){
  CxxSandboxInclude.Builder builder=CxxSandboxInclude.builder();
  builder.setIncludeType(includeType);
  builder.setRoot(new ExplicitBuildTargetSourcePath(symlinkTree.getBuildTarget(),symlinkTree.getRoot().resolve(includeDir)));
  builder.setIncludeDir(includeDir);
  return builder.build();
}","public static CxxSandboxInclude from(SymlinkTree symlinkTree,String includeDir,CxxPreprocessables.IncludeType includeType){
  CxxSandboxInclude.Builder builder=CxxSandboxInclude.builder();
  builder.setIncludeType(includeType);
  builder.setRoot(new ExplicitBuildTargetSourcePath(symlinkTree.getBuildTarget(),symlinkTree.getProjectFilesystem().relativize(symlinkTree.getRoot().resolve(includeDir))));
  builder.setIncludeDir(includeDir);
  return builder.build();
}",0.9467723669309174
52918,"/** 
 * @return a {@link CxxHeaders} constructed from the given {@link HeaderSymlinkTree}. 
 */
public static CxxSymlinkTreeHeaders from(HeaderSymlinkTree symlinkTree,CxxPreprocessables.IncludeType includeType){
  CxxSymlinkTreeHeaders.Builder builder=CxxSymlinkTreeHeaders.builder();
  builder.setBuildTarget(symlinkTree.getBuildTarget());
  builder.setIncludeType(includeType);
  builder.setRoot(new ExplicitBuildTargetSourcePath(symlinkTree.getBuildTarget(),symlinkTree.getRoot()));
  if (includeType == CxxPreprocessables.IncludeType.LOCAL) {
    builder.setIncludeRoot(new ExplicitBuildTargetSourcePath(symlinkTree.getBuildTarget(),symlinkTree.getIncludePath()));
    if (symlinkTree.getHeaderMap().isPresent()) {
      builder.setHeaderMap(new ExplicitBuildTargetSourcePath(symlinkTree.getBuildTarget(),symlinkTree.getHeaderMap().get()));
    }
  }
 else {
    builder.setIncludeRoot(new ExplicitBuildTargetSourcePath(symlinkTree.getBuildTarget(),symlinkTree.getRoot()));
  }
  builder.putAllNameToPathMap(symlinkTree.getLinks());
  return builder.build();
}","/** 
 * @return a {@link CxxHeaders} constructed from the given {@link HeaderSymlinkTree}. 
 */
public static CxxSymlinkTreeHeaders from(HeaderSymlinkTree symlinkTree,CxxPreprocessables.IncludeType includeType){
  CxxSymlinkTreeHeaders.Builder builder=CxxSymlinkTreeHeaders.builder();
  builder.setBuildTarget(symlinkTree.getBuildTarget());
  builder.setIncludeType(includeType);
  builder.setRoot(new ExplicitBuildTargetSourcePath(symlinkTree.getBuildTarget(),symlinkTree.getProjectFilesystem().relativize(symlinkTree.getRoot())));
  if (includeType == CxxPreprocessables.IncludeType.LOCAL) {
    builder.setIncludeRoot(new ExplicitBuildTargetSourcePath(symlinkTree.getBuildTarget(),symlinkTree.getIncludePath()));
    if (symlinkTree.getHeaderMap().isPresent()) {
      builder.setHeaderMap(new ExplicitBuildTargetSourcePath(symlinkTree.getBuildTarget(),symlinkTree.getHeaderMap().get()));
    }
  }
 else {
    builder.setIncludeRoot(new ExplicitBuildTargetSourcePath(symlinkTree.getBuildTarget(),symlinkTree.getProjectFilesystem().relativize(symlinkTree.getRoot())));
  }
  builder.putAllNameToPathMap(symlinkTree.getLinks());
  return builder.build();
}",0.9576957695769576
52919,"@SuppressWarnings(""String_Node_Str"") ImmutableList<String> getCompilationFlags(Path workingDir){
  return ImmutableList.of();
}","@SuppressWarnings(""String_Node_Str"") ImmutableList<String> getCompilationFlags(Path workingDir,ImmutableMap<Path,Path> prefixMap){
  return ImmutableList.of();
}",0.8819444444444444
52920,"public Builder addSymlinkTree(SourcePath root,ImmutableMap<Path,SourcePath> headerMap){
  Path rootPath=pathResolver.getAbsolutePath(root);
  for (  Map.Entry<Path,SourcePath> entry : headerMap.entrySet()) {
    addHeader(entry.getValue(),rootPath.resolve(entry.getKey()));
  }
  return this;
}","public Builder addSymlinkTree(SourcePath root,ImmutableMap<Path,SourcePath> headerMap){
  Path rootPath=pathResolver.getAbsolutePath(root);
  for (  Map.Entry<Path,SourcePath> entry : headerMap.entrySet()) {
    addHeader(entry.getValue(),rootPath.resolve(entry.getKey()));
  }
  Optional<Pair<Path,ImmutableList<Path>>> keys=MorePaths.splitOnCommonPrefix(headerMap.keySet());
  Optional<Pair<Path,ImmutableList<Path>>> vals=MorePaths.splitOnCommonPrefix(headerMap.values().stream().map(pathResolver::getRelativePath).collect(Collectors.toList()));
  if (keys.isPresent() && vals.isPresent() && keys.get().getSecond().equals(vals.get().getSecond())) {
    Pair<Path,Path> stripped=MorePaths.stripCommonSuffix(pathResolver.getRelativePath(root).resolve(keys.get().getFirst()),vals.get().getFirst());
    prefixMap.put(stripped.getFirst(),stripped.getSecond());
  }
  return this;
}",0.4821124361158432
52921,"public HeaderPathNormalizer build(){
  return new HeaderPathNormalizer(pathResolver,ImmutableMap.copyOf(headers),ImmutableMap.copyOf(normalized));
}","public HeaderPathNormalizer build(){
  return new HeaderPathNormalizer(pathResolver,ImmutableMap.copyOf(headers),ImmutableMap.copyOf(normalized),ImmutableMap.copyOf(prefixMap));
}",0.9051987767584098
52922,"protected HeaderPathNormalizer(SourcePathResolver pathResolver,ImmutableMap<Path,SourcePath> headers,ImmutableMap<Path,SourcePath> normalized){
  this.pathResolver=pathResolver;
  this.headers=headers;
  this.normalized=normalized;
}","protected HeaderPathNormalizer(SourcePathResolver pathResolver,ImmutableMap<Path,SourcePath> headers,ImmutableMap<Path,SourcePath> normalized,ImmutableMap<Path,Path> prefixMap){
  this.pathResolver=pathResolver;
  this.headers=headers;
  this.normalized=normalized;
  this.prefixMap=prefixMap;
}",0.8825757575757576
52923,"public static HeaderPathNormalizer empty(SourcePathResolver pathResolver){
  return new HeaderPathNormalizer(pathResolver,ImmutableMap.of(),ImmutableMap.of());
}","public static HeaderPathNormalizer empty(SourcePathResolver pathResolver){
  return new HeaderPathNormalizer(pathResolver,ImmutableMap.of(),ImmutableMap.of(),ImmutableMap.of());
}",0.9470588235294116
52924,"public PrefixMapDebugPathSanitizer(String fakeCompilationDirectory,ImmutableBiMap<Path,String> other,CxxToolProvider.Type cxxType){
  this.fakeCompilationDirectory=fakeCompilationDirectory;
  this.isGcc=cxxType == CxxToolProvider.Type.GCC;
  this.cxxType=cxxType;
  ImmutableBiMap.Builder<Path,String> pathsBuilder=ImmutableBiMap.builder();
  other.entrySet().stream().sorted((left,right) -> right.getKey().toString().length() - left.getKey().toString().length()).forEach(e -> pathsBuilder.put(e.getKey(),e.getValue()));
  this.other=pathsBuilder.build();
}","public PrefixMapDebugPathSanitizer(String fakeCompilationDirectory,ImmutableBiMap<Path,String> other,CxxToolProvider.Type cxxType){
  this.fakeCompilationDirectory=fakeCompilationDirectory;
  this.isGcc=cxxType == CxxToolProvider.Type.GCC;
  this.cxxType=cxxType;
  this.other=other;
}",0.6389548693586699
52925,"private String getDebugPrefixMapFlag(Path realPath,String fakePath){
  return String.format(""String_Node_Str"",realPath,fakePath);
}","private String getDebugPrefixMapFlag(Path realPath,String fakePath){
  String realPathStr=realPath.toString();
  if (fakePath.isEmpty()) {
    realPathStr+=""String_Node_Str"";
  }
  return String.format(""String_Node_Str"",realPathStr,fakePath);
}",0.6986666666666667
52926,"@Override ImmutableList<String> getCompilationFlags(Path workingDir){
  if (cxxType == CxxToolProvider.Type.WINDOWS) {
    return ImmutableList.of();
  }
  ImmutableList.Builder<String> flags=ImmutableList.builder();
  Iterable<Map.Entry<Path,String>> iter=ImmutableList.copyOf(getAllPaths(Optional.of(workingDir))).reverse();
  for (  Map.Entry<Path,String> mappings : iter) {
    flags.add(getDebugPrefixMapFlag(mappings.getKey(),mappings.getValue()));
  }
  if (isGcc) {
    flags.add(""String_Node_Str"");
  }
  return flags.build();
}","@Override ImmutableList<String> getCompilationFlags(Path workingDir,ImmutableMap<Path,Path> prefixMap){
  if (cxxType == CxxToolProvider.Type.WINDOWS) {
    return ImmutableList.of();
  }
  ImmutableList.Builder<String> flags=ImmutableList.builder();
  RichStream.from(prefixMap.entrySet()).<Map.Entry<Path,String>>map(e -> new AbstractMap.SimpleEntry<>(e.getKey(),e.getValue().toString())).concat(RichStream.from(getAllPaths(Optional.of(workingDir)))).sorted(Comparator.comparingInt(entry -> entry.getKey().toString().length())).map(p -> getDebugPrefixMapFlag(p.getKey(),p.getValue())).forEach(flags::add);
  if (isGcc) {
    flags.add(""String_Node_Str"");
  }
  return flags.build();
}",0.6034341782502044
52927,"@Override public HeaderPathNormalizer get(){
  HeaderPathNormalizer.Builder builder=new HeaderPathNormalizer.Builder(resolver);
  for (  CxxHeaders include : preprocessorFlags.getIncludes()) {
    include.addToHeaderPathNormalizer(builder);
  }
  for (  FrameworkPath frameworkPath : preprocessorFlags.getFrameworkPaths()) {
    frameworkPath.getSourcePath().ifPresent(builder::addHeaderDir);
  }
  if (preprocessorFlags.getPrefixHeader().isPresent()) {
    SourcePath headerPath=preprocessorFlags.getPrefixHeader().get();
    builder.addPrefixHeader(headerPath);
  }
  if (sandbox.isPresent()) {
    ExplicitBuildTargetSourcePath root=new ExplicitBuildTargetSourcePath(sandbox.get().getBuildTarget(),sandbox.get().getRoot());
    builder.addSymlinkTree(root,sandbox.get().getLinks());
  }
  return builder.build();
}","@Override public HeaderPathNormalizer get(){
  HeaderPathNormalizer.Builder builder=new HeaderPathNormalizer.Builder(resolver);
  for (  CxxHeaders include : preprocessorFlags.getIncludes()) {
    include.addToHeaderPathNormalizer(builder);
  }
  for (  FrameworkPath frameworkPath : preprocessorFlags.getFrameworkPaths()) {
    frameworkPath.getSourcePath().ifPresent(builder::addHeaderDir);
  }
  if (preprocessorFlags.getPrefixHeader().isPresent()) {
    SourcePath headerPath=preprocessorFlags.getPrefixHeader().get();
    builder.addPrefixHeader(headerPath);
  }
  if (sandbox.isPresent()) {
    ExplicitBuildTargetSourcePath root=new ExplicitBuildTargetSourcePath(sandbox.get().getBuildTarget(),sandbox.get().getProjectFilesystem().relativize(sandbox.get().getRoot()));
    builder.addSymlinkTree(root,sandbox.get().getLinks());
  }
  return builder.build();
}",0.9708853238265004
52928,"@Test public void shouldProperlyTransformColoredLinesInErrorMessages(){
  Ansi ansi=new Ansi(true);
  assertThat(transformer.transformLine(String.format(""String_Node_Str"",ansi.asErrorText(originalPath + ""String_Node_Str""))),equalTo(String.format(""String_Node_Str"",ansi.asErrorText(expectedPath + ""String_Node_Str""))));
  assertThat(transformer.transformLine(String.format(""String_Node_Str"",ansi.asErrorText(originalPath + ""String_Node_Str""))),equalTo(String.format(""String_Node_Str"",ansi.asErrorText(expectedPath + ""String_Node_Str""))));
  assertThat(transformer.transformLine(String.format(""String_Node_Str"",ansi.asErrorText(originalPath + ""String_Node_Str""))),equalTo(String.format(""String_Node_Str"",ansi.asErrorText(expectedPath + ""String_Node_Str""))));
}","@Test public void shouldProperlyTransformColoredLinesInErrorMessages(){
  Ansi ansi=new Ansi(true);
  assertThat(transformer.transformLine(String.format(""String_Node_Str"",ansi.asErrorText(originalPath + ""String_Node_Str""))),equalTo(String.format(""String_Node_Str"",ansi.asErrorText(expectedPath + ""String_Node_Str""))));
  assertThat(transformer.transformLine(String.format(""String_Node_Str"",ansi.asErrorText(originalPath + ""String_Node_Str""))),equalTo(String.format(""String_Node_Str"",ansi.asErrorText(expectedPath + ""String_Node_Str""))));
  assertThat(transformer.transformLine(String.format(""String_Node_Str"",ansi.asErrorText(originalPath + ""String_Node_Str""))),equalTo(String.format(""String_Node_Str"",ansi.asErrorText(expectedPath + ""String_Node_Str""))));
  assertThat(transformer.transformLine(String.format(""String_Node_Str"",originalPath)),equalTo(String.format(""String_Node_Str"",expectedPath)));
  assertThat(transformer.transformLine(String.format(""String_Node_Str"",originalPath)),equalTo(String.format(""String_Node_Str"",expectedPath)));
  assertThat(transformer.transformLine(String.format(""String_Node_Str"",originalPath)),equalTo(String.format(""String_Node_Str"",expectedPath)));
  assertThat(transformer.transformLine(String.format(""String_Node_Str"",originalPath)),equalTo(String.format(""String_Node_Str"",expectedPath)));
}",0.7260536398467433
52929,"@Override public BuildRule createBuildRule(TargetGraph targetGraph,BuildRuleParams params,final BuildRuleResolver resolver,CellPathResolver cellRoots,SwiftLibraryDescriptionArg args) throws NoSuchBuildTargetException {
  Optional<LinkerMapMode> flavoredLinkerMapMode=LinkerMapMode.FLAVOR_DOMAIN.getValue(params.getBuildTarget());
  params=params.withBuildTarget(LinkerMapMode.removeLinkerMapModeFlavorInTarget(params.getBuildTarget(),flavoredLinkerMapMode));
  final BuildTarget buildTarget=params.getBuildTarget();
  Optional<Map.Entry<Flavor,CxxPlatform>> platform=cxxPlatformFlavorDomain.getFlavorAndValue(buildTarget);
  final ImmutableSortedSet<Flavor> buildFlavors=buildTarget.getFlavors();
  ImmutableSortedSet<BuildRule> filteredExtraDeps=params.getExtraDeps().get().stream().filter(input -> !input.getBuildTarget().getUnflavoredBuildTarget().equals(buildTarget.getUnflavoredBuildTarget())).collect(MoreCollectors.toImmutableSortedSet());
  params=params.withExtraDeps(filteredExtraDeps);
  if (!buildFlavors.contains(SWIFT_COMPANION_FLAVOR) && platform.isPresent()) {
    final CxxPlatform cxxPlatform=platform.get().getValue();
    Optional<SwiftPlatform> swiftPlatform=swiftPlatformFlavorDomain.getValue(buildTarget);
    if (!swiftPlatform.isPresent()) {
      throw new HumanReadableException(""String_Node_Str"",cxxPlatform);
    }
    Optional<Map.Entry<Flavor,Type>> type=LIBRARY_TYPE.getFlavorAndValue(buildTarget);
    if (!buildFlavors.contains(SWIFT_COMPILE_FLAVOR) && type.isPresent()) {
      Set<Flavor> flavors=Sets.newHashSet(params.getBuildTarget().getFlavors());
      flavors.remove(type.get().getKey());
      BuildTarget target=BuildTarget.builder(params.getBuildTarget().getUnflavoredBuildTarget()).addAllFlavors(flavors).build();
      if (flavoredLinkerMapMode.isPresent()) {
        target=target.withAppendedFlavors(flavoredLinkerMapMode.get().getFlavor());
      }
      BuildRuleParams typeParams=params.withBuildTarget(target);
switch (type.get().getValue()) {
case SHARED:
        return createSharedLibraryBuildRule(typeParams,resolver,target,swiftPlatform.get(),cxxPlatform,args.getSoname());
case STATIC:
case MACH_O_BUNDLE:
    }
    throw new RuntimeException(""String_Node_Str"");
  }
  ImmutableSet<SwiftCompile> swiftCompileRules=RichStream.from(params.getBuildDeps()).filter(SwiftLibrary.class).map(input -> input.requireSwiftCompileRule(cxxPlatform.getFlavor())).toImmutableSet();
  ImmutableSet<SwiftCompile> implicitSwiftCompileRules=RichStream.from(params.getBuildDeps()).filter(CxxLibrary.class).flatMap(input -> {
    BuildTarget companionTarget=input.getBuildTarget().withAppendedFlavors(SWIFT_COMPANION_FLAVOR);
    return RichStream.from(resolver.getRuleOptional(companionTarget).map(companion -> ((SwiftLibrary)companion).requireSwiftCompileRule(cxxPlatform.getFlavor())));
  }
).toImmutableSet();
  CxxPreprocessorInput inputs=CxxPreprocessorInput.concat(CxxPreprocessables.getTransitiveCxxPreprocessorInput(cxxPlatform,params.getBuildDeps()));
  PreprocessorFlags cxxDeps=PreprocessorFlags.of(Optional.empty(),CxxToolFlags.of(),RichStream.from(inputs.getIncludes()).filter(headers -> headers.getIncludeType() != CxxPreprocessables.IncludeType.SYSTEM).toImmutableSet(),inputs.getFrameworks());
  Preprocessor preprocessor=cxxPlatform.getCpp().resolve(resolver);
  SourcePathRuleFinder ruleFinder=new SourcePathRuleFinder(resolver);
  return new SwiftCompile(cxxPlatform,swiftBuckConfig,new BuildRuleParams(params.getBuildTarget(),() -> ImmutableSortedSet.<BuildRule>naturalOrder().addAll(swiftCompileRules).addAll(implicitSwiftCompileRules).addAll(cxxDeps.getDeps(ruleFinder)).addAll(preprocessor.getDeps(ruleFinder)).build(),ImmutableSortedSet::of,ImmutableSortedSet.of(),params.getProjectFilesystem()),swiftPlatform.get().getSwiftc(),args.getFrameworks(),args.getModuleName().orElse(buildTarget.getShortName()),BuildTargets.getGenPath(params.getProjectFilesystem(),buildTarget,""String_Node_Str""),args.getSrcs(),RichStream.from(args.getCompilerFlags()).map(f -> CxxDescriptionEnhancer.toStringWithMacrosArgs(buildTarget,cellRoots,resolver,cxxPlatform,f)).toImmutableList(),args.getEnableObjcInterop(),args.getBridgingHeader(),preprocessor,cxxDeps);
}
params=params.withBuildTarget(LinkerMapMode.restoreLinkerMapModeFlavorInTarget(params.getBuildTarget(),flavoredLinkerMapMode));
return new SwiftLibrary(params,resolver,ImmutableSet.of(),swiftPlatformFlavorDomain,args.getFrameworks(),args.getLibraries(),args.getSupportedPlatformsRegex(),args.getPreferredLinkage().orElse(NativeLinkable.Linkage.ANY));
}","@Override public BuildRule createBuildRule(TargetGraph targetGraph,BuildRuleParams params,final BuildRuleResolver resolver,CellPathResolver cellRoots,SwiftLibraryDescriptionArg args) throws NoSuchBuildTargetException {
  Optional<LinkerMapMode> flavoredLinkerMapMode=LinkerMapMode.FLAVOR_DOMAIN.getValue(params.getBuildTarget());
  params=params.withBuildTarget(LinkerMapMode.removeLinkerMapModeFlavorInTarget(params.getBuildTarget(),flavoredLinkerMapMode));
  final BuildTarget buildTarget=params.getBuildTarget();
  Optional<Map.Entry<Flavor,CxxPlatform>> platform=cxxPlatformFlavorDomain.getFlavorAndValue(buildTarget);
  final ImmutableSortedSet<Flavor> buildFlavors=buildTarget.getFlavors();
  ImmutableSortedSet<BuildRule> filteredExtraDeps=params.getExtraDeps().get().stream().filter(input -> !input.getBuildTarget().getUnflavoredBuildTarget().equals(buildTarget.getUnflavoredBuildTarget())).collect(MoreCollectors.toImmutableSortedSet());
  params=params.withExtraDeps(filteredExtraDeps);
  if (!buildFlavors.contains(SWIFT_COMPANION_FLAVOR) && platform.isPresent()) {
    final CxxPlatform cxxPlatform=platform.get().getValue();
    Optional<SwiftPlatform> swiftPlatform=swiftPlatformFlavorDomain.getValue(buildTarget);
    if (!swiftPlatform.isPresent()) {
      throw new HumanReadableException(""String_Node_Str"",cxxPlatform);
    }
    Optional<Map.Entry<Flavor,Type>> type=LIBRARY_TYPE.getFlavorAndValue(buildTarget);
    if (!buildFlavors.contains(SWIFT_COMPILE_FLAVOR) && type.isPresent()) {
      Set<Flavor> flavors=Sets.newHashSet(params.getBuildTarget().getFlavors());
      flavors.remove(type.get().getKey());
      BuildTarget target=BuildTarget.builder(params.getBuildTarget().getUnflavoredBuildTarget()).addAllFlavors(flavors).build();
      if (flavoredLinkerMapMode.isPresent()) {
        target=target.withAppendedFlavors(flavoredLinkerMapMode.get().getFlavor());
      }
      BuildRuleParams typeParams=params.withBuildTarget(target);
switch (type.get().getValue()) {
case SHARED:
        return createSharedLibraryBuildRule(typeParams,resolver,target,swiftPlatform.get(),cxxPlatform,args.getSoname());
case STATIC:
case MACH_O_BUNDLE:
    }
    throw new RuntimeException(""String_Node_Str"");
  }
  ImmutableSet<SwiftCompile> swiftCompileRules=RichStream.from(params.getBuildDeps()).filter(SwiftLibrary.class).map(input -> input.requireSwiftCompileRule(cxxPlatform.getFlavor())).toImmutableSet();
  ImmutableSet<SwiftCompile> implicitSwiftCompileRules=RichStream.from(params.getBuildDeps()).filter(CxxLibrary.class).flatMap(input -> {
    BuildTarget companionTarget=input.getBuildTarget().withAppendedFlavors(SWIFT_COMPANION_FLAVOR);
    return RichStream.from(resolver.getRuleOptional(companionTarget).map(companion -> ((SwiftLibrary)companion).requireSwiftCompileRule(cxxPlatform.getFlavor())));
  }
).toImmutableSet();
  CxxPreprocessorInput inputs=CxxPreprocessorInput.concat(CxxPreprocessables.getTransitiveCxxPreprocessorInput(cxxPlatform,params.getBuildDeps()));
  PreprocessorFlags cxxDeps=PreprocessorFlags.of(Optional.empty(),CxxToolFlags.of(),RichStream.from(inputs.getIncludes()).filter(headers -> headers.getIncludeType() != CxxPreprocessables.IncludeType.SYSTEM).toImmutableSet(),inputs.getFrameworks());
  Preprocessor preprocessor=cxxPlatform.getCpp().resolve(resolver);
  SourcePathRuleFinder ruleFinder=new SourcePathRuleFinder(resolver);
  return new SwiftCompile(cxxPlatform,swiftBuckConfig,params.copyAppendingExtraDeps(() -> ImmutableSet.<BuildRule>builder().addAll(swiftCompileRules).addAll(implicitSwiftCompileRules).addAll(cxxDeps.getDeps(ruleFinder)).addAll(preprocessor.getDeps(ruleFinder)).build()),swiftPlatform.get().getSwiftc(),args.getFrameworks(),args.getModuleName().orElse(buildTarget.getShortName()),BuildTargets.getGenPath(params.getProjectFilesystem(),buildTarget,""String_Node_Str""),args.getSrcs(),RichStream.from(args.getCompilerFlags()).map(f -> CxxDescriptionEnhancer.toStringWithMacrosArgs(buildTarget,cellRoots,resolver,cxxPlatform,f)).toImmutableList(),args.getEnableObjcInterop(),args.getBridgingHeader(),preprocessor,cxxDeps);
}
params=params.withBuildTarget(LinkerMapMode.restoreLinkerMapModeFlavorInTarget(params.getBuildTarget(),flavoredLinkerMapMode));
return new SwiftLibrary(params,resolver,ImmutableSet.of(),swiftPlatformFlavorDomain,args.getFrameworks(),args.getLibraries(),args.getSupportedPlatformsRegex(),args.getPreferredLinkage().orElse(NativeLinkable.Linkage.ANY));
}",0.9811446317657496
52930,"private Set<String> generateRoots(List<String> sourceFiles){
  final Set<String> roots=new HashSet<>();
  final RootsHelper helper=new RootsHelper();
  for (  String sourceFile : sourceFiles) {
    String path=dirname(sourceFile);
    if (!isNullOrEmpty(path)) {
      helper.addSourcePath(path);
    }
  }
  final List<String> paths=helper.getSortedSourcePaths();
  for (int index=0, size=paths.size(); index < size; ) {
    final String path=pathWithBuck(paths.get(index));
    if (path == null) {
      index+=1;
      continue;
    }
    int lowestCost=helper.excludesUnder(path);
    String bestRoot=path;
    String parent=dirname(path);
    while (!isNullOrEmpty(parent)) {
      int cost=helper.excludesUnder(parent);
      if (cost < lowestCost) {
        lowestCost=cost;
        bestRoot=parent;
      }
      parent=pathWithBuck(dirname(parent));
    }
    roots.add(bestRoot);
    index+=1;
    String prefix=guaranteeEndsWithFileSeparator(bestRoot);
    while (index < size && paths.get(index).startsWith(prefix)) {
      index+=1;
    }
  }
  return roots;
}","/** 
 * This is a complex routine that takes a list of source files and builds the best set of roots - symlinks to directories - that contains the source files. <p>Any folder with a   {@code BUCK} file could be a root: the best root is the one that requiresthe fewest  {@code excludedFolder} tags, but sometimes we need to pick a less-good root. If wehave  {@code foo/bar/baz/tom},   {@code foo/bar/baz/dick}, and   {@code foo/bar/harry}, the best root for   {@code foo/bar/baz/tom} and {@code foo/bar/baz/dick} may be {@code foo/bar/baz} whilethe best root for  {@code foo/bar/harry} may be {@code foo/bar} ... which would be the directorycontaining  {@code foo/bar/baz}, so we need to pick   {@code foo/bar} for {@code foo/bar/baz/tom}. <p>We do this in two passes. The first pass builds a set of candidates and a map from source directory index to candidate, where a candidate is the best root by   {@code excludedFolder}count. The second pass examines each candidate, and replaces it with the highest ancestor from the set of candidate values, if any.
 */
private Set<String> generateRoots(List<String> sourceFiles){
  final RootsHelper helper=new RootsHelper();
  for (  String sourceFile : sourceFiles) {
    String path=dirname(sourceFile);
    if (!isNullOrEmpty(path)) {
      helper.addSourcePath(path);
    }
  }
  final List<String> paths=helper.getSortedSourcePaths();
  final Set<String> candidates=new HashSet<>();
  final String[] candidateMap=new String[paths.size()];
  for (int index=0, size=paths.size(); index < size; ) {
    final String path=pathWithBuck(paths.get(index));
    if (path == null) {
      index+=1;
      continue;
    }
    int lowestCost=helper.excludesUnder(path);
    String bestRoot=path;
    String parent=dirname(bestRoot);
    while (!isNullOrEmpty(parent)) {
      int cost=helper.excludesUnder(parent);
      if (cost < lowestCost) {
        lowestCost=cost;
        bestRoot=parent;
      }
      parent=pathWithBuck(dirname(parent));
    }
    candidates.add(bestRoot);
    candidateMap[index]=bestRoot;
    index+=1;
    String prefix=guaranteeEndsWithFileSeparator(bestRoot);
    while (index < size && paths.get(index).startsWith(prefix)) {
      index+=1;
    }
  }
  final Set<String> roots=new HashSet<>();
  for (int index=0, size=paths.size(); index < size; ) {
    final String candidate=candidateMap[index];
    if (candidate == null) {
      index+=1;
      continue;
    }
    String bestRoot=candidate;
    String parent=dirname(bestRoot);
    while (!isNullOrEmpty(parent)) {
      if (candidates.contains(parent)) {
        bestRoot=parent;
      }
      parent=dirname(parent);
    }
    roots.add(bestRoot);
    index+=1;
    String prefix=guaranteeEndsWithFileSeparator(bestRoot);
    while (index < size && paths.get(index).startsWith(prefix)) {
      index+=1;
    }
  }
  return roots;
}",0.1144746883744594
52931,"private void mangledResourceLink(Matcher match,String input){
  String fileName=basename(input);
  String name=fileName.substring(0,fileName.length() - DOT_XML.length());
  String path=match.group(1).replace('/','_');
  String configQualifier=match.groupCount() > 2 ? match.group(3) : ""String_Node_Str"";
  String directory=fileJoin(viewPath,OUTPUT_RESOURCE_FOLDER,match.group(2));
  mkdir(directory);
  symlink(fileJoin(repository,input),fileJoin(directory,path + name + configQualifier+ DOT_XML));
}","private void mangledResourceLink(Matcher match,String input){
  String fileName=basename(input);
  String name=fileName.substring(0,fileName.length() - DOT_XML.length());
  String path=match.group(1).replace('/','_');
  String configQualifier=match.group(3);
  if (configQualifier == null) {
    configQualifier=""String_Node_Str"";
  }
  String directory=fileJoin(viewPath,OUTPUT_RESOURCE_FOLDER,match.group(2));
  mkdir(directory);
  symlink(fileJoin(repository,input),fileJoin(directory,path + name + configQualifier+ DOT_XML));
}",0.915615906886518
52932,"@Override public boolean materializeFileContents(BuildJobStateFileHashEntry entry,Path targetAbsPath) throws IOException {
  if (inlineProvider.materializeFileContents(entry,targetAbsPath)) {
    fileMaterializationStatsTracker.recordLocalFileMaterialized();
    LOG.info(""String_Node_Str"",targetAbsPath);
    return true;
  }
  if (localFsProvider.isPresent() && localFsProvider.get().materializeFileContents(entry,targetAbsPath)) {
    LOG.info(""String_Node_Str"",targetAbsPath);
    return true;
  }
  Stopwatch remoteMaterializationStopwatch=Stopwatch.createStarted();
  boolean wasRemotelyMaterialized=serverProvider.materializeFileContents(entry,targetAbsPath);
  remoteMaterializationStopwatch.stop();
  if (wasRemotelyMaterialized) {
    fileMaterializationStatsTracker.recordRemoteFileMaterialized(remoteMaterializationStopwatch.elapsed(TimeUnit.MILLISECONDS));
    if (localFsProvider.isPresent()) {
      localFsProvider.get().writeFileAndGetInputStream(entry,targetAbsPath);
    }
    LOG.info(""String_Node_Str"",targetAbsPath);
    return true;
  }
  return false;
}","@Override public boolean materializeFileContents(BuildJobStateFileHashEntry entry,Path targetAbsPath) throws IOException {
  if (inlineProvider.materializeFileContents(entry,targetAbsPath)) {
    LOG.info(""String_Node_Str"",targetAbsPath);
    return true;
  }
  if (localFsProvider.isPresent() && localFsProvider.get().materializeFileContents(entry,targetAbsPath)) {
    fileMaterializationStatsTracker.recordLocalFileMaterialized();
    LOG.info(""String_Node_Str"",targetAbsPath);
    return true;
  }
  Stopwatch remoteMaterializationStopwatch=Stopwatch.createStarted();
  boolean wasRemotelyMaterialized=serverProvider.materializeFileContents(entry,targetAbsPath);
  remoteMaterializationStopwatch.stop();
  if (wasRemotelyMaterialized) {
    fileMaterializationStatsTracker.recordRemoteFileMaterialized(remoteMaterializationStopwatch.elapsed(TimeUnit.MILLISECONDS));
    if (localFsProvider.isPresent()) {
      localFsProvider.get().writeFileAndGetInputStream(entry,targetAbsPath);
    }
    LOG.info(""String_Node_Str"",targetAbsPath);
    return true;
  }
  return false;
}",0.9377901578458682
52933,"private void buildAllDirectoriesAndSymlinks(){
  Set<Path> deletedDirectories=new HashSet<>();
  for (  Path path : existingDirectories) {
    if (!directoriesToMake.contains(path)) {
      if (dryRun) {
        stderr(""String_Node_Str"",path);
      }
 else {
        deleteAll(path);
        deletedDirectories.add(path);
      }
    }
  }
  for (  Path path : directoriesToMake) {
    if (!existingDirectories.contains(path)) {
      immediateMkdir(path);
    }
  }
  existingSymlinks.forEach((filePath,linkPath) -> {
    if (linkPath.equals(symlinksToCreate.get(filePath))) {
      symlinksToCreate.remove(filePath);
    }
 else {
      if (dryRun) {
        stderr(""String_Node_Str"",linkPath);
      }
 else {
        try {
          Files.delete(linkPath);
        }
 catch (        IOException e) {
          if (!linkInDeletedDirectories(deletedDirectories,linkPath)) {
            stderr(""String_Node_Str"",e.getMessage(),linkPath);
          }
        }
      }
    }
  }
);
  symlinksToCreate.forEach((filePath,linkPath) -> {
    if (dryRun) {
      stderr(""String_Node_Str"",filePath,linkPath);
    }
 else {
      createSymbolicLink(filePath,linkPath);
    }
  }
);
}","private void buildAllDirectoriesAndSymlinks(){
  Set<Path> deletedDirectories=new HashSet<>();
  for (  Path path : existingDirectories) {
    if (!directoriesToMake.contains(path)) {
      if (dryRun) {
        stderr(""String_Node_Str"",path);
      }
 else {
        deleteAll(path);
        deletedDirectories.add(path);
      }
    }
  }
  existingSymlinks.forEach((filePath,linkPath) -> {
    if (linkPath.equals(symlinksToCreate.get(filePath))) {
      symlinksToCreate.remove(filePath);
    }
 else {
      if (dryRun) {
        stderr(""String_Node_Str"",linkPath);
      }
 else {
        try {
          Files.delete(linkPath);
        }
 catch (        IOException e) {
          if (!linkInDeletedDirectories(deletedDirectories,linkPath)) {
            stderr(""String_Node_Str"",e.getMessage(),linkPath);
          }
        }
      }
    }
  }
);
  symlinksToCreate.forEach((filePath,linkPath) -> {
    if (dryRun) {
      stderr(""String_Node_Str"",filePath,linkPath);
    }
 else {
      createSymbolicLink(filePath,linkPath);
    }
  }
);
}",0.9429726088908846
52934,"/** 
 * Parameter order is compatible with Ruby library code, for porting transparency 
 */
private void createSymbolicLink(Path oldPath,Path newPath){
  try {
    Files.createSymbolicLink(newPath,oldPath);
  }
 catch (  IOException e) {
    stderr(""String_Node_Str"",oldPath,newPath,e.getClass().getSimpleName(),e.getMessage());
  }
}","/** 
 * Parameter order is compatible with Ruby library code, for porting transparency 
 */
private void createSymbolicLink(Path oldPath,Path newPath){
  Path directory=newPath.getParent();
  if (directory != null && Files.notExists(directory)) {
    immediateMkdir(directory);
  }
  try {
    Files.createSymbolicLink(newPath,oldPath);
  }
 catch (  IOException e) {
    stderr(""String_Node_Str"",oldPath,newPath,e.getClass().getSimpleName(),e.getMessage());
  }
}",0.8370927318295739
52935,"@Override public BuildRule createBuildRule(TargetGraph targetGraph,BuildRuleParams params,BuildRuleResolver resolver,CellPathResolver cellRoots,AppleLibraryDescriptionArg args) throws NoSuchBuildTargetException {
  Optional<Map.Entry<Flavor,Type>> type=LIBRARY_TYPE.getFlavorAndValue(params.getBuildTarget());
  if (type.isPresent() && type.get().getValue().equals(Type.FRAMEWORK)) {
    return createFrameworkBundleBuildRule(targetGraph,params,resolver,args);
  }
 else {
    return createLibraryBuildRule(targetGraph,params,resolver,cellRoots,args,args.getLinkStyle(),Optional.empty(),ImmutableSet.of(),ImmutableSortedSet.of());
  }
}","@Override public BuildRule createBuildRule(TargetGraph targetGraph,BuildRuleParams params,BuildRuleResolver resolver,CellPathResolver cellRoots,AppleLibraryDescriptionArg args) throws NoSuchBuildTargetException {
  Optional<Map.Entry<Flavor,Type>> type=LIBRARY_TYPE.getFlavorAndValue(params.getBuildTarget());
  if (type.isPresent() && type.get().getValue().equals(Type.FRAMEWORK)) {
    return createFrameworkBundleBuildRule(targetGraph,params,resolver,args);
  }
 else {
    return createLibraryBuildRule(targetGraph,params,resolver,cellRoots,args,args.getLinkStyle(),Optional.empty(),ImmutableSet.of(),ImmutableSortedSet.of(),CxxLibraryDescription.TransitiveCxxPreprocessorInputFunction.fromLibraryRule());
  }
}",0.9415247964470762
52936,"private <A extends AppleNativeTargetDescriptionArg>BuildRule requireUnstrippedBuildRule(BuildRuleParams params,BuildRuleResolver resolver,CellPathResolver cellRoots,TargetGraph targetGraph,A args,Optional<Linker.LinkableDepType> linkableDepType,Optional<SourcePath> bundleLoader,ImmutableSet<BuildTarget> blacklist,SourcePathResolver pathResolver,ImmutableSortedSet<BuildTarget> extraCxxDeps) throws NoSuchBuildTargetException {
  Optional<MultiarchFileInfo> multiarchFileInfo=MultiarchFileInfos.create(appleCxxPlatformFlavorDomain,params.getBuildTarget());
  if (multiarchFileInfo.isPresent()) {
    ImmutableSortedSet.Builder<BuildRule> thinRules=ImmutableSortedSet.naturalOrder();
    for (    BuildTarget thinTarget : multiarchFileInfo.get().getThinTargets()) {
      thinRules.add(requireSingleArchUnstrippedBuildRule(params.withBuildTarget(thinTarget),resolver,cellRoots,targetGraph,args,linkableDepType,bundleLoader,blacklist,pathResolver,extraCxxDeps));
    }
    return MultiarchFileInfos.requireMultiarchRule(params.withBuildTarget(params.getBuildTarget().withoutFlavors(AppleDebugFormat.FLAVOR_DOMAIN.getFlavors())),resolver,multiarchFileInfo.get(),thinRules.build());
  }
 else {
    return requireSingleArchUnstrippedBuildRule(params,resolver,cellRoots,targetGraph,args,linkableDepType,bundleLoader,blacklist,pathResolver,extraCxxDeps);
  }
}","private <A extends AppleNativeTargetDescriptionArg>BuildRule requireUnstrippedBuildRule(BuildRuleParams params,BuildRuleResolver resolver,CellPathResolver cellRoots,TargetGraph targetGraph,A args,Optional<Linker.LinkableDepType> linkableDepType,Optional<SourcePath> bundleLoader,ImmutableSet<BuildTarget> blacklist,SourcePathResolver pathResolver,ImmutableSortedSet<BuildTarget> extraCxxDeps,CxxLibraryDescription.TransitiveCxxPreprocessorInputFunction transitiveCxxPreprocessorInput) throws NoSuchBuildTargetException {
  Optional<MultiarchFileInfo> multiarchFileInfo=MultiarchFileInfos.create(appleCxxPlatformFlavorDomain,params.getBuildTarget());
  if (multiarchFileInfo.isPresent()) {
    ImmutableSortedSet.Builder<BuildRule> thinRules=ImmutableSortedSet.naturalOrder();
    for (    BuildTarget thinTarget : multiarchFileInfo.get().getThinTargets()) {
      thinRules.add(requireSingleArchUnstrippedBuildRule(params.withBuildTarget(thinTarget),resolver,cellRoots,targetGraph,args,linkableDepType,bundleLoader,blacklist,pathResolver,extraCxxDeps,transitiveCxxPreprocessorInput));
    }
    return MultiarchFileInfos.requireMultiarchRule(params.withBuildTarget(params.getBuildTarget().withoutFlavors(AppleDebugFormat.FLAVOR_DOMAIN.getFlavors())),resolver,multiarchFileInfo.get(),thinRules.build());
  }
 else {
    return requireSingleArchUnstrippedBuildRule(params,resolver,cellRoots,targetGraph,args,linkableDepType,bundleLoader,blacklist,pathResolver,extraCxxDeps,transitiveCxxPreprocessorInput);
  }
}",0.9462290502793296
52937,"/** 
 * @param targetGraph The target graph.
 * @param cellRoots The roots of known cells.
 * @param bundleLoader The binary in which the current library will be (dynamically) loaded into.
 */
public <A extends AppleNativeTargetDescriptionArg>BuildRule createLibraryBuildRule(TargetGraph targetGraph,BuildRuleParams params,BuildRuleResolver resolver,CellPathResolver cellRoots,A args,Optional<Linker.LinkableDepType> linkableDepType,Optional<SourcePath> bundleLoader,ImmutableSet<BuildTarget> blacklist,ImmutableSortedSet<BuildTarget> extraCxxDeps) throws NoSuchBuildTargetException {
  Optional<StripStyle> flavoredStripStyle=StripStyle.FLAVOR_DOMAIN.getValue(params.getBuildTarget());
  params=CxxStrip.removeStripStyleFlavorInParams(params,flavoredStripStyle);
  SourcePathResolver pathResolver=new SourcePathResolver(new SourcePathRuleFinder(resolver));
  BuildRule unstrippedBinaryRule=requireUnstrippedBuildRule(params,resolver,cellRoots,targetGraph,args,linkableDepType,bundleLoader,blacklist,pathResolver,extraCxxDeps);
  if (!shouldWrapIntoDebuggableBinary(params.getBuildTarget(),unstrippedBinaryRule)) {
    return unstrippedBinaryRule;
  }
  CxxPlatform representativePlatform=delegate.getCxxPlatforms().getValue(Iterables.getFirst(Sets.intersection(delegate.getCxxPlatforms().getFlavors(),params.getBuildTarget().getFlavors()),defaultCxxPlatform.getFlavor()));
  params=CxxStrip.restoreStripStyleFlavorInParams(params,flavoredStripStyle);
  BuildRule strippedBinaryRule=CxxDescriptionEnhancer.createCxxStripRule(params,resolver,flavoredStripStyle.orElse(StripStyle.NON_GLOBAL_SYMBOLS),unstrippedBinaryRule,representativePlatform);
  return AppleDescriptions.createAppleDebuggableBinary(params,resolver,strippedBinaryRule,(ProvidesLinkedBinaryDeps)unstrippedBinaryRule,AppleDebugFormat.FLAVOR_DOMAIN.getValue(params.getBuildTarget()).orElse(appleConfig.getDefaultDebugInfoFormatForLibraries()),delegate.getCxxPlatforms(),delegate.getDefaultCxxPlatform(),appleCxxPlatformFlavorDomain);
}","/** 
 * @param targetGraph The target graph.
 * @param cellRoots The roots of known cells.
 * @param bundleLoader The binary in which the current library will be (dynamically) loaded into.
 */
public <A extends AppleNativeTargetDescriptionArg>BuildRule createLibraryBuildRule(TargetGraph targetGraph,BuildRuleParams params,BuildRuleResolver resolver,CellPathResolver cellRoots,A args,Optional<Linker.LinkableDepType> linkableDepType,Optional<SourcePath> bundleLoader,ImmutableSet<BuildTarget> blacklist,ImmutableSortedSet<BuildTarget> extraCxxDeps,CxxLibraryDescription.TransitiveCxxPreprocessorInputFunction transitiveCxxPreprocessorInput) throws NoSuchBuildTargetException {
  Optional<StripStyle> flavoredStripStyle=StripStyle.FLAVOR_DOMAIN.getValue(params.getBuildTarget());
  params=CxxStrip.removeStripStyleFlavorInParams(params,flavoredStripStyle);
  SourcePathResolver pathResolver=new SourcePathResolver(new SourcePathRuleFinder(resolver));
  BuildRule unstrippedBinaryRule=requireUnstrippedBuildRule(params,resolver,cellRoots,targetGraph,args,linkableDepType,bundleLoader,blacklist,pathResolver,extraCxxDeps,transitiveCxxPreprocessorInput);
  if (!shouldWrapIntoDebuggableBinary(params.getBuildTarget(),unstrippedBinaryRule)) {
    return unstrippedBinaryRule;
  }
  CxxPlatform representativePlatform=delegate.getCxxPlatforms().getValue(Iterables.getFirst(Sets.intersection(delegate.getCxxPlatforms().getFlavors(),params.getBuildTarget().getFlavors()),defaultCxxPlatform.getFlavor()));
  params=CxxStrip.restoreStripStyleFlavorInParams(params,flavoredStripStyle);
  BuildRule strippedBinaryRule=CxxDescriptionEnhancer.createCxxStripRule(params,resolver,flavoredStripStyle.orElse(StripStyle.NON_GLOBAL_SYMBOLS),unstrippedBinaryRule,representativePlatform);
  return AppleDescriptions.createAppleDebuggableBinary(params,resolver,strippedBinaryRule,(ProvidesLinkedBinaryDeps)unstrippedBinaryRule,AppleDebugFormat.FLAVOR_DOMAIN.getValue(params.getBuildTarget()).orElse(appleConfig.getDefaultDebugInfoFormatForLibraries()),delegate.getCxxPlatforms(),delegate.getDefaultCxxPlatform(),appleCxxPlatformFlavorDomain);
}",0.9701383831026948
52938,"private <A extends AppleNativeTargetDescriptionArg>BuildRule requireSingleArchUnstrippedBuildRule(BuildRuleParams params,BuildRuleResolver resolver,CellPathResolver cellRoots,TargetGraph targetGraph,A args,Optional<Linker.LinkableDepType> linkableDepType,Optional<SourcePath> bundleLoader,ImmutableSet<BuildTarget> blacklist,SourcePathResolver pathResolver,ImmutableSortedSet<BuildTarget> extraCxxDeps) throws NoSuchBuildTargetException {
  CxxLibraryDescriptionArg.Builder delegateArg=CxxLibraryDescriptionArg.builder().from(args);
  AppleDescriptions.populateCxxLibraryDescriptionArg(pathResolver,delegateArg,args,params.getBuildTarget());
  Optional<BuildRule> swiftCompanionBuildRule=swiftDelegate.createCompanionBuildRule(targetGraph,params,resolver,cellRoots,args);
  if (swiftCompanionBuildRule.isPresent()) {
    if (isSwiftTarget(params.getBuildTarget())) {
      return swiftCompanionBuildRule.get();
    }
 else {
      delegateArg.addExportedDeps(swiftCompanionBuildRule.get().getBuildTarget());
      params=params.copyAppendingExtraDeps(ImmutableSet.of(swiftCompanionBuildRule.get()));
    }
  }
  BuildTarget unstrippedTarget=params.getBuildTarget().withoutFlavors(AppleDebugFormat.FLAVOR_DOMAIN.getFlavors());
  if (AppleDescriptions.flavorsDoNotAllowLinkerMapMode(params)) {
    unstrippedTarget=unstrippedTarget.withoutFlavors(LinkerMapMode.NO_LINKER_MAP.getFlavor());
  }
  Optional<BuildRule> existingRule=resolver.getRuleOptional(unstrippedTarget);
  if (existingRule.isPresent()) {
    return existingRule.get();
  }
 else {
    BuildRule rule=delegate.createBuildRule(params.withBuildTarget(unstrippedTarget),resolver,cellRoots,delegateArg.build(),linkableDepType,bundleLoader,blacklist,extraCxxDeps);
    return resolver.addToIndex(rule);
  }
}","private <A extends AppleNativeTargetDescriptionArg>BuildRule requireSingleArchUnstrippedBuildRule(BuildRuleParams params,BuildRuleResolver resolver,CellPathResolver cellRoots,TargetGraph targetGraph,A args,Optional<Linker.LinkableDepType> linkableDepType,Optional<SourcePath> bundleLoader,ImmutableSet<BuildTarget> blacklist,SourcePathResolver pathResolver,ImmutableSortedSet<BuildTarget> extraCxxDeps,CxxLibraryDescription.TransitiveCxxPreprocessorInputFunction transitiveCxxDeps) throws NoSuchBuildTargetException {
  CxxLibraryDescriptionArg.Builder delegateArg=CxxLibraryDescriptionArg.builder().from(args);
  AppleDescriptions.populateCxxLibraryDescriptionArg(pathResolver,delegateArg,args,params.getBuildTarget());
  Optional<BuildRule> swiftCompanionBuildRule=swiftDelegate.createCompanionBuildRule(targetGraph,params,resolver,cellRoots,args);
  if (swiftCompanionBuildRule.isPresent()) {
    if (isSwiftTarget(params.getBuildTarget())) {
      return swiftCompanionBuildRule.get();
    }
 else {
      delegateArg.addExportedDeps(swiftCompanionBuildRule.get().getBuildTarget());
      params=params.copyAppendingExtraDeps(ImmutableSet.of(swiftCompanionBuildRule.get()));
    }
  }
  BuildTarget unstrippedTarget=params.getBuildTarget().withoutFlavors(AppleDebugFormat.FLAVOR_DOMAIN.getFlavors());
  if (AppleDescriptions.flavorsDoNotAllowLinkerMapMode(params)) {
    unstrippedTarget=unstrippedTarget.withoutFlavors(LinkerMapMode.NO_LINKER_MAP.getFlavor());
  }
  Optional<BuildRule> existingRule=resolver.getRuleOptional(unstrippedTarget);
  if (existingRule.isPresent()) {
    return existingRule.get();
  }
 else {
    BuildRule rule=delegate.createBuildRule(params.withBuildTarget(unstrippedTarget),resolver,cellRoots,delegateArg.build(),linkableDepType,bundleLoader,blacklist,extraCxxDeps,transitiveCxxDeps);
    return resolver.addToIndex(rule);
  }
}",0.9733003027800716
52939,"private BuildRule createTestLibraryRule(TargetGraph targetGraph,BuildRuleParams params,BuildRuleResolver resolver,CellPathResolver cellRoots,AppleTestDescriptionArg args,Optional<SourcePath> testHostAppBinarySourcePath,ImmutableSet<BuildTarget> blacklist,BuildTarget libraryTarget,ImmutableSortedSet<BuildTarget> extraCxxDeps) throws NoSuchBuildTargetException {
  BuildTarget existingLibraryTarget=libraryTarget.withAppendedFlavors(AppleDebuggableBinary.RULE_FLAVOR,CxxStrip.RULE_FLAVOR).withAppendedFlavors(StripStyle.NON_GLOBAL_SYMBOLS.getFlavor());
  Optional<BuildRule> existingLibrary=resolver.getRuleOptional(existingLibraryTarget);
  BuildRule library;
  if (existingLibrary.isPresent()) {
    library=existingLibrary.get();
  }
 else {
    library=appleLibraryDescription.createLibraryBuildRule(targetGraph,params.withBuildTarget(libraryTarget),resolver,cellRoots,args,Optional.of(Linker.LinkableDepType.STATIC),testHostAppBinarySourcePath,blacklist,extraCxxDeps);
    resolver.addToIndex(library);
  }
  return library;
}","private BuildRule createTestLibraryRule(TargetGraph targetGraph,BuildRuleParams params,BuildRuleResolver resolver,CellPathResolver cellRoots,AppleTestDescriptionArg args,Optional<SourcePath> testHostAppBinarySourcePath,ImmutableSet<BuildTarget> blacklist,BuildTarget libraryTarget,ImmutableSortedSet<BuildTarget> extraCxxDeps) throws NoSuchBuildTargetException {
  BuildTarget existingLibraryTarget=libraryTarget.withAppendedFlavors(AppleDebuggableBinary.RULE_FLAVOR,CxxStrip.RULE_FLAVOR).withAppendedFlavors(StripStyle.NON_GLOBAL_SYMBOLS.getFlavor());
  Optional<BuildRule> existingLibrary=resolver.getRuleOptional(existingLibraryTarget);
  BuildRule library;
  if (existingLibrary.isPresent()) {
    library=existingLibrary.get();
  }
 else {
    library=appleLibraryDescription.createLibraryBuildRule(targetGraph,params.withBuildTarget(libraryTarget),resolver,cellRoots,args,Optional.of(Linker.LinkableDepType.STATIC),testHostAppBinarySourcePath,blacklist,extraCxxDeps,CxxLibraryDescription.TransitiveCxxPreprocessorInputFunction.fromDeps());
    resolver.addToIndex(library);
  }
  return library;
}",0.9662605435801312
52940,"private ImmutableList<CxxPreprocessorInput> computePreprocessorInputForCxxLibraryDescriptionArg(BuildRuleParams params,CxxPlatform cxxPlatform,CxxLibraryDescription.CommonArg args,HeaderSymlinkTree headerSymlinkTree,ImmutableList<String> includeDirs,Optional<SymlinkTree> sandboxTree) throws NoSuchBuildTargetException {
  ImmutableSet<BuildRule> deps=args.getCxxDeps().get(ruleResolver,cxxPlatform);
  return CxxDescriptionEnhancer.collectCxxPreprocessorInput(params,cxxPlatform,deps,CxxFlags.getLanguageFlags(args.getPreprocessorFlags(),args.getPlatformPreprocessorFlags(),args.getLangPreprocessorFlags(),cxxPlatform),ImmutableList.of(headerSymlinkTree),ImmutableSet.of(),CxxLibraryDescription.getTransitiveCxxPreprocessorInput(params,ruleResolver,cxxPlatform,deps),includeDirs,sandboxTree);
}","private ImmutableList<CxxPreprocessorInput> computePreprocessorInputForCxxLibraryDescriptionArg(BuildRuleParams params,CxxPlatform cxxPlatform,CxxLibraryDescription.CommonArg args,HeaderSymlinkTree headerSymlinkTree,ImmutableList<String> includeDirs,Optional<SymlinkTree> sandboxTree) throws NoSuchBuildTargetException {
  ImmutableSet<BuildRule> deps=args.getCxxDeps().get(ruleResolver,cxxPlatform);
  return CxxDescriptionEnhancer.collectCxxPreprocessorInput(params,cxxPlatform,deps,CxxFlags.getLanguageFlags(args.getPreprocessorFlags(),args.getPlatformPreprocessorFlags(),args.getLangPreprocessorFlags(),cxxPlatform),ImmutableList.of(headerSymlinkTree),ImmutableSet.of(),CxxLibraryDescription.TransitiveCxxPreprocessorInputFunction.fromLibraryRule().apply(params.getBuildTarget(),ruleResolver,cxxPlatform,deps),includeDirs,sandboxTree);
}",0.9596577017114916
52941,"private List<String> buildDotIdeaDotLibrariesFolder(String dotIdea,List<String> inputs){
  String libraries=fileJoin(dotIdea,""String_Node_Str"");
  mkdir(libraries);
  Map<String,List<String>> directories=new HashMap<>();
  inputs.stream().filter((input) -> input.endsWith(""String_Node_Str"")).forEach(jar -> {
    String dirname=dirname(jar);
    String basename=basename(jar);
    List<String> basenames=directories.get(dirname);
    if (basenames == null) {
      basenames=new ArrayList<>();
      directories.put(dirname,basenames);
    }
    basenames.add(basename);
  }
);
  List<String> libraryXmls=new ArrayList<>();
  for (  Map.Entry<String,List<String>> entry : directories.entrySet()) {
    libraryXmls.add(buildLibraryFile(libraries,entry.getKey(),entry.getValue()));
  }
  return libraryXmls;
}","private List<String> buildDotIdeaDotLibrariesFolder(String dotIdea,List<String> inputs){
  String libraries=fileJoin(dotIdea,""String_Node_Str"");
  immediateMkdir(libraries);
  Map<String,List<String>> directories=new HashMap<>();
  inputs.stream().filter((input) -> input.endsWith(""String_Node_Str"")).forEach(jar -> {
    String dirname=dirname(jar);
    String basename=basename(jar);
    List<String> basenames=directories.get(dirname);
    if (basenames == null) {
      basenames=new ArrayList<>();
      directories.put(dirname,basenames);
    }
    basenames.add(basename);
  }
);
  List<String> libraryXmls=new ArrayList<>();
  for (  Map.Entry<String,List<String>> entry : directories.entrySet()) {
    libraryXmls.add(buildLibraryFile(libraries,entry.getKey(),entry.getValue()));
  }
  return libraryXmls;
}",0.993222427603204
52942,"private void buildAllDirectoriesAndSymlinks(){
  Set<Path> deletedDirectories=new HashSet<>();
  for (  Path path : existingDirectories) {
    if (!directoriesToMake.contains(path)) {
      if (dryRun) {
        stderr(""String_Node_Str"",path);
      }
 else {
        deleteAll(path);
        deletedDirectories.add(path);
      }
    }
  }
  for (  Path path : directoriesToMake) {
    if (!existingDirectories.contains(path)) {
      if (dryRun) {
        stderr(""String_Node_Str"",path);
      }
 else {
        try {
          Files.createDirectories(path);
        }
 catch (        IOException e) {
          stderr(""String_Node_Str"",e.getMessage(),path);
        }
      }
    }
  }
  existingSymlinks.forEach((filePath,linkPath) -> {
    if (linkPath.equals(symlinksToCreate.get(filePath))) {
      symlinksToCreate.remove(filePath);
    }
 else {
      if (dryRun) {
        stderr(""String_Node_Str"",linkPath);
      }
 else {
        try {
          Files.delete(linkPath);
        }
 catch (        IOException e) {
          if (!linkInDeletedDirectories(deletedDirectories,linkPath)) {
            stderr(""String_Node_Str"",e.getMessage(),linkPath);
          }
        }
      }
    }
  }
);
  symlinksToCreate.forEach((filePath,linkPath) -> {
    if (dryRun) {
      stderr(""String_Node_Str"",filePath,linkPath);
    }
 else {
      createSymbolicLink(filePath,linkPath);
    }
  }
);
}","private void buildAllDirectoriesAndSymlinks(){
  Set<Path> deletedDirectories=new HashSet<>();
  for (  Path path : existingDirectories) {
    if (!directoriesToMake.contains(path)) {
      if (dryRun) {
        stderr(""String_Node_Str"",path);
      }
 else {
        deleteAll(path);
        deletedDirectories.add(path);
      }
    }
  }
  for (  Path path : directoriesToMake) {
    if (!existingDirectories.contains(path)) {
      immediateMkdir(path);
    }
  }
  existingSymlinks.forEach((filePath,linkPath) -> {
    if (linkPath.equals(symlinksToCreate.get(filePath))) {
      symlinksToCreate.remove(filePath);
    }
 else {
      if (dryRun) {
        stderr(""String_Node_Str"",linkPath);
      }
 else {
        try {
          Files.delete(linkPath);
        }
 catch (        IOException e) {
          if (!linkInDeletedDirectories(deletedDirectories,linkPath)) {
            stderr(""String_Node_Str"",e.getMessage(),linkPath);
          }
        }
      }
    }
  }
);
  symlinksToCreate.forEach((filePath,linkPath) -> {
    if (dryRun) {
      stderr(""String_Node_Str"",filePath,linkPath);
    }
 else {
      createSymbolicLink(filePath,linkPath);
    }
  }
);
}",0.6345631067961165
52943,"private List<String> buildDotIdeaFolder(List<String> inputs){
  String dotIdea=fileJoin(viewPath,DOT_IDEA);
  mkdir(dotIdea);
  writeModulesXml(dotIdea);
  writeMiscXml(dotIdea);
  symlink(fileJoin(repository,DOT_IDEA,CODE_STYLE_SETTINGS),fileJoin(dotIdea,CODE_STYLE_SETTINGS));
  return buildDotIdeaDotLibrariesFolder(dotIdea,inputs);
}","private List<String> buildDotIdeaFolder(List<String> inputs){
  String dotIdea=fileJoin(viewPath,DOT_IDEA);
  immediateMkdir(dotIdea);
  writeModulesXml(dotIdea);
  writeMiscXml(dotIdea);
  symlink(fileJoin(repository,DOT_IDEA,CODE_STYLE_SETTINGS),fileJoin(dotIdea,CODE_STYLE_SETTINGS));
  return buildDotIdeaDotLibrariesFolder(dotIdea,inputs);
}",0.9838945827232796
52944,"private Map<BuildTarget,String> getOutputs(){
  Map<BuildTarget,String> outputs=new HashMap<>();
  ActionGraphAndResolver actionGraph=ActionGraphCache.getFreshActionGraph(eventBus,targetGraph);
  BuildRuleResolver ruleResolver=actionGraph.getResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(new SourcePathRuleFinder(ruleResolver));
  for (  BuildTarget target : buildTargets) {
    BuildRule rule=ruleResolver.getRule(target);
    Path outputPath=pathResolver.getRelativePath(rule.getSourcePathToOutput());
    outputs.put(target,outputPath.toString());
  }
  return outputs;
}","private Map<BuildTarget,String> getOutputs(){
  Map<BuildTarget,String> outputs=new HashMap<>(buildTargets.size());
  ActionGraphAndResolver actionGraph=ActionGraphCache.getFreshActionGraph(eventBus,targetGraph);
  BuildRuleResolver ruleResolver=actionGraph.getResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(new SourcePathRuleFinder(ruleResolver));
  for (  BuildTarget target : buildTargets) {
    BuildRule rule=ruleResolver.getRule(target);
    SourcePath sourcePathToOutput=rule.getSourcePathToOutput();
    if (sourcePathToOutput == null) {
      continue;
    }
    Path outputPath=pathResolver.getRelativePath(sourcePathToOutput);
    outputs.put(target,outputPath.toString());
  }
  return outputs;
}",0.7430293896006028
52945,"@Override public int buildWithClasspath(JavacExecutionContext context,BuildTarget invokingRule,ImmutableList<String> options,ImmutableList<ResolvedJavacPluginProperties> annotationProcessors,ImmutableSortedSet<Path> javaSourceFilePaths,Path pathToSrcsList,Optional<Path> workingDirectory,CompilationMode compilationMode) throws InterruptedException {
  Preconditions.checkArgument(compilationMode == CompilationMode.FULL,""String_Node_Str"");
  ImmutableList.Builder<String> command=ImmutableList.builder();
  command.add(pathToJavac.isLeft() ? pathToJavac.getLeft().toString() : context.getAbsolutePathsForInputs().get(0).toString());
  command.addAll(options);
  ImmutableList<Path> expandedSources;
  try {
    expandedSources=getExpandedSourcePaths(context.getProjectFilesystem(),invokingRule,javaSourceFilePaths,workingDirectory);
  }
 catch (  IOException e) {
    throw new HumanReadableException(""String_Node_Str"",invokingRule,workingDirectory);
  }
  try {
    context.getProjectFilesystem().writeLinesToPath(FluentIterable.from(expandedSources).transform(Object::toString).transform(ARGFILES_ESCAPER),pathToSrcsList);
    command.add(""String_Node_Str"" + pathToSrcsList);
  }
 catch (  IOException e) {
    context.getEventSink().reportThrowable(e,""String_Node_Str"",pathToSrcsList);
    return 1;
  }
  int exitCode=-1;
  try {
    ProcessExecutorParams params=ProcessExecutorParams.builder().setCommand(command.build()).setEnvironment(context.getEnvironment()).setDirectory(context.getProjectFilesystem().getRootPath().toAbsolutePath()).build();
    ProcessExecutor.Result result=context.getProcessExecutor().launchAndExecute(params);
    exitCode=result.getExitCode();
  }
 catch (  IOException e) {
    e.printStackTrace(context.getStdErr());
    return exitCode;
  }
  return exitCode;
}","@Override public int buildWithClasspath(JavacExecutionContext context,BuildTarget invokingRule,ImmutableList<String> options,ImmutableList<ResolvedJavacPluginProperties> annotationProcessors,ImmutableSortedSet<Path> javaSourceFilePaths,Path pathToArgsList,Optional<Path> workingDirectory,CompilationMode compilationMode) throws InterruptedException {
  Preconditions.checkArgument(compilationMode == CompilationMode.FULL,""String_Node_Str"");
  ImmutableList.Builder<String> command=ImmutableList.builder();
  command.add(pathToJavac.isLeft() ? pathToJavac.getLeft().toString() : context.getAbsolutePathsForInputs().get(0).toString());
  ImmutableList<Path> expandedSources;
  try {
    expandedSources=getExpandedSourcePaths(context.getProjectFilesystem(),invokingRule,javaSourceFilePaths,workingDirectory);
  }
 catch (  IOException e) {
    throw new HumanReadableException(""String_Node_Str"",invokingRule,workingDirectory);
  }
  try {
    FluentIterable<String> escapedPaths=FluentIterable.from(expandedSources).transform(Object::toString).transform(ARGFILES_ESCAPER);
    FluentIterable<String> escapedArgs=FluentIterable.from(options).transform(ARGFILES_ESCAPER);
    context.getProjectFilesystem().writeLinesToPath(Iterables.concat(escapedArgs,escapedPaths),pathToArgsList);
    command.add(""String_Node_Str"" + pathToArgsList);
  }
 catch (  IOException e) {
    context.getEventSink().reportThrowable(e,""String_Node_Str"",pathToArgsList);
    return 1;
  }
  int exitCode=-1;
  try {
    ProcessExecutorParams params=ProcessExecutorParams.builder().setCommand(command.build()).setEnvironment(context.getEnvironment()).setDirectory(context.getProjectFilesystem().getRootPath().toAbsolutePath()).build();
    ProcessExecutor.Result result=context.getProcessExecutor().launchAndExecute(params);
    exitCode=result.getExitCode();
  }
 catch (  IOException e) {
    e.printStackTrace(context.getStdErr());
    return exitCode;
  }
  return exitCode;
}",0.9130666666666668
52946,"private void updateAndStoreManifest(BuildRule rule,RuleKey key,ImmutableSet<SourcePath> inputs,RuleKeyAndInputs manifestKey,ArtifactCache cache) throws IOException {
  Preconditions.checkState(useManifestCaching(rule));
  final Path manifestPath=getManifestPath(rule);
  Manifest manifest=new Manifest();
  if (rule.getProjectFilesystem().exists(manifestPath)) {
    try (InputStream inputStream=rule.getProjectFilesystem().newFileInputStream(manifestPath)){
      manifest=new Manifest(inputStream);
    }
   }
 else {
    rule.getProjectFilesystem().createParentDirs(manifestPath);
  }
  if (manifest.size() >= maxDepFileCacheEntries) {
    manifest=new Manifest();
  }
  manifest.addEntry(fileHashCache,key,pathResolver,manifestKey.getInputs(),inputs);
  try (OutputStream outputStream=rule.getProjectFilesystem().newFileOutputStream(manifestPath)){
    manifest.serialize(outputStream);
  }
   final Path tempFile=Files.createTempFile(""String_Node_Str"",""String_Node_Str"");
  try (InputStream inputStream=rule.getProjectFilesystem().newFileInputStream(manifestPath);OutputStream outputStream=new GZIPOutputStream(new BufferedOutputStream(Files.newOutputStream(tempFile)))){
    ByteStreams.copy(inputStream,outputStream);
  }
   cache.store(ArtifactInfo.builder().addRuleKeys(manifestKey.getRuleKey()).build(),BorrowablePath.borrowablePath(tempFile)).addListener(() -> {
    try {
      Files.deleteIfExists(tempFile);
    }
 catch (    IOException e) {
      LOG.warn(e,""String_Node_Str"",manifestPath);
    }
  }
,MoreExecutors.directExecutor());
}","private void updateAndStoreManifest(BuildRule rule,RuleKey key,ImmutableSet<SourcePath> inputs,RuleKeyAndInputs manifestKey,ArtifactCache cache) throws IOException {
  Preconditions.checkState(useManifestCaching(rule));
  final Path manifestPath=getManifestPath(rule);
  Manifest manifest=new Manifest(manifestKey.getRuleKey());
  if (rule.getProjectFilesystem().exists(manifestPath)) {
    try (InputStream inputStream=rule.getProjectFilesystem().newFileInputStream(manifestPath)){
      Manifest existingManifest=new Manifest(inputStream);
      if (existingManifest.getKey().equals(manifestKey.getRuleKey())) {
        manifest=existingManifest;
      }
    }
   }
 else {
    rule.getProjectFilesystem().createParentDirs(manifestPath);
  }
  if (manifest.size() >= maxDepFileCacheEntries) {
    manifest=new Manifest(manifestKey.getRuleKey());
  }
  manifest.addEntry(fileHashCache,key,pathResolver,manifestKey.getInputs(),inputs);
  try (OutputStream outputStream=rule.getProjectFilesystem().newFileOutputStream(manifestPath)){
    manifest.serialize(outputStream);
  }
   final Path tempFile=Files.createTempFile(""String_Node_Str"",""String_Node_Str"");
  try (InputStream inputStream=rule.getProjectFilesystem().newFileInputStream(manifestPath);OutputStream outputStream=new GZIPOutputStream(new BufferedOutputStream(Files.newOutputStream(tempFile)))){
    ByteStreams.copy(inputStream,outputStream);
  }
   cache.store(ArtifactInfo.builder().addRuleKeys(manifestKey.getRuleKey()).build(),BorrowablePath.borrowablePath(tempFile)).addListener(() -> {
    try {
      Files.deleteIfExists(tempFile);
    }
 catch (    IOException e) {
      LOG.warn(e,""String_Node_Str"",manifestPath);
    }
  }
,MoreExecutors.directExecutor());
}",0.9445797807551766
52947,"private Optional<BuildResult> performManifestBasedCacheFetch(final BuildRule rule,final BuildEngineBuildContext context,BuildInfoRecorder buildInfoRecorder,RuleKeyAndInputs manifestKey) throws IOException {
  Preconditions.checkArgument(useManifestCaching(rule));
  final LazyPath tempFile=new LazyPath(){
    @Override protected Path create() throws IOException {
      return Files.createTempFile(""String_Node_Str"",""String_Node_Str"");
    }
  }
;
  CacheResult manifestResult=fetchArtifactForBuildable(manifestKey.getRuleKey(),tempFile,context.getArtifactCache());
  if (!manifestResult.getType().isSuccess()) {
    return Optional.empty();
  }
  Path manifestPath=getManifestPath(rule);
  rule.getProjectFilesystem().deleteFileAtPathIfExists(manifestPath);
  rule.getProjectFilesystem().createParentDirs(manifestPath);
  try (OutputStream outputStream=rule.getProjectFilesystem().newFileOutputStream(manifestPath);InputStream inputStream=new GZIPInputStream(new BufferedInputStream(Files.newInputStream(tempFile.get())))){
    ByteStreams.copy(inputStream,outputStream);
  }
   Files.delete(tempFile.get());
  Manifest manifest;
  try (InputStream input=rule.getProjectFilesystem().newFileInputStream(manifestPath)){
    manifest=new Manifest(input);
  }
   Optional<RuleKey> ruleKey=manifest.lookup(fileHashCache,pathResolver,manifestKey.getInputs());
  if (!ruleKey.isPresent()) {
    return Optional.empty();
  }
  CacheResult cacheResult=tryToFetchArtifactFromBuildCacheAndOverlayOnTopOfProjectFilesystem(rule,ruleKey.get(),context.getArtifactCache(),rule.getProjectFilesystem(),context);
  if (cacheResult.getType().isSuccess()) {
    fillMissingBuildMetadataFromCache(cacheResult,buildInfoRecorder,BuildInfo.MetadataKey.ORIGIN_BUILD_ID,BuildInfo.MetadataKey.DEP_FILE_RULE_KEY,BuildInfo.MetadataKey.DEP_FILE);
    return Optional.of(BuildResult.success(rule,BuildRuleSuccessType.FETCHED_FROM_CACHE_MANIFEST_BASED,cacheResult));
  }
  return Optional.empty();
}","private Optional<BuildResult> performManifestBasedCacheFetch(final BuildRule rule,final BuildEngineBuildContext context,BuildInfoRecorder buildInfoRecorder,RuleKeyAndInputs manifestKey) throws IOException {
  Preconditions.checkArgument(useManifestCaching(rule));
  final LazyPath tempFile=new LazyPath(){
    @Override protected Path create() throws IOException {
      return Files.createTempFile(""String_Node_Str"",""String_Node_Str"");
    }
  }
;
  CacheResult manifestResult=fetchArtifactForBuildable(manifestKey.getRuleKey(),tempFile,context.getArtifactCache());
  if (!manifestResult.getType().isSuccess()) {
    return Optional.empty();
  }
  Path manifestPath=getManifestPath(rule);
  rule.getProjectFilesystem().deleteFileAtPathIfExists(manifestPath);
  rule.getProjectFilesystem().createParentDirs(manifestPath);
  try (OutputStream outputStream=rule.getProjectFilesystem().newFileOutputStream(manifestPath);InputStream inputStream=new GZIPInputStream(new BufferedInputStream(Files.newInputStream(tempFile.get())))){
    ByteStreams.copy(inputStream,outputStream);
  }
   Files.delete(tempFile.get());
  Manifest manifest;
  try (InputStream input=rule.getProjectFilesystem().newFileInputStream(manifestPath)){
    manifest=new Manifest(input);
  }
   Preconditions.checkState(manifest.getKey().equals(manifestKey.getRuleKey()),""String_Node_Str"",rule.getBuildTarget(),manifestKey.getRuleKey(),manifest.getKey());
  Optional<RuleKey> ruleKey=manifest.lookup(fileHashCache,pathResolver,manifestKey.getInputs());
  if (!ruleKey.isPresent()) {
    return Optional.empty();
  }
  CacheResult cacheResult=tryToFetchArtifactFromBuildCacheAndOverlayOnTopOfProjectFilesystem(rule,ruleKey.get(),context.getArtifactCache(),rule.getProjectFilesystem(),context);
  if (cacheResult.getType().isSuccess()) {
    fillMissingBuildMetadataFromCache(cacheResult,buildInfoRecorder,BuildInfo.MetadataKey.ORIGIN_BUILD_ID,BuildInfo.MetadataKey.DEP_FILE_RULE_KEY,BuildInfo.MetadataKey.DEP_FILE);
    return Optional.of(BuildResult.success(rule,BuildRuleSuccessType.FETCHED_FROM_CACHE_MANIFEST_BASED,cacheResult));
  }
  return Optional.empty();
}",0.9602342034642596
52948,"@VisibleForTesting static Manifest fromMap(ImmutableMap<RuleKey,ImmutableMap<String,HashCode>> map){
  Manifest manifest=new Manifest();
  for (  Map.Entry<RuleKey,ImmutableMap<String,HashCode>> entry : map.entrySet()) {
    int entryHashIndex=0;
    int[] entryHashIndices=new int[entry.getValue().size()];
    for (    Map.Entry<String,HashCode> innerEntry : entry.getValue().entrySet()) {
      entryHashIndices[entryHashIndex++]=manifest.addHash(innerEntry.getKey(),innerEntry.getValue());
    }
    manifest.entries.add(new Pair<>(entry.getKey(),entryHashIndices));
  }
  return manifest;
}","@VisibleForTesting static Manifest fromMap(RuleKey key,ImmutableMap<RuleKey,ImmutableMap<String,HashCode>> map){
  Manifest manifest=new Manifest(key);
  for (  Map.Entry<RuleKey,ImmutableMap<String,HashCode>> entry : map.entrySet()) {
    int entryHashIndex=0;
    int[] entryHashIndices=new int[entry.getValue().size()];
    for (    Map.Entry<String,HashCode> innerEntry : entry.getValue().entrySet()) {
      entryHashIndices[entryHashIndex++]=manifest.addHash(innerEntry.getKey(),innerEntry.getValue());
    }
    manifest.entries.add(new Pair<>(entry.getKey(),entryHashIndices));
  }
  return manifest;
}",0.9875518672199172
52949,"/** 
 * Deserialize an existing manifest from the given   {@link InputStream}.
 */
public Manifest(InputStream rawInput) throws IOException {
  DataInputStream input=new DataInputStream(rawInput);
  Preconditions.checkState(input.readInt() == VERSION);
  int numberOfHeaders=input.readInt();
  headers=new ArrayList<>(numberOfHeaders);
  headerIndices=new HashMap<>(numberOfHeaders);
  for (int index=0; index < numberOfHeaders; index++) {
    String header=input.readUTF();
    headers.add(header);
    headerIndices.put(header,index);
  }
  int numberOfHashes=input.readInt();
  hashes=new ArrayList<>(numberOfHashes);
  hashIndices=new HashMap<>(numberOfHashes);
  for (int index=0; index < numberOfHashes; index++) {
    int headerIndex=input.readInt();
    HashCode headerHash=HashCode.fromString(input.readUTF());
    hashes.add(new Pair<>(headerIndex,headerHash));
    hashIndices.put(headerHash,index);
  }
  int numberOfEntries=input.readInt();
  entries=new ArrayList<>(numberOfEntries);
  for (int entryIndex=0; entryIndex < numberOfEntries; entryIndex++) {
    int numberOfEntryHashes=input.readInt();
    int[] entryHashes=new int[numberOfEntryHashes];
    for (int hashIndex=0; hashIndex < numberOfEntryHashes; hashIndex++) {
      entryHashes[hashIndex]=input.readInt();
    }
    RuleKey key=new RuleKey(input.readUTF());
    entries.add(new Pair<>(key,entryHashes));
  }
}","/** 
 * Deserialize an existing manifest from the given   {@link InputStream}.
 */
public Manifest(InputStream rawInput) throws IOException {
  DataInputStream input=new DataInputStream(rawInput);
  int version=input.readInt();
  Preconditions.checkState(version == VERSION,""String_Node_Str"",version,VERSION);
  key=new RuleKey(input.readUTF());
  int numberOfHeaders=input.readInt();
  headers=new ArrayList<>(numberOfHeaders);
  headerIndices=new HashMap<>(numberOfHeaders);
  for (int index=0; index < numberOfHeaders; index++) {
    String header=input.readUTF();
    headers.add(header);
    headerIndices.put(header,index);
  }
  int numberOfHashes=input.readInt();
  hashes=new ArrayList<>(numberOfHashes);
  hashIndices=new HashMap<>(numberOfHashes);
  for (int index=0; index < numberOfHashes; index++) {
    int headerIndex=input.readInt();
    HashCode headerHash=HashCode.fromString(input.readUTF());
    hashes.add(new Pair<>(headerIndex,headerHash));
    hashIndices.put(headerHash,index);
  }
  int numberOfEntries=input.readInt();
  entries=new ArrayList<>(numberOfEntries);
  for (int entryIndex=0; entryIndex < numberOfEntries; entryIndex++) {
    int numberOfEntryHashes=input.readInt();
    int[] entryHashes=new int[numberOfEntryHashes];
    for (int hashIndex=0; hashIndex < numberOfEntryHashes; hashIndex++) {
      entryHashes[hashIndex]=input.readInt();
    }
    RuleKey key=new RuleKey(input.readUTF());
    entries.add(new Pair<>(key,entryHashes));
  }
}",0.3838383838383838
52950,"/** 
 * Serializes the manifest to the given   {@link OutputStream}.
 */
public void serialize(OutputStream rawOutput) throws IOException {
  DataOutputStream output=new DataOutputStream(rawOutput);
  output.writeInt(VERSION);
  output.writeInt(headers.size());
  for (  String header : headers) {
    output.writeUTF(header);
  }
  output.writeInt(hashes.size());
  for (  Pair<Integer,HashCode> hash : hashes) {
    output.writeInt(hash.getFirst());
    output.writeUTF(hash.getSecond().toString());
  }
  output.writeInt(entries.size());
  for (  Pair<RuleKey,int[]> entry : entries) {
    output.writeInt(entry.getSecond().length);
    for (    int hashIndex : entry.getSecond()) {
      output.writeInt(hashIndex);
    }
    output.writeUTF(entry.getFirst().toString());
  }
}","/** 
 * Serializes the manifest to the given   {@link OutputStream}.
 */
public void serialize(OutputStream rawOutput) throws IOException {
  DataOutputStream output=new DataOutputStream(rawOutput);
  output.writeInt(VERSION);
  output.writeUTF(key.toString());
  output.writeInt(headers.size());
  for (  String header : headers) {
    output.writeUTF(header);
  }
  output.writeInt(hashes.size());
  for (  Pair<Integer,HashCode> hash : hashes) {
    output.writeInt(hash.getFirst());
    output.writeUTF(hash.getSecond().toString());
  }
  output.writeInt(entries.size());
  for (  Pair<RuleKey,int[]> entry : entries) {
    output.writeInt(entry.getSecond().length);
    for (    int hashIndex : entry.getSecond()) {
      output.writeInt(hashIndex);
    }
    output.writeUTF(entry.getFirst().toString());
  }
}",0.7551659361302442
52951,"@Test public void manifestIsUpdatedWhenBuiltLocally() throws Exception {
  DefaultDependencyFileRuleKeyFactory depFilefactory=new DefaultDependencyFileRuleKeyFactory(FIELD_LOADER,fileHashCache,pathResolver,ruleFinder);
  final Genrule genrule=GenruleBuilder.newGenruleBuilder(BuildTargetFactory.newInstance(""String_Node_Str"")).setOut(""String_Node_Str"").build(resolver,filesystem);
  final Path input=pathResolver.getRelativePath(Preconditions.checkNotNull(genrule.getSourcePathToOutput()));
  filesystem.writeContentsToPath(""String_Node_Str"",input);
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams params=new FakeBuildRuleParamsBuilder(target).setProjectFilesystem(filesystem).build();
  final Path output=Paths.get(""String_Node_Str"");
  DepFileBuildRule rule=new DepFileBuildRule(params){
    @AddToRuleKey private final SourcePath path=genrule.getSourcePathToOutput();
    @Override public ImmutableList<Step> getBuildSteps(    BuildContext context,    BuildableContext buildableContext){
      return ImmutableList.of(new WriteFileStep(filesystem,""String_Node_Str"",output,false));
    }
    @Override public Predicate<SourcePath> getCoveredByDepFilePredicate(){
      return (      SourcePath path) -> true;
    }
    @Override public Predicate<SourcePath> getExistenceOfInterestPredicate(){
      return (      SourcePath path) -> false;
    }
    @Override public ImmutableList<SourcePath> getInputsAfterBuildingLocally(    BuildContext context){
      return ImmutableList.of(new PathSourcePath(filesystem,input));
    }
    @Override public SourcePath getSourcePathToOutput(){
      return new ExplicitBuildTargetSourcePath(getBuildTarget(),output);
    }
  }
;
  CachingBuildEngine cachingBuildEngine=cachingBuildEngineFactory().setDepFiles(CachingBuildEngine.DepFiles.CACHE).setRuleKeyFactories(RuleKeyFactories.of(defaultRuleKeyFactory,inputBasedRuleKeyFactory,depFilefactory)).build();
  Manifest manifest=Manifest.fromMap(ImmutableMap.of(new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(12))));
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  try (GZIPOutputStream outputStream=new GZIPOutputStream(byteArrayOutputStream)){
    manifest.serialize(outputStream);
  }
   cache.store(ArtifactInfo.builder().addRuleKeys(cachingBuildEngine.getManifestRuleKey(rule,buildContext.getEventBus()).get()).build(),byteArrayOutputStream.toByteArray());
  BuildResult result=cachingBuildEngine.build(buildContext,TestExecutionContext.newInstance(),rule).get();
  assertThat(getSuccess(result),equalTo(BuildRuleSuccessType.BUILT_LOCALLY));
  OnDiskBuildInfo onDiskBuildInfo=buildContext.createOnDiskBuildInfoFor(target,filesystem,buildInfoStore);
  RuleKey depFileRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.MetadataKey.DEP_FILE_RULE_KEY).get();
  Path fetchedManifest=tmp.newFile(""String_Node_Str"");
  CacheResult cacheResult=cache.fetch(cachingBuildEngine.getManifestRuleKey(rule,buildContext.getEventBus()).get(),LazyPath.ofInstance(fetchedManifest));
  assertThat(cacheResult.getType(),equalTo(CacheResultType.HIT));
  manifest=loadManifest(fetchedManifest);
  assertThat(manifest.toMap(),equalTo(ImmutableMap.of(depFileRuleKey,ImmutableMap.of(input.toString(),fileHashCache.get(filesystem.resolve(input))),new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(12)))));
  Path fetchedArtifact=tmp.newFile(""String_Node_Str"");
  cacheResult=cache.fetch(depFileRuleKey,LazyPath.ofInstance(fetchedArtifact));
  assertThat(cacheResult.getType(),equalTo(CacheResultType.HIT));
}","@Test public void manifestIsUpdatedWhenBuiltLocally() throws Exception {
  DefaultDependencyFileRuleKeyFactory depFilefactory=new DefaultDependencyFileRuleKeyFactory(FIELD_LOADER,fileHashCache,pathResolver,ruleFinder);
  final Genrule genrule=GenruleBuilder.newGenruleBuilder(BuildTargetFactory.newInstance(""String_Node_Str"")).setOut(""String_Node_Str"").build(resolver,filesystem);
  final Path input=pathResolver.getRelativePath(Preconditions.checkNotNull(genrule.getSourcePathToOutput()));
  filesystem.writeContentsToPath(""String_Node_Str"",input);
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams params=new FakeBuildRuleParamsBuilder(target).setProjectFilesystem(filesystem).build();
  final Path output=Paths.get(""String_Node_Str"");
  DepFileBuildRule rule=new DepFileBuildRule(params){
    @AddToRuleKey private final SourcePath path=genrule.getSourcePathToOutput();
    @Override public ImmutableList<Step> getBuildSteps(    BuildContext context,    BuildableContext buildableContext){
      return ImmutableList.of(new WriteFileStep(filesystem,""String_Node_Str"",output,false));
    }
    @Override public Predicate<SourcePath> getCoveredByDepFilePredicate(){
      return (      SourcePath path) -> true;
    }
    @Override public Predicate<SourcePath> getExistenceOfInterestPredicate(){
      return (      SourcePath path) -> false;
    }
    @Override public ImmutableList<SourcePath> getInputsAfterBuildingLocally(    BuildContext context){
      return ImmutableList.of(new PathSourcePath(filesystem,input));
    }
    @Override public SourcePath getSourcePathToOutput(){
      return new ExplicitBuildTargetSourcePath(getBuildTarget(),output);
    }
  }
;
  CachingBuildEngine cachingBuildEngine=cachingBuildEngineFactory().setDepFiles(CachingBuildEngine.DepFiles.CACHE).setRuleKeyFactories(RuleKeyFactories.of(defaultRuleKeyFactory,inputBasedRuleKeyFactory,depFilefactory)).build();
  Manifest manifest=Manifest.fromMap(depFilefactory.buildManifestKey(rule).getRuleKey(),ImmutableMap.of(new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(12))));
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  try (GZIPOutputStream outputStream=new GZIPOutputStream(byteArrayOutputStream)){
    manifest.serialize(outputStream);
  }
   cache.store(ArtifactInfo.builder().addRuleKeys(cachingBuildEngine.getManifestRuleKey(rule,buildContext.getEventBus()).get()).build(),byteArrayOutputStream.toByteArray());
  BuildResult result=cachingBuildEngine.build(buildContext,TestExecutionContext.newInstance(),rule).get();
  assertThat(getSuccess(result),equalTo(BuildRuleSuccessType.BUILT_LOCALLY));
  OnDiskBuildInfo onDiskBuildInfo=buildContext.createOnDiskBuildInfoFor(target,filesystem,buildInfoStore);
  RuleKey depFileRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.MetadataKey.DEP_FILE_RULE_KEY).get();
  Path fetchedManifest=tmp.newFile(""String_Node_Str"");
  CacheResult cacheResult=cache.fetch(cachingBuildEngine.getManifestRuleKey(rule,buildContext.getEventBus()).get(),LazyPath.ofInstance(fetchedManifest));
  assertThat(cacheResult.getType(),equalTo(CacheResultType.HIT));
  manifest=loadManifest(fetchedManifest);
  assertThat(manifest.toMap(),equalTo(ImmutableMap.of(depFileRuleKey,ImmutableMap.of(input.toString(),fileHashCache.get(filesystem.resolve(input))),new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(12)))));
  Path fetchedArtifact=tmp.newFile(""String_Node_Str"");
  cacheResult=cache.fetch(depFileRuleKey,LazyPath.ofInstance(fetchedArtifact));
  assertThat(cacheResult.getType(),equalTo(CacheResultType.HIT));
}",0.992978108219744
52952,"@Test public void manifestBasedCacheHit() throws Exception {
  DefaultDependencyFileRuleKeyFactory depFilefactory=new DefaultDependencyFileRuleKeyFactory(FIELD_LOADER,fileHashCache,pathResolver,ruleFinder);
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams params=new FakeBuildRuleParamsBuilder(target).setProjectFilesystem(filesystem).build();
  final SourcePath input=new PathSourcePath(filesystem,filesystem.getRootPath().getFileSystem().getPath(""String_Node_Str""));
  filesystem.touch(pathResolver.getRelativePath(input));
  final Path output=Paths.get(""String_Node_Str"");
  DepFileBuildRule rule=new DepFileBuildRule(params){
    @AddToRuleKey private final SourcePath path=input;
    @Override public ImmutableList<Step> getBuildSteps(    BuildContext context,    BuildableContext buildableContext){
      return ImmutableList.of(new WriteFileStep(filesystem,""String_Node_Str"",output,false));
    }
    @Override public Predicate<SourcePath> getCoveredByDepFilePredicate(){
      return (      SourcePath path) -> true;
    }
    @Override public Predicate<SourcePath> getExistenceOfInterestPredicate(){
      return (      SourcePath path) -> false;
    }
    @Override public ImmutableList<SourcePath> getInputsAfterBuildingLocally(    BuildContext context){
      return ImmutableList.of(input);
    }
    @Override public SourcePath getSourcePathToOutput(){
      return new ExplicitBuildTargetSourcePath(getBuildTarget(),output);
    }
  }
;
  CachingBuildEngine cachingBuildEngine=cachingBuildEngineFactory().setDepFiles(CachingBuildEngine.DepFiles.CACHE).setRuleKeyFactories(RuleKeyFactories.of(defaultRuleKeyFactory,inputBasedRuleKeyFactory,depFilefactory)).build();
  RuleKey ruleKey=defaultRuleKeyFactory.build(rule);
  RuleKeyAndInputs depFileKey=depFilefactory.build(rule,ImmutableList.of(DependencyFileEntry.fromSourcePath(input,pathResolver)));
  Manifest manifest=new Manifest();
  manifest.addEntry(fileHashCache,depFileKey.getRuleKey(),pathResolver,ImmutableSet.of(input),ImmutableSet.of(input));
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  try (GZIPOutputStream outputStream=new GZIPOutputStream(byteArrayOutputStream)){
    manifest.serialize(outputStream);
  }
   cache.store(ArtifactInfo.builder().addRuleKeys(cachingBuildEngine.getManifestRuleKey(rule,buildContext.getEventBus()).get()).build(),byteArrayOutputStream.toByteArray());
  Path artifact=tmp.newFile(""String_Node_Str"");
  writeEntriesToZip(artifact,ImmutableMap.of(BuildInfo.getPathToMetadataDirectory(target,filesystem).resolve(BuildInfo.MetadataKey.RECORDED_PATHS),ObjectMappers.WRITER.writeValueAsString(ImmutableList.of(output.toString())),output,""String_Node_Str""));
  cache.store(ArtifactInfo.builder().addRuleKeys(depFileKey.getRuleKey()).putMetadata(BuildInfo.MetadataKey.ORIGIN_BUILD_ID,buildContext.getBuildId().toString()).putMetadata(BuildInfo.MetadataKey.DEP_FILE_RULE_KEY,depFileKey.getRuleKey().toString()).putMetadata(BuildInfo.MetadataKey.DEP_FILE,ObjectMappers.WRITER.writeValueAsString(depFileKey.getInputs().stream().map(pathResolver::getRelativePath).collect(MoreCollectors.toImmutableList()))).build(),BorrowablePath.notBorrowablePath(artifact));
  BuildResult result=cachingBuildEngine.build(buildContext,TestExecutionContext.newInstance(),rule).get();
  assertThat(getSuccess(result),equalTo(BuildRuleSuccessType.FETCHED_FROM_CACHE_MANIFEST_BASED));
  for (  RuleKey key : ImmutableSet.of(ruleKey,depFileKey.getRuleKey())) {
    LazyPath fetchedArtifact=LazyPath.ofInstance(tmp.newFile(""String_Node_Str""));
    CacheResult cacheResult=cache.fetch(key,fetchedArtifact);
    assertThat(cacheResult.getType(),equalTo(CacheResultType.HIT));
    assertThat(cacheResult.getMetadata().get(BuildInfo.MetadataKey.RULE_KEY),equalTo(ruleKey.toString()));
    assertThat(cacheResult.getMetadata().get(BuildInfo.MetadataKey.DEP_FILE_RULE_KEY),equalTo(depFileKey.getRuleKey().toString()));
    assertThat(cacheResult.getMetadata().get(BuildInfo.MetadataKey.DEP_FILE),equalTo(ObjectMappers.WRITER.writeValueAsString(depFileKey.getInputs().stream().map(pathResolver::getRelativePath).collect(MoreCollectors.toImmutableList()))));
    Files.delete(fetchedArtifact.get());
  }
}","@Test public void manifestBasedCacheHit() throws Exception {
  DefaultDependencyFileRuleKeyFactory depFilefactory=new DefaultDependencyFileRuleKeyFactory(FIELD_LOADER,fileHashCache,pathResolver,ruleFinder);
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams params=new FakeBuildRuleParamsBuilder(target).setProjectFilesystem(filesystem).build();
  final SourcePath input=new PathSourcePath(filesystem,filesystem.getRootPath().getFileSystem().getPath(""String_Node_Str""));
  filesystem.touch(pathResolver.getRelativePath(input));
  final Path output=Paths.get(""String_Node_Str"");
  DepFileBuildRule rule=new DepFileBuildRule(params){
    @AddToRuleKey private final SourcePath path=input;
    @Override public ImmutableList<Step> getBuildSteps(    BuildContext context,    BuildableContext buildableContext){
      return ImmutableList.of(new WriteFileStep(filesystem,""String_Node_Str"",output,false));
    }
    @Override public Predicate<SourcePath> getCoveredByDepFilePredicate(){
      return (      SourcePath path) -> true;
    }
    @Override public Predicate<SourcePath> getExistenceOfInterestPredicate(){
      return (      SourcePath path) -> false;
    }
    @Override public ImmutableList<SourcePath> getInputsAfterBuildingLocally(    BuildContext context){
      return ImmutableList.of(input);
    }
    @Override public SourcePath getSourcePathToOutput(){
      return new ExplicitBuildTargetSourcePath(getBuildTarget(),output);
    }
  }
;
  CachingBuildEngine cachingBuildEngine=cachingBuildEngineFactory().setDepFiles(CachingBuildEngine.DepFiles.CACHE).setRuleKeyFactories(RuleKeyFactories.of(defaultRuleKeyFactory,inputBasedRuleKeyFactory,depFilefactory)).build();
  RuleKey ruleKey=defaultRuleKeyFactory.build(rule);
  RuleKeyAndInputs depFileKey=depFilefactory.build(rule,ImmutableList.of(DependencyFileEntry.fromSourcePath(input,pathResolver)));
  Manifest manifest=new Manifest(depFilefactory.buildManifestKey(rule).getRuleKey());
  manifest.addEntry(fileHashCache,depFileKey.getRuleKey(),pathResolver,ImmutableSet.of(input),ImmutableSet.of(input));
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  try (GZIPOutputStream outputStream=new GZIPOutputStream(byteArrayOutputStream)){
    manifest.serialize(outputStream);
  }
   cache.store(ArtifactInfo.builder().addRuleKeys(cachingBuildEngine.getManifestRuleKey(rule,buildContext.getEventBus()).get()).build(),byteArrayOutputStream.toByteArray());
  Path artifact=tmp.newFile(""String_Node_Str"");
  writeEntriesToZip(artifact,ImmutableMap.of(BuildInfo.getPathToMetadataDirectory(target,filesystem).resolve(BuildInfo.MetadataKey.RECORDED_PATHS),ObjectMappers.WRITER.writeValueAsString(ImmutableList.of(output.toString())),output,""String_Node_Str""));
  cache.store(ArtifactInfo.builder().addRuleKeys(depFileKey.getRuleKey()).putMetadata(BuildInfo.MetadataKey.ORIGIN_BUILD_ID,buildContext.getBuildId().toString()).putMetadata(BuildInfo.MetadataKey.DEP_FILE_RULE_KEY,depFileKey.getRuleKey().toString()).putMetadata(BuildInfo.MetadataKey.DEP_FILE,ObjectMappers.WRITER.writeValueAsString(depFileKey.getInputs().stream().map(pathResolver::getRelativePath).collect(MoreCollectors.toImmutableList()))).build(),BorrowablePath.notBorrowablePath(artifact));
  BuildResult result=cachingBuildEngine.build(buildContext,TestExecutionContext.newInstance(),rule).get();
  assertThat(getSuccess(result),equalTo(BuildRuleSuccessType.FETCHED_FROM_CACHE_MANIFEST_BASED));
  for (  RuleKey key : ImmutableSet.of(ruleKey,depFileKey.getRuleKey())) {
    LazyPath fetchedArtifact=LazyPath.ofInstance(tmp.newFile(""String_Node_Str""));
    CacheResult cacheResult=cache.fetch(key,fetchedArtifact);
    assertThat(cacheResult.getType(),equalTo(CacheResultType.HIT));
    assertThat(cacheResult.getMetadata().get(BuildInfo.MetadataKey.RULE_KEY),equalTo(ruleKey.toString()));
    assertThat(cacheResult.getMetadata().get(BuildInfo.MetadataKey.DEP_FILE_RULE_KEY),equalTo(depFileKey.getRuleKey().toString()));
    assertThat(cacheResult.getMetadata().get(BuildInfo.MetadataKey.DEP_FILE),equalTo(ObjectMappers.WRITER.writeValueAsString(depFileKey.getInputs().stream().map(pathResolver::getRelativePath).collect(MoreCollectors.toImmutableList()))));
    Files.delete(fetchedArtifact.get());
  }
}",0.9941465698899556
52953,"@Test public void manifestIsTruncatedWhenGrowingPastSizeLimit() throws Exception {
  DefaultDependencyFileRuleKeyFactory depFilefactory=new DefaultDependencyFileRuleKeyFactory(FIELD_LOADER,fileHashCache,pathResolver,ruleFinder);
  final Genrule genrule=GenruleBuilder.newGenruleBuilder(BuildTargetFactory.newInstance(""String_Node_Str"")).setOut(""String_Node_Str"").build(resolver,filesystem);
  final Path input=pathResolver.getRelativePath(Preconditions.checkNotNull(genrule.getSourcePathToOutput()));
  filesystem.writeContentsToPath(""String_Node_Str"",input);
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams params=new FakeBuildRuleParamsBuilder(target).setProjectFilesystem(filesystem).build();
  final Path output=Paths.get(""String_Node_Str"");
  DepFileBuildRule rule=new DepFileBuildRule(params){
    @AddToRuleKey private final SourcePath path=genrule.getSourcePathToOutput();
    @Override public ImmutableList<Step> getBuildSteps(    BuildContext context,    BuildableContext buildableContext){
      return ImmutableList.of(new WriteFileStep(filesystem,""String_Node_Str"",output,false));
    }
    @Override public Predicate<SourcePath> getCoveredByDepFilePredicate(){
      return (      SourcePath path) -> true;
    }
    @Override public Predicate<SourcePath> getExistenceOfInterestPredicate(){
      return (      SourcePath path) -> false;
    }
    @Override public ImmutableList<SourcePath> getInputsAfterBuildingLocally(    BuildContext context){
      return ImmutableList.of(new PathSourcePath(filesystem,input));
    }
    @Override public SourcePath getSourcePathToOutput(){
      return new ExplicitBuildTargetSourcePath(getBuildTarget(),output);
    }
  }
;
  CachingBuildEngine cachingBuildEngine=cachingBuildEngineFactory().setDepFiles(CachingBuildEngine.DepFiles.CACHE).setMaxDepFileCacheEntries(1L).setRuleKeyFactories(RuleKeyFactories.of(defaultRuleKeyFactory,inputBasedRuleKeyFactory,depFilefactory)).build();
  Manifest manifest=Manifest.fromMap(ImmutableMap.of(new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(12))));
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  try (GZIPOutputStream outputStream=new GZIPOutputStream(byteArrayOutputStream)){
    manifest.serialize(outputStream);
  }
   cache.store(ArtifactInfo.builder().addRuleKeys(cachingBuildEngine.getManifestRuleKey(rule,buildContext.getEventBus()).get()).build(),byteArrayOutputStream.toByteArray());
  BuildResult result=cachingBuildEngine.build(buildContext,TestExecutionContext.newInstance(),rule).get();
  assertThat(getSuccess(result),equalTo(BuildRuleSuccessType.BUILT_LOCALLY));
  OnDiskBuildInfo onDiskBuildInfo=buildContext.createOnDiskBuildInfoFor(target,filesystem,buildInfoStore);
  RuleKey depFileRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.MetadataKey.DEP_FILE_RULE_KEY).get();
  Path fetchedManifest=tmp.newFile(""String_Node_Str"");
  CacheResult cacheResult=cache.fetch(cachingBuildEngine.getManifestRuleKey(rule,buildContext.getEventBus()).get(),LazyPath.ofInstance(fetchedManifest));
  assertThat(cacheResult.getType(),equalTo(CacheResultType.HIT));
  manifest=loadManifest(fetchedManifest);
  assertThat(manifest.toMap(),equalTo(ImmutableMap.of(depFileRuleKey,ImmutableMap.of(input.toString(),fileHashCache.get(filesystem.resolve(input))))));
}","@Test public void manifestIsTruncatedWhenGrowingPastSizeLimit() throws Exception {
  DefaultDependencyFileRuleKeyFactory depFilefactory=new DefaultDependencyFileRuleKeyFactory(FIELD_LOADER,fileHashCache,pathResolver,ruleFinder);
  final Genrule genrule=GenruleBuilder.newGenruleBuilder(BuildTargetFactory.newInstance(""String_Node_Str"")).setOut(""String_Node_Str"").build(resolver,filesystem);
  final Path input=pathResolver.getRelativePath(Preconditions.checkNotNull(genrule.getSourcePathToOutput()));
  filesystem.writeContentsToPath(""String_Node_Str"",input);
  BuildTarget target=BuildTargetFactory.newInstance(""String_Node_Str"");
  BuildRuleParams params=new FakeBuildRuleParamsBuilder(target).setProjectFilesystem(filesystem).build();
  final Path output=Paths.get(""String_Node_Str"");
  DepFileBuildRule rule=new DepFileBuildRule(params){
    @AddToRuleKey private final SourcePath path=genrule.getSourcePathToOutput();
    @Override public ImmutableList<Step> getBuildSteps(    BuildContext context,    BuildableContext buildableContext){
      return ImmutableList.of(new WriteFileStep(filesystem,""String_Node_Str"",output,false));
    }
    @Override public Predicate<SourcePath> getCoveredByDepFilePredicate(){
      return (      SourcePath path) -> true;
    }
    @Override public Predicate<SourcePath> getExistenceOfInterestPredicate(){
      return (      SourcePath path) -> false;
    }
    @Override public ImmutableList<SourcePath> getInputsAfterBuildingLocally(    BuildContext context){
      return ImmutableList.of(new PathSourcePath(filesystem,input));
    }
    @Override public SourcePath getSourcePathToOutput(){
      return new ExplicitBuildTargetSourcePath(getBuildTarget(),output);
    }
  }
;
  CachingBuildEngine cachingBuildEngine=cachingBuildEngineFactory().setDepFiles(CachingBuildEngine.DepFiles.CACHE).setMaxDepFileCacheEntries(1L).setRuleKeyFactories(RuleKeyFactories.of(defaultRuleKeyFactory,inputBasedRuleKeyFactory,depFilefactory)).build();
  Manifest manifest=Manifest.fromMap(depFilefactory.buildManifestKey(rule).getRuleKey(),ImmutableMap.of(new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(12))));
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  try (GZIPOutputStream outputStream=new GZIPOutputStream(byteArrayOutputStream)){
    manifest.serialize(outputStream);
  }
   cache.store(ArtifactInfo.builder().addRuleKeys(cachingBuildEngine.getManifestRuleKey(rule,buildContext.getEventBus()).get()).build(),byteArrayOutputStream.toByteArray());
  BuildResult result=cachingBuildEngine.build(buildContext,TestExecutionContext.newInstance(),rule).get();
  assertThat(getSuccess(result),equalTo(BuildRuleSuccessType.BUILT_LOCALLY));
  OnDiskBuildInfo onDiskBuildInfo=buildContext.createOnDiskBuildInfoFor(target,filesystem,buildInfoStore);
  RuleKey depFileRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.MetadataKey.DEP_FILE_RULE_KEY).get();
  Path fetchedManifest=tmp.newFile(""String_Node_Str"");
  CacheResult cacheResult=cache.fetch(cachingBuildEngine.getManifestRuleKey(rule,buildContext.getEventBus()).get(),LazyPath.ofInstance(fetchedManifest));
  assertThat(cacheResult.getType(),equalTo(CacheResultType.HIT));
  manifest=loadManifest(fetchedManifest);
  assertThat(manifest.toMap(),equalTo(ImmutableMap.of(depFileRuleKey,ImmutableMap.of(input.toString(),fileHashCache.get(filesystem.resolve(input))))));
}",0.9924634254470224
52954,"@Test public void serialize() throws IOException {
  ImmutableMap<RuleKey,ImmutableMap<String,HashCode>> entries=ImmutableMap.of(new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(20)));
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  Manifest.fromMap(entries).serialize(byteArrayOutputStream);
  Manifest deserialized=new Manifest(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));
  assertThat(deserialized.toMap(),Matchers.equalTo(entries));
}","@Test public void serialize() throws IOException {
  ImmutableMap<RuleKey,ImmutableMap<String,HashCode>> entries=ImmutableMap.of(new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(20)));
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  Manifest.fromMap(new RuleKey(""String_Node_Str""),entries).serialize(byteArrayOutputStream);
  Manifest deserialized=new Manifest(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));
  assertThat(deserialized.toMap(),Matchers.equalTo(entries));
}",0.971000935453695
52955,"@Test public void lookupHashMismatch() throws IOException {
  RuleKey key=new RuleKey(""String_Node_Str"");
  SourcePath input=new FakeSourcePath(""String_Node_Str"");
  Manifest manifest=Manifest.fromMap(ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input).toString(),HashCode.fromInt(1))));
  FileHashCache fileHashCache=new FakeFileHashCache(ImmutableMap.of(RESOLVER.getAbsolutePath(input),HashCode.fromInt(2)));
  assertThat(manifest.lookup(fileHashCache,RESOLVER,ImmutableSet.of(input)),Matchers.equalTo(Optional.empty()));
}","@Test public void lookupHashMismatch() throws IOException {
  RuleKey key=new RuleKey(""String_Node_Str"");
  SourcePath input=new FakeSourcePath(""String_Node_Str"");
  Manifest manifest=Manifest.fromMap(new RuleKey(""String_Node_Str""),ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input).toString(),HashCode.fromInt(1))));
  FileHashCache fileHashCache=new FakeFileHashCache(ImmutableMap.of(RESOLVER.getAbsolutePath(input),HashCode.fromInt(2)));
  assertThat(manifest.lookup(fileHashCache,RESOLVER,ImmutableSet.of(input)),Matchers.equalTo(Optional.empty()));
}",0.97214734950584
52956,"@Test public void addEntry() throws IOException {
  Manifest manifest=new Manifest();
  RuleKey key=new RuleKey(""String_Node_Str"");
  SourcePath input=new FakeSourcePath(""String_Node_Str"");
  HashCode hashCode=HashCode.fromInt(20);
  FileHashCache fileHashCache=new FakeFileHashCache(ImmutableMap.of(RESOLVER.getAbsolutePath(input),hashCode));
  manifest.addEntry(fileHashCache,key,RESOLVER,ImmutableSet.of(input),ImmutableSet.of(input));
  assertThat(manifest.toMap(),Matchers.equalTo(ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input).toString(),hashCode))));
}","@Test public void addEntry() throws IOException {
  Manifest manifest=new Manifest(new RuleKey(""String_Node_Str""));
  RuleKey key=new RuleKey(""String_Node_Str"");
  SourcePath input=new FakeSourcePath(""String_Node_Str"");
  HashCode hashCode=HashCode.fromInt(20);
  FileHashCache fileHashCache=new FakeFileHashCache(ImmutableMap.of(RESOLVER.getAbsolutePath(input),hashCode));
  manifest.addEntry(fileHashCache,key,RESOLVER,ImmutableSet.of(input),ImmutableSet.of(input));
  assertThat(manifest.toMap(),Matchers.equalTo(ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input).toString(),hashCode))));
}",0.8957983193277311
52957,"@Test public void size(){
  assertThat(new Manifest().size(),Matchers.equalTo(0));
  assertThat(Manifest.fromMap(ImmutableMap.of(new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(0)))).size(),Matchers.equalTo(1));
  assertThat(Manifest.fromMap(ImmutableMap.of(new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(0)),new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(0)))).size(),Matchers.equalTo(2));
}","@Test public void size(){
  assertThat(new Manifest(new RuleKey(""String_Node_Str"")).size(),Matchers.equalTo(0));
  assertThat(Manifest.fromMap(new RuleKey(""String_Node_Str""),ImmutableMap.of(new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(0)))).size(),Matchers.equalTo(1));
  assertThat(Manifest.fromMap(new RuleKey(""String_Node_Str""),ImmutableMap.of(new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(0)),new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(0)))).size(),Matchers.equalTo(2));
}",0.915129151291513
52958,"@Test public void addEntryWithSourcePathsThatHaveSameRelativePaths() throws IOException {
  RuleKey key=new RuleKey(""String_Node_Str"");
  Path tmp1=Files.createTempDirectory(""String_Node_Str"");
  ProjectFilesystem filesystem1=new FakeProjectFilesystem(tmp1);
  SourcePath input1=new PathSourcePath(filesystem1,Paths.get(""String_Node_Str""));
  HashCode hashCode1=HashCode.fromInt(1);
  Path tmp2=Files.createTempDirectory(""String_Node_Str"");
  ProjectFilesystem filesystem2=new FakeProjectFilesystem(tmp2);
  SourcePath input2=new PathSourcePath(filesystem2,Paths.get(""String_Node_Str""));
  HashCode hashCode2=HashCode.fromInt(1);
  FileHashCache fileHashCache=new FakeFileHashCache(ImmutableMap.of(RESOLVER.getAbsolutePath(input1),hashCode1,RESOLVER.getAbsolutePath(input2),hashCode2));
  Manifest manifest1=new Manifest();
  manifest1.addEntry(fileHashCache,key,RESOLVER,ImmutableSet.of(input1,input2),ImmutableSet.of(input1));
  assertThat(manifest1.toMap(),Matchers.equalTo(ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input1).toString(),Manifest.hashSourcePathGroup(fileHashCache,RESOLVER,ImmutableList.of(input1,input2))))));
  Manifest manifest2=new Manifest();
  manifest2.addEntry(fileHashCache,key,RESOLVER,ImmutableSet.of(input1,input2),ImmutableSet.of(input2));
  assertThat(manifest2.toMap(),Matchers.equalTo(ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input2).toString(),Manifest.hashSourcePathGroup(fileHashCache,RESOLVER,ImmutableList.of(input1,input2))))));
}","@Test public void addEntryWithSourcePathsThatHaveSameRelativePaths() throws IOException {
  RuleKey key=new RuleKey(""String_Node_Str"");
  Path tmp1=Files.createTempDirectory(""String_Node_Str"");
  ProjectFilesystem filesystem1=new FakeProjectFilesystem(tmp1);
  SourcePath input1=new PathSourcePath(filesystem1,Paths.get(""String_Node_Str""));
  HashCode hashCode1=HashCode.fromInt(1);
  Path tmp2=Files.createTempDirectory(""String_Node_Str"");
  ProjectFilesystem filesystem2=new FakeProjectFilesystem(tmp2);
  SourcePath input2=new PathSourcePath(filesystem2,Paths.get(""String_Node_Str""));
  HashCode hashCode2=HashCode.fromInt(1);
  FileHashCache fileHashCache=new FakeFileHashCache(ImmutableMap.of(RESOLVER.getAbsolutePath(input1),hashCode1,RESOLVER.getAbsolutePath(input2),hashCode2));
  Manifest manifest1=new Manifest(new RuleKey(""String_Node_Str""));
  manifest1.addEntry(fileHashCache,key,RESOLVER,ImmutableSet.of(input1,input2),ImmutableSet.of(input1));
  assertThat(manifest1.toMap(),Matchers.equalTo(ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input1).toString(),Manifest.hashSourcePathGroup(fileHashCache,RESOLVER,ImmutableList.of(input1,input2))))));
  Manifest manifest2=new Manifest(new RuleKey(""String_Node_Str""));
  manifest2.addEntry(fileHashCache,key,RESOLVER,ImmutableSet.of(input1,input2),ImmutableSet.of(input2));
  assertThat(manifest2.toMap(),Matchers.equalTo(ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input2).toString(),Manifest.hashSourcePathGroup(fileHashCache,RESOLVER,ImmutableList.of(input1,input2))))));
}",0.9804941482444732
52959,"@Test public void lookupMissingHeader() throws IOException {
  RuleKey key=new RuleKey(""String_Node_Str"");
  SourcePath input=new FakeSourcePath(""String_Node_Str"");
  Manifest manifest=Manifest.fromMap(ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input).toString(),HashCode.fromInt(1))));
  FileHashCache fileHashCache=new FakeFileHashCache(ImmutableMap.of());
  assertThat(manifest.lookup(fileHashCache,RESOLVER,ImmutableSet.of(input)),Matchers.equalTo(Optional.empty()));
}","@Test public void lookupMissingHeader() throws IOException {
  RuleKey key=new RuleKey(""String_Node_Str"");
  SourcePath input=new FakeSourcePath(""String_Node_Str"");
  Manifest manifest=Manifest.fromMap(new RuleKey(""String_Node_Str""),ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input).toString(),HashCode.fromInt(1))));
  FileHashCache fileHashCache=new FakeFileHashCache(ImmutableMap.of());
  assertThat(manifest.lookup(fileHashCache,RESOLVER,ImmutableSet.of(input)),Matchers.equalTo(Optional.empty()));
}",0.9693978282329714
52960,"@Test public void toMap(){
  ImmutableMap<RuleKey,ImmutableMap<String,HashCode>> entries=ImmutableMap.of(new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(20)));
  assertThat(Manifest.fromMap(entries).toMap(),Matchers.equalTo(entries));
}","@Test public void toMap(){
  ImmutableMap<RuleKey,ImmutableMap<String,HashCode>> entries=ImmutableMap.of(new RuleKey(""String_Node_Str""),ImmutableMap.of(""String_Node_Str"",HashCode.fromInt(20)));
  assertThat(Manifest.fromMap(new RuleKey(""String_Node_Str""),entries).toMap(),Matchers.equalTo(entries));
}",0.9457092819614712
52961,"@Test public void lookupMatchWithSourcePathsThatHaveSameRelativePaths() throws IOException {
  RuleKey key=new RuleKey(""String_Node_Str"");
  Path tmp1=Files.createTempDirectory(""String_Node_Str"");
  ProjectFilesystem filesystem1=new FakeProjectFilesystem(tmp1);
  SourcePath input1=new PathSourcePath(filesystem1,Paths.get(""String_Node_Str""));
  HashCode hashCode1=HashCode.fromInt(1);
  Path tmp2=Files.createTempDirectory(""String_Node_Str"");
  ProjectFilesystem filesystem2=new FakeProjectFilesystem(tmp2);
  SourcePath input2=new PathSourcePath(filesystem2,Paths.get(""String_Node_Str""));
  HashCode hashCode2=HashCode.fromInt(1);
  FileHashCache fileHashCache=new FakeFileHashCache(ImmutableMap.of(RESOLVER.getAbsolutePath(input1),hashCode1,RESOLVER.getAbsolutePath(input2),hashCode2));
  Manifest manifest1=Manifest.fromMap(ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input1).toString(),Manifest.hashSourcePathGroup(fileHashCache,RESOLVER,ImmutableList.of(input1,input2)))));
  assertThat(manifest1.lookup(fileHashCache,RESOLVER,ImmutableSet.of(input1,input2)),Matchers.equalTo(Optional.of(key)));
  Manifest manifest2=Manifest.fromMap(ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input2).toString(),Manifest.hashSourcePathGroup(fileHashCache,RESOLVER,ImmutableList.of(input1,input2)))));
  assertThat(manifest2.lookup(fileHashCache,RESOLVER,ImmutableSet.of(input1,input2)),Matchers.equalTo(Optional.of(key)));
}","@Test public void lookupMatchWithSourcePathsThatHaveSameRelativePaths() throws IOException {
  RuleKey key=new RuleKey(""String_Node_Str"");
  Path tmp1=Files.createTempDirectory(""String_Node_Str"");
  ProjectFilesystem filesystem1=new FakeProjectFilesystem(tmp1);
  SourcePath input1=new PathSourcePath(filesystem1,Paths.get(""String_Node_Str""));
  HashCode hashCode1=HashCode.fromInt(1);
  Path tmp2=Files.createTempDirectory(""String_Node_Str"");
  ProjectFilesystem filesystem2=new FakeProjectFilesystem(tmp2);
  SourcePath input2=new PathSourcePath(filesystem2,Paths.get(""String_Node_Str""));
  HashCode hashCode2=HashCode.fromInt(1);
  FileHashCache fileHashCache=new FakeFileHashCache(ImmutableMap.of(RESOLVER.getAbsolutePath(input1),hashCode1,RESOLVER.getAbsolutePath(input2),hashCode2));
  Manifest manifest1=Manifest.fromMap(new RuleKey(""String_Node_Str""),ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input1).toString(),Manifest.hashSourcePathGroup(fileHashCache,RESOLVER,ImmutableList.of(input1,input2)))));
  assertThat(manifest1.lookup(fileHashCache,RESOLVER,ImmutableSet.of(input1,input2)),Matchers.equalTo(Optional.of(key)));
  Manifest manifest2=Manifest.fromMap(new RuleKey(""String_Node_Str""),ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input2).toString(),Manifest.hashSourcePathGroup(fileHashCache,RESOLVER,ImmutableList.of(input1,input2)))));
  assertThat(manifest2.lookup(fileHashCache,RESOLVER,ImmutableSet.of(input1,input2)),Matchers.equalTo(Optional.of(key)));
}",0.979054054054054
52962,"@Test public void emptyManifest(){
  assertThat(new Manifest().toMap().entrySet(),Matchers.empty());
}","@Test public void emptyManifest(){
  assertThat(new Manifest(new RuleKey(""String_Node_Str"")).toMap().entrySet(),Matchers.empty());
}",0.8717948717948718
52963,"@Test public void lookupMatchAfterHashMismatch() throws IOException {
  RuleKey key1=new RuleKey(""String_Node_Str"");
  RuleKey key2=new RuleKey(""String_Node_Str"");
  SourcePath input=new FakeSourcePath(""String_Node_Str"");
  Manifest manifest=Manifest.fromMap(ImmutableMap.of(key1,ImmutableMap.of(RESOLVER.getRelativePath(input).toString(),HashCode.fromInt(1)),key2,ImmutableMap.of(RESOLVER.getRelativePath(input).toString(),HashCode.fromInt(2))));
  FileHashCache fileHashCache=new FakeFileHashCache(ImmutableMap.of(RESOLVER.getAbsolutePath(input),HashCode.fromInt(2)));
  assertThat(manifest.lookup(fileHashCache,RESOLVER,ImmutableSet.of(input)),Matchers.equalTo(Optional.of(key2)));
}","@Test public void lookupMatchAfterHashMismatch() throws IOException {
  RuleKey key1=new RuleKey(""String_Node_Str"");
  RuleKey key2=new RuleKey(""String_Node_Str"");
  SourcePath input=new FakeSourcePath(""String_Node_Str"");
  Manifest manifest=Manifest.fromMap(new RuleKey(""String_Node_Str""),ImmutableMap.of(key1,ImmutableMap.of(RESOLVER.getRelativePath(input).toString(),HashCode.fromInt(1)),key2,ImmutableMap.of(RESOLVER.getRelativePath(input).toString(),HashCode.fromInt(2))));
  FileHashCache fileHashCache=new FakeFileHashCache(ImmutableMap.of(RESOLVER.getAbsolutePath(input),HashCode.fromInt(2)));
  assertThat(manifest.lookup(fileHashCache,RESOLVER,ImmutableSet.of(input)),Matchers.equalTo(Optional.of(key2)));
}",0.977904490377762
52964,"@Test public void lookupMatch() throws IOException {
  RuleKey key=new RuleKey(""String_Node_Str"");
  SourcePath input=new FakeSourcePath(""String_Node_Str"");
  HashCode hashCode=HashCode.fromInt(20);
  Manifest manifest=Manifest.fromMap(ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input).toString(),hashCode)));
  FileHashCache fileHashCache=new FakeFileHashCache(ImmutableMap.of(RESOLVER.getAbsolutePath(input),hashCode));
  assertThat(manifest.lookup(fileHashCache,RESOLVER,ImmutableSet.of(input)),Matchers.equalTo(Optional.of(key)));
}","@Test public void lookupMatch() throws IOException {
  RuleKey key=new RuleKey(""String_Node_Str"");
  SourcePath input=new FakeSourcePath(""String_Node_Str"");
  HashCode hashCode=HashCode.fromInt(20);
  Manifest manifest=Manifest.fromMap(new RuleKey(""String_Node_Str""),ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativePath(input).toString(),hashCode)));
  FileHashCache fileHashCache=new FakeFileHashCache(ImmutableMap.of(RESOLVER.getAbsolutePath(input),hashCode));
  assertThat(manifest.lookup(fileHashCache,RESOLVER,ImmutableSet.of(input)),Matchers.equalTo(Optional.of(key)));
}",0.9727831431079894
52965,"@Test public void addEntryFromArchive() throws IOException {
  Manifest manifest=new Manifest();
  RuleKey key=new RuleKey(""String_Node_Str"");
  SourcePath input=new ArchiveMemberSourcePath(new FakeSourcePath(""String_Node_Str""),Paths.get(""String_Node_Str""));
  HashCode hashCode=HashCode.fromInt(20);
  FileHashCache fileHashCache=new FakeFileHashCache(new HashMap<>(),ImmutableMap.of(RESOLVER.getAbsoluteArchiveMemberPath(input),hashCode),new HashMap<>());
  manifest.addEntry(fileHashCache,key,RESOLVER,ImmutableSet.of(input),ImmutableSet.of(input));
  assertThat(manifest.toMap(),Matchers.equalTo(ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativeArchiveMemberPath(input).toString(),hashCode))));
}","@Test public void addEntryFromArchive() throws IOException {
  Manifest manifest=new Manifest(new RuleKey(""String_Node_Str""));
  RuleKey key=new RuleKey(""String_Node_Str"");
  SourcePath input=new ArchiveMemberSourcePath(new FakeSourcePath(""String_Node_Str""),Paths.get(""String_Node_Str""));
  HashCode hashCode=HashCode.fromInt(20);
  FileHashCache fileHashCache=new FakeFileHashCache(new HashMap<>(),ImmutableMap.of(RESOLVER.getAbsoluteArchiveMemberPath(input),hashCode),new HashMap<>());
  manifest.addEntry(fileHashCache,key,RESOLVER,ImmutableSet.of(input),ImmutableSet.of(input));
  assertThat(manifest.toMap(),Matchers.equalTo(ImmutableMap.of(key,ImmutableMap.of(RESOLVER.getRelativeArchiveMemberPath(input).toString(),hashCode))));
}",0.8670360110803325
52966,"@Override public <A extends Arg,U>Optional<U> createMetadata(BuildTarget buildTarget,BuildRuleResolver resolver,A args,Optional<ImmutableMap<BuildTarget,Version>> selectedVersions,Class<U> metadataClass) throws NoSuchBuildTargetException {
  Map.Entry<Flavor,MetadataType> type=METADATA_TYPE.getFlavorAndValue(buildTarget).orElseThrow(IllegalArgumentException::new);
  BuildTarget baseTarget=buildTarget.withoutFlavors(type.getKey());
switch (type.getValue()) {
case PACKAGE_COMPONENTS:
{
      Map.Entry<Flavor,PythonPlatform> pythonPlatform=pythonPlatforms.getFlavorAndValue(baseTarget).orElseThrow(IllegalArgumentException::new);
      Map.Entry<Flavor,CxxPlatform> cxxPlatform=cxxPlatforms.getFlavorAndValue(baseTarget).orElseThrow(IllegalArgumentException::new);
      baseTarget=buildTarget.withoutFlavors(pythonPlatform.getKey(),cxxPlatform.getKey());
      SourcePathRuleFinder ruleFinder=new SourcePathRuleFinder(resolver);
      SourcePathResolver pathResolver=new SourcePathResolver(ruleFinder);
      Path baseModule=PythonUtil.getBasePath(baseTarget,args.baseModule);
      PythonPackageComponents components=PythonPackageComponents.of(PythonUtil.getModules(baseTarget,resolver,ruleFinder,pathResolver,pythonPlatform.getValue(),cxxPlatform.getValue(),""String_Node_Str"",baseModule,args.srcs,args.platformSrcs,args.versionedSrcs,selectedVersions),PythonUtil.getModules(baseTarget,resolver,ruleFinder,pathResolver,pythonPlatform.getValue(),cxxPlatform.getValue(),""String_Node_Str"",baseModule,args.resources,args.platformResources,args.versionedResources,selectedVersions),ImmutableMap.of(),ImmutableSet.of(),args.zipSafe);
      return Optional.of(components).map(metadataClass::cast);
    }
case PACKAGE_DEPS:
{
    Map.Entry<Flavor,PythonPlatform> pythonPlatform=pythonPlatforms.getFlavorAndValue(baseTarget).orElseThrow(IllegalArgumentException::new);
    Map.Entry<Flavor,CxxPlatform> cxxPlatform=cxxPlatforms.getFlavorAndValue(baseTarget).orElseThrow(IllegalArgumentException::new);
    baseTarget=buildTarget.withoutFlavors(pythonPlatform.getKey(),cxxPlatform.getKey());
    ImmutableList<BuildTarget> depTargets=PythonUtil.getDeps(pythonPlatform.getValue(),cxxPlatform.getValue(),args.deps,args.platformDeps);
    return Optional.of(resolver.getAllRules(depTargets)).map(metadataClass::cast);
  }
}
throw new IllegalStateException();
}","@Override public <A extends Arg,U>Optional<U> createMetadata(BuildTarget buildTarget,BuildRuleResolver resolver,A args,Optional<ImmutableMap<BuildTarget,Version>> selectedVersions,Class<U> metadataClass) throws NoSuchBuildTargetException {
  Optional<Map.Entry<Flavor,MetadataType>> optionalType=METADATA_TYPE.getFlavorAndValue(buildTarget);
  if (!optionalType.isPresent()) {
    return Optional.empty();
  }
  Map.Entry<Flavor,MetadataType> type=optionalType.get();
  BuildTarget baseTarget=buildTarget.withoutFlavors(type.getKey());
switch (type.getValue()) {
case PACKAGE_COMPONENTS:
{
      Map.Entry<Flavor,PythonPlatform> pythonPlatform=pythonPlatforms.getFlavorAndValue(baseTarget).orElseThrow(IllegalArgumentException::new);
      Map.Entry<Flavor,CxxPlatform> cxxPlatform=cxxPlatforms.getFlavorAndValue(baseTarget).orElseThrow(IllegalArgumentException::new);
      baseTarget=buildTarget.withoutFlavors(pythonPlatform.getKey(),cxxPlatform.getKey());
      SourcePathRuleFinder ruleFinder=new SourcePathRuleFinder(resolver);
      SourcePathResolver pathResolver=new SourcePathResolver(ruleFinder);
      Path baseModule=PythonUtil.getBasePath(baseTarget,args.baseModule);
      PythonPackageComponents components=PythonPackageComponents.of(PythonUtil.getModules(baseTarget,resolver,ruleFinder,pathResolver,pythonPlatform.getValue(),cxxPlatform.getValue(),""String_Node_Str"",baseModule,args.srcs,args.platformSrcs,args.versionedSrcs,selectedVersions),PythonUtil.getModules(baseTarget,resolver,ruleFinder,pathResolver,pythonPlatform.getValue(),cxxPlatform.getValue(),""String_Node_Str"",baseModule,args.resources,args.platformResources,args.versionedResources,selectedVersions),ImmutableMap.of(),ImmutableSet.of(),args.zipSafe);
      return Optional.of(components).map(metadataClass::cast);
    }
case PACKAGE_DEPS:
{
    Map.Entry<Flavor,PythonPlatform> pythonPlatform=pythonPlatforms.getFlavorAndValue(baseTarget).orElseThrow(IllegalArgumentException::new);
    Map.Entry<Flavor,CxxPlatform> cxxPlatform=cxxPlatforms.getFlavorAndValue(baseTarget).orElseThrow(IllegalArgumentException::new);
    baseTarget=buildTarget.withoutFlavors(pythonPlatform.getKey(),cxxPlatform.getKey());
    ImmutableList<BuildTarget> depTargets=PythonUtil.getDeps(pythonPlatform.getValue(),cxxPlatform.getValue(),args.deps,args.platformDeps);
    return Optional.of(resolver.getAllRules(depTargets)).map(metadataClass::cast);
  }
}
throw new IllegalStateException();
}",0.96108220603538
52967,"@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  boolean first=true;
  if (isSetCellName()) {
    sb.append(""String_Node_Str"");
    if (this.cellName == null) {
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(this.cellName);
    }
    first=false;
  }
  if (!first)   sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  if (this.baseName == null) {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(this.baseName);
  }
  first=false;
  if (!first)   sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  if (this.shortName == null) {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(this.shortName);
  }
  first=false;
  if (!first)   sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  if (this.flavors == null) {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(this.flavors);
  }
  first=false;
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  boolean first=true;
  if (isSetCellName()) {
    sb.append(""String_Node_Str"");
    if (this.cellName == null) {
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(this.cellName);
    }
    first=false;
  }
  if (isSetBaseName()) {
    if (!first)     sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (this.baseName == null) {
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(this.baseName);
    }
    first=false;
  }
  if (isSetShortName()) {
    if (!first)     sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (this.shortName == null) {
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(this.shortName);
    }
    first=false;
  }
  if (isSetFlavors()) {
    if (!first)     sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (this.flavors == null) {
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(this.flavors);
    }
    first=false;
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.5902415916627191
52968,"@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  boolean first=true;
  sb.append(""String_Node_Str"");
  if (this.path == null) {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(this.path);
  }
  first=false;
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  boolean first=true;
  if (isSetPath()) {
    sb.append(""String_Node_Str"");
    if (this.path == null) {
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(this.path);
    }
    first=false;
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.8433382137628112
52969,"private List<PathWithUnixSeparators> processDirectory(Path path,Queue<Path> remainingPaths) throws IOException {
  List<PathWithUnixSeparators> childrenRelativePaths=new ArrayList<>();
  for (  Path relativeChildPath : projectFilesystem.getDirectoryContents(path)) {
    childrenRelativePaths.add(new PathWithUnixSeparators(MorePaths.pathWithUnixSeparators(relativeChildPath)));
    remainingPaths.add(relativeChildPath);
  }
  return childrenRelativePaths;
}","private List<PathWithUnixSeparators> processDirectory(Path path,Queue<Path> remainingPaths) throws IOException {
  List<PathWithUnixSeparators> childrenRelativePaths=new ArrayList<>();
  for (  Path relativeChildPath : projectFilesystem.getDirectoryContents(path)) {
    childrenRelativePaths.add(new PathWithUnixSeparators().setPath(MorePaths.pathWithUnixSeparators(relativeChildPath)));
    remainingPaths.add(relativeChildPath);
  }
  return childrenRelativePaths;
}",0.9892241379310344
52970,"private synchronized void record(Path relPath,Optional<String> memRelPath,HashCode hashCode,List<PathWithUnixSeparators> children){
  LOG.verbose(""String_Node_Str"",projectFilesystem.resolve(relPath).toAbsolutePath());
  Optional<Path> pathRelativeToProjectRoot=projectFilesystem.getPathRelativeToProjectRoot(relPath);
  BuildJobStateFileHashEntry fileHashEntry=new BuildJobStateFileHashEntry();
  boolean pathIsAbsolute=allRecordedPathsAreAbsolute;
  fileHashEntry.setPathIsAbsolute(pathIsAbsolute);
  Path entryKey=pathIsAbsolute ? projectFilesystem.resolve(relPath).toAbsolutePath() : pathRelativeToProjectRoot.get();
  boolean isDirectory=projectFilesystem.isDirectory(relPath);
  Path realPath=findRealPath(relPath);
  boolean realPathInsideProject=projectFilesystem.getPathRelativeToProjectRoot(realPath).isPresent();
  if (!realPathInsideProject && !pathIsAbsolute) {
    Pair<Path,Path> symLinkRootAndTarget=findSymlinkRoot(projectFilesystem.resolve(relPath).toAbsolutePath());
    Path symLinkRoot=projectFilesystem.getPathRelativeToProjectRoot(symLinkRootAndTarget.getFirst()).get();
    fileHashEntry.setRootSymLink(new PathWithUnixSeparators(MorePaths.pathWithUnixSeparators(symLinkRoot)));
    fileHashEntry.setRootSymLinkTarget(new PathWithUnixSeparators(MorePaths.pathWithUnixSeparators(symLinkRootAndTarget.getSecond().toAbsolutePath())));
  }
  fileHashEntry.setIsDirectory(isDirectory);
  fileHashEntry.setHashCode(hashCode.toString());
  fileHashEntry.setPath(new PathWithUnixSeparators(MorePaths.pathWithUnixSeparators(entryKey)));
  if (memRelPath.isPresent()) {
    fileHashEntry.setArchiveMemberPath(memRelPath.get().toString());
  }
  if (!isDirectory && !pathIsAbsolute && realPathInsideProject) {
    try {
      Path absPath=projectFilesystem.resolve(relPath).toAbsolutePath();
      fileHashEntry.setContents(Files.readAllBytes(absPath));
      fileHashEntry.setIsExecutable(absPath.toFile().canExecute());
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
 else   if (isDirectory && !pathIsAbsolute && realPathInsideProject) {
    fileHashEntry.setChildren(children);
  }
  fileHashEntry.setMaterializeDuringPreloading(materializeCurrentFileDuringPreloading);
  remoteFileHashes.addEntry(fileHashEntry);
}","private synchronized void record(Path relPath,Optional<String> memRelPath,HashCode hashCode,List<PathWithUnixSeparators> children){
  LOG.verbose(""String_Node_Str"",projectFilesystem.resolve(relPath).toAbsolutePath());
  Optional<Path> pathRelativeToProjectRoot=projectFilesystem.getPathRelativeToProjectRoot(relPath);
  BuildJobStateFileHashEntry fileHashEntry=new BuildJobStateFileHashEntry();
  boolean pathIsAbsolute=allRecordedPathsAreAbsolute;
  fileHashEntry.setPathIsAbsolute(pathIsAbsolute);
  Path entryKey=pathIsAbsolute ? projectFilesystem.resolve(relPath).toAbsolutePath() : pathRelativeToProjectRoot.get();
  boolean isDirectory=projectFilesystem.isDirectory(relPath);
  Path realPath=findRealPath(relPath);
  boolean realPathInsideProject=projectFilesystem.getPathRelativeToProjectRoot(realPath).isPresent();
  if (!realPathInsideProject && !pathIsAbsolute) {
    Pair<Path,Path> symLinkRootAndTarget=findSymlinkRoot(projectFilesystem.resolve(relPath).toAbsolutePath());
    Path symLinkRoot=projectFilesystem.getPathRelativeToProjectRoot(symLinkRootAndTarget.getFirst()).get();
    fileHashEntry.setRootSymLink(new PathWithUnixSeparators().setPath(MorePaths.pathWithUnixSeparators(symLinkRoot)));
    fileHashEntry.setRootSymLinkTarget(new PathWithUnixSeparators().setPath(MorePaths.pathWithUnixSeparators(symLinkRootAndTarget.getSecond().toAbsolutePath())));
  }
  fileHashEntry.setIsDirectory(isDirectory);
  fileHashEntry.setHashCode(hashCode.toString());
  fileHashEntry.setPath(new PathWithUnixSeparators().setPath(MorePaths.pathWithUnixSeparators(entryKey)));
  if (memRelPath.isPresent()) {
    fileHashEntry.setArchiveMemberPath(memRelPath.get().toString());
  }
  if (!isDirectory && !pathIsAbsolute && realPathInsideProject) {
    try {
      Path absPath=projectFilesystem.resolve(relPath).toAbsolutePath();
      fileHashEntry.setContents(Files.readAllBytes(absPath));
      fileHashEntry.setIsExecutable(absPath.toFile().canExecute());
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
 else   if (isDirectory && !pathIsAbsolute && realPathInsideProject) {
    fileHashEntry.setChildren(children);
  }
  fileHashEntry.setMaterializeDuringPreloading(materializeCurrentFileDuringPreloading);
  remoteFileHashes.addEntry(fileHashEntry);
}",0.993421052631579
52971,"@Test public void canUploadFiles() throws Exception {
  final List<Boolean> fileExistence=Arrays.asList(true,false,true);
  Capture<FrontendRequest> containsRequest=EasyMock.newCapture();
  FrontendResponse containsResponse=new FrontendResponse();
  containsResponse.setType(FrontendRequestType.CAS_CONTAINS);
  CASContainsResponse casContainsResponse=new CASContainsResponse();
  casContainsResponse.setExists(fileExistence);
  containsResponse.setCasContainsResponse(casContainsResponse);
  containsResponse.setWasSuccessful(true);
  EasyMock.expect(frontendService.makeRequest(EasyMock.capture(containsRequest))).andReturn(containsResponse).once();
  Capture<FrontendRequest> storeRequest=EasyMock.newCapture();
  FrontendResponse storeResponse=new FrontendResponse();
  storeResponse.setType(FrontendRequestType.STORE_LOCAL_CHANGES);
  storeResponse.setWasSuccessful(true);
  EasyMock.expect(frontendService.makeRequest(EasyMock.capture(storeRequest))).andReturn(storeResponse).once();
  EasyMock.replay(frontendService);
  BuildJobStateFileHashEntry files[]=new BuildJobStateFileHashEntry[3];
  for (int i=0; i < 3; i++) {
    files[i]=new BuildJobStateFileHashEntry();
    files[i].setHashCode(Integer.toString(i));
    files[i].setContents((""String_Node_Str"" + Integer.toString(i)).getBytes());
    files[i].setPath(new PathWithUnixSeparators(""String_Node_Str"" + i));
  }
  List<BuildJobStateFileHashes> fileHashes=new ArrayList<>();
  fileHashes.add(new BuildJobStateFileHashes());
  fileHashes.get(0).setCellIndex(0);
  fileHashes.get(0).setEntries(new ArrayList<BuildJobStateFileHashEntry>());
  fileHashes.get(0).getEntries().add(files[0]);
  fileHashes.get(0).getEntries().add(files[1]);
  fileHashes.add(new BuildJobStateFileHashes());
  fileHashes.get(1).setCellIndex(1);
  fileHashes.get(1).setEntries(new ArrayList<BuildJobStateFileHashEntry>());
  fileHashes.get(1).getEntries().add(files[2]);
  distBuildService.uploadMissingFilesAsync(fileHashes,executor).get();
  Assert.assertEquals(containsRequest.getValue().getType(),FrontendRequestType.CAS_CONTAINS);
  Assert.assertTrue(containsRequest.getValue().isSetCasContainsRequest());
  Assert.assertTrue(containsRequest.getValue().getCasContainsRequest().isSetContentSha1s());
  Assert.assertEquals(new HashSet<String>(containsRequest.getValue().getCasContainsRequest().getContentSha1s()),new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  Assert.assertEquals(storeRequest.getValue().getType(),FrontendRequestType.STORE_LOCAL_CHANGES);
  Assert.assertTrue(storeRequest.getValue().isSetStoreLocalChangesRequest());
  Assert.assertTrue(storeRequest.getValue().getStoreLocalChangesRequest().isSetFiles());
  Assert.assertEquals(storeRequest.getValue().getStoreLocalChangesRequest().getFiles().size(),1);
  Assert.assertEquals(storeRequest.getValue().getStoreLocalChangesRequest().getFiles().get(0).getContentHash(),""String_Node_Str"");
  Assert.assertTrue(Arrays.equals(storeRequest.getValue().getStoreLocalChangesRequest().getFiles().get(0).getContent(),""String_Node_Str"".getBytes()));
}","@Test public void canUploadFiles() throws Exception {
  final List<Boolean> fileExistence=Arrays.asList(true,false,true);
  Capture<FrontendRequest> containsRequest=EasyMock.newCapture();
  FrontendResponse containsResponse=new FrontendResponse();
  containsResponse.setType(FrontendRequestType.CAS_CONTAINS);
  CASContainsResponse casContainsResponse=new CASContainsResponse();
  casContainsResponse.setExists(fileExistence);
  containsResponse.setCasContainsResponse(casContainsResponse);
  containsResponse.setWasSuccessful(true);
  EasyMock.expect(frontendService.makeRequest(EasyMock.capture(containsRequest))).andReturn(containsResponse).once();
  Capture<FrontendRequest> storeRequest=EasyMock.newCapture();
  FrontendResponse storeResponse=new FrontendResponse();
  storeResponse.setType(FrontendRequestType.STORE_LOCAL_CHANGES);
  storeResponse.setWasSuccessful(true);
  EasyMock.expect(frontendService.makeRequest(EasyMock.capture(storeRequest))).andReturn(storeResponse).once();
  EasyMock.replay(frontendService);
  BuildJobStateFileHashEntry files[]=new BuildJobStateFileHashEntry[3];
  for (int i=0; i < 3; i++) {
    files[i]=new BuildJobStateFileHashEntry();
    files[i].setHashCode(Integer.toString(i));
    files[i].setContents((""String_Node_Str"" + Integer.toString(i)).getBytes());
    files[i].setPath(new PathWithUnixSeparators().setPath(""String_Node_Str"" + i));
  }
  List<BuildJobStateFileHashes> fileHashes=new ArrayList<>();
  fileHashes.add(new BuildJobStateFileHashes());
  fileHashes.get(0).setCellIndex(0);
  fileHashes.get(0).setEntries(new ArrayList<BuildJobStateFileHashEntry>());
  fileHashes.get(0).getEntries().add(files[0]);
  fileHashes.get(0).getEntries().add(files[1]);
  fileHashes.add(new BuildJobStateFileHashes());
  fileHashes.get(1).setCellIndex(1);
  fileHashes.get(1).setEntries(new ArrayList<BuildJobStateFileHashEntry>());
  fileHashes.get(1).getEntries().add(files[2]);
  distBuildService.uploadMissingFilesAsync(fileHashes,executor).get();
  Assert.assertEquals(containsRequest.getValue().getType(),FrontendRequestType.CAS_CONTAINS);
  Assert.assertTrue(containsRequest.getValue().isSetCasContainsRequest());
  Assert.assertTrue(containsRequest.getValue().getCasContainsRequest().isSetContentSha1s());
  Assert.assertEquals(new HashSet<String>(containsRequest.getValue().getCasContainsRequest().getContentSha1s()),new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  Assert.assertEquals(storeRequest.getValue().getType(),FrontendRequestType.STORE_LOCAL_CHANGES);
  Assert.assertTrue(storeRequest.getValue().isSetStoreLocalChangesRequest());
  Assert.assertTrue(storeRequest.getValue().getStoreLocalChangesRequest().isSetFiles());
  Assert.assertEquals(storeRequest.getValue().getStoreLocalChangesRequest().getFiles().size(),1);
  Assert.assertEquals(storeRequest.getValue().getStoreLocalChangesRequest().getFiles().get(0).getContentHash(),""String_Node_Str"");
  Assert.assertTrue(Arrays.equals(storeRequest.getValue().getStoreLocalChangesRequest().getFiles().get(0).getContent(),""String_Node_Str"".getBytes()));
}",0.9983865763149404
52972,"private static PathWithUnixSeparators unixPath(Path path){
  return new PathWithUnixSeparators(MorePaths.pathWithUnixSeparators(path));
}","private static PathWithUnixSeparators unixPath(Path path){
  return new PathWithUnixSeparators().setPath(MorePaths.pathWithUnixSeparators(path));
}",0.9647887323943662
52973,"private static PathWithUnixSeparators unixPath(String path){
  return new PathWithUnixSeparators(MorePaths.pathWithUnixSeparators(path));
}","private static PathWithUnixSeparators unixPath(String path){
  return new PathWithUnixSeparators().setPath(MorePaths.pathWithUnixSeparators(path));
}",0.9652777777777778
52974,"public Optional<String> getValue(String sectionName,String propertyName){
  return config.getValue(sectionName,propertyName);
}","/** 
 * @return the string value for the config settings, where present empty values are{@code Optional.empty()}.
 */
public Optional<String> getValue(String sectionName,String propertyName){
  return config.getValue(sectionName,propertyName);
}",0.6827956989247311
52975,"void invalidateIfBuckConfigHasChanged(Cell cell,Path buildFile){
  ImmutableMap<String,ImmutableMap<String,Optional<String>>> usedConfigs;
  try (AutoCloseableLock readLock=rawAndComputedNodesLock.readLock()){
    usedConfigs=buildFileConfigs.get(buildFile);
  }
   if (usedConfigs == null) {
    this.cell.set(cell);
    return;
  }
  for (  Map.Entry<String,ImmutableMap<String,Optional<String>>> keyEnt : usedConfigs.entrySet()) {
    for (    Map.Entry<String,Optional<String>> valueEnt : keyEnt.getValue().entrySet()) {
      Optional<String> value=cell.getBuckConfig().getValue(keyEnt.getKey(),valueEnt.getKey());
      if (!value.equals(valueEnt.getValue())) {
        invalidatePath(buildFile);
        this.cell.set(cell);
        return;
      }
    }
  }
}","void invalidateIfBuckConfigHasChanged(Cell cell,Path buildFile){
  ImmutableMap<String,ImmutableMap<String,Optional<String>>> usedConfigs;
  try (AutoCloseableLock readLock=rawAndComputedNodesLock.readLock()){
    usedConfigs=buildFileConfigs.get(buildFile);
  }
   if (usedConfigs == null) {
    this.cell.set(cell);
    return;
  }
  for (  Map.Entry<String,ImmutableMap<String,Optional<String>>> keyEnt : usedConfigs.entrySet()) {
    for (    Map.Entry<String,Optional<String>> valueEnt : keyEnt.getValue().entrySet()) {
      Optional<String> value=cell.getBuckConfig().getRawValue(keyEnt.getKey(),valueEnt.getKey());
      if (!value.equals(valueEnt.getValue())) {
        invalidatePath(buildFile);
        this.cell.set(cell);
        return;
      }
    }
  }
}",0.9980481457384516
52976,"@Override public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {
  Stopwatch stopwatch=Stopwatch.createStarted();
  Console console=params.getConsole();
  try (DistBuildService service=DistBuildFactory.newDistBuildService(params)){
    Pair<BuildJobState,String> jobStateAndBuildName=getBuildJobStateAndBuildName(params.getCell().getFilesystem(),console,service);
    BuildJobState jobState=jobStateAndBuildName.getFirst();
    String buildName=jobStateAndBuildName.getSecond();
    console.getStdOut().println(String.format(""String_Node_Str"",jobState.getFileHashesSize()));
    try (CommandThreadManager pool=new CommandThreadManager(getClass().getName(),getConcurrencyLimit(params.getBuckConfig()))){
      DistBuildSlaveExecutor distBuildExecutor=DistBuildFactory.createDistBuildExecutor(jobState,params,pool.getExecutor(),service,Preconditions.checkNotNull(distBuildMode),coordinatorPort,getStampedeIdOptional(),getGlobalCacheDirOptional());
      int returnCode=distBuildExecutor.buildAndReturnExitCode();
      console.printSuccess(String.format(""String_Node_Str"",buildName,stopwatch.elapsed(TimeUnit.MILLISECONDS)));
      return returnCode;
    }
   }
 }","@Override public int runWithoutHelp(CommandRunnerParams params) throws IOException, InterruptedException {
  Stopwatch stopwatch=Stopwatch.createStarted();
  Console console=params.getConsole();
  try (DistBuildService service=DistBuildFactory.newDistBuildService(params)){
    Pair<BuildJobState,String> jobStateAndBuildName=getBuildJobStateAndBuildName(params.getCell().getFilesystem(),console,service);
    BuildJobState jobState=jobStateAndBuildName.getFirst();
    String buildName=jobStateAndBuildName.getSecond();
    console.getStdOut().println(String.format(""String_Node_Str"",jobState.getFileHashesSize()));
    try (CommandThreadManager pool=new CommandThreadManager(getClass().getName(),getConcurrencyLimit(params.getBuckConfig()))){
      DistBuildSlaveExecutor distBuildExecutor=DistBuildFactory.createDistBuildExecutor(jobState,params,pool.getExecutor(),service,Preconditions.checkNotNull(distBuildMode),coordinatorPort,getStampedeIdOptional(),getGlobalCacheDirOptional());
      int returnCode=distBuildExecutor.buildAndReturnExitCode();
      if (returnCode == 0) {
        console.printSuccess(String.format(""String_Node_Str"",buildName,stopwatch.elapsed(TimeUnit.MILLISECONDS)));
      }
 else {
        console.printErrorText(""String_Node_Str"",buildName,stopwatch.elapsed(TimeUnit.MILLISECONDS));
      }
      return returnCode;
    }
   }
 }",0.9255360623781675
52977,"public List<BuildJobStateFileHashes> getFileHashes() throws IOException, InterruptedException {
  try {
    return fileHashes.get().stream().filter(x -> x.getEntriesSize() > 0).collect(Collectors.toList());
  }
 catch (  ExecutionException e) {
    Throwables.throwIfInstanceOf(e.getCause(),IOException.class);
    Throwables.throwIfInstanceOf(e.getCause(),InterruptedException.class);
    throw new RuntimeException(e.getCause());
  }
}","public List<BuildJobStateFileHashes> getFileHashes() throws IOException, InterruptedException {
  try {
    return fileHashes.get();
  }
 catch (  ExecutionException e) {
    Throwables.throwIfInstanceOf(e.getCause(),IOException.class);
    Throwables.throwIfInstanceOf(e.getCause(),InterruptedException.class);
    throw new RuntimeException(e.getCause());
  }
}",0.3575
52978,"private DistBuildCachingEngineDelegate createBuildEngineDelegate() throws IOException, InterruptedException {
  if (cachingBuildEngineDelegate != null) {
    return cachingBuildEngineDelegate;
  }
  ImmutableList.Builder<MaterializerProjectFileHashCache> allCachesBuilder=ImmutableList.builder();
  Cell rootCell=args.getState().getRootCell();
  for (  Path cellPath : rootCell.getKnownRoots()) {
    Cell cell=rootCell.getCell(cellPath);
    allCachesBuilder.add(args.getState().createMaterializer(cell.getFilesystem(),args.getProvider()));
  }
  allCachesBuilder.add(args.getState().createMaterializer(rootCell.getFilesystem(),args.getProvider()));
  ImmutableList<MaterializerProjectFileHashCache> allCaches=allCachesBuilder.build();
  StackedFileHashCache stackedFileHashCache=new StackedFileHashCache(allCaches);
  for (  MaterializerProjectFileHashCache materializer : allCaches) {
    materializer.preloadAllFiles();
  }
  createActionGraphAndResolver();
  SourcePathRuleFinder ruleFinder=new SourcePathRuleFinder(Preconditions.checkNotNull(actionGraphAndResolver).getResolver());
  cachingBuildEngineDelegate=new DistBuildCachingEngineDelegate(new SourcePathResolver(ruleFinder),ruleFinder,args.getState(),stackedFileHashCache);
  return cachingBuildEngineDelegate;
}","private DistBuildCachingEngineDelegate createBuildEngineDelegate() throws IOException, InterruptedException {
  if (cachingBuildEngineDelegate != null) {
    return cachingBuildEngineDelegate;
  }
  ImmutableList.Builder<ProjectFileHashCache> allCachesBuilder=ImmutableList.builder();
  Cell rootCell=args.getState().getRootCell();
  for (  Path cellPath : rootCell.getKnownRoots()) {
    Cell cell=rootCell.getCell(cellPath);
    allCachesBuilder.add(args.getState().createMaterializer(cell.getFilesystem(),args.getProvider()));
  }
  allCachesBuilder.addAll(DefaultFileHashCache.createOsRootDirectoriesCaches());
  StackedFileHashCache stackedFileHashCache=new StackedFileHashCache(allCachesBuilder.build());
  createActionGraphAndResolver();
  SourcePathRuleFinder ruleFinder=new SourcePathRuleFinder(Preconditions.checkNotNull(actionGraphAndResolver).getResolver());
  cachingBuildEngineDelegate=new DistBuildCachingEngineDelegate(new SourcePathResolver(ruleFinder),ruleFinder,args.getState(),stackedFileHashCache);
  return cachingBuildEngineDelegate;
}",0.7801114444920703
52979,"public MaterializerProjectFileHashCache createMaterializer(ProjectFilesystem projectFilesystem,FileContentsProvider provider){
  BuildJobStateFileHashes remoteFileHashes=Preconditions.checkNotNull(fileHashes.get(projectFilesystem),""String_Node_Str"",projectFilesystem);
  return new MaterializerProjectFileHashCache(projectFilesystem,remoteFileHashes,provider,new StackedFileHashCache(loadDirectFileHashCache(projectFilesystem)));
}","public MaterializerProjectFileHashCache createMaterializer(ProjectFilesystem projectFilesystem,FileContentsProvider provider) throws IOException {
  BuildJobStateFileHashes remoteFileHashes=Preconditions.checkNotNull(fileHashes.get(projectFilesystem),""String_Node_Str"",projectFilesystem);
  MaterializerProjectFileHashCache materializer=new MaterializerProjectFileHashCache(projectFilesystem,remoteFileHashes,provider,new StackedFileHashCache(loadDirectFileHashCache(projectFilesystem)));
  materializer.preloadAllFiles();
  return materializer;
}",0.5746421267893661
52980,"@Test public void worksCrossCell() throws Exception {
  final Fixture f=new Fixture(tempDir){
    @Override protected void setUpRules(    BuildRuleResolver resolver,    SourcePathResolver sourcePathResolver) throws Exception {
      Path firstPath=javaFs.getPath(""String_Node_Str"",""String_Node_Str"");
      projectFilesystem.createParentDirs(firstPath);
      projectFilesystem.writeContentsToPath(""String_Node_Str"",firstPath);
      Path secondPath=secondJavaFs.getPath(""String_Node_Str"");
      secondProjectFilesystem.writeContentsToPath(""String_Node_Str"",secondPath);
      JavaLibraryBuilder.createBuilder(BuildTargetFactory.newInstance(projectFilesystem,""String_Node_Str""),projectFilesystem).addSrc(firstPath).build(resolver,projectFilesystem);
      JavaLibraryBuilder.createBuilder(BuildTargetFactory.newInstance(secondProjectFilesystem,""String_Node_Str""),secondProjectFilesystem).addSrc(secondPath).build(resolver,secondProjectFilesystem);
    }
    @Override protected BuckConfig createBuckConfig(){
      return FakeBuckConfig.builder().setSections(""String_Node_Str"",""String_Node_Str"" + secondProjectFilesystem.getRootPath().toAbsolutePath()).build();
    }
  }
;
  List<BuildJobStateFileHashes> recordedHashes=f.distributedBuildFileHashes.getFileHashes();
  ImmutableBiMap<Path,Integer> cellIndex=f.cellIndexer.getIndex();
  assertThat(recordedHashes,Matchers.hasSize(2));
  for (  BuildJobStateFileHashes hashes : recordedHashes) {
    Path cellPath=cellIndex.inverse().get(hashes.getCellIndex());
    if (cellPath.equals(f.projectFilesystem.getRootPath())) {
      assertThat(toFileHashEntryIndex(hashes),Matchers.hasKey(new PathWithUnixSeparators(""String_Node_Str"")));
    }
 else     if (cellPath.equals(f.secondProjectFilesystem.getRootPath())) {
      assertThat(toFileHashEntryIndex(hashes),Matchers.hasKey(new PathWithUnixSeparators(""String_Node_Str"")));
    }
 else {
      fail(""String_Node_Str"" + cellPath);
    }
    assertEquals(hashes.getEntriesSize(),1);
    for (    BuildJobStateFileHashEntry hashEntry : hashes.getEntries()) {
      assertFalse(hashEntry.isPathIsAbsolute());
    }
  }
}","@Test public void worksCrossCell() throws Exception {
  final Fixture f=new Fixture(tempDir){
    @Override protected void setUpRules(    BuildRuleResolver resolver,    SourcePathResolver sourcePathResolver) throws Exception {
      Path firstPath=javaFs.getPath(""String_Node_Str"",""String_Node_Str"");
      projectFilesystem.createParentDirs(firstPath);
      projectFilesystem.writeContentsToPath(""String_Node_Str"",firstPath);
      Path secondPath=secondJavaFs.getPath(""String_Node_Str"");
      secondProjectFilesystem.writeContentsToPath(""String_Node_Str"",secondPath);
      JavaLibraryBuilder.createBuilder(BuildTargetFactory.newInstance(projectFilesystem,""String_Node_Str""),projectFilesystem).addSrc(firstPath).build(resolver,projectFilesystem);
      JavaLibraryBuilder.createBuilder(BuildTargetFactory.newInstance(secondProjectFilesystem,""String_Node_Str""),secondProjectFilesystem).addSrc(secondPath).build(resolver,secondProjectFilesystem);
    }
    @Override protected BuckConfig createBuckConfig(){
      return FakeBuckConfig.builder().setSections(""String_Node_Str"",""String_Node_Str"" + secondProjectFilesystem.getRootPath().toAbsolutePath()).build();
    }
  }
;
  List<BuildJobStateFileHashes> recordedHashes=f.distributedBuildFileHashes.getFileHashes();
  assertThat(recordedHashes,Matchers.hasSize(3));
  BuildJobStateFileHashes rootCellHash=getRootCellHashes(recordedHashes);
  Assert.assertEquals(1,rootCellHash.getEntriesSize());
  Assert.assertEquals(""String_Node_Str"",rootCellHash.getEntries().get(0).getPath().getPath());
  BuildJobStateFileHashes secondaryCellHashes=getCellHashesByIndex(recordedHashes,1);
  Assert.assertEquals(1,secondaryCellHashes.getEntriesSize());
  Assert.assertEquals(""String_Node_Str"",secondaryCellHashes.getEntries().get(0).getPath().getPath());
}",0.7269938650306749
52981,"@Test public void recordsFileHashes() throws Exception {
  SingleFileFixture f=new SingleFileFixture(tempDir);
  List<BuildJobStateFileHashes> recordedHashes=f.distributedBuildFileHashes.getFileHashes();
  assertThat(recordedHashes,Matchers.hasSize(1));
  BuildJobStateFileHashes hashes=recordedHashes.get(0);
  assertThat(hashes.entries,Matchers.hasSize(1));
  BuildJobStateFileHashEntry fileHashEntry=hashes.entries.get(0);
  assertThat(fileHashEntry.getPath().getPath(),Matchers.equalTo(""String_Node_Str""));
  assertFalse(fileHashEntry.isPathIsAbsolute());
  assertFalse(fileHashEntry.isIsDirectory());
}","@Test public void recordsFileHashes() throws Exception {
  SingleFileFixture f=new SingleFileFixture(tempDir);
  List<BuildJobStateFileHashes> recordedHashes=f.distributedBuildFileHashes.getFileHashes();
  assertThat(recordedHashes,Matchers.hasSize(3));
  BuildJobStateFileHashes rootCellHashes=getRootCellHashes(recordedHashes);
  assertThat(rootCellHashes.entries,Matchers.hasSize(1));
  BuildJobStateFileHashEntry fileHashEntry=rootCellHashes.entries.get(0);
  assertThat(fileHashEntry.getPath().getPath(),Matchers.equalTo(""String_Node_Str""));
  assertFalse(fileHashEntry.isPathIsAbsolute());
  assertFalse(fileHashEntry.isIsDirectory());
}",0.9328
52982,"@Test public void recordsArchiveHashes() throws Exception {
  try (ArchiveFilesFixture f=ArchiveFilesFixture.create(archiveTempDir)){
    List<BuildJobStateFileHashes> recordedHashes=f.distributedBuildFileHashes.getFileHashes();
    assertThat(recordedHashes,Matchers.hasSize(1));
    BuildJobStateFileHashes hashes=recordedHashes.get(0);
    assertThat(hashes.entries,Matchers.hasSize(1));
    BuildJobStateFileHashEntry fileHashEntry=hashes.entries.get(0);
    assertThat(fileHashEntry.getPath().getPath(),Matchers.equalTo(""String_Node_Str""));
    assertTrue(fileHashEntry.isSetArchiveMemberPath());
    assertThat(fileHashEntry.getArchiveMemberPath(),Matchers.equalTo(""String_Node_Str""));
    assertFalse(fileHashEntry.isPathIsAbsolute());
    assertFalse(fileHashEntry.isIsDirectory());
  }
 }","@Test public void recordsArchiveHashes() throws Exception {
  try (ArchiveFilesFixture f=ArchiveFilesFixture.create(archiveTempDir)){
    List<BuildJobStateFileHashes> recordedHashes=f.distributedBuildFileHashes.getFileHashes();
    assertThat(recordedHashes,Matchers.hasSize(3));
    BuildJobStateFileHashes hashes=getRootCellHashes(recordedHashes);
    assertThat(hashes.entries,Matchers.hasSize(1));
    BuildJobStateFileHashEntry fileHashEntry=hashes.entries.get(0);
    assertThat(fileHashEntry.getPath().getPath(),Matchers.equalTo(""String_Node_Str""));
    assertTrue(fileHashEntry.isSetArchiveMemberPath());
    assertThat(fileHashEntry.getArchiveMemberPath(),Matchers.equalTo(""String_Node_Str""));
    assertFalse(fileHashEntry.isPathIsAbsolute());
    assertFalse(fileHashEntry.isIsDirectory());
  }
 }",0.9701120797011208
52983,"@SuppressWarnings(""String_Node_Str"") private void submitTraceEvent(final ChromeTraceEvent chromeTraceEvent){
  outputExecutor.submit(new Callable<Void>(){
    @Override public Void call() throws Exception {
      try {
        mapper.writeValue(jsonGenerator,chromeTraceEvent);
      }
 catch (      IOException e) {
      }
      return null;
    }
  }
);
}","@SuppressWarnings(""String_Node_Str"") private void submitTraceEvent(final ChromeTraceEvent chromeTraceEvent){
  @SuppressWarnings(""String_Node_Str"") Future<?> unused=outputExecutor.submit(() -> {
    try {
      mapper.writeValue(jsonGenerator,chromeTraceEvent);
    }
 catch (    IOException e) {
    }
    return null;
  }
);
}",0.7667638483965015
52984,"@Override public void outputTrace(BuildId buildId) throws InterruptedException {
  executor.submit(() -> {
    try {
      outputStream.write(String.format(""String_Node_Str"",exitCode.orElse(-1)).getBytes(Charsets.UTF_8));
      outputStream.close();
    }
 catch (    IOException e) {
      LOG.warn(""String_Node_Str"");
    }
  }
);
  executor.shutdown();
  if (!executor.awaitTermination(SHUTDOWN_TIMEOUT_SECONDS,TimeUnit.SECONDS)) {
    String error=""String_Node_Str"";
    LOG.error(error);
  }
}","@Override public void outputTrace(BuildId buildId) throws InterruptedException {
  @SuppressWarnings(""String_Node_Str"") Future<?> unused=executor.submit(() -> {
    try {
      outputStream.write(String.format(""String_Node_Str"",exitCode.orElse(-1)).getBytes(Charsets.UTF_8));
      outputStream.close();
    }
 catch (    IOException e) {
      LOG.warn(""String_Node_Str"");
    }
  }
);
  executor.shutdown();
  if (!executor.awaitTermination(SHUTDOWN_TIMEOUT_SECONDS,TimeUnit.SECONDS)) {
    String error=""String_Node_Str"";
    LOG.error(error);
  }
}",0.9485714285714286
52985,"private void scheduleDownloadSpeedCalculation(){
  long calculationInterval=DOWNLOAD_SPEED_CALCULATION_INTERVAL.toMillis();
  TimeUnit timeUnit=TimeUnit.MILLISECONDS;
  scheduler.scheduleAtFixedRate(this::calculateDownloadSpeedInLastInterval,calculationInterval,calculationInterval,timeUnit);
}","private void scheduleDownloadSpeedCalculation(){
  long calculationInterval=DOWNLOAD_SPEED_CALCULATION_INTERVAL.toMillis();
  TimeUnit timeUnit=TimeUnit.MILLISECONDS;
  @SuppressWarnings(""String_Node_Str"") ScheduledFuture<?> unused=scheduler.scheduleAtFixedRate(this::calculateDownloadSpeedInLastInterval,calculationInterval,calculationInterval,timeUnit);
}",0.9032258064516128
52986,"private void flushLogLinesIfNeeded(){
  if (logLinesCount > minLinesForAutoFlush) {
    outputExecutor.submit(new Callable<Void>(){
      @Override public Void call() throws Exception {
        try {
          flushLogLines();
        }
 catch (        IOException e) {
          LOG.error(e,""String_Node_Str"");
        }
        return null;
      }
    }
);
  }
}","private void flushLogLinesIfNeeded(){
  if (logLinesCount > minLinesForAutoFlush) {
    @SuppressWarnings(""String_Node_Str"") Future<?> unused=outputExecutor.submit(() -> {
      try {
        flushLogLines();
      }
 catch (      IOException e) {
        LOG.error(e,""String_Node_Str"");
      }
      return null;
    }
);
  }
}",0.6368876080691642
52987,"private void flushLogLines() throws IOException {
  List<String> linesToFlush;
synchronized (lock) {
    linesToFlush=logLines;
    logLines=Lists.newArrayList();
    logLinesCount=logLines.size();
  }
  if (linesToFlush.isEmpty()) {
    return;
  }
  Path logFile=getLogFilePath();
  projectFilesystem.createParentDirs(logFile);
  try (FileOutputStream stream=new FileOutputStream(logFile.toString(),true);PrintWriter writer=new PrintWriter(stream)){
    for (    String line : linesToFlush) {
      writer.println(line);
    }
  }
 }","private void flushLogLines() throws IOException {
  List<String> linesToFlush;
synchronized (lock) {
    linesToFlush=logLines;
    logLines=Lists.newArrayList();
    logLinesCount=logLines.size();
  }
  if (linesToFlush.isEmpty()) {
    return;
  }
  Path logFile=getLogFilePath();
  projectFilesystem.createParentDirs(logFile);
  try (FileOutputStream stream=new FileOutputStream(logFile.toString(),true);OutputStreamWriter streamWriter=new OutputStreamWriter(stream,StandardCharsets.UTF_8);PrintWriter writer=new PrintWriter(streamWriter)){
    for (    String line : linesToFlush) {
      writer.println(line);
    }
  }
 }",0.9208261617900172
52988,"@Override public void assertInProjectFilesystem(Object ruleName,ProjectFilesystem projectFilesystem){
  Preconditions.checkState(projectFilesystem == this.projectFilesystem,""String_Node_Str"" + ""String_Node_Str"",ruleName,this.projectFilesystem.getRootPath(),projectFilesystem.getRootPath());
}","@Override public void assertInProjectFilesystem(Object ruleName,ProjectFilesystem projectFilesystem){
  Preconditions.checkState(this.projectFilesystem.getRootPath().equals(projectFilesystem.getRootPath()),""String_Node_Str"" + ""String_Node_Str"",ruleName,this.projectFilesystem.getRootPath(),projectFilesystem.getRootPath());
}",0.807131280388979
52989,"@Override public void run() throws Throwable {
  Level stdOutLogLevel=Level.INFO;
  Level stdErrLogLevel=Level.WARNING;
  String unparsedStdOutLogLevel=System.getProperty(STD_OUT_LOG_LEVEL_PROPERTY);
  String unparsedStdErrLogLevel=System.getProperty(STD_ERR_LOG_LEVEL_PROPERTY);
  if (unparsedStdOutLogLevel != null) {
    stdOutLogLevel=Level.parse(unparsedStdOutLogLevel);
  }
  if (unparsedStdErrLogLevel != null) {
    stdErrLogLevel=Level.parse(unparsedStdErrLogLevel);
  }
  for (  String className : testClassNames) {
    List<TestResult> results=new ArrayList<>();
    Class<?> testClass=null;
    boolean shouldRunAsTestClass;
    try {
      testClass=Class.forName(className);
      shouldRunAsTestClass=mightBeATestClass(testClass);
    }
 catch (    ClassNotFoundException|LinkageError t) {
      int indexForLastPartOfName=Math.max(className.lastIndexOf('.'),className.lastIndexOf('$')) + 1;
      if (className.indexOf(""String_Node_Str"",indexForLastPartOfName) != -1) {
        results.add(TestResult.forFailureAtInitialization(className,t));
      }
      shouldRunAsTestClass=false;
    }
    if (shouldRunAsTestClass) {
      RecordingFilter filter=new RecordingFilter();
      JUnitCore jUnitCore=new JUnitCore();
      Runner suite=new Computer().getSuite(createRunnerBuilder(),new Class<?>[]{testClass});
      Request request=Request.runner(suite);
      request=request.filterWith(filter);
      jUnitCore.addListener(new TestListener(results,stdOutLogLevel,stdErrLogLevel));
      jUnitCore.run(request);
      results=combineResults(results,filter.filteredOut);
    }
    writeResult(className,results);
  }
}","@Override public void run() throws Throwable {
  Level stdOutLogLevel=Level.INFO;
  Level stdErrLogLevel=Level.WARNING;
  String unparsedStdOutLogLevel=System.getProperty(STD_OUT_LOG_LEVEL_PROPERTY);
  String unparsedStdErrLogLevel=System.getProperty(STD_ERR_LOG_LEVEL_PROPERTY);
  if (unparsedStdOutLogLevel != null) {
    stdOutLogLevel=Level.parse(unparsedStdOutLogLevel);
  }
  if (unparsedStdErrLogLevel != null) {
    stdErrLogLevel=Level.parse(unparsedStdErrLogLevel);
  }
  for (  String className : testClassNames) {
    final Class<?> testClass=Class.forName(className);
    List<TestResult> results=new ArrayList<>();
    RecordingFilter filter=new RecordingFilter();
    if (mightBeATestClass(testClass)) {
      JUnitCore jUnitCore=new JUnitCore();
      Runner suite=new Computer().getSuite(createRunnerBuilder(),new Class<?>[]{testClass});
      Request request=Request.runner(suite);
      request=request.filterWith(filter);
      jUnitCore.addListener(new TestListener(results,stdOutLogLevel,stdErrLogLevel));
      jUnitCore.run(request);
    }
    List<TestResult> actualResults=combineResults(results,filter.filteredOut);
    writeResult(className,actualResults);
  }
}",0.6987610619469027
52990,"@Override public void run() throws Throwable {
  Level stdOutLogLevel=Level.INFO;
  Level stdErrLogLevel=Level.WARNING;
  String unparsedStdOutLogLevel=System.getProperty(STD_OUT_LOG_LEVEL_PROPERTY);
  String unparsedStdErrLogLevel=System.getProperty(STD_ERR_LOG_LEVEL_PROPERTY);
  if (unparsedStdOutLogLevel != null) {
    stdOutLogLevel=Level.parse(unparsedStdOutLogLevel);
  }
  if (unparsedStdErrLogLevel != null) {
    stdErrLogLevel=Level.parse(unparsedStdErrLogLevel);
  }
  for (  String className : testClassNames) {
    final Class<?> testClass=Class.forName(className);
    List<TestResult> results=new ArrayList<>();
    RecordingFilter filter=new RecordingFilter();
    if (mightBeATestClass(testClass)) {
      JUnitCore jUnitCore=new JUnitCore();
      Runner suite=new Computer().getSuite(createRunnerBuilder(),new Class<?>[]{testClass});
      Request request=Request.runner(suite);
      request=request.filterWith(filter);
      jUnitCore.addListener(new TestListener(results,stdOutLogLevel,stdErrLogLevel));
      jUnitCore.run(request);
    }
    List<TestResult> actualResults=combineResults(results,filter.filteredOut);
    writeResult(className,actualResults);
  }
}","@Override public void run() throws Throwable {
  Level stdOutLogLevel=Level.INFO;
  Level stdErrLogLevel=Level.WARNING;
  String unparsedStdOutLogLevel=System.getProperty(STD_OUT_LOG_LEVEL_PROPERTY);
  String unparsedStdErrLogLevel=System.getProperty(STD_ERR_LOG_LEVEL_PROPERTY);
  if (unparsedStdOutLogLevel != null) {
    stdOutLogLevel=Level.parse(unparsedStdOutLogLevel);
  }
  if (unparsedStdErrLogLevel != null) {
    stdErrLogLevel=Level.parse(unparsedStdErrLogLevel);
  }
  for (  String className : testClassNames) {
    List<TestResult> results=new ArrayList<>();
    Class<?> testClass=null;
    boolean shouldRunAsTestClass;
    try {
      testClass=Class.forName(className);
      shouldRunAsTestClass=mightBeATestClass(testClass);
    }
 catch (    ClassNotFoundException|LinkageError t) {
      int indexForLastPartOfName=Math.max(className.lastIndexOf('.'),className.lastIndexOf('$')) + 1;
      if (className.indexOf(""String_Node_Str"",indexForLastPartOfName) != -1) {
        results.add(TestResult.forFailureAtInitialization(className,t));
      }
      shouldRunAsTestClass=false;
    }
    if (shouldRunAsTestClass) {
      RecordingFilter filter=new RecordingFilter();
      JUnitCore jUnitCore=new JUnitCore();
      Runner suite=new Computer().getSuite(createRunnerBuilder(),new Class<?>[]{testClass});
      Request request=Request.runner(suite);
      request=request.filterWith(filter);
      jUnitCore.addListener(new TestListener(results,stdOutLogLevel,stdErrLogLevel));
      jUnitCore.run(request);
      results=combineResults(results,filter.filteredOut);
    }
    writeResult(className,results);
  }
}",0.7433628318584071
52991,"private BuildRule generateDebugLauncherRule(){
  BuildRuleParams debugParams=params.copyWithChanges(addDebugFlavor(params.getBuildTarget()),Suppliers.ofInstance(ImmutableSortedSet.of()),Suppliers.ofInstance(ImmutableSortedSet.of()));
  OcamlDebugLauncher debugLauncher=new OcamlDebugLauncher(debugParams,pathResolver,new OcamlDebugLauncherStep.Args(ocamlContext.getOcamlDebug().get(),ocamlContext.getBytecodeOutput(),ocamlContext.getOcamlInput(),ocamlContext.getBytecodeIncludeFlags()));
  resolver.addToIndex(debugLauncher);
  return debugLauncher;
}","private BuildRule generateDebugLauncherRule(){
  BuildRuleParams debugParams=params.copyWithChanges(addDebugFlavor(params.getBuildTarget()),Suppliers.ofInstance(ImmutableSortedSet.of()),Suppliers.ofInstance(ImmutableSortedSet.of()));
  OcamlDebugLauncher debugLauncher=new OcamlDebugLauncher(debugParams,new OcamlDebugLauncherStep.Args(ocamlContext.getOcamlDebug().get(),ocamlContext.getBytecodeOutput(),ocamlContext.getOcamlInput(),ocamlContext.getBytecodeIncludeFlags()));
  resolver.addToIndex(debugLauncher);
  return debugLauncher;
}",0.9880624426078972
52992,"@Override public ImmutableList<Step> getBuildSteps(BuildContext context,BuildableContext buildableContext){
  buildableContext.recordArtifact(args.getOutput());
  return ImmutableList.of(new MkdirStep(getProjectFilesystem(),args.getOutput().getParent()),new OcamlDebugLauncherStep(getProjectFilesystem(),getResolver(),args));
}","@Override public ImmutableList<Step> getBuildSteps(BuildContext context,BuildableContext buildableContext){
  buildableContext.recordArtifact(args.getOutput());
  return ImmutableList.of(new MkdirStep(getProjectFilesystem(),args.getOutput().getParent()),new OcamlDebugLauncherStep(getProjectFilesystem(),context.getSourcePathResolver(),args));
}",0.9642857142857144
52993,"public OcamlDebugLauncher(BuildRuleParams params,SourcePathResolver resolver,OcamlDebugLauncherStep.Args args){
  super(params,resolver);
  this.args=args;
}","public OcamlDebugLauncher(BuildRuleParams params,OcamlDebugLauncherStep.Args args){
  super(params);
  this.args=args;
}",0.8664259927797834
52994,"@SuppressWarnings(""String_Node_Str"") @Value.Default public Optional<Path> getStubBinaryPath(){
  return Optional.empty();
}",public abstract Optional<Path> getStubBinaryPath();,0.4827586206896552
52995,"@Test public void testCacheStoresAndFetchHits() throws IOException {
  Path cacheDir=tmpDir.newFolder();
  Path fileX=tmpDir.newFile(""String_Node_Str"");
  Path fileY=tmpDir.newFile(""String_Node_Str"");
  Path fileZ=tmpDir.newFile(""String_Node_Str"");
  fileHashCache=new FakeFileHashCache(ImmutableMap.of(fileX,HashCode.fromInt(0),fileY,HashCode.fromInt(1),fileZ,HashCode.fromInt(2)));
  dirArtifactCache=new DirArtifactCache(""String_Node_Str"",new ProjectFilesystem(cacheDir),Paths.get(""String_Node_Str""),true,Optional.empty());
  Files.write(fileX,""String_Node_Str"".getBytes(UTF_8));
  Files.write(fileY,""String_Node_Str"".getBytes(UTF_8));
  Files.write(fileZ,""String_Node_Str"".getBytes(UTF_8));
  BuildRule inputRuleX=new BuildRuleForTest(fileX);
  BuildRule inputRuleY=new BuildRuleForTest(fileY);
  BuildRule inputRuleZ=new BuildRuleForTest(fileZ);
  assertFalse(inputRuleX.equals(inputRuleY));
  assertFalse(inputRuleX.equals(inputRuleZ));
  assertFalse(inputRuleY.equals(inputRuleZ));
  BuildRuleResolver ruleResolver=new BuildRuleResolver(TargetGraph.EMPTY,new DefaultTargetNodeToBuildRuleTransformer());
  ruleResolver.addToIndex(inputRuleX);
  ruleResolver.addToIndex(inputRuleY);
  ruleResolver.addToIndex(inputRuleZ);
  SourcePathRuleFinder ruleFinder=new SourcePathRuleFinder(ruleResolver);
  SourcePathResolver resolver=new SourcePathResolver(ruleFinder);
  DefaultRuleKeyFactory fakeRuleKeyFactory=new DefaultRuleKeyFactory(0,fileHashCache,resolver,ruleFinder);
  RuleKey ruleKeyX=fakeRuleKeyFactory.build(inputRuleX);
  RuleKey ruleKeyY=fakeRuleKeyFactory.build(inputRuleY);
  RuleKey ruleKeyZ=fakeRuleKeyFactory.build(inputRuleZ);
  assertEquals(CacheResultType.MISS,dirArtifactCache.fetch(ruleKeyX,LazyPath.ofInstance(fileX)).getType());
  assertEquals(CacheResultType.MISS,dirArtifactCache.fetch(ruleKeyY,LazyPath.ofInstance(fileY)).getType());
  assertEquals(CacheResultType.MISS,dirArtifactCache.fetch(ruleKeyZ,LazyPath.ofInstance(fileZ)).getType());
  dirArtifactCache.store(ArtifactInfo.builder().addRuleKeys(ruleKeyX).build(),BorrowablePath.notBorrowablePath(fileX));
  dirArtifactCache.store(ArtifactInfo.builder().addRuleKeys(ruleKeyY).build(),BorrowablePath.notBorrowablePath(fileY));
  dirArtifactCache.store(ArtifactInfo.builder().addRuleKeys(ruleKeyZ).build(),BorrowablePath.notBorrowablePath(fileZ));
  Files.delete(fileX);
  Files.delete(fileY);
  Files.delete(fileZ);
  assertEquals(CacheResultType.HIT,dirArtifactCache.fetch(ruleKeyX,LazyPath.ofInstance(fileX)).getType());
  assertEquals(CacheResultType.HIT,dirArtifactCache.fetch(ruleKeyY,LazyPath.ofInstance(fileY)).getType());
  assertEquals(CacheResultType.HIT,dirArtifactCache.fetch(ruleKeyZ,LazyPath.ofInstance(fileZ)).getType());
  assertEquals(inputRuleX,new BuildRuleForTest(fileX));
  assertEquals(inputRuleY,new BuildRuleForTest(fileY));
  assertEquals(inputRuleZ,new BuildRuleForTest(fileZ));
  ImmutableList<Path> cachedFiles=ImmutableList.copyOf(dirArtifactCache.getAllFilesInCache());
  assertEquals(6,cachedFiles.size());
  ImmutableSet<String> filenames=cachedFiles.stream().map(input -> input.getFileName().toString()).collect(MoreCollectors.toImmutableSet());
  for (  RuleKey ruleKey : ImmutableSet.of(ruleKeyX,ruleKeyY,ruleKeyZ)) {
    filenames.contains(ruleKey.toString());
    filenames.contains(ruleKey.toString() + ""String_Node_Str"");
  }
}","@Test public void testCacheStoresAndFetchHits() throws IOException {
  Path cacheDir=tmpDir.newFolder();
  Path fileX=tmpDir.newFile(""String_Node_Str"");
  Path fileY=tmpDir.newFile(""String_Node_Str"");
  Path fileZ=tmpDir.newFile(""String_Node_Str"");
  fileHashCache=new FakeFileHashCache(ImmutableMap.of(fileX,HashCode.fromInt(0),fileY,HashCode.fromInt(1),fileZ,HashCode.fromInt(2)));
  dirArtifactCache=new DirArtifactCache(""String_Node_Str"",new ProjectFilesystem(cacheDir),Paths.get(""String_Node_Str""),true,Optional.empty());
  Files.write(fileX,""String_Node_Str"".getBytes(UTF_8));
  Files.write(fileY,""String_Node_Str"".getBytes(UTF_8));
  Files.write(fileZ,""String_Node_Str"".getBytes(UTF_8));
  BuildRule inputRuleX=new BuildRuleForTest(fileX);
  BuildRule inputRuleY=new BuildRuleForTest(fileY);
  BuildRule inputRuleZ=new BuildRuleForTest(fileZ);
  assertFalse(inputRuleX.equals(inputRuleY));
  assertFalse(inputRuleX.equals(inputRuleZ));
  assertFalse(inputRuleY.equals(inputRuleZ));
  BuildRuleResolver ruleResolver=new BuildRuleResolver(TargetGraph.EMPTY,new DefaultTargetNodeToBuildRuleTransformer());
  ruleResolver.addToIndex(inputRuleX);
  ruleResolver.addToIndex(inputRuleY);
  ruleResolver.addToIndex(inputRuleZ);
  SourcePathRuleFinder ruleFinder=new SourcePathRuleFinder(ruleResolver);
  SourcePathResolver resolver=new SourcePathResolver(ruleFinder);
  DefaultRuleKeyFactory fakeRuleKeyFactory=new DefaultRuleKeyFactory(0,fileHashCache,resolver,ruleFinder);
  RuleKey ruleKeyX=fakeRuleKeyFactory.build(inputRuleX);
  RuleKey ruleKeyY=fakeRuleKeyFactory.build(inputRuleY);
  RuleKey ruleKeyZ=fakeRuleKeyFactory.build(inputRuleZ);
  assertEquals(CacheResultType.MISS,dirArtifactCache.fetch(ruleKeyX,LazyPath.ofInstance(fileX)).getType());
  assertEquals(CacheResultType.MISS,dirArtifactCache.fetch(ruleKeyY,LazyPath.ofInstance(fileY)).getType());
  assertEquals(CacheResultType.MISS,dirArtifactCache.fetch(ruleKeyZ,LazyPath.ofInstance(fileZ)).getType());
  dirArtifactCache.store(ArtifactInfo.builder().addRuleKeys(ruleKeyX).build(),BorrowablePath.notBorrowablePath(fileX));
  dirArtifactCache.store(ArtifactInfo.builder().addRuleKeys(ruleKeyY).build(),BorrowablePath.notBorrowablePath(fileY));
  dirArtifactCache.store(ArtifactInfo.builder().addRuleKeys(ruleKeyZ).build(),BorrowablePath.notBorrowablePath(fileZ));
  Files.delete(fileX);
  Files.delete(fileY);
  Files.delete(fileZ);
  assertEquals(CacheResultType.HIT,dirArtifactCache.fetch(ruleKeyX,LazyPath.ofInstance(fileX)).getType());
  assertEquals(CacheResultType.HIT,dirArtifactCache.fetch(ruleKeyY,LazyPath.ofInstance(fileY)).getType());
  assertEquals(CacheResultType.HIT,dirArtifactCache.fetch(ruleKeyZ,LazyPath.ofInstance(fileZ)).getType());
  assertEquals(inputRuleX,new BuildRuleForTest(fileX));
  assertEquals(inputRuleY,new BuildRuleForTest(fileY));
  assertEquals(inputRuleZ,new BuildRuleForTest(fileZ));
  ImmutableList<Path> cachedFiles=ImmutableList.copyOf(dirArtifactCache.getAllFilesInCache());
  assertEquals(6,cachedFiles.size());
  ImmutableSet<String> filenames=cachedFiles.stream().map(input -> input.getFileName().toString()).collect(MoreCollectors.toImmutableSet());
  for (  RuleKey ruleKey : ImmutableSet.of(ruleKeyX,ruleKeyY,ruleKeyZ)) {
    assertThat(filenames,Matchers.hasItem(ruleKey.toString()));
    assertThat(filenames,Matchers.hasItem(ruleKey.toString() + ""String_Node_Str""));
  }
}",0.9869358669833728
52996,"@Test public void testNonHasMavenCoordinatesBuildRule() throws Exception {
  assumeFalse(""String_Node_Str"",FakeBuildRule.class.isInstance(HasMavenCoordinates.class));
  SourcePathResolver sourcePathResolver=new SourcePathResolver(new SourcePathRuleFinder(resolver));
  BuildRule rule=new FakeBuildRule(""String_Node_Str"",sourcePathResolver);
  try {
    expander.getMavenCoordinates(rule);
    fail(""String_Node_Str"");
  }
 catch (  MacroException e) {
    assertTrue(""String_Node_Str"",e.getMessage().contains(""String_Node_Str""));
  }
}","@Test public void testNonHasMavenCoordinatesBuildRule() throws Exception {
  assumeFalse(""String_Node_Str"",FakeBuildRule.class.isAssignableFrom(HasMavenCoordinates.class));
  SourcePathResolver sourcePathResolver=new SourcePathResolver(new SourcePathRuleFinder(resolver));
  BuildRule rule=new FakeBuildRule(""String_Node_Str"",sourcePathResolver);
  try {
    expander.getMavenCoordinates(rule);
    fail(""String_Node_Str"");
  }
 catch (  MacroException e) {
    assertTrue(""String_Node_Str"",e.getMessage().contains(""String_Node_Str""));
  }
}",0.9795539033457248
52997,"private void flushEventListeners(Console console,BuildId buildId,ImmutableList<BuckEventListener> eventListeners){
  for (  BuckEventListener eventListener : eventListeners) {
    try {
      eventListener.outputTrace(buildId);
    }
 catch (    RuntimeException e) {
      PrintStream stdErr=console.getStdErr();
      stdErr.println(""String_Node_Str"");
      e.printStackTrace(stdErr);
    }
  }
}","private void flushEventListeners(Console console,BuildId buildId,ImmutableList<BuckEventListener> eventListeners) throws InterruptedException {
  for (  BuckEventListener eventListener : eventListeners) {
    try {
      eventListener.outputTrace(buildId);
    }
 catch (    RuntimeException e) {
      PrintStream stdErr=console.getStdErr();
      stdErr.println(""String_Node_Str"");
      e.printStackTrace(stdErr);
    }
  }
}",0.9649334945586456
52998,"/** 
 * Output any trace data collected to the backing store.
 * @param buildId for the trace to be written.
 */
public void outputTrace(BuildId buildId);","/** 
 * Output any trace data collected to the backing store.
 * @param buildId for the trace to be written.
 */
public void outputTrace(BuildId buildId) throws InterruptedException ;",0.913946587537092
52999,"@Override public void outputTrace(BuildId buildId){
  try {
    outputStream.write(String.format(""String_Node_Str"",exitCode.orElse(-1)).getBytes(Charsets.UTF_8));
    outputStream.close();
  }
 catch (  IOException e) {
    LOG.warn(""String_Node_Str"");
  }
  executor.shutdown();
}","@Override public void outputTrace(BuildId buildId) throws InterruptedException {
  executor.submit(() -> {
    try {
      outputStream.write(String.format(""String_Node_Str"",exitCode.orElse(-1)).getBytes(Charsets.UTF_8));
      outputStream.close();
    }
 catch (    IOException e) {
      LOG.warn(""String_Node_Str"");
    }
  }
);
  executor.shutdown();
  if (!executor.awaitTermination(SHUTDOWN_TIMEOUT_SECONDS,TimeUnit.SECONDS)) {
    String error=""String_Node_Str"";
    LOG.error(error);
  }
}",0.7214377406931964
53000,"private void writeToLog(final String prefix,final Object obj){
  executor.submit(() -> {
    try {
      outputStream.write((prefix + ""String_Node_Str"").getBytes(Charsets.UTF_8));
      outputStream.write(objectWriter.writeValueAsBytes(obj));
      outputStream.write(NEWLINE);
      outputStream.flush();
    }
 catch (    JsonProcessingException e) {
      LOG.warn(""String_Node_Str"",prefix);
    }
catch (    IOException e) {
      LOG.debug(""String_Node_Str"",BuckConstant.BUCK_MACHINE_LOG_FILE_NAME,e);
    }
  }
);
}","private void writeToLog(final String prefix,final Object obj){
  executor.submit(() -> {
    try {
      byte[] serializedObj=objectWriter.writeValueAsBytes(obj);
      outputStream.write((prefix + ""String_Node_Str"").getBytes(Charsets.UTF_8));
      outputStream.write(serializedObj);
      outputStream.write(NEWLINE);
      outputStream.flush();
    }
 catch (    JsonProcessingException e) {
      LOG.warn(""String_Node_Str"",prefix);
    }
catch (    IOException e) {
      LOG.debug(""String_Node_Str"",BuckConstant.BUCK_MACHINE_LOG_FILE_NAME,e);
    }
  }
);
}",0.9003690036900369
