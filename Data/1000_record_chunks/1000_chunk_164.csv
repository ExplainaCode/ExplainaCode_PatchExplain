record_number,buggy_code,fixed_code,code_similarity
163001,"@Test @Ignore(""String_Node_Str"") public void testSerializingBuilder() throws TimeoutException, InterruptedException, IOException {
  final MapInstanceConfig<CharSequence,CharSequence> config=(MapInstanceConfig<CharSequence,CharSequence>)ChronicleMapBuilder.of(CharSequence.class,CharSequence.class).entries(2).minSegments(2).replication((byte)1,TcpTransportAndNetworkConfig.of(8244)).removeReturnsNull(true).instance().name(""String_Node_Str"");
  final ChronicleMap<CharSequence,CharSequence> map=findMapByName.create(config);
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(map.get(""String_Node_Str""),""String_Node_Str"");
}","@Test public void testSerializingBuilder() throws TimeoutException, InterruptedException, IOException {
  final MapInstanceConfig<CharSequence,CharSequence> config=(MapInstanceConfig<CharSequence,CharSequence>)ChronicleMapBuilder.of(CharSequence.class,CharSequence.class).entrySize(900).entries(2).minSegments(2).replication((byte)1,TcpTransportAndNetworkConfig.of(8244)).removeReturnsNull(true).instance().name(""String_Node_Str"");
  final ChronicleMap<CharSequence,CharSequence> map=findMapByName.create(config);
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(map.get(""String_Node_Str""),""String_Node_Str"");
}",0.9667194928684628
163002,"@Override public final void readUnlock(){
  try {
    segmentHeader.unlockRWReadLock(LOCK_OFFSET);
  }
 catch (  IllegalMonitorStateException e) {
    errorListener.errorOnUnlock(e);
  }
}","@Override public final void readUnlock(){
  try {
    segmentHeader.unlockRWWriteLock(LOCK_OFFSET);
  }
 catch (  IllegalMonitorStateException e) {
    errorListener.errorOnUnlock(e);
  }
}",0.9814323607427056
163003,"@Override public final ReadLocked<K,KI,MKI,V,VI,MVI> readLock(@Nullable SegmentState segmentState){
  while (true) {
    final boolean success=segmentHeader.tryRWReadLock(LOCK_OFFSET,lockTimeOutNS);
    if (success) {
      if (segmentState != null) {
        return segmentState.readLocked(this);
      }
 else {
        return null;
      }
    }
    if (currentThread().isInterrupted()) {
      throw new IllegalStateException(new InterruptedException(""String_Node_Str""));
    }
 else {
      errorListener.onLockTimeout(segmentHeader.threadIdForLockLong(LOCK_OFFSET));
      segmentHeader.resetLockLong(LOCK_OFFSET);
    }
  }
}","@Override public final ReadLocked<K,KI,MKI,V,VI,MVI> readLock(@Nullable SegmentState segmentState){
  while (true) {
    final boolean success=segmentHeader.tryRWWriteLock(LOCK_OFFSET,lockTimeOutNS);
    if (success) {
      if (segmentState != null) {
        return segmentState.readLocked(this);
      }
 else {
        return null;
      }
    }
    if (currentThread().isInterrupted()) {
      throw new IllegalStateException(new InterruptedException(""String_Node_Str""));
    }
 else {
      errorListener.onLockTimeout(segmentHeader.threadIdForLockLong(LOCK_OFFSET));
      segmentHeader.resetLockLong(LOCK_OFFSET);
    }
  }
}",0.9928853754940712
163004,"void exerciseLargeStrings(ChronicleMap<String,String> map,int run,int start,int finish,int entrySize){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  XMLEncoder xml=new XMLEncoder(baos);
  Map<String,String> map2=new HashMap<>();
  Random rand=new Random(1);
  for (int i=0; i < entrySize / 80; i++)   map2.put(""String_Node_Str"" + i,""String_Node_Str"" + rand.nextInt(1000));
  xml.writeObject(map2);
  xml.close();
  String value=baos.toString().substring(0,entrySize);
  if (run == 0) {
    DirectBytes bytes=DirectStore.allocate(entrySize).bytes();
    SnappyStringMarshaller.INSTANCE.write(bytes,value);
    bytes.flip();
    SnappyStringMarshaller.INSTANCE.read(bytes);
    bytes.release();
  }
  Object lock=TESTING ? Thread.currentThread() : map;
  List<String> keys=new ArrayList<>();
  for (int i=start; i < finish; i++) {
    String key=""String_Node_Str"" + i;
    String object;
synchronized (lock) {
      map.put(key,value);
      keys.add(key);
      for (      String s : keys)       assertTrue(s,map.containsKey(s));
      object=map.get(key);
      assertTrue(key,map.containsKey(key));
    }
    assertNotNull(key,object);
    assertEquals(key,entrySize,object.length());
  }
  for (int i=start; i < finish; i++) {
    String key=""String_Node_Str"" + i;
synchronized (lock) {
      String object=map.get(key);
      assertNotNull(key,object);
      assertEquals(key,entrySize,object.length());
    }
  }
}","void exerciseLargeStrings(ChronicleMap<String,String> map,int run,int start,int finish,int entrySize){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  XMLEncoder xml=new XMLEncoder(baos);
  Map<String,String> map2=new HashMap<>();
  Random rand=new Random(1);
  for (int i=0; i < entrySize / 80; i++)   map2.put(""String_Node_Str"" + i,""String_Node_Str"" + rand.nextInt(1000));
  xml.writeObject(map2);
  xml.close();
  String value=baos.toString().substring(0,entrySize);
  if (run == 0) {
    DirectBytes bytes=DirectStore.allocate(entrySize).bytes();
    SnappyStringMarshaller.INSTANCE.write(bytes,value);
    bytes.flip();
    SnappyStringMarshaller.INSTANCE.read(bytes);
    bytes.release();
  }
  for (int i=start; i < finish; i++) {
    String key=""String_Node_Str"" + i;
    String object;
    map.put(key,value);
    object=map.get(key);
    assertTrue(key,map.containsKey(key));
    assertNotNull(key,object);
    assertEquals(key,entrySize,object.length());
  }
  for (int i=start; i < finish; i++) {
    String key=""String_Node_Str"" + i;
    String object=map.get(key);
    assertNotNull(key,object);
    assertEquals(key,entrySize,object.length());
  }
}",0.8006134969325154
163005,"@Test @Ignore public void testLargeStrings() throws ExecutionException, InterruptedException {
  final ChronicleMap<String,String> map=ChronicleMapBuilder.of(String.class,String.class).valueMarshaller(SnappyStringMarshaller.INSTANCE).actualSegments(1).entries(ENTRIES * 2).entrySize(ENTRY_SIZE / 4).putReturnsNull(true).create();
{
    int threads=4;
    ExecutorService es=Executors.newFixedThreadPool(threads);
    final int block=ENTRIES / threads;
    for (int i=0; i < 3; i++) {
      long start=System.currentTimeMillis();
      List<Future<?>> futureList=new ArrayList<>();
      for (int t=0; t < threads; t++) {
        final int finalT=t;
        final int finalI=i;
        futureList.add(es.submit(new Runnable(){
          @Override public void run(){
            exerciseLargeStrings(map,finalI,finalT * block,finalT * block + block,ENTRY_SIZE);
          }
        }
));
      }
      for (      Future<?> future : futureList) {
        future.get();
      }
      long time=System.currentTimeMillis() - start;
      long operations=3;
      System.out.printf(""String_Node_Str"",operations * ENTRIES * ENTRY_SIZE / 1e6 / (time / 1e3));
    }
    es.shutdown();
    if (es.isTerminated())     map.close();
  }
}","@Test @Ignore public void testLargeStrings() throws ExecutionException, InterruptedException, IOException {
  File file=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  final ChronicleMap<String,String> map=ChronicleMapBuilder.of(String.class,String.class).valueMarshaller(SnappyStringMarshaller.INSTANCE).actualSegments(1).entries(ENTRIES * 2).entrySize(ENTRY_SIZE / 4).putReturnsNull(true).createPersistedTo(file);
{
    int threads=4;
    ExecutorService es=Executors.newFixedThreadPool(threads);
    final int block=ENTRIES / threads;
    for (int i=0; i < 3; i++) {
      long start=System.currentTimeMillis();
      List<Future<?>> futureList=new ArrayList<>();
      for (int t=0; t < threads; t++) {
        final int finalT=t;
        final int finalI=i;
        futureList.add(es.submit(new Runnable(){
          @Override public void run(){
            exerciseLargeStrings(map,finalI,finalT * block,finalT * block + block,ENTRY_SIZE);
          }
        }
));
      }
      for (      Future<?> future : futureList) {
        future.get();
      }
      long time=System.currentTimeMillis() - start;
      long operations=3;
      System.out.printf(""String_Node_Str"",operations * ENTRIES * ENTRY_SIZE / 1e6 / (time / 1e3));
    }
    es.shutdown();
    if (es.isTerminated())     map.close();
  }
}",0.9607227022780832
163006,"private synchronized SocketChannel lazyConnect(final long timeoutMs,final InetSocketAddress remoteAddress){
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + remoteAddress);
  SocketChannel result;
  long timeoutAt=System.currentTimeMillis() + timeoutMs;
  for (; ; ) {
    checkTimeout(timeoutAt);
    closeExisting();
    try {
      result=AbstractChannelReplicator.openSocketChannel(closeables);
      result.connect(config.remoteAddress());
      result.socket().setTcpNoDelay(true);
      doHandShaking(result);
      break;
    }
 catch (    IOException e) {
      if (closeables != null)       closeables.closeQuietly();
    }
catch (    Exception e) {
      if (closeables != null)       closeables.closeQuietly();
      throw e;
    }
  }
  return result;
}","private synchronized SocketChannel lazyConnect(final long timeoutMs,final InetSocketAddress remoteAddress){
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + remoteAddress + ""String_Node_Str""+ name);
  SocketChannel result;
  long timeoutAt=System.currentTimeMillis() + timeoutMs;
  for (; ; ) {
    checkTimeout(timeoutAt);
    closeExisting();
    try {
      result=AbstractChannelReplicator.openSocketChannel(closeables);
      result.connect(config.remoteAddress());
      result.socket().setTcpNoDelay(true);
      doHandShaking(result);
      break;
    }
 catch (    IOException e) {
      if (closeables != null)       closeables.closeQuietly();
    }
catch (    Exception e) {
      if (closeables != null)       closeables.closeQuietly();
      throw e;
    }
  }
  return result;
}",0.9835443037974684
163007,"/** 
 * initiates a very simple level of handshaking with the remote server, we send a special ID of -127 ( when the server receives this it knows its dealing with a stateless client, receive back an identifier from the server
 * @param clientChannel clientChannel
 * @throws java.io.IOException
 */
private synchronized void doHandShaking(@NotNull final SocketChannel clientChannel) throws IOException {
  connectionByte[0]=STATELESS_CLIENT_IDENTIFIER;
  this.connectionOutBuffer.clear();
  long timeoutTime=System.currentTimeMillis() + config.timeoutMs();
  while (connectionOutBuffer.hasRemaining()) {
    clientChannel.write(connectionOutBuffer);
    checkTimeout(timeoutTime);
  }
  this.connectionOutBuffer.clear();
  if (!clientChannel.finishConnect() || !clientChannel.socket().isBound())   return;
  while (this.connectionOutBuffer.position() <= 0) {
    clientChannel.read(this.connectionOutBuffer);
    checkTimeout(timeoutTime);
  }
  byte remoteIdentifier=connectionByte[0];
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + remoteIdentifier);
}","/** 
 * initiates a very simple level of handshaking with the remote server, we send a special ID of -127 ( when the server receives this it knows its dealing with a stateless client, receive back an identifier from the server
 * @param clientChannel clientChannel
 * @throws java.io.IOException
 */
private synchronized void doHandShaking(@NotNull final SocketChannel clientChannel) throws IOException {
  connectionByte[0]=STATELESS_CLIENT_IDENTIFIER;
  this.connectionOutBuffer.clear();
  long timeoutTime=System.currentTimeMillis() + config.timeoutMs();
  while (connectionOutBuffer.hasRemaining()) {
    clientChannel.write(connectionOutBuffer);
    checkTimeout(timeoutTime);
  }
  this.connectionOutBuffer.clear();
  if (!clientChannel.finishConnect() || !clientChannel.socket().isBound())   return;
  while (this.connectionOutBuffer.position() <= 0) {
    clientChannel.read(this.connectionOutBuffer);
    checkTimeout(timeoutTime);
  }
  byte remoteIdentifier=connectionByte[0];
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + remoteIdentifier + ""String_Node_Str""+ name);
}",0.9879740980573544
163008,"StatelessChronicleMap(@NotNull final StatelessMapConfig config,@NotNull final ChronicleMapBuilder chronicleMapBuilder) throws IOException {
  this.chronicleMapBuilder=chronicleMapBuilder;
  this.config=config;
  keyReaderWithSize=new ReaderWithSize<>(chronicleMapBuilder.keyBuilder);
  keyWriterWithSize=new WriterWithSize<>(chronicleMapBuilder.keyBuilder);
  valueReaderWithSize=new ReaderWithSize<>(chronicleMapBuilder.valueBuilder);
  valueWriterWithSize=new WriterWithSize<>(chronicleMapBuilder.valueBuilder);
  this.putReturnsNull=chronicleMapBuilder.putReturnsNull();
  this.removeReturnsNull=chronicleMapBuilder.removeReturnsNull();
  this.maxEntrySize=chronicleMapBuilder.entrySize(true);
  if (maxEntrySize < 128)   maxEntrySize=128;
  this.vClass=chronicleMapBuilder.valueBuilder.eClass;
  this.kClass=chronicleMapBuilder.keyBuilder.eClass;
  this.name=config.name();
  attemptConnect(config.remoteAddress());
  outBuffer=allocateDirect(maxEntrySize).order(ByteOrder.nativeOrder());
  outBytes=new ByteBufferBytes(outBuffer.slice());
  inBuffer=allocateDirect(maxEntrySize).order(ByteOrder.nativeOrder());
  inBytes=new ByteBufferBytes(outBuffer.slice());
}","StatelessChronicleMap(@NotNull final StatelessMapConfig config,@NotNull final ChronicleMapBuilder chronicleMapBuilder) throws IOException {
  this.config=config;
  keyReaderWithSize=new ReaderWithSize<>(chronicleMapBuilder.keyBuilder);
  keyWriterWithSize=new WriterWithSize<>(chronicleMapBuilder.keyBuilder);
  valueReaderWithSize=new ReaderWithSize<>(chronicleMapBuilder.valueBuilder);
  valueWriterWithSize=new WriterWithSize<>(chronicleMapBuilder.valueBuilder);
  this.putReturnsNull=chronicleMapBuilder.putReturnsNull();
  this.removeReturnsNull=chronicleMapBuilder.removeReturnsNull();
  this.maxEntrySize=chronicleMapBuilder.entrySize(true);
  if (maxEntrySize < 128)   maxEntrySize=128;
  this.vClass=chronicleMapBuilder.valueBuilder.eClass;
  this.kClass=chronicleMapBuilder.keyBuilder.eClass;
  this.name=config.name();
  attemptConnect(config.remoteAddress());
  outBuffer=allocateDirect(maxEntrySize).order(ByteOrder.nativeOrder());
  outBytes=new ByteBufferBytes(outBuffer.slice());
  inBuffer=allocateDirect(maxEntrySize).order(ByteOrder.nativeOrder());
  inBytes=new ByteBufferBytes(inBuffer.slice());
}",0.976805251641138
163009,"private Bytes blockingFetchReadOnly(long timeoutTime,final long transactionId){
  try {
    return blockingFetchThrowable(timeoutTime,transactionId);
  }
 catch (  IOException e) {
    close();
    throw new IORuntimeException(e);
  }
catch (  RuntimeException e) {
    close();
    throw e;
  }
catch (  Exception e) {
    close();
    throw new RuntimeException(e);
  }
catch (  AssertionError e) {
    LOG.error(""String_Node_Str"",e);
    throw e;
  }
}","private Bytes blockingFetchReadOnly(long timeoutTime,final long transactionId){
  try {
    return blockingFetchThrowable(timeoutTime,transactionId);
  }
 catch (  IOException e) {
    close();
    throw new IORuntimeException(e);
  }
catch (  RuntimeException e) {
    close();
    throw e;
  }
catch (  Exception e) {
    close();
    throw new RuntimeException(e);
  }
catch (  AssertionError e) {
    LOG.error(""String_Node_Str"" + name,e);
    throw e;
  }
}",0.9923664122137404
163010,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  ProposedNodes that=(ProposedNodes)o;
  if (identifier != that.identifier)   return false;
  if (!addressAndPort.equals(that.addressAndPort))   return false;
  return true;
}","@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || ProposedNodes.class != o.getClass())   return false;
  ProposedNodes that=(ProposedNodes)o;
  if (identifier != that.identifier)   return false;
  if (!addressAndPort.equals(that.addressAndPort))   return false;
  return true;
}",0.525984251968504
163011,"RV readValue(@NotNull ThreadLocalCopies copies,Bytes entry,RV usingValue,long valueSize);","/** 
 * Updates the entry position by valueSize.
 */
RV readValue(@NotNull ThreadLocalCopies copies,Bytes entry,RV usingValue,long valueSize);",0.7705627705627706
163012,"@Override Bytes bytes(long valueSize){
  if (lazyBytes != null) {
    if (lazyBytes.capacity() < valueSize) {
      DirectStore store=(DirectStore)lazyBytes.store();
      store.resize(valueSize,false);
      lazyBytes=store.bytes();
    }
    lazyBytes.clear();
    return lazyBytes;
  }
  return lazyBytes=new DirectStore(valueSize).bytes();
}","@Override Bytes bytes(long valueSize){
  valueSize=valueSizeMarshaller.sizeEncodingSize(valueSize) + valueSize;
  if (lazyBytes != null) {
    if (lazyBytes.capacity() < valueSize) {
      DirectStore store=(DirectStore)lazyBytes.store();
      store.resize(valueSize,false);
      lazyBytes=store.bytes();
    }
    lazyBytes.clear();
    return lazyBytes;
  }
  return lazyBytes=new DirectStore(valueSize).bytes();
}",0.9043250327653998
163013,"@Test @Ignore(""String_Node_Str"") public void testRemoteNotifyRemove() throws IOException, InterruptedException {
{
    ChronicleMapBuilder<Integer,CharSequence> map1Builder=serverBuilder();
    map1=map1Builder.create();
  }
{
    map2=clientBuilder().create();
    map2.put(5,""String_Node_Str"");
  }
  waitTillReplicated();
  putWasCalled.set(false);
  map1.remove(5);
  waitTillReplicated();
  Assert.assertTrue(!putWasCalled.get());
  Assert.assertTrue(wasRemoved.get());
  Assert.assertEquals(""String_Node_Str"",valueRemoved.get());
  Assert.assertEquals(null,map2.get(5));
}","@Test public void testRemoteNotifyRemove() throws IOException, InterruptedException {
{
    ChronicleMapBuilder<Integer,CharSequence> map1Builder=serverBuilder();
    map1=map1Builder.create();
  }
{
    map2=clientBuilder().create();
    map2.put(5,""String_Node_Str"");
  }
  waitTillReplicated();
  putWasCalled.set(false);
  map1.remove(5);
  waitTillReplicated();
  Assert.assertTrue(!putWasCalled.get());
  Assert.assertTrue(wasRemoved.get());
  Assert.assertEquals(""String_Node_Str"",valueRemoved.get());
  Assert.assertEquals(null,map2.get(5));
}",0.9760850310008856
163014,"<KB,KBI,MKBI extends MetaBytesInterop<KB,? super KBI>,RV,VB extends RV,VBI,MVBI extends MetaBytesInterop<RV,? super VBI>>Object replace(@Nullable ThreadLocalCopies copies,@Nullable SegmentState segmentState,MKBI metaKeyInterop,KBI keyInterop,KB key,long keySize,InstanceOrBytesToInstance<KB,K> toKey,GetValueInterops<VB,VBI,MVBI> getExpectedValueInterops,VB expectedValue,GetValueInterops<VB,VBI,MVBI> getNewValueInterops,VB newValue,ReadValue<RV> readValue,InstanceOrBytesToInstance<? super RV,V> toValue,long hash2){
  segmentStateNotNullImpliesCopiesNotNull(copies,segmentState);
  long timestamp=currentTime();
  byte identifier=localIdentifier;
  writeLock(null);
  try {
    MultiMap hashLookup=hashLookup();
    hashLookup.startSearch(hash2);
    MultiStoreBytes entry=null;
    for (long pos; (pos=hashLookup.nextPos()) >= 0L; ) {
      long offset=offsetFromPos(pos);
      if (entry == null) {
        if (segmentState == null) {
          copies=SegmentState.getCopies(copies);
          segmentState=SegmentState.get(copies);
        }
        entry=segmentState.tmpBytes;
      }
      reuse(entry,offset);
      if (!keyEquals(keyInterop,metaKeyInterop,key,keySize,entry))       continue;
      entry.skip(keySize);
      long timestampPos=entry.position();
      if (shouldIgnore(entry,timestamp,identifier))       return null;
      boolean isDeleted=entry.readBoolean();
      if (isDeleted)       break;
      Object result=onKeyPresentOnReplace(copies,segmentState,key,keySize,toKey,getExpectedValueInterops,expectedValue,getNewValueInterops,newValue,readValue,toValue,pos,offset,entry,hashLookup);
      if (result != Boolean.FALSE) {
        entry.position(timestampPos);
        entry.writeLong(timestamp);
        entry.writeByte(identifier);
      }
      return result;
    }
    return null;
  }
  finally {
    if (segmentState != null)     segmentState.close();
    writeUnlock();
  }
}","<KB,KBI,MKBI extends MetaBytesInterop<KB,? super KBI>,RV,VB extends RV,VBI,MVBI extends MetaBytesInterop<RV,? super VBI>>Object replace(@Nullable ThreadLocalCopies copies,@Nullable SegmentState segmentState,MKBI metaKeyInterop,KBI keyInterop,KB key,long keySize,InstanceOrBytesToInstance<KB,K> toKey,GetValueInterops<VB,VBI,MVBI> getExpectedValueInterops,VB expectedValue,GetValueInterops<VB,VBI,MVBI> getNewValueInterops,VB newValue,ReadValue<RV> readValue,InstanceOrBytesToInstance<? super RV,V> toValue,long hash2){
  segmentStateNotNullImpliesCopiesNotNull(copies,segmentState);
  long timestamp=currentTime();
  byte identifier=localIdentifier;
  writeLock(null);
  try {
    MultiMap hashLookup=hashLookup();
    hashLookup.startSearch(hash2);
    MultiStoreBytes entry=null;
    for (long pos; (pos=hashLookup.nextPos()) >= 0L; ) {
      long offset=offsetFromPos(pos);
      if (entry == null) {
        if (segmentState == null) {
          copies=SegmentState.getCopies(copies);
          segmentState=SegmentState.get(copies);
        }
        entry=segmentState.tmpBytes;
      }
      reuse(entry,offset);
      if (!keyEquals(keyInterop,metaKeyInterop,key,keySize,entry))       continue;
      entry.skip(keySize);
      long timestampPos=entry.position();
      if (shouldIgnore(entry,timestamp,identifier)) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",key,identifier,timestamp,entry.readByte(entry.position() - 1),entry.readLong(entry.position() - ADDITIONAL_ENTRY_BYTES + 1));
        return readValue.readNull();
      }
      boolean isDeleted=entry.readBoolean();
      if (isDeleted)       break;
      Object result=onKeyPresentOnReplace(copies,segmentState,key,keySize,toKey,getExpectedValueInterops,expectedValue,getNewValueInterops,newValue,readValue,toValue,pos,offset,entry,hashLookup);
      if (result != Boolean.FALSE) {
        entry.position(timestampPos);
        entry.writeLong(timestamp);
        entry.writeByte(identifier);
      }
      return result;
    }
    return readValue.readNull();
  }
  finally {
    if (segmentState != null)     segmentState.close();
    writeUnlock();
  }
}",0.9288168875797742
163015,"/** 
 * called from a remote node as part of replication
 */
private void remoteRemove(@NotNull ThreadLocalCopies copies,@NotNull SegmentState segmentState,Bytes keyBytes,long hash2,final long timestamp,final byte identifier){
  writeLock(null);
  try {
    Boolean removed=(Boolean)removeWithoutLock(copies,segmentState,DelegatingMetaBytesInterop.<Bytes,BytesInterop<Bytes>>instance(),BytesBytesInterop.INSTANCE,keyBytes,keyBytes.remaining(),keyBytesToInstance,null,null,null,hash2,true,timestamp,identifier,true,true);
    if (!removed && LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + keyBytes.toString().trim() + ""String_Node_Str"");
    }
  }
  finally {
    writeUnlock();
  }
}","/** 
 * called from a remote node as part of replication
 */
private void remoteRemove(@NotNull ThreadLocalCopies copies,@NotNull SegmentState segmentState,Bytes keyBytes,long hash2,final long timestamp,final byte identifier){
  writeLock(null);
  try {
    ReadValueToBytes readValueToLazyBytes=segmentState.readValueToLazyBytes;
    readValueToLazyBytes.valueSizeMarshaller(valueSizeMarshaller);
    Boolean removed=(Boolean)removeWithoutLock(copies,segmentState,DelegatingMetaBytesInterop.<Bytes,BytesInterop<Bytes>>instance(),BytesBytesInterop.INSTANCE,keyBytes,keyBytes.remaining(),keyBytesToInstance,null,null,outputValueBytesToInstance,hash2,readValueToLazyBytes,true,timestamp,identifier,true,true);
    if (!removed && LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + keyBytes.toString().trim() + ""String_Node_Str"");
    }
  }
  finally {
    writeUnlock();
  }
}",0.876504116529449
163016,"@Override <KB,KBI,MKBI extends MetaBytesInterop<KB,? super KBI>,VB,VBI,MVBI extends MetaBytesInterop<? super VB,? super VBI>>Object remove(@Nullable ThreadLocalCopies copies,@Nullable SegmentState segmentState,MKBI metaKeyInterop,KBI keyInterop,KB key,long keySize,InstanceOrBytesToInstance<KB,K> toKey,GetValueInterops<VB,VBI,MVBI> getValueInterops,VB expectedValue,InstanceOrBytesToInstance<? super VB,V> toValue,long hash2,boolean resultUnused){
  writeLock(null);
  try {
    return removeWithoutLock(copies,segmentState,metaKeyInterop,keyInterop,key,keySize,toKey,getValueInterops,expectedValue,toValue,hash2,resultUnused,currentTime(),localIdentifier,false,expectedValue != null);
  }
  finally {
    if (segmentState != null)     segmentState.close();
    writeUnlock();
  }
}","@Override <KB,KBI,MKBI extends MetaBytesInterop<KB,? super KBI>,RV,VB extends RV,VBI,MVBI extends MetaBytesInterop<? super VB,? super VBI>>Object remove(@Nullable ThreadLocalCopies copies,@Nullable SegmentState segmentState,MKBI metaKeyInterop,KBI keyInterop,KB key,long keySize,InstanceOrBytesToInstance<KB,K> toKey,GetValueInterops<VB,VBI,MVBI> getValueInterops,VB expectedValue,InstanceOrBytesToInstance<RV,V> toValue,long hash2,ReadValue<RV> readValue,boolean resultUnused){
  writeLock(null);
  try {
    return removeWithoutLock(copies,segmentState,metaKeyInterop,keyInterop,key,keySize,toKey,getValueInterops,expectedValue,toValue,hash2,readValue,resultUnused,currentTime(),localIdentifier,false,expectedValue != null);
  }
  finally {
    if (segmentState != null)     segmentState.close();
    writeUnlock();
  }
}",0.9601494396014943
163017,"/** 
 * - if expectedValue is not null, returns Boolean.TRUE (removed) or Boolean.FALSE (entry not found), regardless the expectedValue object is Bytes instance (RPC call) or the value instance - if expectedValue is null: - if resultUnused is false, null or removed value is returned - if resultUnused is true, null is always returned
 */
<KB,KBI,MKBI extends MetaBytesInterop<KB,? super KBI>,VB,VBI,MVBI extends MetaBytesInterop<? super VB,? super VBI>>Object removeWithoutLock(@Nullable ThreadLocalCopies copies,final @Nullable SegmentState segmentState,MKBI metaKeyInterop,KBI keyInterop,KB key,long keySize,InstanceOrBytesToInstance<KB,K> toKey,GetValueInterops<VB,VBI,MVBI> getValueInterops,VB expectedValue,InstanceOrBytesToInstance<? super VB,V> toValue,long hash2,boolean resultUnused,long timestamp,byte identifier,boolean remote,boolean booleanResult){
}","/** 
 * - if expectedValue is not null, returns Boolean.TRUE (removed) or Boolean.FALSE (entry not found), regardless the expectedValue object is Bytes instance (RPC call) or the value instance - if expectedValue is null: - if resultUnused is false, null or removed value is returned - if resultUnused is true, null is always returned
 */
<KB,KBI,MKBI extends MetaBytesInterop<KB,? super KBI>,RV,VB extends RV,VBI,MVBI extends MetaBytesInterop<? super VB,? super VBI>>Object removeWithoutLock(@Nullable ThreadLocalCopies copies,final @Nullable SegmentState segmentState,MKBI metaKeyInterop,KBI keyInterop,KB key,long keySize,InstanceOrBytesToInstance<KB,K> toKey,GetValueInterops<VB,VBI,MVBI> getValueInterops,VB expectedValue,InstanceOrBytesToInstance<RV,V> toValue,long hash2,ReadValue<RV> readValue,boolean resultUnused,long timestamp,byte identifier,boolean remote,boolean booleanResult){
}",0.969283276450512
163018,"/** 
 * Only for testing.
 * @param identifier id
 * @return map
 */
ChronicleMap<K,V> createReplicated(byte identifier) throws IOException {
  VanillaChronicleMap<K,?,?,V,?,?> map=new ReplicatedChronicleMap<K,Object,MetaBytesInterop<K,Object>,V,Object,MetaBytesWriter<V,Object>>(this,identifier);
  BytesStore bytesStore=new DirectStore(JDKObjectSerializer.INSTANCE,map.sizeInBytes(),true);
  map.createMappedStoreAndSegments(bytesStore);
  return map;
}","/** 
 * Only for testing.
 * @param identifier id
 * @return map
 */
ChronicleMap<K,V> createReplicated(byte identifier) throws IOException {
  preMapConstruction(true);
  VanillaChronicleMap<K,?,?,V,?,?> map=new ReplicatedChronicleMap<K,Object,MetaBytesInterop<K,Object>,V,Object,MetaBytesWriter<V,Object>>(this,identifier);
  BytesStore bytesStore=new DirectStore(JDKObjectSerializer.INSTANCE,map.sizeInBytes(),true);
  map.createMappedStoreAndSegments(bytesStore);
  return map;
}",0.9701492537313432
163019,"/** 
 * Shortcut for   {@code replication(SimpleReplication.builder().tcpTransportAndNetwork(tcpTransportAndNetwork).create(identifier))}.
 * @param identifier the network-wide identifier of the containers, created by this builder
 * @param tcpTransportAndNetwork configuration of tcp connection and network
 * @return this builder back
 * @see #replication(SimpleReplication)
 * @see ChronicleHashInstanceConfig#replicated(byte,TcpConfig)
 */
B replication(byte identifier,TcpConfig tcpTransportAndNetwork);","/** 
 * Shortcut for   {@code replication(SimpleReplication.builder().tcpTransportAndNetwork(tcpTransportAndNetwork).create(identifier))}.
 * @param identifier the network-wide identifier of the containers, created by this builder
 * @param tcpTransportAndNetwork configuration of tcp connection and network
 * @return this builder back
 * @see #replication(SingleChronicleHashReplication)
 * @see ChronicleHashInstanceConfig#replicated(byte,TcpTransportAndNetworkConfig)
 */
B replication(byte identifier,TcpTransportAndNetworkConfig tcpTransportAndNetwork);",0.9447047797563262
163020,"/** 
 * Configures a time provider, used by hash containers, created by this builder, for needs of replication consensus protocol (conflicting data updates resolution). <p>Default time provider is   {@link TimeProvider#SYSTEM}.
 * @param timeProvider a new time provider for replication needs
 * @return this builder back
 * @see #replication(SimpleReplication)
 */
B timeProvider(TimeProvider timeProvider);","/** 
 * Configures a time provider, used by hash containers, created by this builder, for needs of replication consensus protocol (conflicting data updates resolution). <p>Default time provider is   {@link TimeProvider#SYSTEM}.
 * @param timeProvider a new time provider for replication needs
 * @return this builder back
 * @see #replication(SingleChronicleHashReplication)
 */
B timeProvider(TimeProvider timeProvider);",0.9746682750301568
163021,"/** 
 * Configures replication of the hash containers, created by this builder, via so called ""channels"". See <a href=""https://github.com/OpenHFT/Chronicle-Map#channels-and-channelprovider"">the section about Channels and ChannelProvider in ChronicleMap manual</a> for more information. <p>Another way to establish replication is   {@link #replicated(SimpleReplication)} methodor it's shortcut:  {@link #replicated(byte,TcpConfig)}. <p>By default, hash containers, created by this builder doesn't replicate their data. <p>This method call overrides all previous replication configurations of this builder, made either by means of this method,   {@link #replicated(SimpleReplication)}or   {@link #replicated(byte,TcpConfig)} method calls.
 * @param channel the channel responsible for gathering updates of hash containers,created by this builder, and replicating them over network
 * @return this builder object back
 * @see #replicated(SimpleReplication)
 */
ChronicleHashInstanceConfig<C> replicatedViaChannel(ReplicationChannel channel);","/** 
 * Configures replication of the hash containers, created by this builder, via so called ""channels"". See <a href=""https://github.com/OpenHFT/Chronicle-Map#channels-and-channelprovider"">the section about Channels and ChannelProvider in ChronicleMap manual</a> for more information. <p>Another way to establish replication is   {@link #replicated(SingleChronicleHashReplication)} methodor it's shortcut:  {@link #replicated(byte,TcpTransportAndNetworkConfig)}. <p>By default, hash containers, created by this builder doesn't replicate their data. <p>This method call overrides all previous replication configurations of this builder, made either by means of this method,   {@link #replicated(SingleChronicleHashReplication)}or   {@link #replicated(byte,TcpTransportAndNetworkConfig)} method calls.
 * @param channel the channel responsible for gathering updates of hash containers,created by this builder, and replicating them over network
 * @return this builder object back
 * @see #replicated(SingleChronicleHashReplication)
 */
ChronicleHashInstanceConfig<C> replicatedViaChannel(ReplicationChannel channel);",0.9530887134231304
163022,ChronicleHashInstanceConfig<C> replicated(SimpleReplication replication);,ChronicleHashInstanceConfig<C> replicated(SingleChronicleHashReplication replication);,0.8930817610062893
163023,"public B udpTransport(UdpConfig udpConfig){
  this.udpConfig=udpConfig;
  return (B)this;
}","public B udpTransport(UdpTransportConfig udpConfig){
  this.udpConfig=udpConfig;
  return (B)this;
}",0.9528795811518324
163024,"public B tcpTransportAndNetwork(TcpConfig tcpConfig){
  this.tcpConfig=tcpConfig;
  return (B)this;
}","public B tcpTransportAndNetwork(TcpTransportAndNetworkConfig tcpConfig){
  this.tcpConfig=tcpConfig;
  return (B)this;
}",0.9140271493212668
163025,"@Override public Builder udpTransport(UdpConfig udpConfig){
  return super.udpTransport(udpConfig);
}","@Override public Builder udpTransport(UdpTransportConfig udpConfig){
  return super.udpTransport(udpConfig);
}",0.957345971563981
163026,"@Override public Builder tcpTransportAndNetwork(TcpConfig tcpConfig){
  return super.tcpTransportAndNetwork(tcpConfig);
}","@Override public Builder tcpTransportAndNetwork(TcpTransportAndNetworkConfig tcpConfig){
  return super.tcpTransportAndNetwork(tcpConfig);
}",0.9272030651340996
163027,"public synchronized V remove(Object key){
  long sizeLocation=writeEvent(REMOVE);
  writeKey((K)key);
  return readKey(sizeLocation);
}","public synchronized V remove(Object key){
  if (key == null)   throw new NullPointerException(""String_Node_Str"");
  long sizeLocation=writeEvent(REMOVE);
  writeKey((K)key);
  return readKey(sizeLocation);
}",0.7894736842105263
163028,"@Test public void testEquals() throws IOException, InterruptedException {
  final ChronicleMap<Integer,CharSequence> serverMap1;
  final ChronicleMap<Integer,CharSequence> serverMap2;
  final ChronicleMap<Integer,CharSequence> statelessMap1;
  final ChronicleMap<Integer,CharSequence> statelessMap2;
{
    statelessMap1=ChronicleMapBuilder.of(Integer.class,CharSequence.class).stateless(remoteAddress(new InetSocketAddress(""String_Node_Str"",8076))).create();
    statelessMap2=ChronicleMapBuilder.of(Integer.class,CharSequence.class).stateless(remoteAddress(new InetSocketAddress(""String_Node_Str"",8077))).create();
  }
{
    serverMap1=ChronicleMapBuilder.of(Integer.class,CharSequence.class).replicators((byte)2,TcpReplicationConfig.of(8076)).create();
    serverMap2=ChronicleMapBuilder.of(Integer.class,CharSequence.class).replicators((byte)2,TcpReplicationConfig.of(8077)).create();
  }
  Map<Integer,CharSequence> payload=new HashMap<Integer,CharSequence>();
  for (int i=0; i < 1000; i++) {
    payload.put(i,""String_Node_Str"" + i);
  }
  statelessMap1.putAll(payload);
  Assert.assertTrue(statelessMap1.equals(payload));
  statelessMap1.close();
  statelessMap1.close();
  serverMap1.close();
  serverMap2.close();
}","@Test public void testEquals() throws IOException, InterruptedException {
  final ChronicleMap<Integer,CharSequence> serverMap1;
  final ChronicleMap<Integer,CharSequence> serverMap2;
  final ChronicleMap<Integer,CharSequence> statelessMap1;
  final ChronicleMap<Integer,CharSequence> statelessMap2;
{
    statelessMap1=ChronicleMapBuilder.of(Integer.class,CharSequence.class).stateless(remoteAddress(new InetSocketAddress(""String_Node_Str"",8076))).create();
    statelessMap2=ChronicleMapBuilder.of(Integer.class,CharSequence.class).stateless(remoteAddress(new InetSocketAddress(""String_Node_Str"",8077))).create();
  }
{
    serverMap1=ChronicleMapBuilder.of(Integer.class,CharSequence.class).replicators((byte)2,TcpReplicationConfig.of(8076)).create();
    serverMap2=ChronicleMapBuilder.of(Integer.class,CharSequence.class).replicators((byte)2,TcpReplicationConfig.of(8077)).create();
  }
  Map<Integer,CharSequence> payload=new HashMap<Integer,CharSequence>();
  for (int i=0; i < 1000; i++) {
    payload.put(i,""String_Node_Str"" + i);
  }
  statelessMap1.putAll(payload);
  Assert.assertTrue(statelessMap1.equals(payload));
  statelessMap1.close();
  statelessMap2.close();
  serverMap1.close();
  serverMap2.close();
}",0.9820261437908496
163029,"private Bytes blockingFetchThrowable(long sizeLocation,long timeOutMs,final long transactionId,final long startTime) throws IOException {
  long timeoutTime=startTime + timeOutMs + 1000000;
  for (; ; ) {
    if (clientChannel == null)     clientChannel=lazyConnect(builder.timeoutMs(),builder.remoteAddress());
    try {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + transactionId);
      write(transactionId);
      writeSizeAt(sizeLocation);
      send(bytes,timeoutTime);
      return blockingFetch(timeoutTime,transactionId);
    }
 catch (    java.nio.channels.ClosedChannelException|ClosedConnectionException e) {
      checkTimeout(timeoutTime);
      clientChannel=lazyConnect(builder.timeoutMs(),builder.remoteAddress());
    }
  }
}","private Bytes blockingFetchThrowable(long sizeLocation,long timeOutMs,final long transactionId,final long startTime) throws IOException {
  long timeoutTime=startTime + timeOutMs;
  for (; ; ) {
    if (clientChannel == null)     clientChannel=lazyConnect(builder.timeoutMs(),builder.remoteAddress());
    try {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + transactionId);
      write(transactionId);
      writeSizeAt(sizeLocation);
      send(bytes,timeoutTime);
      bytes.clear();
      bytes.buffer().clear();
      return blockingFetch(timeoutTime,transactionId);
    }
 catch (    java.nio.channels.ClosedChannelException|ClosedConnectionException e) {
      checkTimeout(timeoutTime);
      clientChannel=lazyConnect(builder.timeoutMs(),builder.remoteAddress());
    }
  }
}",0.9611712285168682
163030,"@NotNull public synchronized Set<Map.Entry<K,V>> entrySet(){
  final long sizeLocation=writeEvent(ENTRY_SET);
  final long startTime=System.currentTimeMillis();
  final long transactionId=nextUniqueTransaction(startTime);
  final long timeoutTime=System.currentTimeMillis() + builder.timeoutMs();
  Bytes in=blockingFetch0(sizeLocation,transactionId,startTime);
  final Set<Map.Entry<K,V>> result=new HashSet<Map.Entry<K,V>>();
  for (; ; ) {
    boolean hasMoreEntries=in.readBoolean();
    LOG.info(""String_Node_Str"" + hasMoreEntries);
    long size=in.readInt();
    for (int i=0; i < size; i++) {
      K k=keyValueSerializer.readKey(in);
      V v=keyValueSerializer.readValue(in);
      result.add(new Entry(k,v));
    }
    if (!hasMoreEntries)     break;
    in=blockingFetchReadOnly(timeoutTime,transactionId);
  }
  return result;
}","@NotNull public synchronized Set<Map.Entry<K,V>> entrySet(){
  final long sizeLocation=writeEvent(ENTRY_SET);
  final long startTime=System.currentTimeMillis();
  final long transactionId=nextUniqueTransaction(startTime);
  final long timeoutTime=System.currentTimeMillis() + builder.timeoutMs();
  Bytes in=blockingFetch0(sizeLocation,transactionId,startTime);
  final Set<Map.Entry<K,V>> result=new HashSet<Map.Entry<K,V>>();
  int count=0;
  long total=0;
  for (; ; ) {
    boolean hasMoreEntries=in.readBoolean();
    count++;
    long size=in.readInt();
    for (int i=0; i < size; i++) {
      total++;
      K k=keyValueSerializer.readKey(in);
      V v=keyValueSerializer.readValue(in);
      result.add(new Entry(k,v));
    }
    if (!hasMoreEntries)     break;
    if (in.remaining() == 0) {
      bytes.clear();
      bytes.buffer().clear();
    }
 else {
      buffer.compact();
    }
    in=blockingFetchReadOnly(timeoutTime,transactionId);
  }
  LOG.info(""String_Node_Str"" + total);
  return result;
}",0.5618945102260495
163031,"private Bytes blockingFetch(long timeoutTime,long transactionId) throws IOException {
  bytes.clear();
  bytes.buffer().clear();
  int size=receive(SIZE_OF_SIZE,timeoutTime).readInt();
  int requiredSize=size + SIZE_OF_SIZE;
  if (bytes.capacity() < requiredSize) {
    bytes=new ByteBufferBytes(allocateDirect(requiredSize));
  }
  receive(size,timeoutTime);
  boolean isException=bytes.readBoolean();
  long inTransactionId=bytes.readLong();
  if (inTransactionId != transactionId)   throw new IllegalStateException(""String_Node_Str"" + inTransactionId + ""String_Node_Str""+ transactionId);
  if (isException)   throw (RuntimeException)bytes.readObject();
  return bytes;
}","private Bytes blockingFetch(long timeoutTime,long transactionId) throws IOException {
  int size=receive(SIZE_OF_SIZE,timeoutTime).readInt();
  int requiredSize=size + SIZE_OF_SIZE;
  if (bytes.capacity() < requiredSize) {
    bytes=new ByteBufferBytes(allocateDirect(requiredSize));
  }
  receive(size,timeoutTime);
  boolean isException=bytes.readBoolean();
  long inTransactionId=bytes.readLong();
  if (inTransactionId != transactionId)   throw new IllegalStateException(""String_Node_Str"" + inTransactionId + ""String_Node_Str""+ transactionId);
  if (isException)   throw (RuntimeException)bytes.readObject();
  return bytes;
}",0.7413660782808903
163032,"private Work entrySet(Bytes reader,Bytes writer){
  final long transactionId=reader.readLong();
  final Set<Map.Entry<K,V>> entries;
  try {
    entries=map.entrySet();
  }
 catch (  RuntimeException e) {
    return sendException(reader,writer,e);
  }
  final Iterator<Map.Entry<K,V>> iterator=entries.iterator();
  return new Work(){
    @Override public boolean doWork(    Bytes writer){
      final long sizeLocation=header(writer,transactionId);
      int count=0;
      while (iterator.hasNext()) {
        if (writer.remaining() <= maxEntrySizeBytes) {
          writeHeader(writer,sizeLocation,count,true);
          return false;
        }
        count++;
        final Map.Entry<K,V> next=iterator.next();
        writeKey(next.getKey(),writer);
        writeValue(next.getValue(),writer);
      }
      writeHeader(writer,sizeLocation,count,false);
      return true;
    }
  }
;
}","private Work entrySet(final Bytes reader,Bytes writer){
  final long transactionId=reader.readLong();
  final Set<Map.Entry<K,V>> entries;
  try {
    entries=map.entrySet();
  }
 catch (  RuntimeException e) {
    return sendException(reader,writer,e);
  }
  LOG.info(""String_Node_Str"" + map.size());
  final AtomicInteger i=new AtomicInteger(0);
  final Iterator<Map.Entry<K,V>> iterator=entries.iterator();
  return new Work(){
    @Override public boolean doWork(    Bytes writer){
      if (writer.remaining() <= maxEntrySizeBytes)       return false;
      final long sizeLocation=header(writer,transactionId);
      int count=0;
      while (iterator.hasNext()) {
        if (writer.remaining() <= maxEntrySizeBytes) {
          writeHeader(writer,sizeLocation,count,true,i.incrementAndGet());
          return false;
        }
        count++;
        final Map.Entry<K,V> next=iterator.next();
        writeKey(next.getKey(),writer);
        writeValue(next.getValue(),writer);
      }
      writeHeader(writer,sizeLocation,count,false,i.incrementAndGet());
      return true;
    }
  }
;
}",0.8960321446509292
163033,"private void writeHeader(Bytes writer,long sizeLocation,int count,final boolean hasAnotherChunk){
  final long end=writer.position();
  final int size=(int)(end - sizeLocation);
  writer.position(sizeLocation);
  writer.writeInt(size);
  writer.writeBoolean(false);
  writer.skip(8);
  writer.writeBoolean(hasAnotherChunk);
  writer.writeInt(count);
  writer.position(end);
}","private void writeHeader(Bytes writer,long sizeLocation,int count,final boolean hasAnotherChunk,int seq){
  final long end=writer.position();
  final int size=(int)(end - sizeLocation);
  writer.position(sizeLocation);
  writer.writeInt(size);
  writer.writeBoolean(false);
  writer.skip(8);
  writer.writeBoolean(hasAnotherChunk);
  writer.writeInt(count);
  writer.position(end);
}",0.9894459102902374
163034,"/** 
 * called when the selector receives a OP_WRITE message
 */
private void onWrite(@NotNull final SelectionKey key,final long approxTime) throws InterruptedException, IOException {
  final SocketChannel socketChannel=(SocketChannel)key.channel();
  final Attached attached=(Attached)key.attachment();
  if (attached.entryWriter.isWorkIncomplete()) {
    boolean completed=attached.entryWriter.doWork();
    if (completed)     attached.entryWriter.workCompleted();
    attached.hasRemoteHeartbeatInterval=false;
  }
 else   if (attached.remoteModificationIterator != null)   attached.entryWriter.entriesToBuffer(attached.remoteModificationIterator,key);
  try {
    int bytesJustWritten=attached.entryWriter.writeBufferToSocket(socketChannel,approxTime);
    contemplateThrottleWrites(bytesJustWritten);
  }
 catch (  IOException e) {
    quietClose(key,e);
    if (!attached.isServer)     attached.connector.connectLater();
    throw e;
  }
}","/** 
 * called when the selector receives a OP_WRITE message
 */
private void onWrite(@NotNull final SelectionKey key,final long approxTime) throws InterruptedException, IOException {
  final SocketChannel socketChannel=(SocketChannel)key.channel();
  final Attached attached=(Attached)key.attachment();
  if (attached.entryWriter.isWorkIncomplete()) {
    boolean completed=attached.entryWriter.doWork();
    if (completed)     attached.entryWriter.workCompleted();
    attached.hasRemoteHeartbeatInterval=false;
  }
 else   if (attached.remoteModificationIterator != null)   attached.entryWriter.entriesToBuffer(attached.remoteModificationIterator,key);
  try {
    int bytesJustWritten=attached.entryWriter.writeBufferToSocket(socketChannel,approxTime);
    if (bytesJustWritten > 0)     contemplateThrottleWrites(bytesJustWritten);
  }
 catch (  IOException e) {
    quietClose(key,e);
    if (!attached.isServer)     attached.connector.connectLater();
    throw e;
  }
}",0.984375
163035,"/** 
 * reads entries from the buffer till empty
 * @param attached
 * @throws InterruptedException
 */
private void entriesFromBuffer(Attached attached) throws InterruptedException, IOException {
  for (; ; ) {
    out.limit(in.position());
    if (state == NOT_SET) {
      if (out.remaining() < SIZE_OF_SIZE + 1) {
        return;
      }
      state=out.readByte();
      sizeInBytes=out.readInt();
      long requiredSize=sizeInBytes + SIZE_OF_SIZE + 1;
      if (out.capacity() < requiredSize) {
        attached.entryReader.resizeBuffer(requiredSize + HEADROOM);
      }
      if (state == NOT_SET)       continue;
    }
    if (out.remaining() < sizeInBytes) {
      return;
    }
    final long nextEntryPos=out.position() + sizeInBytes;
    final long limit=out.limit();
    out.limit(nextEntryPos);
    boolean isStateless=(state != 1);
    if (isStateless) {
      if (statelessServerConnector == null) {
        LOG.error(""String_Node_Str"",new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
      }
 else {
        final Work futureWork=statelessServerConnector.processStatelessEvent(state,attached.entryWriter.in,attached.entryReader.out);
        if (futureWork != null) {
          boolean isComplete=futureWork.doWork(attached.entryWriter.in);
          if (!isComplete)           attached.entryWriter.uncompletedWork=futureWork;
        }
      }
    }
 else     externalizable.readExternalEntry(out);
    out.limit(limit);
    out.position(nextEntryPos);
    state=NOT_SET;
    sizeInBytes=0;
  }
}","/** 
 * reads entries from the buffer till empty
 * @param attached
 * @throws InterruptedException
 */
private void entriesFromBuffer(Attached attached) throws InterruptedException, IOException {
  for (; ; ) {
    out.limit(in.position());
    if (state == NOT_SET) {
      if (out.remaining() < SIZE_OF_SIZE + 1) {
        return;
      }
      state=out.readByte();
      sizeInBytes=out.readInt();
      long requiredSize=sizeInBytes + SIZE_OF_SIZE + 1;
      if (out.capacity() < requiredSize) {
        attached.entryReader.resizeBuffer(requiredSize + HEADROOM);
      }
      if (state == NOT_SET)       continue;
    }
    if (out.remaining() < sizeInBytes) {
      return;
    }
    final long nextEntryPos=out.position() + sizeInBytes;
    final long limit=out.limit();
    out.limit(nextEntryPos);
    boolean isStateless=(state != 1);
    if (isStateless) {
      if (statelessServerConnector == null) {
        LOG.error(""String_Node_Str"",new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
      }
 else {
        final Work futureWork=statelessServerConnector.processStatelessEvent(state,attached.entryWriter.in,attached.entryReader.out);
        if (futureWork != null) {
          try {
            boolean isComplete=futureWork.doWork(attached.entryWriter.in);
            if (!isComplete)             attached.entryWriter.uncompletedWork=futureWork;
          }
 catch (          Exception e) {
            LOG.error(""String_Node_Str"",e);
          }
        }
      }
    }
 else     externalizable.readExternalEntry(out);
    out.limit(limit);
    out.position(nextEntryPos);
    state=NOT_SET;
    sizeInBytes=0;
  }
}",0.9619783616692428
163036,"@Override public boolean doWork(Bytes writer){
  final long sizeLocation=header(writer,transactionId);
  int count=0;
  while (iterator.hasNext()) {
    if (writer.remaining() <= maxEntrySizeBytes) {
      writeHeader(writer,sizeLocation,count,true);
      return false;
    }
    count++;
    final Map.Entry<K,V> next=iterator.next();
    writeKey(next.getKey(),writer);
    writeValue(next.getValue(),writer);
  }
  writeHeader(writer,sizeLocation,count,false);
  return true;
}","@Override public boolean doWork(Bytes writer){
  if (writer.remaining() <= maxEntrySizeBytes)   return false;
  final long sizeLocation=header(writer,transactionId);
  int count=0;
  while (iterator.hasNext()) {
    if (writer.remaining() <= maxEntrySizeBytes) {
      writeHeader(writer,sizeLocation,count,true,i.incrementAndGet());
      return false;
    }
    count++;
    final Map.Entry<K,V> next=iterator.next();
    writeKey(next.getKey(),writer);
    writeValue(next.getValue(),writer);
  }
  writeHeader(writer,sizeLocation,count,false,i.incrementAndGet());
  return true;
}",0.9032863849765258
163037,"private Work keySet(Bytes reader,final Bytes writer){
  final long transactionId=reader.readLong();
  Set<K> ks;
  try {
    ks=map.keySet();
  }
 catch (  RuntimeException e) {
    return sendException(reader,writer,e);
  }
  final Iterator<K> iterator=ks.iterator();
  return new Work(){
    @Override public boolean doWork(    Bytes writer){
      final long sizeLocation=header(writer,transactionId);
      int count=0;
      while (iterator.hasNext()) {
        if (writer.remaining() <= maxEntrySizeBytes) {
          writeHeader(writer,sizeLocation,count,true);
          return false;
        }
        count++;
        K key=iterator.next();
        writeKey(key,writer);
      }
      writeHeader(writer,sizeLocation,count,false);
      return true;
    }
  }
;
}","private Work keySet(Bytes reader,final Bytes writer){
  final long transactionId=reader.readLong();
  Set<K> ks;
  try {
    ks=map.keySet();
  }
 catch (  RuntimeException e) {
    return sendException(reader,writer,e);
  }
  final Iterator<K> iterator=ks.iterator();
  return new Work(){
    @Override public boolean doWork(    Bytes writer){
      final long sizeLocation=header(writer,transactionId);
      int count=0;
      while (iterator.hasNext()) {
        if (writer.remaining() <= maxEntrySizeBytes) {
          writeHeader(writer,sizeLocation,count,true,0);
          return false;
        }
        count++;
        K key=iterator.next();
        writeKey(key,writer);
      }
      writeHeader(writer,sizeLocation,count,false,0);
      return true;
    }
  }
;
}",0.9974193548387096
163038,"/** 
 * writes the contents of the buffer to the socket
 * @param socketChannel the socket to publish the buffer to
 * @param approxTime    an approximation of the current time in millis
 * @throws IOException
 */
private int writeBufferToSocket(@NotNull final SocketChannel socketChannel,final long approxTime) throws IOException {
  if (in.position() == 0)   return 0;
  lastSentTime=approxTime;
  out.limit((int)in.position());
  final int len=socketChannel.write(out);
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + len);
  if (out.remaining() == 0) {
    out.clear();
    in.clear();
  }
 else {
    out.compact();
    in.position(out.position());
    in.limit(in.capacity());
    out.clear();
  }
  return len;
}","/** 
 * writes the contents of the buffer to the socket
 * @param socketChannel the socket to publish the buffer to
 * @param approxTime    an approximation of the current time in millis
 * @throws IOException
 */
private int writeBufferToSocket(@NotNull final SocketChannel socketChannel,final long approxTime) throws IOException {
  if (in.position() == 0)   return 0;
  lastSentTime=approxTime;
  int size=(int)in.position();
  out.limit(size);
  final int len=socketChannel.write(out);
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + len);
  if (len == size) {
    out.clear();
    in.clear();
  }
 else {
    out.compact();
    in.position(out.position());
    in.limit(in.capacity());
    out.clear();
  }
  return len;
}",0.9346938775510204
163039,"@Test public void testBufferOverFlowPutAllAndEntrySet() throws IOException, InterruptedException {
  final ChronicleMap<Integer,CharSequence> serverMap;
  final ChronicleMap<Integer,CharSequence> statelessMap;
{
    statelessMap=ChronicleMapBuilder.of(Integer.class,CharSequence.class).stateless(remoteAddress(new InetSocketAddress(""String_Node_Str"",8076))).create();
  }
{
    serverMap=ChronicleMapBuilder.of(Integer.class,CharSequence.class).replicators((byte)2,TcpReplicationConfig.of(8076)).create();
  }
  Map<Integer,CharSequence> payload=new HashMap<Integer,CharSequence>();
  for (int i=0; i < SIZE; i++) {
    payload.put(i,""String_Node_Str"" + i);
  }
  statelessMap.putAll(payload);
  Set<Map.Entry<Integer,CharSequence>> entries=statelessMap.entrySet();
  Map.Entry<Integer,CharSequence> next=entries.iterator().next();
  Assert.assertEquals(""String_Node_Str"" + next.getKey(),next.getValue());
  serverMap.close();
  statelessMap.close();
}","@Test public void testBufferOverFlowPutAllAndEntrySet() throws IOException, InterruptedException {
  final ChronicleMap<Integer,CharSequence> serverMap;
  final ChronicleMap<Integer,CharSequence> statelessMap;
{
    statelessMap=ChronicleMapBuilder.of(Integer.class,CharSequence.class).stateless(remoteAddress(new InetSocketAddress(""String_Node_Str"",8076))).create();
  }
{
    serverMap=ChronicleMapBuilder.of(Integer.class,CharSequence.class).replicators((byte)2,TcpReplicationConfig.of(8076)).create();
  }
  Map<Integer,CharSequence> payload=new HashMap<Integer,CharSequence>();
  for (int i=0; i < SIZE; i++) {
    payload.put(i,""String_Node_Str"" + i);
  }
  statelessMap.putAll(payload);
  Set<Map.Entry<Integer,CharSequence>> entries=statelessMap.entrySet();
  Map.Entry<Integer,CharSequence> next=entries.iterator().next();
  Assert.assertEquals(""String_Node_Str"" + next.getKey(),next.getValue());
  Assert.assertEquals(entries.size(),SIZE);
  serverMap.close();
  statelessMap.close();
}",0.9774127310061602
163040,"ChronicleSetBuilder(Class<E> keyClass){
  chronicleMapBuilder=ChronicleMapBuilder.of(keyClass,DummyValue.class).entryAndValueAlignment(Alignment.NO_ALIGNMENT).valueMarshaller(DummyValueMarshaller.INSTANCE);
}","ChronicleSetBuilder(Class<E> keyClass){
  chronicleMapBuilder=ChronicleMapBuilder.of(keyClass,DummyValue.class).valueMarshaller(DummyValueMarshaller.INSTANCE);
}",0.8726287262872628
163041,"private void updateNextPosToSearchFrom(long allocated,int blocks){
  if ((nextPosToSearchFrom=allocated + blocks) >= freeList.size())   nextPosToSearchFrom=0L;
}","private void updateNextPosToSearchFrom(long allocated,int blocks){
  if ((nextPosToSearchFrom=allocated + blocks) >= entriesPerSegment)   nextPosToSearchFrom=0L;
}",0.925925925925926
163042,"long alloc(int blocks){
  if (blocks > MAX_ENTRY_OVERSIZE_FACTOR)   throw new IllegalArgumentException(""String_Node_Str"" + blocks + ""String_Node_Str""+ MAX_ENTRY_OVERSIZE_FACTOR+ ""String_Node_Str"");
  long ret=freeList.setNextNContinuousClearBits(nextPosToSearchFrom,blocks);
  if (ret == DirectBitSet.NOT_FOUND) {
    ret=freeList.setNextNContinuousClearBits(0L,blocks);
    if (ret == DirectBitSet.NOT_FOUND) {
      if (blocks == 1) {
        throw new IllegalStateException(""String_Node_Str"");
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + blocks + ""String_Node_Str"");
      }
    }
    updateNextPosToSearchFrom(ret,blocks);
  }
 else {
    if (blocks == 1 || freeList.isSet(nextPosToSearchFrom)) {
      updateNextPosToSearchFrom(ret,blocks);
    }
  }
  return ret;
}","long alloc(int blocks){
  if (blocks > MAX_ENTRY_OVERSIZE_FACTOR)   throw new IllegalArgumentException(""String_Node_Str"" + blocks + ""String_Node_Str""+ MAX_ENTRY_OVERSIZE_FACTOR+ ""String_Node_Str"");
  long ret=freeList.setNextNContinuousClearBits(nextPosToSearchFrom,blocks);
  if (ret == DirectBitSet.NOT_FOUND || ret + blocks > entriesPerSegment) {
    if (ret + blocks > entriesPerSegment)     freeList.clear(ret,ret + blocks);
    ret=freeList.setNextNContinuousClearBits(0L,blocks);
    if (ret == DirectBitSet.NOT_FOUND || ret + blocks > entriesPerSegment) {
      if (ret + blocks > entriesPerSegment)       freeList.clear(ret,ret + blocks);
      if (blocks == 1) {
        throw new IllegalStateException(""String_Node_Str"");
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + blocks + ""String_Node_Str"");
      }
    }
    updateNextPosToSearchFrom(ret,blocks);
  }
 else {
    if (blocks == 1 || freeList.isSet(nextPosToSearchFrom)) {
      updateNextPosToSearchFrom(ret,blocks);
    }
  }
  return ret;
}",0.8718783930510315
163043,"/** 
 * Returns the file this hash container mapped to, i. e. when it is created by  {@link ChronicleHashBuilder#create()} call, or {@code null} if it is purely in-memory,i. e. if it is created by  {@link ChronicleHashBuilder#create()} call.
 * @return the file this {@link ChronicleMap} or {@link ChronicleSet} is mapped to,or  {@code null} if it is not mapped to any file
 * @see ChronicleHashBuilder#create(File)
 * @see ChronicleHashBuilder#create()
 */
File file();","/** 
 * Returns the file this hash container mapped to, i. e. when it is created by  {@link ChronicleHashBuilder#create()} call, or {@code null} if it is purely in-memory,i. e. if it is created by  {@link ChronicleHashBuilder#create()} call.
 * @return the file this {@link ChronicleMap} or {@link ChronicleSet} is mapped to,or  {@code null} if it is not mapped to any file
 * @see ChronicleHashBuilder#file(java.io.File)
 * @see ChronicleHashBuilder#create()
 */
File file();",0.9830866807610994
163044,"/** 
 * Specifies that hash containers us the specified file, if create is called and this is not set the map will be created in off-heap memory, and changes will not be persisted to disk. If a file is provided all  changes to the map are  persisted to disk (this is an operating system guarantee) independently from JVM process lifecycle.
 * @param file the file with existing hash container or a desired location of a new off-heappersisted hash container
 * @return this builder back
 * @see ChronicleHash#file()
 * @see ChronicleHash#close()
 */
B file(File file) throws IOException ;","/** 
 * Specifies that hash containers us the specified file, if create is called and this is not set the map will be created in off-heap memory, and changes will not be persisted to disk. If a file is provided all  changes to the map are  persisted to disk (this is an operating system guarantee) independently from JVM process lifecycle.
 * @param file the file with existing hash container or a desired location of a new off-heappersisted hash container
 * @return this builder back
 * @throws IOException If the file cannot be created and read.
 * @see ChronicleHash#file()
 * @see ChronicleHash#close()
 */
B file(File file) throws IOException ;",0.824575586095392
163045,"/** 
 * Returns a replicator, dedicated to the specified channel. Channel is basically just a number, that should correspond on different servers for instances of the same replicated map. Only one replicator per channel could be obtained from a single   {@code ReplicatingChannel}. The returned replicator could be applied to a map at most once.
 * @return a replicator, dedicated to the specified channel
 */
public ChronicleChannel createChannel(short channel){
  return new ChronicleChannel(channel);
}","/** 
 * Returns a replicator, dedicated to the specified channel. Channel is basically just a number, that should correspond on different servers for instances of the same replicated map. Only one replicator per channel could be obtained from a single   {@code ReplicatingChannel}. The returned replicator could be applied to a map at most once.
 * @param channel number to create
 * @return a replicator, dedicated to the specified channel
 */
public ChronicleChannel createChannel(short channel){
  return new ChronicleChannel(channel);
}",0.9665071770334928
163046,"/** 
 * Specifies the value to be put for each key queried in   {@link ChronicleMap#get get()} and{@link ChronicleMap#getUsing(Object,Object) getUsing()} methods, if the key is absent in themap. Then this default value is returned from query method. <p/> <p>Setting default value to  {@code null} is interpreted as map shouldn't put any defaultvalue for absent keys. This is by default. <p/> <p>This configuration overrides any previous  {@link #defaultValueProvider(DefaultValueProvider)}configuration to this   {@code ChronicleMapBuilder}.
 * @param defaultValue the default value to be put to the map for absent keys during {@code get()} and {@code getUsing()} calls and returned from these calls
 * @return this builder object back
 */
public ChronicleMapBuilder<K,V> defaultValue(V defaultValue){
  this.defaultValue=defaultValue;
  this.defaultValueProvider=null;
  return this;
}","/** 
 * Specifies the value to be put for each key queried in   {@link ChronicleMap#get get()} and{@link ChronicleMap#getUsing(Object,Object) getUsing()} methods, if the key is absent in themap. Then this default value is returned from query method. <p>Setting default value to  {@code null} is interpreted as map shouldn't put any defaultvalue for absent keys. This is by default. <p>This configuration overrides any previous  {@link #defaultValueProvider(DefaultValueProvider)}configuration to this   {@code ChronicleMapBuilder}.
 * @param defaultValue the default value to be put to the map for absent keys during {@code get()} and {@code getUsing()} calls and returned from these calls
 * @return this builder object back
 */
public ChronicleMapBuilder<K,V> defaultValue(V defaultValue){
  this.defaultValue=defaultValue;
  this.defaultValueProvider=null;
  return this;
}",0.9943246311010216
163047,"/** 
 * {@inheritDoc}<p/> <p>Example:
 */
@Override public ChronicleMapBuilder<K,V> keyMarshaller(@NotNull BytesMarshaller<K> keyMarshaller){
  keyBuilder.marshaller(keyMarshaller,null);
  return this;
}","/** 
 * {@inheritDoc}<p>Example:
 */
@Override public ChronicleMapBuilder<K,V> keyMarshaller(@NotNull BytesMarshaller<K> keyMarshaller){
  keyBuilder.marshaller(keyMarshaller,null);
  return this;
}",0.9875311720698254
163048,"/** 
 * Configures the constant number of bytes, taken by serialized form of values, put into maps, created by this builder. This is done by providing the   {@code sampleValue}, all values should take the same number of bytes in serialized form, as this sample object. <p/> <p>If values are of boxed primitive type or   {@link Byteable} subclass, i. e. if value size isknown statically, it is automatically accounted and this method shouldn't be called. <p/> <p>If value size varies, method  {@link #valueSize(int)} or {@link #entrySize(int)} should becalled instead of this one.
 * @param sampleValue the sample value
 * @return this builder back
 * @see #valueSize(int)
 * @see #constantKeySizeBySample(Object)
 */
public ChronicleMapBuilder<K,V> constantValueSizeBySample(V sampleValue){
  this.sampleValue=sampleValue;
  return this;
}","/** 
 * Configures the constant number of bytes, taken by serialized form of values, put into maps, created by this builder. This is done by providing the   {@code sampleValue}, all values should take the same number of bytes in serialized form, as this sample object. <p>If values are of boxed primitive type or   {@link Byteable} subclass, i. e. if value size isknown statically, it is automatically accounted and this method shouldn't be called. <p>If value size varies, method  {@link #valueSize(int)} or {@link #entrySize(int)} should becalled instead of this one.
 * @param sampleValue the sample value
 * @return this builder back
 * @see #valueSize(int)
 * @see #constantKeySizeBySample(Object)
 */
public ChronicleMapBuilder<K,V> constantValueSizeBySample(V sampleValue){
  this.sampleValue=sampleValue;
  return this;
}",0.9940047961630696
163049,"/** 
 * {@inheritDoc}<p/> <p>For example, if your keys are Git commit hashes:<pre>  {@code Map<byte[], String> gitCommitMessagesByHash = ChronicleMapBuilder.of(byte[].class, String.class) .constantKeySizeBySample(new byte[20]) .create();}</pre>
 * @see #keySize(int)
 * @see #constantValueSizeBySample(Object)
 */
@Override public ChronicleMapBuilder<K,V> constantKeySizeBySample(K sampleKey){
  this.sampleKey=sampleKey;
  return this;
}","/** 
 * {@inheritDoc}<p>For example, if your keys are Git commit hashes:<pre>  {@code Map<byte[], String> gitCommitMessagesByHash = ChronicleMapBuilder.of(byte[].class, String.class) .constantKeySizeBySample(new byte[20]) .create();}</pre>
 * @see #keySize(int)
 * @see #constantValueSizeBySample(Object)
 */
@Override public ChronicleMapBuilder<K,V> constantKeySizeBySample(K sampleKey){
  this.sampleKey=sampleKey;
  return this;
}",0.9942594718714122
163050,"/** 
 * {@inheritDoc}<p/> <p>Example: <pre>  {@code Map<Key, Value> map =ChronicleMapBuilder.of(Key.class, Value.class) .entries(1_000_000) .keySize(50).valueSize(200) // this class hasn't implemented yet, just for example .objectSerializer(new KryoObjectSerializer()) .create();}</pre> <p/> <p>This serializer is used to serialize both keys and values, if they both require this: loosely typed, nullable, and custom   {@linkplain #keyMarshaller(BytesMarshaller) key} and{@linkplain #valueMarshallerAndFactory(BytesMarshaller,ObjectFactory) value} marshallers arenot configured.
 */
@Override public ChronicleMapBuilder<K,V> objectSerializer(ObjectSerializer objectSerializer){
  this.objectSerializer=objectSerializer;
  return this;
}","/** 
 * {@inheritDoc}<p>Example: <pre>  {@code Map<Key, Value> map =ChronicleMapBuilder.of(Key.class, Value.class) .entries(1_000_000) .keySize(50).valueSize(200) // this class hasn't implemented yet, just for example .objectSerializer(new KryoObjectSerializer()) .create();}</pre> <p>This serializer is used to serialize both keys and values, if they both require this: loosely typed, nullable, and custom   {@linkplain #keyMarshaller(BytesMarshaller) key} and{@linkplain #valueMarshallerAndFactory(BytesMarshaller,ObjectFactory) value} marshallers arenot configured.
 */
@Override public ChronicleMapBuilder<K,V> objectSerializer(ObjectSerializer objectSerializer){
  this.objectSerializer=objectSerializer;
  return this;
}",0.9931600547195624
163051,"/** 
 * Returns the timestamp of the last change from the specified remote node, already replicated to this Replica. <p/> <p>Used in conjunction with replication, to back fill data from a remote node. This node may have missed updates while it was not been running or connected via TCP.
 * @param remoteIdentifier the identifier of the remote node to check last replicated update time from
 * @return a timestamp of the last modification to an entry, or 0 if there are no entries.
 * @see #identifier()
 */
long lastModificationTime(byte remoteIdentifier);","/** 
 * Returns the timestamp of the last change from the specified remote node, already replicated to this Replica.  <p>Used in conjunction with replication, to back fill data from a remote node. This node may have missed updates while it was not been running or connected via TCP.
 * @param remoteIdentifier the identifier of the remote node to check last replicated update time from
 * @return a timestamp of the last modification to an entry, or 0 if there are no entries.
 * @see #identifier()
 */
long lastModificationTime(byte remoteIdentifier);",0.9963898916967509
163052,"/** 
 * Dirties all entries with a modification time equal to   {@code fromTimeStamp} or newer. It means allthese entries will be considered as ""new"" by this ModificationIterator and iterated once again no matter if they have already been. <p/> <p>This functionality is used to publish recently modified entries to a new remote node as it connects.
 * @param fromTimeStamp the timestamp from which all entries should be dirty
 */
void dirtyEntries(long fromTimeStamp);","/** 
 * Dirties all entries with a modification time equal to   {@code fromTimeStamp} or newer. It means allthese entries will be considered as ""new"" by this ModificationIterator and iterated once again no matter if they have already been.  <p>This functionality is used to publish recently modified entries to a new remote node as it connects.
 * @param fromTimeStamp the timestamp from which all entries should be dirty
 */
void dirtyEntries(long fromTimeStamp);",0.9957081545064378
163053,"/** 
 * Used only with replication, its sometimes possible to receive an old ( or stale update ) from a remote map. This method is used to determine if we should ignore such updates. <p/> <p>We can reject put() and removes() when comparing times stamps with remote systems
 * @param entry      the maps entry
 * @param timestamp  the time the entry was created or updated
 * @param identifier the unique identifier relating to this map
 * @return true if the entry should not be processed
 */
private boolean shouldIgnore(@NotNull final NativeBytes entry,final long timestamp,final byte identifier){
  final long lastModifiedTimeStamp=entry.readLong();
  if (lastModifiedTimeStamp < timestamp) {
    entry.skip(1);
    return false;
  }
  if (lastModifiedTimeStamp > timestamp)   return true;
  return entry.readByte() > identifier;
}","/** 
 * Used only with replication, its sometimes possible to receive an old ( or stale update ) from a remote map. This method is used to determine if we should ignore such updates. <p>We can reject put() and removes() when comparing times stamps with remote systems
 * @param entry      the maps entry
 * @param timestamp  the time the entry was created or updated
 * @param identifier the unique identifier relating to this map
 * @return true if the entry should not be processed
 */
private boolean shouldIgnore(@NotNull final NativeBytes entry,final long timestamp,final byte identifier){
  final long lastModifiedTimeStamp=entry.readLong();
  if (lastModifiedTimeStamp < timestamp) {
    entry.skip(1);
    return false;
  }
  if (lastModifiedTimeStamp > timestamp)   return true;
  return entry.readByte() > identifier;
}",0.9969933854479855
163054,"void preMapConstruction(){
  keyBuilder.objectSerializer(objectSerializer());
  valueBuilder.objectSerializer(objectSerializer());
  int maxSize=entrySize() * figureBufferAllocationFactor();
  keyBuilder.maxSize(maxSize);
  valueBuilder.maxSize(maxSize);
  if (sampleKey != null)   keyBuilder.constantSizeBySample(sampleKey);
  if (sampleValue != null)   valueBuilder.constantSizeBySample(sampleValue);
}","void preMapConstruction(){
  keyBuilder.objectSerializer(objectSerializer());
  valueBuilder.objectSerializer(objectSerializer());
  long maxSize=(long)entrySize() * figureBufferAllocationFactor();
  keyBuilder.maxSize(maxSize);
  valueBuilder.maxSize(maxSize);
  if (sampleKey != null)   keyBuilder.constantSizeBySample(sampleKey);
  if (sampleValue != null)   valueBuilder.constantSizeBySample(sampleValue);
}",0.9840490797546012
163055,"int alloc(int blocks){
  if (blocks > MAX_ENTRY_OVERSIZE_FACTOR)   throw new IllegalArgumentException(""String_Node_Str"" + blocks + ""String_Node_Str""+ MAX_ENTRY_OVERSIZE_FACTOR+ ""String_Node_Str"");
  int ret=(int)freeList.setNextNContinuousClearBits(nextPosToSearchFrom,blocks);
  if (ret == DirectBitSet.NOT_FOUND) {
    ret=(int)freeList.setNextNContinuousClearBits(0,blocks);
    if (ret == DirectBitSet.NOT_FOUND) {
      if (blocks == 1) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + blocks + ""String_Node_Str"");
      }
    }
  }
  if (blocks == 1 || freeList.isSet(nextPosToSearchFrom))   nextPosToSearchFrom=ret + blocks;
  return ret;
}","int alloc(int blocks){
  if (blocks > MAX_ENTRY_OVERSIZE_FACTOR)   throw new IllegalArgumentException(""String_Node_Str"" + blocks + ""String_Node_Str""+ MAX_ENTRY_OVERSIZE_FACTOR+ ""String_Node_Str"");
  int ret=(int)freeList.setNextNContinuousClearBits(nextPosToSearchFrom,blocks);
  if (ret == DirectBitSet.NOT_FOUND) {
    ret=(int)freeList.setNextNContinuousClearBits(0,blocks);
    if (ret == DirectBitSet.NOT_FOUND) {
      if (blocks == 1) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + blocks + ""String_Node_Str"");
      }
    }
    updateNextPosToSearchFrom(ret,blocks);
  }
 else {
    if (blocks == 1 || freeList.isSet(nextPosToSearchFrom)) {
      updateNextPosToSearchFrom(ret,blocks);
    }
  }
  return ret;
}",0.93196405648267
163056,"public VanillaChronicleMap(ChronicleMapBuilder<K,V> builder) throws IOException {
  SerializationBuilder<K> keyBuilder=builder.keyBuilder;
  kClass=keyBuilder.eClass;
  keySizeMarshaller=keyBuilder.sizeMarshaller();
  originalKeyReader=keyBuilder.reader();
  originalKeyInterop=(KI)keyBuilder.interop();
  originalMetaKeyInterop=(MKI)keyBuilder.metaInterop();
  metaKeyInteropProvider=(MetaProvider<K,KI,MKI>)keyBuilder.metaInteropProvider();
  SerializationBuilder<V> valueBuilder=builder.valueBuilder;
  vClass=valueBuilder.eClass;
  valueSizeMarshaller=valueBuilder.sizeMarshaller();
  originalValueReader=valueBuilder.reader();
  originalValueWriter=(VW)valueBuilder.interop();
  originalMetaValueWriter=(MVW)valueBuilder.metaInterop();
  metaValueWriterProvider=(MetaProvider)valueBuilder.metaInteropProvider();
  valueFactory=valueBuilder.factory();
  defaultValueProvider=builder.defaultValueProvider();
  lockTimeOutNS=builder.lockTimeOut(TimeUnit.NANOSECONDS);
  this.entrySize=builder.entrySize();
  this.alignment=builder.entryAndValueAlignment();
  this.errorListener=builder.errorListener();
  this.putReturnsNull=builder.putReturnsNull();
  this.removeReturnsNull=builder.removeReturnsNull();
  this.actualSegments=builder.actualSegments();
  this.entriesPerSegment=builder.actualEntriesPerSegment();
  this.metaDataBytes=builder.metaDataBytes();
  this.eventListener=builder.eventListener();
  this.mask=useSmallMultiMaps() ? 0xFFFF : ~0;
  this.bits=Maths.intLog2(actualSegments);
  initTransients();
}","public VanillaChronicleMap(ChronicleMapBuilder<K,V> builder) throws IOException {
  SerializationBuilder<K> keyBuilder=builder.keyBuilder;
  kClass=keyBuilder.eClass;
  keySizeMarshaller=keyBuilder.sizeMarshaller();
  originalKeyReader=keyBuilder.reader();
  originalKeyInterop=(KI)keyBuilder.interop();
  originalMetaKeyInterop=(MKI)keyBuilder.metaInterop();
  metaKeyInteropProvider=(MetaProvider<K,KI,MKI>)keyBuilder.metaInteropProvider();
  SerializationBuilder<V> valueBuilder=builder.valueBuilder;
  vClass=valueBuilder.eClass;
  valueSizeMarshaller=valueBuilder.sizeMarshaller();
  originalValueReader=valueBuilder.reader();
  originalValueWriter=(VW)valueBuilder.interop();
  originalMetaValueWriter=(MVW)valueBuilder.metaInterop();
  metaValueWriterProvider=(MetaProvider)valueBuilder.metaInteropProvider();
  valueFactory=valueBuilder.factory();
  defaultValueProvider=builder.defaultValueProvider();
  lockTimeOutNS=builder.lockTimeOut(TimeUnit.NANOSECONDS);
  this.entrySize=builder.entrySize();
  this.alignment=builder.entryAndValueAlignment();
  this.errorListener=builder.errorListener();
  this.putReturnsNull=builder.putReturnsNull();
  this.removeReturnsNull=builder.removeReturnsNull();
  this.actualSegments=builder.actualSegments();
  this.entriesPerSegment=align8(builder.actualEntriesPerSegment());
  this.metaDataBytes=builder.metaDataBytes();
  this.eventListener=builder.eventListener();
  this.mask=useSmallMultiMaps() ? 0xFFFF : ~0;
  this.bits=Maths.intLog2(actualSegments);
  initTransients();
}",0.9973718791064388
163057,"@SuppressWarnings(""String_Node_Str"") SerializationBuilder(Class<E> eClass,Role role){
  this.bufferIdentity=role;
  this.eClass=eClass;
  instancesAreMutable=instancesAreMutable(eClass);
  ObjectFactory<E> factory=null;
  if (role == Role.VALUE) {
    factory=concreteClass(eClass) && marshallerUseFactory(eClass) ? new NewInstanceObjectFactory<E>(eClass) : (ObjectFactory<E>)NullObjectFactory.of();
  }
  if (concreteClass(eClass) && Byteable.class.isAssignableFrom(eClass)) {
    agileMarshaller(ByteableMarshaller.of((Class)eClass),factory);
  }
 else   if (eClass == CharSequence.class || eClass == String.class) {
    reader((BytesReader<E>)CharSequenceReader.of(),factory);
    writer((BytesWriter<E>)CharSequenceWriter.instance());
  }
 else   if (eClass == Void.class) {
    agileMarshaller((AgileBytesMarshaller<E>)VoidMarshaller.INSTANCE,factory);
  }
 else   if (eClass == Long.class) {
    agileMarshaller((AgileBytesMarshaller<E>)LongMarshaller.INSTANCE,factory);
  }
 else   if (eClass == Double.class) {
    agileMarshaller((AgileBytesMarshaller<E>)DoubleMarshaller.INSTANCE,factory);
  }
 else   if (eClass == Integer.class) {
    agileMarshaller((AgileBytesMarshaller<E>)IntegerMarshaller.INSTANCE,factory);
  }
 else   if (eClass == byte[].class) {
    reader((BytesReader<E>)ByteArrayMarshaller.INSTANCE,factory);
    interop((BytesInterop<E>)ByteArrayMarshaller.INSTANCE);
  }
 else   if (concreteClass(eClass)) {
    BytesMarshaller<E> marshaller=chooseMarshaller(eClass,eClass);
    if (marshaller != null)     marshaller(marshaller,factory);
  }
  if (role == Role.VALUE && concreteClass(eClass) && marshallerUseFactory(eClass)) {
    factory(factory);
  }
}","@SuppressWarnings(""String_Node_Str"") SerializationBuilder(Class<E> eClass,Role role){
  this.bufferIdentity=role;
  this.eClass=eClass;
  instancesAreMutable=instancesAreMutable(eClass);
  ObjectFactory<E> factory=null;
  if (role == Role.VALUE) {
    factory=concreteClass(eClass) && marshallerUseFactory(eClass) ? new NewInstanceObjectFactory<E>(eClass) : (ObjectFactory<E>)NullObjectFactory.<E>of();
  }
  if (concreteClass(eClass) && Byteable.class.isAssignableFrom(eClass)) {
    agileMarshaller(ByteableMarshaller.of((Class)eClass),factory);
  }
 else   if (eClass == CharSequence.class || eClass == String.class) {
    reader((BytesReader<E>)CharSequenceReader.of(),factory);
    writer((BytesWriter<E>)CharSequenceWriter.instance());
  }
 else   if (eClass == Void.class) {
    agileMarshaller((AgileBytesMarshaller<E>)VoidMarshaller.INSTANCE,factory);
  }
 else   if (eClass == Long.class) {
    agileMarshaller((AgileBytesMarshaller<E>)LongMarshaller.INSTANCE,factory);
  }
 else   if (eClass == Double.class) {
    agileMarshaller((AgileBytesMarshaller<E>)DoubleMarshaller.INSTANCE,factory);
  }
 else   if (eClass == Integer.class) {
    agileMarshaller((AgileBytesMarshaller<E>)IntegerMarshaller.INSTANCE,factory);
  }
 else   if (eClass == byte[].class) {
    reader((BytesReader<E>)ByteArrayMarshaller.INSTANCE,factory);
    interop((BytesInterop<E>)ByteArrayMarshaller.INSTANCE);
  }
 else   if (concreteClass(eClass)) {
    BytesMarshaller<E> marshaller=chooseMarshaller(eClass,eClass);
    if (marshaller != null)     marshaller(marshaller,factory);
  }
  if (role == Role.VALUE && concreteClass(eClass) && marshallerUseFactory(eClass)) {
    factory(factory);
  }
}",0.999108469539376
163058,"/** 
 * Specifies the value to be put for each key queried in   {@link ChronicleMap#get get()} and{@link ChronicleMap#getUsing(Object,Object) getUsing()} methods, if the key is absentin the map. Then this default value is returned from query method. <p>Setting default value to  {@code null} is interpreted as map shouldn't put any defaultvalue for absent keys. This is by default. <p>This configuration overrides any previous {@link #defaultValueProvider(DefaultValueProvider)} configuration to this{@code ChronicleMapBuilder}.
 * @param defaultValue the default value to be put to the map for absent keys during{@code get()} and {@code getUsing()} calls and returned from these calls
 * @return this builder object back
 */
public ChronicleMapBuilder<K,V> defaultValue(V defaultValue){
  this.defaultValue=defaultValue;
  this.defaultValueProvider=null;
  return this;
}","/** 
 * Specifies the value to be put for each key queried in   {@link ChronicleMap#get get()} and {@link ChronicleMap#getUsing(Object,Object) getUsing()} methods, if the key is absent in the map. Then thisdefault value is returned from query method. <p>Setting default value to  {@code null} is interpreted as map shouldn't put any default value forabsent keys. This is by default. <p>This configuration overrides any previous  {@link #defaultValueProvider(DefaultValueProvider)}configuration to this   {@code ChronicleMapBuilder}.
 * @param defaultValue the default value to be put to the map for absent keys during {@code get()} and{@code getUsing()} calls and returned from these calls
 * @return this builder object back
 */
public ChronicleMapBuilder<K,V> defaultValue(V defaultValue){
  this.defaultValue=defaultValue;
  this.defaultValueProvider=null;
  return this;
}",0.9588100686498856
163059,"/** 
 * Configures the constant number of bytes, taken by serialized form of values, put into maps, created by this builder. This is done by providing the   {@code sampleValue}, all values should take the same number of bytes in serialized form, as this sample object. <p>If values are of boxed primitive type or   {@link Byteable} subclass, i. e. if value sizeis known statically, it is automatically accounted and this method shouldn't be called. <p>If value size varies, method  {@link #valueSize(int)} or {@link #entrySize(int)} should becalled instead of this one.
 * @param sampleValue the sample value
 * @return this builder back
 * @see #valueSize(int)
 * @see #constantKeySizeBySample(Object)
 */
public ChronicleMapBuilder<K,V> constantValueSizeBySample(V sampleValue){
  this.sampleValue=sampleValue;
  return this;
}","/** 
 * Configures the constant number of bytes, taken by serialized form of values, put into maps, created by this builder. This is done by providing the   {@code sampleValue}, all values should take the same number of bytes in serialized form, as this sample object. <p>If values are of boxed primitive type or   {@link Byteable} subclass, i. e. if value size is knownstatically, it is automatically accounted and this method shouldn't be called. <p>If value size varies, method  {@link #valueSize(int)} or {@link #entrySize(int)} should be calledinstead of this one.
 * @param sampleValue the sample value
 * @return this builder back
 * @see #valueSize(int)
 * @see #constantKeySizeBySample(Object)
 */
public ChronicleMapBuilder<K,V> constantValueSizeBySample(V sampleValue){
  this.sampleValue=sampleValue;
  return this;
}",0.9903498190591074
163060,"@Override public boolean wasRemoved(@NotNull Bytes entry){
  final long start=entry.position();
  try {
    return entry.readBoolean(keySizeMarshaller.readSize(entry) + 10);
  }
  finally {
    entry.position(start);
  }
}","@Override public boolean wasRemoved(@NotNull Bytes entry){
  final long start=entry.position();
  try {
    return entry.readBoolean(keySizeMarshaller.readSize(entry) + 9);
  }
  finally {
    entry.position(start);
  }
}",0.9932279909706546
163061,"WithCustomFactory(@NotNull Class<E> tClass,@NotNull ObjectFactory<E> factory){
  super(tClass);
  this.factory=factory;
}","WithCustomFactory(@NotNull Class<E> tClass,@NotNull ObjectFactory<E> factory){
  super(tClass);
  this.factory=factory;
  initSize();
}",0.9453125
163062,"public static <E extends Byteable>ByteableMarshaller<E> of(@NotNull Class<E> eClass,ObjectFactory<E> factory){
  if (factory instanceof AllocateInstanceObjectFactory) {
    Class allocatedClass=((AllocateInstanceObjectFactory)factory).allocatedClass();
    return new ByteableMarshaller<E>(allocatedClass);
  }
 else {
    return new WithCustomFactory<E>(eClass,factory);
  }
}","public static <E extends Byteable>ByteableMarshaller<E> of(@NotNull Class<E> eClass,ObjectFactory<E> factory){
  if (factory instanceof AllocateInstanceObjectFactory) {
    Class allocatedClass=((AllocateInstanceObjectFactory)factory).allocatedClass();
    return new Default<E>(allocatedClass);
  }
 else {
    return new WithCustomFactory<E>(eClass,factory);
  }
}",0.9663526244952894
163063,"ByteableMarshaller(@NotNull Class<E> tClass){
  this.tClass=tClass;
  try {
    size=getInstance().maxSize();
  }
 catch (  Exception e) {
    throw new IllegalStateException(e);
  }
}","private ByteableMarshaller(@NotNull Class<E> tClass){
  this.tClass=tClass;
}",0.5287356321839081
163064,"/** 
 * used to exchange identifiers and timestamps and heartbeat intervals between the server and client
 * @param key           the SelectionKey relating to the this cha
 * @param socketChannel
 * @throws java.io.IOException
 * @throws InterruptedException
 */
private void doHandShaking(@NotNull final SelectionKey key,SocketChannel socketChannel) throws IOException, InterruptedException {
  final Attached attached=(Attached)key.attachment();
  final TcpSocketChannelEntryWriter writer=attached.entryWriter;
  final TcpSocketChannelEntryReader reader=attached.entryReader;
  if (attached.remoteIdentifier == Byte.MIN_VALUE) {
    final byte remoteIdentifier=reader.identifierFromBuffer();
    if (remoteIdentifier == Byte.MIN_VALUE)     return;
    attached.remoteIdentifier=remoteIdentifier;
    selectionKeysStore[remoteIdentifier]=key;
    activeKeys.set(remoteIdentifier);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"",localIdentifier,remoteIdentifier);
    }
    final IdentifierListener identifierListener=replicationConfig.identifierListener;
    final SocketAddress remoteAddress=socketChannel.getRemoteAddress();
    boolean identifierIsUnique;
    if (identifierListener != null) {
      identifierIsUnique=identifierListener.isIdentifierUnique(remoteIdentifier,remoteAddress);
    }
 else {
      identifierIsUnique=remoteIdentifier != localIdentifier;
    }
    if (identifierIsUnique) {
      throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + remoteIdentifier);
    }
    attached.remoteModificationIterator=replica.acquireModificationIterator(remoteIdentifier,attached);
    writer.writeRemoteBootstrapTimestamp(replica.lastModificationTime(remoteIdentifier));
    writer.writeRemoteHeartbeatInterval(heartBeatIntervalMillis);
  }
  if (attached.remoteBootstrapTimestamp == Long.MIN_VALUE) {
    attached.remoteBootstrapTimestamp=reader.remoteBootstrapTimestamp();
    if (attached.remoteBootstrapTimestamp == Long.MIN_VALUE)     return;
  }
  if (!attached.hasRemoteHeartbeatInterval) {
    long value=reader.remoteHeartbeatIntervalFromBuffer();
    if (value == Long.MIN_VALUE)     return;
    if (value < 0) {
      LOG.error(""String_Node_Str"" + value);
    }
    attached.remoteHeartbeatInterval=(long)(value * 1.25);
    selectorTimeout=Math.min(selectorTimeout,value);
    if (selectorTimeout < 0)     LOG.info(""String_Node_Str"");
    attached.hasRemoteHeartbeatInterval=true;
    attached.handShakingComplete=true;
    attached.remoteModificationIterator.dirtyEntries(attached.remoteBootstrapTimestamp);
    reader.entriesFromBuffer();
  }
}","/** 
 * used to exchange identifiers and timestamps and heartbeat intervals between the server and client
 * @param key           the SelectionKey relating to the this cha
 * @param socketChannel
 * @throws java.io.IOException
 * @throws InterruptedException
 */
private void doHandShaking(@NotNull final SelectionKey key,SocketChannel socketChannel) throws IOException, InterruptedException {
  final Attached attached=(Attached)key.attachment();
  final TcpSocketChannelEntryWriter writer=attached.entryWriter;
  final TcpSocketChannelEntryReader reader=attached.entryReader;
  if (attached.remoteIdentifier == Byte.MIN_VALUE) {
    final byte remoteIdentifier=reader.identifierFromBuffer();
    if (remoteIdentifier == Byte.MIN_VALUE)     return;
    attached.remoteIdentifier=remoteIdentifier;
    selectionKeysStore[remoteIdentifier]=key;
    activeKeys.set(remoteIdentifier);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"",localIdentifier,remoteIdentifier);
    }
    final IdentifierListener identifierListener=replicationConfig.identifierListener;
    final SocketAddress remoteAddress=socketChannel.getRemoteAddress();
    if ((identifierListener != null && !identifierListener.isIdentifierUnique(remoteIdentifier,remoteAddress)) || remoteIdentifier == localIdentifier)     throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + remoteIdentifier);
    attached.remoteModificationIterator=replica.acquireModificationIterator(remoteIdentifier,attached);
    writer.writeRemoteBootstrapTimestamp(replica.lastModificationTime(remoteIdentifier));
    writer.writeRemoteHeartbeatInterval(heartBeatIntervalMillis);
  }
  if (attached.remoteBootstrapTimestamp == Long.MIN_VALUE) {
    attached.remoteBootstrapTimestamp=reader.remoteBootstrapTimestamp();
    if (attached.remoteBootstrapTimestamp == Long.MIN_VALUE)     return;
  }
  if (!attached.hasRemoteHeartbeatInterval) {
    long value=reader.remoteHeartbeatIntervalFromBuffer();
    if (value == Long.MIN_VALUE)     return;
    if (value < 0) {
      LOG.error(""String_Node_Str"" + value);
    }
    attached.remoteHeartbeatInterval=(long)(value * 1.25);
    selectorTimeout=Math.min(selectorTimeout,value);
    if (selectorTimeout < 0)     LOG.info(""String_Node_Str"");
    attached.hasRemoteHeartbeatInterval=true;
    attached.handShakingComplete=true;
    attached.remoteModificationIterator.dirtyEntries(attached.remoteBootstrapTimestamp);
    reader.entriesFromBuffer();
  }
}",0.9309462915601024
163065,"/** 
 * sets up a 2 clusters ( notionally one for each host ), and replicates 2 Chronicle Maps between them
 * @throws IOException
 * @throws InterruptedException
 */
@Test public void test() throws IOException, InterruptedException {
  map2a.put(1,""String_Node_Str"");
  map1a.put(1,""String_Node_Str"");
  waitTillEqual(2500);
  Assert.assertEquals(""String_Node_Str"",map1a,map1b);
  Assert.assertEquals(""String_Node_Str"",map2a,map2b);
  assertTrue(""String_Node_Str"",!map1a.isEmpty());
  assertTrue(""String_Node_Str"",!map2a.isEmpty());
}","/** 
 * sets up a 2 clusters ( notionally one for each host ), and replicates 2 Chronicle Maps between them
 * @throws IOException
 * @throws InterruptedException
 */
@Test @Ignore public void test() throws IOException, InterruptedException {
  map2a.put(1,""String_Node_Str"");
  map1a.put(1,""String_Node_Str"");
  waitTillEqual(2500);
  Assert.assertEquals(""String_Node_Str"",map1a,map1b);
  Assert.assertEquals(""String_Node_Str"",map2a,map2b);
  assertTrue(""String_Node_Str"",!map1a.isEmpty());
  assertTrue(""String_Node_Str"",!map2a.isEmpty());
}",0.9925788497217068
163066,"@SuppressWarnings(""String_Node_Str"") private static <T>BytesMarshaller<T> chooseDefaultMarshaller(@NotNull Class<T> tClass){
  if (Byteable.class.isAssignableFrom(tClass))   return new ByteableMarshaller(tClass);
  if (BytesMarshallable.class.isAssignableFrom(tClass))   return new BytesMarshallableMarshaller(tClass);
  if (Externalizable.class.isAssignableFrom(tClass))   return new ExternalizableMarshaller(tClass);
  if (tClass == CharSequence.class)   return (BytesMarshaller<T>)CharSequenceMarshaller.INSTANCE;
  if (tClass == String.class)   return (BytesMarshaller<T>)StringMarshaller.INSTANCE;
  if (tClass == Integer.class)   return (BytesMarshaller<T>)IntegerMarshaller.INSTANCE;
  if (tClass == Long.class)   return (BytesMarshaller<T>)LongMarshaller.INSTANCE;
  if (tClass == Double.class)   return (BytesMarshaller<T>)DoubleMarshaller.INSTANCE;
  return SerializableMarshaller.INSTANCE;
}","@SuppressWarnings(""String_Node_Str"") private static <T>BytesMarshaller<T> chooseDefaultMarshaller(@NotNull Class<T> tClass){
  Class<T> classForMarshaller=marshallerUseFactory(tClass) && tClass.isInterface() ? DataValueClasses.directClassFor(tClass) : tClass;
  if (Byteable.class.isAssignableFrom(tClass))   return new ByteableMarshaller(classForMarshaller);
  if (BytesMarshallable.class.isAssignableFrom(tClass))   return new BytesMarshallableMarshaller(classForMarshaller);
  if (Externalizable.class.isAssignableFrom(tClass))   return new ExternalizableMarshaller(classForMarshaller);
  if (tClass == CharSequence.class)   return (BytesMarshaller<T>)CharSequenceMarshaller.INSTANCE;
  if (tClass == String.class)   return (BytesMarshaller<T>)StringMarshaller.INSTANCE;
  if (tClass == Integer.class)   return (BytesMarshaller<T>)IntegerMarshaller.INSTANCE;
  if (tClass == Long.class)   return (BytesMarshaller<T>)LongMarshaller.INSTANCE;
  if (tClass == Double.class)   return (BytesMarshaller<T>)DoubleMarshaller.INSTANCE;
  return SerializableMarshaller.INSTANCE;
}",0.8951898734177215
163067,"ChronicleMapBuilder(Class<K> keyClass,Class<V> valueClass){
  this.keyClass=keyClass;
  this.valueClass=valueClass;
  Class<K> keyClassForMarshaller=marshallerUseFactory(keyClass) && keyClass.isInterface() ? DataValueClasses.directClassFor(keyClass) : keyClass;
  keyMarshaller=chooseDefaultMarshaller(keyClassForMarshaller);
  Class<V> valueClassForMarshaller=marshallerUseFactory(valueClass) && valueClass.isInterface() ? DataValueClasses.directClassFor(valueClass) : valueClass;
  valueMarshaller=chooseDefaultMarshaller(valueClassForMarshaller);
  valueFactory=marshallerUseFactory(valueClass) ? new AllocateInstanceObjectFactory(valueClass.isInterface() ? DataValueClasses.directClassFor(valueClass) : valueClass) : NullObjectFactory.INSTANCE;
}","ChronicleMapBuilder(Class<K> keyClass,Class<V> valueClass){
  this.keyClass=keyClass;
  this.valueClass=valueClass;
  keyMarshaller=chooseDefaultMarshaller(keyClass);
  valueMarshaller=chooseDefaultMarshaller(valueClass);
  valueFactory=marshallerUseFactory(valueClass) ? new AllocateInstanceObjectFactory(valueClass.isInterface() ? DataValueClasses.directClassFor(valueClass) : valueClass) : NullObjectFactory.INSTANCE;
}",0.6092150170648464
163068,"@Before public void setup() throws IOException {
{
    final TcpReplicationConfig tcpReplicationConfig=TcpReplicationConfig.of(8086,new InetSocketAddress(""String_Node_Str"",8087)).heartBeatInterval(1,SECONDS);
    clusterA=new ReplicatingClusterBuilder((byte)1,1024).tcpReplication(tcpReplicationConfig).create();
    map1a=ChronicleMapBuilder.of(Integer.class,CharSequence.class).entries(1000).addReplicator(clusterA.channelReplicator((short)1)).create(getPersistenceFile());
    map2a=ChronicleMapBuilder.of(Integer.class,CharSequence.class).entries(1000).addReplicator(clusterA.channelReplicator((short)2)).create(getPersistenceFile());
  }
{
    final TcpReplicationConfig tcpReplicationConfig=TcpReplicationConfig.of(8087).heartBeatInterval(1,SECONDS);
    clusterB=new ReplicatingClusterBuilder((byte)2,1024).tcpReplication(tcpReplicationConfig).create();
    map1b=ChronicleMapBuilder.of(Integer.class,CharSequence.class).entries(1000).addReplicator(clusterB.channelReplicator((short)1)).create(getPersistenceFile());
    map2b=ChronicleMapBuilder.of(Integer.class,CharSequence.class).entries(1000).addReplicator(clusterB.channelReplicator((short)2)).create(getPersistenceFile());
  }
}","@Before public void setup() throws IOException {
{
    final TcpReplicationConfig tcpReplicationConfig=TcpReplicationConfig.of(8086,new InetSocketAddress(""String_Node_Str"",8087)).heartBeatInterval(1,SECONDS);
    clusterA=new ReplicatingClusterBuilder((byte)1,1024).tcpReplication(tcpReplicationConfig).create();
    map1a=ChronicleMapBuilder.of(Integer.class,CharSequence.class).entries(1000).addReplicator(clusterA.channelReplicator((short)1)).create(getPersistenceFile());
    map2a=ChronicleMapBuilder.of(Integer.class,CharSequence.class).entries(1000).addReplicator(clusterA.channelReplicator((short)2)).create(getPersistenceFile());
  }
{
    final TcpReplicationConfig tcpReplicationConfig=TcpReplicationConfig.of(8087,new InetSocketAddress(""String_Node_Str"",8086)).heartBeatInterval(1,SECONDS);
    clusterB=new ReplicatingClusterBuilder((byte)2,1024).tcpReplication(tcpReplicationConfig).create();
    map1b=ChronicleMapBuilder.of(Integer.class,CharSequence.class).entries(1000).addReplicator(clusterB.channelReplicator((short)1)).create(getPersistenceFile());
    map2b=ChronicleMapBuilder.of(Integer.class,CharSequence.class).entries(1000).addReplicator(clusterB.channelReplicator((short)2)).create(getPersistenceFile());
  }
}",0.9810699588477366
163069,"@Before public void setup() throws IOException {
{
    final TcpReplicationConfig tcpReplicationConfig=TcpReplicationConfig.of(8086,new InetSocketAddress(""String_Node_Str"",8087)).heartBeatInterval(1,SECONDS);
    clusterA=new ReplicatingClusterBuilder((byte)1,1024).tcpReplication(tcpReplicationConfig).create();
    map1a=ChronicleMapBuilder.of(Integer.class,CharSequence.class).entries(1000).addReplicator(clusterA.channelReplicator((short)1)).create(getPersistenceFile());
  }
{
    final TcpReplicationConfig replicationConfig=TcpReplicationConfig.of(8087).heartBeatInterval(1,SECONDS);
    clusterB=new ReplicatingClusterBuilder((byte)2,1024).tcpReplication(replicationConfig).create();
    map1b=ChronicleMapBuilder.of(Integer.class,CharSequence.class).addReplicator(clusterB.channelReplicator((short)1)).entries(1000).create(getPersistenceFile());
  }
}","@Before public void setup() throws IOException {
{
    final TcpReplicationConfig tcpReplicationConfig=TcpReplicationConfig.of(8086,new InetSocketAddress(""String_Node_Str"",8087)).heartBeatInterval(1,SECONDS);
    clusterA=new ReplicatingClusterBuilder((byte)1,1024).tcpReplication(tcpReplicationConfig).create();
    map1a=ChronicleMapBuilder.of(Integer.class,CharSequence.class).entries(1000).addReplicator(clusterA.channelReplicator((short)1)).create(getPersistenceFile());
  }
{
    final TcpReplicationConfig tcpReplicationConfig=TcpReplicationConfig.of(8087,new InetSocketAddress(""String_Node_Str"",8086)).heartBeatInterval(1,SECONDS);
    clusterB=new ReplicatingClusterBuilder((byte)2,1024).tcpReplication(tcpReplicationConfig).create();
    map1b=ChronicleMapBuilder.of(Integer.class,CharSequence.class).addReplicator(clusterB.channelReplicator((short)1)).entries(1000).create(getPersistenceFile());
  }
}",0.9683972911963884
163070,"SharedHashMapBuilder<K,V> toBuilder() throws IOException {
  SharedHashMapBuilder builder=clone();
  for (int i=0; i < 10; i++) {
    if (file.exists() && file.length() > 0) {
      readFile(file,builder);
      break;
    }
    if (file.createNewFile() || file.length() == 0) {
      newFile(file);
      break;
    }
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new IOException(e);
    }
  }
  if (builder == null || !file.exists())   throw new FileNotFoundException(""String_Node_Str"" + file);
  return builder;
}","SharedHashMapBuilder<K,V> toBuilder() throws IOException {
  SharedHashMapBuilder builder=clone();
  if (file != null) {
    for (int i=0; i < 10; i++) {
      if (file.exists() && file.length() > 0) {
        readFile(file,builder);
        break;
      }
      if (file.createNewFile() || file.length() == 0) {
        newFile(file);
        break;
      }
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
        throw new IOException(e);
      }
    }
    if (builder == null || !file.exists())     throw new FileNotFoundException(""String_Node_Str"" + file);
  }
  return builder;
}",0.9476351351351352
163071,"/** 
 * this is used to iterate over all the modification iterators
 * @return
 */
int assignedModIterBitSetSizeInBytes(){
  return (int)align64((long)Math.ceil(127 + RESERVED_MOD_ITER / 8));
}","private int assignedModIterBitSetSizeInBytes(){
  return (int)align64((127 + RESERVED_MOD_ITER) / 8);
}",0.668918918918919
163072,"@Override public void onDraw(Canvas canvas){
  if (image == null)   return;
  if (image.getHeight() == 0 || image.getWidth() == 0)   return;
  int oldCanvasSize=canvasSize;
  canvasSize=canvas.getWidth();
  if (canvas.getHeight() < canvasSize)   canvasSize=canvas.getHeight();
  if (oldCanvasSize != canvasSize)   refreshBitmapShader();
  paint.setShader(shader);
  int outerWidth=0;
  int center=canvasSize / 2;
  if (hasSelector && isSelected) {
    outerWidth=selectorStrokeWidth;
    center=(canvasSize - (outerWidth * 2)) / 2;
    paint.setColorFilter(selectorFilter);
    canvas.drawCircle(center + outerWidth,center + outerWidth,((canvasSize - (outerWidth * 2)) / 2) + outerWidth - 4.0f,paintSelectorBorder);
  }
 else   if (hasBorder) {
    outerWidth=borderWidth;
    center=(canvasSize - (outerWidth * 2)) / 2;
    paint.setColorFilter(null);
    canvas.drawCircle(center + outerWidth,center + outerWidth,((canvasSize - (outerWidth * 2)) / 2) + outerWidth - 4.0f,paintBorder);
  }
 else   paint.setColorFilter(null);
  canvas.drawCircle(center + outerWidth,center + outerWidth,((canvasSize - (outerWidth * 2)) / 2) - 4.0f,paint);
}","@Override public void onDraw(Canvas canvas){
  if (image == null)   return;
  if (image.getHeight() == 0 || image.getWidth() == 0)   return;
  int oldCanvasSize=canvasSize;
  canvasSize=getWidth() < getHeight() ? getWidth() : getHeight();
  if (oldCanvasSize != canvasSize)   refreshBitmapShader();
  paint.setShader(shader);
  int outerWidth=0;
  int center=canvasSize / 2;
  if (hasSelector && isSelected) {
    outerWidth=selectorStrokeWidth;
    center=(canvasSize - (outerWidth * 2)) / 2;
    paint.setColorFilter(selectorFilter);
    canvas.drawCircle(center + outerWidth,center + outerWidth,((canvasSize - (outerWidth * 2)) / 2) + outerWidth - 4.0f,paintSelectorBorder);
  }
 else   if (hasBorder) {
    outerWidth=borderWidth;
    center=(canvasSize - (outerWidth * 2)) / 2;
    paint.setColorFilter(null);
    canvas.drawCircle(center + outerWidth,center + outerWidth,((canvasSize - (outerWidth * 2)) / 2) + outerWidth - 4.0f,paintBorder);
  }
 else   paint.setColorFilter(null);
  canvas.drawCircle(center + outerWidth,center + outerWidth,((canvasSize - (outerWidth * 2)) / 2) - 4.0f,paint);
}",0.967023172905526
163073,"private void visitNonModuleAttributeCall(@NotNull final Call call){
  if (org.elixir_lang.structure_view.element.CallDefinitionClause.is(call)) {
    visitCallDefinitionClause(call);
  }
 else {
    PsiReference reference=call.getReference();
    if (reference != null) {
      Collection<PsiElement> resolvedCollection=null;
      if (reference instanceof PsiPolyVariantReference) {
        PsiPolyVariantReference polyVariantReference=(PsiPolyVariantReference)reference;
        ResolveResult[] resolveResults;
        try {
          resolveResults=polyVariantReference.multiResolve(false);
        }
 catch (        StackOverflowError stackOverflowError) {
          Logger.error(Callable.class,""String_Node_Str"",call);
          resolveResults=new ResolveResult[0];
        }
        List<ResolveResult> validResolveResults=ContainerUtil.filter(resolveResults,new Condition<ResolveResult>(){
          @Override public boolean value(          ResolveResult resolveResult){
            return resolveResult.isValidResult();
          }
        }
);
        resolvedCollection=ContainerUtil.map(validResolveResults,new com.intellij.util.Function<ResolveResult,PsiElement>(){
          @Override public PsiElement fun(          ResolveResult resolveResult){
            return resolveResult.getElement();
          }
        }
);
      }
 else {
        PsiElement resolved=reference.resolve();
        if (resolved != null) {
          resolvedCollection=Collections.singleton(resolved);
        }
      }
      if (resolvedCollection != null) {
        for (        PsiElement resolved : resolvedCollection) {
          highlight(call,reference.getRangeInElement(),resolved,holder);
        }
      }
    }
 else     if (isBitStreamSegmentOption(call)) {
      String name=call.getName();
      if (name != null && BIT_STRING_TYPES.contains(name)) {
        highlight(call,holder,ElixirSyntaxHighlighter.TYPE);
      }
    }
  }
}","private void visitNonModuleAttributeCall(@NotNull final Call call){
  if (org.elixir_lang.structure_view.element.CallDefinitionClause.is(call)) {
    visitCallDefinitionClause(call);
  }
 else {
    PsiReference reference=call.getReference();
    if (reference != null) {
      Collection<PsiElement> resolvedCollection=null;
      if (reference instanceof PsiPolyVariantReference) {
        PsiPolyVariantReference polyVariantReference=(PsiPolyVariantReference)reference;
        ResolveResult[] resolveResults;
        try {
          resolveResults=polyVariantReference.multiResolve(false);
        }
 catch (        StackOverflowError stackOverflowError) {
          Logger.error(Callable.class,""String_Node_Str"",call);
          resolveResults=new ResolveResult[0];
        }
        List<ResolveResult> validResolveResults=ContainerUtil.filter(resolveResults,new Condition<ResolveResult>(){
          @Override public boolean value(          ResolveResult resolveResult){
            return resolveResult.isValidResult();
          }
        }
);
        resolvedCollection=ContainerUtil.map(validResolveResults,new com.intellij.util.Function<ResolveResult,PsiElement>(){
          @Override public PsiElement fun(          ResolveResult resolveResult){
            return resolveResult.getElement();
          }
        }
);
      }
 else {
        PsiElement resolved=reference.resolve();
        if (resolved != null) {
          resolvedCollection=Collections.singleton(resolved);
        }
      }
      if (resolvedCollection != null && resolvedCollection.size() > 0) {
        for (        PsiElement resolved : resolvedCollection) {
          highlight(call,reference.getRangeInElement(),resolved,holder);
        }
      }
 else       if (call.hasDoBlockOrKeyword()) {
        PsiElement functionNameElement=call.functionNameElement();
        if (functionNameElement != null) {
          highlight(functionNameElement.getTextRange(),holder,ElixirSyntaxHighlighter.MACRO_CALL);
        }
      }
    }
 else     if (isBitStreamSegmentOption(call)) {
      String name=call.getName();
      if (name != null && BIT_STRING_TYPES.contains(name)) {
        highlight(call,holder,ElixirSyntaxHighlighter.TYPE);
      }
    }
  }
}",0.926689027311931
163074,"/** 
 * Annotates the specified PSI element. It is guaranteed to be executed in non-reentrant fashion. I.e there will be no call of this method for this instance before previous call get completed. Multiple instances of the annotator might exist simultaneously, though.
 * @param element to annotate.
 * @param holder  the container which receives annotations created by the plugin.
 */
@Override public void annotate(@NotNull final PsiElement element,@NotNull final AnnotationHolder holder){
  element.accept(new PsiRecursiveElementVisitor(){
    @Override public void visitElement(    @NotNull final PsiElement element){
      if (element instanceof Call) {
        visitCall((Call)element);
      }
    }
    private void visitCall(    @NotNull final Call call){
      if (!(call instanceof AtNonNumericOperation || call instanceof AtUnqualifiedNoParenthesesCall)) {
        visitNonModuleAttributeCall(call);
      }
    }
    private void visitCallDefinitionClause(    @NotNull final Call call){
      PsiElement head=org.elixir_lang.structure_view.element.CallDefinitionClause.head(call);
      if (head != null) {
        visitCallDefinitionHead(head,call);
      }
    }
    private void visitCallDefinitionHead(    @NotNull final PsiElement head,    @NotNull final Call clause){
      PsiElement stripped=org.elixir_lang.structure_view.element.CallDefinitionHead.strip(head);
      if (stripped instanceof Call) {
        visitStrippedCallDefinitionHead((Call)stripped,clause);
      }
    }
    private void visitNonModuleAttributeCall(    @NotNull final Call call){
      if (org.elixir_lang.structure_view.element.CallDefinitionClause.is(call)) {
        visitCallDefinitionClause(call);
      }
 else {
        PsiReference reference=call.getReference();
        if (reference != null) {
          Collection<PsiElement> resolvedCollection=null;
          if (reference instanceof PsiPolyVariantReference) {
            PsiPolyVariantReference polyVariantReference=(PsiPolyVariantReference)reference;
            ResolveResult[] resolveResults;
            try {
              resolveResults=polyVariantReference.multiResolve(false);
            }
 catch (            StackOverflowError stackOverflowError) {
              Logger.error(Callable.class,""String_Node_Str"",call);
              resolveResults=new ResolveResult[0];
            }
            List<ResolveResult> validResolveResults=ContainerUtil.filter(resolveResults,new Condition<ResolveResult>(){
              @Override public boolean value(              ResolveResult resolveResult){
                return resolveResult.isValidResult();
              }
            }
);
            resolvedCollection=ContainerUtil.map(validResolveResults,new com.intellij.util.Function<ResolveResult,PsiElement>(){
              @Override public PsiElement fun(              ResolveResult resolveResult){
                return resolveResult.getElement();
              }
            }
);
          }
 else {
            PsiElement resolved=reference.resolve();
            if (resolved != null) {
              resolvedCollection=Collections.singleton(resolved);
            }
          }
          if (resolvedCollection != null) {
            for (            PsiElement resolved : resolvedCollection) {
              highlight(call,reference.getRangeInElement(),resolved,holder);
            }
          }
        }
 else         if (isBitStreamSegmentOption(call)) {
          String name=call.getName();
          if (name != null && BIT_STRING_TYPES.contains(name)) {
            highlight(call,holder,ElixirSyntaxHighlighter.TYPE);
          }
        }
      }
    }
    private void visitStrippedCallDefinitionHead(    @NotNull final Call stripped,    @NotNull final Call clause){
      PsiElement functionNameElement=stripped.functionNameElement();
      if (functionNameElement != null) {
        TextAttributesKey textAttributeKey=null;
        if (org.elixir_lang.structure_view.element.CallDefinitionClause.isFunction(clause)) {
          textAttributeKey=ElixirSyntaxHighlighter.FUNCTION_DECLARATION;
        }
 else         if (org.elixir_lang.structure_view.element.CallDefinitionClause.isMacro(clause)) {
          textAttributeKey=ElixirSyntaxHighlighter.MACRO_DECLARATION;
        }
        if (textAttributeKey != null) {
          highlight(functionNameElement,holder,textAttributeKey);
        }
      }
    }
  }
);
}","/** 
 * Annotates the specified PSI element. It is guaranteed to be executed in non-reentrant fashion. I.e there will be no call of this method for this instance before previous call get completed. Multiple instances of the annotator might exist simultaneously, though.
 * @param element to annotate.
 * @param holder  the container which receives annotations created by the plugin.
 */
@Override public void annotate(@NotNull final PsiElement element,@NotNull final AnnotationHolder holder){
  element.accept(new PsiRecursiveElementVisitor(){
    @Override public void visitElement(    @NotNull final PsiElement element){
      if (element instanceof Call) {
        visitCall((Call)element);
      }
    }
    private void visitCall(    @NotNull final Call call){
      if (!(call instanceof AtNonNumericOperation || call instanceof AtUnqualifiedNoParenthesesCall)) {
        visitNonModuleAttributeCall(call);
      }
    }
    private void visitCallDefinitionClause(    @NotNull final Call call){
      PsiElement head=org.elixir_lang.structure_view.element.CallDefinitionClause.head(call);
      if (head != null) {
        visitCallDefinitionHead(head,call);
      }
    }
    private void visitCallDefinitionHead(    @NotNull final PsiElement head,    @NotNull final Call clause){
      PsiElement stripped=org.elixir_lang.structure_view.element.CallDefinitionHead.strip(head);
      if (stripped instanceof Call) {
        visitStrippedCallDefinitionHead((Call)stripped,clause);
      }
    }
    private void visitNonModuleAttributeCall(    @NotNull final Call call){
      if (org.elixir_lang.structure_view.element.CallDefinitionClause.is(call)) {
        visitCallDefinitionClause(call);
      }
 else {
        PsiReference reference=call.getReference();
        if (reference != null) {
          Collection<PsiElement> resolvedCollection=null;
          if (reference instanceof PsiPolyVariantReference) {
            PsiPolyVariantReference polyVariantReference=(PsiPolyVariantReference)reference;
            ResolveResult[] resolveResults;
            try {
              resolveResults=polyVariantReference.multiResolve(false);
            }
 catch (            StackOverflowError stackOverflowError) {
              Logger.error(Callable.class,""String_Node_Str"",call);
              resolveResults=new ResolveResult[0];
            }
            List<ResolveResult> validResolveResults=ContainerUtil.filter(resolveResults,new Condition<ResolveResult>(){
              @Override public boolean value(              ResolveResult resolveResult){
                return resolveResult.isValidResult();
              }
            }
);
            resolvedCollection=ContainerUtil.map(validResolveResults,new com.intellij.util.Function<ResolveResult,PsiElement>(){
              @Override public PsiElement fun(              ResolveResult resolveResult){
                return resolveResult.getElement();
              }
            }
);
          }
 else {
            PsiElement resolved=reference.resolve();
            if (resolved != null) {
              resolvedCollection=Collections.singleton(resolved);
            }
          }
          if (resolvedCollection != null && resolvedCollection.size() > 0) {
            for (            PsiElement resolved : resolvedCollection) {
              highlight(call,reference.getRangeInElement(),resolved,holder);
            }
          }
 else           if (call.hasDoBlockOrKeyword()) {
            PsiElement functionNameElement=call.functionNameElement();
            if (functionNameElement != null) {
              highlight(functionNameElement.getTextRange(),holder,ElixirSyntaxHighlighter.MACRO_CALL);
            }
          }
        }
 else         if (isBitStreamSegmentOption(call)) {
          String name=call.getName();
          if (name != null && BIT_STRING_TYPES.contains(name)) {
            highlight(call,holder,ElixirSyntaxHighlighter.TYPE);
          }
        }
      }
    }
    private void visitStrippedCallDefinitionHead(    @NotNull final Call stripped,    @NotNull final Call clause){
      PsiElement functionNameElement=stripped.functionNameElement();
      if (functionNameElement != null) {
        TextAttributesKey textAttributeKey=null;
        if (org.elixir_lang.structure_view.element.CallDefinitionClause.isFunction(clause)) {
          textAttributeKey=ElixirSyntaxHighlighter.FUNCTION_DECLARATION;
        }
 else         if (org.elixir_lang.structure_view.element.CallDefinitionClause.isMacro(clause)) {
          textAttributeKey=ElixirSyntaxHighlighter.MACRO_DECLARATION;
        }
        if (textAttributeKey != null) {
          highlight(functionNameElement,holder,textAttributeKey);
        }
      }
    }
  }
);
}",0.9639028658936776
163075,"@Override public boolean processDeclarations(@NotNull PsiScopeProcessor processor,@NotNull ResolveState state,PsiElement lastParent,@NotNull PsiElement place){
  return ElixirPsiImplUtil.processDeclarationsInPreviousSibling(this,processor,state,lastParent,place);
}","@Override public boolean processDeclarations(@NotNull PsiScopeProcessor processor,@NotNull ResolveState state,PsiElement lastParent,@NotNull PsiElement place){
  boolean keepProcessing=ElixirPsiImplUtil.processDeclarationsInPreviousSibling(this,processor,state,lastParent,place);
  if (keepProcessing) {
    processor.execute(this,state);
  }
  return keepProcessing;
}",0.8138801261829653
163076,"@NotNull public static PsiElement fullyResolveAlias(@NotNull QualifiableAlias alias,@Nullable PsiReference startingReference){
  PsiElement fullyResolved;
  PsiElement currentResolved=alias;
  PsiReference reference=startingReference;
  do {
    if (reference == null) {
      reference=currentResolved.getReference();
    }
    if (reference != null) {
      if (reference instanceof PsiPolyVariantReference) {
        PsiPolyVariantReference polyVariantReference=(PsiPolyVariantReference)reference;
        ResolveResult[] resolveResults=polyVariantReference.multiResolve(false);
        int resolveResultCount=resolveResults.length;
        if (resolveResultCount == 0) {
          fullyResolved=currentResolved;
          break;
        }
 else         if (resolveResultCount == 1) {
          ResolveResult resolveResult=resolveResults[0];
          PsiElement nextResolved=resolveResult.getElement();
          if (nextResolved == null || nextResolved.isEquivalentTo(currentResolved)) {
            fullyResolved=currentResolved;
            break;
          }
 else {
            currentResolved=nextResolved;
          }
        }
 else {
          PsiElement nextResolved=null;
          for (          ResolveResult resolveResult : resolveResults) {
            PsiElement resolveResultElement=resolveResult.getElement();
            if (resolveResultElement != null && resolveResultElement instanceof Call && isModular((Call)resolveResultElement)) {
              nextResolved=resolveResultElement;
              break;
            }
          }
          if (nextResolved == null || nextResolved.isEquivalentTo(currentResolved)) {
            fullyResolved=currentResolved;
            break;
          }
 else {
            currentResolved=nextResolved;
          }
        }
      }
 else {
        PsiElement nextResolved=reference.resolve();
        if (nextResolved == null || nextResolved.isEquivalentTo(currentResolved)) {
          fullyResolved=currentResolved;
          break;
        }
 else {
          currentResolved=nextResolved;
        }
      }
    }
 else {
      fullyResolved=currentResolved;
      break;
    }
    reference=null;
  }
 while (true);
  return fullyResolved;
}","@NotNull public static PsiElement fullyResolveAlias(@NotNull QualifiableAlias alias,@Nullable PsiReference startingReference){
  PsiElement fullyResolved;
  PsiElement currentResolved=alias;
  PsiReference reference=startingReference;
  do {
    if (reference == null) {
      reference=currentResolved.getReference();
    }
    if (reference != null) {
      if (reference instanceof PsiPolyVariantReference) {
        PsiPolyVariantReference polyVariantReference=(PsiPolyVariantReference)reference;
        ResolveResult[] resolveResults=polyVariantReference.multiResolve(false);
        int resolveResultCount=resolveResults.length;
        if (resolveResultCount == 0) {
          fullyResolved=currentResolved;
          break;
        }
 else         if (resolveResultCount == 1) {
          ResolveResult resolveResult=resolveResults[0];
          PsiElement nextResolved=resolveResult.getElement();
          if (nextResolved != null && nextResolved instanceof Call && isModular((Call)nextResolved)) {
            fullyResolved=nextResolved;
            break;
          }
          if (nextResolved == null || nextResolved.isEquivalentTo(currentResolved)) {
            fullyResolved=currentResolved;
            break;
          }
 else {
            currentResolved=nextResolved;
          }
        }
 else {
          PsiElement nextResolved=null;
          for (          ResolveResult resolveResult : resolveResults) {
            PsiElement resolveResultElement=resolveResult.getElement();
            if (resolveResultElement != null && resolveResultElement instanceof Call && isModular((Call)resolveResultElement)) {
              nextResolved=resolveResultElement;
              break;
            }
          }
          if (nextResolved == null) {
            fullyResolved=currentResolved;
          }
 else {
            fullyResolved=nextResolved;
          }
          break;
        }
      }
 else {
        PsiElement nextResolved=reference.resolve();
        if (nextResolved == null || nextResolved.isEquivalentTo(currentResolved)) {
          fullyResolved=currentResolved;
          break;
        }
 else {
          currentResolved=nextResolved;
        }
      }
    }
 else {
      fullyResolved=currentResolved;
      break;
    }
    reference=null;
  }
 while (true);
  return fullyResolved;
}",0.8414795244385733
163077,"protected boolean execute(@NotNull Call element,@NotNull final ResolveState state){
  boolean keepProcessing=true;
  if (org.elixir_lang.structure_view.element.CallDefinitionClause.is(element)) {
    keepProcessing=executeOnCallDefinitionClause(element,state);
  }
 else   if (Import.is(element)) {
    final ResolveState importState=state.put(IMPORT_CALL,element);
    try {
      Import.callDefinitionClauseCallWhile(element,new Function<Call,Boolean>(){
        @Override public Boolean fun(        Call callDefinitionClause){
          return executeOnCallDefinitionClause(callDefinitionClause,importState);
        }
      }
);
    }
 catch (    StackOverflowError stackOverflowError) {
      Logger.error(CallDefinitionClause.class,""String_Node_Str"",element);
    }
  }
 else   if (Module.is(element)) {
    Call[] childCalls=macroChildCalls(element);
    if (childCalls != null) {
      for (      Call childCall : childCalls) {
        if (!execute(childCall,state)) {
          break;
        }
      }
    }
    keepProcessing=keepProcessing();
  }
  return keepProcessing;
}","private boolean execute(@NotNull Call element,@NotNull final ResolveState state){
  boolean keepProcessing=true;
  if (org.elixir_lang.structure_view.element.CallDefinitionClause.is(element)) {
    keepProcessing=executeOnCallDefinitionClause(element,state);
  }
 else   if (Import.is(element)) {
    final ResolveState importState=state.put(IMPORT_CALL,element);
    try {
      Import.callDefinitionClauseCallWhile(element,new Function<Call,Boolean>(){
        @Override public Boolean fun(        Call callDefinitionClause){
          return executeOnCallDefinitionClause(callDefinitionClause,importState);
        }
      }
);
    }
 catch (    StackOverflowError stackOverflowError) {
      Logger.error(CallDefinitionClause.class,""String_Node_Str"",element);
    }
  }
 else   if (Module.is(element)) {
    Call[] childCalls=macroChildCalls(element);
    if (childCalls != null) {
      for (      Call childCall : childCalls) {
        if (!execute(childCall,state)) {
          break;
        }
      }
    }
    keepProcessing=keepProcessing();
    if (keepProcessing) {
      keepProcessing=implicitImports(element,state);
    }
  }
  return keepProcessing;
}",0.9569462938304484
163078,"@Override public Boolean fun(Call callDefinitionClause){
  return executeOnCallDefinitionClause(callDefinitionClause,importState);
}","@Override public Boolean fun(Call callDefinitionClause){
  return executeOnCallDefinitionClause(callDefinitionClause,modularCanonicalNameState);
}",0.920863309352518
163079,"@Nullable public static List<LookupElement> lookupElementList(@NotNull PsiElement entrance){
  Variants variants=new Variants();
  Parameter parameter=Parameter.putParameterized(new Parameter(entrance));
  Call entranceCallDefinitionClause=null;
  if (parameter.isCallDefinitionClauseName()) {
    entranceCallDefinitionClause=(Call)parameter.parameterized;
  }
  ResolveState resolveState=ResolveState.initial().put(ENTRANCE,entrance).put(ENTRANCE_CALL_DEFINITION_CLAUSE,entranceCallDefinitionClause);
  PsiTreeUtil.treeWalkUp(variants,entrance,entrance.getContainingFile(),resolveState);
  List<LookupElement> lookupElementList=new ArrayList<LookupElement>();
  lookupElementList.addAll(variants.getLookupElementCollection());
  variants.addProjectNameElementsTo(lookupElementList,entrance,entranceCallDefinitionClause);
  return lookupElementList;
}","@Nullable public static List<LookupElement> lookupElementList(@NotNull PsiElement entrance){
  Variants variants=new Variants();
  Parameter parameter=Parameter.putParameterized(new Parameter(entrance));
  Call entranceCallDefinitionClause=null;
  if (parameter.isCallDefinitionClauseName()) {
    entranceCallDefinitionClause=(Call)parameter.parameterized;
  }
  ResolveState resolveState=ResolveState.initial().put(ENTRANCE,entrance).put(ENTRANCE_CALL_DEFINITION_CLAUSE,entranceCallDefinitionClause);
  PsiTreeUtil.treeWalkUp(variants,entrance,entrance.getContainingFile(),resolveState);
  List<LookupElement> lookupElementList=new ArrayList<LookupElement>();
  lookupElementList.addAll(variants.getLookupElementCollection());
  return lookupElementList;
}",0.941614906832298
163080,"/** 
 * Called on every   {@link Call} where {@link org.elixir_lang.structure_view.element.CallDefinitionClause#is} is{@code true} when checking tree with {@link #execute(Call,ResolveState)}
 * @param element
 * @param state
 * @return {@code true} to keep searching up tree; {@code false} to stop searching.
 */
@Override protected boolean executeOnCallDefinitionClause(Call element,ResolveState state){
  Call entranceCallDefinitionClause=state.get(ENTRANCE_CALL_DEFINITION_CLAUSE);
  if (entranceCallDefinitionClause == null || !element.isEquivalentTo(entranceCallDefinitionClause)) {
    addToLookupElementByPsiElement(element);
  }
  return true;
}","/** 
 * Called on every   {@link Call} where {@link org.elixir_lang.structure_view.element.CallDefinitionClause#is} is{@code true} when checking tree with {@link #execute(Call,ResolveState)}
 * @return {@code true} to keep searching up tree; {@code false} to stop searching.
 */
@Override protected boolean executeOnCallDefinitionClause(Call element,ResolveState state){
  Call entranceCallDefinitionClause=state.get(ENTRANCE_CALL_DEFINITION_CLAUSE);
  if (entranceCallDefinitionClause == null || !element.isEquivalentTo(entranceCallDefinitionClause)) {
    addToLookupElementByPsiElement(element);
  }
  return true;
}",0.9732704402515724
163081,"private static File putFile(@NotNull String fileName,@NotNull File directory) throws IOException {
  URL moduleUrl=ResourceUtil.getResource(ElixirModules.class,""String_Node_Str"",fileName);
  if (moduleUrl == null) {
    throw new IOException(""String_Node_Str"" + fileName);
  }
  try (BufferedInputStream inputStream=new BufferedInputStream(URLUtil.openStream(moduleUrl))){
    File file=new File(directory,fileName);
    try (BufferedOutputStream outputStream=new BufferedOutputStream(new FileOutputStream(file))){
      FileUtil.copy(inputStream,outputStream);
      return file;
    }
   }
 }","private static File putFile(@NotNull String fileName,@NotNull File directory) throws IOException {
  URL moduleUrl=ResourceUtil.getResource(ElixirModules.class,""String_Node_Str"",fileName);
  if (moduleUrl == null) {
    throw new IOException(""String_Node_Str"" + fileName);
  }
  BufferedInputStream inputStream=new BufferedInputStream(URLUtil.openStream(moduleUrl));
  File file=new File(directory,fileName);
  BufferedOutputStream outputStream=new BufferedOutputStream(new FileOutputStream(file));
  try {
    FileUtil.copy(inputStream,outputStream);
    return file;
  }
  finally {
    inputStream.close();
    outputStream.close();
  }
}",0.7012145748987855
163082,"@Nullable @Override public BracePair findPair(boolean left,HighlighterIterator iterator,CharSequence fileText,FileType fileType){
  BracePair pair=super.findPair(left,iterator,fileText,fileType);
  if (pair == DO_END) {
    iterator.advance();
    IElementType tokenType=iterator.getTokenType();
    if (tokenType == ElixirTypes.KEYWORD_PAIR_COLON) {
      pair=null;
    }
    iterator.retreat();
  }
  return pair;
}","@Nullable @Override public BracePair findPair(boolean left,HighlighterIterator iterator,CharSequence fileText,FileType fileType){
  BracePair pair=super.findPair(left,iterator,fileText,fileType);
  if (pair == DO_END || pair == FN_END) {
    iterator.advance();
    IElementType tokenType=iterator.getTokenType();
    if (tokenType == ElixirTypes.KEYWORD_PAIR_COLON) {
      pair=null;
    }
    iterator.retreat();
  }
  return pair;
}",0.9789227166276346
163083,"@Nullable @Override public Result applyFilter(@NotNull String line,int entireLength){
  Matcher matcher=myPattern.matcher(line);
  if (!matcher.find()) {
    return null;
  }
  String filePath=matcher.group(myFileMatchGroup);
  int fileLine=matchGroupToNumber(matcher,myLineMatchGroup);
  int fileColumn=matchGroupToNumber(matcher,myColumnMatchGroup);
  int highlightStartOffset=entireLength - line.length() + matcher.start(0);
  int highlightEndOffset=highlightStartOffset + matcher.end(0) - matcher.start(0);
  VirtualFile absolutePath=resolveAbsolutePath(filePath);
  HyperlinkInfo hyperlinkInfo=absolutePath != null ? new OpenFileHyperlinkInfo(myProject,absolutePath,fileLine,fileColumn) : null;
  return new Result(highlightStartOffset,highlightEndOffset,hyperlinkInfo);
}","@Nullable @Override public Result applyFilter(@NotNull String line,int entireLength){
  Matcher matcher=myPattern.matcher(line);
  if (!matcher.find()) {
    return null;
  }
  String filePath=matcher.group(myFileMatchGroup);
  int fileLine=matchGroupToNumber(matcher,myLineMatchGroup);
  int fileColumn=matchGroupToNumber(matcher,myColumnMatchGroup);
  int highlightStartOffset=entireLength - line.length() + matcher.start(0) + 1;
  int highlightEndOffset=highlightStartOffset + matcher.end(0) - matcher.start(0) - 1;
  VirtualFile absolutePath=resolveAbsolutePath(filePath);
  HyperlinkInfo hyperlinkInfo=absolutePath != null ? new OpenFileHyperlinkInfo(myProject,absolutePath,fileLine,fileColumn) : null;
  return new Result(highlightStartOffset,highlightEndOffset,hyperlinkInfo);
}",0.9948783610755442
163084,"/** 
 * Highlights the function name of the declared @type, @typep, or @opaque as an   {@link ElixirSyntaxHighlighter.TYPE}and the its parameters as   {@link ElixirSyntaxHighlighter.TYPE_PARAMETER}.
 */
private void highlightType(@NotNull final AtUnqualifiedNoParenthesesCall atUnqualifiedNoParenthesesCall,@NotNull final AnnotationHolder annotationHolder){
  PsiElement noParenthesesOneArgument=atUnqualifiedNoParenthesesCall.getNoParenthesesOneArgument();
  PsiElement[] grandChildren=noParenthesesOneArgument.getChildren();
  if (grandChildren.length == 1) {
    PsiElement grandChild=grandChildren[0];
    if (grandChild instanceof Match) {
    }
 else     if (grandChild instanceof Type) {
      Infix infix=(Infix)grandChild;
      PsiElement leftOperand=infix.leftOperand();
      Set<String> typeParameterNameSet=Collections.emptySet();
      if (leftOperand instanceof Call) {
        Call call=(Call)leftOperand;
        PsiElement functionNameElement=call.functionNameElement();
        if (functionNameElement != null) {
          highlight(functionNameElement.getTextRange(),annotationHolder,ElixirSyntaxHighlighter.TYPE);
        }
        if (call instanceof ElixirMatchedUnqualifiedNoArgumentsCall) {
        }
 else         if (call instanceof ElixirMatchedUnqualifiedParenthesesCall) {
          PsiElement[] primaryArguments=call.primaryArguments();
          PsiElement[] secondaryArguments=call.secondaryArguments();
          if (secondaryArguments != null) {
            typeParameterNameSet=typeTypeParameterNameSet(secondaryArguments);
            highlightTypesAndTypeParameterUsages(primaryArguments,Collections.<String>emptySet(),annotationHolder,ElixirSyntaxHighlighter.TYPE);
            highlightTypesAndTypeTypeParameterDeclarations(secondaryArguments,typeParameterNameSet,annotationHolder,ElixirSyntaxHighlighter.TYPE);
          }
 else           if (primaryArguments != null) {
            typeParameterNameSet=typeTypeParameterNameSet(primaryArguments);
            highlightTypesAndTypeTypeParameterDeclarations(primaryArguments,typeParameterNameSet,annotationHolder,ElixirSyntaxHighlighter.TYPE);
          }
        }
 else {
          cannotHighlightTypes(call);
        }
      }
 else {
        cannotHighlightTypes(leftOperand);
      }
      PsiElement rightOperand=infix.rightOperand();
      if (rightOperand != null) {
        highlightTypesAndTypeParameterUsages(rightOperand,typeParameterNameSet,annotationHolder,ElixirSyntaxHighlighter.TYPE);
      }
    }
 else     if (grandChild instanceof ElixirMatchedUnqualifiedParenthesesCall) {
      ElixirMatchedUnqualifiedParenthesesCall matchedUnqualifiedParenthesesCall=(ElixirMatchedUnqualifiedParenthesesCall)grandChild;
      if (matchedUnqualifiedParenthesesCall.functionName().equals(UNQUOTE)) {
        PsiElement[] secondaryArguments=matchedUnqualifiedParenthesesCall.secondaryArguments();
        if (secondaryArguments != null) {
          Set<String> typeParameterNameSet=typeTypeParameterNameSet(secondaryArguments);
          highlightTypesAndTypeTypeParameterDeclarations(secondaryArguments,typeParameterNameSet,annotationHolder,ElixirSyntaxHighlighter.TYPE);
        }
      }
 else {
        cannotHighlightTypes(matchedUnqualifiedParenthesesCall);
      }
    }
 else {
      cannotHighlightTypes(grandChild);
    }
  }
}","/** 
 * Highlights the function name of the declared @type, @typep, or @opaque as an   {@link ElixirSyntaxHighlighter.TYPE}and the its parameters as   {@link ElixirSyntaxHighlighter.TYPE_PARAMETER}.
 */
private void highlightType(@NotNull final AtUnqualifiedNoParenthesesCall atUnqualifiedNoParenthesesCall,@NotNull final AnnotationHolder annotationHolder){
  PsiElement noParenthesesOneArgument=atUnqualifiedNoParenthesesCall.getNoParenthesesOneArgument();
  PsiElement[] grandChildren=noParenthesesOneArgument.getChildren();
  if (grandChildren.length == 1) {
    PsiElement grandChild=grandChildren[0];
    if (grandChild instanceof Match) {
    }
 else     if (grandChild instanceof Type) {
      Infix infix=(Infix)grandChild;
      PsiElement leftOperand=infix.leftOperand();
      Set<String> typeParameterNameSet=Collections.emptySet();
      if (leftOperand instanceof Call) {
        Call call=(Call)leftOperand;
        PsiElement functionNameElement=call.functionNameElement();
        if (functionNameElement != null) {
          highlight(functionNameElement.getTextRange(),annotationHolder,ElixirSyntaxHighlighter.TYPE);
        }
        if (call instanceof ElixirMatchedUnqualifiedNoArgumentsCall) {
        }
 else         if (call instanceof ElixirMatchedUnqualifiedParenthesesCall) {
          PsiElement[] primaryArguments=call.primaryArguments();
          PsiElement[] secondaryArguments=call.secondaryArguments();
          if (secondaryArguments != null) {
            typeParameterNameSet=typeTypeParameterNameSet(secondaryArguments);
            highlightTypesAndTypeParameterUsages(primaryArguments,Collections.<String>emptySet(),annotationHolder,ElixirSyntaxHighlighter.TYPE);
            highlightTypesAndTypeTypeParameterDeclarations(secondaryArguments,typeParameterNameSet,annotationHolder,ElixirSyntaxHighlighter.TYPE);
          }
 else           if (primaryArguments != null) {
            typeParameterNameSet=typeTypeParameterNameSet(primaryArguments);
            highlightTypesAndTypeTypeParameterDeclarations(primaryArguments,typeParameterNameSet,annotationHolder,ElixirSyntaxHighlighter.TYPE);
          }
        }
 else {
          cannotHighlightTypes(call);
        }
      }
 else {
        cannotHighlightTypes(leftOperand);
      }
      PsiElement rightOperand=infix.rightOperand();
      if (rightOperand != null) {
        highlightTypesAndTypeParameterUsages(rightOperand,typeParameterNameSet,annotationHolder,ElixirSyntaxHighlighter.TYPE);
      }
    }
 else     if (grandChild instanceof ElixirMatchedUnqualifiedParenthesesCall) {
      ElixirMatchedUnqualifiedParenthesesCall matchedUnqualifiedParenthesesCall=(ElixirMatchedUnqualifiedParenthesesCall)grandChild;
      if (matchedUnqualifiedParenthesesCall.functionName().equals(UNQUOTE)) {
        PsiElement[] secondaryArguments=matchedUnqualifiedParenthesesCall.secondaryArguments();
        if (secondaryArguments != null) {
          Set<String> typeParameterNameSet=typeTypeParameterNameSet(secondaryArguments);
          highlightTypesAndTypeTypeParameterDeclarations(secondaryArguments,typeParameterNameSet,annotationHolder,ElixirSyntaxHighlighter.TYPE);
        }
      }
 else {
        cannotHighlightTypes(matchedUnqualifiedParenthesesCall);
      }
    }
 else     if (grandChild instanceof UnqualifiedNoArgumentsCall) {
      Call grandChildCall=(Call)grandChild;
      PsiElement functionNameElement=grandChildCall.functionNameElement();
      if (functionNameElement != null) {
        highlight(functionNameElement.getTextRange(),annotationHolder,ElixirSyntaxHighlighter.TYPE);
      }
    }
 else {
      cannotHighlightTypes(grandChild);
    }
  }
}",0.9473383759098044
163085,@Contract(pure=true) @NotNull @Override PsiReference getReference();,@Contract(pure=true) @Nullable @Override PsiReference getReference();,0.948905109489051
163086,"@Contract(pure=true) @NotNull public static Operator operator(Prefix prefix){
}","@Contract(pure=true) @NotNull public static Operator operator(Prefix prefix){
  PsiElement[] children=prefix.getChildren();
  if (children.length != 2) {
    error(Prefix.class,""String_Node_Str"" + children.length,prefix);
  }
  return (Operator)children[0];
}",0.4674556213017751
163087,"@Contract(pure=true) @NotNull public static Operator operator(Prefix prefix){
}","@Contract(pure=true) @NotNull public static Operator operator(Prefix prefix){
  PsiElement[] children=prefix.getChildren();
  if (children.length != 2) {
    error(Prefix.class,""String_Node_Str"" + children.length,prefix);
  }
  return (Operator)children[0];
}",0.4674556213017751
163088,"@Contract(pure=true) @NotNull public static Quotable leftOperand(Infix infix){
  PsiElement[] children=infix.getChildren();
  if (children.length != 3) {
    error(Infix.class,""String_Node_Str"" + children.length,infix);
  }
  return (Quotable)children[0];
}","@Contract(pure=true) @NotNull public static Quotable leftOperand(Infix infix){
  PsiElement[] children=infix.getChildren();
  if (children.length < 2 || 3 < children.length) {
    error(Infix.class,""String_Node_Str"" + children.length,infix);
  }
  return (Quotable)children[0];
}",0.9514925373134328
163089,"public static boolean relativeIdentifier(PsiBuilder b,int l){
  if (!recursion_guard_(b,l,""String_Node_Str""))   return false;
  boolean r;
  Marker m=enter_section_(b,l,_NONE_,""String_Node_Str"");
  r=consumeToken(b,IDENTIFIER);
  if (!r)   r=consumeToken(b,AND_OPERATOR);
  if (!r)   r=consumeToken(b,ARROW_OPERATOR);
  if (!r)   r=consumeToken(b,AT_OPERATOR);
  if (!r)   r=consumeToken(b,CAPTURE_OPERATOR);
  if (!r)   r=consumeToken(b,COMPARISON_OPERATOR);
  if (!r)   r=consumeToken(b,DO);
  if (!r)   r=relativeIdentifier_7(b,l + 1);
  if (!r)   r=consumeToken(b,HAT_OPERATOR);
  if (!r)   r=consumeToken(b,IN_MATCH_OPERATOR);
  if (!r)   r=consumeToken(b,IN_OPERATOR);
  if (!r)   r=consumeToken(b,MATCH_OPERATOR);
  if (!r)   r=consumeToken(b,MULTIPLICATION_OPERATOR);
  if (!r)   r=consumeToken(b,OR_OPERATOR);
  if (!r)   r=consumeToken(b,PIPE_OPERATOR);
  if (!r)   r=consumeToken(b,RELATIONAL_OPERATOR);
  if (!r)   r=consumeToken(b,STAB_OPERATOR);
  if (!r)   r=consumeToken(b,STRUCT_OPERATOR);
  if (!r)   r=consumeToken(b,TWO_OPERATOR);
  if (!r)   r=consumeToken(b,UNARY_OPERATOR);
  if (!r)   r=consumeToken(b,WHEN_OPERATOR);
  if (!r)   r=atomKeyword(b,l + 1);
  if (!r)   r=charListLine(b,l + 1);
  if (!r)   r=stringLine(b,l + 1);
  exit_section_(b,l,m,RELATIVE_IDENTIFIER,r,false,null);
  return r;
}","public static boolean relativeIdentifier(PsiBuilder b,int l){
  if (!recursion_guard_(b,l,""String_Node_Str""))   return false;
  boolean r;
  Marker m=enter_section_(b,l,_NONE_,""String_Node_Str"");
  r=consumeToken(b,IDENTIFIER);
  if (!r)   r=consumeToken(b,AFTER);
  if (!r)   r=consumeToken(b,AND_OPERATOR);
  if (!r)   r=consumeToken(b,ARROW_OPERATOR);
  if (!r)   r=consumeToken(b,AT_OPERATOR);
  if (!r)   r=consumeToken(b,CAPTURE_OPERATOR);
  if (!r)   r=consumeToken(b,COMPARISON_OPERATOR);
  if (!r)   r=consumeToken(b,DO);
  if (!r)   r=relativeIdentifier_8(b,l + 1);
  if (!r)   r=consumeToken(b,HAT_OPERATOR);
  if (!r)   r=consumeToken(b,IN_MATCH_OPERATOR);
  if (!r)   r=consumeToken(b,IN_OPERATOR);
  if (!r)   r=consumeToken(b,MATCH_OPERATOR);
  if (!r)   r=consumeToken(b,MULTIPLICATION_OPERATOR);
  if (!r)   r=consumeToken(b,OR_OPERATOR);
  if (!r)   r=consumeToken(b,PIPE_OPERATOR);
  if (!r)   r=consumeToken(b,RELATIONAL_OPERATOR);
  if (!r)   r=consumeToken(b,STAB_OPERATOR);
  if (!r)   r=consumeToken(b,STRUCT_OPERATOR);
  if (!r)   r=consumeToken(b,TWO_OPERATOR);
  if (!r)   r=consumeToken(b,UNARY_OPERATOR);
  if (!r)   r=consumeToken(b,WHEN_OPERATOR);
  if (!r)   r=atomKeyword(b,l + 1);
  if (!r)   r=charListLine(b,l + 1);
  if (!r)   r=stringLine(b,l + 1);
  exit_section_(b,l,m,RELATIVE_IDENTIFIER,r,false,null);
  return r;
}",0.9854314531191632
163090,"@Override public void onError(int response,@Nonnull Exception e){
}","@Override public void onError(int response,@Nonnull Exception e){
  if (response == ResponseCodes.ITEM_NOT_OWNED) {
    onConsumed();
  }
 else {
    super.onError(response,e);
  }
}",0.5381526104417671
163091,"@Override public void onSuccess(@Nonnull Object result){
  inventory.load().whenLoaded(new InventoryLoadedListener());
  Toast.makeText(getActivity(),R.string.msg_item_consumed,Toast.LENGTH_SHORT).show();
}","@Override public void onSuccess(@Nonnull Object result){
  onConsumed();
}",0.5142857142857142
163092,"public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {
  findAndHookConstructor(DefaultHttpClient.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      setObjectField(param.thisObject,""String_Node_Str"",null);
      setObjectField(param.thisObject,""String_Node_Str"",getSCCM());
    }
  }
);
  findAndHookConstructor(DefaultHttpClient.class,HttpParams.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      setObjectField(param.thisObject,""String_Node_Str"",(HttpParams)param.args[0]);
      setObjectField(param.thisObject,""String_Node_Str"",getSCCM());
    }
  }
);
  findAndHookConstructor(DefaultHttpClient.class,ClientConnectionManager.class,HttpParams.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      HttpParams params=(HttpParams)param.args[1];
      setObjectField(param.thisObject,""String_Node_Str"",params);
      setObjectField(param.thisObject,""String_Node_Str"",getCCM(param.args[0],params));
    }
  }
);
  findAndHookConstructor(SSLSocketFactory.class,String.class,KeyStore.class,String.class,KeyStore.class,SecureRandom.class,HostNameResolver.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      String algorithm=(String)param.args[0];
      KeyStore keystore=(KeyStore)param.args[1];
      String keystorePassword=(String)param.args[2];
      SecureRandom random=(SecureRandom)param.args[4];
      KeyManager[] keymanagers=null;
      TrustManager[] trustmanagers=null;
      if (keystore != null) {
        keymanagers=(KeyManager[])callStaticMethod(SSLSocketFactory.class,""String_Node_Str"",keystore,keystorePassword);
      }
      trustmanagers=new TrustManager[]{new ImSureItsLegitTrustManager()};
      setObjectField(param.thisObject,""String_Node_Str"",SSLContext.getInstance(algorithm));
      callMethod(getObjectField(param.thisObject,""String_Node_Str""),""String_Node_Str"",keymanagers,trustmanagers,random);
      setObjectField(param.thisObject,""String_Node_Str"",callMethod(getObjectField(param.thisObject,""String_Node_Str""),""String_Node_Str""));
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      return (SSLSocketFactory)newInstance(SSLSocketFactory.class);
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Socket.class,new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      return true;
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      Class<?> cls=findClass(""String_Node_Str"",lpparam.classLoader);
      TrustManager[] managers=(TrustManager[])param.getResult();
      if (managers.length > 0 && cls.isInstance(managers[0]))       return;
      param.setResult(new TrustManager[]{new ImSureItsLegitTrustManager()});
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",HostnameVerifier.class,new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      return null;
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",javax.net.ssl.SSLSocketFactory.class,new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      return null;
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",HostnameVerifier.class,new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      return null;
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",WebView.class,SslErrorHandler.class,SslError.class,new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      ((android.webkit.SslErrorHandler)param.args[1]).proceed();
      return null;
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",WebView.class,int.class,String.class,String.class,new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      return null;
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",X509Certificate[].class,String.class,String.class,new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      ArrayList<X509Certificate> list=new ArrayList<X509Certificate>();
      return list;
    }
  }
);
}","public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {
  findAndHookConstructor(DefaultHttpClient.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      setObjectField(param.thisObject,""String_Node_Str"",null);
      setObjectField(param.thisObject,""String_Node_Str"",getSCCM());
    }
  }
);
  findAndHookConstructor(DefaultHttpClient.class,HttpParams.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      setObjectField(param.thisObject,""String_Node_Str"",(HttpParams)param.args[0]);
      setObjectField(param.thisObject,""String_Node_Str"",getSCCM());
    }
  }
);
  findAndHookConstructor(DefaultHttpClient.class,ClientConnectionManager.class,HttpParams.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      HttpParams params=(HttpParams)param.args[1];
      setObjectField(param.thisObject,""String_Node_Str"",params);
      setObjectField(param.thisObject,""String_Node_Str"",getCCM(param.args[0],params));
    }
  }
);
  findAndHookConstructor(SSLSocketFactory.class,String.class,KeyStore.class,String.class,KeyStore.class,SecureRandom.class,HostNameResolver.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      String algorithm=(String)param.args[0];
      KeyStore keystore=(KeyStore)param.args[1];
      String keystorePassword=(String)param.args[2];
      SecureRandom random=(SecureRandom)param.args[4];
      KeyManager[] keymanagers=null;
      TrustManager[] trustmanagers=null;
      if (keystore != null) {
        keymanagers=(KeyManager[])callStaticMethod(SSLSocketFactory.class,""String_Node_Str"",keystore,keystorePassword);
      }
      trustmanagers=new TrustManager[]{new ImSureItsLegitTrustManager()};
      setObjectField(param.thisObject,""String_Node_Str"",SSLContext.getInstance(algorithm));
      callMethod(getObjectField(param.thisObject,""String_Node_Str""),""String_Node_Str"",keymanagers,trustmanagers,random);
      setObjectField(param.thisObject,""String_Node_Str"",callMethod(getObjectField(param.thisObject,""String_Node_Str""),""String_Node_Str""));
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      return (SSLSocketFactory)newInstance(SSLSocketFactory.class);
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Socket.class,new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      return true;
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      Class<?> cls=findClass(""String_Node_Str"",lpparam.classLoader);
      TrustManager[] managers=(TrustManager[])param.getResult();
      if (managers.length > 0 && cls.isInstance(managers[0]))       return;
      param.setResult(new TrustManager[]{new ImSureItsLegitTrustManager()});
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",HostnameVerifier.class,new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      return null;
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",javax.net.ssl.SSLSocketFactory.class,new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      return null;
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",HostnameVerifier.class,new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      return null;
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",WebView.class,SslErrorHandler.class,SslError.class,new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      ((android.webkit.SslErrorHandler)param.args[1]).proceed();
      return null;
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",WebView.class,int.class,String.class,String.class,new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      return null;
    }
  }
);
  if (hasTrustManagerImpl()) {
    findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",X509Certificate[].class,String.class,String.class,new XC_MethodReplacement(){
      @Override protected Object replaceHookedMethod(      MethodHookParam param) throws Throwable {
        ArrayList<X509Certificate> list=new ArrayList<X509Certificate>();
        return list;
      }
    }
);
  }
}",0.995205010274978
163093,"public FacebookSocialNetwork(Fragment fragment,Context context,ArrayList<String> permissions){
  super(fragment,context);
  String applicationID=Utility.getMetadataApplicationId(fragment.getActivity());
  if (applicationID == null) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
  this.permissions=permissions;
}","public FacebookSocialNetwork(Fragment fragment,Context context,ArrayList<String> permissions){
  super(fragment,context);
  String applicationID=Utility.getMetadataApplicationId(context);
  if (applicationID == null) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
  this.permissions=permissions;
}",0.9572901325478644
163094,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  RelativeLayout relativeLayout=new RelativeLayout(this);
  RelativeLayout.LayoutParams relativeLayoutParams=new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT,RelativeLayout.LayoutParams.MATCH_PARENT);
  relativeLayout.setBackgroundColor(Color.parseColor(""String_Node_Str""));
  setContentView(relativeLayout,relativeLayoutParams);
  final String paramUrlToLoad=getIntent().getStringExtra(PARAM_URL_TO_LOAD);
  final String paramCallback=getIntent().getStringExtra(PARAM_CALLBACK);
  if (TextUtils.isEmpty(paramUrlToLoad)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (TextUtils.isEmpty(paramCallback)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  WebView webView=new WebView(this);
  LinearLayout.LayoutParams linearLayoutParams=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.MATCH_PARENT);
  webView.setLayoutParams(linearLayoutParams);
  relativeLayout.addView(webView);
  final LinearLayout progressContainer=new LinearLayout(this);
  LinearLayout.LayoutParams progressLayoutParams=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.MATCH_PARENT);
  progressContainer.setGravity(Gravity.CENTER);
  progressContainer.setBackgroundColor(Color.parseColor(""String_Node_Str""));
  progressContainer.setLayoutParams(progressLayoutParams);
  relativeLayout.addView(progressContainer);
  ProgressBar progressBar=new ProgressBar(this);
  LinearLayout.LayoutParams progressBarLayoutParams=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT,LinearLayout.LayoutParams.WRAP_CONTENT);
  progressBar.setLayoutParams(progressBarLayoutParams);
  progressContainer.addView(progressBar);
  webView.setHorizontalScrollBarEnabled(false);
  webView.getSettings().setJavaScriptEnabled(true);
  webView.setWebViewClient(new WebViewClient(){
    @Override public void onPageStarted(    WebView view,    String url,    Bitmap favicon){
      super.onPageStarted(view,url,favicon);
      progressContainer.setVisibility(View.VISIBLE);
    }
    @Override public void onPageFinished(    WebView view,    String url){
      super.onPageFinished(view,url);
      progressContainer.setVisibility(View.GONE);
    }
    @Override public boolean shouldOverrideUrlLoading(    WebView view,    String url){
      if (url.toLowerCase().startsWith(paramCallback.toLowerCase())) {
        Intent intent=new Intent();
        intent.setData(Uri.parse(url));
        setResult(RESULT_OK,intent);
        finish();
        return true;
      }
      return super.shouldOverrideUrlLoading(view,url);
    }
    @Override public void onReceivedError(    WebView view,    int errorCode,    String description,    String failingUrl){
      super.onReceivedError(view,errorCode,description,failingUrl);
      Intent intent=new Intent();
      intent.setAction(description);
      setResult(RESULT_CANCELED,intent);
      finish();
    }
  }
);
  webView.loadUrl(paramUrlToLoad);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  RelativeLayout relativeLayout=new RelativeLayout(this);
  RelativeLayout.LayoutParams relativeLayoutParams=new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT,RelativeLayout.LayoutParams.MATCH_PARENT);
  relativeLayout.setBackgroundColor(Color.parseColor(""String_Node_Str""));
  setContentView(relativeLayout,relativeLayoutParams);
  final String paramUrlToLoad=getIntent().getStringExtra(PARAM_URL_TO_LOAD);
  final String paramCallback=getIntent().getStringExtra(PARAM_CALLBACK);
  if (TextUtils.isEmpty(paramUrlToLoad)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (TextUtils.isEmpty(paramCallback)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  WebView webView=new WebView(this);
  LinearLayout.LayoutParams linearLayoutParams=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.MATCH_PARENT);
  webView.setLayoutParams(linearLayoutParams);
  relativeLayout.addView(webView);
  final LinearLayout progressContainer=new LinearLayout(this);
  LinearLayout.LayoutParams progressLayoutParams=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.MATCH_PARENT);
  progressContainer.setGravity(Gravity.CENTER);
  progressContainer.setBackgroundColor(Color.parseColor(""String_Node_Str""));
  progressContainer.setLayoutParams(progressLayoutParams);
  relativeLayout.addView(progressContainer);
  ProgressBar progressBar=new ProgressBar(this);
  LinearLayout.LayoutParams progressBarLayoutParams=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT,LinearLayout.LayoutParams.WRAP_CONTENT);
  progressBar.setLayoutParams(progressBarLayoutParams);
  progressContainer.addView(progressBar);
  webView.setHorizontalScrollBarEnabled(false);
  webView.getSettings().setJavaScriptEnabled(true);
  webView.setWebViewClient(new WebViewClient(){
    @Override public void onPageStarted(    WebView view,    String url,    Bitmap favicon){
      super.onPageStarted(view,url,favicon);
      progressContainer.setVisibility(View.VISIBLE);
    }
    @Override public void onPageFinished(    WebView view,    String url){
      super.onPageFinished(view,url);
      progressContainer.setVisibility(View.GONE);
    }
    @Override public boolean shouldOverrideUrlLoading(    WebView view,    String url){
      if (url.toLowerCase().startsWith(paramCallback.toLowerCase())) {
        Intent intent=new Intent();
        intent.setData(Uri.parse(url));
        setResult(RESULT_OK,intent);
        finish();
        return true;
      }
      return super.shouldOverrideUrlLoading(view,url);
    }
    @Override public void onReceivedSslError(    WebView view,    SslErrorHandler handler,    SslError error){
      handler.cancel();
    }
    @Override public void onReceivedError(    WebView view,    int errorCode,    String description,    String failingUrl){
      super.onReceivedError(view,errorCode,description,failingUrl);
      Intent intent=new Intent();
      intent.setAction(description);
      setResult(RESULT_CANCELED,intent);
      finish();
    }
  }
);
  webView.loadUrl(paramUrlToLoad);
}",0.9778615167216204
163095,"@Override protected String doInBackground(Void... params){
  String scope=""String_Node_Str"" + Scopes.PLUS_LOGIN;
  String token;
  try {
    token=GoogleAuthUtil.getToken(mSocialNetworkManager.getActivity(),Plus.AccountApi.getAccountName(googleApiClient),scope);
  }
 catch (  Exception e) {
    e.printStackTrace();
    return e.getMessage();
  }
  return token;
}","@Override protected String doInBackground(Activity... params){
  String scope=""String_Node_Str"" + Scopes.PLUS_LOGIN;
  String token;
  try {
    token=GoogleAuthUtil.getToken(params[0],Plus.AccountApi.getAccountName(googleApiClient),scope);
  }
 catch (  Exception e) {
    e.printStackTrace();
    return e.getMessage();
  }
  return token;
}",0.923728813559322
163096,"/** 
 * Request Google plus share dialog
 * @param bundle bundle containing information that should be shared(Bundle constants in {@link com.github.gorbin.asne.core.SocialNetwork})
 * @param onPostingCompleteListener listener for posting request
 */
@Override public void requestPostDialog(Bundle bundle,OnPostingCompleteListener onPostingCompleteListener){
  super.requestPostDialog(bundle,onPostingCompleteListener);
  PlusShare.Builder plusShare=new PlusShare.Builder(mSocialNetworkManager.getActivity()).setType(""String_Node_Str"");
  if (bundle != null) {
    if (bundle.containsKey(BUNDLE_MESSAGE)) {
      plusShare.setText(bundle.getString(BUNDLE_MESSAGE));
    }
    if (bundle.containsKey(BUNDLE_LINK)) {
      plusShare.setContentUrl(Uri.parse(bundle.getString(BUNDLE_LINK)));
    }
  }
  Intent shareIntent=plusShare.getIntent();
  mSocialNetworkManager.getActivity().startActivityForResult(shareIntent,0);
}","/** 
 * Request Google plus share dialog
 * @param bundle bundle containing information that should be shared(Bundle constants in {@link com.github.gorbin.asne.core.SocialNetwork})
 * @param onPostingCompleteListener listener for posting request
 */
@Override public void requestPostDialog(Bundle bundle,OnPostingCompleteListener onPostingCompleteListener){
  super.requestPostDialog(bundle,onPostingCompleteListener);
  PlusShare.Builder plusShare=new PlusShare.Builder(mActivity).setType(""String_Node_Str"");
  if (bundle != null) {
    if (bundle.containsKey(BUNDLE_MESSAGE)) {
      plusShare.setText(bundle.getString(BUNDLE_MESSAGE));
    }
    if (bundle.containsKey(BUNDLE_LINK)) {
      plusShare.setContentUrl(Uri.parse(bundle.getString(BUNDLE_LINK)));
    }
  }
  Intent shareIntent=plusShare.getIntent();
  mActivity.startActivityForResult(shareIntent,0);
}",0.9708846584546472
163097,"@Override protected void onPostExecute(String token){
  if (token != null) {
    ((OnRequestAccessTokenCompleteListener)mLocalListeners.get(REQUEST_ACCESS_TOKEN)).onRequestAccessTokenComplete(getID(),new AccessToken(token,null));
  }
 else {
    mLocalListeners.get(REQUEST_LOGIN).onError(getID(),REQUEST_ACCESS_TOKEN,token,null);
  }
}","@Override protected void onPostExecute(String token){
  if (token != null) {
    ((OnRequestAccessTokenCompleteListener)mLocalListeners.get(REQUEST_ACCESS_TOKEN)).onRequestAccessTokenComplete(getID(),new AccessToken(token,null));
  }
 else {
    mLocalListeners.get(REQUEST_ACCESS_TOKEN).onError(getID(),REQUEST_ACCESS_TOKEN,token,null);
  }
}",0.9779086892488954
163098,"/** 
 * Overrided for Google plus
 * @param savedInstanceState If the activity is being re-initialized after previously being shut down then this Bundle contains the data it most recently supplied in onSaveInstanceState(Bundle). Note: Otherwise it is null.
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Plus.PlusOptions plusOptions=new Plus.PlusOptions.Builder().addActivityTypes(MomentUtil.ACTIONS).build();
  googleApiClient=new GoogleApiClient.Builder(mSocialNetworkManager.getActivity()).addApi(Plus.API,plusOptions).addScope(Plus.SCOPE_PLUS_LOGIN).addScope(Plus.SCOPE_PLUS_PROFILE).addConnectionCallbacks(this).addOnConnectionFailedListener(this).build();
}","/** 
 * Overrided for Google plus
 * @param savedInstanceState If the activity is being re-initialized after previously being shut down then this Bundle contains the data it most recently supplied in onSaveInstanceState(Bundle). Note: Otherwise it is null.
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mActivity=mSocialNetworkManager.getActivity();
  Plus.PlusOptions plusOptions=new Plus.PlusOptions.Builder().addActivityTypes(MomentUtil.ACTIONS).build();
  googleApiClient=new GoogleApiClient.Builder(mActivity).addApi(Plus.API,plusOptions).addScope(Plus.SCOPE_PLUS_LOGIN).addScope(Plus.SCOPE_PLUS_PROFILE).addConnectionCallbacks(this).addOnConnectionFailedListener(this).build();
}",0.9486652977412732
163099,"/** 
 * Request   {@link com.github.gorbin.asne.core.AccessToken} of Google plus social network that you can get from onRequestAccessTokenCompleteListener
 * @param onRequestAccessTokenCompleteListener listener for {@link com.github.gorbin.asne.core.AccessToken} request
 */
@Override public void requestAccessToken(OnRequestAccessTokenCompleteListener onRequestAccessTokenCompleteListener){
  super.requestAccessToken(onRequestAccessTokenCompleteListener);
  AsyncTask<Void,Void,String> task=new AsyncTask<Void,Void,String>(){
    @Override protected String doInBackground(    Void... params){
      String scope=""String_Node_Str"" + Scopes.PLUS_LOGIN;
      String token;
      try {
        token=GoogleAuthUtil.getToken(mSocialNetworkManager.getActivity(),Plus.AccountApi.getAccountName(googleApiClient),scope);
      }
 catch (      Exception e) {
        e.printStackTrace();
        return e.getMessage();
      }
      return token;
    }
    @Override protected void onPostExecute(    String token){
      if (token != null) {
        ((OnRequestAccessTokenCompleteListener)mLocalListeners.get(REQUEST_ACCESS_TOKEN)).onRequestAccessTokenComplete(getID(),new AccessToken(token,null));
      }
 else {
        mLocalListeners.get(REQUEST_LOGIN).onError(getID(),REQUEST_ACCESS_TOKEN,token,null);
      }
    }
  }
;
  task.execute();
}","/** 
 * Request   {@link com.github.gorbin.asne.core.AccessToken} of Google plus social network that you can get from onRequestAccessTokenCompleteListener
 * @param onRequestAccessTokenCompleteListener listener for {@link com.github.gorbin.asne.core.AccessToken} request
 */
@Override public void requestAccessToken(OnRequestAccessTokenCompleteListener onRequestAccessTokenCompleteListener){
  super.requestAccessToken(onRequestAccessTokenCompleteListener);
  AsyncTask<Activity,Void,String> task=new AsyncTask<Activity,Void,String>(){
    @Override protected String doInBackground(    Activity... params){
      String scope=""String_Node_Str"" + Scopes.PLUS_LOGIN;
      String token;
      try {
        token=GoogleAuthUtil.getToken(params[0],Plus.AccountApi.getAccountName(googleApiClient),scope);
      }
 catch (      Exception e) {
        e.printStackTrace();
        return e.getMessage();
      }
      return token;
    }
    @Override protected void onPostExecute(    String token){
      if (token != null) {
        ((OnRequestAccessTokenCompleteListener)mLocalListeners.get(REQUEST_ACCESS_TOKEN)).onRequestAccessTokenComplete(getID(),new AccessToken(token,null));
      }
 else {
        mLocalListeners.get(REQUEST_ACCESS_TOKEN).onError(getID(),REQUEST_ACCESS_TOKEN,token,null);
      }
    }
  }
;
  task.execute(mActivity);
}",0.9612229679343772
163100,"/** 
 * Make login request - authorize in Google plus social network
 * @param onLoginCompleteListener listener for login complete
 */
@Override public void requestLogin(OnLoginCompleteListener onLoginCompleteListener){
  super.requestLogin(onLoginCompleteListener);
  mConnectRequested=true;
  try {
    mConnectionResult.startResolutionForResult(mSocialNetworkManager.getActivity(),REQUEST_AUTH);
  }
 catch (  Exception e) {
    if (!googleApiClient.isConnecting()) {
      googleApiClient.connect();
    }
  }
}","/** 
 * Make login request - authorize in Google plus social network
 * @param onLoginCompleteListener listener for login complete
 */
@Override public void requestLogin(OnLoginCompleteListener onLoginCompleteListener){
  super.requestLogin(onLoginCompleteListener);
  mConnectRequested=true;
  try {
    mConnectionResult.startResolutionForResult(mActivity,REQUEST_AUTH);
  }
 catch (  Exception e) {
    if (!googleApiClient.isConnecting()) {
      googleApiClient.connect();
    }
  }
}",0.9741035856573704
163101,"@Override protected void onDraw(Canvas canvas){
  updateWheelStateIfReq();
  if (mWheelDrawable != null) {
    drawWheel(canvas);
  }
  if (mAdapter != null && mAdapterItemCount > 0) {
    drawWheelItems(canvas);
  }
}","@Override protected void onDraw(Canvas canvas){
  updateWheelStateIfReq();
  if (mWheelDrawable != null && mWheelBounds != null) {
    drawWheel(canvas);
  }
  if (mAdapter != null && mAdapterItemCount > 0) {
    drawWheelItems(canvas);
  }
}",0.7347826086956522
163102,"private void initOrientationListener(){
  orientationListener=new OrientationEventListener(activity){
    @Override public void onOrientationChanged(    int orientation){
      if (orientation == ORIENTATION_UNKNOWN) {
        return;
      }
      Camera.CameraInfo info=new Camera.CameraInfo();
      Camera.getCameraInfo(0,info);
      orientation=(orientation + 45) / 90 * 90;
      int rotation=(info.orientation + orientation) % 360;
synchronized (parameters) {
        parameters.setRotation(rotation);
        camera.setParameters(parameters);
        currOrientation=rotation;
      }
    }
  }
;
}","private void initOrientationListener(){
  orientationListener=new OrientationEventListener(activity){
    @Override public void onOrientationChanged(    int orientation){
      if (camera != null && orientation != ORIENTATION_UNKNOWN) {
        int newOutputOrientation=getCameraPictureRotation(orientation);
        if (newOutputOrientation != outputOrientation) {
          outputOrientation=newOutputOrientation;
          Camera.Parameters params=camera.getParameters();
          params.setRotation(outputOrientation);
          try {
            camera.setParameters(params);
          }
 catch (          Exception e) {
            Timber.e(e,""String_Node_Str"");
          }
        }
      }
    }
  }
;
}",0.3924242424242424
163103,"@Override public void onOrientationChanged(int orientation){
  if (orientation == ORIENTATION_UNKNOWN) {
    return;
  }
  Camera.CameraInfo info=new Camera.CameraInfo();
  Camera.getCameraInfo(0,info);
  orientation=(orientation + 45) / 90 * 90;
  int rotation=(info.orientation + orientation) % 360;
synchronized (parameters) {
    parameters.setRotation(rotation);
    camera.setParameters(parameters);
    currOrientation=rotation;
  }
}","@Override public void onOrientationChanged(int orientation){
  if (camera != null && orientation != ORIENTATION_UNKNOWN) {
    int newOutputOrientation=getCameraPictureRotation(orientation);
    if (newOutputOrientation != outputOrientation) {
      outputOrientation=newOutputOrientation;
      Camera.Parameters params=camera.getParameters();
      params.setRotation(outputOrientation);
      try {
        camera.setParameters(params);
      }
 catch (      Exception e) {
        Timber.e(e,""String_Node_Str"");
      }
    }
  }
}",0.2684426229508196
163104,"private int getCameraId(boolean useFrontCamera){
  int count=Camera.getNumberOfCameras();
  int result=-1;
  if (count > 0) {
    result=0;
    Camera.CameraInfo info=new Camera.CameraInfo();
    for (int i=0; i < count; i++) {
      Camera.getCameraInfo(i,info);
      if (info.facing == Camera.CameraInfo.CAMERA_FACING_BACK && !useFrontCamera) {
        result=i;
        break;
      }
 else       if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT && useFrontCamera) {
        result=i;
        break;
      }
    }
  }
  return result;
}","private int getCameraId(boolean useFrontCamera){
  int count=Camera.getNumberOfCameras();
  int result=-1;
  if (count > 0) {
    result=0;
    Camera.CameraInfo info=new Camera.CameraInfo();
    for (int i=0; i < count; i++) {
      Camera.getCameraInfo(i,info);
      if (info.facing == Camera.CameraInfo.CAMERA_FACING_BACK && !useFrontCamera) {
        result=i;
        break;
      }
 else       if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT && useFrontCamera) {
        result=i;
        break;
      }
    }
  }
  cameraId=result;
  return result;
}",0.9829596412556054
163105,"/** 
 * @param width Screen width
 * @param height Screen height
 * @param ratio Required ratio
 */
private void setPreviewContainerSize(int width,int height,Ratio ratio){
  height=(width / ratio.h) * ratio.w;
  previewContainer.setLayoutParams(new RelativeLayout.LayoutParams(width,height));
}","/** 
 * @param width  Screen width
 * @param height Screen height
 * @param ratio  Required ratio
 */
private void setPreviewContainerSize(int width,int height,Ratio ratio){
  height=(width / ratio.h) * ratio.w;
  previewContainer.setLayoutParams(new RelativeLayout.LayoutParams(width,height));
}",0.9966101694915256
163106,"public void openCamera(View view){
  Intent intent=new Intent(this,CameraActivity.class);
  intent.putExtra(CameraActivity.PATH,Const.FOLDERS.PATH);
  intent.putExtra(CameraActivity.OPEN_PHOTO_PREVIEW,true);
  intent.putExtra(CameraActivity.LAYOUT_ID,R.layout.fragment_camera_custom);
  intent.putExtra(CameraActivity.USE_FRONT_CAMERA,false);
  startActivity(intent);
}","public void openCamera(View view){
  Intent intent=new Intent(this,CameraActivity.class);
  intent.putExtra(CameraActivity.PATH,Const.FOLDERS.PATH);
  intent.putExtra(CameraActivity.OPEN_PHOTO_PREVIEW,true);
  intent.putExtra(CameraActivity.LAYOUT_ID,R.layout.fragment_camera_custom);
  intent.putExtra(CameraActivity.USE_FRONT_CAMERA,true);
  startActivity(intent);
}",0.9905020352781548
163107,"protected void addToWindow(){
  WindowManager.LayoutParams params=new WindowManager.LayoutParams(iconWidth > 0 ? iconWidth : WindowManager.LayoutParams.WRAP_CONTENT,iconHeight > 0 ? iconHeight : WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,PixelFormat.TRANSPARENT);
  params.gravity=Gravity.TOP | Gravity.START;
  windowManager.addView(iconView,layoutParams=params);
  addedToWindow=true;
}","protected void addToWindow(){
  WindowManager.LayoutParams params=new WindowManager.LayoutParams(iconWidth > 0 ? iconWidth : WindowManager.LayoutParams.WRAP_CONTENT,iconHeight > 0 ? iconHeight : WindowManager.LayoutParams.WRAP_CONTENT,WindowManagerHelper.getOverlayFlag(),WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,PixelFormat.TRANSPARENT);
  params.gravity=Gravity.TOP | Gravity.START;
  windowManager.addView(iconView,layoutParams=params);
  addedToWindow=true;
}",0.9420702754036088
163108,"private void addToWindow(View layout){
  WindowManager.LayoutParams params=new WindowManager.LayoutParams(WindowManager.LayoutParams.MATCH_PARENT,WindowManager.LayoutParams.MATCH_PARENT,WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,PixelFormat.TRANSLUCENT);
  windowManager.addView(layout,params);
}","private void addToWindow(View layout){
  WindowManager.LayoutParams params=new WindowManager.LayoutParams(WindowManager.LayoutParams.MATCH_PARENT,WindowManager.LayoutParams.MATCH_PARENT,WindowManagerHelper.getOverlayFlag(),WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,PixelFormat.TRANSLUCENT);
  windowManager.addView(layout,params);
}",0.9252217997465144
163109,"protected void hide(){
  shadowFadeOut.startAnimation();
  hideAnim.startAnimation(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      if (layout != null && layout.getParent() != null) {
        windowManager.removeView(layout);
        isShowing=false;
      }
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
}","protected void hide(){
  shadowFadeOut.startAnimation();
  hideAnim.startAnimation(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      if (layout != null && layout.getParent() != null) {
        isShowing=false;
        layout.post(new Runnable(){
          @Override public void run(){
            windowManager.removeView(layout);
          }
        }
);
      }
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
}",0.8093457943925234
163110,"protected void show(){
  if (layout != null && layout.getParent() == null) {
    addToWindow(layout);
  }
  shadowFadeIn.startAnimation();
  showAnim.startAnimation(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      isShowing=true;
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
}","protected void show(){
  if (layout != null && layout.getParent() == null) {
    addToWindow(layout);
  }
  shadowFadeIn.startAnimation();
  showAnim.startAnimation(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
      isShowing=true;
    }
    @Override public void onAnimationEnd(    Animation animation){
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
}",0.9515418502202644
163111,"@Override public void onAnimationEnd(Animation animation){
  if (layout != null && layout.getParent() != null) {
    windowManager.removeView(layout);
    isShowing=false;
  }
}","@Override public void onAnimationEnd(Animation animation){
  if (layout != null && layout.getParent() != null) {
    isShowing=false;
    layout.post(new Runnable(){
      @Override public void run(){
        windowManager.removeView(layout);
      }
    }
);
  }
}",0.6153846153846154
163112,"@Nullable private Bitmap makeBitmapMask(@Nullable Drawable drawable){
  if (drawable != null) {
    if (getMeasuredWidth() > 0 && getMeasuredHeight() > 0) {
      Bitmap mask=Bitmap.createBitmap(getMeasuredWidth(),getMeasuredHeight(),Bitmap.Config.ARGB_8888);
      Canvas canvas=new Canvas(mask);
      drawable.setBounds(0,0,getMeasuredWidth(),getMeasuredWidth());
      drawable.draw(canvas);
      return mask;
    }
 else {
      log(""String_Node_Str"");
      return null;
    }
  }
 else {
    log(""String_Node_Str"");
  }
  return null;
}","@Nullable private Bitmap makeBitmapMask(@Nullable Drawable drawable){
  if (drawable != null) {
    if (getMeasuredWidth() > 0 && getMeasuredHeight() > 0) {
      Bitmap mask=Bitmap.createBitmap(getMeasuredWidth(),getMeasuredHeight(),Bitmap.Config.ARGB_8888);
      Canvas canvas=new Canvas(mask);
      drawable.setBounds(0,0,getMeasuredWidth(),getMeasuredHeight());
      drawable.draw(canvas);
      return mask;
    }
 else {
      log(""String_Node_Str"");
      return null;
    }
  }
 else {
    log(""String_Node_Str"");
  }
  return null;
}",0.9917355371900828
163113,"@Override public void onItemSelected(Issue item){
  IssueInfo info=new IssueInfo();
  info.num=item.getNumber();
  info.repoInfo=new RepoInfo();
  info.repoInfo.owner=item.getRepository().getOwner().getLogin();
  info.repoInfo.name=item.getRepository().getName();
  if (item.getPullRequest() != null) {
    Intent intent=PullRequestDetailActivity.createLauncherIntent(getActivity(),info);
    startActivity(intent);
  }
 else {
    Intent intent=IssueDetailActivity.createLauncherIntent(getActivity(),info);
    startActivity(intent);
  }
}","@Override public void onItemSelected(Issue item){
  IssueInfo info=new IssueInfo();
  info.num=item.getNumber();
  info.repoInfo=new RepoInfo();
  if (item.getRepository() != null) {
    info.repoInfo=new RepoInfo();
    info.repoInfo.owner=item.getRepository().getOwner().getLogin();
    info.repoInfo.name=item.getRepository().getName();
  }
 else   if (item.getRepositoryUrl() != null) {
    info.repoInfo=new RepoInfo();
    Uri parse=Uri.parse(item.getRepositoryUrl());
    List<String> pathSegments=parse.getPathSegments();
    if (pathSegments != null && pathSegments.size() > 1) {
      pathSegments=new ArrayList<>(pathSegments);
      Collections.reverse(pathSegments);
      info.repoInfo.name=pathSegments.get(0);
      info.repoInfo.owner=pathSegments.get(1);
    }
  }
  if (info.repoInfo != null) {
    if (item.getPullRequest() != null) {
      Intent intent=PullRequestDetailActivity.createLauncherIntent(getActivity(),info);
      startActivity(intent);
    }
 else {
      Intent intent=IssueDetailActivity.createLauncherIntent(getActivity(),info);
      startActivity(intent);
    }
  }
}",0.6456310679611651
163114,"private void getContent(){
  GetPullRequestFiles getPullRequestFiles=new GetPullRequestFiles(info);
  getPullRequestFiles.observable().subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer<Pair<List<CommitFile>,Integer>>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
    }
    @Override public void onNext(    Pair<List<CommitFile>,Integer> listIntegerPair){
      if (getActivity() != null) {
        adapter.addAll(listIntegerPair.first);
        adapter.setOnFileRequestListener(PullRequestFilesListFragment.this);
        recyclerView.setAdapter(adapter);
      }
    }
  }
);
}","private void getContent(){
  GetPullRequestFiles getPullRequestFiles=new GetPullRequestFiles(issueInfo);
  getPullRequestFiles.observable().subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer<Pair<List<CommitFile>,Integer>>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
    }
    @Override public void onNext(    Pair<List<CommitFile>,Integer> listIntegerPair){
      if (getActivity() != null) {
        adapter.addAll(listIntegerPair.first);
        adapter.setOnFileRequestListener(PullRequestFilesListFragment.this);
        recyclerView.setAdapter(adapter);
      }
    }
  }
);
}",0.9963262307127112
163115,"@Override public void onFileRequest(CommitFile file){
  FileInfo info=new FileInfo();
  info.content=file.patch;
  info.name=file.getFileName();
  Intent launcherIntent=FileActivity.createLauncherIntent(getActivity(),info);
  startActivity(launcherIntent);
}","@Override public void onFileRequest(CommitFile file){
  FileInfo info=new FileInfo();
  info.content=file.patch;
  info.name=file.getFileName();
  info.repoInfo=issueInfo.repoInfo;
  Intent launcherIntent=FileActivity.createLauncherIntent(getActivity(),info);
  startActivity(launcherIntent);
}",0.9347826086956522
163116,"@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  if (getArguments() != null) {
    adapter=new CommitFilesAdapter(LayoutInflater.from(getActivity()));
    info=(IssueInfo)getArguments().getParcelable(INFO);
    recyclerView=(RecyclerView)view.findViewById(R.id.recycler);
    recyclerView.setLayoutManager(new LinearLayoutManager(getActivity(),LinearLayoutManager.VERTICAL,false));
    getContent();
  }
}","@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  if (getArguments() != null) {
    adapter=new CommitFilesAdapter(LayoutInflater.from(getActivity()));
    issueInfo=(IssueInfo)getArguments().getParcelable(INFO);
    recyclerView=(RecyclerView)view.findViewById(R.id.recycler);
    recyclerView.setLayoutManager(new LinearLayoutManager(getActivity(),LinearLayoutManager.VERTICAL,false));
    getContent();
  }
}",0.9948186528497408
163117,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_new_issue);
  if (getIntent().getExtras() != null) {
    repoInfo=(RepoInfo)getIntent().getExtras().getParcelable(REPO_INFO);
    findViews();
    setTitle(getString(R.string.new_issue_title,repoInfo.name));
    issueRequest=CacheWrapper.getIssueRequest(repoInfo.owner + ""String_Node_Str"" + repoInfo.name);
    if (issueRequest != null) {
      setupFromCache(issueRequest);
    }
 else {
      issueRequest=new IssueRequest();
    }
  }
 else {
    finish();
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_new_issue);
  if (getIntent().getExtras() != null) {
    repoInfo=getIntent().getExtras().getParcelable(REPO_INFO);
    findViews();
    setTitle(getString(R.string.new_issue_title,repoInfo.name));
    issueRequest=CacheWrapper.getIssueRequest(repoInfo.owner + ""String_Node_Str"" + repoInfo.name);
    if (issueRequest != null) {
      setupFromCache(issueRequest);
    }
 else {
      issueRequest=new IssueRequest();
    }
    if (getSupportActionBar() != null) {
      getSupportActionBar().setBackgroundDrawable(new ColorDrawable(AttributesUtils.getPrimaryColor(this)));
    }
  }
 else {
    finish();
  }
}",0.8766716196136701
163118,"private void openNewIssueActivity(){
  Intent intent=NewIssueActivity.createLauncherIntent(getActivity(),repoInfo);
  startActivityForResult(intent,ISSUE_REQUEST);
}","private void openNewIssueActivity(){
  Intent intent=NewIssueActivity.createLauncherIntent(getActivity(),repoInfo);
  startActivityForResult(intent,NEW_ISSUE_REQUEST);
}",0.9880239520958084
163119,"@Override public void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
  if (resultCode == Activity.RESULT_FIRST_USER) {
    invalidate();
  }
 else   if (resultCode == Activity.RESULT_OK) {
    if (requestCode == ISSUE_REQUEST) {
      invalidate();
    }
 else     if (requestCode == MILESTONES_REQUEST) {
      Milestone milestone=data.getParcelableExtra(Milestone.class.getSimpleName());
      Intent intent=MilestoneIssuesActivity.launchIntent(getActivity(),repoInfo,milestone);
      startActivity(intent);
    }
  }
}","@Override public void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
  if (resultCode == Activity.RESULT_FIRST_USER) {
    invalidate();
  }
 else   if (resultCode == Activity.RESULT_OK) {
    if (requestCode == NEW_ISSUE_REQUEST) {
      invalidate();
    }
 else     if (requestCode == MILESTONES_REQUEST) {
      Milestone milestone=data.getParcelableExtra(Milestone.class.getSimpleName());
      Intent intent=MilestoneIssuesActivity.launchIntent(getActivity(),repoInfo,milestone);
      startActivity(intent);
    }
  }
}",0.9966329966329966
163120,"@Override protected void fabClick(){
  super.fabClick();
  if (repoInfo.permissions != null) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && fab != null) {
      animateRevealFab();
    }
 else {
      openNewIssueActivity();
    }
  }
}","@Override protected void fabClick(){
  super.fabClick();
  if (repoInfo.permissions != null) {
    openNewIssueActivity();
  }
}",0.6666666666666666
163121,"@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  revealView=view.findViewById(R.id.revealView);
  Spinner spinner=(Spinner)view.findViewById(R.id.spinner);
  String[] items=getResources().getStringArray(R.array.issues_filter);
  ArrayAdapter<String> adapter=new ArrayAdapter<>(getActivity(),android.R.layout.simple_list_item_1,items);
  spinner.setAdapter(adapter);
  spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      if (currentFilter != position) {
        currentFilter=position;
        clear();
        onRefresh();
      }
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
  view.findViewById(R.id.milestones).setOnClickListener(v -> showMilestones());
}","@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  Spinner spinner=(Spinner)view.findViewById(R.id.spinner);
  String[] items=getResources().getStringArray(R.array.issues_filter);
  ArrayAdapter<String> adapter=new ArrayAdapter<>(getActivity(),android.R.layout.simple_list_item_1,items);
  spinner.setAdapter(adapter);
  spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      if (currentFilter != position) {
        currentFilter=position;
        clear();
        onRefresh();
      }
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
  view.findViewById(R.id.milestones).setOnClickListener(v -> showMilestones());
}",0.972640982691234
163122,"@Override public void onIssueOpenRequest(Issue item){
  if (item != null) {
    IssueInfo info=new IssueInfo();
    info.repoInfo=repoInfo;
    info.num=item.number;
    if (item.pullRequest == null) {
      Intent intent=IssueDetailActivity.createLauncherIntent(getActivity(),info);
      startActivityForResult(intent,ISSUE_REQUEST);
    }
  }
}","@Override public void onIssueOpenRequest(Issue item){
  if (item != null) {
    IssueInfo info=new IssueInfo();
    info.repoInfo=repoInfo;
    info.num=item.number;
    if (item.pullRequest == null) {
      Intent intent=IssueDetailActivity.createLauncherIntent(getActivity(),info);
      startActivity(intent);
    }
  }
}",0.9448584202682564
163123,"@SuppressLint(""String_Node_Str"") @Override public void onPrepareOptionsMenu(Menu menu){
  super.onPrepareOptionsMenu(menu);
  MenuItem menuItem=menu.findItem(R.id.edit);
  if (menuItem != null && fileContent != null) {
    Drawable drawable=AppCompatDrawableManager.get().getDrawable(getActivity(),R.drawable.pencil);
    drawable=DrawableCompat.wrap(drawable);
    drawable.setTint(Color.WHITE);
    menuItem.setIcon(drawable);
    menuItem.setEnabled(fileInfo.content != null);
  }
}","@SuppressLint(""String_Node_Str"") @Override public void onPrepareOptionsMenu(Menu menu){
  super.onPrepareOptionsMenu(menu);
  MenuItem menuItem=menu.findItem(R.id.edit);
  if (menuItem != null && fileContent != null) {
    Drawable drawable=AppCompatDrawableManager.get().getDrawable(getActivity(),R.drawable.pencil);
    Drawable wrappedDrawable=DrawableCompat.wrap(drawable);
    wrappedDrawable=wrappedDrawable.mutate();
    DrawableCompat.setTint(wrappedDrawable,getResources().getColor(R.color.white));
    menuItem.setIcon(drawable);
    menuItem.setEnabled(fileInfo.content != null);
  }
}",0.7752081406105458
163124,"@Override protected int getTitle(){
  return R.string.my_issues;
}","@Override protected int getTitle(){
  return R.string.navigation_issues;
}",0.9142857142857144
163125,"@Override public boolean onPrepareOptionsMenu(Menu menu){
  if (this.issueStory != null) {
    if (issueInfo.repoInfo.permissions != null && issueInfo.repoInfo.permissions.push || accountNameProvider.getName().equals(issueStory.item.user.login)) {
      if (menu.findItem(R.id.action_close_issue) != null) {
        menu.removeItem(R.id.action_close_issue);
      }
      if (menu.findItem(R.id.action_reopen_issue) != null) {
        menu.removeItem(R.id.action_reopen_issue);
      }
      if (issueStory.item.state == IssueState.closed) {
        MenuItem menuItem=menu.add(0,R.id.action_reopen_issue,1,getString(R.string.reopenIssue));
        menuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
      }
 else {
        MenuItem menuItem=menu.add(0,R.id.action_close_issue,1,getString(R.string.closeIssue));
        menuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
      }
    }
  }
  return true;
}","@Override public boolean onPrepareOptionsMenu(Menu menu){
  if (this.issueStory != null) {
    if (issueInfo.repoInfo.permissions != null && issueInfo.repoInfo.permissions.push || (accountNameProvider.getName() != null && accountNameProvider.getName().equals(issueStory.item.user.login))) {
      if (menu.findItem(R.id.action_close_issue) != null) {
        menu.removeItem(R.id.action_close_issue);
      }
      if (menu.findItem(R.id.action_reopen_issue) != null) {
        menu.removeItem(R.id.action_reopen_issue);
      }
      if (issueStory.item.state == IssueState.closed) {
        MenuItem menuItem=menu.add(0,R.id.action_reopen_issue,1,getString(R.string.reopenIssue));
        menuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
      }
 else {
        MenuItem menuItem=menu.add(0,R.id.action_close_issue,1,getString(R.string.closeIssue));
        menuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
      }
    }
  }
  return true;
}",0.9770666666666666
163126,"@Override public void onErrorTwoFactorException(){
  show2faDialog(R.string.write_otp_code_sms);
}","@Override public void onErrorTwoFactorException(){
  show2faRequest(R.string.write_otp_code_sms);
}",0.934010152284264
163127,"@Override public void onErrorTwoFactorAppException(){
  show2faDialog(R.string.write_otp_code_app);
}","@Override public void onErrorTwoFactorAppException(){
  show2faRequest(R.string.write_otp_code_app);
}",0.9359605911330048
163128,"private void checkError(Throwable e){
  if (e instanceof UnauthorizedException) {
    onErrorUnauthorized();
  }
 else {
    onGenericError();
  }
}","private void checkError(Throwable e){
  if (e instanceof UnauthorizedException) {
    onErrorUnauthorized();
  }
 else   if (!(e instanceof TwoFactorAppException || e instanceof TwoFactorAuthException)) {
    onGenericError();
  }
}",0.7789473684210526
163129,"private void createContent(NewContentRequest newContentRequest){
  NewFileClient client=new NewFileClient(newContentRequest,repoInfo,currentPath + editPath.getText().toString());
  client.observable().subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(newContentResponse -> {
    Toast.makeText(NewContentActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    hideProgressDialog();
  }
,throwable -> {
    Toast.makeText(NewContentActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
  }
);
}","private void createContent(NewContentRequest newContentRequest){
  String path=currentPath + editPath.getText().toString();
  if (currentPath.equals(""String_Node_Str"")) {
    path=editPath.getText().toString();
  }
  NewFileClient client=new NewFileClient(newContentRequest,repoInfo,path);
  client.observable().subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(newContentResponse -> {
    Toast.makeText(NewContentActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    hideProgressDialog();
  }
,throwable -> {
    Toast.makeText(NewContentActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    hideProgressDialog();
  }
);
}",0.8161582852431987
163130,"@Override public boolean onOptionsItemSelected(MenuItem item){
  super.onOptionsItemSelected(item);
switch (item.getItemId()) {
case R.id.action_send:
    NewContentRequest contentRequest=checkDataAndCreateIssue();
  invalidateOptionsMenu();
createContent(contentRequest);
showProgressDialog(R.string.creating_content);
break;
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  super.onOptionsItemSelected(item);
switch (item.getItemId()) {
case R.id.action_send:
    NewContentRequest contentRequest=checkDataAndCreateFile();
  invalidateOptionsMenu();
createContent(contentRequest);
showProgressDialog(R.string.creating_content);
break;
}
return true;
}",0.9897810218978104
163131,"@Override public void loadMore(String username,Callback<List<Repo>> listCallback){
  if (page > Integer.MIN_VALUE) {
    execute(config().execute(new SdkItem<>(page,username)),listCallback);
  }
}","@Override public void loadMore(String username,Callback<List<Repo>> listCallback){
  if (page != null) {
    execute(config().execute(new SdkItem<>(page,username)),listCallback);
  }
}",0.9421052631578948
163132,"@NonNull @Override protected GenericRepository<String,List<Repo>> configRepository(RestWrapper restWrapper){
  if (genericRepository == null) {
    genericRepository=new GenericRepository<>(getUserReposCache(),getCloudRepositoriesDataSource(restWrapper,sortOrder));
  }
  return genericRepository;
}","@NonNull @Override protected GenericRepository<String,List<Repo>> configRepository(RestWrapper restWrapper){
  if (genericRepository == null) {
    genericRepository=new GenericRepository<>(getUserReposCacheDataSource(),getCloudRepositoriesDataSource(restWrapper,sortOrder));
  }
  return genericRepository;
}",0.9835526315789472
163133,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_content_editor);
  setTitle(""String_Node_Str"");
  if (getIntent().getExtras() != null) {
    findViews();
    toolbarExtra.inflateMenu(R.menu.content_editor_extra);
    toolbarExtra.setOnMenuItemClickListener(this);
    final String hint=getIntent().getExtras().getString(HINT);
    if (!TextUtils.isEmpty(hint)) {
      editText.setHint(hint);
    }
    editText.setHint(getString(R.string.edit_hint));
    editText.setQueryTokenReceiver(this);
    String content=getIntent().getExtras().getString(PREFILL);
    if (getIntent().getExtras().containsKey(REPO_INFO) && getIntent().getExtras().containsKey(ISSUE_NUM)) {
      RepoInfo repoInfo=getIntent().getExtras().getParcelable(REPO_INFO);
      int issueNumber=getIntent().getExtras().getInt(ISSUE_NUM);
      issueInfo=new IssueInfo();
      issueInfo.repoInfo=repoInfo;
      issueInfo.num=issueNumber;
      if (!TextUtils.isEmpty(content)) {
        editText.setText(HtmlUtils.format(content));
      }
    }
    allowEmpty=getIntent().getExtras().getBoolean(ALLOW_EMPTY,false);
    if (!allowEmpty) {
      editText.addTextChangedListener(new TextWatcher(){
        @Override public void beforeTextChanged(        CharSequence s,        int start,        int count,        int after){
        }
        @Override public void onTextChanged(        CharSequence s,        int start,        int before,        int count){
          invalidateOptionsMenu();
        }
        @Override public void afterTextChanged(        Editable s){
        }
      }
);
    }
    editText.addTextChangedListener(new TextWatcher(){
      @Override public void beforeTextChanged(      CharSequence s,      int start,      int count,      int after){
      }
      @Override public void onTextChanged(      CharSequence s,      int start,      int before,      int count){
        if (hint != null) {
          if (editText.getText().length() > 0) {
            setTitle(hint);
          }
        }
      }
      @Override public void afterTextChanged(      Editable s){
      }
    }
);
    backIsOk=getIntent().getExtras().getBoolean(BACK_IS_OK,false);
  }
 else {
    finish();
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_content_editor);
  setTitle(""String_Node_Str"");
  if (getIntent().getExtras() != null) {
    findViews();
    toolbarExtra.inflateMenu(R.menu.content_editor_extra);
    toolbarExtra.setOnMenuItemClickListener(this);
    final String hint=getIntent().getExtras().getString(HINT);
    if (!TextUtils.isEmpty(hint)) {
      editText.setHint(hint);
    }
    editText.setHint(getString(R.string.edit_hint));
    editText.setQueryTokenReceiver(this);
    String content=getIntent().getExtras().getString(PREFILL);
    if (getIntent().getExtras().containsKey(REPO_INFO) && getIntent().getExtras().containsKey(ISSUE_NUM)) {
      RepoInfo repoInfo=getIntent().getExtras().getParcelable(REPO_INFO);
      int issueNumber=getIntent().getExtras().getInt(ISSUE_NUM);
      issueInfo=new IssueInfo();
      issueInfo.repoInfo=repoInfo;
      issueInfo.num=issueNumber;
      if (!TextUtils.isEmpty(content)) {
        editText.setText(Html.fromHtml(HtmlUtils.format(content).toString()));
      }
    }
    allowEmpty=getIntent().getExtras().getBoolean(ALLOW_EMPTY,false);
    if (!allowEmpty) {
      editText.addTextChangedListener(new TextWatcher(){
        @Override public void beforeTextChanged(        CharSequence s,        int start,        int count,        int after){
        }
        @Override public void onTextChanged(        CharSequence s,        int start,        int before,        int count){
          invalidateOptionsMenu();
        }
        @Override public void afterTextChanged(        Editable s){
        }
      }
);
    }
    editText.addTextChangedListener(new TextWatcher(){
      @Override public void beforeTextChanged(      CharSequence s,      int start,      int count,      int after){
      }
      @Override public void onTextChanged(      CharSequence s,      int start,      int before,      int count){
        if (hint != null) {
          if (editText.getText().length() > 0) {
            setTitle(hint);
          }
        }
      }
      @Override public void afterTextChanged(      Editable s){
      }
    }
);
    backIsOk=getIntent().getExtras().getBoolean(BACK_IS_OK,false);
  }
 else {
    finish();
  }
}",0.9942781690140844
163134,"@Override public void onStart(){
  super.onStart();
  if (issueInfo != null) {
    String issueComment=CacheWrapper.getIssueComment(issueInfo.toString());
    if (issueComment != null) {
      editText.setText(issueComment);
    }
  }
}","@Override public void onStart(){
  super.onStart();
  if (issueInfo != null) {
    String issueComment=CacheWrapper.getIssueComment(issueInfo.toString());
    if (issueComment != null) {
      editText.setText(Html.fromHtml(issueComment));
    }
  }
}",0.919917864476386
163135,"private void createBottom(Bundle savedInstanceState){
  mBottomBar=BottomBar.attachShy((CoordinatorLayout)findViewById(R.id.coordinator),findViewById(R.id.content),savedInstanceState);
  mBottomBar.useOnlyStatusBarTopOffset();
  final List<Fragment> fragments=new ArrayList<>();
  PullRequestConversationFragment overviewFragment=PullRequestConversationFragment.newInstance(issueInfo);
  overviewFragment.setPullRequestStoryLoaderInterface(this);
  fragments.add(overviewFragment);
  infoFragment=PullRequestInfoFragment.newInstance(issueInfo);
  fragments.add(infoFragment);
  fragments.add(PullRequestFilesListFragment.newInstance(issueInfo));
  fragments.add(PullRequestCommitsListFragment.newInstance(issueInfo));
  mBottomBar.setItems(new BottomBarTab(getBottomTabIcon(Octicons.Icon.oct_comment_discussion),""String_Node_Str""),new BottomBarTab(getBottomTabIcon(Octicons.Icon.oct_info),""String_Node_Str""),new BottomBarTab(getBottomTabIcon(Octicons.Icon.oct_file_code),""String_Node_Str""),new BottomBarTab(getBottomTabIcon(Octicons.Icon.oct_git_commit),""String_Node_Str""));
  mBottomBar.setDefaultTabPosition(0);
  mBottomBar.setActiveTabColor(AttributesUtils.getPrimaryColor(this));
  mBottomBar.setOnTabClickListener(new OnTabClickListener(){
    @Override public void onTabSelected(    int position){
      selectItem(position);
    }
    private void selectItem(    int position){
      selectFragment(fragments.get(position));
    }
    @Override public void onTabReSelected(    int position){
      selectItem(position);
    }
  }
);
  SharedPreferences defaultSharedPreferences=PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
  String pref_theme=defaultSharedPreferences.getString(""String_Node_Str"",getString(R.string.theme_light));
  mBottomBar.useDarkTheme(""String_Node_Str"".equalsIgnoreCase(pref_theme));
}","private void createBottom(Bundle savedInstanceState){
  mBottomBar=BottomBar.attachShy((CoordinatorLayout)findViewById(R.id.coordinator),findViewById(R.id.content),savedInstanceState);
  mBottomBar.useOnlyStatusBarTopOffset();
  final List<Fragment> fragments=new ArrayList<>();
  PullRequestConversationFragment overviewFragment=PullRequestConversationFragment.newInstance(issueInfo);
  overviewFragment.setPullRequestStoryLoaderInterface(this);
  fragments.add(overviewFragment);
  infoFragment=PullRequestInfoFragment.newInstance(issueInfo);
  fragments.add(infoFragment);
  fragments.add(PullRequestFilesListFragment.newInstance(issueInfo));
  fragments.add(PullRequestCommitsListFragment.newInstance(issueInfo));
  mBottomBar.setItems(new BottomBarTab(getBottomTabIcon(Octicons.Icon.oct_comment_discussion),""String_Node_Str""),new BottomBarTab(getBottomTabIcon(Octicons.Icon.oct_info),""String_Node_Str""),new BottomBarTab(getBottomTabIcon(Octicons.Icon.oct_file_code),""String_Node_Str""),new BottomBarTab(getBottomTabIcon(Octicons.Icon.oct_git_commit),""String_Node_Str""));
  mBottomBar.setDefaultTabPosition(0);
  mBottomBar.setOnTabClickListener(new OnTabClickListener(){
    @Override public void onTabSelected(    int position){
      selectItem(position);
    }
    private void selectItem(    int position){
      selectFragment(fragments.get(position));
    }
    @Override public void onTabReSelected(    int position){
      selectItem(position);
    }
  }
);
  SharedPreferences defaultSharedPreferences=PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
  String pref_theme=defaultSharedPreferences.getString(""String_Node_Str"",getString(R.string.theme_light));
  mBottomBar.useDarkTheme(""String_Node_Str"".equalsIgnoreCase(pref_theme));
}",0.9803378565494324
163136,"public void setIssueEvent(IssueStoryEvent issueEvent){
  applyGenericIssueStory(issueEvent);
  textView.setText(""String_Node_Str"");
  String eventType=issueEvent.event.event;
  if (eventType.equals(""String_Node_Str"") || eventType.equals(""String_Node_Str"")) {
    String text=issueEvent.event.actor.login + ""String_Node_Str"" + eventType;
    textView.setText(text);
  }
 else   if (eventType.equals(""String_Node_Str"") || eventType.equals(""String_Node_Str"")) {
    String text=null;
    String user=""String_Node_Str"" + issueEvent.event.assignee.login + ""String_Node_Str"";
    if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_assigned,user);
    }
 else     if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_unassigned,user);
    }
    if (text != null) {
      textView.setText(Html.fromHtml(text));
    }
  }
 else   if (eventType.equals(""String_Node_Str"") || eventType.equals(""String_Node_Str"")) {
    String text=null;
    String milestone=""String_Node_Str"" + issueEvent.event.milestone.title + ""String_Node_Str"";
    if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_milestoned,milestone);
    }
 else     if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_demilestoned,milestone);
    }
    if (text != null) {
      textView.setText(Html.fromHtml(text));
    }
  }
 else   if (eventType.equals(""String_Node_Str"") || eventType.equals(""String_Node_Str"")) {
    String text=null;
    String commitId=issueEvent.event.commit_id;
    String commitContent;
    if (!TextUtils.isEmpty(commitId)) {
      commitContent=commitId.substring(0,8);
    }
 else {
      commitContent=""String_Node_Str"";
    }
    String milestone=""String_Node_Str"" + commitContent + ""String_Node_Str"";
    if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_merged,milestone);
    }
 else     if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_referenced,milestone);
    }
    if (text != null) {
      textView.setText(Html.fromHtml(text));
    }
  }
 else {
    String text=issueEvent.event.actor.login + ""String_Node_Str"" + eventType;
    textView.setText(text);
  }
  textView.setVisibility(View.VISIBLE);
}","public void setIssueEvent(IssueStoryEvent issueEvent){
  applyGenericIssueStory(issueEvent);
  textView.setText(""String_Node_Str"");
  String eventType=issueEvent.event.event;
switch (eventType) {
case ""String_Node_Str"":
case ""String_Node_Str"":
{
      String text=issueEvent.event.actor.login + ""String_Node_Str"" + eventType;
      textView.setText(text);
      break;
    }
case ""String_Node_Str"":
case ""String_Node_Str"":
{
    String text=null;
    String user=""String_Node_Str"" + issueEvent.event.assignee.login + ""String_Node_Str"";
    if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_assigned,user);
    }
 else     if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_unassigned,user);
    }
    if (text != null) {
      textView.setText(Html.fromHtml(text));
    }
    break;
  }
case ""String_Node_Str"":
case ""String_Node_Str"":
{
  String text=null;
  String milestone=""String_Node_Str"" + issueEvent.event.milestone.title + ""String_Node_Str"";
  if (eventType.equals(""String_Node_Str"")) {
    text=getResources().getString(R.string.issue_milestoned,milestone);
  }
 else   if (eventType.equals(""String_Node_Str"")) {
    text=getResources().getString(R.string.issue_demilestoned,milestone);
  }
  if (text != null) {
    textView.setText(Html.fromHtml(text));
  }
  break;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
{
String text=null;
String commitId=issueEvent.event.commit_id;
String commitContent;
if (!TextUtils.isEmpty(commitId)) {
  commitContent=ShaUtils.shortSha(commitId);
}
 else {
  commitContent=""String_Node_Str"";
}
String commitContentStrong=""String_Node_Str"" + commitContent + ""String_Node_Str"";
if (eventType.equals(""String_Node_Str"")) {
  text=getResources().getString(R.string.issue_merged,commitContentStrong);
}
 else if (eventType.equals(""String_Node_Str"")) {
  text=getResources().getString(R.string.issue_referenced,commitContentStrong);
}
if (text != null) {
  textView.setText(Html.fromHtml(text));
}
break;
}
case ""String_Node_Str"":
{
Rename rename=issueEvent.event.rename;
String from=getResources().getString(R.string.issue_renamed_from,rename.from);
String to=getResources().getString(R.string.issue_renamed_to,rename.to);
textView.setText(Html.fromHtml(from + ""String_Node_Str"" + to));
break;
}
default :
{
String text=issueEvent.event.actor.login + ""String_Node_Str"" + eventType;
textView.setText(text);
break;
}
}
textView.setVisibility(View.VISIBLE);
}",0.2737060041407868
163137,"@Override public void onStart(){
  super.onStart();
  if (resultDrawer == null) {
    accountList=getAccounts();
    if (!accountList.isEmpty()) {
      selectedAccount=accountList.get(0);
      createDrawer();
      selectAccount(selectedAccount);
      onUserEventsSelected();
    }
  }
}","@Override public void onStart(){
  super.onStart();
  if (resultDrawer == null) {
    accountList=getAccounts();
    if (!accountList.isEmpty()) {
      selectedAccount=accountList.get(0);
      createDrawer();
      selectAccount(selectedAccount);
    }
  }
}",0.9454545454545454
163138,"@Override public boolean onReposSelected(){
  clearFragments();
  setFragment(GeneralReposFragment.newInstance(),false);
  return true;
}","@Override public boolean onReposSelected(){
  setFragment(GeneralReposFragment.newInstance(),false);
  return true;
}",0.9212598425196852
163139,"@Override public void onBackPressed(){
  if (resultDrawer != null && resultDrawer.isDrawerOpen()) {
    resultDrawer.closeDrawer();
  }
 else {
    if (lastUsedFragment instanceof EventsListFragment) {
      finish();
    }
 else     if (resultDrawer != null && (lastUsedFragment instanceof GeneralReposFragment || lastUsedFragment instanceof GeneralPeopleFragment)) {
      resultDrawer.setSelection(R.id.nav_drawer_events);
      clearFragments();
      onUserEventsSelected();
    }
  }
}","@Override public void onBackPressed(){
  if (resultDrawer != null && resultDrawer.isDrawerOpen()) {
    resultDrawer.closeDrawer();
  }
 else {
    if (lastUsedFragment instanceof EventsListFragment) {
      finish();
    }
 else     if (resultDrawer != null && (lastUsedFragment instanceof GeneralReposFragment || lastUsedFragment instanceof GeneralPeopleFragment)) {
      resultDrawer.setSelection(R.id.nav_drawer_events);
    }
  }
}",0.9418103448275862
163140,"private void selectAccount(final Account account){
  boolean changingUser=selectedAccount != null && !selectedAccount.name.equals(account.name);
  this.selectedAccount=account;
  if (notificationsDrawerItem != null) {
    notificationsDrawerItem.withChecked(selectedAccount != null && ContentResolver.getSyncAutomatically(selectedAccount,selectedAccount.type.replace(""String_Node_Str"",""String_Node_Str"")));
    if (resultDrawer != null) {
      resultDrawer.updateItem(notificationsDrawerItem);
    }
  }
  StoreCredentials credentials=new StoreCredentials(MainActivity.this);
  credentials.clear();
  String authToken=AccountsHelper.getUserToken(this,account);
  credentials.storeToken(authToken);
  credentials.storeUsername(account.name);
  credentials.storeUrl(AccountsHelper.getUrl(this,account));
  String url=AccountsHelper.getUrl(this,account);
  credentials.storeUrl(url);
  if (changingUser) {
    lastUsedFragment=null;
    clearFragments();
  }
}","private void selectAccount(final Account account){
  boolean changingUser=selectedAccount != null && !selectedAccount.name.equals(account.name);
  this.selectedAccount=account;
  if (notificationsDrawerItem != null) {
    notificationsDrawerItem.withChecked(selectedAccount != null && ContentResolver.getSyncAutomatically(selectedAccount,selectedAccount.type.replace(""String_Node_Str"",""String_Node_Str"")));
    if (resultDrawer != null) {
      resultDrawer.updateItem(notificationsDrawerItem);
    }
  }
  StoreCredentials credentials=new StoreCredentials(MainActivity.this);
  credentials.clear();
  String authToken=AccountsHelper.getUserToken(this,account);
  credentials.storeToken(authToken);
  credentials.storeUsername(account.name);
  credentials.storeUrl(AccountsHelper.getUrl(this,account));
  String url=AccountsHelper.getUrl(this,account);
  credentials.storeUrl(url);
  if (changingUser) {
    lastUsedFragment=null;
  }
}",0.9883843717001056
163141,"@Override public boolean onUserEventsSelected(){
  String user=new StoreCredentials(this).getUserName();
  if (user != null) {
    setFragment(EventsListFragment.newInstance(user));
  }
  return true;
}","@Override public boolean onUserEventsSelected(){
  String user=new StoreCredentials(this).getUserName();
  if (user != null) {
    setFragment(EventsListFragment.newInstance(user),false);
  }
  return true;
}",0.9853658536585366
163142,"@Override public void onStart(){
  super.onStart();
  if (resultDrawer == null) {
    accountList=getAccounts();
    if (!accountList.isEmpty()) {
      selectedAccount=accountList.get(0);
      createDrawer();
      selectAccount(selectedAccount);
      onUserEventsSelected();
    }
  }
}","@Override public void onStart(){
  super.onStart();
  if (resultDrawer == null) {
    accountList=getAccounts();
    if (!accountList.isEmpty()) {
      selectedAccount=accountList.get(0);
      createDrawer();
      selectAccount(selectedAccount);
    }
  }
}",0.9454545454545454
163143,"@Override public boolean onReposSelected(){
  clearFragments();
  setFragment(GeneralReposFragment.newInstance(),false);
  return true;
}","@Override public boolean onReposSelected(){
  setFragment(GeneralReposFragment.newInstance(),false);
  return true;
}",0.9212598425196852
163144,"@Override public void onBackPressed(){
  if (resultDrawer != null && resultDrawer.isDrawerOpen()) {
    resultDrawer.closeDrawer();
  }
 else {
    if (lastUsedFragment instanceof EventsListFragment) {
      finish();
    }
 else     if (resultDrawer != null && (lastUsedFragment instanceof GeneralReposFragment || lastUsedFragment instanceof GeneralPeopleFragment)) {
      resultDrawer.setSelection(R.id.nav_drawer_events);
      clearFragments();
      onUserEventsSelected();
    }
  }
}","@Override public void onBackPressed(){
  if (resultDrawer != null && resultDrawer.isDrawerOpen()) {
    resultDrawer.closeDrawer();
  }
 else {
    if (lastUsedFragment instanceof EventsListFragment) {
      finish();
    }
 else     if (resultDrawer != null && (lastUsedFragment instanceof GeneralReposFragment || lastUsedFragment instanceof GeneralPeopleFragment)) {
      resultDrawer.setSelection(R.id.nav_drawer_events);
    }
  }
}",0.9418103448275862
163145,"private void selectAccount(final Account account){
  boolean changingUser=selectedAccount != null && !selectedAccount.name.equals(account.name);
  this.selectedAccount=account;
  if (notificationsDrawerItem != null) {
    notificationsDrawerItem.withChecked(selectedAccount != null && ContentResolver.getSyncAutomatically(selectedAccount,selectedAccount.type.replace(""String_Node_Str"",""String_Node_Str"")));
    if (resultDrawer != null) {
      resultDrawer.updateItem(notificationsDrawerItem);
    }
  }
  StoreCredentials credentials=new StoreCredentials(MainActivity.this);
  credentials.clear();
  String authToken=AccountsHelper.getUserToken(this,account);
  credentials.storeToken(authToken);
  credentials.storeUsername(account.name);
  credentials.storeUrl(AccountsHelper.getUrl(this,account));
  String url=AccountsHelper.getUrl(this,account);
  credentials.storeUrl(url);
  if (changingUser) {
    lastUsedFragment=null;
    clearFragments();
  }
}","private void selectAccount(final Account account){
  boolean changingUser=selectedAccount != null && !selectedAccount.name.equals(account.name);
  this.selectedAccount=account;
  if (notificationsDrawerItem != null) {
    notificationsDrawerItem.withChecked(selectedAccount != null && ContentResolver.getSyncAutomatically(selectedAccount,selectedAccount.type.replace(""String_Node_Str"",""String_Node_Str"")));
    if (resultDrawer != null) {
      resultDrawer.updateItem(notificationsDrawerItem);
    }
  }
  StoreCredentials credentials=new StoreCredentials(MainActivity.this);
  credentials.clear();
  String authToken=AccountsHelper.getUserToken(this,account);
  credentials.storeToken(authToken);
  credentials.storeUsername(account.name);
  credentials.storeUrl(AccountsHelper.getUrl(this,account));
  String url=AccountsHelper.getUrl(this,account);
  credentials.storeUrl(url);
  if (changingUser) {
    lastUsedFragment=null;
  }
}",0.9883843717001056
163146,"@Override public boolean onUserEventsSelected(){
  String user=new StoreCredentials(this).getUserName();
  if (user != null) {
    setFragment(EventsListFragment.newInstance(user));
  }
  return true;
}","@Override public boolean onUserEventsSelected(){
  String user=new StoreCredentials(this).getUserName();
  if (user != null) {
    setFragment(EventsListFragment.newInstance(user),false);
  }
  return true;
}",0.9853658536585366
163147,"public void setIssueEvent(IssueStoryEvent issueEvent){
  applyGenericIssueStory(issueEvent);
  textView.setText(""String_Node_Str"");
  String eventType=issueEvent.event.event;
  if (eventType.equals(""String_Node_Str"") || eventType.equals(""String_Node_Str"")) {
    String text=issueEvent.event.actor.login + ""String_Node_Str"" + eventType;
    textView.setText(text);
  }
 else   if (eventType.equals(""String_Node_Str"") || eventType.equals(""String_Node_Str"")) {
    String text=null;
    String user=""String_Node_Str"" + issueEvent.event.assignee.login + ""String_Node_Str"";
    if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_assigned,user);
    }
 else     if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_unassigned,user);
    }
    if (text != null) {
      textView.setText(Html.fromHtml(text));
    }
  }
 else   if (eventType.equals(""String_Node_Str"") || eventType.equals(""String_Node_Str"")) {
    String text=null;
    String milestone=""String_Node_Str"" + issueEvent.event.milestone.title + ""String_Node_Str"";
    if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_milestoned,milestone);
    }
 else     if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_demilestoned,milestone);
    }
    if (text != null) {
      textView.setText(Html.fromHtml(text));
    }
  }
 else   if (eventType.equals(""String_Node_Str"") || eventType.equals(""String_Node_Str"")) {
    String text=null;
    String commitId=issueEvent.event.commit_id;
    String milestone=""String_Node_Str"" + commitId.substring(0,8) + ""String_Node_Str"";
    if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_merged,milestone);
    }
 else     if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_referenced,milestone);
    }
    if (text != null) {
      textView.setText(Html.fromHtml(text));
    }
  }
 else {
    String text=issueEvent.event.actor.login + ""String_Node_Str"" + eventType;
    textView.setText(text);
  }
  textView.setVisibility(View.VISIBLE);
}","public void setIssueEvent(IssueStoryEvent issueEvent){
  applyGenericIssueStory(issueEvent);
  textView.setText(""String_Node_Str"");
  String eventType=issueEvent.event.event;
  if (eventType.equals(""String_Node_Str"") || eventType.equals(""String_Node_Str"")) {
    String text=issueEvent.event.actor.login + ""String_Node_Str"" + eventType;
    textView.setText(text);
  }
 else   if (eventType.equals(""String_Node_Str"") || eventType.equals(""String_Node_Str"")) {
    String text=null;
    String user=""String_Node_Str"" + issueEvent.event.assignee.login + ""String_Node_Str"";
    if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_assigned,user);
    }
 else     if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_unassigned,user);
    }
    if (text != null) {
      textView.setText(Html.fromHtml(text));
    }
  }
 else   if (eventType.equals(""String_Node_Str"") || eventType.equals(""String_Node_Str"")) {
    String text=null;
    String milestone=""String_Node_Str"" + issueEvent.event.milestone.title + ""String_Node_Str"";
    if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_milestoned,milestone);
    }
 else     if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_demilestoned,milestone);
    }
    if (text != null) {
      textView.setText(Html.fromHtml(text));
    }
  }
 else   if (eventType.equals(""String_Node_Str"") || eventType.equals(""String_Node_Str"")) {
    String text=null;
    String commitId=issueEvent.event.commit_id;
    String commitContent;
    if (!TextUtils.isEmpty(commitId)) {
      commitContent=commitId.substring(0,8);
    }
 else {
      commitContent=""String_Node_Str"";
    }
    String milestone=""String_Node_Str"" + commitContent + ""String_Node_Str"";
    if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_merged,milestone);
    }
 else     if (eventType.equals(""String_Node_Str"")) {
      text=getResources().getString(R.string.issue_referenced,milestone);
    }
    if (text != null) {
      textView.setText(Html.fromHtml(text));
    }
  }
 else {
    String text=issueEvent.event.actor.login + ""String_Node_Str"" + eventType;
    textView.setText(text);
  }
  textView.setVisibility(View.VISIBLE);
}",0.9518763796909492
163148,"public void setIssue(RepoInfo repoInfo,final Issue issue){
  if (this.issue == null) {
    this.issue=issue;
    title.setText(issue.title);
    if (issue.user != null) {
      profileName.setText(issue.user.login);
      profileEmail.setText(TimeUtils.getTimeAgoString(issue.created_at));
      ImageLoader instance=ImageLoader.getInstance();
      instance.displayImage(issue.user.avatar_url,profileIcon);
      OnClickListener issueUserClick=new OnClickListener(){
        @Override public void onClick(        View v){
          Intent launcherIntent=ProfileActivity.createLauncherIntent(v.getContext(),issue.user);
          v.getContext().startActivity(launcherIntent);
        }
      }
;
      profileName.setOnClickListener(issueUserClick);
      profileEmail.setOnClickListener(issueUserClick);
      profileIcon.setOnClickListener(issueUserClick);
    }
    if (!TextUtils.isEmpty(issue.body_html)) {
      String htmlCode=HtmlUtils.format(issue.body_html).toString();
      HttpImageGetter imageGetter=new HttpImageGetter(getContext());
      imageGetter.repoInfo(repoInfo);
      imageGetter.bind(body,htmlCode,issue.number);
      body.setMovementMethod(UiUtils.CHECKING_LINK_METHOD);
    }
 else {
      body.setText(Html.fromHtml(""String_Node_Str"" + getResources().getString(R.string.no_description_provided) + ""String_Node_Str""));
      body.setTextColor(getResources().getColor(R.color.gray_github_medium));
    }
    if (issue.labels != null && issue.labels.size() > 0) {
      labelsLayout.setVisibility(View.VISIBLE);
      int margin=getResources().getDimensionPixelOffset(R.dimen.gapSmall);
      for (      Label label : issue.labels) {
        LabelView labelView=new LabelView(getContext());
        labelView.setLabel(label);
        labelsLayout.addView(labelView);
        if (labelView.getLayoutParams() != null && labelView.getLayoutParams() instanceof FlowLayout.LayoutParams) {
          FlowLayout.LayoutParams layoutParams=(FlowLayout.LayoutParams)labelView.getLayoutParams();
          layoutParams.height=FlowLayout.LayoutParams.WRAP_CONTENT;
          layoutParams.width=FlowLayout.LayoutParams.WRAP_CONTENT;
          layoutParams.setMargins(margin,margin,margin,margin);
          labelView.setLayoutParams(layoutParams);
        }
      }
    }
 else {
      labelsLayout.setVisibility(View.GONE);
    }
    if (textMilestone != null) {
      Milestone milestone=issue.milestone;
      if (milestone != null) {
        textMilestone.setCompoundDrawables(new IconicsDrawable(getContext(),Octicons.Icon.oct_milestone).actionBar().paddingDp(8).colorRes(getColorIcons()),null,null,null);
        textMilestone.setText(milestone.title);
        textMilestone.setVisibility(View.VISIBLE);
      }
 else {
        textMilestone.setVisibility(View.GONE);
      }
    }
    if (textAssignee != null) {
      final User assignee=issue.assignee;
      if (assignee != null) {
        textAssignee.setCompoundDrawables(new IconicsDrawable(getContext(),Octicons.Icon.oct_person).actionBar().colorRes(getColorIcons()).paddingDp(8),null,null,null);
        textAssignee.setText(assignee.login);
        textMilestone.setVisibility(View.VISIBLE);
        textAssignee.setOnClickListener(new OnClickListener(){
          @Override public void onClick(          View v){
            Intent launcherIntent=ProfileActivity.createLauncherIntent(v.getContext(),assignee);
            v.getContext().startActivity(launcherIntent);
          }
        }
);
      }
 else {
        textAssignee.setVisibility(View.GONE);
      }
    }
    if (textRepository != null) {
      final Repo repo=issue.repository;
      if (repo != null) {
        textRepository.setCompoundDrawables(new IconicsDrawable(getContext(),Octicons.Icon.oct_repo).actionBar().colorRes(getColorIcons()).paddingDp(8),null,null,null);
        textRepository.setText(repo.full_name);
        textRepository.setVisibility(View.VISIBLE);
        textRepository.setOnClickListener(new OnClickListener(){
          @Override public void onClick(          View v){
            RepoInfo repoInfo=new RepoInfo();
            repoInfo.owner=repo.owner.login;
            repoInfo.name=repo.name;
            Intent launcherIntent=RepoDetailActivity.createLauncherIntent(v.getContext(),repoInfo);
            v.getContext().startActivity(launcherIntent);
          }
        }
);
      }
 else {
        textRepository.setVisibility(View.GONE);
      }
    }
  }
  StoreCredentials credentials=new StoreCredentials(getContext());
  if (repoInfo.permissions != null && repoInfo.permissions.push || issue.user.login.equals(credentials.getUserName())) {
    OnClickListener editClickListener=new OnClickListener(){
      @Override public void onClick(      View v){
        if (issueDetailRequestListener != null) {
          if (v.getId() == R.id.textTitle) {
            issueDetailRequestListener.onTitleEditRequest();
          }
 else           if (v.getId() == R.id.textBody) {
            issueDetailRequestListener.onContentEditRequest();
          }
        }
      }
    }
;
    title.setOnClickListener(editClickListener);
    body.setOnClickListener(editClickListener);
  }
}","public void setIssue(RepoInfo repoInfo,final Issue issue){
  if (this.issue == null) {
    this.issue=issue;
    title.setText(issue.title);
    if (issue.user != null) {
      profileName.setText(issue.user.login);
      profileEmail.setText(TimeUtils.getTimeAgoString(issue.created_at));
      ImageLoader instance=ImageLoader.getInstance();
      instance.displayImage(issue.user.avatar_url,profileIcon);
      OnClickListener issueUserClick=new OnClickListener(){
        @Override public void onClick(        View v){
          Intent launcherIntent=ProfileActivity.createLauncherIntent(v.getContext(),issue.user);
          v.getContext().startActivity(launcherIntent);
        }
      }
;
      profileName.setOnClickListener(issueUserClick);
      profileEmail.setOnClickListener(issueUserClick);
      profileIcon.setOnClickListener(issueUserClick);
    }
    if (!TextUtils.isEmpty(issue.body_html)) {
      String htmlCode=HtmlUtils.format(issue.body_html).toString();
      HttpImageGetter imageGetter=new HttpImageGetter(getContext());
      imageGetter.repoInfo(repoInfo);
      imageGetter.bind(body,htmlCode,issue.number);
      body.setMovementMethod(UiUtils.CHECKING_LINK_METHOD);
    }
 else {
      body.setText(Html.fromHtml(""String_Node_Str"" + getResources().getString(R.string.no_description_provided) + ""String_Node_Str""));
      body.setTextColor(getResources().getColor(R.color.gray_github_medium));
    }
    if (issue.labels != null && issue.labels.size() > 0) {
      labelsLayout.setVisibility(View.VISIBLE);
      int margin=getResources().getDimensionPixelOffset(R.dimen.gapSmall);
      for (      Label label : issue.labels) {
        LabelView labelView=new LabelView(getContext());
        labelView.setLabel(label);
        labelsLayout.addView(labelView);
        if (labelView.getLayoutParams() != null && labelView.getLayoutParams() instanceof FlowLayout.LayoutParams) {
          FlowLayout.LayoutParams layoutParams=(FlowLayout.LayoutParams)labelView.getLayoutParams();
          layoutParams.height=FlowLayout.LayoutParams.WRAP_CONTENT;
          layoutParams.width=FlowLayout.LayoutParams.WRAP_CONTENT;
          layoutParams.setMargins(margin,margin,margin,margin);
          labelView.setLayoutParams(layoutParams);
        }
      }
    }
 else {
      labelsLayout.setVisibility(View.GONE);
    }
    if (textMilestone != null) {
      Milestone milestone=issue.milestone;
      if (milestone != null) {
        textMilestone.setCompoundDrawables(getIcon(Octicons.Icon.oct_milestone),null,null,null);
        textMilestone.setText(milestone.title);
        textMilestone.setVisibility(View.VISIBLE);
      }
 else {
        textMilestone.setVisibility(View.GONE);
      }
    }
    if (textAssignee != null) {
      final User assignee=issue.assignee;
      if (assignee != null) {
        textAssignee.setCompoundDrawables(getIcon(Octicons.Icon.oct_person),null,null,null);
        textAssignee.setText(assignee.login);
        textMilestone.setVisibility(View.VISIBLE);
        textAssignee.setOnClickListener(new OnClickListener(){
          @Override public void onClick(          View v){
            Intent launcherIntent=ProfileActivity.createLauncherIntent(v.getContext(),assignee);
            v.getContext().startActivity(launcherIntent);
          }
        }
);
      }
 else {
        textAssignee.setVisibility(View.GONE);
      }
    }
    if (textRepository != null) {
      final Repo repo=issue.repository;
      if (repo != null) {
        textRepository.setCompoundDrawables(getIcon(Octicons.Icon.oct_repo),null,null,null);
        textRepository.setText(repo.full_name);
        textRepository.setVisibility(View.VISIBLE);
        textRepository.setOnClickListener(new OnClickListener(){
          @Override public void onClick(          View v){
            RepoInfo repoInfo=new RepoInfo();
            repoInfo.owner=repo.owner.login;
            repoInfo.name=repo.name;
            Intent launcherIntent=RepoDetailActivity.createLauncherIntent(v.getContext(),repoInfo);
            v.getContext().startActivity(launcherIntent);
          }
        }
);
      }
 else {
        textRepository.setVisibility(View.GONE);
      }
    }
  }
  StoreCredentials credentials=new StoreCredentials(getContext());
  if (repoInfo.permissions != null && repoInfo.permissions.push || issue.user.login.equals(credentials.getUserName())) {
    OnClickListener editClickListener=new OnClickListener(){
      @Override public void onClick(      View v){
        if (issueDetailRequestListener != null) {
          if (v.getId() == R.id.textTitle) {
            issueDetailRequestListener.onTitleEditRequest();
          }
 else           if (v.getId() == R.id.textBody) {
            issueDetailRequestListener.onContentEditRequest();
          }
        }
      }
    }
;
    title.setOnClickListener(editClickListener);
    body.setOnClickListener(editClickListener);
  }
}",0.9726461843409316
163149,"public int getColorIcons(){
  if (pullRequest.state == IssueState.open) {
    return R.color.issue_state_open;
  }
 else {
    return R.color.issue_state_close;
  }
}","public int getColorIcons(){
  if (pullRequest.merged) {
    return R.color.pullrequest_state_merged;
  }
 else   if (pullRequest.state == IssueState.open) {
    return R.color.pullrequest_state_open;
  }
 else {
    return R.color.pullrequest_state_close;
  }
}",0.7306791569086651
163150,"@Override protected void onBindViewHolder(ViewHolder holder,Content content){
  holder.textName.setText(content.name);
  IconicsDrawable iconDrawable=null;
  if (ContentType.dir.equals(content.type)) {
    iconDrawable=new IconicsDrawable(holder.itemView.getContext(),Octicons.Icon.oct_file_directory);
  }
 else   if (ContentType.submodule.equals(content.type)) {
    iconDrawable=new IconicsDrawable(holder.itemView.getContext(),Octicons.Icon.oct_file_symlink_directory);
  }
 else   if (ContentType.file.equals(content.type)) {
    iconDrawable=new IconicsDrawable(holder.itemView.getContext(),Octicons.Icon.oct_file_text);
  }
  if (iconDrawable != null) {
    iconDrawable.color(AttributesUtils.getPrimaryLightColor(holder.itemView.getContext()));
    holder.image.setImageDrawable(iconDrawable);
  }
}","@Override protected void onBindViewHolder(ViewHolder holder,Content content){
  holder.textName.setText(content.name);
  IconicsDrawable iconDrawable=null;
  if (ContentType.dir.equals(content.type)) {
    iconDrawable=new IconicsDrawable(holder.itemView.getContext(),Octicons.Icon.oct_file_directory);
  }
 else   if (ContentType.symlink.equals(content.type)) {
    iconDrawable=new IconicsDrawable(holder.itemView.getContext(),Octicons.Icon.oct_file_symlink_directory);
  }
 else   if (ContentType.file.equals(content.type)) {
    iconDrawable=new IconicsDrawable(holder.itemView.getContext(),Octicons.Icon.oct_file_text);
  }
  if (iconDrawable != null) {
    iconDrawable.color(AttributesUtils.getPrimaryLightColor(holder.itemView.getContext()));
    holder.image.setImageDrawable(iconDrawable);
  }
}",0.9913151364764268
163151,"private void onContentLoaded(List<Content> contents){
  if (getActivity() != null) {
    if (contents != null && contents.size() > 0) {
      Collections.sort(contents,Content.Comparators.TYPE);
      displayContent(contents);
    }
 else     if (getAdapter() == null || getAdapter().getItemCount() == 0) {
      setEmpty(false);
    }
  }
}","private void onContentLoaded(List<Content> contents){
  if (getActivity() != null) {
    if (contents != null && contents.size() > 0) {
      Collections.sort(contents);
      displayContent(contents);
    }
 else     if (getAdapter() == null || getAdapter().getItemCount() == 0) {
      setEmpty(false);
    }
  }
}",0.9619482496194824
163152,"private void setAction(GithubListClient<List<Issue>> client){
  client.observable().observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer<Pair<List<Issue>,Integer>>(){
    @Override public void onCompleted(){
      stopRefresh();
    }
    @Override public void onError(    Throwable e){
      stopRefresh();
      if (getAdapter() == null || getAdapter().getItemCount() == 0) {
        setEmpty(true);
      }
    }
    @Override public void onNext(    Pair<List<Issue>,Integer> listIntegerPair){
      onResponse(listIntegerPair.first);
    }
  }
);
}","private void setAction(GithubListClient<List<Issue>> client){
  client.observable().observeOn(AndroidSchedulers.mainThread()).doOnNext(new Action1<Pair<List<Issue>,Integer>>(){
    @Override public void call(    Pair<List<Issue>,Integer> listIntegerPair){
      setPage(listIntegerPair.second);
    }
  }
).flatMap(new Func1<Pair<List<Issue>,Integer>,Observable<Issue>>(){
    @Override public Observable<Issue> call(    Pair<List<Issue>,Integer> listIntegerPair){
      return Observable.from(listIntegerPair.first);
    }
  }
).filter(new Func1<Issue,Boolean>(){
    @Override public Boolean call(    Issue issue){
      return issue.pullRequest == null;
    }
  }
).toList().subscribe(new Subscriber<List<Issue>>(){
    @Override public void onCompleted(){
      stopRefresh();
    }
    @Override public void onError(    Throwable e){
      if (getAdapter() == null || getAdapter().getItemCount() == 0) {
        setEmpty(true);
      }
    }
    @Override public void onNext(    List<Issue> issues){
      onResponse(issues);
    }
  }
);
}",0.540708514605345
163153,"protected void onResponse(List<Issue> issues){
  if (issues != null && issues.size() > 0) {
    issues=filterIssues(issues);
    if (getAdapter() == null) {
      IssuesAdapter issuesAdapter=new IssuesAdapter(LayoutInflater.from(getActivity()));
      issuesAdapter.setIssuesAdapterListener(this);
      issuesAdapter.addAll(issues);
      setAdapter(issuesAdapter);
    }
 else {
      getAdapter().addAll(issues);
    }
  }
 else   if (getAdapter() == null || getAdapter().getItemCount() == 0) {
    setEmpty(false);
  }
}","protected void onResponse(List<Issue> issues){
  if (issues != null && issues.size() > 0) {
    if (getAdapter() == null) {
      IssuesAdapter issuesAdapter=new IssuesAdapter(LayoutInflater.from(getActivity()));
      issuesAdapter.setIssuesAdapterListener(this);
      issuesAdapter.addAll(issues);
      setAdapter(issuesAdapter);
    }
 else {
      getAdapter().addAll(issues);
    }
  }
 else   if (getAdapter() == null || getAdapter().getItemCount() == 0) {
    setEmpty(false);
  }
}",0.967487684729064
163154,"@Override public void onError(Throwable e){
  stopRefresh();
  if (getAdapter() == null || getAdapter().getItemCount() == 0) {
    setEmpty(true);
  }
}","@Override public void onError(Throwable e){
  if (getAdapter() == null || getAdapter().getItemCount() == 0) {
    setEmpty(true);
  }
}",0.940766550522648
163155,"@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  revealView=view.findViewById(R.id.revealView);
  Spinner spinner=(Spinner)view.findViewById(R.id.spinner);
  String[] items=getResources().getStringArray(R.array.issues_filter);
  ArrayAdapter<String> adapter=new ArrayAdapter<>(getActivity(),android.R.layout.simple_list_item_1,items);
  spinner.setAdapter(adapter);
  spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      if (currentFilter != position) {
        currentFilter=position;
        onRefresh();
      }
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
}","@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  revealView=view.findViewById(R.id.revealView);
  Spinner spinner=(Spinner)view.findViewById(R.id.spinner);
  String[] items=getResources().getStringArray(R.array.issues_filter);
  ArrayAdapter<String> adapter=new ArrayAdapter<>(getActivity(),android.R.layout.simple_list_item_1,items);
  spinner.setAdapter(adapter);
  spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      if (currentFilter != position) {
        currentFilter=position;
        clear();
        onRefresh();
      }
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
}",0.9897775105231508
163156,"@Override public void onNext(Pair<List<Issue>,Integer> listIntegerPair){
  onResponse(listIntegerPair.first);
}","@Override public void onNext(List<Issue> issues){
  onResponse(issues);
}",0.7391304347826086
163157,"@Override public void onItemSelected(AdapterView<?> parent,View view,int position,long id){
  if (currentFilter != position) {
    currentFilter=position;
    onRefresh();
  }
}","@Override public void onItemSelected(AdapterView<?> parent,View view,int position,long id){
  if (currentFilter != position) {
    currentFilter=position;
    clear();
    onRefresh();
  }
}",0.9645776566757494
163158,"@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  Spinner spinner=(Spinner)view.findViewById(R.id.spinner);
  String[] items=getResources().getStringArray(R.array.pullrequest_filter);
  ArrayAdapter<String> adapter=new ArrayAdapter<>(getActivity(),android.R.layout.simple_list_item_1,items);
  spinner.setAdapter(adapter);
  spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      if (currentFilter != position) {
        currentFilter=position;
        onRefresh();
      }
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
}","@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  Spinner spinner=(Spinner)view.findViewById(R.id.spinner);
  String[] items=getResources().getStringArray(R.array.pullrequest_filter);
  ArrayAdapter<String> adapter=new ArrayAdapter<>(getActivity(),android.R.layout.simple_list_item_1,items);
  spinner.setAdapter(adapter);
  spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      if (currentFilter != position) {
        currentFilter=position;
        clear();
        onRefresh();
      }
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
}",0.9892063492063492
163159,"@Override public void onItemSelected(AdapterView<?> parent,View view,int position,long id){
  if (currentFilter != position) {
    currentFilter=position;
    onRefresh();
  }
}","@Override public void onItemSelected(AdapterView<?> parent,View view,int position,long id){
  if (currentFilter != position) {
    currentFilter=position;
    clear();
    onRefresh();
  }
}",0.9645776566757494
163160,"@Override protected void getContent(){
  super.getContent();
  loadingView.setVisibility(View.VISIBLE);
  if (checkPermissions(issueInfo)) {
    GetRepoClient repoClient=new GetRepoClient(this,issueInfo.repoInfo);
    repoClient.setOnResultCallback(new BaseClient.OnResultCallback<Repo>(){
      @Override public void onResponseOk(      Repo repo,      Response r){
        issueInfo.repoInfo.permissions=repo.permissions;
        repository=repo;
        getContent();
      }
      @Override public void onFail(      RetrofitError error){
      }
    }
);
    repoClient.execute();
  }
 else {
    loadIssue();
  }
}","@Override protected void getContent(){
  super.getContent();
  hideProgressDialog();
  loadingView.setVisibility(View.VISIBLE);
  if (checkPermissions(issueInfo)) {
    GetRepoClient repoClient=new GetRepoClient(this,issueInfo.repoInfo);
    repoClient.setOnResultCallback(new BaseClient.OnResultCallback<Repo>(){
      @Override public void onResponseOk(      Repo repo,      Response r){
        issueInfo.repoInfo.permissions=repo.permissions;
        repository=repo;
        getContent();
      }
      @Override public void onFail(      RetrofitError error){
      }
    }
);
    repoClient.execute();
  }
 else {
    loadIssue();
  }
}",0.9809523809523808
163161,"@Override protected void getContent(){
  super.getContent();
  loadingView.setVisibility(View.VISIBLE);
  if (checkPermissions(issueInfo)) {
    GetRepoClient repoClient=new GetRepoClient(this,issueInfo.repoInfo);
    repoClient.setOnResultCallback(new BaseClient.OnResultCallback<Repo>(){
      @Override public void onResponseOk(      Repo repo,      Response r){
        issueInfo.repoInfo.permissions=repo.permissions;
        repository=repo;
        loadPullRequest();
      }
      @Override public void onFail(      RetrofitError error){
      }
    }
);
    repoClient.execute();
  }
 else {
    loadPullRequest();
  }
}","@Override protected void getContent(){
  super.getContent();
  hideProgressDialog();
  loadingView.setVisibility(View.VISIBLE);
  if (checkPermissions(issueInfo)) {
    GetRepoClient repoClient=new GetRepoClient(this,issueInfo.repoInfo);
    repoClient.setOnResultCallback(new BaseClient.OnResultCallback<Repo>(){
      @Override public void onResponseOk(      Repo repo,      Response r){
        issueInfo.repoInfo.permissions=repo.permissions;
        repository=repo;
        loadPullRequest();
      }
      @Override public void onFail(      RetrofitError error){
      }
    }
);
    repoClient.execute();
  }
 else {
    loadPullRequest();
  }
}",0.9812792511700468
163162,"private void setUpOrgs(final View view){
  ImageView icon=(ImageView)view.findViewById(R.id.iconOrgs);
  IconicsDrawable githubIconDrawable=drawable(view.getContext(),Octicons.Icon.oct_organization);
  icon.setImageDrawable(githubIconDrawable);
  textOrgs=(TextView)view.findViewById(R.id.textOrgs);
  view.findViewById(R.id.orgs).setOnClickListener(this);
  GetOrgsClient orgsClient=new GetOrgsClient(view.getContext(),user.login);
  orgsClient.setOnResultCallback(new BaseClient.OnResultCallback<ListOrganizations>(){
    @Override public void onResponseOk(    ListOrganizations organizations,    Response r){
      textOrgs.setText(view.getContext().getString(R.string.orgs_num,organizations.size()));
    }
    @Override public void onFail(    RetrofitError error){
    }
  }
);
  orgsClient.execute();
}","private void setUpOrgs(final View view){
  final ImageView icon=(ImageView)view.findViewById(R.id.iconOrgs);
  IconicsDrawable githubIconDrawable=drawable(view.getContext(),Octicons.Icon.oct_organization);
  icon.setImageDrawable(githubIconDrawable);
  textOrgs=(TextView)view.findViewById(R.id.textOrgs);
  view.findViewById(R.id.orgs).setOnClickListener(this);
  GetOrgsClient orgsClient=new GetOrgsClient(view.getContext(),user.login);
  orgsClient.setOnResultCallback(new BaseClient.OnResultCallback<ListOrganizations>(){
    @Override public void onResponseOk(    ListOrganizations organizations,    Response r){
      if (organizations != null && organizations.size() > 0) {
        textOrgs.setText(view.getContext().getString(R.string.orgs_num,organizations.size()));
      }
 else {
        view.findViewById(R.id.orgs).setVisibility(View.GONE);
        view.findViewById(R.id.dividerGists).setVisibility(View.GONE);
      }
    }
    @Override public void onFail(    RetrofitError error){
    }
  }
);
  orgsClient.execute();
}",0.8758807588075881
163163,"@Override public void onResponseOk(ListOrganizations organizations,Response r){
  textOrgs.setText(view.getContext().getString(R.string.orgs_num,organizations.size()));
}","@Override public void onResponseOk(ListOrganizations organizations,Response r){
  if (organizations != null && organizations.size() > 0) {
    textOrgs.setText(view.getContext().getString(R.string.orgs_num,organizations.size()));
  }
 else {
    view.findViewById(R.id.orgs).setVisibility(View.GONE);
    view.findViewById(R.id.dividerGists).setVisibility(View.GONE);
  }
}",0.6261510128913443
163164,"@Override public void onLoadingComplete(String imageUri,View view,Bitmap loadedImage){
  super.onLoadingComplete(imageUri,view,loadedImage);
  Palette.generateAsync(loadedImage,new PaletteListener(loadedImage,listener));
}","@Override public void onLoadingComplete(String imageUri,View view,final Bitmap loadedImage){
  super.onLoadingComplete(imageUri,view,loadedImage);
  new Palette.Builder(loadedImage).maximumColorCount(3).generate(new Palette.PaletteAsyncListener(){
    @Override public void onGenerated(    Palette palette){
      if (listener != null) {
        listener.onImageLoaded(loadedImage,palette);
      }
    }
  }
);
}",0.5291338582677165
163165,"public void loadImageAndPalette(String url,final PaletteUtilsListener listener){
  ImageLoader.getInstance().loadImage(url,new SimpleImageLoadingListener(){
    @Override public void onLoadingComplete(    String imageUri,    View view,    Bitmap loadedImage){
      super.onLoadingComplete(imageUri,view,loadedImage);
      Palette.generateAsync(loadedImage,new PaletteListener(loadedImage,listener));
    }
  }
);
}","public void loadImageAndPalette(String url,final PaletteUtilsListener listener){
  ImageLoader.getInstance().loadImage(url,new SimpleImageLoadingListener(){
    @Override public void onLoadingComplete(    String imageUri,    View view,    final Bitmap loadedImage){
      super.onLoadingComplete(imageUri,view,loadedImage);
      new Palette.Builder(loadedImage).maximumColorCount(3).generate(new Palette.PaletteAsyncListener(){
        @Override public void onGenerated(        Palette palette){
          if (listener != null) {
            listener.onImageLoaded(loadedImage,palette);
          }
        }
      }
);
    }
  }
);
}",0.7021883920076119
163166,"@Override public void onResponseOk(ListContributors contributors,Response r){
  List<User> users=new ArrayList<User>(contributors.size());
  User cleanUser=new User();
  cleanUser.login=""String_Node_Str"";
  users.add(cleanUser);
  for (  Contributor contributor : contributors) {
    users.add(contributor.author);
  }
  assigneesAdapter=new UsersAdapterSpinner(NewIssueActivity.this,users);
  spinnerAssignee.setAdapter(assigneesAdapter);
}","@Override public void onResponseOk(ListContributors contributors,Response r){
  if (contributors != null) {
    List<User> users=new ArrayList<User>(contributors.size());
    User cleanUser=new User();
    cleanUser.login=""String_Node_Str"";
    users.add(cleanUser);
    for (    Contributor contributor : contributors) {
      users.add(contributor.author);
    }
    assigneesAdapter=new UsersAdapterSpinner(NewIssueActivity.this,users);
    spinnerAssignee.setAdapter(assigneesAdapter);
  }
}",0.8952991452991453
163167,"@Override public boolean onOptionsItemSelected(MenuItem item){
  if (!fromSearch) {
switch (item.getItemId()) {
case R.id.issue_list_filter_open:
      currentState=IssueState.open;
    issuesAdapter.clear();
  onRefresh();
break;
case R.id.issue_list_filter_closed:
currentState=IssueState.closed;
issuesAdapter.clear();
onRefresh();
break;
case R.id.issue_list_filter_search:
Intent intent=SearchIssuesActivity.launchIntent(getActivity(),repoInfo);
startActivity(intent);
break;
}
}
return super.onOptionsItemSelected(item);
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  if (!fromSearch) {
switch (item.getItemId()) {
case R.id.issue_list_filter_open:
      currentState=IssueState.open;
    if (issuesAdapter != null) {
      issuesAdapter.clear();
    }
  onRefresh();
break;
case R.id.issue_list_filter_closed:
currentState=IssueState.closed;
if (issuesAdapter != null) {
issuesAdapter.clear();
}
onRefresh();
break;
case R.id.issue_list_filter_search:
Intent intent=SearchIssuesActivity.launchIntent(getActivity(),repoInfo);
startActivity(intent);
break;
}
}
return super.onOptionsItemSelected(item);
}",0.9042553191489362
163168,"@Override public void onResponseOk(ListIssues issues,Response r){
  super.onResponseOk(issues,r);
  if (issues == null || issues.size() == 0 && (issuesAdapter == null || issuesAdapter.getCount() == 0)) {
    setEmpty();
  }
}","@Override public void onResponseOk(ListIssues issues,Response r){
  super.onResponseOk(issues,r);
  if (refreshing) {
    if (issuesAdapter != null) {
      issuesAdapter.clear();
    }
  }
  if (issues == null || issues.size() == 0 && (issuesAdapter == null || issuesAdapter.getCount() == 0)) {
    setEmpty();
  }
}",0.8302583025830258
163169,"@Override public void onNotificationRequested(){
  setTitle(R.string.notifications);
  setFragment(NotificationsFragment.newInstance());
}","@Override public void onNotificationRequested(){
  setTitle(R.string.notifications);
  if (notificationsFragment == null) {
    notificationsFragment=NotificationsFragment.newInstance();
  }
  setFragment(notificationsFragment,true);
}",0.6702412868632708
163170,"@Override public boolean onCreateOptionsMenu(Menu menu){
  super.onCreateOptionsMenu(menu);
  if (getToolbar() != null) {
    getToolbar().inflateMenu(R.menu.main_menu);
    MenuItem notificationsItem=menu.findItem(R.id.action_notifications);
    notificationProvider=(NotificationsActionProvider)MenuItemCompat.getActionProvider(notificationsItem);
    notificationProvider.setOnNotificationListener(this);
    bus.register(notificationProvider);
  }
  return true;
}","@Override public boolean onCreateOptionsMenu(Menu menu){
  super.onCreateOptionsMenu(menu);
  if (getToolbar() != null) {
    getToolbar().inflateMenu(R.menu.main_menu);
    MenuItem notificationsItem=menu.findItem(R.id.action_notifications);
    notificationProvider=(NotificationsActionProvider)MenuItemCompat.getActionProvider(notificationsItem);
    if (notificationProvider != null) {
      notificationProvider.setOnNotificationListener(this);
    }
    bus.register(notificationProvider);
  }
  return true;
}",0.951219512195122
163171,"@Override public View getView(int position,View convertView,ViewGroup parent){
  View v=mInflater.inflate(R.layout.notification_row,parent,false);
  final Notification item=getItem(position);
  v.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      bus.post(item);
    }
  }
);
  TextView text=(TextView)v.findViewById(R.id.text);
  text.setText(item.subject.title);
  ImageView iv=(ImageView)v.findViewById(R.id.clearNotifications);
  iv.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      PopupMenu popupMenu=new PopupMenu(v.getContext(),v);
      popupMenu.inflate(R.menu.notifications_row_menu);
      popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener(){
        @Override public boolean onMenuItemClick(        MenuItem menuItem){
switch (menuItem.getItemId()) {
case R.id.action_notification_unsubscribe:
            bus.post(new UnsubscribeThreadNotification(item));
          break;
case R.id.action_notification_mark_read:
        bus.post(new ClearNotification(item,false));
      break;
  }
  return true;
}
}
);
popupMenu.show();
}
}
);
return v;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  View v=mInflater.inflate(R.layout.notification_row,parent,false);
  final Notification item=getItem(position);
  v.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (bus != null && item != null) {
        bus.post(item);
      }
    }
  }
);
  TextView text=(TextView)v.findViewById(R.id.text);
  text.setText(item.subject.title);
  ImageView iv=(ImageView)v.findViewById(R.id.clearNotifications);
  iv.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      PopupMenu popupMenu=new PopupMenu(v.getContext(),v);
      popupMenu.inflate(R.menu.notifications_row_menu);
      popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener(){
        @Override public boolean onMenuItemClick(        MenuItem menuItem){
switch (menuItem.getItemId()) {
case R.id.action_notification_unsubscribe:
            bus.post(new UnsubscribeThreadNotification(item));
          break;
case R.id.action_notification_mark_read:
        bus.post(new ClearNotification(item,false));
      break;
  }
  return true;
}
}
);
popupMenu.show();
}
}
);
return v;
}",0.9664039817503112
163172,"@Override public void onBindViewHolder(Holder holder,int position){
  if (position == 0) {
    ((IssueHolder)holder).issueDetailView.setIssue(issueStory.issue);
  }
 else   if (holder instanceof CommentHolder) {
    IssueStoryComment issueStoryDetail=(IssueStoryComment)issueStory.details.get(position - 1).second;
    ((CommentHolder)holder).issueCommentView.setComment(issueStoryDetail);
  }
 else   if (holder instanceof TimelineHolder) {
    IssueStoryEvent issueStoryDetail=(IssueStoryEvent)issueStory.details.get(position - 1).second;
    ((TimelineHolder)holder).issueTimelineView.setLastItem((position + 1) == getItemCount());
    ((TimelineHolder)holder).issueTimelineView.setIssueEvent(issueStoryDetail);
  }
 else {
    IssueStoryDetail issueStoryDetail=issueStory.details.get(position - 1).second;
    if (issueStoryDetail instanceof IssueStoryEvent) {
      holder.text.setText(((IssueStoryEvent)issueStoryDetail).event.event);
    }
  }
}","@Override public void onBindViewHolder(Holder holder,int position){
  if (position == 0) {
    ((IssueHolder)holder).issueDetailView.setIssue(issueStory.issue);
  }
 else   if (holder instanceof CommentHolder) {
    IssueStoryComment issueStoryDetail=(IssueStoryComment)issueStory.details.get(position - 1).second;
    ((CommentHolder)holder).issueCommentView.setComment(issueStoryDetail);
  }
 else   if (holder instanceof TimelineHolder) {
    if (issueStory.details.get(position - 1).second instanceof IssueStoryEvent) {
      IssueStoryEvent issueStoryDetail=(IssueStoryEvent)issueStory.details.get(position - 1).second;
      ((TimelineHolder)holder).issueTimelineView.setLastItem((position + 1) == getItemCount());
      ((TimelineHolder)holder).issueTimelineView.setIssueEvent(issueStoryDetail);
    }
  }
 else {
    IssueStoryDetail issueStoryDetail=issueStory.details.get(position - 1).second;
    if (issueStoryDetail instanceof IssueStoryEvent) {
      holder.text.setText(((IssueStoryEvent)issueStoryDetail).event.event);
    }
  }
}",0.933933933933934
163173,"@Override public void onResponseOk(final String s,Response r){
  webView.clearCache(true);
  webView.clearFormData();
  webView.clearHistory();
  webView.clearMatches();
  webView.clearSslPreferences();
  webView.getSettings().setUseWideViewPort(false);
  webView.setBackgroundColor(getResources().getColor(R.color.gray_github_light));
  webView.loadDataWithBaseURL(""String_Node_Str"",s,""String_Node_Str"",""String_Node_Str"",null);
}","@Override public void onResponseOk(final String s,Response r){
  if (getActivity() != null && isAdded()) {
    webView.clearCache(true);
    webView.clearFormData();
    webView.clearHistory();
    webView.clearMatches();
    webView.clearSslPreferences();
    webView.getSettings().setUseWideViewPort(false);
    webView.setBackgroundColor(getResources().getColor(R.color.gray_github_light));
    webView.loadDataWithBaseURL(""String_Node_Str"",s,""String_Node_Str"",""String_Node_Str"",null);
  }
}",0.9307359307359307
163174,"private void navigateUp(){
  currentSelectedContent=currentSelectedContent.parent;
  if (currentSelectedContent != null) {
    if (treeContent.get(currentSelectedContent) != null) {
      displayContent(treeContent.get(currentSelectedContent));
    }
  }
 else {
    getActivity().finish();
  }
}","private void navigateUp(){
  currentSelectedContent=currentSelectedContent.parent;
  if (currentSelectedContent != null) {
    if (treeContent.get(currentSelectedContent) != null) {
      displayContent(treeContent.get(currentSelectedContent));
    }
  }
}",0.927536231884058
163175,"public void showNotificationBubble(boolean show){
  this.show=show;
  int start=show ? 0 : 16;
  int end=show ? 16 : 0;
  animator=ValueAnimator.ofInt(start,end);
  animator.setDuration(animationDuration);
  animator.setInterpolator(show ? new BounceInterpolator() : new AccelerateDecelerateInterpolator());
  animator.addUpdateListener(this);
  animator.start();
  this.postInvalidate();
}","public void showNotificationBubble(boolean show){
  this.show=show;
  int start=show ? 0 : getSize();
  int end=show ? getSize() : 0;
  animator=ValueAnimator.ofInt(start,end);
  animator.setDuration(animationDuration);
  animator.setInterpolator(show ? new BounceInterpolator() : new AccelerateDecelerateInterpolator());
  animator.addUpdateListener(this);
  animator.start();
  this.postInvalidate();
}",0.9722921914357684
163176,"private void showDialog(){
  try {
    progressDialog=new SpotsDialog(this,R.style.SpotDialog_Login);
    progressDialog.setCancelable(false);
    progressDialog.setCanceledOnTouchOutside(false);
    progressDialog.show();
  }
 catch (  Exception e) {
    e.printStackTrace();
    Crashlytics.logException(e);
  }
}","private void showDialog(){
  try {
    progressDialog=new SpotsDialog(this,R.style.SpotDialog_Login);
    progressDialog.setCancelable(false);
    progressDialog.setCanceledOnTouchOutside(false);
    progressDialog.show();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9447236180904522
163177,"private void showDialog(){
  try {
    progressDialog=new SpotsDialog(this,R.style.SpotDialog_CreatingIssue);
    progressDialog.setCancelable(false);
    progressDialog.setCanceledOnTouchOutside(false);
    progressDialog.show();
  }
 catch (  Exception e) {
    e.printStackTrace();
    Crashlytics.logException(e);
  }
}","private void showDialog(){
  try {
    progressDialog=new SpotsDialog(this,R.style.SpotDialog_CreatingIssue);
    progressDialog.setCancelable(false);
    progressDialog.setCanceledOnTouchOutside(false);
    progressDialog.show();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9461663947797716
163178,"private void showDialog(){
  try {
    progressDialog=new SpotsDialog(this,R.style.SpotDialog_Login);
    progressDialog.setCancelable(false);
    progressDialog.setCanceledOnTouchOutside(false);
    progressDialog.show();
  }
 catch (  Exception e) {
    e.printStackTrace();
    Crashlytics.logException(e);
  }
}","private void showDialog(){
  try {
    progressDialog=new SpotsDialog(this,R.style.SpotDialog_Login);
    progressDialog.setCancelable(false);
    progressDialog.setCanceledOnTouchOutside(false);
    progressDialog.show();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9447236180904522
163179,"private void showDialog(){
  try {
    progressDialog=new SpotsDialog(this,R.style.SpotDialog_CreatingIssue);
    progressDialog.setCancelable(false);
    progressDialog.setCanceledOnTouchOutside(false);
    progressDialog.show();
  }
 catch (  Exception e) {
    e.printStackTrace();
    Crashlytics.logException(e);
  }
}","private void showDialog(){
  try {
    progressDialog=new SpotsDialog(this,R.style.SpotDialog_CreatingIssue);
    progressDialog.setCancelable(false);
    progressDialog.setCanceledOnTouchOutside(false);
    progressDialog.show();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9461663947797716
163180,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  toolbar=(Toolbar)findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  toolbarDetail=(Toolbar)findViewById(R.id.toolbarDetail);
  String gistId=null;
  String gistUser=null;
  boolean containsUser=false;
  boolean isAuthUser=false;
  Account[] accounts=AccountManager.get(this).getAccountsByType(getString(R.string.account_type));
  if (accounts.length > 0) {
    if ((Intent.ACTION_SEND.equals(getIntent().getAction())) || (Intent.ACTION_VIEW.equals(getIntent().getAction()))) {
      Uri uri=getIntent().getData();
      if (uri == null && getIntent().getStringExtra(Intent.EXTRA_TEXT) != null) {
        try {
          uri=Uri.parse(getIntent().getStringExtra(Intent.EXTRA_TEXT));
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
      if (uri != null) {
        gistId=uri.getLastPathSegment();
        if (uri.getPathSegments().size() > 1) {
          containsUser=true;
          gistUser=uri.getPathSegments().get(0);
        }
      }
    }
    loadUserGists=true;
    if (gistUser != null && gistId != null && toolbarDetail != null) {
      loadUserGists=false;
      setTitle(getString(R.string.user_gists,gistUser));
      showGistsFragment(gistUser);
      showGistDetailFragment(gistId);
    }
 else     if (gistId != null) {
      Intent launcherIntent=GistDetailActivity.createLauncherIntent(this,gistId);
      startActivity(launcherIntent);
      finish();
    }
    for (    Account account : accounts) {
      if (account.name.equals(gistUser)) {
        isAuthUser=true;
        break;
      }
    }
    if (!containsUser || isAuthUser) {
      createDrawer();
    }
    if (accounts.length > 0) {
      selectAccount(accounts[0]);
    }
  }
 else {
    Intent intent=new Intent(MainActivity.this,LoginActivity.class);
    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    intent.putExtra(Intent.EXTRA_INTENT,getIntent());
    startActivity(intent);
    finish();
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  toolbar=(Toolbar)findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  toolbarDetail=(Toolbar)findViewById(R.id.toolbarDetail);
  String gistId=null;
  String gistUser=null;
  boolean containsUser=false;
  boolean isAuthUser=false;
  Account[] accounts=AccountManager.get(this).getAccountsByType(getString(R.string.account_type));
  if (accounts.length > 0) {
    if ((Intent.ACTION_SEND.equals(getIntent().getAction())) || (Intent.ACTION_VIEW.equals(getIntent().getAction()))) {
      Uri uri=getIntent().getData();
      if (uri == null && getIntent().getStringExtra(Intent.EXTRA_TEXT) != null) {
        try {
          uri=Uri.parse(getIntent().getStringExtra(Intent.EXTRA_TEXT));
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
      if (uri != null) {
        gistId=uri.getLastPathSegment();
        if (uri.getPathSegments().size() > 1) {
          containsUser=true;
          gistUser=uri.getPathSegments().get(0);
        }
      }
    }
    loadUserGists=true;
    if (gistUser != null && gistId != null && toolbarDetail != null) {
      loadUserGists=false;
      setTitle(getString(R.string.user_gists,gistUser));
      showGistsFragment(gistUser);
      showGistDetailFragment(gistId);
    }
 else     if (gistId != null) {
      Intent launcherIntent=GistDetailActivity.createLauncherIntent(this,gistId);
      startActivity(launcherIntent);
      finish();
    }
    for (    Account account : accounts) {
      if (account.name.equals(gistUser)) {
        isAuthUser=true;
        break;
      }
    }
    if (!containsUser || isAuthUser) {
      createDrawer();
    }
  }
 else {
    Intent intent=new Intent(MainActivity.this,LoginActivity.class);
    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    intent.putExtra(Intent.EXTRA_INTENT,getIntent());
    startActivity(intent);
    finish();
  }
}",0.9826871494757377
163181,"@Override protected void onResponse(ListGists gists,boolean refreshing){
  if (gists != null && gists.size() > 0) {
    if (gistsAdapter == null || refreshing) {
      gistsAdapter=new GistsAdapter(getActivity(),gists);
      setListAdapter(gistsAdapter);
    }
    if (gistsAdapter.isLazyLoading()) {
      if (gistsAdapter != null) {
        gistsAdapter.setLazyLoading(false);
        gistsAdapter.addAll(gists);
      }
    }
    if (gistsAdapter != null) {
      setListAdapter(gistsAdapter);
    }
  }
}","@Override protected void onResponse(ListGists gists,boolean refreshing){
  if (gists != null && gists.size() > 0) {
    if (gistsAdapter == null || refreshing) {
      gistsAdapter=new GistsAdapter(getActivity(),gists);
      setListAdapter(gistsAdapter);
    }
    if (gistsAdapter.isLazyLoading()) {
      if (gistsAdapter != null) {
        gistsAdapter.setLazyLoading(false);
        gistsAdapter.addAll(gists);
      }
    }
 else {
      setListAdapter(gistsAdapter);
    }
  }
}",0.9678068410462776
163182,"@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  setupListView(view);
  progressBar=(SmoothProgressBar)view.findViewById(R.id.progress);
  emptyIcon=(ImageView)view.findViewById(R.id.emptyIcon);
  emptyText=(TextView)view.findViewById(R.id.emptyText);
  emptyLy=view.findViewById(R.id.emptyLayout);
  fab=(FloatingActionButton)view.findViewById(R.id.fabButton);
  loadArguments();
  checkFAB();
  swipe=(SwipeRefreshLayout)view.findViewById(R.id.swipe);
  executeRequest();
}","@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  setupListView(view);
  progressBar=(SmoothProgressBar)view.findViewById(R.id.progress);
  emptyIcon=(ImageView)view.findViewById(R.id.emptyIcon);
  emptyText=(TextView)view.findViewById(R.id.emptyText);
  emptyLy=view.findViewById(R.id.emptyLayout);
  fab=(FloatingActionButton)view.findViewById(R.id.fabButton);
  loadArguments();
  checkFAB();
  swipe=(SwipeRefreshLayout)view.findViewById(R.id.swipe);
  swipe.setOnRefreshListener(this);
  executeRequest();
}",0.9683098591549296
163183,"private void displayContent(ListContents contents){
  if (contents != null) {
    try {
      ListContents currentContents=treeContent.get(currentSelectedContent);
      Context context=getActivity();
      int style=R.style.AppTheme_Repos;
      if (currentContents == null) {
        int size=contents.size() + (currentSelectedContent.parent != null ? 1 : 0);
        currentContents=new ListContents(size);
        treeContent.put(currentSelectedContent,currentContents);
        if (currentSelectedContent.parent != null) {
          Content up=new UpContent();
          up.parent=currentSelectedContent.parent;
          currentContents.add(up);
        }
        Collections.sort(contents,ListContents.SORT.TYPE);
        currentContents.addAll(contents);
        contentAdapter=new RepoSourceAdapter(context,currentContents,style);
      }
 else {
        contentAdapter=new RepoSourceAdapter(context,contents,style);
      }
      setListAdapter(contentAdapter);
      if (refreshListener != null) {
        refreshListener.cancelRefresh();
      }
    }
 catch (    Exception e) {
      Crashlytics.logException(e);
    }
  }
}","private void displayContent(ListContents contents){
  if (getActivity() != null && contents != null) {
    try {
      ListContents currentContents=treeContent.get(currentSelectedContent);
      Context context=getActivity();
      int style=R.style.AppTheme_Repos;
      if (currentContents == null) {
        int size=contents.size() + (currentSelectedContent.parent != null ? 1 : 0);
        currentContents=new ListContents(size);
        treeContent.put(currentSelectedContent,currentContents);
        if (currentSelectedContent.parent != null) {
          Content up=new UpContent();
          up.parent=currentSelectedContent.parent;
          currentContents.add(up);
        }
        Collections.sort(contents,ListContents.SORT.TYPE);
        currentContents.addAll(contents);
        contentAdapter=new RepoSourceAdapter(context,currentContents,style);
      }
 else {
        contentAdapter=new RepoSourceAdapter(context,contents,style);
      }
      setListAdapter(contentAdapter);
      if (refreshListener != null) {
        refreshListener.cancelRefresh();
      }
    }
 catch (    Exception e) {
      Crashlytics.logException(e);
    }
  }
}",0.989125706829056
163184,"public static SearchReposFragment newInstance(String query){
  Bundle args=Bundle.EMPTY;
  args.putString(SearchManager.QUERY,query);
  SearchReposFragment f=new SearchReposFragment();
  f.setArguments(args);
  return f;
}","public static SearchReposFragment newInstance(String query){
  Bundle args=new Bundle();
  if (query != null) {
    args.putString(SearchManager.QUERY,query);
  }
  SearchReposFragment f=new SearchReposFragment();
  f.setArguments(args);
  return f;
}",0.904862579281184
163185,"@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  view.setBackgroundColor(Color.WHITE);
  String query=getArguments().getString(SearchManager.QUERY);
  setQuery(query);
}","@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  view.setBackgroundColor(Color.WHITE);
  String query=getArguments().getString(SearchManager.QUERY,null);
  if (query != null) {
    setQuery(query);
  }
 else {
    setEmpty();
  }
}",0.8763636363636363
163186,"@Override protected void onResponse(ListEvents githubEvents,boolean refreshing){
  if (githubEvents != null && githubEvents.size() > 0) {
    if (eventsAdapter == null || refreshing) {
      eventsAdapter=new EventAdapter(getActivity(),githubEvents);
      setListAdapter(eventsAdapter);
    }
    if (eventsAdapter.isLazyLoading()) {
      if (eventsAdapter != null) {
        eventsAdapter.setLazyLoading(false);
        eventsAdapter.addAll(githubEvents);
      }
    }
  }
}","@Override protected void onResponse(ListEvents githubEvents,boolean refreshing){
  getListView().setDivider(null);
  if (githubEvents != null && githubEvents.size() > 0) {
    if (eventsAdapter == null || refreshing) {
      eventsAdapter=new EventAdapter(getActivity(),githubEvents);
      setListAdapter(eventsAdapter);
    }
    if (eventsAdapter.isLazyLoading()) {
      if (eventsAdapter != null) {
        eventsAdapter.setLazyLoading(false);
        eventsAdapter.addAll(githubEvents);
      }
    }
    if (eventsAdapter != null) {
      setListAdapter(eventsAdapter);
    }
  }
}",0.8968105065666041
163187,"@Override protected void onResponse(ListOrganizations organizations,boolean refreshing){
  if (adapter == null) {
    setUpList();
  }
  adapter.addAll(organizations,paging);
}","@Override protected void onResponse(ListOrganizations organizations,boolean refreshing){
  getListView().setDivider(null);
  if (getListAdapter() != null) {
    adapter.addAll(organizations,paging);
  }
 else   if (adapter == null) {
    setUpList(organizations);
  }
 else {
    setListAdapter(adapter);
  }
}",0.5802469135802469
163188,"private void setUpList(){
  adapter=new OrganizationsAdapter(getActivity(),new ArrayList<Organization>());
  setListAdapter(adapter);
  getListView().setDivider(null);
}","private void setUpList(ListOrganizations organizations){
  adapter=new OrganizationsAdapter(getActivity(),organizations);
  setListAdapter(adapter);
  getListView().setDivider(null);
}",0.8555240793201133
163189,"@Override protected void onResponse(ListRepos repos,boolean refreshing){
  if (repos.size() > 0) {
    if (reposAdapter == null) {
      setUpList();
    }
    reposAdapter.addAll(repos,paging);
  }
}","@Override protected void onResponse(ListRepos repos,boolean refreshing){
  getListView().setDivider(null);
  if (repos.size() > 0) {
    if (getListAdapter() != null) {
      reposAdapter.addAll(repos,paging);
    }
 else     if (reposAdapter == null) {
      setUpList(repos);
    }
 else {
      setListAdapter(reposAdapter);
    }
  }
}",0.601113172541744
163190,"protected void setUpList(){
  reposAdapter=new ReposAdapter(getActivity(),new ArrayList<Repo>());
  getListView().setDivider(null);
  setListAdapter(reposAdapter);
  settings=new GitskariosSettings(getActivity());
  settings.registerListener(this);
}","protected void setUpList(ListRepos repos){
  settings=new GitskariosSettings(getActivity());
  settings.registerListener(this);
  reposAdapter=new ReposAdapter(getActivity(),repos);
  setListAdapter(reposAdapter);
}",0.2838709677419355
163191,"@Override protected void onResponse(ListUsers users,boolean refreshing){
  if (usersAdapter == null) {
    setUpList();
  }
  usersAdapter.addAll(users,paging);
}","@Override protected void onResponse(ListUsers users,boolean refreshing){
  getListView().setDivider(null);
  if (users.size() > 0) {
    if (getListAdapter() != null) {
      usersAdapter.addAll(users,paging);
    }
 else     if (usersAdapter == null) {
      setUpList(users);
    }
 else {
      setListAdapter(usersAdapter);
    }
  }
}",0.499001996007984
163192,"private void setUpList(){
  usersAdapter=new UsersAdapter(getActivity(),new ArrayList<User>());
  setListAdapter(usersAdapter);
  getListView().setDivider(null);
}","private void setUpList(ListUsers users){
  usersAdapter=new UsersAdapter(getActivity(),users);
  setListAdapter(usersAdapter);
}",0.7628865979381443
163193,"@Override protected void onResponse(ListEvents githubEvents,boolean refreshing){
  if (githubEvents != null && githubEvents.size() > 0) {
    if (eventsAdapter == null || refreshing) {
      eventsAdapter=new EventAdapter(getActivity(),githubEvents);
      setListAdapter(eventsAdapter);
    }
    if (eventsAdapter.isLazyLoading()) {
      if (eventsAdapter != null) {
        eventsAdapter.setLazyLoading(false);
        eventsAdapter.addAll(githubEvents);
      }
    }
  }
}","@Override protected void onResponse(ListEvents githubEvents,boolean refreshing){
  getListView().setDivider(null);
  if (githubEvents != null && githubEvents.size() > 0) {
    if (eventsAdapter == null || refreshing) {
      eventsAdapter=new EventAdapter(getActivity(),githubEvents);
      setListAdapter(eventsAdapter);
    }
    if (eventsAdapter.isLazyLoading()) {
      if (eventsAdapter != null) {
        eventsAdapter.setLazyLoading(false);
        eventsAdapter.addAll(githubEvents);
      }
    }
    if (eventsAdapter != null) {
      setListAdapter(eventsAdapter);
    }
  }
}",0.8968105065666041
163194,"@Override protected void onResponse(ListOrganizations organizations,boolean refreshing){
  if (adapter == null) {
    setUpList();
  }
  adapter.addAll(organizations,paging);
}","@Override protected void onResponse(ListOrganizations organizations,boolean refreshing){
  getListView().setDivider(null);
  if (getListAdapter() != null) {
    adapter.addAll(organizations,paging);
  }
 else   if (adapter == null) {
    setUpList(organizations);
  }
 else {
    setListAdapter(adapter);
  }
}",0.5802469135802469
163195,"private void setUpList(){
  adapter=new OrganizationsAdapter(getActivity(),new ArrayList<Organization>());
  setListAdapter(adapter);
  getListView().setDivider(null);
}","private void setUpList(ListOrganizations organizations){
  adapter=new OrganizationsAdapter(getActivity(),organizations);
  setListAdapter(adapter);
  getListView().setDivider(null);
}",0.8555240793201133
163196,"@Override protected void onResponse(ListRepos repos,boolean refreshing){
  if (repos.size() > 0) {
    if (reposAdapter == null) {
      setUpList();
    }
    reposAdapter.addAll(repos,paging);
  }
}","@Override protected void onResponse(ListRepos repos,boolean refreshing){
  getListView().setDivider(null);
  if (repos.size() > 0) {
    if (getListAdapter() != null) {
      reposAdapter.addAll(repos,paging);
    }
 else     if (reposAdapter == null) {
      setUpList(repos);
    }
 else {
      setListAdapter(reposAdapter);
    }
  }
}",0.601113172541744
163197,"protected void setUpList(){
  reposAdapter=new ReposAdapter(getActivity(),new ArrayList<Repo>());
  getListView().setDivider(null);
  setListAdapter(reposAdapter);
  settings=new GitskariosSettings(getActivity());
  settings.registerListener(this);
}","protected void setUpList(ListRepos repos){
  settings=new GitskariosSettings(getActivity());
  settings.registerListener(this);
  reposAdapter=new ReposAdapter(getActivity(),repos);
  setListAdapter(reposAdapter);
}",0.2838709677419355
163198,"@Override protected void onResponse(ListUsers users,boolean refreshing){
  if (usersAdapter == null) {
    setUpList();
  }
  usersAdapter.addAll(users,paging);
}","@Override protected void onResponse(ListUsers users,boolean refreshing){
  getListView().setDivider(null);
  if (users.size() > 0) {
    if (getListAdapter() != null) {
      usersAdapter.addAll(users,paging);
    }
 else     if (usersAdapter == null) {
      setUpList(users);
    }
 else {
      setListAdapter(usersAdapter);
    }
  }
}",0.499001996007984
163199,"private void setUpList(){
  usersAdapter=new UsersAdapter(getActivity(),new ArrayList<User>());
  setListAdapter(usersAdapter);
  getListView().setDivider(null);
}","private void setUpList(ListUsers users){
  usersAdapter=new UsersAdapter(getActivity(),users);
  setListAdapter(usersAdapter);
}",0.7628865979381443
163200,"private void findViews(){
  fabLayout=(FABCenterLayout)findViewById(R.id.fabLayout);
  fabLayout.setFabColor(getResources().getColor(R.color.accent));
  fabLayout.setFabColorPressed(getResources().getColor(R.color.primary_dark));
  GithubIconDrawable drawable=new GithubIconDrawable(this,GithubIconify.IconValue.octicon_comment_discussion).color(Color.WHITE).fabSize();
  fabLayout.setFabIcon(drawable);
  fabLayout.setFabClickListener(this,getString(R.string.add_comment));
  issueBody=(TextView)findViewById(R.id.issueBody);
}","private void findViews(){
  fabLayout=(FABCenterLayout)findViewById(R.id.fabLayout);
  fabLayout.setFabColor(getResources().getColor(R.color.accent));
  fabLayout.setFabColorPressed(getResources().getColor(R.color.primary_dark));
  GithubIconDrawable drawable=new GithubIconDrawable(this,GithubIconify.IconValue.octicon_comment_discussion).color(Color.WHITE).fabSize();
  fabLayout.setFabIcon(drawable);
  fabLayout.setFabClickListener(this,getString(R.string.add_comment));
  issueBody=(TextView)findViewById(R.id.issueBody);
  issueBody.setMaxLines(3);
  issueBody.setEllipsize(TextUtils.TruncateAt.END);
}",0.9295774647887324
163201,"@Override public boolean onOptionsItemSelected(MenuItem item){
  super.onOptionsItemSelected(item);
switch (item.getItemId()) {
case android.R.id.home:
    setResult(shouldRefreshOnBack ? RESULT_FIRST_USER : RESULT_OK);
  finish();
break;
case R.id.action_close_issue:
closeIssueDialog();
break;
case R.id.action_fold_issue:
fabLayout.setFold(!fabLayout.isFold());
invalidateOptionsMenu();
break;
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  super.onOptionsItemSelected(item);
switch (item.getItemId()) {
case android.R.id.home:
    setResult(shouldRefreshOnBack ? RESULT_FIRST_USER : RESULT_OK);
  finish();
break;
case R.id.action_close_issue:
closeIssueDialog();
break;
case R.id.action_fold_issue:
if (fabLayout.isFold()) {
issueBody.setMaxLines(Integer.MAX_VALUE);
issueBody.setEllipsize(null);
}
 else {
issueBody.setMaxLines(3);
issueBody.setEllipsize(TextUtils.TruncateAt.END);
}
fabLayout.setFold(!fabLayout.isFold());
invalidateOptionsMenu();
break;
}
return true;
}",0.7905138339920948
163202,"@Override public void onResponseOk(Issue issue,Response r){
  if (issue != null) {
    issueBody.setText(issue.body);
    IssueDetailActivity.this.issue=issue;
    IssueDetailActivity.this.issueState=issue.state;
    invalidateOptionsMenu();
    setData();
    Spanned issueNumber=Html.fromHtml(getString(R.string.issue_detail_title,issue.number));
    shouldRefreshOnBack=true;
  }
}","@Override public void onResponseOk(Issue issue,Response r){
  if (issue != null) {
    issueBody.setText(issue.body);
    IssueDetailActivity.this.issue=issue;
    IssueDetailActivity.this.issueState=issue.state;
    invalidateOptionsMenu();
    setData();
    shouldRefreshOnBack=true;
  }
}",0.8402366863905325
163203,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  super.onLayout(changed,l,t,r,b);
  if (topView != null && fabVisible && fabView != null) {
    int bottom=topView.getBottom();
    if (bottom > 0) {
      int int16=getResources().getDimensionPixelOffset(R.dimen.gapLarge);
      fabView.layout(r - fabView.getWidth() - int16,bottom - fabView.getHeight() / 2,r - int16,bottom + fabView.getHeight() / 2);
      removeView(fabView);
      addView(fabView);
    }
  }
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  super.onLayout(changed,l,t,r,b);
  if (topView != null && fabVisible && fabView != null) {
    int bottom=topView.getBottom();
    if (bottom > 0) {
      int int16=getResources().getDimensionPixelOffset(R.dimen.gapLarge);
      fabView.layout(r - fabView.getWidth() - int16,bottom - fabView.getHeight() / 2,r - int16,bottom + fabView.getHeight() / 2);
      removeView(fabView);
      addView(fabView);
      ViewCompat.setElevation(fabView,6f);
    }
  }
}",0.95821185617104
163204,"@Override public void addView(View child,int index,ViewGroup.LayoutParams params){
  super.addView(child,index,params);
  if (child.getId() == scrollableId) {
    scrolledChild=child;
    addChildScrollListener(scrolledChild);
  }
 else   if (child.getId() == topId) {
    topView=child;
  }
 else {
    View viewTop=child.findViewById(topId);
    if (viewTop != null) {
      topView=viewTop;
      ViewCompat.setElevation(topView,4f);
    }
    View viewScroll=child.findViewById(scrollableId);
    if (viewScroll != null) {
      scrolledChild=viewScroll;
    }
  }
}","@Override public void addView(View child,int index,ViewGroup.LayoutParams params){
  super.addView(child,index,params);
  if (child.getId() == scrollableId) {
    scrolledChild=child;
    addChildScrollListener(scrolledChild);
  }
 else   if (child.getId() == topId) {
    topView=child;
  }
 else {
    View viewTop=child.findViewById(topId);
    if (viewTop != null) {
      topView=viewTop;
    }
    View viewScroll=child.findViewById(scrollableId);
    if (viewScroll != null) {
      scrolledChild=viewScroll;
    }
  }
}",0.9608021877848678
163205,"private void animFold(int finalValue){
  ValueAnimator animator=ValueAnimator.ofInt(topView.getMeasuredHeight(),finalValue);
  animator.addUpdateListener(new TopFoldAnimatorListener(topView));
  animator.setDuration(FOLD_DURATION);
  animator.start();
}","private void animFold(int finalValue){
  ValueAnimator animator=ValueAnimator.ofInt(topView.getMeasuredHeight(),finalValue);
  animator.addUpdateListener(new TopFoldAnimatorListener(topView));
  animator.setDuration(FOLD_DURATION);
  animator.setInterpolator(new AccelerateDecelerateInterpolator());
  animator.start();
}",0.8815331010452961
163206,"public void setEmpty(){
  if (emptyText != null && emptyIcon != null) {
    if (getNoDataIcon() != null && getNoDataText() > 0) {
      IconDrawable iconDrawable=new IconDrawable(getActivity(),getNoDataIcon());
      iconDrawable.colorRes(R.color.gray_github_medium);
      emptyIcon.setImageDrawable(iconDrawable);
      emptyText.setText(getNoDataText());
      emptyLy.setVisibility(View.VISIBLE);
    }
  }
}","public void setEmpty(){
  if (getActivity() != null) {
    if (emptyText != null && emptyIcon != null) {
      if (getNoDataIcon() != null && getNoDataText() > 0) {
        IconDrawable iconDrawable=new IconDrawable(getActivity(),getNoDataIcon());
        iconDrawable.colorRes(R.color.gray_github_medium);
        emptyIcon.setImageDrawable(iconDrawable);
        emptyText.setText(getNoDataText());
        emptyLy.setVisibility(View.VISIBLE);
      }
    }
  }
}",0.919042189281642
163207,"public IssueInfo(Parcel in){
  super(in);
  num=in.readInt();
}","public IssueInfo(Parcel in){
  owner=in.readString();
  repo=in.readString();
  num=in.readInt();
}",0.7283950617283951
163208,"@Override public void writeToParcel(Parcel dest,int flags){
  super.writeToParcel(dest,flags);
  dest.writeInt(num);
}","@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeString(owner);
  dest.writeString(repo);
  dest.writeInt(num);
}",0.8031496062992126
163209,"public RepoInfo(Parcel in){
  super(in);
  repo=in.readString();
}","public RepoInfo(Parcel in){
  owner=in.readString();
  repo=in.readString();
}",0.8611111111111112
163210,"@Override public void writeToParcel(Parcel dest,int flags){
  super.writeToParcel(dest,flags);
  dest.writeString(repo);
}","@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeString(owner);
  dest.writeString(repo);
}",0.8559322033898306
163211,"@Override public void onFail(RetrofitError error){
  stopRefresh();
  setEmpty();
  ErrorHandler.onRetrofitError(getActivity(),this.getClass().getSimpleName(),error);
}","@Override public void onFail(RetrofitError error){
  stopRefresh();
  if (getListAdapter() == null || getListAdapter().getCount() == 0) {
    setEmpty();
  }
  ErrorHandler.onRetrofitError(getActivity(),""String_Node_Str"",error);
}",0.6984924623115578
163212,"@Override public void onResponseOk(K k,Response r){
  if (getActivity() != null && isAdded()) {
    stopRefresh();
    if (!paging && k != null && k instanceof List) {
      if (emptyLy != null && ((List)k).size() > 0) {
        emptyLy.setVisibility(View.GONE);
        getLinkData(r);
        onResponse(k,refreshing);
      }
 else {
        setEmpty();
      }
    }
 else {
      setEmpty();
    }
  }
}","@Override public void onResponseOk(K k,Response r){
  if (getActivity() != null && isAdded()) {
    stopRefresh();
    if (k != null && k instanceof List) {
      if (emptyLy != null && ((List)k).size() > 0) {
        emptyLy.setVisibility(View.GONE);
        getLinkData(r);
        onResponse(k,refreshing);
        paging=false;
        refreshing=false;
      }
 else {
        setEmpty();
      }
    }
 else {
      setEmpty();
    }
  }
}",0.9308323563892146
163213,"@Override protected Iconify.IconValue getNoDataIcon(){
  return null;
}","@Override protected Iconify.IconValue getNoDataIcon(){
  return Iconify.IconValue.fa_info_circle;
}",0.8235294117647058
163214,"@Override protected int getNoDataText(){
  return 0;
}","@Override protected int getNoDataText(){
  return R.string.no_issues_found;
}",0.8091603053435115
163215,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Tracker t=((GistsApplication)getApplication()).getTracker();
  t.setScreenName(this.getClass().getSimpleName());
  t.send(new HitBuilders.AppViewBuilder().build());
  BugSenseHandler.initAndStartSession(BaseActivity.this,""String_Node_Str"");
  ImageLoader.getInstance().init(UniversalImageLoaderUtils.getImageLoaderConfiguration(this));
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (!BuildConfig.DEBUG) {
    Tracker t=((GistsApplication)getApplication()).getTracker();
    t.setScreenName(this.getClass().getSimpleName());
    t.send(new HitBuilders.AppViewBuilder().build());
    BugSenseHandler.initAndStartSession(BaseActivity.this,""String_Node_Str"");
    ImageLoader.getInstance().init(UniversalImageLoaderUtils.getImageLoaderConfiguration(this));
  }
}",0.9543478260869566
163216,"private void setUpFromPaletteItem(PaletteItem paletteItem){
  this.usedPalette=paletteItem;
  int rgb=getResources().getColor(R.color.accent);
  if (paletteItem != null && paletteItem.getRgb() != 0x000000) {
    rgb=paletteItem.getRgb();
  }
  if (getActivity().getActionBar() != null) {
    animateChange(rgb);
  }
  avatarImage.setBorderColor(rgb);
  selectButton(null);
  mailText.setPrefixColor(rgb);
  blogText.setPrefixColor(rgb);
  joinedText.setPrefixColor(rgb);
}","private void setUpFromPaletteItem(PaletteItem paletteItem){
  if (isAdded()) {
    this.usedPalette=paletteItem;
    int rgb=getResources().getColor(R.color.accent);
    if (paletteItem != null && paletteItem.getRgb() != 0x000000) {
      rgb=paletteItem.getRgb();
    }
    if (getActivity().getActionBar() != null) {
      animateChange(rgb);
    }
    avatarImage.setBorderColor(rgb);
    selectButton(null);
    mailText.setPrefixColor(rgb);
    blogText.setPrefixColor(rgb);
    joinedText.setPrefixColor(rgb);
  }
}",0.9506545820745216
163217,"@Override public void onResponseOk(ListContents contents,Response r){
  if (contentAdapter == null) {
    contentAdapter=new RepoContentAdapter(getActivity(),new ArrayList<Content>());
    setListAdapter(contentAdapter);
  }
  Collections.sort(contents,ListContents.SORT.TYPE);
  contentAdapter.clear();
  contentAdapter.addAll(contents);
}","@Override public void onResponseOk(ListContents contents,Response r){
  try {
    if (contentAdapter == null) {
      contentAdapter=new RepoContentAdapter(getActivity(),new ArrayList<Content>());
      setListAdapter(contentAdapter);
    }
    Collections.sort(contents,ListContents.SORT.TYPE);
    contentAdapter.clear();
    contentAdapter.addAll(contents);
  }
 catch (  Exception e) {
    BugSenseHandler.addCrashExtraData(""String_Node_Str"",e.getMessage());
    BugSenseHandler.flush(getActivity());
  }
}",0.6611764705882353
163218,"private boolean validateAllValues(Object[] objectRow){
  if (conversions != null && conversions.validatedIndexes != null) {
    boolean keepRow=true;
    for (int i=0; keepRow && i < conversions.validatedIndexes.length; i++) {
      int index=conversions.validatedIndexes[i];
      try {
        Object value=index < objectRow.length ? objectRow[i] : null;
        conversions.executeValidations(index,value);
      }
 catch (      Throwable ex) {
        keepRow=handleConversionError(ex,objectRow,index);
      }
    }
    return keepRow;
  }
  return true;
}","private boolean validateAllValues(Object[] objectRow){
  if (conversions != null && conversions.validatedIndexes != null) {
    boolean keepRow=true;
    for (int i=0; keepRow && i < conversions.validatedIndexes.length; i++) {
      int index=conversions.validatedIndexes[i];
      try {
        Object value=index < objectRow.length ? objectRow[index] : null;
        conversions.executeValidations(index,value);
      }
 catch (      Throwable ex) {
        keepRow=handleConversionError(ex,objectRow,index);
      }
    }
    return keepRow;
  }
  return true;
}",0.9964476021314388
163219,"@Test(expectedExceptions=DataValidationException.class) public void testValidationAnnotation(){
  List<A> list=new CsvRoutines().parseAll(A.class,new StringReader(""String_Node_Str""));
  System.out.println(list);
}","@Test public void testValidationAnnotation(){
  CsvParserSettings settings=new CsvParserSettings();
  final boolean[] ran=new boolean[]{false};
  settings.setProcessorErrorHandler(new ProcessorErrorHandler<Context>(){
    @Override public void handleError(    DataProcessingException error,    Object[] inputRow,    Context context){
      assertEquals(error.getColumnIndex(),2);
      assertEquals(inputRow[2],""String_Node_Str"");
      ran[0]=true;
    }
  }
);
  new CsvRoutines(settings).parseAll(A.class,new StringReader(""String_Node_Str""));
  assertTrue(ran[0]);
}",0.248081841432225
163220,"/** 
 * Goes through a list of objects and associates each value to a particular field of a java bean instance
 * @param instance the java bean instance that is going to have its properties set
 * @param row      the values to associate with each field of the javabean.
 * @param context  information about the current parsing process.
 */
void mapValuesToFields(T instance,Object[] row,Context context){
  if (row.length > lastFieldIndexMapped) {
    this.lastFieldIndexMapped=row.length;
    mapFieldIndexes(context,row,context.headers(),context.extractedFieldIndexes(),context.columnsReordered());
  }
  int last=row.length < readOrder.length ? row.length : readOrder.length;
  int i=0;
  for (; i < last; i++) {
    FieldMapping field=readOrder[i];
    if (field != null) {
      Object value=row[i];
      field.write(instance,value);
    }
  }
  if (missing != null) {
    for (i=0; i < missing.length; i++) {
      Object value=valuesForMissing[i];
      if (value != null) {
        FieldMapping field=missing[i];
        field.write(instance,value);
      }
    }
  }
}","/** 
 * Goes through a list of objects and associates each value to a particular field of a java bean instance
 * @param instance the java bean instance that is going to have its properties set
 * @param row      the values to associate with each field of the javabean.
 * @param context  information about the current parsing process.
 */
void mapValuesToFields(T instance,Object[] row,Context context){
  if (row.length > lastFieldIndexMapped) {
    this.lastFieldIndexMapped=row.length;
    mapFieldIndexes(context,row,context.headers(),context.extractedFieldIndexes(),context.columnsReordered());
  }
  int last=row.length < readOrder.length ? row.length : readOrder.length;
  int i=0;
  for (; i < last; i++) {
    FieldMapping field=readOrder[i];
    if (field != null) {
      Object value=row[i];
      field.write(instance,value);
    }
  }
  if (row.length < readOrder.length) {
    i=last;
    for (; i < readOrder.length; i++) {
      FieldMapping field=readOrder[i];
      if (field != null) {
        Object value=conversions.applyConversions(i,null,null);
        field.write(instance,value);
      }
    }
  }
  if (missing != null) {
    for (i=0; i < missing.length; i++) {
      Object value=valuesForMissing[i];
      if (value != null) {
        FieldMapping field=missing[i];
        field.write(instance,value);
      }
    }
  }
}",0.8618421052631579
163221,"/** 
 * Defines whether fields selected using the field selection methods (defined by the parent class   {@link CommonSettings}) should be reordered (defaults to true). <p>When disabled, each parsed record will contain values for all columns, in the order they occur in the input. Fields which were not selected will not be parsed but and the record will contain empty values. <p>When enabled, each parsed record will contain values only for the selected columns. The values will be ordered according to the selection.
 * @param columnReorderingEnabled the flag indicating whether or not selected fields should be reordered and returned by the parser
 */
public void setColumnReorderingEnabled(boolean columnReorderingEnabled){
  if (columnReorderingEnabled && preventReordering()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.columnReorderingEnabled=columnReorderingEnabled;
}","/** 
 * Defines whether fields selected using the field selection methods (defined by the parent class   {@link CommonSettings}) should be reordered (defaults to true). <p>When disabled, each parsed record will contain values for all columns, in the order they occur in the input. Fields which were not selected will not be parsed but the record will contain empty values. <p>When enabled, each parsed record will contain values only for the selected columns. The values will be ordered according to the selection.
 * @param columnReorderingEnabled the flag indicating whether or not selected fields should be reordered and returned by the parser
 */
public void setColumnReorderingEnabled(boolean columnReorderingEnabled){
  if (columnReorderingEnabled && preventReordering()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.columnReorderingEnabled=columnReorderingEnabled;
}",0.9977827050997784
163222,"/** 
 * Initializes the ParserOutput with the configuration specified in   {@link CommonParserSettings}
 * @param parser   the parser whose output will be managed by this class.
 * @param settings the parser configuration
 */
public ParserOutput(AbstractParser<?> parser,CommonParserSettings<?> settings){
  this.parser=parser;
  this.appenderInstance=settings.newCharAppender();
  this.appender=appenderInstance;
  this.parsedValues=new String[settings.getMaxColumns()];
  this.appenders=new CharAppender[settings.getMaxColumns() + 1];
  Arrays.fill(appenders,appender);
  this.settings=settings;
  this.skipEmptyLines=settings.getSkipEmptyLines();
  this.nullValue=settings.getNullValue();
  this.columnsToExtractInitialized=false;
  this.currentRecord=0;
  if (settings.getHeaders() != null) {
    initializeHeaders();
  }
}","/** 
 * Initializes the ParserOutput with the configuration specified in   {@link CommonParserSettings}
 * @param parser   the parser whose output will be managed by this class.
 * @param settings the parser configuration
 */
public ParserOutput(AbstractParser<?> parser,CommonParserSettings<?> settings){
  this.parser=parser;
  this.appenderInstance=settings.newCharAppender();
  this.appender=appenderInstance;
  this.parsedValues=new String[settings.getMaxColumns()];
  this.appenders=new CharAppender[settings.getMaxColumns() + 1];
  Arrays.fill(appenders,appender);
  this.settings=settings;
  this.skipEmptyLines=settings.getSkipEmptyLines();
  this.nullValue=settings.getNullValue();
  this.columnsToExtractInitialized=false;
  this.currentRecord=0;
  if (settings.getHeaders() != null) {
    initializeHeaders();
  }
  this.columnReorderingEnabledSetting=settings.isColumnReorderingEnabled();
}",0.9560693641618496
163223,"/** 
 * Gets all values parsed in the   {@link ParserOutput#parsedValues} array
 * @return the sequence of parsed values in a record.
 */
public String[] rowParsed(){
  if (column > 0) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
      if (settings.isHeaderExtractionEnabled()) {
        Arrays.fill(parsedValues,null);
        column=0;
        this.appender=appenders[0];
        return null;
      }
 else       if (!columnsReordered && selectedIndexes != null) {
        String[] out=new String[column];
        for (int i=0; i < selectedIndexes.length; i++) {
          int index=selectedIndexes[i];
          if (index < column) {
            out[index]=parsedValues[index];
          }
        }
        column=0;
        return out;
      }
    }
    currentRecord++;
    if (columnsReordered) {
      String[] reorderedValues=new String[selectedIndexes.length];
      for (int i=0; i < selectedIndexes.length; i++) {
        int index=selectedIndexes[i];
        if (index >= column || index == -1) {
          reorderedValues[i]=nullValue;
        }
 else {
          reorderedValues[i]=parsedValues[index];
        }
      }
      column=0;
      this.appender=appenders[0];
      return reorderedValues;
    }
 else {
      String[] out=new String[column];
      System.arraycopy(parsedValues,0,out,0,column);
      column=0;
      this.appender=appenders[0];
      return out;
    }
  }
 else   if (!skipEmptyLines) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
    }
    currentRecord++;
    if (columnsReordered) {
      String[] out=new String[selectedIndexes.length];
      Arrays.fill(out,nullValue);
      return out;
    }
    return ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  return null;
}","/** 
 * Gets all values parsed in the   {@link ParserOutput#parsedValues} array
 * @return the sequence of parsed values in a record.
 */
public String[] rowParsed(){
  if (column > 0) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
      if (settings.isHeaderExtractionEnabled()) {
        Arrays.fill(parsedValues,null);
        column=0;
        this.appender=appenders[0];
        return null;
      }
 else       if (!columnsReordered && selectedIndexes != null) {
        String[] out=new String[column];
        for (int i=0; i < selectedIndexes.length; i++) {
          int index=selectedIndexes[i];
          if (index < column) {
            out[index]=parsedValues[index];
          }
        }
        column=0;
        return out;
      }
    }
    currentRecord++;
    if (columnsReordered) {
      String[] reorderedValues=new String[selectedIndexes.length];
      for (int i=0; i < selectedIndexes.length; i++) {
        int index=selectedIndexes[i];
        if (index >= column || index == -1) {
          reorderedValues[i]=nullValue;
        }
 else {
          reorderedValues[i]=parsedValues[index];
        }
      }
      column=0;
      this.appender=appenders[0];
      return reorderedValues;
    }
 else {
      int last=columnReorderingEnabledSetting ? column : column < headers.length ? headers.length : column;
      String[] out=new String[last];
      System.arraycopy(parsedValues,0,out,0,column);
      column=0;
      this.appender=appenders[0];
      return out;
    }
  }
 else   if (!skipEmptyLines) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
    }
    currentRecord++;
    if (columnsReordered) {
      String[] out=new String[selectedIndexes.length];
      Arrays.fill(out,nullValue);
      return out;
    }
    return ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  return null;
}",0.9673672566371682
163224,"/** 
 * Returns the next available bucket. Blocks until a bucket is made available or the reading process stops.
 * @return the next available bucket.
 */
@SuppressWarnings(""String_Node_Str"") public synchronized CharBucket nextBucket(){
  if (activeExecution == null && !finished) {
    int length=-1;
    try {
      length=readBucket();
      if (length >= 0 && length <= 4) {
        length=readBucket();
      }
    }
 catch (    BomInput.BytesProcessedNotification e) {
      throw e;
    }
catch (    Exception e) {
      error=e;
    }
    if (length != -1) {
      activeExecution=new Thread(this,""String_Node_Str"");
      activeExecution.start();
    }
 else {
      finished=true;
      try {
        buckets.put(end);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
 finally {
        stopReading();
      }
    }
  }
  try {
    if (finished) {
      if (buckets.size() <= 1) {
        return end;
      }
    }
    if (currentBucket != null) {
      instances.release(currentBucket);
    }
    Object element=buckets.take();
    if (element == end) {
      finished=true;
      return end;
    }
 else {
      currentBucket=(Entry<CharBucket>)element;
    }
    return currentBucket.get();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    finished=true;
    return end;
  }
}","/** 
 * Returns the next available bucket. Blocks until a bucket is made available or the reading process stops.
 * @return the next available bucket.
 */
@SuppressWarnings(""String_Node_Str"") public synchronized CharBucket nextBucket(){
  if (activeExecution == null && !finished) {
    int length=-1;
    try {
      length=readBucket();
      if (length >= 0 && length <= 4) {
        length=readBucket();
      }
    }
 catch (    BomInput.BytesProcessedNotification e) {
      throw e;
    }
catch (    Exception e) {
      setError(e);
    }
    if (length != -1) {
      activeExecution=new Thread(this,""String_Node_Str"");
      activeExecution.start();
    }
 else {
      finished=true;
      try {
        buckets.put(end);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
 finally {
        stopReading();
      }
    }
  }
  try {
    if (finished) {
      if (buckets.size() <= 1) {
        return end;
      }
    }
    if (currentBucket != null) {
      instances.release(currentBucket);
    }
    Object element=buckets.take();
    if (element == end) {
      finished=true;
      return end;
    }
 else {
      currentBucket=(Entry<CharBucket>)element;
    }
    return currentBucket.get();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    finished=true;
    return end;
  }
}",0.9934640522875816
163225,"/** 
 * The   {@link CharBucket} loading process that executes in parallel until the input is completely read.Once the end of the input is reached, the  {@link java.io.Reader} instance provided in the constructor is closed.
 */
@Override public void run(){
  try {
    try {
      while (readBucket() != -1 && active)       ;
    }
  finally {
      buckets.put(end);
    }
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
catch (  Exception e) {
    finished=true;
    error=e;
  }
 finally {
    stopReading();
  }
}","/** 
 * The   {@link CharBucket} loading process that executes in parallel until the input is completely read.Once the end of the input is reached, the  {@link java.io.Reader} instance provided in the constructor is closed.
 */
@Override public void run(){
  try {
    try {
      while (active && readBucket() != -1)       ;
    }
  finally {
      buckets.put(end);
    }
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
catch (  Exception e) {
    finished=true;
    setError(e);
  }
 finally {
    stopReading();
  }
}",0.9657657657657658
163226,"private TextParsingException handleException(Throwable ex){
  if (ex instanceof DataProcessingException) {
    DataProcessingException error=(DataProcessingException)ex;
    error.restrictContent(errorContentLength);
    error.setContext(this.context);
    throw error;
  }
  String message=ex.getClass().getName() + ""String_Node_Str"" + ex.getMessage();
  char[] chars=output.appender.getChars();
  if (chars != null) {
    int length=output.appender.length();
    if (length > chars.length) {
      message=""String_Node_Str"" + length + ""String_Node_Str""+ ""String_Node_Str""+ settings.getMaxCharsPerColumn()+ ""String_Node_Str"";
      length=chars.length;
    }
    String tmp=new String(chars);
    if (tmp.contains(""String_Node_Str"") || tmp.contains(""String_Node_Str"")) {
      tmp=displayLineSeparators(tmp,true);
      String lineSeparator=displayLineSeparators(settings.getFormat().getLineSeparatorString(),false);
      message+=""String_Node_Str"" + ""String_Node_Str"" + lineSeparator + ""String_Node_Str""+ getParsedContent(tmp);
    }
    int nullCharacterCount=0;
    int maxLength=length > Integer.MAX_VALUE / 2 ? Integer.MAX_VALUE / 2 - 1 : length;
    StringBuilder s=new StringBuilder(maxLength);
    for (int i=0; i < maxLength; i++) {
      if (chars[i] == '\0') {
        s.append('\\');
        s.append('0');
        nullCharacterCount++;
      }
 else {
        s.append(chars[i]);
      }
    }
    tmp=s.toString();
    if (nullCharacterCount > 0) {
      message+=""String_Node_Str"" + nullCharacterCount + ""String_Node_Str""+ ""String_Node_Str""+ getParsedContent(tmp);
    }
  }
  if (ex instanceof ArrayIndexOutOfBoundsException) {
    try {
      int index=Integer.parseInt(ex.getMessage());
      if (index == settings.getMaxCharsPerColumn()) {
        message+=""String_Node_Str"" + index + ""String_Node_Str"";
      }
      if (index == settings.getMaxColumns()) {
        message+=""String_Node_Str"" + index + ""String_Node_Str"";
      }
      message+=""String_Node_Str"";
    }
 catch (    Throwable t) {
    }
  }
  try {
    if (!message.isEmpty()) {
      message+=""String_Node_Str"";
    }
    message+=""String_Node_Str"" + settings.toString();
  }
 catch (  Exception t) {
  }
  if (errorContentLength == 0) {
    output.appender.reset();
  }
  TextParsingException out=new TextParsingException(context,message,ex);
  out.setErrorContentLength(errorContentLength);
  return out;
}","private TextParsingException handleException(Throwable ex){
  if (context != null) {
    context.stop();
  }
  if (ex instanceof DataProcessingException) {
    DataProcessingException error=(DataProcessingException)ex;
    error.restrictContent(errorContentLength);
    error.setContext(this.context);
    throw error;
  }
  String message=ex.getClass().getName() + ""String_Node_Str"" + ex.getMessage();
  char[] chars=output.appender.getChars();
  if (chars != null) {
    int length=output.appender.length();
    if (length > chars.length) {
      message=""String_Node_Str"" + length + ""String_Node_Str""+ ""String_Node_Str""+ settings.getMaxCharsPerColumn()+ ""String_Node_Str"";
      length=chars.length;
    }
    String tmp=new String(chars);
    if (tmp.contains(""String_Node_Str"") || tmp.contains(""String_Node_Str"")) {
      tmp=displayLineSeparators(tmp,true);
      String lineSeparator=displayLineSeparators(settings.getFormat().getLineSeparatorString(),false);
      message+=""String_Node_Str"" + ""String_Node_Str"" + lineSeparator + ""String_Node_Str""+ getParsedContent(tmp);
    }
    int nullCharacterCount=0;
    int maxLength=length > Integer.MAX_VALUE / 2 ? Integer.MAX_VALUE / 2 - 1 : length;
    StringBuilder s=new StringBuilder(maxLength);
    for (int i=0; i < maxLength; i++) {
      if (chars[i] == '\0') {
        s.append('\\');
        s.append('0');
        nullCharacterCount++;
      }
 else {
        s.append(chars[i]);
      }
    }
    tmp=s.toString();
    if (nullCharacterCount > 0) {
      message+=""String_Node_Str"" + nullCharacterCount + ""String_Node_Str""+ ""String_Node_Str""+ getParsedContent(tmp);
    }
  }
  if (ex instanceof ArrayIndexOutOfBoundsException) {
    try {
      int index=Integer.parseInt(ex.getMessage());
      if (index == settings.getMaxCharsPerColumn()) {
        message+=""String_Node_Str"" + index + ""String_Node_Str"";
      }
      if (index == settings.getMaxColumns()) {
        message+=""String_Node_Str"" + index + ""String_Node_Str"";
      }
      message+=""String_Node_Str"";
    }
 catch (    Throwable t) {
    }
  }
  try {
    if (!message.isEmpty()) {
      message+=""String_Node_Str"";
    }
    message+=""String_Node_Str"" + settings.toString();
  }
 catch (  Exception t) {
  }
  if (errorContentLength == 0) {
    output.appender.reset();
  }
  TextParsingException out=new TextParsingException(context,message,ex);
  out.setErrorContentLength(errorContentLength);
  return out;
}",0.9898823043568036
163227,"private String[] handleEOF(){
  String[] row=null;
  try {
    boolean consumeValueOnEOF=consumeValueOnEOF();
    if (output.column != 0 || consumeValueOnEOF) {
      if (output.appender.length() > 0 || consumeValueOnEOF) {
        output.valueParsed();
      }
 else {
        output.emptyParsed();
      }
      row=output.rowParsed();
    }
 else     if (output.appender.length() > 0) {
      output.valueParsed();
      row=output.rowParsed();
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw handleException(e);
  }
  if (row != null && processor != NoopProcessor.instance) {
    rowProcessed(row);
  }
  return row;
}","private String[] handleEOF(){
  String[] row=null;
  try {
    boolean consumeValueOnEOF=consumeValueOnEOF();
    if (output.column != 0 || consumeValueOnEOF) {
      if (output.appender.length() > 0 || consumeValueOnEOF) {
        output.valueParsed();
      }
 else {
        output.emptyParsed();
      }
      row=output.rowParsed();
    }
 else     if (output.appender.length() > 0) {
      output.valueParsed();
      row=output.rowParsed();
    }
  }
 catch (  Throwable e) {
    throw handleException(e);
  }
  if (row != null && processor != NoopProcessor.instance) {
    rowProcessed(row);
  }
  return row;
}",0.9340746624305004
163228,"@Test(expectedExceptions=ArrayIndexOutOfBoundsException.class) public void test100Cols() throws Exception {
  final CsvParserSettings s=new CsvParserSettings();
  s.setHeaderExtractionEnabled(true);
  s.setMaxColumns(99);
  final RowListProcessor rowListProcessor=new RowListProcessor();
  s.setProcessor(rowListProcessor);
  final CsvParser parser=new CsvParser(s);
  parser.parse(newReader(""String_Node_Str""));
  fail(""String_Node_Str"");
}","@Test(expectedExceptions=TextParsingException.class) public void test100Cols() throws Exception {
  final CsvParserSettings s=new CsvParserSettings();
  s.setHeaderExtractionEnabled(true);
  s.setMaxColumns(99);
  s.setLineSeparatorDetectionEnabled(true);
  final RowListProcessor rowListProcessor=new RowListProcessor();
  s.setProcessor(rowListProcessor);
  final CsvParser parser=new CsvParser(s);
  parser.parse(newReader(""String_Node_Str""));
  fail(""String_Node_Str"");
}",0.9170305676855895
163229,"@Override protected final void parseRecord(){
  if (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {
    ch=input.skipWhitespace(ch,delimiter,quote);
  }
  while (ch != newLine) {
    if (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {
      ch=input.skipWhitespace(ch,delimiter,quote);
    }
    if (ch == delimiter || ch == newLine) {
      output.emptyParsed();
    }
 else {
      unescaped=false;
      prev='\0';
      if (ch == quote) {
        output.trim=false;
        input.enableNormalizeLineEndings(normalizeLineEndingsInQuotes);
        if (output.appender.length() == 0) {
          String value=input.getQuotedString(quote,quoteEscape,escapeEscape,maxColumnLength,delimiter,newLine,keepQuotes,keepEscape);
          if (value != null) {
            output.valueParsed(value == ""String_Node_Str"" ? emptyValue : value);
            try {
              ch=input.nextChar();
              if (ch == delimiter) {
                try {
                  ch=input.nextChar();
                }
 catch (                EOFException e) {
                  output.emptyParsed();
                  return;
                }
              }
            }
 catch (            EOFException e) {
              return;
            }
            continue;
          }
        }
        parseQuotedValue();
        input.enableNormalizeLineEndings(true);
        output.valueParsed();
      }
 else       if (doNotEscapeUnquotedValues) {
        String value=null;
        if (output.appender.length() == 0) {
          value=input.getString(ch,delimiter,ignoreTrailingWhitespace,nullValue,maxColumnLength);
        }
        if (value != null) {
          output.valueParsed(value);
          ch=input.getChar();
        }
 else {
          output.trim=ignoreTrailingWhitespace;
          ch=output.appender.appendUntil(ch,input,delimiter,newLine);
          output.valueParsed();
        }
      }
 else {
        output.trim=ignoreTrailingWhitespace;
        parseValueProcessingEscape();
        output.valueParsed();
      }
    }
    if (ch != newLine) {
      ch=input.nextChar();
      if (ch == newLine) {
        output.emptyParsed();
      }
    }
  }
}","@Override protected final void parseRecord(){
  if (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {
    ch=input.skipWhitespace(ch,delimiter,quote);
  }
  while (ch != newLine) {
    if (ch <= ' ' && ignoreLeadingWhitespace && whitespaceRangeStart < ch) {
      ch=input.skipWhitespace(ch,delimiter,quote);
    }
    if (ch == delimiter || ch == newLine) {
      output.emptyParsed();
    }
 else {
      unescaped=false;
      prev='\0';
      if (ch == quote) {
        output.trim=false;
        input.enableNormalizeLineEndings(normalizeLineEndingsInQuotes);
        if (output.appender.length() == 0) {
          String value=input.getQuotedString(quote,quoteEscape,escapeEscape,maxColumnLength,delimiter,newLine,keepQuotes,keepEscape);
          if (value != null) {
            output.valueParsed(value == ""String_Node_Str"" ? emptyValue : value);
            try {
              ch=input.nextChar();
              if (ch == delimiter) {
                try {
                  ch=input.nextChar();
                  if (ch == newLine) {
                    output.emptyParsed();
                  }
                }
 catch (                EOFException e) {
                  output.emptyParsed();
                  return;
                }
              }
            }
 catch (            EOFException e) {
              return;
            }
            continue;
          }
        }
        parseQuotedValue();
        input.enableNormalizeLineEndings(true);
        output.valueParsed();
      }
 else       if (doNotEscapeUnquotedValues) {
        String value=null;
        if (output.appender.length() == 0) {
          value=input.getString(ch,delimiter,ignoreTrailingWhitespace,nullValue,maxColumnLength);
        }
        if (value != null) {
          output.valueParsed(value);
          ch=input.getChar();
        }
 else {
          output.trim=ignoreTrailingWhitespace;
          ch=output.appender.appendUntil(ch,input,delimiter,newLine);
          output.valueParsed();
        }
      }
 else {
        output.trim=ignoreTrailingWhitespace;
        parseValueProcessingEscape();
        output.valueParsed();
      }
    }
    if (ch != newLine) {
      ch=input.nextChar();
      if (ch == newLine) {
        output.emptyParsed();
      }
    }
  }
}",0.9775904149101398
163230,"/** 
 * Converts the given parsed row to a   {@link Record}
 * @return a {@link Record} representing the given row.
 */
Record toRecord(String[] row);","/** 
 * Converts the given parsed row to a   {@link Record}
 * @param row the row to be converted into a {@link Record}
 * @return a {@link Record} representing the given row.
 */
Record toRecord(String[] row);",0.8333333333333334
163231,"/** 
 * Unsupported operation.
 * @param input the input be converted.
 * @return throws a {@code UnsupportedOperationException}
 * @throws UnsupportedOperationException
 */
@Override public Object revert(String input){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","/** 
 * Unsupported operation.
 * @param input the input be converted.
 * @return throws a {@code UnsupportedOperationException}
 */
@Override public Object revert(String input){
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.921904761904762
163232,"/** 
 * Defines whether or not leading whitespaces from quoted values should be skipped  (defaults to false) Note: if   {@link #keepQuotes} evaluates to {@code true}, values won't be trimmed.
 * @param ignoreLeadingWhitespaces whether leading whitespaces from quoted values should be skipped
 */
public void setIgnoreLeadingWhitespacesInQuotes(boolean ignoreLeadingWhitespacesInQuotes){
  this.ignoreLeadingWhitespacesInQuotes=ignoreLeadingWhitespacesInQuotes;
}","/** 
 * Defines whether or not leading whitespaces from quoted values should be skipped  (defaults to false) Note: if   {@link #keepQuotes} evaluates to {@code true}, values won't be trimmed.
 * @param ignoreLeadingWhitespacesInQuotes whether leading whitespaces from quoted values should be skipped
 */
public void setIgnoreLeadingWhitespacesInQuotes(boolean ignoreLeadingWhitespacesInQuotes){
  this.ignoreLeadingWhitespacesInQuotes=ignoreLeadingWhitespacesInQuotes;
}",0.9914163090128756
163233,"/** 
 * Returns the name to be used as a header based on a given field and its   {@link Parsed} annotation.
 * @return the header name to be used for the given field.
 */
public String getHeaderName(){
  if (target == null) {
    return null;
  }
  String name=null;
  Parsed annotation=findAnnotation(target,Parsed.class);
  if (annotation != null) {
    if (annotation.field().length == 0) {
      name=getTargetName();
    }
 else {
      name=annotation.field()[0];
    }
  }
  if (transformer != null) {
    if (field != null) {
      return transformer.transformName(field,name);
    }
 else {
      return transformer.transformName(method,name);
    }
  }
  return name;
}","/** 
 * Returns the name to be used as a header based on a given field and its   {@link Parsed} annotation.
 * @return the header name to be used for the given field.
 */
public String getHeaderName(){
  if (target == null) {
    return null;
  }
  String name=null;
  Parsed annotation=findAnnotation(target,Parsed.class);
  if (annotation != null) {
    if (annotation.field().length == 0) {
      name=getTargetName();
    }
 else {
      name=annotation.field()[0];
    }
    if (name.length() == 0) {
      name=getTargetName();
    }
  }
  if (transformer != null) {
    if (field != null) {
      return transformer.transformName(field,name);
    }
 else {
      return transformer.transformName(method,name);
    }
  }
  return name;
}",0.9549929676511956
163234,"/** 
 * Requests the next batch of characters from the implementing class and updates the character count. <p> If there are no more characters in the input, the reading will stop by invoking the   {@link AbstractCharInputReader#stop()} method.
 */
private void updateBuffer(){
  if (length - recordStart > 0 && buffer != null && !skipping) {
    tmp.append(buffer,recordStart,length - recordStart);
  }
  recordStart=0;
  reloadBuffer();
  charCount+=i;
  i=0;
  if (length == -1) {
    stop();
    incrementLineCount=true;
  }
  if (inputAnalysisProcesses != null) {
    try {
      for (      InputAnalysisProcess process : inputAnalysisProcesses) {
        process.execute(buffer,length);
      }
    }
  finally {
      if (length > 4) {
        inputAnalysisProcesses=null;
      }
    }
  }
}","/** 
 * Requests the next batch of characters from the implementing class and updates the character count. <p> If there are no more characters in the input, the reading will stop by invoking the   {@link AbstractCharInputReader#stop()} method.
 */
private void updateBuffer(){
  if (length - recordStart > 0 && buffer != null && !skipping) {
    tmp.append(buffer,recordStart,length - recordStart);
  }
  recordStart=0;
  reloadBuffer();
  charCount+=i;
  i=0;
  if (length == -1) {
    stop();
    incrementLineCount=true;
  }
  if (inputAnalysisProcesses != null) {
    if (length > 0 && length <= 4) {
      int tmpLength=length;
      char[] tmp=Arrays.copyOfRange(buffer,0,length + 1);
      List<InputAnalysisProcess> processes=inputAnalysisProcesses;
      inputAnalysisProcesses=null;
      reloadBuffer();
      inputAnalysisProcesses=processes;
      if (length != -1) {
        char[] newBuffer=new char[tmpLength + buffer.length];
        System.arraycopy(tmp,0,newBuffer,0,tmpLength);
        System.arraycopy(buffer,0,newBuffer,tmpLength,length);
        buffer=newBuffer;
        length+=tmpLength;
      }
 else {
        buffer=tmp;
        length=tmpLength;
      }
    }
    try {
      for (      InputAnalysisProcess process : inputAnalysisProcesses) {
        process.execute(buffer,length);
      }
    }
  finally {
      if (length > 4) {
        inputAnalysisProcesses=null;
      }
    }
  }
}",0.7069431920649234
163235,"@Override public void execute(char[] characters,int length){
  Set<Character> allSymbols=new HashSet<Character>();
  Map<Character,Integer> symbols=new HashMap<Character,Integer>();
  Map<Character,Integer> escape=new HashMap<Character,Integer>();
  List<Map<Character,Integer>> symbolsPerRow=new ArrayList<Map<Character,Integer>>();
  int doubleQuoteCount=0;
  int singleQuoteCount=0;
  int i;
  char inQuote='\0';
  boolean afterNewLine=true;
  for (i=0; i < length; i++) {
    char ch=characters[i];
    if (afterNewLine && ch == comment) {
      while (++i < length) {
        ch=characters[i];
        if (ch == '\r' || ch == '\n' || ch == normalizedNewLine) {
          break;
        }
      }
      continue;
    }
    if (ch == '""' || ch == '\'') {
      if (inQuote == ch) {
        if (ch == '""') {
          doubleQuoteCount++;
        }
 else {
          singleQuoteCount++;
        }
        if (i + 1 < length) {
          char next=characters[i + 1];
          if (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\n' && next != '\r')) {
            char prev=characters[i - 1];
            if (!Character.isLetterOrDigit(prev)) {
              increment(escape,prev);
            }
          }
        }
        inQuote='\0';
      }
 else       if (inQuote == '\0') {
        char prev='\0';
        int j=i;
        while (prev <= ' ' && --j >= 0) {
          prev=characters[j];
        }
        if (j < 0 || !Character.isLetterOrDigit(prev)) {
          inQuote=ch;
        }
      }
      continue;
    }
    if (inQuote != '\0') {
      continue;
    }
    afterNewLine=false;
    if (isSymbol(ch)) {
      allSymbols.add(ch);
      increment(symbols,ch);
    }
 else     if ((ch == '\r' || ch == '\n' || ch == normalizedNewLine) && symbols.size() > 0) {
      afterNewLine=true;
      symbolsPerRow.add(symbols);
      if (symbolsPerRow.size() == MAX_ROW_SAMPLES) {
        break;
      }
      symbols=new HashMap<Character,Integer>();
    }
  }
  if (length >= characters.length && i >= length && symbolsPerRow.size() > 1) {
    symbolsPerRow.remove(symbolsPerRow.size() - 1);
  }
  Map<Character,Integer> totals=calculateTotals(symbolsPerRow);
  Map<Character,Integer> sums=new HashMap<Character,Integer>();
  Set<Character> toRemove=new HashSet<Character>();
  for (  Map<Character,Integer> previous : symbolsPerRow) {
    for (    Map<Character,Integer> current : symbolsPerRow) {
      for (      Character symbol : allSymbols) {
        Integer previousCount=previous.get(symbol);
        Integer currentCount=current.get(symbol);
        if (previousCount == null && currentCount == null) {
          toRemove.add(symbol);
        }
        if (previousCount == null || currentCount == null) {
          continue;
        }
        increment(sums,symbol,Math.abs(previousCount - currentCount));
      }
    }
  }
  sums.keySet().removeAll(toRemove);
  char delimiterMax=max(sums,totals,suggestedDelimiter);
  char delimiterMin=min(sums,totals,suggestedDelimiter);
  char delimiter;
  out:   if (delimiterMax != delimiterMin) {
    if (sums.get(delimiterMin) == 0 && sums.get(delimiterMax) != 0) {
      delimiter=delimiterMin;
      break out;
    }
    if (totals.get(delimiterMin) > totals.get(delimiterMax)) {
      delimiter=delimiterMin;
      break out;
    }
    delimiter=delimiterMax;
  }
 else {
    delimiter=delimiterMax;
  }
  char quote=doubleQuoteCount >= singleQuoteCount ? '""' : '\'';
  escape.remove(delimiter);
  char quoteEscape=max(escape,totals,quote);
  apply(delimiter,quote,quoteEscape);
}","@Override public void execute(char[] characters,int length){
  Set<Character> allSymbols=new HashSet<Character>();
  Map<Character,Integer> symbols=new HashMap<Character,Integer>();
  Map<Character,Integer> escape=new HashMap<Character,Integer>();
  List<Map<Character,Integer>> symbolsPerRow=new ArrayList<Map<Character,Integer>>();
  int doubleQuoteCount=0;
  int singleQuoteCount=0;
  int i;
  char inQuote='\0';
  boolean afterNewLine=true;
  for (i=0; i < length; i++) {
    char ch=characters[i];
    if (afterNewLine && ch == comment) {
      while (++i < length) {
        ch=characters[i];
        if (ch == '\r' || ch == '\n' || ch == normalizedNewLine) {
          break;
        }
      }
      continue;
    }
    if (ch == '""' || ch == '\'') {
      if (inQuote == ch) {
        if (ch == '""') {
          doubleQuoteCount++;
        }
 else {
          singleQuoteCount++;
        }
        if (i + 1 < length) {
          char next=characters[i + 1];
          if (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\n' && next != '\r')) {
            char prev=characters[i - 1];
            if (!Character.isLetterOrDigit(prev)) {
              increment(escape,prev);
            }
          }
        }
        inQuote='\0';
      }
 else       if (inQuote == '\0') {
        char prev='\0';
        int j=i;
        while (prev <= ' ' && --j >= 0) {
          prev=characters[j];
        }
        if (j < 0 || !Character.isLetterOrDigit(prev)) {
          inQuote=ch;
        }
      }
      continue;
    }
    if (inQuote != '\0') {
      continue;
    }
    afterNewLine=false;
    if (isSymbol(ch)) {
      allSymbols.add(ch);
      increment(symbols,ch);
    }
 else     if ((ch == '\r' || ch == '\n' || ch == normalizedNewLine) && symbols.size() > 0) {
      afterNewLine=true;
      symbolsPerRow.add(symbols);
      if (symbolsPerRow.size() == MAX_ROW_SAMPLES) {
        break;
      }
      symbols=new HashMap<Character,Integer>();
    }
  }
  if (symbols.size() > 0 && length < characters.length) {
    symbolsPerRow.add(symbols);
  }
  if (length >= characters.length && i >= length && symbolsPerRow.size() > 1) {
    symbolsPerRow.remove(symbolsPerRow.size() - 1);
  }
  Map<Character,Integer> totals=calculateTotals(symbolsPerRow);
  Map<Character,Integer> sums=new HashMap<Character,Integer>();
  Set<Character> toRemove=new HashSet<Character>();
  for (  Map<Character,Integer> previous : symbolsPerRow) {
    for (    Map<Character,Integer> current : symbolsPerRow) {
      for (      Character symbol : allSymbols) {
        Integer previousCount=previous.get(symbol);
        Integer currentCount=current.get(symbol);
        if (previousCount == null && currentCount == null) {
          toRemove.add(symbol);
        }
        if (previousCount == null || currentCount == null) {
          continue;
        }
        increment(sums,symbol,Math.abs(previousCount - currentCount));
      }
    }
  }
  sums.keySet().removeAll(toRemove);
  char delimiterMax=max(sums,totals,suggestedDelimiter);
  char delimiterMin=min(sums,totals,suggestedDelimiter);
  char delimiter;
  out:   if (delimiterMax != delimiterMin) {
    if (sums.get(delimiterMin) == 0 && sums.get(delimiterMax) != 0) {
      delimiter=delimiterMin;
      break out;
    }
    if (totals.get(delimiterMin) > totals.get(delimiterMax)) {
      delimiter=delimiterMin;
      break out;
    }
    delimiter=delimiterMax;
  }
 else {
    delimiter=delimiterMax;
  }
  char quote=doubleQuoteCount >= singleQuoteCount ? '""' : '\'';
  escape.remove(delimiter);
  char quoteEscape=max(escape,totals,quote);
  apply(delimiter,quote,quoteEscape);
}",0.9870737073707372
163236,"/** 
 * Configures the parser based on the annotations provided in a given class
 * @param beanClass the classes whose annotations will be processed to derive configurations for parsing
 */
protected synchronized void configureFromAnnotations(Class<?> beanClass){
  Headers headerAnnotation=AnnotationHelper.findHeadersAnnotation(beanClass);
  String[] headersFromBean=ArgumentUtils.EMPTY_STRING_ARRAY;
  boolean allFieldsIndexBased=AnnotationHelper.allFieldsIndexBasedForParsing(beanClass);
  boolean extractHeaders=!allFieldsIndexBased;
  if (headerAnnotation != null) {
    if (headerAnnotation.sequence().length > 0) {
      headersFromBean=headerAnnotation.sequence();
    }
    extractHeaders=headerAnnotation.extract();
  }
  if (headerExtractionEnabled == null) {
    setHeaderExtractionEnabled(extractHeaders);
  }
  if (getHeaders() == null && headersFromBean.length > 0 && !headerExtractionEnabled) {
    setHeaders(headersFromBean);
  }
  if (getFieldSet() == null) {
    if (allFieldsIndexBased) {
      selectIndexes(AnnotationHelper.getSelectedIndexes(beanClass,MethodFilter.ONLY_SETTERS));
    }
 else     if (headersFromBean.length > 0 && AnnotationHelper.allFieldsNameBasedForParsing(beanClass)) {
      selectFields(headersFromBean);
    }
  }
}","/** 
 * Configures the parser based on the annotations provided in a given class
 * @param beanClass the classes whose annotations will be processed to derive configurations for parsing
 */
protected synchronized void configureFromAnnotations(Class<?> beanClass){
  if (!deriveHeadersFrom(beanClass)) {
    return;
  }
  Headers headerAnnotation=AnnotationHelper.findHeadersAnnotation(beanClass);
  String[] headersFromBean=ArgumentUtils.EMPTY_STRING_ARRAY;
  boolean allFieldsIndexBased=AnnotationHelper.allFieldsIndexBasedForParsing(beanClass);
  boolean extractHeaders=!allFieldsIndexBased;
  if (headerAnnotation != null) {
    if (headerAnnotation.sequence().length > 0) {
      headersFromBean=headerAnnotation.sequence();
    }
    extractHeaders=headerAnnotation.extract();
  }
  if (headerExtractionEnabled == null) {
    setHeaderExtractionEnabled(extractHeaders);
  }
  if (getHeaders() == null && headersFromBean.length > 0 && !headerExtractionEnabled) {
    setHeadersDerivedFromClass(beanClass,headersFromBean);
  }
  if (getFieldSet() == null) {
    if (allFieldsIndexBased) {
      selectIndexes(AnnotationHelper.getSelectedIndexes(beanClass,MethodFilter.ONLY_SETTERS));
    }
 else     if (headersFromBean.length > 0 && AnnotationHelper.allFieldsNameBasedForParsing(beanClass)) {
      selectFields(headersFromBean);
    }
  }
}",0.968187044844768
163237,"/** 
 * Configures the writer based on the annotations provided in a given class
 * @param beanClass the classes whose annotations will be processed to derive configurations for writing.
 */
protected void configureFromAnnotations(Class<?> beanClass){
  Headers headerAnnotation=AnnotationHelper.findHeadersAnnotation(beanClass);
  String[] headersFromBean=AnnotationHelper.deriveHeaderNamesFromFields(beanClass,MethodFilter.ONLY_GETTERS);
  boolean writeHeaders=false;
  if (headerAnnotation != null) {
    if (headerAnnotation.sequence().length > 0) {
      headersFromBean=headerAnnotation.sequence();
    }
    writeHeaders=headerAnnotation.write();
  }
  if (headerWritingEnabled == null) {
    headerWritingEnabled=writeHeaders;
  }
  if (getHeaders() == null && headersFromBean.length > 0) {
    setHeaders(headersFromBean);
  }
}","/** 
 * Configures the writer based on the annotations provided in a given class
 * @param beanClass the classes whose annotations will be processed to derive configurations for writing.
 */
protected void configureFromAnnotations(Class<?> beanClass){
  if (!deriveHeadersFrom(beanClass)) {
    return;
  }
  Headers headerAnnotation=AnnotationHelper.findHeadersAnnotation(beanClass);
  String[] headersFromBean=AnnotationHelper.deriveHeaderNamesFromFields(beanClass,MethodFilter.ONLY_GETTERS);
  boolean writeHeaders=false;
  if (headerAnnotation != null) {
    if (headerAnnotation.sequence().length > 0) {
      headersFromBean=headerAnnotation.sequence();
    }
    writeHeaders=headerAnnotation.write();
  }
  if (headerWritingEnabled == null) {
    headerWritingEnabled=writeHeaders;
  }
  if (getHeaders() == null && headersFromBean.length > 0) {
    setHeadersDerivedFromClass(beanClass,headersFromBean);
  }
}",0.9527065527065528
163238,"@Override public void execute(char[] characters,int length){
  Set<Character> allSymbols=new HashSet<Character>();
  Map<Character,Integer> symbols=new HashMap<Character,Integer>();
  Map<Character,Integer> escape=new HashMap<Character,Integer>();
  List<Map<Character,Integer>> symbolsPerRow=new ArrayList<Map<Character,Integer>>();
  int doubleQuoteCount=0;
  int singleQuoteCount=0;
  int i;
  char inQuote='\0';
  boolean afterNewLine=true;
  for (i=0; i < length; i++) {
    char ch=characters[i];
    if (afterNewLine && ch == comment) {
      while (++i < length) {
        ch=characters[i];
        if (ch == '\r' || ch == '\n' || ch == normalizedNewLine) {
          break;
        }
      }
      continue;
    }
    if (ch == '""' || ch == '\'') {
      if (inQuote == ch) {
        if (ch == '""') {
          doubleQuoteCount++;
        }
 else {
          singleQuoteCount++;
        }
        if (i + 1 < length) {
          char next=characters[i + 1];
          if (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\n' && next != '\r')) {
            char prev=characters[i - 1];
            if (!Character.isLetterOrDigit(prev)) {
              increment(escape,prev);
            }
          }
        }
        inQuote='\0';
      }
 else       if (inQuote == '\0') {
        char prev='\0';
        int j=i;
        while (prev <= ' ' && --j >= 0) {
          prev=characters[j];
        }
        if (j < 0 || !Character.isLetterOrDigit(prev)) {
          inQuote=ch;
        }
      }
      continue;
    }
    if (inQuote != '\0') {
      continue;
    }
    afterNewLine=false;
    if (isSymbol(ch)) {
      allSymbols.add(ch);
      increment(symbols,ch);
    }
 else     if ((ch == '\r' || ch == '\n' || ch == normalizedNewLine) && symbols.size() > 0) {
      afterNewLine=true;
      symbolsPerRow.add(symbols);
      if (symbolsPerRow.size() == MAX_ROW_SAMPLES) {
        break;
      }
      symbols=new HashMap<Character,Integer>();
    }
  }
  if (i >= length && symbolsPerRow.size() > 1) {
    symbolsPerRow.remove(symbolsPerRow.size() - 1);
  }
  Map<Character,Integer> totals=calculateTotals(symbolsPerRow);
  Map<Character,Integer> sums=new HashMap<Character,Integer>();
  Set<Character> toRemove=new HashSet<Character>();
  for (  Map<Character,Integer> previous : symbolsPerRow) {
    for (    Map<Character,Integer> current : symbolsPerRow) {
      for (      Character symbol : allSymbols) {
        Integer previousCount=previous.get(symbol);
        Integer currentCount=current.get(symbol);
        if (previousCount == null && currentCount == null) {
          toRemove.add(symbol);
        }
        if (previousCount == null || currentCount == null) {
          continue;
        }
        increment(sums,symbol,Math.abs(previousCount - currentCount));
      }
    }
  }
  sums.keySet().removeAll(toRemove);
  char delimiter=max(sums,totals,suggestedDelimiter);
  char quote=doubleQuoteCount >= singleQuoteCount ? '""' : '\'';
  escape.remove(delimiter);
  char quoteEscape=max(escape,totals,quote);
  apply(delimiter,quote,quoteEscape);
}","@Override public void execute(char[] characters,int length){
  Set<Character> allSymbols=new HashSet<Character>();
  Map<Character,Integer> symbols=new HashMap<Character,Integer>();
  Map<Character,Integer> escape=new HashMap<Character,Integer>();
  List<Map<Character,Integer>> symbolsPerRow=new ArrayList<Map<Character,Integer>>();
  int doubleQuoteCount=0;
  int singleQuoteCount=0;
  int i;
  char inQuote='\0';
  boolean afterNewLine=true;
  for (i=0; i < length; i++) {
    char ch=characters[i];
    if (afterNewLine && ch == comment) {
      while (++i < length) {
        ch=characters[i];
        if (ch == '\r' || ch == '\n' || ch == normalizedNewLine) {
          break;
        }
      }
      continue;
    }
    if (ch == '""' || ch == '\'') {
      if (inQuote == ch) {
        if (ch == '""') {
          doubleQuoteCount++;
        }
 else {
          singleQuoteCount++;
        }
        if (i + 1 < length) {
          char next=characters[i + 1];
          if (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\n' && next != '\r')) {
            char prev=characters[i - 1];
            if (!Character.isLetterOrDigit(prev)) {
              increment(escape,prev);
            }
          }
        }
        inQuote='\0';
      }
 else       if (inQuote == '\0') {
        char prev='\0';
        int j=i;
        while (prev <= ' ' && --j >= 0) {
          prev=characters[j];
        }
        if (j < 0 || !Character.isLetterOrDigit(prev)) {
          inQuote=ch;
        }
      }
      continue;
    }
    if (inQuote != '\0') {
      continue;
    }
    afterNewLine=false;
    if (isSymbol(ch)) {
      allSymbols.add(ch);
      increment(symbols,ch);
    }
 else     if ((ch == '\r' || ch == '\n' || ch == normalizedNewLine) && symbols.size() > 0) {
      afterNewLine=true;
      symbolsPerRow.add(symbols);
      if (symbolsPerRow.size() == MAX_ROW_SAMPLES) {
        break;
      }
      symbols=new HashMap<Character,Integer>();
    }
  }
  if (i >= length && symbolsPerRow.size() > 1) {
    symbolsPerRow.remove(symbolsPerRow.size() - 1);
  }
  Map<Character,Integer> totals=calculateTotals(symbolsPerRow);
  Map<Character,Integer> sums=new HashMap<Character,Integer>();
  Set<Character> toRemove=new HashSet<Character>();
  for (  Map<Character,Integer> previous : symbolsPerRow) {
    for (    Map<Character,Integer> current : symbolsPerRow) {
      for (      Character symbol : allSymbols) {
        Integer previousCount=previous.get(symbol);
        Integer currentCount=current.get(symbol);
        if (previousCount == null && currentCount == null) {
          toRemove.add(symbol);
        }
        if (previousCount == null || currentCount == null) {
          continue;
        }
        increment(sums,symbol,Math.abs(previousCount - currentCount));
      }
    }
  }
  sums.keySet().removeAll(toRemove);
  char delimiterMax=max(sums,totals,suggestedDelimiter);
  char delimiterMin=min(sums,totals,suggestedDelimiter);
  char delimiter;
  out:   if (delimiterMax != delimiterMin) {
    if (sums.get(delimiterMin) == 0 && sums.get(delimiterMax) != 0) {
      delimiter=delimiterMin;
      break out;
    }
    if (totals.get(delimiterMin) > totals.get(delimiterMax)) {
      delimiter=delimiterMin;
      break out;
    }
    delimiter=delimiterMax;
  }
 else {
    delimiter=delimiterMax;
  }
  char quote=doubleQuoteCount >= singleQuoteCount ? '""' : '\'';
  escape.remove(delimiter);
  char quoteEscape=max(escape,totals,quote);
  apply(delimiter,quote,quoteEscape);
}",0.935049386411254
163239,"/** 
 * Removes leading and trailing white spaces from the input and returns the result. Equivalent to   {@link TrimConversion#revert(String)}
 * @param input the String to be trimmed
 * @return the input String without leading and trailing white spaces, or null if the input is null.
 */
@Override public String execute(String input){
  if (input == null) {
    return null;
  }
  if (length != -1) {
    input=input.trim();
    if (input.length() > length) {
      return input.substring(0,length);
    }
  }
  return input.trim();
}","/** 
 * Removes leading and trailing white spaces from the input and returns the result. Equivalent to   {@link TrimConversion#revert(String)}
 * @param input the String to be trimmed
 * @return the input String without leading and trailing white spaces, or null if the input is null.
 */
@Override public String execute(String input){
  if (input == null) {
    return null;
  }
  if (length != -1) {
    int begin=0;
    while (input.charAt(begin) <= ' ') {
      begin++;
    }
    int end=begin + (length < input.length() ? length : input.length()) - 1;
    if (end >= input.length()) {
      end=input.length() - 1;
    }
    while (input.charAt(end) <= ' ') {
      end--;
    }
    return input.substring(begin,end + 1);
  }
  return input.trim();
}",0.6553059643687065
163240,"/** 
 * Dumps the content of a   {@link java.sql.ResultSet}.
 * @param rs     the {@link java.sql.ResultSet} whose contents should be read and written to a given output
 * @param output the output that will store the data in the given {@link java.sql.ResultSet}in the format specified by concrete implementations of this class.
 */
public final void write(ResultSet rs,Writer output){
  validateWriterSettings();
  boolean hasWriterProcessor=writerSettings.getRowWriterProcessor() != null;
  AbstractWriter<W> writer=null;
  long rowCount=0L;
  Object[] row=null;
  try {
    try {
      ResultSetMetaData md=rs.getMetaData();
      int columns=md.getColumnCount();
      String[] headers=new String[columns];
      int[] lengths=new int[columns];
      for (int i=1; i <= columns; i++) {
        headers[i - 1]=md.getColumnLabel(i);
        int precision=md.getPrecision(i);
        int scale=md.getScale(i);
        int length;
        if (precision != 0 && scale != 0) {
          length=precision + scale + 2;
        }
 else {
          length=precision + scale;
        }
        lengths[i - 1]=length;
      }
      String[] userProvidedHeaders=writerSettings.getHeaders();
      if (userProvidedHeaders == null) {
        writerSettings.setHeaders(headers);
      }
 else {
        headers=userProvidedHeaders;
      }
      adjustColumnLengths(headers,lengths);
      writer=createWriter(output,writerSettings);
      if (writerSettings.isHeaderWritingEnabled()) {
        writer.writeHeaders();
      }
      row=new Object[columns];
      while (rs.next()) {
        for (int i=1; i <= columns; i++) {
          row[i - 1]=rs.getObject(i);
        }
        if (hasWriterProcessor) {
          writer.processRecord(row);
        }
 else {
          writer.writeRow(row);
        }
        rowCount++;
      }
    }
  finally {
      if (!keepResourcesOpen) {
        rs.close();
      }
    }
  }
 catch (  Exception e) {
    throw new TextWritingException(""String_Node_Str"",rowCount,row,e);
  }
 finally {
    if (writer != null) {
      if (!keepResourcesOpen) {
        writer.close();
      }
    }
  }
}","/** 
 * Dumps the content of a   {@link java.sql.ResultSet}.
 * @param rs     the {@link java.sql.ResultSet} whose contents should be read and written to a given output
 * @param output the output that will store the data in the given {@link java.sql.ResultSet}in the format specified by concrete implementations of this class.
 */
public final void write(ResultSet rs,Writer output){
  validateWriterSettings();
  boolean hasWriterProcessor=writerSettings.getRowWriterProcessor() != null;
  AbstractWriter<W> writer=null;
  long rowCount=0L;
  Object[] row=null;
  try {
    try {
      ResultSetMetaData md=rs.getMetaData();
      int columns=md.getColumnCount();
      String[] headers=new String[columns];
      int[] lengths=new int[columns];
      for (int i=1; i <= columns; i++) {
        headers[i - 1]=md.getColumnLabel(i);
        int precision=md.getPrecision(i);
        int scale=md.getScale(i);
        int length;
        if (precision != 0 && scale != 0) {
          length=precision + scale + 2;
        }
 else {
          length=precision + scale;
        }
        lengths[i - 1]=length;
      }
      String[] userProvidedHeaders=writerSettings.getHeaders();
      if (userProvidedHeaders == null) {
        writerSettings.setHeaders(headers);
      }
 else {
        headers=userProvidedHeaders;
      }
      adjustColumnLengths(headers,lengths);
      writer=createWriter(output,writerSettings);
      if (writerSettings.isHeaderWritingEnabled()) {
        writer.writeHeaders();
      }
      row=new Object[columns];
      while (rs.next()) {
        for (int i=1; i <= columns; i++) {
          row[i - 1]=rs.getObject(i);
        }
        if (hasWriterProcessor) {
          writer.processRecord(row);
        }
 else {
          writer.writeRow(row);
        }
        rowCount++;
      }
    }
  finally {
      if (!keepResourcesOpen) {
        rs.close();
      }
    }
  }
 catch (  Exception e) {
    throw new TextWritingException(""String_Node_Str"",rowCount,row,e);
  }
 finally {
    close(writer);
  }
}",0.9742850276375872
163241,"private RowProcessor createWritingRowProcessor(final Writer output){
  return new RowProcessor(){
    private AbstractWriter<W> writer;
    @Override public void processStarted(    ParsingContext context){
      writer=createWriter(output,writerSettings);
    }
    @Override public void rowProcessed(    String[] row,    ParsingContext context){
      writer.writeRow(row);
    }
    @Override public void processEnded(    ParsingContext context){
      if (!keepResourcesOpen) {
        writer.close();
      }
    }
  }
;
}","private RowProcessor createWritingRowProcessor(final Writer output){
  return new RowProcessor(){
    private AbstractWriter<W> writer;
    @Override public void processStarted(    ParsingContext context){
      writer=createWriter(output,writerSettings);
    }
    @Override public void rowProcessed(    String[] row,    ParsingContext context){
      writer.writeRow(row);
    }
    @Override public void processEnded(    ParsingContext context){
      close(writer);
    }
  }
;
}",0.9415262636273538
163242,"void run(ResultSet rs) throws Exception {
  StringWriter output=new StringWriter();
  routineImpl.setKeepResourcesOpen(true);
  routineImpl.write(rs,output);
  output.write(""String_Node_Str"");
  assertFalse(rs.isClosed());
  output.close();
  result=output.toString();
  rs.close();
}","public void run(ResultSet rs){
  CsvWriterSettings settings=new CsvWriterSettings();
  CsvRoutines csvRoutines=new CsvRoutines(settings);
  csvRoutines.setKeepResourcesOpen(true);
  FileOutputStream fout=null;
  try {
    try {
      fout=new FileOutputStream(tmp);
      csvRoutines.write(rs,fout);
    }
  finally {
      fout.close();
    }
  }
 catch (  Exception e) {
    throw new IllegalStateException(e);
  }
}",0.1139601139601139
163243,"/** 
 * Stops parsing and closes all open resources.
 */
public final void stopParsing(){
  try {
    try {
      context.stop();
    }
  finally {
      try {
        processor.processEnded(context);
      }
  finally {
        output.appender.reset();
        input.stop();
      }
    }
  }
 catch (  Throwable error) {
    throw handleException(error);
  }
}","/** 
 * Stops parsing and closes all open resources.
 */
public final void stopParsing(){
  try {
    try {
      if (context != null) {
        context.stop();
      }
    }
  finally {
      try {
        if (processor != null) {
          processor.processEnded(context);
        }
      }
  finally {
        if (output != null) {
          output.appender.reset();
        }
        if (input != null) {
          input.stop();
        }
      }
    }
  }
 catch (  Throwable error) {
    throw handleException(error);
  }
}",0.8125701459034792
163244,"protected void setContext(Context context){
  if (context instanceof ParsingContext) {
    setParsingContext((ParsingContext)context);
  }
 else {
    setParsingContext(null);
  }
  this.columnIndex=context == null ? -1 : context.currentColumn();
  this.recordNumber=context == null ? -1L : context.currentRecord();
  if (this.headers == null) {
    this.headers=context == null ? null : context.headers();
  }
  this.extractedIndexes=context == null ? null : context.extractedFieldIndexes();
}","protected void setContext(Context context){
  if (context != null) {
    if (context instanceof ParsingContext) {
      setParsingContext((ParsingContext)context);
    }
 else {
      setParsingContext(null);
    }
    this.columnIndex=context == null ? -1 : context.currentColumn();
    this.recordNumber=context == null ? -1L : context.currentRecord();
    if (this.headers == null) {
      this.headers=context == null ? null : context.headers();
    }
    this.extractedIndexes=context == null ? null : context.extractedFieldIndexes();
  }
}",0.933589990375361
163245,"private void parseQuotedValue(){
  if (prev != '\0' && parseUnescapedQuotesUntilDelimiter) {
    if (quoteHandling == SKIP_VALUE) {
      skipValue();
      return;
    }
    if (!keepQuotes) {
      output.appender.prepend(quote);
    }
    ch=input.nextChar();
    output.trim=ignoreTrailingWhitespace;
    ch=output.appender.appendUntil(ch,input,delimiter,newLine);
  }
 else {
    if (keepQuotes && prev == '\0') {
      output.appender.append(quote);
    }
    ch=input.nextChar();
    while (true) {
      if (prev == quote && (ch <= ' ' && whitespaceRangeStart < ch || ch == delimiter || ch == newLine)) {
        break;
      }
      if (ch != quote && ch != quoteEscape) {
        if (prev == quote) {
          if (handleUnescapedQuote()) {
            if (quoteHandling == SKIP_VALUE) {
              break;
            }
 else {
              return;
            }
          }
 else {
            return;
          }
        }
        if (prev == quoteEscape && quoteEscape != '\0') {
          output.appender.append(quoteEscape);
        }
        ch=output.appender.appendUntil(ch,input,quote,quoteEscape,escapeEscape);
        prev=ch;
        ch=input.nextChar();
      }
 else {
        processQuoteEscape();
        prev=ch;
        ch=input.nextChar();
        if (unescaped && (ch == delimiter || ch == newLine)) {
          return;
        }
      }
    }
    if (ch != delimiter && ch != newLine && ch <= ' ' && whitespaceRangeStart < ch) {
      whitespaceAppender.reset();
      do {
        whitespaceAppender.append(ch);
        ch=input.nextChar();
        if (ch == newLine) {
          return;
        }
      }
 while (ch <= ' ' && whitespaceRangeStart < ch);
      if (ch != delimiter && parseUnescapedQuotes) {
        if (output.appender instanceof DefaultCharAppender) {
          output.appender.append(quote);
          ((DefaultCharAppender)output.appender).append(whitespaceAppender);
        }
        if (parseUnescapedQuotesUntilDelimiter || ch != quote && ch != quoteEscape) {
          output.appender.append(ch);
        }
        prev=ch;
        parseQuotedValue();
      }
 else       if (keepQuotes) {
        output.appender.append(quote);
      }
    }
 else     if (keepQuotes) {
      output.appender.append(quote);
    }
    if (ch != delimiter && ch != newLine) {
      throw new TextParsingException(context,""String_Node_Str"" + ch + ""String_Node_Str""+ delimiter+ ""String_Node_Str"");
    }
  }
}","private void parseQuotedValue(){
  if (prev != '\0' && parseUnescapedQuotesUntilDelimiter) {
    if (quoteHandling == SKIP_VALUE) {
      skipValue();
      return;
    }
    if (!keepQuotes) {
      output.appender.prepend(quote);
    }
    ch=input.nextChar();
    output.trim=ignoreTrailingWhitespace;
    ch=output.appender.appendUntil(ch,input,delimiter,newLine);
  }
 else {
    if (keepQuotes && prev == '\0') {
      output.appender.append(quote);
    }
    ch=input.nextChar();
    while (true) {
      if (prev == quote && (ch <= ' ' && whitespaceRangeStart < ch || ch == delimiter || ch == newLine)) {
        break;
      }
      if (ch != quote && ch != quoteEscape) {
        if (prev == quote) {
          if (handleUnescapedQuote()) {
            if (quoteHandling == SKIP_VALUE) {
              break;
            }
 else {
              return;
            }
          }
 else {
            return;
          }
        }
        if (prev == quoteEscape && quoteEscape != '\0') {
          output.appender.append(quoteEscape);
        }
        ch=output.appender.appendUntil(ch,input,quote,quoteEscape,escapeEscape);
        prev=ch;
        ch=input.nextChar();
      }
 else {
        processQuoteEscape();
        prev=ch;
        ch=input.nextChar();
        if (unescaped && (ch == delimiter || ch == newLine)) {
          return;
        }
      }
    }
    if (ch != delimiter && ch != newLine && ch <= ' ' && whitespaceRangeStart < ch) {
      whitespaceAppender.reset();
      do {
        whitespaceAppender.append(ch);
        ch=input.nextChar();
        if (ch == newLine) {
          if (keepQuotes) {
            output.appender.append(quote);
          }
          return;
        }
      }
 while (ch <= ' ' && whitespaceRangeStart < ch);
      if (ch != delimiter && parseUnescapedQuotes) {
        if (output.appender instanceof DefaultCharAppender) {
          output.appender.append(quote);
          ((DefaultCharAppender)output.appender).append(whitespaceAppender);
        }
        if (parseUnescapedQuotesUntilDelimiter || ch != quote && ch != quoteEscape) {
          output.appender.append(ch);
        }
        prev=ch;
        parseQuotedValue();
      }
 else       if (keepQuotes) {
        output.appender.append(quote);
      }
    }
 else     if (keepQuotes) {
      output.appender.append(quote);
    }
    if (ch != delimiter && ch != newLine) {
      throw new TextParsingException(context,""String_Node_Str"" + ch + ""String_Node_Str""+ delimiter+ ""String_Node_Str"");
    }
  }
}",0.9833433674493276
163246,"/** 
 * An implementation of   {@link CharInputReader} which loads the parser buffer in parallel or sequentially, as defined by the readInputOnSeparateThread property
 * @param whitespaceRangeStart starting range of characters considered to be whitespace.
 * @return The input reader as chosen with the readInputOnSeparateThread property.
 */
CharInputReader newCharInputReader(int whitespaceRangeStart){
  if (readInputOnSeparateThread) {
    if (lineSeparatorDetectionEnabled) {
      return new ConcurrentCharInputReader(getFormat().getNormalizedNewline(),this.getInputBufferSize(),10,whitespaceRangeStart);
    }
 else {
      return new ConcurrentCharInputReader(getFormat().getLineSeparator(),getFormat().getNormalizedNewline(),this.getInputBufferSize(),10,whitespaceRangeStart);
    }
  }
 else {
    if (lineSeparatorDetectionEnabled) {
      return new DefaultCharInputReader(getFormat().getNormalizedNewline(),this.getInputBufferSize(),whitespaceRangeStart);
    }
 else {
      return new DefaultCharInputReader(getFormat().getLineSeparator(),getFormat().getNormalizedNewline(),this.getInputBufferSize(),whitespaceRangeStart);
    }
  }
}","/** 
 * An implementation of   {@link CharInputReader} which loads the parser buffer in parallel or sequentially, as defined by the readInputOnSeparateThread property
 * @param whitespaceRangeStart starting range of characters considered to be whitespace.
 * @return The input reader as chosen with the readInputOnSeparateThread property.
 */
protected CharInputReader newCharInputReader(int whitespaceRangeStart){
  if (readInputOnSeparateThread) {
    if (lineSeparatorDetectionEnabled) {
      return new ConcurrentCharInputReader(getFormat().getNormalizedNewline(),this.getInputBufferSize(),10,whitespaceRangeStart);
    }
 else {
      return new ConcurrentCharInputReader(getFormat().getLineSeparator(),getFormat().getNormalizedNewline(),this.getInputBufferSize(),10,whitespaceRangeStart);
    }
  }
 else {
    if (lineSeparatorDetectionEnabled) {
      return new DefaultCharInputReader(getFormat().getNormalizedNewline(),this.getInputBufferSize(),whitespaceRangeStart);
    }
 else {
      return new DefaultCharInputReader(getFormat().getLineSeparator(),getFormat().getNormalizedNewline(),this.getInputBufferSize(),whitespaceRangeStart);
    }
  }
}",0.9956672443674176
163247,"/** 
 * Returns the next available bucket. Blocks until a bucket is made available or the reading process stops.
 * @return the next available bucket.
 */
@SuppressWarnings(""String_Node_Str"") public synchronized CharBucket nextBucket(){
  try {
    if (finished) {
      return end;
    }
    if (currentBucket != null) {
      instances.release(currentBucket);
    }
    Object element=buckets.take();
    if (element == end) {
      finished=true;
      return end;
    }
 else {
      currentBucket=(Entry<CharBucket>)element;
    }
    return currentBucket.get();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    finished=true;
    return end;
  }
}","/** 
 * Returns the next available bucket. Blocks until a bucket is made available or the reading process stops.
 * @return the next available bucket.
 */
@SuppressWarnings(""String_Node_Str"") public synchronized CharBucket nextBucket(){
  try {
    if (finished) {
      if (buckets.size() <= 1) {
        return end;
      }
    }
    if (currentBucket != null) {
      instances.release(currentBucket);
    }
    Object element=buckets.take();
    if (element == end) {
      finished=true;
      return end;
    }
 else {
      currentBucket=(Entry<CharBucket>)element;
    }
    return currentBucket.get();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    finished=true;
    return end;
  }
}",0.9541930937279774
163248,"/** 
 * Stops the CharInputReader from reading characters from the   {@link java.io.Reader} provided in {@link ConcurrentCharInputReader#start(Reader)} and closes it.Also stops the input reading thread.
 */
@Override public void stop(){
  if (bucketLoader != null) {
    bucketLoader.stopReading();
    bucketLoader.reportError();
    if (bucketLoader.notification != null) {
      BomInput.BytesProcessedNotification notification=bucketLoader.notification;
      bucketLoader=null;
      unwrapInputStream(notification);
    }
  }
}","/** 
 * Stops the CharInputReader from reading characters from the   {@link java.io.Reader} provided in {@link ConcurrentCharInputReader#start(Reader)} and closes it.Also stops the input reading thread.
 */
@Override public void stop(){
  if (!unwrapping && bucketLoader != null) {
    bucketLoader.stopReading();
    bucketLoader.reportError();
  }
}",0.7601809954751131
163249,"/** 
 * Starts an input reading thread to load characters from the given reader into ""buckets"" of characters
 */
@Override protected void setReader(Reader reader){
  stop();
  bucketLoader=new ConcurrentCharLoader(reader,bucketSize,bucketQuantity);
  bucketLoader.reportError();
}","/** 
 * Starts an input reading thread to load characters from the given reader into ""buckets"" of characters
 */
@Override protected void setReader(Reader reader){
  if (!unwrapping) {
    stop();
    bucketLoader=new ConcurrentCharLoader(reader,bucketSize,bucketQuantity);
    bucketLoader.reportError();
  }
 else {
    bucketLoader.reader=reader;
  }
  unwrapping=false;
}",0.8305343511450382
163250,"/** 
 * Assigns the next ""bucket"" of characters to the   {@link ConcurrentCharInputReader#buffer} attribute, and updates the {@link ConcurrentCharInputReader#length} to the number of characters read.
 */
@Override protected void reloadBuffer(){
  CharBucket currentBucket=bucketLoader.nextBucket();
  bucketLoader.reportError();
  super.buffer=currentBucket.data;
  super.length=currentBucket.length;
}","/** 
 * Assigns the next ""bucket"" of characters to the   {@link ConcurrentCharInputReader#buffer} attribute, and updates the {@link ConcurrentCharInputReader#length} to the number of characters read.
 */
@Override protected void reloadBuffer(){
  try {
    CharBucket currentBucket=bucketLoader.nextBucket();
    bucketLoader.reportError();
    super.buffer=currentBucket.data;
    super.length=currentBucket.length;
  }
 catch (  BomInput.BytesProcessedNotification e) {
    unwrapping=true;
    unwrapInputStream(e);
  }
}",0.8682505399568035
163251,"/** 
 * Returns the next available bucket. Blocks until a bucket is made available or the reading process stops.
 * @return the next available bucket.
 */
@SuppressWarnings(""String_Node_Str"") public synchronized CharBucket nextBucket(){
  try {
    if (finished) {
      if (buckets.size() <= 1) {
        return end;
      }
    }
    if (currentBucket != null) {
      instances.release(currentBucket);
    }
    Object element=buckets.take();
    if (element == end) {
      finished=true;
      return end;
    }
 else {
      currentBucket=(Entry<CharBucket>)element;
    }
    return currentBucket.get();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    finished=true;
    return end;
  }
}","/** 
 * Returns the next available bucket. Blocks until a bucket is made available or the reading process stops.
 * @return the next available bucket.
 */
@SuppressWarnings(""String_Node_Str"") public synchronized CharBucket nextBucket(){
  if (activeExecution == null && !finished) {
    int length=-1;
    try {
      length=readBucket();
      if (length >= 0 && length <= 4) {
        length=readBucket();
      }
    }
 catch (    BomInput.BytesProcessedNotification e) {
      throw e;
    }
catch (    Exception e) {
      error=e;
    }
    if (length != -1) {
      activeExecution=new Thread(this,""String_Node_Str"");
      activeExecution.start();
    }
 else {
      finished=true;
      try {
        buckets.put(end);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
 finally {
        stopReading();
      }
    }
  }
  try {
    if (finished) {
      if (buckets.size() <= 1) {
        return end;
      }
    }
    if (currentBucket != null) {
      instances.release(currentBucket);
    }
    Object element=buckets.take();
    if (element == end) {
      finished=true;
      return end;
    }
 else {
      currentBucket=(Entry<CharBucket>)element;
    }
    return currentBucket.get();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    finished=true;
    return end;
  }
}",0.6942070275403609
163252,"/** 
 * The   {@link CharBucket} loading process that executes in parallel until the input is completely read.Once the end of the input is reached, the  {@link java.io.Reader} instance provided in the constructor is closed.
 */
@Override public void run(){
  Thread.currentThread().setName(""String_Node_Str"");
  try {
    try {
      int length;
      do {
        Entry<CharBucket> bucket=instances.allocate();
        length=bucket.get().fill(reader);
        if (length != -1) {
          buckets.put(bucket);
        }
 else {
          instances.release(bucket);
        }
      }
 while (active && length != -1);
    }
  finally {
      buckets.put(end);
    }
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
catch (  BomInput.BytesProcessedNotification e) {
    finished=true;
    notification=e;
  }
catch (  Exception e) {
    finished=true;
    error=e;
  }
 finally {
    stopReading();
  }
}","/** 
 * The   {@link CharBucket} loading process that executes in parallel until the input is completely read.Once the end of the input is reached, the  {@link java.io.Reader} instance provided in the constructor is closed.
 */
@Override public void run(){
  try {
    try {
      while (readBucket() != -1 && active)       ;
    }
  finally {
      buckets.put(end);
    }
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
catch (  Exception e) {
    finished=true;
    error=e;
  }
 finally {
    stopReading();
  }
}",0.7050938337801609
163253,"/** 
 * Stops the   {@link CharBucket} loading process and closes the reader provided in the constructor of this class
 */
public void stopReading(){
  active=false;
  try {
    reader.close();
  }
 catch (  IOException e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
 finally {
    try {
      activeExecution.interrupt();
    }
 catch (    Throwable ex) {
      throw new IllegalStateException(""String_Node_Str"",ex);
    }
  }
}","/** 
 * Stops the   {@link CharBucket} loading process and closes the reader provided in the constructor of this class
 */
public void stopReading(){
  active=false;
  try {
    reader.close();
  }
 catch (  IOException e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
 finally {
    try {
      if (activeExecution != null) {
        activeExecution.interrupt();
      }
    }
 catch (    Throwable ex) {
      throw new IllegalStateException(""String_Node_Str"",ex);
    }
  }
}",0.9502645502645504
163254,"/** 
 * Creates a   {@link FixedInstancePool} with a given amount of {@link CharBucket} instances and starts a thread to fill each one.
 * @param reader         The source of characters to extract and fill {@link CharBucket} instances
 * @param bucketSize     The size of each individual {@link CharBucket}
 * @param bucketQuantity The number of {@link CharBucket} instances used to extract characters from the given reader.
 */
public ConcurrentCharLoader(Reader reader,final int bucketSize,int bucketQuantity){
  this.end=new CharBucket(-1);
  this.buckets=new ArrayBlockingQueue<Object>(bucketQuantity);
  this.reader=reader;
  this.instances=new FixedInstancePool<CharBucket>(bucketQuantity){
    @Override protected CharBucket newInstance(){
      return new CharBucket(bucketSize);
    }
  }
;
  finished=false;
  active=true;
  activeExecution=new Thread(this,""String_Node_Str"");
  activeExecution.start();
}","/** 
 * Creates a   {@link FixedInstancePool} with a given amount of {@link CharBucket} instances and starts a thread to fill each one.
 * @param reader         The source of characters to extract and fill {@link CharBucket} instances
 * @param bucketSize     The size of each individual {@link CharBucket}
 * @param bucketQuantity The number of {@link CharBucket} instances used to extract characters from the given reader.
 */
public ConcurrentCharLoader(Reader reader,final int bucketSize,int bucketQuantity){
  this.end=new CharBucket(-1);
  this.buckets=new ArrayBlockingQueue<Object>(bucketQuantity);
  this.reader=reader;
  this.instances=new FixedInstancePool<CharBucket>(bucketQuantity){
    @Override protected CharBucket newInstance(){
      return new CharBucket(bucketSize);
    }
  }
;
  finished=false;
  active=true;
}",0.95368782161235
163255,"@Override public final void skipLines(long lines){
  if (lines < 1) {
    return;
  }
  long expectedLineCount=this.lineCount + lines;
  try {
    do {
      nextChar();
    }
 while (lineCount < expectedLineCount);
    if (lineCount < lines) {
      throw new IllegalArgumentException(""String_Node_Str"" + lines + ""String_Node_Str""+ (expectedLineCount - lines)+ ""String_Node_Str"");
    }
  }
 catch (  EOFException ex) {
    throw new IllegalArgumentException(""String_Node_Str"" + lines + ""String_Node_Str""+ (expectedLineCount - lines)+ ""String_Node_Str"");
  }
}","@Override public final void skipLines(long lines){
  if (lines < 1) {
    skipping=false;
    return;
  }
  skipping=true;
  long expectedLineCount=this.lineCount + lines;
  try {
    do {
      nextChar();
    }
 while (lineCount < expectedLineCount);
    skipping=false;
    if (lineCount < lines) {
      throw new IllegalArgumentException(""String_Node_Str"" + lines + ""String_Node_Str""+ (expectedLineCount - lines)+ ""String_Node_Str"");
    }
  }
 catch (  EOFException ex) {
    skipping=false;
    throw new IllegalArgumentException(""String_Node_Str"" + lines + ""String_Node_Str""+ (expectedLineCount - lines)+ ""String_Node_Str"");
  }
}",0.9357798165137616
163256,"/** 
 * Requests the next batch of characters from the implementing class and updates the character count. <p> If there are no more characters in the input, the reading will stop by invoking the   {@link AbstractCharInputReader#stop()} method.
 */
private void updateBuffer(){
  if (length - recordStart > 0 && buffer != null) {
    tmp.append(buffer,recordStart,length - recordStart);
  }
  recordStart=0;
  reloadBuffer();
  charCount+=i;
  i=0;
  if (length == -1) {
    stop();
    incrementLineCount=true;
  }
  if (inputAnalysisProcesses != null) {
    try {
      for (      InputAnalysisProcess process : inputAnalysisProcesses) {
        process.execute(buffer,length);
      }
    }
  finally {
      if (length > 4) {
        inputAnalysisProcesses=null;
      }
    }
  }
}","/** 
 * Requests the next batch of characters from the implementing class and updates the character count. <p> If there are no more characters in the input, the reading will stop by invoking the   {@link AbstractCharInputReader#stop()} method.
 */
private void updateBuffer(){
  if (length - recordStart > 0 && buffer != null && !skipping) {
    tmp.append(buffer,recordStart,length - recordStart);
  }
  recordStart=0;
  reloadBuffer();
  charCount+=i;
  i=0;
  if (length == -1) {
    stop();
    incrementLineCount=true;
  }
  if (inputAnalysisProcesses != null) {
    try {
      for (      InputAnalysisProcess process : inputAnalysisProcesses) {
        process.execute(buffer,length);
      }
    }
  finally {
      if (length > 4) {
        inputAnalysisProcesses=null;
      }
    }
  }
}",0.9917877447883764
163257,"/** 
 * Writes a collection of annotated java beans to a given output.
 * @param elements the elements to write to the output
 * @param beanType the type of element in the given collection
 * @param output   the output into which the given elements will be written
 * @param headers  headers to use in the first row of the written result.
 * @param < T >      the type of element in the given collection
 */
public <T>void writeAll(Iterable<T> elements,Class<T> beanType,Writer output,String... headers){
  setRowWriterProcessor(new BeanWriterProcessor<T>(beanType));
  try {
    if (headers.length > 0) {
      writerSettings.setHeaders(headers);
      writerSettings.setHeaderWritingEnabled(true);
    }
    createWriter(output,writerSettings).processRecordsAndClose(elements);
  }
  finally {
    writerSettings.setRowWriterProcessor(null);
  }
}","/** 
 * Writes a collection of annotated java beans to a given output.
 * @param elements the elements to write to the output
 * @param beanType the type of element in the given collection
 * @param output   the output into which the given elements will be written
 * @param headers  headers to use in the first row of the written result.
 * @param < T >      the type of element in the given collection
 */
public <T>void writeAll(Iterable<T> elements,Class<T> beanType,Writer output,String... headers){
  setRowWriterProcessor(new BeanWriterProcessor<T>(beanType));
  try {
    if (headers.length > 0) {
      writerSettings.setHeaders(headers);
      writerSettings.setHeaderWritingEnabled(true);
    }
    if (keepResourcesOpen && previousOutput == output) {
      writerSettings.setHeaderWritingEnabled(false);
    }
    AbstractWriter<W> writer=createWriter(output,writerSettings);
    if (keepResourcesOpen) {
      writer.processRecords(elements);
      previousOutput=output;
    }
 else {
      writer.processRecordsAndClose(elements);
    }
  }
  finally {
    writerSettings.setRowWriterProcessor(null);
  }
}",0.8558375634517766
163258,"/** 
 * Returns the parser configuration (if any) used by the routines of this utility class.
 * @return the parser configuration.
 */
public final P getParserSettings(){
  return parserSettings;
}","/** 
 * Returns the parser configuration (if any) used by the routines of this utility class.
 * @return the parser configuration.
 */
public final P getParserSettings(){
  validateParserSettings();
  return parserSettings;
}",0.8957345971563981
163259,"/** 
 * Returns the writer configuration (if any) used by the routines of this utility class.
 * @return the writer configuration.
 */
public final W getWriterSettings(){
  return writerSettings;
}","/** 
 * Returns the writer configuration (if any) used by the routines of this utility class.
 * @return the writer configuration.
 */
public final W getWriterSettings(){
  validateWriterSettings();
  return writerSettings;
}",0.933649289099526
163260,"@Override public void execute(char[] characters,int length){
  Set<Character> allSymbols=new HashSet<Character>();
  Map<Character,Integer> symbols=new HashMap<Character,Integer>();
  Map<Character,Integer> escape=new HashMap<Character,Integer>();
  List<Map<Character,Integer>> symbolsPerRow=new ArrayList<Map<Character,Integer>>();
  int doubleQuoteCount=0;
  int singleQuoteCount=0;
  int i;
  char inQuote='\0';
  boolean afterNewLine=true;
  for (i=0; i < length; i++) {
    char ch=characters[i];
    if (afterNewLine && ch == comment) {
      while (++i < length) {
        ch=characters[i];
        if (ch == '\r' || ch == '\n' || ch == normalizedNewLine) {
          break;
        }
      }
      continue;
    }
    if (ch == '""' || ch == '\'') {
      if (inQuote == ch) {
        if (ch == '""') {
          doubleQuoteCount++;
        }
 else {
          singleQuoteCount++;
        }
        if (i + 1 < length) {
          char next=characters[i + 1];
          if (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\n' && next != '\r')) {
            char prev=characters[i - 1];
            if (!Character.isLetterOrDigit(prev)) {
              increment(escape,prev);
            }
          }
        }
        inQuote='\0';
      }
 else       if (inQuote == '\0') {
        inQuote=ch;
      }
      continue;
    }
    if (inQuote != '\0') {
      continue;
    }
    afterNewLine=false;
    if (isSymbol(ch)) {
      allSymbols.add(ch);
      increment(symbols,ch);
    }
 else     if ((ch == '\r' || ch == '\n' || ch == normalizedNewLine) && symbols.size() > 0) {
      afterNewLine=true;
      symbolsPerRow.add(symbols);
      if (symbolsPerRow.size() == MAX_ROW_SAMPLES) {
        break;
      }
      symbols=new HashMap<Character,Integer>();
    }
  }
  if (i >= length && symbolsPerRow.size() > 1) {
    symbolsPerRow.remove(symbolsPerRow.size() - 1);
  }
  Map<Character,Integer> totals=calculateTotals(symbolsPerRow);
  Map<Character,Integer> sums=new HashMap<Character,Integer>();
  Set<Character> toRemove=new HashSet<Character>();
  for (  Map<Character,Integer> previous : symbolsPerRow) {
    for (    Map<Character,Integer> current : symbolsPerRow) {
      for (      Character symbol : allSymbols) {
        Integer previousCount=previous.get(symbol);
        Integer currentCount=current.get(symbol);
        if (previousCount == null && currentCount == null) {
          toRemove.add(symbol);
        }
        if (previousCount == null || currentCount == null) {
          continue;
        }
        increment(sums,symbol,Math.abs(previousCount - currentCount));
      }
    }
  }
  sums.keySet().removeAll(toRemove);
  char delimiter=min(sums,totals,suggestedDelimiter);
  char quote=doubleQuoteCount >= singleQuoteCount ? '""' : '\'';
  escape.remove(delimiter);
  char quoteEscape=max(escape,totals,quote);
  apply(delimiter,quote,quoteEscape);
}","@Override public void execute(char[] characters,int length){
  Set<Character> allSymbols=new HashSet<Character>();
  Map<Character,Integer> symbols=new HashMap<Character,Integer>();
  Map<Character,Integer> escape=new HashMap<Character,Integer>();
  List<Map<Character,Integer>> symbolsPerRow=new ArrayList<Map<Character,Integer>>();
  int doubleQuoteCount=0;
  int singleQuoteCount=0;
  int i;
  char inQuote='\0';
  boolean afterNewLine=true;
  for (i=0; i < length; i++) {
    char ch=characters[i];
    if (afterNewLine && ch == comment) {
      while (++i < length) {
        ch=characters[i];
        if (ch == '\r' || ch == '\n' || ch == normalizedNewLine) {
          break;
        }
      }
      continue;
    }
    if (ch == '""' || ch == '\'') {
      if (inQuote == ch) {
        if (ch == '""') {
          doubleQuoteCount++;
        }
 else {
          singleQuoteCount++;
        }
        if (i + 1 < length) {
          char next=characters[i + 1];
          if (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\n' && next != '\r')) {
            char prev=characters[i - 1];
            if (!Character.isLetterOrDigit(prev)) {
              increment(escape,prev);
            }
          }
        }
        inQuote='\0';
      }
 else       if (inQuote == '\0') {
        char prev='\0';
        int j=i;
        while (prev <= ' ' && --j >= 0) {
          prev=characters[j];
        }
        if (j < 0 || !Character.isLetterOrDigit(prev)) {
          inQuote=ch;
        }
      }
      continue;
    }
    if (inQuote != '\0') {
      continue;
    }
    afterNewLine=false;
    if (isSymbol(ch)) {
      allSymbols.add(ch);
      increment(symbols,ch);
    }
 else     if ((ch == '\r' || ch == '\n' || ch == normalizedNewLine) && symbols.size() > 0) {
      afterNewLine=true;
      symbolsPerRow.add(symbols);
      if (symbolsPerRow.size() == MAX_ROW_SAMPLES) {
        break;
      }
      symbols=new HashMap<Character,Integer>();
    }
  }
  if (i >= length && symbolsPerRow.size() > 1) {
    symbolsPerRow.remove(symbolsPerRow.size() - 1);
  }
  Map<Character,Integer> totals=calculateTotals(symbolsPerRow);
  Map<Character,Integer> sums=new HashMap<Character,Integer>();
  Set<Character> toRemove=new HashSet<Character>();
  for (  Map<Character,Integer> previous : symbolsPerRow) {
    for (    Map<Character,Integer> current : symbolsPerRow) {
      for (      Character symbol : allSymbols) {
        Integer previousCount=previous.get(symbol);
        Integer currentCount=current.get(symbol);
        if (previousCount == null && currentCount == null) {
          toRemove.add(symbol);
        }
        if (previousCount == null || currentCount == null) {
          continue;
        }
        increment(sums,symbol,Math.abs(previousCount - currentCount));
      }
    }
  }
  sums.keySet().removeAll(toRemove);
  char delimiter=min(sums,totals,suggestedDelimiter);
  char quote=doubleQuoteCount >= singleQuoteCount ? '""' : '\'';
  escape.remove(delimiter);
  char quoteEscape=max(escape,totals,quote);
  apply(delimiter,quote,quoteEscape);
}",0.9682959048877148
163261,"private void parseQuotedValue(){
  if (prev != '\0' && parseUnescapedQuotesUntilDelimiter) {
    if (quoteHandling == SKIP_VALUE) {
      skipValue();
      return;
    }
    if (!keepQuotes) {
      output.appender.prepend(quote);
    }
    ch=input.nextChar();
    output.trim=ignoreTrailingWhitespace;
    ch=output.appender.appendUntil(ch,input,delimiter,newLine);
  }
 else {
    if (keepQuotes && prev == '\0') {
      output.appender.append(quote);
    }
    ch=input.nextChar();
    while (true) {
      if (prev == quote && (ch <= ' ' && whitespaceRangeStart < ch || ch == delimiter || ch == newLine)) {
        break;
      }
      if (ch != quote && ch != quoteEscape) {
        if (prev == quote) {
          if (handleUnescapedQuote()) {
            break;
          }
 else {
            return;
          }
        }
        if (prev == quoteEscape && quoteEscape != '\0') {
          output.appender.append(quoteEscape);
        }
        ch=output.appender.appendUntil(ch,input,quote,quoteEscape,escapeEscape);
        prev=ch;
        ch=input.nextChar();
      }
 else {
        processQuoteEscape();
        prev=ch;
        ch=input.nextChar();
        if (unescaped && (ch == delimiter || ch == newLine)) {
          return;
        }
      }
    }
    if (ch != delimiter && ch != newLine && ch <= ' ' && whitespaceRangeStart < ch) {
      whitespaceAppender.reset();
      do {
        whitespaceAppender.append(ch);
        ch=input.nextChar();
        if (ch == newLine) {
          return;
        }
      }
 while (ch <= ' ' && whitespaceRangeStart < ch);
      if (ch != delimiter && parseUnescapedQuotes) {
        if (output.appender instanceof DefaultCharAppender) {
          output.appender.append(quote);
          ((DefaultCharAppender)output.appender).append(whitespaceAppender);
        }
        if (parseUnescapedQuotesUntilDelimiter || ch != quote && ch != quoteEscape) {
          output.appender.append(ch);
        }
        prev=ch;
        parseQuotedValue();
      }
 else       if (keepQuotes) {
        output.appender.append(quote);
      }
    }
 else     if (keepQuotes) {
      output.appender.append(quote);
    }
    if (ch != delimiter && ch != newLine) {
      throw new TextParsingException(context,""String_Node_Str"" + ch + ""String_Node_Str""+ delimiter+ ""String_Node_Str"");
    }
  }
}","private void parseQuotedValue(){
  if (prev != '\0' && parseUnescapedQuotesUntilDelimiter) {
    if (quoteHandling == SKIP_VALUE) {
      skipValue();
      return;
    }
    if (!keepQuotes) {
      output.appender.prepend(quote);
    }
    ch=input.nextChar();
    output.trim=ignoreTrailingWhitespace;
    ch=output.appender.appendUntil(ch,input,delimiter,newLine);
  }
 else {
    if (keepQuotes && prev == '\0') {
      output.appender.append(quote);
    }
    ch=input.nextChar();
    while (true) {
      if (prev == quote && (ch <= ' ' && whitespaceRangeStart < ch || ch == delimiter || ch == newLine)) {
        break;
      }
      if (ch != quote && ch != quoteEscape) {
        if (prev == quote) {
          if (handleUnescapedQuote()) {
            if (quoteHandling == SKIP_VALUE) {
              break;
            }
 else {
              return;
            }
          }
 else {
            return;
          }
        }
        if (prev == quoteEscape && quoteEscape != '\0') {
          output.appender.append(quoteEscape);
        }
        ch=output.appender.appendUntil(ch,input,quote,quoteEscape,escapeEscape);
        prev=ch;
        ch=input.nextChar();
      }
 else {
        processQuoteEscape();
        prev=ch;
        ch=input.nextChar();
        if (unescaped && (ch == delimiter || ch == newLine)) {
          return;
        }
      }
    }
    if (ch != delimiter && ch != newLine && ch <= ' ' && whitespaceRangeStart < ch) {
      whitespaceAppender.reset();
      do {
        whitespaceAppender.append(ch);
        ch=input.nextChar();
        if (ch == newLine) {
          return;
        }
      }
 while (ch <= ' ' && whitespaceRangeStart < ch);
      if (ch != delimiter && parseUnescapedQuotes) {
        if (output.appender instanceof DefaultCharAppender) {
          output.appender.append(quote);
          ((DefaultCharAppender)output.appender).append(whitespaceAppender);
        }
        if (parseUnescapedQuotesUntilDelimiter || ch != quote && ch != quoteEscape) {
          output.appender.append(ch);
        }
        prev=ch;
        parseQuotedValue();
      }
 else       if (keepQuotes) {
        output.appender.append(quote);
      }
    }
 else     if (keepQuotes) {
      output.appender.append(quote);
    }
    if (ch != delimiter && ch != newLine) {
      throw new TextParsingException(context,""String_Node_Str"" + ch + ""String_Node_Str""+ delimiter+ ""String_Node_Str"");
    }
  }
}",0.977675777175047
163262,"@Override protected final boolean consumeValueOnEOF(){
  if (ch == quote) {
    if (prev == quote) {
      if (keepQuotes) {
        output.appender.append(quote);
      }
      return true;
    }
 else {
      output.appender.append(quote);
    }
  }
  return false;
}","@Override protected final boolean consumeValueOnEOF(){
  if (ch == quote) {
    if (prev == quote) {
      if (keepQuotes) {
        output.appender.append(quote);
      }
      return true;
    }
 else {
      if (!unescaped) {
        output.appender.append(quote);
      }
    }
  }
  return false;
}",0.9405594405594404
163263,"protected final void unwrapInputStream(BomInput.BytesProcessedNotification notification){
  InputStream inputStream=notification.input;
  String encoding=notification.encoding;
  if (encoding != null) {
    try {
      start(new InputStreamReader(inputStream,encoding));
    }
 catch (    Exception e) {
      throw new IllegalStateException(e);
    }
  }
 else {
    start(new InputStreamReader(inputStream));
  }
}","protected final void unwrapInputStream(BomInput.BytesProcessedNotification notification){
  InputStream inputStream=notification.input;
  String encoding=notification.encoding;
  if (encoding != null) {
    try {
      start(new InputStreamReader(inputStream,encoding));
    }
 catch (    Exception e) {
      throw new IllegalStateException(e);
    }
  }
 else {
    length=-1;
    start(new InputStreamReader(inputStream));
  }
}",0.9822904368358912
163264,"@Override public T next(){
  T out=(T)beanHolder[0];
  if (parser.parseNext() == null) {
    beanHolder[0]=null;
  }
  return out;
}","@Override public T next(){
  if (hasNext()) {
    T out=(T)beanHolder[0];
    beanHolder[0]=null;
    return out;
  }
  return null;
}",0.706766917293233
163265,"@Override public ResultIterator<T,ParsingContext> iterator(){
  final AbstractParser<P> parser=createParser(parserSettings);
  parser.beginParsing(input);
  context=parser.getContext();
  parser.parseNext();
  return new ResultIterator<T,ParsingContext>(){
    @Override public boolean hasNext(){
      return !parser.getContext().isStopped() || beanHolder[0] != null;
    }
    @Override public T next(){
      T out=(T)beanHolder[0];
      if (parser.parseNext() == null) {
        beanHolder[0]=null;
      }
      return out;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    @Override public ParsingContext getContext(){
      return context;
    }
  }
;
}","@Override public ResultIterator<T,ParsingContext> iterator(){
  final AbstractParser<P> parser=createParser(parserSettings);
  parser.beginParsing(input);
  context=parser.getContext();
  return new ResultIterator<T,ParsingContext>(){
    @Override public boolean hasNext(){
      return beanHolder[0] != null || parser.parseNext() != null;
    }
    @Override public T next(){
      if (hasNext()) {
        T out=(T)beanHolder[0];
        beanHolder[0]=null;
        return out;
      }
      return null;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    @Override public ParsingContext getContext(){
      return context;
    }
  }
;
}",0.8746518105849582
163266,"/** 
 * Iterates over an input to produce instances of annotated java beans on demand.
 * @param beanType the type of java beans to be instantiated.
 * @param input    the input to be parsed
 * @param < T >      the type of java beans to be instantiated.
 * @return an {@link Iterable} that allows iterating over the input and producing instances of java beans on demand.
 */
public <T>IterableResult<T,ParsingContext> iterate(final Class<T> beanType,final Reader input){
  final Object[] beanHolder=new Object[1];
  setRowProcessor(new BeanProcessor<T>(beanType){
    @Override public void beanProcessed(    T bean,    ParsingContext context){
      beanHolder[0]=bean;
    }
    @Override public void processEnded(    ParsingContext context){
      super.processEnded(context);
      parserSettings.setRowProcessor(null);
    }
  }
);
  return new IterableResult<T,ParsingContext>(){
    private ParsingContext context;
    @Override public ParsingContext getContext(){
      return context;
    }
    @Override public ResultIterator<T,ParsingContext> iterator(){
      final AbstractParser<P> parser=createParser(parserSettings);
      parser.beginParsing(input);
      context=parser.getContext();
      parser.parseNext();
      return new ResultIterator<T,ParsingContext>(){
        @Override public boolean hasNext(){
          return !parser.getContext().isStopped() || beanHolder[0] != null;
        }
        @Override public T next(){
          T out=(T)beanHolder[0];
          if (parser.parseNext() == null) {
            beanHolder[0]=null;
          }
          return out;
        }
        @Override public void remove(){
          throw new UnsupportedOperationException(""String_Node_Str"");
        }
        @Override public ParsingContext getContext(){
          return context;
        }
      }
;
    }
  }
;
}","/** 
 * Iterates over an input to produce instances of annotated java beans on demand.
 * @param beanType the type of java beans to be instantiated.
 * @param input    the input to be parsed
 * @param < T >      the type of java beans to be instantiated.
 * @return an {@link Iterable} that allows iterating over the input and producing instances of java beans on demand.
 */
public <T>IterableResult<T,ParsingContext> iterate(final Class<T> beanType,final Reader input){
  final Object[] beanHolder=new Object[1];
  setRowProcessor(new BeanProcessor<T>(beanType){
    @Override public void beanProcessed(    T bean,    ParsingContext context){
      beanHolder[0]=bean;
    }
    @Override public void processEnded(    ParsingContext context){
      super.processEnded(context);
      parserSettings.setRowProcessor(null);
    }
  }
);
  return new IterableResult<T,ParsingContext>(){
    private ParsingContext context;
    @Override public ParsingContext getContext(){
      return context;
    }
    @Override public ResultIterator<T,ParsingContext> iterator(){
      final AbstractParser<P> parser=createParser(parserSettings);
      parser.beginParsing(input);
      context=parser.getContext();
      return new ResultIterator<T,ParsingContext>(){
        @Override public boolean hasNext(){
          return beanHolder[0] != null || parser.parseNext() != null;
        }
        @Override public T next(){
          if (hasNext()) {
            T out=(T)beanHolder[0];
            beanHolder[0]=null;
            return out;
          }
          return null;
        }
        @Override public void remove(){
          throw new UnsupportedOperationException(""String_Node_Str"");
        }
        @Override public ParsingContext getContext(){
          return context;
        }
      }
;
    }
  }
;
}",0.946212952799122
163267,"@Override public boolean hasNext(){
  return !parser.getContext().isStopped() || beanHolder[0] != null;
}","@Override public boolean hasNext(){
  return beanHolder[0] != null || parser.parseNext() != null;
}",0.6764705882352942
163268,"@Override protected void configureFromAnnotations(Class<?> beanClass){
  if (fieldLengths == null) {
    try {
      fieldLengths=FixedWidthFields.forParsing(beanClass);
      Headers headerAnnotation=AnnotationHelper.findHeadersAnnotation(beanClass);
      setHeaderExtractionEnabled(headerAnnotation != null && headerAnnotation.extract());
    }
 catch (    IllegalArgumentException e) {
      throw e;
    }
catch (    Exception ex) {
    }
  }
  super.configureFromAnnotations(beanClass);
  if (!isHeaderExtractionEnabled()) {
    FixedWidthFields.setHeadersIfPossible(fieldLengths,this);
  }
}","@Override protected void configureFromAnnotations(Class<?> beanClass){
  if (fieldLengths == null) {
    try {
      fieldLengths=FixedWidthFields.forParsing(beanClass);
      Headers headerAnnotation=AnnotationHelper.findHeadersAnnotation(beanClass);
      if (headerExtractionEnabled == null && headerAnnotation != null) {
        setHeaderExtractionEnabled(headerAnnotation.extract());
      }
    }
 catch (    IllegalArgumentException e) {
      throw e;
    }
catch (    Exception ex) {
    }
  }
  if (headerExtractionEnabled == null) {
    setHeaderExtractionEnabled(false);
  }
  super.configureFromAnnotations(beanClass);
  if (!isHeaderExtractionEnabled()) {
    FixedWidthFields.setHeadersIfPossible(fieldLengths,this);
  }
}",0.8284644194756554
163269,"@Override public T next(){
  if (hasNext()) {
    T out=(T)beanHolder[0];
    beanHolder[0]=null;
    return out;
  }
  return null;
}","@Override public T next(){
  T out=(T)beanHolder[0];
  if (out == null && hasNext()) {
    out=(T)beanHolder[0];
  }
  beanHolder[0]=null;
  row=null;
  return out;
}",0.6266666666666667
163270,"@Override public ResultIterator<T,ParsingContext> iterator(){
  final AbstractParser<P> parser=createParser(parserSettings);
  parser.beginParsing(input);
  context=parser.getContext();
  return new ResultIterator<T,ParsingContext>(){
    @Override public boolean hasNext(){
      return beanHolder[0] != null || parser.parseNext() != null;
    }
    @Override public T next(){
      if (hasNext()) {
        T out=(T)beanHolder[0];
        beanHolder[0]=null;
        return out;
      }
      return null;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    @Override public ParsingContext getContext(){
      return context;
    }
  }
;
}","@Override public ResultIterator<T,ParsingContext> iterator(){
  final AbstractParser<P> parser=createParser(parserSettings);
  parser.beginParsing(input);
  context=parser.getContext();
  return new ResultIterator<T,ParsingContext>(){
    String[] row;
    @Override public boolean hasNext(){
      return beanHolder[0] != null || row != null || (row=parser.parseNext()) != null;
    }
    @Override public T next(){
      T out=(T)beanHolder[0];
      if (out == null && hasNext()) {
        out=(T)beanHolder[0];
      }
      beanHolder[0]=null;
      row=null;
      return out;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    @Override public ParsingContext getContext(){
      return context;
    }
  }
;
}",0.865010073875084
163271,"/** 
 * Iterates over an input to produce instances of annotated java beans on demand.
 * @param beanType the type of java beans to be instantiated.
 * @param input    the input to be parsed
 * @param < T >      the type of java beans to be instantiated.
 * @return an {@link Iterable} that allows iterating over the input and producing instances of java beans on demand.
 */
public <T>IterableResult<T,ParsingContext> iterate(final Class<T> beanType,final Reader input){
  final Object[] beanHolder=new Object[1];
  setRowProcessor(new BeanProcessor<T>(beanType){
    @Override public void beanProcessed(    T bean,    ParsingContext context){
      beanHolder[0]=bean;
    }
    @Override public void processEnded(    ParsingContext context){
      super.processEnded(context);
      parserSettings.setRowProcessor(null);
    }
  }
);
  return new IterableResult<T,ParsingContext>(){
    private ParsingContext context;
    @Override public ParsingContext getContext(){
      return context;
    }
    @Override public ResultIterator<T,ParsingContext> iterator(){
      final AbstractParser<P> parser=createParser(parserSettings);
      parser.beginParsing(input);
      context=parser.getContext();
      return new ResultIterator<T,ParsingContext>(){
        @Override public boolean hasNext(){
          return beanHolder[0] != null || parser.parseNext() != null;
        }
        @Override public T next(){
          if (hasNext()) {
            T out=(T)beanHolder[0];
            beanHolder[0]=null;
            return out;
          }
          return null;
        }
        @Override public void remove(){
          throw new UnsupportedOperationException(""String_Node_Str"");
        }
        @Override public ParsingContext getContext(){
          return context;
        }
      }
;
    }
  }
;
}","/** 
 * Iterates over an input to produce instances of annotated java beans on demand.
 * @param beanType the type of java beans to be instantiated.
 * @param input    the input to be parsed
 * @param < T >      the type of java beans to be instantiated.
 * @return an {@link Iterable} that allows iterating over the input and producing instances of java beans on demand.
 */
public <T>IterableResult<T,ParsingContext> iterate(final Class<T> beanType,final Reader input){
  final Object[] beanHolder=new Object[1];
  setRowProcessor(new BeanProcessor<T>(beanType){
    @Override public void beanProcessed(    T bean,    ParsingContext context){
      beanHolder[0]=bean;
    }
    @Override public void processEnded(    ParsingContext context){
      super.processEnded(context);
      parserSettings.setRowProcessor(null);
    }
  }
);
  return new IterableResult<T,ParsingContext>(){
    private ParsingContext context;
    @Override public ParsingContext getContext(){
      return context;
    }
    @Override public ResultIterator<T,ParsingContext> iterator(){
      final AbstractParser<P> parser=createParser(parserSettings);
      parser.beginParsing(input);
      context=parser.getContext();
      return new ResultIterator<T,ParsingContext>(){
        String[] row;
        @Override public boolean hasNext(){
          return beanHolder[0] != null || row != null || (row=parser.parseNext()) != null;
        }
        @Override public T next(){
          T out=(T)beanHolder[0];
          if (out == null && hasNext()) {
            out=(T)beanHolder[0];
          }
          beanHolder[0]=null;
          row=null;
          return out;
        }
        @Override public void remove(){
          throw new UnsupportedOperationException(""String_Node_Str"");
        }
        @Override public ParsingContext getContext(){
          return context;
        }
      }
;
    }
  }
;
}",0.9365721997300944
163272,"@Override public boolean hasNext(){
  return beanHolder[0] != null || parser.parseNext() != null;
}","@Override public boolean hasNext(){
  return beanHolder[0] != null || row != null || (row=parser.parseNext()) != null;
}",0.9041095890410958
163273,"/** 
 * Parses the next record from the input. Note that   {@link AbstractParser#beginParsing(Reader)} must have been invoked once before calling this method.If the end of the input is reached, then this method will return null. Additionally, all resources will be closed automatically at the end of the input or if any error happens while parsing.
 * @return The record parsed from the input or null if there's no more characters to read.
 */
public final String[] parseNext(){
  if (firstRecord != null) {
    String[] out=firstRecord.getValues();
    firstRecord=null;
    return out;
  }
  try {
    while (!context.isStopped()) {
      ch=input.nextChar();
      if (inComment()) {
        processComment();
        continue;
      }
      input.markRecordStart();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        if (recordsToRead >= 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
          if (recordsToRead == 0L) {
            stopParsing();
            return null;
          }
        }
        if (processor != NoopProcessor.instance) {
          rowProcessed(row);
        }
        return row;
      }
 else       if (extractingHeaders) {
        return null;
      }
    }
    stopParsing();
    return null;
  }
 catch (  EOFException ex) {
    String[] row=handleEOF();
    stopParsing();
    return row;
  }
catch (  NullPointerException ex) {
    if (context == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
 else {
      if (input != null) {
        stopParsing();
      }
      throw new IllegalStateException(""String_Node_Str"",ex);
    }
  }
catch (  Throwable ex) {
    try {
      ex=handleException(ex);
    }
  finally {
      stopParsing(ex);
    }
  }
  return null;
}","/** 
 * Parses the next record from the input. Note that   {@link AbstractParser#beginParsing(Reader)} must have been invoked once before calling this method.If the end of the input is reached, then this method will return null. Additionally, all resources will be closed automatically at the end of the input or if any error happens while parsing.
 * @return The record parsed from the input or null if there's no more characters to read.
 */
public final String[] parseNext(){
  if (firstRecord != null) {
    String[] out=firstRecord.getValues();
    firstRecord=null;
    return out;
  }
  try {
    while (!context.isStopped()) {
      input.markRecordStart();
      ch=input.nextChar();
      if (inComment()) {
        processComment();
        continue;
      }
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        if (recordsToRead >= 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
          if (recordsToRead == 0L) {
            stopParsing();
            return null;
          }
        }
        if (processor != NoopProcessor.instance) {
          rowProcessed(row);
        }
        return row;
      }
 else       if (extractingHeaders) {
        return null;
      }
    }
    stopParsing();
    return null;
  }
 catch (  EOFException ex) {
    String[] row=handleEOF();
    stopParsing();
    return row;
  }
catch (  NullPointerException ex) {
    if (context == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
 else {
      if (input != null) {
        stopParsing();
      }
      throw new IllegalStateException(""String_Node_Str"",ex);
    }
  }
catch (  Throwable ex) {
    try {
      ex=handleException(ex);
    }
  finally {
      stopParsing(ex);
    }
  }
  return null;
}",0.9827201783723524
163274,"/** 
 * Parses a single line from a String in the format supported by the parser implementation.
 * @param line a line of text to be parsed
 * @return the values parsed from the input line
 */
public final String[] parseLine(String line){
  if (line == null || line.isEmpty()) {
    return null;
  }
  lineReader.setLine(line);
  if (context == null || context.isStopped()) {
    beginParsing(lineReader);
  }
 else {
    ((DefaultCharInputReader)input).reloadBuffer();
  }
  try {
    while (!context.isStopped()) {
      ch=input.nextChar();
      if (inComment()) {
        processComment();
        return null;
      }
      input.markRecordStart();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        if (processor != NoopProcessor.instance) {
          rowProcessed(row);
        }
        return row;
      }
    }
    return null;
  }
 catch (  EOFException ex) {
    return handleEOF();
  }
catch (  NullPointerException ex) {
    if (input != null) {
      stopParsing(null);
    }
    throw new IllegalStateException(""String_Node_Str"",ex);
  }
catch (  Throwable ex) {
    try {
      ex=handleException(ex);
    }
  finally {
      stopParsing(ex);
    }
  }
  return null;
}","/** 
 * Parses a single line from a String in the format supported by the parser implementation.
 * @param line a line of text to be parsed
 * @return the values parsed from the input line
 */
public final String[] parseLine(String line){
  if (line == null || line.isEmpty()) {
    return null;
  }
  lineReader.setLine(line);
  if (context == null || context.isStopped()) {
    beginParsing(lineReader);
  }
 else {
    ((DefaultCharInputReader)input).reloadBuffer();
  }
  try {
    while (!context.isStopped()) {
      input.markRecordStart();
      ch=input.nextChar();
      if (inComment()) {
        processComment();
        return null;
      }
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        if (processor != NoopProcessor.instance) {
          rowProcessed(row);
        }
        return row;
      }
    }
    return null;
  }
 catch (  EOFException ex) {
    return handleEOF();
  }
catch (  NullPointerException ex) {
    if (input != null) {
      stopParsing(null);
    }
    throw new IllegalStateException(""String_Node_Str"",ex);
  }
catch (  Throwable ex) {
    try {
      ex=handleException(ex);
    }
  finally {
      stopParsing(ex);
    }
  }
  return null;
}",0.9747762408462164
163275,"@Override public final void markRecordStart(){
  tmp.reset();
  if (length == -1) {
    tmp.append(ch);
  }
  recordStart=i <= 0 ? 0 : i - 1;
}","@Override public final void markRecordStart(){
  tmp.reset();
  recordStart=i % length;
}",0.7068965517241379
163276,"@DataProvider public Object[][] inputBufferSizeProvider(){
  return new Object[][]{{2},{3},{4},{5},{6},{7},{8}};
}","@DataProvider public Object[][] inputBufferSizeProvider(){
  return new Object[][]{{1},{2},{3},{4},{5},{6},{7},{8}};
}",0.9827586206896552
163277,"@Test(dataProvider=""String_Node_Str"") public void testCurrentParsedContentWithShortString(int inputBufferSize) throws IOException {
  CsvParserSettings settings=new CsvParserSettings();
  settings.setReadInputOnSeparateThread(false);
  settings.setInputBufferSize(inputBufferSize);
  settings.getFormat().setLineSeparator(""String_Node_Str"");
  CsvParser parser=new CsvParser(settings);
  parser.beginParsing(new StringReader(""String_Node_Str""));
  parser.parseNext();
  assertEquals(parser.getContext().currentParsedContent(),""String_Node_Str"");
  parser.stopParsing();
  parser.parse(new StringReader(""String_Node_Str""));
  assertEquals(parser.getContext().currentParsedContent(),""String_Node_Str"");
  parser.parse(new StringReader(""String_Node_Str""));
  assertEquals(parser.getContext().currentParsedContent(),""String_Node_Str"");
  parser.parse(new StringReader(""String_Node_Str""));
  assertEquals(parser.getContext().currentParsedContent(),""String_Node_Str"");
  parser.parse(new StringReader(""String_Node_Str""));
  assertEquals(parser.getContext().currentParsedContent(),""String_Node_Str"");
}","@Test(dataProvider=""String_Node_Str"") public void testCurrentParsedContentWithShortString(int inputBufferSize) throws IOException {
  CsvParserSettings settings=new CsvParserSettings();
  settings.setReadInputOnSeparateThread(false);
  settings.setInputBufferSize(inputBufferSize);
  settings.getFormat().setLineSeparator(""String_Node_Str"");
  CsvParser parser=new CsvParser(settings);
  parser.beginParsing(new StringReader(""String_Node_Str""));
  parser.parseNext();
  assertEquals(parser.getContext().currentParsedContent(),""String_Node_Str"");
  parser.stopParsing();
  parser.parse(new StringReader(""String_Node_Str""));
  assertEquals(parser.getContext().currentParsedContent(),""String_Node_Str"");
  parser.parse(new StringReader(""String_Node_Str""));
  assertEquals(parser.getContext().currentParsedContent(),""String_Node_Str"");
  parser.parse(new StringReader(""String_Node_Str""));
  assertEquals(parser.getContext().currentParsedContent(),""String_Node_Str"");
  parser.parse(new StringReader(""String_Node_Str""));
  assertEquals(parser.getContext().currentParsedContent(),null);
  parser.beginParsing(new StringReader(""String_Node_Str""));
  parser.parseNext();
  assertEquals(parser.getContext().currentParsedContent(),""String_Node_Str"");
  parser.parseNext();
  assertEquals(parser.getContext().currentParsedContent(),""String_Node_Str"");
  parser.parseNext();
  assertEquals(parser.getContext().currentParsedContent(),null);
  parser.stopParsing();
  parser.parse(new StringReader(""String_Node_Str""));
  assertEquals(parser.getContext().currentParsedContent(),null);
}",0.808702175543886
163278,"/** 
 * Dumps the content of a   {@link java.sql.ResultSet}.
 * @param rs     the {@link java.sql.ResultSet} whose contents should be read and written to a given output
 * @param output the output that will store the data in the given {@link java.sql.ResultSet}in the format specified by concrete implementations of this class.
 */
public final void write(ResultSet rs,Writer output){
  validateWriterSettings();
  boolean hasWriterProcessor=writerSettings.getRowWriterProcessor() != null;
  AbstractWriter<W> writer=null;
  long rowCount=0L;
  Object[] row=null;
  try {
    try {
      ResultSetMetaData md=rs.getMetaData();
      int columns=md.getColumnCount();
      String[] headers=new String[columns];
      int[] lengths=new int[columns];
      for (int i=1; i <= columns; i++) {
        headers[i - 1]=md.getColumnLabel(i);
        int precision=md.getPrecision(i);
        int scale=md.getScale(i);
        int length;
        if (precision != 0 && scale != 0) {
          length=precision + scale + 2;
        }
 else {
          length=precision + scale;
        }
        lengths[i - 1]=length;
      }
      writerSettings.setHeaders(headers);
      adjustColumnLengths(headers,lengths);
      writer=createWriter(output,writerSettings);
      if (writerSettings.isHeaderWritingEnabled()) {
        writer.writeHeaders();
      }
      row=new Object[columns];
      while (rs.next()) {
        for (int i=1; i <= columns; i++) {
          row[i - 1]=rs.getObject(i);
        }
        if (hasWriterProcessor) {
          writer.processRecord(row);
        }
 else {
          writer.writeRow(row);
        }
        rowCount++;
      }
    }
  finally {
      rs.close();
    }
  }
 catch (  Exception e) {
    throw new TextWritingException(""String_Node_Str"",rowCount,row,e);
  }
 finally {
    if (writer != null) {
      writer.close();
    }
  }
}","/** 
 * Dumps the content of a   {@link java.sql.ResultSet}.
 * @param rs     the {@link java.sql.ResultSet} whose contents should be read and written to a given output
 * @param output the output that will store the data in the given {@link java.sql.ResultSet}in the format specified by concrete implementations of this class.
 */
public final void write(ResultSet rs,Writer output){
  validateWriterSettings();
  boolean hasWriterProcessor=writerSettings.getRowWriterProcessor() != null;
  AbstractWriter<W> writer=null;
  long rowCount=0L;
  Object[] row=null;
  try {
    try {
      ResultSetMetaData md=rs.getMetaData();
      int columns=md.getColumnCount();
      String[] headers=new String[columns];
      int[] lengths=new int[columns];
      for (int i=1; i <= columns; i++) {
        headers[i - 1]=md.getColumnLabel(i);
        int precision=md.getPrecision(i);
        int scale=md.getScale(i);
        int length;
        if (precision != 0 && scale != 0) {
          length=precision + scale + 2;
        }
 else {
          length=precision + scale;
        }
        lengths[i - 1]=length;
      }
      String[] userProvidedHeaders=writerSettings.getHeaders();
      if (userProvidedHeaders == null) {
        writerSettings.setHeaders(headers);
      }
 else {
        headers=userProvidedHeaders;
      }
      adjustColumnLengths(headers,lengths);
      writer=createWriter(output,writerSettings);
      if (writerSettings.isHeaderWritingEnabled()) {
        writer.writeHeaders();
      }
      row=new Object[columns];
      while (rs.next()) {
        for (int i=1; i <= columns; i++) {
          row[i - 1]=rs.getObject(i);
        }
        if (hasWriterProcessor) {
          writer.processRecord(row);
        }
 else {
          writer.writeRow(row);
        }
        rowCount++;
      }
    }
  finally {
      rs.close();
    }
  }
 catch (  Exception e) {
    throw new TextWritingException(""String_Node_Str"",rowCount,row,e);
  }
 finally {
    if (writer != null) {
      writer.close();
    }
  }
}",0.9431060994361866
163279,"private Statement populateDatabase() throws Exception {
  String createTable=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Class.forName(""String_Node_Str"");
  Connection connection=DriverManager.getConnection(""String_Node_Str"");
  Statement statement=connection.createStatement();
  statement.execute(createTable);
  statement.executeUpdate(""String_Node_Str"");
  statement.executeUpdate(""String_Node_Str"");
  statement.executeUpdate(""String_Node_Str"");
  return statement;
}","protected Statement populateDatabase() throws Exception {
  String createTable=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Class.forName(""String_Node_Str"");
  Connection connection=DriverManager.getConnection(""String_Node_Str"");
  Statement statement=connection.createStatement();
  statement.execute(createTable);
  statement.executeUpdate(""String_Node_Str"");
  statement.executeUpdate(""String_Node_Str"");
  statement.executeUpdate(""String_Node_Str"");
  return statement;
}",0.9886363636363636
163280,"@Override public final void markRecordStart(){
  tmp.reset();
  recordStart=i <= 0 ? 0 : i - 1;
}","@Override public final void markRecordStart(){
  tmp.reset();
  if (length == -1) {
    tmp.append(ch);
  }
  recordStart=i <= 0 ? 0 : i - 1;
}",0.8083333333333333
163281,"private void initializeMetadataConversions(String[] data,MetaData md){
  if (conversions != null) {
    String[] headers=headers();
    if (headers == null) {
      headers=data;
    }
    conversions.prepareExecution(false,headers);
    md.setDefaultConversions(conversions.getConversions(md.index,md.type));
  }
}","private void initializeMetadataConversions(String[] data,MetaData md){
  if (conversions != null) {
synchronized (this) {
      String[] headers=headers();
      if (headers == null) {
        headers=data;
      }
      conversions.prepareExecution(false,headers);
      md.setDefaultConversions(conversions.getConversions(md.index,md.type));
    }
  }
}",0.9402985074626866
163282,"public MetaData getMetaData(int index){
  if (indexMap == null || indexMap.length < index + 1) {
    int startFrom=0;
    int lastIndex=index;
    if (indexMap != null) {
      startFrom=indexMap.length;
      indexMap=Arrays.copyOf(indexMap,index + 1);
    }
 else {
      String[] headers=context.headers();
      if (headers != null && lastIndex < headers.length) {
        lastIndex=headers.length;
      }
      int[] indexes=context.extractedFieldIndexes();
      if (indexes != null) {
        for (int i=0; i < indexes.length; i++) {
          if (lastIndex < indexes[i]) {
            lastIndex=indexes[i];
          }
        }
      }
      indexMap=new MetaData[lastIndex + 1];
    }
    for (int i=startFrom; i < lastIndex + 1; i++) {
      indexMap[i]=new MetaData(i);
    }
  }
  return indexMap[index];
}","public MetaData getMetaData(int index){
  if (indexMap == null || indexMap.length < index + 1 || indexMap[index] == null) {
synchronized (this) {
      if (indexMap == null || indexMap.length < index + 1 || indexMap[index] == null) {
        int startFrom=0;
        int lastIndex=index;
        if (indexMap != null) {
          startFrom=indexMap.length;
          indexMap=Arrays.copyOf(indexMap,index + 1);
        }
 else {
          String[] headers=context.headers();
          if (headers != null && lastIndex < headers.length) {
            lastIndex=headers.length;
          }
          int[] indexes=context.extractedFieldIndexes();
          if (indexes != null) {
            for (int i=0; i < indexes.length; i++) {
              if (lastIndex < indexes[i]) {
                lastIndex=indexes[i];
              }
            }
          }
          indexMap=new MetaData[lastIndex + 1];
        }
        for (int i=startFrom; i < lastIndex + 1; i++) {
          indexMap[i]=new MetaData(i);
        }
      }
    }
  }
  return indexMap[index];
}",0.8709506107275624
163283,"/** 
 * Converts a formatted date String to an instance of Date. <p>The pattern in the formatted date must match one of the date patterns provided in the constructor of this class.
 * @param input the String containing a formatted date which must be converted to a Date
 * @return the Date instance containing the date information represented by the given String, or the value of {@code valueIfObjectIsNull} if the String input is null.
 */
@Override protected Date fromString(String input){
  for (  SimpleDateFormat formatter : parsers) {
    try {
      return formatter.parse(input);
    }
 catch (    ParseException ex) {
    }
  }
  DataProcessingException exception=new DataProcessingException(""String_Node_Str"" + Arrays.toString(formats));
  exception.setValue(input);
  throw exception;
}","/** 
 * Converts a formatted date String to an instance of Date. <p>The pattern in the formatted date must match one of the date patterns provided in the constructor of this class.
 * @param input the String containing a formatted date which must be converted to a Date
 * @return the Date instance containing the date information represented by the given String, or the value of {@code valueIfObjectIsNull} if the String input is null.
 */
@Override protected Date fromString(String input){
  for (  SimpleDateFormat formatter : parsers) {
    try {
synchronized (formatter) {
        return formatter.parse(input);
      }
    }
 catch (    ParseException ex) {
    }
  }
  DataProcessingException exception=new DataProcessingException(""String_Node_Str"" + Arrays.toString(formats));
  exception.setValue(input);
  throw exception;
}",0.9773145309625996
163284,"@Override public final void start(Reader reader){
  stop();
  setReader(reader);
  lineCount=0;
  lineSeparatorDetected=false;
  submitLineSeparatorDetector();
  updateBuffer();
}","@Override public final void start(Reader reader){
  stop();
  setReader(reader);
  lineCount=0;
  lineSeparatorDetected=false;
  submitLineSeparatorDetector();
  updateBuffer();
  if (length > 0 && buffer[0] == '\uFEFF') {
    i++;
  }
}",0.8605769230769231
163285,"private void processQuoteEscape(){
  if (ch == quoteEscape && prev == escapeEscape && escapeEscape != '\0') {
    if (keepEscape) {
      output.appender.append(escapeEscape);
    }
    output.appender.append(quoteEscape);
    ch='\0';
  }
 else   if (prev == quoteEscape) {
    if (ch == quote) {
      if (keepEscape) {
        output.appender.append(quoteEscape);
      }
      output.appender.append(quote);
      ch='\0';
    }
 else {
      output.appender.append(prev);
    }
  }
 else   if (ch == quote && prev == quote) {
    output.appender.append(quote);
  }
}","private void processQuoteEscape(){
  if (ch == quoteEscape && prev == escapeEscape && escapeEscape != '\0') {
    if (keepEscape) {
      output.appender.append(escapeEscape);
    }
    output.appender.append(quoteEscape);
    ch='\0';
  }
 else   if (prev == quoteEscape) {
    if (ch == quote) {
      if (keepEscape) {
        output.appender.append(quoteEscape);
      }
      output.appender.append(quote);
      ch='\0';
    }
 else {
      output.appender.append(prev);
    }
  }
 else   if (ch == quote && prev == quote) {
    output.appender.append(quote);
  }
 else   if (prev == quote) {
    handleUnescapedQuoteInValue();
  }
}",0.9421487603305784
163286,"private boolean append(boolean isElementQuoted,String element){
  if (element == null) {
    if (nullValue == null) {
      return isElementQuoted;
    }
    element=nullValue;
  }
  int start=0;
  if (this.ignoreLeading) {
    start=skipLeadingWhitespace(whitespaceRangeStart,element);
  }
  final int length=element.length();
  if (start < length && element.charAt(start) == quoteChar) {
    isElementQuoted=true;
  }
  if (isElementQuoted) {
    if (usingNullOrEmptyValue && length >= 2) {
      if (element.charAt(0) == quoteChar && element.charAt(length - 1) == quoteChar) {
        appender.append(element);
        return false;
      }
 else {
        appendQuoted(start,element);
        return true;
      }
    }
 else {
      appendQuoted(start,element);
      return true;
    }
  }
  int i=start;
  char ch='\0';
  for (; i < length; i++) {
    ch=element.charAt(i);
    if (ch == quoteChar || ch == separator || ch == newLine || ch == escapeChar || (ch < maxTrigger && quotationTriggers[ch])) {
      appender.append(element,start,i);
      start=i + 1;
      if (ch == quoteChar) {
        if (quoteElement(i,element)) {
          appendQuoted(i,element);
          return true;
        }
 else         if (escapeUnquoted) {
          appendQuoted(i,element);
        }
 else {
          appender.append(element,i,length);
          if (ignoreTrailing && element.charAt(length - 1) <= ' ' && whitespaceRangeStart < element.charAt(length - 1)) {
            appender.updateWhitespace();
          }
        }
        return isElementQuoted;
      }
 else       if (ch == escapeChar && inputNotEscaped && escapeEscape != '\0' && escapeUnquoted) {
        appender.append(escapeEscape);
      }
 else       if (ch == separator || ch == newLine || ch < maxTrigger && quotationTriggers[ch]) {
        appendQuoted(i,element);
        return true;
      }
      appender.append(ch);
    }
  }
  appender.append(element,start,i);
  if (ch <= ' ' && ignoreTrailing && whitespaceRangeStart < ch) {
    appender.updateWhitespace();
  }
  return isElementQuoted;
}","private boolean append(boolean isElementQuoted,String element){
  if (element == null) {
    if (nullValue == null) {
      return isElementQuoted;
    }
    element=nullValue;
  }
  int start=0;
  if (this.ignoreLeading) {
    start=skipLeadingWhitespace(whitespaceRangeStart,element);
  }
  final int length=element.length();
  if (start < length && element.charAt(start) == quoteChar) {
    isElementQuoted=true;
  }
  if (isElementQuoted) {
    if (usingNullOrEmptyValue && length >= 2) {
      if (element.charAt(0) == quoteChar && element.charAt(length - 1) == quoteChar) {
        appender.append(element);
        return false;
      }
 else {
        appendQuoted(start,element);
        return true;
      }
    }
 else {
      appendQuoted(start,element);
      return true;
    }
  }
  int i=start;
  char ch='\0';
  for (; i < length; i++) {
    ch=element.charAt(i);
    if (ch == quoteChar || ch == separator || ch == newLine || ch == escapeChar || (ch < maxTrigger && quotationTriggers[ch])) {
      appender.append(element,start,i);
      start=i + 1;
      if (ch == quoteChar || ch == escapeChar) {
        if (quoteElement(i,element)) {
          appendQuoted(i,element);
          return true;
        }
 else         if (escapeUnquoted) {
          appendQuoted(i,element);
        }
 else {
          appender.append(element,i,length);
          if (ignoreTrailing && element.charAt(length - 1) <= ' ' && whitespaceRangeStart < element.charAt(length - 1)) {
            appender.updateWhitespace();
          }
        }
        return isElementQuoted;
      }
 else       if (ch == escapeChar && inputNotEscaped && escapeEscape != '\0' && escapeUnquoted) {
        appender.append(escapeEscape);
      }
 else       if (ch == separator || ch == newLine || ch < maxTrigger && quotationTriggers[ch]) {
        appendQuoted(i,element);
        return true;
      }
      appender.append(ch);
    }
  }
  appender.append(element,start,i);
  if (ch <= ' ' && ignoreTrailing && whitespaceRangeStart < ch) {
    appender.updateWhitespace();
  }
  return isElementQuoted;
}",0.9951899951899952
163287,"@Test(dataProvider=""String_Node_Str"") public void testEscapeWriting(String input){
  System.out.println(""String_Node_Str"" + input + ""String_Node_Str"");
  int i=0;
  for (  char escape : new char[]{'\'','|'}) {
    CsvWriterSettings settings=new CsvWriterSettings();
    settings.setEscapeUnquotedValues(true);
    settings.getFormat().setQuote('\'');
    settings.getFormat().setQuoteEscape(escape);
    System.out.print(++i + ""String_Node_Str"" + escape+ ""String_Node_Str"");
    String result=new CsvWriter(settings).writeRowToString(input);
    CsvParserSettings parserSettings=new CsvParserSettings();
    settings.setEscapeUnquotedValues(true);
    settings.getFormat().setQuote('\'');
    settings.getFormat().setQuoteEscape(escape);
    String parsed=new CsvParser(parserSettings).parseLine(input)[0];
    System.out.println(result + (parsed.equals(input) ? ""String_Node_Str"" : ""String_Node_Str""));
    assertEquals(parsed,input);
  }
}","@Test(dataProvider=""String_Node_Str"") public void testEscapeWriting(String input){
  System.out.println(""String_Node_Str"" + input + ""String_Node_Str"");
  int i=0;
  List<String> expected=new ArrayList<String>();
  for (  char escape : new char[]{'\'','|'}) {
    CsvWriterSettings settings=new CsvWriterSettings();
    settings.setQuoteAllFields(true);
    settings.getFormat().setQuote('\'');
    settings.getFormat().setQuoteEscape(escape);
    System.out.print(++i + ""String_Node_Str"" + escape+ ""String_Node_Str"");
    String result=new CsvWriter(settings).writeRowToString(input);
    CsvParserSettings parserSettings=new CsvParserSettings();
    settings.setEscapeUnquotedValues(true);
    settings.getFormat().setQuote('\'');
    settings.getFormat().setQuoteEscape(escape);
    String parsed=new CsvParser(parserSettings).parseLine(input)[0];
    System.out.println(result + (parsed.equals(input) ? ""String_Node_Str"" : ""String_Node_Str""));
    assertEquals(parsed,input);
    expected.add(result);
  }
}",0.9451563300871348
163288,"@Override protected void processRow(Object[] row){
  if (row.length > 0 && lookaheadFormats != null || lookbehindFormats != null) {
    String value=String.valueOf(row[0]);
    int end;
    if (value.length() >= lookupChars.length) {
      end=lookupChars.length;
    }
 else {
      end=value.length();
      for (int i=lookupChars.length - 1; i > end; i--) {
        lookupChars[i]='\0';
      }
    }
    value.getChars(0,end,lookupChars,0);
    boolean matched=false;
    if (lookaheadFormats != null) {
      for (int i=0; i < lookaheadFormats.length; i++) {
        if (lookaheadFormats[i].matches(lookupChars)) {
          fieldLengths=lookaheadFormats[i].lengths;
          fieldAlignments=lookaheadFormats[i].alignments;
          fieldPaddings=lookaheadFormats[i].paddings;
          matched=true;
          break;
        }
      }
      if (lookbehindFormats != null && matched) {
        lookbehindFormat=null;
        for (int i=0; i < lookbehindFormats.length; i++) {
          if (lookbehindFormats[i].matches(lookupChars)) {
            lookbehindFormat=lookbehindFormats[i];
            break;
          }
        }
      }
    }
 else {
      for (int i=0; i < lookbehindFormats.length; i++) {
        if (lookbehindFormats[i].matches(lookupChars)) {
          lookbehindFormat=lookbehindFormats[i];
          matched=true;
          fieldLengths=rootLengths;
          fieldAlignments=rootAlignments;
          fieldPaddings=rootPaddings;
          break;
        }
      }
    }
    if (!matched) {
      if (lookbehindFormat == null) {
        if (rootLengths == null) {
          throw new TextWritingException(""String_Node_Str"" + new String(lookupChars) + '\'',getRecordCount(),row);
        }
        fieldLengths=rootLengths;
        fieldAlignments=rootAlignments;
        fieldPaddings=rootPaddings;
      }
 else {
        fieldLengths=lookbehindFormat.lengths;
        fieldAlignments=lookbehindFormat.alignments;
        fieldPaddings=lookbehindFormat.paddings;
      }
    }
  }
  int lastIndex=fieldLengths.length < row.length ? fieldLengths.length : row.length;
  for (int i=0; i < lastIndex; i++) {
    length=fieldLengths[i];
    alignment=fieldAlignments[i];
    padding=fieldPaddings[i];
    if (writingHeaders) {
      if (defaultHeaderPadding) {
        padding=defaultPadding;
      }
      if (defaultHeaderAlignment != null) {
        alignment=defaultHeaderAlignment;
      }
    }
    String nextElement=getStringValue(row[i]);
    processElement(nextElement);
    appendValueToRow();
  }
}","@Override protected void processRow(Object[] row){
  if (row.length > 0 && lookaheadFormats != null || lookbehindFormats != null) {
    int dstBegin=0;
    for (int i=0; i < row.length && dstBegin < lookupChars.length; i++) {
      String value=String.valueOf(row[i]);
      int len=value.length();
      if (dstBegin + len > lookupChars.length) {
        len=lookupChars.length - dstBegin;
      }
      value.getChars(0,len,lookupChars,dstBegin);
      dstBegin+=len;
    }
    for (int i=lookupChars.length - 1; i > dstBegin; i--) {
      lookupChars[i]='\0';
    }
    boolean matched=false;
    if (lookaheadFormats != null) {
      for (int i=0; i < lookaheadFormats.length; i++) {
        if (lookaheadFormats[i].matches(lookupChars)) {
          fieldLengths=lookaheadFormats[i].lengths;
          fieldAlignments=lookaheadFormats[i].alignments;
          fieldPaddings=lookaheadFormats[i].paddings;
          matched=true;
          break;
        }
      }
      if (lookbehindFormats != null && matched) {
        lookbehindFormat=null;
        for (int i=0; i < lookbehindFormats.length; i++) {
          if (lookbehindFormats[i].matches(lookupChars)) {
            lookbehindFormat=lookbehindFormats[i];
            break;
          }
        }
      }
    }
 else {
      for (int i=0; i < lookbehindFormats.length; i++) {
        if (lookbehindFormats[i].matches(lookupChars)) {
          lookbehindFormat=lookbehindFormats[i];
          matched=true;
          fieldLengths=rootLengths;
          fieldAlignments=rootAlignments;
          fieldPaddings=rootPaddings;
          break;
        }
      }
    }
    if (!matched) {
      if (lookbehindFormat == null) {
        if (rootLengths == null) {
          throw new TextWritingException(""String_Node_Str"" + new String(lookupChars) + '\'',getRecordCount(),row);
        }
        fieldLengths=rootLengths;
        fieldAlignments=rootAlignments;
        fieldPaddings=rootPaddings;
      }
 else {
        fieldLengths=lookbehindFormat.lengths;
        fieldAlignments=lookbehindFormat.alignments;
        fieldPaddings=lookbehindFormat.paddings;
      }
    }
  }
  int lastIndex=fieldLengths.length < row.length ? fieldLengths.length : row.length;
  for (int i=0; i < lastIndex; i++) {
    length=fieldLengths[i];
    alignment=fieldAlignments[i];
    padding=fieldPaddings[i];
    if (writingHeaders) {
      if (defaultHeaderPadding) {
        padding=defaultPadding;
      }
      if (defaultHeaderAlignment != null) {
        alignment=defaultHeaderAlignment;
      }
    }
    String nextElement=getStringValue(row[i]);
    processElement(nextElement);
    appendValueToRow();
  }
}",0.9291490180978051
163289,"/** 
 * The FixedWidthWriter supports all settings provided by   {@link FixedWidthWriterSettings}, and requires this configuration to be properly initialized.
 * @param output the output stream that will be written with the fixed-width records produced by this class.
 * @param encoding the encoding of the stream
 * @param settings the fixed-width writer configuration
 */
public FixedWidthWriter(OutputStream output,Charset encoding,FixedWidthWriterSettings settings){
  super(output,encoding,settings);
}","/** 
 * The FixedWidthWriter supports all settings provided by   {@link FixedWidthWriterSettings}, and requires this configuration to be properly initialized.
 * @param output   the output stream that will be written with the fixed-width records produced by this class.
 * @param encoding the encoding of the stream
 * @param settings the fixed-width writer configuration
 */
public FixedWidthWriter(OutputStream output,Charset encoding,FixedWidthWriterSettings settings){
  super(output,encoding,settings);
}",0.998031496062992
163290,"@Override public void execute(char[] characters,int length){
  Set<Character> allSymbols=new HashSet<Character>();
  Map<Character,Integer> symbols=new HashMap<Character,Integer>();
  Map<Character,Integer> escape=new HashMap<Character,Integer>();
  List<Map<Character,Integer>> symbolsPerRow=new ArrayList<Map<Character,Integer>>();
  int doubleQuoteCount=0;
  int singleQuoteCount=0;
  int i;
  char inQuote='\0';
  boolean afterNewLine=true;
  for (i=0; i < length; i++) {
    char ch=characters[i];
    if (afterNewLine && ch == comment) {
      while (++i < length) {
        ch=characters[i];
        if (ch == '\r' || ch == '\n' || ch == normalizedNewLine) {
          break;
        }
      }
      continue;
    }
    if (ch == '""' || ch == '\'') {
      if (inQuote == ch) {
        if (ch == '""') {
          doubleQuoteCount++;
        }
 else {
          singleQuoteCount++;
        }
        if (i + 1 < length) {
          char next=characters[i + 1];
          if (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next)) {
            char prev=characters[i - 1];
            if (!Character.isLetterOrDigit(prev)) {
              increment(escape,prev);
            }
          }
        }
        inQuote='\0';
      }
 else       if (inQuote == '\0') {
        inQuote=ch;
      }
      continue;
    }
    if (inQuote != '\0') {
      continue;
    }
    afterNewLine=false;
    if (isSymbol(ch)) {
      allSymbols.add(ch);
      increment(symbols,ch);
    }
 else     if ((ch == '\r' || ch == '\n' || ch == normalizedNewLine) && symbols.size() > 0) {
      afterNewLine=true;
      symbolsPerRow.add(symbols);
      if (symbolsPerRow.size() == MAX_ROW_SAMPLES) {
        break;
      }
      symbols=new HashMap<Character,Integer>();
    }
  }
  if (i >= length && symbolsPerRow.size() > 1) {
    symbolsPerRow.remove(symbolsPerRow.size() - 1);
  }
  Map<Character,Integer> totals=calculateTotals(symbolsPerRow);
  Map<Character,Integer> sums=new HashMap<Character,Integer>();
  Set<Character> toRemove=new HashSet<Character>();
  for (  Map<Character,Integer> previous : symbolsPerRow) {
    for (    Map<Character,Integer> current : symbolsPerRow) {
      for (      Character symbol : allSymbols) {
        Integer previousCount=previous.get(symbol);
        Integer currentCount=current.get(symbol);
        if (previousCount == null && currentCount == null) {
          toRemove.add(symbol);
        }
        if (previousCount == null || currentCount == null) {
          continue;
        }
        increment(sums,symbol,Math.abs(previousCount - currentCount));
      }
    }
  }
  sums.keySet().removeAll(toRemove);
  char delimiter=min(sums,totals,suggestedDelimiter);
  char quote=doubleQuoteCount >= singleQuoteCount ? '""' : '\'';
  escape.remove(delimiter);
  char quoteEscape=max(escape,totals,quote);
  apply(delimiter,quote,quoteEscape);
}","@Override public void execute(char[] characters,int length){
  Set<Character> allSymbols=new HashSet<Character>();
  Map<Character,Integer> symbols=new HashMap<Character,Integer>();
  Map<Character,Integer> escape=new HashMap<Character,Integer>();
  List<Map<Character,Integer>> symbolsPerRow=new ArrayList<Map<Character,Integer>>();
  int doubleQuoteCount=0;
  int singleQuoteCount=0;
  int i;
  char inQuote='\0';
  boolean afterNewLine=true;
  for (i=0; i < length; i++) {
    char ch=characters[i];
    if (afterNewLine && ch == comment) {
      while (++i < length) {
        ch=characters[i];
        if (ch == '\r' || ch == '\n' || ch == normalizedNewLine) {
          break;
        }
      }
      continue;
    }
    if (ch == '""' || ch == '\'') {
      if (inQuote == ch) {
        if (ch == '""') {
          doubleQuoteCount++;
        }
 else {
          singleQuoteCount++;
        }
        if (i + 1 < length) {
          char next=characters[i + 1];
          if (Character.isLetterOrDigit(next) || (next <= ' ' && whitespaceRangeStart < next && next != '\n' && next != '\r')) {
            char prev=characters[i - 1];
            if (!Character.isLetterOrDigit(prev)) {
              increment(escape,prev);
            }
          }
        }
        inQuote='\0';
      }
 else       if (inQuote == '\0') {
        inQuote=ch;
      }
      continue;
    }
    if (inQuote != '\0') {
      continue;
    }
    afterNewLine=false;
    if (isSymbol(ch)) {
      allSymbols.add(ch);
      increment(symbols,ch);
    }
 else     if ((ch == '\r' || ch == '\n' || ch == normalizedNewLine) && symbols.size() > 0) {
      afterNewLine=true;
      symbolsPerRow.add(symbols);
      if (symbolsPerRow.size() == MAX_ROW_SAMPLES) {
        break;
      }
      symbols=new HashMap<Character,Integer>();
    }
  }
  if (i >= length && symbolsPerRow.size() > 1) {
    symbolsPerRow.remove(symbolsPerRow.size() - 1);
  }
  Map<Character,Integer> totals=calculateTotals(symbolsPerRow);
  Map<Character,Integer> sums=new HashMap<Character,Integer>();
  Set<Character> toRemove=new HashSet<Character>();
  for (  Map<Character,Integer> previous : symbolsPerRow) {
    for (    Map<Character,Integer> current : symbolsPerRow) {
      for (      Character symbol : allSymbols) {
        Integer previousCount=previous.get(symbol);
        Integer currentCount=current.get(symbol);
        if (previousCount == null && currentCount == null) {
          toRemove.add(symbol);
        }
        if (previousCount == null || currentCount == null) {
          continue;
        }
        increment(sums,symbol,Math.abs(previousCount - currentCount));
      }
    }
  }
  sums.keySet().removeAll(toRemove);
  char delimiter=min(sums,totals,suggestedDelimiter);
  char quote=doubleQuoteCount >= singleQuoteCount ? '""' : '\'';
  escape.remove(delimiter);
  char quoteEscape=max(escape,totals,quote);
  apply(delimiter,quote,quoteEscape);
}",0.9945130315500684
163291,"protected Statement populateDatabase() throws Exception {
  String createTable=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Class.forName(""String_Node_Str"");
  Connection connection=DriverManager.getConnection(""String_Node_Str"");
  Statement statement=connection.createStatement();
  statement.execute(createTable);
  statement.executeUpdate(""String_Node_Str"");
  statement.executeUpdate(""String_Node_Str"");
  statement.executeUpdate(""String_Node_Str"");
  return statement;
}","protected Statement populateDatabase() throws Exception {
  String createTable=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Class.forName(""String_Node_Str"");
  Statement statement=connectToDatabase();
  statement.execute(createTable);
  statement.executeUpdate(""String_Node_Str"");
  statement.executeUpdate(""String_Node_Str"");
  statement.executeUpdate(""String_Node_Str"");
  return statement;
}",0.8454452405322416
163292,"/** 
 * Returns the next available bucket. Blocks until a bucket is made available or the reading process stops.
 * @return the next available bucket.
 */
@SuppressWarnings(""String_Node_Str"") public synchronized CharBucket nextBucket(){
  try {
    if (finished) {
      return end;
    }
    if (currentBucket != null) {
      instances.release(currentBucket);
    }
    Object element=buckets.take();
    if (element == end) {
      finished=true;
      return end;
    }
 else {
      currentBucket=(Entry<CharBucket>)element;
    }
    return currentBucket.get();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    finished=true;
    return end;
  }
}","/** 
 * Returns the next available bucket. Blocks until a bucket is made available or the reading process stops.
 * @return the next available bucket.
 */
@SuppressWarnings(""String_Node_Str"") public synchronized CharBucket nextBucket(){
  try {
    if (finished) {
      if (error != null) {
        ArgumentUtils.throwUnchecked(error);
      }
      return end;
    }
    if (currentBucket != null) {
      instances.release(currentBucket);
    }
    Object element=buckets.take();
    if (element == end) {
      finished=true;
      return end;
    }
 else {
      currentBucket=(Entry<CharBucket>)element;
    }
    return currentBucket.get();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    finished=true;
    return end;
  }
}",0.945054945054945
163293,"/** 
 * The   {@link CharBucket} loading process that executes in parallel until the input is completely read.Once the end of the input is reached, the  {@link java.io.Reader} instance provided in the constructor is closed.
 */
@Override public void run(){
  Thread.currentThread().setName(""String_Node_Str"");
  try {
    try {
      int length;
      do {
        Entry<CharBucket> bucket=instances.allocate();
        length=bucket.get().fill(reader);
        if (length != -1) {
          buckets.put(bucket);
        }
 else {
          instances.release(bucket);
        }
      }
 while (active && length != -1);
    }
  finally {
      buckets.put(end);
    }
  }
 catch (  IOException e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
 finally {
    stopReading();
  }
}","/** 
 * The   {@link CharBucket} loading process that executes in parallel until the input is completely read.Once the end of the input is reached, the  {@link java.io.Reader} instance provided in the constructor is closed.
 */
@Override public void run(){
  Thread.currentThread().setName(""String_Node_Str"");
  try {
    try {
      int length;
      do {
        Entry<CharBucket> bucket=instances.allocate();
        length=bucket.get().fill(reader);
        if (length != -1) {
          buckets.put(bucket);
        }
 else {
          instances.release(bucket);
        }
      }
 while (active && length != -1);
    }
  finally {
      buckets.put(end);
    }
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
catch (  Exception e) {
    finished=true;
    error=e;
  }
 finally {
    stopReading();
  }
}",0.8290697674418605
163294,"/** 
 * Returns the metadata information associated with the records generated by this factory class
 * @return the record metadata.
 */
public final RecordMetaData getRecordMetaData(){
  return metaData;
}","/** 
 * Returns the metadata information associated with the records generated by this factory class
 * @return the record metadata.
 */
public final M getRecordMetaData(){
  return metaData;
}",0.9674185463659148
163295,"/** 
 * Creates a new factory of   {@link Record} based the state of a parser
 * @param context            the parser context
 */
public AbstractRecordFactory(Context context){
  this.metaData=new RecordMetaDataImpl(context);
}","/** 
 * Creates a new factory of   {@link Record} based the state of a parser
 * @param context            the parser context
 */
public AbstractRecordFactory(Context context){
  this.metaData=createMetaData(context);
}",0.9551569506726456
163296,"RecordMetaDataImpl(Context context){
  this.context=context;
}","RecordMetaDataImpl(C context){
  this.context=context;
}",0.9491525423728814
163297,"protected void adjustColumnLengths(String[] headers,int[] lengths){
  getWriterSettings().setFieldLengths(new FixedWidthFields(headers,lengths));
}","protected void adjustColumnLengths(String[] headers,int[] lengths){
  if (getWriterSettings().getFieldLengths() == null) {
    getWriterSettings().setFieldLengths(new FixedWidthFields(headers,lengths));
  }
}",0.8225352112676056
163298,"/** 
 * Identifies which fields are associated with which columns in a row.
 * @param row              A row with values for the given java bean.
 * @param headers          The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes          The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldIndexes(Context context,Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  if (headers == null) {
    headers=ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  int last=headers.length > row.length ? headers.length : row.length;
  for (  FieldMapping mapping : parsedFields) {
    int index=mapping.getIndex();
    if (last < index) {
      last=index;
    }
  }
  FieldMapping[] fieldOrder=new FieldMapping[last];
  TreeSet<String> fieldsNotFound=new TreeSet<String>();
  for (  FieldMapping mapping : parsedFields) {
    if (mapping.isMappedToField()) {
      int index=ArgumentUtils.indexOf(headers,mapping.getFieldName());
      if (index == -1) {
        fieldsNotFound.add(mapping.getFieldName());
        continue;
      }
      fieldOrder[index]=mapping;
    }
 else     if (mapping.getIndex() < fieldOrder.length) {
      fieldOrder[mapping.getIndex()]=mapping;
    }
  }
  if (context != null && !fieldsNotFound.isEmpty()) {
    if (headers.length == 0) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
    }
    if (strictHeaderValidationEnabled) {
      DataProcessingException exception=new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
      exception.setValue(""String_Node_Str"",Arrays.toString(headers));
      throw exception;
    }
  }
  if (indexes != null) {
    for (int i=0; i < fieldOrder.length; i++) {
      boolean isIndexUsed=false;
      for (int j=0; j < indexes.length; j++) {
        if (indexes[j] == i) {
          isIndexUsed=true;
          break;
        }
      }
      if (!isIndexUsed) {
        fieldOrder[i]=null;
      }
    }
    if (columnsReordered) {
      FieldMapping[] newFieldOrder=new FieldMapping[indexes.length];
      for (int i=0; i < indexes.length; i++) {
        for (int j=0; j < fieldOrder.length; j++) {
          int index=indexes[i];
          if (index != -1) {
            FieldMapping field=fieldOrder[index];
            newFieldOrder[i]=field;
          }
        }
      }
      fieldOrder=newFieldOrder;
    }
  }
  readOrder=fieldOrder;
  initializeValuesForMissing();
}","/** 
 * Identifies which fields are associated with which columns in a row.
 * @param row              A row with values for the given java bean.
 * @param headers          The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes          The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldIndexes(Context context,Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  if (headers == null) {
    headers=ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  int last=headers.length > row.length ? headers.length : row.length;
  for (  FieldMapping mapping : parsedFields) {
    int index=mapping.getIndex();
    if (last < index) {
      last=index + 1;
    }
  }
  FieldMapping[] fieldOrder=new FieldMapping[last];
  TreeSet<String> fieldsNotFound=new TreeSet<String>();
  for (  FieldMapping mapping : parsedFields) {
    if (mapping.isMappedToField()) {
      int index=ArgumentUtils.indexOf(headers,mapping.getFieldName());
      if (index == -1) {
        fieldsNotFound.add(mapping.getFieldName());
        continue;
      }
      fieldOrder[index]=mapping;
    }
 else     if (mapping.getIndex() < fieldOrder.length) {
      fieldOrder[mapping.getIndex()]=mapping;
    }
  }
  if (context != null && !fieldsNotFound.isEmpty()) {
    if (headers.length == 0) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
    }
    if (strictHeaderValidationEnabled) {
      DataProcessingException exception=new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
      exception.setValue(""String_Node_Str"",Arrays.toString(headers));
      throw exception;
    }
  }
  if (indexes != null) {
    for (int i=0; i < fieldOrder.length; i++) {
      boolean isIndexUsed=false;
      for (int j=0; j < indexes.length; j++) {
        if (indexes[j] == i) {
          isIndexUsed=true;
          break;
        }
      }
      if (!isIndexUsed) {
        fieldOrder[i]=null;
      }
    }
    if (columnsReordered) {
      FieldMapping[] newFieldOrder=new FieldMapping[indexes.length];
      for (int i=0; i < indexes.length; i++) {
        for (int j=0; j < fieldOrder.length; j++) {
          int index=indexes[i];
          if (index != -1) {
            FieldMapping field=fieldOrder[index];
            newFieldOrder[i]=field;
          }
        }
      }
      fieldOrder=newFieldOrder;
    }
  }
  readOrder=fieldOrder;
  initializeValuesForMissing();
}",0.9993096306523992
163299,"/** 
 * Stops parsing and closes all open resources.
 */
public final void stopParsing(){
  try {
    context.stop();
  }
  finally {
    try {
      processor.processEnded(context);
    }
  finally {
      output.appender.reset();
      input.stop();
    }
  }
}","/** 
 * Stops parsing and closes all open resources.
 */
public final void stopParsing(){
  try {
    try {
      context.stop();
    }
  finally {
      try {
        processor.processEnded(context);
      }
  finally {
        output.appender.reset();
        input.stop();
      }
    }
  }
 catch (  Throwable error) {
    throw handleException(error);
  }
}",0.6432
163300,"/** 
 * Stops the CharInputReader from reading characters from the   {@link java.io.Reader} provided in {@link ConcurrentCharInputReader#start(Reader)} and closes it.Also stops the input reading thread.
 */
@Override public void stop(){
  if (bucketLoader != null) {
    bucketLoader.stopReading();
  }
}","/** 
 * Stops the CharInputReader from reading characters from the   {@link java.io.Reader} provided in {@link ConcurrentCharInputReader#start(Reader)} and closes it.Also stops the input reading thread.
 */
@Override public void stop(){
  if (bucketLoader != null) {
    bucketLoader.stopReading();
    bucketLoader.reportError();
  }
}",0.95
163301,"/** 
 * Starts an input reading thread to load characters from the given reader into ""buckets"" of characters
 */
@Override protected void setReader(Reader reader){
  stop();
  bucketLoader=new ConcurrentCharLoader(reader,bucketSize,bucketQuantity);
}","/** 
 * Starts an input reading thread to load characters from the given reader into ""buckets"" of characters
 */
@Override protected void setReader(Reader reader){
  stop();
  bucketLoader=new ConcurrentCharLoader(reader,bucketSize,bucketQuantity);
  bucketLoader.reportError();
}",0.9433962264150944
163302,"/** 
 * Assigns the next ""bucket"" of characters to the   {@link ConcurrentCharInputReader#buffer} attribute, and updates the {@link ConcurrentCharInputReader#length} to the number of characters read.
 */
@Override protected void reloadBuffer(){
  CharBucket currentBucket=bucketLoader.nextBucket();
  super.buffer=currentBucket.data;
  super.length=currentBucket.length;
}","/** 
 * Assigns the next ""bucket"" of characters to the   {@link ConcurrentCharInputReader#buffer} attribute, and updates the {@link ConcurrentCharInputReader#length} to the number of characters read.
 */
@Override protected void reloadBuffer(){
  CharBucket currentBucket=bucketLoader.nextBucket();
  bucketLoader.reportError();
  super.buffer=currentBucket.data;
  super.length=currentBucket.length;
}",0.9612403100775194
163303,"/** 
 * Returns the next available bucket. Blocks until a bucket is made available or the reading process stops.
 * @return the next available bucket.
 */
@SuppressWarnings(""String_Node_Str"") public synchronized CharBucket nextBucket(){
  try {
    if (finished) {
      if (error != null) {
        ArgumentUtils.throwUnchecked(error);
      }
      return end;
    }
    if (currentBucket != null) {
      instances.release(currentBucket);
    }
    Object element=buckets.take();
    if (element == end) {
      finished=true;
      return end;
    }
 else {
      currentBucket=(Entry<CharBucket>)element;
    }
    return currentBucket.get();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    finished=true;
    return end;
  }
}","/** 
 * Returns the next available bucket. Blocks until a bucket is made available or the reading process stops.
 * @return the next available bucket.
 */
@SuppressWarnings(""String_Node_Str"") public synchronized CharBucket nextBucket(){
  try {
    if (finished) {
      return end;
    }
    if (currentBucket != null) {
      instances.release(currentBucket);
    }
    Object element=buckets.take();
    if (element == end) {
      finished=true;
      return end;
    }
 else {
      currentBucket=(Entry<CharBucket>)element;
    }
    return currentBucket.get();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    finished=true;
    return end;
  }
}",0.945054945054945
163304,"/** 
 * Creates a   {@link FixedInstancePool} with a given amount of {@link CharBucket} instances and starts a thread to fill each one.
 * @param reader The source of characters to extract and fill {@link CharBucket} instances
 * @param bucketSize The size of each individual {@link CharBucket}
 * @param bucketQuantity The number of {@link CharBucket} instances used to extract characters from the given reader.
 */
public ConcurrentCharLoader(Reader reader,final int bucketSize,int bucketQuantity){
  this.end=new CharBucket(-1);
  this.buckets=new ArrayBlockingQueue<Object>(bucketQuantity);
  this.reader=reader;
  this.instances=new FixedInstancePool<CharBucket>(bucketQuantity){
    @Override protected CharBucket newInstance(){
      return new CharBucket(bucketSize);
    }
  }
;
  finished=false;
  active=true;
  activeExecution=new Thread(this,""String_Node_Str"");
  activeExecution.start();
}","/** 
 * Creates a   {@link FixedInstancePool} with a given amount of {@link CharBucket} instances and starts a thread to fill each one.
 * @param reader         The source of characters to extract and fill {@link CharBucket} instances
 * @param bucketSize     The size of each individual {@link CharBucket}
 * @param bucketQuantity The number of {@link CharBucket} instances used to extract characters from the given reader.
 */
public ConcurrentCharLoader(Reader reader,final int bucketSize,int bucketQuantity){
  this.end=new CharBucket(-1);
  this.buckets=new ArrayBlockingQueue<Object>(bucketQuantity);
  this.reader=reader;
  this.instances=new FixedInstancePool<CharBucket>(bucketQuantity){
    @Override protected CharBucket newInstance(){
      return new CharBucket(bucketSize);
    }
  }
;
  finished=false;
  active=true;
  activeExecution=new Thread(this,""String_Node_Str"");
  activeExecution.start();
}",0.9933993399339934
163305,"@Test(expectedExceptions=TextParsingException.class) public void parseExceptionInConcurrentInput() throws Exception {
  Reader explodingInput=new Reader(){
    String firstPart=""String_Node_Str"";
    @Override public int read(    char[] chars,    int off,    int len) throws IOException {
      if (firstPart != null) {
        for (int i=0; i < firstPart.length() && len-- > 0; i++) {
          chars[off++]=firstPart.charAt(i);
        }
        int out=firstPart.length();
        firstPart=null;
        return out;
      }
      throw new IllegalStateException(""String_Node_Str"");
    }
    @Override public void close() throws IOException {
    }
  }
;
  CsvParserSettings settings=new CsvParserSettings();
  System.err.println(""String_Node_Str"");
  CsvParser parser=new CsvParser(settings);
  parser.beginParsing(explodingInput);
  assertEquals(""String_Node_Str"",Arrays.toString(parser.parseNext()));
  assertEquals(""String_Node_Str"",Arrays.toString(parser.parseNext()));
  parser.parseNext();
  fail(""String_Node_Str"");
}","@Test(expectedExceptions=TextParsingException.class) public void parseExceptionInConcurrentInput() throws Exception {
  Reader explodingInput=new Reader(){
    String firstPart=""String_Node_Str"";
    @Override public int read(    char[] chars,    int off,    int len) throws IOException {
      if (firstPart != null) {
        for (int i=0; i < firstPart.length() && len-- > 0; i++) {
          chars[off++]=firstPart.charAt(i);
        }
        int out=firstPart.length();
        firstPart=null;
        return out;
      }
      throw new IllegalStateException(""String_Node_Str"");
    }
    @Override public void close() throws IOException {
    }
  }
;
  CsvParserSettings settings=new CsvParserSettings();
  System.err.println(""String_Node_Str"");
  CsvParser parser=new CsvParser(settings);
  parser.beginParsing(explodingInput);
  assertEquals(Arrays.toString(parser.parseNext()),""String_Node_Str"");
  assertEquals(Arrays.toString(parser.parseNext()),""String_Node_Str"");
  System.out.println(Arrays.toString(parser.parseNext()));
  fail(""String_Node_Str"");
}",0.8859188544152745
163306,"/** 
 * Initializes the ParserOutput with the configuration specified in   {@link CommonParserSettings}
 * @param parser the parser whose output will be managed by this class.
 * @param settings the parser configuration
 */
public ParserOutput(AbstractParser<?> parser,CommonParserSettings<?> settings){
  this.parser=parser;
  this.appenderInstance=settings.newCharAppender();
  this.appender=appenderInstance;
  this.parsedValues=new String[settings.getMaxColumns()];
  this.appenders=new CharAppender[settings.getMaxColumns() + 1];
  Arrays.fill(appenders,appender);
  this.settings=settings;
  this.skipEmptyLines=settings.getSkipEmptyLines();
  this.nullValue=settings.getNullValue();
  this.columnsToExtractInitialized=false;
  this.currentRecord=0;
  if (settings.getHeaders() != null) {
    initializeHeaders();
  }
}","/** 
 * Initializes the ParserOutput with the configuration specified in   {@link CommonParserSettings}
 * @param parser   the parser whose output will be managed by this class.
 * @param settings the parser configuration
 */
public ParserOutput(AbstractParser<?> parser,CommonParserSettings<?> settings){
  this.parser=parser;
  this.appenderInstance=settings.newCharAppender();
  this.appender=appenderInstance;
  this.parsedValues=new String[settings.getMaxColumns()];
  this.appenders=new CharAppender[settings.getMaxColumns() + 1];
  Arrays.fill(appenders,appender);
  this.settings=settings;
  this.skipEmptyLines=settings.getSkipEmptyLines();
  this.nullValue=settings.getNullValue();
  this.columnsToExtractInitialized=false;
  this.currentRecord=0;
  if (settings.getHeaders() != null) {
    initializeHeaders();
  }
}",0.9987893462469734
163307,"/** 
 * Gets all values parsed in the   {@link ParserOutput#parsedValues} array
 * @return the sequence of parsed values in a record.
 */
public String[] rowParsed(){
  if (column > 0) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
      if (settings.isHeaderExtractionEnabled()) {
        Arrays.fill(parsedValues,null);
        column=0;
        this.appender=appenders[0];
        return null;
      }
    }
    currentRecord++;
    if (columnsReordered) {
      String[] reorderedValues=new String[selectedIndexes.length];
      for (int i=0; i < selectedIndexes.length; i++) {
        int index=selectedIndexes[i];
        if (index >= column || index == -1) {
          reorderedValues[i]=nullValue;
        }
 else {
          reorderedValues[i]=parsedValues[index];
        }
      }
      column=0;
      this.appender=appenders[0];
      return reorderedValues;
    }
 else {
      String[] out=new String[column];
      System.arraycopy(parsedValues,0,out,0,column);
      column=0;
      this.appender=appenders[0];
      return out;
    }
  }
 else   if (!skipEmptyLines) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
    }
    currentRecord++;
    if (columnsReordered) {
      String[] out=new String[selectedIndexes.length];
      Arrays.fill(out,nullValue);
      return out;
    }
    return ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  return null;
}","/** 
 * Gets all values parsed in the   {@link ParserOutput#parsedValues} array
 * @return the sequence of parsed values in a record.
 */
public String[] rowParsed(){
  if (column > 0) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
      if (settings.isHeaderExtractionEnabled()) {
        Arrays.fill(parsedValues,null);
        column=0;
        this.appender=appenders[0];
        return null;
      }
 else       if (!columnsReordered && selectedIndexes != null) {
        String[] out=new String[column];
        for (int i=0; i < selectedIndexes.length; i++) {
          int index=selectedIndexes[i];
          if (index < column) {
            out[index]=parsedValues[index];
          }
        }
        return out;
      }
    }
    currentRecord++;
    if (columnsReordered) {
      String[] reorderedValues=new String[selectedIndexes.length];
      for (int i=0; i < selectedIndexes.length; i++) {
        int index=selectedIndexes[i];
        if (index >= column || index == -1) {
          reorderedValues[i]=nullValue;
        }
 else {
          reorderedValues[i]=parsedValues[index];
        }
      }
      column=0;
      this.appender=appenders[0];
      return reorderedValues;
    }
 else {
      String[] out=new String[column];
      System.arraycopy(parsedValues,0,out,0,column);
      column=0;
      this.appender=appenders[0];
      return out;
    }
  }
 else   if (!skipEmptyLines) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
    }
    currentRecord++;
    if (columnsReordered) {
      String[] out=new String[selectedIndexes.length];
      Arrays.fill(out,nullValue);
      return out;
    }
    return ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  return null;
}",0.8957406230133503
163308,"private static void registerLookup(String direction,String lookup,FixedWidthFields lengths,Map<String,FixedWidthFields> map){
  if (lookup == null || lookup.trim().isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"" + direction + ""String_Node_Str"");
  }
  if (lengths == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + direction + ""String_Node_Str""+ lookup+ ""String_Node_Str"");
  }
  map.put(lookup,lengths);
}","private static void registerLookup(String direction,String lookup,FixedWidthFields lengths,Map<String,FixedWidthFields> map){
  if (lookup == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + direction + ""String_Node_Str"");
  }
  if (lengths == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + direction + ""String_Node_Str""+ lookup+ ""String_Node_Str"");
  }
  map.put(lookup,lengths);
}",0.9688581314878892
163309,"private boolean append(boolean isElementQuoted,String element){
  if (element == null) {
    if (nullValue == null) {
      return isElementQuoted;
    }
    element=nullValue;
  }
  int start=0;
  if (this.ignoreLeading) {
    start=skipLeadingWhitespace(element);
  }
  final int length=element.length();
  if (start < length && element.charAt(start) == quoteChar) {
    isElementQuoted=true;
  }
  if (isElementQuoted) {
    if (usingNullOrEmptyValue && length >= 2) {
      isElementQuoted=!(element.charAt(0) == quoteChar && element.charAt(length - 1) == quoteChar);
      if (isElementQuoted) {
        appendQuoted(start,element);
        return true;
      }
    }
 else {
      appendQuoted(start,element);
      return true;
    }
  }
  int i=start;
  char ch='\0';
  for (; i < length; i++) {
    ch=element.charAt(i);
    if (ch == quoteChar || ch == separator || ch == newLine || ch == escapeChar || (ch < maxTrigger && quotationTriggers[ch])) {
      appender.append(element,start,i);
      start=i + 1;
      if (ch == quoteChar) {
        if (quoteElement(i,element)) {
          appendQuoted(i,element);
          return true;
        }
 else         if (escapeUnquoted) {
          appendQuoted(i,element);
        }
 else {
          appender.append(element,i,length);
          if (ignoreTrailing && element.charAt(length - 1) <= ' ') {
            appender.updateWhitespace();
          }
        }
        return isElementQuoted;
      }
 else       if (ch == escapeChar && inputNotEscaped && escapeEscape != '\0' && escapeUnquoted) {
        appender.append(escapeEscape);
      }
 else       if (ch == separator || ch == newLine || ch < maxTrigger && quotationTriggers[ch]) {
        appendQuoted(i,element);
        return true;
      }
      appender.append(ch);
    }
  }
  appender.append(element,start,i);
  if (ch <= ' ' && this.ignoreTrailing) {
    appender.updateWhitespace();
  }
  return isElementQuoted;
}","private boolean append(boolean isElementQuoted,String element){
  if (element == null) {
    if (nullValue == null) {
      return isElementQuoted;
    }
    element=nullValue;
  }
  int start=0;
  if (this.ignoreLeading) {
    start=skipLeadingWhitespace(element);
  }
  final int length=element.length();
  if (start < length && element.charAt(start) == quoteChar) {
    isElementQuoted=true;
  }
  if (isElementQuoted) {
    if (usingNullOrEmptyValue && length >= 2) {
      if (element.charAt(0) == quoteChar && element.charAt(length - 1) == quoteChar) {
        appender.append(element);
        return false;
      }
 else {
        appendQuoted(start,element);
        return true;
      }
    }
 else {
      appendQuoted(start,element);
      return true;
    }
  }
  int i=start;
  char ch='\0';
  for (; i < length; i++) {
    ch=element.charAt(i);
    if (ch == quoteChar || ch == separator || ch == newLine || ch == escapeChar || (ch < maxTrigger && quotationTriggers[ch])) {
      appender.append(element,start,i);
      start=i + 1;
      if (ch == quoteChar) {
        if (quoteElement(i,element)) {
          appendQuoted(i,element);
          return true;
        }
 else         if (escapeUnquoted) {
          appendQuoted(i,element);
        }
 else {
          appender.append(element,i,length);
          if (ignoreTrailing && element.charAt(length - 1) <= ' ') {
            appender.updateWhitespace();
          }
        }
        return isElementQuoted;
      }
 else       if (ch == escapeChar && inputNotEscaped && escapeEscape != '\0' && escapeUnquoted) {
        appender.append(escapeEscape);
      }
 else       if (ch == separator || ch == newLine || ch < maxTrigger && quotationTriggers[ch]) {
        appendQuoted(i,element);
        return true;
      }
      appender.append(ch);
    }
  }
  appender.append(element,start,i);
  if (ch <= ' ' && this.ignoreTrailing) {
    appender.updateWhitespace();
  }
  return isElementQuoted;
}",0.9703476482617588
163310,"@Test(dataProvider=""String_Node_Str"") public void testWriteNullValueAsEmptyQuotes(String nullValue,String emptyValue,boolean quoteAllFields,String expectedNullValue,String expectedEmptyValue){
  CsvWriterSettings s=new CsvWriterSettings();
  s.setNullValue(nullValue);
  s.setEmptyValue(emptyValue);
  s.setQuoteAllFields(quoteAllFields);
  String result;
  result=new CsvWriter(s).writeRowToString(new String[]{null,""String_Node_Str""});
  assertEquals(result,expectedNullValue + ',' + expectedEmptyValue);
}","@Test(dataProvider=""String_Node_Str"") public void testWriteNullValueAsEmptyQuotes(String nullValue,String emptyValue,boolean quoteAllFields,boolean quoteEscapingEnabled,String expectedNullValue,String expectedEmptyValue){
  CsvWriterSettings s=new CsvWriterSettings();
  s.setNullValue(nullValue);
  s.setEmptyValue(emptyValue);
  s.setQuoteAllFields(quoteAllFields);
  String result;
  result=new CsvWriter(s).writeRowToString(new String[]{null,""String_Node_Str""});
  assertEquals(result,expectedNullValue + ',' + expectedEmptyValue);
}",0.9722488038277513
163311,"@DataProvider public Object[][] nullAndEmptyValueProvider(){
  return new Object[][]{{""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"",""String_Node_Str""},{null,null,false,""String_Node_Str"",""String_Node_Str""},{null,null,true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"",""String_Node_Str""}};
}","@DataProvider public Object[][] nullAndEmptyValueProvider(){
  return new Object[][]{{""String_Node_Str"",""String_Node_Str"",false,false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,false,""String_Node_Str"",""String_Node_Str""},{null,null,false,false,""String_Node_Str"",""String_Node_Str""},{null,null,true,false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,false,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,true,""String_Node_Str"",""String_Node_Str""},{null,null,false,true,""String_Node_Str"",""String_Node_Str""},{null,null,true,true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",false,true,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",true,true,""String_Node_Str"",""String_Node_Str""}};
}",0.0990606319385141
163312,"/** 
 * Converts a given object to its String representation for writing to a   {@code String}<ul> <li>If the object is null, then   {@link AbstractWriter#nullValue} is returned.</li><li>If the String representation of this object is an empty String, then  {@link AbstractWriter#emptyValue} is returned</li></ul>
 * @param element the object to be converted into a String.
 * @return the String representation of the given object
 */
protected String getStringValue(Object element){
  if (element == null) {
    element=nullValue;
    if (element == null) {
      return null;
    }
  }
  String string=String.valueOf(element);
  if (string.isEmpty()) {
    return emptyValue;
  }
  return string;
}","/** 
 * Converts a given object to its String representation for writing to a   {@code String}<ul> <li>If the object is null, then   {@link AbstractWriter#nullValue} is returned.</li><li>If the String representation of this object is an empty String, then  {@link AbstractWriter#emptyValue} is returned</li></ul>
 * @param element the object to be converted into a String.
 * @return the String representation of the given object
 */
protected String getStringValue(Object element){
  usingNullOrEmptyValue=false;
  if (element == null) {
    element=nullValue;
    usingNullOrEmptyValue=true;
    if (element == null) {
      return null;
    }
  }
  String string=String.valueOf(element);
  if (string.isEmpty()) {
    usingNullOrEmptyValue=true;
    return emptyValue;
  }
  return string;
}",0.925653047555258
163313,"private boolean append(boolean isElementQuoted,String element){
  if (element == null) {
    element=nullValue;
  }
  if (element == null) {
    return isElementQuoted;
  }
  int start=0;
  if (this.ignoreLeading) {
    start=skipLeadingWhitespace(element);
  }
  final int length=element.length();
  if (start < length && element.charAt(start) == quoteChar) {
    isElementQuoted=true;
  }
  if (isElementQuoted) {
    appendQuoted(start,element);
    return true;
  }
  int i=start;
  char ch='\0';
  for (; i < length; i++) {
    ch=element.charAt(i);
    if (ch == quoteChar || ch == separator || ch == newLine || ch == escapeChar || (ch < maxTrigger && quotationTriggers[ch])) {
      appender.append(element,start,i);
      start=i + 1;
      if (ch == quoteChar) {
        if (quoteElement(i,element)) {
          appendQuoted(i,element);
          return true;
        }
 else         if (escapeUnquoted) {
          appendQuoted(i,element);
        }
 else {
          appender.append(element,i,length);
          if (ignoreTrailing && element.charAt(length - 1) <= ' ') {
            appender.updateWhitespace();
          }
        }
        return isElementQuoted;
      }
 else       if (ch == escapeChar && inputNotEscaped && escapeEscape != '\0' && escapeUnquoted) {
        appender.append(escapeEscape);
      }
 else       if (ch == separator || ch == newLine || ch < maxTrigger && quotationTriggers[ch]) {
        appendQuoted(i,element);
        return true;
      }
      appender.append(ch);
    }
  }
  appender.append(element,start,i);
  if (ch <= ' ' && this.ignoreTrailing) {
    appender.updateWhitespace();
  }
  return isElementQuoted;
}","private boolean append(boolean isElementQuoted,String element){
  if (element == null) {
    if (nullValue == null) {
      return isElementQuoted;
    }
    element=nullValue;
  }
  int start=0;
  if (this.ignoreLeading) {
    start=skipLeadingWhitespace(element);
  }
  final int length=element.length();
  if (start < length && element.charAt(start) == quoteChar) {
    isElementQuoted=true;
  }
  if (isElementQuoted) {
    if (usingNullOrEmptyValue && length >= 2) {
      isElementQuoted=!(element.charAt(0) == quoteChar && element.charAt(length - 1) == quoteChar);
      if (isElementQuoted) {
        appendQuoted(start,element);
        return true;
      }
    }
 else {
      appendQuoted(start,element);
      return true;
    }
  }
  int i=start;
  char ch='\0';
  for (; i < length; i++) {
    ch=element.charAt(i);
    if (ch == quoteChar || ch == separator || ch == newLine || ch == escapeChar || (ch < maxTrigger && quotationTriggers[ch])) {
      appender.append(element,start,i);
      start=i + 1;
      if (ch == quoteChar) {
        if (quoteElement(i,element)) {
          appendQuoted(i,element);
          return true;
        }
 else         if (escapeUnquoted) {
          appendQuoted(i,element);
        }
 else {
          appender.append(element,i,length);
          if (ignoreTrailing && element.charAt(length - 1) <= ' ') {
            appender.updateWhitespace();
          }
        }
        return isElementQuoted;
      }
 else       if (ch == escapeChar && inputNotEscaped && escapeEscape != '\0' && escapeUnquoted) {
        appender.append(escapeEscape);
      }
 else       if (ch == separator || ch == newLine || ch < maxTrigger && quotationTriggers[ch]) {
        appendQuoted(i,element);
        return true;
      }
      appender.append(ch);
    }
  }
  appender.append(element,start,i);
  if (ch <= ' ' && this.ignoreTrailing) {
    appender.updateWhitespace();
  }
  return isElementQuoted;
}",0.8810645966176879
163314,"@Test public void testWriteEmptyValue(){
  CsvWriterSettings s=new CsvWriterSettings();
  s.setNullValue(""String_Node_Str"");
  s.setEmptyValue(""String_Node_Str"");
  CsvWriter w=new CsvWriter(s);
  String result=w.writeRowToString(new String[]{null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  System.out.println(result);
}","@Test public void testWriteEmptyValue(){
  CsvWriterSettings s=new CsvWriterSettings();
  s.setNullValue(""String_Node_Str"");
  s.setEmptyValue(""String_Node_Str"");
  CsvWriter w=new CsvWriter(s);
  String result=w.writeRowToString(new String[]{null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  assertEquals(result,""String_Node_Str"");
}",0.9138888888888888
163315,"private void skipToNewLine(){
  while (ch != newLine) {
    ch=input.nextChar();
  }
}","private void skipToNewLine(){
  try {
    while (ch != newLine) {
      ch=input.nextChar();
    }
  }
 catch (  EOFException e) {
  }
}",0.7747747747747747
163316,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private static Conversion getConversion(Class fieldType,Field field,Annotation annotation){
  try {
    Parsed parsed=field == null ? null : findAnnotation(field,Parsed.class);
    Class annType=annotation.annotationType();
    String nullRead=getNullReadValue(parsed);
    String nullWrite=getNullWriteValue(parsed);
    if (annType == NullString.class) {
      String[] nulls=((NullString)annotation).nulls();
      return Conversions.toNull(nulls);
    }
 else     if (annType == EnumOptions.class) {
      if (!fieldType.isEnum()) {
        if (field == null) {
          throw new IllegalStateException(""String_Node_Str"" + EnumOptions.class.getName() + ""String_Node_Str""+ fieldType.getName()+ ""String_Node_Str"");
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + EnumOptions.class.getName() + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ field.getType().getName()+ ""String_Node_Str"");
        }
      }
      EnumOptions enumOptions=((EnumOptions)annotation);
      String element=enumOptions.customElement().trim();
      if (element.isEmpty()) {
        element=null;
      }
      Enum nullReadValue=nullRead == null ? null : Enum.valueOf(fieldType,nullRead);
      return new EnumConversion(fieldType,nullReadValue,nullWrite,element,enumOptions.selectors());
    }
 else     if (annType == Trim.class) {
      int length=((Trim)annotation).length();
      if (length == -1) {
        return Conversions.trim();
      }
 else {
        return Conversions.trim(length);
      }
    }
 else     if (annType == LowerCase.class) {
      return Conversions.toLowerCase();
    }
 else     if (annType == UpperCase.class) {
      return Conversions.toUpperCase();
    }
 else     if (annType == Replace.class) {
      Replace replace=((Replace)annotation);
      return Conversions.replace(replace.expression(),replace.replacement());
    }
 else     if (annType == BooleanString.class) {
      if (fieldType != boolean.class && fieldType != Boolean.class) {
        if (field == null) {
          throw new DataProcessingException(""String_Node_Str"" + BooleanString.class.getName() + ""String_Node_Str""+ fieldType.getName()+ ""String_Node_Str"");
        }
 else {
          throw new DataProcessingException(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ fieldType.getName()+ ""String_Node_Str"");
        }
      }
      BooleanString boolString=((BooleanString)annotation);
      String[] falseStrings=boolString.falseStrings();
      String[] trueStrings=boolString.trueStrings();
      Boolean valueForNull=nullRead == null ? null : BooleanConversion.getBoolean(nullRead,trueStrings,falseStrings);
      if (valueForNull == null && fieldType == boolean.class) {
        valueForNull=Boolean.FALSE;
      }
      return Conversions.toBoolean(valueForNull,nullWrite,trueStrings,falseStrings);
    }
 else     if (annType == Format.class) {
      Format format=((Format)annotation);
      String[] formats=format.formats();
      Conversion conversion=null;
      if (fieldType == BigDecimal.class) {
        BigDecimal defaultForNull=nullRead == null ? null : new BigDecimal(nullRead);
        conversion=Conversions.formatToBigDecimal(defaultForNull,nullWrite,formats);
      }
 else       if (Number.class.isAssignableFrom(fieldType)) {
        conversion=Conversions.formatToNumber(formats);
        ((NumericConversion)conversion).setNumberType(fieldType);
      }
 else {
        Date dateIfNull=null;
        if (nullRead != null) {
          if (""String_Node_Str"".equalsIgnoreCase(nullRead)) {
            dateIfNull=new Date();
          }
 else {
            if (formats.length == 0) {
              throw new DataProcessingException(""String_Node_Str"");
            }
            SimpleDateFormat sdf=new SimpleDateFormat(formats[0]);
            dateIfNull=sdf.parse(nullRead);
          }
        }
        if (Date.class == fieldType) {
          conversion=Conversions.toDate(dateIfNull,nullWrite,formats);
        }
 else         if (Calendar.class == fieldType) {
          Calendar calendarIfNull=null;
          if (dateIfNull != null) {
            calendarIfNull=Calendar.getInstance();
            calendarIfNull.setTime(dateIfNull);
          }
          conversion=Conversions.toCalendar(calendarIfNull,nullWrite,formats);
        }
      }
      if (conversion != null) {
        String[] options=format.options();
        if (options.length > 0) {
          if (conversion instanceof FormattedConversion) {
            Object[] formatters=((FormattedConversion)conversion).getFormatterObjects();
            for (            Object formatter : formatters) {
              applyFormatSettings(formatter,options);
            }
          }
 else {
            throw new DataProcessingException(""String_Node_Str"" + Arrays.toString(options) + ""String_Node_Str""+ conversion.getClass()+ ""String_Node_Str""+ FormattedConversion.class);
          }
        }
        return conversion;
      }
    }
 else     if (annType == Convert.class) {
      Convert convert=((Convert)annotation);
      String[] args=convert.args();
      Class conversionClass=convert.conversionClass();
      if (!Conversion.class.isAssignableFrom(conversionClass)) {
        throw new DataProcessingException(""String_Node_Str"" + conversionClass.getSimpleName() + ""String_Node_Str""+ conversionClass.getName()+ ')');
      }
      try {
        Constructor constructor=conversionClass.getConstructor(String[].class);
        return (Conversion)constructor.newInstance((Object)args);
      }
 catch (      NoSuchMethodException e) {
        throw new DataProcessingException(""String_Node_Str"" + conversionClass.getSimpleName() + ""String_Node_Str""+ conversionClass.getName()+ ')',e);
      }
catch (      Exception e) {
        throw new DataProcessingException(""String_Node_Str"" + conversionClass.getSimpleName() + ""String_Node_Str""+ conversionClass.getName()+ ')',e);
      }
    }
    return null;
  }
 catch (  DataProcessingException ex) {
    throw ex;
  }
catch (  Throwable ex) {
    if (field == null) {
      throw new DataProcessingException(""String_Node_Str"" + fieldType,ex);
    }
 else {
      throw new DataProcessingException(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ field.getDeclaringClass().getName(),ex);
    }
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private static Conversion getConversion(Class fieldType,Field field,Annotation annotation){
  try {
    Parsed parsed=field == null ? null : findAnnotation(field,Parsed.class);
    Class annType=annotation.annotationType();
    String nullRead=getNullReadValue(parsed);
    String nullWrite=getNullWriteValue(parsed);
    if (annType == NullString.class) {
      String[] nulls=((NullString)annotation).nulls();
      return Conversions.toNull(nulls);
    }
 else     if (annType == EnumOptions.class) {
      if (!fieldType.isEnum()) {
        if (field == null) {
          throw new IllegalStateException(""String_Node_Str"" + EnumOptions.class.getName() + ""String_Node_Str""+ fieldType.getName()+ ""String_Node_Str"");
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + EnumOptions.class.getName() + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ field.getType().getName()+ ""String_Node_Str"");
        }
      }
      EnumOptions enumOptions=((EnumOptions)annotation);
      String element=enumOptions.customElement().trim();
      if (element.isEmpty()) {
        element=null;
      }
      Enum nullReadValue=nullRead == null ? null : Enum.valueOf(fieldType,nullRead);
      return new EnumConversion(fieldType,nullReadValue,nullWrite,element,enumOptions.selectors());
    }
 else     if (annType == Trim.class) {
      int length=((Trim)annotation).length();
      if (length == -1) {
        return Conversions.trim();
      }
 else {
        return Conversions.trim(length);
      }
    }
 else     if (annType == LowerCase.class) {
      return Conversions.toLowerCase();
    }
 else     if (annType == UpperCase.class) {
      return Conversions.toUpperCase();
    }
 else     if (annType == Replace.class) {
      Replace replace=((Replace)annotation);
      return Conversions.replace(replace.expression(),replace.replacement());
    }
 else     if (annType == BooleanString.class) {
      if (fieldType != boolean.class && fieldType != Boolean.class) {
        if (field == null) {
          throw new DataProcessingException(""String_Node_Str"" + BooleanString.class.getName() + ""String_Node_Str""+ fieldType.getName()+ ""String_Node_Str"");
        }
 else {
          throw new DataProcessingException(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ fieldType.getName()+ ""String_Node_Str"");
        }
      }
      BooleanString boolString=((BooleanString)annotation);
      String[] falseStrings=boolString.falseStrings();
      String[] trueStrings=boolString.trueStrings();
      Boolean valueForNull=nullRead == null ? null : BooleanConversion.getBoolean(nullRead,trueStrings,falseStrings);
      if (valueForNull == null && fieldType == boolean.class) {
        valueForNull=Boolean.FALSE;
      }
      return Conversions.toBoolean(valueForNull,nullWrite,trueStrings,falseStrings);
    }
 else     if (annType == Format.class) {
      Format format=((Format)annotation);
      String[] formats=format.formats();
      Conversion conversion=null;
      if (fieldType == BigDecimal.class) {
        BigDecimal defaultForNull=nullRead == null ? null : new BigDecimal(nullRead);
        conversion=Conversions.formatToBigDecimal(defaultForNull,nullWrite,formats);
      }
 else       if (Number.class.isAssignableFrom(fieldType)) {
        conversion=Conversions.formatToNumber(formats);
        ((NumericConversion)conversion).setNumberType(fieldType);
      }
 else {
        Date dateIfNull=null;
        if (nullRead != null) {
          if (""String_Node_Str"".equalsIgnoreCase(nullRead)) {
            dateIfNull=new Date();
          }
 else {
            if (formats.length == 0) {
              throw new DataProcessingException(""String_Node_Str"");
            }
            SimpleDateFormat sdf=new SimpleDateFormat(formats[0]);
            dateIfNull=sdf.parse(nullRead);
          }
        }
        if (Date.class == fieldType) {
          conversion=Conversions.toDate(dateIfNull,nullWrite,formats);
        }
 else         if (Calendar.class == fieldType) {
          Calendar calendarIfNull=null;
          if (dateIfNull != null) {
            calendarIfNull=Calendar.getInstance();
            calendarIfNull.setTime(dateIfNull);
          }
          conversion=Conversions.toCalendar(calendarIfNull,nullWrite,formats);
        }
      }
      if (conversion != null) {
        String[] options=format.options();
        if (options.length > 0) {
          if (conversion instanceof FormattedConversion) {
            Object[] formatters=((FormattedConversion)conversion).getFormatterObjects();
            for (            Object formatter : formatters) {
              applyFormatSettings(formatter,options);
            }
          }
 else {
            throw new DataProcessingException(""String_Node_Str"" + Arrays.toString(options) + ""String_Node_Str""+ conversion.getClass()+ ""String_Node_Str""+ FormattedConversion.class);
          }
        }
        return conversion;
      }
    }
 else     if (annType == Convert.class) {
      Convert convert=((Convert)annotation);
      String[] args=convert.args();
      Class conversionClass=convert.conversionClass();
      if (!Conversion.class.isAssignableFrom(conversionClass)) {
        throw new DataProcessingException(""String_Node_Str"" + conversionClass.getSimpleName() + ""String_Node_Str""+ conversionClass.getName()+ ')');
      }
      try {
        Constructor constructor=conversionClass.getConstructor(String[].class);
        return (Conversion)constructor.newInstance((Object)args);
      }
 catch (      NoSuchMethodException e) {
        throw new DataProcessingException(""String_Node_Str"" + conversionClass.getSimpleName() + ""String_Node_Str""+ conversionClass.getName()+ ')',e);
      }
catch (      Exception e) {
        throw new DataProcessingException(""String_Node_Str"" + conversionClass.getSimpleName() + ""String_Node_Str""+ conversionClass.getName()+ ')',e);
      }
    }
    if (fieldType == String.class && (nullRead != null || nullWrite != null)) {
      return new ToStringConversion(nullRead,nullWrite);
    }
    return null;
  }
 catch (  DataProcessingException ex) {
    throw ex;
  }
catch (  Throwable ex) {
    if (field == null) {
      throw new DataProcessingException(""String_Node_Str"" + fieldType,ex);
    }
 else {
      throw new DataProcessingException(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ field.getDeclaringClass().getName(),ex);
    }
  }
}",0.9888551165146908
163317,"/** 
 * Reads the value accessible by this field mapping from a given object
 * @param instance the object whose field, mapped by this field mapping, will be read
 * @return the value contained in the given instance's field
 */
public Object read(Object instance){
  setAccessible(readMethod);
  try {
    if (readMethod != null) {
      return readMethod.invoke(instance);
    }
 else {
      return field.get(instance);
    }
  }
 catch (  Throwable e) {
    throw new DataProcessingException(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ this.beanClass.getName(),e);
  }
}","private Object read(Object instance,boolean ignoreErrors){
  setAccessible(readMethod);
  try {
    if (readMethod != null) {
      return readMethod.invoke(instance);
    }
 else {
      return field.get(instance);
    }
  }
 catch (  Throwable e) {
    if (!ignoreErrors) {
      throw new DataProcessingException(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ this.beanClass.getName(),e);
    }
  }
  return null;
}",0.6607495069033531
163318,"/** 
 * Creates the mapping and identifies how it is mapped (by name or by index)
 * @param beanClass the class that contains a the given field.
 * @param field a {@link java.lang.reflect.Field} annotated with {@link Parsed}
 * @param property the property descriptor of this field, if any. If this bean does not have getters/setters, it will be accessed directly.
 */
public FieldMapping(Class<?> beanClass,Field field,PropertyWrapper property){
  this.beanClass=beanClass;
  this.field=field;
  this.readMethod=property != null ? property.getReadMethod() : null;
  this.writeMethod=property != null ? property.getWriteMethod() : null;
  determineFieldMapping();
}","/** 
 * Creates the mapping and identifies how it is mapped (by name or by index)
 * @param beanClass the class that contains a the given field.
 * @param field a {@link java.lang.reflect.Field} annotated with {@link Parsed}
 * @param property the property descriptor of this field, if any. If this bean does not have getters/setters, it will be accessed directly.
 */
public FieldMapping(Class<?> beanClass,Field field,PropertyWrapper property){
  this.beanClass=beanClass;
  this.field=field;
  this.readMethod=property != null ? property.getReadMethod() : null;
  this.writeMethod=property != null ? property.getWriteMethod() : null;
  Class typeToSet;
  if (field != null) {
    typeToSet=field.getType();
  }
 else   if (writeMethod != null && writeMethod.getParameterTypes().length == 1) {
    typeToSet=writeMethod.getParameterTypes()[0];
  }
 else {
    typeToSet=Object.class;
  }
  primitive=typeToSet.isPrimitive();
  defaultPrimitiveValue=getDefaultPrimitiveValue(typeToSet);
  determineFieldMapping();
}",0.7911957168352172
163319,"/** 
 * Writes a value to the field of a given object instance, whose field is accessible through this field mapping.
 * @param instance the object whose field will be set
 * @param value the value to set on the given object's field.
 */
public void write(Object instance,Object value){
  setAccessible(writeMethod);
  try {
    if (writeMethod != null) {
      writeMethod.invoke(instance,value);
    }
 else {
      field.set(instance,value);
    }
  }
 catch (  Throwable e) {
    DataProcessingException ex=new DataProcessingException(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ this.beanClass.getName(),e);
    ex.setValue(value);
    ex.markAsNonFatal();
    ex.setValue(value);
    throw ex;
  }
}","/** 
 * Writes a value to the field of a given object instance, whose field is accessible through this field mapping.
 * @param instance the object whose field will be set
 * @param value the value to set on the given object's field.
 */
public void write(Object instance,Object value){
  setAccessible(writeMethod);
  try {
    if (value == null && primitive) {
      if (applyDefault == null) {
        Object currentValue=read(instance,true);
        applyDefault=defaultPrimitiveValue.equals(currentValue);
      }
      if (applyDefault == Boolean.TRUE) {
        value=defaultPrimitiveValue;
      }
 else {
        return;
      }
    }
    if (writeMethod != null) {
      writeMethod.invoke(instance,value);
    }
 else {
      field.set(instance,value);
    }
  }
 catch (  Throwable e) {
    DataProcessingException ex=new DataProcessingException(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ this.beanClass.getName(),e);
    ex.markAsNonFatal();
    ex.setValue(value);
    throw ex;
  }
}",0.7842683632157317
163320,"private void initializeConversions(String[] row,Context context){
  conversionsInitialized=true;
  this.fieldIndexes=null;
  this.fieldsReordered=false;
  this.conversionsInitialized=false;
  String[] contextHeaders=context.headers();
  if (contextHeaders != null && contextHeaders.length > 0) {
    conversions.prepareExecution(false,contextHeaders);
  }
 else {
    conversions.prepareExecution(false,row);
  }
  this.fieldIndexes=context.extractedFieldIndexes();
  this.fieldsReordered=context.columnsReordered();
}","protected void initializeConversions(String[] row,Context context){
  conversionsInitialized=true;
  this.fieldIndexes=null;
  this.fieldsReordered=false;
  this.conversionsInitialized=false;
  String[] contextHeaders=context == null ? null : context.headers();
  if (contextHeaders != null && contextHeaders.length > 0) {
    conversions.prepareExecution(false,contextHeaders);
  }
 else {
    conversions.prepareExecution(false,row);
  }
  if (context != null) {
    this.fieldIndexes=context.extractedFieldIndexes();
    this.fieldsReordered=context.columnsReordered();
  }
}",0.936131386861314
163321,"/** 
 * Identifies which fields are associated with which columns in a row.
 * @param row              A row with values for the given java bean.
 * @param headers          The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes          The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldIndexes(Context context,Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  if (headers == null) {
    headers=ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  int biggestIndex=headers.length > row.length ? headers.length : row.length;
  for (  FieldMapping mapping : parsedFields) {
    int index=mapping.getIndex();
    if (biggestIndex < index) {
      biggestIndex=index;
    }
  }
  FieldMapping[] fieldOrder=new FieldMapping[biggestIndex + 1];
  TreeSet<String> fieldsNotFound=new TreeSet<String>();
  for (  FieldMapping mapping : parsedFields) {
    if (mapping.isMappedToField()) {
      int index=ArgumentUtils.indexOf(headers,mapping.getFieldName());
      if (index == -1) {
        fieldsNotFound.add(mapping.getFieldName());
        continue;
      }
      fieldOrder[index]=mapping;
    }
 else     if (mapping.getIndex() < fieldOrder.length) {
      fieldOrder[mapping.getIndex()]=mapping;
    }
  }
  if (context != null && !fieldsNotFound.isEmpty()) {
    if (headers.length == 0) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
    }
    if (strictHeaderValidationEnabled) {
      DataProcessingException exception=new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
      exception.setValue(""String_Node_Str"",Arrays.toString(headers));
      throw exception;
    }
  }
  if (indexes != null) {
    for (int i=0; i < fieldOrder.length; i++) {
      boolean isIndexUsed=false;
      for (int j=0; j < indexes.length; j++) {
        if (indexes[j] == i) {
          isIndexUsed=true;
          break;
        }
      }
      if (!isIndexUsed) {
        fieldOrder[i]=null;
      }
    }
    if (columnsReordered) {
      FieldMapping[] newFieldOrder=new FieldMapping[indexes.length];
      for (int i=0; i < indexes.length; i++) {
        for (int j=0; j < fieldOrder.length; j++) {
          int index=indexes[i];
          if (index != -1) {
            FieldMapping field=fieldOrder[index];
            newFieldOrder[i]=field;
          }
        }
      }
      fieldOrder=newFieldOrder;
    }
  }
  this.readOrder=fieldOrder;
}","/** 
 * Identifies which fields are associated with which columns in a row.
 * @param row              A row with values for the given java bean.
 * @param headers          The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes          The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldIndexes(Context context,Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  if (headers == null) {
    headers=ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  int last=headers.length > row.length ? headers.length : row.length;
  for (  FieldMapping mapping : parsedFields) {
    int index=mapping.getIndex();
    if (last < index) {
      last=index;
    }
  }
  FieldMapping[] fieldOrder=new FieldMapping[last];
  TreeSet<String> fieldsNotFound=new TreeSet<String>();
  for (  FieldMapping mapping : parsedFields) {
    if (mapping.isMappedToField()) {
      int index=ArgumentUtils.indexOf(headers,mapping.getFieldName());
      if (index == -1) {
        fieldsNotFound.add(mapping.getFieldName());
        continue;
      }
      fieldOrder[index]=mapping;
    }
 else     if (mapping.getIndex() < fieldOrder.length) {
      fieldOrder[mapping.getIndex()]=mapping;
    }
  }
  if (context != null && !fieldsNotFound.isEmpty()) {
    if (headers.length == 0) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
    }
    if (strictHeaderValidationEnabled) {
      DataProcessingException exception=new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
      exception.setValue(""String_Node_Str"",Arrays.toString(headers));
      throw exception;
    }
  }
  if (indexes != null) {
    for (int i=0; i < fieldOrder.length; i++) {
      boolean isIndexUsed=false;
      for (int j=0; j < indexes.length; j++) {
        if (indexes[j] == i) {
          isIndexUsed=true;
          break;
        }
      }
      if (!isIndexUsed) {
        fieldOrder[i]=null;
      }
    }
    if (columnsReordered) {
      FieldMapping[] newFieldOrder=new FieldMapping[indexes.length];
      for (int i=0; i < indexes.length; i++) {
        for (int j=0; j < fieldOrder.length; j++) {
          int index=indexes[i];
          if (index != -1) {
            FieldMapping field=fieldOrder[index];
            newFieldOrder[i]=field;
          }
        }
      }
      fieldOrder=newFieldOrder;
    }
  }
  readOrder=fieldOrder;
  initializeValuesForMissing();
}",0.9287808242800484
163322,"/** 
 * Associates a conversion to a field of the java bean class.
 * @param conversion The conversion object that must be executed against the given field
 * @param mapping    the helper object that contains information about how a field is mapped.
 */
@SuppressWarnings(""String_Node_Str"") private void addConversion(Conversion conversion,FieldMapping mapping){
  if (conversion == null) {
    return;
  }
  if (mapping.isMappedToIndex()) {
    this.convertIndexes(conversion).add(mapping.getIndex());
  }
 else {
    this.convertFields(conversion).add(mapping.getFieldName());
  }
}","protected void addConversion(Conversion conversion,FieldMapping mapping){
  if (conversion == null) {
    return;
  }
  convertFields(conversion).add(mapping.getFieldName());
}",0.4578947368421052
163323,"/** 
 * Goes through a list of objects and associates each value to a particular field of a java bean instance
 * @param instance the java bean instance that is going to have its properties set
 * @param row      the values to associate with each field of the javabean.
 * @param context  information about the current parsing process.
 */
void mapValuesToFields(T instance,Object[] row,Context context){
  if (row.length > lastFieldIndexMapped) {
    this.lastFieldIndexMapped=row.length;
    mapFieldIndexes(context,row,context.headers(),context.extractedFieldIndexes(),context.columnsReordered());
  }
  int last=row.length < readOrder.length ? row.length : readOrder.length;
  for (int i=0; i < last; i++) {
    FieldMapping field=readOrder[i];
    if (field != null) {
      Object value=row[i];
      field.write(instance,value);
    }
  }
}","/** 
 * Goes through a list of objects and associates each value to a particular field of a java bean instance
 * @param instance the java bean instance that is going to have its properties set
 * @param row      the values to associate with each field of the javabean.
 * @param context  information about the current parsing process.
 */
void mapValuesToFields(T instance,Object[] row,Context context){
  if (row.length > lastFieldIndexMapped) {
    this.lastFieldIndexMapped=row.length;
    mapFieldIndexes(context,row,context.headers(),context.extractedFieldIndexes(),context.columnsReordered());
  }
  int last=row.length < readOrder.length ? row.length : readOrder.length;
  int i=0;
  for (; i < last; i++) {
    FieldMapping field=readOrder[i];
    if (field != null) {
      Object value=row[i];
      field.write(instance,value);
    }
  }
  if (missing != null) {
    for (i=0; i < missing.length; i++) {
      Object value=valuesForMissing[i];
      if (value != null) {
        FieldMapping field=missing[i];
        field.write(instance,value);
      }
    }
  }
}",0.8748051948051948
163324,"@Override public String getString(char ch,char stop,boolean trim,String nullValue){
  if (i == 0) {
    return null;
  }
  int i=this.i;
  for (; ch != stop; ch=buffer[i++]) {
    if (i >= length) {
      return null;
    }
    if (lineSeparator1 == ch && (lineSeparator2 == '\0' || lineSeparator2 == buffer[i])) {
      break;
    }
  }
  int pos=this.i - 1;
  int len=i - this.i;
  this.i=i - 1;
  if (trim) {
    i=i - 2;
    while (buffer[i--] <= ' ') {
      len--;
    }
  }
  String out;
  if (len <= 0) {
    out=nullValue;
  }
 else {
    out=new String(buffer,pos,len);
  }
  nextChar();
  return out;
}","@Override public String getString(char ch,char stop,boolean trim,String nullValue,int maxLength){
  if (i == 0) {
    return null;
  }
  int i=this.i;
  for (; ch != stop; ch=buffer[i++]) {
    if (i >= length) {
      return null;
    }
    if (lineSeparator1 == ch && (lineSeparator2 == '\0' || lineSeparator2 == buffer[i])) {
      break;
    }
  }
  int pos=this.i - 1;
  int len=i - this.i;
  if (len > maxLength) {
    return null;
  }
  this.i=i - 1;
  if (trim) {
    i=i - 2;
    while (buffer[i--] <= ' ') {
      len--;
    }
  }
  String out;
  if (len <= 0) {
    out=nullValue;
  }
 else {
    out=new String(buffer,pos,len);
  }
  nextChar();
  return out;
}",0.9533437013996888
163325,"/** 
 * Attempts to collect a   {@code String} from the current position until a stop character is found on the input,or a line ending is reached. If the  {@code String} can be obtained, the current position of the parser will be updated tothe last consumed character. If the internal buffer needs to be reloaded, this method will return  {@code null}and the current position of the buffer will remain unchanged.
 * @param ch the current character to be considered. If equal to the stop character the {@code nullValue} will be returned
 * @param stop the stop character that identifies the end of the content to be collected
 * @param trim flag indicating whether or not trailing whitespaces should be discarded
 * @param nullValue value to return when the length of the content to be returned is {@code 0}.
 * @return the {@code String} found on the input, or {@code null} if the buffer needs to reloaded.
 */
String getString(char ch,char stop,boolean trim,String nullValue);","/** 
 * Attempts to collect a   {@code String} from the current position until a stop character is found on the input,or a line ending is reached. If the  {@code String} can be obtained, the current position of the parser will be updated tothe last consumed character. If the internal buffer needs to be reloaded, this method will return  {@code null}and the current position of the buffer will remain unchanged.
 * @param ch        the current character to be considered. If equal to the stop character the {@code nullValue} will be returned
 * @param stop      the stop character that identifies the end of the content to be collected
 * @param trim      flag indicating whether or not trailing whitespaces should be discarded
 * @param nullValue value to return when the length of the content to be returned is {@code 0}.
 * @param maxLength the maximum length of the {@code String} to be returned. If the length exceeds this limit, {@code null} will be returned
 * @return the {@code String} found on the input, or {@code null} if the buffer needs to reloaded or the maximum length has been exceeded.
 */
String getString(char ch,char stop,boolean trim,String nullValue,int maxLength);",0.8522622345337026
163326,"/** 
 * Skips characters from the current input position, until a non-whitespace character, or a stop character is found
 * @param current the current character of the input
 * @param stopChar1 the first stop character (which can be a whitespace)
 * @param stopChar2 the second character (which can be a whitespace)
 * @return the first non-whitespace character (or delimiter) found in the input.
 */
char skipWhitespace(char current,char stopChar1,char stopChar2);","/** 
 * Skips characters from the current input position, until a non-whitespace character, or a stop character is found
 * @param current   the current character of the input
 * @param stopChar1 the first stop character (which can be a whitespace)
 * @param stopChar2 the second character (which can be a whitespace)
 * @return the first non-whitespace character (or delimiter) found in the input.
 */
char skipWhitespace(char current,char stopChar1,char stopChar2);",0.9978540772532188
163327,"@Override public String getString(char ch,char stop,boolean trim,String nullValue){
  return reader.getString(ch,stop,trim,nullValue);
}","@Override public String getString(char ch,char stop,boolean trim,String nullValue,int maxLength){
  return reader.getString(ch,stop,trim,nullValue,maxLength);
}",0.918918918918919
163328,"@Override protected final void parseRecord(){
  if (ch <= ' ' && ignoreLeadingWhitespace) {
    ch=input.skipWhitespace(ch,delimiter,quote);
  }
  while (ch != newLine) {
    if (ch <= ' ' && ignoreLeadingWhitespace) {
      ch=input.skipWhitespace(ch,delimiter,quote);
    }
    if (ch == delimiter || ch == newLine) {
      output.emptyParsed();
    }
 else {
      prev='\0';
      if (ch == quote) {
        output.trim=false;
        if (normalizeLineEndingsInQuotes) {
          parseQuotedValue();
        }
 else {
          input.enableNormalizeLineEndings(false);
          parseQuotedValue();
          input.enableNormalizeLineEndings(true);
        }
        output.valueParsed();
      }
 else       if (doNotEscapeUnquotedValues) {
        String value=null;
        if (output.appender.length() == 0) {
          value=input.getString(ch,delimiter,ignoreTrailingWhitespace,nullValue);
        }
        if (value != null) {
          output.valueParsed(value);
          ch=input.getChar();
        }
 else {
          output.trim=ignoreTrailingWhitespace;
          ch=output.appender.appendUntil(ch,input,delimiter,newLine);
          output.valueParsed();
        }
      }
 else {
        output.trim=ignoreTrailingWhitespace;
        parseValueProcessingEscape();
        output.valueParsed();
      }
    }
    if (ch != newLine) {
      ch=input.nextChar();
      if (ch == newLine) {
        output.emptyParsed();
      }
    }
  }
}","@Override protected final void parseRecord(){
  if (ch <= ' ' && ignoreLeadingWhitespace) {
    ch=input.skipWhitespace(ch,delimiter,quote);
  }
  while (ch != newLine) {
    if (ch <= ' ' && ignoreLeadingWhitespace) {
      ch=input.skipWhitespace(ch,delimiter,quote);
    }
    if (ch == delimiter || ch == newLine) {
      output.emptyParsed();
    }
 else {
      prev='\0';
      if (ch == quote) {
        output.trim=false;
        if (normalizeLineEndingsInQuotes) {
          parseQuotedValue();
        }
 else {
          input.enableNormalizeLineEndings(false);
          parseQuotedValue();
          input.enableNormalizeLineEndings(true);
        }
        output.valueParsed();
      }
 else       if (doNotEscapeUnquotedValues) {
        String value=null;
        if (output.appender.length() == 0) {
          value=input.getString(ch,delimiter,ignoreTrailingWhitespace,nullValue,maxColumnLength);
        }
        if (value != null) {
          output.valueParsed(value);
          ch=input.getChar();
        }
 else {
          output.trim=ignoreTrailingWhitespace;
          ch=output.appender.appendUntil(ch,input,delimiter,newLine);
          output.valueParsed();
        }
      }
 else {
        output.trim=ignoreTrailingWhitespace;
        parseValueProcessingEscape();
        output.valueParsed();
      }
    }
    if (ch != newLine) {
      ch=input.nextChar();
      if (ch == newLine) {
        output.emptyParsed();
      }
    }
  }
}",0.9945392491467576
163329,"/** 
 * The CsvParser supports all settings provided by   {@link CsvParserSettings}, and requires this configuration to be properly initialized.
 * @param settings the parser configuration
 */
public CsvParser(CsvParserSettings settings){
  super(settings);
  ignoreTrailingWhitespace=settings.getIgnoreTrailingWhitespaces();
  ignoreLeadingWhitespace=settings.getIgnoreLeadingWhitespaces();
  parseUnescapedQuotes=settings.isParseUnescapedQuotes();
  parseUnescapedQuotesUntilDelimiter=settings.isParseUnescapedQuotesUntilDelimiter();
  doNotEscapeUnquotedValues=!settings.isEscapeUnquotedValues();
  keepEscape=settings.isKeepEscapeSequences();
  keepQuotes=settings.getKeepQuotes();
  normalizeLineEndingsInQuotes=settings.isNormalizeLineEndingsWithinQuotes();
  nullValue=settings.getNullValue();
  CsvFormat format=settings.getFormat();
  delimiter=format.getDelimiter();
  quote=format.getQuote();
  quoteEscape=format.getQuoteEscape();
  escapeEscape=format.getCharToEscapeQuoteEscaping();
  newLine=format.getNormalizedNewline();
  whitespaceAppender=new ExpandingCharAppender(10,""String_Node_Str"");
  this.quoteHandling=settings.getUnescapedQuoteHandling();
  if (quoteHandling == null) {
    if (parseUnescapedQuotes) {
      if (parseUnescapedQuotesUntilDelimiter) {
        quoteHandling=STOP_AT_DELIMITER;
      }
 else {
        quoteHandling=STOP_AT_CLOSING_QUOTE;
      }
    }
 else {
      quoteHandling=RAISE_ERROR;
    }
  }
 else {
    parseUnescapedQuotesUntilDelimiter=quoteHandling == STOP_AT_DELIMITER || quoteHandling == SKIP_VALUE;
    parseUnescapedQuotes=quoteHandling != RAISE_ERROR;
  }
}","/** 
 * The CsvParser supports all settings provided by   {@link CsvParserSettings}, and requires this configuration to be properly initialized.
 * @param settings the parser configuration
 */
public CsvParser(CsvParserSettings settings){
  super(settings);
  ignoreTrailingWhitespace=settings.getIgnoreTrailingWhitespaces();
  ignoreLeadingWhitespace=settings.getIgnoreLeadingWhitespaces();
  parseUnescapedQuotes=settings.isParseUnescapedQuotes();
  parseUnescapedQuotesUntilDelimiter=settings.isParseUnescapedQuotesUntilDelimiter();
  doNotEscapeUnquotedValues=!settings.isEscapeUnquotedValues();
  keepEscape=settings.isKeepEscapeSequences();
  keepQuotes=settings.getKeepQuotes();
  normalizeLineEndingsInQuotes=settings.isNormalizeLineEndingsWithinQuotes();
  nullValue=settings.getNullValue();
  maxColumnLength=settings.getMaxCharsPerColumn();
  CsvFormat format=settings.getFormat();
  delimiter=format.getDelimiter();
  quote=format.getQuote();
  quoteEscape=format.getQuoteEscape();
  escapeEscape=format.getCharToEscapeQuoteEscaping();
  newLine=format.getNormalizedNewline();
  whitespaceAppender=new ExpandingCharAppender(10,""String_Node_Str"");
  this.quoteHandling=settings.getUnescapedQuoteHandling();
  if (quoteHandling == null) {
    if (parseUnescapedQuotes) {
      if (parseUnescapedQuotesUntilDelimiter) {
        quoteHandling=STOP_AT_DELIMITER;
      }
 else {
        quoteHandling=STOP_AT_CLOSING_QUOTE;
      }
    }
 else {
      quoteHandling=RAISE_ERROR;
    }
  }
 else {
    parseUnescapedQuotesUntilDelimiter=quoteHandling == STOP_AT_DELIMITER || quoteHandling == SKIP_VALUE;
    parseUnescapedQuotes=quoteHandling != RAISE_ERROR;
  }
}",0.9844937671024628
163330,"@Override public void markRecordStart(){
  tmp.reset();
  recordStart=i - 1;
}","@Override public void markRecordStart(){
  tmp.reset();
  recordStart=i <= 0 ? 0 : i - 1;
}",0.9230769230769232
163331,"/** 
 * Requests the next batch of characters from the implementing class and updates the character count. <p> If there are no more characters in the input, the reading will stop by invoking the   {@link AbstractCharInputReader#stop()} method.
 */
private void updateBuffer(){
  if (length - recordStart > 0 && buffer != null) {
    tmp.append(buffer,recordStart,length - recordStart);
  }
  reloadBuffer();
  charCount+=i;
  i=0;
  if (length == -1) {
    stop();
    incrementLineCount=true;
  }
  if (inputAnalysisProcesses != null) {
    try {
      for (      InputAnalysisProcess process : inputAnalysisProcesses) {
        process.execute(buffer,length);
      }
    }
  finally {
      inputAnalysisProcesses=null;
    }
  }
}","/** 
 * Requests the next batch of characters from the implementing class and updates the character count. <p> If there are no more characters in the input, the reading will stop by invoking the   {@link AbstractCharInputReader#stop()} method.
 */
private void updateBuffer(){
  if (length - recordStart > 0 && buffer != null) {
    tmp.append(buffer,recordStart,length - recordStart);
  }
  recordStart=0;
  reloadBuffer();
  charCount+=i;
  i=0;
  if (length == -1) {
    stop();
    incrementLineCount=true;
  }
  if (inputAnalysisProcesses != null) {
    try {
      for (      InputAnalysisProcess process : inputAnalysisProcesses) {
        process.execute(buffer,length);
      }
    }
  finally {
      inputAnalysisProcesses=null;
    }
  }
}",0.9885521885521884
163332,"/** 
 * Parses the next record from the input. Note that   {@link AbstractParser#beginParsing(Reader)} must have been invoked once before calling this method.If the end of the input is reached, then this method will return null. Additionally, all resources will be closed automatically at the end of the input or if any error happens while parsing.
 * @return The record parsed from the input or null if there's no more characters to read.
 */
public final String[] parseNext(){
  if (firstRecord != null) {
    String[] out=firstRecord.getValues();
    firstRecord=null;
    return out;
  }
  try {
    while (!context.isStopped()) {
      ch=input.nextChar();
      if (inComment()) {
        processComment();
        continue;
      }
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        if (recordsToRead >= 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
          if (recordsToRead == 0L) {
            stopParsing();
            return null;
          }
        }
        rowProcessed(row);
        return row;
      }
    }
    stopParsing();
    return null;
  }
 catch (  EOFException ex) {
    String[] row=handleEOF();
    stopParsing();
    return row;
  }
catch (  NullPointerException ex) {
    if (context == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
 else {
      if (input != null) {
        stopParsing();
      }
      throw new IllegalStateException(""String_Node_Str"",ex);
    }
  }
catch (  Throwable ex) {
    try {
      ex=handleException(ex);
    }
  finally {
      stopParsing(ex);
    }
  }
  return null;
}","/** 
 * Parses the next record from the input. Note that   {@link AbstractParser#beginParsing(Reader)} must have been invoked once before calling this method.If the end of the input is reached, then this method will return null. Additionally, all resources will be closed automatically at the end of the input or if any error happens while parsing.
 * @return The record parsed from the input or null if there's no more characters to read.
 */
public final String[] parseNext(){
  if (firstRecord != null) {
    String[] out=firstRecord.getValues();
    firstRecord=null;
    return out;
  }
  try {
    while (!context.isStopped()) {
      ch=input.nextChar();
      if (inComment()) {
        processComment();
        continue;
      }
      input.markRecordStart();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        if (recordsToRead >= 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
          if (recordsToRead == 0L) {
            stopParsing();
            return null;
          }
        }
        rowProcessed(row);
        return row;
      }
    }
    stopParsing();
    return null;
  }
 catch (  EOFException ex) {
    String[] row=handleEOF();
    stopParsing();
    return row;
  }
catch (  NullPointerException ex) {
    if (context == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
 else {
      if (input != null) {
        stopParsing();
      }
      throw new IllegalStateException(""String_Node_Str"",ex);
    }
  }
catch (  Throwable ex) {
    try {
      ex=handleException(ex);
    }
  finally {
      stopParsing(ex);
    }
  }
  return null;
}",0.9906032130948772
163333,"/** 
 * Parses a single line from a String in the format supported by the parser implementation.
 * @param line a line of text to be parsed
 * @return the values parsed from the input line
 */
public final String[] parseLine(String line){
  if (line == null || line.isEmpty()) {
    return null;
  }
  lineReader.setLine(line);
  if (context == null || context.isStopped()) {
    beginParsing(lineReader);
  }
 else {
    ((DefaultCharInputReader)input).reloadBuffer();
  }
  try {
    while (!context.isStopped()) {
      ch=input.nextChar();
      if (inComment()) {
        processComment();
        return null;
      }
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        rowProcessed(row);
        return row;
      }
    }
    return null;
  }
 catch (  EOFException ex) {
    return handleEOF();
  }
catch (  NullPointerException ex) {
    if (input != null) {
      stopParsing(null);
    }
    throw new IllegalStateException(""String_Node_Str"",ex);
  }
catch (  Throwable ex) {
    try {
      ex=handleException(ex);
    }
  finally {
      stopParsing(ex);
    }
  }
  return null;
}","/** 
 * Parses a single line from a String in the format supported by the parser implementation.
 * @param line a line of text to be parsed
 * @return the values parsed from the input line
 */
public final String[] parseLine(String line){
  if (line == null || line.isEmpty()) {
    return null;
  }
  lineReader.setLine(line);
  if (context == null || context.isStopped()) {
    beginParsing(lineReader);
  }
 else {
    ((DefaultCharInputReader)input).reloadBuffer();
  }
  try {
    while (!context.isStopped()) {
      ch=input.nextChar();
      if (inComment()) {
        processComment();
        return null;
      }
      input.markRecordStart();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        rowProcessed(row);
        return row;
      }
    }
    return null;
  }
 catch (  EOFException ex) {
    return handleEOF();
  }
catch (  NullPointerException ex) {
    if (input != null) {
      stopParsing(null);
    }
    throw new IllegalStateException(""String_Node_Str"",ex);
  }
catch (  Throwable ex) {
    try {
      ex=handleException(ex);
    }
  finally {
      stopParsing(ex);
    }
  }
  return null;
}",0.9865275966970882
163334,"@Override public String currentParsedContent(){
  char[] chars=output.appender.getChars();
  if (chars != null) {
    int length=output.appender.length();
    if (length > chars.length) {
      length=chars.length;
    }
    if (length > 0) {
      return new String(chars,0,length);
    }
  }
  return null;
}","@Override public String currentParsedContent(){
  if (input != null) {
    return input.currentParsedContent();
  }
  return null;
}",0.4932126696832579
163335,"private void setParsingContext(ParsingContext parsingContext){
  this.lineIndex=parsingContext == null ? -1L : parsingContext.currentLine();
  this.charIndex=parsingContext == null ? '\0' : parsingContext.currentChar();
  this.content=parsingContext == null ? null : parsingContext.currentParsedContent();
}","private void setParsingContext(ParsingContext parsingContext){
  this.lineIndex=parsingContext == null ? -1L : parsingContext.currentLine();
  this.charIndex=parsingContext == null ? '\0' : parsingContext.currentChar();
  this.content=parsingContext == null ? null : parsingContext.fieldContentOnError();
}",0.9624796084828712
163336,"/** 
 * Requests the next batch of characters from the implementing class and updates the character count. <p> If there are no more characters in the input, the reading will stop by invoking the   {@link AbstractCharInputReader#stop()} method.
 */
private void updateBuffer(){
  reloadBuffer();
  charCount+=i;
  i=0;
  if (length == -1) {
    stop();
    incrementLineCount=true;
  }
  if (inputAnalysisProcesses != null) {
    try {
      for (      InputAnalysisProcess process : inputAnalysisProcesses) {
        process.execute(buffer,length);
      }
    }
  finally {
      inputAnalysisProcesses=null;
    }
  }
}","/** 
 * Requests the next batch of characters from the implementing class and updates the character count. <p> If there are no more characters in the input, the reading will stop by invoking the   {@link AbstractCharInputReader#stop()} method.
 */
private void updateBuffer(){
  if (length - recordStart > 0 && buffer != null) {
    tmp.append(buffer,recordStart,length - recordStart);
  }
  reloadBuffer();
  charCount+=i;
  i=0;
  if (length == -1) {
    stop();
    incrementLineCount=true;
  }
  if (inputAnalysisProcesses != null) {
    try {
      for (      InputAnalysisProcess process : inputAnalysisProcesses) {
        process.execute(buffer,length);
      }
    }
  finally {
      inputAnalysisProcesses=null;
    }
  }
}",0.9166051660516604
163337,"@Override public String readComment(){
  long expectedLineCount=lineCount + 1;
  try {
    do {
      char ch=nextChar();
      if (ch <= ' ') {
        ch=skipWhitespace(ch,normalizedLineSeparator,normalizedLineSeparator);
      }
      commentBuilder.appendUntil(ch,this,normalizedLineSeparator,normalizedLineSeparator);
      if (lineCount < expectedLineCount) {
        commentBuilder.appendIgnoringWhitespace(nextChar());
      }
 else {
        commentBuilder.updateWhitespace();
        return commentBuilder.getAndReset();
      }
    }
 while (true);
  }
 catch (  EOFException ex) {
    commentBuilder.updateWhitespace();
    return commentBuilder.getAndReset();
  }
}","@Override public String readComment(){
  long expectedLineCount=lineCount + 1;
  try {
    do {
      char ch=nextChar();
      if (ch <= ' ') {
        ch=skipWhitespace(ch,normalizedLineSeparator,normalizedLineSeparator);
      }
      tmp.appendUntil(ch,this,normalizedLineSeparator,normalizedLineSeparator);
      if (lineCount < expectedLineCount) {
        tmp.appendIgnoringWhitespace(nextChar());
      }
 else {
        tmp.updateWhitespace();
        return tmp.getAndReset();
      }
    }
 while (true);
  }
 catch (  EOFException ex) {
    tmp.updateWhitespace();
    return tmp.getAndReset();
  }
}",0.9209302325581395
163338,"/** 
 * Appends the given character.
 * @param ch the character to append
 */
void append(char ch);","/** 
 * Appends characters from an input array
 * @param ch the character array
 * @param from the position of the first character in the array to be appended
 * @param length the number of characters to be appended from the given posiion.
 */
void append(char[] ch,int from,int length);",0.2435233160621761
163339,"/** 
 * Appends the contents of another DefaultCharAppender, discarding any of its trailing whitespace characters
 * @param appender The DefaultCharAppender instance got get contents from.
 */
public void append(DefaultCharAppender appender){
  System.arraycopy(appender.chars,0,this.chars,this.index,appender.index - appender.whitespaceCount);
  this.index+=appender.index - appender.whitespaceCount;
  appender.reset();
}","@Override public void append(char[] ch,int from,int length){
  System.arraycopy(ch,from,chars,index,length);
  index+=length;
}",0.3054545454545455
163340,"public final void append(DefaultCharAppender appender){
  try {
    super.append(appender);
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    expand(appender.index);
    this.append(appender);
  }
}","@Override public void append(char[] ch,int from,int length){
  if (index + length <= chars.length) {
    super.append(ch,from,length);
  }
 else {
    chars=Arrays.copyOf(chars,Math.min(((chars.length + length + index)),MAX_ARRAY_LENGTH));
    super.append(ch,from,length);
  }
}",0.212058212058212
163341,"/** 
 * Does nothing
 */
@Override public void append(char ch){
}","/** 
 * Does nothing
 */
@Override public void append(char[] ch,int from,int length){
}",0.8552631578947368
163342,"@Test(enabled=true,dataProvider=""String_Node_Str"") public void parseColumns(String csvFile,char[] lineSeparator) throws Exception {
  CsvParserSettings settings=newCsvInputSettings(lineSeparator);
  settings.setRowProcessor(processor);
  settings.setHeaderExtractionEnabled(true);
  settings.setIgnoreLeadingWhitespaces(true);
  settings.setIgnoreTrailingWhitespaces(true);
  settings.selectFields(""String_Node_Str"");
  settings.setColumnReorderingEnabled(true);
  CsvParser parser=new CsvParser(settings);
  parser.parse(newReader(csvFile));
  String[] expectedHeaders=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String[][] expectedResult=new String[][]{{""String_Node_Str"",null,null,null,null},{""String_Node_Str"",null,null,null,null},{""String_Node_Str"",null,null,null,null},{""String_Node_Str"",null,null,null,null},{null,null,null,null,null},{null,null,null,null,null},{null,null,null,null,null},{null,null,null,null,null},{""String_Node_Str"",null,null,null,null},{""String_Node_Str"",null,null,null,null},{""String_Node_Str"",null,null,null,null},{""String_Node_Str"",null,null,null,null},{null,null,null,null,null},{""String_Node_Str"",null,null,null,null},{""String_Node_Str"",null,null,null,null}};
  assertHeadersAndValuesMatch(expectedHeaders,expectedResult);
}","@Test(enabled=true,dataProvider=""String_Node_Str"") public void parseColumns(String csvFile,char[] lineSeparator) throws Exception {
  CsvParserSettings settings=newCsvInputSettings(lineSeparator);
  settings.setRowProcessor(processor);
  settings.setHeaderExtractionEnabled(true);
  settings.setIgnoreLeadingWhitespaces(true);
  settings.setIgnoreTrailingWhitespaces(true);
  settings.selectFields(""String_Node_Str"");
  settings.setColumnReorderingEnabled(false);
  CsvParser parser=new CsvParser(settings);
  parser.parse(newReader(csvFile));
  String[] expectedHeaders=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String[][] expectedResult=new String[][]{{""String_Node_Str"",null,null,null,null},{""String_Node_Str"",null,null,null,null},{""String_Node_Str"",null,null,null,null},{""String_Node_Str"",null,null,null,null},{null,null,null,null,null},{null,null,null,null,null},{null,null,null,null,null},{null,null,null,null,null},{""String_Node_Str"",null,null,null,null},{""String_Node_Str"",null,null,null,null},{""String_Node_Str"",null,null,null,null},{""String_Node_Str"",null,null,null,null},{null,null,null,null,null},{""String_Node_Str"",null,null,null,null},{""String_Node_Str"",null,null,null,null}};
  assertHeadersAndValuesMatch(expectedHeaders,expectedResult);
}",0.9973474801061007
163343,"private static boolean isCustomAnnotation(Annotation annotation){
  Class annotationType=annotation.annotationType();
  boolean isCustom=customAnnotationTypes.contains(annotationType);
  if (isCustom) {
    return false;
  }
  boolean isJavaLang=javaLangAnnotationTypes.contains(annotationType);
  if (isJavaLang) {
    return true;
  }
  isJavaLang=annotationType.getName().startsWith(""String_Node_Str"");
  if (isJavaLang) {
    javaLangAnnotationTypes.add(annotationType);
  }
 else {
    customAnnotationTypes.add(annotationType);
  }
  return isJavaLang;
}","private static boolean isCustomAnnotation(Annotation annotation){
  Class annotationType=annotation.annotationType();
  if (customAnnotationTypes.contains(annotationType)) {
    return true;
  }
  if (javaLangAnnotationTypes.contains(annotationType)) {
    return false;
  }
  if (annotationType.getName().startsWith(""String_Node_Str"")) {
    javaLangAnnotationTypes.add(annotationType);
    return false;
  }
 else {
    customAnnotationTypes.add(annotationType);
    return true;
  }
}",0.5711556829035339
163344,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private static Conversion getConversion(Class fieldType,Field field,Annotation annotation){
  try {
    Parsed parsed=field == null ? null : findAnnotation(field,Parsed.class);
    Class annType=annotation.annotationType();
    String nullRead=getNullReadValue(parsed);
    String nullWrite=getNullWriteValue(parsed);
    if (annType == NullString.class) {
      String[] nulls=((NullString)annotation).nulls();
      return Conversions.toNull(nulls);
    }
 else     if (annType == EnumOptions.class) {
      if (!fieldType.isEnum()) {
        if (field == null) {
          throw new IllegalStateException(""String_Node_Str"" + EnumOptions.class.getName() + ""String_Node_Str""+ fieldType.getName()+ ""String_Node_Str"");
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + EnumOptions.class.getName() + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ field.getType().getName()+ ""String_Node_Str"");
        }
      }
      EnumOptions enumOptions=((EnumOptions)annotation);
      String element=enumOptions.customElement().trim();
      if (element.isEmpty()) {
        element=null;
      }
      Enum nullReadValue=nullRead == null ? null : Enum.valueOf(fieldType,nullRead);
      return new EnumConversion(fieldType,nullReadValue,nullWrite,element,enumOptions.selectors());
    }
 else     if (annType == Trim.class) {
      int length=((Trim)annotation).length();
      if (length == -1) {
        return Conversions.trim();
      }
 else {
        return Conversions.trim(length);
      }
    }
 else     if (annType == LowerCase.class) {
      return Conversions.toLowerCase();
    }
 else     if (annType == UpperCase.class) {
      return Conversions.toUpperCase();
    }
 else     if (annType == Replace.class) {
      Replace replace=((Replace)annotation);
      return Conversions.replace(replace.expression(),replace.replacement());
    }
 else     if (annType == BooleanString.class) {
      if (fieldType != boolean.class && fieldType != Boolean.class) {
        if (field == null) {
          throw new DataProcessingException(""String_Node_Str"" + BooleanString.class.getName() + ""String_Node_Str""+ fieldType.getName()+ ""String_Node_Str"");
        }
 else {
          throw new DataProcessingException(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ fieldType.getName()+ ""String_Node_Str"");
        }
      }
      BooleanString boolString=((BooleanString)annotation);
      String[] falseStrings=boolString.falseStrings();
      String[] trueStrings=boolString.trueStrings();
      Boolean valueForNull=nullRead == null ? null : Boolean.valueOf(nullRead);
      if (valueForNull == null && fieldType == boolean.class) {
        valueForNull=Boolean.FALSE;
      }
      return Conversions.toBoolean(valueForNull,nullWrite,trueStrings,falseStrings);
    }
 else     if (annType == Format.class) {
      Format format=((Format)annotation);
      String[] formats=format.formats();
      Conversion conversion=null;
      if (fieldType == BigDecimal.class) {
        BigDecimal defaultForNull=nullRead == null ? null : new BigDecimal(nullRead);
        conversion=Conversions.formatToBigDecimal(defaultForNull,nullWrite,formats);
      }
 else       if (Number.class.isAssignableFrom(fieldType)) {
        conversion=Conversions.formatToNumber(formats);
        ((NumericConversion)conversion).setNumberType(fieldType);
      }
 else {
        Date dateIfNull=null;
        if (nullRead != null) {
          if (""String_Node_Str"".equalsIgnoreCase(nullRead)) {
            dateIfNull=new Date();
          }
 else {
            if (formats.length == 0) {
              throw new DataProcessingException(""String_Node_Str"");
            }
            SimpleDateFormat sdf=new SimpleDateFormat(formats[0]);
            dateIfNull=sdf.parse(nullRead);
          }
        }
        if (Date.class == fieldType) {
          conversion=Conversions.toDate(dateIfNull,nullWrite,formats);
        }
 else         if (Calendar.class == fieldType) {
          Calendar calendarIfNull=null;
          if (dateIfNull != null) {
            calendarIfNull=Calendar.getInstance();
            calendarIfNull.setTime(dateIfNull);
          }
          conversion=Conversions.toCalendar(calendarIfNull,nullWrite,formats);
        }
      }
      if (conversion != null) {
        String[] options=format.options();
        if (options.length > 0) {
          if (conversion instanceof FormattedConversion) {
            Object[] formatters=((FormattedConversion)conversion).getFormatterObjects();
            for (            Object formatter : formatters) {
              applyFormatSettings(formatter,options);
            }
          }
 else {
            throw new DataProcessingException(""String_Node_Str"" + Arrays.toString(options) + ""String_Node_Str""+ conversion.getClass()+ ""String_Node_Str""+ FormattedConversion.class);
          }
        }
        return conversion;
      }
    }
 else     if (annType == Convert.class) {
      Convert convert=((Convert)annotation);
      String[] args=convert.args();
      Class conversionClass=convert.conversionClass();
      if (!Conversion.class.isAssignableFrom(conversionClass)) {
        throw new DataProcessingException(""String_Node_Str"" + conversionClass.getSimpleName() + ""String_Node_Str""+ conversionClass.getName()+ ')');
      }
      try {
        Constructor constructor=conversionClass.getConstructor(String[].class);
        return (Conversion)constructor.newInstance((Object)args);
      }
 catch (      NoSuchMethodException e) {
        throw new DataProcessingException(""String_Node_Str"" + conversionClass.getSimpleName() + ""String_Node_Str""+ conversionClass.getName()+ ')',e);
      }
catch (      Exception e) {
        throw new DataProcessingException(""String_Node_Str"" + conversionClass.getSimpleName() + ""String_Node_Str""+ conversionClass.getName()+ ')',e);
      }
    }
    return null;
  }
 catch (  DataProcessingException ex) {
    throw ex;
  }
catch (  Throwable ex) {
    if (field == null) {
      throw new DataProcessingException(""String_Node_Str"" + fieldType,ex);
    }
 else {
      throw new DataProcessingException(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ field.getDeclaringClass().getName(),ex);
    }
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private static Conversion getConversion(Class fieldType,Field field,Annotation annotation){
  try {
    Parsed parsed=field == null ? null : findAnnotation(field,Parsed.class);
    Class annType=annotation.annotationType();
    String nullRead=getNullReadValue(parsed);
    String nullWrite=getNullWriteValue(parsed);
    if (annType == NullString.class) {
      String[] nulls=((NullString)annotation).nulls();
      return Conversions.toNull(nulls);
    }
 else     if (annType == EnumOptions.class) {
      if (!fieldType.isEnum()) {
        if (field == null) {
          throw new IllegalStateException(""String_Node_Str"" + EnumOptions.class.getName() + ""String_Node_Str""+ fieldType.getName()+ ""String_Node_Str"");
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + EnumOptions.class.getName() + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ field.getType().getName()+ ""String_Node_Str"");
        }
      }
      EnumOptions enumOptions=((EnumOptions)annotation);
      String element=enumOptions.customElement().trim();
      if (element.isEmpty()) {
        element=null;
      }
      Enum nullReadValue=nullRead == null ? null : Enum.valueOf(fieldType,nullRead);
      return new EnumConversion(fieldType,nullReadValue,nullWrite,element,enumOptions.selectors());
    }
 else     if (annType == Trim.class) {
      int length=((Trim)annotation).length();
      if (length == -1) {
        return Conversions.trim();
      }
 else {
        return Conversions.trim(length);
      }
    }
 else     if (annType == LowerCase.class) {
      return Conversions.toLowerCase();
    }
 else     if (annType == UpperCase.class) {
      return Conversions.toUpperCase();
    }
 else     if (annType == Replace.class) {
      Replace replace=((Replace)annotation);
      return Conversions.replace(replace.expression(),replace.replacement());
    }
 else     if (annType == BooleanString.class) {
      if (fieldType != boolean.class && fieldType != Boolean.class) {
        if (field == null) {
          throw new DataProcessingException(""String_Node_Str"" + BooleanString.class.getName() + ""String_Node_Str""+ fieldType.getName()+ ""String_Node_Str"");
        }
 else {
          throw new DataProcessingException(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ fieldType.getName()+ ""String_Node_Str"");
        }
      }
      BooleanString boolString=((BooleanString)annotation);
      String[] falseStrings=boolString.falseStrings();
      String[] trueStrings=boolString.trueStrings();
      Boolean valueForNull=nullRead == null ? null : BooleanConversion.getBoolean(nullRead,trueStrings,falseStrings);
      if (valueForNull == null && fieldType == boolean.class) {
        valueForNull=Boolean.FALSE;
      }
      return Conversions.toBoolean(valueForNull,nullWrite,trueStrings,falseStrings);
    }
 else     if (annType == Format.class) {
      Format format=((Format)annotation);
      String[] formats=format.formats();
      Conversion conversion=null;
      if (fieldType == BigDecimal.class) {
        BigDecimal defaultForNull=nullRead == null ? null : new BigDecimal(nullRead);
        conversion=Conversions.formatToBigDecimal(defaultForNull,nullWrite,formats);
      }
 else       if (Number.class.isAssignableFrom(fieldType)) {
        conversion=Conversions.formatToNumber(formats);
        ((NumericConversion)conversion).setNumberType(fieldType);
      }
 else {
        Date dateIfNull=null;
        if (nullRead != null) {
          if (""String_Node_Str"".equalsIgnoreCase(nullRead)) {
            dateIfNull=new Date();
          }
 else {
            if (formats.length == 0) {
              throw new DataProcessingException(""String_Node_Str"");
            }
            SimpleDateFormat sdf=new SimpleDateFormat(formats[0]);
            dateIfNull=sdf.parse(nullRead);
          }
        }
        if (Date.class == fieldType) {
          conversion=Conversions.toDate(dateIfNull,nullWrite,formats);
        }
 else         if (Calendar.class == fieldType) {
          Calendar calendarIfNull=null;
          if (dateIfNull != null) {
            calendarIfNull=Calendar.getInstance();
            calendarIfNull.setTime(dateIfNull);
          }
          conversion=Conversions.toCalendar(calendarIfNull,nullWrite,formats);
        }
      }
      if (conversion != null) {
        String[] options=format.options();
        if (options.length > 0) {
          if (conversion instanceof FormattedConversion) {
            Object[] formatters=((FormattedConversion)conversion).getFormatterObjects();
            for (            Object formatter : formatters) {
              applyFormatSettings(formatter,options);
            }
          }
 else {
            throw new DataProcessingException(""String_Node_Str"" + Arrays.toString(options) + ""String_Node_Str""+ conversion.getClass()+ ""String_Node_Str""+ FormattedConversion.class);
          }
        }
        return conversion;
      }
    }
 else     if (annType == Convert.class) {
      Convert convert=((Convert)annotation);
      String[] args=convert.args();
      Class conversionClass=convert.conversionClass();
      if (!Conversion.class.isAssignableFrom(conversionClass)) {
        throw new DataProcessingException(""String_Node_Str"" + conversionClass.getSimpleName() + ""String_Node_Str""+ conversionClass.getName()+ ')');
      }
      try {
        Constructor constructor=conversionClass.getConstructor(String[].class);
        return (Conversion)constructor.newInstance((Object)args);
      }
 catch (      NoSuchMethodException e) {
        throw new DataProcessingException(""String_Node_Str"" + conversionClass.getSimpleName() + ""String_Node_Str""+ conversionClass.getName()+ ')',e);
      }
catch (      Exception e) {
        throw new DataProcessingException(""String_Node_Str"" + conversionClass.getSimpleName() + ""String_Node_Str""+ conversionClass.getName()+ ')',e);
      }
    }
    return null;
  }
 catch (  DataProcessingException ex) {
    throw ex;
  }
catch (  Throwable ex) {
    if (field == null) {
      throw new DataProcessingException(""String_Node_Str"" + fieldType,ex);
    }
 else {
      throw new DataProcessingException(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ field.getDeclaringClass().getName(),ex);
    }
  }
}",0.9958893280632412
163345,"/** 
 * Get all indexes in the given selector and adds the conversions defined at that index to the map of conversionsByIndex. <p>This method is called in the same sequence each selector was created (in   {@link FieldConversionMapping#prepareExecution(boolean,String[])}) <p>At the end of the process, the map of conversionsByIndex will have each index with its list of conversions in the order they were declared.
 * @param writing            flag indicating whether a writing process is being initialized.
 * @param selector           the selected fields for a given conversion sequence.
 * @param conversionsByIndex map of all conversions registered to every field index, in the order they were declared
 * @param values             The field sequence that identifies how records will be organized.<p> This is generally the sequence of headers in a record, but it might be just the first parsed row from a given input (as field selection by index is allowed).
 */
public void prepareExecution(boolean writing,FieldSelector selector,Map<Integer,List<Conversion<?,?>>> conversionsByIndex,String[] values){
  if (conversionsMap == null) {
    return;
  }
  Conversion<String,?>[] conversions=conversionsMap.get(selector);
  if (conversions == null) {
    return;
  }
  if (!writing && (values == null || (conversionsMap.size() > values.length))) {
    boolean isSelectionOfNames=true;
    for (    FieldSelector expectedSelection : conversionsMap.keySet()) {
      if (!(expectedSelection instanceof FieldNameSelector || expectedSelection instanceof FieldEnumSelector)) {
        isSelectionOfNames=false;
        break;
      }
    }
    if (isSelectionOfNames && values != null) {
      int i=values.length;
      values=Arrays.copyOf(values,conversionsMap.size() + 1);
      for (      FieldSelector expectedSelection : conversionsMap.keySet()) {
        List<?> selection=((FieldSet<?>)expectedSelection).get();
        if (selection.size() == 1) {
          String selected=ArgumentUtils.normalize(selection.get(0).toString());
          if (ArgumentUtils.indexOf(values,selected) == -1) {
            values[i++]=selected;
            if (i == values.length) {
              break;
            }
          }
        }
      }
    }
  }
  int[] fieldIndexes=selector.getFieldIndexes(values);
  if (fieldIndexes == null) {
    fieldIndexes=ArgumentUtils.toIntArray(conversionsByIndex.keySet());
  }
  for (  int fieldIndex : fieldIndexes) {
    List<Conversion<?,?>> conversionsAtIndex=conversionsByIndex.get(fieldIndex);
    if (conversionsAtIndex == null) {
      conversionsAtIndex=new ArrayList<Conversion<?,?>>();
      conversionsByIndex.put(fieldIndex,conversionsAtIndex);
    }
    validateDuplicates(selector,conversionsAtIndex,conversions);
    conversionsAtIndex.addAll(Arrays.asList(conversions));
  }
}","/** 
 * Get all indexes in the given selector and adds the conversions defined at that index to the map of conversionsByIndex. <p>This method is called in the same sequence each selector was created (in   {@link FieldConversionMapping#prepareExecution(boolean,String[])}) <p>At the end of the process, the map of conversionsByIndex will have each index with its list of conversions in the order they were declared.
 * @param writing            flag indicating whether a writing process is being initialized.
 * @param selector           the selected fields for a given conversion sequence.
 * @param conversionsByIndex map of all conversions registered to every field index, in the order they were declared
 * @param values             The field sequence that identifies how records will be organized.<p> This is generally the sequence of headers in a record, but it might be just the first parsed row from a given input (as field selection by index is allowed).
 */
public void prepareExecution(boolean writing,FieldSelector selector,Map<Integer,List<Conversion<?,?>>> conversionsByIndex,String[] values){
  if (conversionsMap == null) {
    return;
  }
  Conversion<String,?>[] conversions=conversionsMap.get(selector);
  if (conversions == null) {
    return;
  }
  int[] fieldIndexes=selector.getFieldIndexes(values);
  if (fieldIndexes == null) {
    fieldIndexes=ArgumentUtils.toIntArray(conversionsByIndex.keySet());
  }
  for (  int fieldIndex : fieldIndexes) {
    List<Conversion<?,?>> conversionsAtIndex=conversionsByIndex.get(fieldIndex);
    if (conversionsAtIndex == null) {
      conversionsAtIndex=new ArrayList<Conversion<?,?>>();
      conversionsByIndex.put(fieldIndex,conversionsAtIndex);
    }
    validateDuplicates(selector,conversionsAtIndex,conversions);
    conversionsAtIndex.addAll(Arrays.asList(conversions));
  }
}",0.790907141325327
163346,"/** 
 * Creates a Conversion from String to Boolean with default values to return when the input is null. <p>The list of Strings that identify ""true"" the list of Strings that identify ""false"" are mandatory.
 * @param valueIfStringIsNull default Boolean value to be returned when the input String is null. Used when {@link ObjectConversion#execute(String)} is invoked.
 * @param valueIfObjectIsNull default String value to be returned when a Boolean input is null. Used when {@link BooleanConversion#revert(Boolean)} is invoked.
 * @param valuesForTrue Strings that identify the boolean value <i>true</i>. The first element will be returned when executing  {@code revert(true)}
 * @param valuesForFalse Strings that identify the boolean value <i>false</i>. The first element will be returned when executing {@code #revert(false)}
 */
public BooleanConversion(Boolean valueIfStringIsNull,String valueIfObjectIsNull,String[] valuesForTrue,String[] valuesForFalse){
  super(valueIfStringIsNull,valueIfObjectIsNull);
  ArgumentUtils.notEmpty(""String_Node_Str"",valuesForTrue);
  ArgumentUtils.notEmpty(""String_Node_Str"",valuesForFalse);
  Collections.addAll(falseValues,valuesForFalse);
  Collections.addAll(trueValues,valuesForTrue);
  ArgumentUtils.normalize(falseValues);
  ArgumentUtils.normalize(trueValues);
  for (  String falseValue : falseValues) {
    if (trueValues.contains(falseValue)) {
      throw new DataProcessingException(""String_Node_Str"" + falseValue + '\'');
    }
  }
  defaultForTrue=valuesForTrue[0];
  defaultForFalse=valuesForFalse[0];
}","/** 
 * Creates a Conversion from String to Boolean with default values to return when the input is null. <p>The list of Strings that identify ""true"" the list of Strings that identify ""false"" are mandatory.
 * @param valueIfStringIsNull default Boolean value to be returned when the input String is null. Used when {@link ObjectConversion#execute(String)} is invoked.
 * @param valueIfObjectIsNull default String value to be returned when a Boolean input is null. Used when {@link BooleanConversion#revert(Boolean)} is invoked.
 * @param valuesForTrue       Strings that identify the boolean value <i>true</i>. The first element will be returned when executing  {@code revert(true)}
 * @param valuesForFalse      Strings that identify the boolean value <i>false</i>. The first element will be returned when executing {@code #revert(false)}
 */
public BooleanConversion(Boolean valueIfStringIsNull,String valueIfObjectIsNull,String[] valuesForTrue,String[] valuesForFalse){
  super(valueIfStringIsNull,valueIfObjectIsNull);
  ArgumentUtils.notEmpty(""String_Node_Str"",valuesForTrue);
  ArgumentUtils.notEmpty(""String_Node_Str"",valuesForFalse);
  Collections.addAll(falseValues,valuesForFalse);
  Collections.addAll(trueValues,valuesForTrue);
  ArgumentUtils.normalize(falseValues);
  ArgumentUtils.normalize(trueValues);
  for (  String falseValue : falseValues) {
    if (trueValues.contains(falseValue)) {
      throw new DataProcessingException(""String_Node_Str"" + falseValue + '\'');
    }
  }
  defaultForTrue=valuesForTrue[0];
  defaultForFalse=valuesForFalse[0];
}",0.9964822513591302
163347,"/** 
 * Converts a String to a Boolean
 * @param input a String to be converted into a Boolean value.
 * @return true if the input String is part of {@link BooleanConversion#trueValues}, false if the input String is part of   {@link BooleanConversion#falseValues}, or   {@link BooleanConversion#getValueIfStringIsNull()} if the input String is null.
 */
@Override protected Boolean fromString(String input){
  if (input != null) {
    String normalized=ArgumentUtils.normalize(input);
    if (falseValues.contains(normalized)) {
      return Boolean.FALSE;
    }
    if (trueValues.contains(normalized)) {
      return Boolean.TRUE;
    }
    DataProcessingException exception=new DataProcessingException(""String_Node_Str"" + trueValues + ""String_Node_Str""+ falseValues+ ""String_Node_Str"");
    exception.setValue(input);
    throw exception;
  }
  return super.getValueIfStringIsNull();
}","/** 
 * Converts a String to a Boolean
 * @param input a String to be converted into a Boolean value.
 * @return true if the input String is part of {@link BooleanConversion#trueValues}, false if the input String is part of   {@link BooleanConversion#falseValues}, or   {@link BooleanConversion#getValueIfStringIsNull()} if the input String is null.
 */
@Override protected Boolean fromString(String input){
  if (input != null) {
    return getBoolean(input,trueValues,falseValues);
  }
  return super.getValueIfStringIsNull();
}",0.691114245416079
163348,"private static void invokeSetter(Object formatter,PropertyWrapper property,String value){
  Method writeMethod=property.getWriteMethod();
  if (writeMethod == null) {
    throw new DataProcessingException(""String_Node_Str"" + property.getName() + ""String_Node_Str""+ formatter.getClass()+ ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
  Class<?> parameterType=writeMethod.getParameterTypes()[0];
  Object parameterValue=null;
  if (parameterType == String.class) {
    parameterValue=value;
  }
 else   if (parameterType == Integer.class || parameterType == int.class) {
    parameterValue=Integer.parseInt(value);
  }
 else   if (parameterType == Character.class || parameterType == char.class) {
    parameterValue=value.charAt(0);
  }
 else   if (parameterType == Currency.class) {
    parameterValue=Currency.getInstance(value);
  }
 else   if (parameterType == Boolean.class) {
    parameterValue=Boolean.valueOf(value);
  }
 else   if (parameterType == TimeZone.class) {
    parameterValue=TimeZone.getTimeZone(value);
  }
 else   if (parameterType == DateFormatSymbols.class) {
    parameterValue=DateFormatSymbols.getInstance(new Locale(value));
  }
  if (parameterValue == null) {
    throw new DataProcessingException(""String_Node_Str"" + property.getName() + ""String_Node_Str""+ formatter.getClass()+ ""String_Node_Str""+ value+ ""String_Node_Str""+ parameterType);
  }
  try {
    writeMethod.invoke(formatter,parameterValue);
  }
 catch (  Throwable e) {
    throw new DataProcessingException(""String_Node_Str"" + property.getName() + ""String_Node_Str""+ formatter.getClass()+ ""String_Node_Str""+ parameterValue+ ""String_Node_Str""+ value+ ""String_Node_Str"",e);
  }
}","private static void invokeSetter(Object formatter,PropertyWrapper property,String value){
  Method writeMethod=property.getWriteMethod();
  if (writeMethod == null) {
    throw new DataProcessingException(""String_Node_Str"" + property.getName() + ""String_Node_Str""+ formatter.getClass()+ ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
  Class<?> parameterType=writeMethod.getParameterTypes()[0];
  Object parameterValue=null;
  if (parameterType == String.class) {
    parameterValue=value;
  }
 else   if (parameterType == Integer.class || parameterType == int.class) {
    parameterValue=Integer.parseInt(value);
  }
 else   if (parameterType == Character.class || parameterType == char.class) {
    parameterValue=value.charAt(0);
  }
 else   if (parameterType == Currency.class) {
    parameterValue=Currency.getInstance(value);
  }
 else   if (parameterType == Boolean.class || parameterType == boolean.class) {
    parameterValue=Boolean.valueOf(value);
  }
 else   if (parameterType == TimeZone.class) {
    parameterValue=TimeZone.getTimeZone(value);
  }
 else   if (parameterType == DateFormatSymbols.class) {
    parameterValue=DateFormatSymbols.getInstance(new Locale(value));
  }
  if (parameterValue == null) {
    throw new DataProcessingException(""String_Node_Str"" + property.getName() + ""String_Node_Str""+ formatter.getClass()+ ""String_Node_Str""+ value+ ""String_Node_Str""+ parameterType);
  }
  try {
    writeMethod.invoke(formatter,parameterValue);
  }
 catch (  Throwable e) {
    throw new DataProcessingException(""String_Node_Str"" + property.getName() + ""String_Node_Str""+ formatter.getClass()+ ""String_Node_Str""+ parameterValue+ ""String_Node_Str""+ value+ ""String_Node_Str"",e);
  }
}",0.9899348727057432
163349,"public MetaData getMetaData(int index){
  if (indexMap == null || indexMap.length < index) {
    int startFrom=0;
    int lastIndex=index;
    if (indexMap != null) {
      startFrom=indexMap.length;
      indexMap=Arrays.copyOf(indexMap,index);
    }
 else {
      String[] headers=context.headers();
      if (headers != null && lastIndex < headers.length) {
        lastIndex=headers.length;
      }
      int[] indexes=context.extractedFieldIndexes();
      if (indexes != null) {
        for (int i=0; i < indexes.length; i++) {
          if (lastIndex < indexes[i]) {
            lastIndex=indexes[i];
          }
        }
      }
      indexMap=new MetaData[lastIndex];
    }
    for (int i=startFrom; i < lastIndex; i++) {
      indexMap[i]=new MetaData(i);
    }
  }
  return indexMap[index];
}","public MetaData getMetaData(int index){
  if (indexMap == null || indexMap.length < index + 1) {
    int startFrom=0;
    int lastIndex=index;
    if (indexMap != null) {
      startFrom=indexMap.length;
      indexMap=Arrays.copyOf(indexMap,index + 1);
    }
 else {
      String[] headers=context.headers();
      if (headers != null && lastIndex < headers.length) {
        lastIndex=headers.length;
      }
      int[] indexes=context.extractedFieldIndexes();
      if (indexes != null) {
        for (int i=0; i < indexes.length; i++) {
          if (lastIndex < indexes[i]) {
            lastIndex=indexes[i];
          }
        }
      }
      indexMap=new MetaData[lastIndex + 1];
    }
    for (int i=startFrom; i < lastIndex + 1; i++) {
      indexMap[i]=new MetaData(i);
    }
  }
  return indexMap[index];
}",0.9901477832512317
163350,"private String[] handleEOF(){
  String[] row=null;
  try {
    if (output.column != 0) {
      if (output.appender.length() > 0) {
        output.valueParsed();
      }
 else {
        output.emptyParsed();
      }
      row=output.rowParsed();
    }
 else     if (output.appender.length() > 0) {
      output.valueParsed();
      row=output.rowParsed();
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw handleException(e);
  }
  if (row != null) {
    rowProcessed(row);
  }
  return row;
}","private String[] handleEOF(){
  String[] row=null;
  try {
    boolean consumeValueOnEOF=consumeValueOnEOF();
    if (output.column != 0 || consumeValueOnEOF) {
      if (output.appender.length() > 0 || consumeValueOnEOF) {
        output.valueParsed();
      }
 else {
        output.emptyParsed();
      }
      row=output.rowParsed();
    }
 else     if (output.appender.length() > 0) {
      output.valueParsed();
      row=output.rowParsed();
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw handleException(e);
  }
  if (row != null) {
    rowProcessed(row);
  }
  return row;
}",0.9161406672678089
163351,"@Override protected void parseRecord(){
  if (ch <= ' ' && ignoreLeadingWhitespace) {
    ch=input.skipWhitespace(ch);
  }
  while (ch != newLine) {
    if (ch <= ' ' && ignoreLeadingWhitespace) {
      ch=input.skipWhitespace(ch);
    }
    if (ch == delimiter) {
      output.emptyParsed();
    }
 else {
      if (ch == quote) {
        output.trim=false;
        if (normalizeLineEndingsInQuotes) {
          parseQuotedValue('\0');
        }
 else {
          input.enableNormalizeLineEndings(false);
          parseQuotedValue('\0');
          input.enableNormalizeLineEndings(true);
        }
      }
 else       if (doNotEscapeUnquotedValues) {
        output.trim=ignoreTrailingWhitespace;
        ch=input.appendUntilDelimiter(ch,output.appender);
      }
 else {
        output.trim=ignoreTrailingWhitespace;
        parseValueProcessingEscape('\0');
      }
      output.valueParsed();
    }
    if (ch != newLine) {
      ch=input.nextChar();
      if (ch == newLine) {
        output.emptyParsed();
      }
    }
  }
}","@Override protected void parseRecord(){
  if (ch <= ' ' && ignoreLeadingWhitespace) {
    ch=input.skipWhitespace(ch);
  }
  while (ch != newLine) {
    if (ch <= ' ' && ignoreLeadingWhitespace) {
      ch=input.skipWhitespace(ch);
    }
    if (ch == delimiter) {
      output.emptyParsed();
    }
 else {
      prev='\0';
      if (ch == quote) {
        output.trim=false;
        if (normalizeLineEndingsInQuotes) {
          parseQuotedValue();
        }
 else {
          input.enableNormalizeLineEndings(false);
          parseQuotedValue();
          input.enableNormalizeLineEndings(true);
        }
      }
 else       if (doNotEscapeUnquotedValues) {
        output.trim=ignoreTrailingWhitespace;
        ch=input.appendUntilDelimiter(ch,output.appender);
      }
 else {
        output.trim=ignoreTrailingWhitespace;
        parseValueProcessingEscape();
      }
      output.valueParsed();
    }
    if (ch != newLine) {
      ch=input.nextChar();
      if (ch == newLine) {
        output.emptyParsed();
      }
    }
  }
}",0.8767520541324312
163352,"private void parseValueProcessingEscape(char prev){
  while (ch != delimiter && ch != newLine) {
    if (ch != quote && ch != quoteEscape) {
      if (prev == quote) {
        handleUnescapedQuoteInValue();
        break;
      }
      output.appender.append(ch);
    }
 else     if (ch == quoteEscape && prev == escapeEscape && escapeEscape != '\0') {
      if (keepEscape) {
        output.appender.append(escapeEscape);
      }
      output.appender.append(quoteEscape);
      ch='\0';
    }
 else     if (prev == quoteEscape) {
      if (ch == quote) {
        if (keepEscape) {
          output.appender.append(quoteEscape);
        }
        output.appender.append(quote);
        ch='\0';
      }
 else {
        output.appender.append(prev);
      }
    }
 else     if (ch == quote && prev == quote) {
      output.appender.append(quote);
    }
    prev=ch;
    ch=input.nextChar();
  }
}","private void parseValueProcessingEscape(){
  while (ch != delimiter && ch != newLine) {
    if (ch != quote && ch != quoteEscape) {
      if (prev == quote) {
        handleUnescapedQuoteInValue();
        break;
      }
      output.appender.append(ch);
    }
 else     if (ch == quoteEscape && prev == escapeEscape && escapeEscape != '\0') {
      if (keepEscape) {
        output.appender.append(escapeEscape);
      }
      output.appender.append(quoteEscape);
      ch='\0';
    }
 else     if (prev == quoteEscape) {
      if (ch == quote) {
        if (keepEscape) {
          output.appender.append(quoteEscape);
        }
        output.appender.append(quote);
        ch='\0';
      }
 else {
        output.appender.append(prev);
      }
    }
 else     if (ch == quote && prev == quote) {
      output.appender.append(quote);
    }
    prev=ch;
    ch=input.nextChar();
  }
}",0.9949523275378576
163353,"private void parseQuotedValue(char prev){
  if (prev != '\0' && parseUnescapedQuotesUntilDelimiter) {
    if (quoteHandling == SKIP_VALUE) {
      skipValue();
      return;
    }
    output.appender.prepend(quote);
    ch=input.nextChar();
    output.trim=ignoreTrailingWhitespace;
    ch=input.appendUntilDelimiter(ch,output.appender);
    return;
  }
 else {
    while (true) {
      ch=input.nextChar();
      if (prev == quote && (ch <= ' ' || ch == delimiter || ch == newLine)) {
        break;
      }
      if (ch != quote && ch != quoteEscape) {
        if (prev == quote) {
          if (handleUnescapedQuote()) {
            break;
          }
 else {
            return;
          }
        }
        ch=input.appendUtilAnyEscape(ch,output.appender);
      }
 else       if (ch == quoteEscape && prev == escapeEscape && escapeEscape != '\0') {
        if (keepEscape) {
          output.appender.append(escapeEscape);
        }
        output.appender.append(quoteEscape);
        ch='\0';
      }
 else       if (prev == quoteEscape) {
        if (ch == quote) {
          if (keepEscape) {
            output.appender.append(quoteEscape);
          }
          output.appender.append(quote);
          ch='\0';
        }
 else {
          output.appender.append(prev);
        }
      }
 else       if (ch == quote && prev == quote) {
        output.appender.append(quote);
      }
      prev=ch;
    }
    if (ch != delimiter && ch != newLine && ch <= ' ') {
      whitespaceAppender.reset();
      do {
        whitespaceAppender.append(ch);
        ch=input.nextChar();
        if (ch == newLine) {
          return;
        }
      }
 while (ch <= ' ');
      if (ch != delimiter && parseUnescapedQuotes) {
        if (output.appender instanceof DefaultCharAppender) {
          output.appender.append(quote);
          ((DefaultCharAppender)output.appender).append(whitespaceAppender);
        }
        if (ch != quote && ch != quoteEscape) {
          output.appender.append(ch);
        }
        parseQuotedValue(ch);
      }
    }
    if (ch != delimiter && ch != newLine) {
      throw new TextParsingException(context,""String_Node_Str"" + ch + ""String_Node_Str""+ delimiter+ ""String_Node_Str"");
    }
  }
}","private void parseQuotedValue(){
  if (prev != '\0' && parseUnescapedQuotesUntilDelimiter) {
    if (quoteHandling == SKIP_VALUE) {
      skipValue();
      return;
    }
    output.appender.prepend(quote);
    ch=input.nextChar();
    output.trim=ignoreTrailingWhitespace;
    ch=input.appendUntilDelimiter(ch,output.appender);
    return;
  }
 else {
    while (true) {
      ch=input.nextChar();
      if (prev == quote && (ch <= ' ' || ch == delimiter || ch == newLine)) {
        break;
      }
      if (ch != quote && ch != quoteEscape) {
        if (prev == quote) {
          if (handleUnescapedQuote()) {
            break;
          }
 else {
            return;
          }
        }
        ch=input.appendUtilAnyEscape(ch,output.appender);
      }
 else       if (ch == quoteEscape && prev == escapeEscape && escapeEscape != '\0') {
        if (keepEscape) {
          output.appender.append(escapeEscape);
        }
        output.appender.append(quoteEscape);
        ch='\0';
      }
 else       if (prev == quoteEscape) {
        if (ch == quote) {
          if (keepEscape) {
            output.appender.append(quoteEscape);
          }
          output.appender.append(quote);
          ch='\0';
        }
 else {
          output.appender.append(prev);
        }
      }
 else       if (ch == quote && prev == quote) {
        output.appender.append(quote);
      }
      prev=ch;
    }
    if (ch != delimiter && ch != newLine && ch <= ' ') {
      whitespaceAppender.reset();
      do {
        whitespaceAppender.append(ch);
        ch=input.nextChar();
        if (ch == newLine) {
          return;
        }
      }
 while (ch <= ' ');
      if (ch != delimiter && parseUnescapedQuotes) {
        if (output.appender instanceof DefaultCharAppender) {
          output.appender.append(quote);
          ((DefaultCharAppender)output.appender).append(whitespaceAppender);
        }
        if (ch != quote && ch != quoteEscape) {
          output.appender.append(ch);
        }
        prev=ch;
        parseQuotedValue();
      }
    }
    if (ch != delimiter && ch != newLine) {
      throw new TextParsingException(context,""String_Node_Str"" + ch + ""String_Node_Str""+ delimiter+ ""String_Node_Str"");
    }
  }
}",0.9937304075235108
163354,"private boolean handleUnescapedQuote(){
switch (quoteHandling) {
case STOP_AT_CLOSING_QUOTE:
case STOP_AT_DELIMITER:
    output.appender.append(quote);
  output.appender.append(ch);
parseQuotedValue(ch);
return true;
default :
handleValueSkipping(true);
return false;
}
}","private boolean handleUnescapedQuote(){
switch (quoteHandling) {
case STOP_AT_CLOSING_QUOTE:
case STOP_AT_DELIMITER:
    output.appender.append(quote);
  output.appender.append(ch);
prev=ch;
parseQuotedValue();
return true;
default :
handleValueSkipping(true);
return false;
}
}",0.9799635701275046
163355,"private void handleUnescapedQuoteInValue(){
switch (quoteHandling) {
case STOP_AT_CLOSING_QUOTE:
case STOP_AT_DELIMITER:
    output.appender.append(quote);
  parseValueProcessingEscape(ch);
break;
default :
handleValueSkipping(false);
break;
}
}","private void handleUnescapedQuoteInValue(){
switch (quoteHandling) {
case STOP_AT_CLOSING_QUOTE:
case STOP_AT_DELIMITER:
    output.appender.append(quote);
  prev=ch;
parseValueProcessingEscape();
break;
default :
handleValueSkipping(false);
break;
}
}",0.977867203219316
163356,"@Test(dataProvider=""String_Node_Str"") public void testWriteBlanks(boolean quoteAllFields,String nullValue,String expectedResult){
  CsvWriterSettings s=new CsvWriterSettings();
  s.setQuoteAllFields(quoteAllFields);
  s.getFormat().setLineSeparator(""String_Node_Str"");
  s.setNullValue(nullValue);
  s.setEmptyValue(""String_Node_Str"");
  CsvWriter w=new CsvWriter(s);
  CsvParserSettings ps=new CsvParserSettings();
  ps.setNullValue(nullValue);
  ps.setEmptyValue(""String_Node_Str"");
  CsvParser p=new CsvParser(ps);
  String result=w.writeRowToString(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null);
  assertEquals(result,expectedResult);
  String[] row=p.parseLine(result);
  if (quoteAllFields) {
    assertEquals(row[0],""String_Node_Str"");
    assertEquals(row[1],""String_Node_Str"");
  }
 else {
    assertEquals(row[0],nullValue);
    assertEquals(row[1],nullValue);
  }
  assertEquals(row[2],""String_Node_Str"");
  assertEquals(row[3],""String_Node_Str"");
  assertEquals(row[4],nullValue);
}","@Test(dataProvider=""String_Node_Str"") public void testWriteBlanks(boolean quoteAllFields,String nullValue,String expectedResult){
  CsvWriterSettings s=new CsvWriterSettings();
  s.setQuoteAllFields(quoteAllFields);
  s.getFormat().setLineSeparator(""String_Node_Str"");
  s.setNullValue(nullValue);
  s.setEmptyValue(""String_Node_Str"");
  CsvWriter w=new CsvWriter(s);
  CsvParserSettings ps=new CsvParserSettings();
  ps.setNullValue(nullValue);
  ps.setEmptyValue(""String_Node_Str"");
  CsvParser p=new CsvParser(ps);
  String result=w.writeRowToString(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null);
  assertEquals(result,expectedResult);
  String[] row=p.parseLine(result);
  if (quoteAllFields) {
    assertEquals(row[0],""String_Node_Str"");
    assertEquals(row[1],""String_Node_Str"");
    assertEquals(row[4],""String_Node_Str"");
  }
 else {
    assertEquals(row[0],nullValue);
    assertEquals(row[1],nullValue);
    assertEquals(row[4],nullValue);
  }
  assertEquals(row[2],""String_Node_Str"");
  assertEquals(row[3],""String_Node_Str"");
}",0.9456625357483316
163357,"/** 
 * Format-specific implementation for writing a single record into the output. <p> The AbstractWriter handles the initialization and processing of the output until it is ready to be written (generally, reorganizing it and passing it on to a   {@link RowWriterProcessor}). <p> It then delegates the record to the writer-specific implementation defined by   {@link #processRow(Object[])}. In general, an implementation of   {@link AbstractWriter#processRow(Object[])} will perform the following steps:<ul> <li>Iterate over each object in the given input and convert it to the expected String representation.</li> <li>The conversion <b>must</b> happen using the provided  {@link AbstractWriter#appender} object. The an individual value is processed, the {@link AbstractWriter#appendValueToRow()} method must be called. This will clear the accumulated value in {@link AbstractWriter#appender} and add it to the output row.</li><li>Format specific separators and other characters must be introduced to the output row using  {@link AbstractWriter#appendToRow(char)}</li> </ul> <p> Once the   {@link #processRow(Object[])} method returns, a row will be written to the output with the processed information, and a newline will be automatically written after the given contents. The newline character sequence will conform to what is specified in {@link Format#getLineSeparator()}<p> This cycle repeats until the writing process is stopped by the user or an error happens. <p> In case of errors, the unchecked exception   {@link TextWritingException} will be thrown and all resources in use will be closed automatically. The exception should contain the cause and more information about the output state when the error happened.
 * @param row the data to be written to the output in the expected format.
 * @see com.univocity.parsers.common.input.CharAppender
 * @see com.univocity.parsers.common.CommonWriterSettings
 */
protected abstract void processRow(Object[] row);","/** 
 * Format-specific implementation for writing a single record into the output. <p> The AbstractWriter handles the initialization and processing of the output until it is ready to be written (generally, reorganizing it and passing it on to a   {@link RowWriterProcessor}). <p> It then delegates the record to the writer-specific implementation defined by   {@link #processRow(Object[])}. In general, an implementation of   {@link AbstractWriter#processRow(Object[])} will perform the following steps:<ul> <li>Iterate over each object in the given input and convert it to the expected String representation.</li> <li>The conversion <b>must</b> happen using the provided  {@link AbstractWriter#appender} object. The an individual value is processed, the {@link AbstractWriter#appendValueToRow()} method must be called.This will clear the accumulated value in  {@link AbstractWriter#appender} and add it to the output row.</li><li>Format specific separators and other characters must be introduced to the output row using  {@link AbstractWriter#appendToRow(char)}</li> </ul> <p> Once the   {@link #processRow(Object[])} method returns, a row will be written to the output with the processed information, and a newline will be automatically written after the given contents, unless this is a{@link com.univocity.parsers.fixed.FixedWidthWriter} whose {@link FixedWidthWriterSettings#getWriteLineSeparatorAfterRecord()} evaluates to {@code false}. The newline character sequence will conform to what is specified in   {@link Format#getLineSeparator()}<p> This cycle repeats until the writing process is stopped by the user or an error happens. <p> In case of errors, the unchecked exception   {@link TextWritingException} will be thrown and all resources in use will be closed automatically. The exception should contain the cause and more information about the output state when the error happened.
 * @param row the data to be written to the output in the expected format.
 * @see com.univocity.parsers.common.input.CharAppender
 * @see com.univocity.parsers.common.CommonWriterSettings
 */
protected abstract void processRow(Object[] row);",0.9573898222546872
163358,"/** 
 * Writes an empty line to the output. <p> The newline character sequence will conform to what is specified in   {@link Format#getLineSeparator()}<p> The output will remain open for further writing.
 */
public final void writeEmptyRow(){
  try {
    writer.write(lineSeparator);
  }
 catch (  Throwable ex) {
    throw throwExceptionAndClose(""String_Node_Str"",Arrays.toString(lineSeparator),ex);
  }
}","/** 
 * Writes an empty line to the output, unless this is a   {@link com.univocity.parsers.fixed.FixedWidthWriter} whose{@link FixedWidthWriterSettings#getWriteLineSeparatorAfterRecord()} evaluates to {@code false}. <p> The newline character sequence will conform to what is specified in   {@link Format#getLineSeparator()}<p> The output will remain open for further writing.
 */
public final void writeEmptyRow(){
  try {
    if (enableNewlineAfterRecord) {
      writer.write(lineSeparator);
    }
  }
 catch (  Throwable ex) {
    throw throwExceptionAndClose(""String_Node_Str"",Arrays.toString(lineSeparator),ex);
  }
}",0.6336248785228377
163359,"/** 
 * Writes a comment row to the output. <p> A newline will automatically written after the given contents. The newline character sequence will conform to what is specified in   {@link Format#getLineSeparator()}<p> The output will remain open for further writing.
 * @param comment the contents to be written as a comment to the output
 */
public final void commentRow(String comment){
  writeRow(this.comment + comment);
}","/** 
 * Writes a comment row to the output. <p> A newline will automatically written after the given contents, unless this is a  {@link com.univocity.parsers.fixed.FixedWidthWriter} whose{@link FixedWidthWriterSettings#getWriteLineSeparatorAfterRecord()} evaluates to {@code false}. The newline character sequence will conform to what is specified in   {@link Format#getLineSeparator()}<p> The output will remain open for further writing.
 * @param comment the contents to be written as a comment to the output
 */
public final void commentRow(String comment){
  writeRow(this.comment + comment);
}",0.83203125
163360,"/** 
 * Initializes the Fixed-Width writer with CSV-specific configuration
 * @param settings the Fixed-Width  writer configuration
 */
protected final void initialize(FixedWidthWriterSettings settings){
  FixedWidthFormat format=settings.getFormat();
  this.padding=format.getPadding();
  this.defaultPadding=padding;
  this.ignoreLeading=settings.getIgnoreLeadingWhitespaces();
  this.ignoreTrailing=settings.getIgnoreTrailingWhitespaces();
  this.fieldLengths=settings.getFieldLengths();
  this.fieldAlignments=settings.getFieldAlignments();
  this.fieldPaddings=settings.getFieldPaddings();
  this.lookaheadFormats=settings.getLookaheadFormats();
  this.lookbehindFormats=settings.getLookbehindFormats();
  this.defaultHeaderPadding=settings.getUseDefaultPaddingForHeaders();
  this.defaultHeaderAlignment=settings.getDefaultAlignmentForHeaders();
  if (lookaheadFormats != null || lookbehindFormats != null) {
    lookupChars=new char[Lookup.calculateMaxLookupLength(lookaheadFormats,lookbehindFormats)];
    rootLengths=fieldLengths;
    rootAlignments=fieldAlignments;
    rootPaddings=fieldPaddings;
  }
 else {
    lookupChars=null;
    rootLengths=null;
    rootAlignments=null;
    rootPaddings=null;
  }
}","/** 
 * Initializes the Fixed-Width writer with CSV-specific configuration
 * @param settings the Fixed-Width  writer configuration
 */
protected final void initialize(FixedWidthWriterSettings settings){
  FixedWidthFormat format=settings.getFormat();
  this.padding=format.getPadding();
  this.defaultPadding=padding;
  this.ignoreLeading=settings.getIgnoreLeadingWhitespaces();
  this.ignoreTrailing=settings.getIgnoreTrailingWhitespaces();
  this.fieldLengths=settings.getFieldLengths();
  this.fieldAlignments=settings.getFieldAlignments();
  this.fieldPaddings=settings.getFieldPaddings();
  this.lookaheadFormats=settings.getLookaheadFormats();
  this.lookbehindFormats=settings.getLookbehindFormats();
  this.defaultHeaderPadding=settings.getUseDefaultPaddingForHeaders();
  this.defaultHeaderAlignment=settings.getDefaultAlignmentForHeaders();
  super.enableNewlineAfterRecord(settings.getWriteLineSeparatorAfterRecord());
  if (lookaheadFormats != null || lookbehindFormats != null) {
    lookupChars=new char[Lookup.calculateMaxLookupLength(lookaheadFormats,lookbehindFormats)];
    rootLengths=fieldLengths;
    rootAlignments=fieldAlignments;
    rootPaddings=fieldPaddings;
  }
 else {
    lookupChars=null;
    rootLengths=null;
    rootAlignments=null;
    rootPaddings=null;
  }
}",0.9685634699562276
163361,"@Override protected void addConfiguration(Map<String,Object> out){
  super.addConfiguration(out);
  out.put(""String_Node_Str"",fieldLengths);
  out.put(""String_Node_Str"",lookaheadFormats);
  out.put(""String_Node_Str"",lookbehindFormats);
  out.put(""String_Node_Str"",useDefaultPaddingForHeaders);
  out.put(""String_Node_Str"",defaultAlignmentForHeaders);
}","@Override protected void addConfiguration(Map<String,Object> out){
  super.addConfiguration(out);
  out.put(""String_Node_Str"",writeLineSeparatorAfterRecord);
  out.put(""String_Node_Str"",fieldLengths);
  out.put(""String_Node_Str"",lookaheadFormats);
  out.put(""String_Node_Str"",lookbehindFormats);
  out.put(""String_Node_Str"",useDefaultPaddingForHeaders);
  out.put(""String_Node_Str"",defaultAlignmentForHeaders);
}",0.9214659685863874
163362,"private void appendAndExpand(char ch){
  try {
    chars[index++]=ch;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    expand();
    chars[index]=ch;
  }
}","private void appendAndExpand(char ch){
  try {
    chars[index++]=ch;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    expandAndRetry();
    appendAndExpand(ch);
  }
}",0.8855421686746988
163363,"private String[] handleEOF(){
  String[] row=null;
  if (output.column != 0) {
    if (output.appender.length() > 0) {
      output.valueParsed();
    }
 else {
      output.emptyParsed();
    }
    row=output.rowParsed();
  }
 else   if (output.appender.length() > 0) {
    output.valueParsed();
    row=output.rowParsed();
  }
  if (row != null) {
    rowProcessed(row);
  }
  return row;
}","private String[] handleEOF(){
  String[] row=null;
  try {
    if (output.column != 0) {
      if (output.appender.length() > 0) {
        output.valueParsed();
      }
 else {
        output.emptyParsed();
      }
      row=output.rowParsed();
    }
 else     if (output.appender.length() > 0) {
      output.valueParsed();
      row=output.rowParsed();
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw handleException(e);
  }
  if (row != null) {
    rowProcessed(row);
  }
  return row;
}",0.8288888888888889
163364,"/** 
 * Initializes the ParserOutput with the configuration specified in   {@link CommonParserSettings}
 * @param settings the parser configuration
 */
public ParserOutput(CommonParserSettings<?> settings){
  this.appender=settings.newCharAppender();
  this.parsedValues=new String[settings.getMaxColumns()];
  this.appenders=new CharAppender[settings.getMaxColumns()];
  Arrays.fill(appenders,appender);
  this.settings=settings;
  this.skipEmptyLines=settings.getSkipEmptyLines();
  this.nullValue=settings.getNullValue();
  this.columnsToExtractInitialized=false;
  this.currentRecord=0;
}","/** 
 * Initializes the ParserOutput with the configuration specified in   {@link CommonParserSettings}
 * @param settings the parser configuration
 */
public ParserOutput(CommonParserSettings<?> settings){
  this.appender=settings.newCharAppender();
  this.parsedValues=new String[settings.getMaxColumns()];
  this.appenders=new CharAppender[settings.getMaxColumns() + 1];
  Arrays.fill(appenders,appender);
  this.settings=settings;
  this.skipEmptyLines=settings.getSkipEmptyLines();
  this.nullValue=settings.getNullValue();
  this.columnsToExtractInitialized=false;
  this.currentRecord=0;
}",0.9966329966329966
163365,"private void readValue(){
  if (ignoreTrailingWhitespace) {
    if (alignment == FieldAlignment.RIGHT) {
      while (length-- > 0) {
        output.appender.appendIgnoringWhitespace(ch);
        ch=input.nextChar();
      }
    }
 else {
      while (length-- > 0) {
        output.appender.appendIgnoringWhitespaceAndPadding(ch,padding);
        ch=input.nextChar();
      }
    }
  }
 else {
    if (alignment == FieldAlignment.RIGHT) {
      while (length-- > 0) {
        output.appender.append(ch);
        ch=input.nextChar();
      }
    }
 else {
      while (length-- > 0) {
        output.appender.appendIgnoringPadding(ch,padding);
        ch=input.nextChar();
      }
    }
  }
}","private void readValue(){
  length--;
  if (ignoreTrailingWhitespace) {
    if (alignment == FieldAlignment.RIGHT) {
      output.appender.appendIgnoringWhitespace(ch);
      while (length-- > 0) {
        output.appender.appendIgnoringWhitespace(ch=input.nextChar());
      }
    }
 else {
      output.appender.appendIgnoringWhitespaceAndPadding(ch,padding);
      while (length-- > 0) {
        output.appender.appendIgnoringWhitespaceAndPadding(ch=input.nextChar(),padding);
      }
    }
  }
 else {
    if (alignment == FieldAlignment.RIGHT) {
      output.appender.append(ch);
      while (length-- > 0) {
        output.appender.append(ch=input.nextChar());
      }
    }
 else {
      output.appender.appendIgnoringPadding(ch,padding);
      while (length-- > 0) {
        output.appender.appendIgnoringPadding(ch=input.nextChar(),padding);
      }
    }
  }
}",0.5150544522741832
163366,"@Override protected void parseRecord(){
  if (ch == newLine && skipEmptyLines) {
    return;
  }
  boolean matched=false;
  if (lookaheadFormats != null || lookbehindFormats != null) {
    if (initializeLookaheadInput) {
      initializeLookaheadInput=false;
      this.lookaheadInput=new LookaheadCharInputReader(input,newLine);
      this.input=lookaheadInput;
    }
    lookaheadInput.lookahead(maxLookupLength);
    if (lookaheadFormats != null) {
      for (int i=0; i < lookaheadFormats.length; i++) {
        if (lookaheadInput.matches(ch,lookaheadFormats[i].value)) {
          lengths=lookaheadFormats[i].lengths;
          lookupFormat=lookaheadFormats[i];
          matched=true;
          break;
        }
      }
      if (lookbehindFormats != null && matched) {
        lookbehindFormat=null;
        for (int i=0; i < lookbehindFormats.length; i++) {
          if (lookaheadInput.matches(ch,lookbehindFormats[i].value)) {
            lookbehindFormat=lookbehindFormats[i];
            break;
          }
        }
      }
    }
 else {
      for (int i=0; i < lookbehindFormats.length; i++) {
        if (lookaheadInput.matches(ch,lookbehindFormats[i].value)) {
          lookbehindFormat=lookbehindFormats[i];
          matched=true;
          lengths=rootLengths;
          break;
        }
      }
    }
    if (!matched) {
      if (lookbehindFormat == null) {
        if (rootLengths == null) {
          throw new TextParsingException(context,""String_Node_Str"" + lookaheadInput.getLookahead(ch) + '\'');
        }
        lengths=rootLengths;
        alignments=rootAlignments;
        paddings=rootPaddings;
        lookupFormat=null;
      }
 else {
        lengths=lookbehindFormat.lengths;
        alignments=lookbehindFormat.alignments;
        paddings=lookbehindFormat.paddings;
        lookupFormat=lookbehindFormat;
      }
    }
  }
  int i;
  for (i=0; i < lengths.length; i++) {
    length=lengths[i];
    if (paddings != null) {
      padding=useDefaultPadding ? defaultPadding : paddings[i];
    }
    if (alignments != null) {
      alignment=alignments[i];
    }
    skipPadding();
    if (ignoreLeadingWhitespace) {
      skipWhitespace();
    }
    if (recordEndsOnNewLine) {
      readValueUntilNewLine();
      if (ch == newLine) {
        output.valueParsed();
        useDefaultPadding=false;
        return;
      }
    }
 else {
      readValue();
    }
    output.valueParsed();
  }
  if (skipToNewLine) {
    skipToNewLine();
  }
  useDefaultPadding=false;
}","@Override protected void parseRecord(){
  if (ch == newLine && skipEmptyLines) {
    return;
  }
  boolean matched=false;
  if (lookaheadFormats != null || lookbehindFormats != null) {
    if (initializeLookaheadInput) {
      initializeLookaheadInput=false;
      this.lookaheadInput=new LookaheadCharInputReader(input,newLine);
      this.input=lookaheadInput;
    }
    lookaheadInput.lookahead(maxLookupLength);
    if (lookaheadFormats != null) {
      for (int i=0; i < lookaheadFormats.length; i++) {
        if (lookaheadInput.matches(ch,lookaheadFormats[i].value)) {
          lengths=lookaheadFormats[i].lengths;
          lookupFormat=lookaheadFormats[i];
          matched=true;
          break;
        }
      }
      if (lookbehindFormats != null && matched) {
        lookbehindFormat=null;
        for (int i=0; i < lookbehindFormats.length; i++) {
          if (lookaheadInput.matches(ch,lookbehindFormats[i].value)) {
            lookbehindFormat=lookbehindFormats[i];
            break;
          }
        }
      }
    }
 else {
      for (int i=0; i < lookbehindFormats.length; i++) {
        if (lookaheadInput.matches(ch,lookbehindFormats[i].value)) {
          lookbehindFormat=lookbehindFormats[i];
          matched=true;
          lengths=rootLengths;
          break;
        }
      }
    }
    if (!matched) {
      if (lookbehindFormat == null) {
        if (rootLengths == null) {
          throw new TextParsingException(context,""String_Node_Str"" + lookaheadInput.getLookahead(ch) + '\'');
        }
        lengths=rootLengths;
        alignments=rootAlignments;
        paddings=rootPaddings;
        lookupFormat=null;
      }
 else {
        lengths=lookbehindFormat.lengths;
        alignments=lookbehindFormat.alignments;
        paddings=lookbehindFormat.paddings;
        lookupFormat=lookbehindFormat;
      }
    }
  }
  int i;
  for (i=0; i < lengths.length; i++) {
    length=lengths[i];
    if (paddings != null) {
      padding=useDefaultPadding ? defaultPadding : paddings[i];
    }
    if (alignments != null) {
      alignment=alignments[i];
    }
    skipPadding();
    if (ignoreLeadingWhitespace) {
      skipWhitespace();
    }
    if (recordEndsOnNewLine) {
      readValueUntilNewLine();
      if (ch == newLine) {
        output.valueParsed();
        useDefaultPadding=false;
        return;
      }
    }
 else     if (length > 0) {
      readValue();
      if (i + 1 < lengths.length) {
        ch=input.nextChar();
      }
    }
    output.valueParsed();
  }
  if (skipToNewLine) {
    skipToNewLine();
  }
  useDefaultPadding=false;
}",0.9817754262198708
163367,"/** 
 * Initializes the sequence of selected fields, if any.
 * @param values a sequence of values that represent the headers of the input. This can be either a parsed record or the headers as defined in {@link CommonSettings#getHeaders()}
 */
private void initializeColumnsToExtract(String[] values){
  FieldSelector selector=settings.getFieldSelector();
  if (selector != null) {
    selectedIndexes=selector.getFieldIndexes(values);
    if (selectedIndexes != null) {
      Arrays.fill(appenders,NoopCharAppender.getInstance());
      for (int i=0; i < selectedIndexes.length; i++) {
        appenders[selectedIndexes[i]]=appender;
      }
      columnsReordered=settings.isColumnReorderingEnabled();
      if (!columnsReordered && values.length < appenders.length) {
        Arrays.fill(appenders,values.length,appenders.length,appender);
      }
    }
  }
}","/** 
 * Initializes the sequence of selected fields, if any.
 * @param values a sequence of values that represent the headers of the input. This can be either a parsed record or the headers as defined in {@link CommonSettings#getHeaders()}
 */
private void initializeColumnsToExtract(String[] values){
  FieldSelector selector=settings.getFieldSelector();
  if (selector != null) {
    selectedIndexes=selector.getFieldIndexes(values);
    if (selectedIndexes != null) {
      Arrays.fill(appenders,NoopCharAppender.getInstance());
      for (int i=0; i < selectedIndexes.length; i++) {
        int index=selectedIndexes[i];
        if (index != -1) {
          appenders[index]=appender;
        }
      }
      columnsReordered=settings.isColumnReorderingEnabled();
      if (!columnsReordered && values.length < appenders.length) {
        Arrays.fill(appenders,values.length,appenders.length,appender);
      }
    }
  }
}",0.9429530201342282
163368,"/** 
 * Gets all values parsed in the   {@link ParserOutput#parsedValues} array
 * @return the sequence of parsed values in a record.
 */
public String[] rowParsed(){
  if (column > 0) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
      if (settings.isHeaderExtractionEnabled()) {
        Arrays.fill(parsedValues,null);
        column=0;
        this.appender=appenders[0];
        return null;
      }
    }
    currentRecord++;
    if (columnsReordered) {
      String[] reorderedValues=new String[selectedIndexes.length];
      for (int i=0; i < selectedIndexes.length; i++) {
        int index=selectedIndexes[i];
        if (index >= column) {
          reorderedValues[i]=nullValue;
        }
 else {
          reorderedValues[i]=parsedValues[index];
        }
      }
      column=0;
      this.appender=appenders[0];
      return reorderedValues;
    }
 else {
      String[] out=new String[column];
      System.arraycopy(parsedValues,0,out,0,column);
      column=0;
      this.appender=appenders[0];
      return out;
    }
  }
 else   if (!skipEmptyLines) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
    }
    currentRecord++;
    if (columnsReordered) {
      String[] out=new String[selectedIndexes.length];
      Arrays.fill(out,nullValue);
      return out;
    }
    return ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  return null;
}","/** 
 * Gets all values parsed in the   {@link ParserOutput#parsedValues} array
 * @return the sequence of parsed values in a record.
 */
public String[] rowParsed(){
  if (column > 0) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
      if (settings.isHeaderExtractionEnabled()) {
        Arrays.fill(parsedValues,null);
        column=0;
        this.appender=appenders[0];
        return null;
      }
    }
    currentRecord++;
    if (columnsReordered) {
      String[] reorderedValues=new String[selectedIndexes.length];
      for (int i=0; i < selectedIndexes.length; i++) {
        int index=selectedIndexes[i];
        if (index >= column || index == -1) {
          reorderedValues[i]=nullValue;
        }
 else {
          reorderedValues[i]=parsedValues[index];
        }
      }
      column=0;
      this.appender=appenders[0];
      return reorderedValues;
    }
 else {
      String[] out=new String[column];
      System.arraycopy(parsedValues,0,out,0,column);
      column=0;
      this.appender=appenders[0];
      return out;
    }
  }
 else   if (!skipEmptyLines) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
    }
    currentRecord++;
    if (columnsReordered) {
      String[] out=new String[selectedIndexes.length];
      Arrays.fill(out,nullValue);
      return out;
    }
    return ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  return null;
}",0.9946485907955762
163369,"@Override public int[] getFieldIndexes(String[] headers){
  if (headers == null) {
    return null;
  }
  headers=ArgumentUtils.normalize(headers);
  List<String> selection=this.get();
  ArgumentUtils.normalize(selection);
  String[] chosenFields=selection.toArray(new String[selection.size()]);
  Object[] unknownFields=ArgumentUtils.findMissingElements(headers,chosenFields);
  if (unknownFields.length > 0 && !selection.containsAll(Arrays.asList(headers))) {
    if (unknownFields.length == chosenFields.length) {
      return new int[0];
    }
  }
  int[] out=new int[chosenFields.length];
  int i=0;
  Set<Integer> indexesTaken=new HashSet<Integer>();
  for (  String chosenField : chosenFields) {
    int index=ArgumentUtils.indexOf(headers,chosenField);
    if (index != -1) {
      indexesTaken.add(index);
    }
    out[i++]=index;
  }
  int generatedIndex=0;
  for (i=0; i < out.length; i++) {
    if (out[i] == -1) {
      while (indexesTaken.contains(generatedIndex)) {
        generatedIndex++;
      }
      indexesTaken.add(generatedIndex);
      out[i]=generatedIndex;
    }
  }
  return out;
}","@Override public int[] getFieldIndexes(String[] headers){
  if (headers == null) {
    return null;
  }
  headers=ArgumentUtils.normalize(headers);
  List<String> selection=this.get();
  ArgumentUtils.normalize(selection);
  String[] chosenFields=selection.toArray(new String[selection.size()]);
  Object[] unknownFields=ArgumentUtils.findMissingElements(headers,chosenFields);
  if (unknownFields.length > 0 && !selection.containsAll(Arrays.asList(headers))) {
    if (unknownFields.length == chosenFields.length) {
      return new int[0];
    }
  }
  int[] out=new int[chosenFields.length];
  int i=0;
  for (  String chosenField : chosenFields) {
    out[i++]=ArgumentUtils.indexOf(headers,chosenField);
  }
  return out;
}",0.7621121393576483
163370,"/** 
 * Identifies which fields are associated with which columns in a row.
 * @param row              A row with values for the given java bean.
 * @param headers          The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes          The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldIndexes(ParsingContext context,Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  if (headers == null) {
    headers=ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  int biggestIndex=headers.length > row.length ? headers.length : row.length;
  for (  FieldMapping mapping : parsedFields) {
    int index=mapping.getIndex();
    if (biggestIndex < index) {
      biggestIndex=index;
    }
  }
  FieldMapping[] fieldOrder=new FieldMapping[biggestIndex + 1];
  TreeSet<String> fieldsNotFound=new TreeSet<String>();
  for (  FieldMapping mapping : parsedFields) {
    if (mapping.isMappedToField()) {
      int index=ArgumentUtils.indexOf(headers,mapping.getFieldName());
      if (index == -1) {
        fieldsNotFound.add(mapping.getFieldName());
        continue;
      }
      fieldOrder[index]=mapping;
    }
 else     if (mapping.getIndex() < fieldOrder.length) {
      fieldOrder[mapping.getIndex()]=mapping;
    }
  }
  if (context != null && !fieldsNotFound.isEmpty()) {
    if (headers.length == 0) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
    }
    if (strictHeaderValidationEnabled) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str""+ Arrays.toString(headers));
    }
  }
  if (indexes != null) {
    for (int i=0; i < fieldOrder.length; i++) {
      boolean isIndexUsed=false;
      for (int j=0; j < indexes.length; j++) {
        if (indexes[j] == i) {
          isIndexUsed=true;
          break;
        }
      }
      if (!isIndexUsed) {
        fieldOrder[i]=null;
      }
    }
    if (columnsReordered) {
      FieldMapping[] newFieldOrder=new FieldMapping[indexes.length];
      for (int i=0; i < indexes.length; i++) {
        for (int j=0; j < fieldOrder.length; j++) {
          int index=indexes[i];
          FieldMapping field=fieldOrder[index];
          newFieldOrder[i]=field;
        }
      }
      fieldOrder=newFieldOrder;
    }
  }
  this.readOrder=fieldOrder;
}","/** 
 * Identifies which fields are associated with which columns in a row.
 * @param row              A row with values for the given java bean.
 * @param headers          The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes          The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldIndexes(ParsingContext context,Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  if (headers == null) {
    headers=ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  int biggestIndex=headers.length > row.length ? headers.length : row.length;
  for (  FieldMapping mapping : parsedFields) {
    int index=mapping.getIndex();
    if (biggestIndex < index) {
      biggestIndex=index;
    }
  }
  FieldMapping[] fieldOrder=new FieldMapping[biggestIndex + 1];
  TreeSet<String> fieldsNotFound=new TreeSet<String>();
  for (  FieldMapping mapping : parsedFields) {
    if (mapping.isMappedToField()) {
      int index=ArgumentUtils.indexOf(headers,mapping.getFieldName());
      if (index == -1) {
        fieldsNotFound.add(mapping.getFieldName());
        continue;
      }
      fieldOrder[index]=mapping;
    }
 else     if (mapping.getIndex() < fieldOrder.length) {
      fieldOrder[mapping.getIndex()]=mapping;
    }
  }
  if (context != null && !fieldsNotFound.isEmpty()) {
    if (headers.length == 0) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
    }
    if (strictHeaderValidationEnabled) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str""+ Arrays.toString(headers));
    }
  }
  if (indexes != null) {
    for (int i=0; i < fieldOrder.length; i++) {
      boolean isIndexUsed=false;
      for (int j=0; j < indexes.length; j++) {
        if (indexes[j] == i) {
          isIndexUsed=true;
          break;
        }
      }
      if (!isIndexUsed) {
        fieldOrder[i]=null;
      }
    }
    if (columnsReordered) {
      FieldMapping[] newFieldOrder=new FieldMapping[indexes.length];
      for (int i=0; i < indexes.length; i++) {
        for (int j=0; j < fieldOrder.length; j++) {
          int index=indexes[i];
          if (index != -1) {
            FieldMapping field=fieldOrder[index];
            newFieldOrder[i]=field;
          }
        }
      }
      fieldOrder=newFieldOrder;
    }
  }
  this.readOrder=fieldOrder;
}",0.991945587972078
163371,"private void parseQuotedValue(char prev){
  ch=input.nextChar();
  while (!(prev == quote && (ch <= ' ' || ch == delimiter || ch == newLine))) {
    if (ch != quote && ch != quoteEscape) {
      if (prev == quote) {
        if (parseUnescapedQuotes) {
          output.appender.append(quote);
          output.appender.append(ch);
          parseQuotedValue(ch);
          break;
        }
 else {
          throw new TextParsingException(context,""String_Node_Str"" + quote + ""String_Node_Str"");
        }
      }
      output.appender.append(ch);
    }
 else     if (ch == quoteEscape && prev == escapeEscape && escapeEscape != '\0') {
      if (keepEscape) {
        output.appender.append(escapeEscape);
      }
      output.appender.append(quoteEscape);
      ch='\0';
    }
 else     if (prev == quoteEscape) {
      if (ch == quote) {
        if (keepEscape) {
          output.appender.append(quoteEscape);
        }
        output.appender.append(quote);
        ch='\0';
      }
 else {
        output.appender.append(prev);
      }
    }
 else     if (ch == quote && prev == quote) {
      output.appender.append(quote);
    }
    prev=ch;
    ch=input.nextChar();
  }
  if (ch != delimiter && ch != newLine && ch <= ' ') {
    whitespaceAppender.reset();
    do {
      whitespaceAppender.append(ch);
      ch=input.nextChar();
      if (ch == newLine) {
        return;
      }
    }
 while (ch <= ' ');
    if (ch != delimiter && parseUnescapedQuotes) {
      if (output.appender instanceof DefaultCharAppender) {
        output.appender.append(quote);
        ((DefaultCharAppender)output.appender).append(whitespaceAppender);
      }
      if (ch != quote && ch != quoteEscape) {
        output.appender.append(ch);
      }
      if (parseUnescapedQuotesUntilDelimiter) {
        output.appender.prepend(quote);
        ch=input.nextChar();
        parseValue();
      }
 else {
        parseQuotedValue(ch);
      }
    }
  }
  if (ch != delimiter && ch != newLine) {
    throw new TextParsingException(context,""String_Node_Str"" + ch + ""String_Node_Str""+ delimiter+ ""String_Node_Str"");
  }
}","private void parseQuotedValue(char prev){
  if (prev != '\0' && parseUnescapedQuotesUntilDelimiter) {
    output.appender.prepend(quote);
    ch=input.nextChar();
    parseValue();
    return;
  }
  ch=input.nextChar();
  while (!(prev == quote && (ch <= ' ' || ch == delimiter || ch == newLine))) {
    if (ch != quote && ch != quoteEscape) {
      if (prev == quote) {
        if (parseUnescapedQuotes) {
          output.appender.append(quote);
          output.appender.append(ch);
          parseQuotedValue(ch);
          break;
        }
 else {
          throw new TextParsingException(context,""String_Node_Str"" + quote + ""String_Node_Str"");
        }
      }
      output.appender.append(ch);
    }
 else     if (ch == quoteEscape && prev == escapeEscape && escapeEscape != '\0') {
      if (keepEscape) {
        output.appender.append(escapeEscape);
      }
      output.appender.append(quoteEscape);
      ch='\0';
    }
 else     if (prev == quoteEscape) {
      if (ch == quote) {
        if (keepEscape) {
          output.appender.append(quoteEscape);
        }
        output.appender.append(quote);
        ch='\0';
      }
 else {
        output.appender.append(prev);
      }
    }
 else     if (ch == quote && prev == quote) {
      output.appender.append(quote);
    }
    prev=ch;
    ch=input.nextChar();
  }
  if (ch != delimiter && ch != newLine && ch <= ' ') {
    whitespaceAppender.reset();
    do {
      whitespaceAppender.append(ch);
      ch=input.nextChar();
      if (ch == newLine) {
        return;
      }
    }
 while (ch <= ' ');
    if (ch != delimiter && parseUnescapedQuotes) {
      if (output.appender instanceof DefaultCharAppender) {
        output.appender.append(quote);
        ((DefaultCharAppender)output.appender).append(whitespaceAppender);
      }
      if (ch != quote && ch != quoteEscape) {
        output.appender.append(ch);
      }
      parseQuotedValue(ch);
    }
  }
  if (ch != delimiter && ch != newLine) {
    throw new TextParsingException(context,""String_Node_Str"" + ch + ""String_Node_Str""+ delimiter+ ""String_Node_Str"");
  }
}",0.5102332222751071
163372,"/** 
 * Calculates the index of a header name in relation to the original   {@link #headers} array defined in this writer
 * @param headersInContext headers currently in use (they might change).
 * @param headerName       the name of the header whose position will be identified
 * @return the position of the given header
 */
private int getFieldIndex(String[] headersInContext,String headerName){
  if (headerIndexes == null) {
    headerIndexes=new HashMap<String[],Map<String,Integer>>();
  }
  Map<String,Integer> indexes=headerIndexes.get(headersInContext);
  if (indexes == null) {
    indexes=new HashMap<String,Integer>();
    headerIndexes.put(headersInContext,indexes);
  }
  Integer index=indexes.get(headerName);
  if (index == null) {
    if (headersInContext == null) {
      throw throwExceptionAndClose(""String_Node_Str"" + headerName + ""String_Node_Str"",null);
    }
    index=ArgumentUtils.indexOf(ArgumentUtils.normalize(headersInContext),ArgumentUtils.normalize(headerName));
    if (index == -1) {
      throw throwExceptionAndClose(""String_Node_Str"" + headerName + ""String_Node_Str""+ Arrays.toString(headers)+ '.',null);
    }
    indexes.put(headerName,index);
  }
  return index;
}","/** 
 * Calculates the index of a header name in relation to the original   {@link #headers} array defined in this writer
 * @param headersInContext headers currently in use (they might change).
 * @param headerName       the name of the header whose position will be identified
 * @param ignoreOnMismatch flag indicating that if the header is not found, no exception is to be thrown, and -1 should be returned instead.
 * @return the position of the given header, or -1 if it's not found when ignoreOnMismatch is set to {@code true}
 */
private int getFieldIndex(String[] headersInContext,String headerName,boolean ignoreOnMismatch){
  if (headerIndexes == null) {
    headerIndexes=new HashMap<String[],Map<String,Integer>>();
  }
  Map<String,Integer> indexes=headerIndexes.get(headersInContext);
  if (indexes == null) {
    indexes=new HashMap<String,Integer>();
    headerIndexes.put(headersInContext,indexes);
  }
  Integer index=indexes.get(headerName);
  if (index == null) {
    if (headersInContext == null) {
      throw throwExceptionAndClose(""String_Node_Str"" + headerName + ""String_Node_Str"",null);
    }
    index=ArgumentUtils.indexOf(ArgumentUtils.normalize(headersInContext),ArgumentUtils.normalize(headerName));
    if (index == -1) {
      if (!ignoreOnMismatch) {
        throw throwExceptionAndClose(""String_Node_Str"" + headerName + ""String_Node_Str""+ Arrays.toString(headersInContext)+ '.',null);
      }
    }
    indexes.put(headerName,index);
  }
  return index;
}",0.8857566765578635
163373,"private final void addValue(String[] headersInContext,String headerName,Object value){
  addValue(getFieldIndex(headersInContext,headerName),value);
}","private final void addValue(String[] headersInContext,String headerName,boolean ignoreOnMismatch,Object value){
  int index=getFieldIndex(headersInContext,headerName,ignoreOnMismatch);
  if (index != -1) {
    addValue(index,value);
  }
}",0.5567010309278351
163374,"/** 
 * Writes values from an implementation of   {@link java.util.Map} to a partial output record, ready to bewritten to the output. Values will be stored under a column identified by the headers. If no headers are defined, the keys of the map will be used to initialize an internal header row. A map of headers can be optionally provided to assign a name to the keys of the input map. This is useful when the input map has keys will generate unwanted header names.
 * @param headerMapping an optional map associating keys of the rowData map with expected header names
 * @param rowData       the data to be written. Its keys will be used to form a header row in case no headers are available.
 * @param < K >           type of the key in both rowData and headerMapping maps.
 */
private <K>void writeValuesFromMap(Map<K,String> headerMapping,Map<K,?> rowData){
  try {
    if (rowData != null && !rowData.isEmpty()) {
      dummyHeaderRow=this.headers;
      if (usingSwitch) {
        dummyHeaderRow=((RowWriterProcessorSwitch)writerProcessor).getHeaders(headerMapping,rowData);
        if (dummyHeaderRow == null) {
          dummyHeaderRow=this.headers;
        }
      }
      if (dummyHeaderRow != null) {
        if (headerMapping == null) {
          for (          Map.Entry<?,?> e : rowData.entrySet()) {
            addValue(dummyHeaderRow,String.valueOf(e.getKey()),e.getValue());
          }
        }
 else {
          for (          Map.Entry<?,?> e : rowData.entrySet()) {
            String header=headerMapping.get(e.getKey());
            if (header != null) {
              addValue(dummyHeaderRow,header,e.getValue());
            }
          }
        }
      }
 else       if (headerMapping != null) {
        setHeadersFromMap(headerMapping,false);
        writeValuesFromMap(headerMapping,rowData);
      }
 else {
        setHeadersFromMap(rowData,true);
        writeValuesFromMap(null,rowData);
      }
    }
  }
 catch (  Throwable t) {
    throw throwExceptionAndClose(""String_Node_Str"",t);
  }
}","/** 
 * Writes values from an implementation of   {@link java.util.Map} to a partial output record, ready to bewritten to the output. Values will be stored under a column identified by the headers. If no headers are defined, the keys of the map will be used to initialize an internal header row. A map of headers can be optionally provided to assign a name to the keys of the input map. This is useful when the input map has keys will generate unwanted header names.
 * @param headerMapping an optional map associating keys of the rowData map with expected header names
 * @param rowData       the data to be written. Its keys will be used to form a header row in case no headers are available.
 * @param < K >           type of the key in both rowData and headerMapping maps.
 */
private <K>void writeValuesFromMap(Map<K,String> headerMapping,Map<K,?> rowData){
  try {
    if (rowData != null && !rowData.isEmpty()) {
      dummyHeaderRow=this.headers;
      if (usingSwitch) {
        dummyHeaderRow=((RowWriterProcessorSwitch)writerProcessor).getHeaders(headerMapping,rowData);
        if (dummyHeaderRow == null) {
          dummyHeaderRow=this.headers;
        }
      }
      if (dummyHeaderRow != null) {
        if (headerMapping == null) {
          for (          Map.Entry<?,?> e : rowData.entrySet()) {
            addValue(dummyHeaderRow,String.valueOf(e.getKey()),true,e.getValue());
          }
        }
 else {
          for (          Map.Entry<?,?> e : rowData.entrySet()) {
            String header=headerMapping.get(e.getKey());
            if (header != null) {
              addValue(dummyHeaderRow,header,true,e.getValue());
            }
          }
        }
      }
 else       if (headerMapping != null) {
        setHeadersFromMap(headerMapping,false);
        writeValuesFromMap(headerMapping,rowData);
      }
 else {
        setHeadersFromMap(rowData,true);
        writeValuesFromMap(null,rowData);
      }
    }
  }
 catch (  Throwable t) {
    throw throwExceptionAndClose(""String_Node_Str"",t);
  }
}",0.9975393700787402
163375,"/** 
 * Associates a   {@link RowWriterProcessor} implementation with an expected value to be matched in the column provided in the constructor of this class.
 * @param beanType the type of annotated java beans whose instances will be used to trigger the usage of a different format.
 */
public <T>void addSwitchForType(Class<T> beanType){
  addSwitch(new Switch(null,null,beanType));
}","/** 
 * Associates a   {@link RowWriterProcessor} implementation with an expected value to be matched in the column provided in the constructor of this class.
 * @param beanType the type of annotated java beans whose instances will be used to trigger the usage of a different format.
 * @param < T >      the type of annotated java beans whose instances will be used to trigger the usage of a different format.
 */
public <T>void addSwitchForType(Class<T> beanType){
  addSwitch(new Switch(null,null,beanType));
}",0.8587319243604005
163376,"/** 
 * Returns the CSV format detected when one of the following settings is enabled: <li> <ul>  {@link CommonParserSettings#isLineSeparatorDetectionEnabled()}</ul> <ul>  {@link CsvParserSettings#isDelimiterDetectionEnabled()}</ul> <ul>  {@link CsvParserSettings#isQuoteDetectionEnabled()}</ul> </li> The detected format will be available once the parsing process is initialized (i.e. when   {@link AbstractParser#beginParsing(Reader) runs}.
 * @return the detected CSV format, or {@code null} if no detection has been enabled or if the parsing process has not been started yet.
 */
public final CsvFormat getDetectedFormat(){
  CsvFormat out=null;
  if (settings.isDelimiterDetectionEnabled()) {
    out=settings.getFormat().clone();
    out.setDelimiter(this.delimiter);
  }
  if (settings.isQuoteDetectionEnabled()) {
    out=out == null ? settings.getFormat().clone() : out;
    out.setQuote(quote);
    out.setQuoteEscape(quoteEscape);
  }
  if (settings.isLineSeparatorDetectionEnabled()) {
    out=out == null ? settings.getFormat().clone() : out;
    out.setLineSeparator(input.getLineSeparator());
  }
  return out;
}","/** 
 * Returns the CSV format detected when one of the following settings is enabled: <ul> <li>  {@link CommonParserSettings#isLineSeparatorDetectionEnabled()}</li> <li>  {@link CsvParserSettings#isDelimiterDetectionEnabled()}</li> <li>  {@link CsvParserSettings#isQuoteDetectionEnabled()}</li> </ul> The detected format will be available once the parsing process is initialized (i.e. when   {@link AbstractParser#beginParsing(Reader) runs}.
 * @return the detected CSV format, or {@code null} if no detection has been enabled or if the parsing process has not been started yet.
 */
public final CsvFormat getDetectedFormat(){
  CsvFormat out=null;
  if (settings.isDelimiterDetectionEnabled()) {
    out=settings.getFormat().clone();
    out.setDelimiter(this.delimiter);
  }
  if (settings.isQuoteDetectionEnabled()) {
    out=out == null ? settings.getFormat().clone() : out;
    out.setQuote(quote);
    out.setQuoteEscape(quoteEscape);
  }
  if (settings.isLineSeparatorDetectionEnabled()) {
    out=out == null ? settings.getFormat().clone() : out;
    out.setLineSeparator(input.getLineSeparator());
  }
  return out;
}",0.9858030168589176
163377,"/** 
 * Creates a new instance with the mandatory characters for handling newlines transparently.
 * @param lineSeparator the sequence of characters that represent a newline, as defined in {@link Format#getLineSeparator()}
 * @param normalizedLineSeparator the normalized newline character (as defined in {@link Format#getNormalizedNewline()}) that is used to replace any lineSeparator sequence found in the input.
 */
public AbstractCharInputReader(char[] lineSeparator,char normalizedLineSeparator){
  this.detectLineSeparator=false;
  this.normalizedLineSeparator=normalizedLineSeparator;
  setLineSeparator(lineSeparator);
}","/** 
 * Creates a new instance with the mandatory characters for handling newlines transparently.
 * @param lineSeparator           the sequence of characters that represent a newline, as defined in {@link Format#getLineSeparator()}
 * @param normalizedLineSeparator the normalized newline character (as defined in {@link Format#getNormalizedNewline()}) that is used to replace any lineSeparator sequence found in the input.
 */
public AbstractCharInputReader(char[] lineSeparator,char normalizedLineSeparator){
  this.detectLineSeparator=false;
  this.normalizedLineSeparator=normalizedLineSeparator;
  setLineSeparator(lineSeparator);
}",0.9921011058451816
163378,"/** 
 * Closes the   {@link java.io.Writer} given in this class constructor.<p> An IllegalStateException will be thrown in case of any errors.
 */
public final void close(){
  try {
    this.headerIndexes=null;
    if (writer != null) {
      try {
        writer.flush();
      }
  finally {
        writer.close();
        writer=null;
      }
    }
  }
 catch (  Throwable ex) {
    throw new IllegalStateException(""String_Node_Str"",ex);
  }
  if (this.partialLineIndex != 0) {
    throw new TextWritingException(""String_Node_Str"" + ""String_Node_Str"",recordCount,Arrays.copyOf(partialLine,partialLineIndex));
  }
}","/** 
 * Closes the   {@link java.io.Writer} given in this class constructor.<p> An IllegalStateException will be thrown in case of any errors.
 */
public final void close(){
  try {
    this.headerIndexes=null;
    if (writer != null) {
      writer.close();
      writer=null;
    }
  }
 catch (  Throwable ex) {
    throw new IllegalStateException(""String_Node_Str"",ex);
  }
  if (this.partialLineIndex != 0) {
    throw new TextWritingException(""String_Node_Str"" + ""String_Node_Str"",recordCount,Arrays.copyOf(partialLine,partialLineIndex));
  }
}",0.8867924528301887
163379,"private void parseQuotedValue(char prev){
  ch=input.nextChar();
  while (!(prev == quote && (ch <= ' ' || ch == delimiter || ch == newLine))) {
    if (ch != quote && ch != quoteEscape) {
      if (prev == quote) {
        if (parseUnescapedQuotes) {
          output.appender.append(quote);
          output.appender.append(ch);
          parseQuotedValue(ch);
          break;
        }
 else {
          throw new TextParsingException(context,""String_Node_Str"" + quote + ""String_Node_Str"");
        }
      }
      output.appender.append(ch);
      prev=ch;
    }
 else     if (ch == quoteEscape && prev == escapeEscape && escapeEscape != '\0') {
      if (keepEscape) {
        output.appender.append(escapeEscape);
      }
      output.appender.append(quoteEscape);
      prev='\0';
    }
 else     if (prev == quoteEscape) {
      if (ch == quote) {
        if (keepEscape) {
          output.appender.append(quoteEscape);
        }
        output.appender.append(quote);
        prev='\0';
      }
 else {
        output.appender.append(prev);
      }
    }
 else {
      prev=ch;
    }
    ch=input.nextChar();
  }
  if (ch != delimiter && ch != newLine && ch <= ' ') {
    whitespaceAppender.reset();
    do {
      whitespaceAppender.append(ch);
      ch=input.nextChar();
      if (ch == newLine) {
        return;
      }
    }
 while (ch <= ' ');
    if (ch != delimiter && parseUnescapedQuotes) {
      if (output.appender instanceof DefaultCharAppender) {
        output.appender.append(quote);
        ((DefaultCharAppender)output.appender).append(whitespaceAppender);
      }
      if (ch != quoteEscape) {
        output.appender.append(ch);
      }
      parseQuotedValue(ch);
    }
  }
  if (ch != delimiter && ch != newLine) {
    throw new TextParsingException(context,""String_Node_Str"" + ch + ""String_Node_Str""+ delimiter+ ""String_Node_Str"");
  }
}","private void parseQuotedValue(char prev){
  ch=input.nextChar();
  while (!(prev == quote && (ch <= ' ' || ch == delimiter || ch == newLine))) {
    if (ch != quote && ch != quoteEscape) {
      if (prev == quote) {
        if (parseUnescapedQuotes) {
          output.appender.append(quote);
          output.appender.append(ch);
          parseQuotedValue(ch);
          break;
        }
 else {
          throw new TextParsingException(context,""String_Node_Str"" + quote + ""String_Node_Str"");
        }
      }
      output.appender.append(ch);
      prev=ch;
    }
 else     if (ch == quoteEscape && prev == escapeEscape && escapeEscape != '\0') {
      if (keepEscape) {
        output.appender.append(escapeEscape);
      }
      output.appender.append(quoteEscape);
      prev='\0';
    }
 else     if (prev == quoteEscape) {
      if (ch == quote) {
        if (keepEscape) {
          output.appender.append(quoteEscape);
        }
        output.appender.append(quote);
        prev='\0';
      }
 else {
        output.appender.append(prev);
      }
    }
 else     if (ch == quote && prev == quote) {
      output.appender.append(quote);
    }
 else {
      prev=ch;
    }
    ch=input.nextChar();
  }
  if (ch != delimiter && ch != newLine && ch <= ' ') {
    whitespaceAppender.reset();
    do {
      whitespaceAppender.append(ch);
      ch=input.nextChar();
      if (ch == newLine) {
        return;
      }
    }
 while (ch <= ' ');
    if (ch != delimiter && parseUnescapedQuotes) {
      if (output.appender instanceof DefaultCharAppender) {
        output.appender.append(quote);
        ((DefaultCharAppender)output.appender).append(whitespaceAppender);
      }
      if (ch != quote && ch != quoteEscape) {
        output.appender.append(ch);
      }
      parseQuotedValue(ch);
    }
  }
  if (ch != delimiter && ch != newLine) {
    throw new TextParsingException(context,""String_Node_Str"" + ch + ""String_Node_Str""+ delimiter+ ""String_Node_Str"");
  }
}",0.9397089397089398
163380,"/** 
 * {@inheritDoc}
 */
@Override public final char nextChar(){
  if (length == -1) {
    throwEOFException();
  }
  char ch=buffer[i - 1];
  if (i >= length) {
    updateBuffer();
  }
  i++;
  if (lineSeparator1 == ch && (lineSeparator2 == '\0' || length != -1 && lineSeparator2 == buffer[i - 1])) {
    lineCount++;
    if (lineSeparator2 != '\0') {
      ch=normalizedLineSeparator;
      if (i >= length) {
        if (length != -1) {
          updateBuffer();
        }
 else {
          throwEOFException();
        }
      }
      if (i < length) {
        i++;
      }
    }
 else {
      return normalizedLineSeparator;
    }
  }
  return ch;
}","/** 
 * {@inheritDoc}
 */
@Override public final char nextChar(){
  if (length == -1) {
    throwEOFException();
  }
  char ch=buffer[i - 1];
  if (i >= length) {
    updateBuffer();
  }
  i++;
  if (lineSeparator1 == ch && (lineSeparator2 == '\0' || length != -1 && lineSeparator2 == buffer[i - 1])) {
    lineCount++;
    if (normalizeLineEndings) {
      if (lineSeparator2 != '\0') {
        ch=normalizedLineSeparator;
        if (i >= length) {
          if (length != -1) {
            updateBuffer();
          }
 else {
            throwEOFException();
          }
        }
        i++;
      }
 else {
        return normalizedLineSeparator;
      }
    }
  }
  return ch;
}",0.8895522388059701
163381,"/** 
 * Appends the given character and marks it as ignored if it is a whitespace (  {@code ch <= ' '}) or a padding character (depends on the character given as the value for the   {@link DefaultCharAppender#padding} attribute in the constructor)<p>If the given character is equal to  {@link Format#getNormalizedNewline()}, then the character sequence returned by   {@link Format#getLineSeparator()} is going to be appended.
 * @param ch character to append
 */
@Override public void appendIgnoringWhitespaceAndPadding(char ch){
  try {
    if (ch == newLine) {
      super.appendIgnoringWhitespaceAndPadding(lineSeparator1);
      if (lineSeparator2 != '\0') {
        super.appendIgnoringWhitespaceAndPadding(lineSeparator2);
      }
    }
 else {
      super.appendIgnoringWhitespaceAndPadding(ch);
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    expandAndRetry();
    appendIgnoringPadding(ch);
  }
}","/** 
 * Appends the given character and marks it as ignored if it is a whitespace (  {@code ch <= ' '}) or a padding character (depends on the character given as the value for the   {@link DefaultCharAppender#padding} attribute in the constructor)<p/> <p>If the given character is equal to  {@link Format#getNormalizedNewline()}, then the character sequence returned by   {@link Format#getLineSeparator()} is going to be appended.
 * @param ch character to append
 */
@Override public void appendIgnoringWhitespaceAndPadding(char ch){
  try {
    if (ch == newLine && denormalizeLineEndings) {
      super.appendIgnoringWhitespaceAndPadding(lineSeparator1);
      if (lineSeparator2 != '\0') {
        super.appendIgnoringWhitespaceAndPadding(lineSeparator2);
      }
    }
 else {
      super.appendIgnoringWhitespaceAndPadding(ch);
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    expandAndRetry();
    appendIgnoringPadding(ch);
  }
}",0.9833780160857908
163382,"/** 
 * Appends the given character and marks it as ignored if it is a whitespace (  {@code ch <= ' '}) <p>If the given character is equal to   {@link Format#getNormalizedNewline()}, then the character sequence returned by   {@link Format#getLineSeparator()} is going to be appended.
 * @param ch character to append
 */
@Override public void appendIgnoringWhitespace(char ch){
  try {
    if (ch == newLine) {
      super.appendIgnoringWhitespace(lineSeparator1);
      if (lineSeparator2 != '\0') {
        super.appendIgnoringWhitespace(lineSeparator2);
      }
    }
 else {
      super.appendIgnoringWhitespace(ch);
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    expandAndRetry();
    appendIgnoringPadding(ch);
  }
}","/** 
 * Appends the given character and marks it as ignored if it is a whitespace (  {@code ch <= ' '}) <p/> <p>If the given character is equal to   {@link Format#getNormalizedNewline()}, then the character sequence returned by   {@link Format#getLineSeparator()} is going to be appended.
 * @param ch character to append
 */
@Override public void appendIgnoringWhitespace(char ch){
  try {
    if (ch == newLine && denormalizeLineEndings) {
      super.appendIgnoringWhitespace(lineSeparator1);
      if (lineSeparator2 != '\0') {
        super.appendIgnoringWhitespace(lineSeparator2);
      }
    }
 else {
      super.appendIgnoringWhitespace(ch);
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    expandAndRetry();
    appendIgnoringPadding(ch);
  }
}",0.9793471019320452
163383,"/** 
 * Appends the given character and marks it as ignored if it is a padding character (depends on the character given as the value for the   {@link WriterCharAppender#padding} attribute in the constructor)<p>If the given character is equal to  {@link Format#getNormalizedNewline()}, then the character sequence returned by   {@link Format#getLineSeparator()} is going to be appended.
 * @param ch character to append
 */
@Override public void appendIgnoringPadding(char ch){
  try {
    if (ch == newLine) {
      super.appendIgnoringPadding(lineSeparator1);
      if (lineSeparator2 != '\0') {
        super.appendIgnoringPadding(lineSeparator2);
      }
    }
 else {
      super.appendIgnoringPadding(ch);
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    expandAndRetry();
    appendIgnoringPadding(ch);
  }
}","/** 
 * Appends the given character and marks it as ignored if it is a padding character (depends on the character given as the value for the   {@link WriterCharAppender#padding} attribute in the constructor)<p/> <p>If the given character is equal to  {@link Format#getNormalizedNewline()}, then the character sequence returned by   {@link Format#getLineSeparator()} is going to be appended.
 * @param ch character to append
 */
@Override public void appendIgnoringPadding(char ch){
  try {
    if (ch == newLine && denormalizeLineEndings) {
      super.appendIgnoringPadding(lineSeparator1);
      if (lineSeparator2 != '\0') {
        super.appendIgnoringPadding(lineSeparator2);
      }
    }
 else {
      super.appendIgnoringPadding(ch);
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    expandAndRetry();
    appendIgnoringPadding(ch);
  }
}",0.9815805109922756
163384,"/** 
 * Creates a WriterCharAppender with: <ul> <li>a maximum limit of characters to append</li> <li>the default value to return when no characters have been accumulated.</li> <li>the basic   {@link Format} specification for handling newlines</li></ul> The padding character is defaulted to a whitespace character ' '.
 * @param maxLength  maximum limit of characters to append
 * @param emptyValue default value to return when no characters have been accumulated
 * @param padding    the padding character to ignore when calling {@link WriterCharAppender#appendIgnoringWhitespaceAndPadding(char)}.
 * @param format     the output format specification used for newline handling
 */
public WriterCharAppender(int maxLength,String emptyValue,char padding,Format format){
  super(maxLength,emptyValue,padding);
  char[] lineSeparator=format.getLineSeparator();
  this.lineSeparator1=lineSeparator[0];
  this.lineSeparator2=lineSeparator.length > 1 ? lineSeparator[1] : '\0';
  newLine=format.getNormalizedNewline();
}","/** 
 * Creates a WriterCharAppender with: <ul> <li>a maximum limit of characters to append</li> <li>the default value to return when no characters have been accumulated.</li> <li>the basic   {@link Format} specification for handling newlines</li></ul> <p/> The padding character is defaulted to a whitespace character ' '.
 * @param maxLength  maximum limit of characters to append
 * @param emptyValue default value to return when no characters have been accumulated
 * @param padding    the padding character to ignore when calling {@link WriterCharAppender#appendIgnoringWhitespaceAndPadding(char)}.
 * @param format     the output format specification used for newline handling
 */
public WriterCharAppender(int maxLength,String emptyValue,char padding,Format format){
  super(maxLength,emptyValue,padding);
  char[] lineSeparator=format.getLineSeparator();
  this.lineSeparator1=lineSeparator[0];
  this.lineSeparator2=lineSeparator.length > 1 ? lineSeparator[1] : '\0';
  newLine=format.getNormalizedNewline();
}",0.9975405804230202
163385,"Annotation buildBooleanStringAnnotation(final String[] trueStrings,final String[] falseStrings){
  return new com.univocity.parsers.annotations.BooleanString(){
    @Override public String[] trueStrings(){
      return trueStrings == null ? ArgumentUtils.EMPTY_STRING_ARRAY : trueStrings;
    }
    @Override public String[] falseStrings(){
      return falseStrings == null ? ArgumentUtils.EMPTY_STRING_ARRAY : falseStrings;
    }
    @Override public Class<? extends Annotation> annotationType(){
      return com.univocity.parsers.annotations.BooleanString.class;
    }
  }
;
}","static Annotation buildBooleanStringAnnotation(final String[] trueStrings,final String[] falseStrings){
  return new com.univocity.parsers.annotations.BooleanString(){
    @Override public String[] trueStrings(){
      return trueStrings == null ? ArgumentUtils.EMPTY_STRING_ARRAY : trueStrings;
    }
    @Override public String[] falseStrings(){
      return falseStrings == null ? ArgumentUtils.EMPTY_STRING_ARRAY : falseStrings;
    }
    @Override public Class<? extends Annotation> annotationType(){
      return com.univocity.parsers.annotations.BooleanString.class;
    }
  }
;
}",0.9940017137960584
163386,"private Annotation newFormatAnnotation(final String format,final String... formatOptions){
  return new com.univocity.parsers.annotations.Format(){
    @Override public String[] formats(){
      return new String[]{format};
    }
    @Override public String[] options(){
      return formatOptions;
    }
    @Override public Class<? extends Annotation> annotationType(){
      return com.univocity.parsers.annotations.Format.class;
    }
  }
;
}","private static Annotation newFormatAnnotation(final String format,final String... formatOptions){
  return new com.univocity.parsers.annotations.Format(){
    @Override public String[] formats(){
      return new String[]{format};
    }
    @Override public String[] options(){
      return formatOptions;
    }
    @Override public Class<? extends Annotation> annotationType(){
      return com.univocity.parsers.annotations.Format.class;
    }
  }
;
}",0.9922135706340378
163387,"private void parseField(){
  if (ch <= ' ' && ignoreLeadingWhitespace) {
    skipWhitespace();
  }
  if (ch == delimiter) {
    output.emptyParsed();
  }
 else {
    if (ch == quote) {
      parseQuotedValue('\0');
    }
 else     if (doNotEscapeUnquotedValues) {
      parseValue();
    }
 else {
      parseValueProcessingEscape();
    }
    output.valueParsed();
  }
}","private void parseField(){
  if (ch <= ' ' && ignoreLeadingWhitespace) {
    skipWhitespace();
  }
  if (ch == delimiter) {
    output.emptyParsed();
  }
 else {
    if (ch == quote) {
      if (normalizeLineEndingsInQuotes) {
        parseQuotedValue('\0');
      }
 else {
        input.enableNormalizeLineEndings(false);
        parseQuotedValue('\0');
        input.enableNormalizeLineEndings(true);
      }
    }
 else     if (doNotEscapeUnquotedValues) {
      parseValue();
    }
 else {
      parseValueProcessingEscape();
    }
    output.valueParsed();
  }
}",0.7902023429179978
163388,"/** 
 * The CsvParser supports all settings provided by   {@link CsvParserSettings}, and requires this configuration to be properly initialized.
 * @param settings the parser configuration
 */
public CsvParser(CsvParserSettings settings){
  super(settings);
  ignoreTrailingWhitespace=settings.getIgnoreTrailingWhitespaces();
  ignoreLeadingWhitespace=settings.getIgnoreLeadingWhitespaces();
  parseUnescapedQuotes=settings.isParseUnescapedQuotes();
  doNotEscapeUnquotedValues=!settings.isEscapeUnquotedValues();
  keepEscape=settings.isKeepEscapeSequences();
  CsvFormat format=settings.getFormat();
  delimiter=format.getDelimiter();
  quote=format.getQuote();
  quoteEscape=format.getQuoteEscape();
  escapeEscape=format.getCharToEscapeQuoteEscaping();
  newLine=format.getNormalizedNewline();
  whitespaceAppender=new DefaultCharAppender(settings.getMaxCharsPerColumn(),""String_Node_Str"");
}","/** 
 * The CsvParser supports all settings provided by   {@link CsvParserSettings}, and requires this configuration to be properly initialized.
 * @param settings the parser configuration
 */
public CsvParser(CsvParserSettings settings){
  super(settings);
  ignoreTrailingWhitespace=settings.getIgnoreTrailingWhitespaces();
  ignoreLeadingWhitespace=settings.getIgnoreLeadingWhitespaces();
  parseUnescapedQuotes=settings.isParseUnescapedQuotes();
  doNotEscapeUnquotedValues=!settings.isEscapeUnquotedValues();
  keepEscape=settings.isKeepEscapeSequences();
  normalizeLineEndingsInQuotes=settings.isNormalizeLineEndingsWithinQuotes();
  CsvFormat format=settings.getFormat();
  delimiter=format.getDelimiter();
  quote=format.getQuote();
  quoteEscape=format.getQuoteEscape();
  escapeEscape=format.getCharToEscapeQuoteEscaping();
  newLine=format.getNormalizedNewline();
  whitespaceAppender=new DefaultCharAppender(settings.getMaxCharsPerColumn(),""String_Node_Str"");
}",0.958288770053476
163389,"/** 
 * Identifies which fields are associated with which columns in a row.
 * @param row              A row with values for the given java bean.
 * @param headers          The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes          The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldIndexes(ParsingContext context,Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  if (headers == null) {
    headers=ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  int biggestIndex=headers.length > row.length ? headers.length : row.length;
  for (  FieldMapping mapping : parsedFields) {
    int index=mapping.getIndex();
    if (biggestIndex < index) {
      biggestIndex=index;
    }
  }
  FieldMapping[] fieldOrder=new FieldMapping[biggestIndex];
  TreeSet<String> fieldsNotFound=new TreeSet<String>();
  for (  FieldMapping mapping : parsedFields) {
    if (mapping.isMappedToField()) {
      int index=ArgumentUtils.indexOf(headers,mapping.getFieldName());
      if (index == -1) {
        fieldsNotFound.add(mapping.getFieldName());
        continue;
      }
      fieldOrder[index]=mapping;
    }
 else     if (mapping.getIndex() < fieldOrder.length) {
      fieldOrder[mapping.getIndex()]=mapping;
    }
  }
  if (context != null && !fieldsNotFound.isEmpty()) {
    if (headers.length == 0) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
    }
    if (strictHeaderValidationEnabled) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str""+ Arrays.toString(headers));
    }
  }
  if (indexes != null) {
    for (int i=0; i < fieldOrder.length; i++) {
      boolean isIndexUsed=false;
      for (int j=0; j < indexes.length; j++) {
        if (indexes[j] == i) {
          isIndexUsed=true;
          break;
        }
      }
      if (!isIndexUsed) {
        fieldOrder[i]=null;
      }
    }
    if (columnsReordered) {
      FieldMapping[] newFieldOrder=new FieldMapping[indexes.length];
      for (int i=0; i < indexes.length; i++) {
        for (int j=0; j < fieldOrder.length; j++) {
          int index=indexes[i];
          FieldMapping field=fieldOrder[index];
          newFieldOrder[i]=field;
        }
      }
      fieldOrder=newFieldOrder;
    }
  }
  this.readOrder=fieldOrder;
}","/** 
 * Identifies which fields are associated with which columns in a row.
 * @param row              A row with values for the given java bean.
 * @param headers          The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes          The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldIndexes(ParsingContext context,Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  if (headers == null) {
    headers=ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  int biggestIndex=headers.length > row.length ? headers.length : row.length;
  for (  FieldMapping mapping : parsedFields) {
    int index=mapping.getIndex();
    if (biggestIndex < index) {
      biggestIndex=index;
    }
  }
  FieldMapping[] fieldOrder=new FieldMapping[biggestIndex + 1];
  TreeSet<String> fieldsNotFound=new TreeSet<String>();
  for (  FieldMapping mapping : parsedFields) {
    if (mapping.isMappedToField()) {
      int index=ArgumentUtils.indexOf(headers,mapping.getFieldName());
      if (index == -1) {
        fieldsNotFound.add(mapping.getFieldName());
        continue;
      }
      fieldOrder[index]=mapping;
    }
 else     if (mapping.getIndex() < fieldOrder.length) {
      fieldOrder[mapping.getIndex()]=mapping;
    }
  }
  if (context != null && !fieldsNotFound.isEmpty()) {
    if (headers.length == 0) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
    }
    if (strictHeaderValidationEnabled) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str""+ Arrays.toString(headers));
    }
  }
  if (indexes != null) {
    for (int i=0; i < fieldOrder.length; i++) {
      boolean isIndexUsed=false;
      for (int j=0; j < indexes.length; j++) {
        if (indexes[j] == i) {
          isIndexUsed=true;
          break;
        }
      }
      if (!isIndexUsed) {
        fieldOrder[i]=null;
      }
    }
    if (columnsReordered) {
      FieldMapping[] newFieldOrder=new FieldMapping[indexes.length];
      for (int i=0; i < indexes.length; i++) {
        for (int j=0; j < fieldOrder.length; j++) {
          int index=indexes[i];
          FieldMapping field=fieldOrder[index];
          newFieldOrder[i]=field;
        }
      }
      fieldOrder=newFieldOrder;
    }
  }
  this.readOrder=fieldOrder;
}",0.9992777175875768
163390,"@Override public String[] headers(){
  return fieldNames;
}","@Override public String[] headers(){
  return fieldNames == null || fieldNames.length == 0 ? context.headers() : fieldNames;
}",0.6378378378378379
163391,"@Override public final void rowProcessed(String[] row,ParsingContext context){
  RowProcessor processor=switchRowProcessor(row,context);
  if (processor == null) {
    processor=NoopRowProcessor.instance;
  }
  if (processor != selectedRowProcessor) {
    contextForProcessor=rowProcessors.get(processor);
    if (contextForProcessor == null) {
      contextForProcessor=new ParsingContextWrapper(context){
        private final String[] fieldNames=getHeaders();
        @Override public String[] headers(){
          return fieldNames;
        }
      }
;
      processor.processStarted(contextForProcessor);
      rowProcessors.put(processor,contextForProcessor);
    }
    if (selectedRowProcessor != NoopRowProcessor.instance) {
      rowProcessorSwitched(selectedRowProcessor,processor);
    }
    selectedRowProcessor=processor;
    selectedRowProcessor.rowProcessed(row,contextForProcessor);
  }
 else {
    selectedRowProcessor.rowProcessed(row,contextForProcessor);
  }
}","@Override public final void rowProcessed(String[] row,final ParsingContext context){
  RowProcessor processor=switchRowProcessor(row,context);
  if (processor == null) {
    processor=NoopRowProcessor.instance;
  }
  if (processor != selectedRowProcessor) {
    contextForProcessor=rowProcessors.get(processor);
    if (contextForProcessor == null) {
      contextForProcessor=new ParsingContextWrapper(context){
        private final String[] fieldNames=getHeaders();
        @Override public String[] headers(){
          return fieldNames == null || fieldNames.length == 0 ? context.headers() : fieldNames;
        }
      }
;
      processor.processStarted(contextForProcessor);
      rowProcessors.put(processor,contextForProcessor);
    }
    if (selectedRowProcessor != NoopRowProcessor.instance) {
      rowProcessorSwitched(selectedRowProcessor,processor);
    }
    selectedRowProcessor=processor;
    selectedRowProcessor.rowProcessed(row,contextForProcessor);
  }
 else {
    selectedRowProcessor.rowProcessed(row,contextForProcessor);
  }
}",0.9640924741760944
163392,"/** 
 * Closes the   {@link java.io.Writer} given in this class constructor.<p> An IllegalStateException will be thrown in case of any errors.
 */
public final void close(){
  try {
    this.headerIndexes=null;
    if (writer != null) {
      try {
        writer.flush();
      }
  finally {
        writer.close();
      }
    }
  }
 catch (  Throwable ex) {
    throw new IllegalStateException(""String_Node_Str"",ex);
  }
}","/** 
 * Closes the   {@link java.io.Writer} given in this class constructor.<p> An IllegalStateException will be thrown in case of any errors.
 */
public final void close(){
  try {
    this.headerIndexes=null;
    if (writer != null) {
      try {
        writer.flush();
      }
  finally {
        writer.close();
      }
    }
  }
 catch (  Throwable ex) {
    throw new IllegalStateException(""String_Node_Str"",ex);
  }
  if (this.partialLineIndex != 0) {
    throw new TextWritingException(""String_Node_Str"" + ""String_Node_Str"",recordCount,Arrays.copyOf(partialLine,partialLineIndex));
  }
}",0.8305582761998042
163393,"private void parseField(){
  if (ignoreLeadingWhitespace && ch != '\t' && ch <= ' ') {
    skipWhitespace();
  }
  if (ch == '\t') {
    output.emptyParsed();
  }
 else {
    if (ignoreTrailingWhitespace) {
      while (ch != '\t' && ch != newLine) {
        if (ch == escapeChar) {
          ch=input.nextChar();
          if (ch == 't') {
            output.appender.appendIgnoringWhitespace('\t');
          }
 else           if (ch == 'n') {
            output.appender.appendIgnoringWhitespace('\n');
          }
 else           if (ch == '\\') {
            output.appender.appendIgnoringWhitespace('\\');
          }
 else           if (ch == 'r') {
            output.appender.appendIgnoringWhitespace('\r');
          }
 else {
            output.appender.append(escapeChar);
            if (ch == newLine || ch == '\t') {
              break;
            }
            output.appender.appendIgnoringWhitespace(ch);
          }
          ch=input.nextChar();
        }
 else {
          output.appender.appendIgnoringWhitespace(ch);
          ch=input.nextChar();
        }
      }
    }
 else {
      while (ch != '\t' && ch != newLine) {
        if (ch == escapeChar) {
          ch=input.nextChar();
          if (ch == 't') {
            output.appender.append('\t');
          }
 else           if (ch == 'n') {
            output.appender.append('\n');
          }
 else           if (ch == '\\') {
            output.appender.append('\\');
          }
 else           if (ch == 'r') {
            output.appender.append('\r');
          }
 else {
            output.appender.append(escapeChar);
            if (ch == newLine || ch == '\t') {
              break;
            }
            output.appender.append(ch);
          }
          ch=input.nextChar();
        }
 else {
          output.appender.append(ch);
          ch=input.nextChar();
        }
      }
    }
    output.valueParsed();
  }
}","private void parseField(){
  if (ignoreLeadingWhitespace && ch != '\t' && ch <= ' ') {
    skipWhitespace();
  }
  if (ch == '\t') {
    output.emptyParsed();
  }
 else {
    if (ignoreTrailingWhitespace) {
      while (ch != '\t' && ch != newLine) {
        if (ch == escapeChar) {
          ch=input.nextChar();
          if (ch == 't') {
            output.appender.appendIgnoringWhitespace('\t');
          }
 else           if (ch == 'n') {
            output.appender.appendIgnoringWhitespace('\n');
          }
 else           if (ch == '\\') {
            output.appender.appendIgnoringWhitespace('\\');
          }
 else           if (ch == 'r') {
            output.appender.appendIgnoringWhitespace('\r');
          }
 else           if (ch == newLine && joinLines) {
            output.appender.appendIgnoringWhitespace(newLine);
          }
 else {
            output.appender.append(escapeChar);
            if (ch == newLine || ch == '\t') {
              break;
            }
            output.appender.appendIgnoringWhitespace(ch);
          }
          ch=input.nextChar();
        }
 else {
          output.appender.appendIgnoringWhitespace(ch);
          ch=input.nextChar();
        }
      }
    }
 else {
      while (ch != '\t' && ch != newLine) {
        if (ch == escapeChar) {
          ch=input.nextChar();
          if (ch == 't') {
            output.appender.append('\t');
          }
 else           if (ch == 'n') {
            output.appender.append('\n');
          }
 else           if (ch == '\\') {
            output.appender.append('\\');
          }
 else           if (ch == 'r') {
            output.appender.append('\r');
          }
 else           if (ch == newLine && joinLines) {
            output.appender.append(newLine);
          }
 else {
            output.appender.append(escapeChar);
            if (ch == newLine || ch == '\t') {
              break;
            }
            output.appender.append(ch);
          }
          ch=input.nextChar();
        }
 else {
          output.appender.append(ch);
          ch=input.nextChar();
        }
      }
    }
    output.valueParsed();
  }
}",0.8918387413962635
163394,"/** 
 * The TsvParser supports all settings provided by   {@link TsvParserSettings}, and requires this configuration to be properly initialized.
 * @param settings the parser configuration
 */
public TsvParser(TsvParserSettings settings){
  super(settings);
  ignoreTrailingWhitespace=settings.getIgnoreTrailingWhitespaces();
  ignoreLeadingWhitespace=settings.getIgnoreLeadingWhitespaces();
  TsvFormat format=settings.getFormat();
  newLine=format.getNormalizedNewline();
  escapeChar=settings.getFormat().getEscapeChar();
}","/** 
 * The TsvParser supports all settings provided by   {@link TsvParserSettings}, and requires this configuration to be properly initialized.
 * @param settings the parser configuration
 */
public TsvParser(TsvParserSettings settings){
  super(settings);
  ignoreTrailingWhitespace=settings.getIgnoreTrailingWhitespaces();
  ignoreLeadingWhitespace=settings.getIgnoreLeadingWhitespaces();
  joinLines=settings.isLineJoiningEnabled();
  TsvFormat format=settings.getFormat();
  newLine=format.getNormalizedNewline();
  escapeChar=settings.getFormat().getEscapeChar();
}",0.95897903372835
163395,"/** 
 * Initializes the TSV writer with TSV-specific configuration
 * @param settings the TSV writer configuration
 */
protected final void initialize(TsvWriterSettings settings){
  this.escapeChar=settings.getFormat().getEscapeChar();
  this.ignoreLeading=settings.getIgnoreLeadingWhitespaces();
  this.ignoreTrailing=settings.getIgnoreTrailingWhitespaces();
}","/** 
 * Initializes the TSV writer with TSV-specific configuration
 * @param settings the TSV writer configuration
 */
protected final void initialize(TsvWriterSettings settings){
  this.escapeChar=settings.getFormat().getEscapeChar();
  this.ignoreLeading=settings.getIgnoreLeadingWhitespaces();
  this.ignoreTrailing=settings.getIgnoreTrailingWhitespaces();
  this.joinLines=settings.isLineJoiningEnabled();
  this.newLine=settings.getFormat().getNormalizedNewline();
}",0.8677884615384616
163396,"private void append(String element){
  if (element == null) {
    element=nullValue;
  }
  if (element == null) {
    return;
  }
  int start=0;
  if (this.ignoreLeading) {
    start=skipLeadingWhitespace(element);
  }
  if (this.ignoreTrailing) {
    for (int i=start; i < element.length(); i++) {
      char ch=element.charAt(i);
      if (ch == '\t') {
        appender.append(escapeChar);
        appender.append('t');
      }
 else       if (ch == '\n') {
        appender.append(escapeChar);
        appender.append('n');
      }
 else       if (ch == '\\') {
        appender.append(escapeChar);
        appender.append('\\');
      }
 else       if (ch == '\r') {
        appender.append(escapeChar);
        appender.append('r');
      }
 else {
        appender.appendIgnoringWhitespace(ch);
      }
    }
  }
 else {
    for (int i=start; i < element.length(); i++) {
      char ch=element.charAt(i);
      if (ch == '\t') {
        appender.append(escapeChar);
        appender.append('t');
      }
 else       if (ch == '\n') {
        appender.append(escapeChar);
        appender.append('n');
      }
 else       if (ch == '\\') {
        appender.append(escapeChar);
        appender.append('\\');
      }
 else       if (ch == '\r') {
        appender.append(escapeChar);
        appender.append('r');
      }
 else {
        appender.append(ch);
      }
    }
  }
}","private void append(String element){
  if (element == null) {
    element=nullValue;
  }
  if (element == null) {
    return;
  }
  int start=0;
  if (this.ignoreLeading) {
    start=skipLeadingWhitespace(element);
  }
  if (this.ignoreTrailing) {
    for (int i=start; i < element.length(); i++) {
      char ch=element.charAt(i);
      if (ch == '\t') {
        appender.append(escapeChar);
        appender.append('t');
      }
 else       if (ch == '\n') {
        appender.append(escapeChar);
        appender.append(joinLines ? newLine : 'n');
      }
 else       if (ch == '\\') {
        appender.append(escapeChar);
        appender.append('\\');
      }
 else       if (ch == '\r') {
        appender.append(escapeChar);
        appender.append(joinLines ? newLine : 'r');
      }
 else {
        appender.appendIgnoringWhitespace(ch);
      }
    }
  }
 else {
    for (int i=start; i < element.length(); i++) {
      char ch=element.charAt(i);
      if (ch == '\t') {
        appender.append(escapeChar);
        appender.append('t');
      }
 else       if (ch == '\n') {
        appender.append(escapeChar);
        appender.append(joinLines ? newLine : 'n');
      }
 else       if (ch == '\\') {
        appender.append(escapeChar);
        appender.append('\\');
      }
 else       if (ch == '\r') {
        appender.append(escapeChar);
        appender.append(joinLines ? newLine : 'r');
      }
 else {
        appender.append(ch);
      }
    }
  }
}",0.9201121233356692
163397,"@Test(enabled=true,dataProvider=""String_Node_Str"") public void writeSelectedColumnOnlyToString(boolean quoteAllFields,char[] lineSeparator) throws Exception {
  TsvWriterSettings settings=new TsvWriterSettings();
  String[] expectedHeaders=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  settings.getFormat().setLineSeparator(lineSeparator);
  settings.setIgnoreLeadingWhitespaces(false);
  settings.setIgnoreTrailingWhitespaces(false);
  settings.setHeaders(expectedHeaders);
  settings.selectFields(""String_Node_Str"",""String_Node_Str"");
  TsvWriter writer=new TsvWriter(settings);
  Object[][] input=new Object[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{null,null},{""String_Node_Str"",null},{""String_Node_Str"",""String_Node_Str""}};
  String headers=writer.writeHeadersToString();
  assertEquals(headers,""String_Node_Str"");
  List<String> rowList=writer.writeRowsToString(input);
  assertEquals(rowList.get(0),""String_Node_Str"");
  assertEquals(rowList.get(1),""String_Node_Str"");
  assertEquals(rowList.get(2),""String_Node_Str"");
  assertEquals(rowList.get(3),""String_Node_Str"");
  assertEquals(rowList.get(4),""String_Node_Str"");
  assertEquals(rowList.get(5),""String_Node_Str"");
  assertEquals(rowList.get(6),""String_Node_Str"");
  assertEquals(rowList.get(7),""String_Node_Str"");
}","@Test(enabled=true,dataProvider=""String_Node_Str"") public void writeSelectedColumnOnlyToString(char[] lineSeparator) throws Exception {
  TsvWriterSettings settings=new TsvWriterSettings();
  String[] expectedHeaders=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  settings.getFormat().setLineSeparator(lineSeparator);
  settings.setIgnoreLeadingWhitespaces(false);
  settings.setIgnoreTrailingWhitespaces(false);
  settings.setHeaders(expectedHeaders);
  settings.selectFields(""String_Node_Str"",""String_Node_Str"");
  TsvWriter writer=new TsvWriter(settings);
  Object[][] input=new Object[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{null,null},{""String_Node_Str"",null},{""String_Node_Str"",""String_Node_Str""}};
  String headers=writer.writeHeadersToString();
  assertEquals(headers,""String_Node_Str"");
  List<String> rowList=writer.writeRowsToString(input);
  assertEquals(rowList.get(0),""String_Node_Str"");
  assertEquals(rowList.get(1),""String_Node_Str"");
  assertEquals(rowList.get(2),""String_Node_Str"");
  assertEquals(rowList.get(3),""String_Node_Str"");
  assertEquals(rowList.get(4),""String_Node_Str"");
  assertEquals(rowList.get(5),""String_Node_Str"");
  assertEquals(rowList.get(6),""String_Node_Str"");
  assertEquals(rowList.get(7),""String_Node_Str"");
}",0.9922271037512672
163398,"@Test(enabled=true,dataProvider=""String_Node_Str"") public void writeTest(boolean quoteAllFields,char[] lineSeparator) throws Exception {
  TsvWriterSettings settings=new TsvWriterSettings();
  String[] expectedHeaders=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  settings.getFormat().setLineSeparator(lineSeparator);
  settings.setIgnoreLeadingWhitespaces(false);
  settings.setIgnoreTrailingWhitespaces(false);
  settings.setHeaders(expectedHeaders);
  ByteArrayOutputStream tsvResult=new ByteArrayOutputStream();
  TsvWriter writer=new TsvWriter(new OutputStreamWriter(tsvResult,""String_Node_Str""),settings);
  Object[][] expectedResult=new Object[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str""},{null,null,""String_Node_Str"",null,""String_Node_Str""},{null,null,null,null,null},{null,null,null,null,null},{null,null,""String_Node_Str"",null,null},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{null,""String_Node_Str"",null,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  writer.writeHeaders();
  for (int i=0; i < 4; i++) {
    writer.writeRow(expectedResult[i]);
  }
  writer.writeRow(""String_Node_Str"");
  for (int i=4; i < expectedResult.length; i++) {
    writer.writeRow(expectedResult[i]);
  }
  writer.close();
  String result=tsvResult.toString();
  result=""String_Node_Str"".replaceAll(""String_Node_Str"",new String(lineSeparator)) + result;
  TsvParserSettings parserSettings=new TsvParserSettings();
  parserSettings.setRowProcessor(processor);
  parserSettings.getFormat().setLineSeparator(lineSeparator);
  parserSettings.setHeaderExtractionEnabled(true);
  parserSettings.setIgnoreLeadingWhitespaces(false);
  parserSettings.setIgnoreTrailingWhitespaces(false);
  TsvParser parser=new TsvParser(parserSettings);
  parser.parse(new StringReader(result));
  try {
    assertHeadersAndValuesMatch(expectedHeaders,expectedResult);
  }
 catch (  Error e) {
    System.out.println(""String_Node_Str"" + result + ""String_Node_Str"");
    throw e;
  }
}","@Test(enabled=true,dataProvider=""String_Node_Str"") public void writeTest(char[] lineSeparator) throws Exception {
  TsvWriterSettings settings=new TsvWriterSettings();
  String[] expectedHeaders=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  settings.getFormat().setLineSeparator(lineSeparator);
  settings.setIgnoreLeadingWhitespaces(false);
  settings.setIgnoreTrailingWhitespaces(false);
  settings.setHeaders(expectedHeaders);
  ByteArrayOutputStream tsvResult=new ByteArrayOutputStream();
  TsvWriter writer=new TsvWriter(new OutputStreamWriter(tsvResult,""String_Node_Str""),settings);
  Object[][] expectedResult=new Object[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str""},{null,null,""String_Node_Str"",null,""String_Node_Str""},{null,null,null,null,null},{null,null,null,null,null},{null,null,""String_Node_Str"",null,null},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{null,""String_Node_Str"",null,""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  writer.writeHeaders();
  for (int i=0; i < 4; i++) {
    writer.writeRow(expectedResult[i]);
  }
  writer.writeRow(""String_Node_Str"");
  for (int i=4; i < expectedResult.length; i++) {
    writer.writeRow(expectedResult[i]);
  }
  writer.close();
  String result=tsvResult.toString();
  result=""String_Node_Str"".replaceAll(""String_Node_Str"",new String(lineSeparator)) + result;
  TsvParserSettings parserSettings=new TsvParserSettings();
  parserSettings.setRowProcessor(processor);
  parserSettings.getFormat().setLineSeparator(lineSeparator);
  parserSettings.setHeaderExtractionEnabled(true);
  parserSettings.setIgnoreLeadingWhitespaces(false);
  parserSettings.setIgnoreTrailingWhitespaces(false);
  TsvParser parser=new TsvParser(parserSettings);
  parser.parse(new StringReader(result));
  try {
    assertHeadersAndValuesMatch(expectedHeaders,expectedResult);
  }
 catch (  Error e) {
    System.out.println(""String_Node_Str"" + result + ""String_Node_Str"");
    throw e;
  }
}",0.9958906557084152
163399,"@Test(enabled=true,dataProvider=""String_Node_Str"") public void writeSelectedColumnOnly(boolean quoteAllFields,char[] lineSeparator) throws Exception {
  TsvWriterSettings settings=new TsvWriterSettings();
  String[] expectedHeaders=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  settings.getFormat().setLineSeparator(lineSeparator);
  settings.setIgnoreLeadingWhitespaces(false);
  settings.setIgnoreTrailingWhitespaces(false);
  settings.setHeaders(expectedHeaders);
  settings.selectFields(""String_Node_Str"",""String_Node_Str"");
  ByteArrayOutputStream tsvResult=new ByteArrayOutputStream();
  TsvWriter writer=new TsvWriter(new OutputStreamWriter(tsvResult,""String_Node_Str""),settings);
  Object[][] input=new Object[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{null,null},{""String_Node_Str"",null},{""String_Node_Str"",""String_Node_Str""}};
  writer.writeHeaders();
  writer.writeRowsAndClose(input);
  Object[][] expectedResult=new Object[][]{{null,null,""String_Node_Str"",null,""String_Node_Str""},{null,null,""String_Node_Str"",null,""String_Node_Str""},{null,null,""String_Node_Str"",null,""String_Node_Str""},{null,null,""String_Node_Str"",null,""String_Node_Str""},{null,null,""String_Node_Str"",null,""String_Node_Str""},{null,null,null,null,null},{null,null,""String_Node_Str"",null,null},{null,null,""String_Node_Str"",null,""String_Node_Str""}};
  String result=tsvResult.toString();
  RowListProcessor rowList=new RowListProcessor();
  TsvParserSettings parserSettings=new TsvParserSettings();
  parserSettings.setRowProcessor(rowList);
  parserSettings.getFormat().setLineSeparator(lineSeparator);
  parserSettings.setHeaderExtractionEnabled(true);
  parserSettings.setIgnoreLeadingWhitespaces(false);
  parserSettings.setIgnoreTrailingWhitespaces(false);
  TsvParser parser=new TsvParser(parserSettings);
  parser.parse(new StringReader(result));
  try {
    assertHeadersAndValuesMatch(rowList,expectedHeaders,expectedResult);
  }
 catch (  Error e) {
    System.out.println(""String_Node_Str"" + result + ""String_Node_Str"");
    throw e;
  }
}","@Test(enabled=true,dataProvider=""String_Node_Str"") public void writeSelectedColumnOnly(char[] lineSeparator) throws Exception {
  TsvWriterSettings settings=new TsvWriterSettings();
  String[] expectedHeaders=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  settings.getFormat().setLineSeparator(lineSeparator);
  settings.setIgnoreLeadingWhitespaces(false);
  settings.setIgnoreTrailingWhitespaces(false);
  settings.setHeaders(expectedHeaders);
  settings.selectFields(""String_Node_Str"",""String_Node_Str"");
  ByteArrayOutputStream tsvResult=new ByteArrayOutputStream();
  TsvWriter writer=new TsvWriter(new OutputStreamWriter(tsvResult,""String_Node_Str""),settings);
  Object[][] input=new Object[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{null,null},{""String_Node_Str"",null},{""String_Node_Str"",""String_Node_Str""}};
  writer.writeHeaders();
  writer.writeRowsAndClose(input);
  Object[][] expectedResult=new Object[][]{{null,null,""String_Node_Str"",null,""String_Node_Str""},{null,null,""String_Node_Str"",null,""String_Node_Str""},{null,null,""String_Node_Str"",null,""String_Node_Str""},{null,null,""String_Node_Str"",null,""String_Node_Str""},{null,null,""String_Node_Str"",null,""String_Node_Str""},{null,null,null,null,null},{null,null,""String_Node_Str"",null,null},{null,null,""String_Node_Str"",null,""String_Node_Str""}};
  String result=tsvResult.toString();
  RowListProcessor rowList=new RowListProcessor();
  TsvParserSettings parserSettings=new TsvParserSettings();
  parserSettings.setRowProcessor(rowList);
  parserSettings.getFormat().setLineSeparator(lineSeparator);
  parserSettings.setHeaderExtractionEnabled(true);
  parserSettings.setIgnoreLeadingWhitespaces(false);
  parserSettings.setIgnoreTrailingWhitespaces(false);
  TsvParser parser=new TsvParser(parserSettings);
  parser.parse(new StringReader(result));
  try {
    assertHeadersAndValuesMatch(rowList,expectedHeaders,expectedResult);
  }
 catch (  Error e) {
    System.out.println(""String_Node_Str"" + result + ""String_Node_Str"");
    throw e;
  }
}",0.9948395781916088
163400,"@DataProvider public Object[][] lineSeparatorProvider(){
  return new Object[][]{{false,new char[]{'\n'}},{true,new char[]{'\r','\n'}},{true,new char[]{'\n'}},{false,new char[]{'\r','\n'}}};
}","@DataProvider public Object[][] lineSeparatorProvider(){
  return new Object[][]{{new char[]{'\n'}},{new char[]{'\r','\n'}},{new char[]{'\n'}},{new char[]{'\r','\n'}}};
}",0.9392265193370166
163401,"/** 
 * {@inheritDoc}
 */
@Override public int[] getFieldIndexes(String[] headers){
  headers=ArgumentUtils.normalize(headers);
  List<String> var=this.get();
  ArgumentUtils.normalize(var);
  String[] chosenFields=var.toArray(new String[var.size()]);
  Object[] unknownFields=ArgumentUtils.findMissingElements(headers,chosenFields);
  if (unknownFields.length > 0 && !var.containsAll(Arrays.asList(headers))) {
    throw new IllegalStateException(""String_Node_Str"" + Arrays.toString(unknownFields) + ""String_Node_Str""+ Arrays.toString(headers));
  }
  int[] out=new int[chosenFields.length];
  int i=0;
  Set<Integer> indexesTaken=new HashSet<Integer>();
  for (  String chosenField : chosenFields) {
    int index=ArgumentUtils.indexOf(headers,chosenField);
    if (index != -1) {
      indexesTaken.add(index);
    }
    out[i++]=index;
  }
  int generatedIndex=0;
  for (i=0; i < out.length; i++) {
    if (out[i] == -1) {
      while (indexesTaken.contains(generatedIndex)) {
        generatedIndex++;
      }
      indexesTaken.add(generatedIndex);
      out[i]=generatedIndex;
    }
  }
  return out;
}","/** 
 * {@inheritDoc}
 */
@Override public int[] getFieldIndexes(String[] headers){
  headers=ArgumentUtils.normalize(headers);
  List<String> selection=this.get();
  ArgumentUtils.normalize(selection);
  String[] chosenFields=selection.toArray(new String[selection.size()]);
  Object[] unknownFields=ArgumentUtils.findMissingElements(headers,chosenFields);
  if (unknownFields.length > 0 && !selection.containsAll(Arrays.asList(headers))) {
    if (unknownFields.length == chosenFields.length) {
      return new int[0];
    }
  }
  int[] out=new int[chosenFields.length];
  int i=0;
  Set<Integer> indexesTaken=new HashSet<Integer>();
  for (  String chosenField : chosenFields) {
    int index=ArgumentUtils.indexOf(headers,chosenField);
    if (index != -1) {
      indexesTaken.add(index);
    }
    out[i++]=index;
  }
  int generatedIndex=0;
  for (i=0; i < out.length; i++) {
    if (out[i] == -1) {
      while (indexesTaken.contains(generatedIndex)) {
        generatedIndex++;
      }
      indexesTaken.add(generatedIndex);
      out[i]=generatedIndex;
    }
  }
  return out;
}",0.8831286948613006
163402,"/** 
 * Requests the next batch of characters from the implementing class and updates the character count. <p> If there are no more characters in the input, the reading will stop by invoking the   {@link AbstractCharInputReader#stop()} method.
 */
private void updateBuffer(){
  reloadBuffer();
  charCount+=i;
  i=0;
  if (length == -1) {
    stop();
  }
  if (inputAnalysisProcesses != null) {
    try {
      for (      InputAnalysisProcess process : inputAnalysisProcesses) {
        process.execute(buffer,length);
      }
    }
  finally {
      inputAnalysisProcesses=null;
    }
  }
}","/** 
 * Requests the next batch of characters from the implementing class and updates the character count. <p> If there are no more characters in the input, the reading will stop by invoking the   {@link AbstractCharInputReader#stop()} method.
 */
private void updateBuffer(){
  reloadBuffer();
  charCount+=i;
  i=0;
  if (length == -1) {
    stop();
    incrementLineCount=true;
  }
  if (inputAnalysisProcesses != null) {
    try {
      for (      InputAnalysisProcess process : inputAnalysisProcesses) {
        process.execute(buffer,length);
      }
    }
  finally {
      inputAnalysisProcesses=null;
    }
  }
}",0.9760923330585326
163403,"/** 
 * {@inheritDoc}
 */
@Override public final char nextChar(){
  if (length == -1) {
    throw new EOFException();
  }
  char ch=buffer[i - 1];
  if (i >= length) {
    updateBuffer();
  }
  i++;
  if (lineSeparator1 == ch && (lineSeparator2 == '\0' || lineSeparator2 == buffer[i - 1])) {
    lineCount++;
    if (lineSeparator2 != '\0') {
      ch=normalizedLineSeparator;
      if (i >= length) {
        if (length != -1) {
          updateBuffer();
        }
 else {
          throw new EOFException();
        }
      }
      if (i < length) {
        i++;
      }
    }
 else {
      return normalizedLineSeparator;
    }
  }
  return ch;
}","/** 
 * {@inheritDoc}
 */
@Override public final char nextChar(){
  if (length == -1) {
    throwEOFException();
  }
  char ch=buffer[i - 1];
  if (i >= length) {
    updateBuffer();
  }
  i++;
  if (lineSeparator1 == ch && (lineSeparator2 == '\0' || length != -1 && lineSeparator2 == buffer[i - 1])) {
    lineCount++;
    if (lineSeparator2 != '\0') {
      ch=normalizedLineSeparator;
      if (i >= length) {
        if (length != -1) {
          updateBuffer();
        }
 else {
          throwEOFException();
        }
      }
      if (i < length) {
        i++;
      }
    }
 else {
      return normalizedLineSeparator;
    }
  }
  return ch;
}",0.9800613496932516
163404,"private static void invokeSetter(Object formatter,PropertyDescriptor property,String value){
  Method writeMethod=property.getWriteMethod();
  if (writeMethod == null) {
    throw new DataProcessingException(""String_Node_Str"" + property.getName() + ""String_Node_Str""+ formatter.getClass()+ ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
  Class<?> parameterType=writeMethod.getParameterTypes()[0];
  Object parameterValue=null;
  if (parameterType == String.class) {
    parameterValue=value;
  }
 else   if (parameterType == Integer.class || parameterType == int.class) {
    parameterValue=Integer.parseInt(value);
  }
 else   if (parameterType == Character.class || parameterType == char.class) {
    parameterValue=value.charAt(0);
  }
 else   if (parameterType == Currency.class) {
    parameterValue=Currency.getInstance(value);
  }
 else   if (parameterType == Boolean.class) {
    parameterValue=Boolean.valueOf(value);
  }
 else   if (parameterType == TimeZone.class) {
    parameterValue=TimeZone.getTimeZone(value);
  }
 else   if (parameterType == DateFormatSymbols.class) {
    parameterValue=DateFormatSymbols.getInstance(new Locale(value));
  }
  if (parameterValue == null) {
    throw new DataProcessingException(""String_Node_Str"" + property.getName() + ""String_Node_Str""+ formatter.getClass()+ ""String_Node_Str""+ value+ ""String_Node_Str""+ parameterType);
  }
  try {
    writeMethod.invoke(formatter,parameterValue);
  }
 catch (  Throwable e) {
    throw new DataProcessingException(""String_Node_Str"" + property.getName() + ""String_Node_Str""+ formatter.getClass()+ ""String_Node_Str""+ parameterValue+ ""String_Node_Str""+ value+ ""String_Node_Str"",e);
  }
}","private static void invokeSetter(Object formatter,PropertyWrapper property,String value){
  Method writeMethod=property.getWriteMethod();
  if (writeMethod == null) {
    throw new DataProcessingException(""String_Node_Str"" + property.getName() + ""String_Node_Str""+ formatter.getClass()+ ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
  Class<?> parameterType=writeMethod.getParameterTypes()[0];
  Object parameterValue=null;
  if (parameterType == String.class) {
    parameterValue=value;
  }
 else   if (parameterType == Integer.class || parameterType == int.class) {
    parameterValue=Integer.parseInt(value);
  }
 else   if (parameterType == Character.class || parameterType == char.class) {
    parameterValue=value.charAt(0);
  }
 else   if (parameterType == Currency.class) {
    parameterValue=Currency.getInstance(value);
  }
 else   if (parameterType == Boolean.class) {
    parameterValue=Boolean.valueOf(value);
  }
 else   if (parameterType == TimeZone.class) {
    parameterValue=TimeZone.getTimeZone(value);
  }
 else   if (parameterType == DateFormatSymbols.class) {
    parameterValue=DateFormatSymbols.getInstance(new Locale(value));
  }
  if (parameterValue == null) {
    throw new DataProcessingException(""String_Node_Str"" + property.getName() + ""String_Node_Str""+ formatter.getClass()+ ""String_Node_Str""+ value+ ""String_Node_Str""+ parameterType);
  }
  try {
    writeMethod.invoke(formatter,parameterValue);
  }
 catch (  Throwable e) {
    throw new DataProcessingException(""String_Node_Str"" + property.getName() + ""String_Node_Str""+ formatter.getClass()+ ""String_Node_Str""+ parameterValue+ ""String_Node_Str""+ value+ ""String_Node_Str"",e);
  }
}",0.995518374663878
163405,"public static void applyFormatSettings(Object formatter,String[] propertiesAndValues){
  if (propertiesAndValues.length == 0) {
    return;
  }
  Map<String,String> values=new HashMap<String,String>();
  for (  String setting : propertiesAndValues) {
    if (setting == null) {
      throw new DataProcessingException(""String_Node_Str"" + Arrays.toString(propertiesAndValues));
    }
    String[] pair=setting.split(""String_Node_Str"");
    if (pair.length != 2) {
      throw new DataProcessingException(""String_Node_Str"" + setting + ""String_Node_Str""+ Arrays.toString(propertiesAndValues));
    }
    values.put(pair[0],pair[1]);
  }
  try {
    BeanInfo beanInfo=Introspector.getBeanInfo(formatter.getClass(),Object.class);
    for (    PropertyDescriptor property : beanInfo.getPropertyDescriptors()) {
      String name=property.getName();
      String value=values.remove(name);
      if (value != null) {
        invokeSetter(formatter,property,value);
      }
      if (""String_Node_Str"".equals(property.getName())) {
        DecimalFormatSymbols modifiedDecimalSymbols=new DecimalFormatSymbols();
        boolean modified=false;
        try {
          BeanInfo decimalBeanInfo=Introspector.getBeanInfo(modifiedDecimalSymbols.getClass(),Object.class);
          for (          PropertyDescriptor prop : decimalBeanInfo.getPropertyDescriptors()) {
            value=values.remove(prop.getName());
            if (value != null) {
              invokeSetter(modifiedDecimalSymbols,prop,value);
              modified=true;
            }
          }
          if (modified) {
            property.getWriteMethod().invoke(formatter,modifiedDecimalSymbols);
          }
        }
 catch (        Throwable ex) {
          throw new DataProcessingException(""String_Node_Str"" + formatter.getClass() + '.',ex);
        }
      }
    }
  }
 catch (  IntrospectionException e) {
  }
  if (!values.isEmpty()) {
    throw new DataProcessingException(""String_Node_Str"" + formatter.getClass() + ""String_Node_Str""+ values);
  }
}","public static void applyFormatSettings(Object formatter,String[] propertiesAndValues){
  if (propertiesAndValues.length == 0) {
    return;
  }
  Map<String,String> values=new HashMap<String,String>();
  for (  String setting : propertiesAndValues) {
    if (setting == null) {
      throw new DataProcessingException(""String_Node_Str"" + Arrays.toString(propertiesAndValues));
    }
    String[] pair=setting.split(""String_Node_Str"");
    if (pair.length != 2) {
      throw new DataProcessingException(""String_Node_Str"" + setting + ""String_Node_Str""+ Arrays.toString(propertiesAndValues));
    }
    values.put(pair[0],pair[1]);
  }
  try {
    for (    PropertyWrapper property : BeanHelper.getPropertyDescriptors(formatter.getClass())) {
      String name=property.getName();
      String value=values.remove(name);
      if (value != null) {
        invokeSetter(formatter,property,value);
      }
      if (""String_Node_Str"".equals(property.getName())) {
        DecimalFormatSymbols modifiedDecimalSymbols=new DecimalFormatSymbols();
        boolean modified=false;
        try {
          for (          PropertyWrapper prop : BeanHelper.getPropertyDescriptors(modifiedDecimalSymbols.getClass())) {
            value=values.remove(prop.getName());
            if (value != null) {
              invokeSetter(modifiedDecimalSymbols,prop,value);
              modified=true;
            }
          }
          if (modified) {
            property.getWriteMethod().invoke(formatter,modifiedDecimalSymbols);
          }
        }
 catch (        Throwable ex) {
          throw new DataProcessingException(""String_Node_Str"" + formatter.getClass() + '.',ex);
        }
      }
    }
  }
 catch (  Exception e) {
  }
  if (!values.isEmpty()) {
    throw new DataProcessingException(""String_Node_Str"" + formatter.getClass() + ""String_Node_Str""+ values);
  }
}",0.8858541612986344
163406,"/** 
 * Creates the mapping and identifies how it is mapped (by name or by index)
 * @param beanClass the class that contains a the given field.
 * @param field a {@link java.lang.reflect.Field} annotated with {@link Parsed}
 * @param property the property descriptor of this field, if any. If this bean does not have getters/setters, it will be accessed directly.
 */
public FieldMapping(Class<?> beanClass,Field field,PropertyDescriptor property){
  this.beanClass=beanClass;
  this.field=field;
  this.readMethod=property != null ? property.getReadMethod() : null;
  this.writeMethod=property != null ? property.getWriteMethod() : null;
  determineFieldMapping();
}","/** 
 * Creates the mapping and identifies how it is mapped (by name or by index)
 * @param beanClass the class that contains a the given field.
 * @param field a {@link java.lang.reflect.Field} annotated with {@link Parsed}
 * @param property the property descriptor of this field, if any. If this bean does not have getters/setters, it will be accessed directly.
 */
public FieldMapping(Class<?> beanClass,Field field,PropertyWrapper property){
  this.beanClass=beanClass;
  this.field=field;
  this.readMethod=property != null ? property.getReadMethod() : null;
  this.writeMethod=property != null ? property.getWriteMethod() : null;
  determineFieldMapping();
}",0.9887471867966992
163407,"/** 
 * Identifies and extracts fields annotated with the   {@link Parsed} annotation
 */
public final void initialize(){
  if (!initialized) {
    initialized=true;
    Map<String,PropertyDescriptor> properties=new HashMap<String,PropertyDescriptor>();
    try {
      BeanInfo beanInfo=Introspector.getBeanInfo(beanClass,Object.class);
      for (      PropertyDescriptor property : beanInfo.getPropertyDescriptors()) {
        String name=property.getName();
        properties.put(name,property);
      }
    }
 catch (    IntrospectionException e) {
    }
    Set<String> used=new HashSet<String>();
    Class<?> clazz=beanClass;
    do {
      Field[] declared=clazz.getDeclaredFields();
      for (      Field field : declared) {
        if (used.contains(field.getName())) {
          continue;
        }
        used.add(field.getName());
        processField(field,properties.get(field.getName()));
      }
      clazz=clazz.getSuperclass();
    }
 while (clazz != null && clazz != Object.class);
    readOrder=null;
    lastFieldIndexMapped=-1;
    validateMappings();
  }
}","/** 
 * Identifies and extracts fields annotated with the   {@link Parsed} annotation
 */
public final void initialize(){
  if (!initialized) {
    initialized=true;
    Map<String,PropertyWrapper> properties=new HashMap<String,PropertyWrapper>();
    try {
      for (      PropertyWrapper property : BeanHelper.getPropertyDescriptors(beanClass)) {
        String name=property.getName();
        if (name != null) {
          properties.put(name,property);
        }
      }
    }
 catch (    Exception e) {
    }
    Set<String> used=new HashSet<String>();
    Class<?> clazz=beanClass;
    do {
      Field[] declared=clazz.getDeclaredFields();
      for (      Field field : declared) {
        if (used.contains(field.getName())) {
          continue;
        }
        used.add(field.getName());
        processField(field,properties.get(field.getName()));
      }
      clazz=clazz.getSuperclass();
    }
 while (clazz != null && clazz != Object.class);
    readOrder=null;
    lastFieldIndexMapped=-1;
    validateMappings();
  }
}",0.3237647058823529
163408,"/** 
 * Normalizes the Strings in a given array by trimming all elements and converting them to lower case.
 * @param strings a String collection with elements to be normalized. The original contents of the collection will be modified.
 */
public static void normalize(Collection<String> strings){
  HashSet<String> normalized=new HashSet<String>(strings.size());
  for (  String string : strings) {
    if (string == null) {
      normalized.add(null);
    }
 else {
      normalized.add(string.trim().toLowerCase());
    }
  }
  strings.clear();
  strings.addAll(normalized);
}","/** 
 * Normalizes the Strings in a given array by trimming all elements and converting them to lower case.
 * @param strings a String collection with elements to be normalized. The original contents of the collection will be modified.
 */
public static void normalize(Collection<String> strings){
  LinkedHashSet<String> normalized=new LinkedHashSet<String>(strings.size());
  for (  String string : strings) {
    if (string == null) {
      normalized.add(null);
    }
 else {
      normalized.add(string.trim().toLowerCase());
    }
  }
  strings.clear();
  strings.addAll(normalized);
}",0.9897435897435898
163409,"private void initializeConversions(String[] row,ParsingContext context){
  conversionsInitialized=true;
  this.fieldIndexes=null;
  this.fieldsReordered=false;
  this.conversionsInitialized=false;
  if (context.headers() != null && context.headers().length > 0) {
    conversions.prepareExecution(context.headers());
  }
 else {
    conversions.prepareExecution(row);
  }
  this.fieldIndexes=context.extractedFieldIndexes();
  this.fieldsReordered=context.columnsReordered();
}","private void initializeConversions(String[] row,ParsingContext context){
  conversionsInitialized=true;
  this.fieldIndexes=null;
  this.fieldsReordered=false;
  this.conversionsInitialized=false;
  if (context.headers() != null && context.headers().length > 0) {
    conversions.prepareExecution(false,context.headers());
  }
 else {
    conversions.prepareExecution(false,row);
  }
  this.fieldIndexes=context.extractedFieldIndexes();
  this.fieldsReordered=context.columnsReordered();
}",0.9875776397515528
163410,"/** 
 * Executes the sequences of reverse conversions defined using   {@link ConversionProcessor#convertFields(Conversion)},   {@link ConversionProcessor#convertIndexes(Conversion)} and {@link ConversionProcessor#convertAll(Conversion)}, for every field in the given row. <p>Each field will be transformed using the   {@link Conversion#revert(Object)} method.<p>In general the conversions will process an Object (such as a Boolean, Date, etc), and convert it to a String representation.
 * @param executeInReverseOrder flag to indicate whether the conversion sequence should be executed in the reverse order of its declaration.
 * @param row the row of objects that will be converted
 * @param headers All field names used to produce records in a given destination. May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexesToWrite The indexes of the headers that are actually being written. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @return {@code true} if the the row should be discarded
 */
public final boolean reverseConversions(boolean executeInReverseOrder,Object[] row,String[] headers,int[] indexesToWrite){
  boolean keepRow=true;
  if (conversions != null) {
    if (!conversionsInitialized) {
      conversionsInitialized=true;
      conversions.prepareExecution(headers);
      this.fieldIndexes=indexesToWrite;
    }
    final int last=fieldIndexes == null ? row.length : fieldIndexes.length;
    for (int i=0; i < last; i++) {
      try {
        if (fieldIndexes == null) {
          row[i]=conversions.reverseConversions(executeInReverseOrder,i,row[i]);
        }
 else {
          int index=fieldIndexes[i];
          row[index]=conversions.reverseConversions(executeInReverseOrder,index,row[index]);
        }
      }
 catch (      Throwable ex) {
        keepRow=false;
        handleConversionError(ex,row,i);
      }
    }
  }
  return keepRow;
}","/** 
 * Executes the sequences of reverse conversions defined using   {@link ConversionProcessor#convertFields(Conversion)},   {@link ConversionProcessor#convertIndexes(Conversion)} and {@link ConversionProcessor#convertAll(Conversion)}, for every field in the given row. <p>Each field will be transformed using the   {@link Conversion#revert(Object)} method.<p>In general the conversions will process an Object (such as a Boolean, Date, etc), and convert it to a String representation.
 * @param executeInReverseOrder flag to indicate whether the conversion sequence should be executed in the reverse order of its declaration.
 * @param row the row of objects that will be converted
 * @param headers All field names used to produce records in a given destination. May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexesToWrite The indexes of the headers that are actually being written. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @return {@code true} if the the row should be discarded
 */
public final boolean reverseConversions(boolean executeInReverseOrder,Object[] row,String[] headers,int[] indexesToWrite){
  boolean keepRow=true;
  if (conversions != null) {
    if (!conversionsInitialized) {
      conversionsInitialized=true;
      conversions.prepareExecution(true,headers);
      this.fieldIndexes=indexesToWrite;
    }
    final int last=fieldIndexes == null ? row.length : fieldIndexes.length;
    for (int i=0; i < last; i++) {
      try {
        if (fieldIndexes == null) {
          row[i]=conversions.reverseConversions(executeInReverseOrder,i,row[i]);
        }
 else {
          int index=fieldIndexes[i];
          row[index]=conversions.reverseConversions(executeInReverseOrder,index,row[index]);
        }
      }
 catch (      Throwable ex) {
        keepRow=false;
        handleConversionError(ex,row,i);
      }
    }
  }
  return keepRow;
}",0.9987602281180264
163411,"private int getExtractedColumnIndex(){
  if (this.extractedIndexes != null && columnIndex < extractedIndexes.length) {
    return extractedIndexes[columnIndex];
  }
  return columnIndex;
}","private int getExtractedColumnIndex(){
  if (this.extractedIndexes != null && columnIndex < extractedIndexes.length && columnIndex > -1) {
    return extractedIndexes[columnIndex];
  }
  return columnIndex;
}",0.9494949494949496
163412,"/** 
 * Get all indexes in the given selector and adds the conversions defined at that index to the map of conversionsByIndex. <p>This method is called in the same sequence each selector was created (in   {@link FieldConversionMapping#prepareExecution(String[])}) <p>At the end of the process, the map of conversionsByIndex will have each index with its list of conversions in the order they were declared.
 * @param selector           the selected fields for a given conversion sequence.
 * @param conversionsByIndex map of all conversions registered to every field index, in the order they were declared
 * @param values             The field sequence that identifies how records will be organized.<p> This is generally the sequence of headers in a record, but it might be just the first parsed row from a given input (as field selection by index is allowed).
 */
public void prepareExecution(FieldSelector selector,Map<Integer,List<Conversion<?,?>>> conversionsByIndex,String[] values){
  if (conversionsMap == null) {
    return;
  }
  Conversion<String,?>[] conversions=conversionsMap.get(selector);
  if (conversions == null) {
    return;
  }
  int[] fieldIndexes=selector.getFieldIndexes(values);
  for (  int fieldIndex : fieldIndexes) {
    List<Conversion<?,?>> conversionsAtIndex=conversionsByIndex.get(fieldIndex);
    if (conversionsAtIndex == null) {
      conversionsAtIndex=new ArrayList<Conversion<?,?>>();
      conversionsByIndex.put(fieldIndex,conversionsAtIndex);
    }
    validateDuplicates(selector,conversionsAtIndex,conversions);
    conversionsAtIndex.addAll(Arrays.asList(conversions));
  }
}","/** 
 * Get all indexes in the given selector and adds the conversions defined at that index to the map of conversionsByIndex. <p>This method is called in the same sequence each selector was created (in   {@link FieldConversionMapping#prepareExecution(boolean,String[])}) <p>At the end of the process, the map of conversionsByIndex will have each index with its list of conversions in the order they were declared.
 * @param writing			 flag indicating whether a writing process is being initialized.
 * @param selector           the selected fields for a given conversion sequence.
 * @param conversionsByIndex map of all conversions registered to every field index, in the order they were declared
 * @param values             The field sequence that identifies how records will be organized.<p> This is generally the sequence of headers in a record, but it might be just the first parsed row from a given input (as field selection by index is allowed).
 */
public void prepareExecution(boolean writing,FieldSelector selector,Map<Integer,List<Conversion<?,?>>> conversionsByIndex,String[] values){
  if (conversionsMap == null) {
    return;
  }
  Conversion<String,?>[] conversions=conversionsMap.get(selector);
  if (conversions == null) {
    return;
  }
  if (!writing && conversionsMap.size() > values.length) {
    boolean isSelectionOfNames=true;
    for (    FieldSelector expectedSelection : conversionsMap.keySet()) {
      if (!(expectedSelection instanceof FieldNameSelector || expectedSelection instanceof FieldEnumSelector)) {
        isSelectionOfNames=false;
        break;
      }
    }
    if (isSelectionOfNames) {
      int i=values.length;
      values=Arrays.copyOf(values,conversionsMap.size() + 1);
      for (      FieldSelector expectedSelection : conversionsMap.keySet()) {
        List<?> selection=((FieldSet<?>)expectedSelection).get();
        if (selection.size() == 1) {
          String selected=ArgumentUtils.normalize(selection.get(0).toString());
          if (ArgumentUtils.indexOf(values,selected) == -1) {
            values[i++]=selected;
          }
        }
      }
    }
  }
  int[] fieldIndexes=selector.getFieldIndexes(values);
  for (  int fieldIndex : fieldIndexes) {
    List<Conversion<?,?>> conversionsAtIndex=conversionsByIndex.get(fieldIndex);
    if (conversionsAtIndex == null) {
      conversionsAtIndex=new ArrayList<Conversion<?,?>>();
      conversionsByIndex.put(fieldIndex,conversionsAtIndex);
    }
    validateDuplicates(selector,conversionsAtIndex,conversions);
    conversionsAtIndex.addAll(Arrays.asList(conversions));
  }
}",0.7695229052931403
163413,"/** 
 * {@inheritDoc}
 */
@Override public int[] getFieldIndexes(String[] headers){
  headers=ArgumentUtils.normalize(headers);
  List<String> var=this.get();
  String[] chosenFields=ArgumentUtils.normalize(var.toArray(new String[var.size()]));
  Object[] unknownFields=ArgumentUtils.findMissingElements(headers,chosenFields);
  if (unknownFields.length > 0) {
    throw new IllegalStateException(""String_Node_Str"" + Arrays.toString(unknownFields) + ""String_Node_Str""+ Arrays.toString(headers));
  }
  int[] out=new int[chosenFields.length];
  int i=0;
  for (  String chosenField : chosenFields) {
    out[i++]=ArgumentUtils.indexOf(headers,chosenField);
  }
  return out;
}","/** 
 * {@inheritDoc}
 */
@Override public int[] getFieldIndexes(String[] headers){
  headers=ArgumentUtils.normalize(headers);
  List<String> var=this.get();
  ArgumentUtils.normalize(var);
  String[] chosenFields=var.toArray(new String[var.size()]);
  Object[] unknownFields=ArgumentUtils.findMissingElements(headers,chosenFields);
  if (unknownFields.length > 0 && !var.containsAll(Arrays.asList(headers))) {
    throw new IllegalStateException(""String_Node_Str"" + Arrays.toString(unknownFields) + ""String_Node_Str""+ Arrays.toString(headers));
  }
  int[] out=new int[chosenFields.length];
  int i=0;
  Set<Integer> indexesTaken=new HashSet<Integer>();
  for (  String chosenField : chosenFields) {
    int index=ArgumentUtils.indexOf(headers,chosenField);
    if (index != -1) {
      indexesTaken.add(index);
    }
    out[i++]=index;
  }
  int generatedIndex=0;
  for (i=0; i < out.length; i++) {
    if (out[i] == -1) {
      while (indexesTaken.contains(generatedIndex)) {
        generatedIndex++;
      }
      indexesTaken.add(generatedIndex);
      out[i]=generatedIndex;
    }
  }
  return out;
}",0.6681614349775785
163414,"/** 
 * Identifies which fields are associated with which columns in a row.
 * @param row              A row with values for the given java bean.
 * @param headers          The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes          The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldIndexes(ParsingContext context,Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  if (headers == null) {
    headers=ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  int biggestIndex=headers.length > row.length ? headers.length : row.length;
  for (  FieldMapping mapping : parsedFields) {
    int index=mapping.getIndex();
    if (biggestIndex < index) {
      biggestIndex=index;
    }
  }
  FieldMapping[] fieldOrder=new FieldMapping[biggestIndex];
  TreeSet<String> fieldsNotFound=new TreeSet<String>();
  for (  FieldMapping mapping : parsedFields) {
    if (mapping.isMappedToField()) {
      int index=ArgumentUtils.indexOf(headers,mapping.getFieldName());
      if (index == -1) {
        fieldsNotFound.add(mapping.getFieldName());
        continue;
      }
      fieldOrder[index]=mapping;
    }
 else {
      if (mapping.getIndex() < fieldOrder.length) {
        fieldOrder[mapping.getIndex()]=mapping;
      }
    }
  }
  if (context != null && !fieldsNotFound.isEmpty()) {
    if (headers.length == 0) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
    }
    throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str""+ Arrays.toString(headers));
  }
  if (indexes != null) {
    for (int i=0; i < fieldOrder.length; i++) {
      boolean isIndexUsed=false;
      for (int j=0; j < indexes.length; j++) {
        if (indexes[j] == i) {
          isIndexUsed=true;
          break;
        }
      }
      if (!isIndexUsed) {
        fieldOrder[i]=null;
      }
    }
    if (columnsReordered) {
      FieldMapping[] newFieldOrder=new FieldMapping[indexes.length];
      for (int i=0; i < indexes.length; i++) {
        for (int j=0; j < fieldOrder.length; j++) {
          int index=indexes[i];
          FieldMapping field=fieldOrder[index];
          newFieldOrder[i]=field;
        }
      }
      fieldOrder=newFieldOrder;
    }
  }
  this.readOrder=fieldOrder;
}","/** 
 * Identifies which fields are associated with which columns in a row.
 * @param row              A row with values for the given java bean.
 * @param headers          The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes          The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldIndexes(ParsingContext context,Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  if (headers == null) {
    headers=ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  int biggestIndex=headers.length > row.length ? headers.length : row.length;
  for (  FieldMapping mapping : parsedFields) {
    int index=mapping.getIndex();
    if (biggestIndex < index) {
      biggestIndex=index;
    }
  }
  FieldMapping[] fieldOrder=new FieldMapping[biggestIndex];
  TreeSet<String> fieldsNotFound=new TreeSet<String>();
  for (  FieldMapping mapping : parsedFields) {
    if (mapping.isMappedToField()) {
      int index=ArgumentUtils.indexOf(headers,mapping.getFieldName());
      if (index == -1) {
        fieldsNotFound.add(mapping.getFieldName());
        continue;
      }
      fieldOrder[index]=mapping;
    }
 else     if (mapping.getIndex() < fieldOrder.length) {
      fieldOrder[mapping.getIndex()]=mapping;
    }
  }
  if (context != null && !fieldsNotFound.isEmpty()) {
    if (headers.length == 0) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
    }
    if (strictHeaderValidationEnabled) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str""+ Arrays.toString(headers));
    }
  }
  if (indexes != null) {
    for (int i=0; i < fieldOrder.length; i++) {
      boolean isIndexUsed=false;
      for (int j=0; j < indexes.length; j++) {
        if (indexes[j] == i) {
          isIndexUsed=true;
          break;
        }
      }
      if (!isIndexUsed) {
        fieldOrder[i]=null;
      }
    }
    if (columnsReordered) {
      FieldMapping[] newFieldOrder=new FieldMapping[indexes.length];
      for (int i=0; i < indexes.length; i++) {
        for (int j=0; j < fieldOrder.length; j++) {
          int index=indexes[i];
          FieldMapping field=fieldOrder[index];
          newFieldOrder[i]=field;
        }
      }
      fieldOrder=newFieldOrder;
    }
  }
  this.readOrder=fieldOrder;
}",0.967084924531733
163415,"private void initalizeMetadataConversions(String[] data,MetaData md){
  if (conversions != null) {
    String[] headers=headers();
    if (headers == null) {
      headers=data;
    }
    conversions.prepareExecution(headers);
    md.setDefaultConversions(conversions.getConversions(md.index,md.type));
  }
}","private void initalizeMetadataConversions(String[] data,MetaData md){
  if (conversions != null) {
    String[] headers=headers();
    if (headers == null) {
      headers=data;
    }
    conversions.prepareExecution(false,headers);
    md.setDefaultConversions(conversions.getConversions(md.index,md.type));
  }
}",0.990353697749196
163416,"@Test public void ensureExceptionsAreThrown(){
  CsvParserSettings parserSettings=new CsvParserSettings();
  BeanListProcessor<AB> beanProcessor=new BeanListProcessor<AB>(AB.class);
  parserSettings.setRowProcessor(beanProcessor);
  CsvParser parser=new CsvParser(parserSettings);
  try {
    parser.parse(new StringReader(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  TextParsingException e) {
  }
}","/** 
 * As of https://github.com/uniVocity/univocity-parsers/issues/48, this test is no longer valid by default Originally the parser would force an exact match of headers declared in the bean and in the input. With the changes introduced in Github_48, the parsing process became less strict to allow beans to be loaded using inputs with varying number of columns. When a column is not found in the input the values attributed to the bean will be considered null. If conversions are defined for that field, they will be applied over the null value. To keep getting errors when headers are not fully matched, enable the strict header validation using  {@link BeanProcessor#setStrictHeaderValidationEnabled(boolean)}
 */
@Test public void ensureExceptionsAreThrown(){
  CsvParserSettings parserSettings=new CsvParserSettings();
  BeanListProcessor<AB> beanProcessor=new BeanListProcessor<AB>(AB.class);
  beanProcessor.setStrictHeaderValidationEnabled(true);
  parserSettings.setRowProcessor(beanProcessor);
  CsvParser parser=new CsvParser(parserSettings);
  try {
    parser.parse(new StringReader(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  TextParsingException e) {
  }
}",0.5189323401613904
163417,"/** 
 * In case of any exceptions, a   {@link TextWritingException} is thrown, and the output {@link java.io.Writer} is closed.
 * @param message Description of the error
 * @param recordValues values used to write to the output at the time the exception happened
 * @param cause the exception to be wrapped by a {@link TextWritingException}
 */
private TextWritingException throwExceptionAndClose(String message,Object[] recordValues,Throwable cause){
  try {
    throw new TextWritingException(message,recordCount,recordValues,cause);
  }
  finally {
    close();
  }
}","/** 
 * In case of any exceptions, a   {@link TextWritingException} is thrown, and the output {@link java.io.Writer} is closed.
 * @param message Description of the error
 * @param recordValues values used to write to the output at the time the exception happened
 * @param cause the exception to be wrapped by a {@link TextWritingException}
 */
private TextWritingException throwExceptionAndClose(String message,Object[] recordValues,Throwable cause){
  try {
    throw new TextWritingException(message,recordCount,recordValues,cause);
  }
  finally {
    try {
      close();
    }
 catch (    Throwable t) {
    }
  }
}",0.9522212908633696
163418,"/** 
 * Used when fields were selected and the input rows have a different order than the output. This method fills the internal #outputRow array with the values provided by the user in the correct order.
 * @param row user-provided data which has to be rearranged to the expected record sequence before writing to the output.
 */
private <T>void fillOutputRow(T[] row){
  if (row.length > indexesToWrite.length) {
    String msg=""String_Node_Str"" + this.indexesToWrite.length + ""String_Node_Str""+ row.length+ ""String_Node_Str"";
    throwExceptionAndClose(msg,headers,null);
  }
  for (int i=0; i < indexesToWrite.length && i < row.length; i++) {
    outputRow[indexesToWrite[i]]=row[i];
  }
}","/** 
 * Used when fields were selected and the input rows have a different order than the output. This method fills the internal #outputRow array with the values provided by the user in the correct order.
 * @param row user-provided data which has to be rearranged to the expected record sequence before writing to the output.
 */
private <T>void fillOutputRow(T[] row){
  if (row.length > outputRow.length) {
    outputRow=row;
  }
 else   if (row.length > indexesToWrite.length) {
    for (int i=0; i < indexesToWrite.length; i++) {
      outputRow[indexesToWrite[i]]=row[indexesToWrite[i]];
    }
  }
 else {
    for (int i=0; i < indexesToWrite.length && i < row.length; i++) {
      outputRow[indexesToWrite[i]]=row[i];
    }
  }
}",0.7179846046186145
163419,"void processField(Field field,PropertyDescriptor propertyDescriptor){
  Parsed annotation=field.getAnnotation(Parsed.class);
  if (annotation != null) {
    FieldMapping mapping=new FieldMapping(beanClass,field,propertyDescriptor);
    parsedFields.add(mapping);
    setupConversions(field,mapping);
  }
}","/** 
 * Determines whether or not an annotated field should be processed. Can be overridden by subclasses for fine grained control.
 * @param field the field to be processed
 * @return {@code true} if the given field should be processed, otherwise {@code false}.
 */
protected boolean processField(FieldMapping field){
  return true;
}",0.0875
163420,"/** 
 * Identifies which fields are associated with which columns in a row.
 * @param row              A row with values for the given java bean.
 * @param headers          The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes          The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldIndexes(ParsingContext context,Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  if (headers == null) {
    headers=ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  int biggestIndex=headers.length > row.length ? headers.length : row.length;
  for (  FieldMapping mapping : parsedFields) {
    int index=mapping.getIndex();
    if (biggestIndex < index) {
      biggestIndex=index;
    }
  }
  FieldMapping[] fieldOrder=new FieldMapping[biggestIndex];
  TreeSet<String> fieldsNotFound=new TreeSet<String>();
  for (  FieldMapping mapping : parsedFields) {
    if (mapping.isMappedToField()) {
      int index=ArgumentUtils.indexOf(headers,mapping.getFieldName());
      if (index == -1) {
        fieldsNotFound.add(mapping.getFieldName());
      }
      fieldOrder[index]=mapping;
    }
 else {
      if (mapping.getIndex() < fieldOrder.length) {
        fieldOrder[mapping.getIndex()]=mapping;
      }
    }
  }
  if (!fieldsNotFound.isEmpty()) {
    if (headers.length == 0) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
    }
    throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str""+ Arrays.toString(headers));
  }
  if (indexes != null) {
    for (int i=0; i < fieldOrder.length; i++) {
      boolean isIndexUsed=false;
      for (int j=0; j < indexes.length; j++) {
        if (indexes[j] == i) {
          isIndexUsed=true;
          break;
        }
      }
      if (!isIndexUsed) {
        fieldOrder[i]=null;
      }
    }
    if (columnsReordered) {
      FieldMapping[] newFieldOrder=new FieldMapping[indexes.length];
      for (int i=0; i < indexes.length; i++) {
        for (int j=0; j < fieldOrder.length; j++) {
          int index=indexes[i];
          FieldMapping field=fieldOrder[index];
          newFieldOrder[i]=field;
        }
      }
      fieldOrder=newFieldOrder;
    }
  }
  this.readOrder=fieldOrder;
}","/** 
 * Identifies which fields are associated with which columns in a row.
 * @param row              A row with values for the given java bean.
 * @param headers          The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes          The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldIndexes(ParsingContext context,Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  if (headers == null) {
    headers=ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  int biggestIndex=headers.length > row.length ? headers.length : row.length;
  for (  FieldMapping mapping : parsedFields) {
    int index=mapping.getIndex();
    if (biggestIndex < index) {
      biggestIndex=index;
    }
  }
  FieldMapping[] fieldOrder=new FieldMapping[biggestIndex];
  TreeSet<String> fieldsNotFound=new TreeSet<String>();
  for (  FieldMapping mapping : parsedFields) {
    if (mapping.isMappedToField()) {
      int index=ArgumentUtils.indexOf(headers,mapping.getFieldName());
      if (index == -1) {
        fieldsNotFound.add(mapping.getFieldName());
        continue;
      }
      fieldOrder[index]=mapping;
    }
 else {
      if (mapping.getIndex() < fieldOrder.length) {
        fieldOrder[mapping.getIndex()]=mapping;
      }
    }
  }
  if (context != null && !fieldsNotFound.isEmpty()) {
    if (headers.length == 0) {
      throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str"");
    }
    throw new DataProcessingException(""String_Node_Str"" + fieldsNotFound.toString() + ""String_Node_Str""+ Arrays.toString(headers));
  }
  if (indexes != null) {
    for (int i=0; i < fieldOrder.length; i++) {
      boolean isIndexUsed=false;
      for (int j=0; j < indexes.length; j++) {
        if (indexes[j] == i) {
          isIndexUsed=true;
          break;
        }
      }
      if (!isIndexUsed) {
        fieldOrder[i]=null;
      }
    }
    if (columnsReordered) {
      FieldMapping[] newFieldOrder=new FieldMapping[indexes.length];
      for (int i=0; i < indexes.length; i++) {
        for (int j=0; j < fieldOrder.length; j++) {
          int index=indexes[i];
          FieldMapping field=fieldOrder[index];
          newFieldOrder[i]=field;
        }
      }
      fieldOrder=newFieldOrder;
    }
  }
  this.readOrder=fieldOrder;
}",0.9931822369633316
163421,"/** 
 * Converts a java bean instance into a sequence of values for writing.
 * @param bean           an instance of the type defined in this class constructor.
 * @param headers        All field names used to produce records in a given destination. May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexesToWrite The indexes of the headers that are actually being written. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @return a row of objects containing the values extracted from the java bean
 */
public final Object[] reverseConversions(T bean,String[] headers,int[] indexesToWrite){
  if (bean == null) {
    return null;
  }
  Object[] row;
  if (indexesToWrite != null) {
    row=new Object[indexesToWrite.length];
  }
 else   if (headers != null) {
    row=new Object[headers.length];
  }
 else {
    throw new TextWritingException(""String_Node_Str"" + bean.getClass().getName() + ""String_Node_Str"",-1,new Object[]{bean});
  }
  try {
    mapFieldsToValues(bean,row,headers,indexesToWrite,false);
  }
 catch (  DataProcessingException ex) {
    ex.markAsNonFatal();
    if (!beanClass.isAssignableFrom(bean.getClass())) {
      handleConversionError(ex,new Object[]{bean},-1);
    }
 else {
      handleConversionError(ex,row,-1);
    }
    return null;
  }
  if (super.reverseConversions(true,row,headers,indexesToWrite)) {
    return row;
  }
  return null;
}","/** 
 * Converts a java bean instance into a sequence of values for writing.
 * @param bean           an instance of the type defined in this class constructor.
 * @param headers        All field names used to produce records in a given destination. May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexesToWrite The indexes of the headers that are actually being written. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @return a row of objects containing the values extracted from the java bean
 */
public final Object[] reverseConversions(T bean,String[] headers,int[] indexesToWrite){
  if (bean == null) {
    return null;
  }
  Object[] row;
  if (headers != null) {
    row=new Object[headers.length];
  }
 else   if (indexesToWrite != null) {
    row=new Object[indexesToWrite.length];
  }
 else {
    throw new TextWritingException(""String_Node_Str"" + bean.getClass().getName() + ""String_Node_Str"",-1,new Object[]{bean});
  }
  try {
    mapFieldsToValues(bean,row,headers,indexesToWrite,false);
  }
 catch (  DataProcessingException ex) {
    ex.markAsNonFatal();
    if (!beanClass.isAssignableFrom(bean.getClass())) {
      handleConversionError(ex,new Object[]{bean},-1);
    }
 else {
      handleConversionError(ex,row,-1);
    }
    return null;
  }
  if (super.reverseConversions(true,row,headers,indexesToWrite)) {
    return row;
  }
  return null;
}",0.9722222222222222
163422,"/** 
 * Converts the java bean instance into a sequence of values for writing.
 * @param input an instance of the type defined in this class constructor.
 * @param headers All field names used to produce records in a given destination. May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexesToWrite The indexes of the headers that are actually being written. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @return a row of objects containing the values extracted from the java bean
 */
@Override public Object[] write(T input,String[] headers,int[] indexesToWrite){
  super.initialize();
  return reverseConversions(input,headers,indexesToWrite);
}","/** 
 * Converts the java bean instance into a sequence of values for writing.
 * @param input an instance of the type defined in this class constructor.
 * @param headers All field names used to produce records in a given destination. May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexesToWrite The indexes of the headers that are actually being written. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @return a row of objects containing the values extracted from the java bean
 */
@Override public Object[] write(T input,String[] headers,int[] indexesToWrite){
  if (!initialized) {
    this.headers=headers;
    super.initialize();
    this.headers=null;
  }
  return reverseConversions(input,headers,indexesToWrite);
}",0.9536423841059604
163423,"/** 
 * Defines a conversion from String to   {@link java.math.BigDecimal} using a sequence of acceptable numeric patterns.This constructor assumes the output of a conversion should be null when input is null
 * @param numericFormats list of acceptable numeric patterns. The first pattern in this sequence will be used to convert a BigDecimal into a String in <code>revert(BigDecimal)</code>.
 */
public FormattedBigDecimalConversion(String... numericFormats){
  super(numericFormats);
}","/** 
 * Defines a conversion from String to   {@link java.math.BigDecimal} using a sequence of acceptable numeric patterns. The patternsmust be added to this conversion class through the  {@link #addFormat(String,String)} method.This constructor assumes the output of a conversion should be null when input is null
 */
public FormattedBigDecimalConversion(){
  super();
}",0.6177156177156177
163424,"/** 
 * Defines a conversion from String to   {@link java.lang.Number} using a sequence of acceptable numeric patterns.This constructor assumes the output of a conversion should be null when input is null
 * @param numericFormats list of acceptable numeric patterns. The first pattern in this sequence will be used to convert a Number into a String in {@link NumericConversion#revert(Number)}.
 */
public NumericConversion(String... numericFormats){
  this(null,null,numericFormats);
}","/** 
 * Defines a conversion from String to   {@link java.lang.Number} using a sequence of acceptable numeric patterns. The patternsmust be added to this conversion class through the  {@link #addFormat(String,String)} method.This constructor assumes the output of a conversion should be null when input is null
 */
public NumericConversion(){
  super();
}",0.4166666666666667
163425,"/** 
 * Converts a formatted numeric String to an instance of Number. <p>The pattern in the formatted input must match one of the numeric patterns provided in the constructor of this class.
 * @param input the String containing a formatted number which must be converted to a number
 * @return the Number instance containing the value represented by the given String, or the value of {@link ObjectConversion#getValueIfStringIsNull()} if the String input is null.
 */
@SuppressWarnings(""String_Node_Str"") @Override protected T fromString(String input){
  for (  DecimalFormat formatter : formatters) {
    try {
      return (T)formatter.parse(input);
    }
 catch (    ParseException ex) {
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"" + input + ""String_Node_Str""+ Arrays.toString(formats));
}","/** 
 * Converts a formatted numeric String to an instance of Number. <p>The pattern in the formatted input must match one of the numeric patterns provided in the constructor of this class.
 * @param input the String containing a formatted number which must be converted to a number
 * @return the Number instance containing the value represented by the given String, or the value of {@link ObjectConversion#getValueIfStringIsNull()} if the String input is null.
 */
@SuppressWarnings(""String_Node_Str"") @Override protected T fromString(String input){
  for (int i=0; i < formatters.length; i++) {
    position.setIndex(0);
    T out=(T)formatters[i].parse(input,position);
    if (position.getIndex() < input.length() && formatters.length > 1) {
      continue;
    }
 else {
      return out;
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"" + input + ""String_Node_Str""+ Arrays.toString(formats));
}",0.7750144592249856
163426,"private boolean quoteElement(String nextElement){
  if (quoteAllFields) {
    return true;
  }
  if (nextElement == null) {
    return false;
  }
  for (int j=0; j < nextElement.length(); j++) {
    char nextChar=nextElement.charAt(j);
    if (nextChar == separator || nextChar == newLine) {
      return true;
    }
  }
  return false;
}","private boolean quoteElement(String nextElement){
  if (quoteAllFields) {
    return true;
  }
  if (nextElement == null) {
    return false;
  }
  for (int j=0; j < nextElement.length(); j++) {
    char nextChar=nextElement.charAt(j);
    if (nextChar == separator || nextChar == newLine || nextChar == quotechar) {
      return true;
    }
  }
  return false;
}",0.9643366619115548
163427,"private boolean quoteElement(String nextElement){
  if (quoteAllFields) {
    return true;
  }
  if (nextElement == null) {
    return false;
  }
  for (int j=0; j < nextElement.length(); j++) {
    char nextChar=nextElement.charAt(j);
    if (nextChar == separator || nextChar == newLine) {
      return true;
    }
  }
  return false;
}","private boolean quoteElement(String nextElement){
  if (quoteAllFields) {
    return true;
  }
  if (nextElement == null) {
    return false;
  }
  for (int j=0; j < nextElement.length(); j++) {
    char nextChar=nextElement.charAt(j);
    if (nextChar == separator || nextChar == newLine || nextChar == quotechar) {
      return true;
    }
  }
  return false;
}",0.9643366619115548
163428,"/** 
 * Defines a conversion from String to   {@link java.math.BigDecimal} using a sequence of acceptable numeric patterns.This constructor assumes the output of a conversion should be null when input is null
 * @param numericFormats list of acceptable numeric patterns. The first pattern in this sequence will be used to convert a BigDecimal into a String in <code>revert(BigDecimal)</code>.
 */
public FormattedBigDecimalConversion(String... numericFormats){
  super(numericFormats);
}","/** 
 * Defines a conversion from String to   {@link java.math.BigDecimal} using a sequence of acceptable numeric patterns. The patternsmust be added to this conversion class through the  {@link #addFormat(String,String)} method.This constructor assumes the output of a conversion should be null when input is null
 */
public FormattedBigDecimalConversion(){
  super();
}",0.6177156177156177
163429,"/** 
 * Defines a conversion from String to   {@link java.lang.Number} using a sequence of acceptable numeric patterns.This constructor assumes the output of a conversion should be null when input is null
 * @param numericFormats list of acceptable numeric patterns. The first pattern in this sequence will be used to convert a Number into a String in {@link NumericConversion#revert(Number)}.
 */
public NumericConversion(String... numericFormats){
  this(null,null,numericFormats);
}","/** 
 * Defines a conversion from String to   {@link java.lang.Number} using a sequence of acceptable numeric patterns. The patternsmust be added to this conversion class through the  {@link #addFormat(String,String)} method.This constructor assumes the output of a conversion should be null when input is null
 */
public NumericConversion(){
  super();
}",0.4166666666666667
163430,"/** 
 * Converts a formatted numeric String to an instance of Number. <p>The pattern in the formatted input must match one of the numeric patterns provided in the constructor of this class.
 * @param input the String containing a formatted number which must be converted to a number
 * @return the Number instance containing the value represented by the given String, or the value of {@link ObjectConversion#getValueIfStringIsNull()} if the String input is null.
 */
@SuppressWarnings(""String_Node_Str"") @Override protected T fromString(String input){
  for (  DecimalFormat formatter : formatters) {
    try {
      return (T)formatter.parse(input);
    }
 catch (    ParseException ex) {
    }
  }
  throw new DataProcessingException(""String_Node_Str"" + input + ""String_Node_Str""+ Arrays.toString(formats));
}","/** 
 * Converts a formatted numeric String to an instance of Number. <p>The pattern in the formatted input must match one of the numeric patterns provided in the constructor of this class.
 * @param input the String containing a formatted number which must be converted to a number
 * @return the Number instance containing the value represented by the given String, or the value of {@link ObjectConversion#getValueIfStringIsNull()} if the String input is null.
 */
@SuppressWarnings(""String_Node_Str"") @Override protected T fromString(String input){
  for (int i=0; i < formatters.length; i++) {
    position.setIndex(0);
    T out=(T)formatters[i].parse(input,position);
    if (position.getIndex() < input.length() && formatters.length > 1) {
      continue;
    }
 else {
      return out;
    }
  }
  throw new DataProcessingException(""String_Node_Str"" + input + ""String_Node_Str""+ Arrays.toString(formats));
}",0.7492762015055009
163431,"/** 
 * Configures the parser to process escape sequences in unquoted values. Defaults to   {@code false}. <p>By default, this is disabled and if the input is   {@code A""""B,C}, the resulting value will be  {@code [A""""B] and [C]} (i.e. the content is read as-is). However, if the parser is configured to process escape sequences in unquoted values, the result will be  {@code [A""B] and [C]}</p>
 * @param escapeUnquotedValues a flag indicating whether escape sequences should be processed in unquoted values 
 */
public void setEscapeUnquotedValues(boolean escapeUnquotedValues){
  this.escapeUnquotedValues=escapeUnquotedValues;
}","/** 
 * Configures the parser to process escape sequences in unquoted values. Defaults to   {@code false}. <p>By default, this is disabled and if the input is   {@code A""""B,C}, the resulting value will be  {@code [A""""B] and [C]} (i.e. the content is read as-is). However, if the parser is configuredto process escape sequences in unquoted values, the result will be  {@code [A""B] and [C]}</p>
 * @param escapeUnquotedValues a flag indicating whether escape sequences should be processed in unquoted values
 */
public void setEscapeUnquotedValues(boolean escapeUnquotedValues){
  this.escapeUnquotedValues=escapeUnquotedValues;
}",0.9984101748807632
163432,"/** 
 * Indicates whether escape sequences should be processed in unquoted values. Defaults to   {@code false}. <p>By default, this is disabled and if the input is   {@code A""""B,C}, the resulting value will be  {@code [A""""B] and [C]} (i.e. the content is read as-is). However, if the parser is configured to process escape sequences in unquoted values, the result will be  {@code [A""B] and [C]}</p>
 * @return true if escape sequences should be processed in unquoted values, otherwise false 
 */
public boolean isEscapeUnquotedValues(){
  return escapeUnquotedValues;
}","/** 
 * Indicates whether escape sequences should be processed in unquoted values. Defaults to   {@code false}. <p>By default, this is disabled and if the input is   {@code A""""B,C}, the resulting value will be  {@code [A""""B] and [C]} (i.e. the content is read as-is). However, if the parser is configuredto process escape sequences in unquoted values, the result will be  {@code [A""B] and [C]}</p>
 * @return true if escape sequences should be processed in unquoted values, otherwise false
 */
public boolean isEscapeUnquotedValues(){
  return escapeUnquotedValues;
}",0.9982394366197184
163433,"/** 
 * The CsvWriter supports all settings provided by   {@link CsvWriterSettings}, and requires this configuration to be properly initialized.
 * @param writer the output resource that will receive CSV records produced by this class.
 * @param settings the CSV writer configuration
 */
public CsvWriter(Writer writer,CsvWriterSettings settings){
  super(writer,settings);
  CsvFormat format=settings.getFormat();
  this.separator=format.getDelimiter();
  this.quotechar=format.getQuote();
  this.escapechar=format.getQuoteEscape();
  this.newLine=format.getNormalizedNewline();
  this.quoteAllFields=settings.getQuoteAllFields();
  this.ignoreLeading=settings.getIgnoreLeadingWhitespaces();
  this.ignoreTrailing=settings.getIgnoreTrailingWhitespaces();
}","/** 
 * The CsvWriter supports all settings provided by   {@link CsvWriterSettings}, and requires this configuration to be properly initialized.
 * @param writer the output resource that will receive CSV records produced by this class.
 * @param settings the CSV writer configuration
 */
public CsvWriter(Writer writer,CsvWriterSettings settings){
  super(writer,settings);
  CsvFormat format=settings.getFormat();
  this.separator=format.getDelimiter();
  this.quotechar=format.getQuote();
  this.escapechar=format.getQuoteEscape();
  this.escapeEscape=settings.getFormat().getCharToEscapeQuoteEscaping();
  this.newLine=format.getNormalizedNewline();
  this.quoteAllFields=settings.getQuoteAllFields();
  this.ignoreLeading=settings.getIgnoreLeadingWhitespaces();
  this.ignoreTrailing=settings.getIgnoreTrailingWhitespaces();
  this.escapeUnquoted=settings.isEscapeUnquotedValues();
}",0.9209245742092458
163434,"private void append(boolean isElementQuoted,String element){
  if (element == null) {
    element=nullValue;
  }
  if (element == null) {
    return;
  }
  int start=0;
  if (this.ignoreLeading) {
    start=skipLeadingWhitespace(element);
  }
  if (this.ignoreTrailing) {
    for (int i=start; i < element.length(); i++) {
      char nextChar=element.charAt(i);
      if (isElementQuoted && nextChar == quotechar) {
        appender.appendIgnoringWhitespace(escapechar);
      }
      appender.appendIgnoringWhitespace(nextChar);
    }
  }
 else {
    for (int i=start; i < element.length(); i++) {
      char nextChar=element.charAt(i);
      if (isElementQuoted && nextChar == quotechar) {
        appender.append(escapechar);
      }
      appender.append(nextChar);
    }
  }
}","private void append(boolean isElementQuoted,String element){
  if (element == null) {
    element=nullValue;
  }
  if (element == null) {
    return;
  }
  int start=0;
  if (this.ignoreLeading) {
    start=skipLeadingWhitespace(element);
  }
  if (this.ignoreTrailing) {
    for (int i=start; i < element.length(); i++) {
      char nextChar=element.charAt(i);
      if (nextChar == quotechar && (isElementQuoted || escapeUnquoted)) {
        appender.appendIgnoringWhitespace(escapechar);
      }
 else       if (nextChar == escapechar && escapeEscape != '\0' && (isElementQuoted || escapeUnquoted)) {
        appender.appendIgnoringWhitespace(escapeEscape);
      }
      appender.appendIgnoringWhitespace(nextChar);
    }
  }
 else {
    for (int i=start; i < element.length(); i++) {
      char nextChar=element.charAt(i);
      if (nextChar == quotechar && (isElementQuoted || escapeUnquoted)) {
        appender.append(escapechar);
      }
 else       if (nextChar == escapechar && escapeEscape != '\0' && (isElementQuoted || escapeUnquoted)) {
        appender.appendIgnoringWhitespace(escapeEscape);
      }
      appender.append(nextChar);
    }
  }
}",0.7497425334706488
163435,"@Override protected void addConfiguration(Map<String,Object> out){
  super.addConfiguration(out);
  out.put(""String_Node_Str"",quoteAllFields);
}","@Override protected void addConfiguration(Map<String,Object> out){
  super.addConfiguration(out);
  out.put(""String_Node_Str"",quoteAllFields);
  out.put(""String_Node_Str"",escapeUnquotedValues);
}",0.8495575221238938
163436,"private void setAlignment(FieldAlignment alignment,int position){
  if (alignment == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  validateIndex(position);
  this.fieldAlignment.set(position,alignment);
}","private void setAlignment(int position,FieldAlignment alignment){
  if (alignment == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  validateIndex(position);
  this.fieldAlignment.set(position,alignment);
}",0.9437229437229436
163437,"/** 
 * Identifies which fields are associated with which columns in a row.
 * @param row A row with values for the given java bean.
 * @param headers The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldIndexes(Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  this.fieldIndexesMapped=true;
  if (headers == null) {
    headers=ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  int biggestIndex=headers.length > row.length ? headers.length : row.length;
  for (  FieldMapping mapping : parsedFields) {
    int index=mapping.getIndex();
    if (biggestIndex < index) {
      biggestIndex=index;
    }
  }
  FieldMapping[] fieldOrder=new FieldMapping[biggestIndex];
  for (  FieldMapping mapping : parsedFields) {
    if (mapping.isMappedToField()) {
      int index=ArgumentUtils.indexOf(headers,mapping.getFieldName());
      if (index == -1) {
        throw new IllegalStateException(""String_Node_Str"" + mapping.getFieldName() + ""String_Node_Str""+ Arrays.toString(headers));
      }
      fieldOrder[index]=mapping;
    }
 else {
      fieldOrder[mapping.getIndex()]=mapping;
    }
  }
  if (indexes != null) {
    for (int i=0; i < fieldOrder.length; i++) {
      boolean isIndexUsed=false;
      for (int j=0; j < indexes.length; j++) {
        if (indexes[j] == i) {
          isIndexUsed=true;
          break;
        }
      }
      if (!isIndexUsed) {
        fieldOrder[i]=null;
      }
    }
    if (columnsReordered) {
      FieldMapping[] newFieldOrder=new FieldMapping[indexes.length];
      for (int i=0; i < indexes.length; i++) {
        for (int j=0; j < fieldOrder.length; j++) {
          int index=indexes[i];
          FieldMapping field=fieldOrder[index];
          newFieldOrder[i]=field;
        }
      }
      fieldOrder=newFieldOrder;
    }
  }
  this.readOrder=fieldOrder;
}","/** 
 * Identifies which fields are associated with which columns in a row.
 * @param row A row with values for the given java bean.
 * @param headers The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldIndexes(Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  if (headers == null) {
    headers=ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  int biggestIndex=headers.length > row.length ? headers.length : row.length;
  for (  FieldMapping mapping : parsedFields) {
    int index=mapping.getIndex();
    if (biggestIndex < index) {
      biggestIndex=index;
    }
  }
  FieldMapping[] fieldOrder=new FieldMapping[biggestIndex];
  for (  FieldMapping mapping : parsedFields) {
    if (mapping.isMappedToField()) {
      int index=ArgumentUtils.indexOf(headers,mapping.getFieldName());
      if (index == -1) {
        throw new IllegalStateException(""String_Node_Str"" + mapping.getFieldName() + ""String_Node_Str""+ Arrays.toString(headers));
      }
      fieldOrder[index]=mapping;
    }
 else {
      if (mapping.getIndex() < fieldOrder.length) {
        fieldOrder[mapping.getIndex()]=mapping;
      }
    }
  }
  if (indexes != null) {
    for (int i=0; i < fieldOrder.length; i++) {
      boolean isIndexUsed=false;
      for (int j=0; j < indexes.length; j++) {
        if (indexes[j] == i) {
          isIndexUsed=true;
          break;
        }
      }
      if (!isIndexUsed) {
        fieldOrder[i]=null;
      }
    }
    if (columnsReordered) {
      FieldMapping[] newFieldOrder=new FieldMapping[indexes.length];
      for (int i=0; i < indexes.length; i++) {
        for (int j=0; j < fieldOrder.length; j++) {
          int index=indexes[i];
          FieldMapping field=fieldOrder[index];
          newFieldOrder[i]=field;
        }
      }
      fieldOrder=newFieldOrder;
    }
  }
  this.readOrder=fieldOrder;
}",0.979854264894985
163438,"/** 
 * Iterates over all fields in the java bean instance and extracts its values.
 * @param instance the java bean instance to be read
 * @param row object array that will receive the values extracted from java bean
 * @param headers The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldsToValues(T instance,Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  if (!fieldIndexesMapped) {
    mapFieldIndexes(row,headers,indexes,columnsReordered);
  }
  int last=row.length < readOrder.length ? row.length : readOrder.length;
  for (int i=0; i < last; i++) {
    FieldMapping field=readOrder[i];
    if (field != null) {
      row[i]=field.read(instance);
    }
  }
}","/** 
 * Iterates over all fields in the java bean instance and extracts its values.
 * @param instance the java bean instance to be read
 * @param row object array that will receive the values extracted from java bean
 * @param headers The names of all fields of the record (including any header that is not mapped to the java bean). May be null if no headers have been defined in {@link CommonSettings#getHeaders()}
 * @param indexes The indexes of the headers or row that are actually being used. May be null if no fields have been selected using {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param columnsReordered Indicates the indexes provided were reordered and do not match the original sequence of headers.
 */
private void mapFieldsToValues(T instance,Object[] row,String[] headers,int[] indexes,boolean columnsReordered){
  if (row.length > this.lastFieldIndexMapped) {
    mapFieldIndexes(row,headers,indexes,columnsReordered);
  }
  int last=row.length < readOrder.length ? row.length : readOrder.length;
  for (int i=0; i < last; i++) {
    FieldMapping field=readOrder[i];
    if (field != null) {
      row[i]=field.read(instance);
    }
  }
}",0.9887453105460609
163439,"/** 
 * Identifies and extracts fields annotated with the   {@link Parsed} annotation
 */
protected final void initialize(){
  if (!initialized) {
    initialized=true;
    Map<String,PropertyDescriptor> properties=new HashMap<String,PropertyDescriptor>();
    try {
      BeanInfo beanInfo=Introspector.getBeanInfo(beanClass,Object.class);
      for (      PropertyDescriptor property : beanInfo.getPropertyDescriptors()) {
        String name=property.getName();
        properties.put(name,property);
      }
    }
 catch (    IntrospectionException e) {
    }
    Field[] declared=beanClass.getDeclaredFields();
    for (    Field field : declared) {
      Parsed annotation=field.getAnnotation(Parsed.class);
      if (annotation != null) {
        FieldMapping mapping=new FieldMapping(beanClass,field,properties.get(field.getName()));
        parsedFields.add(mapping);
        setupConversions(field,mapping);
      }
    }
    readOrder=null;
    fieldIndexesMapped=false;
  }
}","/** 
 * Identifies and extracts fields annotated with the   {@link Parsed} annotation
 */
protected final void initialize(){
  if (!initialized) {
    initialized=true;
    Map<String,PropertyDescriptor> properties=new HashMap<String,PropertyDescriptor>();
    try {
      BeanInfo beanInfo=Introspector.getBeanInfo(beanClass,Object.class);
      for (      PropertyDescriptor property : beanInfo.getPropertyDescriptors()) {
        String name=property.getName();
        properties.put(name,property);
      }
    }
 catch (    IntrospectionException e) {
    }
    Field[] declared=beanClass.getDeclaredFields();
    for (    Field field : declared) {
      Parsed annotation=field.getAnnotation(Parsed.class);
      if (annotation != null) {
        FieldMapping mapping=new FieldMapping(beanClass,field,properties.get(field.getName()));
        parsedFields.add(mapping);
        setupConversions(field,mapping);
      }
    }
    readOrder=null;
    lastFieldIndexMapped=-1;
  }
}",0.9923973644196656
163440,"/** 
 * Goes through a list of objects and associates each value to a particular field of a java bean instance
 * @param instance the java bean instance that is going to have its properties set
 * @param row the values to associate with each field of the javabean.
 * @param context information about the current parsing process.
 */
private void mapValuesToFields(T instance,Object[] row,ParsingContext context){
  if (!fieldIndexesMapped) {
    mapFieldIndexes(row,context.headers(),context.extractedFieldIndexes(),context.columnsReordered());
  }
  int last=row.length < readOrder.length ? row.length : readOrder.length;
  for (int i=0; i < last; i++) {
    FieldMapping field=readOrder[i];
    if (field != null) {
      Object value=row[i];
      field.write(instance,value);
    }
  }
}","/** 
 * Goes through a list of objects and associates each value to a particular field of a java bean instance
 * @param instance the java bean instance that is going to have its properties set
 * @param row the values to associate with each field of the javabean.
 * @param context information about the current parsing process.
 */
private void mapValuesToFields(T instance,Object[] row,ParsingContext context){
  if (row.length > lastFieldIndexMapped) {
    this.lastFieldIndexMapped=row.length;
    mapFieldIndexes(row,context.headers(),context.extractedFieldIndexes(),context.columnsReordered());
  }
  int last=row.length < readOrder.length ? row.length : readOrder.length;
  for (int i=0; i < last; i++) {
    FieldMapping field=readOrder[i];
    if (field != null) {
      Object value=row[i];
      field.write(instance,value);
    }
  }
}",0.9609756097560976
163441,"/** 
 * {@inheritDoc}
 */
@Override public final char nextChar(){
  if (length == -1) {
    throw new EOFException();
  }
  char ch=buffer[i - 1];
  if (i >= length) {
    if (length != -1) {
      updateBuffer();
    }
 else {
      throw new EOFException();
    }
  }
  i++;
  if (lineSeparator1 == ch && (lineSeparator2 == '\0' || lineSeparator2 == buffer[i - 1])) {
    lineCount++;
    if (lineSeparator2 != '\0') {
      ch=normalizedLineSeparator;
      if (i >= length) {
        if (length != -1) {
          updateBuffer();
        }
 else {
          throw new EOFException();
        }
      }
      if (i < length) {
        i++;
      }
    }
  }
  return ch;
}","/** 
 * {@inheritDoc}
 */
@Override public final char nextChar(){
  if (length == -1) {
    throw new EOFException();
  }
  char ch=buffer[i - 1];
  if (i >= length) {
    if (length != -1) {
      updateBuffer();
    }
 else {
      throw new EOFException();
    }
  }
  i++;
  if (lineSeparator1 == ch && (lineSeparator2 == '\0' || lineSeparator2 == buffer[i - 1])) {
    lineCount++;
    if (lineSeparator2 != '\0') {
      ch=normalizedLineSeparator;
      if (i >= length) {
        if (length != -1) {
          updateBuffer();
        }
 else {
          throw new EOFException();
        }
      }
      if (i < length) {
        i++;
      }
    }
 else {
      return normalizedLineSeparator;
    }
  }
  return ch;
}",0.9386590584878745
163442,"private void parseQuotedValue(char prev){
  ch=input.nextChar();
  while (!(prev == quote && (ch == delimiter || ch == newLine || ch <= ' '))) {
    if (ch != quote) {
      if (prev == quote) {
        if (parseUnescapedQuotes) {
          output.appender.append(quote);
          output.appender.append(ch);
          parseQuotedValue(ch);
          break;
        }
 else {
          throw new TextParsingException(context,""String_Node_Str"" + quote + ""String_Node_Str"");
        }
      }
      output.appender.append(ch);
      prev=ch;
    }
 else     if (prev == quoteEscape) {
      output.appender.append(quote);
      prev='\0';
    }
 else {
      prev=ch;
    }
    ch=input.nextChar();
  }
  if (ch != newLine && ch <= ' ') {
    whitespaceAppender.reset();
    do {
      whitespaceAppender.append(ch);
      ch=input.nextChar();
      if (ch == newLine) {
        return;
      }
    }
 while (ch <= ' ');
    if (!(ch == delimiter || ch == newLine) && parseUnescapedQuotes) {
      if (output.appender instanceof DefaultCharAppender) {
        output.appender.append(quote);
        ((DefaultCharAppender)output.appender).append(whitespaceAppender);
      }
      if (ch != quoteEscape) {
        output.appender.append(ch);
      }
      parseQuotedValue(ch);
    }
  }
  if (!(ch == delimiter || ch == newLine)) {
    throw new TextParsingException(context,""String_Node_Str"" + ch + ""String_Node_Str""+ delimiter+ ""String_Node_Str"");
  }
}","private void parseQuotedValue(char prev){
  ch=input.nextChar();
  while (!(prev == quote && (ch <= ' ' || ch == delimiter || ch == newLine))) {
    if (ch != quote && ch != quoteEscape) {
      if (prev == quote) {
        if (parseUnescapedQuotes) {
          output.appender.append(quote);
          output.appender.append(ch);
          parseQuotedValue(ch);
          break;
        }
 else {
          throw new TextParsingException(context,""String_Node_Str"" + quote + ""String_Node_Str"");
        }
      }
      output.appender.append(ch);
      prev=ch;
    }
 else     if (prev == quoteEscape) {
      if (ch == quote) {
        output.appender.append(quote);
        prev='\0';
      }
 else {
        output.appender.append(prev);
      }
    }
 else {
      prev=ch;
    }
    ch=input.nextChar();
  }
  if (ch != newLine && ch <= ' ') {
    whitespaceAppender.reset();
    do {
      whitespaceAppender.append(ch);
      ch=input.nextChar();
      if (ch == newLine) {
        return;
      }
    }
 while (ch <= ' ');
    if (!(ch == delimiter || ch == newLine) && parseUnescapedQuotes) {
      if (output.appender instanceof DefaultCharAppender) {
        output.appender.append(quote);
        ((DefaultCharAppender)output.appender).append(whitespaceAppender);
      }
      if (ch != quoteEscape) {
        output.appender.append(ch);
      }
      parseQuotedValue(ch);
    }
  }
  if (!(ch == delimiter || ch == newLine)) {
    throw new TextParsingException(context,""String_Node_Str"" + ch + ""String_Node_Str""+ delimiter+ ""String_Node_Str"");
  }
}",0.9298013245033112
163443,"/** 
 * Get all indexes in the given selector and adds the conversions defined at that index to the map of conversionsByIndex. <p>This method is called in the same sequence each selector was created (in   {@link FieldConversionMapping#prepareExecution(String[])}) <p>At the end of the process, the map of conversionsByIndex will have each index with its list of conversions in the order they were declared.
 * @param selector the selected fields for a given conversion sequence.
 * @param conversionsByIndex map of all conversions registered to every field index, in the order they were declared
 * @param values The field sequence that identifies how records will be organized.<p> This is generally the sequence of headers in a record, but it might be just the first parsed row from a given input (as field selection by index is allowed).
 */
public void prepareExecution(FieldSelector selector,Map<Integer,List<Conversion<String,?>>> conversionsByIndex,String[] values){
  if (conversionsMap == null) {
    return;
  }
  Conversion<String,?>[] conversions=conversionsMap.get(selector);
  if (conversions == null) {
    return;
  }
  int[] fieldIndexes=selector.getFieldIndexes(values);
  for (  int fieldIndex : fieldIndexes) {
    List<Conversion<String,?>> conversionsAtIndex=conversionsByIndex.get(fieldIndex);
    if (conversionsAtIndex == null) {
      conversionsAtIndex=new ArrayList<Conversion<String,?>>();
      conversionsByIndex.put(fieldIndex,conversionsAtIndex);
    }
    validateDuplicates(selector,conversionsAtIndex,conversions);
    conversionsAtIndex.addAll(Arrays.asList(conversions));
  }
}","/** 
 * Get all indexes in the given selector and adds the conversions defined at that index to the map of conversionsByIndex. <p>This method is called in the same sequence each selector was created (in   {@link FieldConversionMapping#prepareExecution(String[])}) <p>At the end of the process, the map of conversionsByIndex will have each index with its list of conversions in the order they were declared.
 * @param selector the selected fields for a given conversion sequence.
 * @param conversionsByIndex map of all conversions registered to every field index, in the order they were declared
 * @param values The field sequence that identifies how records will be organized.<p> This is generally the sequence of headers in a record, but it might be just the first parsed row from a given input (as field selection by index is allowed).
 */
public void prepareExecution(FieldSelector selector,Map<Integer,List<Conversion<?,?>>> conversionsByIndex,String[] values){
  if (conversionsMap == null) {
    return;
  }
  Conversion<String,?>[] conversions=conversionsMap.get(selector);
  if (conversions == null) {
    return;
  }
  int[] fieldIndexes=selector.getFieldIndexes(values);
  for (  int fieldIndex : fieldIndexes) {
    List<Conversion<?,?>> conversionsAtIndex=conversionsByIndex.get(fieldIndex);
    if (conversionsAtIndex == null) {
      conversionsAtIndex=new ArrayList<Conversion<?,?>>();
      conversionsByIndex.put(fieldIndex,conversionsAtIndex);
    }
    validateDuplicates(selector,conversionsAtIndex,conversions);
    conversionsAtIndex.addAll(Arrays.asList(conversions));
  }
}",0.9934640522875816
163444,"/** 
 * Applies a sequence of conversions associated with an Object value at a given index in a record.
 * @param executeInReverseOrder flag to indicate whether or not the conversion sequence must be executed in reverse order
 * @param index The index of parsed value in a record
 * @param value The value in a record
 * @return the Object resulting from a sequence of conversions against the original value.
 */
@SuppressWarnings(""String_Node_Str"") public Object reverseConversions(boolean executeInReverseOrder,int index,Object value){
  List<Conversion<String,?>> conversions=conversionsByIndex.get(index);
  if (conversions != null) {
    Conversion<String,?> conversion=null;
    try {
      if (executeInReverseOrder) {
        for (int i=conversions.size() - 1; i >= 0; i--) {
          conversion=conversions.get(i);
          value=((Conversion<String,Object>)conversion).revert(value);
        }
      }
 else {
        for (        Conversion<String,?> c : conversions) {
          conversion=c;
          value=((Conversion<String,Object>)conversion).revert(value);
        }
      }
    }
 catch (    Exception ex) {
      if (conversion != null) {
        throw new IllegalStateException(""String_Node_Str"" + value + ""String_Node_Str""+ conversion.getClass().getName(),ex);
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + value + ""String_Node_Str"",ex);
      }
    }
  }
  return value;
}","/** 
 * Applies a sequence of conversions associated with an Object value at a given index in a record.
 * @param executeInReverseOrder flag to indicate whether or not the conversion sequence must be executed in reverse order
 * @param index The index of parsed value in a record
 * @param value The value in a record
 * @return the Object resulting from a sequence of conversions against the original value.
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public Object reverseConversions(boolean executeInReverseOrder,int index,Object value){
  List<Conversion<?,?>> conversions=conversionsByIndex.get(index);
  if (conversions != null) {
    Conversion conversion=null;
    try {
      if (executeInReverseOrder) {
        for (int i=conversions.size() - 1; i >= 0; i--) {
          conversion=conversions.get(i);
          value=conversion.revert(value);
        }
      }
 else {
        for (        Conversion<?,?> c : conversions) {
          conversion=c;
          value=conversion.revert(value);
        }
      }
    }
 catch (    Exception ex) {
      if (conversion != null) {
        throw new IllegalStateException(""String_Node_Str"" + value + ""String_Node_Str""+ conversion.getClass().getName(),ex);
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + value + ""String_Node_Str"",ex);
      }
    }
  }
  return value;
}",0.7476769120800572
163445,"/** 
 * Applies a sequence of conversions associated with a String value parsed from a given index.
 * @param index The index of parsed value in a record
 * @param stringValue The parsed value in a record
 * @return the Object produced by a sequence of conversions against the original String value.
 */
public Object applyConversions(int index,String stringValue){
  List<Conversion<String,?>> conversions=conversionsByIndex.get(index);
  if (conversions != null) {
    for (    Conversion<String,?> conversion : conversions) {
      Object result=null;
      try {
        result=conversion.execute(stringValue);
        if (result == null || result instanceof String) {
          stringValue=(String)result;
        }
 else {
          return result;
        }
      }
 catch (      Exception ex) {
        throw new IllegalStateException(""String_Node_Str"" + result + ""String_Node_Str""+ conversion.getClass().getName(),ex);
      }
    }
  }
  return stringValue;
}","/** 
 * Applies a sequence of conversions associated with a String value parsed from a given index.
 * @param index The index of parsed value in a record
 * @param stringValue The parsed value in a record
 * @return the Object produced by a sequence of conversions against the original String value.
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public Object applyConversions(int index,String stringValue){
  List<Conversion<?,?>> conversions=conversionsByIndex.get(index);
  if (conversions != null) {
    Object result=stringValue;
    for (    Conversion conversion : conversions) {
      try {
        result=conversion.execute(result);
      }
 catch (      Exception ex) {
        throw new IllegalStateException(""String_Node_Str"" + result + ""String_Node_Str""+ conversion.getClass().getName(),ex);
      }
    }
    return result;
  }
  return stringValue;
}",0.7943722943722944
163446,"/** 
 * Ensures an individual field does not have the same conversion object applied to it more than once.
 * @param selector the selection of fields
 * @param conversionsAtIndex the sequence of conversions applied to a given index
 * @param conversionsToAdd the sequence of conversions to add to conversionsAtIndex
 */
private void validateDuplicates(FieldSelector selector,List<Conversion<String,?>> conversionsAtIndex,Conversion<String,?>[] conversionsToAdd){
  for (  Conversion<String,?> toAdd : conversionsToAdd) {
    for (    Conversion<String,?> existing : conversionsAtIndex) {
      if (toAdd == existing) {
        throw new IllegalArgumentException(""String_Node_Str"" + toAdd.getClass().getName() + ""String_Node_Str""+ selector.describe());
      }
    }
  }
}","/** 
 * Ensures an individual field does not have the same conversion object applied to it more than once.
 * @param selector the selection of fields
 * @param conversionsAtIndex the sequence of conversions applied to a given index
 * @param conversionsToAdd the sequence of conversions to add to conversionsAtIndex
 */
private void validateDuplicates(FieldSelector selector,List<Conversion<?,?>> conversionsAtIndex,Conversion<?,?>[] conversionsToAdd){
  for (  Conversion<?,?> toAdd : conversionsToAdd) {
    for (    Conversion<?,?> existing : conversionsAtIndex) {
      if (toAdd == existing) {
        throw new IllegalArgumentException(""String_Node_Str"" + toAdd.getClass().getName() + ""String_Node_Str""+ selector.describe());
      }
    }
  }
}",0.9816031537450722
163447,"@Override public final void processStarted(ParsingContext context){
  splitter.clearValuesAndHeaders();
  batchCount=0;
  batchesProcessed=0;
}","@Override public final void processStarted(ParsingContext context){
  splitter.reset();
  batchCount=0;
  batchesProcessed=0;
}",0.9333333333333332
163448,"@Override public final void rowProcessed(String[] row,ParsingContext context){
  splitter.addValuesToColumns(false,row,context);
  batchCount++;
  if (batchCount >= rowsPerBatch) {
    batchProcessed(batchCount);
    batchCount=0;
    splitter.clearValues();
    batchesProcessed++;
  }
}","@Override public final void rowProcessed(String[] row,ParsingContext context){
  splitter.addValuesToColumns(row,context);
  batchCount++;
  if (batchCount >= rowsPerBatch) {
    batchProcessed(batchCount);
    batchCount=0;
    splitter.clearValues();
    batchesProcessed++;
  }
}",0.9894736842105264
163449,"@Override public final void processStarted(ParsingContext context){
  super.processStarted(context);
  splitter.clearValuesAndHeaders();
  batchCount=0;
  batchesProcessed=0;
}","@Override public final void processStarted(ParsingContext context){
  super.processStarted(context);
  splitter.reset();
  batchCount=0;
  batchesProcessed=0;
}",0.9464285714285714
163450,"@Override public final void rowProcessed(Object[] row,ParsingContext context){
  splitter.addValuesToColumns(false,row,context);
  batchCount++;
  if (batchCount >= rowsPerBatch) {
    batchProcessed(batchCount);
    batchCount=0;
    splitter.clearValues();
    batchesProcessed++;
  }
}","@Override public final void rowProcessed(Object[] row,ParsingContext context){
  splitter.addValuesToColumns(row,context);
  batchCount++;
  if (batchCount >= rowsPerBatch) {
    batchProcessed(batchCount);
    batchCount=0;
    splitter.clearValues();
    batchesProcessed++;
  }
}",0.9894736842105264
163451,"@Override public final void processStarted(ParsingContext context){
  splitter.clearValuesAndHeaders();
}","@Override public final void processStarted(ParsingContext context){
  splitter.reset();
}",0.9072164948453608
163452,"@Override public final void rowProcessed(String[] row,ParsingContext context){
  splitter.addValuesToColumns(true,row,context);
}","@Override public final void rowProcessed(String[] row,ParsingContext context){
  splitter.addValuesToColumns(row,context);
}",0.9802371541501976
163453,"void clearValues(){
  this.columnValues=null;
}","/** 
 * Removes any column values previously processed
 */
void clearValues(){
  addNullsFrom=rowCount;
  this.columnValues=null;
}",0.5280898876404494
163454,"String[] getHeaders(){
  return headers;
}","/** 
 * Returns the headers of the input. This can be either the headers defined in   {@link CommonSettings#getHeaders()}or the headers parsed in the input when   {@link CommonSettings#getHeaders()}  equals to {@code true}
 * @return the headers of all records parsed.
 */
String[] getHeaders(){
  return headers;
}",0.2352941176470588
163455,"List<List<T>> getColumnValues(){
  return columnValues;
}","/** 
 * Returns the values processed for each column
 * @return a list of lists. The stored lists correspond to the position of the column processed from the input; Each listcontains the corresponding values parsed for a column, across multiple rows.
 */
List<List<T>> getColumnValues(){
  return columnValues;
}",0.3089430894308943
163456,"ColumnSplitter(int initialRowSize){
  if (initialRowSize <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.initialRowSize=initialRowSize;
}","/** 
 * Creates a splitter allocating a space for a give number of expected rows to be read
 * @param expectedRowCount the expected number of rows to be parsed
 */
ColumnSplitter(int expectedRowCount){
  if (expectedRowCount <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.expectedRowCount=expectedRowCount;
}",0.4387351778656126
163457,"void addValuesToColumns(boolean expandWithNulls,T[] row,ParsingContext context){
  if (columnValues == null) {
    initialize(context);
  }
  if (columnValues.size() < row.length) {
    int columnsToAdd=row.length - columnValues.size();
    while (columnsToAdd-- > 0) {
      ArrayList<T> values;
      long records=context.currentRecord();
      if (records == 1L || !expandWithNulls) {
        values=new ArrayList<T>(initialRowSize);
      }
 else {
        values=new ArrayList<T>(initialRowSize < records ? (int)records : initialRowSize);
        while (--records > 0) {
          values.add(null);
        }
      }
      columnValues.add(values);
    }
  }
  for (int i=0; i < row.length; i++) {
    columnValues.get(i).add(row[i]);
  }
  if (row.length < columnValues.size()) {
    for (int i=row.length; i < columnValues.size(); i++) {
      columnValues.get(i).add(null);
    }
  }
}","/** 
 * Splits the row and add stores the value of each column in its corresponding list in   {@link #columnValues}
 * @param row the row whose column values will be split
 * @param context the current active parsing context.
 */
void addValuesToColumns(T[] row,ParsingContext context){
  if (columnValues == null) {
    initialize(context);
  }
  if (columnValues.size() < row.length) {
    int columnsToAdd=row.length - columnValues.size();
    while (columnsToAdd-- > 0) {
      long records=context.currentRecord() - addNullsFrom;
      ArrayList<T> values=new ArrayList<T>(expectedRowCount < records ? (int)records : expectedRowCount);
      while (--records > 0) {
        values.add(null);
      }
      columnValues.add(values);
    }
  }
  for (int i=0; i < row.length; i++) {
    columnValues.get(i).add(row[i]);
  }
  if (row.length < columnValues.size()) {
    for (int i=row.length; i < columnValues.size(); i++) {
      columnValues.get(i).add(null);
    }
  }
  rowCount++;
}",0.6627721720658524
163458,"Map<Integer,List<T>> getColumnValuesAsMapOfIndexes(){
  Map<Integer,List<T>> map=new HashMap<Integer,List<T>>();
  putColumnValuesInMapOfIndexes(map);
  return map;
}","/** 
 * Returns a map of column indexes and their respective list of values parsed from the input.
 * @return a map of column indexes and their respective list of values.
 */
Map<Integer,List<T>> getColumnValuesAsMapOfIndexes(){
  Map<Integer,List<T>> map=new HashMap<Integer,List<T>>();
  putColumnValuesInMapOfIndexes(map);
  return map;
}",0.6548323471400395
163459,"private void initialize(ParsingContext context){
  headers:   if (this.headers == null) {
    String[] allHeaders=context.headers();
    if (allHeaders == null) {
      headers=ArgumentUtils.EMPTY_STRING_ARRAY;
      break headers;
    }
    if (!context.columnsReordered()) {
      this.headers=allHeaders;
      break headers;
    }
    int[] selectedIndexes=context.extractedFieldIndexes();
    final int last=Math.min(allHeaders.length,selectedIndexes.length);
    this.headers=new String[selectedIndexes.length];
    for (int i=0; i < last; i++) {
      headers[i]=allHeaders[selectedIndexes[i]];
    }
  }
  columnValues=new ArrayList<List<T>>(headers.length > 0 ? headers.length : 10);
}","/** 
 * Initializes the list of column values, the headers of each column and which columns to read if fields have been selected using   {@link CommonSettings#selectFields(String)} or {@link CommonSettings#selectIndexes(Integer)}
 * @param context the current active parsing context, which will be used to obtain information about headers and selected fields.
 */
private void initialize(ParsingContext context){
  headers:   if (this.headers == null) {
    String[] allHeaders=context.headers();
    if (allHeaders == null) {
      headers=ArgumentUtils.EMPTY_STRING_ARRAY;
      break headers;
    }
    if (!context.columnsReordered()) {
      this.headers=allHeaders;
      break headers;
    }
    int[] selectedIndexes=context.extractedFieldIndexes();
    final int last=Math.min(allHeaders.length,selectedIndexes.length);
    this.headers=new String[selectedIndexes.length];
    for (int i=0; i < last; i++) {
      headers[i]=allHeaders[selectedIndexes[i]];
    }
  }
  columnValues=new ArrayList<List<T>>(headers.length > 0 ? headers.length : 10);
}",0.7922374429223744
163460,"void putColumnValuesInMapOfIndexes(Map<Integer,List<T>> map){
  if (columnValues == null) {
    return;
  }
  for (int i=0; i < columnValues.size(); i++) {
    map.put(i,columnValues.get(i));
  }
}","/** 
 * Fills a given map associating each column index to its list of values
 * @param map the map to hold the values of each column
 */
void putColumnValuesInMapOfIndexes(Map<Integer,List<T>> map){
  if (columnValues == null) {
    return;
  }
  for (int i=0; i < columnValues.size(); i++) {
    map.put(i,columnValues.get(i));
  }
}",0.7406015037593985
163461,"Map<String,List<T>> getColumnValuesAsMapOfNames(){
  Map<String,List<T>> map=new HashMap<String,List<T>>();
  putColumnValuesInMapOfNames(map);
  return map;
}","/** 
 * Returns a map of column names and their respective list of values parsed from the input.
 * @return a map of column names and their respective list of values.
 */
Map<String,List<T>> getColumnValuesAsMapOfNames(){
  Map<String,List<T>> map=new HashMap<String,List<T>>();
  putColumnValuesInMapOfNames(map);
  return map;
}",0.6503067484662577
163462,"String getHeader(int columnIndex){
  if (headers.length < columnIndex) {
    return headers[columnIndex];
  }
  return null;
}","/** 
 * Returns the header of a particular column
 * @param columnIndex the index of the column whose header is to be obtained
 * @return the name of the column at the given index, or null if there's no header defined for the given column index.
 */
String getHeader(int columnIndex){
  if (headers.length < columnIndex) {
    return headers[columnIndex];
  }
  return null;
}",0.50199203187251
163463,"void putColumnValuesInMapOfNames(Map<String,List<T>> map){
  if (columnValues == null) {
    return;
  }
  for (int i=0; i < columnValues.size(); i++) {
    String header=getHeader(i);
    if (header == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str""+ Arrays.toString(getHeaders()));
    }
    map.put(header,columnValues.get(i));
  }
}","/** 
 * Fills a given map associating each column name to its list o values
 * @param map the map to hold the values of each column
 * @throws IllegalArgumentException if a column does not have a name associated to it. In this case, use {@link #putColumnValuesInMapOfIndexes(Map)} instead.
 */
void putColumnValuesInMapOfNames(Map<String,List<T>> map){
  if (columnValues == null) {
    return;
  }
  for (int i=0; i < columnValues.size(); i++) {
    String header=getHeader(i);
    if (header == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str""+ Arrays.toString(getHeaders()));
    }
    map.put(header,columnValues.get(i));
  }
}",0.720532319391635
163464,"@Override public final void processStarted(ParsingContext context){
  super.processStarted(context);
  splitter.clearValuesAndHeaders();
}","@Override public final void processStarted(ParsingContext context){
  super.processStarted(context);
  splitter.reset();
}",0.9307692307692308
163465,"@Override public final void rowProcessed(Object[] row,ParsingContext context){
  splitter.addValuesToColumns(true,row,context);
}","@Override public final void rowProcessed(Object[] row,ParsingContext context){
  splitter.addValuesToColumns(row,context);
}",0.9802371541501976
163466,"@Override public void batchProcessed(int rowsInThisBatch){
  List<List<String>> columnValues=getColumnValuesAsList();
  Map<Integer,List<String>> columnsByIndex=getColumnValuesAsMapOfIndexes();
  String[][] expectedValues=getBatchesProcessed() == 0 ? expectedValueOnFirstBatch : expectedValueOnSecondBatch;
  assertEquals(columnValues.size(),expectedValues.length);
  for (int i=0; i < rowsInThisBatch; i++) {
    assertEquals(columnValues.get(i).size(),rowsInThisBatch);
    assertEquals(columnValues.get(i).toArray(),expectedValues[i]);
    assertEquals(columnsByIndex.get(i).toArray(),expectedValues[i]);
  }
  try {
    getColumnValuesAsMapOfNames();
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
  assertEquals(getHeaders(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
}","@Override public void batchProcessed(int rowsInThisBatch){
  List<List<String>> columnValues=getColumnValuesAsList();
  Map<Integer,List<String>> columnsByIndex=getColumnValuesAsMapOfIndexes();
  String[][] expectedValues=getBatchesProcessed() == 0 ? expectedValueOnFirstBatch : expectedValueOnSecondBatch;
  assertEquals(columnValues.size(),expectedValues.length);
  for (int i=0; i < expectedValues.length; i++) {
    assertEquals(columnValues.get(i).size(),rowsInThisBatch);
    assertEquals(columnValues.get(i).toArray(),expectedValues[i]);
    assertEquals(columnsByIndex.get(i).toArray(),expectedValues[i]);
  }
  try {
    getColumnValuesAsMapOfNames();
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
  assertEquals(getHeaders(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
}",0.9792429792429792
163467,"@Test public void testColumnValues(){
  final String[][] expectedValueOnFirstBatch=new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",null}};
  final String[][] expectedValueOnSecondBatch=new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{null,""String_Node_Str""}};
  BatchedColumnProcessor processor=new BatchedColumnProcessor(2){
    @Override public void batchProcessed(    int rowsInThisBatch){
      List<List<String>> columnValues=getColumnValuesAsList();
      Map<Integer,List<String>> columnsByIndex=getColumnValuesAsMapOfIndexes();
      String[][] expectedValues=getBatchesProcessed() == 0 ? expectedValueOnFirstBatch : expectedValueOnSecondBatch;
      assertEquals(columnValues.size(),expectedValues.length);
      for (int i=0; i < rowsInThisBatch; i++) {
        assertEquals(columnValues.get(i).size(),rowsInThisBatch);
        assertEquals(columnValues.get(i).toArray(),expectedValues[i]);
        assertEquals(columnsByIndex.get(i).toArray(),expectedValues[i]);
      }
      try {
        getColumnValuesAsMapOfNames();
        fail(""String_Node_Str"");
      }
 catch (      Exception e) {
      }
      assertEquals(getHeaders(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    }
  }
;
  CsvParserSettings settings=new CsvParserSettings();
  settings.setHeaderExtractionEnabled(true);
  settings.setRowProcessor(processor);
  new CsvParser(settings).parse(new StringReader(INPUT));
}","@Test public void testColumnValues(){
  final String[][] expectedValueOnFirstBatch=new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",null}};
  final String[][] expectedValueOnSecondBatch=new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{null,""String_Node_Str""}};
  BatchedColumnProcessor processor=new BatchedColumnProcessor(2){
    @Override public void batchProcessed(    int rowsInThisBatch){
      List<List<String>> columnValues=getColumnValuesAsList();
      Map<Integer,List<String>> columnsByIndex=getColumnValuesAsMapOfIndexes();
      String[][] expectedValues=getBatchesProcessed() == 0 ? expectedValueOnFirstBatch : expectedValueOnSecondBatch;
      assertEquals(columnValues.size(),expectedValues.length);
      for (int i=0; i < expectedValues.length; i++) {
        assertEquals(columnValues.get(i).size(),rowsInThisBatch);
        assertEquals(columnValues.get(i).toArray(),expectedValues[i]);
        assertEquals(columnsByIndex.get(i).toArray(),expectedValues[i]);
      }
      try {
        getColumnValuesAsMapOfNames();
        fail(""String_Node_Str"");
      }
 catch (      Exception e) {
      }
      assertEquals(getHeaders(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    }
  }
;
  CsvParserSettings settings=new CsvParserSettings();
  settings.setHeaderExtractionEnabled(true);
  settings.setRowProcessor(processor);
  new CsvParser(settings).parse(new StringReader(INPUT));
}",0.989158163265306
163468,"@Override public void batchProcessed(int rowsInThisBatch){
  List<List<Object>> columnValues=getColumnValuesAsList();
  Map<Integer,List<Object>> columnsByIndex=getColumnValuesAsMapOfIndexes();
  Object[][] expectedValues=getBatchesProcessed() == 0 ? expectedValueOnFirstBatch : expectedValueOnSecondBatch;
  assertEquals(columnValues.size(),expectedValues.length);
  for (int i=0; i < rowsInThisBatch; i++) {
    assertEquals(columnValues.get(i).size(),rowsInThisBatch);
    assertEquals(columnValues.get(i).toArray(),expectedValues[i]);
    assertEquals(columnsByIndex.get(i).toArray(),expectedValues[i]);
  }
  try {
    getColumnValuesAsMapOfNames();
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
  assertEquals(getHeaders(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
}","@Override public void batchProcessed(int rowsInThisBatch){
  List<List<Object>> columnValues=getColumnValuesAsList();
  Map<Integer,List<Object>> columnsByIndex=getColumnValuesAsMapOfIndexes();
  Object[][] expectedValues=getBatchesProcessed() == 0 ? expectedValueOnFirstBatch : expectedValueOnSecondBatch;
  assertEquals(columnValues.size(),expectedValues.length);
  for (int i=0; i < expectedValues.length; i++) {
    assertEquals(columnValues.get(i).size(),rowsInThisBatch);
    assertEquals(columnValues.get(i).toArray(),expectedValues[i]);
    assertEquals(columnsByIndex.get(i).toArray(),expectedValues[i]);
  }
  try {
    getColumnValuesAsMapOfNames();
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
  assertEquals(getHeaders(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
}",0.9792429792429792
163469,"@Test public void testColumnValues(){
  final Object[][] expectedValueOnFirstBatch=new Object[][]{{1,2},{true,false},{'C',null}};
  final Object[][] expectedValueOnSecondBatch=new Object[][]{{3,4},{null,false},{'C','C'},{null,new BigDecimal(""String_Node_Str"")}};
  BatchedObjectColumnProcessor processor=new BatchedObjectColumnProcessor(2){
    @Override public void batchProcessed(    int rowsInThisBatch){
      List<List<Object>> columnValues=getColumnValuesAsList();
      Map<Integer,List<Object>> columnsByIndex=getColumnValuesAsMapOfIndexes();
      Object[][] expectedValues=getBatchesProcessed() == 0 ? expectedValueOnFirstBatch : expectedValueOnSecondBatch;
      assertEquals(columnValues.size(),expectedValues.length);
      for (int i=0; i < rowsInThisBatch; i++) {
        assertEquals(columnValues.get(i).size(),rowsInThisBatch);
        assertEquals(columnValues.get(i).toArray(),expectedValues[i]);
        assertEquals(columnsByIndex.get(i).toArray(),expectedValues[i]);
      }
      try {
        getColumnValuesAsMapOfNames();
        fail(""String_Node_Str"");
      }
 catch (      Exception e) {
      }
      assertEquals(getHeaders(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    }
  }
;
  processor.convertFields(Conversions.toInteger()).add(""String_Node_Str"");
  processor.convertFields(Conversions.toBoolean()).add(""String_Node_Str"");
  processor.convertFields(Conversions.toChar()).add(""String_Node_Str"");
  processor.convertIndexes(Conversions.toBigDecimal()).add(3);
  CsvParserSettings settings=new CsvParserSettings();
  settings.setHeaderExtractionEnabled(true);
  settings.setRowProcessor(processor);
  new CsvParser(settings).parse(new StringReader(INPUT));
}","@Test public void testColumnValues(){
  final Object[][] expectedValueOnFirstBatch=new Object[][]{{1,2},{true,false},{'C',null}};
  final Object[][] expectedValueOnSecondBatch=new Object[][]{{3,4},{null,false},{'C','C'},{null,new BigDecimal(""String_Node_Str"")}};
  BatchedObjectColumnProcessor processor=new BatchedObjectColumnProcessor(2){
    @Override public void batchProcessed(    int rowsInThisBatch){
      List<List<Object>> columnValues=getColumnValuesAsList();
      Map<Integer,List<Object>> columnsByIndex=getColumnValuesAsMapOfIndexes();
      Object[][] expectedValues=getBatchesProcessed() == 0 ? expectedValueOnFirstBatch : expectedValueOnSecondBatch;
      assertEquals(columnValues.size(),expectedValues.length);
      for (int i=0; i < expectedValues.length; i++) {
        assertEquals(columnValues.get(i).size(),rowsInThisBatch);
        assertEquals(columnValues.get(i).toArray(),expectedValues[i]);
        assertEquals(columnsByIndex.get(i).toArray(),expectedValues[i]);
      }
      try {
        getColumnValuesAsMapOfNames();
        fail(""String_Node_Str"");
      }
 catch (      Exception e) {
      }
      assertEquals(getHeaders(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    }
  }
;
  processor.convertFields(Conversions.toInteger()).add(""String_Node_Str"");
  processor.convertFields(Conversions.toBoolean()).add(""String_Node_Str"");
  processor.convertFields(Conversions.toChar()).add(""String_Node_Str"");
  processor.convertIndexes(Conversions.toBigDecimal()).add(3);
  CsvParserSettings settings=new CsvParserSettings();
  settings.setHeaderExtractionEnabled(true);
  settings.setRowProcessor(processor);
  new CsvParser(settings).parse(new StringReader(INPUT));
}",0.9901449275362318
163470,"/** 
 * {@inheritDoc}
 */
@Override protected void processRow(Object[] row){
  for (int i=0; i < row.length; i++) {
    if (i != 0) {
      appendToRow(separator);
    }
    String nextElement=getStringValue(row[i]);
    boolean isElementQuoted=quoteElement(nextElement);
    if (isElementQuoted) {
      appender.append(quotechar);
    }
    int originalLength=appender.length();
    append(isElementQuoted,nextElement);
    if (appender.length() == originalLength && nullValue != null && !nullValue.isEmpty()) {
      if (isElementQuoted) {
        append(isElementQuoted,emptyValue);
      }
 else {
        append(isElementQuoted,nullValue);
      }
    }
    if (isElementQuoted) {
      appender.append(quotechar);
    }
    appendValueToRow();
  }
}","/** 
 * {@inheritDoc}
 */
@Override protected void processRow(Object[] row){
  for (int i=0; i < row.length; i++) {
    if (i != 0) {
      appendToRow(separator);
    }
    String nextElement=getStringValue(row[i]);
    boolean isElementQuoted=quoteElement(nextElement);
    if (isElementQuoted) {
      appender.append(quotechar);
    }
    int originalLength=appender.length();
    append(isElementQuoted,nextElement);
    if (appender.length() == originalLength && nullValue != null && !nullValue.isEmpty()) {
      if (isElementQuoted) {
        append(isElementQuoted,emptyValue);
      }
 else {
        append(isElementQuoted,nullValue);
      }
    }
    if (isElementQuoted) {
      appender.appendIgnoringWhitespace(quotechar);
    }
    appendValueToRow();
  }
}",0.9882352941176472
163471,"/** 
 * Parses the entirety of a given input and delegates each parsed row to an instance of   {@link RowProcessor}, defined by   {@link CommonParserSettings#getRowProcessor()}.
 * @param reader The input to be parsed.
 */
public final void parse(Reader reader){
  beginParsing(reader);
  try {
    while (!context.stopped && (ch=input.nextChar()) != '\0') {
      if (ch == comment) {
        input.skipLines(1);
        continue;
      }
      output.clear();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        processor.rowProcessed(row,context);
        if (recordsToRead > 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
        }
      }
    }
  }
 catch (  Exception ex) {
    throw new TextParsingException(context,ex);
  }
 finally {
    stopParsing();
  }
}","/** 
 * Parses the entirety of a given input and delegates each parsed row to an instance of   {@link RowProcessor}, defined by   {@link CommonParserSettings#getRowProcessor()}.
 * @param reader The input to be parsed.
 */
public final void parse(Reader reader){
  beginParsing(reader);
  try {
    while (!context.stopped) {
      ch=input.nextChar();
      if (ch == comment) {
        input.skipLines(1);
        continue;
      }
      output.clear();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        processor.rowProcessed(row,context);
        if (recordsToRead > 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
        }
      }
    }
  }
 catch (  EOFException ex) {
    if (output.column != 0) {
      if (output.appender.length() > 0) {
        output.valueParsed();
      }
 else {
        output.emptyParsed();
      }
      String[] row=output.rowParsed();
      if (row != null) {
        processor.rowProcessed(row,context);
      }
    }
 else     if (output.appender.length() > 0) {
      output.valueParsed();
      String[] row=output.rowParsed();
      if (row != null) {
        processor.rowProcessed(row,context);
      }
    }
  }
catch (  Exception ex) {
    throw new TextParsingException(context,ex);
  }
 finally {
    stopParsing();
  }
}",0.7534498620055198
163472,"/** 
 * Parses the next record from the input. Note that   {@link AbstractParser#beginParsing(Reader)} must have been invoked once before calling this method.If the end of the input is reached, then this method will return null. Additionally, all resources will be closed automatically at the end of the input or if any error happens while parsing.
 * @return The record parsed from the input or null if there's no more characters to read.
 */
public final String[] parseNext(){
  try {
    while (!context.stopped && (ch=input.nextChar()) != '\0') {
      if (ch == comment) {
        input.skipLines(1);
        continue;
      }
      output.clear();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        if (recordsToRead > 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
        }
        return row;
      }
    }
    stopParsing();
    return null;
  }
 catch (  Exception ex) {
    try {
      throw new TextParsingException(context,ex);
    }
  finally {
      stopParsing();
    }
  }
}","/** 
 * Parses the next record from the input. Note that   {@link AbstractParser#beginParsing(Reader)} must have been invoked once before calling this method.If the end of the input is reached, then this method will return null. Additionally, all resources will be closed automatically at the end of the input or if any error happens while parsing.
 * @return The record parsed from the input or null if there's no more characters to read.
 */
public final String[] parseNext(){
  try {
    while (!context.stopped) {
      ch=input.nextChar();
      if (ch == comment) {
        input.skipLines(1);
        continue;
      }
      output.clear();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        if (recordsToRead > 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
        }
        return row;
      }
    }
    stopParsing();
    return null;
  }
 catch (  EOFException ex) {
    if (output.appender.length() > 0) {
      output.valueParsed();
    }
    String[] row=output.rowParsed();
    stopParsing();
    return row;
  }
catch (  Exception ex) {
    try {
      throw new TextParsingException(context,ex);
    }
  finally {
      stopParsing();
    }
  }
}",0.9102787456445992
163473,"/** 
 * Gets all values parsed in the   {@link ParserOutput#parsedValues} array
 * @return the sequence of parsed values in a record.
 */
String[] rowParsed(){
  if (column > 0) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
      if (settings.isHeaderExtractionEnabled()) {
        Arrays.fill(parsedValues,null);
        return null;
      }
    }
    currentRecord++;
    if (columnsReordered) {
      String[] reorderedValues=new String[selectedIndexes.length];
      for (int i=0; i < selectedIndexes.length; i++) {
        int index=selectedIndexes[i];
        if (index >= column) {
          reorderedValues[i]=nullValue;
        }
 else {
          reorderedValues[i]=parsedValues[index];
        }
      }
      return reorderedValues;
    }
 else {
      String[] out=new String[column];
      System.arraycopy(parsedValues,0,out,0,column);
      return out;
    }
  }
 else   if (!skipEmptyLines) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
    }
    currentRecord++;
    if (columnsReordered) {
      String[] out=new String[selectedIndexes.length];
      Arrays.fill(out,nullValue);
      return out;
    }
    return ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  return null;
}","/** 
 * Gets all values parsed in the   {@link ParserOutput#parsedValues} array
 * @return the sequence of parsed values in a record.
 */
String[] rowParsed(){
  if (column > 0) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
      if (settings.isHeaderExtractionEnabled()) {
        Arrays.fill(parsedValues,null);
        column=0;
        return null;
      }
    }
    currentRecord++;
    if (columnsReordered) {
      String[] reorderedValues=new String[selectedIndexes.length];
      for (int i=0; i < selectedIndexes.length; i++) {
        int index=selectedIndexes[i];
        if (index >= column) {
          reorderedValues[i]=nullValue;
        }
 else {
          reorderedValues[i]=parsedValues[index];
        }
      }
      column=0;
      return reorderedValues;
    }
 else {
      String[] out=new String[column];
      System.arraycopy(parsedValues,0,out,0,column);
      column=0;
      return out;
    }
  }
 else   if (!skipEmptyLines) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
    }
    currentRecord++;
    if (columnsReordered) {
      String[] out=new String[selectedIndexes.length];
      Arrays.fill(out,nullValue);
      return out;
    }
    return ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  return null;
}",0.980127186009539
163474,"/** 
 * {@inheritDoc}
 */
@Override public final char nextChar(){
  if (length == -1) {
    return '\0';
  }
  char ch=buffer[i - 1];
  if (i >= length) {
    if (length != -1) {
      updateBuffer();
    }
 else {
      return '\0';
    }
  }
  i++;
  if (lineSeparator1 == ch && (lineSeparator2 == '\0' || lineSeparator2 == buffer[i - 1])) {
    lineCount++;
    if (lineSeparator2 != '\0') {
      ch=normalizedLineSeparator;
      if (i >= length) {
        if (length != -1) {
          updateBuffer();
        }
 else {
          return '\0';
        }
      }
      if (i < length) {
        i++;
      }
    }
  }
  return ch;
}","/** 
 * {@inheritDoc}
 */
@Override public final char nextChar(){
  if (length == -1) {
    throw new EOFException();
  }
  char ch=buffer[i - 1];
  if (i >= length) {
    if (length != -1) {
      updateBuffer();
    }
 else {
      throw new EOFException();
    }
  }
  i++;
  if (lineSeparator1 == ch && (lineSeparator2 == '\0' || lineSeparator2 == buffer[i - 1])) {
    lineCount++;
    if (lineSeparator2 != '\0') {
      ch=normalizedLineSeparator;
      if (i >= length) {
        if (length != -1) {
          updateBuffer();
        }
 else {
          throw new EOFException();
        }
      }
      if (i < length) {
        i++;
      }
    }
  }
  return ch;
}",0.1937452326468344
163475,"/** 
 * {@inheritDoc}
 */
@Override public final void skipLines(int lines){
  if (lines < 1) {
    return;
  }
  int expectedLineCount=this.lineCount + lines;
  char ch='\0';
  do {
    ch=nextChar();
  }
 while (lineCount < expectedLineCount && ch != '\0');
  if (ch == '\0' && lineCount < lines) {
    throw new IllegalArgumentException(""String_Node_Str"" + lines + ""String_Node_Str""+ (expectedLineCount - lines)+ ""String_Node_Str"");
  }
}","/** 
 * {@inheritDoc}
 */
@Override public final void skipLines(int lines){
  if (lines < 1) {
    return;
  }
  int expectedLineCount=this.lineCount + lines;
  char ch='\0';
  try {
    do {
      ch=nextChar();
    }
 while (lineCount < expectedLineCount && ch != '\0');
    if (lineCount < lines) {
      throw new IllegalArgumentException(""String_Node_Str"" + lines + ""String_Node_Str""+ (expectedLineCount - lines)+ ""String_Node_Str"");
    }
  }
 catch (  EOFException ex) {
    throw new IllegalArgumentException(""String_Node_Str"" + lines + ""String_Node_Str""+ (expectedLineCount - lines)+ ""String_Node_Str"");
  }
}",0.8015122873345936
163476,"/** 
 * {@inheritDoc}
 */
@Override protected void parseRecord(){
  if (ch <= ' ' && ignoreLeadingWhitespace) {
    skipWhitespace();
  }
  while (ch != newLine && ch != '\0') {
    parseField();
    if (ch != newLine) {
      ch=input.nextChar();
      if (ch == newLine) {
        output.emptyParsed();
      }
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override protected void parseRecord(){
  if (ch <= ' ' && ignoreLeadingWhitespace) {
    skipWhitespace();
  }
  while (ch != newLine) {
    parseField();
    if (ch != newLine) {
      ch=input.nextChar();
      if (ch == newLine) {
        output.emptyParsed();
      }
    }
  }
}",0.9779179810725552
163477,"private void parseQuotedValue(){
  char prev='\0';
  ch=input.nextChar();
  while (!(prev == quote && (ch == delimiter || ch <= ' ')) && ch != '\0') {
    if (ch != quote) {
      output.appender.append(ch);
      prev=ch;
    }
 else     if (prev == quoteEscape) {
      output.appender.append(quote);
      prev='\0';
    }
 else {
      prev=ch;
    }
    ch=input.nextChar();
  }
  if (ch <= ' ') {
    skipWhitespace();
  }
}","private void parseQuotedValue(){
  char prev='\0';
  ch=input.nextChar();
  while (!(prev == quote && (ch == delimiter || ch <= ' '))) {
    if (ch != quote) {
      output.appender.append(ch);
      prev=ch;
    }
 else     if (prev == quoteEscape) {
      output.appender.append(quote);
      prev='\0';
    }
 else {
      prev=ch;
    }
    ch=input.nextChar();
  }
  if (ch <= ' ') {
    skipWhitespace();
  }
}",0.4468085106382978
163478,"private void parseValue(){
  if (ignoreTrailingWhitespace) {
    while (ch != delimiter && ch != newLine && ch != '\0') {
      output.appender.appendIgnoringWhitespace(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (ch != delimiter && ch != newLine && ch != '\0') {
      output.appender.append(ch);
      ch=input.nextChar();
    }
  }
}","private void parseValue(){
  if (ignoreTrailingWhitespace) {
    while (ch != delimiter && ch != newLine) {
      output.appender.appendIgnoringWhitespace(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (ch != delimiter && ch != newLine) {
      output.appender.append(ch);
      ch=input.nextChar();
    }
  }
}",0.5828402366863905
163479,"private void skipWhitespace(){
  while (ch <= ' ' && ch != delimiter && ch != newLine && ch != '\0') {
    ch=input.nextChar();
  }
}","private void skipWhitespace(){
  while (ch <= ' ' && ch != delimiter && ch != newLine) {
    ch=input.nextChar();
  }
}",0.9444444444444444
163480,"private void readValueUntilNewLine(){
  if (ignoreTrailingWhitespace) {
    while (length-- > 0 && ch != newLine && ch != '\0') {
      output.appender.appendIgnoringWhitespaceAndPadding(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (length-- > 0 && ch != newLine && ch != '\0') {
      output.appender.appendIgnoringPadding(ch);
      ch=input.nextChar();
    }
  }
}","private void readValueUntilNewLine(){
  if (ignoreTrailingWhitespace) {
    while (length-- > 0 && ch != newLine) {
      output.appender.appendIgnoringWhitespaceAndPadding(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (length-- > 0 && ch != newLine) {
      output.appender.appendIgnoringPadding(ch);
      ch=input.nextChar();
    }
  }
}",0.5760869565217391
163481,"private void readValue(){
  if (ignoreTrailingWhitespace) {
    while (length-- > 0 && ch != '\0') {
      output.appender.appendIgnoringWhitespaceAndPadding(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (length-- > 0 && ch != '\0') {
      output.appender.appendIgnoringPadding(ch);
      ch=input.nextChar();
    }
  }
}","private void readValue(){
  if (ignoreTrailingWhitespace) {
    while (length-- > 0) {
      output.appender.appendIgnoringWhitespaceAndPadding(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (length-- > 0) {
      output.appender.appendIgnoringPadding(ch);
      ch=input.nextChar();
    }
  }
}",0.6987577639751553
163482,"private void skipToNewLine(){
  while (ch != newLine && ch != '\0') {
    ch=input.nextChar();
  }
}","private void skipToNewLine(){
  while (ch != newLine) {
    ch=input.nextChar();
  }
}",0.9247311827956988
163483,"private void skipPadding(){
  while (ch == padding && length-- > 0 && ch != '\0') {
    ch=input.nextChar();
  }
}","private void skipPadding(){
  while (ch == padding && length-- > 0) {
    ch=input.nextChar();
  }
}",0.9345794392523364
163484,"private void skipWhitespace(){
  while (ch <= ' ' && length-- > 0 && ch != '\0') {
    ch=input.nextChar();
  }
}","private void skipWhitespace(){
  while (ch <= ' ' && length-- > 0) {
    ch=input.nextChar();
  }
}",0.9339622641509434
163485,"/** 
 * Initializes the sequence of selected fields, if any.
 * @param values a sequence of values that represent the headers of the input. This can be either a parsed record or the headers as defined in {@link CommonSettings#getHeaders()}
 */
private void initializeColumnsToExtract(String[] values){
  columnsToExtractInitialized=true;
  columnsReordered=false;
  selectedIndexes=null;
  FieldSelector selector=settings.getFieldSelector();
  if (selector != null) {
    selectedIndexes=selector.getFieldIndexes(values);
    if (selectedIndexes != null) {
      Arrays.fill(appenders,NoopCharAppender.getInstance());
      for (int i=0; i < selectedIndexes.length; i++) {
        appenders[selectedIndexes[i]]=appender;
      }
      columnsReordered=settings.isColumnReorderingEnabled();
    }
  }
}","/** 
 * Initializes the sequence of selected fields, if any.
 * @param values a sequence of values that represent the headers of the input. This can be either a parsed record or the headers as defined in {@link CommonSettings#getHeaders()}
 */
private void initializeColumnsToExtract(String[] values){
  columnsToExtractInitialized=true;
  columnsReordered=false;
  selectedIndexes=null;
  FieldSelector selector=settings.getFieldSelector();
  if (selector != null) {
    selectedIndexes=selector.getFieldIndexes(values);
    if (selectedIndexes != null) {
      Arrays.fill(appenders,NoopCharAppender.getInstance());
      for (int i=0; i < selectedIndexes.length; i++) {
        appenders[selectedIndexes[i]]=appender;
      }
      columnsReordered=settings.isColumnReorderingEnabled();
      if (!columnsReordered && values.length < appenders.length) {
        Arrays.fill(appenders,values.length,appenders.length,appender);
      }
    }
  }
}",0.915951972555746
163486,protected abstract RowListProcessor newRowListProcessor();,"protected RowListProcessor newRowListProcessor(){
  return new RowListProcessor();
}",0.6901408450704225
163487,"/** 
 * Parses the entirety of a given input and delegates each parsed row to an instance of   {@link RowProcessor}, defined by   {@link CommonParserSettings#getRowProcessor()}.
 * @param reader The input to be parsed.
 */
public final void parse(Reader reader){
  beginParsing(reader);
  try {
    while (!context.stopped && (ch=input.nextChar()) != '\0') {
      if (ch == comment) {
        input.skipLines(1);
        continue;
      }
      output.clear();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        processor.rowProcessed(row,context);
        if (recordsToRead > 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
        }
      }
    }
  }
 catch (  Exception ex) {
    throw new TextParsingException(context,ex);
  }
 finally {
    stopParsing();
  }
}","/** 
 * Parses the entirety of a given input and delegates each parsed row to an instance of   {@link RowProcessor}, defined by   {@link CommonParserSettings#getRowProcessor()}.
 * @param reader The input to be parsed.
 */
public final void parse(Reader reader){
  beginParsing(reader);
  try {
    while (!context.stopped) {
      ch=input.nextChar();
      if (ch == comment) {
        input.skipLines(1);
        continue;
      }
      output.clear();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        processor.rowProcessed(row,context);
        if (recordsToRead > 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
        }
      }
    }
  }
 catch (  EOFException ex) {
    if (output.column != 0) {
      if (output.appender.length() > 0) {
        output.valueParsed();
      }
 else {
        output.emptyParsed();
      }
      String[] row=output.rowParsed();
      if (row != null) {
        processor.rowProcessed(row,context);
      }
    }
 else     if (output.appender.length() > 0) {
      output.valueParsed();
      String[] row=output.rowParsed();
      if (row != null) {
        processor.rowProcessed(row,context);
      }
    }
  }
catch (  Exception ex) {
    throw new TextParsingException(context,ex);
  }
 finally {
    stopParsing();
  }
}",0.7534498620055198
163488,"/** 
 * Parses the next record from the input. Note that   {@link AbstractParser#beginParsing(Reader)} must have been invoked once before calling this method.If the end of the input is reached, then this method will return null. Additionally, all resources will be closed automatically at the end of the input or if any error happens while parsing.
 * @return The record parsed from the input or null if there's no more characters to read.
 */
public final String[] parseNext(){
  try {
    while (!context.stopped && (ch=input.nextChar()) != '\0') {
      if (ch == comment) {
        input.skipLines(1);
        continue;
      }
      output.clear();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        if (recordsToRead > 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
        }
        return row;
      }
    }
    stopParsing();
    return null;
  }
 catch (  Exception ex) {
    try {
      throw new TextParsingException(context,ex);
    }
  finally {
      stopParsing();
    }
  }
}","/** 
 * Parses the next record from the input. Note that   {@link AbstractParser#beginParsing(Reader)} must have been invoked once before calling this method.If the end of the input is reached, then this method will return null. Additionally, all resources will be closed automatically at the end of the input or if any error happens while parsing.
 * @return The record parsed from the input or null if there's no more characters to read.
 */
public final String[] parseNext(){
  try {
    while (!context.stopped) {
      ch=input.nextChar();
      if (ch == comment) {
        input.skipLines(1);
        continue;
      }
      output.clear();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        if (recordsToRead > 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
        }
        return row;
      }
    }
    stopParsing();
    return null;
  }
 catch (  EOFException ex) {
    if (output.appender.length() > 0) {
      output.valueParsed();
    }
    String[] row=output.rowParsed();
    stopParsing();
    return row;
  }
catch (  Exception ex) {
    try {
      throw new TextParsingException(context,ex);
    }
  finally {
      stopParsing();
    }
  }
}",0.9102787456445992
163489,"/** 
 * Gets all values parsed in the   {@link ParserOutput#parsedValues} array
 * @return the sequence of parsed values in a record.
 */
String[] rowParsed(){
  if (column > 0) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
      if (settings.isHeaderExtractionEnabled()) {
        Arrays.fill(parsedValues,null);
        return null;
      }
    }
    currentRecord++;
    if (columnsReordered) {
      String[] reorderedValues=new String[selectedIndexes.length];
      for (int i=0; i < selectedIndexes.length; i++) {
        int index=selectedIndexes[i];
        if (index >= column) {
          reorderedValues[i]=nullValue;
        }
 else {
          reorderedValues[i]=parsedValues[index];
        }
      }
      return reorderedValues;
    }
 else {
      String[] out=new String[column];
      System.arraycopy(parsedValues,0,out,0,column);
      return out;
    }
  }
 else   if (!skipEmptyLines) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
    }
    currentRecord++;
    if (columnsReordered) {
      String[] out=new String[selectedIndexes.length];
      Arrays.fill(out,nullValue);
      return out;
    }
    return ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  return null;
}","/** 
 * Gets all values parsed in the   {@link ParserOutput#parsedValues} array
 * @return the sequence of parsed values in a record.
 */
String[] rowParsed(){
  if (column > 0) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
      if (settings.isHeaderExtractionEnabled()) {
        Arrays.fill(parsedValues,null);
        column=0;
        return null;
      }
    }
    currentRecord++;
    if (columnsReordered) {
      String[] reorderedValues=new String[selectedIndexes.length];
      for (int i=0; i < selectedIndexes.length; i++) {
        int index=selectedIndexes[i];
        if (index >= column) {
          reorderedValues[i]=nullValue;
        }
 else {
          reorderedValues[i]=parsedValues[index];
        }
      }
      column=0;
      return reorderedValues;
    }
 else {
      String[] out=new String[column];
      System.arraycopy(parsedValues,0,out,0,column);
      column=0;
      return out;
    }
  }
 else   if (!skipEmptyLines) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
    }
    currentRecord++;
    if (columnsReordered) {
      String[] out=new String[selectedIndexes.length];
      Arrays.fill(out,nullValue);
      return out;
    }
    return ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  return null;
}",0.980127186009539
163490,"/** 
 * {@inheritDoc}
 */
@Override public final char nextChar(){
  if (length == -1) {
    return '\0';
  }
  char ch=buffer[i - 1];
  if (i >= length) {
    if (length != -1) {
      updateBuffer();
    }
 else {
      return '\0';
    }
  }
  i++;
  if (lineSeparator1 == ch && (lineSeparator2 == '\0' || lineSeparator2 == buffer[i - 1])) {
    lineCount++;
    if (lineSeparator2 != '\0') {
      ch=normalizedLineSeparator;
      if (i >= length) {
        if (length != -1) {
          updateBuffer();
        }
 else {
          return '\0';
        }
      }
      if (i < length) {
        i++;
      }
    }
  }
  return ch;
}","/** 
 * {@inheritDoc}
 */
@Override public final char nextChar(){
  if (length == -1) {
    throw new EOFException();
  }
  char ch=buffer[i - 1];
  if (i >= length) {
    if (length != -1) {
      updateBuffer();
    }
 else {
      throw new EOFException();
    }
  }
  i++;
  if (lineSeparator1 == ch && (lineSeparator2 == '\0' || lineSeparator2 == buffer[i - 1])) {
    lineCount++;
    if (lineSeparator2 != '\0') {
      ch=normalizedLineSeparator;
      if (i >= length) {
        if (length != -1) {
          updateBuffer();
        }
 else {
          throw new EOFException();
        }
      }
      if (i < length) {
        i++;
      }
    }
  }
  return ch;
}",0.1937452326468344
163491,"/** 
 * {@inheritDoc}
 */
@Override public final void skipLines(int lines){
  if (lines < 1) {
    return;
  }
  int expectedLineCount=this.lineCount + lines;
  char ch='\0';
  do {
    ch=nextChar();
  }
 while (lineCount < expectedLineCount && ch != '\0');
  if (ch == '\0' && lineCount < lines) {
    throw new IllegalArgumentException(""String_Node_Str"" + lines + ""String_Node_Str""+ (expectedLineCount - lines)+ ""String_Node_Str"");
  }
}","/** 
 * {@inheritDoc}
 */
@Override public final void skipLines(int lines){
  if (lines < 1) {
    return;
  }
  int expectedLineCount=this.lineCount + lines;
  char ch='\0';
  try {
    do {
      ch=nextChar();
    }
 while (lineCount < expectedLineCount && ch != '\0');
    if (lineCount < lines) {
      throw new IllegalArgumentException(""String_Node_Str"" + lines + ""String_Node_Str""+ (expectedLineCount - lines)+ ""String_Node_Str"");
    }
  }
 catch (  EOFException ex) {
    throw new IllegalArgumentException(""String_Node_Str"" + lines + ""String_Node_Str""+ (expectedLineCount - lines)+ ""String_Node_Str"");
  }
}",0.8015122873345936
163492,"/** 
 * {@inheritDoc}
 */
@Override protected void parseRecord(){
  if (ch <= ' ' && ignoreLeadingWhitespace) {
    skipWhitespace();
  }
  while (ch != newLine && ch != '\0') {
    parseField();
    if (ch != newLine) {
      ch=input.nextChar();
      if (ch == newLine) {
        output.emptyParsed();
      }
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override protected void parseRecord(){
  if (ch <= ' ' && ignoreLeadingWhitespace) {
    skipWhitespace();
  }
  while (ch != newLine) {
    parseField();
    if (ch != newLine) {
      ch=input.nextChar();
      if (ch == newLine) {
        output.emptyParsed();
      }
    }
  }
}",0.9779179810725552
163493,"private void parseQuotedValue(){
  char prev='\0';
  ch=input.nextChar();
  while (!(prev == quote && (ch == delimiter || ch <= ' ')) && ch != '\0') {
    if (ch != quote) {
      output.appender.append(ch);
      prev=ch;
    }
 else     if (prev == quoteEscape) {
      output.appender.append(quote);
      prev='\0';
    }
 else {
      prev=ch;
    }
    ch=input.nextChar();
  }
  if (ch <= ' ') {
    skipWhitespace();
  }
}","private void parseQuotedValue(){
  char prev='\0';
  ch=input.nextChar();
  while (!(prev == quote && (ch == delimiter || ch <= ' '))) {
    if (ch != quote) {
      output.appender.append(ch);
      prev=ch;
    }
 else     if (prev == quoteEscape) {
      output.appender.append(quote);
      prev='\0';
    }
 else {
      prev=ch;
    }
    ch=input.nextChar();
  }
  if (ch <= ' ') {
    skipWhitespace();
  }
}",0.4468085106382978
163494,"private void parseValue(){
  if (ignoreTrailingWhitespace) {
    while (ch != delimiter && ch != newLine && ch != '\0') {
      output.appender.appendIgnoringWhitespace(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (ch != delimiter && ch != newLine && ch != '\0') {
      output.appender.append(ch);
      ch=input.nextChar();
    }
  }
}","private void parseValue(){
  if (ignoreTrailingWhitespace) {
    while (ch != delimiter && ch != newLine) {
      output.appender.appendIgnoringWhitespace(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (ch != delimiter && ch != newLine) {
      output.appender.append(ch);
      ch=input.nextChar();
    }
  }
}",0.5828402366863905
163495,"private void skipWhitespace(){
  while (ch <= ' ' && ch != delimiter && ch != newLine && ch != '\0') {
    ch=input.nextChar();
  }
}","private void skipWhitespace(){
  while (ch <= ' ' && ch != delimiter && ch != newLine) {
    ch=input.nextChar();
  }
}",0.9444444444444444
163496,"private void readValueUntilNewLine(){
  if (ignoreTrailingWhitespace) {
    while (length-- > 0 && ch != newLine && ch != '\0') {
      output.appender.appendIgnoringWhitespaceAndPadding(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (length-- > 0 && ch != newLine && ch != '\0') {
      output.appender.appendIgnoringPadding(ch);
      ch=input.nextChar();
    }
  }
}","private void readValueUntilNewLine(){
  if (ignoreTrailingWhitespace) {
    while (length-- > 0 && ch != newLine) {
      output.appender.appendIgnoringWhitespaceAndPadding(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (length-- > 0 && ch != newLine) {
      output.appender.appendIgnoringPadding(ch);
      ch=input.nextChar();
    }
  }
}",0.5760869565217391
163497,"private void readValue(){
  if (ignoreTrailingWhitespace) {
    while (length-- > 0 && ch != '\0') {
      output.appender.appendIgnoringWhitespaceAndPadding(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (length-- > 0 && ch != '\0') {
      output.appender.appendIgnoringPadding(ch);
      ch=input.nextChar();
    }
  }
}","private void readValue(){
  if (ignoreTrailingWhitespace) {
    while (length-- > 0) {
      output.appender.appendIgnoringWhitespaceAndPadding(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (length-- > 0) {
      output.appender.appendIgnoringPadding(ch);
      ch=input.nextChar();
    }
  }
}",0.6987577639751553
163498,"private void skipToNewLine(){
  while (ch != newLine && ch != '\0') {
    ch=input.nextChar();
  }
}","private void skipToNewLine(){
  while (ch != newLine) {
    ch=input.nextChar();
  }
}",0.9247311827956988
163499,"private void skipPadding(){
  while (ch == padding && length-- > 0 && ch != '\0') {
    ch=input.nextChar();
  }
}","private void skipPadding(){
  while (ch == padding && length-- > 0) {
    ch=input.nextChar();
  }
}",0.9345794392523364
163500,"private void skipWhitespace(){
  while (ch <= ' ' && length-- > 0 && ch != '\0') {
    ch=input.nextChar();
  }
}","private void skipWhitespace(){
  while (ch <= ' ' && length-- > 0) {
    ch=input.nextChar();
  }
}",0.9339622641509434
163501,"/** 
 * Parses the entirety of a given input and delegates each parsed row to an instance of   {@link RowProcessor}, defined by   {@link CommonParserSettings#getRowProcessor()}.
 * @param reader The input to be parsed.
 */
public final void parse(Reader reader){
  beginParsing(reader);
  try {
    while (!context.stopped) {
      ch=input.nextChar();
      if (ch == comment) {
        input.skipLines(1);
        continue;
      }
      output.clear();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        processor.rowProcessed(row,context);
        if (recordsToRead > 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
        }
      }
    }
  }
 catch (  EOFException ex) {
    if (output.column != 0) {
      if (output.appender.length() > 0) {
        output.valueParsed();
      }
 else {
        output.emptyParsed();
      }
      String[] row=output.rowParsed();
      if (row != null) {
        processor.rowProcessed(row,context);
      }
    }
 else     if (output.appender.length() > 0) {
      output.valueParsed();
      String[] row=output.rowParsed();
      if (row != null) {
        processor.rowProcessed(row,context);
      }
    }
  }
catch (  Exception ex) {
    throw new TextParsingException(context,ex);
  }
 finally {
    stopParsing();
  }
}","/** 
 * Parses the entirety of a given input and delegates each parsed row to an instance of   {@link RowProcessor}, defined by   {@link CommonParserSettings#getRowProcessor()}.
 * @param reader The input to be parsed.
 */
public final void parse(Reader reader){
  beginParsing(reader);
  try {
    while (!context.stopped && (ch=input.nextChar()) != '\0') {
      if (ch == comment) {
        input.skipLines(1);
        continue;
      }
      output.clear();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        processor.rowProcessed(row,context);
        if (recordsToRead > 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
        }
      }
    }
  }
 catch (  Exception ex) {
    throw new TextParsingException(context,ex);
  }
 finally {
    stopParsing();
  }
}",0.7534498620055198
163502,"/** 
 * Parses the next record from the input. Note that   {@link AbstractParser#beginParsing(Reader)} must have been invoked once before calling this method.If the end of the input is reached, then this method will return null. Additionally, all resources will be closed automatically at the end of the input or if any error happens while parsing.
 * @return The record parsed from the input or null if there's no more characters to read.
 */
public final String[] parseNext(){
  try {
    while (!context.stopped) {
      ch=input.nextChar();
      if (ch == comment) {
        input.skipLines(1);
        continue;
      }
      output.clear();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        if (recordsToRead > 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
        }
        return row;
      }
    }
    stopParsing();
    return null;
  }
 catch (  EOFException ex) {
    if (output.appender.length() > 0) {
      output.valueParsed();
    }
    String[] row=output.rowParsed();
    stopParsing();
    return row;
  }
catch (  Exception ex) {
    try {
      throw new TextParsingException(context,ex);
    }
  finally {
      stopParsing();
    }
  }
}","/** 
 * Parses the next record from the input. Note that   {@link AbstractParser#beginParsing(Reader)} must have been invoked once before calling this method.If the end of the input is reached, then this method will return null. Additionally, all resources will be closed automatically at the end of the input or if any error happens while parsing.
 * @return The record parsed from the input or null if there's no more characters to read.
 */
public final String[] parseNext(){
  try {
    while (!context.stopped && (ch=input.nextChar()) != '\0') {
      if (ch == comment) {
        input.skipLines(1);
        continue;
      }
      output.clear();
      parseRecord();
      String[] row=output.rowParsed();
      if (row != null) {
        if (recordsToRead > 0 && context.currentRecord() >= recordsToRead) {
          context.stop();
        }
        return row;
      }
    }
    stopParsing();
    return null;
  }
 catch (  Exception ex) {
    try {
      throw new TextParsingException(context,ex);
    }
  finally {
      stopParsing();
    }
  }
}",0.8963414634146342
163503,"/** 
 * Gets all values parsed in the   {@link ParserOutput#parsedValues} array
 * @return the sequence of parsed values in a record.
 */
String[] rowParsed(){
  if (column > 0) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
      if (settings.isHeaderExtractionEnabled()) {
        Arrays.fill(parsedValues,null);
        column=0;
        return null;
      }
    }
    currentRecord++;
    if (columnsReordered) {
      String[] reorderedValues=new String[selectedIndexes.length];
      for (int i=0; i < selectedIndexes.length; i++) {
        int index=selectedIndexes[i];
        if (index >= column) {
          reorderedValues[i]=nullValue;
        }
 else {
          reorderedValues[i]=parsedValues[index];
        }
      }
      column=0;
      return reorderedValues;
    }
 else {
      String[] out=new String[column];
      System.arraycopy(parsedValues,0,out,0,column);
      column=0;
      return out;
    }
  }
 else   if (!skipEmptyLines) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
    }
    currentRecord++;
    if (columnsReordered) {
      String[] out=new String[selectedIndexes.length];
      Arrays.fill(out,nullValue);
      return out;
    }
    return ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  return null;
}","/** 
 * Gets all values parsed in the   {@link ParserOutput#parsedValues} array
 * @return the sequence of parsed values in a record.
 */
String[] rowParsed(){
  if (column > 0) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
      if (settings.isHeaderExtractionEnabled()) {
        Arrays.fill(parsedValues,null);
        return null;
      }
    }
    currentRecord++;
    if (columnsReordered) {
      String[] reorderedValues=new String[selectedIndexes.length];
      for (int i=0; i < selectedIndexes.length; i++) {
        int index=selectedIndexes[i];
        if (index >= column) {
          reorderedValues[i]=nullValue;
        }
 else {
          reorderedValues[i]=parsedValues[index];
        }
      }
      return reorderedValues;
    }
 else {
      String[] out=new String[column];
      System.arraycopy(parsedValues,0,out,0,column);
      return out;
    }
  }
 else   if (!skipEmptyLines) {
    if (!columnsToExtractInitialized) {
      initializeHeaders();
    }
    currentRecord++;
    if (columnsReordered) {
      String[] out=new String[selectedIndexes.length];
      Arrays.fill(out,nullValue);
      return out;
    }
    return ArgumentUtils.EMPTY_STRING_ARRAY;
  }
  return null;
}",0.980127186009539
163504,"/** 
 * {@inheritDoc}
 */
@Override public final char nextChar(){
  if (length == -1) {
    throw new EOFException();
  }
  char ch=buffer[i - 1];
  if (i >= length) {
    if (length != -1) {
      updateBuffer();
    }
 else {
      throw new EOFException();
    }
  }
  i++;
  if (lineSeparator1 == ch && (lineSeparator2 == '\0' || lineSeparator2 == buffer[i - 1])) {
    lineCount++;
    if (lineSeparator2 != '\0') {
      ch=normalizedLineSeparator;
      if (i >= length) {
        if (length != -1) {
          updateBuffer();
        }
 else {
          throw new EOFException();
        }
      }
      if (i < length) {
        i++;
      }
    }
  }
  return ch;
}","/** 
 * {@inheritDoc}
 */
@Override public final char nextChar(){
  if (length == -1) {
    return '\0';
  }
  char ch=buffer[i - 1];
  if (i >= length) {
    if (length != -1) {
      updateBuffer();
    }
 else {
      return '\0';
    }
  }
  i++;
  if (lineSeparator1 == ch && (lineSeparator2 == '\0' || lineSeparator2 == buffer[i - 1])) {
    lineCount++;
    if (lineSeparator2 != '\0') {
      ch=normalizedLineSeparator;
      if (i >= length) {
        if (length != -1) {
          updateBuffer();
        }
 else {
          return '\0';
        }
      }
      if (i < length) {
        i++;
      }
    }
  }
  return ch;
}",0.919908466819222
163505,"/** 
 * {@inheritDoc}
 */
@Override public final void skipLines(int lines){
  if (lines < 1) {
    return;
  }
  int expectedLineCount=this.lineCount + lines;
  char ch='\0';
  try {
    do {
      ch=nextChar();
    }
 while (lineCount < expectedLineCount && ch != '\0');
    if (lineCount < lines) {
      throw new IllegalArgumentException(""String_Node_Str"" + lines + ""String_Node_Str""+ (expectedLineCount - lines)+ ""String_Node_Str"");
    }
  }
 catch (  EOFException ex) {
    throw new IllegalArgumentException(""String_Node_Str"" + lines + ""String_Node_Str""+ (expectedLineCount - lines)+ ""String_Node_Str"");
  }
}","/** 
 * {@inheritDoc}
 */
@Override public final void skipLines(int lines){
  if (lines < 1) {
    return;
  }
  int expectedLineCount=this.lineCount + lines;
  char ch='\0';
  do {
    ch=nextChar();
  }
 while (lineCount < expectedLineCount && ch != '\0');
  if (ch == '\0' && lineCount < lines) {
    throw new IllegalArgumentException(""String_Node_Str"" + lines + ""String_Node_Str""+ (expectedLineCount - lines)+ ""String_Node_Str"");
  }
}",0.8015122873345936
163506,"/** 
 * {@inheritDoc}
 */
@Override protected void parseRecord(){
  if (ch <= ' ' && ignoreLeadingWhitespace) {
    skipWhitespace();
  }
  while (ch != newLine) {
    parseField();
    if (ch != newLine) {
      ch=input.nextChar();
      if (ch == newLine) {
        output.emptyParsed();
      }
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override protected void parseRecord(){
  if (ch <= ' ' && ignoreLeadingWhitespace) {
    skipWhitespace();
  }
  while (ch != newLine && ch != '\0') {
    parseField();
    if (ch != newLine) {
      ch=input.nextChar();
      if (ch == newLine) {
        output.emptyParsed();
      }
    }
  }
}",0.9779179810725552
163507,"private void parseQuotedValue(){
  char prev='\0';
  ch=input.nextChar();
  while (!(prev == quote && (ch == delimiter || ch <= ' '))) {
    if (ch != quote) {
      output.appender.append(ch);
      prev=ch;
    }
 else     if (prev == quoteEscape) {
      output.appender.append(quote);
      prev='\0';
    }
 else {
      prev=ch;
    }
    ch=input.nextChar();
  }
  if (ch <= ' ') {
    skipWhitespace();
  }
}","private void parseQuotedValue(){
  char prev='\0';
  ch=input.nextChar();
  while (!(prev == quote && (ch == delimiter || ch <= ' ')) && ch != '\0') {
    if (ch != quote) {
      output.appender.append(ch);
      prev=ch;
    }
 else     if (prev == quoteEscape) {
      output.appender.append(quote);
      prev='\0';
    }
 else {
      prev=ch;
    }
    ch=input.nextChar();
  }
  if (ch <= ' ') {
    skipWhitespace();
  }
}",0.6028368794326241
163508,"private void parseValue(){
  if (ignoreTrailingWhitespace) {
    while (ch != delimiter && ch != newLine) {
      output.appender.appendIgnoringWhitespace(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (ch != delimiter && ch != newLine) {
      output.appender.append(ch);
      ch=input.nextChar();
    }
  }
}","private void parseValue(){
  if (ignoreTrailingWhitespace) {
    while (ch != delimiter && ch != newLine && ch != '\0') {
      output.appender.appendIgnoringWhitespace(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (ch != delimiter && ch != newLine && ch != '\0') {
      output.appender.append(ch);
      ch=input.nextChar();
    }
  }
}",0.9585798816568049
163509,"private void skipWhitespace(){
  while (ch <= ' ' && ch != delimiter && ch != newLine) {
    ch=input.nextChar();
  }
}","private void skipWhitespace(){
  while (ch <= ' ' && ch != delimiter && ch != newLine && ch != '\0') {
    ch=input.nextChar();
  }
}",0.9444444444444444
163510,"private void readValueUntilNewLine(){
  if (ignoreTrailingWhitespace) {
    while (length-- > 0 && ch != newLine) {
      output.appender.appendIgnoringWhitespaceAndPadding(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (length-- > 0 && ch != newLine) {
      output.appender.appendIgnoringPadding(ch);
      ch=input.nextChar();
    }
  }
}","private void readValueUntilNewLine(){
  if (ignoreTrailingWhitespace) {
    while (length-- > 0 && ch != newLine && ch != '\0') {
      output.appender.appendIgnoringWhitespaceAndPadding(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (length-- > 0 && ch != newLine && ch != '\0') {
      output.appender.appendIgnoringPadding(ch);
      ch=input.nextChar();
    }
  }
}",0.9619565217391304
163511,"private void readValue(){
  if (ignoreTrailingWhitespace) {
    while (length-- > 0) {
      output.appender.appendIgnoringWhitespaceAndPadding(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (length-- > 0) {
      output.appender.appendIgnoringPadding(ch);
      ch=input.nextChar();
    }
  }
}","private void readValue(){
  if (ignoreTrailingWhitespace) {
    while (length-- > 0 && ch != '\0') {
      output.appender.appendIgnoringWhitespaceAndPadding(ch);
      ch=input.nextChar();
    }
  }
 else {
    while (length-- > 0 && ch != '\0') {
      output.appender.appendIgnoringPadding(ch);
      ch=input.nextChar();
    }
  }
}",0.9565217391304348
163512,"private void skipToNewLine(){
  while (ch != newLine) {
    ch=input.nextChar();
  }
}","private void skipToNewLine(){
  while (ch != newLine && ch != '\0') {
    ch=input.nextChar();
  }
}",0.9247311827956988
163513,"private void skipPadding(){
  while (ch == padding && length-- > 0) {
    ch=input.nextChar();
  }
}","private void skipPadding(){
  while (ch == padding && length-- > 0 && ch != '\0') {
    ch=input.nextChar();
  }
}",0.9345794392523364
163514,"private void skipWhitespace(){
  while (ch <= ' ' && length-- > 0) {
    ch=input.nextChar();
  }
}","private void skipWhitespace(){
  while (ch <= ' ' && length-- > 0 && ch != '\0') {
    ch=input.nextChar();
  }
}",0.9339622641509434
163515,"public static Set<GeoHashQuery> queriesAtLocation(GeoLocation location,double radius){
  int queryBits=Math.max(1,Utils.bitsForBoundingBox(location,radius));
  int geoHashPrecision=(int)(Math.ceil(queryBits / Base32Utils.BITS_PER_BASE32_CHAR));
  double latitude=location.latitude;
  double longitude=location.longitude;
  double latitudeDegrees=radius / Constants.METERS_PER_DEGREE_LATITUDE;
  double latitudeNorth=Math.min(90,latitude + latitudeDegrees);
  double latitudeSouth=Math.max(-90,latitude - latitudeDegrees);
  double longitudeDeltaNorth=GeoUtils.distanceToLongitudeDegrees(radius,latitudeNorth);
  double longitudeDeltaSouth=GeoUtils.distanceToLongitudeDegrees(radius,latitudeSouth);
  double longitudeDelta=Math.max(longitudeDeltaNorth,longitudeDeltaSouth);
  Set<GeoHashQuery> queries=new HashSet<GeoHashQuery>();
  GeoHash geoHash=new GeoHash(latitude,longitude,geoHashPrecision);
  GeoHash geoHashW=new GeoHash(latitude,GeoUtils.wrapLongitude(longitude - longitudeDelta),geoHashPrecision);
  GeoHash geoHashE=new GeoHash(latitude,GeoUtils.wrapLongitude(longitude + longitudeDelta),geoHashPrecision);
  GeoHash geoHashN=new GeoHash(latitudeNorth,longitude,geoHashPrecision);
  GeoHash geoHashNW=new GeoHash(latitudeNorth,GeoUtils.wrapLongitude(longitude - longitudeDelta),geoHashPrecision);
  GeoHash geoHashNE=new GeoHash(latitudeNorth,GeoUtils.wrapLongitude(longitude + longitudeDelta),geoHashPrecision);
  GeoHash geoHashS=new GeoHash(latitudeSouth,longitude,geoHashPrecision);
  GeoHash geoHashSW=new GeoHash(latitudeSouth,GeoUtils.wrapLongitude(longitude - longitudeDelta),geoHashPrecision);
  GeoHash geoHashSE=new GeoHash(latitudeSouth,GeoUtils.wrapLongitude(longitude + longitudeDelta),geoHashPrecision);
  queries.add(queryForGeoHash(geoHash,queryBits));
  queries.add(queryForGeoHash(geoHashE,queryBits));
  queries.add(queryForGeoHash(geoHashW,queryBits));
  queries.add(queryForGeoHash(geoHashN,queryBits));
  queries.add(queryForGeoHash(geoHashNE,queryBits));
  queries.add(queryForGeoHash(geoHashNW,queryBits));
  queries.add(queryForGeoHash(geoHashS,queryBits));
  queries.add(queryForGeoHash(geoHashSE,queryBits));
  queries.add(queryForGeoHash(geoHashSW,queryBits));
  boolean didJoin;
  do {
    GeoHashQuery query1=null;
    GeoHashQuery query2=null;
    for (    GeoHashQuery query : queries) {
      for (      GeoHashQuery other : queries) {
        if (query != other && query.canJoinWith(other)) {
          query1=query;
          query2=other;
          break;
        }
      }
    }
    if (query1 != null && query2 != null) {
      queries.remove(query1);
      queries.remove(query2);
      queries.add(query1.joinWith(query2));
      didJoin=true;
    }
 else {
      didJoin=false;
    }
  }
 while (didJoin);
  return queries;
}","public static Set<GeoHashQuery> queriesAtLocation(GeoLocation location,double radius){
  int queryBits=Math.max(1,Utils.bitsForBoundingBox(location,radius));
  int geoHashPrecision=(int)(Math.ceil(((float)queryBits) / Base32Utils.BITS_PER_BASE32_CHAR));
  double latitude=location.latitude;
  double longitude=location.longitude;
  double latitudeDegrees=radius / Constants.METERS_PER_DEGREE_LATITUDE;
  double latitudeNorth=Math.min(90,latitude + latitudeDegrees);
  double latitudeSouth=Math.max(-90,latitude - latitudeDegrees);
  double longitudeDeltaNorth=GeoUtils.distanceToLongitudeDegrees(radius,latitudeNorth);
  double longitudeDeltaSouth=GeoUtils.distanceToLongitudeDegrees(radius,latitudeSouth);
  double longitudeDelta=Math.max(longitudeDeltaNorth,longitudeDeltaSouth);
  Set<GeoHashQuery> queries=new HashSet<GeoHashQuery>();
  GeoHash geoHash=new GeoHash(latitude,longitude,geoHashPrecision);
  GeoHash geoHashW=new GeoHash(latitude,GeoUtils.wrapLongitude(longitude - longitudeDelta),geoHashPrecision);
  GeoHash geoHashE=new GeoHash(latitude,GeoUtils.wrapLongitude(longitude + longitudeDelta),geoHashPrecision);
  GeoHash geoHashN=new GeoHash(latitudeNorth,longitude,geoHashPrecision);
  GeoHash geoHashNW=new GeoHash(latitudeNorth,GeoUtils.wrapLongitude(longitude - longitudeDelta),geoHashPrecision);
  GeoHash geoHashNE=new GeoHash(latitudeNorth,GeoUtils.wrapLongitude(longitude + longitudeDelta),geoHashPrecision);
  GeoHash geoHashS=new GeoHash(latitudeSouth,longitude,geoHashPrecision);
  GeoHash geoHashSW=new GeoHash(latitudeSouth,GeoUtils.wrapLongitude(longitude - longitudeDelta),geoHashPrecision);
  GeoHash geoHashSE=new GeoHash(latitudeSouth,GeoUtils.wrapLongitude(longitude + longitudeDelta),geoHashPrecision);
  queries.add(queryForGeoHash(geoHash,queryBits));
  queries.add(queryForGeoHash(geoHashE,queryBits));
  queries.add(queryForGeoHash(geoHashW,queryBits));
  queries.add(queryForGeoHash(geoHashN,queryBits));
  queries.add(queryForGeoHash(geoHashNE,queryBits));
  queries.add(queryForGeoHash(geoHashNW,queryBits));
  queries.add(queryForGeoHash(geoHashS,queryBits));
  queries.add(queryForGeoHash(geoHashSE,queryBits));
  queries.add(queryForGeoHash(geoHashSW,queryBits));
  boolean didJoin;
  do {
    GeoHashQuery query1=null;
    GeoHashQuery query2=null;
    for (    GeoHashQuery query : queries) {
      for (      GeoHashQuery other : queries) {
        if (query != other && query.canJoinWith(other)) {
          query1=query;
          query2=other;
          break;
        }
      }
    }
    if (query1 != null && query2 != null) {
      queries.remove(query1);
      queries.remove(query2);
      queries.add(query1.joinWith(query2));
      didJoin=true;
    }
 else {
      didJoin=false;
    }
  }
 while (didJoin);
  return queries;
}",0.9983827493261456
163516,"@Test public void inputContextWithLifespanTest() throws AIServiceException {
  final AIDataService aiDataService=createDataService();
  final AIContext weatherContext=new AIContext(""String_Node_Str"");
  weatherContext.setParameters(Collections.singletonMap(""String_Node_Str"",""String_Node_Str""));
  weatherContext.setLifespan(3);
  final AIRequest aiRequest=new AIRequest();
  aiRequest.setQuery(""String_Node_Str"");
  aiRequest.setContexts(Collections.singletonList(weatherContext));
  final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
  assertEquals(""String_Node_Str"",aiResponse.getResult().getFulfillment().getSpeech());
  assertNotNull(aiResponse.getResult().getContext(""String_Node_Str""));
  AIResponse nextResponse=null;
  for (int i=0; i < 2; i++) {
    nextResponse=makeRequest(aiDataService,new AIRequest(""String_Node_Str""));
  }
  assertNotNull(nextResponse.getResult().getContext(""String_Node_Str""));
  nextResponse=makeRequest(aiDataService,new AIRequest(""String_Node_Str""));
  assertNull(nextResponse.getResult().getContext(""String_Node_Str""));
}","@Test public void inputContextWithLifespanTest() throws AIServiceException {
  final AIDataService aiDataService=createDataService();
  final AIContext weatherContext=new AIContext(""String_Node_Str"");
  weatherContext.setParameters(Collections.singletonMap(""String_Node_Str"",""String_Node_Str""));
  weatherContext.setLifespan(3);
  final AIRequest aiRequest=new AIRequest();
  aiRequest.setQuery(""String_Node_Str"");
  aiRequest.setContexts(Collections.singletonList(weatherContext));
  final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
  assertEquals(""String_Node_Str"",aiResponse.getResult().getFulfillment().getSpeech());
  assertNotNull(aiResponse.getResult().getContext(""String_Node_Str""));
  AIResponse nextResponse=null;
  for (int i=0; i < 1; i++) {
    nextResponse=makeRequest(aiDataService,new AIRequest(""String_Node_Str""));
  }
  assertNotNull(nextResponse.getResult().getContext(""String_Node_Str""));
  nextResponse=makeRequest(aiDataService,new AIRequest(""String_Node_Str""));
  assertNull(nextResponse.getResult().getContext(""String_Node_Str""));
}",0.9990680335507922
163517,"public AIConfiguration(final String clientAccessToken,final SupportedLanguages language,final RecognitionEngine recognitionEngine){
  super(clientAccessToken);
  this.recognitionEngine=recognitionEngine;
  if (recognitionEngine == RecognitionEngine.Speaktoit && language == SupportedLanguages.Korean) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
}","public AIConfiguration(final String clientAccessToken,final SupportedLanguages language,final RecognitionEngine recognitionEngine){
  super(clientAccessToken,language);
  this.recognitionEngine=recognitionEngine;
  if (recognitionEngine == RecognitionEngine.Speaktoit && language == SupportedLanguages.Korean) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
}",0.9880478087649402
163518,"protected boolean checkPermissions(){
  final int permissionCheck=ContextCompat.checkSelfPermission(context,Manifest.permission.RECORD_AUDIO);
  if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
    return false;
  }
  return true;
}","protected boolean checkPermissions(){
  boolean granted=true;
  try {
    granted=ContextCompat.checkSelfPermission(context,Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED;
  }
 catch (  final Exception ignored) {
  }
  return granted;
}",0.6719681908548708
163519,"@Override public void onError(final int error){
  if (error == SpeechRecognizer.ERROR_NO_MATCH && isAndroid5()) {
    return;
  }
  if (recognitionActive) {
    recognitionActive=false;
    final AIError aiError;
    if (errorMessages.containsKey(error)) {
      final String description=errorMessages.get(error);
      aiError=new AIError(""String_Node_Str"" + description);
    }
 else {
      aiError=new AIError(""String_Node_Str"" + error);
    }
    GoogleRecognitionServiceImpl.this.onError(aiError);
  }
}","@Override public void onError(final int error){
  if (error == SpeechRecognizer.ERROR_NO_MATCH && affectedWithGoogleSearchProblem() && !wasReadyForSpeech) {
    return;
  }
  if (recognitionActive) {
    recognitionActive=false;
    final AIError aiError;
    if (errorMessages.containsKey(error)) {
      final String description=errorMessages.get(error);
      aiError=new AIError(""String_Node_Str"" + description);
    }
 else {
      aiError=new AIError(""String_Node_Str"" + error);
    }
    GoogleRecognitionServiceImpl.this.onError(aiError);
  }
}",0.936852026390198
163520,"@Override public void startListening(final RequestExtras requestExtras){
  if (!recognitionActive) {
    this.requestExtras=requestExtras;
    final Intent sttIntent=new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
    sttIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);
    final String language=config.getLanguage().replace('-','_');
    sttIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE,language);
    sttIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_PREFERENCE,language);
    sttIntent.putExtra(RecognizerIntent.EXTRA_PARTIAL_RESULTS,true);
    sttIntent.putExtra(""String_Node_Str"",new String[]{});
    runInUiThread(new Runnable(){
      @Override public void run(){
        initializeRecognizer();
        speechRecognizer.startListening(sttIntent);
        recognitionActive=true;
      }
    }
);
  }
 else {
    Log.w(TAG,""String_Node_Str"");
  }
}","@Override public void startListening(final RequestExtras requestExtras){
  if (!recognitionActive) {
    this.requestExtras=requestExtras;
    final Intent sttIntent=new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
    sttIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);
    final String language=config.getLanguage().replace('-','_');
    sttIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE,language);
    sttIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_PREFERENCE,language);
    sttIntent.putExtra(RecognizerIntent.EXTRA_PARTIAL_RESULTS,true);
    sttIntent.putExtra(""String_Node_Str"",new String[]{});
    runInUiThread(new Runnable(){
      @Override public void run(){
        initializeRecognizer();
        wasReadyForSpeech=false;
        speechRecognizer.startListening(sttIntent);
        recognitionActive=true;
      }
    }
);
  }
 else {
    Log.w(TAG,""String_Node_Str"");
  }
}",0.9822485207100592
163521,"protected void initializeRecognizer(){
synchronized (speechRecognizerLock) {
    if (speechRecognizer != null) {
      speechRecognizer.destroy();
      speechRecognizer=null;
    }
    final ComponentName googleRecognizerComponent=RecognizerChecker.findGoogleRecognizer(context);
    if (googleRecognizerComponent == null) {
      speechRecognizer=SpeechRecognizer.createSpeechRecognizer(context);
    }
 else {
      speechRecognizer=SpeechRecognizer.createSpeechRecognizer(context,googleRecognizerComponent);
    }
    speechRecognizer.setRecognitionListener(new InternalRecognitionListener());
  }
}","protected void initializeRecognizer(){
  if (speechRecognizer != null && affectedWithGoogleSearchProblem()) {
    return;
  }
synchronized (speechRecognizerLock) {
    if (speechRecognizer != null) {
      speechRecognizer.destroy();
      speechRecognizer=null;
    }
    final ComponentName googleRecognizerComponent=RecognizerChecker.findGoogleRecognizer(context);
    if (googleRecognizerComponent == null) {
      speechRecognizer=SpeechRecognizer.createSpeechRecognizer(context);
    }
 else {
      speechRecognizer=SpeechRecognizer.createSpeechRecognizer(context,googleRecognizerComponent);
    }
    speechRecognizer.setRecognitionListener(new InternalRecognitionListener());
  }
}",0.9327146171693736
163522,"public GoogleRecognitionServiceImpl(final Context context,final AIConfiguration config){
  super(config,context);
  final ComponentName googleRecognizerComponent=RecognizerChecker.findGoogleRecognizer(context);
  if (googleRecognizerComponent == null) {
    Log.w(TAG,""String_Node_Str"");
  }
  handler=new Handler(context.getMainLooper());
}","public GoogleRecognitionServiceImpl(final Context context,final AIConfiguration config){
  super(config,context);
  final ComponentName googleRecognizerComponent=RecognizerChecker.findGoogleRecognizer(context);
  if (googleRecognizerComponent == null) {
    Log.w(TAG,""String_Node_Str"");
  }
  handler=new Handler(context.getMainLooper());
  googleRecognizerVersion=RecognizerChecker.getGoogleRecognizerVersion(context);
}",0.8938401048492791
163523,"@Override public void onReadyForSpeech(final Bundle params){
  if (recognitionActive) {
    GoogleRecognitionServiceImpl.this.onListeningStarted();
  }
}","@Override public void onReadyForSpeech(final Bundle params){
  if (recognitionActive) {
    GoogleRecognitionServiceImpl.this.onListeningStarted();
  }
  wasReadyForSpeech=true;
}",0.9216867469879518
163524,"@Override public void onError(final int error){
  if (error == SpeechRecognizer.ERROR_NO_MATCH && affectedWithGoogleSearchProblem() && !wasReadyForSpeech) {
    return;
  }
  if (recognitionActive) {
    recognitionActive=false;
    final AIError aiError;
    if (errorMessages.containsKey(error)) {
      final String description=errorMessages.get(error);
      aiError=new AIError(""String_Node_Str"" + description);
    }
 else {
      aiError=new AIError(""String_Node_Str"" + error);
    }
    GoogleRecognitionServiceImpl.this.onError(aiError);
  }
}","@Override public void onError(final int error){
  if (error == SpeechRecognizer.ERROR_NO_MATCH && !wasReadyForSpeech) {
    return;
  }
  if (recognitionActive) {
    recognitionActive=false;
    final AIError aiError;
    if (errorMessages.containsKey(error)) {
      final String description=errorMessages.get(error);
      aiError=new AIError(""String_Node_Str"" + description);
    }
 else {
      aiError=new AIError(""String_Node_Str"" + error);
    }
    GoogleRecognitionServiceImpl.this.onError(aiError);
  }
}",0.9653233364573572
163525,"protected void initializeRecognizer(){
  if (speechRecognizer != null && affectedWithGoogleSearchProblem()) {
    return;
  }
synchronized (speechRecognizerLock) {
    if (speechRecognizer != null) {
      speechRecognizer.destroy();
      speechRecognizer=null;
    }
    final ComponentName googleRecognizerComponent=RecognizerChecker.findGoogleRecognizer(context);
    if (googleRecognizerComponent == null) {
      speechRecognizer=SpeechRecognizer.createSpeechRecognizer(context);
    }
 else {
      speechRecognizer=SpeechRecognizer.createSpeechRecognizer(context,googleRecognizerComponent);
    }
    speechRecognizer.setRecognitionListener(new InternalRecognitionListener());
  }
}","protected void initializeRecognizer(){
  if (speechRecognizer != null) {
    return;
  }
synchronized (speechRecognizerLock) {
    if (speechRecognizer != null) {
      speechRecognizer.destroy();
      speechRecognizer=null;
    }
    final ComponentName googleRecognizerComponent=RecognizerChecker.findGoogleRecognizer(context);
    if (googleRecognizerComponent == null) {
      speechRecognizer=SpeechRecognizer.createSpeechRecognizer(context);
    }
 else {
      speechRecognizer=SpeechRecognizer.createSpeechRecognizer(context,googleRecognizerComponent);
    }
    speechRecognizer.setRecognitionListener(new InternalRecognitionListener());
  }
}",0.9724497393894268
163526,"public GoogleRecognitionServiceImpl(final Context context,final AIConfiguration config){
  super(config,context);
  final ComponentName googleRecognizerComponent=RecognizerChecker.findGoogleRecognizer(context);
  if (googleRecognizerComponent == null) {
    Log.w(TAG,""String_Node_Str"");
  }
  handler=new Handler(context.getMainLooper());
  googleRecognizerVersion=RecognizerChecker.getGoogleRecognizerVersion(context);
}","public GoogleRecognitionServiceImpl(final Context context,final AIConfiguration config){
  super(config,context);
  final ComponentName googleRecognizerComponent=RecognizerChecker.findGoogleRecognizer(context);
  if (googleRecognizerComponent == null) {
    Log.w(TAG,""String_Node_Str"");
  }
  handler=new Handler(context.getMainLooper());
}",0.8938401048492791
163527,"protected String doTextRequest(final String endpoint,final String requestJson) throws MalformedURLException, AIServiceException {
  HttpURLConnection connection=null;
  try {
    final URL url=new URL(endpoint);
    final String queryData=requestJson;
    Log.d(TAG,""String_Node_Str"" + queryData);
    connection=(HttpURLConnection)url.openConnection();
    connection.setRequestMethod(""String_Node_Str"");
    connection.setDoOutput(true);
    connection.addRequestProperty(""String_Node_Str"",""String_Node_Str"" + config.getApiKey());
    connection.addRequestProperty(""String_Node_Str"",config.getSubscriptionKey());
    connection.addRequestProperty(""String_Node_Str"",""String_Node_Str"");
    connection.addRequestProperty(""String_Node_Str"",""String_Node_Str"");
    connection.connect();
    final BufferedOutputStream outputStream=new BufferedOutputStream(connection.getOutputStream());
    IOUtils.write(queryData,outputStream,Charsets.UTF_8);
    outputStream.close();
    final InputStream inputStream=new BufferedInputStream(connection.getInputStream());
    final String response=IOUtils.toString(inputStream,Charsets.UTF_8);
    inputStream.close();
    return response;
  }
 catch (  final IOException e) {
    if (connection != null) {
      try {
        final String errorString=IOUtils.toString(connection.getErrorStream(),Charsets.UTF_8);
        Log.d(TAG,""String_Node_Str"" + errorString);
        return errorString;
      }
 catch (      final IOException ex) {
        Log.w(TAG,""String_Node_Str"",ex);
      }
    }
    Log.e(TAG,""String_Node_Str"",e);
    throw new AIServiceException(""String_Node_Str"",e);
  }
 finally {
    if (connection != null) {
      connection.disconnect();
    }
  }
}","protected String doTextRequest(final String endpoint,final String requestJson) throws MalformedURLException, AIServiceException {
  HttpURLConnection connection=null;
  try {
    final URL url=new URL(endpoint);
    final String queryData=requestJson;
    Log.d(TAG,""String_Node_Str"" + queryData);
    connection=(HttpURLConnection)url.openConnection();
    connection.setRequestMethod(""String_Node_Str"");
    connection.setDoOutput(true);
    connection.addRequestProperty(""String_Node_Str"",""String_Node_Str"" + config.getApiKey());
    connection.addRequestProperty(""String_Node_Str"",config.getSubscriptionKey());
    connection.addRequestProperty(""String_Node_Str"",""String_Node_Str"");
    connection.addRequestProperty(""String_Node_Str"",""String_Node_Str"");
    connection.connect();
    final BufferedOutputStream outputStream=new BufferedOutputStream(connection.getOutputStream());
    IOUtils.write(queryData,outputStream,Charsets.UTF_8);
    outputStream.close();
    final InputStream inputStream=new BufferedInputStream(connection.getInputStream());
    final String response=IOUtils.toString(inputStream,Charsets.UTF_8);
    inputStream.close();
    return response;
  }
 catch (  final IOException e) {
    if (connection != null) {
      try {
        final InputStream errorStream=connection.getErrorStream();
        if (errorStream != null) {
          final String errorString=IOUtils.toString(errorStream,Charsets.UTF_8);
          Log.d(TAG,""String_Node_Str"" + errorString);
          return errorString;
        }
 else {
          throw new AIServiceException(""String_Node_Str"",e);
        }
      }
 catch (      final IOException ex) {
        Log.w(TAG,""String_Node_Str"",ex);
      }
    }
    Log.e(TAG,""String_Node_Str"",e);
    throw new AIServiceException(""String_Node_Str"",e);
  }
 finally {
    if (connection != null) {
      connection.disconnect();
    }
  }
}",0.9296636085626911
163528,"@Test public void AIDataServiceDevRuTest(){
  if (isExperimentalTest()) {
    final AIConfiguration config=new AIConfiguration(""String_Node_Str"",getSubscriptionKey(),AIConfiguration.SupportedLanguages.Russian,AIConfiguration.RecognitionEngine.System);
    config.setWriteSoundLog(false);
    config.setExperimental(isExperimentalTest());
    final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
    final AIRequest aiRequest=new AIRequest();
    aiRequest.setQuery(""String_Node_Str"");
    try {
      final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
      assertFalse(TextUtils.isEmpty(aiResponse.getResult().getResolvedQuery()));
      assertEquals(""String_Node_Str"",aiResponse.getResult().getAction());
      assertEquals(""String_Node_Str"",aiResponse.getResult().getFulfillment().getSpeech());
    }
 catch (    final AIServiceException e) {
      e.printStackTrace();
      assertTrue(e.getMessage(),false);
    }
  }
 else {
    assertTrue(true);
  }
}","@Test public void AIDataServiceDevRuTest(){
  final String devUrl=getDevUrl();
  if (!TextUtils.isEmpty(devUrl)) {
    final AIConfiguration config=new AIConfiguration(""String_Node_Str"",getSubscriptionKey(),AIConfiguration.SupportedLanguages.Russian,AIConfiguration.RecognitionEngine.System);
    config.setServiceUrl(devUrl);
    config.setWriteSoundLog(false);
    final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
    final AIRequest aiRequest=new AIRequest();
    aiRequest.setQuery(""String_Node_Str"");
    try {
      final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
      assertFalse(TextUtils.isEmpty(aiResponse.getResult().getResolvedQuery()));
      assertEquals(""String_Node_Str"",aiResponse.getResult().getAction());
      assertEquals(""String_Node_Str"",aiResponse.getResult().getFulfillment().getSpeech());
    }
 catch (    final AIServiceException e) {
      e.printStackTrace();
      assertTrue(e.getMessage(),false);
    }
  }
 else {
    assertTrue(true);
  }
}",0.17002457002457
163529,"@Test public void AIDataServiceDevTest(){
  if (isExperimentalTest()) {
    final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
    config.setWriteSoundLog(false);
    config.setExperimental(isExperimentalTest());
    final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
    final AIRequest aiRequest=new AIRequest();
    aiRequest.setQuery(""String_Node_Str"");
    try {
      final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
      assertFalse(TextUtils.isEmpty(aiResponse.getResult().getResolvedQuery()));
      assertEquals(""String_Node_Str"",aiResponse.getResult().getAction());
      assertEquals(""String_Node_Str"",aiResponse.getResult().getFulfillment().getSpeech());
    }
 catch (    final AIServiceException e) {
      e.printStackTrace();
      assertTrue(e.getMessage(),false);
    }
  }
 else {
    assertTrue(true);
  }
}","@Test public void AIDataServiceDevTest(){
  final String devUrl=getDevUrl();
  if (!TextUtils.isEmpty(devUrl)) {
    final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
    config.setServiceUrl(devUrl);
    config.setWriteSoundLog(false);
    final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
    final AIRequest aiRequest=new AIRequest();
    aiRequest.setQuery(""String_Node_Str"");
    try {
      final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
      assertFalse(TextUtils.isEmpty(aiResponse.getResult().getResolvedQuery()));
      assertEquals(""String_Node_Str"",aiResponse.getResult().getAction());
      assertEquals(""String_Node_Str"",aiResponse.getResult().getFulfillment().getSpeech());
    }
 catch (    final AIServiceException e) {
      e.printStackTrace();
      assertTrue(e.getMessage(),false);
    }
  }
 else {
    assertTrue(true);
  }
}",0.1685559388861508
163530,"@Test public void testBrazilLanguage(){
  final AIConfiguration config=new AIConfiguration(getPtBrAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.PortugueseBrazil,AIConfiguration.RecognitionEngine.System);
  config.setExperimental(isExperimentalTest());
  try {
    final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
    final AIRequest aiRequest=new AIRequest();
    aiRequest.setQuery(""String_Node_Str"");
    final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
    assertFalse(TextUtils.isEmpty(aiResponse.getResult().getResolvedQuery()));
    assertEquals(""String_Node_Str"",aiResponse.getResult().getAction());
    assertEquals(""String_Node_Str"",aiResponse.getResult().getFulfillment().getSpeech());
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}","@Test public void testBrazilLanguage(){
  final AIConfiguration config=new AIConfiguration(getPtBrAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.PortugueseBrazil,AIConfiguration.RecognitionEngine.System);
  updateConfig(config);
  try {
    final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
    final AIRequest aiRequest=new AIRequest();
    aiRequest.setQuery(""String_Node_Str"");
    final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
    assertFalse(TextUtils.isEmpty(aiResponse.getResult().getResolvedQuery()));
    assertEquals(""String_Node_Str"",aiResponse.getResult().getAction());
    assertEquals(""String_Node_Str"",aiResponse.getResult().getFulfillment().getSpeech());
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}",0.3585337915234822
163531,"@Test public void errorTextRequestTest(){
  final AIConfiguration config=new AIConfiguration(""String_Node_Str"",getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  config.setExperimental(isExperimentalTest());
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final AIRequest aiRequest=new AIRequest();
  aiRequest.setQuery(""String_Node_Str"");
  try {
    final AIResponse aiResponse=aiDataService.request(aiRequest);
    assertTrue(""String_Node_Str"",false);
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertNotNull(e.getResponse());
    assertEquals(""String_Node_Str"",e.getResponse().getStatus().getErrorType());
    assertEquals(""String_Node_Str"",e.getMessage());
  }
}","@Test public void errorTextRequestTest(){
  final AIConfiguration config=new AIConfiguration(""String_Node_Str"",getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  updateConfig(config);
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final AIRequest aiRequest=new AIRequest();
  aiRequest.setQuery(""String_Node_Str"");
  try {
    final AIResponse aiResponse=aiDataService.request(aiRequest);
    assertTrue(""String_Node_Str"",false);
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertNotNull(e.getResponse());
    assertEquals(""String_Node_Str"",e.getResponse().getStatus().getErrorType());
    assertEquals(""String_Node_Str"",e.getMessage());
  }
}",0.5522959183673469
163532,"@Test public void resetContextsTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.Speaktoit);
  config.setExperimental(isExperimentalTest());
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  try {
{
      final AIRequest aiRequest=new AIRequest(""String_Node_Str"");
      final AIResponse aiResponse=aiDataService.request(aiRequest);
      assertContainsContext(aiResponse,""String_Node_Str"");
      final boolean resetSucceed=aiDataService.resetContexts();
      assertTrue(resetSucceed);
    }
{
      final AIRequest aiRequest=new AIRequest(""String_Node_Str"");
      final AIResponse aiResponse=aiDataService.request(aiRequest);
      assertNotNull(aiResponse);
      assertFalse(aiResponse.getStatus().getErrorDetails(),aiResponse.isError());
      assertNotContainsContext(aiResponse,""String_Node_Str"");
    }
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}","@Test public void resetContextsTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.Speaktoit);
  updateConfig(config);
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  try {
{
      final AIRequest aiRequest=new AIRequest(""String_Node_Str"");
      final AIResponse aiResponse=aiDataService.request(aiRequest);
      assertContainsContext(aiResponse,""String_Node_Str"");
      final boolean resetSucceed=aiDataService.resetContexts();
      assertTrue(resetSucceed);
    }
{
      final AIRequest aiRequest=new AIRequest(""String_Node_Str"");
      final AIResponse aiResponse=aiDataService.request(aiRequest);
      assertNotNull(aiResponse);
      assertFalse(aiResponse.getStatus().getErrorDetails(),aiResponse.isError());
      assertNotContainsContext(aiResponse,""String_Node_Str"");
    }
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}",0.2806691449814126
163533,"@Test public void outputContextTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  config.setExperimental(isExperimentalTest());
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final AIRequest aiRequest=new AIRequest();
  aiRequest.setQuery(""String_Node_Str"");
  try {
    cleanContexts(aiDataService);
    final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
    final String action=aiResponse.getResult().getAction();
    assertEquals(""String_Node_Str"",action);
    assertNotNull(aiResponse.getResult().getContexts());
    assertContainsContext(aiResponse,""String_Node_Str"");
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}","@Test public void outputContextTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  updateConfig(config);
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final AIRequest aiRequest=new AIRequest();
  aiRequest.setQuery(""String_Node_Str"");
  try {
    cleanContexts(aiDataService);
    final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
    final String action=aiResponse.getResult().getAction();
    assertEquals(""String_Node_Str"",action);
    assertNotNull(aiResponse.getResult().getContexts());
    assertContainsContext(aiResponse,""String_Node_Str"");
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}",0.345664739884393
163534,"@Test public void testParameters(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  config.setExperimental(isExperimentalTest());
  try {
    final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
    final AIResponse response=aiDataService.request(new AIRequest(""String_Node_Str""));
    assertNotNull(response.getResult().getParameters());
    assertFalse(response.getResult().getParameters().isEmpty());
    final AIOutputContext context=response.getResult().getContexts()[0];
    assertNotNull(context.getParameters());
    assertTrue(context.getParameters().containsKey(""String_Node_Str""));
    final JsonElement contextParam=context.getParameters().get(""String_Node_Str"");
    assertEquals(""String_Node_Str"",contextParam.getAsString());
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}","@Test public void testParameters(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  updateConfig(config);
  try {
    final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
    final AIResponse response=aiDataService.request(new AIRequest(""String_Node_Str""));
    assertNotNull(response.getResult().getParameters());
    assertFalse(response.getResult().getParameters().isEmpty());
    final AIOutputContext context=response.getResult().getContexts()[0];
    assertNotNull(context.getParameters());
    assertTrue(context.getParameters().containsKey(""String_Node_Str""));
    final JsonElement contextParam=context.getParameters().get(""String_Node_Str"");
    assertEquals(""String_Node_Str"",contextParam.getAsString());
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}",0.9690309690309692
163535,"@Test public void errorVoiceRequestTest(){
  final AIConfiguration config=new AIConfiguration(""String_Node_Str"",getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  config.setExperimental(isExperimentalTest());
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final InputStream voiceStream=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
  try {
    final AIResponse aiResponse=aiDataService.voiceRequest(voiceStream);
    assertTrue(""String_Node_Str"",false);
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertNotNull(e.getResponse());
    assertEquals(""String_Node_Str"",e.getResponse().getStatus().getErrorType());
    assertEquals(""String_Node_Str"",e.getMessage());
  }
}","@Test public void errorVoiceRequestTest(){
  final AIConfiguration config=new AIConfiguration(""String_Node_Str"",getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  updateConfig(config);
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final InputStream voiceStream=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
  try {
    final AIResponse aiResponse=aiDataService.voiceRequest(voiceStream);
    assertTrue(""String_Node_Str"",false);
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertNotNull(e.getResponse());
    assertEquals(""String_Node_Str"",e.getResponse().getStatus().getErrorType());
    assertEquals(""String_Node_Str"",e.getMessage());
  }
}",0.5384615384615384
163536,"@Test public void differentAgentsTest(){
  final String query=""String_Node_Str"";
{
    final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
    config.setWriteSoundLog(false);
    config.setExperimental(isExperimentalTest());
    final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
    final AIRequest aiRequest=new AIRequest();
    aiRequest.setQuery(query);
    try {
      final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
      assertNotNull(aiResponse.getResult());
      assertEquals(""String_Node_Str"",aiResponse.getResult().getAction());
    }
 catch (    final AIServiceException e) {
      e.printStackTrace();
      assertTrue(e.getMessage(),false);
    }
  }
{
    final AIConfiguration secondConfig=new AIConfiguration(getSecondAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
    secondConfig.setWriteSoundLog(false);
    secondConfig.setExperimental(isExperimentalTest());
    final AIDataService aiDataService=new AIDataService(Robolectric.application,secondConfig);
    final AIRequest aiRequest=new AIRequest();
    aiRequest.setQuery(query);
    try {
      final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
      assertNotNull(aiResponse.getResult());
      assertTrue(TextUtils.isEmpty(aiResponse.getResult().getAction()));
    }
 catch (    final AIServiceException e) {
      e.printStackTrace();
      assertTrue(e.getMessage(),false);
    }
  }
}","@Test public void differentAgentsTest(){
  final String query=""String_Node_Str"";
{
    final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
    updateConfig(config);
    config.setWriteSoundLog(false);
    final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
    final AIRequest aiRequest=new AIRequest();
    aiRequest.setQuery(query);
    try {
      final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
      assertNotNull(aiResponse.getResult());
      assertEquals(""String_Node_Str"",aiResponse.getResult().getAction());
    }
 catch (    final AIServiceException e) {
      e.printStackTrace();
      assertTrue(e.getMessage(),false);
    }
  }
{
    final AIConfiguration secondConfig=new AIConfiguration(getSecondAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
    updateConfig(secondConfig);
    secondConfig.setWriteSoundLog(false);
    final AIDataService aiDataService=new AIDataService(Robolectric.application,secondConfig);
    final AIRequest aiRequest=new AIRequest();
    aiRequest.setQuery(query);
    try {
      final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
      assertNotNull(aiResponse.getResult());
      assertTrue(TextUtils.isEmpty(aiResponse.getResult().getAction()));
    }
 catch (    final AIServiceException e) {
      e.printStackTrace();
      assertTrue(e.getMessage(),false);
    }
  }
}",0.247036805988771
163537,"@Test public void textRequestTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  config.setWriteSoundLog(false);
  config.setExperimental(isExperimentalTest());
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final AIRequest aiRequest=new AIRequest();
  aiRequest.setQuery(""String_Node_Str"");
  try {
    final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
    assertFalse(TextUtils.isEmpty(aiResponse.getResult().getResolvedQuery()));
    assertEquals(""String_Node_Str"",aiResponse.getResult().getAction());
    assertEquals(""String_Node_Str"",aiResponse.getResult().getFulfillment().getSpeech());
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}","@Test public void textRequestTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  updateConfig(config);
  config.setWriteSoundLog(false);
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final AIRequest aiRequest=new AIRequest();
  aiRequest.setQuery(""String_Node_Str"");
  try {
    final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
    assertFalse(TextUtils.isEmpty(aiResponse.getResult().getResolvedQuery()));
    assertEquals(""String_Node_Str"",aiResponse.getResult().getAction());
    assertEquals(""String_Node_Str"",aiResponse.getResult().getFulfillment().getSpeech());
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}",0.3740112994350282
163538,"@Test public void wrongEntitiesTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  config.setWriteSoundLog(false);
  config.setExperimental(isExperimentalTest());
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final AIRequest aiRequest=new AIRequest();
  aiRequest.setQuery(""String_Node_Str"");
  final Entity myDwarfs=new Entity(""String_Node_Str"");
  myDwarfs.addEntry(new EntityEntry(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""}));
  myDwarfs.addEntry(new EntityEntry(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  final ArrayList<Entity> extraEntities=new ArrayList<>();
  extraEntities.add(myDwarfs);
  aiRequest.setEntities(extraEntities);
  final AIResponse aiResponse;
  try {
    aiResponse=makeRequest(aiDataService,aiRequest);
    assertTrue(""String_Node_Str"",false);
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(true);
  }
}","@Test public void wrongEntitiesTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  updateConfig(config);
  config.setWriteSoundLog(false);
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final AIRequest aiRequest=new AIRequest();
  aiRequest.setQuery(""String_Node_Str"");
  final Entity myDwarfs=new Entity(""String_Node_Str"");
  myDwarfs.addEntry(new EntityEntry(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""}));
  myDwarfs.addEntry(new EntityEntry(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  final ArrayList<Entity> extraEntities=new ArrayList<>();
  extraEntities.add(myDwarfs);
  aiRequest.setEntities(extraEntities);
  final AIResponse aiResponse;
  try {
    aiResponse=makeRequest(aiDataService,aiRequest);
    assertTrue(""String_Node_Str"",false);
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(true);
  }
}",0.9673617407071624
163539,"@Test public void voiceRequestTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.Speaktoit);
  config.setWriteSoundLog(false);
  config.setExperimental(isExperimentalTest());
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final InputStream inputStream=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
  try {
    final AIResponse aiResponse=aiDataService.voiceRequest(inputStream);
    assertNotNull(aiResponse);
    assertFalse(aiResponse.getStatus().getErrorDetails(),aiResponse.isError());
    assertFalse(TextUtils.isEmpty(aiResponse.getId()));
    assertNotNull(aiResponse.getResult());
    final String resolvedQuery=aiResponse.getResult().getResolvedQuery();
    assertFalse(TextUtils.isEmpty(resolvedQuery));
    assertTrue(resolvedQuery.contains(""String_Node_Str""));
    assertTrue(resolvedQuery.contains(""String_Node_Str""));
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}","@Test public void voiceRequestTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.Speaktoit);
  updateConfig(config);
  config.setWriteSoundLog(false);
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final InputStream inputStream=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
  try {
    final AIResponse aiResponse=aiDataService.voiceRequest(inputStream);
    assertNotNull(aiResponse);
    assertFalse(aiResponse.getStatus().getErrorDetails(),aiResponse.isError());
    assertFalse(TextUtils.isEmpty(aiResponse.getId()));
    assertNotNull(aiResponse.getResult());
    final String resolvedQuery=aiResponse.getResult().getResolvedQuery();
    assertFalse(TextUtils.isEmpty(resolvedQuery));
    assertTrue(resolvedQuery.contains(""String_Node_Str""));
    assertTrue(resolvedQuery.contains(""String_Node_Str""));
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}",0.967828418230563
163540,"@Test public void sessionTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  config.setExperimental(isExperimentalTest());
  try {
    final AIDataService firstService=new AIDataService(Robolectric.application,config);
    final AIDataService secondService=new AIDataService(Robolectric.application,config);
{
      final AIRequest weatherRequest=new AIRequest();
      weatherRequest.setQuery(""String_Node_Str"");
      final AIResponse weatherResponse=makeRequest(firstService,weatherRequest);
      assertNotNull(weatherResponse);
    }
{
      final AIRequest checkSecondRequest=new AIRequest();
      checkSecondRequest.setQuery(""String_Node_Str"");
      final AIResponse checkSecondResponse=makeRequest(secondService,checkSecondRequest);
      assertTrue(TextUtils.isEmpty(checkSecondResponse.getResult().getAction()));
    }
{
      final AIRequest checkFirstRequest=new AIRequest();
      checkFirstRequest.setQuery(""String_Node_Str"");
      final AIResponse checkFirstResponse=makeRequest(firstService,checkFirstRequest);
      assertNotNull(checkFirstResponse.getResult().getAction());
      assertTrue(checkFirstResponse.getResult().getAction().equalsIgnoreCase(""String_Node_Str""));
    }
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}","@Test public void sessionTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  updateConfig(config);
  try {
    final AIDataService firstService=new AIDataService(Robolectric.application,config);
    final AIDataService secondService=new AIDataService(Robolectric.application,config);
{
      final AIRequest weatherRequest=new AIRequest();
      weatherRequest.setQuery(""String_Node_Str"");
      final AIResponse weatherResponse=makeRequest(firstService,weatherRequest);
      assertNotNull(weatherResponse);
    }
{
      final AIRequest checkSecondRequest=new AIRequest();
      checkSecondRequest.setQuery(""String_Node_Str"");
      final AIResponse checkSecondResponse=makeRequest(secondService,checkSecondRequest);
      assertTrue(TextUtils.isEmpty(checkSecondResponse.getResult().getAction()));
    }
{
      final AIRequest checkFirstRequest=new AIRequest();
      checkFirstRequest.setQuery(""String_Node_Str"");
      final AIResponse checkFirstResponse=makeRequest(firstService,checkFirstRequest);
      assertNotNull(checkFirstResponse.getResult().getAction());
      assertTrue(checkFirstResponse.getResult().getAction().equalsIgnoreCase(""String_Node_Str""));
    }
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}",0.1529329608938547
163541,"@Test public void entitiesTest() throws AIServiceException {
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  config.setWriteSoundLog(false);
  config.setExperimental(isExperimentalTest());
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final AIRequest aiRequest=new AIRequest();
  aiRequest.setQuery(""String_Node_Str"");
  final Entity myDwarfs=new Entity(""String_Node_Str"");
  myDwarfs.addEntry(new EntityEntry(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""}));
  myDwarfs.addEntry(new EntityEntry(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""}));
  final ArrayList<Entity> extraEntities=new ArrayList<>();
  extraEntities.add(myDwarfs);
  aiRequest.setEntities(extraEntities);
  final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
  assertFalse(TextUtils.isEmpty(aiResponse.getResult().getResolvedQuery()));
  assertEquals(""String_Node_Str"",aiResponse.getResult().getAction());
  assertEquals(""String_Node_Str"",aiResponse.getResult().getFulfillment().getSpeech());
}","@Test public void entitiesTest() throws AIServiceException {
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  updateConfig(config);
  config.setWriteSoundLog(false);
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final AIRequest aiRequest=new AIRequest();
  aiRequest.setQuery(""String_Node_Str"");
  final Entity myDwarfs=new Entity(""String_Node_Str"");
  myDwarfs.addEntry(new EntityEntry(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""}));
  myDwarfs.addEntry(new EntityEntry(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""}));
  final ArrayList<Entity> extraEntities=new ArrayList<>();
  extraEntities.add(myDwarfs);
  aiRequest.setEntities(extraEntities);
  final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
  assertFalse(TextUtils.isEmpty(aiResponse.getResult().getResolvedQuery()));
  assertEquals(""String_Node_Str"",aiResponse.getResult().getAction());
  assertEquals(""String_Node_Str"",aiResponse.getResult().getFulfillment().getSpeech());
}",0.9695173581710416
163542,"@Test public void testRussianLanguage(){
  final AIConfiguration config=new AIConfiguration(getRuAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.Russian,AIConfiguration.RecognitionEngine.System);
  config.setExperimental(isExperimentalTest());
  try {
    final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
    final AIRequest aiRequest=new AIRequest();
    aiRequest.setQuery(""String_Node_Str"");
    final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
    assertFalse(TextUtils.isEmpty(aiResponse.getResult().getResolvedQuery()));
    assertEquals(""String_Node_Str"",aiResponse.getResult().getAction());
    assertEquals(""String_Node_Str"",aiResponse.getResult().getFulfillment().getSpeech());
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}","@Test public void testRussianLanguage(){
  final AIConfiguration config=new AIConfiguration(getRuAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.Russian,AIConfiguration.RecognitionEngine.System);
  updateConfig(config);
  try {
    final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
    final AIRequest aiRequest=new AIRequest();
    aiRequest.setQuery(""String_Node_Str"");
    final AIResponse aiResponse=makeRequest(aiDataService,aiRequest);
    assertFalse(TextUtils.isEmpty(aiResponse.getResult().getResolvedQuery()));
    assertEquals(""String_Node_Str"",aiResponse.getResult().getAction());
    assertEquals(""String_Node_Str"",aiResponse.getResult().getFulfillment().getSpeech());
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}",0.3511008111239861
163543,"@Test public void inputContextTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  config.setWriteSoundLog(false);
  config.setExperimental(isExperimentalTest());
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final AIRequest aiRequest=new AIRequest();
  aiRequest.setQuery(""String_Node_Str"");
  AIResponse aiResponse;
  String action;
  try {
    cleanContexts(aiDataService);
    aiResponse=makeRequest(aiDataService,aiRequest);
    action=aiResponse.getResult().getAction();
    assertEquals(""String_Node_Str"",action);
    aiRequest.addContext(new AIContext(""String_Node_Str""));
    aiResponse=makeRequest(aiDataService,aiRequest);
    action=aiResponse.getResult().getAction();
    assertEquals(""String_Node_Str"",action);
    aiRequest.setResetContexts(true);
    aiRequest.setContexts(null);
    aiRequest.addContext(new AIContext(""String_Node_Str""));
    aiResponse=makeRequest(aiDataService,aiRequest);
    action=aiResponse.getResult().getAction();
    assertEquals(""String_Node_Str"",action);
    cleanContexts(aiDataService);
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}","@Test public void inputContextTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  updateConfig(config);
  config.setWriteSoundLog(false);
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final AIRequest aiRequest=new AIRequest();
  aiRequest.setQuery(""String_Node_Str"");
  AIResponse aiResponse;
  String action;
  try {
    cleanContexts(aiDataService);
    aiResponse=makeRequest(aiDataService,aiRequest);
    action=aiResponse.getResult().getAction();
    assertEquals(""String_Node_Str"",action);
    aiRequest.addContext(new AIContext(""String_Node_Str""));
    aiResponse=makeRequest(aiDataService,aiRequest);
    action=aiResponse.getResult().getAction();
    assertEquals(""String_Node_Str"",action);
    aiRequest.setResetContexts(true);
    aiRequest.setContexts(null);
    aiRequest.addContext(new AIContext(""String_Node_Str""));
    aiResponse=makeRequest(aiDataService,aiRequest);
    action=aiResponse.getResult().getAction();
    assertEquals(""String_Node_Str"",action);
    cleanContexts(aiDataService);
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}",0.2536287242169595
163544,"@Test public void outputContextVoiceTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.Speaktoit);
  config.setWriteSoundLog(false);
  config.setExperimental(isExperimentalTest());
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final InputStream inputStream=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
  try {
    final AIResponse aiResponse=aiDataService.voiceRequest(inputStream);
    assertNotNull(aiResponse);
    assertFalse(aiResponse.getStatus().getErrorDetails(),aiResponse.isError());
    assertFalse(TextUtils.isEmpty(aiResponse.getId()));
    assertNotNull(aiResponse.getResult());
    final String resolvedQuery=aiResponse.getResult().getResolvedQuery();
    assertFalse(TextUtils.isEmpty(resolvedQuery));
    assertTrue(resolvedQuery.contains(""String_Node_Str""));
    assertContainsContext(aiResponse,""String_Node_Str"");
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}","@Test public void outputContextVoiceTest(){
  final AIConfiguration config=new AIConfiguration(getAccessToken(),getSubscriptionKey(),AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.Speaktoit);
  updateConfig(config);
  config.setWriteSoundLog(false);
  final AIDataService aiDataService=new AIDataService(Robolectric.application,config);
  final InputStream inputStream=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
  try {
    final AIResponse aiResponse=aiDataService.voiceRequest(inputStream);
    assertNotNull(aiResponse);
    assertFalse(aiResponse.getStatus().getErrorDetails(),aiResponse.isError());
    assertFalse(TextUtils.isEmpty(aiResponse.getId()));
    assertNotNull(aiResponse.getResult());
    final String resolvedQuery=aiResponse.getResult().getResolvedQuery();
    assertFalse(TextUtils.isEmpty(resolvedQuery));
    assertTrue(resolvedQuery.contains(""String_Node_Str""));
    assertContainsContext(aiResponse,""String_Node_Str"");
  }
 catch (  final AIServiceException e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}",0.9679430097951914
163545,"@Test public void testSpeechDetect(){
  final VoiceActivityDetector voiceActivityDetector=new VoiceActivityDetector(SAMPLE_RATE);
  final InputStream inputStream=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
  voiceDetected=false;
  speechStarted=false;
  voiceActivityDetector.setSpeechListener(new VoiceActivityDetector.SpeechEventsListener(){
    @Override public void onSpeechBegin(){
      speechStarted=true;
    }
    @Override public void onSpeechEnd(){
      voiceDetected=true;
    }
    @Override public void onAudioLevelChanged(    double energy){
    }
  }
);
  try {
    final int bufferSize=1096;
    final byte[] buffer=new byte[bufferSize];
    int bytesRead=0;
    bytesRead=inputStream.read(buffer,0,bufferSize);
    while (bytesRead >= 0) {
      voiceActivityDetector.processBuffer(buffer,bytesRead);
      bytesRead=inputStream.read(buffer,0,bufferSize);
    }
    assertTrue(speechStarted);
    assertTrue(voiceDetected);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}","@Test public void testSpeechDetect(){
  final VoiceActivityDetector voiceActivityDetector=new VoiceActivityDetector(SAMPLE_RATE);
  final InputStream inputStream=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
  voiceDetected=false;
  speechStarted=false;
  voiceActivityDetector.setSpeechListener(new VoiceActivityDetector.SpeechEventsListener(){
    @Override public void onSpeechBegin(){
      speechStarted=true;
    }
    @Override public void onSpeechCancel(){
    }
    @Override public void onSpeechEnd(){
      voiceDetected=true;
    }
    @Override public void onRmsChanged(    double level){
    }
  }
);
  try {
    final int bufferSize=1096;
    final byte[] buffer=new byte[bufferSize];
    int bytesRead=0;
    bytesRead=inputStream.read(buffer,0,bufferSize);
    while (bytesRead >= 0) {
      voiceActivityDetector.processBuffer(buffer,bytesRead);
      bytesRead=inputStream.read(buffer,0,bufferSize);
    }
    assertTrue(speechStarted);
    assertTrue(voiceDetected);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}",0.9395050412465628
163546,"@Test public void testEnabled(){
  final VoiceActivityDetector voiceActivityDetector=new VoiceActivityDetector(SAMPLE_RATE);
  voiceActivityDetector.setEnabled(false);
  final InputStream inputStream=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
  voiceDetected=false;
  speechStarted=false;
  voiceActivityDetector.setSpeechListener(new VoiceActivityDetector.SpeechEventsListener(){
    @Override public void onSpeechBegin(){
      speechStarted=true;
    }
    @Override public void onSpeechEnd(){
      voiceDetected=true;
    }
    @Override public void onAudioLevelChanged(    double energy){
    }
  }
);
  try {
    final int bufferSize=1096;
    final byte[] buffer=new byte[bufferSize];
    int bytesRead=0;
    bytesRead=inputStream.read(buffer,0,bufferSize);
    while (bytesRead >= 0) {
      voiceActivityDetector.processBuffer(buffer,bytesRead);
      bytesRead=inputStream.read(buffer,0,bufferSize);
    }
    assertTrue(speechStarted);
    assertFalse(voiceDetected);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}","@Test public void testEnabled(){
  final VoiceActivityDetector voiceActivityDetector=new VoiceActivityDetector(SAMPLE_RATE);
  voiceActivityDetector.setEnabled(false);
  final InputStream inputStream=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
  voiceDetected=false;
  speechStarted=false;
  voiceActivityDetector.setSpeechListener(new VoiceActivityDetector.SpeechEventsListener(){
    @Override public void onSpeechBegin(){
      speechStarted=true;
    }
    @Override public void onSpeechCancel(){
    }
    @Override public void onSpeechEnd(){
      voiceDetected=true;
    }
    @Override public void onRmsChanged(    double level){
    }
  }
);
  try {
    final int bufferSize=1096;
    final byte[] buffer=new byte[bufferSize];
    int bytesRead=0;
    bytesRead=inputStream.read(buffer,0,bufferSize);
    while (bytesRead >= 0) {
      voiceActivityDetector.processBuffer(buffer,bytesRead);
      bytesRead=inputStream.read(buffer,0,bufferSize);
    }
    assertTrue(speechStarted);
    assertFalse(voiceDetected);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}",0.9415929203539825
163547,"@Test public void testSilence(){
  final VoiceActivityDetector voiceActivityDetector=new VoiceActivityDetector(SAMPLE_RATE);
  final InputStream inputStream=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
  voiceDetected=false;
  voiceActivityDetector.setSpeechListener(new VoiceActivityDetector.SpeechEventsListener(){
    @Override public void onSpeechBegin(){
    }
    @Override public void onSpeechEnd(){
      voiceDetected=true;
    }
    @Override public void onAudioLevelChanged(    double energy){
    }
  }
);
  try {
    final int bufferSize=1096;
    final byte[] buffer=new byte[bufferSize];
    int bytesRead=inputStream.read(buffer,0,bufferSize);
    while (bytesRead >= 0) {
      voiceActivityDetector.processBuffer(buffer,bytesRead);
      bytesRead=inputStream.read(buffer,0,bufferSize);
    }
    assertFalse(voiceDetected);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}","@Test public void testSilence(){
  final VoiceActivityDetector voiceActivityDetector=new VoiceActivityDetector(SAMPLE_RATE);
  final InputStream inputStream=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
  voiceDetected=false;
  voiceActivityDetector.setSpeechListener(new VoiceActivityDetector.SpeechEventsListener(){
    @Override public void onSpeechBegin(){
    }
    @Override public void onSpeechCancel(){
    }
    @Override public void onSpeechEnd(){
      voiceDetected=true;
    }
    @Override public void onRmsChanged(    double level){
    }
  }
);
  try {
    final int bufferSize=1096;
    final byte[] buffer=new byte[bufferSize];
    int bytesRead=inputStream.read(buffer,0,bufferSize);
    while (bytesRead >= 0) {
      voiceActivityDetector.processBuffer(buffer,bytesRead);
      bytesRead=inputStream.read(buffer,0,bufferSize);
    }
    assertFalse(voiceDetected);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}",0.9333333333333332
163548,"public void testNoise(){
  final VoiceActivityDetector voiceActivityDetector=new VoiceActivityDetector(SAMPLE_RATE);
  final InputStream inputStream=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
  voiceDetected=false;
  voiceActivityDetector.setSpeechListener(new VoiceActivityDetector.SpeechEventsListener(){
    @Override public void onSpeechBegin(){
    }
    @Override public void onSpeechEnd(){
      voiceDetected=true;
    }
    @Override public void onAudioLevelChanged(    double energy){
    }
  }
);
  try {
    final int bufferSize=1096;
    final byte[] buffer=new byte[bufferSize];
    int bytesRead=inputStream.read(buffer,0,bufferSize);
    while (bytesRead >= 0) {
      voiceActivityDetector.processBuffer(buffer,bytesRead);
      bytesRead=inputStream.read(buffer,0,bufferSize);
    }
    assertFalse(voiceDetected);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}","public void testNoise(){
  final VoiceActivityDetector voiceActivityDetector=new VoiceActivityDetector(SAMPLE_RATE);
  final InputStream inputStream=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
  voiceDetected=false;
  voiceActivityDetector.setSpeechListener(new VoiceActivityDetector.SpeechEventsListener(){
    @Override public void onSpeechBegin(){
    }
    @Override public void onSpeechCancel(){
    }
    @Override public void onSpeechEnd(){
      voiceDetected=true;
    }
    @Override public void onRmsChanged(    double level){
    }
  }
);
  try {
    final int bufferSize=1096;
    final byte[] buffer=new byte[bufferSize];
    int bytesRead=inputStream.read(buffer,0,bufferSize);
    while (bytesRead >= 0) {
      voiceActivityDetector.processBuffer(buffer,bytesRead);
      bytesRead=inputStream.read(buffer,0,bufferSize);
    }
    assertFalse(voiceDetected);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    assertTrue(e.getMessage(),false);
  }
}",0.9327902240325866
163549,"@Override public void cancel(){
  if (recognitionActive) {
    runInUiThread(new Runnable(){
      @Override public void run(){
synchronized (speechRecognizerLock) {
          if (recognitionActive) {
            if (speechRecognizer != null) {
              speechRecognizer.cancel();
            }
            recognitionActive=false;
          }
        }
      }
    }
);
  }
}","@Override public void cancel(){
  if (recognitionActive) {
    runInUiThread(new Runnable(){
      @Override public void run(){
synchronized (speechRecognizerLock) {
          if (recognitionActive) {
            recognitionActive=false;
            if (speechRecognizer != null) {
              speechRecognizer.cancel();
            }
            onListeningCancelled();
          }
        }
      }
    }
);
  }
}",0.8972431077694235
163550,"/** 
 * This method must be called from UI thread
 */
@Override public void resume(){
  super.resume();
}","/** 
 * This method must be called from UI thread
 */
@Override public void resume(){
}",0.90625
163551,"@Override public void onError(final int error){
  recognitionActive=false;
  final AIError aiError;
  if (errorMessages.containsKey(error)) {
    final String description=errorMessages.get(error);
    aiError=new AIError(""String_Node_Str"" + description);
  }
 else {
    aiError=new AIError(""String_Node_Str"" + error);
  }
  GoogleRecognitionServiceImpl.this.onError(aiError);
}","@Override public void onError(final int error){
  if (recognitionActive) {
    recognitionActive=false;
    final AIError aiError;
    if (errorMessages.containsKey(error)) {
      final String description=errorMessages.get(error);
      aiError=new AIError(""String_Node_Str"" + description);
    }
 else {
      aiError=new AIError(""String_Node_Str"" + error);
    }
    GoogleRecognitionServiceImpl.this.onError(aiError);
  }
}",0.9391304347826088
163552,"@Override public void run(){
synchronized (speechRecognizerLock) {
    if (recognitionActive) {
      if (speechRecognizer != null) {
        speechRecognizer.cancel();
      }
      recognitionActive=false;
    }
  }
}","@Override public void run(){
synchronized (speechRecognizerLock) {
    if (recognitionActive) {
      recognitionActive=false;
      if (speechRecognizer != null) {
        speechRecognizer.cancel();
      }
      onListeningCancelled();
    }
  }
}",0.5598290598290598
163553,"@Override public void stopListening(){
  if (recognitionActive) {
    runInUiThread(new Runnable(){
      @Override public void run(){
synchronized (speechRecognizerLock) {
          if (recognitionActive) {
            speechRecognizer.stopListening();
            recognitionActive=false;
          }
        }
      }
    }
);
  }
 else {
    Log.w(TAG,""String_Node_Str"");
  }
}","@Override public void stopListening(){
  if (recognitionActive) {
    runInUiThread(new Runnable(){
      @Override public void run(){
synchronized (speechRecognizerLock) {
          if (recognitionActive) {
            if (speechRecognizer != null) {
              speechRecognizer.stopListening();
            }
          }
        }
      }
    }
);
  }
 else {
    Log.w(TAG,""String_Node_Str"");
  }
}",0.9095541401273886
163554,"/** 
 * This method must be called from UI thread
 */
@Override public void pause(){
  super.pause();
  clearRecognizer();
}","/** 
 * This method must be called from UI thread
 */
@Override public void pause(){
  clearRecognizer();
}",0.9264069264069263
163555,"@Override public void onEndOfSpeech(){
  GoogleRecognitionServiceImpl.this.onListeningFinished();
}","@Override public void onEndOfSpeech(){
  if (recognitionActive) {
    GoogleRecognitionServiceImpl.this.onListeningFinished();
  }
}",0.8571428571428571
163556,"@Override public void onRmsChanged(final float rmsdB){
  GoogleRecognitionServiceImpl.this.onAudioLevelChanged(rmsdB);
}","@Override public void onRmsChanged(final float rmsdB){
  if (recognitionActive) {
    GoogleRecognitionServiceImpl.this.onAudioLevelChanged(rmsdB);
  }
}",0.8791208791208791
163557,"@Override public void onPartialResults(final Bundle partialResults){
  final ArrayList<String> partialRecognitionResults=partialResults.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION);
  if (partialRecognitionResults != null && !partialRecognitionResults.isEmpty()) {
    GoogleRecognitionServiceImpl.this.onPartialResults(partialRecognitionResults);
  }
}","@Override public void onPartialResults(final Bundle partialResults){
  if (recognitionActive) {
    final ArrayList<String> partialRecognitionResults=partialResults.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION);
    if (partialRecognitionResults != null && !partialRecognitionResults.isEmpty()) {
      GoogleRecognitionServiceImpl.this.onPartialResults(partialRecognitionResults);
    }
  }
}",0.9492847854356308
163558,"@Override public void onReadyForSpeech(final Bundle params){
  GoogleRecognitionServiceImpl.this.onListeningStarted();
}","@Override public void onReadyForSpeech(final Bundle params){
  if (recognitionActive) {
    GoogleRecognitionServiceImpl.this.onListeningStarted();
  }
}",0.8791208791208791
163559,"public Date getTimeParameter(final String name,final Date defaultValue) throws IllegalArgumentException {
  if (parameters.containsKey(name)) {
    final String parameterStringValue=parameters.get(name).getAsString();
    if (TextUtils.isEmpty(parameterStringValue)) {
      return defaultValue;
    }
    try {
      return ParametersConverter.parseTime(name);
    }
 catch (    final ParseException pe) {
      throw new IllegalArgumentException(String.format(DATE_FORMAT_ERROR_MESSAGE,name,parameterStringValue),pe);
    }
  }
  return defaultValue;
}","public Date getTimeParameter(final String name,final Date defaultValue) throws IllegalArgumentException {
  if (parameters.containsKey(name)) {
    final String parameterStringValue=parameters.get(name).getAsString();
    if (TextUtils.isEmpty(parameterStringValue)) {
      return defaultValue;
    }
    try {
      return ParametersConverter.parseTime(parameterStringValue);
    }
 catch (    final ParseException pe) {
      throw new IllegalArgumentException(String.format(DATE_FORMAT_ERROR_MESSAGE,name,parameterStringValue),pe);
    }
  }
  return defaultValue;
}",0.9804270462633452
163560,"public float getFloatParameter(final String name,final int defaultValue){
  if (parameters.containsKey(name)) {
    final String parameterStringValue=parameters.get(name).getAsString();
    if (TextUtils.isEmpty(parameterStringValue)) {
      return defaultValue;
    }
    return ParametersConverter.parseFloat(name);
  }
  return defaultValue;
}","public float getFloatParameter(final String name,final int defaultValue){
  if (parameters.containsKey(name)) {
    final String parameterStringValue=parameters.get(name).getAsString();
    if (TextUtils.isEmpty(parameterStringValue)) {
      return defaultValue;
    }
    return ParametersConverter.parseFloat(parameterStringValue);
  }
  return defaultValue;
}",0.9690140845070424
163561,"public Date getDateParameter(final String name,final Date defaultValue) throws IllegalArgumentException {
  if (parameters.containsKey(name)) {
    final String parameterStringValue=parameters.get(name).getAsString();
    if (TextUtils.isEmpty(parameterStringValue)) {
      return defaultValue;
    }
    try {
      return ParametersConverter.parseDate(name);
    }
 catch (    final ParseException pe) {
      throw new IllegalArgumentException(String.format(DATE_FORMAT_ERROR_MESSAGE,name,parameterStringValue),pe);
    }
  }
  return defaultValue;
}","public Date getDateParameter(final String name,final Date defaultValue) throws IllegalArgumentException {
  if (parameters.containsKey(name)) {
    final String parameterStringValue=parameters.get(name).getAsString();
    if (TextUtils.isEmpty(parameterStringValue)) {
      return defaultValue;
    }
    try {
      return ParametersConverter.parseDate(parameterStringValue);
    }
 catch (    final ParseException pe) {
      throw new IllegalArgumentException(String.format(DATE_FORMAT_ERROR_MESSAGE,name,parameterStringValue),pe);
    }
  }
  return defaultValue;
}",0.9804270462633452
163562,"public int getIntParameter(final String name,final int defaultValue){
  if (parameters.containsKey(name)) {
    final String parameterStringValue=parameters.get(name).getAsString();
    if (TextUtils.isEmpty(parameterStringValue)) {
      return defaultValue;
    }
    return ParametersConverter.parseInteger(name);
  }
  return defaultValue;
}","public int getIntParameter(final String name,final int defaultValue){
  if (parameters.containsKey(name)) {
    final String parameterStringValue=parameters.get(name).getAsString();
    if (TextUtils.isEmpty(parameterStringValue)) {
      return defaultValue;
    }
    return ParametersConverter.parseInteger(parameterStringValue);
  }
  return defaultValue;
}",0.9688385269121812
163563,"public Date getDateTimeParameter(final String name,final Date defaultValue) throws IllegalArgumentException {
  if (parameters.containsKey(name)) {
    final String parameterStringValue=parameters.get(name).getAsString();
    if (TextUtils.isEmpty(parameterStringValue)) {
      return defaultValue;
    }
    try {
      return ParametersConverter.parseDateTime(name);
    }
 catch (    final ParseException pe) {
      throw new IllegalArgumentException(String.format(DATE_FORMAT_ERROR_MESSAGE,name,parameterStringValue),pe);
    }
  }
  return defaultValue;
}","public Date getDateTimeParameter(final String name,final Date defaultValue) throws IllegalArgumentException {
  if (parameters.containsKey(name)) {
    final String parameterStringValue=parameters.get(name).getAsString();
    if (TextUtils.isEmpty(parameterStringValue)) {
      return defaultValue;
    }
    try {
      return ParametersConverter.parseDateTime(parameterStringValue);
    }
 catch (    final ParseException pe) {
      throw new IllegalArgumentException(String.format(DATE_FORMAT_ERROR_MESSAGE,name,parameterStringValue),pe);
    }
  }
  return defaultValue;
}",0.980701754385965
163564,"@TargetApi(14) @Override public void onResults(final Bundle results){
  if (recognitionActive) {
    recognitionActive=false;
    final ArrayList<String> recognitionResults=results.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION);
    float[] rates=null;
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
      rates=results.getFloatArray(SpeechRecognizer.CONFIDENCE_SCORES);
    }
    if (recognitionResults == null || recognitionResults.size() == 0) {
      GoogleRecognitionServiceImpl.this.onResult(new AIResponse());
    }
 else {
      final AIRequest aiRequest=new AIRequest();
      if (rates != null) {
        aiRequest.setQuery(recognitionResults.toArray(new String[recognitionResults.size()]),rates);
      }
 else {
        aiRequest.setQuery(recognitionResults.get(0));
      }
      if (contexts != null) {
        aiRequest.setContexts(contexts);
      }
      GoogleRecognitionServiceImpl.this.sendRequest(aiRequest);
      clearRecognizer();
    }
  }
}","@TargetApi(14) @Override public void onResults(final Bundle results){
  if (recognitionActive) {
    recognitionActive=false;
    final ArrayList<String> recognitionResults=results.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION);
    float[] rates=null;
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
      rates=results.getFloatArray(SpeechRecognizer.CONFIDENCE_SCORES);
    }
    if (recognitionResults == null || recognitionResults.isEmpty()) {
      GoogleRecognitionServiceImpl.this.onResult(new AIResponse());
    }
 else {
      final AIRequest aiRequest=new AIRequest();
      if (rates != null) {
        aiRequest.setQuery(recognitionResults.toArray(new String[recognitionResults.size()]),rates);
      }
 else {
        aiRequest.setQuery(recognitionResults.get(0));
      }
      if (contexts != null) {
        aiRequest.setContexts(contexts);
      }
      GoogleRecognitionServiceImpl.this.onPartialResults(recognitionResults);
      GoogleRecognitionServiceImpl.this.sendRequest(aiRequest);
      clearRecognizer();
    }
  }
}",0.9193857965451055
163565,"public AIDialog(final Context context,final AIConfiguration config){
  this.context=context;
  this.config=config;
  dialog=new Dialog(context);
  handler=new Handler(Looper.getMainLooper());
}","public AIDialog(final Context context,final AIConfiguration config,final int customLayout){
  this.context=context;
  this.config=config;
  dialog=new Dialog(context);
  handler=new Handler(Looper.getMainLooper());
  dialog.setCanceledOnTouchOutside(true);
  dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
  dialog.setContentView(customLayout);
  partialResultsTextView=(TextView)dialog.findViewById(R.id.partialResultsTextView);
  aiButton=(AIButton)dialog.findViewById(R.id.micButton);
  aiButton.initialize(config);
  setAIButtonCallback(aiButton);
}",0.5126162018592297
163566,"public void buttonListenOnClick(final View view){
  final AIConfiguration config=new AIConfiguration(Config.ACCESS_TOKEN,Config.SUBSCRIPTION_KEY,AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  config.setExperimental(true);
  final AIDialog aiDialog=new AIDialog(this,config);
  aiDialog.setResultsListener(new AIDialog.AIDialogListener(){
    @Override public void onResult(    final AIResponse response){
      runOnUiThread(new Runnable(){
        @Override public void run(){
          Log.d(TAG,""String_Node_Str"");
          if (response.isError()) {
            resultTextView.setText(""String_Node_Str"" + response.getStatus().getErrorDetails());
            Log.i(TAG,""String_Node_Str"");
            Log.i(TAG,""String_Node_Str"" + response.getStatus().getErrorDetails());
            Log.i(TAG,""String_Node_Str"" + response.getStatus().getErrorType());
          }
 else {
            resultTextView.setText(GsonFactory.getGson().toJson(response));
            Log.i(TAG,""String_Node_Str"");
            Log.i(TAG,""String_Node_Str"" + response.getStatus().getCode());
            Log.i(TAG,""String_Node_Str"" + response.getStatus().getErrorType());
            Log.i(TAG,""String_Node_Str"" + response.getResult().getResolvedQuery());
            Log.i(TAG,""String_Node_Str"" + response.getResult().getAction());
            Log.i(TAG,""String_Node_Str"" + response.getResult().getSpeech());
            if (response.getResult().getMetadata() != null) {
              Log.i(TAG,""String_Node_Str"" + response.getResult().getMetadata().getIntentId());
              Log.i(TAG,""String_Node_Str"" + response.getResult().getMetadata().getIntentName());
            }
            if (response.getResult().getParameters() != null && !response.getResult().getParameters().isEmpty()) {
              Log.i(TAG,""String_Node_Str"");
              for (              final Map.Entry<String,JsonElement> entry : response.getResult().getParameters().entrySet()) {
                Log.i(TAG,String.format(""String_Node_Str"",entry.getKey(),entry.getValue().toString()));
              }
            }
          }
        }
      }
);
    }
    @Override public void onError(    final AIError error){
      runOnUiThread(new Runnable(){
        @Override public void run(){
          Log.d(TAG,""String_Node_Str"");
          resultTextView.setText(error.toString());
        }
      }
);
    }
  }
);
  aiDialog.show();
}","public void buttonListenOnClick(final View view){
  final AIConfiguration config=new AIConfiguration(Config.ACCESS_TOKEN,Config.SUBSCRIPTION_KEY,AIConfiguration.SupportedLanguages.English,AIConfiguration.RecognitionEngine.System);
  config.setExperimental(true);
  final AIDialog aiDialog=new AIDialog(this,config);
  aiDialog.setResultsListener(new AIDialog.AIDialogListener(){
    @Override public void onResult(    final AIResponse response){
      runOnUiThread(new Runnable(){
        @Override public void run(){
          Log.d(TAG,""String_Node_Str"");
          if (response.isError()) {
            resultTextView.setText(""String_Node_Str"" + response.getStatus().getErrorDetails());
            Log.i(TAG,""String_Node_Str"");
            Log.i(TAG,""String_Node_Str"" + response.getStatus().getErrorDetails());
            Log.i(TAG,""String_Node_Str"" + response.getStatus().getErrorType());
          }
 else {
            resultTextView.setText(GsonFactory.getGson().toJson(response));
            Log.i(TAG,""String_Node_Str"");
            Log.i(TAG,""String_Node_Str"" + response.getStatus().getCode());
            Log.i(TAG,""String_Node_Str"" + response.getStatus().getErrorType());
            Log.i(TAG,""String_Node_Str"" + response.getResult().getResolvedQuery());
            Log.i(TAG,""String_Node_Str"" + response.getResult().getAction());
            Log.i(TAG,""String_Node_Str"" + response.getResult().getSpeech());
            if (response.getResult().getMetadata() != null) {
              Log.i(TAG,""String_Node_Str"" + response.getResult().getMetadata().getIntentId());
              Log.i(TAG,""String_Node_Str"" + response.getResult().getMetadata().getIntentName());
            }
            if (response.getResult().getParameters() != null && !response.getResult().getParameters().isEmpty()) {
              Log.i(TAG,""String_Node_Str"");
              for (              final Map.Entry<String,JsonElement> entry : response.getResult().getParameters().entrySet()) {
                Log.i(TAG,String.format(""String_Node_Str"",entry.getKey(),entry.getValue().toString()));
              }
            }
          }
        }
      }
);
    }
    @Override public void onError(    final AIError error){
      runOnUiThread(new Runnable(){
        @Override public void run(){
          Log.d(TAG,""String_Node_Str"");
          resultTextView.setText(error.toString());
        }
      }
);
    }
  }
);
  aiDialog.showAndListen();
}",0.9981546032396964
163567,"@Override public void cancel(){
  if (recognitionActive) {
    runInUiThread(new Runnable(){
      @Override public void run(){
synchronized (speechRecognizerLock) {
          if (recognitionActive) {
            speechRecognizer.cancel();
            recognitionActive=false;
          }
        }
      }
    }
);
  }
}","@Override public void cancel(){
  if (recognitionActive) {
    runInUiThread(new Runnable(){
      @Override public void run(){
synchronized (speechRecognizerLock) {
          if (recognitionActive) {
            if (speechRecognizer != null) {
              speechRecognizer.cancel();
            }
            recognitionActive=false;
          }
        }
      }
    }
);
  }
}",0.9145299145299144
163568,"@Override public void run(){
synchronized (speechRecognizerLock) {
    if (recognitionActive) {
      speechRecognizer.cancel();
      recognitionActive=false;
    }
  }
}","@Override public void run(){
synchronized (speechRecognizerLock) {
    if (recognitionActive) {
      if (speechRecognizer != null) {
        speechRecognizer.cancel();
      }
      recognitionActive=false;
    }
  }
}",0.8769230769230769
163569,"@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  if (!isInEditMode()) {
    if (aiService != null) {
      aiService.pause();
    }
  }
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  if (!isInEditMode()) {
    cancelListening();
    if (aiService != null) {
      aiService.pause();
    }
  }
}",0.936986301369863
163570,"public String getContexts(){
  return contexts;
}","public String[] getContexts(){
  return contexts;
}",0.98
163571,"public String getInputContexts(){
  return inputContexts;
}","public String[] getInputContexts(){
  return inputContexts;
}",0.9833333333333332
163572,"private void init(AttributeSet attrs,int defStyle){
  final TypedArray a=getContext().obtainStyledAttributes(attrs,R.styleable.CircleView,defStyle,0);
  mTitleText=a.getString(R.styleable.CircleView_titleText);
  mSubtitleText=a.getString(R.styleable.CircleView_subtitleText);
  mTitleColor=a.getColor(R.styleable.CircleView_titleColor,mTitleColor);
  mSubtitleColor=a.getColor(R.styleable.CircleView_subtitleColor,mSubtitleColor);
  mBackgroundColor=a.getColor(R.styleable.CircleView_backgroundColor,mBackgroundColor);
  mStrokeColor=a.getColor(R.styleable.CircleView_strokeColor,mStrokeColor);
  mFillColor=a.getColor(R.styleable.CircleView_fillColor,mFillColor);
  mTitleSize=a.getDimension(R.styleable.CircleView_titleSize,mTitleSize);
  mSubtitleSize=a.getDimension(R.styleable.CircleView_subtitleSize,mSubtitleSize);
  mStrokeWidth=a.getFloat(R.styleable.CircleView_strokeWidth,mStrokeWidth);
  mFillRadius=a.getFloat(R.styleable.CircleView_fillRadius,mFillRadius);
  a.recycle();
  mTitleTextPaint=new TextPaint();
  mTitleTextPaint.setFlags(Paint.ANTI_ALIAS_FLAG);
  mTitleTextPaint.setTypeface(Typeface.defaultFromStyle(Typeface.NORMAL));
  mTitleTextPaint.setTextAlign(Paint.Align.CENTER);
  mTitleTextPaint.setLinearText(true);
  mTitleTextPaint.setColor(mTitleColor);
  mTitleTextPaint.setTextSize(mTitleSize);
  mSubTextPaint=new TextPaint();
  mSubTextPaint.setFlags(Paint.ANTI_ALIAS_FLAG);
  mSubTextPaint.setTypeface(Typeface.defaultFromStyle(Typeface.NORMAL));
  mSubTextPaint.setTextAlign(Paint.Align.CENTER);
  mSubTextPaint.setLinearText(true);
  mSubTextPaint.setColor(mSubtitleColor);
  mSubTextPaint.setTextSize(mSubtitleSize);
  mStrokePaint=new Paint();
  mStrokePaint.setFlags(Paint.ANTI_ALIAS_FLAG);
  mStrokePaint.setStyle(Paint.Style.STROKE);
  mStrokePaint.setColor(mStrokeColor);
  mStrokePaint.setStrokeWidth(mStrokeWidth);
  mBackgroundPaint=new Paint();
  mBackgroundPaint.setFlags(Paint.ANTI_ALIAS_FLAG);
  mBackgroundPaint.setStyle(Paint.Style.FILL);
  mBackgroundPaint.setColor(mBackgroundColor);
  mFillPaint=new Paint();
  mFillPaint.setFlags(Paint.ANTI_ALIAS_FLAG);
  mFillPaint.setStyle(Paint.Style.FILL);
  mFillPaint.setColor(mFillColor);
  mInnerRectF=new RectF();
}","private void init(AttributeSet attrs,int defStyle){
  final TypedArray a=getContext().obtainStyledAttributes(attrs,R.styleable.CircleView,defStyle,0);
  if (a.hasValue(R.styleable.CircleView_titleText)) {
    mTitleText=a.getString(R.styleable.CircleView_titleText);
  }
  if (a.hasValue(R.styleable.CircleView_subtitleText)) {
    mSubtitleText=a.getString(R.styleable.CircleView_subtitleText);
  }
  mTitleColor=a.getColor(R.styleable.CircleView_titleColor,DEFAULT_TITLE_COLOR);
  mSubtitleColor=a.getColor(R.styleable.CircleView_subtitleColor,DEFAULT_SUBTITLE_COLOR);
  mBackgroundColor=a.getColor(R.styleable.CircleView_backgroundColorValue,DEFAULT_BACKGROUND_COLOR);
  mStrokeColor=a.getColor(R.styleable.CircleView_strokeColorValue,DEFAULT_STROKE_COLOR);
  mFillColor=a.getColor(R.styleable.CircleView_fillColor,DEFAULT_FILL_COLOR);
  mTitleSize=a.getDimension(R.styleable.CircleView_titleSize,DEFAULT_TITLE_SIZE);
  mSubtitleSize=a.getDimension(R.styleable.CircleView_subtitleSize,DEFAULT_SUBTITLE_SIZE);
  mStrokeWidth=a.getFloat(R.styleable.CircleView_strokeWidthSize,DEFAULT_STROKE_WIDTH);
  mFillRadius=a.getFloat(R.styleable.CircleView_fillRadius,DEFAULT_FILL_RADIUS);
  a.recycle();
  mTitleTextPaint=new TextPaint();
  mTitleTextPaint.setFlags(Paint.ANTI_ALIAS_FLAG);
  mTitleTextPaint.setTypeface(Typeface.defaultFromStyle(Typeface.NORMAL));
  mTitleTextPaint.setTextAlign(Paint.Align.CENTER);
  mTitleTextPaint.setLinearText(true);
  mTitleTextPaint.setColor(mTitleColor);
  mTitleTextPaint.setTextSize(mTitleSize);
  mSubTextPaint=new TextPaint();
  mSubTextPaint.setFlags(Paint.ANTI_ALIAS_FLAG);
  mSubTextPaint.setTypeface(Typeface.defaultFromStyle(Typeface.NORMAL));
  mSubTextPaint.setTextAlign(Paint.Align.CENTER);
  mSubTextPaint.setLinearText(true);
  mSubTextPaint.setColor(mSubtitleColor);
  mSubTextPaint.setTextSize(mSubtitleSize);
  mStrokePaint=new Paint();
  mStrokePaint.setFlags(Paint.ANTI_ALIAS_FLAG);
  mStrokePaint.setStyle(Paint.Style.STROKE);
  mStrokePaint.setColor(mStrokeColor);
  mStrokePaint.setStrokeWidth(mStrokeWidth);
  mBackgroundPaint=new Paint();
  mBackgroundPaint.setFlags(Paint.ANTI_ALIAS_FLAG);
  mBackgroundPaint.setStyle(Paint.Style.FILL);
  mBackgroundPaint.setColor(mBackgroundColor);
  mFillPaint=new Paint();
  mFillPaint.setFlags(Paint.ANTI_ALIAS_FLAG);
  mFillPaint.setStyle(Paint.Style.FILL);
  mFillPaint.setColor(mFillColor);
  mInnerRectF=new RectF();
}",0.3918772953121625
163573,"/** 
 * Sets the view's title size dimension attribute value.
 * @param titleSize The title size dimension attribute value to use.
 */
public void setTitleSize(float titleSize){
  mTitleSize=titleSize;
  invalidate();
}","/** 
 * Sets the view's title size dimension attribute value.
 * @param titleSize The title size dimension attribute value to use.
 */
public void setTitleSize(float titleSize){
  mTitleSize=titleSize;
  invalidateTextPaints();
}",0.9776785714285714
163574,"/** 
 * Sets the view's subtitle size dimension attribute value.
 * @param subtitleSize The subtitle size dimension attribute value to use.
 */
public void setSubtitleSize(float subtitleSize){
  mTitleSize=subtitleSize;
  invalidate();
}","/** 
 * Sets the view's subtitle size dimension attribute value.
 * @param subtitleSize The subtitle size dimension attribute value to use.
 */
public void setSubtitleSize(float subtitleSize){
  mSubtitleSize=subtitleSize;
  invalidateTextPaints();
}",0.8295687885010267
163575,"/** 
 * Sets the view's subtitle string attribute value.
 * @param subtitle The example string attribute value to use.
 */
public void setSubtitleText(String subtitle){
  mTitleText=subtitle;
  invalidate();
}","/** 
 * Sets the view's subtitle string attribute value.
 * @param subtitle The example string attribute value to use.
 */
public void setSubtitleText(String subtitle){
  mSubtitleText=subtitle;
  invalidate();
}",0.98812351543943
163576,"/** 
 * Sets the view's fill color attribute value.
 * @param fillColor The fill color attribute value to use.
 */
public void setFillColor(int fillColor){
  mFillColor=fillColor;
  invalidate();
}","/** 
 * Sets the view's fill color attribute value.
 * @param fillColor The fill color attribute value to use.
 */
public void setFillColor(int fillColor){
  mFillColor=fillColor;
  invalidatePaints();
}",0.985
163577,"/** 
 * Sets the view's stroke color attribute value.
 * @param strokeColor The stroke color attribute value to use.
 */
public void setStrokeColor(int strokeColor){
  mStrokeColor=strokeColor;
  invalidate();
}","/** 
 * Sets the view's stroke color attribute value.
 * @param strokeColor The stroke color attribute value to use.
 */
public void setStrokeColor(int strokeColor){
  mStrokeColor=strokeColor;
  invalidatePaints();
}",0.985981308411215
163578,"public void updateTrajectory(float[] translation){
  mVertexBuffer.position(mTrajectoryCount * 3);
  mVertexBuffer.put(new float[]{translation[0],translation[2],-translation[1]});
  mTrajectoryCount++;
}","public void updateTrajectory(float[] translation){
  mVertexBuffer.position(mTrajectoryCount * 3);
  if (((mTrajectoryCount + 1) * 3) >= MAX_VERTICES) {
    Log.w(TAG,""String_Node_Str"");
    resetPath();
  }
  mVertexBuffer.put(new float[]{translation[0],translation[2],-translation[1]});
  mTrajectoryCount++;
}",0.7883495145631068
163579,"public Trajectory(){
  Matrix.setIdentityM(getModelMatrix(),0);
  ByteBuffer vertexByteBuffer=ByteBuffer.allocateDirect(GRID_RANGE_M * BYTES_PER_FLOAT);
  vertexByteBuffer.order(ByteOrder.nativeOrder());
  mVertexBuffer=vertexByteBuffer.asFloatBuffer();
  int vertexShader=RenderUtils.loadShader(GLES20.GL_VERTEX_SHADER,sVertexShaderCode);
  int fragShader=RenderUtils.loadShader(GLES20.GL_FRAGMENT_SHADER,sFragmentShaderCode);
  mProgram=GLES20.glCreateProgram();
  GLES20.glAttachShader(mProgram,vertexShader);
  GLES20.glAttachShader(mProgram,fragShader);
  GLES20.glLinkProgram(mProgram);
}","public Trajectory(){
  Matrix.setIdentityM(getModelMatrix(),0);
  ByteBuffer vertexByteBuffer=ByteBuffer.allocateDirect(MAX_VERTICES * BYTES_PER_FLOAT);
  vertexByteBuffer.order(ByteOrder.nativeOrder());
  mVertexBuffer=vertexByteBuffer.asFloatBuffer();
  int vertexShader=RenderUtils.loadShader(GLES20.GL_VERTEX_SHADER,sVertexShaderCode);
  int fragShader=RenderUtils.loadShader(GLES20.GL_FRAGMENT_SHADER,sFragmentShaderCode);
  mProgram=GLES20.glCreateProgram();
  GLES20.glAttachShader(mProgram,vertexShader);
  GLES20.glAttachShader(mProgram,fragShader);
  GLES20.glLinkProgram(mProgram);
}",0.9814814814814816
163580,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_about);
  mResources=getResources();
  StringBuilder builder=new StringBuilder();
  addStringsFromArray(builder,R.array.meta_about,LINE_BREAK + LINE_BREAK);
  addString(builder,LINE_BREAK);
  addStringsFromArray(builder,R.array.meta_questions_answers,LINE_BREAK + LINE_BREAK,true);
  addString(builder,LINE_BREAK);
  addTitleAndBody(builder,R.string.meta_security_title,R.array.meta_security_body);
  addTitleAndBody(builder,R.string.meta_permissions_title,R.array.meta_permissions_body);
  addTitleAndBody(builder,R.string.meta_privacy_title,R.array.meta_privacy_body);
  addTitleAndBody(builder,R.string.meta_open_source_title,R.array.meta_open_source_body);
  builder.setLength(builder.length() - (LINE_BREAK.length() * 3));
  if (Config.DEMO_ACTIVE) {
    final String[] descriptionChunks=Strings.splitToChunks(builder.toString(),4000);
    for (    String descriptionChunk : descriptionChunks) {
      System.out.println(descriptionChunk);
    }
  }
  mTextViewAbout=(TextView)findViewById(R.id.textViewAbout);
  mTextViewAbout.setText(Html.fromHtml(builder.toString()));
  mButtonRate=(Button)findViewById(R.id.buttonRate);
  mButtonRate.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      final String packageName=getApplicationContext().getPackageName();
      Intent rateIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(String.format(URL_GOOGLE_PLAY,packageName)));
      startActivity(rateIntent);
    }
  }
);
  findViewById(R.id.buttonTranslate).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      AlertDialog.Builder builder=new AlertDialog.Builder(ActivityAbout.this);
      builder.setTitle(R.string.translate);
      builder.setMessage(R.string.translate_explanation);
      builder.setNeutralButton(R.string.ok,null);
      builder.show();
    }
  }
);
  BackgroundPatterns.applyRandomBackground(this,mTextViewAbout);
  getActionBar().setDisplayHomeAsUpEnabled(true);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_about);
  mResources=getResources();
  StringBuilder builder=new StringBuilder();
  addStringsFromArray(builder,R.array.meta_about,LINE_BREAK + LINE_BREAK);
  addString(builder,LINE_BREAK);
  addStringsFromArray(builder,R.array.meta_questions_answers,LINE_BREAK + LINE_BREAK,true);
  addString(builder,LINE_BREAK);
  addTitleAndBody(builder,R.string.meta_security_title,R.array.meta_security_body);
  addTitleAndBody(builder,R.string.meta_permissions_title,R.array.meta_permissions_body);
  addTitleAndBody(builder,R.string.meta_privacy_title,R.array.meta_privacy_body);
  addTitleAndBody(builder,R.string.meta_open_source_title,R.array.meta_open_source_body);
  builder.setLength(builder.length() - (LINE_BREAK.length() * 3));
  if (Config.DEMO_ACTIVE) {
    final StringBuilder appDescription=new StringBuilder();
    appDescription.append(""String_Node_Str"");
    appDescription.append(""String_Node_Str"");
    appDescription.append(Base64.encodeToString(builder.toString().getBytes(),Base64.NO_WRAP));
    appDescription.append(""String_Node_Str"");
    final String[] descriptionChunks=Strings.splitToChunks(appDescription.toString(),4000);
    for (    String descriptionChunk : descriptionChunks) {
      System.out.println(descriptionChunk);
    }
  }
  mTextViewAbout=(TextView)findViewById(R.id.textViewAbout);
  mTextViewAbout.setText(Html.fromHtml(builder.toString()));
  mButtonRate=(Button)findViewById(R.id.buttonRate);
  mButtonRate.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      final String packageName=getApplicationContext().getPackageName();
      Intent rateIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(String.format(URL_GOOGLE_PLAY,packageName)));
      startActivity(rateIntent);
    }
  }
);
  findViewById(R.id.buttonTranslate).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      AlertDialog.Builder builder=new AlertDialog.Builder(ActivityAbout.this);
      builder.setTitle(R.string.translate);
      builder.setMessage(R.string.translate_explanation);
      builder.setNeutralButton(R.string.ok,null);
      builder.show();
    }
  }
);
  BackgroundPatterns.applyRandomBackground(this,mTextViewAbout);
  getActionBar().setDisplayHomeAsUpEnabled(true);
}",0.9304789229750609
163581,"/** 
 * Encodes a string in Base-64.
 * @param str Required: String to encode.
 * @return Base-64 encoded string.
 */
public final static String encodeBase64(String str){
  if (str == null) {
    return null;
  }
  byte[] data=str.getBytes(Charset.forName(""String_Node_Str""));
  return Base64.encodeToString(data,Base64.NO_PADDING);
}","/** 
 * Encodes a string in Base-64.
 * @param str Required: String to encode.
 * @return Base-64 encoded string.
 */
public final static String encodeBase64(String str){
  if (str == null) {
    return null;
  }
  byte[] data=str.getBytes(Charset.forName(""String_Node_Str""));
  return Base64.encodeToString(data,Base64.URL_SAFE | Base64.NO_WRAP | Base64.NO_PADDING);
}",0.9502133712660028
163582,"/** 
 * Encodes a string in Base-64.
 * @param str Required: String to encode.
 * @return Base-64 encoded string.
 */
public final static String encodeBase64(String str){
  if (str == null) {
    return null;
  }
  byte[] data=str.getBytes(Charset.forName(""String_Node_Str""));
  return Base64.encodeToString(data,Base64.NO_PADDING);
}","/** 
 * Encodes a string in Base-64.
 * @param str Required: String to encode.
 * @return Base-64 encoded string.
 */
public final static String encodeBase64(String str){
  if (str == null) {
    return null;
  }
  byte[] data=str.getBytes(Charset.forName(""String_Node_Str""));
  return Base64.encodeToString(data,Base64.URL_SAFE | Base64.NO_WRAP | Base64.NO_PADDING);
}",0.9502133712660028
163583,"/** 
 * Converts string into SHA-256 hash.
 * @param data Required: The {@link String} to hash.
 * @return the hash as a {@link String}.
 */
public final static String generateHash(String data) throws Exception {
  String hashedData=data;
  try {
    byte[] bytes=data.getBytes(""String_Node_Str"");
    MessageDigest digest=MessageDigest.getInstance(""String_Node_Str"");
    digest.update(bytes,0,bytes.length);
    byte[] digestBytes=digest.digest();
    hashedData=Base64.encodeToString(digestBytes,Base64.URL_SAFE | Base64.NO_WRAP | Base64.NO_PADDING);
  }
 catch (  Exception e) {
    throw e;
  }
  return hashedData;
}","/** 
 * Converts string into SHA-256 hash.
 * @param data Required: The {@link String} to hash.
 * @return the hash as a {@link String}.
 */
public final static String generateHash(String data) throws Exception {
  String hashedData=data;
  try {
    byte[] bytes=data.getBytes(StandardCharsets.US_ASCII);
    MessageDigest digest=MessageDigest.getInstance(""String_Node_Str"");
    digest.update(bytes,0,bytes.length);
    byte[] digestBytes=digest.digest();
    hashedData=Base64.encodeToString(digestBytes,Base64.URL_SAFE | Base64.NO_WRAP | Base64.NO_PADDING);
  }
 catch (  Exception e) {
    throw e;
  }
  return hashedData;
}",0.9680511182108626
163584,"/** 
 * Calls   {@Code continueTask()} of the parent after checking if all the required attributes have been set.
 */
public void continueTask(){
  if (requiredAttributes != null && requiredAttributes.size() > 1) {
    for (    String requiredAttribute : requiredAttributes) {
      if (!challengeResponses.containsKey(requiredAttribute)) {
        throw new CognitoParameterInvalidException(String.format(""String_Node_Str"",requiredAttribute));
      }
    }
  }
  if (challengeResponses.containsKey(CognitoServiceConstants.CHLG_RESP_NEW_PASSWORD) && (challengeResponses.get(CognitoServiceConstants.CHLG_RESP_NEW_PASSWORD) != null)) {
    super.continueTask();
  }
 else {
    throw new CognitoParameterInvalidException(""String_Node_Str"");
  }
}","/** 
 * Calls   {@Code continueTask()} of the parent after checking if all the required attributes have been set.
 */
public void continueTask(){
  if (requiredAttributes != null && requiredAttributes.size() > 1) {
    for (    String requiredAttribute : requiredAttributes) {
      String requiredAttrKey=CognitoServiceConstants.CHLG_PARAM_USER_ATTRIBUTE_PREFIX + requiredAttribute;
      if (!challengeResponses.containsKey(requiredAttrKey)) {
        throw new CognitoParameterInvalidException(String.format(""String_Node_Str"",requiredAttribute));
      }
    }
  }
  if (challengeResponses.containsKey(CognitoServiceConstants.CHLG_RESP_NEW_PASSWORD) && (challengeResponses.get(CognitoServiceConstants.CHLG_RESP_NEW_PASSWORD) != null)) {
    super.continueTask();
  }
 else {
    throw new CognitoParameterInvalidException(""String_Node_Str"");
  }
}",0.6658307210031348
163585,"@Override public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  validateInterfaceMethod(method,args);
  InvokeRequest invokeRequest=buildInvokeRequest(method,args == null ? null : args[0]);
  InvokeResult invokeResult=lambda.invoke(invokeRequest);
  return processInvokeResult(method,invokeResult);
}","@Override public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  validateInterfaceMethod(method,args);
  final Object buildArg=(args == null || args.length == 0) ? null : args[0];
  InvokeRequest invokeRequest=buildInvokeRequest(method,buildArg);
  InvokeResult invokeResult=lambda.invoke(invokeRequest);
  return processInvokeResult(method,invokeResult);
}",0.7374301675977654
163586,"@Override public void processLine(String line){
  if (images != null && line.contains(AndroidBuild.TARGET_PLATFORM) && line.contains(imageTag))   System.out.println(""String_Node_Str"" + line);
  images.add(line);
}","@Override public void processLine(String line){
  System.out.println(""String_Node_Str"" + line);
  if (images != null && line.contains(AndroidBuild.TARGET_PLATFORM) && line.contains(imageTag))   System.out.println(""String_Node_Str"");
  images.add(line);
}",0.8822269807280514
163587,"protected boolean create(final AndroidSDK sdk) throws IOException {
  File sketchbookFolder=processing.app.Base.getSketchbookFolder();
  File androidFolder=new File(sketchbookFolder,""String_Node_Str"");
  if (!androidFolder.exists())   androidFolder.mkdir();
  File avdPath=new File(androidFolder,""String_Node_Str"" + name);
  ProcessBuilder pb=new ProcessBuilder(sdk.getAvdManagerPath(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",name,""String_Node_Str"",getSdkId(),""String_Node_Str"",DEFAULT_SDCARD_SIZE,""String_Node_Str"",device,""String_Node_Str"",avdPath.getAbsolutePath(),""String_Node_Str"");
  avdList=null;
  Map<String,String> env=pb.environment();
  env.clear();
  env.put(""String_Node_Str"",Platform.getJavaHome().getCanonicalPath());
  pb.redirectErrorStream(true);
  try {
    process=pb.start();
    OutputStream os=process.getOutputStream();
    PrintWriter pw=new PrintWriter(new OutputStreamWriter(os));
    pw.println(""String_Node_Str"");
    pw.flush();
    pw.close();
    os.flush();
    os.close();
    StringWriter outWriter=new StringWriter();
    new StreamPump(process.getInputStream(),""String_Node_Str"").addTarget(outWriter).start();
    process.waitFor();
    if (process.exitValue() == 0) {
      File configFile=new File(avdPath,""String_Node_Str"");
      if (configFile.exists()) {
        try (PrintWriter output=new PrintWriter(new FileWriter(configFile.getAbsolutePath(),true))){
          output.printf(""String_Node_Str"",""String_Node_Str"" + skin);
        }
 catch (        Exception e) {
        }
      }
      return true;
    }
    if (outWriter.toString().contains(""String_Node_Str"")) {
      AndroidUtil.showMessage(AVD_TARGET_TITLE,AVD_TARGET_MESSAGE);
    }
 else {
      AndroidUtil.showMessage(AVD_CREATE_TITLE,String.format(AVD_CREATE_MESSAGE,AndroidBuild.TARGET_SDK));
    }
    System.err.println(outWriter.toString());
  }
 catch (  final InterruptedException ie) {
    ie.printStackTrace();
  }
 finally {
    process.destroy();
  }
  return false;
}","protected boolean create(final AndroidSDK sdk) throws IOException {
  File sketchbookFolder=processing.app.Base.getSketchbookFolder();
  File androidFolder=new File(sketchbookFolder,""String_Node_Str"");
  if (!androidFolder.exists())   androidFolder.mkdir();
  File avdPath=new File(androidFolder,""String_Node_Str"" + name);
  final String[] cmd=new String[]{sdk.getAvdManagerPath(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",name,""String_Node_Str"",getSdkId(),""String_Node_Str"",DEFAULT_SDCARD_SIZE,""String_Node_Str"",device,""String_Node_Str"",avdPath.getAbsolutePath(),""String_Node_Str""};
  ProcessBuilder pb=new ProcessBuilder(cmd);
  System.out.println(processing.core.PApplet.join(cmd,""String_Node_Str""));
  avdList=null;
  Map<String,String> env=pb.environment();
  env.clear();
  env.put(""String_Node_Str"",Platform.getJavaHome().getCanonicalPath());
  pb.redirectErrorStream(true);
  try {
    process=pb.start();
    OutputStream os=process.getOutputStream();
    PrintWriter pw=new PrintWriter(new OutputStreamWriter(os));
    pw.println(""String_Node_Str"");
    pw.flush();
    pw.close();
    os.flush();
    os.close();
    StringWriter outWriter=new StringWriter();
    new StreamPump(process.getInputStream(),""String_Node_Str"").addTarget(outWriter).start();
    process.waitFor();
    if (process.exitValue() == 0) {
      File configFile=new File(avdPath,""String_Node_Str"");
      if (configFile.exists()) {
        try (PrintWriter output=new PrintWriter(new FileWriter(configFile.getAbsolutePath(),true))){
          output.printf(""String_Node_Str"",""String_Node_Str"" + skin);
        }
 catch (        Exception e) {
        }
      }
      return true;
    }
    if (outWriter.toString().contains(""String_Node_Str"")) {
      AndroidUtil.showMessage(AVD_TARGET_TITLE,AVD_TARGET_MESSAGE);
    }
 else {
      AndroidUtil.showMessage(AVD_CREATE_TITLE,String.format(AVD_CREATE_MESSAGE,AndroidBuild.TARGET_SDK));
    }
    System.err.println(outWriter.toString());
  }
 catch (  final InterruptedException ie) {
    ie.printStackTrace();
  }
 finally {
    process.destroy();
  }
  return false;
}",0.9564794553853636
163588,"static public boolean ensureProperAVD(final Frame window,final AndroidMode mode,final AndroidSDK sdk,boolean wear){
  try {
    if (wear) {
      if (wearAVD.exists(sdk)) {
        return true;
      }
      if (wearAVD.badness()) {
        AndroidUtil.showMessage(AVD_LOAD_TITLE,AVD_LOAD_MESSAGE);
        return false;
      }
      if (wearAVD.hasWearImages(sdk)) {
        boolean res=AndroidSDK.locateSysImage(window,mode,true);
        if (!res) {
          return false;
        }
 else {
          wearAVD.refreshWearImages(sdk);
        }
      }
      if (wearAVD.create(sdk)) {
        return true;
      }
    }
 else {
      if (mobileAVD.exists(sdk)) {
        return true;
      }
      if (mobileAVD.badness()) {
        AndroidUtil.showMessage(AVD_LOAD_TITLE,AVD_LOAD_MESSAGE);
        return false;
      }
      if (mobileAVD.hasImages(sdk)) {
        boolean res=AndroidSDK.locateSysImage(window,mode,false);
        if (!res) {
          return false;
        }
 else {
          mobileAVD.refreshImages(sdk);
        }
      }
      if (mobileAVD.create(sdk)) {
        return true;
      }
    }
  }
 catch (  final Exception e) {
    e.printStackTrace();
    AndroidUtil.showMessage(AVD_CREATE_TITLE,String.format(AVD_CREATE_MESSAGE,AndroidBuild.TARGET_SDK));
  }
  return false;
}","static public boolean ensureProperAVD(final Frame window,final AndroidMode mode,final AndroidSDK sdk,boolean wear){
  try {
    if (wear) {
      if (wearAVD.exists(sdk)) {
        return true;
      }
      if (wearAVD.badness()) {
        AndroidUtil.showMessage(AVD_LOAD_TITLE,AVD_LOAD_MESSAGE);
        return false;
      }
      if (!wearAVD.hasWearImages(sdk)) {
        boolean res=AndroidSDK.locateSysImage(window,mode,true);
        if (!res) {
          return false;
        }
 else {
          wearAVD.refreshWearImages(sdk);
        }
      }
      if (wearAVD.create(sdk)) {
        return true;
      }
    }
 else {
      if (mobileAVD.exists(sdk)) {
        return true;
      }
      if (mobileAVD.badness()) {
        AndroidUtil.showMessage(AVD_LOAD_TITLE,AVD_LOAD_MESSAGE);
        return false;
      }
      if (!mobileAVD.hasImages(sdk)) {
        boolean res=AndroidSDK.locateSysImage(window,mode,false);
        if (!res) {
          return false;
        }
 else {
          mobileAVD.refreshImages(sdk);
        }
      }
      if (mobileAVD.create(sdk)) {
        return true;
      }
    }
  }
 catch (  final Exception e) {
    e.printStackTrace();
    AndroidUtil.showMessage(AVD_CREATE_TITLE,String.format(AVD_CREATE_MESSAGE,AndroidBuild.TARGET_SDK));
  }
  return false;
}",0.9992343032159264
163589,"protected void getImages(final ArrayList<String> images,final AndroidSDK sdk,final String imageTag) throws IOException {
  ProcessBuilder pb=new ProcessBuilder(sdk.getAvdManagerPath(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Map<String,String> env=pb.environment();
  env.clear();
  env.put(""String_Node_Str"",Platform.getJavaHome().getCanonicalPath());
  pb.redirectErrorStream(true);
  try {
    process=pb.start();
    StreamPump output=new StreamPump(process.getInputStream(),""String_Node_Str"");
    output.addTarget(new LineProcessor(){
      @Override public void processLine(      String line){
        if (images != null && line.contains(AndroidBuild.TARGET_PLATFORM) && line.contains(imageTag))         System.out.println(""String_Node_Str"" + line);
        images.add(line);
      }
    }
).start();
    process.waitFor();
  }
 catch (  final InterruptedException ie) {
    ie.printStackTrace();
  }
 finally {
    process.destroy();
  }
}","protected void getImages(final ArrayList<String> images,final AndroidSDK sdk,final String imageTag) throws IOException {
  final String[] cmd=new String[]{sdk.getAvdManagerPath(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ProcessBuilder pb=new ProcessBuilder(cmd);
  System.out.println(processing.core.PApplet.join(cmd,""String_Node_Str""));
  Map<String,String> env=pb.environment();
  env.clear();
  env.put(""String_Node_Str"",Platform.getJavaHome().getCanonicalPath());
  pb.redirectErrorStream(true);
  try {
    process=pb.start();
    StreamPump output=new StreamPump(process.getInputStream(),""String_Node_Str"");
    output.addTarget(new LineProcessor(){
      @Override public void processLine(      String line){
        System.out.println(""String_Node_Str"" + line);
        if (images != null && line.contains(AndroidBuild.TARGET_PLATFORM) && line.contains(imageTag))         System.out.println(""String_Node_Str"");
        images.add(line);
      }
    }
).start();
    process.waitFor();
  }
 catch (  final InterruptedException ie) {
    ie.printStackTrace();
  }
 finally {
    process.destroy();
  }
}",0.8180163785259327
163590,"public JMenu buildModeMenu(){
  JMenu menu=new JMenu(""String_Node_Str"");
  JMenuItem item;
  item=new JMenuItem(""String_Node_Str"");
  item.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      new Permissions(sketch,appComponent,androidMode.getFolder());
    }
  }
);
  menu.add(item);
  menu.addSeparator();
  fragmentItem=new JCheckBoxMenuItem(""String_Node_Str"");
  wallpaperItem=new JCheckBoxMenuItem(""String_Node_Str"");
  watchfaceItem=new JCheckBoxMenuItem(""String_Node_Str"");
  vrItem=new JCheckBoxMenuItem(""String_Node_Str"");
  fragmentItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      fragmentItem.setState(true);
      wallpaperItem.setState(false);
      watchfaceItem.setSelected(false);
      vrItem.setSelected(false);
      setAppComponent(AndroidBuild.APP);
    }
  }
);
  wallpaperItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      fragmentItem.setState(false);
      wallpaperItem.setState(true);
      watchfaceItem.setSelected(false);
      vrItem.setSelected(false);
      setAppComponent(AndroidBuild.WALLPAPER);
    }
  }
);
  watchfaceItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      fragmentItem.setState(false);
      wallpaperItem.setState(false);
      watchfaceItem.setSelected(true);
      vrItem.setSelected(false);
      setAppComponent(AndroidBuild.WATCHFACE);
    }
  }
);
  vrItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      fragmentItem.setState(false);
      wallpaperItem.setState(false);
      watchfaceItem.setSelected(false);
      vrItem.setSelected(true);
      setAppComponent(AndroidBuild.VR);
    }
  }
);
  fragmentItem.setState(false);
  wallpaperItem.setState(false);
  watchfaceItem.setSelected(false);
  vrItem.setSelected(false);
  menu.add(fragmentItem);
  menu.add(wallpaperItem);
  menu.add(watchfaceItem);
  menu.add(vrItem);
  menu.addSeparator();
  final JMenu mobDeveMenu=new JMenu(""String_Node_Str"");
  JMenuItem noMobDevItem=new JMenuItem(""String_Node_Str"");
  noMobDevItem.setEnabled(false);
  mobDeveMenu.add(noMobDevItem);
  menu.add(mobDeveMenu);
  UpdateDeviceListTask task=new UpdateDeviceListTask(mobDeveMenu);
  if (updateDevicesTimer == null) {
    updateDevicesTimer=new java.util.Timer();
  }
 else {
    updateDevicesTimer.cancel();
  }
  updateDevicesTimer.schedule(task,5000,5000);
  menu.addSeparator();
  item=new JMenuItem(""String_Node_Str"");
  item.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      new SDKUpdater();
    }
  }
);
  menu.add(item);
  item=new JMenuItem(""String_Node_Str"");
  item.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      Devices.killAdbServer();
    }
  }
);
  menu.add(item);
  return menu;
}","public JMenu buildModeMenu(){
  JMenu menu=new JMenu(""String_Node_Str"");
  JMenuItem item;
  item=new JMenuItem(""String_Node_Str"");
  item.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      new Permissions(sketch,appComponent,androidMode.getFolder());
    }
  }
);
  menu.add(item);
  menu.addSeparator();
  fragmentItem=new JCheckBoxMenuItem(""String_Node_Str"");
  wallpaperItem=new JCheckBoxMenuItem(""String_Node_Str"");
  watchfaceItem=new JCheckBoxMenuItem(""String_Node_Str"");
  vrItem=new JCheckBoxMenuItem(""String_Node_Str"");
  fragmentItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      fragmentItem.setState(true);
      wallpaperItem.setState(false);
      watchfaceItem.setSelected(false);
      vrItem.setSelected(false);
      setAppComponent(AndroidBuild.APP);
    }
  }
);
  wallpaperItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      fragmentItem.setState(false);
      wallpaperItem.setState(true);
      watchfaceItem.setSelected(false);
      vrItem.setSelected(false);
      setAppComponent(AndroidBuild.WALLPAPER);
    }
  }
);
  watchfaceItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      fragmentItem.setState(false);
      wallpaperItem.setState(false);
      watchfaceItem.setSelected(true);
      vrItem.setSelected(false);
      setAppComponent(AndroidBuild.WATCHFACE);
    }
  }
);
  vrItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      fragmentItem.setState(false);
      wallpaperItem.setState(false);
      watchfaceItem.setSelected(false);
      vrItem.setSelected(true);
      setAppComponent(AndroidBuild.VR);
    }
  }
);
  fragmentItem.setState(false);
  wallpaperItem.setState(false);
  watchfaceItem.setSelected(false);
  vrItem.setSelected(false);
  menu.add(fragmentItem);
  menu.add(wallpaperItem);
  menu.add(watchfaceItem);
  menu.add(vrItem);
  menu.addSeparator();
  final JMenu mobDeveMenu=new JMenu(""String_Node_Str"");
  JMenuItem noMobDevItem=new JMenuItem(""String_Node_Str"");
  noMobDevItem.setEnabled(false);
  mobDeveMenu.add(noMobDevItem);
  menu.add(mobDeveMenu);
  UpdateDeviceListTask task=new UpdateDeviceListTask(mobDeveMenu);
  if (updateDevicesTimer == null) {
    updateDevicesTimer=new java.util.Timer();
  }
 else {
    updateDevicesTimer.cancel();
  }
  updateDevicesTimer.schedule(task,5000,5000);
  menu.addSeparator();
  item=new JMenuItem(""String_Node_Str"");
  item.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      new SDKUpdater(AndroidEditor.this,androidMode);
    }
  }
);
  menu.add(item);
  item=new JMenuItem(""String_Node_Str"");
  item.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      Devices.killAdbServer();
    }
  }
);
  menu.add(item);
  return menu;
}",0.9950066577896138
163591,"public void actionPerformed(ActionEvent actionEvent){
  cancelTasks();
  setVisible(false);
}","public void actionPerformed(ActionEvent actionEvent){
  cancelTasks();
  dispose();
}",0.898876404494382
163592,"@Override protected Object doInBackground() throws Exception {
  ArrayList<String> cmd=new ArrayList<>();
  String path=toolsFolder + File.separator + ""String_Node_Str""+ File.separator;
  if (Platform.isWindows())   path+=""String_Node_Str"";
 else   path+=""String_Node_Str"";
  cmd.add(path);
  if (installFlag) {
  }
 else {
    cmd.add(""String_Node_Str"");
    ProcessBuilder process=new ProcessBuilder(cmd);
    Process p=process.start();
    try {
      progressBar.setIndeterminate(true);
      p.waitFor();
    }
 catch (    InterruptedException e) {
      p.destroy();
    }
    progressBar.setIndeterminate(false);
  }
  return null;
}","@Override protected Object doInBackground() throws Exception {
  downloadTaskRunning=true;
  ArrayList<String> cmd=new ArrayList<>();
  String path=toolsFolder + File.separator + ""String_Node_Str""+ File.separator;
  if (Platform.isWindows())   path+=""String_Node_Str"";
 else   path+=""String_Node_Str"";
  cmd.add(path);
  cmd.add(""String_Node_Str"");
  ProcessBuilder process=new ProcessBuilder(cmd);
  backgroundProcess=process.start();
  backgroundProcess.waitFor();
  return null;
}",0.5253784505788067
163593,"private void createLayout(){
  Container outer=getContentPane();
  outer.removeAll();
  Box verticalBox=Box.createVerticalBox();
  verticalBox.setBorder(new EmptyBorder(13,13,13,13));
  outer.add(verticalBox);
  JPanel packagesPanel=new JPanel();
  packagesPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(),""String_Node_Str""));
  BoxLayout boxLayout=new BoxLayout(packagesPanel,BoxLayout.Y_AXIS);
  packagesPanel.setLayout(boxLayout);
  JPanel installedPanel=new JPanel();
  installedPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(),""String_Node_Str""));
  modelInstalled=new DefaultTableModel(15,columnClassI.length){
    @Override public boolean isCellEditable(    int row,    int column){
      return false;
    }
    @Override public Class<?> getColumnClass(    int columnIndex){
      return columnClassI[columnIndex];
    }
  }
;
  JTable tInstalled=new JTable(modelInstalled){
    @Override public String getColumnName(    int column){
      return columnsInstalled.get(column);
    }
  }
;
  tInstalled.setFillsViewportHeight(true);
  tInstalled.setPreferredScrollableViewportSize(new Dimension(tInstalled.getPreferredSize().width,15 * tInstalled.getRowHeight()));
  installedPanel.add(new JScrollPane(tInstalled));
  JPanel updatesPanel=new JPanel();
  updatesPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(),""String_Node_Str""));
  modelUpdates=new DefaultTableModel(5,columnClassU.length){
    @Override public boolean isCellEditable(    int row,    int column){
      return false;
    }
    @Override public Class<?> getColumnClass(    int columnIndex){
      return columnClassU[columnIndex];
    }
  }
;
  JTable tUpdates=new JTable(modelUpdates){
    @Override public String getColumnName(    int column){
      return columnsUpdates.get(column);
    }
  }
;
  tUpdates.setFillsViewportHeight(true);
  tUpdates.setPreferredScrollableViewportSize(new Dimension(tUpdates.getPreferredSize().width,5 * tUpdates.getRowHeight()));
  updatesPanel.add(new JScrollPane(tUpdates));
  packagesPanel.add(installedPanel);
  packagesPanel.add(updatesPanel);
  JPanel controlPanel=new JPanel();
  GridBagLayout gridBagLayout=new GridBagLayout();
  controlPanel.setLayout(gridBagLayout);
  GridBagConstraints gbc=new GridBagConstraints();
  status=new JLabel();
  status.setText(""String_Node_Str"");
  gbc.gridx=0;
  gbc.gridy=0;
  controlPanel.add(status,gbc);
  progressBar=new JProgressBar();
  progressBar.setIndeterminate(true);
  gbc.gridx=0;
  gbc.gridy=1;
  gbc.weightx=1.0;
  gbc.fill=GridBagConstraints.HORIZONTAL;
  controlPanel.add(progressBar,gbc);
  actionButton=new JButton(""String_Node_Str"");
  actionButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      downloadTask=new DownloadTask();
      downloadTask.execute();
    }
  }
);
  actionButton.setVisible(false);
  gbc.gridx=1;
  gbc.gridy=0;
  gbc.weightx=0.0;
  gbc.fill=GridBagConstraints.HORIZONTAL;
  controlPanel.add(actionButton,gbc);
  ActionListener disposer=new ActionListener(){
    public void actionPerformed(    ActionEvent actionEvent){
      cancelTasks();
      setVisible(false);
    }
  }
;
  JButton closeButton=new JButton(""String_Node_Str"");
  closeButton.addActionListener(disposer);
  closeButton.setEnabled(true);
  gbc.gridx=1;
  gbc.gridy=1;
  gbc.weightx=0.0;
  gbc.fill=GridBagConstraints.HORIZONTAL;
  controlPanel.add(closeButton,gbc);
  verticalBox.add(packagesPanel);
  verticalBox.add(controlPanel);
  pack();
  JRootPane root=getRootPane();
  root.setDefaultButton(closeButton);
  processing.app.ui.Toolkit.registerWindowCloseKeys(root,disposer);
  processing.app.ui.Toolkit.setIcon(this);
  setLocationRelativeTo(null);
  setResizable(false);
  setVisible(true);
}","private void createLayout(){
  Container outer=getContentPane();
  outer.removeAll();
  Box verticalBox=Box.createVerticalBox();
  verticalBox.setBorder(new EmptyBorder(13,13,13,13));
  outer.add(verticalBox);
  JPanel packagesPanel=new JPanel();
  packagesPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(),""String_Node_Str""));
  BoxLayout boxLayout=new BoxLayout(packagesPanel,BoxLayout.Y_AXIS);
  packagesPanel.setLayout(boxLayout);
  JPanel installedPanel=new JPanel(new BorderLayout());
  installedPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(),""String_Node_Str""));
  modelInstalled=new DefaultTableModel(15,columnClassI.length){
    @Override public boolean isCellEditable(    int row,    int column){
      return false;
    }
    @Override public Class<?> getColumnClass(    int columnIndex){
      return columnClassI[columnIndex];
    }
  }
;
  JTable tInstalled=new JTable(modelInstalled){
    @Override public String getColumnName(    int column){
      return columnsInstalled.get(column);
    }
  }
;
  tInstalled.setFillsViewportHeight(true);
  tInstalled.setPreferredScrollableViewportSize(new Dimension(tInstalled.getPreferredSize().width,15 * tInstalled.getRowHeight()));
  installedPanel.add(new JScrollPane(tInstalled));
  JPanel updatesPanel=new JPanel(new BorderLayout());
  updatesPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(),""String_Node_Str""));
  modelUpdates=new DefaultTableModel(5,columnClassU.length){
    @Override public boolean isCellEditable(    int row,    int column){
      return false;
    }
    @Override public Class<?> getColumnClass(    int columnIndex){
      return columnClassU[columnIndex];
    }
  }
;
  JTable tUpdates=new JTable(modelUpdates){
    @Override public String getColumnName(    int column){
      return columnsUpdates.get(column);
    }
  }
;
  tUpdates.setFillsViewportHeight(true);
  tUpdates.setPreferredScrollableViewportSize(new Dimension(tUpdates.getPreferredSize().width,5 * tUpdates.getRowHeight()));
  updatesPanel.add(new JScrollPane(tUpdates),BorderLayout.CENTER);
  packagesPanel.add(installedPanel);
  packagesPanel.add(updatesPanel);
  JPanel controlPanel=new JPanel();
  GridBagLayout gridBagLayout=new GridBagLayout();
  controlPanel.setLayout(gridBagLayout);
  GridBagConstraints gbc=new GridBagConstraints();
  status=new JLabel();
  status.setText(""String_Node_Str"");
  gbc.gridx=0;
  gbc.gridy=0;
  controlPanel.add(status,gbc);
  progressBar=new JProgressBar();
  progressBar.setIndeterminate(true);
  gbc.gridx=0;
  gbc.gridy=1;
  gbc.weightx=1.0;
  gbc.fill=GridBagConstraints.HORIZONTAL;
  controlPanel.add(progressBar,gbc);
  actionButton=new JButton(""String_Node_Str"");
  actionButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (downloadTaskRunning) {
        downloadTask.cancel(true);
        status.setText(""String_Node_Str"");
        actionButton.setText(""String_Node_Str"");
      }
 else {
        downloadTask=new DownloadTask();
        progressBar.setIndeterminate(true);
        downloadTask.execute();
        status.setText(""String_Node_Str"");
        actionButton.setText(""String_Node_Str"");
      }
    }
  }
);
  actionButton.setVisible(false);
  gbc.gridx=1;
  gbc.gridy=0;
  gbc.weightx=0.0;
  gbc.fill=GridBagConstraints.HORIZONTAL;
  controlPanel.add(actionButton,gbc);
  ActionListener disposer=new ActionListener(){
    public void actionPerformed(    ActionEvent actionEvent){
      cancelTasks();
      dispose();
    }
  }
;
  JButton closeButton=new JButton(""String_Node_Str"");
  closeButton.addActionListener(disposer);
  closeButton.setEnabled(true);
  gbc.gridx=1;
  gbc.gridy=1;
  gbc.weightx=0.0;
  gbc.fill=GridBagConstraints.HORIZONTAL;
  controlPanel.add(closeButton,gbc);
  verticalBox.add(packagesPanel);
  verticalBox.add(controlPanel);
  pack();
  JRootPane root=getRootPane();
  root.setDefaultButton(closeButton);
  processing.app.ui.Toolkit.registerWindowCloseKeys(root,disposer);
  processing.app.ui.Toolkit.setIcon(this);
  addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      cancelTasks();
      super.windowClosing(e);
    }
  }
);
  setLocationRelativeTo(null);
  setResizable(true);
  setVisible(true);
}",0.9288334556126192
163594,"@Override public void propertyChange(PropertyChangeEvent evt){
switch (evt.getPropertyName()) {
case PROPERTY_CHANGE_QUERY:
    progressBar.setIndeterminate(false);
  if (requiredPackages.size() == 0) {
    if (updatesList.size() == 0) {
      status.setText(""String_Node_Str"");
      status.setForeground(Color.GREEN);
    }
 else {
      actionButton.setVisible(true);
      status.setText(""String_Node_Str"");
      status.setForeground(Color.BLUE);
    }
  }
 else {
    status.setText(""String_Node_Str"");
    status.setForeground(Color.RED);
    actionButton.setText(""String_Node_Str"");
    actionButton.setVisible(true);
    installFlag=true;
  }
break;
}
}","@Override public void propertyChange(PropertyChangeEvent evt){
switch (evt.getPropertyName()) {
case PROPERTY_CHANGE_QUERY:
    progressBar.setIndeterminate(false);
  if (updatesList.size() == 0) {
    status.setText(""String_Node_Str"");
    status.setForeground(Color.GREEN);
  }
 else {
    actionButton.setVisible(true);
    status.setText(""String_Node_Str"");
    status.setForeground(Color.BLUE);
  }
break;
}
}",0.7360594795539034
163595,"public SDKUpdater(){
  super(""String_Node_Str"");
  requiredPackages=new HashMap<>();
  requiredPackages.put(""String_Node_Str"",false);
  requiredPackages.put(""String_Node_Str"",false);
  requiredPackages.put(""String_Node_Str"",false);
  requiredPackages.put(""String_Node_Str"",false);
  requiredPackages.put(""String_Node_Str"",false);
  requiredPackages.put(""String_Node_Str"",false);
  try {
    sdk=AndroidSDK.load();
    toolsFolder=sdk.getToolsFolder();
    queryTask=new QueryTask();
    queryTask.addPropertyChangeListener(this);
    queryTask.execute();
    createLayout();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public SDKUpdater(Editor editor,AndroidMode androidMode){
  super(""String_Node_Str"");
  androidMode.checkSDK(editor);
  try {
    sdk=AndroidSDK.load();
    if (sdk == null) {
      sdk=AndroidSDK.locate(editor,androidMode);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  AndroidSDK.CancelException e) {
    e.printStackTrace();
  }
catch (  AndroidSDK.BadSDKException e) {
    e.printStackTrace();
  }
  if (sdk == null)   return;
  toolsFolder=sdk.getToolsFolder();
  queryTask=new QueryTask();
  queryTask.addPropertyChangeListener(this);
  queryTask.execute();
  createLayout();
}",0.1907051282051282
163596,"public void cancelTasks(){
  queryTask.cancel(true);
}","public void cancelTasks(){
  queryTask.cancel(true);
  if (downloadTaskRunning) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.WARNING_MESSAGE);
    downloadTask.cancel(true);
  }
}",0.3898916967509025
163597,"@Override protected void done(){
  super.done();
  if (updatesList != null && installedList != null) {
    modelInstalled.setDataVector(installedList,columnsInstalled);
    modelUpdates.setDataVector(updatesList,columnsUpdates);
    modelUpdates.fireTableDataChanged();
    modelInstalled.fireTableDataChanged();
  }
}","@Override protected void done(){
  super.done();
  try {
    get();
    actionButton.setVisible(false);
    status.setText(""String_Node_Str"");
    queryTask=new QueryTask();
    queryTask.addPropertyChangeListener(SDKUpdater.this);
    queryTask.execute();
  }
 catch (  InterruptedException|CancellationException e) {
    backgroundProcess.destroy();
  }
catch (  ExecutionException e) {
    JOptionPane.showMessageDialog(null,e.getCause().toString(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
 finally {
    downloadTaskRunning=false;
    progressBar.setIndeterminate(false);
  }
}",0.1563876651982378
163598,"private void createAppModule(File projectFolder,File exportFolder,String buildToolsVer) throws SketchException, IOException {
  File moduleFolder=mkdirs(exportFolder,""String_Node_Str"");
  String minSdk;
  String tmplFile;
  if (appComponent == VR) {
    minSdk=min_sdk_gvr;
    tmplFile=VR_GRADLE_BUILD_TEMPLATE;
  }
 else {
    minSdk=min_sdk_fragment;
    tmplFile=APP_GRADLE_BUILD_TEMPLATE;
  }
  File appBuildTemplate=mode.getContentFile(""String_Node_Str"" + tmplFile);
  File appBuildFile=new File(moduleFolder,""String_Node_Str"");
  HashMap<String,String> replaceMap=new HashMap<String,String>();
  replaceMap.put(""String_Node_Str"",Base.getToolsFolder().getPath());
  replaceMap.put(""String_Node_Str"",sdk.getTargetPlatform().getPath());
  replaceMap.put(""String_Node_Str"",buildToolsVer);
  replaceMap.put(""String_Node_Str"",getPackageName());
  replaceMap.put(""String_Node_Str"",minSdk);
  replaceMap.put(""String_Node_Str"",target_sdk);
  replaceMap.put(""String_Node_Str"",support_version);
  replaceMap.put(""String_Node_Str"",wear_version);
  replaceMap.put(""String_Node_Str"",gvr_sdk_version);
  replaceMap.put(""String_Node_Str"",manifest.getVersionCode());
  replaceMap.put(""String_Node_Str"",manifest.getVersionName());
  AndroidMode.createFileFromTemplate(appBuildTemplate,appBuildFile,replaceMap);
  writeFile(new File(moduleFolder,""String_Node_Str""),new String[]{""String_Node_Str""});
  File coreFile=new File(projectFolder,""String_Node_Str"");
  File libsFolder=mkdirs(moduleFolder,""String_Node_Str"");
  Util.copyFile(coreFile,new File(libsFolder,""String_Node_Str""));
  if (appComponent == VR) {
    File vrFile=new File(projectFolder,""String_Node_Str"");
    Util.copyFile(vrFile,new File(libsFolder,""String_Node_Str""));
  }
  File mainFolder=mkdirs(moduleFolder,""String_Node_Str"");
  File javaFolder=mkdirs(mainFolder,""String_Node_Str"");
  File resFolder=mkdirs(mainFolder,""String_Node_Str"");
  File assetsFolder=mkdirs(mainFolder,""String_Node_Str"");
  Util.copyFile(new File(projectFolder,""String_Node_Str""),new File(mainFolder,""String_Node_Str""));
  Util.copyDir(new File(projectFolder,""String_Node_Str""),resFolder);
  Util.copyDir(new File(projectFolder,""String_Node_Str""),javaFolder);
  Util.copyDir(new File(projectFolder,""String_Node_Str""),assetsFolder);
}","private void createAppModule(File projectFolder,File exportFolder,String buildToolsVer) throws SketchException, IOException {
  File moduleFolder=mkdirs(exportFolder,""String_Node_Str"");
  String minSdk;
  String tmplFile;
  if (appComponent == VR) {
    minSdk=min_sdk_gvr;
    tmplFile=VR_GRADLE_BUILD_TEMPLATE;
  }
 else {
    minSdk=min_sdk_fragment;
    tmplFile=APP_GRADLE_BUILD_TEMPLATE;
  }
  File appBuildTemplate=mode.getContentFile(""String_Node_Str"" + tmplFile);
  File appBuildFile=new File(moduleFolder,""String_Node_Str"");
  HashMap<String,String> replaceMap=new HashMap<String,String>();
  replaceMap.put(""String_Node_Str"",Base.getToolsFolder().getPath().replace('\\','/'));
  replaceMap.put(""String_Node_Str"",sdk.getTargetPlatform().getPath().replace('\\','/'));
  replaceMap.put(""String_Node_Str"",buildToolsVer);
  replaceMap.put(""String_Node_Str"",getPackageName());
  replaceMap.put(""String_Node_Str"",minSdk);
  replaceMap.put(""String_Node_Str"",target_sdk);
  replaceMap.put(""String_Node_Str"",support_version);
  replaceMap.put(""String_Node_Str"",wear_version);
  replaceMap.put(""String_Node_Str"",gvr_sdk_version);
  replaceMap.put(""String_Node_Str"",manifest.getVersionCode());
  replaceMap.put(""String_Node_Str"",manifest.getVersionName());
  AndroidMode.createFileFromTemplate(appBuildTemplate,appBuildFile,replaceMap);
  writeFile(new File(moduleFolder,""String_Node_Str""),new String[]{""String_Node_Str""});
  File coreFile=new File(projectFolder,""String_Node_Str"");
  File libsFolder=mkdirs(moduleFolder,""String_Node_Str"");
  Util.copyFile(coreFile,new File(libsFolder,""String_Node_Str""));
  if (appComponent == VR) {
    File vrFile=new File(projectFolder,""String_Node_Str"");
    Util.copyFile(vrFile,new File(libsFolder,""String_Node_Str""));
  }
  File mainFolder=mkdirs(moduleFolder,""String_Node_Str"");
  File javaFolder=mkdirs(mainFolder,""String_Node_Str"");
  File resFolder=mkdirs(mainFolder,""String_Node_Str"");
  File assetsFolder=mkdirs(mainFolder,""String_Node_Str"");
  Util.copyFile(new File(projectFolder,""String_Node_Str""),new File(mainFolder,""String_Node_Str""));
  Util.copyDir(new File(projectFolder,""String_Node_Str""),resFolder);
  Util.copyDir(new File(projectFolder,""String_Node_Str""),javaFolder);
  Util.copyDir(new File(projectFolder,""String_Node_Str""),assetsFolder);
}",0.9921156373193168
163599,"private void writeBuildXML(final File xmlFile,final String projectName){
  File xmlTemplate=mode.getContentFile(""String_Node_Str"" + ANT_BUILD_TEMPLATE);
  HashMap<String,String> replaceMap=new HashMap<String,String>();
  replaceMap.put(""String_Node_Str"",projectName);
  replaceMap.put(""String_Node_Str"",Base.getToolsFolder().getPath());
  AndroidMode.createFileFromTemplate(xmlTemplate,xmlFile,replaceMap);
}","private void writeBuildXML(final File xmlFile,final String projectName){
  File xmlTemplate=mode.getContentFile(""String_Node_Str"" + ANT_BUILD_TEMPLATE);
  HashMap<String,String> replaceMap=new HashMap<String,String>();
  replaceMap.put(""String_Node_Str"",projectName);
  replaceMap.put(""String_Node_Str"",Base.getToolsFolder().getPath().replace('\\','/'));
  AndroidMode.createFileFromTemplate(xmlTemplate,xmlFile,replaceMap);
}",0.9784172661870504
163600,"private void createAppModuleFolder(String buildToolsVer,String targetID) throws SketchException, IOException {
  File moduleFolder=new File(tmpFolder,""String_Node_Str"");
  String minSdk;
  String tmplFile;
  if (appComponent == VR) {
    minSdk=min_sdk_gvr;
    tmplFile=VR_GRADLE_BUILD_TEMPLATE;
  }
 else {
    minSdk=min_sdk_fragment;
    tmplFile=APP_GRADLE_BUILD_TEMPLATE;
  }
  File appBuildTemplate=mode.getContentFile(""String_Node_Str"" + tmplFile);
  File appBuildFile=new File(moduleFolder,""String_Node_Str"");
  HashMap<String,String> replaceMap=new HashMap<String,String>();
  replaceMap.put(""String_Node_Str"",Base.getToolsFolder().getPath());
  replaceMap.put(""String_Node_Str"",sdk.getTargetPlatform().getPath());
  replaceMap.put(""String_Node_Str"",buildToolsVer);
  replaceMap.put(""String_Node_Str"",getPackageName());
  replaceMap.put(""String_Node_Str"",minSdk);
  replaceMap.put(""String_Node_Str"",target_sdk);
  replaceMap.put(""String_Node_Str"",support_version);
  replaceMap.put(""String_Node_Str"",wear_version);
  replaceMap.put(""String_Node_Str"",gvr_sdk_version);
  replaceMap.put(""String_Node_Str"",manifest.getVersionCode());
  replaceMap.put(""String_Node_Str"",manifest.getVersionName());
  AndroidMode.createFileFromTemplate(appBuildTemplate,appBuildFile,replaceMap);
  writeFile(new File(moduleFolder,""String_Node_Str""),new String[]{""String_Node_Str""});
  File libsFolder=mkdirs(moduleFolder,""String_Node_Str"");
  File mainFolder=new File(moduleFolder,""String_Node_Str"");
  File resFolder=mkdirs(mainFolder,""String_Node_Str"");
  File assetsFolder=mkdirs(mainFolder,""String_Node_Str"");
  writeRes(resFolder);
  File tempManifest=new File(mainFolder,""String_Node_Str"");
  manifest.writeCopy(tempManifest,sketchClassName);
  Util.copyFile(coreZipFile,new File(libsFolder,""String_Node_Str""));
  copyImportedLibs(libsFolder,assetsFolder);
  copyCodeFolder(libsFolder);
  copyWearLib(tmpFolder,libsFolder);
  copySupportLibs(tmpFolder,libsFolder);
  if (getAppComponent() == FRAGMENT) {
    File aarFile=new File(sdk.getSupportLibrary(),""String_Node_Str"" + support_version + ""String_Node_Str""+ support_version+ ""String_Node_Str"");
    Util.copyFile(aarFile,new File(libsFolder,aarFile.getName()));
  }
  if (getAppComponent() == VR) {
    copyGVRLibs(targetID,libsFolder);
  }
  final File sketchDataFolder=sketch.getDataFolder();
  if (sketchDataFolder.exists()) {
    Util.copyDir(sketchDataFolder,assetsFolder);
  }
  final File sketchResFolder=new File(sketch.getFolder(),""String_Node_Str"");
  if (sketchResFolder.exists()) {
    Util.copyDir(sketchResFolder,resFolder);
  }
}","private void createAppModuleFolder(String buildToolsVer,String targetID) throws SketchException, IOException {
  File moduleFolder=new File(tmpFolder,""String_Node_Str"");
  String minSdk;
  String tmplFile;
  if (appComponent == VR) {
    minSdk=min_sdk_gvr;
    tmplFile=VR_GRADLE_BUILD_TEMPLATE;
  }
 else {
    minSdk=min_sdk_fragment;
    tmplFile=APP_GRADLE_BUILD_TEMPLATE;
  }
  File appBuildTemplate=mode.getContentFile(""String_Node_Str"" + tmplFile);
  File appBuildFile=new File(moduleFolder,""String_Node_Str"");
  HashMap<String,String> replaceMap=new HashMap<String,String>();
  replaceMap.put(""String_Node_Str"",Base.getToolsFolder().getPath().replace('\\','/'));
  replaceMap.put(""String_Node_Str"",sdk.getTargetPlatform().getPath().replace('\\','/'));
  replaceMap.put(""String_Node_Str"",buildToolsVer);
  replaceMap.put(""String_Node_Str"",getPackageName());
  replaceMap.put(""String_Node_Str"",minSdk);
  replaceMap.put(""String_Node_Str"",target_sdk);
  replaceMap.put(""String_Node_Str"",support_version);
  replaceMap.put(""String_Node_Str"",wear_version);
  replaceMap.put(""String_Node_Str"",gvr_sdk_version);
  replaceMap.put(""String_Node_Str"",manifest.getVersionCode());
  replaceMap.put(""String_Node_Str"",manifest.getVersionName());
  AndroidMode.createFileFromTemplate(appBuildTemplate,appBuildFile,replaceMap);
  writeFile(new File(moduleFolder,""String_Node_Str""),new String[]{""String_Node_Str""});
  File libsFolder=mkdirs(moduleFolder,""String_Node_Str"");
  File mainFolder=new File(moduleFolder,""String_Node_Str"");
  File resFolder=mkdirs(mainFolder,""String_Node_Str"");
  File assetsFolder=mkdirs(mainFolder,""String_Node_Str"");
  writeRes(resFolder);
  File tempManifest=new File(mainFolder,""String_Node_Str"");
  manifest.writeCopy(tempManifest,sketchClassName);
  Util.copyFile(coreZipFile,new File(libsFolder,""String_Node_Str""));
  copyImportedLibs(libsFolder,assetsFolder);
  copyCodeFolder(libsFolder);
  copyWearLib(tmpFolder,libsFolder);
  copySupportLibs(tmpFolder,libsFolder);
  if (getAppComponent() == FRAGMENT) {
    File aarFile=new File(sdk.getSupportLibrary(),""String_Node_Str"" + support_version + ""String_Node_Str""+ support_version+ ""String_Node_Str"");
    Util.copyFile(aarFile,new File(libsFolder,aarFile.getName()));
  }
  if (getAppComponent() == VR) {
    copyGVRLibs(targetID,libsFolder);
  }
  final File sketchDataFolder=sketch.getDataFolder();
  if (sketchDataFolder.exists()) {
    Util.copyDir(sketchDataFolder,assetsFolder);
  }
  final File sketchResFolder=new File(sketch.getFolder(),""String_Node_Str"");
  if (sketchResFolder.exists()) {
    Util.copyDir(sketchResFolder,resFolder);
  }
}",0.9931008049060944
163601,"private void initVR(){
  if (!initialized) {
    headRotation=new float[4];
    headView=new float[16];
    perspectiveMatrix=new PMatrix3D();
    viewMatrix=new PMatrix3D();
    initialized=true;
  }
}","private void initVR(){
  if (!initialized) {
    headRotation=new float[4];
    headView=new float[16];
    translationVector=new float[3];
    forwardVector=new float[3];
    rightVector=new float[3];
    upVector=new float[3];
    perspectiveMatrix=new PMatrix3D();
    viewMatrix=new PMatrix3D();
    initialized=true;
  }
}",0.7637051039697542
163602,"protected void eyeTransform(Eye eye){
  eyeType=eye.getType();
  viewPort=eye.getViewport();
  float[] p=eye.getPerspective(cameraNear,cameraFar);
  perspectiveMatrix.set(p[0],p[4],p[8],p[12],p[1],-p[5],p[9],p[13],p[2],p[6],p[10],p[14],p[3],p[7],p[11],p[15]);
  float[] v=eye.getEyeView();
  viewMatrix.set(v[0],v[4],v[8],v[12],v[1],v[5],v[9],v[13],v[2],v[6],v[10],v[14],v[3],v[7],v[11],v[15]);
}","protected void eyeTransform(Eye eye){
  eyeType=eye.getType();
  eyeViewPort=eye.getViewport();
  eyeFov=eye.getFov();
  eyePerspective=eye.getPerspective(cameraNear,cameraFar);
  perspectiveMatrix.set(eyePerspective[0],eyePerspective[4],eyePerspective[8],eyePerspective[12],eyePerspective[1],eyePerspective[5],eyePerspective[9],eyePerspective[13],eyePerspective[2],eyePerspective[6],eyePerspective[10],eyePerspective[14],eyePerspective[3],eyePerspective[7],eyePerspective[11],eyePerspective[15]);
  eyeView=eye.getEyeView();
  viewMatrix.set(eyeView[0],eyeView[4],eyeView[8],eyeView[12],eyeView[1],eyeView[5],eyeView[9],eyeView[13],eyeView[2],eyeView[6],eyeView[10],eyeView[14],eyeView[3],eyeView[7],eyeView[11],eyeView[15]);
}",0.3309608540925267
163603,"protected void headTransform(HeadTransform headTransform){
  initVR();
  headTransform.getHeadView(headView,0);
  headTransform.getQuaternion(headRotation,0);
}","protected void headTransform(HeadTransform headTransform){
  initVR();
  headTransform.getHeadView(headView,0);
  headTransform.getQuaternion(headRotation,0);
  headTransform.getTranslation(translationVector,0);
  headTransform.getForwardVector(forwardVector,0);
  headTransform.getRightVector(rightVector,0);
  headTransform.getUpVector(upVector,0);
}",0.625
163604,"@Override public void beginDraw(){
  super.beginDraw();
  pgl.viewport(viewPort.x,viewPort.y,viewPort.width,viewPort.height);
  camera(0.0f,0.0f,defCameraZ,0.0f,0.0f,0.0f,0.0f,-1.0f,0.0f);
  setProjection(perspectiveMatrix);
  preApplyMatrix(viewMatrix);
}","@Override public void beginDraw(){
  super.beginDraw();
  pgl.viewport(eyeViewPort.x,eyeViewPort.y,eyeViewPort.width,eyeViewPort.height);
  camera(0.0f,0.0f,defCameraZ,0.0f,0.0f,0.0f,0.0f,1.0f,0.0f);
  setProjection(perspectiveMatrix);
  preApplyMatrix(viewMatrix);
}",0.8833652007648184
163605,"@Override public void endDraw(){
  if (bitmap == null)   return;
  if (primaryGraphics) {
    SurfaceHolder holder=parent.getSurfaceHolder();
    if (holder != null) {
      Canvas screen=null;
      try {
        screen=holder.lockCanvas(null);
        if (screen != null) {
          screen.drawBitmap(bitmap,new Matrix(),null);
        }
      }
  finally {
        if (screen != null) {
          parent.getSurfaceHolder().unlockCanvasAndPost(screen);
        }
      }
    }
  }
 else {
    loadPixels();
  }
  setModified();
  super.updatePixels();
}","@Override public void endDraw(){
  if (bitmap == null)   return;
  if (primaryGraphics) {
    SurfaceHolder holder=parent.getSurfaceHolder();
    if (holder != null) {
      Canvas screen=null;
      try {
        screen=holder.lockCanvas(null);
        if (screen != null) {
          screen.drawBitmap(bitmap,new Matrix(),null);
        }
      }
  finally {
        if (screen != null) {
          try {
            parent.getSurfaceHolder().unlockCanvasAndPost(screen);
          }
 catch (          IllegalStateException ex) {
          }
        }
      }
    }
  }
 else {
    loadPixels();
  }
  setModified();
  super.updatePixels();
}",0.9266666666666666
163606,"@Override public void onCreate(SurfaceHolder surfaceHolder){
  super.onCreate(surfaceHolder);
  if (sketch == null || isPreview()) {
    sketch=createSketch();
    sketch.initSurface(PWallpaper.this,getSurfaceHolder());
    sketch.startSurface();
    setTouchEventsEnabled(true);
  }
 else {
    sketch.resetSurface(PWallpaper.this,getSurfaceHolder());
    sketch.startSurface();
  }
  if (sketch != null) {
    sketch.preview=isPreview();
    if (!sketch.preview)     requestPermissions();
  }
}","@Override public void onCreate(SurfaceHolder surfaceHolder){
  super.onCreate(surfaceHolder);
  sketch=createSketch();
  sketch.initSurface(PWallpaper.this,getSurfaceHolder());
  sketch.startSurface();
  sketch.preview=isPreview();
  if (isPreview())   requestPermissions();
  setTouchEventsEnabled(true);
}",0.5554171855541719
163607,"@Override public void onDestroy(){
  super.onDestroy();
  if (!isPreview() && sketch != null) {
    sketch.onDestroy();
  }
}","@Override public void onDestroy(){
  super.onDestroy();
  if (sketch != null) {
    sketch.onDestroy();
  }
}",0.9316239316239316
163608,"@Override public void onTouchEvent(MotionEvent event){
  super.onTouchEvent(event);
  if (sketch != null)   sketch.surfaceTouchEvent(event);
}","@Override public void onTouchEvent(MotionEvent event){
  super.onTouchEvent(event);
  if (sketch != null) {
    sketch.surfaceTouchEvent(event);
  }
}",0.9726027397260274
163609,"public PApplet getSketch(){
  return sketch;
}","public PApplet getSketch(){
  return engine.sketch;
}",0.9292929292929292
163610,"@Override public void onVisibilityChanged(boolean visible){
  if (!isPreview() && sketch != null) {
    if (visible) {
      sketch.onResume();
    }
 else {
      sketch.onPause();
    }
  }
  super.onVisibilityChanged(visible);
}","@Override public void onVisibilityChanged(boolean visible){
  if (sketch != null) {
    if (visible) {
      sketch.onResume();
    }
 else {
      sketch.onPause();
    }
  }
  super.onVisibilityChanged(visible);
}",0.9641255605381166
163611,"public void setSketch(PApplet sketch){
}","public void setSketch(PApplet sketch){
  engine.sketch=sketch;
}",0.7692307692307693
163612,"public void onPermissionsGranted(){
  if (sketch != null)   sketch.onPermissionsGranted();
}","public void onPermissionsGranted(){
  if (sketch != null) {
    sketch.onPermissionsGranted();
  }
}",0.9583333333333334
163613,"public void onPause(){
  if (g != null) {
    savedStyle=new PStyle();
    g.getStyle(savedStyle);
  }
  handleMethods(""String_Node_Str"");
  surface.pauseThread();
  pause();
}","public void onPause(){
  if (g != null && 0 < frameCount) {
    savedStyle=new PStyle();
    g.getStyle(savedStyle);
  }
  handleMethods(""String_Node_Str"");
  surface.pauseThread();
  pause();
}",0.9513513513513514
163614,"/** 
 * Called to dispose of resources and shut down the sketch. Destroys the thread, dispose the renderer, and notify listeners. <p> Not to be called or overriden by users. If called multiple times, will only notify listeners once. Register a dispose listener instead.
 */
final public void dispose(){
  finished=true;
  if (surface != null && surface.stopThread()) {
    if (g != null) {
      g.dispose();
      surface.dispose();
    }
  }
  handleMethods(""String_Node_Str"");
}","/** 
 * Called to dispose of resources and shut down the sketch. Destroys the thread, dispose the renderer, and notify listeners. <p> Not to be called or overriden by users. If called multiple times, will only notify listeners once. Register a dispose listener instead.
 */
final public void dispose(){
  finished=true;
  if (surface != null) {
    surface.stopThread();
    surface.dispose();
  }
  if (g != null) {
    g.dispose();
  }
  handleMethods(""String_Node_Str"");
}",0.9184100418410042
163615,public boolean stopThread(boolean killProc);,public boolean stopThread();,0.7777777777777778
163616,"/** 
 * Main method for the primary animation thread. <A HREF=""http://java.sun.com/products/jfc/tsc/articles/painting/"">Painting in AWT and Swing</A>
 */
@Override public void run(){
  long beforeTime=System.nanoTime();
  long overSleepTime=0L;
  int noDelays=0;
  final int NO_DELAYS_PER_YIELD=15;
  if (sketch == null)   return;
  sketch.start();
  while ((Thread.currentThread() == thread) && (sketch != null && !sketch.finished)) {
    checkPause();
    callDraw();
    long afterTime=System.nanoTime();
    long timeDiff=afterTime - beforeTime;
    long sleepTime=(frameRatePeriod - timeDiff) - overSleepTime;
    if (sleepTime > 0) {
      try {
        Thread.sleep(sleepTime / 1000000L,(int)(sleepTime % 1000000L));
        noDelays=0;
      }
 catch (      InterruptedException ex) {
      }
      overSleepTime=(System.nanoTime() - afterTime) - sleepTime;
    }
 else {
      overSleepTime=0L;
      noDelays++;
      if (noDelays > NO_DELAYS_PER_YIELD) {
        Thread.yield();
        noDelays=0;
      }
    }
    beforeTime=System.nanoTime();
  }
  if (killProcAfterStop)   finish();
}","/** 
 * Main method for the primary animation thread. <A HREF=""http://java.sun.com/products/jfc/tsc/articles/painting/"">Painting in AWT and Swing</A>
 */
@Override public void run(){
  long beforeTime=System.nanoTime();
  long overSleepTime=0L;
  int noDelays=0;
  final int NO_DELAYS_PER_YIELD=15;
  if (sketch == null)   return;
  sketch.start();
  while ((Thread.currentThread() == thread) && (sketch != null && !sketch.finished)) {
    checkPause();
    callDraw();
    long afterTime=System.nanoTime();
    long timeDiff=afterTime - beforeTime;
    long sleepTime=(frameRatePeriod - timeDiff) - overSleepTime;
    if (sleepTime > 0) {
      try {
        Thread.sleep(sleepTime / 1000000L,(int)(sleepTime % 1000000L));
        noDelays=0;
      }
 catch (      InterruptedException ex) {
      }
      overSleepTime=(System.nanoTime() - afterTime) - sleepTime;
    }
 else {
      overSleepTime=0L;
      noDelays++;
      if (noDelays > NO_DELAYS_PER_YIELD) {
        Thread.yield();
        noDelays=0;
      }
    }
    beforeTime=System.nanoTime();
  }
  finish();
}",0.9885057471264368
163617,"@Override public boolean stopThread(boolean killProc){
  killProcAfterStop=killProc;
  if (thread == null) {
    return false;
  }
  thread=null;
  return true;
}","@Override public boolean stopThread(){
  if (thread == null) {
    return false;
  }
  thread=null;
  return true;
}",0.8345323741007195
163618,"public AndroidRenderer getRenderer(){
  renderer=new AndroidRenderer();
  return renderer;
}","public AndroidRenderer getRenderer(){
  return new AndroidRenderer();
}",0.8220858895705522
163619,"public AndroidConfigChooser getConfigChooser(int r,int g,int b,int a,int d,int s,int samples){
  configChooser=new AndroidConfigChooser(r,g,b,a,d,s,samples);
  return configChooser;
}","public AndroidConfigChooser getConfigChooser(int r,int g,int b,int a,int d,int s,int samples){
  return new AndroidConfigChooser(r,g,b,a,d,s,samples);
}",0.8716417910447761
163620,"public boolean addTexture(PGraphicsOpenGL pg){
  int w, h;
  boolean resize;
  w=maxSize;
  if (-1 < lastTex && textures[lastTex].glHeight < maxSize) {
    h=PApplet.min(2 * textures[lastTex].glHeight,maxSize);
    resize=true;
  }
 else {
    h=minSize;
    resize=false;
  }
  Texture tex;
  if (is3D) {
    tex=new Texture(pg,w,h,new Texture.Parameters(ARGB,Texture.BILINEAR,false));
  }
 else {
    tex=new Texture(pg,w,h,new Texture.Parameters(ARGB,Texture.LINEAR,false));
  }
  if (textures == null) {
    textures=new Texture[1];
    textures[0]=tex;
    images=new PImage[1];
    images[0]=pg.wrapTexture(tex);
    lastTex=0;
  }
 else   if (resize) {
    Texture tex0=textures[lastTex];
    tex.pg.pushStyle();
    tex.pg.blendMode(REPLACE);
    tex.put(tex0);
    tex.pg.popStyle();
    textures[lastTex]=tex;
    pg.setCache(images[lastTex],tex);
    images[lastTex].width=tex.width;
    images[lastTex].height=tex.height;
  }
 else {
    lastTex=textures.length;
    Texture[] tempTex=new Texture[lastTex + 1];
    PApplet.arrayCopy(textures,tempTex,textures.length);
    tempTex[lastTex]=tex;
    textures=tempTex;
    PImage[] tempImg=new PImage[textures.length];
    PApplet.arrayCopy(images,tempImg,images.length);
    tempImg[lastTex]=pg.wrapTexture(tex);
    images=tempImg;
  }
  tex.bind();
  return resize;
}","public boolean addTexture(PGraphicsOpenGL pg){
  int w, h;
  boolean resize;
  w=maxSize;
  if (-1 < lastTex && textures[lastTex].glHeight < maxSize) {
    h=PApplet.min(2 * textures[lastTex].glHeight,maxSize);
    resize=true;
  }
 else {
    h=minSize;
    resize=false;
  }
  Texture tex;
  if (is3D) {
    tex=new Texture(pg,w,h,new Texture.Parameters(ARGB,Texture.BILINEAR,false));
  }
 else {
    tex=new Texture(pg,w,h,new Texture.Parameters(ARGB,Texture.LINEAR,false));
  }
  if (textures == null) {
    textures=new Texture[1];
    textures[0]=tex;
    images=new PImage[1];
    images[0]=pg.wrapTexture(tex);
    lastTex=0;
  }
 else   if (resize) {
    Texture tex0=textures[lastTex];
    tex.put(tex0);
    textures[lastTex]=tex;
    pg.setCache(images[lastTex],tex);
    images[lastTex].width=tex.width;
    images[lastTex].height=tex.height;
  }
 else {
    lastTex=textures.length;
    Texture[] tempTex=new Texture[lastTex + 1];
    PApplet.arrayCopy(textures,tempTex,textures.length);
    tempTex[lastTex]=tex;
    textures=tempTex;
    PImage[] tempImg=new PImage[textures.length];
    PApplet.arrayCopy(images,tempImg,images.length);
    tempImg[lastTex]=pg.wrapTexture(tex);
    images=tempImg;
  }
  tex.bind();
  return resize;
}",0.9697674418604652
163621,"protected void copyTexture(int texTarget,int texName,int texWidth,int texHeight,int x,int y,int w,int h,boolean scale){
  if (tempFbo == null) {
    tempFbo=new FrameBuffer(pg,glWidth,glHeight);
  }
  tempFbo.setColorBuffer(this);
  tempFbo.disableDepthTest();
  pg.pushFramebuffer();
  pg.setFramebuffer(tempFbo);
  if (scale) {
    pgl.drawTexture(texTarget,texName,texWidth,texHeight,0,0,tempFbo.width,tempFbo.height,x,y,w,h,0,0,width,height);
  }
 else {
    pgl.drawTexture(texTarget,texName,texWidth,texHeight,0,0,tempFbo.width,tempFbo.height,x,y,w,h,x,y,w,h);
  }
  pg.popFramebuffer();
  updateTexels(x,y,w,h);
}","protected void copyTexture(int texTarget,int texName,int texWidth,int texHeight,int x,int y,int w,int h,boolean scale){
  if (tempFbo == null) {
    tempFbo=new FrameBuffer(pg,glWidth,glHeight);
  }
  tempFbo.setColorBuffer(this);
  tempFbo.disableDepthTest();
  pg.pushFramebuffer();
  pg.setFramebuffer(tempFbo);
  pg.pushStyle();
  pg.blendMode(REPLACE);
  if (scale) {
    pgl.drawTexture(texTarget,texName,texWidth,texHeight,0,0,tempFbo.width,tempFbo.height,x,y,w,h,0,0,width,height);
  }
 else {
    pgl.drawTexture(texTarget,texName,texWidth,texHeight,0,0,tempFbo.width,tempFbo.height,x,y,w,h,x,y,w,h);
  }
  pgl.flush();
  pg.popStyle();
  pg.popFramebuffer();
  updateTexels(x,y,w,h);
}",0.9429657794676806
163622,"private void updateSdkMenu(final JMenu sdkMenu){
  try {
    ArrayList<AndroidSDK.SDKTarget> targets=androidMode.getSDK().getAvailableSdkTargets();
    if (targets.size() != 0)     sdkMenu.removeAll();
    AndroidSDK.SDKTarget lowestTargetAvailable=null;
    JCheckBoxMenuItem lowestTargetMenuItem=null;
    String savedSdkName=Preferences.get(""String_Node_Str"");
    boolean savedTargetSet=false;
    for (    final AndroidSDK.SDKTarget target : targets) {
      if (target.version < 11) {
        continue;
      }
      final JCheckBoxMenuItem item=new JCheckBoxMenuItem(""String_Node_Str"" + target.name + ""String_Node_Str""+ target.version+ ""String_Node_Str"");
      if (savedTargetSet == false && (lowestTargetAvailable == null || lowestTargetAvailable.version > target.version)) {
        lowestTargetAvailable=target;
        lowestTargetMenuItem=item;
      }
      if (target.name.equals(savedSdkName)) {
        AndroidBuild.setSdkTarget(target,sketch);
        item.setState(true);
        savedTargetSet=true;
      }
      item.addChangeListener(new ChangeListener(){
        @Override public void stateChanged(        ChangeEvent e){
          if (target.name.equals(AndroidBuild.sdkName))           item.setState(true);
 else           item.setState(false);
        }
      }
);
      item.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          AndroidBuild.setSdkTarget(target,sketch);
          for (int i=0; i < sdkMenu.getItemCount(); i++) {
            ((JCheckBoxMenuItem)sdkMenu.getItem(i)).setState(false);
          }
          item.setState(true);
        }
      }
);
      sdkMenu.add(item);
    }
    if (!savedTargetSet) {
      AndroidBuild.setSdkTarget(lowestTargetAvailable,sketch);
      lowestTargetMenuItem.setState(true);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","private void updateSdkMenu(final JMenu sdkMenu){
  try {
    ArrayList<AndroidSDK.SDKTarget> targets=androidMode.getSDK().getAvailableSdkTargets();
    if (targets.size() != 0)     sdkMenu.removeAll();
    AndroidSDK.SDKTarget lowestTargetAvailable=null;
    JCheckBoxMenuItem lowestTargetMenuItem=null;
    String savedSdkName=Preferences.get(""String_Node_Str"");
    boolean savedTargetSet=false;
    for (    final AndroidSDK.SDKTarget target : targets) {
      if (target.version < 11) {
        continue;
      }
      final JCheckBoxMenuItem item=new JCheckBoxMenuItem(""String_Node_Str"" + target.name + ""String_Node_Str""+ target.version+ ""String_Node_Str"");
      if (savedTargetSet == false && (lowestTargetAvailable == null || lowestTargetAvailable.version > target.version)) {
        lowestTargetAvailable=target;
        lowestTargetMenuItem=item;
      }
      if (target.name.equals(savedSdkName)) {
        AndroidBuild.setSdkTarget(target,sketch);
        item.setState(true);
        savedTargetSet=true;
      }
      item.addChangeListener(new ChangeListener(){
        @Override public void stateChanged(        ChangeEvent e){
          if (target.name.equals(AndroidBuild.sdkName))           item.setState(true);
 else           item.setState(false);
        }
      }
);
      item.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          AndroidBuild.setSdkTarget(target,sketch);
          for (int i=0; i < sdkMenu.getItemCount(); i++) {
            ((JCheckBoxMenuItem)sdkMenu.getItem(i)).setState(false);
          }
          item.setState(true);
        }
      }
);
      sdkMenu.add(item);
    }
    if (!savedTargetSet && lowestTargetAvailable != null) {
      AndroidBuild.setSdkTarget(lowestTargetAvailable,sketch);
      lowestTargetMenuItem.setState(true);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.991336308742452
163623,"private void downloadAndUnpack(String urlString,File saveTo,File unpackTo) throws IOException {
  URL url=new URL(urlString);
  URLConnection conn=url.openConnection();
  InputStream inputStream=conn.getInputStream();
  FileOutputStream outputStream=new FileOutputStream(saveTo);
  byte[] b=new byte[BUFFER_SIZE];
  int count;
  while ((count=inputStream.read(b)) >= 0) {
    outputStream.write(b,0,count);
    downloadedSize+=count;
    firePropertyChange(PROPERTY_CHANGE_EVENT_DOWNLOADED,0,downloadedSize);
  }
  outputStream.flush();
  outputStream.close();
  inputStream.close();
  inputStream.close();
  outputStream.close();
  extractFolder(saveTo,unpackTo);
}","private void downloadAndUnpack(String urlString,File saveTo,File unpackTo) throws IOException {
  URL url=null;
  try {
    url=new URL(urlString);
  }
 catch (  MalformedURLException e) {
    try {
      url=new URL(URL_REPOSITORY_FOLDER + urlString);
    }
 catch (    MalformedURLException e1) {
      e1.printStackTrace();
      return;
    }
  }
  URLConnection conn=url.openConnection();
  InputStream inputStream=conn.getInputStream();
  FileOutputStream outputStream=new FileOutputStream(saveTo);
  byte[] b=new byte[BUFFER_SIZE];
  int count;
  while ((count=inputStream.read(b)) >= 0) {
    outputStream.write(b,0,count);
    downloadedSize+=count;
    firePropertyChange(PROPERTY_CHANGE_EVENT_DOWNLOADED,0,downloadedSize);
  }
  outputStream.flush();
  outputStream.close();
  inputStream.close();
  inputStream.close();
  outputStream.close();
  extractFolder(saveTo,unpackTo);
}",0.8554913294797688
163624,"public void checkSDK(Editor parent){
  if (sdk == null) {
    try {
      sdk=AndroidSDK.load();
      if (sdk == null && parent != null) {
        sdk=AndroidSDK.locate(parent,this);
      }
    }
 catch (    BadSDKException e) {
      e.printStackTrace();
    }
catch (    IOException e) {
      e.printStackTrace();
    }
  }
  if (sdk == null) {
    if (!AndroidSDK.isDownloading()) {
      Messages.showWarning(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    }
  }
}","public void checkSDK(Editor editor){
  if (sdk == null) {
    try {
      sdk=AndroidSDK.load();
      if (sdk == null && editor != null) {
        sdk=AndroidSDK.locate(editor,this);
      }
    }
 catch (    BadSDKException e) {
      e.printStackTrace();
    }
catch (    IOException e) {
      e.printStackTrace();
    }
  }
  if (sdk == null) {
    if (!AndroidSDK.isDownloading()) {
      Messages.showWarning(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    }
  }
}",0.9628865979381444
163625,"public AndroidMode(Base base,File folder){
  super(base,folder);
  checkSDK(null);
}","public AndroidMode(Base base,File folder){
  super(base,folder);
}",0.88
163626,"@Override protected void arcImpl(float x,float y,float w,float h,float start,float stop,int mode){
  if (stop - start >= TWO_PI) {
    ellipseImpl(x,y,w,h);
  }
 else {
    start=start * RAD_TO_DEG;
    stop=stop * RAD_TO_DEG;
    while (start < 0) {
      start+=360;
      stop+=360;
    }
    if (start > stop) {
      float temp=start;
      start=stop;
      stop=temp;
    }
    float sweep=stop - start;
    rect.set(x,y,x + w,y + h);
    if (mode == 0) {
      if (fill) {
        canvas.drawArc(rect,start,sweep,true,fillPaint);
      }
      if (stroke) {
        canvas.drawArc(rect,start,sweep,false,strokePaint);
      }
    }
 else     if (mode == OPEN) {
      if (fill) {
        showMissingWarning(""String_Node_Str"");
      }
      if (stroke) {
        canvas.drawArc(rect,start,sweep,false,strokePaint);
      }
    }
 else     if (mode == CHORD) {
      showMissingWarning(""String_Node_Str"");
    }
 else     if (mode == PIE) {
      if (fill) {
        canvas.drawArc(rect,start,sweep,true,fillPaint);
      }
      if (stroke) {
        canvas.drawArc(rect,start,sweep,true,strokePaint);
      }
    }
  }
}","@Override protected void arcImpl(float x,float y,float w,float h,float start,float stop,int mode){
  if (stop - start >= TWO_PI) {
    ellipseImpl(x,y,w,h);
  }
 else {
    start=start * RAD_TO_DEG;
    stop=stop * RAD_TO_DEG;
    while (start < 0) {
      start+=360;
      stop+=360;
    }
    if (start > stop) {
      float temp=start;
      start=stop;
      stop=temp;
    }
    float sweep=stop - start;
    rect.set(x,y,x + w,y + h);
    if (mode == 0) {
      if (fill) {
        canvas.drawArc(rect,start,sweep,true,fillPaint);
      }
      if (stroke) {
        canvas.drawArc(rect,start,sweep,false,strokePaint);
      }
    }
 else     if (mode == OPEN) {
      if (fill) {
        canvas.drawArc(rect,start,sweep,false,fillPaint);
        canvas.drawArc(rect,start,sweep,false,strokePaint);
      }
      if (stroke) {
        canvas.drawArc(rect,start,sweep,false,strokePaint);
      }
    }
 else     if (mode == CHORD) {
      float endAngle=start + sweep;
      float halfRectWidth=rect.width() / 2;
      float halfRectHeight=rect.height() / 2;
      float centerX=rect.centerX();
      float centerY=rect.cenerY();
      float startX=(float)(halfRectWidth * Math.cos(Math.toRadians(start))) + centerX;
      float startY=(float)(halfRectHeight * Math.sin(Math.toRadians(start))) + centerY;
      float endX=(float)(halfRectWidth * Math.cos(Math.toRadians(endAngle))) + centerX;
      float endY=(float)(halfRectHeight * Math.sin(Math.toRadians(endAngle))) + centerY;
      if (fill) {
        canvas.drawArc(rect,start,sweep,false,fillPaint);
        canvas.drawArc(rect,start,sweep,false,strokePaint);
        canvas.drawLine(startX,startY,endX,endY,strokePaint);
      }
      if (stroke) {
        canvas.drawArc(rect,start,sweep,false,strokePaint);
        canvas.drawLine(startX,startY,endX,endY,strokePaint);
      }
    }
 else     if (mode == PIE) {
      if (fill) {
        canvas.drawArc(rect,start,sweep,true,fillPaint);
      }
      if (stroke) {
        canvas.drawArc(rect,start,sweep,true,strokePaint);
      }
    }
  }
}",0.6654123549702101
163627,"/** 
 * Call createInput() without automatic gzip decompression.
 */
public InputStream createInputRaw(String filename){
  InputStream stream=null;
  if (filename == null)   return null;
  if (filename.length() == 0) {
    return null;
  }
  if (filename.indexOf(""String_Node_Str"") != -1) {
    try {
      HttpGet httpRequest=null;
      httpRequest=new HttpGet(URI.create(filename));
      HttpClient httpclient=new DefaultHttpClient();
      HttpResponse response=(HttpResponse)httpclient.execute(httpRequest);
      HttpEntity entity=response.getEntity();
      return entity.getContent();
    }
 catch (    MalformedURLException mfue) {
    }
catch (    FileNotFoundException fnfe) {
    }
catch (    IOException e) {
      e.printStackTrace();
      return null;
    }
  }
  AssetManager assets=getAssets();
  try {
    stream=assets.open(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  IOException e) {
  }
  File absFile=new File(filename);
  if (absFile.exists()) {
    try {
      stream=new FileInputStream(absFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  File sketchFile=new File(sketchPath(filename));
  if (sketchFile.exists()) {
    try {
      stream=new FileInputStream(sketchFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  Context context=getApplicationContext();
  try {
    stream=context.openFileInput(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  FileNotFoundException e) {
  }
  return null;
}","/** 
 * Call createInput() without automatic gzip decompression.
 */
public InputStream createInputRaw(String filename){
  InputStream stream=null;
  if (filename == null)   return null;
  if (filename.length() == 0) {
    return null;
  }
  if (filename.indexOf(""String_Node_Str"") != -1) {
    try {
      HttpGet httpRequest=null;
      httpRequest=new HttpGet(URI.create(filename));
      HttpClient httpclient=new DefaultHttpClient();
      HttpResponse response=(HttpResponse)httpclient.execute(httpRequest);
      HttpEntity entity=response.getEntity();
      return entity.getContent();
    }
 catch (    MalformedURLException mfue) {
    }
catch (    FileNotFoundException fnfe) {
    }
catch (    IOException e) {
      e.printStackTrace();
      return null;
    }
  }
  AssetManager assets=activity.getAssets();
  try {
    stream=assets.open(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  IOException e) {
  }
  File absFile=new File(filename);
  if (absFile.exists()) {
    try {
      stream=new FileInputStream(absFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  File sketchFile=new File(sketchPath(filename));
  if (sketchFile.exists()) {
    try {
      stream=new FileInputStream(sketchFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  try {
    stream=activity.openFileInput(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  FileNotFoundException e) {
  }
  return null;
}",0.979314603272615
163628,"/** 
 * Create a bitmap font on the fly from either a font name that's installed on the system, or from a .ttf or .otf that's inside the data folder of this sketch. <P/> Use 'null' for the charset if you want to dynamically create character bitmaps only as they're needed.
 */
public PFont createFont(String name,float size,boolean smooth,char[] charset){
  String lowerName=name.toLowerCase();
  Typeface baseFont=null;
  if (lowerName.endsWith(""String_Node_Str"") || lowerName.endsWith(""String_Node_Str"")) {
    AssetManager assets=getBaseContext().getAssets();
    baseFont=Typeface.createFromAsset(assets,name);
  }
 else {
    baseFont=(Typeface)PFont.findNative(name);
  }
  return new PFont(baseFont,round(size),smooth,charset);
}","/** 
 * Create a bitmap font on the fly from either a font name that's installed on the system, or from a .ttf or .otf that's inside the data folder of this sketch. <P/> Use 'null' for the charset if you want to dynamically create character bitmaps only as they're needed.
 */
public PFont createFont(String name,float size,boolean smooth,char[] charset){
  String lowerName=name.toLowerCase();
  Typeface baseFont=null;
  if (lowerName.endsWith(""String_Node_Str"") || lowerName.endsWith(""String_Node_Str"")) {
    AssetManager assets=activity.getAssets();
    baseFont=Typeface.createFromAsset(assets,name);
  }
 else {
    baseFont=(Typeface)PFont.findNative(name);
  }
  return new PFont(baseFont,round(size),smooth,charset);
}",0.9836065573770492
163629,"@Override protected void onStop(){
  tellPDE(""String_Node_Str"");
  super.onStop();
}","@Override public void onStop(){
  tellPDE(""String_Node_Str"");
  super.onStop();
}",0.9333333333333332
163630,"@Override protected void onPause(){
  super.onPause();
  paused=true;
  handleMethods(""String_Node_Str"");
  pause();
}","@Override public void onPause(){
  super.onPause();
  paused=true;
  handleMethods(""String_Node_Str"");
  pause();
}",0.9527896995708156
163631,"private void tellPDE(final String message){
  Log.i(getComponentName().getPackageName(),""String_Node_Str"" + message);
}","private void tellPDE(final String message){
  Log.i(activity.getComponentName().getPackageName(),""String_Node_Str"" + message);
}",0.9635627530364372
163632,"/** 
 * Create an offscreen PGraphics object for drawing. This can be used for bitmap or vector images drawing or rendering. <UL> <LI>Do not use ""new PGraphicsXxxx()"", use this method. This method ensures that internal variables are set up properly that tie the new graphics context back to its parent PApplet. <LI>The basic way to create bitmap images is to use the <A HREF=""http://processing.org/reference/saveFrame_.html"">saveFrame()</A> function. <LI>If you want to create a really large scene and write that, first make sure that you've allocated a lot of memory in the Preferences. <LI>If you want to create images that are larger than the screen, you should create your own PGraphics object, draw to that, and use <A HREF=""http://processing.org/reference/save_.html"">save()</A>. For now, it's best to use <A HREF=""http://dev.processing.org/reference/everything/javadoc/processing/core/PGraphics3D.html"">P3D</A> in this scenario. P2D is currently disabled, and the JAVA2D default will give mixed results. An example of using P3D: <PRE> PGraphics big; void setup() { big = createGraphics(3000, 3000, P3D); big.beginDraw(); big.background(128); big.line(20, 1800, 1800, 900); // etc.. big.endDraw(); // make sure the file is written to the sketch folder big.save(""big.tif""); } </PRE> <LI>It's important to always wrap drawing to createGraphics() with beginDraw() and endDraw() (beginFrame() and endFrame() prior to revision 0115). The reason is that the renderer needs to know when drawing has stopped, so that it can update itself internally. This also handles calling the defaults() method, for people familiar with that. <LI>It's not possible to use createGraphics() with the OPENGL renderer, because it doesn't allow offscreen use. <LI>With Processing 0115 and later, it's possible to write images in formats other than the default .tga and .tiff. The exact formats and background information can be found in the developer's reference for <A HREF=""http://dev.processing.org/reference/core/javadoc/processing/core/PImage.html#save(java.lang.String)"">PImage.save()</A>. </UL>
 */
public PGraphics createGraphics(int iwidth,int iheight,String irenderer){
  PGraphics pg=null;
  if (irenderer.equals(JAVA2D)) {
    pg=new PGraphicsAndroid2D();
  }
 else   if (irenderer.equals(P2D)) {
    if (!g.isGL()) {
      throw new RuntimeException(""String_Node_Str"");
    }
    pg=new PGraphics2D();
  }
 else   if (irenderer.equals(P3D)) {
    if (!g.isGL()) {
      throw new RuntimeException(""String_Node_Str"");
    }
    pg=new PGraphics3D();
  }
 else {
    Class<?> rendererClass=null;
    Constructor<?> constructor=null;
    try {
      rendererClass=this.getClass().getClassLoader().loadClass(irenderer);
    }
 catch (    ClassNotFoundException cnfe) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (rendererClass != null) {
      try {
        constructor=rendererClass.getConstructor(new Class[]{});
      }
 catch (      NoSuchMethodException nsme) {
        throw new RuntimeException(""String_Node_Str"");
      }
      if (constructor != null) {
        try {
          pg=(PGraphics)constructor.newInstance();
        }
 catch (        InvocationTargetException e) {
          e.printStackTrace();
          throw new RuntimeException(e.getMessage());
        }
catch (        IllegalAccessException e) {
          e.printStackTrace();
          throw new RuntimeException(e.getMessage());
        }
catch (        InstantiationException e) {
          e.printStackTrace();
          throw new RuntimeException(e.getMessage());
        }
      }
    }
  }
  pg.setParent(this);
  pg.setPrimary(false);
  pg.setSize(iwidth,iheight);
  return pg;
}","/** 
 * Create an offscreen PGraphics object for drawing. This can be used for bitmap or vector images drawing or rendering. <UL> <LI>Do not use ""new PGraphicsXxxx()"", use this method. This method ensures that internal variables are set up properly that tie the new graphics context back to its parent PApplet. <LI>The basic way to create bitmap images is to use the <A HREF=""http://processing.org/reference/saveFrame_.html"">saveFrame()</A> function. <LI>If you want to create a really large scene and write that, first make sure that you've allocated a lot of memory in the Preferences. <LI>If you want to create images that are larger than the screen, you should create your own PGraphics object, draw to that, and use <A HREF=""http://processing.org/reference/save_.html"">save()</A>. For now, it's best to use <A HREF=""http://dev.processing.org/reference/everything/javadoc/processing/core/PGraphics3D.html"">P3D</A> in this scenario. P2D is currently disabled, and the JAVA2D default will give mixed results. An example of using P3D: <PRE> PGraphics big; void setup() { big = createGraphics(3000, 3000, P3D); big.beginDraw(); big.background(128); big.line(20, 1800, 1800, 900); // etc.. big.endDraw(); // make sure the file is written to the sketch folder big.save(""big.tif""); } </PRE> <LI>It's important to always wrap drawing to createGraphics() with beginDraw() and endDraw() (beginFrame() and endFrame() prior to revision 0115). The reason is that the renderer needs to know when drawing has stopped, so that it can update itself internally. This also handles calling the defaults() method, for people familiar with that. <LI>It's not possible to use createGraphics() with the OPENGL renderer, because it doesn't allow offscreen use. <LI>With Processing 0115 and later, it's possible to write images in formats other than the default .tga and .tiff. The exact formats and background information can be found in the developer's reference for <A HREF=""http://dev.processing.org/reference/core/javadoc/processing/core/PImage.html#save(java.lang.String)"">PImage.save()</A>. </UL>
 */
public PGraphics createGraphics(int iwidth,int iheight,String irenderer){
  PGraphics pg=null;
  if (irenderer.equals(JAVA2D)) {
    pg=new PGraphicsAndroid2D();
  }
 else   if (irenderer.equals(P2D)) {
    if (!g.isGL()) {
      throw new RuntimeException(""String_Node_Str"");
    }
    pg=new PGraphics2D();
  }
 else   if (irenderer.equals(P3D)) {
    if (!g.isGL()) {
      throw new RuntimeException(""String_Node_Str"");
    }
    pg=new PGraphics3D();
  }
 else {
    Class<?> rendererClass=null;
    Constructor<?> constructor=null;
    try {
      rendererClass=this.getClass().getClassLoader().loadClass(irenderer);
    }
 catch (    ClassNotFoundException cnfe) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (rendererClass != null) {
      try {
        constructor=rendererClass.getConstructor(new Class[]{});
      }
 catch (      NoSuchMethodException nsme) {
        throw new RuntimeException(""String_Node_Str"");
      }
      if (constructor != null) {
        try {
          pg=(PGraphics)constructor.newInstance();
        }
 catch (        InvocationTargetException e) {
          e.printStackTrace();
          throw new RuntimeException(e.getMessage());
        }
catch (        IllegalAccessException e) {
          e.printStackTrace();
          throw new RuntimeException(e.getMessage());
        }
catch (        InstantiationException e) {
          e.printStackTrace();
          throw new RuntimeException(e.getMessage());
        }
catch (        java.lang.InstantiationException e) {
          e.printStackTrace();
        }
catch (        IllegalArgumentException e) {
          e.printStackTrace();
        }
      }
    }
  }
  pg.setParent(this);
  pg.setPrimary(false);
  pg.setSize(iwidth,iheight);
  return pg;
}",0.9761019649495486
163633,"/** 
 * Prepend the sketch folder path to the filename (or path) that is passed in. External libraries should use this function to save to the sketch folder. <p/> Note that when running as an applet inside a web browser, the sketchPath will be set to null, because security restrictions prevent applets from accessing that information. <p/> This will also cause an error if the sketch is not inited properly, meaning that init() was never called on the PApplet when hosted my some other main() or by other code. For proper use of init(), see the examples in the main description text for PApplet.
 */
public String sketchPath(String where){
  if (sketchPath == null) {
    return where;
  }
  try {
    if (new File(where).isAbsolute())     return where;
  }
 catch (  Exception e) {
  }
  Context context=getApplicationContext();
  return context.getFileStreamPath(where).getAbsolutePath();
}","/** 
 * Prepend the sketch folder path to the filename (or path) that is passed in. External libraries should use this function to save to the sketch folder. <p/> Note that when running as an applet inside a web browser, the sketchPath will be set to null, because security restrictions prevent applets from accessing that information. <p/> This will also cause an error if the sketch is not inited properly, meaning that init() was never called on the PApplet when hosted my some other main() or by other code. For proper use of init(), see the examples in the main description text for PApplet.
 */
public String sketchPath(String where){
  if (sketchPath == null) {
    return where;
  }
  try {
    if (new File(where).isAbsolute())     return where;
  }
 catch (  Exception e) {
  }
  return activity.getFileStreamPath(where).getAbsolutePath();
}",0.9587155963302753
163634,"public SketchSurfaceViewGL(Context context,int wide,int high,Class<? extends PGraphicsOpenGL> clazz){
  super(context);
  final ActivityManager activityManager=(ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);
  final ConfigurationInfo configurationInfo=activityManager.getDeviceConfigurationInfo();
  final boolean supportsGLES2=configurationInfo.reqGlEsVersion >= 0x20000;
  if (!supportsGLES2) {
    throw new RuntimeException(""String_Node_Str"");
  }
  surfaceHolder=getHolder();
  surfaceHolder.addCallback(this);
  if (clazz.equals(PGraphics2D.class)) {
    g3=new PGraphics2D();
  }
 else   if (clazz.equals(PGraphics3D.class)) {
    g3=new PGraphics3D();
  }
 else {
    try {
      Constructor<? extends PGraphicsOpenGL> constructor=clazz.getConstructor();
      g3=constructor.newInstance();
    }
 catch (    Exception exception) {
      throw new RuntimeException(""String_Node_Str"",exception);
    }
  }
  g3.setParent(PApplet.this);
  g3.setPrimary(true);
  g3.setSize(wide,high);
  setEGLContextClientVersion(2);
  int quality=sketchQuality();
  if (1 < quality) {
    setEGLConfigChooser(((PGLES)g3.pgl).getConfigChooser(quality));
  }
  setRenderer(((PGLES)g3.pgl).getRenderer());
  setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
  g=g3;
  setFocusable(true);
  setFocusableInTouchMode(true);
  requestFocus();
}","public SketchSurfaceViewGL(Context context,int wide,int high,Class<? extends PGraphicsOpenGL> clazz){
  super(context);
  final ActivityManager activityManager=(ActivityManager)activity.getSystemService(Context.ACTIVITY_SERVICE);
  final ConfigurationInfo configurationInfo=activityManager.getDeviceConfigurationInfo();
  final boolean supportsGLES2=configurationInfo.reqGlEsVersion >= 0x20000;
  if (!supportsGLES2) {
    throw new RuntimeException(""String_Node_Str"");
  }
  surfaceHolder=getHolder();
  surfaceHolder.addCallback(this);
  if (clazz.equals(PGraphics2D.class)) {
    g3=new PGraphics2D();
  }
 else   if (clazz.equals(PGraphics3D.class)) {
    g3=new PGraphics3D();
  }
 else {
    try {
      Constructor<? extends PGraphicsOpenGL> constructor=clazz.getConstructor();
      g3=constructor.newInstance();
    }
 catch (    Exception exception) {
      throw new RuntimeException(""String_Node_Str"",exception);
    }
  }
  g3.setParent(PApplet.this);
  g3.setPrimary(true);
  g3.setSize(wide,high);
  setEGLContextClientVersion(2);
  int quality=sketchQuality();
  if (1 < quality) {
    setEGLConfigChooser(((PGLES)g3.pgl).getConfigChooser(quality));
  }
  setRenderer(((PGLES)g3.pgl).getRenderer());
  setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
  g=g3;
  setFocusable(true);
  setFocusableInTouchMode(true);
  requestFocus();
}",0.996660482374768
163635,"@Override protected void onStart(){
  tellPDE(""String_Node_Str"");
  super.onStart();
}","@Override public void onStart(){
  tellPDE(""String_Node_Str"");
  super.onStart();
}",0.9349112426035504
163636,"@Override protected void onResume(){
  super.onResume();
  if (DEBUG)   System.out.println(""String_Node_Str"");
  paused=false;
  handleMethods(""String_Node_Str"");
  resume();
}","@Override public void onResume(){
  super.onResume();
  if (DEBUG)   System.out.println(""String_Node_Str"");
  paused=false;
  handleMethods(""String_Node_Str"");
  resume();
}",0.968481375358166
163637,"protected boolean create(final AndroidSDK sdk) throws IOException {
  final String[] params={sdk.getAndroidToolPath(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",name,""String_Node_Str"",target,""String_Node_Str"",DEFAULT_SDCARD_SIZE,""String_Node_Str"",DEFAULT_SKIN};
  avdList=null;
  final ProcessHelper p=new ProcessHelper(params);
  try {
    final ProcessResult createAvdResult=p.execute(""String_Node_Str"");
    if (createAvdResult.succeeded()) {
      return true;
    }
    if (createAvdResult.toString().contains(""String_Node_Str"")) {
      Base.showWarningTiered(""String_Node_Str"",AVD_TARGET_PRIMARY,AVD_TARGET_SECONDARY,null);
    }
 else {
      Base.showWarningTiered(""String_Node_Str"",AVD_CREATE_PRIMARY,AVD_CREATE_SECONDARY,null);
      System.out.println(createAvdResult);
    }
  }
 catch (  final InterruptedException ie) {
  }
  return false;
}","protected boolean create(final AndroidSDK sdk) throws IOException {
  final String[] params={sdk.getAndroidToolPath(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",name,""String_Node_Str"",target,""String_Node_Str"",DEFAULT_SDCARD_SIZE,""String_Node_Str"",DEFAULT_SKIN,""String_Node_Str"",""String_Node_Str""};
  avdList=null;
  final ProcessHelper p=new ProcessHelper(params);
  try {
    final ProcessResult createAvdResult=p.execute(""String_Node_Str"");
    if (createAvdResult.succeeded()) {
      return true;
    }
    if (createAvdResult.toString().contains(""String_Node_Str"")) {
      Base.showWarningTiered(""String_Node_Str"",AVD_TARGET_PRIMARY,AVD_TARGET_SECONDARY,null);
    }
 else {
      Base.showWarningTiered(""String_Node_Str"",AVD_CREATE_PRIMARY,AVD_CREATE_SECONDARY,null);
      System.out.println(createAvdResult);
    }
  }
 catch (  final InterruptedException ie) {
  }
  return false;
}",0.9796610169491524
163638,"private File zipalignPackage(File signedPackage,File projectFolder) throws IOException, InterruptedException {
  String zipalignPath=sdk.getSdkFolder().getAbsolutePath() + ""String_Node_Str"";
  File alignedPackage=new File(projectFolder,""String_Node_Str"" + sketch.getName() + ""String_Node_Str"");
  String[] args={zipalignPath,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",signedPackage.getAbsolutePath(),alignedPackage.getAbsolutePath()};
  Process alignProcess=Runtime.getRuntime().exec(args);
  alignProcess.waitFor();
  if (alignedPackage.exists())   return alignedPackage;
  return null;
}","private File zipalignPackage(File signedPackage,File projectFolder) throws IOException, InterruptedException {
  File buildToolsFolder=new File(sdk.getSdkFolder(),""String_Node_Str"").listFiles()[0];
  String zipalignPath=buildToolsFolder.getAbsolutePath() + ""String_Node_Str"";
  File alignedPackage=new File(projectFolder,""String_Node_Str"" + sketch.getName() + ""String_Node_Str"");
  String[] args={zipalignPath,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",signedPackage.getAbsolutePath(),alignedPackage.getAbsolutePath()};
  Process alignProcess=Runtime.getRuntime().exec(args);
  alignProcess.waitFor();
  if (alignedPackage.exists())   return alignedPackage;
  return null;
}",0.9058365758754864
163639,"public void launch(Future<Device> deviceFuture){
  listener.statusNotice(""String_Node_Str"");
  final Device device=waitForDevice(deviceFuture,listener);
  if (device == null || !device.isAlive()) {
    listener.statusError(""String_Node_Str"");
    Devices.killAdbServer();
    return;
  }
  device.addListener(this);
  listener.statusNotice(""String_Node_Str"" + device.getId());
  if (!device.installApp(build.getPathForAPK(),listener)) {
    listener.statusError(""String_Node_Str"");
    Devices.killAdbServer();
    return;
  }
  listener.statusNotice(""String_Node_Str"" + device.getId());
  if (startSketch(build,device)) {
    listener.statusNotice(""String_Node_Str"" + (device.isEmulator() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
 else {
    listener.statusError(""String_Node_Str"");
  }
  listener.stopIndeterminate();
  lastRunDevice=device;
}","public void launch(Future<Device> deviceFuture){
  listener.statusNotice(""String_Node_Str"");
  final Device device=waitForDevice(deviceFuture,listener);
  if (device == null || !device.isAlive()) {
    listener.statusError(""String_Node_Str"");
    Devices.killAdbServer();
    return;
  }
  device.addListener(this);
  listener.statusNotice(""String_Node_Str"" + device.getId());
  if (!device.installApp(build,listener)) {
    listener.statusError(""String_Node_Str"");
    Devices.killAdbServer();
    return;
  }
  listener.statusNotice(""String_Node_Str"" + device.getId());
  if (startSketch(build,device)) {
    listener.statusNotice(""String_Node_Str"" + (device.isEmulator() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
 else {
    listener.statusError(""String_Node_Str"");
  }
  listener.stopIndeterminate();
  lastRunDevice=device;
}",0.9907300115874856
163640,"public boolean installApp(final String apkPath,final RunnerListener status){
  if (!isAlive()) {
    return false;
  }
  bringLauncherToFront();
  try {
    final ProcessResult installResult=adb(""String_Node_Str"",""String_Node_Str"",apkPath);
    if (!installResult.succeeded()) {
      status.statusError(""String_Node_Str"");
      System.err.println(installResult);
      return false;
    }
    String errorMsg=null;
    for (    final String line : installResult) {
      if (line.startsWith(""String_Node_Str"")) {
        errorMsg=line.substring(8);
        System.err.println(line);
      }
    }
    if (errorMsg == null) {
      status.statusNotice(""String_Node_Str"");
      return true;
    }
    status.statusError(""String_Node_Str"" + errorMsg);
  }
 catch (  final IOException e) {
    status.statusError(e);
  }
catch (  final InterruptedException e) {
  }
  return false;
}","public boolean installApp(final AndroidBuild build,final RunnerListener status){
  if (!isAlive()) {
    return false;
  }
  bringLauncherToFront();
  try {
    final ProcessResult installResult=adb(""String_Node_Str"",""String_Node_Str"",build.getPathForAPK());
    if (!installResult.succeeded()) {
      status.statusError(""String_Node_Str"");
      System.err.println(installResult);
      return false;
    }
    String errorMsg=null;
    for (    final String line : installResult) {
      if (line.startsWith(""String_Node_Str"")) {
        errorMsg=line.substring(8);
        if (line.contains(""String_Node_Str"")) {
          boolean removeResult=removeApp(build.getPackageName());
          if (removeResult)           return installApp(build,status);
        }
        System.err.println(line);
      }
    }
    if (errorMsg == null) {
      status.statusNotice(""String_Node_Str"");
      return true;
    }
    status.statusError(""String_Node_Str"" + errorMsg);
  }
 catch (  final IOException e) {
    status.statusError(e);
  }
catch (  final InterruptedException e) {
  }
  return false;
}",0.3732928679817905
163641,"@Override protected Object doInBackground() throws Exception {
  String hostOs=getOsString();
  File modeFolder=new File(Base.getSketchbookModesFolder() + ""String_Node_Str"");
  File sdkFolder=new File(modeFolder,""String_Node_Str"");
  if (!sdkFolder.exists())   sdkFolder.mkdir();
  File platformsFolder=new File(sdkFolder,""String_Node_Str"");
  if (!platformsFolder.exists())   platformsFolder.mkdir();
  File buildToolsFolder=new File(sdkFolder,""String_Node_Str"");
  if (!buildToolsFolder.exists())   buildToolsFolder.mkdir();
  File tempFolder=new File(modeFolder,""String_Node_Str"");
  if (!tempFolder.exists())   tempFolder.mkdir();
  try {
    SDKUrlHolder downloadUrls=getDownloadUrls(URL_REPOSITORY,hostOs);
    firePropertyChange(PROPERTY_CHANGE_EVENT_TOTAL,0,downloadUrls.totalSize);
    totalSize=downloadUrls.totalSize;
    File downloadedTools=new File(tempFolder,downloadUrls.toolsFilename);
    downloadAndUnpack(downloadUrls.toolsUrl,downloadedTools,sdkFolder);
    File downloadedPlatformTools=new File(tempFolder,downloadUrls.platformToolsFilename);
    downloadAndUnpack(downloadUrls.platformToolsUrl,downloadedPlatformTools,sdkFolder);
    File downloadedBuildTools=new File(tempFolder,downloadUrls.buildToolsFilename);
    downloadAndUnpack(downloadUrls.buildToolsUrl,downloadedBuildTools,buildToolsFolder);
    File downloadedPlatform=new File(tempFolder,downloadUrls.platformFilename);
    downloadAndUnpack(downloadUrls.platformUrl,downloadedPlatform,platformsFolder);
    if (Base.isLinux() || Base.isMacOS()) {
      Runtime.getRuntime().exec(""String_Node_Str"" + sdkFolder.getAbsolutePath());
    }
    tempFolder.delete();
    Base.getPlatform().setenv(""String_Node_Str"",sdkFolder.getAbsolutePath());
    androidMode.loadSDK();
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
  return null;
}","@Override protected Object doInBackground() throws Exception {
  String hostOs=getOsString();
  File modeFolder=new File(Base.getSketchbookModesFolder() + ""String_Node_Str"");
  File sdkFolder=new File(modeFolder,""String_Node_Str"");
  if (!sdkFolder.exists())   sdkFolder.mkdir();
  File platformsFolder=new File(sdkFolder,""String_Node_Str"");
  if (!platformsFolder.exists())   platformsFolder.mkdir();
  File buildToolsFolder=new File(sdkFolder,""String_Node_Str"");
  if (!buildToolsFolder.exists())   buildToolsFolder.mkdir();
  File tempFolder=new File(modeFolder,""String_Node_Str"");
  if (!tempFolder.exists())   tempFolder.mkdir();
  try {
    SDKUrlHolder downloadUrls=getDownloadUrls(URL_REPOSITORY,hostOs);
    firePropertyChange(PROPERTY_CHANGE_EVENT_TOTAL,0,downloadUrls.totalSize);
    totalSize=downloadUrls.totalSize;
    File downloadedTools=new File(tempFolder,downloadUrls.toolsFilename);
    downloadAndUnpack(downloadUrls.toolsUrl,downloadedTools,sdkFolder);
    File downloadedPlatformTools=new File(tempFolder,downloadUrls.platformToolsFilename);
    downloadAndUnpack(downloadUrls.platformToolsUrl,downloadedPlatformTools,sdkFolder);
    File downloadedBuildTools=new File(tempFolder,downloadUrls.buildToolsFilename);
    downloadAndUnpack(downloadUrls.buildToolsUrl,downloadedBuildTools,buildToolsFolder);
    File downloadedPlatform=new File(tempFolder,downloadUrls.platformFilename);
    downloadAndUnpack(downloadUrls.platformUrl,downloadedPlatform,platformsFolder);
    if (Base.isLinux() || Base.isMacOS()) {
      Runtime.getRuntime().exec(""String_Node_Str"" + sdkFolder.getAbsolutePath());
    }
    tempFolder.delete();
    Base.getPlatform().setenv(""String_Node_Str"",sdkFolder.getAbsolutePath());
    Preferences.set(""String_Node_Str"",sdkFolder.getAbsolutePath());
    androidMode.loadSDK();
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
  return null;
}",0.9829145728643216
163642,"public static void setSdkTarget(AndroidSDK.SDKTarget target,Sketch sketch){
  sdkName=target.name;
  sdkVersion=Integer.toString(target.version);
  Manifest manifest=new Manifest(sketch);
  manifest.setSdkTarget(sdkVersion);
  Preferences.set(""String_Node_Str"",sdkVersion);
}","public static void setSdkTarget(AndroidSDK.SDKTarget target,Sketch sketch){
  sdkName=target.name;
  sdkVersion=Integer.toString(target.version);
  sdkTarget=""String_Node_Str"" + sdkVersion;
  Manifest manifest=new Manifest(sketch);
  manifest.setSdkTarget(sdkVersion);
  Preferences.set(""String_Node_Str"",sdkVersion);
}",0.6127946127946128
163643,"@Override protected Object doInBackground() throws Exception {
  String hostOs=getOsString();
  File modeFolder=new File(Base.getSketchbookModesFolder() + ""String_Node_Str"");
  File sdkFolder=new File(modeFolder,""String_Node_Str"");
  if (!sdkFolder.exists())   sdkFolder.mkdir();
  File platformsFolder=new File(sdkFolder,""String_Node_Str"");
  if (!platformsFolder.exists())   platformsFolder.mkdir();
  File buildToolsFolder=new File(sdkFolder,""String_Node_Str"");
  if (!buildToolsFolder.exists())   buildToolsFolder.mkdir();
  File tempFolder=new File(modeFolder,""String_Node_Str"");
  if (!tempFolder.exists())   tempFolder.mkdir();
  try {
    SDKUrlHolder downloadUrls=getDownloadUrls(URL_REPOSITORY,hostOs);
    firePropertyChange(PROPERTY_CHANGE_EVENT_TOTAL,0,downloadUrls.totalSize);
    totalSize=downloadUrls.totalSize;
    File downloadedTools=new File(tempFolder,downloadUrls.toolsFilename);
    downloadAndUnpack(downloadUrls.toolsUrl,downloadedTools,sdkFolder);
    File downloadedPlatformTools=new File(tempFolder,downloadUrls.platformToolsFilename);
    downloadAndUnpack(downloadUrls.platformToolsUrl,downloadedPlatformTools,sdkFolder);
    File downloadedBuildTools=new File(tempFolder,downloadUrls.buildToolsFilename);
    downloadAndUnpack(downloadUrls.buildToolsUrl,downloadedBuildTools,buildToolsFolder);
    File downloadedPlatform=new File(tempFolder,downloadUrls.platformFilename);
    downloadAndUnpack(downloadUrls.platformUrl,downloadedPlatform,platformsFolder);
    if (Base.isLinux() || Base.isMacOS()) {
      Runtime.getRuntime().exec(""String_Node_Str"" + sdkFolder.getAbsolutePath());
    }
    tempFolder.delete();
    Base.getPlatform().setenv(""String_Node_Str"",sdkFolder.getAbsolutePath());
    androidMode.loadSDK();
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
  return null;
}","@Override protected Object doInBackground() throws Exception {
  String hostOs=getOsString();
  File modeFolder=new File(Base.getSketchbookModesFolder() + ""String_Node_Str"");
  File sdkFolder=new File(modeFolder,""String_Node_Str"");
  if (!sdkFolder.exists())   sdkFolder.mkdir();
  File platformsFolder=new File(sdkFolder,""String_Node_Str"");
  if (!platformsFolder.exists())   platformsFolder.mkdir();
  File buildToolsFolder=new File(sdkFolder,""String_Node_Str"");
  if (!buildToolsFolder.exists())   buildToolsFolder.mkdir();
  File tempFolder=new File(modeFolder,""String_Node_Str"");
  if (!tempFolder.exists())   tempFolder.mkdir();
  try {
    SDKUrlHolder downloadUrls=getDownloadUrls(URL_REPOSITORY,hostOs);
    firePropertyChange(PROPERTY_CHANGE_EVENT_TOTAL,0,downloadUrls.totalSize);
    totalSize=downloadUrls.totalSize;
    File downloadedTools=new File(tempFolder,downloadUrls.toolsFilename);
    downloadAndUnpack(downloadUrls.toolsUrl,downloadedTools,sdkFolder);
    File downloadedPlatformTools=new File(tempFolder,downloadUrls.platformToolsFilename);
    downloadAndUnpack(downloadUrls.platformToolsUrl,downloadedPlatformTools,sdkFolder);
    File downloadedBuildTools=new File(tempFolder,downloadUrls.buildToolsFilename);
    downloadAndUnpack(downloadUrls.buildToolsUrl,downloadedBuildTools,buildToolsFolder);
    File downloadedPlatform=new File(tempFolder,downloadUrls.platformFilename);
    downloadAndUnpack(downloadUrls.platformUrl,downloadedPlatform,platformsFolder);
    if (Base.isLinux() || Base.isMacOS()) {
      Runtime.getRuntime().exec(""String_Node_Str"" + sdkFolder.getAbsolutePath());
    }
    tempFolder.delete();
    Base.getPlatform().setenv(""String_Node_Str"",sdkFolder.getAbsolutePath());
    Preferences.set(""String_Node_Str"",sdkFolder.getAbsolutePath());
    androidMode.loadSDK();
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
  return null;
}",0.9829145728643216
163644,"protected static IntBuffer updateIntBuffer(IntBuffer buf,int[] arr,boolean wrap){
  if (USE_DIRECT_BUFFERS) {
    if (buf == null || buf.capacity() < arr.length) {
      buf=PGL.allocateDirectIntBuffer(arr.length);
    }
    buf.position(0);
    buf.put(arr);
    buf.rewind();
  }
 else {
    if (wrap) {
      buf=IntBuffer.wrap(arr);
    }
 else {
      if (buf == null || buf.capacity() < arr.length) {
        buf=IntBuffer.allocate(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }
  return buf;
}","protected static void updateIntBuffer(IntBuffer buf,int[] arr,int offset,int size){
  if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
    buf.position(offset);
    buf.put(arr,offset,size);
    buf.rewind();
  }
}",0.2846153846153846
163645,"protected static FloatBuffer updateFloatBuffer(FloatBuffer buf,float[] arr,boolean wrap){
  if (USE_DIRECT_BUFFERS) {
    if (buf == null || buf.capacity() < arr.length) {
      buf=PGL.allocateDirectFloatBuffer(arr.length);
    }
    buf.position(0);
    buf.put(arr);
    buf.rewind();
  }
 else {
    if (wrap) {
      buf=FloatBuffer.wrap(arr);
    }
 else {
      if (buf == null || buf.capacity() < arr.length) {
        buf=FloatBuffer.allocate(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }
  return buf;
}","protected static void updateFloatBuffer(FloatBuffer buf,float[] arr,int offset,int size){
  if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
    buf.position(offset);
    buf.put(arr,offset,size);
    buf.rewind();
  }
}",0.2925
163646,"protected static ByteBuffer updateByteBuffer(ByteBuffer buf,byte[] arr,boolean wrap){
  if (USE_DIRECT_BUFFERS) {
    if (buf == null || buf.capacity() < arr.length) {
      buf=PGL.allocateDirectByteBuffer(arr.length);
    }
    buf.position(0);
    buf.put(arr);
    buf.rewind();
  }
 else {
    if (wrap) {
      buf=ByteBuffer.wrap(arr);
    }
 else {
      if (buf == null || buf.capacity() < arr.length) {
        buf=ByteBuffer.allocate(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }
  return buf;
}","protected static void updateByteBuffer(ByteBuffer buf,byte[] arr,int offset,int size){
  if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
    buf.position(offset);
    buf.put(arr,offset,size);
    buf.rewind();
  }
}",0.2810126582278481
163647,"protected static ShortBuffer updateShortBuffer(ShortBuffer buf,short[] arr,boolean wrap){
  if (USE_DIRECT_BUFFERS) {
    if (buf == null || buf.capacity() < arr.length) {
      buf=PGL.allocateDirectShortBuffer(arr.length);
    }
    buf.position(0);
    buf.put(arr);
    buf.rewind();
  }
 else {
    if (wrap) {
      buf=ShortBuffer.wrap(arr);
    }
 else {
      if (buf == null || buf.capacity() < arr.length) {
        buf=ShortBuffer.allocate(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }
  return buf;
}","protected static void updateShortBuffer(ShortBuffer buf,short[] arr,int offset,int size){
  if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
    buf.position(offset);
    buf.put(arr,offset,size);
    buf.rewind();
  }
}",0.2925
163648,"/** 
 * Converts input array of Java ARGB values representing an image of width x height resolution to native OpenGL format (RGBA on big endian, BGRA on little endian). It also rearranges the elements in the array so that the image is flipped vertically.
 */
protected static void javaToNativeARGB(int[] pixels,int width,int height){
  int index=0;
  int yindex=(height - 1) * width;
  for (int y=0; y < height / 2; y++) {
    if (BIG_ENDIAN) {
      for (int x=0; x < width; x++) {
        int temp=pixels[index];
        pixels[index]=((pixels[yindex] >> 24) & 0xff) | ((pixels[yindex] << 8) & 0xffffff00);
        pixels[yindex]=((temp >> 24) & 0xff) | ((temp << 8) & 0xffffff00);
        index++;
        yindex++;
      }
    }
 else {
      for (int x=0; x < width; x++) {
        int temp=pixels[index];
        pixels[index]=(pixels[yindex] & 0xff000000) | ((pixels[yindex] << 16) & 0xff0000) | (pixels[yindex] & 0xff00)| ((pixels[yindex] >> 16) & 0xff);
        pixels[yindex]=(pixels[yindex] & 0xff000000) | ((temp << 16) & 0xff0000) | (temp & 0xff00)| ((temp >> 16) & 0xff);
        index++;
        yindex++;
      }
    }
    yindex-=width * 2;
  }
  if ((height % 2) == 1) {
    index=(height / 2) * width;
    if (BIG_ENDIAN) {
      for (int x=0; x < width; x++) {
        pixels[index]=((pixels[index] >> 24) & 0xff) | ((pixels[index] << 8) & 0xffffff00);
        index++;
      }
    }
 else {
      for (int x=0; x < width; x++) {
        pixels[index]=(pixels[index] & 0xff000000) | ((pixels[index] << 16) & 0xff0000) | (pixels[index] & 0xff00)| ((pixels[index] >> 16) & 0xff);
        index++;
      }
    }
  }
}","/** 
 * Converts input array of Java ARGB values representing an image of width x height resolution to native OpenGL format (RGBA on big endian, BGRA on little endian). It also rearranges the elements in the array so that the image is flipped vertically.
 */
protected static void javaToNativeARGB(int[] pixels,int width,int height){
  int index=0;
  int yindex=(height - 1) * width;
  for (int y=0; y < height / 2; y++) {
    if (BIG_ENDIAN) {
      for (int x=0; x < width; x++) {
        int temp=pixels[index];
        pixels[index]=((pixels[yindex] >> 24) & 0xff) | ((pixels[yindex] << 8) & 0xffffff00);
        pixels[yindex]=((temp >> 24) & 0xff) | ((temp << 8) & 0xffffff00);
        index++;
        yindex++;
      }
    }
 else {
      for (int x=0; x < width; x++) {
        int temp=pixels[index];
        pixels[index]=(pixels[yindex] & 0xff000000) | ((pixels[yindex] << 16) & 0xff0000) | (pixels[yindex] & 0xff00)| ((pixels[yindex] >> 16) & 0xff);
        pixels[yindex]=(temp & 0xff000000) | ((temp << 16) & 0xff0000) | (temp & 0xff00)| ((temp >> 16) & 0xff);
        index++;
        yindex++;
      }
    }
    yindex-=width * 2;
  }
  if ((height % 2) == 1) {
    index=(height / 2) * width;
    if (BIG_ENDIAN) {
      for (int x=0; x < width; x++) {
        pixels[index]=((pixels[index] >> 24) & 0xff) | ((pixels[index] << 8) & 0xffffff00);
        index++;
      }
    }
 else {
      for (int x=0; x < width; x++) {
        pixels[index]=(pixels[index] & 0xff000000) | ((pixels[index] << 16) & 0xff0000) | (pixels[index] & 0xff00)| ((pixels[index] >> 16) & 0xff);
        index++;
      }
    }
  }
}",0.994475138121547
163649,"protected void setDefaults(){
  inGeo.clear();
  tessGeo.clear();
  texCache.clear();
  super.noTexture();
  setDefaultBlend();
  if (hints[DISABLE_DEPTH_TEST]) {
    pgl.disable(PGL.DEPTH_TEST);
  }
 else {
    pgl.enable(PGL.DEPTH_TEST);
  }
  pgl.depthFunc(PGL.LEQUAL);
  if (hints[DISABLE_OPTIMIZED_STROKE]) {
    flushMode=FLUSH_CONTINUOUSLY;
  }
 else {
    flushMode=FLUSH_WHEN_FULL;
  }
  if (primarySurface) {
    pgl.getIntegerv(PGL.SAMPLES,intBuffer);
    int temp=intBuffer.get(0);
    if (quality != temp && 1 < temp && 1 < quality) {
      quality=temp;
    }
  }
  if (quality < 2) {
    pgl.disable(PGL.MULTISAMPLE);
  }
 else {
    pgl.enable(PGL.MULTISAMPLE);
  }
  pgl.disable(PGL.POINT_SMOOTH);
  pgl.disable(PGL.LINE_SMOOTH);
  pgl.disable(PGL.POLYGON_SMOOTH);
  viewport.put(0,0);
  viewport.put(1,0);
  viewport.put(2,width);
  viewport.put(3,height);
  pgl.viewport(viewport.get(0),viewport.get(1),viewport.get(2),viewport.get(3));
  if (sized) {
    background(backgroundColor);
    defaultPerspective();
    defaultCamera();
    sized=false;
  }
 else {
    modelview.set(camera);
    modelviewInv.set(cameraInv);
    updateProjmodelview();
  }
  if (is3D()) {
    noLights();
    lightFalloff(1,0,0);
    lightSpecular(0,0,0);
  }
  pgl.frontFace(PGL.CW);
  pgl.disable(PGL.CULL_FACE);
  pgl.activeTexture(PGL.TEXTURE0);
  normalX=normalY=normalZ=0;
  pgl.depthMask(true);
  pgl.clearDepth(1);
  pgl.clearStencil(0);
  pgl.clear(PGL.DEPTH_BUFFER_BIT | PGL.STENCIL_BUFFER_BIT);
  if (!settingsInited) {
    defaultSettings();
  }
  if (restoreSurface) {
    restoreSurfaceFromPixels();
    restoreSurface=false;
  }
  if (hints[DISABLE_DEPTH_MASK]) {
    pgl.depthMask(false);
  }
 else {
    pgl.depthMask(true);
  }
  pixelsOp=OP_NONE;
  modified=false;
  setgetPixels=false;
  clearColorBuffer0=clearColorBuffer;
  clearColorBuffer=false;
}","protected void setDefaults(){
  inGeo.clear();
  tessGeo.clear();
  texCache.clear();
  super.noTexture();
  setBlendMode(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    pgl.disable(PGL.DEPTH_TEST);
  }
 else {
    pgl.enable(PGL.DEPTH_TEST);
  }
  pgl.depthFunc(PGL.LEQUAL);
  if (hints[DISABLE_OPTIMIZED_STROKE]) {
    flushMode=FLUSH_CONTINUOUSLY;
  }
 else {
    flushMode=FLUSH_WHEN_FULL;
  }
  if (primarySurface) {
    pgl.getIntegerv(PGL.SAMPLES,intBuffer);
    int temp=intBuffer.get(0);
    if (quality != temp && 1 < temp && 1 < quality) {
      quality=temp;
    }
  }
  if (quality < 2) {
    pgl.disable(PGL.MULTISAMPLE);
  }
 else {
    pgl.enable(PGL.MULTISAMPLE);
  }
  pgl.disable(PGL.POINT_SMOOTH);
  pgl.disable(PGL.LINE_SMOOTH);
  pgl.disable(PGL.POLYGON_SMOOTH);
  viewport.put(0,0);
  viewport.put(1,0);
  viewport.put(2,width);
  viewport.put(3,height);
  pgl.viewport(viewport.get(0),viewport.get(1),viewport.get(2),viewport.get(3));
  if (sized) {
    background(backgroundColor);
    defaultPerspective();
    defaultCamera();
    sized=false;
  }
 else {
    modelview.set(camera);
    modelviewInv.set(cameraInv);
    updateProjmodelview();
  }
  if (is3D()) {
    noLights();
    lightFalloff(1,0,0);
    lightSpecular(0,0,0);
  }
  pgl.frontFace(PGL.CW);
  pgl.disable(PGL.CULL_FACE);
  pgl.activeTexture(PGL.TEXTURE0);
  normalX=normalY=normalZ=0;
  pgl.depthMask(true);
  pgl.clearDepth(1);
  pgl.clearStencil(0);
  pgl.clear(PGL.DEPTH_BUFFER_BIT | PGL.STENCIL_BUFFER_BIT);
  if (!settingsInited) {
    defaultSettings();
  }
  if (restoreSurface) {
    restoreSurfaceFromPixels();
    restoreSurface=false;
  }
  if (hints[DISABLE_DEPTH_MASK]) {
    pgl.depthMask(false);
  }
 else {
    pgl.depthMask(true);
  }
  pixelsOp=OP_NONE;
  modified=false;
  setgetPixels=false;
  clearColorBuffer0=clearColorBuffer;
  clearColorBuffer=false;
}",0.993048128342246
163650,"/** 
 * Allows to set custom blend modes for the entire scene, using openGL. Reference article about blending modes: http://www.pegtop.net/delphi/articles/blendmodes/ HARD_LIGHT, SOFT_LIGHT, OVERLAY, DODGE, BURN modes cannot be implemented in fixed-function pipeline because they require conditional blending and non-linear blending equations.
 */
@Override public void blendMode(int mode){
  if (blendMode != mode) {
    flush();
    blendMode=mode;
    pgl.enable(PGL.BLEND);
    if (mode == REPLACE) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_ADD);
      }
      pgl.blendFunc(PGL.ONE,PGL.ZERO);
    }
 else     if (mode == BLEND) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_ADD);
      }
      pgl.blendFunc(PGL.SRC_ALPHA,PGL.ONE_MINUS_SRC_ALPHA);
    }
 else     if (mode == ADD) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_ADD);
      }
      pgl.blendFunc(PGL.SRC_ALPHA,PGL.ONE);
    }
 else     if (mode == SUBTRACT) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_ADD);
      }
      pgl.blendFunc(PGL.ONE_MINUS_DST_COLOR,PGL.ZERO);
    }
 else     if (mode == LIGHTEST) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_MAX);
        pgl.blendFunc(PGL.SRC_ALPHA,PGL.DST_ALPHA);
      }
 else {
        PGraphics.showWarning(BLEND_DRIVER_ERROR,""String_Node_Str"");
      }
    }
 else     if (mode == DARKEST) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_MIN);
        pgl.blendFunc(PGL.SRC_ALPHA,PGL.DST_ALPHA);
      }
 else {
        PGraphics.showWarning(BLEND_DRIVER_ERROR,""String_Node_Str"");
      }
    }
 else     if (mode == DIFFERENCE) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_REVERSE_SUBTRACT);
        pgl.blendFunc(PGL.ONE,PGL.ONE);
      }
 else {
        PGraphics.showWarning(BLEND_DRIVER_ERROR,""String_Node_Str"");
      }
    }
 else     if (mode == EXCLUSION) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_ADD);
      }
      pgl.blendFunc(PGL.ONE_MINUS_DST_COLOR,PGL.ONE_MINUS_SRC_COLOR);
    }
 else     if (mode == MULTIPLY) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_ADD);
      }
      pgl.blendFunc(PGL.DST_COLOR,PGL.SRC_COLOR);
    }
 else     if (mode == SCREEN) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_ADD);
      }
      pgl.blendFunc(PGL.ONE_MINUS_DST_COLOR,PGL.ONE);
    }
 else     if (mode == OVERLAY) {
      PGraphics.showWarning(BLEND_RENDERER_ERROR,""String_Node_Str"");
    }
 else     if (mode == HARD_LIGHT) {
      PGraphics.showWarning(BLEND_RENDERER_ERROR,""String_Node_Str"");
    }
 else     if (mode == SOFT_LIGHT) {
      PGraphics.showWarning(BLEND_RENDERER_ERROR,""String_Node_Str"");
    }
 else     if (mode == DODGE) {
      PGraphics.showWarning(BLEND_RENDERER_ERROR,""String_Node_Str"");
    }
 else     if (mode == BURN) {
      PGraphics.showWarning(BLEND_RENDERER_ERROR,""String_Node_Str"");
    }
  }
}","/** 
 * Allows to set custom blend modes for the entire scene, using openGL. Reference article about blending modes: http://www.pegtop.net/delphi/articles/blendmodes/ HARD_LIGHT, SOFT_LIGHT, OVERLAY, DODGE, BURN modes cannot be implemented in fixed-function pipeline because they require conditional blending and non-linear blending equations.
 */
@Override public void blendMode(int mode){
  if (blendMode != mode) {
    flush();
    setBlendMode(mode);
  }
}",0.262561719430729
163651,"protected void restoreGL(){
  blendMode(blendMode);
  if (hints[DISABLE_DEPTH_TEST]) {
    pgl.disable(PGL.DEPTH_TEST);
  }
 else {
    pgl.enable(PGL.DEPTH_TEST);
  }
  pgl.depthFunc(PGL.LEQUAL);
  if (quality < 2) {
    pgl.disable(PGL.MULTISAMPLE);
  }
 else {
    pgl.enable(PGL.MULTISAMPLE);
    pgl.disable(PGL.POINT_SMOOTH);
    pgl.disable(PGL.LINE_SMOOTH);
    pgl.disable(PGL.POLYGON_SMOOTH);
  }
  pgl.viewport(viewport.get(0),viewport.get(1),viewport.get(2),viewport.get(3));
  if (clip) {
    pgl.enable(PGL.SCISSOR_TEST);
    pgl.scissor(clipRect[0],clipRect[1],clipRect[2],clipRect[3]);
  }
 else {
    pgl.disable(PGL.SCISSOR_TEST);
  }
  pgl.frontFace(PGL.CW);
  pgl.disable(PGL.CULL_FACE);
  pgl.activeTexture(PGL.TEXTURE0);
  if (hints[DISABLE_DEPTH_MASK]) {
    pgl.depthMask(false);
  }
 else {
    pgl.depthMask(true);
  }
  currentFramebuffer.bind();
  pgl.drawBuffer(currentFramebuffer.getDefaultDrawBuffer());
}","protected void restoreGL(){
  setBlendMode(blendMode);
  if (hints[DISABLE_DEPTH_TEST]) {
    pgl.disable(PGL.DEPTH_TEST);
  }
 else {
    pgl.enable(PGL.DEPTH_TEST);
  }
  pgl.depthFunc(PGL.LEQUAL);
  if (quality < 2) {
    pgl.disable(PGL.MULTISAMPLE);
  }
 else {
    pgl.enable(PGL.MULTISAMPLE);
    pgl.disable(PGL.POINT_SMOOTH);
    pgl.disable(PGL.LINE_SMOOTH);
    pgl.disable(PGL.POLYGON_SMOOTH);
  }
  pgl.viewport(viewport.get(0),viewport.get(1),viewport.get(2),viewport.get(3));
  if (clip) {
    pgl.enable(PGL.SCISSOR_TEST);
    pgl.scissor(clipRect[0],clipRect[1],clipRect[2],clipRect[3]);
  }
 else {
    pgl.disable(PGL.SCISSOR_TEST);
  }
  pgl.frontFace(PGL.CW);
  pgl.disable(PGL.CULL_FACE);
  pgl.activeTexture(PGL.TEXTURE0);
  if (hints[DISABLE_DEPTH_MASK]) {
    pgl.depthMask(false);
  }
 else {
    pgl.depthMask(true);
  }
  currentFramebuffer.bind();
  pgl.drawBuffer(currentFramebuffer.getDefaultDrawBuffer());
}",0.9973333333333332
163652,"protected void drawTexture(int x,int y,int w,int h){
  pgl.drawTexture(texture.glTarget,texture.glName,texture.glWidth,texture.glHeight,x,y,x + w,y + h,x,height - (y + h),x + w,height - y);
}","protected void drawTexture(int x,int y,int w,int h){
  pgl.disable(PGL.BLEND);
  pgl.drawTexture(texture.glTarget,texture.glName,texture.glWidth,texture.glHeight,x,y,x + w,y + h,x,height - (y + h),x + w,height - y);
  pgl.enable(PGL.BLEND);
}",0.8822170900692841
163653,"/** 
 * Format this XML data as a String.
 * @webref xml:method
 * @brief Formats XML data as a String
 * @param indent -1 for a single line (and no declaration), >= 0 for indents and newlines
 * @return the content
 * @see XML#toString()
 */
public String format(int indent){
  try {
    boolean useIndentAmount=false;
    TransformerFactory factory=TransformerFactory.newInstance();
    if (indent != -1) {
      try {
        factory.setAttribute(""String_Node_Str"",indent);
      }
 catch (      IllegalArgumentException e) {
        useIndentAmount=true;
      }
    }
    Transformer transformer=factory.newTransformer();
    if (indent == -1 || parent == null) {
      transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION,""String_Node_Str"");
    }
 else {
      transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION,""String_Node_Str"");
    }
    transformer.setOutputProperty(OutputKeys.METHOD,""String_Node_Str"");
    if (useIndentAmount) {
      transformer.setOutputProperty(""String_Node_Str"",String.valueOf(indent));
    }
    transformer.setOutputProperty(OutputKeys.ENCODING,""String_Node_Str"");
    transformer.setOutputProperty(OutputKeys.INDENT,""String_Node_Str"");
    final String decl=""String_Node_Str"";
    StringWriter tempWriter=new StringWriter();
    StreamResult tempResult=new StreamResult(tempWriter);
    transformer.transform(new DOMSource(node),tempResult);
    String[] tempLines=PApplet.split(tempWriter.toString(),'\n');
    PApplet.println(tempLines);
    if (tempLines[0].startsWith(decl)) {
      int declEnd=tempLines[0].indexOf(""String_Node_Str"") + 2;
      if (tempLines[0].length() == declEnd) {
        PApplet.println(""String_Node_Str"");
        tempLines=PApplet.subset(tempLines,1);
      }
 else {
        PApplet.println(""String_Node_Str"");
        tempLines[0]=tempLines[0].substring(declEnd);
      }
    }
    String singleLine=PApplet.join(PApplet.trim(tempLines),""String_Node_Str"");
    if (indent == -1) {
      return singleLine;
    }
    StringWriter stringWriter=new StringWriter();
    StreamResult xmlOutput=new StreamResult(stringWriter);
    Source source=new StreamSource(new StringReader(singleLine));
    transformer.transform(source,xmlOutput);
    return decl + ""String_Node_Str"" + stringWriter.toString();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}","/** 
 * Format this XML data as a String.
 * @webref xml:method
 * @brief Formats XML data as a String
 * @param indent -1 for a single line (and no declaration), >= 0 for indents and newlines
 * @return the content
 * @see XML#toString()
 */
public String format(int indent){
  try {
    boolean useIndentAmount=false;
    TransformerFactory factory=TransformerFactory.newInstance();
    if (indent != -1) {
      try {
        factory.setAttribute(""String_Node_Str"",indent);
      }
 catch (      IllegalArgumentException e) {
        useIndentAmount=true;
      }
    }
    Transformer transformer=factory.newTransformer();
    if (indent == -1 || parent == null) {
      transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION,""String_Node_Str"");
    }
 else {
      transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION,""String_Node_Str"");
    }
    transformer.setOutputProperty(OutputKeys.METHOD,""String_Node_Str"");
    if (useIndentAmount) {
      transformer.setOutputProperty(""String_Node_Str"",String.valueOf(indent));
    }
    transformer.setOutputProperty(OutputKeys.ENCODING,""String_Node_Str"");
    transformer.setOutputProperty(OutputKeys.INDENT,""String_Node_Str"");
    final String decl=""String_Node_Str"";
    final String sep=System.getProperty(""String_Node_Str"");
    StringWriter tempWriter=new StringWriter();
    StreamResult tempResult=new StreamResult(tempWriter);
    transformer.transform(new DOMSource(node),tempResult);
    String[] tempLines=PApplet.split(tempWriter.toString(),sep);
    if (tempLines[0].startsWith(""String_Node_Str"")) {
      int declEnd=tempLines[0].indexOf(""String_Node_Str"") + 2;
      if (tempLines[0].length() == declEnd) {
        tempLines=PApplet.subset(tempLines,1);
      }
 else {
        tempLines[0]=tempLines[0].substring(declEnd);
      }
    }
    String singleLine=PApplet.join(PApplet.trim(tempLines),""String_Node_Str"");
    if (indent == -1) {
      return singleLine;
    }
    StringWriter stringWriter=new StringWriter();
    StreamResult xmlOutput=new StreamResult(stringWriter);
    Source source=new StreamSource(new StringReader(singleLine));
    transformer.transform(source,xmlOutput);
    return decl + sep + stringWriter.toString();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}",0.9467353951890034
163654,"private final float cos(float angle){
  return (float)Math.cos(angle);
}","static private final float cos(float angle){
  return (float)Math.cos(angle);
}",0.9536423841059604
163655,"private final float sin(float angle){
  return (float)Math.sin(angle);
}","static private final float sin(float angle){
  return (float)Math.sin(angle);
}",0.9536423841059604
163656,"private final float max(float a,float b){
  return (a > b) ? a : b;
}","static private final float max(float a,float b){
  return (a > b) ? a : b;
}",0.9517241379310344
163657,"private final float abs(float a){
  return (a < 0) ? -a : a;
}","static private final float abs(float a){
  return (a < 0) ? -a : a;
}",0.9465648854961832
163658,"protected void parsePath(){
  family=PATH;
  kind=0;
  String pathData=element.getString(""String_Node_Str"");
  if (pathData == null || PApplet.trim(pathData).length() == 0) {
    return;
  }
  char[] pathDataChars=pathData.toCharArray();
  StringBuffer pathBuffer=new StringBuffer();
  boolean lastSeparate=false;
  for (int i=0; i < pathDataChars.length; i++) {
    char c=pathDataChars[i];
    boolean separate=false;
    if (c == 'M' || c == 'm' || c == 'L' || c == 'l' || c == 'H' || c == 'h' || c == 'V' || c == 'v' || c == 'C' || c == 'c' || c == 'S' || c == 's' || c == 'Q' || c == 'q' || c == 'T' || c == 't' || c == 'Z' || c == 'z' || c == ',') {
      separate=true;
      if (i != 0) {
        pathBuffer.append(""String_Node_Str"");
      }
    }
    if (c == 'Z' || c == 'z') {
      separate=false;
    }
    if (c == '-' && !lastSeparate) {
      if (i == 0 || pathDataChars[i - 1] != 'e') {
        pathBuffer.append(""String_Node_Str"");
      }
    }
    if (c != ',') {
      pathBuffer.append(c);
    }
    if (separate && c != ',' && c != '-') {
      pathBuffer.append(""String_Node_Str"");
    }
    lastSeparate=separate;
  }
  String[] pathTokens=PApplet.splitTokens(pathBuffer.toString(),""String_Node_Str"" + WHITESPACE);
  vertices=new float[pathTokens.length][2];
  vertexCodes=new int[pathTokens.length];
  float cx=0;
  float cy=0;
  int i=0;
  char implicitCommand='\0';
  boolean prevCurve=false;
  float ctrlX, ctrlY;
  while (i < pathTokens.length) {
    char c=pathTokens[i].charAt(0);
    if (((c >= '0' && c <= '9') || (c == '-')) && implicitCommand != '\0') {
      c=implicitCommand;
      i--;
    }
 else {
      implicitCommand=c;
    }
switch (c) {
case 'M':
      cx=PApplet.parseFloat(pathTokens[i + 1]);
    cy=PApplet.parseFloat(pathTokens[i + 2]);
  parsePathMoveto(cx,cy);
implicitCommand='L';
i+=3;
break;
case 'm':
cx=cx + PApplet.parseFloat(pathTokens[i + 1]);
cy=cy + PApplet.parseFloat(pathTokens[i + 2]);
parsePathMoveto(cx,cy);
implicitCommand='l';
i+=3;
break;
case 'L':
cx=PApplet.parseFloat(pathTokens[i + 1]);
cy=PApplet.parseFloat(pathTokens[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'l':
cx=cx + PApplet.parseFloat(pathTokens[i + 1]);
cy=cy + PApplet.parseFloat(pathTokens[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'H':
cx=PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'h':
cx=cx + PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'V':
cy=PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'v':
cy=cy + PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'C':
{
float ctrlX1=PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY1=PApplet.parseFloat(pathTokens[i + 2]);
float ctrlX2=PApplet.parseFloat(pathTokens[i + 3]);
float ctrlY2=PApplet.parseFloat(pathTokens[i + 4]);
float endX=PApplet.parseFloat(pathTokens[i + 5]);
float endY=PApplet.parseFloat(pathTokens[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
prevCurve=true;
}
break;
case 'c':
{
float ctrlX1=cx + PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY1=cy + PApplet.parseFloat(pathTokens[i + 2]);
float ctrlX2=cx + PApplet.parseFloat(pathTokens[i + 3]);
float ctrlY2=cy + PApplet.parseFloat(pathTokens[i + 4]);
float endX=cx + PApplet.parseFloat(pathTokens[i + 5]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
prevCurve=true;
}
break;
case 'S':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float ctrlX2=PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY2=PApplet.parseFloat(pathTokens[i + 2]);
float endX=PApplet.parseFloat(pathTokens[i + 3]);
float endY=PApplet.parseFloat(pathTokens[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 's':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float ctrlX2=cx + PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY2=cy + PApplet.parseFloat(pathTokens[i + 2]);
float endX=cx + PApplet.parseFloat(pathTokens[i + 3]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 'Q':
{
ctrlX=PApplet.parseFloat(pathTokens[i + 1]);
ctrlY=PApplet.parseFloat(pathTokens[i + 2]);
float endX=PApplet.parseFloat(pathTokens[i + 3]);
float endY=PApplet.parseFloat(pathTokens[i + 4]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 'q':
{
ctrlX=cx + PApplet.parseFloat(pathTokens[i + 1]);
ctrlY=cy + PApplet.parseFloat(pathTokens[i + 2]);
float endX=cx + PApplet.parseFloat(pathTokens[i + 3]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 4]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 'T':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float endX=PApplet.parseFloat(pathTokens[i + 1]);
float endY=PApplet.parseFloat(pathTokens[i + 2]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
prevCurve=true;
}
break;
case 't':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float endX=cx + PApplet.parseFloat(pathTokens[i + 1]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 2]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
prevCurve=true;
}
break;
case 'Z':
case 'z':
close=true;
i++;
break;
default :
String parsed=PApplet.join(PApplet.subset(pathTokens,0,i),""String_Node_Str"");
String unparsed=PApplet.join(PApplet.subset(pathTokens,i),""String_Node_Str"");
System.err.println(""String_Node_Str"" + parsed);
System.err.println(""String_Node_Str"" + unparsed);
if (pathTokens[i].equals(""String_Node_Str"") || pathTokens[i].equals(""String_Node_Str"")) {
String msg=""String_Node_Str"" + ""String_Node_Str"";
throw new RuntimeException(msg);
}
throw new RuntimeException(""String_Node_Str"" + pathTokens[i]);
}
}
}","protected void parsePath(){
  family=PATH;
  kind=0;
  String pathData=element.getString(""String_Node_Str"");
  if (pathData == null || PApplet.trim(pathData).length() == 0) {
    return;
  }
  char[] pathDataChars=pathData.toCharArray();
  StringBuffer pathBuffer=new StringBuffer();
  boolean lastSeparate=false;
  for (int i=0; i < pathDataChars.length; i++) {
    char c=pathDataChars[i];
    boolean separate=false;
    if (c == 'M' || c == 'm' || c == 'L' || c == 'l' || c == 'H' || c == 'h' || c == 'V' || c == 'v' || c == 'C' || c == 'c' || c == 'S' || c == 's' || c == 'Q' || c == 'q' || c == 'T' || c == 't' || c == 'Z' || c == 'z' || c == ',') {
      separate=true;
      if (i != 0) {
        pathBuffer.append(""String_Node_Str"");
      }
    }
    if (c == 'Z' || c == 'z') {
      separate=false;
    }
    if (c == '-' && !lastSeparate) {
      if (i == 0 || pathDataChars[i - 1] != 'e') {
        pathBuffer.append(""String_Node_Str"");
      }
    }
    if (c != ',') {
      pathBuffer.append(c);
    }
    if (separate && c != ',' && c != '-') {
      pathBuffer.append(""String_Node_Str"");
    }
    lastSeparate=separate;
  }
  String[] pathTokens=PApplet.splitTokens(pathBuffer.toString(),""String_Node_Str"" + WHITESPACE);
  vertices=new float[pathTokens.length][2];
  vertexCodes=new int[pathTokens.length];
  float cx=0;
  float cy=0;
  int i=0;
  char implicitCommand='\0';
  boolean prevCurve=false;
  float ctrlX, ctrlY;
  float movetoX=0;
  float movetoY=0;
  while (i < pathTokens.length) {
    char c=pathTokens[i].charAt(0);
    if (((c >= '0' && c <= '9') || (c == '-')) && implicitCommand != '\0') {
      c=implicitCommand;
      i--;
    }
 else {
      implicitCommand=c;
    }
switch (c) {
case 'M':
      cx=PApplet.parseFloat(pathTokens[i + 1]);
    cy=PApplet.parseFloat(pathTokens[i + 2]);
  movetoX=cx;
movetoY=cy;
parsePathMoveto(cx,cy);
implicitCommand='L';
i+=3;
break;
case 'm':
cx=cx + PApplet.parseFloat(pathTokens[i + 1]);
cy=cy + PApplet.parseFloat(pathTokens[i + 2]);
parsePathMoveto(cx,cy);
implicitCommand='l';
i+=3;
break;
case 'L':
cx=PApplet.parseFloat(pathTokens[i + 1]);
cy=PApplet.parseFloat(pathTokens[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'l':
cx=cx + PApplet.parseFloat(pathTokens[i + 1]);
cy=cy + PApplet.parseFloat(pathTokens[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'H':
cx=PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'h':
cx=cx + PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'V':
cy=PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'v':
cy=cy + PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'C':
{
float ctrlX1=PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY1=PApplet.parseFloat(pathTokens[i + 2]);
float ctrlX2=PApplet.parseFloat(pathTokens[i + 3]);
float ctrlY2=PApplet.parseFloat(pathTokens[i + 4]);
float endX=PApplet.parseFloat(pathTokens[i + 5]);
float endY=PApplet.parseFloat(pathTokens[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
prevCurve=true;
}
break;
case 'c':
{
float ctrlX1=cx + PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY1=cy + PApplet.parseFloat(pathTokens[i + 2]);
float ctrlX2=cx + PApplet.parseFloat(pathTokens[i + 3]);
float ctrlY2=cy + PApplet.parseFloat(pathTokens[i + 4]);
float endX=cx + PApplet.parseFloat(pathTokens[i + 5]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
prevCurve=true;
}
break;
case 'S':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float ctrlX2=PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY2=PApplet.parseFloat(pathTokens[i + 2]);
float endX=PApplet.parseFloat(pathTokens[i + 3]);
float endY=PApplet.parseFloat(pathTokens[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 's':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float ctrlX2=cx + PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY2=cy + PApplet.parseFloat(pathTokens[i + 2]);
float endX=cx + PApplet.parseFloat(pathTokens[i + 3]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 'Q':
{
ctrlX=PApplet.parseFloat(pathTokens[i + 1]);
ctrlY=PApplet.parseFloat(pathTokens[i + 2]);
float endX=PApplet.parseFloat(pathTokens[i + 3]);
float endY=PApplet.parseFloat(pathTokens[i + 4]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 'q':
{
ctrlX=cx + PApplet.parseFloat(pathTokens[i + 1]);
ctrlY=cy + PApplet.parseFloat(pathTokens[i + 2]);
float endX=cx + PApplet.parseFloat(pathTokens[i + 3]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 4]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 'T':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float endX=PApplet.parseFloat(pathTokens[i + 1]);
float endY=PApplet.parseFloat(pathTokens[i + 2]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
prevCurve=true;
}
break;
case 't':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float endX=cx + PApplet.parseFloat(pathTokens[i + 1]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 2]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
prevCurve=true;
}
break;
case 'Z':
case 'z':
cx=movetoX;
cy=movetoY;
close=true;
i++;
break;
default :
String parsed=PApplet.join(PApplet.subset(pathTokens,0,i),""String_Node_Str"");
String unparsed=PApplet.join(PApplet.subset(pathTokens,i),""String_Node_Str"");
System.err.println(""String_Node_Str"" + parsed);
System.err.println(""String_Node_Str"" + unparsed);
if (pathTokens[i].equals(""String_Node_Str"") || pathTokens[i].equals(""String_Node_Str"")) {
String msg=""String_Node_Str"" + ""String_Node_Str"";
throw new RuntimeException(msg);
}
throw new RuntimeException(""String_Node_Str"" + pathTokens[i]);
}
}
}",0.9936903888481292
163659,"protected void beginDraw(boolean clear0){
  if (!clear0 && glColorFbo[0] != 0) {
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,glColorFbo[0]);
    GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER,GLES20.GL_COLOR_ATTACHMENT0,GLES20.GL_TEXTURE_2D,glColorTex[backTex],0);
    usingFBOlayer=true;
  }
 else {
    usingFBOlayer=false;
  }
}","protected void beginDraw(boolean clear0){
  if ((!clear0 || FORCE_SCREEN_FBO) && glColorFbo[0] != 0) {
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,glColorFbo[0]);
    GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER,GLES20.GL_COLOR_ATTACHMENT0,GLES20.GL_TEXTURE_2D,glColorTex[backTex],0);
    if (firstFrame) {
      GLES20.glClearColor(0,0,0,0);
      GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
    }
 else     if (!clear0) {
      drawTexture(GLES20.GL_TEXTURE_2D,glColorTex[frontTex],fboWidth,fboHeight,0,0,pg.width,pg.height,0,0,pg.width,pg.height);
    }
    usingFBOlayer=true;
  }
 else {
    usingFBOlayer=false;
  }
  if (firstFrame) {
    firstFrame=false;
  }
}",0.6647173489278753
163660,"protected void endDraw(boolean clear){
  if (usingFBOlayer) {
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,0);
    GLES20.glClearDepthf(1);
    GLES20.glClearColor(0,0,0,0);
    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
    GLES20.glDisable(GLES20.GL_BLEND);
    drawTexture(GLES20.GL_TEXTURE_2D,glColorTex[backTex],fboWidth,fboHeight,0,0,pg.width,pg.height,0,0,pg.width,pg.height);
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,glColorFbo[0]);
    if (!clear) {
      GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER,GLES20.GL_COLOR_ATTACHMENT0,GLES20.GL_TEXTURE_2D,glColorTex[frontTex],0);
      drawTexture(GLES20.GL_TEXTURE_2D,glColorTex[backTex],fboWidth,fboHeight,0,0,pg.width,pg.height,0,0,pg.width,pg.height);
      GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER,GLES20.GL_COLOR_ATTACHMENT0,GLES20.GL_TEXTURE_2D,glColorTex[backTex],0);
    }
    int temp=frontTex;
    frontTex=backTex;
    backTex=temp;
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,0);
  }
}","protected void endDraw(boolean clear){
  if (usingFBOlayer) {
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,0);
    GLES20.glClearDepthf(1);
    GLES20.glClearColor(0,0,0,0);
    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
    GLES20.glDisable(GLES20.GL_BLEND);
    drawTexture(GLES20.GL_TEXTURE_2D,glColorTex[backTex],fboWidth,fboHeight,0,0,pg.width,pg.height,0,0,pg.width,pg.height);
    int temp=frontTex;
    frontTex=backTex;
    backTex=temp;
  }
}",0.5876902713434812
163661,"protected void update(){
  if (!initialized) {
    String ext=GLES20.glGetString(GLES20.GL_EXTENSIONS);
    if (-1 < ext.indexOf(""String_Node_Str"")) {
      fboWidth=pg.width;
      fboHeight=pg.height;
    }
 else {
      fboWidth=PGL.nextPowerOfTwo(pg.width);
      fboHeight=PGL.nextPowerOfTwo(pg.height);
    }
    boolean packed=ext.indexOf(""String_Node_Str"") != -1;
    GLES20.glGenTextures(2,glColorTex,0);
    for (int i=0; i < 2; i++) {
      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,glColorTex[i]);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MIN_FILTER,GLES20.GL_NEAREST);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MAG_FILTER,GLES20.GL_NEAREST);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_S,GLES20.GL_CLAMP_TO_EDGE);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_T,GLES20.GL_CLAMP_TO_EDGE);
      GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,0,GLES20.GL_RGBA,fboWidth,fboHeight,0,PGL.RGBA,PGL.UNSIGNED_BYTE,null);
      initTexture(GLES20.GL_TEXTURE_2D,PGL.RGBA,fboWidth,fboHeight);
    }
    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,0);
    GLES20.glGenFramebuffers(1,glColorFbo,0);
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,glColorFbo[0]);
    GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER,GLES20.GL_COLOR_ATTACHMENT0,GLES20.GL_TEXTURE_2D,glColorTex[0],0);
    if (packed) {
      int[] depthStencil={0};
      GLES20.glGenRenderbuffers(1,depthStencil,0);
      GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER,depthStencil[0]);
      GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER,DEPTH24_STENCIL8,fboWidth,fboHeight);
      GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_DEPTH_ATTACHMENT,GLES20.GL_RENDERBUFFER,depthStencil[0]);
      GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_STENCIL_ATTACHMENT,GLES20.GL_RENDERBUFFER,depthStencil[0]);
    }
 else {
      int[] depth={0};
      int[] stencil={0};
      GLES20.glGenRenderbuffers(1,depth,0);
      GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER,depth[0]);
      GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER,GLES20.GL_DEPTH_COMPONENT16,fboWidth,fboHeight);
      GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_DEPTH_ATTACHMENT,GLES20.GL_RENDERBUFFER,depth[0]);
      int[] temp=new int[1];
      GLES20.glGetIntegerv(GLES20.GL_STENCIL_BITS,temp,0);
      int stencilBits=temp[0];
      if (stencilBits == 8) {
        GLES20.glGenRenderbuffers(1,stencil,0);
        GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER,stencil[0]);
        GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER,GLES20.GL_STENCIL_INDEX8,fboWidth,fboHeight);
        GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_STENCIL_ATTACHMENT,GLES20.GL_RENDERBUFFER,stencil[0]);
      }
    }
    validateFramebuffer();
    GLES20.glClearDepthf(1);
    GLES20.glClearStencil(0);
    GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_STENCIL_BUFFER_BIT);
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,0);
    PGraphicsOpenGL.drawFramebuffer.glFbo=0;
    backTex=0;
    frontTex=1;
    initialized=true;
  }
}","protected void update(){
  if (!initialized) {
    String ext=GLES20.glGetString(GLES20.GL_EXTENSIONS);
    if (-1 < ext.indexOf(""String_Node_Str"")) {
      fboWidth=pg.width;
      fboHeight=pg.height;
    }
 else {
      fboWidth=PGL.nextPowerOfTwo(pg.width);
      fboHeight=PGL.nextPowerOfTwo(pg.height);
    }
    boolean packed=ext.indexOf(""String_Node_Str"") != -1;
    int depthBits=getDepthBits();
    int stencilBits=getStencilBits();
    GLES20.glGenTextures(2,glColorTex,0);
    for (int i=0; i < 2; i++) {
      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,glColorTex[i]);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MIN_FILTER,GLES20.GL_NEAREST);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MAG_FILTER,GLES20.GL_NEAREST);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_S,GLES20.GL_CLAMP_TO_EDGE);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_T,GLES20.GL_CLAMP_TO_EDGE);
      GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,0,GLES20.GL_RGBA,fboWidth,fboHeight,0,PGL.RGBA,PGL.UNSIGNED_BYTE,null);
      initTexture(GLES20.GL_TEXTURE_2D,PGL.RGBA,fboWidth,fboHeight);
    }
    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,0);
    backTex=0;
    frontTex=1;
    GLES20.glGenFramebuffers(1,glColorFbo,0);
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,glColorFbo[0]);
    GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER,GLES20.GL_COLOR_ATTACHMENT0,GLES20.GL_TEXTURE_2D,glColorTex[backTex],0);
    if (packed && depthBits == 24 && stencilBits == 8) {
      int[] depthStencil={0};
      GLES20.glGenRenderbuffers(1,depthStencil,0);
      GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER,depthStencil[0]);
      GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER,DEPTH24_STENCIL8,fboWidth,fboHeight);
      GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_DEPTH_ATTACHMENT,GLES20.GL_RENDERBUFFER,depthStencil[0]);
      GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_STENCIL_ATTACHMENT,GLES20.GL_RENDERBUFFER,depthStencil[0]);
    }
 else {
      int[] depth={0};
      int[] stencil={0};
      GLES20.glGenRenderbuffers(1,depth,0);
      GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER,depth[0]);
      GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER,GLES20.GL_DEPTH_COMPONENT16,fboWidth,fboHeight);
      GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_DEPTH_ATTACHMENT,GLES20.GL_RENDERBUFFER,depth[0]);
      if (stencilBits == 8) {
        GLES20.glGenRenderbuffers(1,stencil,0);
        GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER,stencil[0]);
        GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER,GLES20.GL_STENCIL_INDEX8,fboWidth,fboHeight);
        GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_STENCIL_ATTACHMENT,GLES20.GL_RENDERBUFFER,stencil[0]);
      }
    }
    validateFramebuffer();
    GLES20.glClearDepthf(1);
    GLES20.glClearStencil(0);
    GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_STENCIL_BUFFER_BIT);
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,0);
    initialized=true;
  }
}",0.9350566459230892
163662,"protected void handleKeyEvent(KeyEvent event){
switch (event.getAction()) {
case KeyEvent.PRESSED:
    keyPressed=true;
  keyPressed();
break;
case KeyEvent.RELEASED:
keyPressed=false;
keyReleased();
break;
}
if (event.getAction() == KeyEvent.PRESSED && event.getKeyCode() == android.view.KeyEvent.KEYCODE_BACK) {
exit();
}
}","protected void handleKeyEvent(KeyEvent event){
switch (event.getAction()) {
case KeyEvent.PRESSED:
    keyPressed=true;
  keyPressed();
break;
case KeyEvent.RELEASED:
keyPressed=false;
keyReleased();
break;
}
handleMethods(""String_Node_Str"",new Object[]{event});
if (event.getAction() == KeyEvent.PRESSED && event.getKeyCode() == android.view.KeyEvent.KEYCODE_BACK) {
exit();
}
}",0.9232954545454546
163663,"static protected void copyGeometry(PShape src,PShape dest){
  copyMatrix(src,dest);
  copyStyles(src,dest);
  copyImage(src,dest);
  if (src.style) {
    for (int i=0; i < src.vertexCount; i++) {
      float[] vert=src.vertices[i];
      dest.normal(vert[PGraphics.NX],vert[PGraphics.NY],vert[PGraphics.NZ]);
      dest.vertex(vert[X],vert[Y],vert[Z],vert[PGraphics.U],vert[PGraphics.V]);
    }
  }
 else {
    for (int i=0; i < src.vertexCount; i++) {
      float[] vert=src.vertices[i];
      if (vert[Z] == 0) {
        dest.vertex(vert[X],vert[Y]);
      }
 else {
        dest.vertex(vert[X],vert[Y],vert[Z]);
      }
    }
  }
  dest.end();
}","static protected void copyGeometry(PShape src,PShape dest){
  copyMatrix(src,dest);
  copyStyles(src,dest);
  copyImage(src,dest);
  if (src.style) {
    for (int i=0; i < src.vertexCount; i++) {
      float[] vert=src.vertices[i];
      dest.fill(vert[PGraphics.R] * 255,vert[PGraphics.G] * 255,vert[PGraphics.B] * 255,vert[PGraphics.A] * 255);
      if (0 < PApplet.dist(vert[PGraphics.NX],vert[PGraphics.NY],vert[PGraphics.NZ],0,0,0)) {
        dest.normal(vert[PGraphics.NX],vert[PGraphics.NY],vert[PGraphics.NZ]);
      }
      dest.vertex(vert[X],vert[Y],vert[Z],vert[PGraphics.U],vert[PGraphics.V]);
    }
  }
 else {
    for (int i=0; i < src.vertexCount; i++) {
      float[] vert=src.vertices[i];
      if (vert[Z] == 0) {
        dest.vertex(vert[X],vert[Y]);
      }
 else {
        dest.vertex(vert[X],vert[Y],vert[Z]);
      }
    }
  }
  dest.end();
}",0.845442536327609
163664,"protected void addChildren(ArrayList<OBJFace> faces,ArrayList<OBJMaterial> materials,ArrayList<PVector> coords,ArrayList<PVector> normals,ArrayList<PVector> texcoords){
  int mtlIdxCur=-1;
  OBJMaterial mtl=null;
  for (int i=0; i < faces.size(); i++) {
    OBJFace face=faces.get(i);
    if (mtlIdxCur != face.matIdx) {
      mtlIdxCur=PApplet.max(0,face.matIdx);
      mtl=materials.get(mtlIdxCur);
    }
    PShape child=new PShapeOBJ(face,mtl,coords,normals,texcoords);
    addChild(child);
  }
}","protected void addChildren(ArrayList<OBJFace> faces,ArrayList<OBJMaterial> materials,ArrayList<PVector> coords,ArrayList<PVector> normals,ArrayList<PVector> texcoords){
  int mtlIdxCur=-1;
  OBJMaterial mtl=null;
  for (int i=0; i < faces.size(); i++) {
    OBJFace face=faces.get(i);
    if (mtlIdxCur != face.matIdx || face.matIdx == -1) {
      mtlIdxCur=PApplet.max(0,face.matIdx);
      mtl=materials.get(mtlIdxCur);
    }
    PShape child=new PShapeOBJ(face,mtl,coords,normals,texcoords);
    addChild(child);
  }
}",0.9794319294809012
163665,"static protected void parseOBJ(PApplet parent,BufferedReader reader,ArrayList<OBJFace> faces,ArrayList<OBJMaterial> materials,ArrayList<PVector> coords,ArrayList<PVector> normals,ArrayList<PVector> texcoords){
  Hashtable<String,Integer> mtlTable=new Hashtable<String,Integer>();
  int mtlIdxCur=-1;
  boolean readv, readvn, readvt;
  try {
    readv=readvn=readvt=false;
    String line;
    String gname=""String_Node_Str"";
    while ((line=reader.readLine()) != null) {
      while (line.contains(""String_Node_Str"")) {
        line=line.split(""String_Node_Str"")[0];
        final String s=reader.readLine();
        if (s != null)         line+=s;
      }
      String[] parts=line.split(""String_Node_Str"");
      if (parts.length > 0) {
        if (parts[0].equals(""String_Node_Str"")) {
          PVector tempv=new PVector(Float.valueOf(parts[1]).floatValue(),Float.valueOf(parts[2]).floatValue(),Float.valueOf(parts[3]).floatValue());
          coords.add(tempv);
          readv=true;
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          PVector tempn=new PVector(Float.valueOf(parts[1]).floatValue(),Float.valueOf(parts[2]).floatValue(),Float.valueOf(parts[3]).floatValue());
          normals.add(tempn);
          readvn=true;
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          PVector tempv=new PVector(Float.valueOf(parts[1]).floatValue(),1 - Float.valueOf(parts[2]).floatValue());
          texcoords.add(tempv);
          readvt=true;
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          if (parts[1] != null) {
            BufferedReader mreader=parent.createReader(parts[1]);
            if (mreader != null) {
              parseMTL(parent,mreader,materials,mtlTable);
            }
          }
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          gname=1 < parts.length ? parts[1] : ""String_Node_Str"";
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          if (parts[1] != null) {
            String mtlname=parts[1];
            if (mtlTable.containsKey(mtlname)) {
              Integer tempInt=mtlTable.get(mtlname);
              mtlIdxCur=tempInt.intValue();
            }
 else {
              mtlIdxCur=-1;
            }
          }
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          OBJFace face=new OBJFace();
          face.matIdx=mtlIdxCur;
          face.name=gname;
          for (int i=1; i < parts.length; i++) {
            String seg=parts[i];
            if (seg.indexOf(""String_Node_Str"") > 0) {
              String[] forder=seg.split(""String_Node_Str"");
              if (forder.length > 2) {
                if (forder[0].length() > 0 && readv) {
                  face.vertIdx.add(Integer.valueOf(forder[0]));
                }
                if (forder[1].length() > 0 && readvt) {
                  face.texIdx.add(Integer.valueOf(forder[1]));
                }
                if (forder[2].length() > 0 && readvn) {
                  face.normIdx.add(Integer.valueOf(forder[2]));
                }
              }
 else               if (forder.length > 1) {
                if (forder[0].length() > 0 && readv) {
                  face.vertIdx.add(Integer.valueOf(forder[0]));
                }
                if (forder[1].length() > 0) {
                  if (readvt) {
                    face.texIdx.add(Integer.valueOf(forder[1]));
                  }
 else                   if (readvn) {
                    face.normIdx.add(Integer.valueOf(forder[1]));
                  }
                }
              }
 else               if (forder.length > 0) {
                if (forder[0].length() > 0 && readv) {
                  face.vertIdx.add(Integer.valueOf(forder[0]));
                }
              }
            }
 else {
              if (seg.length() > 0 && readv) {
                face.vertIdx.add(Integer.valueOf(seg));
              }
            }
          }
          faces.add(face);
        }
      }
    }
    if (materials.size() == 0) {
      OBJMaterial defMtl=new OBJMaterial();
      materials.add(defMtl);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","static protected void parseOBJ(PApplet parent,BufferedReader reader,ArrayList<OBJFace> faces,ArrayList<OBJMaterial> materials,ArrayList<PVector> coords,ArrayList<PVector> normals,ArrayList<PVector> texcoords){
  Hashtable<String,Integer> mtlTable=new Hashtable<String,Integer>();
  int mtlIdxCur=-1;
  boolean readv, readvn, readvt;
  try {
    readv=readvn=readvt=false;
    String line;
    String gname=""String_Node_Str"";
    while ((line=reader.readLine()) != null) {
      line=line.trim();
      if (line.equals(""String_Node_Str"") || line.indexOf('#') == 0) {
        continue;
      }
      while (line.contains(""String_Node_Str"")) {
        line=line.split(""String_Node_Str"")[0];
        final String s=reader.readLine();
        if (s != null)         line+=s;
      }
      String[] parts=line.split(""String_Node_Str"");
      if (parts.length > 0) {
        if (parts[0].equals(""String_Node_Str"")) {
          PVector tempv=new PVector(Float.valueOf(parts[1]).floatValue(),Float.valueOf(parts[2]).floatValue(),Float.valueOf(parts[3]).floatValue());
          coords.add(tempv);
          readv=true;
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          PVector tempn=new PVector(Float.valueOf(parts[1]).floatValue(),Float.valueOf(parts[2]).floatValue(),Float.valueOf(parts[3]).floatValue());
          normals.add(tempn);
          readvn=true;
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          PVector tempv=new PVector(Float.valueOf(parts[1]).floatValue(),1 - Float.valueOf(parts[2]).floatValue());
          texcoords.add(tempv);
          readvt=true;
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          if (parts[1] != null) {
            BufferedReader mreader=parent.createReader(parts[1]);
            if (mreader != null) {
              parseMTL(parent,mreader,materials,mtlTable);
            }
          }
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          gname=1 < parts.length ? parts[1] : ""String_Node_Str"";
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          if (parts[1] != null) {
            String mtlname=parts[1];
            if (mtlTable.containsKey(mtlname)) {
              Integer tempInt=mtlTable.get(mtlname);
              mtlIdxCur=tempInt.intValue();
            }
 else {
              mtlIdxCur=-1;
            }
          }
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          OBJFace face=new OBJFace();
          face.matIdx=mtlIdxCur;
          face.name=gname;
          for (int i=1; i < parts.length; i++) {
            String seg=parts[i];
            if (seg.indexOf(""String_Node_Str"") > 0) {
              String[] forder=seg.split(""String_Node_Str"");
              if (forder.length > 2) {
                if (forder[0].length() > 0 && readv) {
                  face.vertIdx.add(Integer.valueOf(forder[0]));
                }
                if (forder[1].length() > 0 && readvt) {
                  face.texIdx.add(Integer.valueOf(forder[1]));
                }
                if (forder[2].length() > 0 && readvn) {
                  face.normIdx.add(Integer.valueOf(forder[2]));
                }
              }
 else               if (forder.length > 1) {
                if (forder[0].length() > 0 && readv) {
                  face.vertIdx.add(Integer.valueOf(forder[0]));
                }
                if (forder[1].length() > 0) {
                  if (readvt) {
                    face.texIdx.add(Integer.valueOf(forder[1]));
                  }
 else                   if (readvn) {
                    face.normIdx.add(Integer.valueOf(forder[1]));
                  }
                }
              }
 else               if (forder.length > 0) {
                if (forder[0].length() > 0 && readv) {
                  face.vertIdx.add(Integer.valueOf(forder[0]));
                }
              }
            }
 else {
              if (seg.length() > 0 && readv) {
                face.vertIdx.add(Integer.valueOf(seg));
              }
            }
          }
          faces.add(face);
        }
      }
    }
    if (materials.size() == 0) {
      OBJMaterial defMtl=new OBJMaterial();
      materials.add(defMtl);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9860917941585536
163666,"protected PShapeOBJ(OBJFace face,OBJMaterial mtl,ArrayList<PVector> coords,ArrayList<PVector> normals,ArrayList<PVector> texcoords){
  family=GEOMETRY;
  if (face.vertIdx.size() == 3) {
    kind=TRIANGLES;
  }
 else   if (face.vertIdx.size() == 4) {
    kind=QUADS;
  }
 else {
    kind=POLYGON;
  }
  fillColor=rgbaValue(mtl.kd);
  ambientColor=rgbaValue(mtl.ka);
  specularColor=rgbaValue(mtl.ks);
  shininess=mtl.ns;
  if (mtl.kdMap != null) {
    tintColor=rgbaValue(mtl.kd,mtl.d);
  }
  vertexCount=face.vertIdx.size();
  vertices=new float[vertexCount][12];
  for (int j=0; j < face.vertIdx.size(); j++) {
    int vertIdx, normIdx;
    PVector vert, norms;
    vert=norms=null;
    vertIdx=face.vertIdx.get(j).intValue() - 1;
    vert=coords.get(vertIdx);
    if (j < face.normIdx.size()) {
      normIdx=face.normIdx.get(j).intValue() - 1;
      if (-1 < normIdx) {
        norms=normals.get(normIdx);
      }
    }
    vertices[j][X]=vert.x;
    vertices[j][Y]=vert.y;
    vertices[j][Z]=vert.z;
    vertices[j][PGraphics.R]=mtl.kd.x;
    vertices[j][PGraphics.B]=mtl.kd.y;
    vertices[j][PGraphics.G]=mtl.kd.z;
    vertices[j][PGraphics.A]=1;
    if (norms != null) {
      vertices[j][PGraphics.NX]=norms.x;
      vertices[j][PGraphics.NY]=norms.y;
      vertices[j][PGraphics.NZ]=norms.z;
    }
    if (mtl != null && mtl.kdMap != null) {
      int texIdx;
      PVector tex=null;
      if (j < face.texIdx.size()) {
        texIdx=face.texIdx.get(j).intValue() - 1;
        if (-1 < texIdx) {
          tex=texcoords.get(texIdx);
        }
      }
      image=mtl.kdMap;
      if (tex != null) {
        vertices[j][PGraphics.U]=tex.x;
        vertices[j][PGraphics.V]=tex.y;
      }
    }
  }
}","protected PShapeOBJ(OBJFace face,OBJMaterial mtl,ArrayList<PVector> coords,ArrayList<PVector> normals,ArrayList<PVector> texcoords){
  family=GEOMETRY;
  if (face.vertIdx.size() == 3) {
    kind=TRIANGLES;
  }
 else   if (face.vertIdx.size() == 4) {
    kind=QUADS;
  }
 else {
    kind=POLYGON;
  }
  stroke=false;
  fill=true;
  fillColor=rgbaValue(mtl.kd);
  ambientColor=rgbaValue(mtl.ka);
  specularColor=rgbaValue(mtl.ks);
  shininess=mtl.ns;
  if (mtl.kdMap != null) {
    tintColor=rgbaValue(mtl.kd,mtl.d);
  }
  vertexCount=face.vertIdx.size();
  vertices=new float[vertexCount][12];
  for (int j=0; j < face.vertIdx.size(); j++) {
    int vertIdx, normIdx;
    PVector vert, norms;
    vert=norms=null;
    vertIdx=face.vertIdx.get(j).intValue() - 1;
    vert=coords.get(vertIdx);
    if (j < face.normIdx.size()) {
      normIdx=face.normIdx.get(j).intValue() - 1;
      if (-1 < normIdx) {
        norms=normals.get(normIdx);
      }
    }
    vertices[j][X]=vert.x;
    vertices[j][Y]=vert.y;
    vertices[j][Z]=vert.z;
    vertices[j][PGraphics.R]=mtl.kd.x;
    vertices[j][PGraphics.G]=mtl.kd.y;
    vertices[j][PGraphics.B]=mtl.kd.z;
    vertices[j][PGraphics.A]=1;
    if (norms != null) {
      vertices[j][PGraphics.NX]=norms.x;
      vertices[j][PGraphics.NY]=norms.y;
      vertices[j][PGraphics.NZ]=norms.z;
    }
    if (mtl != null && mtl.kdMap != null) {
      int texIdx;
      PVector tex=null;
      if (j < face.texIdx.size()) {
        texIdx=face.texIdx.get(j).intValue() - 1;
        if (-1 < texIdx) {
          tex=texcoords.get(texIdx);
        }
      }
      image=mtl.kdMap;
      if (tex != null) {
        vertices[j][PGraphics.U]=tex.x;
        vertices[j][PGraphics.V]=tex.y;
      }
    }
  }
}",0.990420899854862
163667,"static protected PShape loadShapeImpl(PGraphics pg,String filename,String extension){
  PShapeOBJ obj=null;
  if (extension.equals(""String_Node_Str"")) {
    obj=new PShapeOBJ(pg.parent,filename);
  }
 else   if (extension.equals(""String_Node_Str"")) {
    try {
      InputStream input=new GZIPInputStream(pg.parent.createInput(filename));
      obj=new PShapeOBJ(pg.parent,PApplet.createReader(input));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  if (obj != null) {
    boolean prevStroke=pg.stroke;
    int prevTextureMode=pg.textureMode;
    pg.stroke=false;
    pg.textureMode=NORMAL;
    PShapeOpenGL p3d=PShapeOpenGL.createShape3D(pg.parent,obj);
    pg.stroke=prevStroke;
    pg.textureMode=prevTextureMode;
    return p3d;
  }
 else {
    return null;
  }
}","static protected PShape loadShapeImpl(PGraphics pg,String filename,String extension){
  PShapeOBJ obj=null;
  if (extension.equals(""String_Node_Str"")) {
    obj=new PShapeOBJ(pg.parent,filename);
  }
 else   if (extension.equals(""String_Node_Str"")) {
    try {
      InputStream input=new GZIPInputStream(pg.parent.createInput(filename));
      obj=new PShapeOBJ(pg.parent,PApplet.createReader(input));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  if (obj != null) {
    int prevTextureMode=pg.textureMode;
    pg.textureMode=NORMAL;
    PShapeOpenGL p3d=PShapeOpenGL.createShape3D(pg.parent,obj);
    pg.textureMode=prevTextureMode;
    return p3d;
  }
 else {
    return null;
  }
}",0.9461077844311376
163668,"protected int getTypeFromVertexShader(String filename){
  String[] source=parent.loadStrings(filename);
  Pattern pointPattern=Pattern.compile(""String_Node_Str"");
  Pattern linePattern=Pattern.compile(""String_Node_Str"");
  Pattern lightPattern1=Pattern.compile(""String_Node_Str"");
  Pattern lightPattern2=Pattern.compile(""String_Node_Str"");
  Pattern texPattern=Pattern.compile(""String_Node_Str"");
  int type=PShader.COLOR;
  for (int i=0; i < source.length; i++) {
    boolean foundPoint=pointPattern.matcher(source[i]).find();
    boolean foundLine=linePattern.matcher(source[i]).find();
    boolean foundLight=lightPattern1.matcher(source[i]).find() || lightPattern2.matcher(source[i]).find();
    boolean foundTex=texPattern.matcher(source[i]).find();
    if (foundPoint) {
      type=PShader.POINT;
    }
 else     if (foundLine) {
      type=PShader.LINE;
    }
 else     if (foundLight && foundTex) {
      type=PShader.TEXLIGHT;
    }
 else     if (foundLight) {
      type=PShader.LIGHT;
    }
 else     if (foundTex) {
      type=PShader.TEXTURE;
    }
    if (type != PShader.COLOR)     break;
  }
  return type;
}","protected int getTypeFromVertexShader(String filename){
  String[] source=parent.loadStrings(filename);
  Pattern pointPattern=Pattern.compile(""String_Node_Str"");
  Pattern linePattern=Pattern.compile(""String_Node_Str"");
  Pattern lightPattern1=Pattern.compile(""String_Node_Str"");
  Pattern lightPattern2=Pattern.compile(""String_Node_Str"");
  Pattern texPattern=Pattern.compile(""String_Node_Str"");
  boolean foundPoint=false;
  boolean foundLine=false;
  boolean foundLight=false;
  boolean foundTex=false;
  for (int i=0; i < source.length; i++) {
    foundPoint|=pointPattern.matcher(source[i]).find();
    foundLine|=linePattern.matcher(source[i]).find();
    foundLight|=lightPattern1.matcher(source[i]).find();
    foundLight|=lightPattern2.matcher(source[i]).find();
    foundTex|=texPattern.matcher(source[i]).find();
  }
  int type=PShader.COLOR;
  if (foundPoint) {
    type=PShader.POINT;
  }
 else   if (foundLine) {
    type=PShader.LINE;
  }
 else   if (foundLight && foundTex) {
    type=PShader.TEXLIGHT;
  }
 else   if (foundLight) {
    type=PShader.LIGHT;
  }
 else   if (foundTex) {
    type=PShader.TEXTURE;
  }
  return type;
}",0.6106467223933129
163669,"public final float hue(int what){
  if (what != cacheHsbKey) {
    Color.RGBToHSV((what >> 16) & 0xff,(what >> 8) & 0xff,what & 0xff,cacheHsbValue);
    cacheHsbKey=what;
  }
  return cacheHsbValue[0] * colorModeX;
}","public final float hue(int what){
  if (what != cacheHsbKey) {
    Color.RGBToHSV((what >> 16) & 0xff,(what >> 8) & 0xff,what & 0xff,cacheHsbValue);
    cacheHsbKey=what;
  }
  return (cacheHsbValue[0] / 360f) * colorModeX;
}",0.979591836734694
163670,"protected boolean bufferUpdate(int[] pixels){
  BufferData data=null;
  try {
    data=bufferCache.remove(0);
  }
 catch (  NoSuchElementException ex) {
    PGraphics.showWarning(""String_Node_Str"");
  }
  if (data != null) {
    if ((data.w != width) || (data.h != height)) {
      init(data.w,data.h);
    }
    bind();
    setNative(data.rgbBuf,0,0,width,height);
    unbind();
    data.rgbBuf.get(pixels);
    convertToARGB(pixels);
    data.dispose();
    return true;
  }
 else {
    return false;
  }
}","protected boolean bufferUpdate(int[] pixels){
  BufferData data=null;
  try {
    data=bufferCache.remove(0);
  }
 catch (  NoSuchElementException ex) {
    PGraphics.showWarning(""String_Node_Str"");
  }
  if (data != null) {
    if ((data.w != width) || (data.h != height)) {
      init(data.w,data.h);
    }
    setNative(data.rgbBuf,0,0,width,height);
    data.rgbBuf.get(pixels);
    convertToARGB(pixels);
    data.dispose();
    return true;
  }
 else {
    return false;
  }
}",0.9737373737373738
163671,"public void setFrameRate(float framerate){
  pgl.setFramerate(framerate);
}","public void setFrameRate(float frameRate){
  pgl.setFrameRate(frameRate);
}",0.96
163672,"public Object initCache(PImage img){
  Texture tex=(Texture)img.getCache(pgPrimary);
  if (tex == null || tex.contextIsOutdated()) {
    tex=addTexture(img);
    img.loadPixels();
    tex.set(img.pixels);
  }
  return tex;
}","public Object initCache(PImage img){
  Texture tex=(Texture)img.getCache(pgPrimary);
  if (tex == null || tex.contextIsOutdated()) {
    tex=addTexture(img);
    if (tex != null) {
      img.loadPixels();
      tex.set(img.pixels);
    }
  }
  return tex;
}",0.8814968814968815
163673,"void addArc(float a,float b,float c,float d,float start,float stop,boolean fill,boolean stroke,int ellipseMode){
  float x=a;
  float y=b;
  float w=c;
  float h=d;
  if (ellipseMode == CORNERS) {
    w=c - a;
    h=d - b;
  }
 else   if (ellipseMode == RADIUS) {
    x=a - c;
    y=b - d;
    w=c * 2;
    h=d * 2;
  }
 else   if (ellipseMode == CENTER) {
    x=a - c / 2f;
    y=b - d / 2f;
  }
  if (Float.isInfinite(start) || Float.isInfinite(stop))   return;
  if (stop < start)   return;
  while (start < 0) {
    start+=TWO_PI;
    stop+=TWO_PI;
  }
  if (stop - start > TWO_PI) {
    start=0;
    stop=TWO_PI;
  }
  float hr=w / 2f;
  float vr=h / 2f;
  float centerX=x + hr;
  float centerY=y + vr;
  int startLUT=(int)(0.5f + (start / TWO_PI) * SINCOS_LENGTH);
  int stopLUT=(int)(0.5f + (stop / TWO_PI) * SINCOS_LENGTH);
  if (fill) {
    vertex(centerX,centerY,VERTEX);
  }
  int increment=1;
  int pidx, idx;
  pidx=idx=0;
  for (int i=startLUT; i < stopLUT; i+=increment) {
    int ii=i % SINCOS_LENGTH;
    if (ii < 0)     ii+=SINCOS_LENGTH;
    idx=addVertex(centerX + cosLUT[ii] * hr,centerY + sinLUT[ii] * vr,VERTEX);
    if (0 < i) {
      if (stroke)       addEdge(pidx,idx,i == 1,false);
    }
    pidx=idx;
  }
  idx=addVertex(centerX + cosLUT[stopLUT % SINCOS_LENGTH] * hr,centerY + sinLUT[stopLUT % SINCOS_LENGTH] * vr,VERTEX);
  if (stroke)   addEdge(pidx,idx,false,true);
}","void addArc(float a,float b,float c,float d,float start,float stop,boolean fill,boolean stroke,int ellipseMode){
  float x=a;
  float y=b;
  float w=c;
  float h=d;
  if (ellipseMode == CORNERS) {
    w=c - a;
    h=d - b;
  }
 else   if (ellipseMode == RADIUS) {
    x=a - c;
    y=b - d;
    w=c * 2;
    h=d * 2;
  }
 else   if (ellipseMode == CENTER) {
    x=a - c / 2f;
    y=b - d / 2f;
  }
  if (Float.isInfinite(start) || Float.isInfinite(stop))   return;
  if (stop < start)   return;
  while (start < 0) {
    start+=TWO_PI;
    stop+=TWO_PI;
  }
  if (stop - start > TWO_PI) {
    start=0;
    stop=TWO_PI;
  }
  float hr=w / 2f;
  float vr=h / 2f;
  float centerX=x + hr;
  float centerY=y + vr;
  int startLUT=(int)(0.5f + (start / TWO_PI) * SINCOS_LENGTH);
  int stopLUT=(int)(0.5f + (stop / TWO_PI) * SINCOS_LENGTH);
  if (fill) {
    vertex(centerX,centerY,VERTEX);
  }
  int increment=1;
  int pidx, idx;
  pidx=idx=0;
  for (int i=startLUT; i < stopLUT; i+=increment) {
    int ii=i % SINCOS_LENGTH;
    if (ii < 0)     ii+=SINCOS_LENGTH;
    idx=addVertex(centerX + cosLUT[ii] * hr,centerY + sinLUT[ii] * vr,VERTEX);
    if (startLUT < i) {
      if (stroke)       addEdge(pidx,idx,i == startLUT + 1,false);
    }
    pidx=idx;
  }
  idx=addVertex(centerX + cosLUT[stopLUT % SINCOS_LENGTH] * hr,centerY + sinLUT[stopLUT % SINCOS_LENGTH] * vr,VERTEX);
}",0.976173285198556
163674,"public void hint(int which){
  boolean oldValue=hints[which];
  super.hint(which);
  boolean newValue=hints[which];
  if (oldValue == newValue) {
    return;
  }
  if (which == DISABLE_DEPTH_TEST) {
    flush();
    pgl.disableDepthTest();
    pgl.setClearColor(0,0,0,0);
    pgl.clearDepthBuffer();
  }
 else   if (which == ENABLE_DEPTH_TEST) {
    flush();
    pgl.enableDepthTest();
  }
 else   if (which == DISABLE_DEPTH_MASK) {
    flush();
    pgl.disableDepthMask();
  }
 else   if (which == ENABLE_DEPTH_MASK) {
    flush();
    pgl.enableDepthMask();
  }
 else   if (which == DISABLE_ACCURATE_2D) {
    flush();
    setFlushMode(FLUSH_WHEN_FULL);
  }
 else   if (which == ENABLE_ACCURATE_2D) {
    flush();
    setFlushMode(FLUSH_CONTINUOUSLY);
  }
 else   if (which == DISABLE_TEXTURE_CACHE) {
    flush();
  }
 else   if (which == DISABLE_PERSPECTIVE_CORRECTED_LINES) {
    if (0 < tessGeo.lineVertexCount && 0 < tessGeo.lineIndexCount) {
      flush();
    }
  }
 else   if (which == ENABLE_PERSPECTIVE_CORRECTED_LINES) {
    if (0 < tessGeo.lineVertexCount && 0 < tessGeo.lineIndexCount) {
      flush();
    }
  }
}","public void hint(int which){
  boolean oldValue=which > 0 ? hints[which] : hints[-which];
  super.hint(which);
  boolean newValue=which > 0 ? hints[which] : hints[-which];
  if (oldValue == newValue) {
    return;
  }
  if (which == DISABLE_DEPTH_TEST) {
    flush();
    pgl.disableDepthTest();
    pgl.setClearColor(0,0,0,0);
    pgl.clearDepthBuffer();
  }
 else   if (which == ENABLE_DEPTH_TEST) {
    flush();
    pgl.enableDepthTest();
  }
 else   if (which == DISABLE_DEPTH_MASK) {
    flush();
    pgl.disableDepthMask();
  }
 else   if (which == ENABLE_DEPTH_MASK) {
    flush();
    pgl.enableDepthMask();
  }
 else   if (which == DISABLE_ACCURATE_2D) {
    flush();
    setFlushMode(FLUSH_WHEN_FULL);
  }
 else   if (which == ENABLE_ACCURATE_2D) {
    flush();
    setFlushMode(FLUSH_CONTINUOUSLY);
  }
 else   if (which == DISABLE_TEXTURE_CACHE) {
    flush();
  }
 else   if (which == DISABLE_PERSPECTIVE_CORRECTED_LINES) {
    if (0 < tessGeo.lineVertexCount && 0 < tessGeo.lineIndexCount) {
      flush();
    }
  }
 else   if (which == ENABLE_PERSPECTIVE_CORRECTED_LINES) {
    if (0 < tessGeo.lineVertexCount && 0 < tessGeo.lineIndexCount) {
      flush();
    }
  }
}",0.975799481417459
163675,"public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (!lights) {
    enableLighting();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][3]=currentLightSpecular[3];
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  lightEnable(lightCount);
  lightNoAmbient(lightCount);
  lightDirection(lightCount);
  lightDiffuse(lightCount);
  lightSpecular(lightCount);
  lightFalloff(lightCount);
  lightNoSpot(lightCount);
  lightCount++;
}","public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (!lights) {
    enableLighting();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][3]=currentLightSpecular[3];
  lightNormal[lightCount][0]=-nx;
  lightNormal[lightCount][1]=-ny;
  lightNormal[lightCount][2]=-nz;
  lightNormal[lightCount][3]=0.0f;
  lightEnable(lightCount);
  lightNoAmbient(lightCount);
  lightDirection(lightCount);
  lightDiffuse(lightCount);
  lightSpecular(lightCount);
  lightFalloff(lightCount);
  lightNoSpot(lightCount);
  lightCount++;
}",0.9233226837060704
163676,"/** 
 * More flexible method for dealing with camera(). <P> The actual call is like gluLookat. Here's the real skinny on what does what: <PRE> camera(); or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz); </PRE> do not need to be called from with beginCamera();/endCamera(); That's because they always apply to the camera transformation, and they always totally replace it. That means that any coordinate transforms done before camera(); in draw() will be wiped out. It also means that camera() always operates in untransformed world coordinates. Therefore it is always redundant to call resetMatrix(); before camera(); This isn't technically true of gluLookat, but it's pretty much how it's used. <P> Now, beginCamera(); and endCamera(); are useful if you want to move the camera around using transforms like translate(), etc. They will wipe out any coordinate system transforms that occur before them in draw(), but they will not automatically wipe out the camera transform. This means that they should be at the top of draw(). It also means that the following: <PRE> beginCamera(); rotateY(PI / 8); endCamera(); </PRE> will result in a camera that spins without stopping. If you want to just rotate a small constant amount, try this: <PRE> beginCamera(); camera(); // sets up the default view rotateY(PI / 8); endCamera(); </PRE> That will rotate a little off of the default view. Note that this is entirely equivalent to <PRE> camera(); // sets up the default view beginCamera(); rotateY(PI / 8); endCamera(); </PRE> because camera() doesn't care whether or not it's inside a begin/end clause. Basically it's safe to use camera() or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz) as naked calls because they do all the matrix resetting automatically.
 */
public void camera(float eyeX,float eyeY,float eyeZ,float centerX,float centerY,float centerZ,float upX,float upY,float upZ){
  eyeY=height - eyeY;
  centerY=height - centerY;
  float z0=eyeX - centerX;
  float z1=eyeY - centerY;
  float z2=eyeZ - centerZ;
  float mag=PApplet.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  if (mag != 0) {
    z0/=mag;
    z1/=mag;
    z2/=mag;
  }
  float y0=upX;
  float y1=upY;
  float y2=upZ;
  float x0=y1 * z2 - y2 * z1;
  float x1=-y0 * z2 + y2 * z0;
  float x2=y0 * z1 - y1 * z0;
  y0=z1 * x2 - z2 * x1;
  y1=-z0 * x2 + z2 * x0;
  y2=z0 * x1 - z1 * x0;
  mag=PApplet.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (mag != 0) {
    x0/=mag;
    x1/=mag;
    x2/=mag;
  }
  mag=PApplet.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (mag != 0) {
    y0/=mag;
    y1/=mag;
    y2/=mag;
  }
  float[] m=glmodelview;
  m[0]=x0;
  m[1]=y0;
  m[2]=z0;
  m[3]=0.0f;
  m[4]=x1;
  m[5]=y1;
  m[6]=z1;
  m[7]=0.0f;
  m[8]=x2;
  m[9]=y2;
  m[10]=z2;
  m[11]=0;
  m[12]=0.0f;
  m[13]=0.0f;
  m[14]=0.0f;
  m[15]=1.0f;
  float tx=-eyeX;
  float ty=-eyeY + height;
  float tz=-eyeZ;
  m[12]+=tx * m[0] + ty * m[4] + tz * m[8];
  m[13]+=tx * m[1] + ty * m[5] + tz * m[9];
  m[14]+=tx * m[2] + ty * m[6] + tz * m[10];
  m[15]+=tx * m[3] + ty * m[7] + tz * m[11];
  m[4]=-m[4];
  m[5]=-m[5];
  m[6]=-m[6];
  m[7]=-m[7];
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glLoadMatrixf(glmodelview,0);
  if (usingGLMatrixStack) {
    modelviewStack.set(glmodelview);
  }
  copyGLArrayToPMatrix(glmodelview,modelview);
  modelviewUpdated=true;
  calculateModelviewInvNoScaling();
  PApplet.arrayCopy(glmodelview,pcamera);
  PApplet.arrayCopy(glmodelviewInv,pcameraInv);
  copyGLArrayToPMatrix(pcamera,camera);
  copyGLArrayToPMatrix(pcameraInv,cameraInv);
}","/** 
 * More flexible method for dealing with camera(). <P> The actual call is like gluLookat. Here's the real skinny on what does what: <PRE> camera(); or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz); </PRE> do not need to be called from with beginCamera();/endCamera(); That's because they always apply to the camera transformation, and they always totally replace it. That means that any coordinate transforms done before camera(); in draw() will be wiped out. It also means that camera() always operates in untransformed world coordinates. Therefore it is always redundant to call resetMatrix(); before camera(); This isn't technically true of gluLookat, but it's pretty much how it's used. <P> Now, beginCamera(); and endCamera(); are useful if you want to move the camera around using transforms like translate(), etc. They will wipe out any coordinate system transforms that occur before them in draw(), but they will not automatically wipe out the camera transform. This means that they should be at the top of draw(). It also means that the following: <PRE> beginCamera(); rotateY(PI / 8); endCamera(); </PRE> will result in a camera that spins without stopping. If you want to just rotate a small constant amount, try this: <PRE> beginCamera(); camera(); // sets up the default view rotateY(PI / 8); endCamera(); </PRE> That will rotate a little off of the default view. Note that this is entirely equivalent to <PRE> camera(); // sets up the default view beginCamera(); rotateY(PI / 8); endCamera(); </PRE> because camera() doesn't care whether or not it's inside a begin/end clause. Basically it's safe to use camera() or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz) as naked calls because they do all the matrix resetting automatically.
 */
public void camera(float eyeX,float eyeY,float eyeZ,float centerX,float centerY,float centerZ,float upX,float upY,float upZ){
  float z0=eyeX - centerX;
  float z1=eyeY - centerY;
  float z2=eyeZ - centerZ;
  float mag=PApplet.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  if (mag != 0) {
    z0/=mag;
    z1/=mag;
    z2/=mag;
  }
  float y0=upX;
  float y1=upY;
  float y2=upZ;
  float x0=y1 * z2 - y2 * z1;
  float x1=-y0 * z2 + y2 * z0;
  float x2=y0 * z1 - y1 * z0;
  y0=z1 * x2 - z2 * x1;
  y1=-z0 * x2 + z2 * x0;
  y2=z0 * x1 - z1 * x0;
  mag=PApplet.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (mag != 0) {
    x0/=mag;
    x1/=mag;
    x2/=mag;
  }
  mag=PApplet.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (mag != 0) {
    y0/=mag;
    y1/=mag;
    y2/=mag;
  }
  float[] m=glmodelview;
  m[0]=x0;
  m[1]=y0;
  m[2]=z0;
  m[3]=0.0f;
  m[4]=x1;
  m[5]=y1;
  m[6]=z1;
  m[7]=0.0f;
  m[8]=x2;
  m[9]=y2;
  m[10]=z2;
  m[11]=0;
  m[12]=0.0f;
  m[13]=0.0f;
  m[14]=0.0f;
  m[15]=1.0f;
  float tx=-eyeX;
  float ty=-eyeY;
  float tz=-eyeZ;
  m[12]+=tx * m[0] + ty * m[4] + tz * m[8];
  m[13]+=tx * m[1] + ty * m[5] + tz * m[9];
  m[14]+=tx * m[2] + ty * m[6] + tz * m[10];
  m[15]+=tx * m[3] + ty * m[7] + tz * m[11];
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glLoadMatrixf(glmodelview,0);
  if (usingGLMatrixStack) {
    modelviewStack.set(glmodelview);
  }
  copyGLArrayToPMatrix(glmodelview,modelview);
  modelviewUpdated=true;
  calculateModelviewInvNoScaling();
  PApplet.arrayCopy(glmodelview,pcamera);
  PApplet.arrayCopy(glmodelviewInv,pcameraInv);
  copyGLArrayToPMatrix(pcamera,camera);
  copyGLArrayToPMatrix(pcameraInv,cameraInv);
}",0.9832824538450357
163677,"/** 
 * Same as glFrustum(), except that it wipes out (rather than multiplies against) the current perspective matrix. <P> Implementation based on the explanation in the OpenGL blue book.
 */
public void frustum(float left,float right,float bottom,float top,float znear,float zfar){
  float temp, temp2, temp3, temp4;
  temp=2.0f * znear;
  temp2=right - left;
  temp3=top - bottom;
  temp4=zfar - znear;
  glprojection[0]=temp / temp2;
  glprojection[1]=0.0f;
  glprojection[2]=0.0f;
  glprojection[3]=0.0f;
  glprojection[4]=0.0f;
  glprojection[5]=temp / temp3;
  glprojection[6]=0.0f;
  glprojection[7]=0.0f;
  glprojection[8]=(right + left) / temp2;
  glprojection[9]=(top + bottom) / temp3;
  glprojection[10]=(-zfar - znear) / temp4;
  glprojection[11]=-1.0f;
  glprojection[12]=0.0f;
  glprojection[13]=0.0f;
  glprojection[14]=(-temp * zfar) / temp4;
  glprojection[15]=0.0f;
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glLoadMatrixf(glprojection,0);
  copyGLArrayToPMatrix(glprojection,projection);
  projectionUpdated=true;
  PApplet.arrayCopy(glprojection,pprojection);
  gl.glMatrixMode(GL10.GL_MODELVIEW);
}","/** 
 * Same as glFrustum(), except that it wipes out (rather than multiplies against) the current perspective matrix. <P> Implementation based on the explanation in the OpenGL blue book.
 */
public void frustum(float left,float right,float bottom,float top,float znear,float zfar){
  float temp, temp2, temp3, temp4;
  temp=2.0f * znear;
  temp2=right - left;
  temp3=top - bottom;
  temp4=zfar - znear;
  glprojection[0]=temp / temp2;
  glprojection[1]=0.0f;
  glprojection[2]=0.0f;
  glprojection[3]=0.0f;
  glprojection[4]=0.0f;
  glprojection[5]=-temp / temp3;
  glprojection[6]=0.0f;
  glprojection[7]=0.0f;
  glprojection[8]=(right + left) / temp2;
  glprojection[9]=(top + bottom) / temp3;
  glprojection[10]=(-zfar - znear) / temp4;
  glprojection[11]=-1.0f;
  glprojection[12]=0.0f;
  glprojection[13]=0.0f;
  glprojection[14]=(-temp * zfar) / temp4;
  glprojection[15]=0.0f;
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glLoadMatrixf(glprojection,0);
  copyGLArrayToPMatrix(glprojection,projection);
  projectionUpdated=true;
  PApplet.arrayCopy(glprojection,pprojection);
  gl.glMatrixMode(GL10.GL_MODELVIEW);
}",0.9995541685242978
163678,"/** 
 * Call createInput() without automatic gzip decompression.
 */
public InputStream createInputRaw(String filename){
  InputStream stream=null;
  if (filename == null)   return null;
  if (filename.length() == 0) {
    return null;
  }
  if (filename.indexOf(""String_Node_Str"") != -1) {
    try {
      HttpGet httpRequest=null;
      httpRequest=new HttpGet(URI.create(filename));
      HttpClient httpclient=new DefaultHttpClient();
      HttpResponse response=(HttpResponse)httpclient.execute(httpRequest);
      HttpEntity entity=response.getEntity();
      BufferedHttpEntity bufHttpEntity=new BufferedHttpEntity(entity);
      return bufHttpEntity.getContent();
    }
 catch (    MalformedURLException mfue) {
    }
catch (    FileNotFoundException fnfe) {
    }
catch (    IOException e) {
      e.printStackTrace();
      return null;
    }
  }
  AssetManager assets=getAssets();
  try {
    stream=assets.open(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  IOException e) {
  }
  File absFile=new File(filename);
  if (absFile.exists()) {
    try {
      stream=new FileInputStream(absFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  File sketchFile=new File(sketchPath(filename));
  if (sketchFile.exists()) {
    try {
      stream=new FileInputStream(sketchFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  Context context=getApplicationContext();
  try {
    stream=context.openFileInput(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  FileNotFoundException e) {
  }
  return null;
}","/** 
 * Call createInput() without automatic gzip decompression.
 */
public InputStream createInputRaw(String filename){
  InputStream stream=null;
  if (filename == null)   return null;
  if (filename.length() == 0) {
    return null;
  }
  if (filename.indexOf(""String_Node_Str"") != -1) {
    try {
      HttpGet httpRequest=null;
      httpRequest=new HttpGet(URI.create(filename));
      HttpClient httpclient=new DefaultHttpClient();
      HttpResponse response=(HttpResponse)httpclient.execute(httpRequest);
      HttpEntity entity=response.getEntity();
      return entity.getContent();
    }
 catch (    MalformedURLException mfue) {
    }
catch (    FileNotFoundException fnfe) {
    }
catch (    IOException e) {
      e.printStackTrace();
      return null;
    }
  }
  AssetManager assets=getAssets();
  try {
    stream=assets.open(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  IOException e) {
  }
  File absFile=new File(filename);
  if (absFile.exists()) {
    try {
      stream=new FileInputStream(absFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  File sketchFile=new File(sketchPath(filename));
  if (sketchFile.exists()) {
    try {
      stream=new FileInputStream(sketchFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  Context context=getApplicationContext();
  try {
    stream=context.openFileInput(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  FileNotFoundException e) {
  }
  return null;
}",0.9719402985074628
163679,"public void beginShape(int kind){
  shape=kind;
  if (hints[ENABLE_DEPTH_SORT]) {
    shapeFirst=vertexCount;
    shapeLast=0;
  }
 else {
    vertexCount=0;
    pathCount=0;
    faceCount=0;
    pointCount=0;
    lineCount=0;
    triangleCount=0;
  }
  shapeTextures=0;
  noTexture();
}","public void beginShape(int kind){
  shape=kind;
  if (hints[ENABLE_DEPTH_SORT]) {
    shapeFirst=vertexCount;
    shapeLast=0;
  }
 else {
    vertexCount=0;
    curveVertexCount=0;
    pathCount=0;
    faceCount=0;
    pointCount=0;
    lineCount=0;
    triangleCount=0;
  }
  shapeTextures=0;
  noTexture();
}",0.959866220735786
163680,"public void endDraw(){
  if (primarySurface) {
    Canvas screen=null;
    try {
      screen=parent.getSurfaceHolder().lockCanvas(null);
      if (screen != null) {
        screen.drawBitmap(bitmap,new Matrix(),null);
      }
    }
  finally {
      if (screen != null) {
        parent.getSurfaceHolder().unlockCanvasAndPost(screen);
      }
    }
  }
  if (!primarySurface) {
    loadPixels();
  }
  modified=true;
}","public void endDraw(){
  if (primarySurface) {
    Canvas screen=null;
    try {
      screen=parent.getSurfaceHolder().lockCanvas(null);
      if (screen != null) {
        screen.drawBitmap(bitmap,new Matrix(),null);
      }
    }
  finally {
      if (screen != null) {
        parent.getSurfaceHolder().unlockCanvasAndPost(screen);
      }
    }
  }
 else {
    loadPixels();
  }
  setModified();
  super.updatePixels();
}",0.9041420118343196
163681,"public void rect(float a,float b,float c,float d,float tl,float tr,float br,float bl){
  float hradius, vradius;
switch (rectMode) {
case CORNERS:
    break;
case CORNER:
  c+=a;
d+=b;
break;
case RADIUS:
hradius=c;
vradius=d;
c=a + hradius;
d=b + vradius;
a-=hradius;
b-=vradius;
break;
case CENTER:
hradius=c / 2.0f;
vradius=d / 2.0f;
c=a + hradius;
d=b + vradius;
a-=hradius;
b-=vradius;
}
if (a > c) {
float temp=a;
a=c;
c=temp;
}
if (b > d) {
float temp=b;
b=d;
d=temp;
}
rectImpl(a,b,c,d,tl,tr,br,bl);
}","public void rect(float a,float b,float c,float d,float tl,float tr,float br,float bl){
  float hradius, vradius;
switch (rectMode) {
case CORNERS:
    break;
case CORNER:
  c+=a;
d+=b;
break;
case RADIUS:
hradius=c;
vradius=d;
c=a + hradius;
d=b + vradius;
a-=hradius;
b-=vradius;
break;
case CENTER:
hradius=c / 2.0f;
vradius=d / 2.0f;
c=a + hradius;
d=b + vradius;
a-=hradius;
b-=vradius;
}
if (a > c) {
float temp=a;
a=c;
c=temp;
}
if (b > d) {
float temp=b;
b=d;
d=temp;
}
float maxRounding=PApplet.min((c - a) / 2,(d - b) / 2);
if (tl > maxRounding) tl=maxRounding;
if (tr > maxRounding) tr=maxRounding;
if (br > maxRounding) br=maxRounding;
if (bl > maxRounding) bl=maxRounding;
rectImpl(a,b,c,d,tl,tr,br,bl);
}",0.8303425774877651
163682,"protected PImage getImpl(int x,int y,int w,int h){
  PImage newbie=parent.createImage(w,h,ARGB);
  PTexture newbieTex=addTexture(newbie);
  IntBuffer newbieBuffer=IntBuffer.allocate(w * h);
  gl.glReadPixels(x,height - y,w,-h,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,newbieBuffer);
  copyToTexture(newbieTex,newbieBuffer,0,0,w,h);
  newbie.loadPixels();
  newbieTex.get(newbie.pixels);
  return newbie;
}","protected PImage getImpl(int x,int y,int w,int h){
  PImage newbie=parent.createImage(w,h,ARGB);
  PTexture newbieTex=addTexture(newbie);
  IntBuffer newbieBuffer=IntBuffer.allocate(w * h);
  boolean nonCurrent=!primarySurface && offscreenFramebuffer != currentFramebuffer;
  if (nonCurrent) {
    pushFramebuffer();
    setFramebuffer(offscreenFramebuffer);
  }
  gl.glReadPixels(x,height - y - h,w,h,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,newbieBuffer);
  if (nonCurrent) {
    popFramebuffer();
  }
  copyToTexture(newbieTex,newbieBuffer,0,0,w,h);
  newbie.loadPixels();
  newbieTex.flippedY=true;
  newbieTex.get(newbie.pixels);
  return newbie;
}",0.7559808612440191
163683,"protected void loadTextureImpl(int sampling){
  if (width == 0 || height == 0)   return;
  if (texture == null) {
    PTexture.Parameters params=PTexture.newParameters(ARGB,sampling);
    texture=new PTexture(parent,width,height,params);
    texture.setFlippedY(true);
    this.setCache(a3d,texture);
    this.setParams(a3d,params);
    texCrop=new int[4];
    texCrop[0]=0;
    texCrop[1]=0;
    texCrop[2]=width;
    texCrop[3]=height;
  }
}","protected void loadTextureImpl(int sampling){
  if (width == 0 || height == 0)   return;
  if (texture == null) {
    PTexture.Parameters params=PTexture.newParameters(ARGB,sampling);
    texture=new PTexture(parent,width,height,params);
    texture.setFlippedY(true);
    this.setCache(a3d,texture);
    this.setParams(a3d,params);
    texCrop=new int[4];
    texCrop[0]=0;
    texCrop[1]=height;
    texCrop[2]=width;
    texCrop[3]=-height;
  }
}",0.9910313901345292
163684,"/** 
 * Remove the shape with index idx.
 */
public void removeChild(int idx){
  if (idx < childCount) {
    PShape child=children[idx];
    for (int i=idx; i < childCount - 1; i++) {
      children[i]=children[i + 1];
    }
    childCount--;
    if (child.getName() != null && nameTable != null) {
      nameTable.remove(child.getName());
    }
  }
}","/** 
 * Remove the child shape with index idx.
 */
public void removeChild(int idx){
  if (idx < childCount) {
    PShape child=children[idx];
    for (int i=idx; i < childCount - 1; i++) {
      children[i]=children[i + 1];
    }
    childCount--;
    if (child.getName() != null && nameTable != null) {
      nameTable.remove(child.getName());
    }
  }
}",0.9915254237288136
163685,"protected void drawPath(PGraphics g){
  if (vertices == null)   return;
  g.beginShape();
  if (vertexCodeCount == 0) {
    if (vertices[0].length == 2) {
      for (int i=0; i < vertexCount; i++) {
        g.vertex(vertices[i][X],vertices[i][Y]);
      }
    }
 else {
      for (int i=0; i < vertexCount; i++) {
        g.vertex(vertices[i][X],vertices[i][Y],vertices[i][Z]);
      }
    }
  }
 else {
    int index=0;
    if (vertices[0].length == 2) {
      for (int j=0; j < vertexCodeCount; j++) {
switch (vertexCodes[j]) {
case VERTEX:
          g.vertex(vertices[index][X],vertices[index][Y]);
        index++;
      break;
case BEZIER_VERTEX:
    g.bezierVertex(vertices[index + 0][X],vertices[index + 0][Y],vertices[index + 1][X],vertices[index + 1][Y],vertices[index + 2][X],vertices[index + 2][Y]);
  index+=3;
break;
case CURVE_VERTEX:
g.curveVertex(vertices[index][X],vertices[index][Y]);
index++;
case BREAK:
g.breakShape();
}
}
}
 else {
for (int j=0; j < vertexCodeCount; j++) {
switch (vertexCodes[j]) {
case VERTEX:
g.vertex(vertices[index][X],vertices[index][Y],vertices[index][Z]);
index++;
break;
case BEZIER_VERTEX:
g.bezierVertex(vertices[index + 0][X],vertices[index + 0][Y],vertices[index + 0][Z],vertices[index + 1][X],vertices[index + 1][Y],vertices[index + 1][Z],vertices[index + 2][X],vertices[index + 2][Y],vertices[index + 2][Z]);
index+=3;
break;
case CURVE_VERTEX:
g.curveVertex(vertices[index][X],vertices[index][Y],vertices[index][Z]);
index++;
case BREAK:
g.breakShape();
}
}
}
}
g.endShape(close ? CLOSE : OPEN);
}","protected void drawPath(PGraphics g){
  if (vertices == null)   return;
  g.beginShape();
  if (vertexCodeCount == 0) {
    if (vertices[0].length == 2) {
      for (int i=0; i < vertexCount; i++) {
        g.vertex(vertices[i][X],vertices[i][Y]);
      }
    }
 else {
      for (int i=0; i < vertexCount; i++) {
        g.vertex(vertices[i][X],vertices[i][Y],vertices[i][Z]);
      }
    }
  }
 else {
    int index=0;
    if (vertices[0].length == 2) {
      for (int j=0; j < vertexCodeCount; j++) {
switch (vertexCodes[j]) {
case VERTEX:
          g.vertex(vertices[index][X],vertices[index][Y]);
        index++;
      break;
case QUAD_BEZIER_VERTEX:
    g.quadVertex(vertices[index + 0][X],vertices[index + 0][Y],vertices[index + 1][X],vertices[index + 1][Y]);
  index+=2;
break;
case BEZIER_VERTEX:
g.bezierVertex(vertices[index + 0][X],vertices[index + 0][Y],vertices[index + 1][X],vertices[index + 1][Y],vertices[index + 2][X],vertices[index + 2][Y]);
index+=3;
break;
case CURVE_VERTEX:
g.curveVertex(vertices[index][X],vertices[index][Y]);
index++;
case BREAK:
g.breakShape();
}
}
}
 else {
for (int j=0; j < vertexCodeCount; j++) {
switch (vertexCodes[j]) {
case VERTEX:
g.vertex(vertices[index][X],vertices[index][Y],vertices[index][Z]);
index++;
break;
case QUAD_BEZIER_VERTEX:
g.quadVertex(vertices[index + 0][X],vertices[index + 0][Y],vertices[index + 0][Z],vertices[index + 1][X],vertices[index + 1][Y],vertices[index + 0][Z]);
index+=2;
break;
case BEZIER_VERTEX:
g.bezierVertex(vertices[index + 0][X],vertices[index + 0][Y],vertices[index + 0][Z],vertices[index + 1][X],vertices[index + 1][Y],vertices[index + 1][Z],vertices[index + 2][X],vertices[index + 2][Y],vertices[index + 2][Z]);
index+=3;
break;
case CURVE_VERTEX:
g.curveVertex(vertices[index][X],vertices[index][Y],vertices[index][Z]);
index++;
case BREAK:
g.breakShape();
}
}
}
}
g.endShape(close ? CLOSE : OPEN);
}",0.8990719257540604
163686,"/** 
 * Add a shape to the name lookup table.
 */
protected void addName(String nom,PShape shape){
  if (parent != null) {
    parent.addName(nom,shape);
  }
 else {
    if (nameTable == null) {
      nameTable=new HashMap<String,PShape>();
    }
    nameTable.put(nom,shape);
  }
}","/** 
 * Add a shape to the name lookup table.
 */
public void addName(String nom,PShape shape){
  if (parent != null) {
    parent.addName(nom,shape);
  }
 else {
    if (nameTable == null) {
      nameTable=new HashMap<String,PShape>();
    }
    nameTable.put(nom,shape);
  }
}",0.9803921568627452
163687,"/** 
 * Add a shape to the name lookup table.
 */
protected void addName(String nom,PShape shape){
  if (nameTable == null) {
    nameTable=new HashMap<String,PShape>();
  }
  nameTable.put(nom,shape);
}","/** 
 * Add a shape to the name lookup table.
 */
public void addName(String nom,PShape shape){
  if (nameTable == null) {
    nameTable=new HashMap<String,PShape>();
  }
  nameTable.put(nom,shape);
}",0.9727047146401984
163688,"public PShape groupChildren(PShape[] gchildren,String gname){
  if (family != GROUP)   return null;
  PShape3D group=new PShape3D();
  group.family=PShape.GROUP;
  group.name=gname;
  group.papplet=papplet;
  group.a3d=a3d;
  group.gl=gl;
  group.root=root;
  PShape child, p;
  int idx;
  child=gchildren[0];
  p=child.parent;
  if (p != null) {
    idx=p.getChildIdx(child);
    if (idx < 0)     idx=0;
  }
 else {
    p=this;
    idx=0;
  }
  p.addChild(group,idx);
  for (int i=0; i < gchildren.length; i++) {
    child=gchildren[i];
    p=child.parent;
    if (p != null) {
      idx=p.getChildIdx(child);
      if (-1 < idx) {
        p.removeChild(idx);
      }
    }
  }
  group.firstVertex=root.vertexCount;
  group.lastVertex=0;
  for (int i=0; i < gchildren.length; i++) {
    group.firstVertex=PApplet.min(group.firstVertex,((PShape3D)gchildren[i]).firstVertex);
    group.lastVertex=PApplet.max(group.lastVertex,((PShape3D)gchildren[i]).lastVertex);
  }
  for (int i=0; i < gchildren.length; i++) {
    group.addChildImpl(gchildren[i],false);
  }
  return group;
}","public PShape groupChildren(PShape[] gchildren,String gname){
  if (family != GROUP)   return null;
  PShape3D group=new PShape3D();
  group.family=PShape.GROUP;
  group.name=gname;
  group.papplet=papplet;
  group.a3d=a3d;
  group.gl=gl;
  group.root=root;
  PShape child, p;
  int idx;
  child=gchildren[0];
  p=child.parent;
  if (p != null) {
    idx=p.getChildIndex(child);
    if (idx < 0)     idx=0;
  }
 else {
    p=this;
    idx=0;
  }
  p.addChild(group,idx);
  for (int i=0; i < gchildren.length; i++) {
    child=gchildren[i];
    p=child.parent;
    if (p != null) {
      idx=p.getChildIndex(child);
      if (-1 < idx) {
        p.removeChild(idx);
      }
    }
  }
  group.firstVertex=root.vertexCount;
  group.lastVertex=0;
  for (int i=0; i < gchildren.length; i++) {
    group.firstVertex=PApplet.min(group.firstVertex,((PShape3D)gchildren[i]).firstVertex);
    group.lastVertex=PApplet.max(group.lastVertex,((PShape3D)gchildren[i]).lastVertex);
  }
  for (int i=0; i < gchildren.length; i++) {
    group.addChildImpl(gchildren[i],false);
  }
  return group;
}",0.9962928637627432
163689,"/** 
 * This utility method creates a texture for the provided image, and adds it to the metadata cache of the image.
 * @param img the image to have a texture metadata associated to it
 */
protected PTexture addTexture(PImage img){
  PTexture.Parameters params=(PTexture.Parameters)img.getParams(a3d);
  if (params == null) {
    params=PTexture.newParameters();
    img.setParams(a3d,params);
  }
  PTexture tex=new PTexture(img.parent,img.width,img.height,params);
  img.loadPixels();
  tex.set(img.pixels);
  img.setCache(a3d,tex);
  return tex;
}","/** 
 * This utility method creates a texture for the provided image, and adds it to the metadata cache of the image.
 * @param img the image to have a texture metadata associated to it
 */
protected PTexture addTexture(PImage img){
  PTexture.Parameters params=(PTexture.Parameters)img.getParams(a3d);
  if (params == null) {
    params=PTexture.newParameters();
    img.setParams(a3d,params);
  }
  PTexture tex=new PTexture(img.parent,img.width,img.height,params);
  if (img.pixels == null) {
    img.loadPixels();
  }
  tex.set(img.pixels);
  img.setCache(a3d,tex);
  return tex;
}",0.9419014084507042
163690,"/** 
 * Draw a sphere with radius r centered at coordinate 0, 0, 0. <P> Implementation notes: <P> cache all the points of the sphere in a static array top and bottom are just a bunch of triangles that land in the center point <P> sphere is a series of concentric circles who radii vary along the shape, based on, er.. cos or something <PRE> [toxi 031031] new sphere code. removed all multiplies with radius, as scale() will take care of that anyway [toxi 031223] updated sphere code (removed modulos) and introduced sphereAt(x,y,z,r) to avoid additional translate()'s on the user/sketch side [davbol 080801] now using separate sphereDetailU/V </PRE>
 */
public void sphere(float r){
  if ((sphereDetailU < 3) || (sphereDetailV < 2)) {
    sphereDetail(30);
  }
  edge(false);
  beginShape(TRIANGLE_STRIP);
  for (int i=0; i < sphereDetailU; i++) {
    normal(0,-1,0);
    vertex(0,-r,0);
    normal(sphereX[i],sphereY[i],sphereZ[i]);
    vertex(r * sphereX[i],r * sphereY[i],r * sphereZ[i]);
  }
  vertex(0,-r,0);
  normal(sphereX[0],sphereY[0],sphereZ[0]);
  vertex(r * sphereX[0],r * sphereY[0],r * sphereZ[0]);
  endShape();
  int v1, v11, v2;
  int voff=0;
  for (int i=2; i < sphereDetailV; i++) {
    v1=v11=voff;
    voff+=sphereDetailU;
    v2=voff;
    beginShape(TRIANGLE_STRIP);
    for (int j=0; j < sphereDetailU; j++) {
      normal(sphereX[v1],sphereY[v1],sphereZ[v1]);
      vertex(r * sphereX[v1],r * sphereY[v1],r * sphereZ[v1++]);
      normal(sphereX[v2],sphereY[v2],sphereZ[v2]);
      vertex(r * sphereX[v2],r * sphereY[v2],r * sphereZ[v2++]);
    }
    v1=v11;
    v2=voff;
    normal(sphereX[v1],sphereY[v1],sphereZ[v1]);
    vertex(r * sphereX[v1],r * sphereY[v1],r * sphereZ[v1]);
    normal(sphereX[v2],sphereY[v2],sphereZ[v2]);
    vertex(r * sphereX[v2],r * sphereY[v2],r * sphereZ[v2]);
    endShape();
  }
  beginShape(TRIANGLE_STRIP);
  for (int i=0; i < sphereDetailU; i++) {
    v2=voff + i;
    normal(sphereX[v2],sphereY[v2],sphereZ[v2]);
    vertex(r * sphereX[v2],r * sphereY[v2],r * sphereZ[v2]);
    normal(0,1,0);
    vertex(0,r,0);
  }
  normal(sphereX[voff],sphereY[voff],sphereZ[voff]);
  vertex(r * sphereX[voff],r * sphereY[voff],r * sphereZ[voff]);
  normal(0,1,0);
  vertex(0,r,0);
  endShape();
  edge(true);
}","/** 
 * Draw a sphere with radius r centered at coordinate 0, 0, 0. <P> Implementation notes: <P> cache all the points of the sphere in a static array top and bottom are just a bunch of triangles that land in the center point <P> sphere is a series of concentric circles who radii vary along the shape, based on, er.. cos or something <PRE> [toxi 031031] new sphere code. removed all multiplies with radius, as scale() will take care of that anyway [toxi 031223] updated sphere code (removed modulos) and introduced sphereAt(x,y,z,r) to avoid additional translate()'s on the user/sketch side [davbol 080801] now using separate sphereDetailU/V </PRE>
 */
public void sphere(float r){
  if ((sphereDetailU < 3) || (sphereDetailV < 2)) {
    sphereDetail(30);
  }
  edge(false);
  beginShape(TRIANGLE_STRIP);
  for (int i=0; i < sphereDetailU; i++) {
    normal(0,-1,0);
    vertex(0,-r,0);
    normal(sphereX[i],sphereY[i],sphereZ[i]);
    vertex(r * sphereX[i],r * sphereY[i],r * sphereZ[i]);
  }
  normal(0,-r,0);
  vertex(0,-r,0);
  normal(sphereX[0],sphereY[0],sphereZ[0]);
  vertex(r * sphereX[0],r * sphereY[0],r * sphereZ[0]);
  endShape();
  int v1, v11, v2;
  int voff=0;
  for (int i=2; i < sphereDetailV; i++) {
    v1=v11=voff;
    voff+=sphereDetailU;
    v2=voff;
    beginShape(TRIANGLE_STRIP);
    for (int j=0; j < sphereDetailU; j++) {
      normal(sphereX[v1],sphereY[v1],sphereZ[v1]);
      vertex(r * sphereX[v1],r * sphereY[v1],r * sphereZ[v1++]);
      normal(sphereX[v2],sphereY[v2],sphereZ[v2]);
      vertex(r * sphereX[v2],r * sphereY[v2],r * sphereZ[v2++]);
    }
    v1=v11;
    v2=voff;
    normal(sphereX[v1],sphereY[v1],sphereZ[v1]);
    vertex(r * sphereX[v1],r * sphereY[v1],r * sphereZ[v1]);
    normal(sphereX[v2],sphereY[v2],sphereZ[v2]);
    vertex(r * sphereX[v2],r * sphereY[v2],r * sphereZ[v2]);
    endShape();
  }
  beginShape(TRIANGLE_STRIP);
  for (int i=0; i < sphereDetailU; i++) {
    v2=voff + i;
    normal(sphereX[v2],sphereY[v2],sphereZ[v2]);
    vertex(r * sphereX[v2],r * sphereY[v2],r * sphereZ[v2]);
    normal(0,1,0);
    vertex(0,r,0);
  }
  normal(sphereX[voff],sphereY[voff],sphereZ[voff]);
  vertex(r * sphereX[voff],r * sphereY[voff],r * sphereZ[voff]);
  normal(0,1,0);
  vertex(0,r,0);
  endShape();
  edge(true);
}",0.996031746031746
163691,"/** 
 * First try to create a default font, but if that's not possible, throw   an exception that halts the program because textFont() has not been used  prior to the specified method.
 */
protected void defaultFontOrDeath(String method,float size){
  if (parent != null) {
    textFont=parent.createDefaultFont(size);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + method + ""String_Node_Str"");
  }
}","/** 
 * First try to create a default font, but if that's not possible, throw an exception that halts the program because textFont() has not been used prior to the specified method.
 */
protected void defaultFontOrDeath(String method,float size){
  if (parent != null) {
    textFont=parent.createDefaultFont(size);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + method + ""String_Node_Str"");
  }
}",0.9963811821471652
163692,"static final public String hex(int what,int digits){
  String stuff=Integer.toHexString(what).toUpperCase();
  int length=stuff.length();
  if (length > digits) {
    return stuff.substring(length - digits);
  }
 else   if (length < digits) {
    return ""String_Node_Str"".substring(8 - (digits - length)) + stuff;
  }
  return stuff;
}","/** 
 * Format an integer as a hex string using the specified number of digits.
 * @param what the value to format
 * @param digits the number of digits (maximum 8)
 * @return a String object with the formatted values
 */
static final public String hex(int what,int digits){
  String stuff=Integer.toHexString(what).toUpperCase();
  if (digits > 8) {
    digits=8;
  }
  int length=stuff.length();
  if (length > digits) {
    return stuff.substring(length - digits);
  }
 else   if (length < digits) {
    return ""String_Node_Str"".substring(8 - (digits - length)) + stuff;
  }
  return stuff;
}",0.7204301075268817
163693,"/** 
 * Returns a String that contains the binary value of an int. The digits parameter determines how many digits will be used.
 */
static final public String binary(int what,int digits){
  String stuff=Integer.toBinaryString(what);
  int length=stuff.length();
  if (length > digits) {
    return stuff.substring(length - digits);
  }
 else   if (length < digits) {
    int offset=32 - (digits - length);
    return ""String_Node_Str"".substring(offset) + stuff;
  }
  return stuff;
}","/** 
 * Returns a String that contains the binary value of an int. The digits parameter determines how many digits will be used.
 */
static final public String binary(int what,int digits){
  String stuff=Integer.toBinaryString(what);
  if (digits > 32) {
    digits=32;
  }
  int length=stuff.length();
  if (length > digits) {
    return stuff.substring(length - digits);
  }
 else   if (length < digits) {
    int offset=32 - (digits - length);
    return ""String_Node_Str"".substring(offset) + stuff;
  }
  return stuff;
}",0.6944444444444444
163694,"/** 
 * Call createInput() without automatic gzip decompression.
 */
public InputStream createInputRaw(String filename){
  InputStream stream=null;
  if (filename == null)   return null;
  if (filename.length() == 0) {
    return null;
  }
  if (filename.indexOf(""String_Node_Str"") != -1) {
    try {
      URL url=new URL(filename);
      stream=url.openStream();
      return stream;
    }
 catch (    MalformedURLException mfue) {
    }
catch (    FileNotFoundException fnfe) {
    }
catch (    IOException e) {
      e.printStackTrace();
      return null;
    }
  }
  AssetManager assets=getAssets();
  try {
    stream=assets.open(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  IOException e) {
  }
  File absFile=new File(filename);
  if (absFile.exists()) {
    try {
      stream=new FileInputStream(absFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  File sketchFile=new File(sketchPath(filename));
  if (sketchFile.exists()) {
    try {
      stream=new FileInputStream(sketchFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  Context context=getApplicationContext();
  try {
    stream=context.openFileInput(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  FileNotFoundException e) {
  }
  return null;
}","/** 
 * Call createInput() without automatic gzip decompression.
 */
public InputStream createInputRaw(String filename){
  InputStream stream=null;
  if (filename == null)   return null;
  if (filename.length() == 0) {
    return null;
  }
  if (filename.indexOf(""String_Node_Str"") != -1) {
    try {
      HttpGet httpRequest=null;
      httpRequest=new HttpGet(URI.create(filename));
      HttpClient httpclient=new DefaultHttpClient();
      HttpResponse response=(HttpResponse)httpclient.execute(httpRequest);
      HttpEntity entity=response.getEntity();
      BufferedHttpEntity bufHttpEntity=new BufferedHttpEntity(entity);
      return bufHttpEntity.getContent();
    }
 catch (    MalformedURLException mfue) {
    }
catch (    FileNotFoundException fnfe) {
    }
catch (    IOException e) {
      e.printStackTrace();
      return null;
    }
  }
  AssetManager assets=getAssets();
  try {
    stream=assets.open(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  IOException e) {
  }
  File absFile=new File(filename);
  if (absFile.exists()) {
    try {
      stream=new FileInputStream(absFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  File sketchFile=new File(sketchPath(filename));
  if (sketchFile.exists()) {
    try {
      stream=new FileInputStream(sketchFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  Context context=getApplicationContext();
  try {
    stream=context.openFileInput(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  FileNotFoundException e) {
  }
  return null;
}",0.8656906429026098
163695,"/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (DEBUG)   println(""String_Node_Str"" + Thread.currentThread().getName());
  Window window=getWindow();
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  window.setFlags(WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
  window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  DisplayMetrics dm=new DisplayMetrics();
  getWindowManager().getDefaultDisplay().getMetrics(dm);
  screenWidth=dm.widthPixels;
  screenHeight=dm.heightPixels;
  if (DEBUG)   println(""String_Node_Str"" + dm);
  int sw=sketchWidth();
  int sh=sketchHeight();
  if (sketchRenderer().equals(A2D)) {
    surfaceView=new SketchSurfaceView2D(this,sw,sh);
  }
 else   if (sketchRenderer().equals(A3D)) {
    surfaceView=new SketchSurfaceView3D(this,sw,sh);
  }
  g=((SketchSurfaceView)surfaceView).getGraphics();
  if (sw == screenWidth && sh == screenHeight) {
    window.setContentView(surfaceView);
  }
 else {
    RelativeLayout overallLayout=new RelativeLayout(this);
    RelativeLayout.LayoutParams lp=new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT,RelativeLayout.LayoutParams.WRAP_CONTENT);
    lp.addRule(RelativeLayout.CENTER_IN_PARENT);
    LinearLayout layout=new LinearLayout(this);
    layout.addView(surfaceView,sketchWidth(),sketchHeight());
    overallLayout.addView(layout,lp);
    window.setContentView(overallLayout);
  }
  finished=false;
  looping=true;
  redraw=true;
  firstMotion=true;
  Context context=getApplicationContext();
  sketchPath=context.getFilesDir().getAbsolutePath();
  handler=new Handler();
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  start();
}","/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (DEBUG)   println(""String_Node_Str"" + Thread.currentThread().getName());
  Window window=getWindow();
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  window.setFlags(WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
  window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  DisplayMetrics dm=new DisplayMetrics();
  getWindowManager().getDefaultDisplay().getMetrics(dm);
  screenWidth=dm.widthPixels;
  screenHeight=dm.heightPixels;
  if (DEBUG)   println(""String_Node_Str"" + dm);
  int sw=sketchWidth();
  int sh=sketchHeight();
  if (sketchRenderer().equals(A2D)) {
    surfaceView=new SketchSurfaceView2D(this,sw,sh);
  }
 else   if (sketchRenderer().equals(A3D)) {
    surfaceView=new SketchSurfaceView3D(this,sw,sh);
  }
  g=((SketchSurfaceView)surfaceView).getGraphics();
  if (sw == screenWidth && sh == screenHeight) {
    window.setContentView(surfaceView);
  }
 else {
    RelativeLayout overallLayout=new RelativeLayout(this);
    RelativeLayout.LayoutParams lp=new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT,RelativeLayout.LayoutParams.WRAP_CONTENT);
    lp.addRule(RelativeLayout.CENTER_IN_PARENT);
    LinearLayout layout=new LinearLayout(this);
    layout.addView(surfaceView,sketchWidth(),sketchHeight());
    overallLayout.addView(layout,lp);
    window.setContentView(overallLayout);
  }
  finished=false;
  looping=true;
  redraw=true;
  firstMotion=true;
  sizeMethods=new RegisteredMethods();
  preMethods=new RegisteredMethods();
  drawMethods=new RegisteredMethods();
  postMethods=new RegisteredMethods();
  mouseEventMethods=new RegisteredMethods();
  keyEventMethods=new RegisteredMethods();
  disposeMethods=new RegisteredMethods();
  Context context=getApplicationContext();
  sketchPath=context.getFilesDir().getAbsolutePath();
  handler=new Handler();
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  start();
}",0.928696522391794
163696,"protected void copyToTexture(IntBuffer buffer,int glid,int gltarget){
  gl.glEnable(gltarget);
  gl.glBindTexture(gltarget,glid);
  gl.glTexSubImage2D(gltarget,0,0,0,width,height,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,buffer);
  gl.glDisable(gltarget);
}","protected void copyToTexture(IntBuffer buffer,int glid,int gltarget){
  gl.glEnable(gltarget);
  gl.glBindTexture(gltarget,glid);
  gl.glTexSubImage2D(gltarget,0,0,0,width,height,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,buffer);
  gl.glBindTexture(gltarget,0);
  gl.glDisable(gltarget);
}",0.9398496240601504
163697,"protected void clearMultitextureBlend(int num){
  for (int i=0; i < num; i++) {
    gl11.glActiveTexture(GL11.GL_TEXTURE0 + i);
    gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_MODULATE);
  }
}","protected void clearMultitextureBlend(int num){
  for (int i=0; i < num; i++) {
    gl11.glActiveTexture(GL11.GL_TEXTURE0 + i);
    gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_MODULATE);
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
}",0.86
163698,"protected void setMultitextureBlend(PTexture[] textures,int num){
  if (2 < num) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  if (!texenvCrossbarSupported) {
    PGraphics.showWarning(""String_Node_Str"");
    if (multitexureBlendMode == REPLACE) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
    }
 else     if (multitexureBlendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
    }
 else     if (multitexureBlendMode == MULTIPLY) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (multitexureBlendMode == ADD) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (multitexureBlendMode == SUBTRACT) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
 else {
    if (multitexureBlendMode == REPLACE) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_REPLACE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_REPLACE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == MULTIPLY) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == ADD) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == SUBTRACT) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
}","protected void setMultitextureBlend(PTexture[] textures,int num){
  if (2 < num) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  if (!texenvCrossbarSupported) {
    PGraphics.showWarning(""String_Node_Str"");
    if (multitexureBlendMode == REPLACE) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
    }
 else     if (multitexureBlendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
    }
 else     if (multitexureBlendMode == MULTIPLY) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (multitexureBlendMode == ADD) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (multitexureBlendMode == SUBTRACT) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
 else {
    if (multitexureBlendMode == REPLACE) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_REPLACE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_REPLACE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == MULTIPLY) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == ADD) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == SUBTRACT) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
  gl.glDisable(GL10.GL_BLEND);
}",0.9986878306878308
163699,"protected void drawTexture(PTexture tex,int[] crop,int x,int y,int w,int h){
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_REPLACE);
  gl11.glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,crop,0);
  gl11x.glDrawTexiOES(x,y,0,w,h);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_MODULATE);
  gl.glDisable(tex.getGLTarget());
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
}","protected void drawTexture(PTexture tex,int[] crop,int x,int y,int w,int h){
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_REPLACE);
  gl11.glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,crop,0);
  gl11x.glDrawTexiOES(x,y,0,w,h);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_MODULATE);
  gl.glBindTexture(tex.getGLTarget(),0);
  gl.glDisable(tex.getGLTarget());
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
}",0.971704623878537
163700,"protected void copyToTexture(PTexture tex,IntBuffer buffer,int x,int y,int w,int h){
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
  gl.glTexSubImage2D(tex.getGLTarget(),0,x,y,w,h,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,buffer);
  gl.glDisable(tex.getGLTarget());
}","protected void copyToTexture(PTexture tex,IntBuffer buffer,int x,int y,int w,int h){
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
  gl.glTexSubImage2D(tex.getGLTarget(),0,x,y,w,h,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,buffer);
  gl.glBindTexture(tex.getGLTarget(),0);
  gl.glDisable(tex.getGLTarget());
}",0.9362363919129082
163701,"/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
    if (a3d.lights) {
      noLights();
    }
  }
  if (!settingsInited) {
    defaultSettings();
  }
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  normalBuffer.rewind();
  for (int t=0; t < numTexBuffers; t++) {
    texCoordBuffer[t].rewind();
  }
  numMultitextures=0;
  clearMultitextures();
  clearMultitextures0();
  gl.glShadeModel(GL10.GL_SMOOTH);
  blend(BLEND);
  textureBlend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  gl.glViewport(0,0,width,height);
  camera();
  perspective();
  lights=false;
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glFrontFace(GL10.GL_CW);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  gl.glLightModelfv(GL10.GL_LIGHT_MODEL_AMBIENT,baseLight,0);
  gl.glLightModelx(GL10.GL_LIGHT_MODEL_TWO_SIDE,0);
  shapeFirst=0;
  normalX=normalY=normalZ=0;
  if (primarySurface) {
    if (parent.frameCount == 0) {
      if (fboSupported) {
        if (offscreenFramebuffer == null) {
          createOffscreenFramebuffer();
        }
      }
 else {
        if (gl11 == null || gl11x == null) {
          throw new RuntimeException(""String_Node_Str"");
        }
        if (texture == null) {
          createScreenTexture();
        }
      }
    }
    if (clearColorBuffer) {
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      if (fboSupported) {
        if (offscreenFramebuffer != null) {
          pushFramebuffer();
          setFramebuffer(offscreenFramebuffer);
          offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
          gl.glClearColor(0,0,0,0);
          if (parent.frameCount == 0) {
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          }
 else {
            gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
            drawOffscreenTexture((offscreenIndex + 1) % 2);
          }
        }
      }
 else {
        if (texture != null) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          if (0 < parent.frameCount) {
            drawScreenTexture();
          }
        }
      }
    }
  }
 else {
    if (offscreenFramebuffer == null) {
      createOffscreenFramebuffer();
    }
    pushFramebuffer();
    setFramebuffer(offscreenFramebuffer);
    offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
    gl.glClearColor(0,0,0,0);
    if (clearColorBuffer || parent.frameCount == 0) {
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
      drawOffscreenTexture((offscreenIndex + 1) % 2);
    }
  }
  clearColorBuffer0=clearColorBuffer;
  report(""String_Node_Str"");
}","/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
  }
  if (!settingsInited) {
    defaultSettings();
  }
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  normalBuffer.rewind();
  for (int t=0; t < numTexBuffers; t++) {
    texCoordBuffer[t].rewind();
  }
  numMultitextures=0;
  clearMultitextures();
  clearMultitextures0();
  gl.glShadeModel(GL10.GL_SMOOTH);
  blend(BLEND);
  textureBlend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  gl.glViewport(0,0,width,height);
  camera();
  perspective();
  noLights();
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glFrontFace(GL10.GL_CW);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  gl.glLightModelfv(GL10.GL_LIGHT_MODEL_AMBIENT,baseLight,0);
  gl.glLightModelx(GL10.GL_LIGHT_MODEL_TWO_SIDE,0);
  shapeFirst=0;
  normalX=normalY=normalZ=0;
  if (primarySurface) {
    if (parent.frameCount == 0) {
      if (fboSupported) {
        if (offscreenFramebuffer == null) {
          createOffscreenFramebuffer();
        }
      }
 else {
        if (gl11 == null || gl11x == null) {
          throw new RuntimeException(""String_Node_Str"");
        }
        if (texture == null) {
          createScreenTexture();
        }
      }
    }
    if (clearColorBuffer) {
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      if (fboSupported) {
        if (offscreenFramebuffer != null) {
          pushFramebuffer();
          setFramebuffer(offscreenFramebuffer);
          offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
          gl.glClearColor(0,0,0,0);
          if (parent.frameCount == 0) {
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          }
 else {
            gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
            drawOffscreenTexture((offscreenIndex + 1) % 2);
          }
        }
      }
 else {
        if (texture != null) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          if (0 < parent.frameCount) {
            drawScreenTexture();
          }
        }
      }
    }
  }
 else {
    if (offscreenFramebuffer == null) {
      createOffscreenFramebuffer();
    }
    pushFramebuffer();
    setFramebuffer(offscreenFramebuffer);
    offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
    gl.glClearColor(0,0,0,0);
    if (clearColorBuffer || parent.frameCount == 0) {
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
      drawOffscreenTexture((offscreenIndex + 1) % 2);
    }
  }
  clearColorBuffer0=clearColorBuffer;
  report(""String_Node_Str"");
}",0.9893187066974596
163702,"protected void addNewFace(boolean firstFace,PImage[] images){
  if (faceCount == faceOffset.length) {
    faceOffset=PApplet.expand(faceOffset);
    faceLength=PApplet.expand(faceLength);
    PImage tempi[][]=new PImage[faceCount << 1][MAX_TEXTURES];
    PApplet.arrayCopy(faceTextures,0,tempi,0,faceCount);
    faceTextures=tempi;
  }
  faceOffset[faceCount]=firstFace ? 0 : triangleCount;
  faceLength[faceCount]=1;
  PImage p[]=faceTextures[faceCount];
  if (1 < numMultitextures) {
    PApplet.arrayCopy(images,0,p,0,numMultitextures);
  }
  if (0 < numMultitextures) {
    p[0]=images[0];
  }
 else {
    p[0]=null;
  }
  faceCount++;
}","protected void addNewFace(boolean firstFace,PImage[] images){
  if (faceCount == faceOffset.length) {
    faceOffset=PApplet.expand(faceOffset);
    faceLength=PApplet.expand(faceLength);
    PImage tempi[][]=new PImage[faceCount << 1][MAX_TEXTURES];
    PApplet.arrayCopy(faceTextures,0,tempi,0,faceCount);
    faceTextures=tempi;
  }
  faceOffset[faceCount]=firstFace ? 0 : triangleCount;
  faceLength[faceCount]=1;
  PImage p[]=faceTextures[faceCount];
  if (1 < numMultitextures) {
    PApplet.arrayCopy(images,0,p,0,numMultitextures);
  }
  if (0 < numMultitextures) {
    p[0]=images[0];
  }
 else {
    p[0]=null;
  }
  java.util.Arrays.fill(p,numMultitextures,maxTextureUnits,null);
  faceCount++;
}",0.9510385756676558
163703,"protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  int numTextures=0;
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=start; j < stop; j++) {
    int i=faceOffset[j];
    PImage[] images=faceTextures[j];
    if (1 < numMultitextures) {
      for (int t=0; t < numMultitextures; t++) {
        if (images[t] != null) {
          PTexture tex=images[t].getTexture();
          if (tex == null) {
            tex=images[t].createTexture();
            if (tex == null) {
              break;
            }
          }
          gl.glEnable(tex.getGLTarget());
          gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
          gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
          renderTextures[numTextures]=tex;
          numTextures++;
        }
 else {
          break;
        }
      }
    }
 else     if (images[0] != null) {
      PTexture tex=images[0].getTexture();
      if (tex == null) {
        tex=images[0].createTexture();
      }
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glActiveTexture(GL10.GL_TEXTURE0);
        gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
        renderTextures[0]=tex;
        numTextures=1;
      }
    }
    if (0 < numTextures) {
      if (numTexBuffers < numTextures) {
        addTexBuffers(numTextures - numTexBuffers);
      }
      gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
      if (1 < numTextures) {
        setMultitextureBlend(renderTextures,numTextures);
      }
    }
    if (recordingShape) {
      numRecordedTextures=PApplet.max(numRecordedTextures,numTextures);
      int n0=recordedVertices.size();
      int n1=n0 + 3 * faceLength[j] - 1;
      PShape3D child=(PShape3D)PShape3D.createChild(""String_Node_Str"" + recordedChildren.size(),n0,n1,TRIANGLES,0,images);
      recordedChildren.add(child);
    }
    int size=3 * faceLength[j];
    while (vertexBuffer.capacity() / 3 < size) {
      expandBuffers();
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    for (int t=0; t < numTextures; t++) {
      texCoordBuffer[t].position(0);
    }
    int n=0;
    for (int k=0; k < faceLength[j]; k++) {
      int na=triangles[i][VERTEX1];
      int nb=triangles[i][VERTEX2];
      int nc=triangles[i][VERTEX3];
      float a[]=vertices[na];
      float b[]=vertices[nb];
      float c[]=vertices[nc];
      if (autoNormal && (a[HAS_NORMAL] == 0 || b[HAS_NORMAL] == 0 || c[HAS_NORMAL] == 0)) {
        float x1=b[X] - a[X];
        float y1=b[Y] - a[Y];
        float z1=b[Z] - a[Z];
        float x2=b[X] - c[X];
        float y2=b[Y] - c[Y];
        float z2=b[Z] - c[Z];
        float cx=y1 * z2 - y2 * z1;
        float cy=z1 * x2 - z2 * x1;
        float cz=x1 * y2 - x2 * y1;
        float norm=PApplet.sqrt(cx * cx + cy * cy + cz * cz);
        cx/=norm;
        cy/=norm;
        cz/=norm;
        a[NX]=b[NX]=c[NX]=cx;
        a[NY]=b[NY]=c[NY]=cy;
        a[NZ]=b[NZ]=c[NZ]=cz;
        a[HAS_NORMAL]=b[HAS_NORMAL]=c[HAS_NORMAL]=1;
      }
      if (numTextures == 1) {
        float uscale=1.0f;
        float vscale=1.0f;
        float cx=0.0f;
        float sx=+1.0f;
        float cy=0.0f;
        float sy=+1.0f;
        PTexture tex=renderTextures[0];
        uscale*=tex.getMaxTexCoordU();
        vscale*=tex.getMaxTexCoordV();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
        renderUa[0]=(cx + sx * a[U]) * uscale;
        renderVa[0]=(cy + sy * a[V]) * vscale;
        renderUb[0]=(cx + sx * b[U]) * uscale;
        renderVb[0]=(cy + sy * b[V]) * vscale;
        renderUc[0]=(cx + sx * c[U]) * uscale;
        renderVc[0]=(cy + sy * c[V]) * vscale;
      }
 else       if (1 < numTextures) {
        for (int t=0; t < numTextures; t++) {
          float uscale=1.0f;
          float vscale=1.0f;
          float cx=0.0f;
          float sx=+1.0f;
          float cy=0.0f;
          float sy=+1.0f;
          PTexture tex=renderTextures[t];
          uscale*=tex.getMaxTexCoordU();
          vscale*=tex.getMaxTexCoordV();
          if (tex.isFlippedX()) {
            cx=1.0f;
            sx=-1.0f;
          }
          if (tex.isFlippedY()) {
            cy=1.0f;
            sy=-1.0f;
          }
          renderUa[t]=(cx + sx * vertexU[na][t]) * uscale;
          renderVa[t]=(cy + sy * vertexV[na][t]) * vscale;
          renderUb[t]=(cx + sx * vertexU[nb][t]) * uscale;
          renderVb[t]=(cy + sy * vertexV[nb][t]) * vscale;
          renderUc[t]=(cx + sx * vertexU[nc][t]) * uscale;
          renderVc[t]=(cy + sy * vertexV[nc][t]) * vscale;
        }
      }
      if (recordingShape) {
        recordedVertices.add(new PVector(a[X],a[Y],a[Z]));
        recordedColors.add(new float[]{a[R],a[G],a[B],a[A]});
        recordedNormals.add(new PVector(a[NX],a[NY],a[NZ]));
        for (int t=0; t < numTextures; t++) {
          recordedTexCoords[t].add(new PVector(renderUa[t],renderVa[t],0.0f));
        }
        for (int t=numTextures; t < maxTextureUnits; t++) {
          recordedTexCoords[t].add(new PVector(0.0f,0.0f,0.0f));
        }
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(a[X]);
        vertexArray[3 * n + 1]=toFixed32(a[Y]);
        vertexArray[3 * n + 2]=toFixed32(a[Z]);
        colorArray[4 * n + 0]=toFixed32(a[R]);
        colorArray[4 * n + 1]=toFixed32(a[G]);
        colorArray[4 * n + 2]=toFixed32(a[B]);
        colorArray[4 * n + 3]=toFixed32(a[A]);
        normalArray[3 * n + 0]=toFixed32(a[NX]);
        normalArray[3 * n + 1]=toFixed32(a[NY]);
        normalArray[3 * n + 2]=toFixed32(a[NZ]);
        for (int t=0; t < numTextures; t++) {
          texCoordArray[t][2 * n + 0]=toFixed32(renderUa[t]);
          texCoordArray[t][2 * n + 1]=toFixed32(renderVa[t]);
        }
        n++;
      }
      if (recordingShape) {
        recordedVertices.add(new PVector(b[X],b[Y],b[Z]));
        recordedColors.add(new float[]{b[R],b[G],b[B],b[A]});
        recordedNormals.add(new PVector(b[NX],b[NY],b[NZ]));
        for (int t=0; t < numTextures; t++) {
          recordedTexCoords[t].add(new PVector(renderUb[t],renderVb[t],0.0f));
        }
        for (int t=numTextures; t < maxTextureUnits; t++) {
          recordedTexCoords[t].add(new PVector(0.0f,0.0f,0.0f));
        }
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(b[X]);
        vertexArray[3 * n + 1]=toFixed32(b[Y]);
        vertexArray[3 * n + 2]=toFixed32(b[Z]);
        colorArray[4 * n + 0]=toFixed32(b[R]);
        colorArray[4 * n + 1]=toFixed32(b[G]);
        colorArray[4 * n + 2]=toFixed32(b[B]);
        colorArray[4 * n + 3]=toFixed32(b[A]);
        normalArray[3 * n + 0]=toFixed32(b[NX]);
        normalArray[3 * n + 1]=toFixed32(b[NY]);
        normalArray[3 * n + 2]=toFixed32(b[NZ]);
        for (int t=0; t < numTextures; t++) {
          texCoordArray[t][2 * n + 0]=toFixed32(renderUb[t]);
          texCoordArray[t][2 * n + 1]=toFixed32(renderVb[t]);
        }
        n++;
      }
      if (recordingShape) {
        recordedVertices.add(new PVector(c[X],c[Y],c[Z]));
        recordedColors.add(new float[]{c[R],c[G],c[B],c[A]});
        recordedNormals.add(new PVector(c[NX],c[NY],c[NZ]));
        for (int t=0; t < numTextures; t++) {
          recordedTexCoords[t].add(new PVector(renderUc[t],renderVc[t],0.0f));
        }
        for (int t=numTextures; t < maxTextureUnits; t++) {
          recordedTexCoords[t].add(new PVector(0.0f,0.0f,0.0f));
        }
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(c[X]);
        vertexArray[3 * n + 1]=toFixed32(c[Y]);
        vertexArray[3 * n + 2]=toFixed32(c[Z]);
        colorArray[4 * n + 0]=toFixed32(c[R]);
        colorArray[4 * n + 1]=toFixed32(c[G]);
        colorArray[4 * n + 2]=toFixed32(c[B]);
        colorArray[4 * n + 3]=toFixed32(c[A]);
        normalArray[3 * n + 0]=toFixed32(c[NX]);
        normalArray[3 * n + 1]=toFixed32(c[NY]);
        normalArray[3 * n + 2]=toFixed32(c[NZ]);
        for (int t=0; t < numTextures; t++) {
          texCoordArray[t][2 * n + 0]=toFixed32(renderUc[t]);
          texCoordArray[t][2 * n + 1]=toFixed32(renderVc[t]);
        }
        n++;
      }
      i++;
    }
    if (!recordingShape) {
      vertexBuffer.put(vertexArray);
      colorBuffer.put(colorArray);
      normalBuffer.put(normalArray);
      for (int t=0; t < numTextures; t++) {
        texCoordBuffer[t].put(texCoordArray[t]);
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      normalBuffer.position(0);
      for (int t=0; t < numTextures; t++) {
        texCoordBuffer[t].position(0);
      }
      gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
      gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
      gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
      for (int t=0; t < numTextures; t++) {
        gl.glClientActiveTexture(GL10.GL_TEXTURE0 + t);
        gl.glTexCoordPointer(2,GL10.GL_FIXED,0,texCoordBuffer[t]);
      }
      gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    }
    if (0 < numTextures) {
      if (1 < numTextures) {
        clearMultitextureBlend(numTextures);
      }
      for (int t=0; t < numTextures; t++) {
        PTexture tex=renderTextures[t];
        gl.glDisable(tex.getGLTarget());
      }
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  report(""String_Node_Str"");
}","protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  int numTextures=0;
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=start; j < stop; j++) {
    int i=faceOffset[j];
    PImage[] images=faceTextures[j];
    if (1 < numMultitextures) {
      for (int t=0; t < numMultitextures; t++) {
        if (images[t] != null) {
          PTexture tex=images[t].getTexture();
          if (tex == null) {
            tex=images[t].createTexture();
            if (tex == null) {
              break;
            }
          }
          gl.glEnable(tex.getGLTarget());
          gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
          gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
          renderTextures[numTextures]=tex;
          numTextures++;
        }
 else {
          break;
        }
      }
    }
 else     if (images[0] != null) {
      PTexture tex=images[0].getTexture();
      if (tex == null) {
        tex=images[0].createTexture();
      }
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glActiveTexture(GL10.GL_TEXTURE0);
        gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
        renderTextures[0]=tex;
        numTextures=1;
      }
    }
    if (0 < numTextures) {
      if (numTexBuffers < numTextures) {
        addTexBuffers(numTextures - numTexBuffers);
      }
      gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
      if (1 < numTextures) {
        setMultitextureBlend(renderTextures,numTextures);
      }
    }
    if (recordingShape) {
      numRecordedTextures=PApplet.max(numRecordedTextures,numTextures);
      int n0=recordedVertices.size();
      int n1=n0 + 3 * faceLength[j] - 1;
      PShape3D child=(PShape3D)PShape3D.createChild(""String_Node_Str"" + recordedChildren.size(),n0,n1,TRIANGLES,0,images);
      recordedChildren.add(child);
    }
    int size=3 * faceLength[j];
    while (vertexBuffer.capacity() / 3 < size) {
      expandBuffers();
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    for (int t=0; t < numTextures; t++) {
      texCoordBuffer[t].position(0);
    }
    int n=0;
    for (int k=0; k < faceLength[j]; k++) {
      int na=triangles[i][VERTEX1];
      int nb=triangles[i][VERTEX2];
      int nc=triangles[i][VERTEX3];
      float a[]=vertices[na];
      float b[]=vertices[nb];
      float c[]=vertices[nc];
      if (autoNormal && (a[HAS_NORMAL] == 0 || b[HAS_NORMAL] == 0 || c[HAS_NORMAL] == 0)) {
        float x1=b[X] - a[X];
        float y1=b[Y] - a[Y];
        float z1=b[Z] - a[Z];
        float x2=b[X] - c[X];
        float y2=b[Y] - c[Y];
        float z2=b[Z] - c[Z];
        float cx=y1 * z2 - y2 * z1;
        float cy=z1 * x2 - z2 * x1;
        float cz=x1 * y2 - x2 * y1;
        float norm=PApplet.sqrt(cx * cx + cy * cy + cz * cz);
        cx/=norm;
        cy/=norm;
        cz/=norm;
        a[NX]=b[NX]=c[NX]=cx;
        a[NY]=b[NY]=c[NY]=cy;
        a[NZ]=b[NZ]=c[NZ]=cz;
        a[HAS_NORMAL]=b[HAS_NORMAL]=c[HAS_NORMAL]=1;
      }
      if (numTextures == 1) {
        float uscale=1.0f;
        float vscale=1.0f;
        float cx=0.0f;
        float sx=+1.0f;
        float cy=0.0f;
        float sy=+1.0f;
        PTexture tex=renderTextures[0];
        uscale*=tex.getMaxTexCoordU();
        vscale*=tex.getMaxTexCoordV();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
        renderUa[0]=(cx + sx * a[U]) * uscale;
        renderVa[0]=(cy + sy * a[V]) * vscale;
        renderUb[0]=(cx + sx * b[U]) * uscale;
        renderVb[0]=(cy + sy * b[V]) * vscale;
        renderUc[0]=(cx + sx * c[U]) * uscale;
        renderVc[0]=(cy + sy * c[V]) * vscale;
      }
 else       if (1 < numTextures) {
        for (int t=0; t < numTextures; t++) {
          float uscale=1.0f;
          float vscale=1.0f;
          float cx=0.0f;
          float sx=+1.0f;
          float cy=0.0f;
          float sy=+1.0f;
          PTexture tex=renderTextures[t];
          uscale*=tex.getMaxTexCoordU();
          vscale*=tex.getMaxTexCoordV();
          if (tex.isFlippedX()) {
            cx=1.0f;
            sx=-1.0f;
          }
          if (tex.isFlippedY()) {
            cy=1.0f;
            sy=-1.0f;
          }
          renderUa[t]=(cx + sx * vertexU[na][t]) * uscale;
          renderVa[t]=(cy + sy * vertexV[na][t]) * vscale;
          renderUb[t]=(cx + sx * vertexU[nb][t]) * uscale;
          renderVb[t]=(cy + sy * vertexV[nb][t]) * vscale;
          renderUc[t]=(cx + sx * vertexU[nc][t]) * uscale;
          renderVc[t]=(cy + sy * vertexV[nc][t]) * vscale;
        }
      }
      if (recordingShape) {
        recordedVertices.add(new PVector(a[X],a[Y],a[Z]));
        recordedColors.add(new float[]{a[R],a[G],a[B],a[A]});
        recordedNormals.add(new PVector(a[NX],a[NY],a[NZ]));
        for (int t=0; t < numTextures; t++) {
          recordedTexCoords[t].add(new PVector(renderUa[t],renderVa[t],0.0f));
        }
        for (int t=numTextures; t < maxTextureUnits; t++) {
          recordedTexCoords[t].add(new PVector(0.0f,0.0f,0.0f));
        }
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(a[X]);
        vertexArray[3 * n + 1]=toFixed32(a[Y]);
        vertexArray[3 * n + 2]=toFixed32(a[Z]);
        colorArray[4 * n + 0]=toFixed32(a[R]);
        colorArray[4 * n + 1]=toFixed32(a[G]);
        colorArray[4 * n + 2]=toFixed32(a[B]);
        colorArray[4 * n + 3]=toFixed32(a[A]);
        normalArray[3 * n + 0]=toFixed32(a[NX]);
        normalArray[3 * n + 1]=toFixed32(a[NY]);
        normalArray[3 * n + 2]=toFixed32(a[NZ]);
        for (int t=0; t < numTextures; t++) {
          texCoordArray[t][2 * n + 0]=toFixed32(renderUa[t]);
          texCoordArray[t][2 * n + 1]=toFixed32(renderVa[t]);
        }
        n++;
      }
      if (recordingShape) {
        recordedVertices.add(new PVector(b[X],b[Y],b[Z]));
        recordedColors.add(new float[]{b[R],b[G],b[B],b[A]});
        recordedNormals.add(new PVector(b[NX],b[NY],b[NZ]));
        for (int t=0; t < numTextures; t++) {
          recordedTexCoords[t].add(new PVector(renderUb[t],renderVb[t],0.0f));
        }
        for (int t=numTextures; t < maxTextureUnits; t++) {
          recordedTexCoords[t].add(new PVector(0.0f,0.0f,0.0f));
        }
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(b[X]);
        vertexArray[3 * n + 1]=toFixed32(b[Y]);
        vertexArray[3 * n + 2]=toFixed32(b[Z]);
        colorArray[4 * n + 0]=toFixed32(b[R]);
        colorArray[4 * n + 1]=toFixed32(b[G]);
        colorArray[4 * n + 2]=toFixed32(b[B]);
        colorArray[4 * n + 3]=toFixed32(b[A]);
        normalArray[3 * n + 0]=toFixed32(b[NX]);
        normalArray[3 * n + 1]=toFixed32(b[NY]);
        normalArray[3 * n + 2]=toFixed32(b[NZ]);
        for (int t=0; t < numTextures; t++) {
          texCoordArray[t][2 * n + 0]=toFixed32(renderUb[t]);
          texCoordArray[t][2 * n + 1]=toFixed32(renderVb[t]);
        }
        n++;
      }
      if (recordingShape) {
        recordedVertices.add(new PVector(c[X],c[Y],c[Z]));
        recordedColors.add(new float[]{c[R],c[G],c[B],c[A]});
        recordedNormals.add(new PVector(c[NX],c[NY],c[NZ]));
        for (int t=0; t < numTextures; t++) {
          recordedTexCoords[t].add(new PVector(renderUc[t],renderVc[t],0.0f));
        }
        for (int t=numTextures; t < maxTextureUnits; t++) {
          recordedTexCoords[t].add(new PVector(0.0f,0.0f,0.0f));
        }
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(c[X]);
        vertexArray[3 * n + 1]=toFixed32(c[Y]);
        vertexArray[3 * n + 2]=toFixed32(c[Z]);
        colorArray[4 * n + 0]=toFixed32(c[R]);
        colorArray[4 * n + 1]=toFixed32(c[G]);
        colorArray[4 * n + 2]=toFixed32(c[B]);
        colorArray[4 * n + 3]=toFixed32(c[A]);
        normalArray[3 * n + 0]=toFixed32(c[NX]);
        normalArray[3 * n + 1]=toFixed32(c[NY]);
        normalArray[3 * n + 2]=toFixed32(c[NZ]);
        for (int t=0; t < numTextures; t++) {
          texCoordArray[t][2 * n + 0]=toFixed32(renderUc[t]);
          texCoordArray[t][2 * n + 1]=toFixed32(renderVc[t]);
        }
        n++;
      }
      i++;
    }
    if (!recordingShape) {
      vertexBuffer.put(vertexArray);
      colorBuffer.put(colorArray);
      normalBuffer.put(normalArray);
      for (int t=0; t < numTextures; t++) {
        texCoordBuffer[t].put(texCoordArray[t]);
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      normalBuffer.position(0);
      for (int t=0; t < numTextures; t++) {
        texCoordBuffer[t].position(0);
      }
      gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
      gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
      gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
      for (int t=0; t < numTextures; t++) {
        gl.glClientActiveTexture(GL10.GL_TEXTURE0 + t);
        gl.glTexCoordPointer(2,GL10.GL_FIXED,0,texCoordBuffer[t]);
      }
      gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    }
    if (0 < numTextures) {
      if (1 < numTextures) {
        clearMultitextureBlend(numTextures);
      }
      for (int t=0; t < numTextures; t++) {
        PTexture tex=renderTextures[t];
        gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
        gl.glBindTexture(tex.getGLTarget(),0);
      }
      for (int t=0; t < numTextures; t++) {
        PTexture tex=renderTextures[t];
        gl.glDisable(tex.getGLTarget());
      }
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  report(""String_Node_Str"");
}",0.9903240669636
163704,"protected void drawGeometry(PGraphics g){
  PShape3D p3d=(PShape3D)parent;
  int numTextures;
  float pointSize;
  pointSize=PApplet.min(g.strokeWeight,PGraphicsAndroid3D.maxPointSize);
  gl.glPointSize(pointSize);
  gl.glEnableClientState(GL11.GL_NORMAL_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glNormalBufferID);
  gl.glNormalPointer(GL11.GL_FLOAT,0,0);
  if (p3d.vertexColor) {
    gl.glEnableClientState(GL11.GL_COLOR_ARRAY);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glColorBufferID);
    gl.glColorPointer(4,GL11.GL_FLOAT,0,0);
  }
  gl.glEnableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glVertexBufferID);
  gl.glVertexPointer(3,GL11.GL_FLOAT,0,0);
  numTextures=0;
  for (int t=0; t < textures.length; t++) {
    if (textures[t] != null) {
      PTexture tex=textures[t].getTexture();
      if (tex == null) {
        tex=textures[t].createTexture();
        if (tex == null) {
          break;
        }
      }
      gl.glEnable(tex.getGLTarget());
      gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
      gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
      renderTextures[numTextures]=tex;
      numTextures++;
    }
 else {
      break;
    }
  }
  if (0 < numTextures) {
    if (pointSprites) {
      gl.glPointParameterfv(GL11.GL_POINT_DISTANCE_ATTENUATION,ptDistAtt,0);
      gl.glPointParameterf(GL11.GL_POINT_FADE_THRESHOLD_SIZE,0.6f * pointSize);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MIN,1.0f);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MAX,PGraphicsAndroid3D.maxPointSize);
      gl.glTexEnvf(GL11.GL_POINT_SPRITE_OES,GL11.GL_COORD_REPLACE_OES,GL11.GL_TRUE);
      gl.glEnable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
      for (int t=0; t < numTextures; t++) {
        gl.glClientActiveTexture(GL11.GL_TEXTURE0 + t);
        gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glTexCoordBufferID[t]);
        gl.glTexCoordPointer(2,GL11.GL_FLOAT,0,0);
      }
      if (1 < numTextures) {
        a3d.setMultitextureBlend(renderTextures,numTextures);
      }
    }
  }
  if (!p3d.vertexColor) {
    if (0 < numTextures) {
      if (g.tint) {
        gl.glColor4f(g.tintR,g.tintG,g.tintB,g.tintA);
      }
 else {
        gl.glColor4f(1,1,1,1);
      }
    }
 else {
      gl.glColor4f(g.fillR,g.fillG,g.fillB,g.fillA);
    }
  }
  if (0 < strokeWeight) {
    gl.glLineWidth(strokeWeight);
  }
 else {
    gl.glLineWidth(g.strokeWeight);
  }
  gl.glDrawArrays(glMode,firstVertex,lastVertex - firstVertex + 1);
  if (0 < numTextures) {
    if (1 < numTextures) {
      a3d.clearMultitextureBlend(numTextures);
    }
    if (pointSprites) {
      gl.glDisable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
    }
    for (int t=0; t < numTextures; t++) {
      PTexture tex=renderTextures[t];
      gl.glDisable(tex.getGLTarget());
    }
  }
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  gl.glDisableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL11.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL11.GL_NORMAL_ARRAY);
}","protected void drawGeometry(PGraphics g){
  PShape3D p3d=(PShape3D)parent;
  int numTextures;
  float pointSize;
  pointSize=PApplet.min(g.strokeWeight,PGraphicsAndroid3D.maxPointSize);
  gl.glPointSize(pointSize);
  gl.glEnableClientState(GL11.GL_NORMAL_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glNormalBufferID);
  gl.glNormalPointer(GL11.GL_FLOAT,0,0);
  if (p3d.vertexColor) {
    gl.glEnableClientState(GL11.GL_COLOR_ARRAY);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glColorBufferID);
    gl.glColorPointer(4,GL11.GL_FLOAT,0,0);
  }
  gl.glEnableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glVertexBufferID);
  gl.glVertexPointer(3,GL11.GL_FLOAT,0,0);
  numTextures=0;
  for (int t=0; t < textures.length; t++) {
    if (textures[t] != null) {
      PTexture tex=textures[t].getTexture();
      if (tex == null) {
        tex=textures[t].createTexture();
        if (tex == null) {
          break;
        }
      }
      gl.glEnable(tex.getGLTarget());
      gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
      gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
      renderTextures[numTextures]=tex;
      numTextures++;
    }
 else {
      break;
    }
  }
  if (0 < numTextures) {
    if (pointSprites) {
      gl.glPointParameterfv(GL11.GL_POINT_DISTANCE_ATTENUATION,ptDistAtt,0);
      gl.glPointParameterf(GL11.GL_POINT_FADE_THRESHOLD_SIZE,0.6f * pointSize);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MIN,1.0f);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MAX,PGraphicsAndroid3D.maxPointSize);
      gl.glTexEnvf(GL11.GL_POINT_SPRITE_OES,GL11.GL_COORD_REPLACE_OES,GL11.GL_TRUE);
      gl.glEnable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
      for (int t=0; t < numTextures; t++) {
        gl.glClientActiveTexture(GL11.GL_TEXTURE0 + t);
        gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glTexCoordBufferID[t]);
        gl.glTexCoordPointer(2,GL11.GL_FLOAT,0,0);
      }
      if (1 < numTextures) {
        a3d.setMultitextureBlend(renderTextures,numTextures);
      }
    }
  }
  if (!p3d.vertexColor) {
    if (0 < numTextures) {
      if (g.tint) {
        gl.glColor4f(g.tintR,g.tintG,g.tintB,g.tintA);
      }
 else {
        gl.glColor4f(1,1,1,1);
      }
    }
 else {
      gl.glColor4f(g.fillR,g.fillG,g.fillB,g.fillA);
    }
  }
  if (0 < strokeWeight) {
    gl.glLineWidth(strokeWeight);
  }
 else {
    gl.glLineWidth(g.strokeWeight);
  }
  gl.glDrawArrays(glMode,firstVertex,lastVertex - firstVertex + 1);
  if (0 < numTextures) {
    if (1 < numTextures) {
      a3d.clearMultitextureBlend(numTextures);
    }
    if (pointSprites) {
      gl.glDisable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
    }
    for (int t=0; t < numTextures; t++) {
      PTexture tex=renderTextures[t];
      gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
      gl.glBindTexture(tex.getGLTarget(),0);
    }
    for (int t=0; t < numTextures; t++) {
      PTexture tex=renderTextures[t];
      gl.glDisable(tex.getGLTarget());
    }
  }
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  gl.glDisableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL11.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL11.GL_NORMAL_ARRAY);
}",0.9720618073981584
163705,"protected void loadTexcoords(int unit,int first,int last){
  if (last < first || first < 0 || vertexCount <= last) {
    PGraphics.showWarning(""String_Node_Str"");
    updateElement=-1;
    return;
  }
  if (updateElement != -1) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  if (PGraphicsAndroid3D.maxTextureUnits <= unit) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  updateElement=TEXCOORDS;
  firstUpdateIdx=first;
  lastUpdateIdx=last;
  if (numTexBuffers <= unit) {
    addTexBuffers(unit - numTexBuffers + 1);
  }
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glTexCoordBufferID[unit]);
  int offset=first * 2;
  int size=(last - first + 1) * 2;
  texCoordBuffer.limit(texCoordBuffer.capacity());
  texCoordBuffer.rewind();
  texCoordBuffer.get(texcoords,offset,size);
  updateTexunit=unit;
}","protected void loadTexcoords(int unit,int first,int last){
  if (last < first || first < 0 || vertexCount <= last) {
    PGraphics.showWarning(""String_Node_Str"");
    updateElement=-1;
    return;
  }
  if (updateElement != -1) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  if (PGraphicsAndroid3D.maxTextureUnits <= unit) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  updateElement=TEXCOORDS;
  firstUpdateIdx=first;
  lastUpdateIdx=last;
  if (numTexBuffers <= unit) {
    addTexBuffers(unit - numTexBuffers + 1);
  }
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glTexCoordBufferID[unit]);
  int offset=first * 2;
  int size=(last - first + 1) * 2;
  texCoordBuffer.limit(texCoordBuffer.capacity());
  texCoordBuffer.rewind();
  texCoordBuffer.get(texcoords,offset,size);
  normalizeTexcoords(unit);
  updateTexunit=unit;
}",0.9774881516587678
163706,"public void updateTexcoords(){
  if (updateElement == TEXCOORDS) {
    int offset=firstUpdateIdx * 2;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 2;
    texCoordBuffer.position(0);
    texCoordBuffer.put(texcoords,offset,size);
    texCoordBuffer.flip();
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * PGraphicsAndroid3D.SIZEOF_FLOAT,size * PGraphicsAndroid3D.SIZEOF_FLOAT,texCoordBuffer);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
    texCoordSet[updateTexunit]=true;
    updateElement=-1;
  }
 else {
    PGraphics.showWarning(""String_Node_Str"");
  }
}","public void updateTexcoords(){
  if (updateElement == TEXCOORDS) {
    int offset=firstUpdateIdx * 2;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 2;
    unnormalizeTexcoords(updateTexunit);
    texCoordBuffer.position(0);
    texCoordBuffer.put(texcoords,offset,size);
    texCoordBuffer.flip();
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * PGraphicsAndroid3D.SIZEOF_FLOAT,size * PGraphicsAndroid3D.SIZEOF_FLOAT,texCoordBuffer);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
    texCoordSet[updateTexunit]=true;
    updateElement=-1;
  }
 else {
    PGraphics.showWarning(""String_Node_Str"");
  }
}",0.9653423499577346
163707,"/** 
 * Creates the opengl texture object.
 * @param w int
 * @param h int  
 */
protected void createTexture(int w,int h){
  deleteTexture();
  if (PGraphicsAndroid3D.npotTexSupported) {
    glWidth=w;
    glHeight=h;
  }
 else {
    glWidth=nextPowerOfTwo(w);
    glHeight=nextPowerOfTwo(h);
  }
  if ((glWidth > PGraphicsAndroid3D.maxTextureSize) || (glHeight > PGraphicsAndroid3D.maxTextureSize)) {
    glWidth=glHeight=0;
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + PGraphicsAndroid3D.maxTextureSize + ""String_Node_Str"");
  }
  usingMipmaps=((glMinFilter == GL10.GL_NEAREST_MIPMAP_NEAREST) || (glMinFilter == GL10.GL_LINEAR_MIPMAP_NEAREST) || (glMinFilter == GL10.GL_NEAREST_MIPMAP_LINEAR)|| (glMinFilter == GL10.GL_LINEAR_MIPMAP_LINEAR));
  gl.glEnable(glTarget);
  glID=a3d.createGLResource(PGraphicsAndroid3D.GL_TEXTURE_OBJECT);
  gl.glBindTexture(glTarget,glID);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_MIN_FILTER,glMinFilter);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_MAG_FILTER,glMagFilter);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_WRAP_S,glWrapS);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_WRAP_T,glWrapT);
  gl.glTexImage2D(glTarget,0,glFormat,glWidth,glHeight,0,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,null);
  gl.glDisable(glTarget);
  flippedX=false;
  flippedY=false;
  maxTexCoordU=(float)w / glWidth;
  maxTexCoordV=(float)h / glHeight;
}","/** 
 * Creates the opengl texture object.
 * @param w int
 * @param h int  
 */
protected void createTexture(int w,int h){
  deleteTexture();
  if (PGraphicsAndroid3D.npotTexSupported) {
    glWidth=w;
    glHeight=h;
  }
 else {
    glWidth=nextPowerOfTwo(w);
    glHeight=nextPowerOfTwo(h);
  }
  if ((glWidth > PGraphicsAndroid3D.maxTextureSize) || (glHeight > PGraphicsAndroid3D.maxTextureSize)) {
    glWidth=glHeight=0;
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + PGraphicsAndroid3D.maxTextureSize + ""String_Node_Str"");
  }
  usingMipmaps=((glMinFilter == GL10.GL_NEAREST_MIPMAP_NEAREST) || (glMinFilter == GL10.GL_LINEAR_MIPMAP_NEAREST) || (glMinFilter == GL10.GL_NEAREST_MIPMAP_LINEAR)|| (glMinFilter == GL10.GL_LINEAR_MIPMAP_LINEAR));
  gl.glEnable(glTarget);
  glID=a3d.createGLResource(PGraphicsAndroid3D.GL_TEXTURE_OBJECT);
  gl.glBindTexture(glTarget,glID);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_MIN_FILTER,glMinFilter);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_MAG_FILTER,glMagFilter);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_WRAP_S,glWrapS);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_WRAP_T,glWrapT);
  gl.glTexImage2D(glTarget,0,glFormat,glWidth,glHeight,0,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,null);
  gl.glBindTexture(glTarget,0);
  gl.glDisable(glTarget);
  flippedX=false;
  flippedY=false;
  maxTexCoordU=(float)w / glWidth;
  maxTexCoordV=(float)h / glHeight;
}",0.9887005649717514
163708,"/** 
 * Sets the texture as flipped or not flipped on the vertical direction.
 * @param v boolean;
 */
protected void setFlippedY(boolean v){
  flippedY=v;
}","/** 
 * Sets the texture as flipped or not flipped on the vertical direction.
 * @param v boolean;
 */
public void setFlippedY(boolean v){
  flippedY=v;
}",0.964630225080386
163709,"protected void setMultitextureBlend(PTexture[] textures,int num){
  if (2 < num) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  gl.glDisable(GL10.GL_BLEND);
  if (!texenvCrossbarSupported) {
    PGraphics.showWarning(""String_Node_Str"");
    if (blendMode == REPLACE) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
    }
 else     if (blendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
    }
 else     if (blendMode == MULTIPLY) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (blendMode == ADD) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (blendMode == SUBTRACT) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
 else {
    if (blendMode == REPLACE) {
    }
 else     if (blendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_PRIMARY_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_REPLACE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (blendMode == MULTIPLY) {
    }
 else     if (blendMode == ADD) {
    }
 else     if (blendMode == SUBTRACT) {
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
  gl.glEnable(GL10.GL_BLEND);
  gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
}","protected void setMultitextureBlend(PTexture[] textures,int num){
  if (2 < num) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  gl.glDisable(GL10.GL_BLEND);
  if (!texenvCrossbarSupported) {
    PGraphics.showWarning(""String_Node_Str"");
    if (blendMode == REPLACE) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
    }
 else     if (blendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
    }
 else     if (blendMode == MULTIPLY) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (blendMode == ADD) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (blendMode == SUBTRACT) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
 else {
    if (blendMode == REPLACE) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_REPLACE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_REPLACE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (blendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (blendMode == MULTIPLY) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (blendMode == ADD) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (blendMode == SUBTRACT) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
  gl.glEnable(GL10.GL_BLEND);
  gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
}",0.7684215652851507
163710,"protected void drawGeometry(PGraphics g){
  PShape3D p3d=(PShape3D)parent;
  int numTextures;
  float pointSize;
  pointSize=PApplet.min(g.strokeWeight,PGraphicsAndroid3D.maxPointSize);
  gl.glPointSize(pointSize);
  gl.glEnableClientState(GL11.GL_NORMAL_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glNormalBufferID);
  gl.glNormalPointer(GL11.GL_FLOAT,0,0);
  if (p3d.vertexColor) {
    gl.glEnableClientState(GL11.GL_COLOR_ARRAY);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glColorBufferID);
    gl.glColorPointer(4,GL11.GL_FLOAT,0,0);
  }
  gl.glEnableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glVertexBufferID);
  gl.glVertexPointer(3,GL11.GL_FLOAT,0,0);
  numTextures=0;
  for (int t=0; t < textures.length; t++) {
    if (textures[t] != null) {
      PTexture tex=textures[t].getTexture();
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
        gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
        renderTextures[numTextures]=tex;
        numTextures++;
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (0 < numTextures) {
    if (pointSprites) {
      gl.glPointParameterfv(GL11.GL_POINT_DISTANCE_ATTENUATION,ptDistAtt,0);
      gl.glPointParameterf(GL11.GL_POINT_FADE_THRESHOLD_SIZE,0.6f * pointSize);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MIN,1.0f);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MAX,PGraphicsAndroid3D.maxPointSize);
      gl.glTexEnvf(GL11.GL_POINT_SPRITE_OES,GL11.GL_COORD_REPLACE_OES,GL11.GL_TRUE);
      gl.glEnable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
      for (int t=0; t < numTextures; t++) {
        gl.glClientActiveTexture(GL11.GL_TEXTURE0 + t);
        gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glTexCoordBufferID[t]);
        gl.glTexCoordPointer(2,GL11.GL_FLOAT,0,0);
      }
      if (1 < numTextures) {
        a3d.setMultitextureBlend(renderTextures,numTextures);
      }
    }
  }
  if (!p3d.vertexColor) {
    if (0 < numTextures) {
      if (g.tint) {
        gl.glColor4f(g.tintR,g.tintG,g.tintB,g.tintA);
      }
 else {
        gl.glColor4f(1,1,1,1);
      }
    }
 else {
      gl.glColor4f(g.fillR,g.fillG,g.fillB,g.fillA);
    }
  }
  if (0 < strokeWeight) {
    gl.glLineWidth(strokeWeight);
  }
 else {
    gl.glLineWidth(g.strokeWeight);
  }
  if (0 < glMode && !pointSprites) {
    gl.glDrawArrays(glMode,firstVertex,lastVertex - firstVertex + 1);
  }
 else {
    gl.glDrawArrays(glMode,firstVertex,lastVertex - firstVertex + 1);
  }
  if (0 < numTextures) {
    if (1 < numTextures) {
      a3d.clearMultitextureBlend(numTextures);
    }
    if (pointSprites) {
      gl.glDisable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
    }
    for (int t=0; t < numTextures; t++) {
      PTexture tex=renderTextures[t];
      gl.glDisable(tex.getGLTarget());
    }
  }
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  gl.glDisableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL11.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL11.GL_NORMAL_ARRAY);
}","protected void drawGeometry(PGraphics g){
  PShape3D p3d=(PShape3D)parent;
  int numTextures;
  float pointSize;
  pointSize=PApplet.min(g.strokeWeight,PGraphicsAndroid3D.maxPointSize);
  gl.glPointSize(pointSize);
  gl.glEnableClientState(GL11.GL_NORMAL_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glNormalBufferID);
  gl.glNormalPointer(GL11.GL_FLOAT,0,0);
  if (p3d.vertexColor) {
    gl.glEnableClientState(GL11.GL_COLOR_ARRAY);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glColorBufferID);
    gl.glColorPointer(4,GL11.GL_FLOAT,0,0);
  }
  gl.glEnableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glVertexBufferID);
  gl.glVertexPointer(3,GL11.GL_FLOAT,0,0);
  numTextures=0;
  for (int t=0; t < textures.length; t++) {
    if (textures[t] != null) {
      PTexture tex=textures[t].getTexture();
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
        gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
        renderTextures[numTextures]=tex;
        numTextures++;
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (0 < numTextures) {
    if (pointSprites) {
      gl.glPointParameterfv(GL11.GL_POINT_DISTANCE_ATTENUATION,ptDistAtt,0);
      gl.glPointParameterf(GL11.GL_POINT_FADE_THRESHOLD_SIZE,0.6f * pointSize);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MIN,1.0f);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MAX,PGraphicsAndroid3D.maxPointSize);
      gl.glTexEnvf(GL11.GL_POINT_SPRITE_OES,GL11.GL_COORD_REPLACE_OES,GL11.GL_TRUE);
      gl.glEnable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
      for (int t=0; t < numTextures; t++) {
        gl.glClientActiveTexture(GL11.GL_TEXTURE0 + t);
        gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glTexCoordBufferID[t]);
        gl.glTexCoordPointer(2,GL11.GL_FLOAT,0,0);
      }
      if (1 < numTextures) {
        a3d.setMultitextureBlend(renderTextures,numTextures);
      }
    }
  }
  if (!p3d.vertexColor) {
    if (0 < numTextures) {
      if (g.tint) {
        gl.glColor4f(g.tintR,g.tintG,g.tintB,g.tintA);
      }
 else {
        gl.glColor4f(1,1,1,1);
      }
    }
 else {
      gl.glColor4f(g.fillR,g.fillG,g.fillB,g.fillA);
    }
  }
  if (0 < strokeWeight) {
    gl.glLineWidth(strokeWeight);
  }
 else {
    gl.glLineWidth(g.strokeWeight);
  }
  gl.glDrawArrays(glMode,firstVertex,lastVertex - firstVertex + 1);
  if (0 < numTextures) {
    if (1 < numTextures) {
      a3d.clearMultitextureBlend(numTextures);
    }
    if (pointSprites) {
      gl.glDisable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
    }
    for (int t=0; t < numTextures; t++) {
      PTexture tex=renderTextures[t];
      gl.glDisable(tex.getGLTarget());
    }
  }
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  gl.glDisableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL11.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL11.GL_NORMAL_ARRAY);
}",0.9748598879103284
163711,"protected void addDefaultChild(){
  PShape child=createChild(""String_Node_Str"",0,vertexCount - 1,glMode,0,null);
  addChild(child);
}","protected void addDefaultChild(){
  PShape child=createChild(""String_Node_Str"",0,vertexCount - 1,getDrawModeImpl(),0,null);
  addChild(child);
}",0.9530685920577616
163712,"public void addChild(PShape who){
  if (family == GROUP) {
    super.addChild(who);
    PShape3D who3d=(PShape3D)who;
    who3d.papplet=papplet;
    who3d.a3d=a3d;
    who3d.gl=gl;
    for (int n=who3d.firstVertex; n < who3d.lastVertex; n++) {
      vertexChild[n]=who3d;
    }
  }
 else {
    PGraphics.showWarning(""String_Node_Str"");
  }
}","public void addChild(PShape who){
  if (family == GROUP) {
    super.addChild(who);
    PShape3D who3d=(PShape3D)who;
    who3d.papplet=papplet;
    who3d.a3d=a3d;
    who3d.gl=gl;
    for (int n=who3d.firstVertex; n <= who3d.lastVertex; n++) {
      vertexChild[n]=who3d;
    }
  }
 else {
    PGraphics.showWarning(""String_Node_Str"");
  }
}",0.9985358711566618
163713,"/** 
 * Returns the full name (i.e. the name including an eventual namespace prefix) of the element.
 * @webref
 * @brief  	Returns the name of the element.
 * @return the name, or null if the element only contains #PCDATA.
 */
public String getName(){
  return this.fullName;
}","/** 
 * Returns the full name (i.e. the name including an eventual namespace prefix) of the element.
 * @webref
 * @brief     Returns the name of the element.
 * @return the name, or null if the element only contains #PCDATA.
 */
public String getName(){
  return this.fullName;
}",0.992831541218638
163714,"/** 
 * Returns the content of an element. If there is no such content, <b>null</b> is returned. =advanced Return the #PCDATA content of the element. If the element has a combination of #PCDATA content and child elements, the #PCDATA sections can be retrieved as unnamed child objects. In this case, this method returns null.
 * @webref 
 * @brief  	Returns the content of an element
 * @return the content.
 */
public String getContent(){
  return this.content;
}","/** 
 * Returns the content of an element. If there is no such content, <b>null</b> is returned. =advanced Return the #PCDATA content of the element. If the element has a combination of #PCDATA content and child elements, the #PCDATA sections can be retrieved as unnamed child objects. In this case, this method returns null.
 * @webref
 * @brief     Returns the content of an element
 * @return the content.
 */
public String getContent(){
  return this.content;
}",0.9946178686759956
163715,"/** 
 * Returns a boolean attribute of the element. If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> is returned. When using the version of the method without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value false is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @webref
 * @brief Returns a boolean attribute of the element.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public boolean getBoolean(String name,boolean defaultValue){
  String value=getString(name);
  return (value != null) && (value.equals(""String_Node_Str"") || value.toLowerCase().equals(""String_Node_Str""));
}","/** 
 * Returns a boolean attribute of the element. If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> is returned. When using the version of the method without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value false is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @webref
 * @brief Returns a boolean attribute of the element.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public boolean getBoolean(String name,boolean defaultValue){
  String value=getString(name);
  if (value == null) {
    return defaultValue;
  }
  return (value.equals(""String_Node_Str"") || value.toLowerCase().equals(""String_Node_Str""));
}",0.9672867222578576
163716,"/** 
 * Returns the name of the element without its namespace. 
 * @return the name, or null if the element only contains #PCDATA.
 */
public String getLocalName(){
  return this.name;
}","/** 
 * Returns the name of the element without its namespace.
 * @return the name, or null if the element only contains #PCDATA.
 */
public String getLocalName(){
  return this.name;
}",0.9973045822102424
163717,"/** 
 * Put the names of all children into an array. Same as looping through  each child and calling getName() on each XMLElement.
 */
public String[] listChildren(){
  int childCount=getChildCount();
  String[] outgoing=new String[childCount];
  for (int i=0; i < childCount; i++) {
    outgoing[i]=getChild(i).getName();
  }
  return outgoing;
}","/** 
 * Put the names of all children into an array. Same as looping through each child and calling getName() on each XMLElement.
 */
public String[] listChildren(){
  int childCount=getChildCount();
  String[] outgoing=new String[childCount];
  for (int i=0; i < childCount; i++) {
    outgoing[i]=getChild(i).getName();
  }
  return outgoing;
}",0.9985569985569984
163718,"/** 
 * Calculate the angle between two vectors, using the dot product
 * @param v1 a vector
 * @param v2 another vector
 * @return the angle between the vectors
 */
static public float angleBetween(PVector v1,PVector v2){
  double dot=v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
  double v1mag=Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
  double v2mag=Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);
  double amt=dot / (v1mag * v2mag);
  if (amt <= -1 || amt >= 1) {
    return PConstants.PI;
  }
  return (float)Math.acos(amt);
}","/** 
 * Calculate the angle between two vectors, using the dot product
 * @param v1 a vector
 * @param v2 another vector
 * @return the angle between the vectors
 */
static public float angleBetween(PVector v1,PVector v2){
  double dot=v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
  double v1mag=Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
  double v2mag=Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);
  double amt=dot / (v1mag * v2mag);
  if (amt <= -1) {
    return PConstants.PI;
  }
 else   if (amt >= 1) {
    return 0;
  }
  return (float)Math.acos(amt);
}",0.9424460431654677
163719,"protected void parseMTL(BufferedReader reader,ArrayList<OBJMaterial> materials,Hashtable<String,Integer> materialsHash){
  try {
    String line;
    OBJMaterial currentMtl=null;
    while ((line=reader.readLine()) != null) {
      line=line.trim();
      String elements[]=line.split(""String_Node_Str"");
      if (elements.length > 0) {
        if (elements[0].equals(""String_Node_Str"")) {
          String mtlname=elements[1];
          currentMtl=new OBJMaterial(mtlname);
          materialsHash.put(mtlname,new Integer(materials.size()));
          materials.add(currentMtl);
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 1) {
          String texname=elements[1];
          currentMtl.kdMap=parent.loadImage(texname);
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 3) {
          currentMtl.ka.x=Float.valueOf(elements[1]).floatValue();
          currentMtl.ka.y=Float.valueOf(elements[2]).floatValue();
          currentMtl.ka.z=Float.valueOf(elements[3]).floatValue();
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 3) {
          currentMtl.kd.x=Float.valueOf(elements[1]).floatValue();
          currentMtl.kd.y=Float.valueOf(elements[2]).floatValue();
          currentMtl.kd.z=Float.valueOf(elements[3]).floatValue();
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 3) {
          currentMtl.ks.x=Float.valueOf(elements[1]).floatValue();
          currentMtl.ks.y=Float.valueOf(elements[2]).floatValue();
          currentMtl.ks.z=Float.valueOf(elements[3]).floatValue();
        }
 else         if ((elements[0].equals(""String_Node_Str"") || elements[0].equals(""String_Node_Str"")) && elements.length > 1) {
          currentMtl.d=Float.valueOf(elements[1]).floatValue();
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 1) {
          currentMtl.ns=Float.valueOf(elements[1]).floatValue();
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","protected void parseMTL(BufferedReader reader,ArrayList<OBJMaterial> materials,Hashtable<String,Integer> materialsHash){
  try {
    String line;
    OBJMaterial currentMtl=null;
    while ((line=reader.readLine()) != null) {
      line=line.trim();
      String elements[]=line.split(""String_Node_Str"");
      if (elements.length > 0) {
        if (elements[0].equals(""String_Node_Str"")) {
          String mtlname=elements[1];
          currentMtl=new OBJMaterial(mtlname);
          materialsHash.put(mtlname,new Integer(materials.size()));
          materials.add(currentMtl);
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 1) {
          String texname=elements[1];
          currentMtl.kdMap=parent.loadImage(texname);
          currentMtl.kdMap.getTexture().setFlippedY(true);
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 3) {
          currentMtl.ka.x=Float.valueOf(elements[1]).floatValue();
          currentMtl.ka.y=Float.valueOf(elements[2]).floatValue();
          currentMtl.ka.z=Float.valueOf(elements[3]).floatValue();
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 3) {
          currentMtl.kd.x=Float.valueOf(elements[1]).floatValue();
          currentMtl.kd.y=Float.valueOf(elements[2]).floatValue();
          currentMtl.kd.z=Float.valueOf(elements[3]).floatValue();
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 3) {
          currentMtl.ks.x=Float.valueOf(elements[1]).floatValue();
          currentMtl.ks.y=Float.valueOf(elements[2]).floatValue();
          currentMtl.ks.z=Float.valueOf(elements[3]).floatValue();
        }
 else         if ((elements[0].equals(""String_Node_Str"") || elements[0].equals(""String_Node_Str"")) && elements.length > 1) {
          currentMtl.d=Float.valueOf(elements[1]).floatValue();
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 1) {
          currentMtl.ns=Float.valueOf(elements[1]).floatValue();
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.98603550295858
163720,"static public boolean saveStream(File targetFile,InputStream sourceStream){
  File tempFile=null;
  try {
    File parentDir=targetFile.getParentFile();
    tempFile=File.createTempFile(targetFile.getName(),null,parentDir);
    BufferedInputStream bis=new BufferedInputStream(sourceStream,16384);
    FileOutputStream fos=new FileOutputStream(tempFile);
    BufferedOutputStream bos=new BufferedOutputStream(fos);
    byte[] buffer=new byte[8192];
    int bytesRead;
    while ((bytesRead=bis.read(buffer)) != -1) {
      bos.write(buffer,0,bytesRead);
    }
    bos.flush();
    bos.close();
    bos=null;
    if (!tempFile.renameTo(targetFile)) {
      System.err.println(""String_Node_Str"" + tempFile.getAbsolutePath());
      return false;
    }
    return true;
  }
 catch (  IOException e) {
    if (tempFile != null) {
      tempFile.delete();
    }
    e.printStackTrace();
    return false;
  }
}","static public boolean saveStream(File targetFile,InputStream sourceStream){
  File tempFile=null;
  try {
    File parentDir=targetFile.getParentFile();
    createPath(targetFile);
    tempFile=File.createTempFile(targetFile.getName(),null,parentDir);
    BufferedInputStream bis=new BufferedInputStream(sourceStream,16384);
    FileOutputStream fos=new FileOutputStream(tempFile);
    BufferedOutputStream bos=new BufferedOutputStream(fos);
    byte[] buffer=new byte[8192];
    int bytesRead;
    while ((bytesRead=bis.read(buffer)) != -1) {
      bos.write(buffer,0,bytesRead);
    }
    bos.flush();
    bos.close();
    bos=null;
    if (!tempFile.renameTo(targetFile)) {
      System.err.println(""String_Node_Str"" + tempFile.getAbsolutePath());
      return false;
    }
    return true;
  }
 catch (  IOException e) {
    if (tempFile != null) {
      tempFile.delete();
    }
    e.printStackTrace();
    return false;
  }
}",0.9847494553376906
163721,"/** 
 * I want to print lines to a file. Why am I always explaining myself? It's the JavaSoft API engineers who need to explain themselves.
 */
static public PrintWriter createWriter(OutputStream output){
  try {
    OutputStreamWriter osw=new OutputStreamWriter(output,""String_Node_Str"");
    return new PrintWriter(osw);
  }
 catch (  UnsupportedEncodingException e) {
  }
  return null;
}","/** 
 * I want to print lines to a file. Why am I always explaining myself? It's the JavaSoft API engineers who need to explain themselves.
 */
static public PrintWriter createWriter(OutputStream output){
  try {
    BufferedOutputStream bos=new BufferedOutputStream(output,8192);
    OutputStreamWriter osw=new OutputStreamWriter(bos,""String_Node_Str"");
    return new PrintWriter(osw);
  }
 catch (  UnsupportedEncodingException e) {
  }
  return null;
}",0.885478158205431
163722,"/** 
 * Takes a path and creates any in-between folders if they don't already exist. Useful when trying to save to a subfolder that may not actually exist.
 */
static public void createPath(String path){
  try {
    File file=new File(path);
    String parent=file.getParent();
    if (parent != null) {
      File unit=new File(parent);
      if (!unit.exists())       unit.mkdirs();
    }
  }
 catch (  SecurityException se) {
    System.err.println(""String_Node_Str"" + path);
  }
}","static public void createPath(File file){
  try {
    String parent=file.getParent();
    if (parent != null) {
      File unit=new File(parent);
      if (!unit.exists())       unit.mkdirs();
    }
  }
 catch (  SecurityException se) {
    System.err.println(""String_Node_Str"" + file.getAbsolutePath());
  }
}",0.7103274559193955
163723,"/** 
 * Returns a path inside the applet folder to save to. Like sketchPath(), but creates any in-between folders so that things save properly. <p/> All saveXxxx() functions use the path to the sketch folder, rather than its data folder. Once exported, the data folder will be found inside the jar file of the exported application or applet. In this case, it's not possible to save data into the jar file, because it will often be running from a server, or marked in-use if running from a local file system. With this in mind, saving to the data path doesn't make sense anyway. If you know you're running locally, and want to save to the data folder, use <TT>saveXxxx(""data/blah.dat"")</TT>.
 */
public String savePath(String where){
  if (where == null)   return null;
  System.out.println(""String_Node_Str"" + where);
  String filename=sketchPath(where);
  System.out.println(""String_Node_Str"" + filename);
  createPath(filename);
  return filename;
}","/** 
 * Returns a path inside the applet folder to save to. Like sketchPath(), but creates any in-between folders so that things save properly. <p/> All saveXxxx() functions use the path to the sketch folder, rather than its data folder. Once exported, the data folder will be found inside the jar file of the exported application or applet. In this case, it's not possible to save data into the jar file, because it will often be running from a server, or marked in-use if running from a local file system. With this in mind, saving to the data path doesn't make sense anyway. If you know you're running locally, and want to save to the data folder, use <TT>saveXxxx(""data/blah.dat"")</TT>.
 */
public String savePath(String where){
  if (where == null)   return null;
  String filename=sketchPath(where);
  createPath(filename);
  return filename;
}",0.9050527484730704
163724,"/** 
 * Calculate the angle between two vectors, using the dot product
 * @param v1 a vector
 * @param v2 another vector
 * @return the angle between the vectors
 */
static public float angleBetween(PVector v1,PVector v2){
  float dot=v1.dot(v2);
  float theta=(float)Math.acos(dot / (v1.mag() * v2.mag()));
  return theta;
}","/** 
 * Calculate the angle between two vectors, using the dot product
 * @param v1 a vector
 * @param v2 another vector
 * @return the angle between the vectors
 */
static public float angleBetween(PVector v1,PVector v2){
  double dot=v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
  double v1mag=Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
  double v2mag=Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);
  double amt=dot / (v1mag * v2mag);
  if (amt <= -1 || amt >= 1) {
    return PConstants.PI;
  }
  return (float)Math.acos(amt);
}",0.5796766743648961
163725,"/** 
 * Returns the value of an attribute.
 * @param name the non-null full name of the attribute.
 * @param defaultValue the default value of the attribute.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public double getDouble(String name,double defaultValue){
  String value=this.getAttribute(name,Double.toString(defaultValue));
  return Double.parseDouble(value);
}","/** 
 * Returns the value of an attribute.
 * @param name the non-null full name of the attribute.
 * @param defaultValue the default value of the attribute.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public double getDouble(String name,double defaultValue){
  String value=getString(name);
  return (value == null) ? defaultValue : Double.parseDouble(value);
}",0.8874841972187105
163726,"/** 
 * Returns a float attribute of the element. If the <b>default</b> parameter is used and the attribute doesn't exist, the <b>default</b> value is returned. When using the version of the method without the <b>default</b> parameter, if the attribute doesn't exist, the value 0 is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @return the value, or defaultValue if the attribute does not exist.
 * @webref
 * @brief Returns a float attribute of the element.
 */
public float getFloat(String name,float defaultValue){
  String value=this.getAttribute(name,Float.toString(defaultValue));
  return Float.parseFloat(value);
}","/** 
 * Returns a float attribute of the element. If the <b>default</b> parameter is used and the attribute doesn't exist, the <b>default</b> value is returned. When using the version of the method without the <b>default</b> parameter, if the attribute doesn't exist, the value 0 is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @return the value, or defaultValue if the attribute does not exist.
 * @webref
 * @brief Returns a float attribute of the element.
 */
public float getFloat(String name,float defaultValue){
  String value=getString(name);
  if (value == null) {
    return defaultValue;
  }
  return PApplet.parseFloat(value,defaultValue);
}",0.9061624649859944
163727,"/** 
 * Returns a boolean attribute of the element. If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> is returned. When using the version of the method without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value false is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @webref
 * @brief Returns a boolean attribute of the element.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public boolean getBoolean(String name,boolean defaultValue){
  String value=this.getAttribute(name,Boolean.toString(defaultValue));
  return value.equals(""String_Node_Str"") || value.toLowerCase().equals(""String_Node_Str"");
}","/** 
 * Returns a boolean attribute of the element. If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> is returned. When using the version of the method without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value false is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @webref
 * @brief Returns a boolean attribute of the element.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public boolean getBoolean(String name,boolean defaultValue){
  String value=getString(name);
  return (value != null) && (value.equals(""String_Node_Str"") || value.toLowerCase().equals(""String_Node_Str""));
}",0.8393782383419689
163728,"/** 
 * Returns a String attribute of the element. If the <b>default</b> parameter is used and the attribute doesn't exist, the <b>default</b> value is returned. When using the version of the method without the <b>default</b> parameter, if the attribute doesn't exist, the value 0 is returned.
 * @webref
 * @param name the name of the attribute
 * @param default Value value returned if the attribute is not found
 * @brief Returns a String attribute of the element.
 * @deprecated use getString() or getAttribute()
 */
public String getStringAttribute(String name,String defaultValue){
  return getAttribute(name,defaultValue);
}","/** 
 * Returns a String attribute of the element. If the <b>default</b> parameter is used and the attribute doesn't exist, the <b>default</b> value is returned. When using the version of the method without the <b>default</b> parameter, if the attribute doesn't exist, the value 0 is returned.
 * @webref
 * @param name the name of the attribute
 * @param default Value value returned if the attribute is not found
 * @brief Returns a String attribute of the element.
 * @deprecated use getString() or getAttribute()
 */
public String getStringAttribute(String name,String defaultValue){
  return getString(name,defaultValue);
}",0.988085782366958
163729,"public String getString(String name,String defaultValue){
  return getAttribute(name,defaultValue);
}","public String getString(String name,String defaultValue){
  XMLAttribute attr=this.findAttribute(name);
  if (attr == null) {
    return defaultValue;
  }
 else {
    return attr.getValue();
  }
}",0.6397306397306397
163730,"/** 
 * Returns an integer attribute of the element. If the <b>default</b> parameter is used and the attribute doesn't exist, the <b>default</b> value is returned. When using the version of the method without the <b>default</b> parameter, if the attribute doesn't exist, the value 0 is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @webref
 * @brief Returns an integer attribute of the element.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public int getInt(String name,int defaultValue){
  String value=this.getAttribute(name,Integer.toString(defaultValue));
  return Integer.parseInt(value);
}","/** 
 * Returns an integer attribute of the element. If the <b>default</b> parameter is used and the attribute doesn't exist, the <b>default</b> value is returned. When using the version of the method without the <b>default</b> parameter, if the attribute doesn't exist, the value 0 is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @webref
 * @brief Returns an integer attribute of the element.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public int getInt(String name,int defaultValue){
  String value=getString(name);
  return (value == null) ? defaultValue : PApplet.parseInt(value,defaultValue);
}",0.9240596167494676
163731,"/** 
 * Returns true if the element equals another element.
 * @param rawElement the element to compare to
 */
public boolean equals(Object object){
  if (!(object instanceof XMLElement)) {
    return false;
  }
  XMLElement rawElement=(XMLElement)object;
  if (!this.name.equals(rawElement.getLocalName())) {
    return false;
  }
  if (this.attributes.size() != rawElement.getAttributeCount()) {
    return false;
  }
  Enumeration<XMLAttribute> en=this.attributes.elements();
  while (en.hasMoreElements()) {
    XMLAttribute attr=(XMLAttribute)en.nextElement();
    if (!rawElement.hasAttribute(attr.getName())) {
      return false;
    }
    String value=rawElement.getAttribute(attr.getName(),null);
    if (!attr.getValue().equals(value)) {
      return false;
    }
  }
  if (this.children.size() != rawElement.getChildCount()) {
    return false;
  }
  for (int i=0; i < this.children.size(); i++) {
    XMLElement child1=this.getChild(i);
    XMLElement child2=rawElement.getChild(i);
    if (!child1.equals(child2)) {
      return false;
    }
  }
  return true;
}","/** 
 * Returns true if the element equals another element.
 * @param rawElement the element to compare to
 */
public boolean equals(Object object){
  if (!(object instanceof XMLElement)) {
    return false;
  }
  XMLElement rawElement=(XMLElement)object;
  if (!this.name.equals(rawElement.getLocalName())) {
    return false;
  }
  if (this.attributes.size() != rawElement.getAttributeCount()) {
    return false;
  }
  Enumeration<XMLAttribute> en=this.attributes.elements();
  while (en.hasMoreElements()) {
    XMLAttribute attr=(XMLAttribute)en.nextElement();
    if (!rawElement.hasAttribute(attr.getName())) {
      return false;
    }
    String value=rawElement.getString(attr.getName(),null);
    if (!attr.getValue().equals(value)) {
      return false;
    }
  }
  if (this.children.size() != rawElement.getChildCount()) {
    return false;
  }
  for (int i=0; i < this.children.size(); i++) {
    XMLElement child1=this.getChild(i);
    XMLElement child2=rawElement.getChild(i);
    if (!child1.equals(child2)) {
      return false;
    }
  }
  return true;
}",0.9930200093066542
163732,"/** 
 * Writes an XML element.
 * @param xml the non-null XML element to write.
 * @param prettyPrint if spaces need to be inserted to make the output morereadable
 * @param initialIndent how many spaces to indent the first element.
 */
public void write(XMLElement xml,boolean prettyPrint,int initialIndent,int eachIndent,boolean collapseEmptyElements) throws IOException {
  if (prettyPrint) {
    for (int i=0; i < initialIndent; i++) {
      this.writer.print(' ');
    }
  }
  if (xml.getLocalName() == null) {
    if (xml.getContent() != null) {
      if (prettyPrint) {
        this.writeEncoded(xml.getContent().trim());
        writer.println();
      }
 else {
        this.writeEncoded(xml.getContent());
      }
    }
  }
 else {
    this.writer.print('<');
    this.writer.print(xml.getName());
    for (    String key : xml.listAttributes()) {
      String value=xml.getAttribute(key,null);
      this.writer.print(""String_Node_Str"" + key + ""String_Node_Str"");
      this.writeEncoded(value);
      this.writer.print('""');
    }
    if ((xml.getContent() != null) && (xml.getContent().length() > 0)) {
      writer.print('>');
      this.writeEncoded(xml.getContent());
      writer.print(""String_Node_Str"" + xml.getName() + '>');
      if (prettyPrint) {
        writer.println();
      }
    }
 else     if (xml.hasChildren() || (!collapseEmptyElements)) {
      writer.print('>');
      if (prettyPrint) {
        writer.println();
      }
      int count=xml.getChildCount();
      for (int i=0; i < count; i++) {
        XMLElement child=xml.getChild(i);
        this.write(child,prettyPrint,initialIndent + eachIndent,eachIndent,collapseEmptyElements);
      }
      if (prettyPrint) {
        for (int i=0; i < initialIndent; i++) {
          this.writer.print(' ');
        }
      }
      this.writer.print(""String_Node_Str"" + xml.getName() + ""String_Node_Str"");
      if (prettyPrint) {
        writer.println();
      }
    }
 else {
      this.writer.print(""String_Node_Str"");
      if (prettyPrint) {
        writer.println();
      }
    }
  }
  this.writer.flush();
}","/** 
 * Writes an XML element.
 * @param xml the non-null XML element to write.
 * @param prettyPrint if spaces need to be inserted to make the output morereadable
 * @param initialIndent how many spaces to indent the first element.
 */
public void write(XMLElement xml,boolean prettyPrint,int initialIndent,int eachIndent,boolean collapseEmptyElements) throws IOException {
  if (prettyPrint) {
    for (int i=0; i < initialIndent; i++) {
      this.writer.print(' ');
    }
  }
  if (xml.getLocalName() == null) {
    if (xml.getContent() != null) {
      if (prettyPrint) {
        this.writeEncoded(xml.getContent().trim());
        writer.println();
      }
 else {
        this.writeEncoded(xml.getContent());
      }
    }
  }
 else {
    this.writer.print('<');
    this.writer.print(xml.getName());
    for (    String key : xml.listAttributes()) {
      String value=xml.getString(key,null);
      this.writer.print(""String_Node_Str"" + key + ""String_Node_Str"");
      this.writeEncoded(value);
      this.writer.print('""');
    }
    if ((xml.getContent() != null) && (xml.getContent().length() > 0)) {
      writer.print('>');
      this.writeEncoded(xml.getContent());
      writer.print(""String_Node_Str"" + xml.getName() + '>');
      if (prettyPrint) {
        writer.println();
      }
    }
 else     if (xml.hasChildren() || (!collapseEmptyElements)) {
      writer.print('>');
      if (prettyPrint) {
        writer.println();
      }
      int count=xml.getChildCount();
      for (int i=0; i < count; i++) {
        XMLElement child=xml.getChild(i);
        this.write(child,prettyPrint,initialIndent + eachIndent,eachIndent,collapseEmptyElements);
      }
      if (prettyPrint) {
        for (int i=0; i < initialIndent; i++) {
          this.writer.print(' ');
        }
      }
      this.writer.print(""String_Node_Str"" + xml.getName() + ""String_Node_Str"");
      if (prettyPrint) {
        writer.println();
      }
    }
 else {
      this.writer.print(""String_Node_Str"");
      if (prettyPrint) {
        writer.println();
      }
    }
  }
  this.writer.flush();
}",0.9964191931248508
163733,"public void loadTexture(PTexture.Parameters params){
  if (texture == null) {
    texture=new PTexture(parent,width,height,params);
    texUpdated=false;
  }
  if (pixels != null) {
    pixelsToTexture();
  }
}","public void loadTexture(PTexture.Parameters params){
  if (texture == null) {
    texture=new PTexture(parent,width,height,params);
    texUpdated=false;
  }
  if (pixels == null) {
    loadPixels();
  }
 else {
    pixelsToTexture();
  }
}",0.76
163734,"/** 
 * Call this when you want to mess with the pixels[] array. <p/> For subclasses where the pixels[] buffer isn't set by default, this should copy all data into the pixels[] array
 */
public void loadPixels(){
  if (pixels == null || pixels.length != width * height) {
    pixels=new int[width * height];
  }
  if (bitmap != null) {
    bitmap.getPixels(pixels,0,width,0,0,width,height);
  }
  if (parent.g.is3D()) {
    loadTexture();
  }
}","/** 
 * Call this when you want to mess with the pixels[] array. <p/> For subclasses where the pixels[] buffer isn't set by default, this should copy all data into the pixels[] array
 */
public void loadPixels(){
  if (pixels == null || pixels.length != width * height) {
    pixels=new int[width * height];
  }
  if (bitmap != null) {
    bitmap.getPixels(pixels,0,width,0,0,width,height);
  }
  if (parent.g.is3D()) {
    if (texture == null) {
      texture=new PTexture(parent,width,height,new PTexture.Parameters(format));
      texUpdated=false;
    }
    pixelsToTexture();
  }
}",0.8543689320388349
163735,"private void writeLibraries(final File libsFolder,final File assetsFolder) throws IOException {
  final Sketch sketch=editor.getSketch();
  for (  LibraryFolder library : sketch.getImportedLibraries()) {
    final File exportSettings=new File(libraryFolder,""String_Node_Str"");
    final HashMap<String,String> exportTable=Base.readSettings(exportSettings);
    final String androidList=exportTable.get(""String_Node_Str"");
    String exportList[]=null;
    if (androidList != null) {
      exportList=PApplet.splitTokens(androidList,""String_Node_Str"");
    }
 else {
      exportList=libraryFolder.list();
    }
    for (int i=0; i < exportList.length; i++) {
      exportList[i]=PApplet.trim(exportList[i]);
      if (exportList[i].equals(""String_Node_Str"") || exportList[i].equals(""String_Node_Str"") || exportList[i].equals(""String_Node_Str"")) {
        continue;
      }
      final File exportFile=new File(libraryFolder,exportList[i]);
      if (!exportFile.exists()) {
        System.err.println(""String_Node_Str"" + exportList[i] + ""String_Node_Str"");
      }
 else       if (exportFile.isDirectory()) {
        System.err.println(""String_Node_Str"" + exportList[i] + ""String_Node_Str"");
      }
 else {
        final String name=exportFile.getName();
        final String lcname=name.toLowerCase();
        if (lcname.endsWith(""String_Node_Str"") || lcname.endsWith(""String_Node_Str"")) {
          final String jarName=name.substring(0,name.length() - 4) + ""String_Node_Str"";
          Base.copyFile(exportFile,new File(libsFolder,jarName));
        }
 else {
          Base.copyFile(exportFile,new File(assetsFolder,name));
        }
      }
    }
  }
  final File codeFolder=sketch.getCodeFolder();
  if (codeFolder != null && codeFolder.exists()) {
    for (    final File item : codeFolder.listFiles()) {
      if (!item.isDirectory()) {
        final String name=item.getName();
        final String lcname=name.toLowerCase();
        if (lcname.endsWith(""String_Node_Str"") || lcname.endsWith(""String_Node_Str"")) {
          String jarName=name.substring(0,name.length() - 4) + ""String_Node_Str"";
          Base.copyFile(item,new File(libsFolder,jarName));
        }
      }
    }
  }
}","private void writeLibraries(final File libsFolder,final File assetsFolder) throws IOException {
  final Sketch sketch=editor.getSketch();
  for (  LibraryFolder library : sketch.getImportedLibraries()) {
    File libraryFolder=new File(library.getPath());
    final File exportSettings=new File(libraryFolder,""String_Node_Str"");
    final HashMap<String,String> exportTable=Base.readSettings(exportSettings);
    final String androidList=exportTable.get(""String_Node_Str"");
    String exportList[]=null;
    if (androidList != null) {
      exportList=PApplet.splitTokens(androidList,""String_Node_Str"");
    }
 else {
      exportList=libraryFolder.list();
    }
    for (int i=0; i < exportList.length; i++) {
      exportList[i]=PApplet.trim(exportList[i]);
      if (exportList[i].equals(""String_Node_Str"") || exportList[i].equals(""String_Node_Str"") || exportList[i].equals(""String_Node_Str"")) {
        continue;
      }
      final File exportFile=new File(libraryFolder,exportList[i]);
      if (!exportFile.exists()) {
        System.err.println(""String_Node_Str"" + exportList[i] + ""String_Node_Str"");
      }
 else       if (exportFile.isDirectory()) {
        System.err.println(""String_Node_Str"" + exportList[i] + ""String_Node_Str"");
      }
 else {
        final String name=exportFile.getName();
        final String lcname=name.toLowerCase();
        if (lcname.endsWith(""String_Node_Str"") || lcname.endsWith(""String_Node_Str"")) {
          final String jarName=name.substring(0,name.length() - 4) + ""String_Node_Str"";
          Base.copyFile(exportFile,new File(libsFolder,jarName));
        }
 else {
          Base.copyFile(exportFile,new File(assetsFolder,name));
        }
      }
    }
  }
  final File codeFolder=sketch.getCodeFolder();
  if (codeFolder != null && codeFolder.exists()) {
    for (    final File item : codeFolder.listFiles()) {
      if (!item.isDirectory()) {
        final String name=item.getName();
        final String lcname=name.toLowerCase();
        if (lcname.endsWith(""String_Node_Str"") || lcname.endsWith(""String_Node_Str"")) {
          String jarName=name.substring(0,name.length() - 4) + ""String_Node_Str"";
          Base.copyFile(item,new File(libsFolder,jarName));
        }
      }
    }
  }
}",0.9882935614588024
163736,"/** 
 * Similar to gluPerspective(). Implementation based on Mesa's glu.c
 */
public void perspective(float fov,float aspect,float zNear,float zFar){
  float ymax=cameraNear * (float)Math.tan(cameraFOV / 2);
  float ymin=-ymax;
  float xmin=ymin * cameraAspect;
  float xmax=ymax * cameraAspect;
  frustum(xmin,xmax,ymin,ymax,cameraNear,cameraFar);
}","/** 
 * Similar to gluPerspective(). Implementation based on Mesa's glu.c
 */
public void perspective(float fov,float aspect,float zNear,float zFar){
  float ymax=zNear * (float)Math.tan(fov / 2);
  float ymin=-ymax;
  float xmin=ymin * aspect;
  float xmax=ymax * aspect;
  frustum(xmin,xmax,ymin,ymax,zNear,zFar);
}",0.815592203898051
163737,"/** 
 * More flexible method for dealing with camera(). <P> The actual call is like gluLookat. Here's the real skinny on what does what: <PRE> camera(); or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz); </PRE> do not need to be called from with beginCamera();/endCamera(); That's because they always apply to the camera transformation, and they always totally replace it. That means that any coordinate transforms done before camera(); in draw() will be wiped out. It also means that camera() always operates in untransformed world coordinates. Therefore it is always redundant to call resetMatrix(); before camera(); This isn't technically true of gluLookat, but it's pretty much how it's used. <P> Now, beginCamera(); and endCamera(); are useful if you want to move the camera around using transforms like translate(), etc. They will wipe out any coordinate system transforms that occur before them in draw(), but they will not automatically wipe out the camera transform. This means that they should be at the top of draw(). It also means that the following: <PRE> beginCamera(); rotateY(PI / 8); endCamera(); </PRE> will result in a camera that spins without stopping. If you want to just rotate a small constant amount, try this: <PRE> beginCamera(); camera(); // sets up the default view rotateY(PI / 8); endCamera(); </PRE> That will rotate a little off of the default view. Note that this is entirely equivalent to <PRE> camera(); // sets up the default view beginCamera(); rotateY(PI / 8); endCamera(); </PRE> because camera() doesn't care whether or not it's inside a begin/end clause. Basically it's safe to use camera() or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz) as naked calls because they do all the matrix resetting automatically.
 */
public void camera(float eyeX,float eyeY,float eyeZ,float centerX,float centerY,float centerZ,float upX,float upY,float upZ){
  eyeY=height - eyeY;
  centerY=height - centerY;
  float z0=eyeX - centerX;
  float z1=eyeY - centerY;
  float z2=eyeZ - centerZ;
  float mag=sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  if (mag != 0) {
    z0/=mag;
    z1/=mag;
    z2/=mag;
  }
  float y0=upX;
  float y1=upY;
  float y2=upZ;
  float x0=y1 * z2 - y2 * z1;
  float x1=-y0 * z2 + y2 * z0;
  float x2=y0 * z1 - y1 * z0;
  y0=z1 * x2 - z2 * x1;
  y1=-z0 * x2 + z2 * x0;
  y2=z0 * x1 - z1 * x0;
  mag=sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (mag != 0) {
    x0/=mag;
    x1/=mag;
    x2/=mag;
  }
  mag=sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (mag != 0) {
    y0/=mag;
    y1/=mag;
    y2/=mag;
  }
  float[] m=glmodelview;
  m[0]=x0;
  m[1]=y0;
  m[2]=z0;
  m[3]=0.0f;
  m[4]=x1;
  m[5]=y1;
  m[6]=z1;
  m[7]=0.0f;
  m[8]=x2;
  m[9]=y2;
  m[10]=z2;
  m[11]=0;
  m[12]=0.0f;
  m[13]=0.0f;
  m[14]=0.0f;
  m[15]=1.0f;
  float tx=-eyeX;
  float ty=-eyeY + height;
  float tz=-eyeZ;
  m[12]+=tx * m[0] + ty * m[4] + tz * m[8];
  m[13]+=tx * m[1] + ty * m[5] + tz * m[9];
  m[14]+=tx * m[2] + ty * m[6] + tz * m[10];
  m[15]+=tx * m[3] + ty * m[7] + tz * m[11];
  m[4]=-m[4];
  m[5]=-m[5];
  m[6]=-m[6];
  m[7]=-m[7];
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glLoadMatrixf(glmodelview,0);
  if (usingModelviewStack) {
    modelviewStack.set(glmodelview);
  }
  copyGLArrayToPMatrix(glmodelview,modelview);
  modelviewUpdated=true;
  calculateModelviewInvNoScaling();
  PApplet.arrayCopy(glmodelview,pcamera);
  PApplet.arrayCopy(glmodelviewInv,pcameraInv);
  copyGLArrayToPMatrix(pcamera,camera);
  copyGLArrayToPMatrix(pcameraInv,cameraInv);
}","/** 
 * More flexible method for dealing with camera(). <P> The actual call is like gluLookat. Here's the real skinny on what does what: <PRE> camera(); or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz); </PRE> do not need to be called from with beginCamera();/endCamera(); That's because they always apply to the camera transformation, and they always totally replace it. That means that any coordinate transforms done before camera(); in draw() will be wiped out. It also means that camera() always operates in untransformed world coordinates. Therefore it is always redundant to call resetMatrix(); before camera(); This isn't technically true of gluLookat, but it's pretty much how it's used. <P> Now, beginCamera(); and endCamera(); are useful if you want to move the camera around using transforms like translate(), etc. They will wipe out any coordinate system transforms that occur before them in draw(), but they will not automatically wipe out the camera transform. This means that they should be at the top of draw(). It also means that the following: <PRE> beginCamera(); rotateY(PI / 8); endCamera(); </PRE> will result in a camera that spins without stopping. If you want to just rotate a small constant amount, try this: <PRE> beginCamera(); camera(); // sets up the default view rotateY(PI / 8); endCamera(); </PRE> That will rotate a little off of the default view. Note that this is entirely equivalent to <PRE> camera(); // sets up the default view beginCamera(); rotateY(PI / 8); endCamera(); </PRE> because camera() doesn't care whether or not it's inside a begin/end clause. Basically it's safe to use camera() or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz) as naked calls because they do all the matrix resetting automatically.
 */
public void camera(float eyeX,float eyeY,float eyeZ,float centerX,float centerY,float centerZ,float upX,float upY,float upZ){
  eyeY=height - eyeY;
  centerY=height - centerY;
  currentEyeX=eyeX;
  currentCenterY=centerY;
  float z0=eyeX - centerX;
  float z1=eyeY - centerY;
  float z2=eyeZ - centerZ;
  float mag=sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  if (mag != 0) {
    z0/=mag;
    z1/=mag;
    z2/=mag;
  }
  float y0=upX;
  float y1=upY;
  float y2=upZ;
  float x0=y1 * z2 - y2 * z1;
  float x1=-y0 * z2 + y2 * z0;
  float x2=y0 * z1 - y1 * z0;
  y0=z1 * x2 - z2 * x1;
  y1=-z0 * x2 + z2 * x0;
  y2=z0 * x1 - z1 * x0;
  mag=sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (mag != 0) {
    x0/=mag;
    x1/=mag;
    x2/=mag;
  }
  mag=sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (mag != 0) {
    y0/=mag;
    y1/=mag;
    y2/=mag;
  }
  float[] m=glmodelview;
  m[0]=x0;
  m[1]=y0;
  m[2]=z0;
  m[3]=0.0f;
  m[4]=x1;
  m[5]=y1;
  m[6]=z1;
  m[7]=0.0f;
  m[8]=x2;
  m[9]=y2;
  m[10]=z2;
  m[11]=0;
  m[12]=0.0f;
  m[13]=0.0f;
  m[14]=0.0f;
  m[15]=1.0f;
  float tx=-eyeX;
  float ty=-eyeY + height;
  float tz=-eyeZ;
  m[12]+=tx * m[0] + ty * m[4] + tz * m[8];
  m[13]+=tx * m[1] + ty * m[5] + tz * m[9];
  m[14]+=tx * m[2] + ty * m[6] + tz * m[10];
  m[15]+=tx * m[3] + ty * m[7] + tz * m[11];
  m[4]=-m[4];
  m[5]=-m[5];
  m[6]=-m[6];
  m[7]=-m[7];
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glLoadMatrixf(glmodelview,0);
  if (usingModelviewStack) {
    modelviewStack.set(glmodelview);
  }
  copyGLArrayToPMatrix(glmodelview,modelview);
  modelviewUpdated=true;
  calculateModelviewInvNoScaling();
  PApplet.arrayCopy(glmodelview,pcamera);
  PApplet.arrayCopy(glmodelviewInv,pcameraInv);
  copyGLArrayToPMatrix(pcamera,camera);
  copyGLArrayToPMatrix(pcameraInv,cameraInv);
}",0.99342293394338
163738,"/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  VERTEXCOUNT=0;
  TRIANGLECOUNT=0;
  FACECOUNT=0;
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
    if (a3d.lights) {
      noLights();
    }
  }
  if (!settingsInited) {
    defaultSettings();
  }
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  blend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  perspective();
  camera();
  lights=false;
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (primarySurface) {
    if (parent.frameCount == 0) {
      if (fboSupported) {
        if (offscreenFramebuffer == null) {
          createOffscreenFramebuffer();
        }
      }
 else {
        if (gl11 == null || gl11x == null) {
          throw new RuntimeException(""String_Node_Str"");
        }
        if (texture == null) {
          createScreenTexture();
        }
      }
    }
    if (clearColorBuffer) {
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      if (fboSupported) {
        if (offscreenFramebuffer != null) {
          pushFramebuffer();
          setFramebuffer(offscreenFramebuffer);
          offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
          gl.glClearColor(0,0,0,0);
          if (parent.frameCount == 0) {
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          }
 else {
            gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
            drawOffscreenTexture((offscreenIndex + 1) % 2);
          }
        }
      }
 else {
        if (texture != null) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          if (0 < parent.frameCount) {
            drawScreenTexture();
          }
        }
      }
    }
  }
 else {
    if (offscreenFramebuffer == null) {
      createOffscreenFramebuffer();
    }
    pushFramebuffer();
    setFramebuffer(offscreenFramebuffer);
    offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
    gl.glClearColor(0,0,0,0);
    if (clearColorBuffer || parent.frameCount == 0) {
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
      drawOffscreenTexture((offscreenIndex + 1) % 2);
    }
  }
  clearColorBuffer0=clearColorBuffer;
  report(""String_Node_Str"");
}","/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  VERTEXCOUNT=0;
  TRIANGLECOUNT=0;
  FACECOUNT=0;
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
    if (a3d.lights) {
      noLights();
    }
  }
  if (!settingsInited) {
    defaultSettings();
  }
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  blend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  camera();
  perspective();
  lights=false;
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (primarySurface) {
    if (parent.frameCount == 0) {
      if (fboSupported) {
        if (offscreenFramebuffer == null) {
          createOffscreenFramebuffer();
        }
      }
 else {
        if (gl11 == null || gl11x == null) {
          throw new RuntimeException(""String_Node_Str"");
        }
        if (texture == null) {
          createScreenTexture();
        }
      }
    }
    if (clearColorBuffer) {
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      if (fboSupported) {
        if (offscreenFramebuffer != null) {
          pushFramebuffer();
          setFramebuffer(offscreenFramebuffer);
          offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
          gl.glClearColor(0,0,0,0);
          if (parent.frameCount == 0) {
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          }
 else {
            gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
            drawOffscreenTexture((offscreenIndex + 1) % 2);
          }
        }
      }
 else {
        if (texture != null) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          if (0 < parent.frameCount) {
            drawScreenTexture();
          }
        }
      }
    }
  }
 else {
    if (offscreenFramebuffer == null) {
      createOffscreenFramebuffer();
    }
    pushFramebuffer();
    setFramebuffer(offscreenFramebuffer);
    offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
    gl.glClearColor(0,0,0,0);
    if (clearColorBuffer || parent.frameCount == 0) {
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
      drawOffscreenTexture((offscreenIndex + 1) % 2);
    }
  }
  clearColorBuffer0=clearColorBuffer;
  report(""String_Node_Str"");
}",0.9963302752293578
163739,"/** 
 * Similar to gluOrtho(), but wipes out the current projection matrix. <P> Implementation partially based on Mesa's matrix.c.
 */
public void ortho(float left,float right,float bottom,float top,float near,float far){
  float x=2.0f / (right - left);
  float y=2.0f / (top - bottom);
  float z=-2.0f / (far - near);
  float tx=-(right + left) / (right - left);
  float ty=-(top + bottom) / (top - bottom);
  float tz=-(far + near) / (far - near);
  glprojection[0]=x;
  glprojection[1]=0.0f;
  glprojection[2]=0.0f;
  glprojection[3]=0.0f;
  glprojection[4]=0.0f;
  glprojection[5]=y;
  glprojection[6]=0.0f;
  glprojection[7]=0.0f;
  glprojection[8]=0;
  glprojection[9]=0;
  glprojection[10]=z;
  glprojection[11]=0.0f;
  glprojection[12]=tx;
  glprojection[13]=ty;
  glprojection[14]=tz;
  glprojection[15]=1.0f;
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glLoadMatrixf(glprojection,0);
  copyGLArrayToPMatrix(glprojection,projection);
  gl.glMatrixMode(GL10.GL_MODELVIEW);
}","/** 
 * Properly setting the ortographic projection depends on the values  used to set the camera (eye and center).
 */
public void ortho(float left,float right,float bottom,float top,float near,float far){
  left-=currentEyeX;
  right-=currentEyeX;
  bottom-=currentCenterY;
  top-=currentCenterY;
  float x=2.0f / (right - left);
  float y=2.0f / (top - bottom);
  float z=-2.0f / (far - near);
  float tx=-(right + left) / (right - left);
  float ty=-(top + bottom) / (top - bottom);
  float tz=-(far + near) / (far - near);
  glprojection[0]=x;
  glprojection[1]=0.0f;
  glprojection[2]=0.0f;
  glprojection[3]=0.0f;
  glprojection[4]=0.0f;
  glprojection[5]=y;
  glprojection[6]=0.0f;
  glprojection[7]=0.0f;
  glprojection[8]=0;
  glprojection[9]=0;
  glprojection[10]=z;
  glprojection[11]=0.0f;
  glprojection[12]=tx;
  glprojection[13]=ty;
  glprojection[14]=tz;
  glprojection[15]=1.0f;
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glLoadMatrixf(glprojection,0);
  copyGLArrayToPMatrix(glprojection,projection);
  gl.glMatrixMode(GL10.GL_MODELVIEW);
}",0.8477728830151737
163740,"protected void updatePixelsImpl(int x,int y,int w,int h){
  int x2=x + w;
  int y2=y + h;
  if (!modified) {
    mx1=x;
    mx2=x2;
    my1=y;
    my2=y2;
    modified=true;
  }
 else {
    if (x < mx1)     mx1=x;
    if (x > mx2)     mx2=x;
    if (y < my1)     my1=y;
    if (y > my2)     my2=y;
    if (x2 < mx1)     mx1=x2;
    if (x2 > mx2)     mx2=x2;
    if (y2 < my1)     my1=y2;
    if (y2 > my2)     my2=y2;
  }
}","protected void updatePixelsImpl(int x,int y,int w,int h){
  int x2=x + w;
  int y2=y + h;
  if (!modified) {
    mx1=x;
    mx2=x2;
    my1=y;
    my2=y2;
    modified=true;
  }
 else {
    if (x < mx1)     mx1=x;
    if (x > mx2)     mx2=x;
    if (y < my1)     my1=y;
    if (y > my2)     my2=y;
    if (x2 < mx1)     mx1=x2;
    if (x2 > mx2)     mx2=x2;
    if (y2 < my1)     my1=y2;
    if (y2 > my2)     my2=y2;
  }
  if (texture != null) {
  }
}",0.9668571428571427
163741,"/** 
 * Call this when you want to mess with the pixels[] array. <p/> For subclasses where the pixels[] buffer isn't set by default, this should copy all data into the pixels[] array
 */
public void loadPixels(){
  if (pixels == null || pixels.length != width * height) {
    pixels=new int[width * height];
  }
  if (bitmap != null) {
    bitmap.getPixels(pixels,0,width,0,0,width,height);
  }
}","/** 
 * Call this when you want to mess with the pixels[] array. <p/> For subclasses where the pixels[] buffer isn't set by default, this should copy all data into the pixels[] array
 */
public void loadPixels(){
  if (pixels == null || pixels.length != width * height) {
    pixels=new int[width * height];
  }
  if (bitmap != null) {
    bitmap.getPixels(pixels,0,width,0,0,width,height);
  }
  if (texture != null) {
  }
}",0.9646772228989038
163742,"protected void vertexCheck(){
  if (vertexCount == vertices.length) {
    float temp[][]=new float[vertexCount << 1][VERTEX_FIELD_COUNT];
    System.arraycopy(vertices,0,temp,0,vertexCount);
    vertices=temp;
  }
}","protected void vertexCheck(){
  if (vertexCount == vertices.length) {
    float temp[][]=new float[vertexCount << 1][VERTEX_FIELD_COUNT];
    System.arraycopy(vertices,0,temp,0,vertexCount);
    vertices=temp;
    PImage texTmp[]=new PImage[vertexCount << 1];
    System.arraycopy(verticesTexture,0,texTmp,0,vertexCount);
    verticesTexture=texTmp;
  }
}",0.7543859649122807
163743,"protected void addNewFace(boolean firstFace){
  if (faceCount == faceOffset.length) {
    faceOffset=PApplet.expand(faceOffset);
    faceLength=PApplet.expand(faceLength);
    faceTexture=PApplet.expand(faceTexture);
  }
  faceOffset[faceCount]=firstFace ? 0 : triangleCount;
  faceLength[faceCount]=1;
  faceTexture[faceCount]=textureImage;
  faceCount++;
}","protected void addNewFace(boolean firstFace,PImage tex){
  if (faceCount == faceOffset.length) {
    faceOffset=PApplet.expand(faceOffset);
    faceLength=PApplet.expand(faceLength);
    faceTexture=PApplet.expand(faceTexture);
  }
  faceOffset[faceCount]=firstFace ? 0 : triangleCount;
  faceLength[faceCount]=1;
  faceTexture[faceCount]=tex;
  faceCount++;
}",0.9721448467966574
163744,"protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  PTexture tex=null;
  boolean texturing=false;
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=start; j < stop; j++) {
    int i=faceOffset[j];
    FACECOUNT++;
    if (faceTexture[j] != null) {
      tex=faceTexture[j].getTexture();
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
        gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
        texturing=true;
      }
 else {
        texturing=false;
      }
    }
 else {
      texturing=false;
    }
    if (recordingModel) {
      int n0=recordedVertices.size();
      int n1=n0 + 3 * faceLength[j] - 1;
      VertexGroup group=PShape3D.newVertexGroup(n0,n1,TRIANGLES,0,faceTexture[j]);
      recordedGroups.add(group);
    }
    if (vertexBuffer.capacity() / 3 < 3 * faceLength[j]) {
      expandBuffers();
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    texCoordBuffer.position(0);
    int n=0;
    for (int k=0; k < faceLength[j]; k++) {
      TRIANGLECOUNT++;
      float a[]=vertices[triangles[i][VERTEX1]];
      float b[]=vertices[triangles[i][VERTEX2]];
      float c[]=vertices[triangles[i][VERTEX3]];
      float uscale=1.0f;
      float vscale=1.0f;
      float cx=0.0f;
      float sx=+1.0f;
      float cy=0.0f;
      float sy=+1.0f;
      if (texturing) {
        uscale*=tex.getMaxTextureCoordS();
        vscale*=tex.getMaxTextureCoordT();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
      }
      if (recordingModel) {
        recordedVertices.add(new PVector(a[X],a[Y],a[Z]));
        recordedColors.add(new float[]{a[R],a[G],a[B],a[A]});
        recordedNormals.add(new PVector(a[NX],a[NY],a[NZ]));
        recordedTexCoords.add(new PVector((cx + sx * a[U]) * uscale,(cy + sy * a[V]) * vscale,0.0f));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(a[X]);
        vertexArray[3 * n + 1]=toFixed32(a[Y]);
        vertexArray[3 * n + 2]=toFixed32(a[Z]);
        colorArray[4 * n + 0]=toFixed32(a[R]);
        colorArray[4 * n + 1]=toFixed32(a[G]);
        colorArray[4 * n + 2]=toFixed32(a[B]);
        colorArray[4 * n + 3]=toFixed32(a[A]);
        normalArray[3 * n + 0]=toFixed32(a[NX]);
        normalArray[3 * n + 1]=toFixed32(a[NY]);
        normalArray[3 * n + 2]=toFixed32(a[NZ]);
        texCoordArray[2 * n + 0]=toFixed32((cx + sx * a[U]) * uscale);
        texCoordArray[2 * n + 1]=toFixed32((cy + sy * a[V]) * vscale);
        n++;
        VERTEXCOUNT++;
      }
      if (recordingModel) {
        recordedVertices.add(new PVector(b[X],b[Y],b[Z]));
        recordedColors.add(new float[]{b[R],b[G],b[B],b[A]});
        recordedNormals.add(new PVector(b[NX],b[NY],b[NZ]));
        recordedTexCoords.add(new PVector((cx + sx * b[U]) * uscale,(cy + sy * b[V]) * vscale,0.0f));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(b[X]);
        vertexArray[3 * n + 1]=toFixed32(b[Y]);
        vertexArray[3 * n + 2]=toFixed32(b[Z]);
        colorArray[4 * n + 0]=toFixed32(b[R]);
        colorArray[4 * n + 1]=toFixed32(b[G]);
        colorArray[4 * n + 2]=toFixed32(b[B]);
        colorArray[4 * n + 3]=toFixed32(b[A]);
        normalArray[3 * n + 0]=toFixed32(b[NX]);
        normalArray[3 * n + 1]=toFixed32(b[NY]);
        normalArray[3 * n + 2]=toFixed32(b[NZ]);
        texCoordArray[2 * n + 0]=toFixed32((cx + sx * b[U]) * uscale);
        texCoordArray[2 * n + 1]=toFixed32((cy + sy * b[V]) * vscale);
        n++;
        VERTEXCOUNT++;
      }
      if (recordingModel) {
        recordedVertices.add(new PVector(c[X],c[Y],c[Z]));
        recordedColors.add(new float[]{c[R],c[G],c[B],c[A]});
        recordedNormals.add(new PVector(c[NX],c[NY],c[NZ]));
        recordedTexCoords.add(new PVector((cx + sx * c[U]) * uscale,(cy + sy * c[V]) * vscale,0.0f));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(c[X]);
        vertexArray[3 * n + 1]=toFixed32(c[Y]);
        vertexArray[3 * n + 2]=toFixed32(c[Z]);
        colorArray[4 * n + 0]=toFixed32(c[R]);
        colorArray[4 * n + 1]=toFixed32(c[G]);
        colorArray[4 * n + 2]=toFixed32(c[B]);
        colorArray[4 * n + 3]=toFixed32(c[A]);
        normalArray[3 * n + 0]=toFixed32(c[NX]);
        normalArray[3 * n + 1]=toFixed32(c[NY]);
        normalArray[3 * n + 2]=toFixed32(c[NZ]);
        texCoordArray[2 * n + 0]=toFixed32((cx + sx * c[U]) * uscale);
        texCoordArray[2 * n + 1]=toFixed32((cy + sy * c[V]) * vscale);
        n++;
        VERTEXCOUNT++;
      }
      i++;
    }
    if (!recordingModel) {
      vertexBuffer.put(vertexArray);
      colorBuffer.put(colorArray);
      normalBuffer.put(normalArray);
      if (texturing) {
        texCoordBuffer.put(texCoordArray);
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      normalBuffer.position(0);
      texCoordBuffer.position(0);
      gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
      gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
      gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
      if (texturing) {
        gl.glTexCoordPointer(2,GL10.GL_FIXED,0,texCoordBuffer);
      }
      gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    }
    if (texturing) {
      gl.glBindTexture(tex.getGLTarget(),0);
      gl.glDisable(tex.getGLTarget());
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  report(""String_Node_Str"");
}","protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  PTexture tex=null;
  boolean texturing=false;
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=start; j < stop; j++) {
    int i=faceOffset[j];
    FACECOUNT++;
    if (faceTexture[j] != null) {
      tex=faceTexture[j].getTexture();
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
        gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
        texturing=true;
      }
 else {
        texturing=false;
      }
    }
 else {
      texturing=false;
    }
    if (recordingModel) {
      int n0=recordedVertices.size();
      int n1=n0 + 3 * faceLength[j] - 1;
      VertexGroup group=PShape3D.newVertexGroup(n0,n1,TRIANGLES,0,faceTexture[j]);
      recordedGroups.add(group);
    }
    if (vertexBuffer.capacity() / 3 < 3 * faceLength[j]) {
      expandBuffers();
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    texCoordBuffer.position(0);
    int n=0;
    for (int k=0; k < faceLength[j]; k++) {
      TRIANGLECOUNT++;
      float a[]=vertices[triangles[i][VERTEX1]];
      float b[]=vertices[triangles[i][VERTEX2]];
      float c[]=vertices[triangles[i][VERTEX3]];
      float uscale=1.0f;
      float vscale=1.0f;
      float cx=0.0f;
      float sx=+1.0f;
      float cy=0.0f;
      float sy=+1.0f;
      if (texturing) {
        uscale*=tex.getMaxTextureCoordS();
        vscale*=tex.getMaxTextureCoordT();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
      }
      if (recordingModel) {
        recordedVertices.add(new PVector(a[X],a[Y],a[Z]));
        recordedColors.add(new float[]{a[R],a[G],a[B],a[A]});
        recordedNormals.add(new PVector(a[NX],a[NY],a[NZ]));
        recordedTexCoords.add(new PVector((cx + sx * a[U]) * uscale,(cy + sy * a[V]) * vscale,0.0f));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(a[X]);
        vertexArray[3 * n + 1]=toFixed32(a[Y]);
        vertexArray[3 * n + 2]=toFixed32(a[Z]);
        colorArray[4 * n + 0]=toFixed32(a[R]);
        colorArray[4 * n + 1]=toFixed32(a[G]);
        colorArray[4 * n + 2]=toFixed32(a[B]);
        colorArray[4 * n + 3]=toFixed32(a[A]);
        normalArray[3 * n + 0]=toFixed32(a[NX]);
        normalArray[3 * n + 1]=toFixed32(a[NY]);
        normalArray[3 * n + 2]=toFixed32(a[NZ]);
        texCoordArray[2 * n + 0]=toFixed32((cx + sx * a[U]) * uscale);
        texCoordArray[2 * n + 1]=toFixed32((cy + sy * a[V]) * vscale);
        n++;
        VERTEXCOUNT++;
      }
      if (recordingModel) {
        recordedVertices.add(new PVector(b[X],b[Y],b[Z]));
        recordedColors.add(new float[]{b[R],b[G],b[B],b[A]});
        recordedNormals.add(new PVector(b[NX],b[NY],b[NZ]));
        recordedTexCoords.add(new PVector((cx + sx * b[U]) * uscale,(cy + sy * b[V]) * vscale,0.0f));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(b[X]);
        vertexArray[3 * n + 1]=toFixed32(b[Y]);
        vertexArray[3 * n + 2]=toFixed32(b[Z]);
        colorArray[4 * n + 0]=toFixed32(b[R]);
        colorArray[4 * n + 1]=toFixed32(b[G]);
        colorArray[4 * n + 2]=toFixed32(b[B]);
        colorArray[4 * n + 3]=toFixed32(b[A]);
        normalArray[3 * n + 0]=toFixed32(b[NX]);
        normalArray[3 * n + 1]=toFixed32(b[NY]);
        normalArray[3 * n + 2]=toFixed32(b[NZ]);
        texCoordArray[2 * n + 0]=toFixed32((cx + sx * b[U]) * uscale);
        texCoordArray[2 * n + 1]=toFixed32((cy + sy * b[V]) * vscale);
        n++;
        VERTEXCOUNT++;
      }
      if (recordingModel) {
        recordedVertices.add(new PVector(c[X],c[Y],c[Z]));
        recordedColors.add(new float[]{c[R],c[G],c[B],c[A]});
        recordedNormals.add(new PVector(c[NX],c[NY],c[NZ]));
        recordedTexCoords.add(new PVector((cx + sx * c[U]) * uscale,(cy + sy * c[V]) * vscale,0.0f));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(c[X]);
        vertexArray[3 * n + 1]=toFixed32(c[Y]);
        vertexArray[3 * n + 2]=toFixed32(c[Z]);
        colorArray[4 * n + 0]=toFixed32(c[R]);
        colorArray[4 * n + 1]=toFixed32(c[G]);
        colorArray[4 * n + 2]=toFixed32(c[B]);
        colorArray[4 * n + 3]=toFixed32(c[A]);
        normalArray[3 * n + 0]=toFixed32(c[NX]);
        normalArray[3 * n + 1]=toFixed32(c[NY]);
        normalArray[3 * n + 2]=toFixed32(c[NZ]);
        texCoordArray[2 * n + 0]=toFixed32((cx + sx * c[U]) * uscale);
        texCoordArray[2 * n + 1]=toFixed32((cy + sy * c[V]) * vscale);
        n++;
        VERTEXCOUNT++;
      }
      i++;
    }
    if (!recordingModel) {
      vertexBuffer.put(vertexArray);
      colorBuffer.put(colorArray);
      normalBuffer.put(normalArray);
      if (texturing) {
        texCoordBuffer.put(texCoordArray);
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      normalBuffer.position(0);
      texCoordBuffer.position(0);
      gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
      gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
      gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
      if (texturing) {
        gl.glTexCoordPointer(2,GL10.GL_FIXED,0,texCoordBuffer);
      }
      gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    }
    if (texturing) {
      gl.glDisable(tex.getGLTarget());
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  report(""String_Node_Str"");
}",0.9961250322913976
163745,"/** 
 * Add the triangle.
 */
protected void addTriangle(int a,int b,int c){
  if (triangleCount == triangles.length) {
    int temp[][]=new int[triangleCount << 1][TRIANGLE_FIELD_COUNT];
    System.arraycopy(triangles,0,temp,0,triangleCount);
    triangles=temp;
  }
  triangles[triangleCount][VERTEX1]=a;
  triangles[triangleCount][VERTEX2]=b;
  triangles[triangleCount][VERTEX3]=c;
  triangleCount++;
  boolean firstFace=triangleCount == 1;
  if (textureImage != textureImagePrev || firstFace) {
    addNewFace(firstFace);
  }
 else {
    faceLength[faceCount - 1]++;
  }
  textureImagePrev=textureImage;
}","/** 
 * Add the triangle.
 */
protected void addTriangle(int a,int b,int c){
  if (triangleCount == triangles.length) {
    int temp[][]=new int[triangleCount << 1][TRIANGLE_FIELD_COUNT];
    System.arraycopy(triangles,0,temp,0,triangleCount);
    triangles=temp;
  }
  triangles[triangleCount][VERTEX1]=a;
  triangles[triangleCount][VERTEX2]=b;
  triangles[triangleCount][VERTEX3]=c;
  PImage tex=verticesTexture[a];
  boolean firstFace=triangleCount == 0;
  if (tex != textureImagePrev || firstFace) {
    addNewFace(firstFace,tex);
  }
 else {
    faceLength[faceCount - 1]++;
  }
  triangleCount++;
  textureImagePrev=tex;
}",0.6612772837510105
163746,"public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (!lights) {
    glEnableLights();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][2]=currentLightSpecular[3];
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}","public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (!lights) {
    glEnableLights();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][3]=currentLightSpecular[3];
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}",0.9992307692307691
163747,"public int addTexture(GL10 gl){
  int[] textures=new int[1];
  gl.glGenTextures(1,textures,0);
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textures[0]);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_MIN_FILTER,GL10.GL_NEAREST);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_MAG_FILTER,GL10.GL_NEAREST);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_WRAP_S,GL10.GL_CLAMP_TO_EDGE);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_WRAP_T,GL10.GL_CLAMP_TO_EDGE);
  gl.glTexImage2D(GL10.GL_TEXTURE_2D,0,GL10.GL_RGBA,texWidth,texHeight,0,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,null);
  gl.glBindTexture(GL10.GL_TEXTURE_2D,0);
  currentTexID=-1;
  if (texIDList == null) {
    texIDList=new int[1];
    texIDList[0]=textures[0];
  }
 else {
    int[] tmp=texIDList;
    texIDList=new int[texIDList.length + 1];
    PApplet.arrayCopy(tmp,texIDList,tmp.length);
    texIDList[tmp.length]=textures[0];
  }
  return textures[0];
}","public int addTexture(GL10 gl){
  int[] textures=new int[1];
  gl.glGenTextures(1,textures,0);
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textures[0]);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_MIN_FILTER,GL10.GL_NEAREST);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_MAG_FILTER,GL10.GL_NEAREST);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_WRAP_S,GL10.GL_CLAMP_TO_EDGE);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_WRAP_T,GL10.GL_CLAMP_TO_EDGE);
  gl.glTexImage2D(GL10.GL_TEXTURE_2D,0,GL10.GL_RGBA,texWidth,texHeight,0,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,null);
  if (texIDList == null) {
    texIDList=new int[1];
    texIDList[0]=textures[0];
  }
 else {
    int[] tmp=texIDList;
    texIDList=new int[texIDList.length + 1];
    PApplet.arrayCopy(tmp,texIDList,tmp.length);
    texIDList[tmp.length]=textures[0];
  }
  currentTexID=textures[0];
  return currentTexID;
}",0.9323308270676692
163748,"protected void addToTexture(GL10 gl){
  int[] rgba=new int[width * height];
  int t=0;
  int p=0;
  if (PGraphicsAndroid3D.BIG_ENDIAN) {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=(image.pixels[p++] << 24) | 0xFFFFFFFF;
      }
    }
  }
 else {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=(image.pixels[p++] << 24) | 0xFFFFFFFF;
      }
    }
  }
  if (offsetX + width > texWidth) {
    offsetX=0;
    offsetY+=lineHeight;
    lineHeight=0;
  }
  lineHeight=Math.max(lineHeight,height);
  if (offsetY + lineHeight > texHeight) {
    lastTexID=addTexture(gl);
    offsetX=0;
    offsetY=0;
    lineHeight=0;
  }
  if (lastTexID == -1) {
    lastTexID=texIDList[0];
  }
  if (currentTexID != lastTexID) {
    gl.glBindTexture(GL10.GL_TEXTURE_2D,lastTexID);
    currentTexID=lastTexID;
  }
  gl.glTexSubImage2D(GL10.GL_TEXTURE_2D,0,offsetX,offsetY,width,height,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,IntBuffer.wrap(rgba));
  texture=new TextureInfo(currentTexID,offsetX,offsetY + height,width,-height);
  offsetX+=width;
}","protected void addToTexture(GL10 gl){
  int[] rgba=new int[width * height];
  int t=0;
  int p=0;
  if (PGraphicsAndroid3D.BIG_ENDIAN) {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=0xFFFFFF00 | image.pixels[p++];
      }
    }
  }
 else {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=(image.pixels[p++] << 24) | 0x00FFFFFF;
      }
    }
  }
  if (offsetX + width > texWidth) {
    offsetX=0;
    offsetY+=lineHeight;
    lineHeight=0;
  }
  lineHeight=Math.max(lineHeight,height);
  if (offsetY + lineHeight > texHeight) {
    lastTexID=addTexture(gl);
    offsetX=0;
    offsetY=0;
    lineHeight=0;
  }
  if (lastTexID == -1) {
    lastTexID=texIDList[0];
  }
  if (currentTexID != lastTexID) {
    gl.glBindTexture(GL10.GL_TEXTURE_2D,lastTexID);
    currentTexID=lastTexID;
  }
  gl.glTexSubImage2D(GL10.GL_TEXTURE_2D,0,offsetX,offsetY,width,height,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,IntBuffer.wrap(rgba));
  texture=new TextureInfo(currentTexID,offsetX,offsetY + height,width,-height);
  offsetX+=width;
}",0.864986498649865
163749,"/** 
 * Disables lighting.
 */
public void noLights(){
  lights=false;
  gl.glDisable(GL10.GL_LIGHTING);
  lightCount=0;
}","/** 
 * Disables lighting.
 */
public void noLights(){
  disableLights();
  lightCount=0;
}",0.7887323943661971
163750,"public void pointLight(float r,float g,float b,float x,float y,float z){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=POINT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}","public void pointLight(float r,float g,float b,float x,float y,float z){
  if (!lights) {
    enableLights();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=POINT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}",0.9820096533567354
163751,"public void spotLight(float r,float g,float b,float x,float y,float z,float nx,float ny,float nz,float angle,float concentration){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=SPOT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  lightSpotAngle[lightCount]=PApplet.degrees(angle);
  lightSpotAngleCos[lightCount]=Math.max(0,(float)Math.cos(angle));
  lightSpotConcentration[lightCount]=concentration;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightSpotAngle(lightCount);
  glLightSpotConcentration(lightCount);
  lightCount++;
}","public void spotLight(float r,float g,float b,float x,float y,float z,float nx,float ny,float nz,float angle,float concentration){
  if (!lights) {
    enableLights();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=SPOT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  lightSpotAngle[lightCount]=PApplet.degrees(angle);
  lightSpotAngleCos[lightCount]=Math.max(0,(float)Math.cos(angle));
  lightSpotConcentration[lightCount]=concentration;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightSpotAngle(lightCount);
  glLightSpotConcentration(lightCount);
  lightCount++;
}",0.9875719915125796
163752,"/** 
 * Sets up an ambient and directional light using OpenGL. API takef from PGraphics3D. <PRE> The Lighting Skinny: The way lighting works is complicated enough that it's worth producing a document to describe it. Lighting calculations proceed pretty much exactly as described in the OpenGL red book. Light-affecting material properties: AMBIENT COLOR - multiplies by light's ambient component - for believability this should match diffuse color DIFFUSE COLOR - multiplies by light's diffuse component SPECULAR COLOR - multiplies by light's specular component - usually less colored than diffuse/ambient SHININESS - the concentration of specular effect - this should be set pretty high (20-50) to see really noticeable specularity EMISSIVE COLOR - constant additive color effect Light types: AMBIENT - one color - no specular color - no direction - may have falloff (constant, linear, and quadratic) - may have position (which matters in non-constant falloff case) - multiplies by a material's ambient reflection DIRECTIONAL - has diffuse color - has specular color - has direction - no position - no falloff - multiplies by a material's diffuse and specular reflections POINT - has diffuse color - has specular color - has position - no direction - may have falloff (constant, linear, and quadratic) - multiplies by a material's diffuse and specular reflections SPOT - has diffuse color - has specular color - has position - has direction - has cone angle (set to half the total cone angle) - has concentration value - may have falloff (constant, linear, and quadratic) - multiplies by a material's diffuse and specular reflections Normal modes: All of the primitives (rect, box, sphere, etc.) have their normals set nicely. During beginShape/endShape normals can be set by the user. AUTO-NORMAL - if no normal is set during the shape, we are in auto-normal mode - auto-normal calculates one normal per triangle (face-normal mode) SHAPE-NORMAL - if one normal is set during the shape, it will be used for all vertices VERTEX-NORMAL - if multiple normals are set, each normal applies to subsequent vertices - (except for the first one, which applies to previous and subsequent vertices) Efficiency consequences: There is a major efficiency consequence of position-dependent lighting calculations per vertex. (See below for determining whether lighting is vertex position-dependent.) If there is no position dependency then the only factors that affect the lighting contribution per vertex are its colors and its normal. There is a major efficiency win if 1) lighting is not position dependent 2) we are in AUTO-NORMAL or SHAPE-NORMAL mode because then we can calculate one lighting contribution per shape (SHAPE-NORMAL) or per triangle (AUTO-NORMAL) and simply multiply it into the vertex colors. The converse is our worst-case performance when 1) lighting is position dependent 2) we are in AUTO-NORMAL mode because then we must calculate lighting per-face * per-vertex. Each vertex has a different lighting contribution per face in which it appears. Yuck. Determining vertex position dependency: If any of the following factors are TRUE then lighting is vertex position dependent: 1) Any lights uses non-constant falloff 2) There are any point or spot lights 3) There is a light with specular color AND there is a material with specular color So worth noting is that default lighting (a no-falloff ambient and a directional without specularity) is not position-dependent. We should capitalize. Simon Greenwold, April 2005 </PRE>
 */
public void lights(){
  lights=true;
  gl.glEnable(GL10.GL_LIGHTING);
  int colorModeSaved=colorMode;
  colorMode=RGB;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  ambientLight(colorModeX * 0.5f,colorModeY * 0.5f,colorModeZ * 0.5f);
  directionalLight(colorModeX * 0.5f,colorModeY * 0.5f,colorModeZ * 0.5f,0,0,-1);
  colorMode=colorModeSaved;
}","/** 
 * Sets up an ambient and directional light using OpenGL. API taken from PGraphics3D. <PRE> The Lighting Skinny: The way lighting works is complicated enough that it's worth producing a document to describe it. Lighting calculations proceed pretty much exactly as described in the OpenGL red book. Light-affecting material properties: AMBIENT COLOR - multiplies by light's ambient component - for believability this should match diffuse color DIFFUSE COLOR - multiplies by light's diffuse component SPECULAR COLOR - multiplies by light's specular component - usually less colored than diffuse/ambient SHININESS - the concentration of specular effect - this should be set pretty high (20-50) to see really noticeable specularity EMISSIVE COLOR - constant additive color effect Light types: AMBIENT - one color - no specular color - no direction - may have falloff (constant, linear, and quadratic) - may have position (which matters in non-constant falloff case) - multiplies by a material's ambient reflection DIRECTIONAL - has diffuse color - has specular color - has direction - no position - no falloff - multiplies by a material's diffuse and specular reflections POINT - has diffuse color - has specular color - has position - no direction - may have falloff (constant, linear, and quadratic) - multiplies by a material's diffuse and specular reflections SPOT - has diffuse color - has specular color - has position - has direction - has cone angle (set to half the total cone angle) - has concentration value - may have falloff (constant, linear, and quadratic) - multiplies by a material's diffuse and specular reflections Normal modes: All of the primitives (rect, box, sphere, etc.) have their normals set nicely. During beginShape/endShape normals can be set by the user. AUTO-NORMAL - if no normal is set during the shape, we are in auto-normal mode - auto-normal calculates one normal per triangle (face-normal mode) SHAPE-NORMAL - if one normal is set during the shape, it will be used for all vertices VERTEX-NORMAL - if multiple normals are set, each normal applies to subsequent vertices - (except for the first one, which applies to previous and subsequent vertices) Efficiency consequences: There is a major efficiency consequence of position-dependent lighting calculations per vertex. (See below for determining whether lighting is vertex position-dependent.) If there is no position dependency then the only factors that affect the lighting contribution per vertex are its colors and its normal. There is a major efficiency win if 1) lighting is not position dependent 2) we are in AUTO-NORMAL or SHAPE-NORMAL mode because then we can calculate one lighting contribution per shape (SHAPE-NORMAL) or per triangle (AUTO-NORMAL) and simply multiply it into the vertex colors. The converse is our worst-case performance when 1) lighting is position dependent 2) we are in AUTO-NORMAL mode because then we must calculate lighting per-face * per-vertex. Each vertex has a different lighting contribution per face in which it appears. Yuck. Determining vertex position dependency: If any of the following factors are TRUE then lighting is vertex position dependent: 1) Any lights uses non-constant falloff 2) There are any point or spot lights 3) There is a light with specular color AND there is a material with specular color So worth noting is that default lighting (a no-falloff ambient and a directional without specularity) is not position-dependent. We should capitalize. Simon Greenwold, April 2005 </PRE>
 */
public void lights(){
  enableLights();
  int colorModeSaved=colorMode;
  colorMode=RGB;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  ambientLight(colorModeX * 0.5f,colorModeY * 0.5f,colorModeZ * 0.5f);
  directionalLight(colorModeX * 0.5f,colorModeY * 0.5f,colorModeZ * 0.5f,0,0,-1);
  colorMode=colorModeSaved;
}",0.9940568475452196
163753,"public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][2]=currentLightSpecular[3];
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}","public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (!lights) {
    enableLights();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][2]=currentLightSpecular[3];
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}",0.9839530332681018
163754,"/** 
 * Add an ambient light based on the current color mode. This version includes an (x, y, z) position for situations where the falloff distance is used.
 */
public void ambientLight(float r,float g,float b,float x,float y,float z){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=AMBIENT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  glLightEnable(lightCount);
  glLightAmbient(lightCount);
  glLightPosition(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}","/** 
 * Add an ambient light based on the current color mode. This version includes an (x, y, z) position for situations where the falloff distance is used.
 */
public void ambientLight(float r,float g,float b,float x,float y,float z){
  if (!lights) {
    enableLights();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=AMBIENT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  glLightEnable(lightCount);
  glLightAmbient(lightCount);
  glLightPosition(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  glLightNoDiffuse(lightCount);
  glLightNoSpecular(lightCount);
  lightCount++;
}",0.9520795660036168
163755,"protected PImage getImpl(int x,int y,int w,int h){
  PImage newbie=new PImage(w,h);
  IntBuffer newbieBuffer=IntBuffer.allocate(w * h);
  gl.glReadPixels(x,y,w,h,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,newbieBuffer);
  newbieBuffer.get(newbie.pixels);
  nativeToJavaARGB(newbie);
  return newbie;
}","protected PImage getImpl(int x,int y,int w,int h){
  PImage newbie=parent.createImage(w,h,ARGB);
  PTexture newbieTex=newbie.getTexture();
  IntBuffer newbieBuffer=IntBuffer.allocate(w * h);
  gl.glReadPixels(x,height - y,w,-h,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,newbieBuffer);
  copyToTexture(newbieTex,newbieBuffer,0,0,w,h);
  newbie.textureToPixels();
  return newbie;
}",0.6285714285714286
163756,"protected void allocate(){
  if (!matricesAllocated) {
    glprojection=new float[16];
    glmodelview=new float[16];
    glmodelviewInv=new float[16];
    pcamera=new float[16];
    pcameraInv=new float[16];
    projection=new PMatrix3D();
    modelview=new PMatrix3D();
    modelviewInv=new PMatrix3D();
    camera=new PMatrix3D();
    cameraInv=new PMatrix3D();
    matricesAllocated=true;
  }
  if (!lightsAllocated) {
    lightType=new int[MAX_LIGHTS];
    lightPosition=new float[MAX_LIGHTS][4];
    lightNormal=new float[MAX_LIGHTS][4];
    lightDiffuse=new float[MAX_LIGHTS][4];
    lightSpecular=new float[MAX_LIGHTS][4];
    lightFalloffConstant=new float[MAX_LIGHTS];
    lightFalloffLinear=new float[MAX_LIGHTS];
    lightFalloffQuadratic=new float[MAX_LIGHTS];
    lightSpotAngle=new float[MAX_LIGHTS];
    lightSpotAngleCos=new float[MAX_LIGHTS];
    lightSpotConcentration=new float[MAX_LIGHTS];
    currentLightSpecular=new float[4];
    lightsAllocated=true;
  }
  if (!buffersAllocated) {
    ByteBuffer vbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    vertexBuffer=vbb.asIntBuffer();
    ByteBuffer cbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 4 * SIZEOF_INT);
    cbb.order(ByteOrder.nativeOrder());
    colorBuffer=cbb.asIntBuffer();
    ByteBuffer tbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    texCoordBuffer=tbb.asIntBuffer();
    ByteBuffer nbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    nbb.order(ByteOrder.nativeOrder());
    normalBuffer=nbb.asIntBuffer();
    vertexArray=new int[DEFAULT_BUFFER_SIZE * 3];
    colorArray=new int[DEFAULT_BUFFER_SIZE * 4];
    texCoordArray=new int[DEFAULT_BUFFER_SIZE * 2];
    normalArray=new int[DEFAULT_BUFFER_SIZE * 3];
    getsetBuffer=IntBuffer.allocate(1);
    getsetBuffer.rewind();
    getsetTex=new PTexture(parent,1,1,new PTexture.Parameters(ARGB,NEAREST));
    buffersAllocated=true;
  }
}","protected void allocate(){
  if (!matricesAllocated) {
    glprojection=new float[16];
    glmodelview=new float[16];
    glmodelviewInv=new float[16];
    pcamera=new float[16];
    pcameraInv=new float[16];
    projection=new PMatrix3D();
    modelview=new PMatrix3D();
    modelviewInv=new PMatrix3D();
    camera=new PMatrix3D();
    cameraInv=new PMatrix3D();
    matricesAllocated=true;
  }
  if (!lightsAllocated) {
    lightType=new int[MAX_LIGHTS];
    lightPosition=new float[MAX_LIGHTS][4];
    lightNormal=new float[MAX_LIGHTS][4];
    lightDiffuse=new float[MAX_LIGHTS][4];
    lightSpecular=new float[MAX_LIGHTS][4];
    lightFalloffConstant=new float[MAX_LIGHTS];
    lightFalloffLinear=new float[MAX_LIGHTS];
    lightFalloffQuadratic=new float[MAX_LIGHTS];
    lightSpotAngle=new float[MAX_LIGHTS];
    lightSpotAngleCos=new float[MAX_LIGHTS];
    lightSpotConcentration=new float[MAX_LIGHTS];
    currentLightSpecular=new float[4];
    lightsAllocated=true;
  }
  if (!buffersAllocated) {
    ByteBuffer vbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    vertexBuffer=vbb.asIntBuffer();
    ByteBuffer cbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 4 * SIZEOF_INT);
    cbb.order(ByteOrder.nativeOrder());
    colorBuffer=cbb.asIntBuffer();
    ByteBuffer tbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    texCoordBuffer=tbb.asIntBuffer();
    ByteBuffer nbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    nbb.order(ByteOrder.nativeOrder());
    normalBuffer=nbb.asIntBuffer();
    vertexArray=new int[DEFAULT_BUFFER_SIZE * 3];
    colorArray=new int[DEFAULT_BUFFER_SIZE * 4];
    texCoordArray=new int[DEFAULT_BUFFER_SIZE * 2];
    normalArray=new int[DEFAULT_BUFFER_SIZE * 3];
    getsetBuffer=IntBuffer.allocate(1);
    getsetBuffer.rewind();
    buffersAllocated=true;
  }
}",0.9773527931555108
163757,"protected void drawTexture(PTexture tex,int[] crop,int x,int y,int w,int h){
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_REPLACE);
  gl11.glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,crop,0);
  gl11x.glDrawTexiOES(0,x,y,w,h);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_MODULATE);
  gl.glDisable(tex.getGLTarget());
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
}","protected void drawTexture(PTexture tex,int[] crop,int x,int y,int w,int h){
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_REPLACE);
  gl11.glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,crop,0);
  gl11x.glDrawTexiOES(x,y,0,w,h);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_MODULATE);
  gl.glDisable(tex.getGLTarget());
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
}",0.9971870604781996
163758,"public TextureInfo(int glid,int cropX,int cropY,int cropW,int cropH){
  this.glid=glid;
  crop=new int[4];
  crop[0]=cropX;
  crop[1]=cropY;
  crop[2]=cropW;
  crop[3]=cropH;
}","public TextureInfo(int glid,int cropX,int cropY,int cropW,int cropH){
  this.glid=glid;
  crop=new int[4];
  crop[0]=cropX;
  crop[1]=cropY;
  crop[2]=cropW;
  crop[3]=cropH;
  u0=(float)cropX / (float)texWidth;
  u1=u0 + (float)cropW / (float)texWidth;
  v0=(float)(cropY + cropH) / (float)texHeight;
  v1=(float)cropY / (float)texHeight;
}",0.6808510638297872
163759,"protected void allocate(){
  if (!matricesAllocated) {
    glprojection=new float[16];
    glmodelview=new float[16];
    glmodelviewInv=new float[16];
    pcamera=new float[16];
    pcameraInv=new float[16];
    projection=new PMatrix3D();
    modelview=new PMatrix3D();
    modelviewInv=new PMatrix3D();
    camera=new PMatrix3D();
    cameraInv=new PMatrix3D();
    matricesAllocated=true;
  }
  if (!lightsAllocated) {
    lightType=new int[MAX_LIGHTS];
    lightPosition=new float[MAX_LIGHTS][4];
    lightNormal=new float[MAX_LIGHTS][4];
    lightDiffuse=new float[MAX_LIGHTS][4];
    lightSpecular=new float[MAX_LIGHTS][4];
    lightFalloffConstant=new float[MAX_LIGHTS];
    lightFalloffLinear=new float[MAX_LIGHTS];
    lightFalloffQuadratic=new float[MAX_LIGHTS];
    lightSpotAngle=new float[MAX_LIGHTS];
    lightSpotAngleCos=new float[MAX_LIGHTS];
    lightSpotConcentration=new float[MAX_LIGHTS];
    currentLightSpecular=new float[4];
    lightsAllocated=true;
  }
  if (!buffersAllocated) {
    ByteBuffer vbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    vertexBuffer=vbb.asIntBuffer();
    ByteBuffer cbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 4 * SIZEOF_INT);
    cbb.order(ByteOrder.nativeOrder());
    colorBuffer=cbb.asIntBuffer();
    ByteBuffer tbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    texCoordBuffer=tbb.asIntBuffer();
    ByteBuffer nbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    nbb.order(ByteOrder.nativeOrder());
    normalBuffer=nbb.asIntBuffer();
    vertexArray=new int[DEFAULT_BUFFER_SIZE * 3];
    colorArray=new int[DEFAULT_BUFFER_SIZE * 4];
    texCoordArray=new int[DEFAULT_BUFFER_SIZE * 2];
    normalArray=new int[DEFAULT_BUFFER_SIZE * 3];
    vbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    textVerticesBuffer=vbb.asIntBuffer();
    tbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    textTexCoordsBuffer=tbb.asIntBuffer();
    textVerticesArray=new int[DEFAULT_BUFFER_SIZE * 3];
    textTexCoordsArray=new int[DEFAULT_BUFFER_SIZE * 2];
    buffersAllocated=true;
  }
}","protected void allocate(){
  if (!matricesAllocated) {
    glprojection=new float[16];
    glmodelview=new float[16];
    glmodelviewInv=new float[16];
    pcamera=new float[16];
    pcameraInv=new float[16];
    projection=new PMatrix3D();
    modelview=new PMatrix3D();
    modelviewInv=new PMatrix3D();
    camera=new PMatrix3D();
    cameraInv=new PMatrix3D();
    matricesAllocated=true;
  }
  if (!lightsAllocated) {
    lightType=new int[MAX_LIGHTS];
    lightPosition=new float[MAX_LIGHTS][4];
    lightNormal=new float[MAX_LIGHTS][4];
    lightDiffuse=new float[MAX_LIGHTS][4];
    lightSpecular=new float[MAX_LIGHTS][4];
    lightFalloffConstant=new float[MAX_LIGHTS];
    lightFalloffLinear=new float[MAX_LIGHTS];
    lightFalloffQuadratic=new float[MAX_LIGHTS];
    lightSpotAngle=new float[MAX_LIGHTS];
    lightSpotAngleCos=new float[MAX_LIGHTS];
    lightSpotConcentration=new float[MAX_LIGHTS];
    currentLightSpecular=new float[4];
    lightsAllocated=true;
  }
  if (!buffersAllocated) {
    ByteBuffer vbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    vertexBuffer=vbb.asIntBuffer();
    ByteBuffer cbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 4 * SIZEOF_INT);
    cbb.order(ByteOrder.nativeOrder());
    colorBuffer=cbb.asIntBuffer();
    ByteBuffer tbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    texCoordBuffer=tbb.asIntBuffer();
    ByteBuffer nbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    nbb.order(ByteOrder.nativeOrder());
    normalBuffer=nbb.asIntBuffer();
    vertexArray=new int[DEFAULT_BUFFER_SIZE * 3];
    colorArray=new int[DEFAULT_BUFFER_SIZE * 4];
    texCoordArray=new int[DEFAULT_BUFFER_SIZE * 2];
    normalArray=new int[DEFAULT_BUFFER_SIZE * 3];
    buffersAllocated=true;
  }
}",0.895843287147635
163760,"protected void textCharModelImpl(Glyph.TextureInfo tex,float x1,float y1,float x2,float y2){
  if (textFont.currentTexID != tex.glid) {
    gl.glBindTexture(GL10.GL_TEXTURE_2D,tex.glid);
    textFont.currentTexID=tex.glid;
  }
  gl11.glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,tex.crop,0);
  gl11x.glDrawTexfOES(x1,height - y2,0,x2 - x1,y2 - y1);
}","protected void textCharModelImpl(Glyph.TextureInfo tex,float x1,float y1,float x2,float y2){
  if (textFont.currentTexID != tex.glid) {
    if (0 < textVertexCount) {
      renderTextModel();
      textVertexCount=0;
    }
    gl.glBindTexture(GL10.GL_TEXTURE_2D,tex.glid);
    textFont.currentTexID=tex.glid;
  }
  if (textVertexBuffer.capacity() < textVertexCount + 6) {
    expandTextBuffers();
  }
  int n=textVertexCount;
  textVertexArray[3 * n + 0]=toFixed32(x1);
  textVertexArray[3 * n + 1]=toFixed32(y1);
  textVertexArray[3 * n + 2]=toFixed32(0);
  textTexCoordArray[2 * n + 0]=toFixed32(tex.u0);
  textTexCoordArray[2 * n + 1]=toFixed32(tex.v0);
  n++;
  textVertexArray[3 * n + 0]=toFixed32(x2);
  textVertexArray[3 * n + 1]=toFixed32(y2);
  textVertexArray[3 * n + 2]=toFixed32(0);
  textTexCoordArray[2 * n + 0]=toFixed32(tex.u1);
  textTexCoordArray[2 * n + 1]=toFixed32(tex.v1);
  n++;
  textVertexArray[3 * n + 0]=toFixed32(x1);
  textVertexArray[3 * n + 1]=toFixed32(y2);
  textVertexArray[3 * n + 2]=toFixed32(0);
  textTexCoordArray[2 * n + 0]=toFixed32(tex.u0);
  textTexCoordArray[2 * n + 1]=toFixed32(tex.v1);
  n++;
  textVertexArray[3 * n + 0]=toFixed32(x1);
  textVertexArray[3 * n + 1]=toFixed32(y1);
  textVertexArray[3 * n + 2]=toFixed32(0);
  textTexCoordArray[2 * n + 0]=toFixed32(tex.u0);
  textTexCoordArray[2 * n + 1]=toFixed32(tex.v0);
  n++;
  textVertexArray[3 * n + 0]=toFixed32(x2);
  textVertexArray[3 * n + 1]=toFixed32(y1);
  textVertexArray[3 * n + 2]=toFixed32(0);
  textTexCoordArray[2 * n + 0]=toFixed32(tex.u1);
  textTexCoordArray[2 * n + 1]=toFixed32(tex.v0);
  n++;
  textVertexArray[3 * n + 0]=toFixed32(x2);
  textVertexArray[3 * n + 1]=toFixed32(y2);
  textVertexArray[3 * n + 2]=toFixed32(0);
  textTexCoordArray[2 * n + 0]=toFixed32(tex.u1);
  textTexCoordArray[2 * n + 1]=toFixed32(tex.v1);
  n++;
  textVertexCount=n;
}",0.2087960906263882
163761,"/** 
 * Implementation of actual drawing for a line of text.
 */
protected void textLineImpl(char buffer[],int start,int stop,float x,float y){
  if (gl11 == null || gl11x == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  if (!blend || blendMode != BLEND) {
    gl.glEnable(GL10.GL_BLEND);
    gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  }
  if (textFont.texIDList == null) {
    textFont.initTexture(gl,maxTextureSize,maxTextureSize);
    textFont.addAllGlyphsToTexture(gl);
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  textFont.currentTexID=textFont.texIDList[0];
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textFont.currentTexID);
  gl.glColor4f(colorFloats[0],colorFloats[1],colorFloats[2],colorFloats[3]);
  super.textLineImpl(buffer,start,stop,x,y);
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
  gl.glDisable(GL10.GL_TEXTURE_2D);
}","/** 
 * Implementation of actual drawing for a line of text.
 */
protected void textLineImpl(char buffer[],int start,int stop,float x,float y){
  if (gl11 == null || gl11x == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  if (!blend || blendMode != BLEND) {
    gl.glEnable(GL10.GL_BLEND);
    gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  }
  if (textFont.texIDList == null) {
    textFont.initTexture(gl,maxTextureSize,maxTextureSize);
    textFont.addAllGlyphsToTexture(gl);
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  textFont.currentTexID=textFont.texIDList[0];
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textFont.currentTexID);
  gl.glColor4f(colorFloats[0],colorFloats[1],colorFloats[2],colorFloats[3]);
  if (textMode == MODEL) {
    if (textVertexBuffer == null) {
      allocateTextModel();
    }
    gl.glNormal3f(0,0,1);
    textVertexCount=0;
  }
  super.textLineImpl(buffer,start,stop,x,y);
  if (textMode == MODEL && 0 < textVertexCount) {
    renderTextModel();
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
  gl.glDisable(GL10.GL_TEXTURE_2D);
}",0.8911368015414258
163762,"/** 
 * Implementation of actual drawing for a line of text.
 */
protected void textLineImpl(char buffer[],int start,int stop,float x,float y){
  if (gl11 == null || gl11x == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  if (!blend || blendMode != BLEND) {
    gl.glEnable(GL10.GL_BLEND);
    gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  }
  if (textFont.texIDList == null) {
    textFont.initTexture(gl,maxTextureSize,maxTextureSize);
    textFont.addAllGlyphsToTexture(gl);
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  textFont.currentTexID=textFont.texIDList[0];
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textFont.currentTexID);
  gl.glColor4f(colorFloats[0],colorFloats[1],colorFloats[2],colorFloats[3]);
  if (textMode == MODEL) {
    if (textVertexBuffer == null) {
      allocateTextModel();
    }
    gl.glNormal3f(0,0,1);
    textVertexCount=0;
  }
  super.textLineImpl(buffer,start,stop,x,y);
  if (textMode == MODEL && 0 < textVertexCount) {
    renderTextModel();
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
  gl.glDisable(GL10.GL_TEXTURE_2D);
}","/** 
 * Implementation of actual drawing for a line of text.
 */
protected void textLineImpl(char buffer[],int start,int stop,float x,float y){
  if (gl11 == null || gl11x == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  if (!blend || blendMode != BLEND) {
    gl.glEnable(GL10.GL_BLEND);
    gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  }
  if (textFont.texIDList == null) {
    textFont.initTexture(gl,maxTextureSize,maxTextureSize);
    textFont.addAllGlyphsToTexture(gl);
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  textFont.currentTexID=textFont.texIDList[0];
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textFont.currentTexID);
  gl.glColor4f(fillR,fillG,fillB,fillA);
  if (textMode == MODEL) {
    if (textVertexBuffer == null) {
      allocateTextModel();
    }
    gl.glNormal3f(0,0,1);
    textVertexCount=0;
  }
  super.textLineImpl(buffer,start,stop,x,y);
  if (textMode == MODEL && 0 < textVertexCount) {
    renderTextModel();
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
  gl.glDisable(GL10.GL_TEXTURE_2D);
}",0.9638128861429832
163763,"/** 
 * In the current implementation, start and stop are ignored (in OpenGL). This will obviously have to be revisited if/when proper depth sorting is implemented.
 */
protected void renderLines(int start,int stop){
  report(""String_Node_Str"");
  float sw0=0;
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  for (int j=start; j < stop; j++) {
    int i=pathOffset[j];
    float sw=vertices[lines[i][VERTEX1]][SW];
    if (sw > 0) {
      gl.glLineWidth(sw);
      if (sw0 != sw && recordingModel) {
        int n0=recordedVertices.size();
        int n1=n0 + pathLength[j];
        for (int k=j + 1; k < stop; k++) {
          int i1=pathOffset[k];
          float sw1=vertices[lines[i1][VERTEX1]][SW];
          if (sw0 != sw1) {
            break;
          }
          n1=n0 + pathLength[k];
        }
        VertexGroup group=PShape3D.newVertexGroup(n0,n1,LINE_STRIP,sw,null);
        recordedGroups.add(group);
      }
      if (vertexBuffer.capacity() / 3 <= 3 * (pathLength[j] + 1)) {
        expandBuffers();
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      int n=0;
      float a[]=vertices[lines[i][VERTEX1]];
      if (recordingModel) {
        recordedVertices.add(new PVector(a[X],a[Y],a[Z]));
        recordedColors.add(new float[]{a[SR],a[SG],a[SB],a[SA]});
        recordedNormals.add(new PVector(0,0,0));
        recordedTexCoords.add(new PVector(0,0,0));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(a[X]);
        vertexArray[3 * n + 1]=toFixed32(a[Y]);
        vertexArray[3 * n + 2]=toFixed32(a[Z]);
        colorArray[4 * n + 0]=toFixed32(a[SR]);
        colorArray[4 * n + 1]=toFixed32(a[SG]);
        colorArray[4 * n + 2]=toFixed32(a[SB]);
        colorArray[4 * n + 3]=toFixed32(a[SA]);
        n++;
      }
      for (int k=0; k < pathLength[j]; k++) {
        float b[]=vertices[lines[i][VERTEX2]];
        if (recordingModel) {
          recordedVertices.add(new PVector(b[X],b[Y],b[Z]));
          recordedColors.add(new float[]{b[SR],b[SG],b[SB],b[SA]});
          recordedNormals.add(new PVector(0,0,0));
          recordedTexCoords.add(new PVector(0,0,0));
        }
 else {
          vertexArray[3 * n + 0]=toFixed32(b[X]);
          vertexArray[3 * n + 1]=toFixed32(b[Y]);
          vertexArray[3 * n + 2]=toFixed32(b[Z]);
          colorArray[4 * n + 0]=toFixed32(b[SR]);
          colorArray[4 * n + 1]=toFixed32(b[SG]);
          colorArray[4 * n + 2]=toFixed32(b[SB]);
          colorArray[4 * n + 3]=toFixed32(b[SA]);
          n++;
        }
        i++;
      }
      if (!recordingModel) {
        vertexBuffer.put(vertexArray);
        colorBuffer.put(colorArray);
        vertexBuffer.position(0);
        colorBuffer.position(0);
        gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
        gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
        gl.glDrawArrays(GL10.GL_LINE_STRIP,0,pathLength[j] + 1);
      }
    }
    sw0=sw;
  }
  report(""String_Node_Str"");
}","/** 
 * In the current implementation, start and stop are ignored (in OpenGL). This will obviously have to be revisited if/when proper depth sorting is implemented.
 */
protected void renderLines(int start,int stop){
  report(""String_Node_Str"");
  float sw0=0;
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  for (int j=start; j < stop; j++) {
    int i=pathOffset[j];
    float sw=vertices[lines[i][VERTEX1]][SW];
    if (sw > 0) {
      gl.glLineWidth(sw);
      if (sw0 != sw && recordingModel) {
        int n0=recordedVertices.size();
        int n1=n0 + pathLength[j];
        for (int k=j + 1; k < stop; k++) {
          int i1=pathOffset[k];
          float sw1=vertices[lines[i1][VERTEX1]][SW];
          if (sw0 != sw1) {
            break;
          }
          n1=n0 + pathLength[k];
        }
        VertexGroup group=PShape3D.newVertexGroup(n0,n1,LINE_STRIP,sw,null);
        recordedGroups.add(group);
      }
      if (vertexBuffer.capacity() / 3 <= 3 * (pathLength[j] + 1)) {
        expandBuffers();
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      int n=0;
      float a[]=vertices[lines[i][VERTEX1]];
      if (recordingModel) {
        recordedVertices.add(new PVector(a[X],a[Y],a[Z]));
        recordedColors.add(new float[]{a[SR],a[SG],a[SB],a[SA]});
        recordedNormals.add(new PVector(0,0,0));
        recordedTexCoords.add(new PVector(0,0,0));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(a[X]);
        vertexArray[3 * n + 1]=toFixed32(a[Y]);
        vertexArray[3 * n + 2]=toFixed32(a[Z]);
        colorArray[4 * n + 0]=toFixed32(a[SR]);
        colorArray[4 * n + 1]=toFixed32(a[SG]);
        colorArray[4 * n + 2]=toFixed32(a[SB]);
        colorArray[4 * n + 3]=toFixed32(a[SA]);
        n++;
      }
      for (int k=0; k < pathLength[j]; k++) {
        float b[]=vertices[lines[i][VERTEX2]];
        if (recordingModel) {
          recordedVertices.add(new PVector(b[X],b[Y],b[Z]));
          recordedColors.add(new float[]{b[SR],b[SG],b[SB],b[SA]});
          recordedNormals.add(new PVector(0,0,0));
          recordedTexCoords.add(new PVector(0,0,0));
        }
 else {
          vertexArray[3 * n + 0]=toFixed32(b[X]);
          vertexArray[3 * n + 1]=toFixed32(b[Y]);
          vertexArray[3 * n + 2]=toFixed32(b[Z]);
          colorArray[4 * n + 0]=toFixed32(b[SR]);
          colorArray[4 * n + 1]=toFixed32(b[SG]);
          colorArray[4 * n + 2]=toFixed32(b[SB]);
          colorArray[4 * n + 3]=toFixed32(b[SA]);
          n++;
        }
        i++;
      }
      if (!recordingModel) {
        vertexBuffer.put(vertexArray);
        colorBuffer.put(colorArray);
        vertexBuffer.position(0);
        colorBuffer.position(0);
        gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
        gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
        gl.glDrawArrays(GL10.GL_LINE_STRIP,0,pathLength[j] + 1);
      }
    }
    sw0=sw;
  }
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  report(""String_Node_Str"");
}",0.9841425535393168
163764,"synchronized public void noClear(){
  if (g instanceof PGraphicsAndroid3D) {
    ((PGraphicsAndroid3D)g).noClear();
  }
}","synchronized public void noClear(){
  if (g instanceof PGraphicsAndroid3D) {
    ((PGraphicsAndroid3D)g).noClear();
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.7934426229508197
163765,"synchronized public void clear(){
  if (g instanceof PGraphicsAndroid3D) {
    ((PGraphicsAndroid3D)g).clear();
  }
}","synchronized public void clear(){
  if (g instanceof PGraphicsAndroid3D) {
    ((PGraphicsAndroid3D)g).clear();
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.7878787878787878
163766,"protected void defaultSettings(){
  super.defaultSettings();
  manipulatingCamera=false;
  perspective();
  textureMode(IMAGE);
}","protected void defaultSettings(){
  super.defaultSettings();
  manipulatingCamera=false;
  textureMode(IMAGE);
}",0.9294605809128632
163767,"protected void drawScreenTexture(){
  gl.glEnable(GL10.GL_TEXTURE_2D);
  gl.glBindTexture(GL10.GL_TEXTURE_2D,screenTexID[0]);
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl11.glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,screenTexCrop,0);
  gl11x.glDrawTexiOES(0,0,0,width,height);
  gl.glDisable(GL10.GL_TEXTURE_2D);
  gl.glDepthMask(true);
  gl.glEnable(GL10.GL_BLEND);
}","protected void drawScreenTexture(){
  gl.glEnable(GL10.GL_TEXTURE_2D);
  gl.glBindTexture(GL10.GL_TEXTURE_2D,screenTexID[0]);
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl11.glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,screenTexCrop,0);
  gl11x.glDrawTexiOES(0,0,0,width,height);
  gl.glDisable(GL10.GL_TEXTURE_2D);
  gl.glDepthMask(true);
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
}",0.8927738927738927
163768,"void createDrawFramebuffer(){
  drawTexCrop=new int[4];
  drawTexCrop[0]=0;
  drawTexCrop[1]=0;
  drawTexCrop[2]=width;
  drawTexCrop[3]=height;
  drawImages=new PImage[2];
  drawImages[0]=parent.createImage(width,height,ARGB,NEAREST);
  drawImages[1]=parent.createImage(width,height,ARGB,NEAREST);
  drawTextures=new PTexture[2];
  drawTextures[0]=drawImages[0].getTexture();
  drawTextures[1]=drawImages[1].getTexture();
  drawIndex=0;
  drawFramebuffer=new PFramebuffer(parent,drawTextures[0].getGLWidth(),drawTextures[0].getGLHeight(),false);
  drawFramebuffer.addDepthBuffer(DEPTH_BITS);
  if (0 < STENCIL_BITS) {
    drawFramebuffer.addStencilBuffer(STENCIL_BITS);
  }
}","void createDrawFramebuffer(){
  drawTexCrop=new int[4];
  drawTexCrop[0]=0;
  drawTexCrop[1]=0;
  drawTexCrop[2]=width;
  drawTexCrop[3]=height;
  drawImages=new PImage[2];
  drawImages[0]=parent.createImage(width,height,ARGB,NEAREST);
  drawImages[1]=parent.createImage(width,height,ARGB,NEAREST);
  drawTextures=new PTexture[2];
  drawTextures[0]=drawImages[0].getTexture();
  drawTextures[1]=drawImages[1].getTexture();
  drawTextures[0].setFlippedY(true);
  drawTextures[1].setFlippedY(true);
  drawIndex=0;
  drawFramebuffer=new PFramebuffer(parent,drawTextures[0].getGLWidth(),drawTextures[0].getGLHeight(),false);
  drawFramebuffer.addDepthBuffer(DEPTH_BITS);
  if (0 < STENCIL_BITS) {
    drawFramebuffer.addStencilBuffer(STENCIL_BITS);
  }
}",0.9481065918653576
163769,"public void renderDrawTexture(int idx){
  PTexture tex=drawTextures[idx];
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_REPLACE);
  gl11.glTexParameteriv(tex.getGLTarget(),GL11Ext.GL_TEXTURE_CROP_RECT_OES,drawTexCrop,0);
  gl11x.glDrawTexiOES(0,0,0,width,height);
  gl.glDisable(tex.getGLTarget());
  gl.glDepthMask(true);
  gl.glEnable(GL10.GL_BLEND);
}","public void renderDrawTexture(int idx){
  PTexture tex=drawTextures[idx];
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_REPLACE);
  gl11.glTexParameteriv(tex.getGLTarget(),GL11Ext.GL_TEXTURE_CROP_RECT_OES,drawTexCrop,0);
  gl11x.glDrawTexiOES(0,0,0,width,height);
  gl.glDisable(tex.getGLTarget());
  gl.glDepthMask(true);
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
}",0.9155963302752294
163770,"/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  VERTEXCOUNT=0;
  TRIANGLECOUNT=0;
  FACECOUNT=0;
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    OPENGL_VENDOR=a3d.OPENGL_VENDOR;
    OPENGL_RENDERER=a3d.OPENGL_RENDERER;
    OPENGL_VERSION=a3d.OPENGL_VERSION;
    npotTexSupported=a3d.npotTexSupported;
    mipmapSupported=a3d.mipmapSupported;
    matrixGetSupported=a3d.matrixGetSupported;
    vboSupported=a3d.vboSupported;
    fboSupported=a3d.fboSupported;
    maxTextureSize=a3d.maxTextureSize;
    maxPointSize=a3d.maxPointSize;
  }
  if (!settingsInited)   defaultSettings();
  resetMatrix();
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  blend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  camera();
  perspective();
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (fbStack == null) {
    fbStack=new Stack<PFramebuffer>();
    screenFramebuffer=new PFramebuffer(parent,width,height,true);
    setFramebuffer(screenFramebuffer);
  }
  if (clear && primarySurface) {
    gl.glClearColor(0,0,0,0);
    gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
  }
 else {
    if (fboSupported) {
      if (drawFramebuffer == null) {
        createDrawFramebuffer();
      }
      pushFramebuffer();
      setFramebuffer(drawFramebuffer);
      drawFramebuffer.addColorBuffer(drawTextures[drawIndex]);
      gl.glClearColor(0,0,0,0);
      if (clear) {
        gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
      }
 else {
        gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
      }
      renderDrawTexture((drawIndex + 1) % 2);
    }
 else {
      if (screenTexID[0] == 0) {
        createScreenTexture();
      }
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
      drawScreenTexture();
    }
  }
  report(""String_Node_Str"");
}","/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  VERTEXCOUNT=0;
  TRIANGLECOUNT=0;
  FACECOUNT=0;
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    OPENGL_VENDOR=a3d.OPENGL_VENDOR;
    OPENGL_RENDERER=a3d.OPENGL_RENDERER;
    OPENGL_VERSION=a3d.OPENGL_VERSION;
    npotTexSupported=a3d.npotTexSupported;
    mipmapSupported=a3d.mipmapSupported;
    matrixGetSupported=a3d.matrixGetSupported;
    vboSupported=a3d.vboSupported;
    fboSupported=a3d.fboSupported;
    maxTextureSize=a3d.maxTextureSize;
    maxPointSize=a3d.maxPointSize;
  }
  if (!settingsInited) {
    defaultSettings();
  }
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  blend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  camera();
  perspective();
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (fbStack == null) {
    fbStack=new Stack<PFramebuffer>();
    screenFramebuffer=new PFramebuffer(parent,width,height,true);
    setFramebuffer(screenFramebuffer);
  }
  if (clear && primarySurface) {
    gl.glClearColor(0,0,0,0);
    gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
  }
 else {
    if (fboSupported) {
      if (drawFramebuffer == null) {
        createDrawFramebuffer();
      }
      pushFramebuffer();
      setFramebuffer(drawFramebuffer);
      drawFramebuffer.addColorBuffer(drawTextures[drawIndex]);
      gl.glClearColor(0,0,0,0);
      if (clear) {
        gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
      }
 else {
        gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
      }
      renderDrawTexture((drawIndex + 1) % 2);
    }
 else {
      if (screenTexID[0] == 0) {
        createScreenTexture();
      }
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
      drawScreenTexture();
    }
  }
  report(""String_Node_Str"");
}",0.9876119687440442
163771,"public void endDraw(){
  if (!clear || !primarySurface) {
    if (fboSupported) {
      if (drawFramebuffer != null) {
        popFramebuffer();
        if (primarySurface) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          renderDrawTexture(drawIndex);
        }
        swapDrawIndex();
      }
    }
 else {
      if (screenTexID[0] != 0) {
        copyFrameToScreenTexture();
      }
    }
  }
  gl.glFlush();
  if (!primarySurface) {
    ((PGraphicsAndroid3D)parent.g).restoreGLState();
  }
  report(""String_Node_Str"");
}","public void endDraw(){
  if (!clear || !primarySurface) {
    if (fboSupported) {
      if (drawFramebuffer != null) {
        popFramebuffer();
        if (primarySurface) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          renderDrawTexture(drawIndex);
        }
        swapDrawIndex();
      }
    }
 else {
      if (screenTexID[0] != 0) {
        copyFrameToScreenTexture();
      }
    }
  }
  if (primarySurface) {
    gl.glFlush();
  }
 else {
    ((PGraphicsAndroid3D)parent.g).restoreGLState();
  }
  report(""String_Node_Str"");
}",0.95616211745244
163772,"public void mult(float[] m){
}","public void mult(float n0,float n4,float n8,float n12,float n1,float n5,float n9,float n13,float n2,float n6,float n10,float n14,float n3,float n7,float n11,float n15){
  float r0=current[0] * n0 + current[4] * n1 + current[8] * n2 + current[12] * n3;
  float r4=current[0] * n4 + current[4] * n5 + current[8] * n6 + current[12] * n7;
  float r8=current[0] * n8 + current[4] * n9 + current[8] * n10 + current[12] * n11;
  float r12=current[0] * n12 + current[4] * n13 + current[8] * n14 + current[12] * n15;
  float r1=current[1] * n0 + current[5] * n1 + current[9] * n2 + current[13] * n3;
  float r5=current[1] * n4 + current[5] * n5 + current[9] * n6 + current[13] * n7;
  float r9=current[1] * n8 + current[5] * n8 + current[9] * n10 + current[13] * n11;
  float r13=current[1] * n12 + current[5] * n13 + current[9] * n14 + current[13] * n15;
  float r2=current[2] * n0 + current[6] * n1 + current[10] * n2 + current[14] * n3;
  float r6=current[2] * n4 + current[6] * n5 + current[10] * n6 + current[14] * n7;
  float r10=current[2] * n8 + current[6] * n9 + current[10] * n10 + current[14] * n11;
  float r14=current[2] * n12 + current[6] * n13 + current[10] * n14 + current[14] * n15;
  float r3=current[3] * n0 + current[7] * n1 + current[11] * n2 + current[15] * n3;
  float r7=current[3] * n4 + current[7] * n5 + current[11] * n6 + current[15] * n7;
  float r11=current[3] * n8 + current[7] * n9 + current[11] * n10 + current[15] * n11;
  float r15=current[3] * n12 + current[7] * n13 + current[11] * n14 + current[15] * n15;
  current[0]=r0;
  current[4]=r4;
  current[8]=r8;
  current[12]=r12;
  current[1]=r1;
  current[5]=r5;
  current[9]=r9;
  current[13]=r13;
  current[2]=r2;
  current[6]=r6;
  current[10]=r10;
  current[14]=r14;
  current[3]=r3;
  current[7]=r7;
  current[11]=r11;
  current[15]=r15;
}",0.0281081081081081
163773,"public A3DMatrixStack(){
}","public A3DMatrixStack(){
  matrixStack=new Stack<float[]>();
  current=new float[16];
  set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
}",0.3398692810457516
163774,"public void push(){
}","public void push(){
  float[] mat=new float[16];
  PApplet.arrayCopy(current,mat);
  matrixStack.push(mat);
}",0.3230769230769231
163775,"public void pop(){
}","public void pop(){
  try {
    float[] mat=matrixStack.pop();
    PApplet.arrayCopy(mat,current);
  }
 catch (  EmptyStackException e) {
    PGraphics.showWarning(""String_Node_Str"");
  }
}",0.1923076923076923
163776,"public void get(float[] m){
}","public void get(float[] mat){
  PApplet.arrayCopy(current,mat);
}",0.6170212765957447
163777,"public void set(float[] m){
}","public void set(float n0,float n4,float n8,float n12,float n1,float n5,float n9,float n13,float n2,float n6,float n10,float n14,float n3,float n7,float n11,float n15){
  current[0]=n0;
  current[4]=n4;
  current[8]=n8;
  current[12]=n12;
  current[1]=n1;
  current[5]=n5;
  current[9]=n9;
  current[13]=n13;
  current[2]=n2;
  current[6]=n6;
  current[10]=n10;
  current[14]=n14;
  current[3]=n3;
  current[7]=n7;
  current[11]=n11;
  current[15]=n15;
}",0.1037344398340249
163778,"public void rotate(float a,float rx,float ry,float rz){
}","public void rotate(float angle,float rx,float ry,float rz){
  float c=PApplet.cos(angle);
  float s=PApplet.sin(angle);
  float t=1.0f - c;
  mult((t * rx * rx) + c,(t * rx * ry) - (s * rz),(t * rx * rz) + (s * ry),0,(t * rx * ry) + (s * rz),(t * ry * ry) + c,(t * ry * rz) - (s * rx),0,(t * rx * rz) - (s * ry),(t * ry * rz) + (s * rx),(t * rz * rz) + c,0,0,0,0,1);
}",0.268235294117647
163779,"public void translate(float tx,float ty,float tz){
}","public void translate(float tx,float ty,float tz){
  current[12]+=tx * current[0] + ty * current[4] + tz * current[8];
  current[13]+=tx * current[1] + ty * current[5] + tz * current[9];
  current[14]+=tx * current[2] + ty * current[6] + tz * current[10];
  current[15]+=tx * current[3] + ty * current[7] + tz * current[11];
}",0.2751322751322751
163780,"public void scale(float sx,float sy,float sz){
}","public void scale(float sx,float sy,float sz){
  current[0]*=sx;
  current[4]*=sy;
  current[8]*=sz;
  current[1]*=sx;
  current[5]*=sy;
  current[9]*=sz;
  current[2]*=sx;
  current[6]*=sy;
  current[10]*=sz;
  current[3]*=sx;
  current[7]*=sy;
  current[11]*=sz;
}",0.3057324840764331
163781,"protected void defaultSettings(){
  super.defaultSettings();
  manipulatingCamera=false;
  scalingDuringCamManip=false;
  if (usingModelviewStack) {
    modelviewStack=new A3DMatrixStack();
  }
  textureMode(IMAGE);
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    try {
      Method meth=this.getClass().getMethod(""String_Node_Str"",new Class[]{PGraphicsAndroid3D.class});
      recreateResourceIdx=a3d.addRecreateResourceMethod(this,meth);
    }
 catch (    Exception e) {
      recreateResourceIdx=-1;
    }
  }
}","protected void defaultSettings(){
  super.defaultSettings();
  manipulatingCamera=false;
  scalingDuringCamManip=false;
  clearColorBuffer=false;
  if (fbStack == null) {
    fbStack=new Stack<PFramebuffer>();
    screenFramebuffer=new PFramebuffer(parent,width,height,true);
    setFramebuffer(screenFramebuffer);
  }
  if (usingModelviewStack && modelviewStack == null) {
    modelviewStack=new A3DMatrixStack();
  }
  textureMode(IMAGE);
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    try {
      Method meth=this.getClass().getMethod(""String_Node_Str"",new Class[]{PGraphicsAndroid3D.class});
      recreateResourceIdx=a3d.addRecreateResourceMethod(this,meth);
    }
 catch (    Exception e) {
      recreateResourceIdx=-1;
    }
  }
}",0.8306997742663657
163782,"protected void backgroundImpl(){
  gl.glClearColor(backgroundR,backgroundG,backgroundB,1);
  gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
}","protected void backgroundImpl(){
  gl.glClearColor(backgroundR,backgroundG,backgroundB,1);
  gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
  if (0 < parent.frameCount) {
    clearColorBuffer=true;
  }
}",0.8368421052631579
163783,"/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  VERTEXCOUNT=0;
  TRIANGLECOUNT=0;
  FACECOUNT=0;
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
    if (a3d.lights) {
      noLights();
    }
  }
  if (!settingsInited) {
    defaultSettings();
  }
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  blend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  perspective();
  camera();
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (fbStack == null) {
    fbStack=new Stack<PFramebuffer>();
    screenFramebuffer=new PFramebuffer(parent,width,height,true);
    setFramebuffer(screenFramebuffer);
  }
  if (clear && primarySurface) {
    gl.glClearColor(0,0,0,0);
    gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
  }
 else {
    if (fboSupported) {
      if (drawFramebuffer == null) {
        createDrawFramebuffer();
      }
      pushFramebuffer();
      setFramebuffer(drawFramebuffer);
      drawFramebuffer.addColorBuffer(drawTextures[drawIndex]);
      gl.glClearColor(0,0,0,0);
      if (clear) {
        gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
      }
 else {
        gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
        renderDrawTexture((drawIndex + 1) % 2);
      }
    }
 else {
      if (gl11 == null || gl11x == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      if (screenTexID[0] == 0) {
        createScreenTexture();
      }
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
      drawScreenTexture();
    }
  }
  report(""String_Node_Str"");
}","/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  VERTEXCOUNT=0;
  TRIANGLECOUNT=0;
  FACECOUNT=0;
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
    if (a3d.lights) {
      noLights();
    }
  }
  if (!settingsInited) {
    defaultSettings();
  }
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  blend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  perspective();
  camera();
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (primarySurface) {
    if (parent.frameCount == 0) {
      if (fboSupported) {
        if (drawFramebuffer == null) {
          createDrawFramebuffer();
        }
      }
 else {
        if (gl11 == null || gl11x == null) {
          throw new RuntimeException(""String_Node_Str"");
        }
        if (screenTexID[0] == 0) {
          createScreenTexture();
        }
      }
    }
    if (clearColorBuffer) {
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      if (fboSupported) {
        if (drawFramebuffer != null) {
          pushFramebuffer();
          setFramebuffer(drawFramebuffer);
          drawFramebuffer.setColorBuffer(drawTextures[drawIndex]);
          gl.glClearColor(0,0,0,0);
          if (parent.frameCount == 0) {
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          }
 else {
            gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
            renderDrawTexture((drawIndex + 1) % 2);
          }
        }
      }
 else {
        if (screenTexID[0] != 0) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          if (0 < parent.frameCount) {
            drawScreenTexture();
          }
        }
      }
    }
  }
 else {
    if (!fboSupported) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (drawFramebuffer == null) {
      createDrawFramebuffer();
    }
    pushFramebuffer();
    setFramebuffer(drawFramebuffer);
    drawFramebuffer.setColorBuffer(drawTextures[drawIndex]);
    gl.glClearColor(0,0,0,0);
    if (clearColorBuffer || parent.frameCount == 0) {
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
      renderDrawTexture((drawIndex + 1) % 2);
    }
  }
  clearColorBuffer0=clearColorBuffer;
  report(""String_Node_Str"");
}",0.61060988812703
163784,"public void endDraw(){
  if (!clear || !primarySurface) {
    if (fboSupported) {
      if (drawFramebuffer != null) {
        popFramebuffer();
        if (primarySurface) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          renderDrawTexture(drawIndex);
        }
        swapDrawIndex();
      }
    }
 else {
      if (screenTexID[0] != 0) {
        copyFrameToScreenTexture();
      }
    }
  }
  if (primarySurface) {
    gl.glFlush();
  }
 else {
    ((PGraphicsAndroid3D)parent.g).restoreGLState();
  }
  report(""String_Node_Str"");
}","public void endDraw(){
  if (primarySurface) {
    if (!clearColorBuffer0) {
      if (fboSupported) {
        if (drawFramebuffer != null) {
          popFramebuffer();
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          renderDrawTexture(drawIndex);
          swapDrawIndex();
        }
      }
 else {
        if (screenTexID[0] != 0) {
          copyFrameToScreenTexture();
        }
      }
    }
  }
 else {
    if (drawFramebuffer != null) {
      popFramebuffer();
      swapDrawIndex();
    }
  }
  if (primarySurface) {
    gl.glFlush();
  }
 else {
    ((PGraphicsAndroid3D)parent.g).restoreGLState();
  }
  report(""String_Node_Str"");
}",0.7701582516955539
163785,"/** 
 * Copy texture to pixels. Involves video memory to main memory transfer (slow).
 */
public void get(int[] pixels){
  if ((pixels == null) || (pixels.length != width * height)) {
    pixels=new int[width * height];
  }
  int size=glWidth * glHeight;
  int[] tmp=new int[size];
  IntBuffer pixelBuffer=BufferUtil.newIntBuffer(size);
  PFramebuffer fbo=new PFramebuffer(parent,glWidth,glHeight);
  fbo.addColorBuffer(this);
  a3d.pushFramebuffer();
  a3d.setFramebuffer(fbo);
  gl.glReadPixels(0,0,glWidth,glHeight,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,pixelBuffer);
  a3d.popFramebuffer();
  pixelBuffer.get(tmp);
  pixelBuffer.rewind();
  convertToARGB(tmp,pixels);
  if (flippedX)   flipArrayOnX(pixels,1);
  if (flippedY)   flipArrayOnY(pixels,1);
}","/** 
 * Copy texture to pixels. Involves video memory to main memory transfer (slow).
 */
public void get(int[] pixels){
  if ((pixels == null) || (pixels.length != width * height)) {
    pixels=new int[width * height];
  }
  int size=glWidth * glHeight;
  int[] tmp=new int[size];
  IntBuffer pixelBuffer=BufferUtil.newIntBuffer(size);
  PFramebuffer fbo=new PFramebuffer(parent,glWidth,glHeight);
  fbo.setColorBuffer(this);
  a3d.pushFramebuffer();
  a3d.setFramebuffer(fbo);
  gl.glReadPixels(0,0,glWidth,glHeight,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,pixelBuffer);
  a3d.popFramebuffer();
  pixelBuffer.get(tmp);
  pixelBuffer.rewind();
  convertToARGB(tmp,pixels);
  if (flippedX)   flipArrayOnX(pixels,1);
  if (flippedY)   flipArrayOnY(pixels,1);
}",0.99601593625498
163786,"protected void addToTexture(GL10 gl){
  if (offsetX + width > texWidth) {
    offsetX=0;
    offsetY+=lineHeight;
    lineHeight=0;
  }
  lineHeight=Math.max(lineHeight,height);
  if (offsetY + lineHeight > texHeight) {
    addTexture(gl);
    offsetX=0;
    offsetY=0;
    lineHeight=0;
  }
  int[] rgba=new int[width * height];
  int t=0;
  int p=0;
  if (PGraphicsAndroid3D.BIG_ENDIAN) {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=255 << 24 | 255 << 16 | 0 << 8 | 0;
      }
    }
  }
 else {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=255 << 24 | 0 << 16 | 0 << 8 | 0;
      }
    }
  }
  gl.glTexSubImage2D(GL10.GL_TEXTURE_2D,0,offsetX,offsetY,width,height,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,IntBuffer.wrap(rgba));
  texture=new TextureInfo(currentID,offsetX,offsetY,width,height);
  offsetX+=width;
}","protected void addToTexture(GL10 gl){
  if (offsetX + width > texWidth) {
    offsetX=0;
    offsetY+=lineHeight;
    lineHeight=0;
  }
  lineHeight=Math.max(lineHeight,height);
  if (offsetY + lineHeight > texHeight) {
    addTexture(gl);
    offsetX=0;
    offsetY=0;
    lineHeight=0;
  }
  int[] rgba=new int[width * height];
  int t=0;
  int p=0;
  if (PGraphicsAndroid3D.BIG_ENDIAN) {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=0xFFFFFF00 | image.pixels[p++];
      }
    }
  }
 else {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=(image.pixels[p++] << 24) | 0x00FFFFFF;
      }
    }
  }
  gl.glTexSubImage2D(GL10.GL_TEXTURE_2D,0,offsetX,offsetY,width,height,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,IntBuffer.wrap(rgba));
  texture=new TextureInfo(currentID,offsetX,offsetY,width,height);
  offsetX+=width;
}",0.802646085997795
163787,"protected void textCharModelImpl(Glyph.TextureInfo tex,float x1,float y1,float x2,float y2,int u2,int v2){
  if (textFontTexID != textFont.currentID) {
    textFontTexID=textFont.currentID;
    gl.glBindTexture(GL10.GL_TEXTURE_2D,textFontTexID);
  }
  ((GL11)gl).glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,tex.crop,0);
  ((GL11Ext)gl).glDrawTexiOES((int)x1,height - (int)y1,0,(int)(x2 - x1),(int)(y2 - y1));
}","protected void textCharModelImpl(Glyph.TextureInfo tex,float x1,float y1,float x2,float y2,int u2,int v2){
  if (textFontTexID != tex.glid) {
    textFontTexID=tex.glid;
    gl.glBindTexture(GL10.GL_TEXTURE_2D,textFontTexID);
  }
  ((GL11)gl).glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,tex.crop,0);
  ((GL11Ext)gl).glDrawTexiOES((int)x1,height - (int)y1,0,(int)(x2 - x1),(int)(y2 - y1));
}",0.92
163788,"/** 
 * Implementation of actual drawing for a line of text.
 */
protected void textLineImpl(char buffer[],int start,int stop,float x,float y){
  if (textFont.mTextureID == -1) {
    textFont.initialize(gl,maxTextureSize,maxTextureSize);
    textFont.addToTexture(gl);
  }
  textFontTexID=textFont.currentID;
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textFontTexID);
  gl.glEnable(GL10.GL_TEXTURE_2D);
  gl.glShadeModel(GL10.GL_FLAT);
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  gl.glOrthof(0.0f,width,0.0f,height,0.0f,1.0f);
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  super.textLineImpl(buffer,start,stop,x,y);
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glPopMatrix();
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glPopMatrix();
}","/** 
 * Implementation of actual drawing for a line of text.
 */
protected void textLineImpl(char buffer[],int start,int stop,float x,float y){
  if (textFont.mTextureID == -1) {
    textFont.initialize(gl,maxTextureSize,maxTextureSize);
    textFont.addToTexture(gl);
  }
  textFontTexID=textFont.currentID;
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textFontTexID);
  gl.glEnable(GL10.GL_TEXTURE_2D);
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  gl.glOrthof(0.0f,width,0.0f,height,0.0f,1.0f);
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  super.textLineImpl(buffer,start,stop,x,y);
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glPopMatrix();
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glPopMatrix();
}",0.9791535060012634
163789,"protected void textCharScreenImpl(Glyph.TextureInfo tex,int xx,int yy,int w0,int h0){
  if (textFontTexID != textFont.currentID) {
    textFontTexID=textFont.currentID;
    gl.glBindTexture(GL10.GL_TEXTURE_2D,textFontTexID);
  }
  ((GL11)gl).glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,tex.crop,0);
  ((GL11Ext)gl).glDrawTexiOES((int)xx,(int)yy,0,(int)w0,(int)h0);
}","protected void textCharScreenImpl(Glyph.TextureInfo tex,int xx,int yy,int w0,int h0){
  if (textFontTexID != tex.glid) {
    textFontTexID=tex.glid;
    gl.glBindTexture(GL10.GL_TEXTURE_2D,textFontTexID);
  }
  ((GL11)gl).glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,tex.crop,0);
  ((GL11Ext)gl).glDrawTexiOES((int)xx,(int)yy,0,(int)w0,(int)h0);
}",0.9186351706036744
163790,"public void render(int gr0,int gr1){
  int texTarget=GL11.GL_TEXTURE_2D;
  GLTexture tex;
  float pointSize;
  gl.glLineWidth(a3d.strokeWeight);
  pointSize=PApplet.min(a3d.strokeWeight,a3d.maxPointSize);
  gl.glPointSize(pointSize);
  gl.glEnableClientState(GL11.GL_NORMAL_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glNormalBufferID[0]);
  gl.glNormalPointer(GL11.GL_FLOAT,0,0);
  gl.glEnableClientState(GL11.GL_COLOR_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glColorBufferID[0]);
  gl.glColorPointer(4,GL11.GL_FLOAT,0,0);
  gl.glEnableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glVertexBufferID[0]);
  gl.glVertexPointer(3,GL11.GL_FLOAT,0,0);
  VertexGroup group;
  for (int i=gr0; i <= gr1; i++) {
    group=(VertexGroup)groups.get(i);
    tex=group.texture;
    if (tex != null) {
      texTarget=group.texture.getGLTarget();
      gl.glEnable(texTarget);
      gl.glActiveTexture(GL11.GL_TEXTURE0);
      gl.glBindTexture(GL11.GL_TEXTURE_2D,group.texture.getGLTextureID());
      if (pointSprites) {
        float quadratic[]={1.0f,0.0f,0.01f,1};
        ByteBuffer temp=ByteBuffer.allocateDirect(16);
        temp.order(ByteOrder.nativeOrder());
        gl.glPointParameterfv(GL11.GL_POINT_DISTANCE_ATTENUATION,(FloatBuffer)temp.asFloatBuffer().put(quadratic).flip());
        gl.glPointParameterf(GL11.GL_POINT_FADE_THRESHOLD_SIZE,0.6f * pointSize);
        gl.glPointParameterf(GL11.GL_POINT_SIZE_MIN,1.0f);
        gl.glPointParameterf(GL11.GL_POINT_SIZE_MAX,a3d.maxPointSize);
        gl.glTexEnvf(GL11.GL_POINT_SPRITE_OES,GL11.GL_COORD_REPLACE_OES,GL11.GL_TRUE);
        gl.glEnable(GL11.GL_POINT_SPRITE_OES);
      }
 else {
        gl.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
        gl.glClientActiveTexture(GL11.GL_TEXTURE0);
        gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glTexCoordBufferID[0]);
        gl.glTexCoordPointer(2,GL11.GL_FLOAT,0,0);
      }
    }
    gl.glPushMatrix();
    gl.glScalef(1,-1,1);
    gl.glDrawArrays(glMode,group.first,group.last - group.first + 1);
    gl.glPopMatrix();
    if (tex != null) {
      if (pointSprites) {
        gl.glDisable(GL11.GL_POINT_SPRITE_OES);
      }
 else {
        gl.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
      }
      gl.glDisable(texTarget);
    }
  }
  gl.glDisableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL11.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL11.GL_NORMAL_ARRAY);
}","public void render(int gr0,int gr1){
  int texTarget=GL11.GL_TEXTURE_2D;
  GLTexture tex;
  float pointSize;
  gl.glLineWidth(a3d.strokeWeight);
  pointSize=PApplet.min(a3d.strokeWeight,a3d.maxPointSize);
  gl.glPointSize(pointSize);
  gl.glEnableClientState(GL11.GL_NORMAL_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glNormalBufferID[0]);
  gl.glNormalPointer(GL11.GL_FLOAT,0,0);
  gl.glDisableClientState(GL11.GL_NORMAL_ARRAY);
  System.out.println(""String_Node_Str"");
}",0.297594501718213
163791,"protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  GLTexture tex=null;
  boolean texturing=false;
  vertexBuffer.position(0);
  colorBuffer.position(0);
  normalBuffer.position(0);
  textureBuffer.position(0);
  gl.glPushMatrix();
  gl.glScalef(1,-1,1);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=0; j < faceCount; j++) {
    int i=faceOffset[j];
    if (faceTexture[j] != null) {
      tex=faceTexture[j].getTexture();
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
        gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
        texturing=true;
      }
 else {
        texturing=false;
      }
    }
 else {
      texturing=false;
    }
    if (vertexBuffer.capacity() == 3 * faceLength[j]) {
      expandBuffers();
    }
    vertexBuffer.rewind();
    colorBuffer.rewind();
    normalBuffer.rewind();
    textureBuffer.rewind();
    for (int k=0; k < faceLength[j]; k++) {
      float a[]=vertices[triangles[i][VERTEX1]];
      float b[]=vertices[triangles[i][VERTEX2]];
      float c[]=vertices[triangles[i][VERTEX3]];
      float uscale=1.0f;
      float vscale=1.0f;
      float cx=0.0f;
      float sx=+1.0f;
      float cy=0.0f;
      float sy=+1.0f;
      if (texturing) {
        uscale*=tex.getMaxTextureCoordS();
        vscale*=tex.getMaxTextureCoordT();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
      }
      vertexBuffer.put(toFixed32(a[X]));
      vertexBuffer.put(toFixed32(a[Y]));
      vertexBuffer.put(toFixed32(a[Z]));
      colorBuffer.put(toFixed32(a[R]));
      colorBuffer.put(toFixed32(a[G]));
      colorBuffer.put(toFixed32(a[B]));
      colorBuffer.put(toFixed32(a[A]));
      normalBuffer.put(toFixed32(a[NX]));
      normalBuffer.put(toFixed32(a[NY]));
      normalBuffer.put(toFixed32(a[NZ]));
      textureBuffer.put(toFixed32((cx + sx * a[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * a[V]) * vscale));
      vertexBuffer.put(toFixed32(b[X]));
      vertexBuffer.put(toFixed32(b[Y]));
      vertexBuffer.put(toFixed32(b[Z]));
      colorBuffer.put(toFixed32(b[R]));
      colorBuffer.put(toFixed32(b[G]));
      colorBuffer.put(toFixed32(b[B]));
      colorBuffer.put(toFixed32(b[A]));
      normalBuffer.put(toFixed32(b[NX]));
      normalBuffer.put(toFixed32(b[NY]));
      normalBuffer.put(toFixed32(b[NZ]));
      textureBuffer.put(toFixed32((cx + sx * b[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * b[V]) * vscale));
      vertexBuffer.put(toFixed32(c[X]));
      vertexBuffer.put(toFixed32(c[Y]));
      vertexBuffer.put(toFixed32(c[Z]));
      colorBuffer.put(toFixed32(c[R]));
      colorBuffer.put(toFixed32(c[G]));
      colorBuffer.put(toFixed32(c[B]));
      colorBuffer.put(toFixed32(c[A]));
      normalBuffer.put(toFixed32(c[NX]));
      normalBuffer.put(toFixed32(c[NY]));
      normalBuffer.put(toFixed32(c[NZ]));
      textureBuffer.put(toFixed32((cx + sx * c[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * c[V]) * vscale));
      i++;
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    textureBuffer.position(0);
    gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
    gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
    gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
    if (texturing)     gl.glTexCoordPointer(2,GL10.GL_FIXED,0,textureBuffer);
    gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    if (texturing) {
      gl.glDisable(tex.getGLTarget());
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glPopMatrix();
  report(""String_Node_Str"");
}","protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  GLTexture tex=null;
  boolean texturing=false;
  vertexBuffer.position(0);
  colorBuffer.position(0);
  normalBuffer.position(0);
  textureBuffer.position(0);
  gl.glPushMatrix();
  gl.glScalef(1,-1,1);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=0; j < faceCount; j++) {
    int i=faceOffset[j];
    if (faceTexture[j] != null) {
      tex=faceTexture[j].getTexture();
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
        gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
        texturing=true;
      }
 else {
        texturing=false;
      }
    }
 else {
      texturing=false;
    }
    System.out.println(""String_Node_Str"" + vertexBuffer.capacity() / 3 + ""String_Node_Str"" + 3 * faceLength[j]);
    if (vertexBuffer.capacity() / 3 < 3 * faceLength[j]) {
      expandBuffers();
    }
    vertexBuffer.rewind();
    colorBuffer.rewind();
    normalBuffer.rewind();
    textureBuffer.rewind();
    for (int k=0; k < faceLength[j]; k++) {
      float a[]=vertices[triangles[i][VERTEX1]];
      float b[]=vertices[triangles[i][VERTEX2]];
      float c[]=vertices[triangles[i][VERTEX3]];
      float uscale=1.0f;
      float vscale=1.0f;
      float cx=0.0f;
      float sx=+1.0f;
      float cy=0.0f;
      float sy=+1.0f;
      if (texturing) {
        uscale*=tex.getMaxTextureCoordS();
        vscale*=tex.getMaxTextureCoordT();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
      }
      vertexBuffer.put(toFixed32(a[X]));
      vertexBuffer.put(toFixed32(a[Y]));
      vertexBuffer.put(toFixed32(a[Z]));
      colorBuffer.put(toFixed32(a[R]));
      colorBuffer.put(toFixed32(a[G]));
      colorBuffer.put(toFixed32(a[B]));
      colorBuffer.put(toFixed32(a[A]));
      normalBuffer.put(toFixed32(a[NX]));
      normalBuffer.put(toFixed32(a[NY]));
      normalBuffer.put(toFixed32(a[NZ]));
      textureBuffer.put(toFixed32((cx + sx * a[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * a[V]) * vscale));
      vertexBuffer.put(toFixed32(b[X]));
      vertexBuffer.put(toFixed32(b[Y]));
      vertexBuffer.put(toFixed32(b[Z]));
      colorBuffer.put(toFixed32(b[R]));
      colorBuffer.put(toFixed32(b[G]));
      colorBuffer.put(toFixed32(b[B]));
      colorBuffer.put(toFixed32(b[A]));
      normalBuffer.put(toFixed32(b[NX]));
      normalBuffer.put(toFixed32(b[NY]));
      normalBuffer.put(toFixed32(b[NZ]));
      textureBuffer.put(toFixed32((cx + sx * b[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * b[V]) * vscale));
      vertexBuffer.put(toFixed32(c[X]));
      vertexBuffer.put(toFixed32(c[Y]));
      vertexBuffer.put(toFixed32(c[Z]));
      colorBuffer.put(toFixed32(c[R]));
      colorBuffer.put(toFixed32(c[G]));
      colorBuffer.put(toFixed32(c[B]));
      colorBuffer.put(toFixed32(c[A]));
      normalBuffer.put(toFixed32(c[NX]));
      normalBuffer.put(toFixed32(c[NY]));
      normalBuffer.put(toFixed32(c[NZ]));
      textureBuffer.put(toFixed32((cx + sx * c[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * c[V]) * vscale));
      i++;
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    textureBuffer.position(0);
    gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
    gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
    gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
    if (texturing)     gl.glTexCoordPointer(2,GL10.GL_FIXED,0,textureBuffer);
    gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    if (texturing) {
      gl.glDisable(tex.getGLTarget());
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glPopMatrix();
  report(""String_Node_Str"");
}",0.984390243902439
163792,"protected void renderPoints(int start,int stop){
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  if (vertexBuffer.capacity() == stop - start) {
    expandBuffers();
  }
  vertexBuffer.rewind();
  colorBuffer.rewind();
  float sw=vertices[lines[start][VERTEX1]][SW];
  if (sw > 0) {
    gl.glPointSize(sw);
    for (int i=start; i < stop; i++) {
      float[] a=vertices[points[i][VERTEX1]];
      colorBuffer.put(toFixed16(a[SR]));
      colorBuffer.put(toFixed16(a[SG]));
      colorBuffer.put(toFixed16(a[SB]));
      colorBuffer.put(toFixed16(a[SA]));
      vertexBuffer.put(toFixed32(a[VX]));
      vertexBuffer.put(toFixed32(a[VY]));
      vertexBuffer.put(toFixed32(a[VZ]));
    }
    gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
    gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
    gl.glDrawArrays(GL10.GL_POINTS,start,stop - start);
  }
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
}","protected void renderPoints(int start,int stop){
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  if (vertexBuffer.capacity() / 3 < 3 * (stop - start)) {
    expandBuffers();
  }
  vertexBuffer.rewind();
  colorBuffer.rewind();
  float sw=vertices[lines[start][VERTEX1]][SW];
  if (sw > 0) {
    gl.glPointSize(sw);
    for (int i=start; i < stop; i++) {
      float[] a=vertices[points[i][VERTEX1]];
      colorBuffer.put(toFixed16(a[SR]));
      colorBuffer.put(toFixed16(a[SG]));
      colorBuffer.put(toFixed16(a[SB]));
      colorBuffer.put(toFixed16(a[SA]));
      vertexBuffer.put(toFixed32(a[VX]));
      vertexBuffer.put(toFixed32(a[VY]));
      vertexBuffer.put(toFixed32(a[VZ]));
    }
    gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
    gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
    gl.glDrawArrays(GL10.GL_POINTS,start,stop - start);
  }
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
}",0.992563212692117
163793,"/** 
 * In the current implementation, start and stop are ignored (in OpenGL). This will obviously have to be revisited if/when proper depth sorting is implemented.
 */
protected void renderLines(int start,int stop){
  report(""String_Node_Str"");
  gl.glPushMatrix();
  gl.glScalef(1,-1,1);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  for (int j=0; j < pathCount; j++) {
    int i=pathOffset[j];
    float sw=vertices[lines[i][VERTEX1]][SW];
    if (sw > 0) {
      gl.glLineWidth(sw);
      if (vertexBuffer.capacity() == pathLength[j] + 1) {
        expandBuffers();
      }
      vertexBuffer.rewind();
      colorBuffer.rewind();
      float a[]=vertices[lines[i][VERTEX1]];
      colorBuffer.put(toFixed32(a[SR]));
      colorBuffer.put(toFixed32(a[SG]));
      colorBuffer.put(toFixed32(a[SB]));
      colorBuffer.put(toFixed32(a[SA]));
      vertexBuffer.put(toFixed32(a[X]));
      vertexBuffer.put(toFixed32(a[Y]));
      vertexBuffer.put(toFixed32(a[Z]));
      for (int k=0; k < pathLength[j]; k++) {
        float b[]=vertices[lines[i][VERTEX2]];
        colorBuffer.put(toFixed32(b[SR]));
        colorBuffer.put(toFixed32(b[SG]));
        colorBuffer.put(toFixed32(b[SB]));
        colorBuffer.put(toFixed32(b[SA]));
        vertexBuffer.put(toFixed32(b[X]));
        vertexBuffer.put(toFixed32(b[Y]));
        vertexBuffer.put(toFixed32(b[Z]));
        i++;
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
      gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
      gl.glDrawArrays(GL10.GL_LINE_STRIP,0,pathLength[j] + 1);
    }
  }
  gl.glPopMatrix();
  report(""String_Node_Str"");
}","/** 
 * In the current implementation, start and stop are ignored (in OpenGL). This will obviously have to be revisited if/when proper depth sorting is implemented.
 */
protected void renderLines(int start,int stop){
  report(""String_Node_Str"");
  gl.glPushMatrix();
  gl.glScalef(1,-1,1);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  for (int j=0; j < pathCount; j++) {
    int i=pathOffset[j];
    float sw=vertices[lines[i][VERTEX1]][SW];
    if (sw > 0) {
      gl.glLineWidth(sw);
      if (vertexBuffer.capacity() / 3 <= 3 * (pathLength[j] + 1)) {
        expandBuffers();
      }
      vertexBuffer.rewind();
      colorBuffer.rewind();
      float a[]=vertices[lines[i][VERTEX1]];
      colorBuffer.put(toFixed32(a[SR]));
      colorBuffer.put(toFixed32(a[SG]));
      colorBuffer.put(toFixed32(a[SB]));
      colorBuffer.put(toFixed32(a[SA]));
      vertexBuffer.put(toFixed32(a[X]));
      vertexBuffer.put(toFixed32(a[Y]));
      vertexBuffer.put(toFixed32(a[Z]));
      for (int k=0; k < pathLength[j]; k++) {
        float b[]=vertices[lines[i][VERTEX2]];
        colorBuffer.put(toFixed32(b[SR]));
        colorBuffer.put(toFixed32(b[SG]));
        colorBuffer.put(toFixed32(b[SB]));
        colorBuffer.put(toFixed32(b[SA]));
        vertexBuffer.put(toFixed32(b[X]));
        vertexBuffer.put(toFixed32(b[Y]));
        vertexBuffer.put(toFixed32(b[Z]));
        i++;
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
      gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
      gl.glDrawArrays(GL10.GL_LINE_STRIP,0,pathLength[j] + 1);
    }
  }
  gl.glPopMatrix();
  report(""String_Node_Str"");
}",0.9959723820483314
163794,"public void skewX(float angle){
  apply(1,0,1,angle,0,0);
}","public void skewX(float angle){
  apply(1,0,1,tan(angle),0,0);
}",0.959349593495935
163795,"public void skewY(float angle){
  apply(1,0,1,0,angle,0);
}","public void skewY(float angle){
  apply(1,0,1,0,tan(angle),0);
}",0.959349593495935
163796,"protected boolean isWarped(){
  return ((m00 != 1) || (m01 != 0) && (m10 != 0) || (m11 != 1));
}","protected boolean isWarped(){
  return ((m00 != 1) || (m01 != 0) || (m10 != 0)|| (m11 != 1));
}",0.9738219895287958
163797,"/** 
 * Preferred method of creating new PImage objects, ensures that a reference to the parent PApplet is included, which makes save() work without needing an absolute path.
 */
public PImage createImage(int wide,int high,int format){
  PImage image=new PImage(wide,high,format);
  image.parent=this;
  if (g instanceof PGraphicsAndroid3D) {
    image.format=ARGB;
    image.initTexture();
  }
  return image;
}","public PImage createImage(int wide,int high,GLTexture.Parameters params){
  PImage image=new PImage(wide,high,params.format);
  image.parent=this;
  if (g instanceof PGraphicsAndroid3D) {
    image.format=params.format;
    image.initTexture(params);
  }
  return image;
}",0.6403508771929824
163798,"protected void drawScreenTexture(){
  screenVertBuffer.position(0);
  screenTexCoordBuffer.position(0);
  gl.glColor4f(1.0f,1.0f,1.0f,1.0f);
  gl.glEnable(GL10.GL_TEXTURE_2D);
  gl.glBindTexture(GL10.GL_TEXTURE_2D,screenTexID[0]);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
  gl.glVertexPointer(3,GL10.GL_FIXED,0,screenVertBuffer);
  gl.glTexCoordPointer(2,GL10.GL_FIXED,0,screenTexCoordBuffer);
  gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * 2);
  gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
}","protected void drawScreenTexture(){
  beginShape(QUADS);
  texture(screenTex);
  vertex(0,0,0,screenTex.height);
  vertex(width,0,screenTex.width,screenTex.height);
  vertex(width,height,screenTex.width,0);
  vertex(0,height,0,0);
  endShape();
}",0.1030444964871194
163799,"protected void allocate(){
  if (!matricesAllocated) {
    projection=new float[16];
    modelview=new float[16];
    modelviewInv=new float[16];
    camera=new float[16];
    cameraInv=new float[16];
    matricesAllocated=true;
  }
  if (!lightsAllocated) {
    lightType=new int[MAX_LIGHTS];
    lightPosition=new float[MAX_LIGHTS][4];
    lightNormal=new float[MAX_LIGHTS][4];
    lightDiffuse=new float[MAX_LIGHTS][4];
    lightSpecular=new float[MAX_LIGHTS][4];
    lightFalloffConstant=new float[MAX_LIGHTS];
    lightFalloffLinear=new float[MAX_LIGHTS];
    lightFalloffQuadratic=new float[MAX_LIGHTS];
    lightSpotAngle=new float[MAX_LIGHTS];
    lightSpotAngleCos=new float[MAX_LIGHTS];
    lightSpotConcentration=new float[MAX_LIGHTS];
    currentLightSpecular=new float[4];
    lightsAllocated=true;
  }
  if (!buffersAllocated) {
    ByteBuffer vbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    vertexBuffer=vbb.asIntBuffer();
    ByteBuffer cbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 4 * SIZEOF_INT);
    cbb.order(ByteOrder.nativeOrder());
    colorBuffer=cbb.asIntBuffer();
    ByteBuffer tbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    texCoordBuffer=tbb.asIntBuffer();
    ByteBuffer nbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    nbb.order(ByteOrder.nativeOrder());
    normalBuffer=nbb.asIntBuffer();
    buffersAllocated=true;
  }
  if (!screenTexAllocated) {
    screenNVertices=6;
    ByteBuffer vbb=ByteBuffer.allocateDirect(screenNVertices * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    screenVertBuffer=vbb.asIntBuffer();
    ByteBuffer tbb=ByteBuffer.allocateDirect(screenNVertices * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    screenTexCoordBuffer=tbb.asIntBuffer();
    screenTexAllocated=true;
  }
}","protected void allocate(){
  if (!matricesAllocated) {
    projection=new float[16];
    modelview=new float[16];
    modelviewInv=new float[16];
    camera=new float[16];
    cameraInv=new float[16];
    matricesAllocated=true;
  }
  if (!lightsAllocated) {
    lightType=new int[MAX_LIGHTS];
    lightPosition=new float[MAX_LIGHTS][4];
    lightNormal=new float[MAX_LIGHTS][4];
    lightDiffuse=new float[MAX_LIGHTS][4];
    lightSpecular=new float[MAX_LIGHTS][4];
    lightFalloffConstant=new float[MAX_LIGHTS];
    lightFalloffLinear=new float[MAX_LIGHTS];
    lightFalloffQuadratic=new float[MAX_LIGHTS];
    lightSpotAngle=new float[MAX_LIGHTS];
    lightSpotAngleCos=new float[MAX_LIGHTS];
    lightSpotConcentration=new float[MAX_LIGHTS];
    currentLightSpecular=new float[4];
    lightsAllocated=true;
  }
  if (!buffersAllocated) {
    ByteBuffer vbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    vertexBuffer=vbb.asIntBuffer();
    ByteBuffer cbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 4 * SIZEOF_INT);
    cbb.order(ByteOrder.nativeOrder());
    colorBuffer=cbb.asIntBuffer();
    ByteBuffer tbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    texCoordBuffer=tbb.asIntBuffer();
    ByteBuffer nbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    nbb.order(ByteOrder.nativeOrder());
    normalBuffer=nbb.asIntBuffer();
    buffersAllocated=true;
  }
}",0.8811392037198489
163800,"/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  if (!settingsInited)   defaultSettings();
  resetMatrix();
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  gl.glEnable(GL10.GL_BLEND);
  gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  camera();
  perspective();
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (screenTexID[0] == 0) {
    createScreenTexture();
  }
  tint(255);
  beginShape(QUADS);
  texture(screenTex);
  vertex(0,0,0,screenTex.height);
  vertex(width,0,screenTex.width,screenTex.height);
  vertex(width,height,screenTex.width,0);
  vertex(0,height,0,0);
  endShape();
  report(""String_Node_Str"");
}","/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  if (!settingsInited)   defaultSettings();
  resetMatrix();
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  gl.glEnable(GL10.GL_BLEND);
  gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  camera();
  perspective();
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (clear) {
    gl.glClearColor(0,0,0,0);
    gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
  }
 else {
    if (screenTex == null || screenTex.width != width || screenTex.height != height) {
      createScreenTexture();
    }
    drawScreenTexture();
  }
  report(""String_Node_Str"");
}",0.8295769078687228
163801,"public void endDraw(){
  copyFrameToScreenTexture();
  gl.glFlush();
  report(""String_Node_Str"");
}","public void endDraw(){
  if (!clear && screenTex != null) {
    copyFrameToScreenTexture();
  }
  gl.glFlush();
  report(""String_Node_Str"");
}",0.8215767634854771
163802,"public void setSize(int iwidth,int iheight){
  width=iwidth;
  height=iheight;
  width1=width - 1;
  height1=height - 1;
  allocate();
  reapplySettings();
  deleteScreenTexture();
  vertexCheck();
  cameraFOV=60 * DEG_TO_RAD;
  cameraX=width / 2.0f;
  cameraY=height / 2.0f;
  cameraZ=cameraY / ((float)Math.tan(cameraFOV / 2.0f));
  cameraNear=cameraZ / 10.0f;
  cameraFar=cameraZ * 10.0f;
  cameraAspect=(float)width / (float)height;
}","public void setSize(int iwidth,int iheight){
  width=iwidth;
  height=iheight;
  width1=width - 1;
  height1=height - 1;
  allocate();
  reapplySettings();
  vertexCheck();
  cameraFOV=60 * DEG_TO_RAD;
  cameraX=width / 2.0f;
  cameraY=height / 2.0f;
  cameraZ=cameraY / ((float)Math.tan(cameraFOV / 2.0f));
  cameraNear=cameraZ / 10.0f;
  cameraFar=cameraZ * 10.0f;
  cameraAspect=(float)width / (float)height;
}",0.9706227967097532
163803,"protected void createScreenTexture(){
  int[] pix=new int[width * height];
  for (int i=0; i < width * height; i++)   pix[i]=0xFF000000;
  gl.glGenTextures(1,screenTexID,0);
  gl.glBindTexture(GL10.GL_TEXTURE_2D,screenTexID[0]);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_MIN_FILTER,GL10.GL_LINEAR);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_MAG_FILTER,GL10.GL_LINEAR);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_WRAP_S,GL10.GL_CLAMP_TO_EDGE);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_WRAP_T,GL10.GL_CLAMP_TO_EDGE);
  gl.glTexImage2D(GL10.GL_TEXTURE_2D,0,GL10.GL_RGBA,width,height,0,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,IntBuffer.wrap(pix));
  gl.glBindTexture(GL10.GL_TEXTURE_2D,0);
  int fw=toFixed32(width);
  int fh=toFixed32(height);
  int one=toFixed32(1.0f);
  int[] quadCoords={0,fh,0,0,0,0,fw,0,0,0,fh,0,fw,0,0,fw,fh,0};
  int[] quadTexCoords={0,one,0,0,one,0,0,one,one,0,one,one};
  screenVertBuffer.position(0);
  screenTexCoordBuffer.position(0);
  screenVertBuffer.put(quadCoords);
  screenTexCoordBuffer.put(quadTexCoords);
  screenTex=parent.createImage(width,height,ARGB);
  screenTex.getTexture().set(pix);
}","protected void createScreenTexture(){
  int[] pix=new int[width * height];
  for (int i=0; i < width * height; i++)   pix[i]=0xFF0000;
  screenTex=parent.createImage(width,height,ARGB,GLConstants.NEAREST);
  screenTex.getTexture().set(pix);
}",0.3126760563380282
163804,"public void initTexture(){
  texture=new GLTexture(parent,width,height,new GLTexture.Parameters(format));
  updateTexture();
}","public void initTexture(GLTexture.Parameters params){
  texture=new GLTexture(parent,width,height,params);
  updateTexture();
}",0.782608695652174
163805,"public AndroidSDK(final String sdkPath) throws BadSDKException, IOException {
  sdk=new File(sdkPath);
  if (!sdk.exists()) {
    throw new BadSDKException(sdk + ""String_Node_Str"");
  }
  tools=new File(sdk,""String_Node_Str"");
  if (!tools.exists()) {
    throw new BadSDKException(""String_Node_Str"" + sdk);
  }
  androidTool=findAndroidTool(tools);
  final Platform p=Base.getPlatform();
  p.setenv(""String_Node_Str"",sdk.getCanonicalPath());
  p.setenv(""String_Node_Str"",tools.getCanonicalPath() + File.pathSeparator + p.getenv(""String_Node_Str""));
}","public AndroidSDK(final String sdkPath) throws BadSDKException, IOException {
  sdk=new File(sdkPath);
  if (!sdk.exists()) {
    throw new BadSDKException(sdk + ""String_Node_Str"");
  }
  tools=new File(sdk,""String_Node_Str"");
  if (!tools.exists()) {
    throw new BadSDKException(""String_Node_Str"" + sdk);
  }
  androidTool=findAndroidTool(tools);
  final Platform p=Base.getPlatform();
  String path=p.getenv(""String_Node_Str"");
  p.setenv(""String_Node_Str"",sdk.getCanonicalPath());
  path=tools.getCanonicalPath() + File.pathSeparator + path;
  final String javaHomeProp=System.getProperty(""String_Node_Str"");
  if (javaHomeProp == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  final File javaHome=new File(javaHomeProp).getCanonicalFile();
  p.setenv(""String_Node_Str"",javaHome.getCanonicalPath());
  path=new File(javaHome,""String_Node_Str"").getCanonicalPath() + File.pathSeparator + path;
  p.setenv(""String_Node_Str"",path);
}",0.7105788423153693
163806,"public void requestDraw(){
  ((GLSurfaceView)parent.surfaceView).requestRender();
}","public void requestDraw(){
  if (parent.looping) {
    ((GLSurfaceView)parent.surfaceView).requestRender();
  }
}",0.8469387755102041
163807,"public void pointLight(float r,float g,float b,float x,float y,float z){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=POINT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  lightCount++;
}","public void pointLight(float r,float g,float b,float x,float y,float z){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=POINT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}",0.9859665006790402
163808,"public void spotLight(float r,float g,float b,float x,float y,float z,float nx,float ny,float nz,float angle,float concentration){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=SPOT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=0.0f;
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  lightSpotAngle[lightCount]=angle;
  lightSpotAngleCos[lightCount]=Math.max(0,(float)Math.cos(angle));
  lightSpotConcentration[lightCount]=concentration;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightSpotAngle(lightCount);
  glLightSpotConcentration(lightCount);
  lightCount++;
}","public void spotLight(float r,float g,float b,float x,float y,float z,float nx,float ny,float nz,float angle,float concentration){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=SPOT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  lightSpotAngle[lightCount]=PApplet.degrees(angle);
  lightSpotAngleCos[lightCount]=Math.max(0,(float)Math.cos(angle));
  lightSpotConcentration[lightCount]=concentration;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightSpotAngle(lightCount);
  glLightSpotConcentration(lightCount);
  lightCount++;
}",0.8546744831842024
163809,"public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][2]=currentLightSpecular[3];
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  lightCount++;
}","public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][2]=currentLightSpecular[3];
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}",0.9883299798792756
163810,"/** 
 * Add an ambient light based on the current color mode. This version includes an (x, y, z) position for situations where the falloff distance is used.
 */
public void ambientLight(float r,float g,float b,float x,float y,float z){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=AMBIENT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightAmbient(lightCount);
  glLightPosition(lightCount);
  glLightFalloff(lightCount);
  lightCount++;
}","/** 
 * Add an ambient light based on the current color mode. This version includes an (x, y, z) position for situations where the falloff distance is used.
 */
public void ambientLight(float r,float g,float b,float x,float y,float z){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=AMBIENT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  glLightEnable(lightCount);
  glLightAmbient(lightCount);
  glLightPosition(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}",0.9850746268656716
163811,"/** 
 * Link to an external page without all the muss. <P> When run with an applet, uses the browser to open the url, for applications, attempts to launch a browser with the url. <P> Works on Mac OS X and Windows. For Linux, use: <PRE>open(new String[] { ""firefox"", url });</PRE> or whatever you want as your browser, since Linux doesn't yet have a standard method for launching URLs.
 */
public void link(String url,String frameTitle){
}","/** 
 * Link to an external page without all the muss. <P> When run with an applet, uses the browser to open the url, for applications, attempts to launch a browser with the url. <P> Works on Mac OS X and Windows. For Linux, use: <PRE>open(new String[] { ""firefox"", url });</PRE> or whatever you want as your browser, since Linux doesn't yet have a standard method for launching URLs.
 */
public void link(String url,String frameTitle){
  Intent viewIntent=new Intent(""String_Node_Str"",Uri.parse(url));
  startActivity(viewIntent);
}",0.90216271884655
163812,"/** 
 * Handle renderer-specific image drawing.
 */
protected void imageImpl(PImage src,float x1,float y1,float x2,float y2,int u1,int v1,int u2,int v2){
  if (src.bitmap == null && src.format == ALPHA) {
    src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
    int[] px=new int[src.pixels.length];
    for (int i=0; i < px.length; i++) {
      px[i]=src.pixels[i] << 24 | 0xFFFFFF;
    }
    src.bitmap.setPixels(px,0,src.width,0,0,src.width,src.height);
    src.modified=false;
  }
  if (src.bitmap == null) {
    int offset=v1 * src.width + u1;
    canvas.drawBitmap(src.pixels,offset,src.width,x1,y1,u2 - u1,v2 - v1,src.format == ARGB,tint ? tintPaint : null);
  }
 else {
    if (src.width != src.bitmap.getWidth() || src.height != src.bitmap.getHeight()) {
      src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
      src.modified=true;
    }
    if (src.modified) {
      if (!src.bitmap.isMutable()) {
        src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
      }
      src.bitmap.setPixels(src.pixels,0,src.width,0,0,src.width,src.height);
      src.modified=false;
    }
    if (imageImplSrcRect == null) {
      imageImplSrcRect=new Rect(u1,v1,u2,v2);
      imageImplDstRect=new RectF(x1,y1,x2,y2);
    }
 else {
      imageImplSrcRect.set(u1,v1,u2,v2);
      imageImplDstRect.set(x1,y1,x2,y2);
    }
    canvas.drawBitmap(src.bitmap,imageImplSrcRect,imageImplDstRect,tint ? tintPaint : null);
  }
}","/** 
 * Handle renderer-specific image drawing.
 */
protected void imageImpl(PImage src,float x1,float y1,float x2,float y2,int u1,int v1,int u2,int v2){
  if (src.bitmap == null && src.format == ALPHA) {
    src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
    int[] px=new int[src.pixels.length];
    for (int i=0; i < px.length; i++) {
      px[i]=src.pixels[i] << 24 | 0xFFFFFF;
    }
    src.bitmap.setPixels(px,0,src.width,0,0,src.width,src.height);
    src.modified=false;
  }
  if (src.bitmap == null || src.width != src.bitmap.getWidth() || src.height != src.bitmap.getHeight()) {
    src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
    src.modified=true;
  }
  if (src.modified) {
    if (!src.bitmap.isMutable()) {
      src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
    }
    src.bitmap.setPixels(src.pixels,0,src.width,0,0,src.width,src.height);
    src.modified=false;
  }
  if (imageImplSrcRect == null) {
    imageImplSrcRect=new Rect(u1,v1,u2,v2);
    imageImplDstRect=new RectF(x1,y1,x2,y2);
  }
 else {
    imageImplSrcRect.set(u1,v1,u2,v2);
    imageImplDstRect.set(x1,y1,x2,y2);
  }
  canvas.drawBitmap(src.bitmap,imageImplSrcRect,imageImplDstRect,tint ? tintPaint : null);
}",0.8757741347905282
163813,"public void set(int x,int y,PImage src){
  if (src.format == ALPHA) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (src.bitmap == null) {
    canvas.drawBitmap(src.pixels,0,src.width,x,y,src.width,src.height,false,null);
  }
 else {
    if (src.width != src.bitmap.getWidth() || src.height != src.bitmap.getHeight()) {
      src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
      src.modified=true;
    }
    if (src.modified) {
      if (!src.bitmap.isMutable()) {
        src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
      }
      src.bitmap.setPixels(src.pixels,0,src.width,0,0,src.width,src.height);
      src.modified=false;
    }
  }
  canvas.save(Canvas.MATRIX_SAVE_FLAG);
  canvas.setMatrix(null);
  canvas.drawBitmap(src.bitmap,x,y,null);
  canvas.restore();
}","public void set(int x,int y,PImage src){
  if (src.format == ALPHA) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (src.bitmap == null) {
    canvas.drawBitmap(src.pixels,0,src.width,x,y,src.width,src.height,false,null);
  }
 else {
    if (src.width != src.bitmap.getWidth() || src.height != src.bitmap.getHeight()) {
      src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
      src.modified=true;
    }
    if (src.modified) {
      if (!src.bitmap.isMutable()) {
        src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
      }
      src.bitmap.setPixels(src.pixels,0,src.width,0,0,src.width,src.height);
      src.modified=false;
    }
    canvas.save(Canvas.MATRIX_SAVE_FLAG);
    canvas.setMatrix(null);
    canvas.drawBitmap(src.bitmap,x,y,null);
    canvas.restore();
  }
}",0.992822966507177
163814,"/** 
 * Resize this image to a new width and height. Use 0 for wide or high to make that dimension scale proportionally.
 */
public void resize(int wide,int high){
  loadPixels();
  if (wide <= 0 && high <= 0) {
    width=0;
    height=0;
    pixels=new int[0];
  }
 else {
    if (wide == 0) {
      float diff=(float)high / (float)height;
      wide=(int)(width * diff);
    }
 else     if (high == 0) {
      float diff=(float)wide / (float)width;
      high=(int)(height * diff);
    }
    PImage temp=new PImage(wide,high,this.format);
    temp.copy(this,0,0,width,height,0,0,wide,high);
    this.width=wide;
    this.height=high;
    this.pixels=temp.pixels;
    this.bitmap=null;
  }
  updatePixels();
}","/** 
 * Resize this image to a new width and height. Use 0 for wide or high to make that dimension scale proportionally.
 */
public void resize(int wide,int high){
  loadPixels();
  if (wide <= 0 && high <= 0) {
    width=0;
    height=0;
    pixels=new int[0];
    bitmap=null;
  }
 else {
    if (wide == 0) {
      float diff=(float)high / (float)height;
      wide=(int)(width * diff);
    }
 else     if (high == 0) {
      float diff=(float)wide / (float)width;
      high=(int)(height * diff);
    }
    PImage temp=new PImage(wide,high,this.format);
    temp.copy(this,0,0,width,height,0,0,wide,high);
    this.width=wide;
    this.height=high;
    this.pixels=temp.pixels;
    this.bitmap=null;
  }
  updatePixels();
}",0.988169798190675
163815,"public PImage loadImage(String filename){
  InputStream stream=createInput(filename);
  if (stream == null) {
    System.err.println(""String_Node_Str"" + filename + ""String_Node_Str"");
    return null;
  }
  long t=System.currentTimeMillis();
  Bitmap bitmap=null;
  try {
    bitmap=BitmapFactory.decodeStream(stream);
  }
  finally {
    try {
      stream.close();
      stream=null;
    }
 catch (    IOException e) {
    }
  }
  int much=(int)(System.currentTimeMillis() - t);
  println(""String_Node_Str"" + filename + ""String_Node_Str""+ nfc(much));
  PImage image=new PImage(bitmap);
  image.parent=this;
  return image;
}","public PImage loadImage(String filename){
  InputStream stream=createInput(filename);
  if (stream == null) {
    System.err.println(""String_Node_Str"" + filename + ""String_Node_Str"");
    return null;
  }
  Bitmap bitmap=null;
  try {
    bitmap=BitmapFactory.decodeStream(stream);
  }
  finally {
    try {
      stream.close();
      stream=null;
    }
 catch (    IOException e) {
    }
  }
  PImage image=new PImage(bitmap);
  image.parent=this;
  return image;
}",0.7264409881061299
163816,"protected void textCharModelImpl(PImage glyph,float x1,float y1,float x2,float y2,int u2,int v2){
  boolean savedTint=tint;
  int savedTintColor=tintColor;
  float savedTintR=tintR;
  float savedTintG=tintG;
  float savedTintB=tintB;
  float savedTintA=tintA;
  boolean savedTintAlpha=tintAlpha;
  tint(fillColor);
  imageImpl(glyph,x1,y1,x2,y2,0,0,u2,v2);
  if (savedTint) {
    tint(tintColor);
  }
 else {
    noTint();
  }
}","protected void textCharModelImpl(PImage glyph,float x1,float y1,float x2,float y2,int u2,int v2){
  boolean savedTint=tint;
  int savedTintColor=tintColor;
  tint(fillColor);
  imageImpl(glyph,x1,y1,x2,y2,0,0,u2,v2);
  if (savedTint) {
    tint(savedTintColor);
  }
 else {
    noTint();
  }
}",0.7073509015256588
163817,"public void setTexCoord(ArrayList<PVector> data){
  if (updateElement != TEXTURES) {
    throw new RuntimeException(""String_Node_Str"");
  }
  firstUpdateIdx=0;
  lastUpdateIdx=numVertices - 1;
  PVector vec;
  for (int i=0; i < numVertices; i++) {
    vec=(PVector)data.get(i);
    if (a3d.imageMode == IMAGE) {
      if (vertGroup[i] != null && vertGroup[i].texture == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      updateTexCoordArray[2 * i + 0]=vec.x / vertGroup[i].texture.width;
      updateTexCoordArray[2 * i + 1]=vec.y / vertGroup[i].texture.height;
    }
 else {
      updateTexCoordArray[2 * i + 0]=vec.x;
      updateTexCoordArray[2 * i + 1]=vec.y;
    }
  }
}","public void setTexCoord(ArrayList<PVector> data){
  if (updateElement != TEXTURES) {
    throw new RuntimeException(""String_Node_Str"");
  }
  firstUpdateIdx=0;
  lastUpdateIdx=numVertices - 1;
  if (updateTexture != null) {
    for (int i=0; i < numVertices; i++)     if (vertGroup[i] != null) {
      vertGroup[i].texture=updateTexture;
    }
  }
  PVector vec;
  for (int i=0; i < numVertices; i++) {
    vec=(PVector)data.get(i);
    if (a3d.imageMode == IMAGE) {
      if (vertGroup[i] != null && vertGroup[i].texture == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      updateTexCoordArray[2 * i + 0]=vec.x / vertGroup[i].texture.width;
      updateTexCoordArray[2 * i + 1]=vec.y / vertGroup[i].texture.height;
    }
 else {
      updateTexCoordArray[2 * i + 0]=vec.x;
      updateTexCoordArray[2 * i + 1]=vec.y;
    }
  }
}",0.9004495825305073
163818,"public void setVertex(ArrayList<PVector> data){
  if (updateElement != VERTICES) {
    throw new RuntimeException(""String_Node_Str"");
  }
  firstUpdateIdx=0;
  lastUpdateIdx=numVertices - 1;
  PVector vec;
  for (int i=0; i < numVertices; i++) {
    vec=(PVector)data.get(i);
    updateVertexArray[3 * i + 0]=vec.x;
    updateVertexArray[3 * i + 1]=vec.y;
    updateVertexArray[3 * i + 2]=vec.z;
  }
}","public void setVertex(ArrayList<PVector> data){
  if (updateElement != VERTICES) {
    throw new RuntimeException(""String_Node_Str"");
  }
  firstUpdateIdx=0;
  lastUpdateIdx=numVertices - 1;
  if (creatingGroup) {
    grIdx0=0;
    grIdx1=numVertices - 1;
  }
  PVector vec;
  for (int i=0; i < numVertices; i++) {
    vec=(PVector)data.get(i);
    updateVertexArray[3 * i + 0]=vec.x;
    updateVertexArray[3 * i + 1]=vec.y;
    updateVertexArray[3 * i + 2]=vec.z;
  }
}",0.920780711825488
163819,"protected void addNewFace(){
  if (faceCount == faceOffset.length) {
    faceOffset=PApplet.expand(faceOffset);
    faceLength=PApplet.expand(faceLength);
    faceTexture=PApplet.expand(faceTexture);
  }
  faceOffset[faceCount]=triangleCount;
  faceLength[faceCount]=1;
  faceTexture[faceCount]=textureImage;
  faceCount++;
}","protected void addNewFace(boolean firstFace){
  if (faceCount == faceOffset.length) {
    faceOffset=PApplet.expand(faceOffset);
    faceLength=PApplet.expand(faceLength);
    faceTexture=PApplet.expand(faceTexture);
  }
  faceOffset[faceCount]=firstFace ? 0 : triangleCount;
  faceLength[faceCount]=1;
  faceTexture[faceCount]=textureImage;
  faceCount++;
}",0.9516837481698388
163820,"protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  GLTexture tex=null;
  boolean texturing=false;
  vertexBuffer.position(0);
  colorBuffer.position(0);
  normalBuffer.position(0);
  textureBuffer.position(0);
  gl.glPushMatrix();
  gl.glScalef(1,-1,1);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=0; j < faceCount; j++) {
    int i=faceOffset[j];
    if (faceTexture[j] != null) {
      try {
        tex=(GLTexture)faceTexture[j];
      }
 catch (      ClassCastException cce) {
        throw new RuntimeException(""String_Node_Str"");
      }
      gl.glEnable(tex.getGLTarget());
      gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
      gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
      texturing=true;
    }
 else {
      texturing=false;
    }
    if (vertexBuffer.capacity() == 3 * faceLength[j]) {
      expandBuffers();
    }
    vertexBuffer.rewind();
    colorBuffer.rewind();
    normalBuffer.rewind();
    textureBuffer.rewind();
    for (int k=i; k < faceLength[j]; k++) {
      float a[]=vertices[triangles[k][VERTEX1]];
      float b[]=vertices[triangles[k][VERTEX2]];
      float c[]=vertices[triangles[k][VERTEX3]];
      float uscale=1.0f;
      float vscale=1.0f;
      float cx=0.0f;
      float sx=+1.0f;
      float cy=0.0f;
      float sy=+1.0f;
      if (texturing) {
        uscale*=tex.getMaxTextureCoordS();
        vscale*=tex.getMaxTextureCoordT();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
      }
      vertexBuffer.put(toFixed32(a[X]));
      vertexBuffer.put(toFixed32(a[Y]));
      vertexBuffer.put(toFixed32(a[Z]));
      colorBuffer.put(toFixed32(a[R]));
      colorBuffer.put(toFixed32(a[G]));
      colorBuffer.put(toFixed32(a[B]));
      colorBuffer.put(toFixed32(a[A]));
      normalBuffer.put(toFixed32(a[NX]));
      normalBuffer.put(toFixed32(a[NY]));
      normalBuffer.put(toFixed32(a[NZ]));
      textureBuffer.put(toFixed32((cx + sx * a[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * a[V]) * vscale));
      vertexBuffer.put(toFixed32(b[X]));
      vertexBuffer.put(toFixed32(b[Y]));
      vertexBuffer.put(toFixed32(b[Z]));
      colorBuffer.put(toFixed32(b[R]));
      colorBuffer.put(toFixed32(b[G]));
      colorBuffer.put(toFixed32(b[B]));
      colorBuffer.put(toFixed32(b[A]));
      normalBuffer.put(toFixed32(b[NX]));
      normalBuffer.put(toFixed32(b[NY]));
      normalBuffer.put(toFixed32(b[NZ]));
      textureBuffer.put(toFixed32((cx + sx * b[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * b[V]) * vscale));
      vertexBuffer.put(toFixed32(c[X]));
      vertexBuffer.put(toFixed32(c[Y]));
      vertexBuffer.put(toFixed32(c[Z]));
      colorBuffer.put(toFixed32(c[R]));
      colorBuffer.put(toFixed32(c[G]));
      colorBuffer.put(toFixed32(c[B]));
      colorBuffer.put(toFixed32(c[A]));
      normalBuffer.put(toFixed32(c[NX]));
      normalBuffer.put(toFixed32(c[NY]));
      normalBuffer.put(toFixed32(c[NZ]));
      textureBuffer.put(toFixed32((cx + sx * c[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * c[V]) * vscale));
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    textureBuffer.position(0);
    gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
    gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
    gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
    if (texturing)     gl.glTexCoordPointer(2,GL10.GL_FIXED,0,textureBuffer);
    gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    if (texturing) {
      gl.glDisable(tex.getGLTarget());
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glPopMatrix();
  report(""String_Node_Str"");
}","protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  GLTexture tex=null;
  boolean texturing=false;
  vertexBuffer.position(0);
  colorBuffer.position(0);
  normalBuffer.position(0);
  textureBuffer.position(0);
  gl.glPushMatrix();
  gl.glScalef(1,-1,1);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=0; j < faceCount; j++) {
    int i=faceOffset[j];
    if (faceTexture[j] != null) {
      try {
        tex=(GLTexture)faceTexture[j];
      }
 catch (      ClassCastException cce) {
        throw new RuntimeException(""String_Node_Str"");
      }
      gl.glEnable(tex.getGLTarget());
      gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
      gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
      texturing=true;
    }
 else {
      texturing=false;
    }
    if (vertexBuffer.capacity() == 3 * faceLength[j]) {
      expandBuffers();
    }
    vertexBuffer.rewind();
    colorBuffer.rewind();
    normalBuffer.rewind();
    textureBuffer.rewind();
    for (int k=0; k < faceLength[j]; k++) {
      float a[]=vertices[triangles[i][VERTEX1]];
      float b[]=vertices[triangles[i][VERTEX2]];
      float c[]=vertices[triangles[i][VERTEX3]];
      float uscale=1.0f;
      float vscale=1.0f;
      float cx=0.0f;
      float sx=+1.0f;
      float cy=0.0f;
      float sy=+1.0f;
      if (texturing) {
        uscale*=tex.getMaxTextureCoordS();
        vscale*=tex.getMaxTextureCoordT();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
      }
      vertexBuffer.put(toFixed32(a[X]));
      vertexBuffer.put(toFixed32(a[Y]));
      vertexBuffer.put(toFixed32(a[Z]));
      colorBuffer.put(toFixed32(a[R]));
      colorBuffer.put(toFixed32(a[G]));
      colorBuffer.put(toFixed32(a[B]));
      colorBuffer.put(toFixed32(a[A]));
      normalBuffer.put(toFixed32(a[NX]));
      normalBuffer.put(toFixed32(a[NY]));
      normalBuffer.put(toFixed32(a[NZ]));
      textureBuffer.put(toFixed32((cx + sx * a[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * a[V]) * vscale));
      vertexBuffer.put(toFixed32(b[X]));
      vertexBuffer.put(toFixed32(b[Y]));
      vertexBuffer.put(toFixed32(b[Z]));
      colorBuffer.put(toFixed32(b[R]));
      colorBuffer.put(toFixed32(b[G]));
      colorBuffer.put(toFixed32(b[B]));
      colorBuffer.put(toFixed32(b[A]));
      normalBuffer.put(toFixed32(b[NX]));
      normalBuffer.put(toFixed32(b[NY]));
      normalBuffer.put(toFixed32(b[NZ]));
      textureBuffer.put(toFixed32((cx + sx * b[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * b[V]) * vscale));
      vertexBuffer.put(toFixed32(c[X]));
      vertexBuffer.put(toFixed32(c[Y]));
      vertexBuffer.put(toFixed32(c[Z]));
      colorBuffer.put(toFixed32(c[R]));
      colorBuffer.put(toFixed32(c[G]));
      colorBuffer.put(toFixed32(c[B]));
      colorBuffer.put(toFixed32(c[A]));
      normalBuffer.put(toFixed32(c[NX]));
      normalBuffer.put(toFixed32(c[NY]));
      normalBuffer.put(toFixed32(c[NZ]));
      textureBuffer.put(toFixed32((cx + sx * c[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * c[V]) * vscale));
      i++;
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    textureBuffer.position(0);
    gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
    gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
    gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
    if (texturing)     gl.glTexCoordPointer(2,GL10.GL_FIXED,0,textureBuffer);
    gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    if (texturing) {
      gl.glDisable(tex.getGLTarget());
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glPopMatrix();
  report(""String_Node_Str"");
}",0.9976701410177804
163821,"/** 
 * Add the triangle.
 */
protected void addTriangle(int a,int b,int c){
  if (triangleCount == triangles.length) {
    int temp[][]=new int[triangleCount << 1][TRIANGLE_FIELD_COUNT];
    System.arraycopy(triangles,0,temp,0,triangleCount);
    triangles=temp;
  }
  triangles[triangleCount][VERTEX1]=a;
  triangles[triangleCount][VERTEX2]=b;
  triangles[triangleCount][VERTEX3]=c;
  triangleCount++;
  if (textureImage != textureImagePrev || triangleCount == 1) {
    addNewFace();
  }
 else {
    faceLength[faceCount - 1]++;
  }
  textureImagePrev=textureImage;
}","/** 
 * Add the triangle.
 */
protected void addTriangle(int a,int b,int c){
  if (triangleCount == triangles.length) {
    int temp[][]=new int[triangleCount << 1][TRIANGLE_FIELD_COUNT];
    System.arraycopy(triangles,0,temp,0,triangleCount);
    triangles=temp;
  }
  triangles[triangleCount][VERTEX1]=a;
  triangles[triangleCount][VERTEX2]=b;
  triangles[triangleCount][VERTEX3]=c;
  triangleCount++;
  boolean firstFace=triangleCount == 1;
  if (textureImage != textureImagePrev || firstFace) {
    addNewFace(firstFace);
  }
 else {
    faceLength[faceCount - 1]++;
  }
  textureImagePrev=textureImage;
}",0.935483870967742
163822,"/** 
 * Copy pixels to texture. Involves main memory to video memory transfer (slow).
 */
void update(){
  set(this.pixels);
}","/** 
 * Copy pixels to texture. Involves main memory to video memory transfer (slow).
 */
void update(){
  set(this.pixels,this.format);
}",0.9545454545454546
163823,"public void set(int[] pixels,int format){
  if (pixels.length != width * height) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (glTextureID[0] == 0) {
    createTexture(width,height);
  }
  int[] convArray=pixels;
  int glFormat;
  if (format == ALPHA) {
    glFormat=GL10.GL_ALPHA;
  }
 else   if (format == RGB) {
    glFormat=GL10.GL_RGB;
  }
 else {
    glFormat=GL10.GL_RGBA;
  }
  convArray=convertToRGBA(pixels,format);
  gl.glBindTexture(glTarget,glTextureID[0]);
  if (usingMipmaps) {
    if (a3d.gl11 != null && a3d.mipmapSupported) {
      gl.glTexParameterf(GL11.GL_TEXTURE_2D,GL11.GL_GENERATE_MIPMAP,GL11.GL_TRUE);
    }
 else {
    }
  }
  gl.glTexSubImage2D(glTarget,0,0,0,glWidth,glHeight,glFormat,GL10.GL_UNSIGNED_BYTE,IntBuffer.wrap(convArray));
  gl.glBindTexture(glTarget,0);
}","public void set(int[] intArray,int arrayFormat){
  if (intArray.length != width * height) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (glTextureID[0] == 0) {
    createTexture(width,height);
  }
  int[] convArray=convertToRGBA(intArray,arrayFormat);
  gl.glBindTexture(glTarget,glTextureID[0]);
  if (usingMipmaps) {
    if (a3d.gl11 != null && a3d.mipmapSupported) {
      gl.glTexParameterf(GL11.GL_TEXTURE_2D,GL11.GL_GENERATE_MIPMAP,GL11.GL_TRUE);
    }
 else {
    }
  }
  gl.glTexSubImage2D(glTarget,0,0,0,glWidth,glHeight,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,IntBuffer.wrap(convArray));
  gl.glBindTexture(glTarget,0);
}",0.7725085910652921
163824,"/** 
 * Creates an instance of GLTexture using image file filename as source and the specified texture parameters.
 * @param parent PApplet
 * @param filename String
 * @param params Parameters
 */
public GLTexture(PApplet parent,String filename,Parameters params){
  super(1,1,params.format);
  this.parent=parent;
  a3d=(PGraphicsAndroid3D)parent.g;
  gl=a3d.gl;
  PImage img=parent.loadImage(filename);
  set(img);
}","/** 
 * Creates an instance of GLTexture using image file filename as source and the specified texture parameters.
 * @param parent PApplet
 * @param filename String
 * @param params Parameters
 */
public GLTexture(PApplet parent,String filename,Parameters params){
  super(1,1,params.format);
  this.parent=parent;
  a3d=(PGraphicsAndroid3D)parent.g;
  gl=a3d.gl;
  PImage img=parent.loadImage(filename);
  setParameters(params);
  set(img);
}",0.9710312862108922
163825,"public void endUpdate(){
  if (updateElement == -1) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (lastUpdateIdx < firstUpdateIdx)   return;
  if (updateElement == VERTICES) {
    if (updateVertexArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 3;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 3;
    vertices.put(updateVertexArray,offset,size);
    vertices.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * SIZEOF_FLOAT,size * SIZEOF_FLOAT,vertices);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == COLORS) {
    if (updateColorArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 4;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 4;
    colors.put(updateColorArray,size,offset);
    colors.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,size * SIZEOF_FLOAT,offset * SIZEOF_FLOAT,colors);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == NORMALS) {
    if (updateNormalArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 3;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 3;
    normals.put(updateNormalArray,offset,size);
    normals.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * SIZEOF_FLOAT,size * SIZEOF_FLOAT,normals);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == TEXTURES) {
    if (updateTexCoordArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 2;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 2;
    texCoords.put(updateNormalArray,offset,size);
    texCoords.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * SIZEOF_FLOAT,size * SIZEOF_FLOAT,texCoords);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == GROUPS) {
    createGroups();
  }
  updateElement=-1;
}","public void endUpdate(){
  if (updateElement == -1) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (lastUpdateIdx < firstUpdateIdx)   return;
  if (updateElement == VERTICES) {
    if (updateVertexArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 3;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 3;
    vertices.put(updateVertexArray,offset,size);
    vertices.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * SIZEOF_FLOAT,size * SIZEOF_FLOAT,vertices);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == COLORS) {
    if (updateColorArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 4;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 4;
    colors.put(updateColorArray,size,offset);
    colors.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,size * SIZEOF_FLOAT,offset * SIZEOF_FLOAT,colors);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == NORMALS) {
    if (updateNormalArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 3;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 3;
    normals.put(updateNormalArray,offset,size);
    normals.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * SIZEOF_FLOAT,size * SIZEOF_FLOAT,normals);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == TEXTURES) {
    if (updateTexCoordArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 2;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 2;
    texCoords.put(updateTexCoordArray,offset,size);
    texCoords.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * SIZEOF_FLOAT,size * SIZEOF_FLOAT,texCoords);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == GROUPS) {
    createGroups();
  }
  updateElement=-1;
}",0.9965329370975732
163826,"/** 
 * Handle renderer-specific image drawing.
 */
protected void imageImpl(PImage who,float x1,float y1,float x2,float y2,int u1,int v1,int u2,int v2){
  rect.set(x1,y1,x2,y2);
  if (who.bitmap == null || who.width != who.bitmap.getWidth() || who.height != who.bitmap.getHeight()) {
    who.bitmap=Bitmap.createBitmap(width,height,Config.ARGB_8888);
    who.modified=true;
  }
  if (who.modified) {
    who.bitmap.setPixels(who.pixels,0,who.width,0,0,who.width,who.height);
  }
  if (imageImplSrcRect == null) {
    imageImplSrcRect=new Rect(u1,v1,u2 - u1,v2 - v1);
    imageImplDstRect=new Rect((int)x1,(int)y1,(int)(x2 - x1),(int)(y2 - y1));
  }
 else {
    imageImplSrcRect.set(u1,v1,u2 - u1,v2 - v1);
    imageImplDstRect.set((int)x1,(int)y1,(int)(x2 - x1),(int)(y2 - y1));
  }
  canvas.drawBitmap(who.bitmap,imageImplSrcRect,imageImplDstRect,tint ? tintPaint : null);
}","/** 
 * Handle renderer-specific image drawing.
 */
protected void imageImpl(PImage who,float x1,float y1,float x2,float y2,int u1,int v1,int u2,int v2){
  rect.set(x1,y1,x2,y2);
  if (who.bitmap == null || who.width != who.bitmap.getWidth() || who.height != who.bitmap.getHeight()) {
    who.bitmap=Bitmap.createBitmap(who.width,who.height,Config.ARGB_8888);
    who.modified=true;
  }
  if (who.modified) {
    who.bitmap.setPixels(who.pixels,0,who.width,0,0,who.width,who.height);
  }
  if (imageImplSrcRect == null) {
    imageImplSrcRect=new Rect(u1,v1,u2 - u1,v2 - v1);
    imageImplDstRect=new Rect((int)x1,(int)y1,(int)(x2 - x1),(int)(y2 - y1));
  }
 else {
    imageImplSrcRect.set(u1,v1,u2 - u1,v2 - v1);
    imageImplDstRect.set((int)x1,(int)y1,(int)(x2 - x1),(int)(y2 - y1));
  }
  canvas.drawBitmap(who.bitmap,imageImplSrcRect,imageImplDstRect,tint ? tintPaint : null);
}",0.9897727272727272
163827,"protected void parsePath(){
  family=PATH;
  kind=0;
  String pathData=element.getStringAttribute(""String_Node_Str"");
  if (pathData == null)   return;
  char[] pathDataChars=pathData.toCharArray();
  StringBuffer pathBuffer=new StringBuffer();
  boolean lastSeparate=false;
  for (int i=0; i < pathDataChars.length; i++) {
    char c=pathDataChars[i];
    boolean separate=false;
    if (c == 'M' || c == 'm' || c == 'L' || c == 'l' || c == 'H' || c == 'h' || c == 'V' || c == 'v' || c == 'C' || c == 'c' || c == 'S' || c == 's' || c == 'Q' || c == 'q' || c == 'T' || c == 't' || c == 'Z' || c == 'z' || c == ',') {
      separate=true;
      if (i != 0) {
        pathBuffer.append(""String_Node_Str"");
      }
    }
    if (c == 'Z' || c == 'z') {
      separate=false;
    }
    if (c == '-' && !lastSeparate) {
      pathBuffer.append(""String_Node_Str"");
    }
    if (c != ',') {
      pathBuffer.append(c);
    }
    if (separate && c != ',' && c != '-') {
      pathBuffer.append(""String_Node_Str"");
    }
    lastSeparate=separate;
  }
  String[] pathDataKeys=PApplet.splitTokens(pathBuffer.toString(),""String_Node_Str"" + WHITESPACE);
  vertices=new float[pathDataKeys.length][2];
  vertexCodes=new int[pathDataKeys.length];
  float cx=0;
  float cy=0;
  int i=0;
  while (i < pathDataKeys.length) {
    char c=pathDataKeys[i].charAt(0);
switch (c) {
case 'M':
      cx=PApplet.parseFloat(pathDataKeys[i + 1]);
    cy=PApplet.parseFloat(pathDataKeys[i + 2]);
  parsePathMoveto(cx,cy);
i+=3;
break;
case 'm':
cx=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
cy=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathMoveto(cx,cy);
i+=3;
break;
case 'L':
cx=PApplet.parseFloat(pathDataKeys[i + 1]);
cy=PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'l':
cx=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
cy=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'H':
cx=PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'h':
cx=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'V':
cy=PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'v':
cy=cy + PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'C':
{
float ctrlX1=PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY1=PApplet.parseFloat(pathDataKeys[i + 2]);
float ctrlX2=PApplet.parseFloat(pathDataKeys[i + 3]);
float ctrlY2=PApplet.parseFloat(pathDataKeys[i + 4]);
float endX=PApplet.parseFloat(pathDataKeys[i + 5]);
float endY=PApplet.parseFloat(pathDataKeys[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
}
break;
case 'c':
{
float ctrlX1=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY1=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
float ctrlX2=cx + PApplet.parseFloat(pathDataKeys[i + 3]);
float ctrlY2=cy + PApplet.parseFloat(pathDataKeys[i + 4]);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 5]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
}
break;
case 'S':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX1=px + (px - ppx);
float ctrlY1=py + (py - ppy);
float ctrlX2=PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY2=PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 's':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX1=px + (px - ppx);
float ctrlY1=py + (py - ppy);
float ctrlX2=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY2=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 'Q':
{
float ctrlX=PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY=PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 'q':
{
float ctrlX=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 'T':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX=px + (px - ppx);
float ctrlY=py + (py - ppy);
float endX=PApplet.parseFloat(pathDataKeys[i + 1]);
float endY=PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
}
break;
case 't':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX=px + (px - ppx);
float ctrlY=py + (py - ppy);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
}
break;
case 'Z':
case 'z':
close=true;
i++;
break;
default :
String parsed=PApplet.join(PApplet.subset(pathDataKeys,0,i),""String_Node_Str"");
String unparsed=PApplet.join(PApplet.subset(pathDataKeys,i),""String_Node_Str"");
System.err.println(""String_Node_Str"" + parsed);
System.err.println(""String_Node_Str"" + unparsed);
if (pathDataKeys[i].equals(""String_Node_Str"") || pathDataKeys[i].equals(""String_Node_Str"")) {
String msg=""String_Node_Str"" + ""String_Node_Str"";
throw new RuntimeException(msg);
}
throw new RuntimeException(""String_Node_Str"" + pathDataKeys[i]);
}
}
}","protected void parsePath(){
  family=PATH;
  kind=0;
  String pathData=element.getStringAttribute(""String_Node_Str"");
  if (pathData == null)   return;
  char[] pathDataChars=pathData.toCharArray();
  StringBuffer pathBuffer=new StringBuffer();
  boolean lastSeparate=false;
  for (int i=0; i < pathDataChars.length; i++) {
    char c=pathDataChars[i];
    boolean separate=false;
    if (c == 'M' || c == 'm' || c == 'L' || c == 'l' || c == 'H' || c == 'h' || c == 'V' || c == 'v' || c == 'C' || c == 'c' || c == 'S' || c == 's' || c == 'Q' || c == 'q' || c == 'T' || c == 't' || c == 'Z' || c == 'z' || c == ',') {
      separate=true;
      if (i != 0) {
        pathBuffer.append(""String_Node_Str"");
      }
    }
    if (c == 'Z' || c == 'z') {
      separate=false;
    }
    if (c == '-' && !lastSeparate) {
      if (i == 0 || pathDataChars[i - 1] != 'e') {
        pathBuffer.append(""String_Node_Str"");
      }
    }
    if (c != ',') {
      pathBuffer.append(c);
    }
    if (separate && c != ',' && c != '-') {
      pathBuffer.append(""String_Node_Str"");
    }
    lastSeparate=separate;
  }
  String[] pathDataKeys=PApplet.splitTokens(pathBuffer.toString(),""String_Node_Str"" + WHITESPACE);
  vertices=new float[pathDataKeys.length][2];
  vertexCodes=new int[pathDataKeys.length];
  float cx=0;
  float cy=0;
  int i=0;
  while (i < pathDataKeys.length) {
    char c=pathDataKeys[i].charAt(0);
switch (c) {
case 'M':
      cx=PApplet.parseFloat(pathDataKeys[i + 1]);
    cy=PApplet.parseFloat(pathDataKeys[i + 2]);
  parsePathMoveto(cx,cy);
i+=3;
break;
case 'm':
cx=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
cy=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathMoveto(cx,cy);
i+=3;
break;
case 'L':
cx=PApplet.parseFloat(pathDataKeys[i + 1]);
cy=PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'l':
cx=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
cy=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'H':
cx=PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'h':
cx=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'V':
cy=PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'v':
cy=cy + PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'C':
{
float ctrlX1=PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY1=PApplet.parseFloat(pathDataKeys[i + 2]);
float ctrlX2=PApplet.parseFloat(pathDataKeys[i + 3]);
float ctrlY2=PApplet.parseFloat(pathDataKeys[i + 4]);
float endX=PApplet.parseFloat(pathDataKeys[i + 5]);
float endY=PApplet.parseFloat(pathDataKeys[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
}
break;
case 'c':
{
float ctrlX1=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY1=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
float ctrlX2=cx + PApplet.parseFloat(pathDataKeys[i + 3]);
float ctrlY2=cy + PApplet.parseFloat(pathDataKeys[i + 4]);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 5]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
}
break;
case 'S':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX1=px + (px - ppx);
float ctrlY1=py + (py - ppy);
float ctrlX2=PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY2=PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 's':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX1=px + (px - ppx);
float ctrlY1=py + (py - ppy);
float ctrlX2=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY2=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 'Q':
{
float ctrlX=PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY=PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 'q':
{
float ctrlX=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 'T':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX=px + (px - ppx);
float ctrlY=py + (py - ppy);
float endX=PApplet.parseFloat(pathDataKeys[i + 1]);
float endY=PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
}
break;
case 't':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX=px + (px - ppx);
float ctrlY=py + (py - ppy);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
}
break;
case 'Z':
case 'z':
close=true;
i++;
break;
default :
String parsed=PApplet.join(PApplet.subset(pathDataKeys,0,i),""String_Node_Str"");
String unparsed=PApplet.join(PApplet.subset(pathDataKeys,i),""String_Node_Str"");
System.err.println(""String_Node_Str"" + parsed);
System.err.println(""String_Node_Str"" + unparsed);
if (pathDataKeys[i].equals(""String_Node_Str"") || pathDataKeys[i].equals(""String_Node_Str"")) {
String msg=""String_Node_Str"" + ""String_Node_Str"";
throw new RuntimeException(msg);
}
throw new RuntimeException(""String_Node_Str"" + pathDataKeys[i]);
}
}
}",0.995186617217707
163828,"public Optional<String> getCurrentUserPrincipal() throws DavException, IOException {
  if (currentUserPrincipal.isPresent())   return currentUserPrincipal;
  DavPropertyNameSet props=new DavPropertyNameSet();
  props.add(WebDavConstants.PROPERTY_NAME_CURRENT_USER_PRINCIPAL);
  String propFindUri=getHostHREF().concat(getWellKnownUri());
  PropFindMethod propFindMethod=new PropFindMethod(propFindUri,props,PropFindMethod.DEPTH_0);
  try {
    getClient().execute(propFindMethod);
    return getCurrentUserPrincipalFromMultiStatus(propFindMethod.getResponseBodyAsMultiStatus());
  }
 catch (  DavException e) {
    if (e.getErrorCode() == DavServletResponse.SC_MOVED_PERMANENTLY) {
      Header locationHeader=propFindMethod.getResponseHeader(""String_Node_Str"");
      if (locationHeader.getValue() != null) {
        currentUserPrincipal=getCurrentUserPrincipal(locationHeader.getValue());
        return currentUserPrincipal;
      }
    }
 else     throw e;
  }
 finally {
    propFindMethod.releaseConnection();
  }
  return Optional.absent();
}","public Optional<String> getCurrentUserPrincipal() throws DavException, IOException {
  if (currentUserPrincipal.isPresent())   return currentUserPrincipal;
  DavPropertyNameSet props=new DavPropertyNameSet();
  props.add(WebDavConstants.PROPERTY_NAME_CURRENT_USER_PRINCIPAL);
  String propFindUri=getHostHREF().concat(getWellKnownUri());
  PropFindMethod propFindMethod=new PropFindMethod(propFindUri,props,PropFindMethod.DEPTH_0);
  try {
    getClient().execute(propFindMethod);
    return getCurrentUserPrincipalFromMultiStatus(propFindMethod.getResponseBodyAsMultiStatus());
  }
 catch (  DavException e) {
    if (e.getErrorCode() == DavServletResponse.SC_MOVED_PERMANENTLY || e.getErrorCode() == DavServletResponse.SC_MOVED_TEMPORARILY || e.getErrorCode() == DavServletResponse.SC_SEE_OTHER || e.getErrorCode() == DavServletResponse.SC_USE_PROXY || e.getErrorCode() == DavServletResponse.SC_TEMPORARY_REDIRECT) {
      Header locationHeader=propFindMethod.getResponseHeader(""String_Node_Str"");
      if (locationHeader.getValue() != null) {
        currentUserPrincipal=getCurrentUserPrincipal(locationHeader.getValue());
        return currentUserPrincipal;
      }
    }
 else     throw e;
  }
 finally {
    propFindMethod.releaseConnection();
  }
  return Optional.absent();
}",0.8985010706638116
163829,"public MockMasterCipher(){
  super(null,null);
}","public MockMasterCipher(){
  super(false,null,null);
}",0.9411764705882352
163830,"@Override public Optional<ComponentETagPair<Calendar>> getHiddenComponent(String uid) throws InvalidComponentException, DavException, InvalidMacException, GeneralSecurityException, IOException {
  Optional<ComponentETagPair<Calendar>> originalComponentPair=super.getComponent(uid);
  if (!originalComponentPair.isPresent())   return Optional.absent();
  Calendar exposedComponent=originalComponentPair.get().getComponent();
  XProperty protectedComponent=(XProperty)exposedComponent.getProperty(PROPERTY_NAME_FLOCK_HIDDEN_CALENDAR);
  if (protectedComponent == null)   return originalComponentPair;
  String recoveredComponentText=HidingUtil.decodeAndDecryptIfNecessary(masterCipher,protectedComponent.getValue());
  StringReader stringReader=new StringReader(recoveredComponentText.replace(""String_Node_Str"",""String_Node_Str""));
  CalendarBuilder calendarBuilder=new CalendarBuilder();
  try {
    Calendar recoveredComponent=calendarBuilder.build(stringReader);
    return Optional.of(new ComponentETagPair<Calendar>(recoveredComponent,originalComponentPair.get().getETag()));
  }
 catch (  ParserException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new InvalidComponentException(""String_Node_Str"",true,CalDavConstants.CALDAV_NAMESPACE,getPath(),uid,e);
  }
}","@Override public Optional<ComponentETagPair<Calendar>> getHiddenComponent(String uid) throws InvalidComponentException, DavException, InvalidMacException, GeneralSecurityException, IOException {
  Optional<ComponentETagPair<Calendar>> originalComponentPair=super.getComponent(uid);
  if (!originalComponentPair.isPresent())   return Optional.absent();
  Calendar exposedComponent=originalComponentPair.get().getComponent();
  XProperty protectedComponent=(XProperty)exposedComponent.getProperty(PROPERTY_NAME_FLOCK_HIDDEN_CALENDAR);
  if (protectedComponent == null)   return originalComponentPair;
  String recoveredComponentText=HidingUtil.decodeAndDecryptIfNecessary(masterCipher,protectedComponent.getValue());
  StringReader stringReader=new StringReader(recoveredComponentText);
  CalendarBuilder calendarBuilder=new CalendarBuilder();
  try {
    Calendar recoveredComponent=calendarBuilder.build(stringReader);
    return Optional.of(new ComponentETagPair<Calendar>(recoveredComponent,originalComponentPair.get().getETag()));
  }
 catch (  ParserException e) {
    Log.e(TAG,""String_Node_Str"",e);
    throw new InvalidComponentException(""String_Node_Str"",true,CalDavConstants.CALDAV_NAMESPACE,getPath(),uid,e);
  }
}",0.9819494584837544
163831,"@Override public List<ComponentETagPair<Calendar>> getHiddenComponents() throws InvalidComponentException, DavException, InvalidMacException, GeneralSecurityException, IOException {
  List<ComponentETagPair<Calendar>> exposedComponentPairs=super.getComponents();
  List<ComponentETagPair<Calendar>> recoveredComponentPairs=new LinkedList<ComponentETagPair<Calendar>>();
  for (  ComponentETagPair<Calendar> exposedComponentPair : exposedComponentPairs) {
    Calendar exposedComponent=exposedComponentPair.getComponent();
    XProperty protectedComponent=(XProperty)exposedComponent.getProperty(PROPERTY_NAME_FLOCK_HIDDEN_CALENDAR);
    if (protectedComponent == null)     recoveredComponentPairs.add(exposedComponentPair);
 else {
      String recoveredComponentText=HidingUtil.decodeAndDecryptIfNecessary(masterCipher,protectedComponent.getValue());
      StringReader stringReader=new StringReader(recoveredComponentText.replace(""String_Node_Str"",""String_Node_Str""));
      CalendarBuilder calendarBuilder=new CalendarBuilder();
      try {
        Calendar recoveredComponent=calendarBuilder.build(stringReader);
        recoveredComponentPairs.add(new ComponentETagPair<Calendar>(recoveredComponent,exposedComponentPair.getETag()));
      }
 catch (      ParserException e) {
        Log.e(TAG,""String_Node_Str"",e);
        throw new InvalidComponentException(""String_Node_Str"",true,CalDavConstants.CALDAV_NAMESPACE,getPath(),e);
      }
    }
  }
  return recoveredComponentPairs;
}","@Override public List<ComponentETagPair<Calendar>> getHiddenComponents() throws InvalidComponentException, DavException, InvalidMacException, GeneralSecurityException, IOException {
  List<ComponentETagPair<Calendar>> exposedComponentPairs=super.getComponents();
  List<ComponentETagPair<Calendar>> recoveredComponentPairs=new LinkedList<ComponentETagPair<Calendar>>();
  for (  ComponentETagPair<Calendar> exposedComponentPair : exposedComponentPairs) {
    Calendar exposedComponent=exposedComponentPair.getComponent();
    XProperty protectedComponent=(XProperty)exposedComponent.getProperty(PROPERTY_NAME_FLOCK_HIDDEN_CALENDAR);
    if (protectedComponent == null)     recoveredComponentPairs.add(exposedComponentPair);
 else {
      String recoveredComponentText=HidingUtil.decodeAndDecryptIfNecessary(masterCipher,protectedComponent.getValue());
      StringReader stringReader=new StringReader(recoveredComponentText);
      CalendarBuilder calendarBuilder=new CalendarBuilder();
      try {
        Calendar recoveredComponent=calendarBuilder.build(stringReader);
        recoveredComponentPairs.add(new ComponentETagPair<Calendar>(recoveredComponent,exposedComponentPair.getETag()));
      }
 catch (      ParserException e) {
        Log.e(TAG,""String_Node_Str"",e);
        throw new InvalidComponentException(""String_Node_Str"",true,CalDavConstants.CALDAV_NAMESPACE,getPath(),e);
      }
    }
  }
  return recoveredComponentPairs;
}",0.984646878198567
163832,"protected static List<ContentValues> getValuesForEvents(VCard vCard){
  List<ContentValues> valuesList=new LinkedList<ContentValues>();
  if (vCard.getBirthday() != null && vCard.getBirthday().getDate() != null) {
    SimpleDateFormat formatter=new SimpleDateFormat(""String_Node_Str"",Locale.US);
    ContentValues values=new ContentValues();
    values.put(ContactsContract.Data.MIMETYPE,ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE);
    values.put(ContactsContract.CommonDataKinds.Event.TYPE,ContactsContract.CommonDataKinds.Event.TYPE_BIRTHDAY);
    values.put(ContactsContract.CommonDataKinds.Event.START_DATE,formatter.format(vCard.getBirthday().getDate()));
    valuesList.add(values);
  }
  if (vCard.getExtendedProperty(PROPERTY_EVENT_ANNIVERSARY) != null) {
    ContentValues values=new ContentValues();
    values.put(ContactsContract.Data.MIMETYPE,ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE);
    values.put(ContactsContract.CommonDataKinds.Event.TYPE,ContactsContract.CommonDataKinds.Event.TYPE_ANNIVERSARY);
    values.put(ContactsContract.CommonDataKinds.Event.START_DATE,vCard.getExtendedProperty(PROPERTY_EVENT_ANNIVERSARY).getValue());
    valuesList.add(values);
  }
  if (vCard.getExtendedProperty(PROPERTY_EVENT_OTHER) != null) {
    ContentValues values=new ContentValues();
    values.put(ContactsContract.Data.MIMETYPE,ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE);
    values.put(ContactsContract.CommonDataKinds.Event.TYPE,ContactsContract.CommonDataKinds.Event.TYPE_OTHER);
    values.put(ContactsContract.CommonDataKinds.Event.START_DATE,vCard.getExtendedProperty(PROPERTY_EVENT_OTHER).getValue());
    valuesList.add(values);
  }
  if (vCard.getExtendedProperty(PROPERTY_EVENT_CUSTOM) != null) {
    ContentValues values=new ContentValues();
    values.put(ContactsContract.Data.MIMETYPE,ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE);
    values.put(ContactsContract.CommonDataKinds.Event.TYPE,ContactsContract.CommonDataKinds.Event.TYPE_CUSTOM);
    values.put(ContactsContract.CommonDataKinds.Event.LABEL,vCard.getExtendedProperty(PROPERTY_EVENT_CUSTOM).getParameter(PARAMETER_EVENT_CUSTOM_LABEL));
    values.put(ContactsContract.CommonDataKinds.Event.START_DATE,vCard.getExtendedProperty(PROPERTY_EVENT_CUSTOM).getValue());
    valuesList.add(values);
  }
  return valuesList;
}","protected static List<ContentValues> getValuesForEvents(VCard vCard){
  List<ContentValues> valuesList=new LinkedList<ContentValues>();
  if (vCard.getBirthday() != null && vCard.getBirthday().getDate() != null) {
    SimpleDateFormat formatter=new SimpleDateFormat(""String_Node_Str"",Locale.US);
    String formatted=formatter.format(vCard.getBirthday().getDate());
    ContentValues values=new ContentValues();
    if (formatted.startsWith(""String_Node_Str""))     formatted=""String_Node_Str"" + formatted.substring(4);
    values.put(ContactsContract.Data.MIMETYPE,ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE);
    values.put(ContactsContract.CommonDataKinds.Event.TYPE,ContactsContract.CommonDataKinds.Event.TYPE_BIRTHDAY);
    values.put(ContactsContract.CommonDataKinds.Event.START_DATE,formatted);
    valuesList.add(values);
  }
  if (vCard.getExtendedProperty(PROPERTY_EVENT_ANNIVERSARY) != null) {
    ContentValues values=new ContentValues();
    values.put(ContactsContract.Data.MIMETYPE,ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE);
    values.put(ContactsContract.CommonDataKinds.Event.TYPE,ContactsContract.CommonDataKinds.Event.TYPE_ANNIVERSARY);
    values.put(ContactsContract.CommonDataKinds.Event.START_DATE,vCard.getExtendedProperty(PROPERTY_EVENT_ANNIVERSARY).getValue());
    valuesList.add(values);
  }
  if (vCard.getExtendedProperty(PROPERTY_EVENT_OTHER) != null) {
    ContentValues values=new ContentValues();
    values.put(ContactsContract.Data.MIMETYPE,ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE);
    values.put(ContactsContract.CommonDataKinds.Event.TYPE,ContactsContract.CommonDataKinds.Event.TYPE_OTHER);
    values.put(ContactsContract.CommonDataKinds.Event.START_DATE,vCard.getExtendedProperty(PROPERTY_EVENT_OTHER).getValue());
    valuesList.add(values);
  }
  if (vCard.getExtendedProperty(PROPERTY_EVENT_CUSTOM) != null) {
    ContentValues values=new ContentValues();
    values.put(ContactsContract.Data.MIMETYPE,ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE);
    values.put(ContactsContract.CommonDataKinds.Event.TYPE,ContactsContract.CommonDataKinds.Event.TYPE_CUSTOM);
    values.put(ContactsContract.CommonDataKinds.Event.LABEL,vCard.getExtendedProperty(PROPERTY_EVENT_CUSTOM).getParameter(PARAMETER_EVENT_CUSTOM_LABEL));
    values.put(ContactsContract.CommonDataKinds.Event.START_DATE,vCard.getExtendedProperty(PROPERTY_EVENT_CUSTOM).getValue());
    valuesList.add(values);
  }
  return valuesList;
}",0.9471084585305618
163833,"protected static void addEvent(String path,VCard vCard,ContentValues eventValues) throws InvalidComponentException {
  Integer eventType=eventValues.getAsInteger(ContactsContract.CommonDataKinds.Event.TYPE);
  String eventLabel=eventValues.getAsString(ContactsContract.CommonDataKinds.Event.LABEL);
  String eventStartDate=eventValues.getAsString(ContactsContract.CommonDataKinds.Event.START_DATE);
  SimpleDateFormat formatter=new SimpleDateFormat(""String_Node_Str"",Locale.US);
  if (eventType != null && eventStartDate != null) {
    try {
      if (eventType == ContactsContract.CommonDataKinds.Event.TYPE_BIRTHDAY) {
        Birthday birthday=new Birthday(formatter.parse(eventStartDate));
        vCard.setBirthday(birthday);
      }
    }
 catch (    ParseException e) {
      throw new InvalidComponentException(""String_Node_Str"",false,CardDavConstants.CARDDAV_NAMESPACE,path);
    }
    if (eventType == ContactsContract.CommonDataKinds.Event.TYPE_ANNIVERSARY)     vCard.setExtendedProperty(PROPERTY_EVENT_ANNIVERSARY,eventStartDate);
 else     if (eventType == ContactsContract.CommonDataKinds.Event.TYPE_OTHER)     vCard.setExtendedProperty(PROPERTY_EVENT_OTHER,eventStartDate);
 else     if (eventType == ContactsContract.CommonDataKinds.Event.TYPE_CUSTOM)     vCard.setExtendedProperty(PROPERTY_EVENT_CUSTOM,eventStartDate).setParameter(PARAMETER_EVENT_CUSTOM_LABEL,eventLabel);
  }
 else {
    Log.e(TAG,""String_Node_Str"");
    throw new InvalidComponentException(""String_Node_Str"",false,CardDavConstants.CARDDAV_NAMESPACE,path);
  }
}","protected static void addEvent(String path,VCard vCard,ContentValues eventValues) throws InvalidComponentException {
  Integer eventType=eventValues.getAsInteger(ContactsContract.CommonDataKinds.Event.TYPE);
  String eventLabel=eventValues.getAsString(ContactsContract.CommonDataKinds.Event.LABEL);
  String eventStartDate=eventValues.getAsString(ContactsContract.CommonDataKinds.Event.START_DATE);
  SimpleDateFormat formatter=new SimpleDateFormat(""String_Node_Str"",Locale.US);
  if (eventType != null && eventStartDate != null) {
    try {
      if (eventType == ContactsContract.CommonDataKinds.Event.TYPE_BIRTHDAY) {
        if (eventStartDate.startsWith(""String_Node_Str""))         eventStartDate=""String_Node_Str"" + eventStartDate.substring(1);
        Birthday birthday=new Birthday(formatter.parse(eventStartDate));
        vCard.setBirthday(birthday);
      }
    }
 catch (    ParseException e) {
      throw new InvalidComponentException(""String_Node_Str"",false,CardDavConstants.CARDDAV_NAMESPACE,path,e);
    }
    if (eventType == ContactsContract.CommonDataKinds.Event.TYPE_ANNIVERSARY)     vCard.setExtendedProperty(PROPERTY_EVENT_ANNIVERSARY,eventStartDate);
 else     if (eventType == ContactsContract.CommonDataKinds.Event.TYPE_OTHER)     vCard.setExtendedProperty(PROPERTY_EVENT_OTHER,eventStartDate);
 else     if (eventType == ContactsContract.CommonDataKinds.Event.TYPE_CUSTOM)     vCard.setExtendedProperty(PROPERTY_EVENT_CUSTOM,eventStartDate).setParameter(PARAMETER_EVENT_CUSTOM_LABEL,eventLabel);
  }
 else {
    Log.e(TAG,""String_Node_Str"");
    throw new InvalidComponentException(""String_Node_Str"",false,CardDavConstants.CARDDAV_NAMESPACE,path);
  }
}",0.9591078066914498
163834,"@Override public void onPerformSync(Account account,Bundle extras,String authority,ContentProviderClient provider,SyncResult syncResult){
  Log.d(TAG,""String_Node_Str"" + authority);
  Thread.currentThread().setContextClassLoader(getContext().getClassLoader());
  Optional<DavAccount> davAccountOptional=DavAccountHelper.getAccount(getContext());
  if (!davAccountOptional.isPresent()) {
    Log.d(TAG,""String_Node_Str"");
    syncResult.stats.numAuthExceptions++;
    showNotifications(syncResult);
    return;
  }
  try {
    Optional<MasterCipher> masterCipher=KeyHelper.getMasterCipher(getContext());
    if (!masterCipher.isPresent()) {
      Log.d(TAG,""String_Node_Str"");
      syncResult.stats.numAuthExceptions++;
      return;
    }
    LocalCalendarStore localStore=new LocalCalendarStore(provider,davAccountOptional.get().getOsAccount());
    HidingCalDavStore remoteStore=DavAccountHelper.getHidingCalDavStore(getContext(),davAccountOptional.get(),masterCipher.get());
    if (DavAccountHelper.isUsingOurServers(getContext())) {
      for (      HidingCalDavCollection remoteCollection : remoteStore.getCollections()) {
        try {
          if (!remoteCollection.getPath().contains(KeySyncUtil.PATH_KEY_COLLECTION) && !localStore.getCollection(remoteCollection.getPath()).isPresent()) {
            if (remoteCollection.getHiddenDisplayName().isPresent() && remoteCollection.getHiddenColor().isPresent()) {
              localStore.addCollection(remoteCollection.getPath(),remoteCollection.getHiddenDisplayName().get(),remoteCollection.getHiddenColor().get());
            }
 else             if (!remoteCollection.getHiddenDisplayName().isPresent())             localStore.addCollection(remoteCollection.getPath(),remoteCollection.getHiddenDisplayName().get());
 else             localStore.addCollection(remoteCollection.getPath());
          }
        }
 catch (        IOException e) {
          handleException(getContext(),e,syncResult);
        }
catch (        PropertyParseException e) {
          handleException(getContext(),e,syncResult);
        }
catch (        RemoteException e) {
          handleException(getContext(),e,syncResult);
        }
catch (        InvalidMacException e) {
          handleException(getContext(),e,syncResult);
        }
catch (        GeneralSecurityException e) {
          handleException(getContext(),e,syncResult);
        }
      }
    }
    for (    LocalEventCollection localCollection : localStore.getCollections()) {
      Log.d(TAG,""String_Node_Str"" + localCollection.getPath());
      Optional<HidingCalDavCollection> remoteCollection=remoteStore.getCollection(localCollection.getPath());
      if (remoteCollection.isPresent())       new CalendarSyncWorker(getContext(),localCollection,remoteCollection.get()).run(syncResult,false);
 else {
        Log.d(TAG,""String_Node_Str"");
        localStore.removeCollection(localCollection.getPath());
      }
    }
    finalizeCopiedCalendars(localStore,remoteStore);
    remoteStore.releaseConnections();
  }
 catch (  IOException e) {
    handleException(getContext(),e,syncResult);
  }
catch (  DavException e) {
    handleException(getContext(),e,syncResult);
  }
catch (  PropertyParseException e) {
    handleException(getContext(),e,syncResult);
  }
catch (  RemoteException e) {
    handleException(getContext(),e,syncResult);
  }
catch (  GeneralSecurityException e) {
    handleException(getContext(),e,syncResult);
  }
  showNotifications(syncResult);
  new CalendarsSyncScheduler(getContext()).setTimeLastSync(new Date().getTime());
}","@Override public void onPerformSync(Account account,Bundle extras,String authority,ContentProviderClient provider,SyncResult syncResult){
  Log.d(TAG,""String_Node_Str"" + authority);
  Thread.currentThread().setContextClassLoader(getContext().getClassLoader());
  Optional<DavAccount> davAccountOptional=DavAccountHelper.getAccount(getContext());
  if (!davAccountOptional.isPresent()) {
    Log.d(TAG,""String_Node_Str"");
    syncResult.stats.numAuthExceptions++;
    showNotifications(syncResult);
    return;
  }
  try {
    Optional<MasterCipher> masterCipher=KeyHelper.getMasterCipher(getContext());
    if (!masterCipher.isPresent()) {
      Log.d(TAG,""String_Node_Str"");
      syncResult.stats.numAuthExceptions++;
      return;
    }
    LocalCalendarStore localStore=new LocalCalendarStore(provider,davAccountOptional.get().getOsAccount());
    HidingCalDavStore remoteStore=DavAccountHelper.getHidingCalDavStore(getContext(),davAccountOptional.get(),masterCipher.get());
    if (DavAccountHelper.isUsingOurServers(getContext())) {
      for (      HidingCalDavCollection remoteCollection : remoteStore.getCollections()) {
        try {
          if (!remoteCollection.getPath().contains(KeySyncUtil.PATH_KEY_COLLECTION) && !localStore.getCollection(remoteCollection.getPath()).isPresent()) {
            if (remoteCollection.getHiddenDisplayName().isPresent() && remoteCollection.getHiddenColor().isPresent()) {
              localStore.addCollection(remoteCollection.getPath(),remoteCollection.getHiddenDisplayName().get(),remoteCollection.getHiddenColor().get());
            }
 else             if (remoteCollection.getHiddenDisplayName().isPresent())             localStore.addCollection(remoteCollection.getPath(),remoteCollection.getHiddenDisplayName().get());
 else             localStore.addCollection(remoteCollection.getPath());
          }
        }
 catch (        IOException e) {
          handleException(getContext(),e,syncResult);
        }
catch (        PropertyParseException e) {
          handleException(getContext(),e,syncResult);
        }
catch (        RemoteException e) {
          handleException(getContext(),e,syncResult);
        }
catch (        InvalidMacException e) {
          handleException(getContext(),e,syncResult);
        }
catch (        GeneralSecurityException e) {
          handleException(getContext(),e,syncResult);
        }
      }
    }
    for (    LocalEventCollection localCollection : localStore.getCollections()) {
      Log.d(TAG,""String_Node_Str"" + localCollection.getPath());
      Optional<HidingCalDavCollection> remoteCollection=remoteStore.getCollection(localCollection.getPath());
      if (remoteCollection.isPresent())       new CalendarSyncWorker(getContext(),localCollection,remoteCollection.get()).run(syncResult,false);
 else {
        Log.d(TAG,""String_Node_Str"");
        localStore.removeCollection(localCollection.getPath());
      }
    }
    finalizeCopiedCalendars(localStore,remoteStore);
    remoteStore.releaseConnections();
  }
 catch (  IOException e) {
    handleException(getContext(),e,syncResult);
  }
catch (  DavException e) {
    handleException(getContext(),e,syncResult);
  }
catch (  PropertyParseException e) {
    handleException(getContext(),e,syncResult);
  }
catch (  RemoteException e) {
    handleException(getContext(),e,syncResult);
  }
catch (  GeneralSecurityException e) {
    handleException(getContext(),e,syncResult);
  }
  showNotifications(syncResult);
  new CalendarsSyncScheduler(getContext()).setTimeLastSync(new Date().getTime());
}",0.9998594518622628
163835,"protected static List<ContentValues> getValuesForPostalAddresses(VCard vCard){
  List<ContentValues> valuesList=new LinkedList<ContentValues>();
  for (  ezvcard.property.Address address : vCard.getAddresses()) {
    ContentValues values=new ContentValues();
    values.put(ContactsContract.Data.MIMETYPE,ContactsContract.CommonDataKinds.StructuredPostal.CONTENT_ITEM_TYPE);
    if (address.getTypes().contains(AddressType.HOME))     values.put(ContactsContract.CommonDataKinds.StructuredPostal.TYPE,ContactsContract.CommonDataKinds.StructuredPostal.TYPE_HOME);
 else     if (address.getTypes().contains(AddressType.WORK))     values.put(ContactsContract.CommonDataKinds.StructuredPostal.TYPE,ContactsContract.CommonDataKinds.StructuredPostal.TYPE_WORK);
 else     if (!address.getTypes().isEmpty()) {
      values.put(ContactsContract.CommonDataKinds.StructuredPostal.TYPE,ContactsContract.CommonDataKinds.StructuredPostal.TYPE_CUSTOM);
      values.put(ContactsContract.CommonDataKinds.StructuredPostal.LABEL,propertyNameToLabel(address.getTypes().iterator().next().getValue()));
    }
 else     values.put(ContactsContract.CommonDataKinds.StructuredPostal.TYPE,ContactsContract.CommonDataKinds.StructuredPostal.TYPE_OTHER);
    String formattedAddress=address.getLabel();
    if (StringUtils.isEmpty(address.getLabel())) {
      String lineStreet=StringUtils.join(new String[]{address.getStreetAddress(),address.getPoBox(),address.getExtendedAddress()},""String_Node_Str"");
      String lineLocality=StringUtils.join(new String[]{address.getPostalCode(),address.getLocality()},""String_Node_Str"");
      List<String> lines=new LinkedList<String>();
      if (lineStreet != null)       lines.add(lineStreet);
      if (address.getRegion() != null && !address.getRegion().isEmpty())       lines.add(address.getRegion());
      if (lineLocality != null)       lines.add(lineLocality);
      formattedAddress=StringUtils.join(lines,""String_Node_Str"");
    }
    values.put(ContactsContract.CommonDataKinds.StructuredPostal.FORMATTED_ADDRESS,formattedAddress);
    values.put(ContactsContract.CommonDataKinds.StructuredPostal.STREET,address.getStreetAddress());
    values.put(ContactsContract.CommonDataKinds.StructuredPostal.POBOX,address.getPoBox());
    values.put(ContactsContract.CommonDataKinds.StructuredPostal.NEIGHBORHOOD,address.getExtendedAddress());
    values.put(ContactsContract.CommonDataKinds.StructuredPostal.CITY,address.getLocality());
    values.put(ContactsContract.CommonDataKinds.StructuredPostal.REGION,address.getRegion());
    values.put(ContactsContract.CommonDataKinds.StructuredPostal.POSTCODE,address.getPostalCode());
    values.put(ContactsContract.CommonDataKinds.StructuredPostal.COUNTRY,address.getCountry());
    valuesList.add(values);
  }
  return valuesList;
}","protected static List<ContentValues> getValuesForPostalAddresses(VCard vCard){
  List<ContentValues> valuesList=new LinkedList<ContentValues>();
  for (  ezvcard.property.Address address : vCard.getAddresses()) {
    ContentValues values=new ContentValues();
    values.put(ContactsContract.Data.MIMETYPE,ContactsContract.CommonDataKinds.StructuredPostal.CONTENT_ITEM_TYPE);
    if (address.getTypes().contains(AddressType.HOME))     values.put(ContactsContract.CommonDataKinds.StructuredPostal.TYPE,ContactsContract.CommonDataKinds.StructuredPostal.TYPE_HOME);
 else     if (address.getTypes().contains(AddressType.WORK))     values.put(ContactsContract.CommonDataKinds.StructuredPostal.TYPE,ContactsContract.CommonDataKinds.StructuredPostal.TYPE_WORK);
 else     if (!address.getTypes().isEmpty()) {
      values.put(ContactsContract.CommonDataKinds.StructuredPostal.TYPE,ContactsContract.CommonDataKinds.StructuredPostal.TYPE_CUSTOM);
      values.put(ContactsContract.CommonDataKinds.StructuredPostal.LABEL,propertyNameToLabel(address.getTypes().iterator().next().getValue()));
    }
 else     values.put(ContactsContract.CommonDataKinds.StructuredPostal.TYPE,ContactsContract.CommonDataKinds.StructuredPostal.TYPE_OTHER);
    if (address.getLabel() != null) {
      try {
        String formattedAddress=new String(Base64.decode(address.getLabel()));
        values.put(ContactsContract.CommonDataKinds.StructuredPostal.FORMATTED_ADDRESS,formattedAddress);
        values.put(ContactsContract.CommonDataKinds.StructuredPostal.STREET,address.getStreetAddress());
        values.put(ContactsContract.CommonDataKinds.StructuredPostal.POBOX,address.getPoBox());
        values.put(ContactsContract.CommonDataKinds.StructuredPostal.NEIGHBORHOOD,address.getExtendedAddress());
        values.put(ContactsContract.CommonDataKinds.StructuredPostal.CITY,address.getLocality());
        values.put(ContactsContract.CommonDataKinds.StructuredPostal.REGION,address.getRegion());
        values.put(ContactsContract.CommonDataKinds.StructuredPostal.POSTCODE,address.getPostalCode());
        values.put(ContactsContract.CommonDataKinds.StructuredPostal.COUNTRY,address.getCountry());
        valuesList.add(values);
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"");
      }
    }
  }
  return valuesList;
}",0.8199921905505662
163836,"protected static void addPostalAddress(String path,VCard vCard,ContentValues addressValues) throws InvalidComponentException {
  Integer addressType=addressValues.getAsInteger(ContactsContract.CommonDataKinds.StructuredPostal.TYPE);
  String formattedAddress=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.FORMATTED_ADDRESS);
  String label=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.LABEL);
  String street=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.STREET);
  String poBox=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.POBOX);
  String neighborhood=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.NEIGHBORHOOD);
  String city=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.CITY);
  String region=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.REGION);
  String postcode=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.POBOX);
  String country=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.COUNTRY);
  if (addressType != null && formattedAddress != null) {
    Address address=new Address();
    address.setLabel(formattedAddress);
switch (addressType) {
case ContactsContract.CommonDataKinds.StructuredPostal.TYPE_HOME:
      address.addType(AddressType.HOME);
    break;
case ContactsContract.CommonDataKinds.StructuredPostal.TYPE_WORK:
  address.addType(AddressType.WORK);
break;
case ContactsContract.CommonDataKinds.StructuredPostal.TYPE_CUSTOM:
if (label != null) AddressType.get(label);
break;
}
if (street != null) address.setStreetAddress(street);
if (poBox != null) address.setPoBox(poBox);
if (neighborhood != null) address.setExtendedAddress(neighborhood);
if (city != null) address.setLocality(city);
if (region != null) address.setRegion(region);
if (postcode != null) address.setPostalCode(postcode);
if (country != null) address.setCountry(country);
vCard.addAddress(address);
}
 else {
Log.e(TAG,""String_Node_Str"");
throw new InvalidComponentException(""String_Node_Str"",false,CardDavConstants.CARDDAV_NAMESPACE,path);
}
}","protected static void addPostalAddress(String path,VCard vCard,ContentValues addressValues) throws InvalidComponentException {
  Integer addressType=addressValues.getAsInteger(ContactsContract.CommonDataKinds.StructuredPostal.TYPE);
  String formattedAddress=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.FORMATTED_ADDRESS);
  String label=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.LABEL);
  String street=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.STREET);
  String poBox=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.POBOX);
  String neighborhood=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.NEIGHBORHOOD);
  String city=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.CITY);
  String region=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.REGION);
  String postcode=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.POBOX);
  String country=addressValues.getAsString(ContactsContract.CommonDataKinds.StructuredPostal.COUNTRY);
  if (addressType != null && formattedAddress != null) {
    Address address=new Address();
    address.setLabel(Base64.encodeBytes(formattedAddress.getBytes()));
switch (addressType) {
case ContactsContract.CommonDataKinds.StructuredPostal.TYPE_HOME:
      address.addType(AddressType.HOME);
    break;
case ContactsContract.CommonDataKinds.StructuredPostal.TYPE_WORK:
  address.addType(AddressType.WORK);
break;
case ContactsContract.CommonDataKinds.StructuredPostal.TYPE_CUSTOM:
if (label != null) AddressType.get(label);
break;
}
if (street != null) address.setStreetAddress(street);
if (poBox != null) address.setPoBox(poBox);
if (neighborhood != null) address.setExtendedAddress(neighborhood);
if (city != null) address.setLocality(city);
if (region != null) address.setRegion(region);
if (postcode != null) address.setPostalCode(postcode);
if (country != null) address.setCountry(country);
vCard.addAddress(address);
}
 else {
Log.e(TAG,""String_Node_Str"");
throw new InvalidComponentException(""String_Node_Str"",false,CardDavConstants.CARDDAV_NAMESPACE,path);
}
}",0.993029008320216
163837,"public static void importSaltAndEncryptedKeyMaterial(Context context,String[] saltAndEncryptedKeyMaterial) throws GeneralSecurityException, InvalidMacException, IOException {
  Log.d(TAG,""String_Node_Str"");
  Optional<String> masterPassphrase=KeyStore.getMasterPassphrase(context);
  if (!masterPassphrase.isPresent())   throw new InvalidMacException(""String_Node_Str"");
  byte[] salt=Base64.decode(saltAndEncryptedKeyMaterial[0]);
  SecretKey[] masterKeys=KeyUtil.getCipherAndMacKeysForPassphrase(salt,masterPassphrase.get());
  SecretKey masterCipherKey=masterKeys[0];
  SecretKey masterMacKey=masterKeys[1];
  MasterCipher masterCipher=new MasterCipher(masterCipherKey,masterMacKey);
  byte[] plaintextKeyMaterial=masterCipher.decodeAndDecrypt(saltAndEncryptedKeyMaterial[1].getBytes());
  boolean saltLengthValid=salt.length == KeyUtil.SALT_LENGTH_BYTES;
  boolean keyMaterialLengthValid=plaintextKeyMaterial.length == (KeyUtil.CIPHER_KEY_LENGTH_BYTES + KeyUtil.MAC_KEY_LENGTH_BYTES);
  if (!saltLengthValid || !keyMaterialLengthValid)   throw new GeneralSecurityException(""String_Node_Str"" + saltLengthValid + ""String_Node_Str""+ keyMaterialLengthValid);
  byte[] plaintextCipherKey=Arrays.copyOfRange(plaintextKeyMaterial,0,KeyUtil.CIPHER_KEY_LENGTH_BYTES);
  byte[] plaintextMacKey=Arrays.copyOfRange(plaintextKeyMaterial,KeyUtil.CIPHER_KEY_LENGTH_BYTES,plaintextCipherKey.length);
  KeyStore.saveEncryptedKeyMaterial(context,saltAndEncryptedKeyMaterial[1]);
  KeyStore.saveKeyMaterialSalt(context,salt);
  KeyStore.saveCipherKey(context,plaintextCipherKey);
  KeyStore.saveMacKey(context,plaintextMacKey);
}","public static void importSaltAndEncryptedKeyMaterial(Context context,String[] saltAndEncryptedKeyMaterial) throws GeneralSecurityException, InvalidMacException, IOException {
  Log.d(TAG,""String_Node_Str"");
  Optional<String> masterPassphrase=KeyStore.getMasterPassphrase(context);
  if (!masterPassphrase.isPresent())   throw new InvalidMacException(""String_Node_Str"");
  byte[] salt=Base64.decode(saltAndEncryptedKeyMaterial[0]);
  SecretKey[] masterKeys=KeyUtil.getCipherAndMacKeysForPassphrase(salt,masterPassphrase.get());
  SecretKey masterCipherKey=masterKeys[0];
  SecretKey masterMacKey=masterKeys[1];
  MasterCipher masterCipher=new MasterCipher(masterCipherKey,masterMacKey);
  byte[] plaintextKeyMaterial=masterCipher.decodeAndDecrypt(saltAndEncryptedKeyMaterial[1].getBytes());
  boolean saltLengthValid=salt.length == KeyUtil.SALT_LENGTH_BYTES;
  boolean keyMaterialLengthValid=plaintextKeyMaterial.length == (KeyUtil.CIPHER_KEY_LENGTH_BYTES + KeyUtil.MAC_KEY_LENGTH_BYTES);
  if (!saltLengthValid || !keyMaterialLengthValid)   throw new GeneralSecurityException(""String_Node_Str"" + saltLengthValid + ""String_Node_Str""+ keyMaterialLengthValid);
  byte[] plaintextCipherKey=Arrays.copyOfRange(plaintextKeyMaterial,0,KeyUtil.CIPHER_KEY_LENGTH_BYTES);
  byte[] plaintextMacKey=Arrays.copyOfRange(plaintextKeyMaterial,KeyUtil.CIPHER_KEY_LENGTH_BYTES,KeyUtil.CIPHER_KEY_LENGTH_BYTES + KeyUtil.MAC_KEY_LENGTH_BYTES);
  KeyStore.saveEncryptedKeyMaterial(context,saltAndEncryptedKeyMaterial[1]);
  KeyStore.saveKeyMaterialSalt(context,salt);
  KeyStore.saveCipherKey(context,plaintextCipherKey);
  KeyStore.saveMacKey(context,plaintextMacKey);
}",0.9739663093415007
163838,"private void handleUpdateLayout(){
  final String timeLastSyncText;
  final String syncStatusText;
  final int syncStatusDrawable;
  if (timeLastSync == -1) {
    timeLastSyncView.setVisibility(GONE);
    syncStatusView.setText(getContext().getString(R.string.status_header_sync_in_progress));
    syncStatusView.setCompoundDrawablesWithIntrinsicBounds(0,R.drawable.sync_in_progress,0,0);
    invalidate();
    return;
  }
 else {
    DateFormat formatter=DateFormat.getDateTimeInstance();
    timeLastSyncText=formatter.format(new Date(timeLastSync));
    timeLastSyncView.setText(getContext().getString(R.string.status_header_sync_time,timeLastSyncText));
    timeLastSyncView.setVisibility(VISIBLE);
  }
  if (syncServerHasError) {
    if (account.isPresent() && DavAccountHelper.isUsingOurServers(account.get()))     syncStatusText=getContext().getString(R.string.status_header_status_our_sync_service_error);
 else     syncStatusText=getContext().getString(R.string.status_header_status_their_sync_service_error);
    syncStatusDrawable=R.drawable.sad_cloud;
  }
 else   if (registrationServerHasError) {
    syncStatusText=getContext().getString(R.string.status_header_status_registration_service_error);
    syncStatusDrawable=R.drawable.sad_cloud;
  }
 else   if (!DavAccountHelper.getAccountPassword(getContext()).isPresent()) {
    syncStatusText=getContext().getString(R.string.status_header_status_account_login_failed);
    syncStatusDrawable=R.drawable.sad_cloud;
    if (!authNotificationShown) {
      AbstractDavSyncAdapter.showAuthNotificationAndInvalidatePassword(getContext());
      authNotificationShown=true;
    }
  }
 else   if (!cipherPassphraseIsValid) {
    syncStatusText=getContext().getString(R.string.status_header_status_encryption_password_incorrect);
    syncStatusDrawable=R.drawable.sad_cloud;
  }
 else   if (!subscriptionIsValid) {
    syncStatusText=getContext().getString(R.string.notification_flock_subscription_expired);
    syncStatusDrawable=R.drawable.sad_cloud;
    if (!subscriptionNotificationShown) {
      AbstractDavSyncAdapter.showSubscriptionExpiredNotification(getContext());
      subscriptionNotificationShown=true;
    }
  }
 else   if (!cardIsValid) {
    syncStatusText=getContext().getString(R.string.status_header_status_auto_renew_error);
    syncStatusDrawable=R.drawable.sad_cloud;
  }
 else   if (!ContentResolver.getMasterSyncAutomatically()) {
    syncStatusText=getContext().getString(R.string.status_header_status_sync_disabled);
    syncStatusDrawable=R.drawable.sad_cloud;
  }
 else   if (syncInProgress) {
    syncStatusText=getContext().getString(R.string.status_header_sync_in_progress);
    syncStatusDrawable=R.drawable.sync_in_progress;
  }
 else {
    syncStatusText=getContext().getString(R.string.status_header_status_good);
    syncStatusDrawable=R.drawable.happy_cloud;
  }
  syncStatusView.setText(syncStatusText);
  syncStatusView.setCompoundDrawablesWithIntrinsicBounds(0,syncStatusDrawable,0,0);
  invalidate();
}","private void handleUpdateLayout(){
  final String timeLastSyncText;
  final String syncStatusText;
  final int syncStatusDrawable;
  if (timeLastSync == -1) {
    if (!ContentResolver.getMasterSyncAutomatically()) {
      syncStatusView.setText(getContext().getString(R.string.status_header_status_sync_disabled));
      syncStatusView.setCompoundDrawablesWithIntrinsicBounds(0,R.drawable.sad_cloud,0,0);
    }
 else {
      syncStatusView.setText(getContext().getString(R.string.status_header_sync_in_progress));
      syncStatusView.setCompoundDrawablesWithIntrinsicBounds(0,R.drawable.sync_in_progress,0,0);
    }
    timeLastSyncView.setVisibility(GONE);
    invalidate();
    return;
  }
 else {
    DateFormat formatter=DateFormat.getDateTimeInstance();
    timeLastSyncText=formatter.format(new Date(timeLastSync));
    timeLastSyncView.setText(getContext().getString(R.string.status_header_sync_time,timeLastSyncText));
    timeLastSyncView.setVisibility(VISIBLE);
  }
  if (syncServerHasError) {
    if (account.isPresent() && DavAccountHelper.isUsingOurServers(account.get()))     syncStatusText=getContext().getString(R.string.status_header_status_our_sync_service_error);
 else     syncStatusText=getContext().getString(R.string.status_header_status_their_sync_service_error);
    syncStatusDrawable=R.drawable.sad_cloud;
  }
 else   if (registrationServerHasError) {
    syncStatusText=getContext().getString(R.string.status_header_status_registration_service_error);
    syncStatusDrawable=R.drawable.sad_cloud;
  }
 else   if (!DavAccountHelper.getAccountPassword(getContext()).isPresent()) {
    syncStatusText=getContext().getString(R.string.status_header_status_account_login_failed);
    syncStatusDrawable=R.drawable.sad_cloud;
    if (!authNotificationShown) {
      AbstractDavSyncAdapter.showAuthNotificationAndInvalidatePassword(getContext());
      authNotificationShown=true;
    }
  }
 else   if (!cipherPassphraseIsValid) {
    syncStatusText=getContext().getString(R.string.status_header_status_encryption_password_incorrect);
    syncStatusDrawable=R.drawable.sad_cloud;
  }
 else   if (!subscriptionIsValid) {
    syncStatusText=getContext().getString(R.string.notification_flock_subscription_expired);
    syncStatusDrawable=R.drawable.sad_cloud;
    if (!subscriptionNotificationShown) {
      AbstractDavSyncAdapter.showSubscriptionExpiredNotification(getContext());
      subscriptionNotificationShown=true;
    }
  }
 else   if (!cardIsValid) {
    syncStatusText=getContext().getString(R.string.status_header_status_auto_renew_error);
    syncStatusDrawable=R.drawable.sad_cloud;
  }
 else   if (!ContentResolver.getMasterSyncAutomatically()) {
    syncStatusText=getContext().getString(R.string.status_header_status_sync_disabled);
    syncStatusDrawable=R.drawable.sad_cloud;
  }
 else   if (syncInProgress) {
    syncStatusText=getContext().getString(R.string.status_header_sync_in_progress);
    syncStatusDrawable=R.drawable.sync_in_progress;
  }
 else {
    syncStatusText=getContext().getString(R.string.status_header_status_good);
    syncStatusDrawable=R.drawable.happy_cloud;
  }
  syncStatusView.setText(syncStatusText);
  syncStatusView.setCompoundDrawablesWithIntrinsicBounds(0,syncStatusDrawable,0,0);
  invalidate();
}",0.1125996810207336
163839,"@Override public void onDestroy(){
  Log.d(TAG,""String_Node_Str"");
  if (countEventCopiesFailed == 0) {
    notificationBuilder.setProgress(0,0,false).setContentText(getString(R.string.notification_import_complete_copied) + ""String_Node_Str"" + countEventsCopied+ ""String_Node_Str""+ getString(R.string.events)+ getString(R.string.period));
  }
 else {
    notificationBuilder.setProgress(0,0,false).setContentText(getString(R.string.notification_import_complete_copied) + ""String_Node_Str"" + countEventCopiesFailed+ ""String_Node_Str""+ getString(R.string.events)+ ""String_Node_Str""+ countEventCopiesFailed+ ""String_Node_Str""+ getString(R.string.failed)+ getString(R.string.period));
  }
  notifyManager.notify(ID_CALENDAR_COPY_NOTIFICATION,notificationBuilder.build());
}","@Override public void onDestroy(){
  Log.d(TAG,""String_Node_Str"");
  if (countEventCopiesFailed == 0) {
    notificationBuilder.setProgress(0,0,false).setContentText(getString(R.string.notification_import_complete_copied) + ""String_Node_Str"" + countEventsCopied+ ""String_Node_Str""+ getString(R.string.events)+ getString(R.string.period));
  }
 else {
    notificationBuilder.setProgress(0,0,false).setContentText(getString(R.string.notification_import_complete_copied) + ""String_Node_Str"" + countEventsCopied+ ""String_Node_Str""+ getString(R.string.events)+ ""String_Node_Str""+ countEventCopiesFailed+ ""String_Node_Str""+ getString(R.string.failed)+ getString(R.string.period));
  }
  notifyManager.notify(ID_CALENDAR_COPY_NOTIFICATION,notificationBuilder.build());
}",0.9902152641878668
163840,"protected static void handleDisplayToastBundledError(Context context,Bundle bundle){
  final int ERROR_CODE=bundle.getInt(KEY_STATUS_CODE,-1);
switch (ERROR_CODE) {
case CODE_UNAUTHORIZED:
    handleShowUnauthorizedError(context);
  break;
case CODE_REGISTRATION_API_SERVER_ERROR:
handleShowRegistrationApiServerError(context);
break;
case CODE_REGISTRATION_API_CLIENT_ERROR:
handleShowRegistrationApiClientError(context);
break;
case CODE_DAV_SERVER_ERROR:
handleShowDavServerError(context);
break;
case CODE_DAV_CLIENT_ERROR:
handleShowDavClientError(context);
break;
case CODE_CONNECTION_ERROR:
handleShowConnectionError(context);
break;
case CODE_CERTIFICATE_ERROR:
handleShowCertificateError(context);
break;
case CODE_UNKNOWN_IO_ERROR:
handleShowUnknownIoError(context);
break;
case CODE_INVALID_CIPHER_PASSPHRASE:
handleShowInvalidCipherPassphraseError(context);
break;
case CODE_INVALID_MAC_ERROR:
handleShowInvalidMacErrorError(context);
break;
case CODE_CRYPTO_ERROR:
handleShowCryptoError(context);
break;
case CODE_EMPTY_DAV_URL:
handleShowDavUrlEmpty(context);
break;
case CODE_EMPTY_ACCOUNT_ID:
handleShowAccountIdEmpty(context);
break;
case CODE_ILLEGAL_ACCOUNT_ID:
handleShowIllegalAccountId(context);
break;
case CODE_ACCOUNT_ID_TAKEN:
handleShowAccountIdTaken(context);
break;
case CODE_SHORT_PASSWORD:
handleShowAccountPasswordTooShort(context);
break;
case CODE_PASSWORDS_DO_NOT_MATCH:
handleShowPasswordsDoNotMatch(context);
break;
case CODE_CARD_NUMBER_INVALID:
handleShowCardNumberInvalid(context);
break;
case CODE_CARD_EXPIRATION_INVALID:
handleShowCardExpirationInvalid(context);
break;
case CODE_CARD_CVC_INVALID:
handleShowCardCVCInvalid(context);
break;
case CODE_STRIPE_REJECTED_CARD:
handleShowStripeRejectedCard(context);
break;
case CODE_STRIPE_CONNECTION_ERROR:
handleShowStripeConnectionError(context);
break;
case CODE_STRIPE_API_ERROR:
handleShowStripeApiError(context);
break;
case CODE_SUBSCRIPTION_EXPIRED:
handleShowSubscriptionExpired(context);
break;
case CODE_ACCOUNT_MANAGER_ERROR:
handleShowAccountManagerError(context);
break;
}
}","protected static void handleDisplayToastBundledError(Context context,Bundle bundle){
  final int ERROR_CODE=bundle.getInt(KEY_STATUS_CODE,-1);
switch (ERROR_CODE) {
case CODE_UNAUTHORIZED:
    handleShowUnauthorizedError(context);
  break;
case CODE_REGISTRATION_API_SERVER_ERROR:
handleShowRegistrationApiServerError(context);
break;
case CODE_REGISTRATION_API_CLIENT_ERROR:
handleShowRegistrationApiClientError(context);
break;
case CODE_DAV_SERVER_ERROR:
handleShowDavServerError(context);
break;
case CODE_DAV_CLIENT_ERROR:
handleShowDavClientError(context);
break;
case CODE_CONNECTION_ERROR:
handleShowConnectionError(context);
break;
case CODE_CERTIFICATE_ERROR:
handleShowCertificateError(context);
break;
case CODE_UNKNOWN_IO_ERROR:
handleShowUnknownIoError(context);
break;
case CODE_INVALID_CIPHER_PASSPHRASE:
handleShowInvalidCipherPassphraseError(context);
break;
case CODE_INVALID_MAC_ERROR:
handleShowInvalidMacErrorError(context);
break;
case CODE_CRYPTO_ERROR:
handleShowCryptoError(context);
break;
case CODE_EMPTY_DAV_URL:
handleShowDavUrlEmpty(context);
break;
case CODE_EMPTY_ACCOUNT_ID:
handleShowAccountIdEmpty(context);
break;
case CODE_SPACES_IN_USERNAME:
handleShowSpacesInAccountId(context);
break;
case CODE_ILLEGAL_ACCOUNT_ID:
handleShowIllegalAccountId(context);
break;
case CODE_ACCOUNT_ID_TAKEN:
handleShowAccountIdTaken(context);
break;
case CODE_SHORT_PASSWORD:
handleShowAccountPasswordTooShort(context);
break;
case CODE_PASSWORDS_DO_NOT_MATCH:
handleShowPasswordsDoNotMatch(context);
break;
case CODE_CARD_NUMBER_INVALID:
handleShowCardNumberInvalid(context);
break;
case CODE_CARD_EXPIRATION_INVALID:
handleShowCardExpirationInvalid(context);
break;
case CODE_CARD_CVC_INVALID:
handleShowCardCVCInvalid(context);
break;
case CODE_STRIPE_REJECTED_CARD:
handleShowStripeRejectedCard(context);
break;
case CODE_STRIPE_CONNECTION_ERROR:
handleShowStripeConnectionError(context);
break;
case CODE_STRIPE_API_ERROR:
handleShowStripeApiError(context);
break;
case CODE_SUBSCRIPTION_EXPIRED:
handleShowSubscriptionExpired(context);
break;
case CODE_ACCOUNT_MANAGER_ERROR:
handleShowAccountManagerError(context);
break;
}
}",0.9822653109482148
163841,"private void registerAccountAsync(){
  if (messageHandler != null && messageHandler.serviceStarted)   return;
 else   if (messageHandler == null)   messageHandler=new MessageHandler(setupActivity,this);
  Bundle result=new Bundle();
  String username=((EditText)getActivity().findViewById(R.id.account_username)).getText().toString().trim();
  String password=((EditText)getActivity().findViewById(R.id.cipher_passphrase)).getText().toString().trim();
  String passwordRepeat=((EditText)getActivity().findViewById(R.id.cipher_passphrase_repeat)).getText().toString().trim();
  if (StringUtils.isEmpty(username)) {
    result.putInt(ErrorToaster.KEY_STATUS_CODE,ErrorToaster.CODE_EMPTY_ACCOUNT_ID);
    ErrorToaster.handleDisplayToastBundledError(getActivity(),result);
    return;
  }
  if (StringUtils.isEmpty(password)) {
    result.putInt(ErrorToaster.KEY_STATUS_CODE,ErrorToaster.CODE_SHORT_PASSWORD);
    ErrorToaster.handleDisplayToastBundledError(getActivity(),result);
    ((TextView)getActivity().findViewById(R.id.cipher_passphrase)).setText(""String_Node_Str"");
    ((TextView)getActivity().findViewById(R.id.cipher_passphrase_repeat)).setText(""String_Node_Str"");
    return;
  }
  if (StringUtils.isEmpty(passwordRepeat) || !password.equals(passwordRepeat)) {
    result.putInt(ErrorToaster.KEY_STATUS_CODE,ErrorToaster.CODE_PASSWORDS_DO_NOT_MATCH);
    ErrorToaster.handleDisplayToastBundledError(getActivity(),result);
    ((TextView)getActivity().findViewById(R.id.cipher_passphrase)).setText(""String_Node_Str"");
    ((TextView)getActivity().findViewById(R.id.cipher_passphrase_repeat)).setText(""String_Node_Str"");
    return;
  }
  username=DavAccountHelper.correctUsername(getActivity(),username);
  Intent importService=new Intent(getActivity(),RegisterAccountService.class);
  importService.putExtra(RegisterAccountService.KEY_MESSENGER,new Messenger(messageHandler));
  importService.putExtra(RegisterAccountService.KEY_ACCOUNT_ID,username);
  importService.putExtra(RegisterAccountService.KEY_MASTER_PASSPHRASE,password);
  getActivity().startService(importService);
  messageHandler.serviceStarted=true;
  setupActivity.setNavigationDisabled(true);
  getActivity().setProgressBarIndeterminateVisibility(true);
  getActivity().setProgressBarVisibility(true);
}","private void registerAccountAsync(){
  if (messageHandler != null && messageHandler.serviceStarted)   return;
 else   if (messageHandler == null)   messageHandler=new MessageHandler(setupActivity,this);
  Bundle result=new Bundle();
  String username=((EditText)getActivity().findViewById(R.id.account_username)).getText().toString().trim();
  String password=((EditText)getActivity().findViewById(R.id.cipher_passphrase)).getText().toString().trim();
  String passwordRepeat=((EditText)getActivity().findViewById(R.id.cipher_passphrase_repeat)).getText().toString().trim();
  if (StringUtils.isEmpty(username)) {
    result.putInt(ErrorToaster.KEY_STATUS_CODE,ErrorToaster.CODE_EMPTY_ACCOUNT_ID);
    ErrorToaster.handleDisplayToastBundledError(getActivity(),result);
    return;
  }
  if (username.contains(""String_Node_Str"")) {
    result.putInt(ErrorToaster.KEY_STATUS_CODE,ErrorToaster.CODE_SPACES_IN_USERNAME);
    ErrorToaster.handleDisplayToastBundledError(getActivity(),result);
    return;
  }
  if (StringUtils.isEmpty(password)) {
    result.putInt(ErrorToaster.KEY_STATUS_CODE,ErrorToaster.CODE_SHORT_PASSWORD);
    ErrorToaster.handleDisplayToastBundledError(getActivity(),result);
    ((TextView)getActivity().findViewById(R.id.cipher_passphrase)).setText(""String_Node_Str"");
    ((TextView)getActivity().findViewById(R.id.cipher_passphrase_repeat)).setText(""String_Node_Str"");
    return;
  }
  if (StringUtils.isEmpty(passwordRepeat) || !password.equals(passwordRepeat)) {
    result.putInt(ErrorToaster.KEY_STATUS_CODE,ErrorToaster.CODE_PASSWORDS_DO_NOT_MATCH);
    ErrorToaster.handleDisplayToastBundledError(getActivity(),result);
    ((TextView)getActivity().findViewById(R.id.cipher_passphrase)).setText(""String_Node_Str"");
    ((TextView)getActivity().findViewById(R.id.cipher_passphrase_repeat)).setText(""String_Node_Str"");
    return;
  }
  username=DavAccountHelper.correctUsername(getActivity(),username);
  Intent importService=new Intent(getActivity(),RegisterAccountService.class);
  importService.putExtra(RegisterAccountService.KEY_MESSENGER,new Messenger(messageHandler));
  importService.putExtra(RegisterAccountService.KEY_ACCOUNT_ID,username);
  importService.putExtra(RegisterAccountService.KEY_MASTER_PASSPHRASE,password);
  getActivity().startService(importService);
  messageHandler.serviceStarted=true;
  setupActivity.setNavigationDisabled(true);
  getActivity().setProgressBarIndeterminateVisibility(true);
  getActivity().setProgressBarVisibility(true);
}",0.9541745134965474
163842,"@SuppressWarnings(""String_Node_Str"") private byte[] readAll(InputStream in) throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  byte[] buffer=new byte[4096];
  int length;
  while ((length=in.read(buffer)) > 0) {
    baos.write(buffer,0,length);
  }
  return baos.toByteArray();
}","@SuppressWarnings(""String_Node_Str"") private byte[] readAll(InputStream in) throws IOException {
  if (in == null) {
    return new byte[0];
  }
 else {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    byte[] buffer=new byte[4096];
    int length;
    while ((length=in.read(buffer)) > 0) {
      baos.write(buffer,0,length);
    }
    return baos.toByteArray();
  }
}",0.8583815028901735
163843,"private void updateMetrics(String name,GcInfo info){
  final Map<String,MemoryUsage> before=info.getMemoryUsageBeforeGc();
  final Map<String,MemoryUsage> after=info.getMemoryUsageAfterGc();
  if (oldGenPoolName != null) {
    final long oldBefore=before.get(oldGenPoolName).getUsed();
    final long oldAfter=after.get(oldGenPoolName).getUsed();
    final long delta=oldAfter - oldBefore;
    if (delta > 0L) {
      PROMOTION_RATE.increment(delta);
    }
    if (HelperFunctions.getGcType(name) == GcType.OLD) {
      LIVE_DATA_SIZE.set(oldAfter);
      final long oldMaxAfter=after.get(oldGenPoolName).getMax();
      MAX_DATA_SIZE.set(oldMaxAfter);
    }
  }
  if (youngGenPoolName != null) {
    final long youngBefore=before.get(youngGenPoolName).getUsed();
    final long youngAfter=after.get(youngGenPoolName).getUsed();
    final long delta=youngBefore - youngGenSizeAfter;
    youngGenSizeAfter=youngAfter;
    if (delta > 0L) {
      ALLOCATION_RATE.increment(delta);
    }
  }
}","private void updateMetrics(String name,GcInfo info){
  final Map<String,MemoryUsage> before=info.getMemoryUsageBeforeGc();
  final Map<String,MemoryUsage> after=info.getMemoryUsageAfterGc();
  if (oldGenPoolName != null) {
    final long oldBefore=before.get(oldGenPoolName).getUsed();
    final long oldAfter=after.get(oldGenPoolName).getUsed();
    final long delta=oldAfter - oldBefore;
    if (delta > 0L) {
      PROMOTION_RATE.increment(delta);
    }
    if (oldAfter < oldBefore || HelperFunctions.getGcType(name) == GcType.OLD) {
      LIVE_DATA_SIZE.set(oldAfter);
      final long oldMaxAfter=after.get(oldGenPoolName).getMax();
      MAX_DATA_SIZE.set(oldMaxAfter);
    }
  }
  if (youngGenPoolName != null) {
    final long youngBefore=before.get(youngGenPoolName).getUsed();
    final long youngAfter=after.get(youngGenPoolName).getUsed();
    final long delta=youngBefore - youngGenSizeAfter;
    youngGenSizeAfter=youngAfter;
    if (delta > 0L) {
      ALLOCATION_RATE.increment(delta);
    }
  }
}",0.9880239520958084
163844,"private static HashSet<Badge> restore(Bundle bundle){
  HashSet<Badge> badges=new HashSet<Badge>();
  if (bundle == null)   return badges;
  String[] names=bundle.getStringArray(BADGES);
  for (int i=0; i < names.length; i++) {
    try {
      if (!removedBadges.contains(names[i])) {
        badges.add(Badge.valueOf(names[i]));
      }
    }
 catch (    Exception e) {
      ShatteredPixelDungeon.reportException(e);
    }
  }
  return badges;
}","private static HashSet<Badge> restore(Bundle bundle){
  HashSet<Badge> badges=new HashSet<Badge>();
  if (bundle == null)   return badges;
  String[] names=bundle.getStringArray(BADGES);
  for (int i=0; i < names.length; i++) {
    try {
      if (renamedBadges.containsKey(names[i])) {
        names[i]=renamedBadges.get(names[i]);
      }
      if (!removedBadges.contains(names[i])) {
        badges.add(Badge.valueOf(names[i]));
      }
    }
 catch (    Exception e) {
      ShatteredPixelDungeon.reportException(e);
    }
  }
  return badges;
}",0.8966900702106319
163845,"@SuppressWarnings(""String_Node_Str"") public static void switchLevel(final Level level,int pos){
  if (pos < 0 || pos >= level.length()) {
    pos=level.exit;
  }
  PathFinder.setMapSize(level.width(),level.height());
  Dungeon.level=level;
  DriedRose.restoreGhostHero(level,pos);
  Actor.init();
  Actor respawner=level.respawner();
  if (respawner != null) {
    Actor.add(level.respawner());
  }
  hero.pos=pos;
  Light light=hero.buff(Light.class);
  hero.viewDistance=light == null ? level.viewDistance : Math.max(Light.DISTANCE,level.viewDistance);
  hero.curAction=hero.lastAction=null;
  observe();
  try {
    saveAll();
  }
 catch (  IOException e) {
    ShatteredPixelDungeon.reportException(e);
  }
}","@SuppressWarnings(""String_Node_Str"") public static void switchLevel(final Level level,int pos){
  if (pos < 0 || pos >= level.length()) {
    pos=level.exit;
  }
  PathFinder.setMapSize(level.width(),level.height());
  Dungeon.level=level;
  DriedRose.restoreGhostHero(level,pos);
  Actor.init();
  Actor respawner=level.respawner();
  if (respawner != null) {
    Actor.addDelayed(respawner,level.respawnTime());
  }
  hero.pos=pos;
  Light light=hero.buff(Light.class);
  hero.viewDistance=light == null ? level.viewDistance : Math.max(Light.DISTANCE,level.viewDistance);
  hero.curAction=hero.lastAction=null;
  observe();
  try {
    saveAll();
  }
 catch (  IOException e) {
    ShatteredPixelDungeon.reportException(e);
  }
}",0.9646569646569648
163846,"public static void spawn(CityLevel level){
  if (!spawned && Dungeon.depth > 16 && Random.Int(20 - Dungeon.depth) == 0) {
    Imp npc=new Imp();
    do {
      npc.pos=level.randomRespawnCell();
    }
 while (npc.pos == -1 || level.heaps.get(npc.pos) != null || level.findMob(npc.pos) != null || !(level.passable[npc.pos + PathFinder.CIRCLE4[0]] && level.passable[npc.pos + PathFinder.CIRCLE4[2]]) || !(level.passable[npc.pos + PathFinder.CIRCLE4[1]] && level.passable[npc.pos + PathFinder.CIRCLE4[3]]));
    level.mobs.add(npc);
    spawned=true;
    alternative=Random.Int(2) == 0;
    given=false;
    do {
      reward=(Ring)Generator.random(Generator.Category.RING);
    }
 while (reward.cursed);
    reward.upgrade(2);
    reward.cursed=true;
  }
}","public static void spawn(CityLevel level){
  if (!spawned && Dungeon.depth > 16 && Random.Int(20 - Dungeon.depth) == 0) {
    Imp npc=new Imp();
    do {
      npc.pos=level.randomRespawnCell();
    }
 while (npc.pos == -1 || level.heaps.get(npc.pos) != null || level.traps.get(npc.pos) != null || level.findMob(npc.pos) != null || !(level.passable[npc.pos + PathFinder.CIRCLE4[0]] && level.passable[npc.pos + PathFinder.CIRCLE4[2]]) || !(level.passable[npc.pos + PathFinder.CIRCLE4[1]] && level.passable[npc.pos + PathFinder.CIRCLE4[3]]));
    level.mobs.add(npc);
    spawned=true;
    alternative=Random.Int(2) == 0;
    given=false;
    do {
      reward=(Ring)Generator.random(Generator.Category.RING);
    }
 while (reward.cursed);
    reward.upgrade(2);
    reward.cursed=true;
  }
}",0.9766839378238342
163847,"@Override protected void onZap(Ballistica beam){
  Char ch=Actor.findChar(beam.collisionPos);
  if (ch != null) {
    processSoulMark(ch,chargesPerCast());
    affectTarget(ch);
  }
  affectMap(beam);
  if (Dungeon.level.viewDistance < 6) {
    if (Dungeon.isChallenged(Challenges.DARKNESS)) {
      Buff.prolong(curUser,Light.class,2f + level());
    }
 else {
      Buff.prolong(curUser,Light.class,10f + level() * 5);
    }
  }
}","@Override protected void onZap(Ballistica beam){
  affectMap(beam);
  if (Dungeon.level.viewDistance < 6) {
    if (Dungeon.isChallenged(Challenges.DARKNESS)) {
      Buff.prolong(curUser,Light.class,2f + level());
    }
 else {
      Buff.prolong(curUser,Light.class,10f + level() * 5);
    }
  }
  Char ch=Actor.findChar(beam.collisionPos);
  if (ch != null) {
    processSoulMark(ch,chargesPerCast());
    affectTarget(ch);
  }
}",0.6921296296296297
163848,"@Override protected boolean act(){
  int count=0;
  for (  Mob mob : mobs.toArray(new Mob[0])) {
    if (mob.alignment == Char.Alignment.ENEMY)     count++;
  }
  if (count < nMobs()) {
    Mob mob=createMob();
    mob.state=mob.WANDERING;
    mob.pos=randomRespawnCell();
    if (Dungeon.hero.isAlive() && mob.pos != -1 && distance(Dungeon.hero.pos,mob.pos) >= 4) {
      GameScene.add(mob);
      if (Statistics.amuletObtained) {
        mob.beckon(Dungeon.hero.pos);
      }
    }
  }
  if (Statistics.amuletObtained) {
    spend(TIME_TO_RESPAWN / 2f);
  }
 else   if (Dungeon.level.feeling == Feeling.DARK) {
    spend(2 * TIME_TO_RESPAWN / 3f);
  }
 else {
    spend(TIME_TO_RESPAWN);
  }
  return true;
}","@Override protected boolean act(){
  int count=0;
  for (  Mob mob : mobs.toArray(new Mob[0])) {
    if (mob.alignment == Char.Alignment.ENEMY)     count++;
  }
  if (count < nMobs()) {
    Mob mob=createMob();
    mob.state=mob.WANDERING;
    mob.pos=randomRespawnCell();
    if (Dungeon.hero.isAlive() && mob.pos != -1 && distance(Dungeon.hero.pos,mob.pos) >= 4) {
      GameScene.add(mob);
      if (Statistics.amuletObtained) {
        mob.beckon(Dungeon.hero.pos);
      }
    }
  }
  spend(respawnTime());
  return true;
}",0.7948303715670436
163849,"public Actor respawner(){
  return new Actor(){
{
      actPriority=BUFF_PRIO;
    }
    @Override protected boolean act(){
      int count=0;
      for (      Mob mob : mobs.toArray(new Mob[0])) {
        if (mob.alignment == Char.Alignment.ENEMY)         count++;
      }
      if (count < nMobs()) {
        Mob mob=createMob();
        mob.state=mob.WANDERING;
        mob.pos=randomRespawnCell();
        if (Dungeon.hero.isAlive() && mob.pos != -1 && distance(Dungeon.hero.pos,mob.pos) >= 4) {
          GameScene.add(mob);
          if (Statistics.amuletObtained) {
            mob.beckon(Dungeon.hero.pos);
          }
        }
      }
      if (Statistics.amuletObtained) {
        spend(TIME_TO_RESPAWN / 2f);
      }
 else       if (Dungeon.level.feeling == Feeling.DARK) {
        spend(2 * TIME_TO_RESPAWN / 3f);
      }
 else {
        spend(TIME_TO_RESPAWN);
      }
      return true;
    }
  }
;
}","public Actor respawner(){
  return new Actor(){
{
      actPriority=BUFF_PRIO;
    }
    @Override protected boolean act(){
      int count=0;
      for (      Mob mob : mobs.toArray(new Mob[0])) {
        if (mob.alignment == Char.Alignment.ENEMY)         count++;
      }
      if (count < nMobs()) {
        Mob mob=createMob();
        mob.state=mob.WANDERING;
        mob.pos=randomRespawnCell();
        if (Dungeon.hero.isAlive() && mob.pos != -1 && distance(Dungeon.hero.pos,mob.pos) >= 4) {
          GameScene.add(mob);
          if (Statistics.amuletObtained) {
            mob.beckon(Dungeon.hero.pos);
          }
        }
      }
      spend(respawnTime());
      return true;
    }
  }
;
}",0.8197530864197531
163850,"@Override public int drRoll(){
  int dr=0;
  Barkskin bark=buff(Barkskin.class);
  if (belongings.armor != null) {
    dr+=Random.NormalIntRange(belongings.armor.DRMin(),belongings.armor.DRMax());
    if (STR() < belongings.armor.STRReq()) {
      dr-=2 * (belongings.armor.STRReq() - STR());
      dr=Math.max(dr,0);
    }
  }
  if (belongings.weapon != null)   dr+=Random.NormalIntRange(0,belongings.weapon.defenseFactor(this));
  if (bark != null)   dr+=Random.NormalIntRange(0,bark.level());
  return dr;
}","@Override public int drRoll(){
  int dr=0;
  Barkskin bark=buff(Barkskin.class);
  if (belongings.armor != null) {
    int armDr=Random.NormalIntRange(belongings.armor.DRMin(),belongings.armor.DRMax());
    if (STR() < belongings.armor.STRReq()) {
      armDr-=2 * (belongings.armor.STRReq() - STR());
    }
    if (armDr > 0)     dr+=armDr;
  }
  if (belongings.weapon != null) {
    int wepDr=Random.NormalIntRange(0,belongings.weapon.defenseFactor(this));
    if (STR() < ((Weapon)belongings.weapon).STRReq()) {
      wepDr-=2 * (((Weapon)belongings.weapon).STRReq() - STR());
    }
    if (wepDr > 0)     dr+=wepDr;
  }
  if (bark != null)   dr+=Random.NormalIntRange(0,bark.level());
  return dr;
}",0.7848309975267931
163851,"@Override public int proc(Armor armor,Char attacker,Char defender,int damage){
  testing=true;
  float evasion=defender.defenseSkill(attacker);
  float accuracy=attacker.attackSkill(defender);
  testing=false;
  float hitChance;
  if (evasion >= accuracy) {
    hitChance=1f - (1f - (accuracy / evasion)) / 2f;
  }
 else {
    hitChance=1f - (evasion / accuracy) / 2f;
  }
  damage=(int)Math.ceil(damage * hitChance);
  return damage;
}","@Override public int proc(Armor armor,Char attacker,Char defender,int damage){
  testing=true;
  float evasion=defender.defenseSkill(attacker);
  float accuracy=attacker.attackSkill(defender);
  testing=false;
  float hitChance;
  if (evasion >= accuracy) {
    hitChance=1f - (1f - (accuracy / evasion)) / 2f;
  }
 else {
    hitChance=1f - (evasion / accuracy) / 2f;
  }
  hitChance=(2f + 3f * hitChance) / 5f;
  damage=(int)Math.ceil(damage * hitChance);
  return damage;
}",0.956140350877193
163852,"@Override public int proc(Armor armor,Char attacker,Char defender,int damage){
  if (damage == 0) {
    return 0;
  }
  int level=Math.max(0,armor.level());
  float percent=(level + 1) / (float)(level + 6);
  int amount=(int)Math.ceil(damage * percent);
  DeferedDamage deferred=Buff.affect(defender,DeferedDamage.class);
  deferred.prolong(amount);
  defender.sprite.showStatus(CharSprite.WARNING,Messages.get(this,""String_Node_Str"",amount));
  return damage - amount;
}","@Override public int proc(Armor armor,Char attacker,Char defender,int damage){
  int realDamage=damage - Random.NormalIntRange(armor.DRMin(),armor.DRMax());
  if (realDamage <= 0) {
    return 0;
  }
  int level=Math.max(0,armor.level());
  float percent=(level + 1) / (float)(level + 6);
  int amount=(int)Math.ceil(realDamage * percent);
  DeferedDamage deferred=Buff.affect(defender,DeferedDamage.class);
  deferred.prolong(amount);
  defender.sprite.showStatus(CharSprite.WARNING,Messages.get(this,""String_Node_Str"",amount));
  return damage - amount;
}",0.8949416342412452
163853,"@Override public void update(){
  super.update();
  waitingTime+=Game.elapsed;
  float p=timeLeft / TIME_TO_FADE;
switch (phase) {
case FADE_IN:
    message.alpha(1 - p);
  if ((timeLeft-=Game.elapsed) <= 0) {
    if (!thread.isAlive() && error == null) {
      phase=Phase.FADE_OUT;
      timeLeft=TIME_TO_FADE;
    }
 else {
      phase=Phase.STATIC;
    }
  }
break;
case FADE_OUT:
message.alpha(p);
if ((timeLeft-=Game.elapsed) <= 0) {
Game.switchScene(GameScene.class);
}
break;
case STATIC:
if (error != null) {
String errorMsg;
if (error instanceof FileNotFoundException) errorMsg=Messages.get(this,""String_Node_Str"");
 else if (error instanceof IOException) errorMsg=Messages.get(this,""String_Node_Str"");
 else if (error.getMessage() != null && error.getMessage().equals(""String_Node_Str"")) errorMsg=Messages.get(this,""String_Node_Str"");
 else throw new RuntimeException(""String_Node_Str"",error);
add(new WndError(errorMsg){
public void onBackPressed(){
super.onBackPressed();
Game.switchScene(StartScene.class);
}
}
);
error=null;
}
 else if ((int)waitingTime == 10) {
waitingTime=11f;
ShatteredPixelDungeon.reportException(new RuntimeException(""String_Node_Str"" + Dungeon.seed + ""String_Node_Str""+ Dungeon.depth));
}
break;
}
}","@Override public void update(){
  super.update();
  waitingTime+=Game.elapsed;
  float p=timeLeft / TIME_TO_FADE;
switch (phase) {
case FADE_IN:
    message.alpha(1 - p);
  if ((timeLeft-=Game.elapsed) <= 0) {
    if (!thread.isAlive() && error == null) {
      phase=Phase.FADE_OUT;
      timeLeft=TIME_TO_FADE;
    }
 else {
      phase=Phase.STATIC;
    }
  }
break;
case FADE_OUT:
message.alpha(p);
if ((timeLeft-=Game.elapsed) <= 0) {
Game.switchScene(GameScene.class);
thread=null;
error=null;
}
break;
case STATIC:
if (error != null) {
String errorMsg;
if (error instanceof FileNotFoundException) errorMsg=Messages.get(this,""String_Node_Str"");
 else if (error instanceof IOException) errorMsg=Messages.get(this,""String_Node_Str"");
 else if (error.getMessage() != null && error.getMessage().equals(""String_Node_Str"")) errorMsg=Messages.get(this,""String_Node_Str"");
 else throw new RuntimeException(""String_Node_Str"",error);
add(new WndError(errorMsg){
public void onBackPressed(){
super.onBackPressed();
Game.switchScene(StartScene.class);
}
}
);
thread=null;
error=null;
}
 else if ((int)waitingTime == 10) {
waitingTime=11f;
String s=""String_Node_Str"";
for (StackTraceElement t : thread.getStackTrace()) {
s+=""String_Node_Str"";
s+=t.toString();
}
ShatteredPixelDungeon.reportException(new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + Dungeon.seed + ""String_Node_Str""+ Dungeon.depth+ ""String_Node_Str""+ s));
}
break;
}
}",0.9245142002989536
163854,"@Override public void create(){
  super.create();
  String loadingAsset;
  int loadingDepth;
  final float scrollSpeed;
switch (mode) {
default :
    loadingDepth=Dungeon.depth;
  scrollSpeed=0;
break;
case CONTINUE:
loadingDepth=GamesInProgress.check(GamesInProgress.curSlot).depth;
scrollSpeed=5;
break;
case DESCEND:
if (Dungeon.hero == null) loadingDepth=1;
 else loadingDepth=Dungeon.depth + 1;
scrollSpeed=5;
break;
case FALL:
loadingDepth=Dungeon.depth + 1;
scrollSpeed=100;
break;
case ASCEND:
loadingDepth=Dungeon.depth - 1;
scrollSpeed=-5;
break;
case RETURN:
loadingDepth=returnDepth;
scrollSpeed=returnDepth > Dungeon.depth ? 15 : -15;
break;
}
if (loadingDepth <= 5) loadingAsset=Assets.LOADING_SEWERS;
 else if (loadingDepth <= 10) loadingAsset=Assets.LOADING_PRISON;
 else if (loadingDepth <= 15) loadingAsset=Assets.LOADING_CAVES;
 else if (loadingDepth <= 21) loadingAsset=Assets.LOADING_CITY;
 else loadingAsset=Assets.LOADING_HALLS;
SkinnedBlock bg=new SkinnedBlock(Camera.main.width,Camera.main.height,loadingAsset){
@Override protected NoosaScript script(){
return NoosaScriptNoLighting.get();
}
@Override public void draw(){
Blending.disable();
super.draw();
Blending.enable();
}
@Override public void update(){
super.update();
offset(0,Game.elapsed * scrollSpeed);
}
}
;
bg.scale(4,4);
add(bg);
Image im=new Image(TextureCache.createGradient(0xAA000000,0xBB000000,0xCC000000,0xDD000000,0xFF000000)){
@Override public void update(){
super.update();
if (phase == Phase.FADE_IN) aa=Math.max(0,timeLeft - 0.6f);
 else if (phase == Phase.FADE_OUT) aa=Math.max(0,0.4f - (timeLeft));
 else aa=0;
}
}
;
im.angle=90;
im.x=Camera.main.width;
im.scale.x=Camera.main.height / 5f;
im.scale.y=Camera.main.width;
add(im);
String text=Messages.get(Mode.class,mode.name());
message=PixelScene.renderText(text,9);
message.x=(Camera.main.width - message.width()) / 2;
message.y=(Camera.main.height - message.height()) / 2;
align(message);
add(message);
phase=Phase.FADE_IN;
timeLeft=TIME_TO_FADE;
thread=new Thread(){
@Override public void run(){
try {
switch (mode) {
case DESCEND:
descend();
break;
case ASCEND:
ascend();
break;
case CONTINUE:
restore();
break;
case RESURRECT:
resurrect();
break;
case RETURN:
returnTo();
break;
case FALL:
fall();
break;
case RESET:
reset();
break;
}
if ((Dungeon.depth % 5) == 0) {
Sample.INSTANCE.load(Assets.SND_BOSS);
}
}
 catch (Exception e) {
error=e;
}
if (phase == Phase.STATIC && error == null) {
phase=Phase.FADE_OUT;
timeLeft=TIME_TO_FADE;
}
}
}
;
thread.start();
waitingTime=0f;
}","@Override public void create(){
  super.create();
  String loadingAsset;
  int loadingDepth;
  final float scrollSpeed;
switch (mode) {
default :
    loadingDepth=Dungeon.depth;
  scrollSpeed=0;
break;
case CONTINUE:
loadingDepth=GamesInProgress.check(GamesInProgress.curSlot).depth;
scrollSpeed=5;
break;
case DESCEND:
if (Dungeon.hero == null) loadingDepth=1;
 else loadingDepth=Dungeon.depth + 1;
scrollSpeed=5;
break;
case FALL:
loadingDepth=Dungeon.depth + 1;
scrollSpeed=100;
break;
case ASCEND:
loadingDepth=Dungeon.depth - 1;
scrollSpeed=-5;
break;
case RETURN:
loadingDepth=returnDepth;
scrollSpeed=returnDepth > Dungeon.depth ? 15 : -15;
break;
}
if (loadingDepth <= 5) loadingAsset=Assets.LOADING_SEWERS;
 else if (loadingDepth <= 10) loadingAsset=Assets.LOADING_PRISON;
 else if (loadingDepth <= 15) loadingAsset=Assets.LOADING_CAVES;
 else if (loadingDepth <= 21) loadingAsset=Assets.LOADING_CITY;
 else loadingAsset=Assets.LOADING_HALLS;
SkinnedBlock bg=new SkinnedBlock(Camera.main.width,Camera.main.height,loadingAsset){
@Override protected NoosaScript script(){
return NoosaScriptNoLighting.get();
}
@Override public void draw(){
Blending.disable();
super.draw();
Blending.enable();
}
@Override public void update(){
super.update();
offset(0,Game.elapsed * scrollSpeed);
}
}
;
bg.scale(4,4);
add(bg);
Image im=new Image(TextureCache.createGradient(0xAA000000,0xBB000000,0xCC000000,0xDD000000,0xFF000000)){
@Override public void update(){
super.update();
if (phase == Phase.FADE_IN) aa=Math.max(0,timeLeft - 0.6f);
 else if (phase == Phase.FADE_OUT) aa=Math.max(0,0.4f - (timeLeft));
 else aa=0;
}
}
;
im.angle=90;
im.x=Camera.main.width;
im.scale.x=Camera.main.height / 5f;
im.scale.y=Camera.main.width;
add(im);
String text=Messages.get(Mode.class,mode.name());
message=PixelScene.renderText(text,9);
message.x=(Camera.main.width - message.width()) / 2;
message.y=(Camera.main.height - message.height()) / 2;
align(message);
add(message);
phase=Phase.FADE_IN;
timeLeft=TIME_TO_FADE;
if (thread == null) {
thread=new Thread(){
@Override public void run(){
try {
switch (mode) {
case DESCEND:
descend();
break;
case ASCEND:
ascend();
break;
case CONTINUE:
restore();
break;
case RESURRECT:
resurrect();
break;
case RETURN:
returnTo();
break;
case FALL:
fall();
break;
case RESET:
reset();
break;
}
if ((Dungeon.depth % 5) == 0) {
Sample.INSTANCE.load(Assets.SND_BOSS);
}
}
 catch (Exception e) {
error=e;
}
if (phase == Phase.STATIC && error == null) {
phase=Phase.FADE_OUT;
timeLeft=TIME_TO_FADE;
}
}
}
;
thread.start();
}
waitingTime=0f;
}",0.9952848722986248
163855,"@Override public void onDetach(){
  super.onDetach();
  for (  Item item : items) {
    ((Wand)item).stopCharging();
  }
}","@Override public void onDetach(){
  super.onDetach();
  for (  Item item : items) {
    if (item instanceof Wand) {
      ((Wand)item).stopCharging();
    }
 else     if (item instanceof MissileWeapon) {
      ((MissileWeapon)item).holster=false;
    }
  }
}",0.6263157894736842
163856,"public static void add(Object key,SmartTexture tx){
  all.put(key,tx);
}","public synchronized static void add(Object key,SmartTexture tx){
  all.put(key,tx);
}",0.9171974522292994
163857,"public static boolean contains(Object key){
  return all.containsKey(key);
}","public synchronized static boolean contains(Object key){
  return all.containsKey(key);
}",0.9212121212121211
163858,"public static void reload(){
  for (  SmartTexture tx : all.values()) {
    tx.reload();
  }
}","public synchronized static void reload(){
  for (  SmartTexture tx : all.values()) {
    tx.reload();
  }
}",0.9353233830845772
163859,"public static SmartTexture createSolid(int color){
  final String key=""String_Node_Str"" + color;
  if (all.containsKey(key)) {
    return all.get(key);
  }
 else {
    Bitmap bmp=Bitmap.createBitmap(1,1,Bitmap.Config.ARGB_8888);
    bmp.eraseColor(color);
    SmartTexture tx=new SmartTexture(bmp);
    all.put(key,tx);
    return tx;
  }
}","public synchronized static SmartTexture createSolid(int color){
  final String key=""String_Node_Str"" + color;
  if (all.containsKey(key)) {
    return all.get(key);
  }
 else {
    Bitmap bmp=Bitmap.createBitmap(1,1,Bitmap.Config.ARGB_8888);
    bmp.eraseColor(color);
    SmartTexture tx=new SmartTexture(bmp);
    all.put(key,tx);
    return tx;
  }
}",0.9812409812409812
163860,"public static SmartTexture get(Object src){
  if (all.containsKey(src)) {
    return all.get(src);
  }
 else   if (src instanceof SmartTexture) {
    return (SmartTexture)src;
  }
 else {
    SmartTexture tx=new SmartTexture(getBitmap(src));
    all.put(src,tx);
    return tx;
  }
}","public synchronized static SmartTexture get(Object src){
  if (all.containsKey(src)) {
    return all.get(src);
  }
 else   if (src instanceof SmartTexture) {
    return (SmartTexture)src;
  }
 else {
    SmartTexture tx=new SmartTexture(getBitmap(src));
    all.put(src,tx);
    return tx;
  }
}",0.9775474956822108
163861,"public static void clear(){
  for (  Texture txt : all.values()) {
    txt.delete();
  }
  all.clear();
}","public synchronized static void clear(){
  for (  Texture txt : all.values()) {
    txt.delete();
  }
  all.clear();
}",0.9417040358744396
163862,"public static SmartTexture createGradient(int... colors){
  final String key=""String_Node_Str"" + colors;
  if (all.containsKey(key)) {
    return all.get(key);
  }
 else {
    Bitmap bmp=Bitmap.createBitmap(colors.length,1,Bitmap.Config.ARGB_8888);
    for (int i=0; i < colors.length; i++) {
      bmp.setPixel(i,0,colors[i]);
    }
    SmartTexture tx=new SmartTexture(bmp);
    tx.filter(Texture.LINEAR,Texture.LINEAR);
    tx.wrap(Texture.CLAMP,Texture.CLAMP);
    all.put(key,tx);
    return tx;
  }
}","public synchronized static SmartTexture createGradient(int... colors){
  final String key=""String_Node_Str"" + colors;
  if (all.containsKey(key)) {
    return all.get(key);
  }
 else {
    Bitmap bmp=Bitmap.createBitmap(colors.length,1,Bitmap.Config.ARGB_8888);
    for (int i=0; i < colors.length; i++) {
      bmp.setPixel(i,0,colors[i]);
    }
    SmartTexture tx=new SmartTexture(bmp);
    tx.filter(Texture.LINEAR,Texture.LINEAR);
    tx.wrap(Texture.CLAMP,Texture.CLAMP);
    all.put(key,tx);
    return tx;
  }
}",0.9873170731707316
163863,"public static void remove(Object key){
  SmartTexture tx=all.get(key);
  if (tx != null) {
    all.remove(key);
    tx.delete();
  }
}","public synchronized static void remove(Object key){
  SmartTexture tx=all.get(key);
  if (tx != null) {
    all.remove(key);
    tx.delete();
  }
}",0.9537366548042704
163864,"@Override public synchronized void destroy(){
  super.destroy();
  for (int i=0; i < length; i++) {
    Gizmo g=members.get(i);
    if (g != null) {
      g.destroy();
    }
  }
  members.clear();
  members=null;
  length=0;
}","@Override public synchronized void destroy(){
  super.destroy();
  for (int i=0; i < length; i++) {
    Gizmo g=members.get(i);
    if (g != null) {
      g.destroy();
    }
  }
  if (members != null) {
    members.clear();
    members=null;
  }
  length=0;
}",0.8783505154639175
163865,"@Override protected boolean affectHero(Hero hero){
  Sample.INSTANCE.play(Assets.SND_DRINK);
  hero.HP=hero.HT;
  hero.sprite.emitter().start(Speck.factory(Speck.HEALING),0.4f,4);
  PotionOfHealing.cure(hero);
  hero.belongings.uncurseEquipped();
  ((Hunger)hero.buff(Hunger.class)).satisfy(Hunger.STARVING);
  CellEmitter.get(pos).start(ShaftParticle.FACTORY,0.2f,3);
  Dungeon.hero.interrupt();
  GLog.p(Messages.get(this,""String_Node_Str""));
  return true;
}","@Override protected boolean affectHero(Hero hero){
  if (!hero.isAlive())   return false;
  Sample.INSTANCE.play(Assets.SND_DRINK);
  hero.HP=hero.HT;
  hero.sprite.emitter().start(Speck.factory(Speck.HEALING),0.4f,4);
  PotionOfHealing.cure(hero);
  hero.belongings.uncurseEquipped();
  ((Hunger)hero.buff(Hunger.class)).satisfy(Hunger.STARVING);
  CellEmitter.get(pos).start(ShaftParticle.FACTORY,0.2f,3);
  Dungeon.hero.interrupt();
  GLog.p(Messages.get(this,""String_Node_Str""));
  return true;
}",0.959417273673257
163866,"@Override public void storeInBundle(Bundle bundle){
  super.storeInBundle(bundle);
  bundle.put(ITEMS,items);
  bundle.put(LEVEL,level);
}","@Override public void storeInBundle(Bundle bundle){
  super.storeInBundle(bundle);
  if (items != null)   bundle.put(ITEMS,items);
  bundle.put(LEVEL,level);
}",0.9292929292929292
163867,"@SuppressWarnings(""String_Node_Str"") @Override public void restoreFromBundle(Bundle bundle){
  items=new ArrayList<>((Collection<Item>)((Collection<?>)bundle.getCollection(ITEMS)));
  adjustStats(bundle.getInt(LEVEL));
  super.restoreFromBundle(bundle);
}","@SuppressWarnings(""String_Node_Str"") @Override public void restoreFromBundle(Bundle bundle){
  if (bundle.contains(ITEMS)) {
    items=new ArrayList<>((Collection<Item>)((Collection<?>)bundle.getCollection(ITEMS)));
  }
  adjustStats(bundle.getInt(LEVEL));
  super.restoreFromBundle(bundle);
}",0.9306569343065694
163868,"@Override public void activate(){
  if (Dungeon.bossLevel()) {
    return;
  }
  int nMobs=1;
  if (Random.Int(2) == 0) {
    nMobs++;
    if (Random.Int(2) == 0) {
      nMobs++;
    }
  }
  ArrayList<Integer> candidates=new ArrayList<>();
  for (int i=0; i < PathFinder.NEIGHBOURS8.length; i++) {
    int p=pos + PathFinder.NEIGHBOURS8[i];
    if (Actor.findChar(p) == null && (Dungeon.level.passable[p] || Dungeon.level.avoid[p])) {
      candidates.add(p);
    }
  }
  ArrayList<Integer> respawnPoints=new ArrayList<>();
  while (nMobs > 0 && candidates.size() > 0) {
    int index=Random.index(candidates);
    respawnPoints.add(candidates.remove(index));
    nMobs--;
  }
  ArrayList<Mob> mobs=new ArrayList<>();
  for (  Integer point : respawnPoints) {
    Mob mob=Dungeon.level.createMob();
    mob.state=mob.WANDERING;
    mob.pos=point;
    GameScene.add(mob,DELAY);
    mobs.add(mob);
  }
  for (  Mob mob : mobs) {
    ScrollOfTeleportation.appear(mob,mob.pos);
    Dungeon.level.press(mob.pos,mob,true);
  }
}","@Override public void activate(){
  if (Dungeon.bossLevel()) {
    return;
  }
  int nMobs=1;
  if (Random.Int(2) == 0) {
    nMobs++;
    if (Random.Int(2) == 0) {
      nMobs++;
    }
  }
  ArrayList<Integer> candidates=new ArrayList<>();
  for (int i=0; i < PathFinder.NEIGHBOURS8.length; i++) {
    int p=pos + PathFinder.NEIGHBOURS8[i];
    if (Actor.findChar(p) == null && (Dungeon.level.passable[p] || Dungeon.level.avoid[p])) {
      candidates.add(p);
    }
  }
  ArrayList<Integer> respawnPoints=new ArrayList<>();
  while (nMobs > 0 && candidates.size() > 0) {
    int index=Random.index(candidates);
    respawnPoints.add(candidates.remove(index));
    nMobs--;
  }
  ArrayList<Mob> mobs=new ArrayList<>();
  for (  Integer point : respawnPoints) {
    Mob mob=Dungeon.level.createMob();
    if (mob != null) {
      mob.state=mob.WANDERING;
      mob.pos=point;
      GameScene.add(mob,DELAY);
      mobs.add(mob);
    }
  }
  for (  Mob mob : mobs) {
    ScrollOfTeleportation.appear(mob,mob.pos);
    Dungeon.level.press(mob.pos,mob,true);
  }
}",0.9543927028324533
163869,"@Override public void destroy(){
synchronized (inputs) {
    for (int i=0; i < inputs.length; i++) {
      if (inputs[i].item != null) {
        if (!inputs[i].item.collect()) {
          Dungeon.level.drop(inputs[i].item,Dungeon.hero.pos);
        }
      }
      inputs[i]=null;
    }
  }
  super.destroy();
}","@Override public void destroy(){
synchronized (inputs) {
    for (int i=0; i < inputs.length; i++) {
      if (inputs[i] != null && inputs[i].item != null) {
        if (!inputs[i].item.collect()) {
          Dungeon.level.drop(inputs[i].item,Dungeon.hero.pos);
        }
      }
      inputs[i]=null;
    }
  }
  super.destroy();
}",0.9673405909797824
163870,"protected void placeItems(Bag container){
  Belongings stuff=Dungeon.hero.belongings;
  placeItem(stuff.weapon != null ? stuff.weapon : new Placeholder(ItemSpriteSheet.WEAPON_HOLDER));
  placeItem(stuff.armor != null ? stuff.armor : new Placeholder(ItemSpriteSheet.ARMOR_HOLDER));
  placeItem(stuff.misc1 != null ? stuff.misc1 : new Placeholder(ItemSpriteSheet.RING_HOLDER));
  placeItem(stuff.misc2 != null ? stuff.misc2 : new Placeholder(ItemSpriteSheet.RING_HOLDER));
  boolean backpack=(container == Dungeon.hero.belongings.backpack);
  if (!backpack) {
    count=nCols;
    col=0;
    row=1;
  }
  for (  Item item : container.items) {
    placeItem(item);
  }
  while (count - (backpack ? 4 : nCols) < container.size) {
    placeItem(null);
  }
}","protected void placeItems(Bag container){
  Belongings stuff=Dungeon.hero.belongings;
  placeItem(stuff.weapon != null ? stuff.weapon : new Placeholder(ItemSpriteSheet.WEAPON_HOLDER));
  placeItem(stuff.armor != null ? stuff.armor : new Placeholder(ItemSpriteSheet.ARMOR_HOLDER));
  placeItem(stuff.misc1 != null ? stuff.misc1 : new Placeholder(ItemSpriteSheet.RING_HOLDER));
  placeItem(stuff.misc2 != null ? stuff.misc2 : new Placeholder(ItemSpriteSheet.RING_HOLDER));
  boolean backpack=(container == Dungeon.hero.belongings.backpack);
  if (!backpack) {
    count=nCols;
    col=0;
    row=1;
  }
  for (  Item item : container.items.toArray(new Item[0])) {
    placeItem(item);
  }
  while (count - (backpack ? 4 : nCols) < container.size) {
    placeItem(null);
  }
}",0.9862295081967212
163871,"@Override protected void layout(){
  super.layout();
  if (icon != null) {
    icon.x=x + (width - icon.width()) / 2;
    icon.y=y + (height - icon.height()) / 2;
    PixelScene.align(icon);
    if (!members.contains(icon))     add(icon);
  }
}","@Override protected synchronized void layout(){
  super.layout();
  if (icon != null) {
    icon.x=x + (width - icon.width()) / 2;
    icon.y=y + (height - icon.height()) / 2;
    PixelScene.align(icon);
    if (!members.contains(icon))     add(icon);
  }
}",0.9740518962075848
163872,"public static void updateIcon(){
  if (instance != null) {
    if (instance.icon != null) {
      instance.icon.killAndErase();
      instance.icon=null;
    }
    if (action != null) {
      instance.icon=action.getIcon();
      instance.needsLayout=true;
    }
  }
}","public static void updateIcon(){
  if (instance != null) {
synchronized (instance) {
      if (instance.icon != null) {
        instance.icon.killAndErase();
        instance.icon=null;
      }
      if (action != null) {
        instance.icon=action.getIcon();
        instance.needsLayout=true;
      }
    }
  }
}",0.886986301369863
163873,"@Override public void update(){
  super.update();
  if (!Dungeon.hero.ready) {
    if (icon != null)     icon.alpha(0.5f);
  }
 else {
    if (icon != null)     icon.alpha(1f);
  }
  if (!visible && action != null) {
    visible=true;
    updateIcon();
    flash();
  }
 else {
    visible=action != null;
  }
  if (needsLayout) {
    layout();
    needsLayout=false;
  }
}","@Override public synchronized void update(){
  super.update();
  if (!Dungeon.hero.ready) {
    if (icon != null)     icon.alpha(0.5f);
  }
 else {
    if (icon != null)     icon.alpha(1f);
  }
  if (!visible && action != null) {
    visible=true;
    updateIcon();
    flash();
  }
 else {
    visible=action != null;
  }
  if (needsLayout) {
    layout();
    needsLayout=false;
  }
}",0.9828722002635046
163874,"public WndGame(){
  super();
  addButton(new RedButton(Messages.get(this,""String_Node_Str"")){
    @Override protected void onClick(){
      hide();
      GameScene.show(new WndSettings());
    }
  }
);
  if (Dungeon.challenges > 0) {
    addButton(new RedButton(Messages.get(this,""String_Node_Str"")){
      @Override protected void onClick(){
        hide();
        GameScene.show(new WndChallenges(Dungeon.challenges,false));
      }
    }
);
  }
  if (!Dungeon.hero.isAlive()) {
    RedButton btnStart;
    addButton(btnStart=new RedButton(Messages.get(this,""String_Node_Str"")){
      @Override protected void onClick(){
        GamesInProgress.selectedClass=Dungeon.hero.heroClass;
        InterlevelScene.noStory=true;
        ShatteredPixelDungeon.scene().add(new WndStartGame(GamesInProgress.firstEmpty()));
      }
    }
);
    btnStart.textColor(Window.TITLE_COLOR);
    addButton(new RedButton(Messages.get(this,""String_Node_Str"")){
      @Override protected void onClick(){
        InterlevelScene.mode=InterlevelScene.Mode.DESCEND;
        Game.switchScene(RankingsScene.class);
      }
    }
);
  }
  addButtons(new RedButton(Messages.get(this,""String_Node_Str"")){
    @Override protected void onClick(){
      try {
        Dungeon.saveAll();
      }
 catch (      IOException e) {
        ShatteredPixelDungeon.reportException(e);
      }
      Game.switchScene(TitleScene.class);
    }
  }
,new RedButton(Messages.get(this,""String_Node_Str"")){
    @Override protected void onClick(){
      try {
        Dungeon.saveAll();
      }
 catch (      IOException e) {
        ShatteredPixelDungeon.reportException(e);
      }
      Game.instance.finish();
    }
  }
);
  addButton(new RedButton(Messages.get(this,""String_Node_Str"")){
    @Override protected void onClick(){
      hide();
    }
  }
);
  resize(WIDTH,pos);
}","public WndGame(){
  super();
  addButton(new RedButton(Messages.get(this,""String_Node_Str"")){
    @Override protected void onClick(){
      hide();
      GameScene.show(new WndSettings());
    }
  }
);
  if (Dungeon.challenges > 0) {
    addButton(new RedButton(Messages.get(this,""String_Node_Str"")){
      @Override protected void onClick(){
        hide();
        GameScene.show(new WndChallenges(Dungeon.challenges,false));
      }
    }
);
  }
  if (!Dungeon.hero.isAlive()) {
    RedButton btnStart;
    addButton(btnStart=new RedButton(Messages.get(this,""String_Node_Str"")){
      @Override protected void onClick(){
        GamesInProgress.selectedClass=Dungeon.hero.heroClass;
        InterlevelScene.noStory=true;
        GameScene.show(new WndStartGame(GamesInProgress.firstEmpty()));
      }
    }
);
    btnStart.textColor(Window.TITLE_COLOR);
    addButton(new RedButton(Messages.get(this,""String_Node_Str"")){
      @Override protected void onClick(){
        InterlevelScene.mode=InterlevelScene.Mode.DESCEND;
        Game.switchScene(RankingsScene.class);
      }
    }
);
  }
  addButtons(new RedButton(Messages.get(this,""String_Node_Str"")){
    @Override protected void onClick(){
      try {
        Dungeon.saveAll();
      }
 catch (      IOException e) {
        ShatteredPixelDungeon.reportException(e);
      }
      Game.switchScene(TitleScene.class);
    }
  }
,new RedButton(Messages.get(this,""String_Node_Str"")){
    @Override protected void onClick(){
      try {
        Dungeon.saveAll();
      }
 catch (      IOException e) {
        ShatteredPixelDungeon.reportException(e);
      }
      Game.instance.finish();
    }
  }
);
  addButton(new RedButton(Messages.get(this,""String_Node_Str"")){
    @Override protected void onClick(){
      hide();
    }
  }
);
  resize(WIDTH,pos);
}",0.9871126953660544
163875,"@Override public void restoreFromBundle(Bundle bundle){
  super.restoreFromBundle(bundle);
  exp=bundle.getInt(EXP);
  charge=Math.min(chargeCap,bundle.getInt(CHARGE));
  partialCharge=bundle.getFloat(PARTIALCHARGE);
}","@Override public void restoreFromBundle(Bundle bundle){
  super.restoreFromBundle(bundle);
  exp=bundle.getInt(EXP);
  if (chargeCap > 0)   charge=Math.min(chargeCap,bundle.getInt(CHARGE));
 else   charge=bundle.getInt(CHARGE);
  partialCharge=bundle.getFloat(PARTIALCHARGE);
}",0.8808080808080808
163876,"protected void rangedHit(Char enemy,int cell){
  if (parent != null) {
    if (parent.durability <= parent.durabilityPerUse()) {
      durability=0;
      parent.durability=MAX_DURABILITY;
    }
 else {
      parent.durability-=parent.durabilityPerUse();
    }
    parent=null;
  }
 else {
    durability-=durabilityPerUse();
  }
  if (durability > 0) {
    if (enemy.isAlive() && sticky)     Buff.affect(enemy,PinCushion.class).stick(this);
 else     Dungeon.level.drop(this,enemy.pos).sprite.drop();
  }
}","protected void rangedHit(Char enemy,int cell){
  if (parent != null) {
    if (parent.durability <= parent.durabilityPerUse()) {
      durability=0;
      parent.durability=MAX_DURABILITY;
    }
 else {
      parent.durability-=parent.durabilityPerUse();
    }
    parent=null;
  }
 else {
    durability-=durabilityPerUse();
  }
  if (durability > 0) {
    if (enemy.isAlive() && sticky) {
      PinCushion p=Buff.affect(enemy,PinCushion.class);
      if (p.target == enemy) {
        p.stick(this);
        return;
      }
    }
    Dungeon.level.drop(this,enemy.pos).sprite.drop();
  }
}",0.9079307201458524
163877,"public static Mimic spawnAt(int pos,List<Item> items){
  if (Dungeon.level.pit[pos])   return null;
  Char ch=Actor.findChar(pos);
  if (ch != null) {
    ArrayList<Integer> candidates=new ArrayList<>();
    for (    int n : PathFinder.NEIGHBOURS8) {
      int cell=pos + n;
      if ((Dungeon.level.passable[cell] || Dungeon.level.avoid[cell]) && Actor.findChar(cell) == null) {
        candidates.add(cell);
      }
    }
    if (candidates.size() > 0) {
      int newPos=Random.element(candidates);
      Actor.addDelayed(new Pushing(ch,ch.pos,newPos),-1);
      ch.pos=newPos;
      Dungeon.level.press(newPos,ch);
    }
 else {
      return null;
    }
  }
  Mimic m=new Mimic();
  m.items=new ArrayList<>(items);
  m.adjustStats(Dungeon.depth);
  m.pos=pos;
  m.state=m.HUNTING;
  GameScene.add(m,1);
  m.sprite.turnTo(pos,Dungeon.hero.pos);
  if (Dungeon.level.heroFOV[m.pos]) {
    CellEmitter.get(pos).burst(Speck.factory(Speck.STAR),10);
    Sample.INSTANCE.play(Assets.SND_MIMIC);
  }
  Item reward=null;
  do {
switch (Random.Int(5)) {
case 0:
      reward=new Gold().random();
    break;
case 1:
  reward=Generator.randomMissile();
break;
case 2:
reward=Generator.randomArmor();
break;
case 3:
reward=Generator.randomWeapon();
break;
case 4:
reward=Generator.random(Generator.Category.RING);
break;
}
}
 while (reward == null || !Challenges.isItemBlocked(reward));
m.items.add(reward);
return m;
}","public static Mimic spawnAt(int pos,List<Item> items){
  if (Dungeon.level.pit[pos])   return null;
  Char ch=Actor.findChar(pos);
  if (ch != null) {
    ArrayList<Integer> candidates=new ArrayList<>();
    for (    int n : PathFinder.NEIGHBOURS8) {
      int cell=pos + n;
      if ((Dungeon.level.passable[cell] || Dungeon.level.avoid[cell]) && Actor.findChar(cell) == null) {
        candidates.add(cell);
      }
    }
    if (candidates.size() > 0) {
      int newPos=Random.element(candidates);
      Actor.addDelayed(new Pushing(ch,ch.pos,newPos),-1);
      ch.pos=newPos;
      Dungeon.level.press(newPos,ch);
    }
 else {
      return null;
    }
  }
  Mimic m=new Mimic();
  m.items=new ArrayList<>(items);
  m.adjustStats(Dungeon.depth);
  m.pos=pos;
  m.state=m.HUNTING;
  GameScene.add(m,1);
  m.sprite.turnTo(pos,Dungeon.hero.pos);
  if (Dungeon.level.heroFOV[m.pos]) {
    CellEmitter.get(pos).burst(Speck.factory(Speck.STAR),10);
    Sample.INSTANCE.play(Assets.SND_MIMIC);
  }
  Item reward=null;
  do {
switch (Random.Int(5)) {
case 0:
      reward=new Gold().random();
    break;
case 1:
  reward=Generator.randomMissile();
break;
case 2:
reward=Generator.randomArmor();
break;
case 3:
reward=Generator.randomWeapon();
break;
case 4:
reward=Generator.random(Generator.Category.RING);
break;
}
}
 while (reward == null || Challenges.isItemBlocked(reward));
m.items.add(reward);
return m;
}",0.9996452642781128
163878,"public void paint(Level level){
  Painter.fill(level,this,Terrain.WALL);
  Painter.fill(level,this,1,Terrain.EMPTY);
  Door entrance=entrance();
  entrance.set(Door.Type.LOCKED);
  Point well=null;
  if (entrance.x == left) {
    well=new Point(right - 1,Random.Int(2) == 0 ? top + 1 : bottom - 1);
  }
 else   if (entrance.x == right) {
    well=new Point(left + 1,Random.Int(2) == 0 ? top + 1 : bottom - 1);
  }
 else   if (entrance.y == top) {
    well=new Point(Random.Int(2) == 0 ? left + 1 : right - 1,bottom - 1);
  }
 else   if (entrance.y == bottom) {
    well=new Point(Random.Int(2) == 0 ? left + 1 : right - 1,top + 1);
  }
  Painter.set(level,well,Terrain.EMPTY_WELL);
  int remains=level.pointToCell(random());
  while (level.map[remains] == Terrain.EMPTY_WELL) {
    remains=level.pointToCell(random());
  }
  level.drop(new IronKey(Dungeon.depth),remains).type=Heap.Type.SKELETON;
  Item mainLoot=null;
  do {
switch (Random.Int(3)) {
case 0:
      mainLoot=Generator.random(Generator.Category.RING);
case 1:
    mainLoot=Generator.random(Generator.Category.ARTIFACT);
case 2:
  mainLoot=Generator.random(Random.oneOf(Generator.Category.WEAPON,Generator.Category.ARMOR));
}
}
 while (mainLoot == null || !Challenges.isItemBlocked(mainLoot));
level.drop(mainLoot,remains);
int n=Random.IntRange(1,2);
for (int i=0; i < n; i++) {
level.drop(prize(level),remains);
}
}","public void paint(Level level){
  Painter.fill(level,this,Terrain.WALL);
  Painter.fill(level,this,1,Terrain.EMPTY);
  Door entrance=entrance();
  entrance.set(Door.Type.LOCKED);
  Point well=null;
  if (entrance.x == left) {
    well=new Point(right - 1,Random.Int(2) == 0 ? top + 1 : bottom - 1);
  }
 else   if (entrance.x == right) {
    well=new Point(left + 1,Random.Int(2) == 0 ? top + 1 : bottom - 1);
  }
 else   if (entrance.y == top) {
    well=new Point(Random.Int(2) == 0 ? left + 1 : right - 1,bottom - 1);
  }
 else   if (entrance.y == bottom) {
    well=new Point(Random.Int(2) == 0 ? left + 1 : right - 1,top + 1);
  }
  Painter.set(level,well,Terrain.EMPTY_WELL);
  int remains=level.pointToCell(random());
  while (level.map[remains] == Terrain.EMPTY_WELL) {
    remains=level.pointToCell(random());
  }
  level.drop(new IronKey(Dungeon.depth),remains).type=Heap.Type.SKELETON;
  Item mainLoot=null;
  do {
switch (Random.Int(3)) {
case 0:
      mainLoot=Generator.random(Generator.Category.RING);
    break;
case 1:
  mainLoot=Generator.random(Generator.Category.ARTIFACT);
break;
case 2:
mainLoot=Generator.random(Random.oneOf(Generator.Category.WEAPON,Generator.Category.ARMOR));
break;
}
}
 while (mainLoot == null || Challenges.isItemBlocked(mainLoot));
level.drop(mainLoot,remains);
int n=Random.IntRange(1,2);
for (int i=0; i < n; i++) {
level.drop(prize(level),remains);
}
}",0.98921639108555
163879,"@Override public void add(Buff buff){
  super.add(buff);
  if (buff instanceof Amok || buff instanceof Corruption) {
    state=HUNTING;
  }
 else   if (buff instanceof Terror) {
    state=FLEEING;
  }
 else   if (buff instanceof Sleep) {
    state=SLEEPING;
    this.sprite().showSleep();
    postpone(Sleep.SWS);
  }
}","@Override public void add(Buff buff){
  super.add(buff);
  if (buff instanceof Amok || buff instanceof Corruption) {
    state=HUNTING;
  }
 else   if (buff instanceof Terror) {
    state=FLEEING;
  }
 else   if (buff instanceof Sleep) {
    state=SLEEPING;
    postpone(Sleep.SWS);
  }
}",0.9028006589785832
163880,"@Override public boolean act(){
  if (berserking()) {
    if (target.HP <= 0) {
      target.SHLD-=Math.min(target.SHLD,2);
      if (target.SHLD == 0) {
        target.die(this);
        if (!target.isAlive())         Dungeon.fail(this.getClass());
      }
    }
 else {
      state=State.EXHAUSTED;
      exhaustion=EXHAUSTION_START;
      levelRecovery=LEVEL_RECOVER_START;
      BuffIndicator.refreshHero();
      target.SHLD=0;
      pastRages++;
    }
  }
 else {
    float percentHP=target.HP / (float)target.HT;
    if (percentHP > targetHPPercent()) {
      target.HP=(int)Math.max(target.HT * targetHPPercent(),target.HP - pastRages);
    }
    if (state == State.EXHAUSTED) {
      exhaustion--;
      if (exhaustion == 0) {
        state=State.RECOVERING;
        BuffIndicator.refreshHero();
      }
    }
  }
  spend(TICK);
  return true;
}","@Override public boolean act(){
  if (berserking()) {
    if (target.HP <= 0) {
      target.SHLD-=Math.min(target.SHLD,2);
      if (target.SHLD == 0) {
        target.die(this);
        if (!target.isAlive())         Dungeon.fail(this.getClass());
      }
    }
 else {
      state=State.EXHAUSTED;
      exhaustion=EXHAUSTION_START;
      levelRecovery=LEVEL_RECOVER_START;
      BuffIndicator.refreshHero();
      target.SHLD=0;
      pastRages++;
    }
  }
 else {
    if (target.HP > targetHPMax()) {
      target.HP=Math.max(targetHPMax(),target.HP - 1);
      if (target instanceof Hero) {
        ((Hero)target).resting=false;
        target.remove(MagicalSleep.class);
      }
    }
    if (state == State.EXHAUSTED) {
      exhaustion--;
      if (exhaustion == 0) {
        state=State.RECOVERING;
        BuffIndicator.refreshHero();
      }
    }
  }
  spend(TICK);
  return true;
}",0.784
163881,"public int damageFactor(int dmg){
  float bonus;
  if (state == State.EXHAUSTED) {
    bonus=1f - ((float)Math.sqrt(exhaustion) / 8f);
  }
 else {
    float percentMissing=1f - target.HP / (float)target.HT;
    bonus=1f + (float)Math.pow(percentMissing,3);
  }
  return Math.round(dmg * bonus);
}","public int damageFactor(int dmg){
  float bonus;
  if (state == State.BERSERK) {
    bonus=2f;
  }
 else   if (state == State.EXHAUSTED) {
    bonus=1f - ((float)Math.sqrt(exhaustion) / 10f);
  }
 else {
    float percentMissing=1f - target.HP / (float)targetHPMax();
    bonus=1f + (0.5f * (float)Math.pow(percentMissing,2));
  }
  return Math.round(dmg * bonus);
}",0.8821752265861027
163882,"@Override public String desc(){
  float dispDamage=damageFactor(100);
  String text;
switch (state) {
case NORMAL:
default :
    text=Messages.get(this,""String_Node_Str"",dispDamage);
  break;
case BERSERK:
return Messages.get(this,""String_Node_Str"");
case EXHAUSTED:
text=Messages.get(this,""String_Node_Str"",exhaustion,dispDamage);
break;
case RECOVERING:
text=Messages.get(this,""String_Node_Str"",levelRecovery,dispDamage);
break;
}
if (pastRages == 0) {
text+=""String_Node_Str"" + Messages.get(this,""String_Node_Str"");
}
 else {
text+=""String_Node_Str"" + Messages.get(this,""String_Node_Str"",pastRages,(int)(targetHPPercent() * 100));
}
return text;
}","@Override public String desc(){
  float dispDamage=damageFactor(100);
  String text;
switch (state) {
case NORMAL:
default :
    text=Messages.get(this,""String_Node_Str"",dispDamage);
  break;
case BERSERK:
return Messages.get(this,""String_Node_Str"");
case EXHAUSTED:
text=Messages.get(this,""String_Node_Str"",exhaustion,dispDamage);
break;
case RECOVERING:
text=Messages.get(this,""String_Node_Str"",levelRecovery,dispDamage);
break;
}
if (pastRages == 0) {
text+=""String_Node_Str"" + Messages.get(this,""String_Node_Str"");
}
 else {
int dispPercent=(int)(targetHPMax() / (float)target.HT * 100);
text+=""String_Node_Str"" + Messages.get(this,""String_Node_Str"",pastRages,dispPercent);
}
return text;
}",0.8467261904761905
163883,"@Override public boolean act(){
  if (target instanceof Mob && ((Mob)target).state != ((Mob)target).SLEEPING) {
    detach();
    return true;
  }
  if (target instanceof Hero) {
    target.HP=Math.min(target.HP + 1,target.HT);
    ((Hero)target).resting=true;
    if (target.HP == target.HT) {
      GLog.p(Messages.get(this,""String_Node_Str""));
      detach();
    }
  }
  spend(STEP);
  return true;
}","@Override public boolean act(){
  if (target instanceof Mob && ((Mob)target).state != ((Mob)target).SLEEPING) {
    detach();
    return true;
  }
  if (target instanceof Hero) {
    target.HP=Math.min(target.HP + 1,target.HT);
    ((Hero)target).resting=true;
    if (target.HP == target.buff(Regeneration.class).regencap()) {
      GLog.p(Messages.get(this,""String_Node_Str""));
      detach();
    }
  }
  spend(STEP);
  return true;
}",0.9560047562425684
163884,"@Override public boolean attachTo(Char target){
  if (!target.isImmune(Sleep.class) && super.attachTo(target)) {
    if (target instanceof Hero)     if (target.HP == target.HT) {
      GLog.i(Messages.get(this,""String_Node_Str""));
      detach();
      return true;
    }
 else {
      GLog.i(Messages.get(this,""String_Node_Str""));
    }
 else     if (target instanceof Mob)     ((Mob)target).state=((Mob)target).SLEEPING;
    target.paralysed++;
    return true;
  }
 else {
    return false;
  }
}","@Override public boolean attachTo(Char target){
  if (!target.isImmune(Sleep.class) && super.attachTo(target)) {
    if (target instanceof Hero)     if (target.HP == target.buff(Regeneration.class).regencap()) {
      GLog.i(Messages.get(this,""String_Node_Str""));
      detach();
      return true;
    }
 else {
      GLog.i(Messages.get(this,""String_Node_Str""));
    }
 else     if (target instanceof Mob)     ((Mob)target).state=((Mob)target).SLEEPING;
    target.paralysed++;
    return true;
  }
 else {
    return false;
  }
}",0.9641125121241512
163885,"@Override public boolean act(){
  if (target.isAlive()) {
    if (target.HP < target.HT && !((Hero)target).isStarving()) {
      LockedFloor lock=target.buff(LockedFloor.class);
      if (target.HP > 0 && (lock == null || lock.regenOn())) {
        target.HP+=1;
        if (target.HP == target.HT) {
          ((Hero)target).resting=false;
        }
      }
    }
    ChaliceOfBlood.chaliceRegen regenBuff=Dungeon.hero.buff(ChaliceOfBlood.chaliceRegen.class);
    if (regenBuff != null)     if (regenBuff.isCursed())     spend(REGENERATION_DELAY * 1.5f);
 else     spend(REGENERATION_DELAY - regenBuff.itemLevel() * 0.9f);
 else     spend(REGENERATION_DELAY);
  }
 else {
    diactivate();
  }
  return true;
}","@Override public boolean act(){
  if (target.isAlive()) {
    if (target.HP < regencap() && !((Hero)target).isStarving()) {
      LockedFloor lock=target.buff(LockedFloor.class);
      if (target.HP > 0 && (lock == null || lock.regenOn())) {
        target.HP+=1;
        if (target.HP == regencap()) {
          ((Hero)target).resting=false;
        }
      }
    }
    ChaliceOfBlood.chaliceRegen regenBuff=Dungeon.hero.buff(ChaliceOfBlood.chaliceRegen.class);
    if (regenBuff != null)     if (regenBuff.isCursed())     spend(REGENERATION_DELAY * 1.5f);
 else     spend(REGENERATION_DELAY - regenBuff.itemLevel() * 0.9f);
 else     spend(REGENERATION_DELAY);
  }
 else {
    diactivate();
  }
  return true;
}",0.973314606741573
163886,"@Override public void onHit(MagesStaff staff,Char attacker,Char defender,int damage){
  Chill chill=defender.buff(Chill.class);
  if (chill != null && Random.IntRange(2,10) > chill.cooldown()) {
    new FlavourBuff(){
{
        actPriority=VFX_PRIO;
      }
      public boolean act(){
        Buff.affect(target,Frost.class,Frost.duration(target) * Random.Float(1f,2f));
        return super.act();
      }
    }
.attachTo(defender);
  }
}","@Override public void onHit(MagesStaff staff,Char attacker,Char defender,int damage){
  Chill chill=defender.buff(Chill.class);
  if (chill != null && Random.IntRange(2,10) <= chill.cooldown()) {
    new FlavourBuff(){
{
        actPriority=VFX_PRIO;
      }
      public boolean act(){
        Buff.affect(target,Frost.class,Frost.duration(target) * Random.Float(1f,2f));
        return super.act();
      }
    }
.attachTo(defender);
  }
}",0.996594778660613
163887,"@Override public void onDeath(){
  Badges.validateDeathFromPoison();
  Dungeon.fail(getClass());
  GLog.n(Messages.get(Poison.class,""String_Node_Str""));
}","@Override public void onDeath(){
  Badges.validateDeathFromPoison();
  Dungeon.fail(getClass());
  GLog.n(Messages.get(this,""String_Node_Str""));
}",0.96
163888,"@Override public String desc(){
  return Messages.get(this,""String_Node_Str"",dispTurns(left),damage);
}","@Override public String desc(){
  return Messages.get(this,""String_Node_Str"",dispTurns(left),(int)damage);
}",0.976303317535545
163889,"@Override public boolean attachTo(Char target){
  if (super.attachTo(target)) {
    target.alignment=Char.Alignment.ALLY;
    if (target instanceof Mob) {
      ((Mob)target).rollToDropLoot();
    }
    PinCushion p=target.buff(PinCushion.class);
    if (p != null) {
      p.detach();
    }
    return true;
  }
 else {
    return false;
  }
}","@Override public boolean attachTo(Char target){
  if (super.attachTo(target)) {
    target.alignment=Char.Alignment.ALLY;
    return true;
  }
 else {
    return false;
  }
}",0.6718146718146718
163890,"private void corruptEnemy(Mob enemy){
  if (enemy.buff(Corruption.class) != null || enemy.buff(Doom.class) != null) {
    GLog.w(Messages.get(this,""String_Node_Str""));
    return;
  }
  if (!enemy.properties().contains(Char.Property.BOSS) && !enemy.properties().contains(Char.Property.MINIBOSS) && !enemy.immunities().contains(Corruption.class)) {
    enemy.HP=enemy.HT;
    for (    Buff buff : enemy.buffs()) {
      if (buff.type == Buff.buffType.NEGATIVE && !(buff instanceof SoulMark)) {
        buff.detach();
      }
    }
    Buff.affect(enemy,Corruption.class);
    Statistics.enemiesSlain++;
    Badges.validateMonstersSlain();
    Statistics.qualifiedForNoKilling=false;
    if (enemy.EXP > 0 && curUser.lvl <= enemy.maxLvl) {
      curUser.sprite.showStatus(CharSprite.POSITIVE,Messages.get(enemy,""String_Node_Str"",enemy.EXP));
      curUser.earnExp(enemy.EXP);
    }
  }
 else {
    Buff.affect(enemy,Doom.class);
  }
}","private void corruptEnemy(Mob enemy){
  if (enemy.buff(Corruption.class) != null || enemy.buff(Doom.class) != null) {
    GLog.w(Messages.get(this,""String_Node_Str""));
    return;
  }
  if (!enemy.properties().contains(Char.Property.BOSS) && !enemy.properties().contains(Char.Property.MINIBOSS) && !enemy.immunities().contains(Corruption.class)) {
    enemy.HP=enemy.HT;
    for (    Buff buff : enemy.buffs()) {
      if (buff.type == Buff.buffType.NEGATIVE && !(buff instanceof SoulMark)) {
        buff.detach();
      }
 else       if (buff instanceof PinCushion) {
        buff.detach();
      }
    }
    Buff.affect(enemy,Corruption.class);
    Statistics.enemiesSlain++;
    Badges.validateMonstersSlain();
    Statistics.qualifiedForNoKilling=false;
    if (enemy.EXP > 0 && curUser.lvl <= enemy.maxLvl) {
      curUser.sprite.showStatus(CharSprite.POSITIVE,Messages.get(enemy,""String_Node_Str"",enemy.EXP));
      curUser.earnExp(enemy.EXP);
    }
    enemy.rollToDropLoot();
  }
 else {
    Buff.affect(enemy,Doom.class);
  }
}",0.94667343829355
163891,"@Override public void die(Object cause){
  Dungeon.level.drop(new MysteryMeat(),pos).sprite.drop();
  super.die(cause);
  Statistics.piranhasKilled++;
  Badges.validatePiranhasKilled();
}","@Override public void die(Object cause){
  super.die(cause);
  Statistics.piranhasKilled++;
  Badges.validatePiranhasKilled();
}",0.8126984126984127
163892,"@Override protected void onZap(Ballistica bolt){
  Char ch=Actor.findChar(bolt.collisionPos);
  if (ch != null) {
    if (!(ch instanceof Mob) || ch instanceof NPC) {
      return;
    }
    Mob enemy=(Mob)ch;
    float corruptingPower=2 + level();
    float enemyResist=1 + enemy.EXP;
    if (ch instanceof Mimic || ch instanceof Statue) {
      enemyResist=1 + Dungeon.depth;
    }
 else     if (ch instanceof Piranha || ch instanceof Bee) {
      enemyResist=1 + Dungeon.depth / 2f;
    }
 else     if (ch instanceof Wraith) {
      enemyResist=0.5f + Dungeon.depth / 8f;
    }
 else     if (ch instanceof Yog.BurningFist || ch instanceof Yog.RottingFist) {
      enemyResist=1 + 30;
    }
 else     if (ch instanceof Yog.Larva || ch instanceof King.Undead) {
      enemyResist=1 + 5;
    }
 else     if (ch instanceof Swarm) {
      enemyResist=1 + 3;
    }
    enemyResist*=1 + 2 * Math.pow(enemy.HP / (float)enemy.HT,2);
    for (    Buff buff : enemy.buffs()) {
      if (MAJOR_DEBUFFS.containsKey(buff.getClass()))       enemyResist*=MAJOR_DEBUFF_WEAKEN;
 else       if (MINOR_DEBUFFS.containsKey(buff.getClass()))       enemyResist*=MINOR_DEBUFF_WEAKEN;
 else       if (buff.type == Buff.buffType.NEGATIVE)       enemyResist*=MINOR_DEBUFF_WEAKEN;
    }
    if (enemy.buff(Corruption.class) != null || enemy.buff(Doom.class) != null) {
      enemyResist=corruptingPower * .99f;
    }
    if (corruptingPower > enemyResist) {
      corruptEnemy(enemy);
    }
 else {
      float debuffChance=corruptingPower / enemyResist;
      if (Random.Float() < debuffChance) {
        debuffEnemy(enemy,MAJOR_DEBUFFS);
      }
 else {
        debuffEnemy(enemy,MINOR_DEBUFFS);
      }
    }
    processSoulMark(ch,chargesPerCast());
  }
 else {
    Dungeon.level.press(bolt.collisionPos,null,true);
  }
}","@Override protected void onZap(Ballistica bolt){
  Char ch=Actor.findChar(bolt.collisionPos);
  if (ch != null) {
    if (!(ch instanceof Mob)) {
      return;
    }
    Mob enemy=(Mob)ch;
    float corruptingPower=2 + level();
    float enemyResist=1 + enemy.EXP;
    if (ch instanceof Mimic || ch instanceof Statue) {
      enemyResist=1 + Dungeon.depth;
    }
 else     if (ch instanceof Piranha || ch instanceof Bee) {
      enemyResist=1 + Dungeon.depth / 2f;
    }
 else     if (ch instanceof Wraith) {
      enemyResist=0.5f + Dungeon.depth / 8f;
    }
 else     if (ch instanceof Yog.BurningFist || ch instanceof Yog.RottingFist) {
      enemyResist=1 + 30;
    }
 else     if (ch instanceof Yog.Larva || ch instanceof King.Undead) {
      enemyResist=1 + 5;
    }
 else     if (ch instanceof Swarm) {
      enemyResist=1 + 3;
    }
    enemyResist*=1 + 2 * Math.pow(enemy.HP / (float)enemy.HT,2);
    for (    Buff buff : enemy.buffs()) {
      if (MAJOR_DEBUFFS.containsKey(buff.getClass()))       enemyResist*=MAJOR_DEBUFF_WEAKEN;
 else       if (MINOR_DEBUFFS.containsKey(buff.getClass()))       enemyResist*=MINOR_DEBUFF_WEAKEN;
 else       if (buff.type == Buff.buffType.NEGATIVE)       enemyResist*=MINOR_DEBUFF_WEAKEN;
    }
    if (enemy.buff(Corruption.class) != null || enemy.buff(Doom.class) != null) {
      enemyResist=corruptingPower * .99f;
    }
    if (corruptingPower > enemyResist) {
      corruptEnemy(enemy);
    }
 else {
      float debuffChance=corruptingPower / enemyResist;
      if (Random.Float() < debuffChance) {
        debuffEnemy(enemy,MAJOR_DEBUFFS);
      }
 else {
        debuffEnemy(enemy,MINOR_DEBUFFS);
      }
    }
    processSoulMark(ch,chargesPerCast());
  }
 else {
    Dungeon.level.press(bolt.collisionPos,null,true);
  }
}",0.9941324392288348
163893,"@Override public synchronized void updateMap(){
  super.updateMap();
  data=new int[size];
  for (int cell=0; cell < data.length; cell++) {
    if (!Dungeon.level.discoverable[cell] || !Dungeon.level.insideMap(cell)) {
      data[cell]=CLEARED;
    }
 else {
      updateMapCell(cell);
    }
  }
}","@Override public synchronized void updateMap(){
  super.updateMap();
  data=new int[size];
  for (int cell=0; cell < data.length; cell++) {
    if (!Dungeon.level.discoverable[cell] || (cell - mapWidth) <= 0 || (cell + mapWidth) >= size) {
      data[cell]=CLEARED;
    }
 else {
      updateMapCell(cell);
    }
  }
}",0.8682926829268293
163894,"@Override public synchronized void updateMapCell(int cell){
  if (!wall(cell)) {
    if (!fogHidden(cell) || !wall(cell + mapWidth)) {
      curr=CLEARED;
    }
 else     if (!fogHidden(cell + mapWidth) && (fogHidden(cell - 1) || wall(cell - 1)) && (fogHidden(cell + 1) || wall(cell + 1))&& (fogHidden(cell - 1 + mapWidth) || wall(cell - 1 + mapWidth))&& (fogHidden(cell + 1 + mapWidth) || wall(cell + 1 + mapWidth))) {
      curr=BLOCK_BELOW;
    }
 else {
      curr=BLOCK_NONE;
    }
  }
 else {
    if (!wall(cell + mapWidth)) {
      if (wall(cell - 1 - mapWidth) && wall(cell - mapWidth) && wall(cell + 1 - mapWidth)) {
        curr=CLEARED;
      }
 else       if ((!wall(cell - 1 - mapWidth) && !fogHidden(cell - 1 - mapWidth) && wall(cell - 1)) || (!wall(cell - mapWidth) && !fogHidden(cell - mapWidth)) || (!wall(cell + 1 - mapWidth) && !fogHidden(cell + 1 - mapWidth) && wall(cell + 1))) {
        if (!fogHidden(cell + mapWidth) || (!wall(cell - 1) && !fogHidden(cell - 1)) || (!wall(cell - 1 + mapWidth) && !fogHidden(cell - 1 + mapWidth))|| (!wall(cell + 1) && !fogHidden(cell + 1))|| (!wall(cell + 1 + mapWidth) && !fogHidden(cell + 1 + mapWidth))) {
          curr=CLEARED;
        }
 else {
          curr=BLOCK_ALL;
        }
      }
 else {
        curr=BLOCK_NONE;
      }
    }
 else {
      curr=BLOCK_NONE;
      if (!fogHidden(cell - mapWidth) || !fogHidden(cell) || !fogHidden(cell + mapWidth)) {
        if ((!wall(cell + 1) && !fogHidden(cell + 1 - mapWidth)) || (!wall(cell + 1) && !fogHidden(cell + 1)) || (!wall(cell + 1 + mapWidth) && !fogHidden(cell + 1 + mapWidth))) {
        }
 else {
          curr+=1;
        }
        if ((!wall(cell - 1) && !fogHidden(cell - 1 - mapWidth)) || (!wall(cell - 1) && !fogHidden(cell - 1)) || (!wall(cell - 1 + mapWidth) && !fogHidden(cell - 1 + mapWidth))) {
        }
 else {
          curr+=2;
        }
        if (curr == BLOCK_NONE) {
          curr=CLEARED;
        }
      }
    }
  }
  if (data[cell] != curr) {
    data[cell]=curr;
    super.updateMapCell(cell);
  }
}","@Override public synchronized void updateMapCell(int cell){
  if (!wall(cell)) {
    if (!fogHidden(cell) || !wall(cell + mapWidth)) {
      curr=CLEARED;
    }
 else     if (((cell + 2 * mapWidth) < size) && !fogHidden(cell + mapWidth) && (fogHidden(cell - 1) || wall(cell - 1))&& (fogHidden(cell + 1) || wall(cell + 1))&& (fogHidden(cell - 1 + mapWidth) || wall(cell - 1 + mapWidth))&& (fogHidden(cell + 1 + mapWidth) || wall(cell + 1 + mapWidth))) {
      curr=BLOCK_BELOW;
    }
 else {
      curr=BLOCK_NONE;
    }
  }
 else {
    if (!wall(cell + mapWidth)) {
      if (wall(cell - 1 - mapWidth) && wall(cell - mapWidth) && wall(cell + 1 - mapWidth)) {
        curr=CLEARED;
      }
 else       if ((!wall(cell - 1 - mapWidth) && !fogHidden(cell - 1 - mapWidth) && wall(cell - 1)) || (!wall(cell - mapWidth) && !fogHidden(cell - mapWidth)) || (!wall(cell + 1 - mapWidth) && !fogHidden(cell + 1 - mapWidth) && wall(cell + 1))) {
        if (!fogHidden(cell + mapWidth) || (!wall(cell - 1) && !fogHidden(cell - 1)) || (!wall(cell - 1 + mapWidth) && !fogHidden(cell - 1 + mapWidth))|| (!wall(cell + 1) && !fogHidden(cell + 1))|| (!wall(cell + 1 + mapWidth) && !fogHidden(cell + 1 + mapWidth))) {
          curr=CLEARED;
        }
 else {
          curr=BLOCK_ALL;
        }
      }
 else {
        curr=BLOCK_NONE;
      }
    }
 else {
      curr=BLOCK_NONE;
      if (!fogHidden(cell - mapWidth) || !fogHidden(cell) || !fogHidden(cell + mapWidth)) {
        if (((cell + 1) % mapWidth == 0) || (!wall(cell + 1) && !fogHidden(cell + 1 - mapWidth)) || (!wall(cell + 1) && !fogHidden(cell + 1))|| (!wall(cell + 1 + mapWidth) && !fogHidden(cell + 1 + mapWidth))) {
        }
 else {
          curr+=1;
        }
        if ((cell % mapWidth == 0) || (!wall(cell - 1) && !fogHidden(cell - 1 - mapWidth)) || (!wall(cell - 1) && !fogHidden(cell - 1))|| (!wall(cell - 1 + mapWidth) && !fogHidden(cell - 1 + mapWidth))) {
        }
 else {
          curr+=2;
        }
        if (curr == BLOCK_NONE) {
          curr=CLEARED;
        }
      }
    }
  }
  if (data[cell] != curr) {
    data[cell]=curr;
    super.updateMapCell(cell);
  }
}",0.852020081281377
163895,"@Override public void execute(Hero hero,String action){
  super.execute(hero,action);
  if (action.equals(AC_EAT)) {
    if (!isEquipped(hero))     GLog.i(Messages.get(Artifact.class,""String_Node_Str""));
 else     if (charge == 0)     GLog.i(Messages.get(this,""String_Node_Str""));
 else {
      int chargesToUse=Math.max(1,hero.buff(Hunger.class).hunger() / (int)(Hunger.STARVING / 10));
      if (chargesToUse > charge)       chargesToUse=charge;
      hero.buff(Hunger.class).satisfy((Hunger.STARVING / 10) * chargesToUse);
switch (hero.heroClass) {
case WARRIOR:
        if (hero.HP < hero.HT) {
          hero.HP=Math.min(hero.HP + 5,hero.HT);
          hero.sprite.emitter().burst(Speck.factory(Speck.HEALING),1);
        }
      break;
case MAGE:
    Buff.affect(hero,Recharging.class,4f);
  ScrollOfRecharging.charge(hero);
break;
case ROGUE:
case HUNTRESS:
break;
}
Statistics.foodEaten++;
charge-=chargesToUse;
hero.sprite.operate(hero.pos);
hero.busy();
SpellSprite.show(hero,SpellSprite.FOOD);
Sample.INSTANCE.play(Assets.SND_EAT);
GLog.i(Messages.get(this,""String_Node_Str""));
hero.spend(Food.TIME_TO_EAT);
Badges.validateFoodEaten();
if (charge >= 15) image=ItemSpriteSheet.ARTIFACT_HORN4;
 else if (charge >= 10) image=ItemSpriteSheet.ARTIFACT_HORN3;
 else if (charge >= 5) image=ItemSpriteSheet.ARTIFACT_HORN2;
updateQuickslot();
}
}
 else if (action.equals(AC_STORE)) {
GameScene.selectItem(itemSelector,mode,Messages.get(this,""String_Node_Str""));
}
}","@Override public void execute(Hero hero,String action){
  super.execute(hero,action);
  if (action.equals(AC_EAT)) {
    if (!isEquipped(hero))     GLog.i(Messages.get(Artifact.class,""String_Node_Str""));
 else     if (charge == 0)     GLog.i(Messages.get(this,""String_Node_Str""));
 else {
      int chargesToUse=Math.max(1,hero.buff(Hunger.class).hunger() / (int)(Hunger.STARVING / 10));
      if (chargesToUse > charge)       chargesToUse=charge;
      hero.buff(Hunger.class).satisfy((Hunger.STARVING / 10) * chargesToUse);
switch (hero.heroClass) {
case WARRIOR:
        if (hero.HP < hero.HT) {
          hero.HP=Math.min(hero.HP + 5,hero.HT);
          hero.sprite.emitter().burst(Speck.factory(Speck.HEALING),1);
        }
      break;
case MAGE:
    Buff.affect(hero,Recharging.class,4f);
  ScrollOfRecharging.charge(hero);
break;
case ROGUE:
case HUNTRESS:
break;
}
Statistics.foodEaten++;
charge-=chargesToUse;
hero.sprite.operate(hero.pos);
hero.busy();
SpellSprite.show(hero,SpellSprite.FOOD);
Sample.INSTANCE.play(Assets.SND_EAT);
GLog.i(Messages.get(this,""String_Node_Str""));
hero.spend(Food.TIME_TO_EAT);
Badges.validateFoodEaten();
if (charge >= 15) image=ItemSpriteSheet.ARTIFACT_HORN4;
 else if (charge >= 10) image=ItemSpriteSheet.ARTIFACT_HORN3;
 else if (charge >= 5) image=ItemSpriteSheet.ARTIFACT_HORN2;
 else image=ItemSpriteSheet.ARTIFACT_HORN1;
updateQuickslot();
}
}
 else if (action.equals(AC_STORE)) {
GameScene.selectItem(itemSelector,mode,Messages.get(this,""String_Node_Str""));
}
}",0.9852249832102082
163896,"public FogOfWar(int mapWidth,int mapHeight){
  super();
  this.mapWidth=mapWidth;
  this.mapHeight=mapHeight;
  mapLength=mapHeight * mapWidth;
  pWidth=mapWidth * PIX_PER_TILE;
  pHeight=mapHeight * PIX_PER_TILE;
  width2=1;
  while (width2 < pWidth) {
    width2<<=1;
  }
  height2=1;
  while (height2 < pHeight) {
    height2<<=1;
  }
  float size=DungeonTilemap.SIZE / PIX_PER_TILE;
  width=width2 * size;
  height=height2 * size;
  texture(TextureCache.createBufferTex(""String_Node_Str"",width2,height2));
  scale.set(DungeonTilemap.SIZE / PIX_PER_TILE,DungeonTilemap.SIZE / PIX_PER_TILE);
  toUpdate=new ArrayList<>();
  toUpdate.add(new Rect(0,0,mapWidth,mapHeight));
}","public FogOfWar(int mapWidth,int mapHeight){
  super();
  this.mapWidth=mapWidth;
  this.mapHeight=mapHeight;
  mapLength=mapHeight * mapWidth;
  pWidth=mapWidth * PIX_PER_TILE;
  pHeight=mapHeight * PIX_PER_TILE;
  width2=1;
  while (width2 < pWidth) {
    width2<<=1;
  }
  height2=1;
  while (height2 < pHeight) {
    height2<<=1;
  }
  float size=DungeonTilemap.SIZE / PIX_PER_TILE;
  width=width2 * size;
  height=height2 * size;
  BufferTexture tx=new BufferTexture(width2,height2);
  TextureCache.add(FogOfWar.class,tx);
  texture(tx);
  scale.set(DungeonTilemap.SIZE / PIX_PER_TILE,DungeonTilemap.SIZE / PIX_PER_TILE);
  toUpdate=new ArrayList<>();
  toUpdate.add(new Rect(0,0,mapWidth,mapHeight));
}",0.8908170643528561
163897,"@Override public void destroy(){
  super.destroy();
  if (texture != null) {
    texture.delete();
  }
}","@Override public void destroy(){
  super.destroy();
  if (texture != null) {
    TextureCache.remove(FogOfWar.class);
  }
}",0.8722466960352423
163898,"public void discover(int pos,int oldValue){
  final Image tile=new Image(texture);
  tile.frame(tileset.get(getTileVisual(pos,oldValue,false)));
  tile.point(tileToWorld(pos));
  parent.add(tile);
  parent.add(new AlphaTweener(tile,0,0.6f){
    protected void onComplete(){
      tile.killAndErase();
      killAndErase();
    }
  }
);
}","public void discover(int pos,int oldValue){
  int visual=getTileVisual(pos,oldValue,false);
  if (visual < 0)   return;
  final Image tile=new Image(texture);
  tile.frame(tileset.get(getTileVisual(pos,oldValue,false)));
  tile.point(tileToWorld(pos));
  parent.add(tile);
  parent.add(new AlphaTweener(tile,0,0.6f){
    protected void onComplete(){
      tile.killAndErase();
      killAndErase();
    }
  }
);
}",0.8986666666666666
163899,"public static Camera add(Camera camera){
  all.add(camera);
  return camera;
}","public static synchronized Camera add(Camera camera){
  all.add(camera);
  return camera;
}",0.9230769230769232
163900,"public static void updateAll(){
  int length=all.size();
  for (int i=0; i < length; i++) {
    Camera c=all.get(i);
    if (c.exists && c.active) {
      c.update();
    }
  }
}","public static synchronized void updateAll(){
  for (  Camera c : all) {
    if (c.exists && c.active) {
      c.update();
    }
  }
}",0.7395498392282959
163901,"public static Camera remove(Camera camera){
  all.remove(camera);
  return camera;
}","public static synchronized Camera remove(Camera camera){
  all.remove(camera);
  return camera;
}",0.9281767955801103
163902,"public static Camera reset(Camera newCamera){
  invW2=2f / Game.width;
  invH2=2f / Game.height;
  int length=all.size();
  for (int i=0; i < length; i++) {
    all.get(i).destroy();
  }
  all.clear();
  return main=add(newCamera);
}","public static synchronized Camera reset(Camera newCamera){
  invW2=2f / Game.width;
  invH2=2f / Game.height;
  int length=all.size();
  for (int i=0; i < length; i++) {
    all.get(i).destroy();
  }
  all.clear();
  return main=add(newCamera);
}",0.9728601252609604
163903,"@Override public void update(){
  super.update();
  x=target.sprite.center().x - SIZE / 2;
  y=target.sprite.y - SIZE;
switch (phase) {
case FADE_IN:
    alpha(passed / duration);
  scale.set(passed / duration);
break;
case STATIC:
break;
case FADE_OUT:
alpha(1 - passed / duration);
break;
}
if ((passed+=Game.elapsed) > duration) {
switch (phase) {
case FADE_IN:
phase=Phase.STATIC;
duration=STATIC_TIME;
break;
case STATIC:
phase=Phase.FADE_OUT;
duration=FADE_OUT_TIME;
break;
case FADE_OUT:
kill();
break;
}
passed=0;
}
}","@Override public void update(){
  super.update();
  if (target.sprite != null) {
    x=target.sprite.center().x - SIZE / 2;
    y=target.sprite.y - SIZE;
  }
switch (phase) {
case FADE_IN:
    alpha(passed / duration);
  scale.set(passed / duration);
break;
case STATIC:
break;
case FADE_OUT:
alpha(1 - passed / duration);
break;
}
if ((passed+=Game.elapsed) > duration) {
switch (phase) {
case FADE_IN:
phase=Phase.STATIC;
duration=STATIC_TIME;
break;
case STATIC:
phase=Phase.FADE_OUT;
duration=FADE_OUT_TIME;
break;
case FADE_OUT:
kill();
break;
}
passed=0;
}
}",0.9641873278236914
163904,"@Override public void doSpecial(){
  for (  Mob mob : Dungeon.level.mobs) {
    if (Dungeon.level.heroFOV[mob.pos]) {
      Buff.affect(mob,Burning.class).reignite(mob);
      Buff.prolong(mob,Roots.class,3);
    }
  }
  curUser.HP-=(curUser.HP / 3);
  curUser.spend(Actor.TICK);
  curUser.sprite.operate(curUser.pos);
  curUser.busy();
  curUser.sprite.centerEmitter().start(ElmoParticle.FACTORY,0.15f,4);
  Sample.INSTANCE.play(Assets.SND_READ);
}","@Override public void doSpecial(){
  for (  Mob mob : Dungeon.level.mobs.toArray(new Mob[0])) {
    if (Dungeon.level.heroFOV[mob.pos]) {
      Buff.affect(mob,Burning.class).reignite(mob);
      Buff.prolong(mob,Roots.class,3);
    }
  }
  curUser.HP-=(curUser.HP / 3);
  curUser.spend(Actor.TICK);
  curUser.sprite.operate(curUser.pos);
  curUser.busy();
  curUser.sprite.centerEmitter().start(ElmoParticle.FACTORY,0.15f,4);
  Sample.INSTANCE.play(Assets.SND_READ);
}",0.9782135076252724
163905,"@Override protected void layout(){
  image.x=0;
  image.y=Math.max(0,name.height() + GAP + health.height() - image.height);
  name.x=image.width + GAP;
  name.y=image.height - health.height() - GAP- name.baseLine();
  float w=width - image.width - GAP;
  health.setRect(image.width + GAP,image.height - health.height(),w,health.height());
  buffs.setPos(name.x + name.width() + GAP - 1,name.y + name.baseLine() - BuffIndicator.SIZE - 2);
  height=health.bottom();
}","@Override protected void layout(){
  image.x=0;
  image.y=Math.max(0,name.height() + health.height() - image.height);
  name.x=image.width + GAP;
  name.y=Math.max(0,image.height - health.height() - name.height());
  float w=width - image.width - GAP;
  health.setRect(image.width + GAP,name.y + name.height(),w,health.height());
  buffs.setPos(name.x + name.width() + GAP - 1,name.y + name.baseLine() - BuffIndicator.SIZE - 2);
  height=health.bottom();
}",0.5580890336590663
163906,"private void jump(){
  Level level=Dungeon.level;
  if (enemy == null)   enemy=chooseEnemy();
  if (enemy == null)   return;
  int newPos;
  if (HP > HT / 2) {
    for (int i=0; i < 4; i++) {
      int trapPos;
      do {
        trapPos=Random.Int(level.length());
      }
 while (level.map[trapPos] != Terrain.INACTIVE_TRAP && level.map[trapPos] != Terrain.TRAP);
      if (level.map[trapPos] == Terrain.INACTIVE_TRAP) {
        level.setTrap(new GrippingTrap().reveal(),trapPos);
        Level.set(trapPos,Terrain.TRAP);
        ScrollOfMagicMapping.discover(trapPos);
      }
    }
    int tries=50;
    do {
      newPos=Random.IntRange(3,7) + 32 * Random.IntRange(26,30);
    }
 while ((level.adjacent(newPos,enemy.pos) || Actor.findChar(newPos) != null) && --tries > 0);
    if (tries <= 0)     return;
  }
 else {
    do {
      newPos=Random.Int(level.length());
    }
 while (level.solid[newPos] || level.distance(newPos,enemy.pos) < 8 || Actor.findChar(newPos) != null);
  }
  if (level.heroFOV[pos])   CellEmitter.get(pos).burst(Speck.factory(Speck.WOOL),6);
  sprite.move(pos,newPos);
  move(newPos);
  if (level.heroFOV[newPos])   CellEmitter.get(newPos).burst(Speck.factory(Speck.WOOL),6);
  Sample.INSTANCE.play(Assets.SND_PUFF);
  spend(1 / speed());
}","private void jump(){
  Level level=Dungeon.level;
  if (fieldOfView == null || fieldOfView.length != Dungeon.level.length()) {
    fieldOfView=new boolean[Dungeon.level.length()];
    Dungeon.level.updateFieldOfView(this,fieldOfView);
  }
  if (enemy == null)   enemy=chooseEnemy();
  if (enemy == null)   return;
  int newPos;
  if (HP > HT / 2) {
    for (int i=0; i < 4; i++) {
      int trapPos;
      do {
        trapPos=Random.Int(level.length());
      }
 while (level.map[trapPos] != Terrain.INACTIVE_TRAP && level.map[trapPos] != Terrain.TRAP);
      if (level.map[trapPos] == Terrain.INACTIVE_TRAP) {
        level.setTrap(new GrippingTrap().reveal(),trapPos);
        Level.set(trapPos,Terrain.TRAP);
        ScrollOfMagicMapping.discover(trapPos);
      }
    }
    int tries=50;
    do {
      newPos=Random.IntRange(3,7) + 32 * Random.IntRange(26,30);
    }
 while ((level.adjacent(newPos,enemy.pos) || Actor.findChar(newPos) != null) && --tries > 0);
    if (tries <= 0)     return;
  }
 else {
    do {
      newPos=Random.Int(level.length());
    }
 while (level.solid[newPos] || level.distance(newPos,enemy.pos) < 8 || Actor.findChar(newPos) != null);
  }
  if (level.heroFOV[pos])   CellEmitter.get(pos).burst(Speck.factory(Speck.WOOL),6);
  sprite.move(pos,newPos);
  move(newPos);
  if (level.heroFOV[newPos])   CellEmitter.get(newPos).burst(Speck.factory(Speck.WOOL),6);
  Sample.INSTANCE.play(Assets.SND_PUFF);
  spend(1 / speed());
}",0.9306930693069309
163907,"@Override protected void emit(int index){
  if (blob.volume <= 0) {
    return;
  }
  if (blob.area.isEmpty())   blob.setupArea();
  int[] map=blob.cur;
  float size=DungeonTilemap.SIZE;
  int cell;
  for (int i=blob.area.left; i < blob.area.right; i++) {
    for (int j=blob.area.top; j < blob.area.bottom; j++) {
      cell=i + j * Dungeon.level.width();
      if (map[cell] > 0 && Dungeon.level.heroFOV[cell]) {
        float x=(i + Random.Float()) * size;
        float y=(j + Random.Float()) * size;
        factory.emit(this,index,x,y);
      }
    }
  }
}","@Override protected void emit(int index){
  if (blob.volume <= 0) {
    return;
  }
  if (blob.area.isEmpty())   blob.setupArea();
  int[] map=blob.cur;
  float size=DungeonTilemap.SIZE;
  int cell;
  for (int i=blob.area.left; i < blob.area.right; i++) {
    for (int j=blob.area.top; j < blob.area.bottom; j++) {
      cell=i + j * Dungeon.level.width();
      if (map[cell] > 0 && cell < Dungeon.level.heroFOV.length && Dungeon.level.heroFOV[cell]) {
        float x=(i + Random.Float()) * size;
        float y=(j + Random.Float()) * size;
        factory.emit(this,index,x,y);
      }
    }
  }
}",0.9664660361134996
163908,"@Override public void update(){
  if (visible=Dungeon.level.heroFOV[pos]) {
    super.update();
    if ((delay-=Game.elapsed) <= 0) {
      delay=Random.Float(DELAY);
      ((FlowParticle)recycle(FlowParticle.class)).reset(x + Random.Float(DungeonTilemap.SIZE),y);
    }
  }
}","@Override public void update(){
  if (visible=(pos < Dungeon.level.heroFOV.length && Dungeon.level.heroFOV[pos])) {
    super.update();
    if ((delay-=Game.elapsed) <= 0) {
      delay=Random.Float(DELAY);
      ((FlowParticle)recycle(FlowParticle.class)).reset(x + Random.Float(DungeonTilemap.SIZE),y);
    }
  }
}",0.9324324324324323
163909,"static boolean cancel(){
  if (Dungeon.hero.curAction != null || Dungeon.hero.resting) {
    Dungeon.hero.curAction=null;
    Dungeon.hero.resting=false;
    return true;
  }
 else {
    return cancelCellSelector();
  }
}","static boolean cancel(){
  if (Dungeon.hero != null || Dungeon.hero.curAction != null || Dungeon.hero.resting) {
    Dungeon.hero.curAction=null;
    Dungeon.hero.resting=false;
    return true;
  }
 else {
    return cancelCellSelector();
  }
}",0.9484978540772532
163910,"@Override public void destroy(){
  super.destroy();
  Dungeon.level.mobs.remove(this);
  if (Dungeon.hero.isAlive()) {
    if (alignment == Alignment.ENEMY) {
      Statistics.enemiesSlain++;
      Badges.validateMonstersSlain();
      Statistics.qualifiedForNoKilling=false;
    }
    int exp=Dungeon.hero.lvl <= maxLvl ? EXP : 0;
    if (exp > 0) {
      Dungeon.hero.sprite.showStatus(CharSprite.POSITIVE,Messages.get(this,""String_Node_Str"",exp));
      Dungeon.hero.earnExp(exp);
    }
  }
}","@Override public void destroy(){
  super.destroy();
  Dungeon.level.mobs.remove(this);
  if (Dungeon.hero.isAlive()) {
    if (alignment == Alignment.ENEMY) {
      Statistics.enemiesSlain++;
      Badges.validateMonstersSlain();
      Statistics.qualifiedForNoKilling=false;
      int exp=Dungeon.hero.lvl <= maxLvl ? EXP : 0;
      if (exp > 0) {
        Dungeon.hero.sprite.showStatus(CharSprite.POSITIVE,Messages.get(this,""String_Node_Str"",exp));
        Dungeon.hero.earnExp(exp);
      }
    }
  }
}",0.982
163911,"private void corruptEnemy(Mob enemy){
  if (enemy.buff(Corruption.class) != null || enemy.buff(Doom.class) != null) {
    GLog.w(Messages.get(this,""String_Node_Str""));
    return;
  }
  if (!enemy.properties().contains(Char.Property.BOSS) && !enemy.properties().contains(Char.Property.MINIBOSS) && !enemy.immunities().contains(Corruption.class)) {
    enemy.HP=enemy.HT;
    for (    Buff buff : enemy.buffs()) {
      buff.detach();
    }
    Buff.affect(enemy,Corruption.class);
    if (enemy.EXP > 0 && curUser.lvl <= enemy.maxLvl) {
      curUser.sprite.showStatus(CharSprite.POSITIVE,Messages.get(enemy,""String_Node_Str"",enemy.EXP));
      curUser.earnExp(enemy.EXP);
      enemy.EXP=0;
    }
  }
 else {
    Buff.affect(enemy,Doom.class);
  }
}","private void corruptEnemy(Mob enemy){
  if (enemy.buff(Corruption.class) != null || enemy.buff(Doom.class) != null) {
    GLog.w(Messages.get(this,""String_Node_Str""));
    return;
  }
  if (!enemy.properties().contains(Char.Property.BOSS) && !enemy.properties().contains(Char.Property.MINIBOSS) && !enemy.immunities().contains(Corruption.class)) {
    enemy.HP=enemy.HT;
    for (    Buff buff : enemy.buffs()) {
      buff.detach();
    }
    Buff.affect(enemy,Corruption.class);
    Statistics.enemiesSlain++;
    Badges.validateMonstersSlain();
    Statistics.qualifiedForNoKilling=false;
    if (enemy.EXP > 0 && curUser.lvl <= enemy.maxLvl) {
      curUser.sprite.showStatus(CharSprite.POSITIVE,Messages.get(enemy,""String_Node_Str"",enemy.EXP));
      curUser.earnExp(enemy.EXP);
    }
  }
 else {
    Buff.affect(enemy,Doom.class);
  }
}",0.9183417085427136
163912,"@Override public boolean act(){
  turnsToCost--;
  if (turnsToCost <= 0) {
    charge--;
    if (charge < 0) {
      charge=0;
      detach();
      GLog.w(Messages.get(this,""String_Node_Str""));
      ((Hero)target).interrupt();
    }
 else {
      int lvlDiffFromTarget=((Hero)target).lvl - 1 + level() * 2;
      if (level() >= 7) {
        lvlDiffFromTarget-=level() - 6;
      }
      if (lvlDiffFromTarget >= 0) {
        exp+=Math.round(10f * Math.pow(1.1f,lvlDiffFromTarget));
      }
 else {
        exp+=Math.round(10f * Math.pow(0.75f,-lvlDiffFromTarget));
      }
      if (exp >= (level() + 1) * 50 && level() < levelCap) {
        upgrade();
        exp-=level() * 50;
        GLog.p(Messages.get(this,""String_Node_Str""));
      }
      turnsToCost=5;
    }
    updateQuickslot();
  }
  spend(TICK);
  return true;
}","@Override public boolean act(){
  turnsToCost--;
  if (turnsToCost <= 0) {
    charge--;
    if (charge < 0) {
      charge=0;
      detach();
      GLog.w(Messages.get(this,""String_Node_Str""));
      ((Hero)target).interrupt();
    }
 else {
      int lvlDiffFromTarget=((Hero)target).lvl - (1 + level() * 2);
      if (level() >= 7) {
        lvlDiffFromTarget-=level() - 6;
      }
      if (lvlDiffFromTarget >= 0) {
        exp+=Math.round(10f * Math.pow(1.1f,lvlDiffFromTarget));
      }
 else {
        exp+=Math.round(10f * Math.pow(0.75f,-lvlDiffFromTarget));
      }
      if (exp >= (level() + 1) * 50 && level() < levelCap) {
        upgrade();
        exp-=level() * 50;
        GLog.p(Messages.get(this,""String_Node_Str""));
      }
      turnsToCost=5;
    }
    updateQuickslot();
  }
  spend(TICK);
  return true;
}",0.9987951807228916
163913,"public Plant plant(Plant.Seed seed,int pos){
  if (Dungeon.isChallenged(Challenges.NO_HERBALISM)) {
    return null;
  }
  Plant plant=plants.get(pos);
  if (plant != null) {
    plant.wither();
  }
  if (map[pos] == Terrain.HIGH_GRASS || map[pos] == Terrain.EMPTY || map[pos] == Terrain.EMBERS || map[pos] == Terrain.EMPTY_DECO) {
    map[pos]=Terrain.GRASS;
    flamable[pos]=true;
  }
  plant=seed.couch(pos,this);
  plants.put(pos,plant);
  GameScene.plantSeed(pos);
  return plant;
}","public Plant plant(Plant.Seed seed,int pos){
  if (Dungeon.isChallenged(Challenges.NO_HERBALISM)) {
    return null;
  }
  Plant plant=plants.get(pos);
  if (plant != null) {
    plant.wither();
  }
  if (map[pos] == Terrain.HIGH_GRASS || map[pos] == Terrain.EMPTY || map[pos] == Terrain.EMBERS || map[pos] == Terrain.EMPTY_DECO) {
    set(pos,Terrain.GRASS,this);
    GameScene.updateMap(pos);
  }
  plant=seed.couch(pos,this);
  plants.put(pos,plant);
  GameScene.plantSeed(pos);
  return plant;
}",0.9219858156028368
163914,"public Heap drop(Item item,int cell){
  if ((Dungeon.isChallenged(Challenges.NO_FOOD) && (item instanceof Food || item instanceof BlandfruitBush.Seed)) || (Dungeon.isChallenged(Challenges.NO_ARMOR) && item instanceof Armor) || (Dungeon.isChallenged(Challenges.NO_HEALING) && item instanceof PotionOfHealing)|| (Dungeon.isChallenged(Challenges.NO_HERBALISM) && (item instanceof Plant.Seed || item instanceof Dewdrop || item instanceof SeedPouch))|| (Dungeon.isChallenged(Challenges.NO_SCROLLS) && ((item instanceof Scroll && !(item instanceof ScrollOfUpgrade || item instanceof ScrollOfMagicalInfusion)) || item instanceof ScrollHolder))|| item == null) {
    Heap heap=new Heap();
    ItemSprite sprite=heap.sprite=new ItemSprite();
    sprite.link(heap);
    return heap;
  }
  Heap heap=heaps.get(cell);
  if (heap == null) {
    heap=new Heap();
    heap.seen=Dungeon.level == this && heroFOV[cell];
    heap.pos=cell;
    if (map[cell] == Terrain.CHASM || (Dungeon.level != null && pit[cell])) {
      Dungeon.dropToChasm(item);
      GameScene.discard(heap);
    }
 else {
      heaps.put(cell,heap);
      GameScene.add(heap);
    }
  }
 else   if (heap.type == Heap.Type.LOCKED_CHEST || heap.type == Heap.Type.CRYSTAL_CHEST) {
    int n;
    do {
      n=cell + PathFinder.NEIGHBOURS8[Random.Int(8)];
    }
 while (!passable[n] && !avoid[n]);
    return drop(item,n);
  }
  heap.drop(item);
  if (Dungeon.level != null) {
    press(cell,null);
  }
  return heap;
}","public Heap drop(Item item,int cell){
  if ((Dungeon.isChallenged(Challenges.NO_FOOD) && (item instanceof Food || item instanceof BlandfruitBush.Seed)) || (Dungeon.isChallenged(Challenges.NO_ARMOR) && item instanceof Armor) || (Dungeon.isChallenged(Challenges.NO_HEALING) && item instanceof PotionOfHealing)|| (Dungeon.isChallenged(Challenges.NO_HERBALISM) && (item instanceof Plant.Seed || item instanceof Dewdrop || item instanceof SeedPouch))|| (Dungeon.isChallenged(Challenges.NO_SCROLLS) && ((item instanceof Scroll && !(item instanceof ScrollOfUpgrade || item instanceof ScrollOfMagicalInfusion)) || item instanceof ScrollHolder))|| item == null) {
    Heap heap=new Heap();
    ItemSprite sprite=heap.sprite=new ItemSprite();
    sprite.link(heap);
    return heap;
  }
  Heap heap=heaps.get(cell);
  if (heap == null) {
    heap=new Heap();
    heap.seen=Dungeon.level == this && heroFOV[cell];
    heap.pos=cell;
    heap.drop(item);
    if (map[cell] == Terrain.CHASM || (Dungeon.level != null && pit[cell])) {
      Dungeon.dropToChasm(item);
      GameScene.discard(heap);
    }
 else {
      heaps.put(cell,heap);
      GameScene.add(heap);
    }
  }
 else   if (heap.type == Heap.Type.LOCKED_CHEST || heap.type == Heap.Type.CRYSTAL_CHEST) {
    int n;
    do {
      n=cell + PathFinder.NEIGHBOURS8[Random.Int(8)];
    }
 while (!passable[n] && !avoid[n]);
    return drop(item,n);
  }
 else {
    heap.drop(item);
  }
  if (Dungeon.level != null) {
    press(cell,null);
  }
  return heap;
}",0.9768223043332214
163915,"@Override public void call(){
  if (!finalTarget.isAlive())   return;
  if (finalTarget == Dungeon.hero) {
    if (((float)finalTarget.HP / finalTarget.HT) >= 0.9f) {
      finalTarget.damage((finalTarget.HP - 1),trap);
    }
 else {
      finalTarget.damage(finalTarget.HP,trap);
    }
    Sample.INSTANCE.play(Assets.SND_CURSED);
    if (!finalTarget.isAlive()) {
      Dungeon.fail(GrimTrap.class);
      GLog.n(Messages.get(GrimTrap.class,""String_Node_Str""));
    }
  }
 else {
    finalTarget.damage(finalTarget.HP,this);
    Sample.INSTANCE.play(Assets.SND_BURNING);
  }
  finalTarget.sprite.emitter().burst(ShadowParticle.UP,10);
  if (!finalTarget.isAlive())   finalTarget.next();
}","@Override public void call(){
  finalTarget.damage(finalDmg,trap);
  if (finalTarget == Dungeon.hero) {
    Sample.INSTANCE.play(Assets.SND_CURSED);
    if (!finalTarget.isAlive()) {
      Dungeon.fail(GrimTrap.class);
      GLog.n(Messages.get(GrimTrap.class,""String_Node_Str""));
    }
  }
 else {
    Sample.INSTANCE.play(Assets.SND_BURNING);
  }
  finalTarget.sprite.emitter().burst(ShadowParticle.UP,10);
  Actor.remove(toRemove);
  next();
}",0.6866197183098591
163916,"@Override public void activate(){
  Char target=Actor.findChar(pos);
  if (target == null) {
    for (    Char ch : Actor.chars()) {
      Ballistica bolt=new Ballistica(pos,ch.pos,Ballistica.PROJECTILE);
      if (bolt.collisionPos == ch.pos && (target == null || Dungeon.level.distance(pos,ch.pos) < Dungeon.level.distance(pos,target.pos))) {
        target=ch;
      }
    }
  }
  if (target != null) {
    final Char finalTarget=target;
    final GrimTrap trap=this;
    ((MagicMissile)target.sprite.parent.recycle(MagicMissile.class)).reset(MagicMissile.SHADOW,DungeonTilemap.tileCenterToWorld(pos),target.sprite.center(),new Callback(){
      @Override public void call(){
        if (!finalTarget.isAlive())         return;
        if (finalTarget == Dungeon.hero) {
          if (((float)finalTarget.HP / finalTarget.HT) >= 0.9f) {
            finalTarget.damage((finalTarget.HP - 1),trap);
          }
 else {
            finalTarget.damage(finalTarget.HP,trap);
          }
          Sample.INSTANCE.play(Assets.SND_CURSED);
          if (!finalTarget.isAlive()) {
            Dungeon.fail(GrimTrap.class);
            GLog.n(Messages.get(GrimTrap.class,""String_Node_Str""));
          }
        }
 else {
          finalTarget.damage(finalTarget.HP,this);
          Sample.INSTANCE.play(Assets.SND_BURNING);
        }
        finalTarget.sprite.emitter().burst(ShadowParticle.UP,10);
        if (!finalTarget.isAlive())         finalTarget.next();
      }
    }
);
  }
 else {
    CellEmitter.get(pos).burst(ShadowParticle.UP,10);
    Sample.INSTANCE.play(Assets.SND_BURNING);
  }
}","@Override public void activate(){
  Char target=Actor.findChar(pos);
  if (target == null) {
    for (    Char ch : Actor.chars()) {
      Ballistica bolt=new Ballistica(pos,ch.pos,Ballistica.PROJECTILE);
      if (bolt.collisionPos == ch.pos && (target == null || Dungeon.level.distance(pos,ch.pos) < Dungeon.level.distance(pos,target.pos))) {
        target=ch;
      }
    }
  }
  if (target != null) {
    final Char finalTarget=target;
    final GrimTrap trap=this;
    int damage;
    if (finalTarget == Dungeon.hero && ((float)finalTarget.HP / finalTarget.HT) >= 0.9f) {
      damage=finalTarget.HP - 1;
    }
 else {
      damage=finalTarget.HP;
    }
    final int finalDmg=damage;
    Actor.add(new Actor(){
{
        actPriority=Integer.MIN_VALUE;
      }
      @Override protected boolean act(){
        final Actor toRemove=this;
        ((MagicMissile)finalTarget.sprite.parent.recycle(MagicMissile.class)).reset(MagicMissile.SHADOW,DungeonTilemap.tileCenterToWorld(pos),finalTarget.sprite.center(),new Callback(){
          @Override public void call(){
            finalTarget.damage(finalDmg,trap);
            if (finalTarget == Dungeon.hero) {
              Sample.INSTANCE.play(Assets.SND_CURSED);
              if (!finalTarget.isAlive()) {
                Dungeon.fail(GrimTrap.class);
                GLog.n(Messages.get(GrimTrap.class,""String_Node_Str""));
              }
            }
 else {
              Sample.INSTANCE.play(Assets.SND_BURNING);
            }
            finalTarget.sprite.emitter().burst(ShadowParticle.UP,10);
            Actor.remove(toRemove);
            next();
          }
        }
);
        return false;
      }
    }
);
  }
 else {
    CellEmitter.get(pos).burst(ShadowParticle.UP,10);
    Sample.INSTANCE.play(Assets.SND_BURNING);
  }
}",0.7298494242692648
163917,"@Override public void call(){
  int dmg=Random.NormalIntRange(1,4) - finalTarget.drRoll();
  finalTarget.damage(dmg,trap);
  if (finalTarget == Dungeon.hero && !finalTarget.isAlive()) {
    Dungeon.fail(getClass());
  }
  Buff.affect(finalTarget,Poison.class).set(Poison.durationFactor(finalTarget) * (4 + Dungeon.depth));
  Sample.INSTANCE.play(Assets.SND_HIT,1,1,Random.Float(0.8f,1.25f));
  finalTarget.sprite.bloodBurstA(finalTarget.sprite.center(),dmg);
  finalTarget.sprite.flash();
}","@Override public void call(){
  int dmg=Random.NormalIntRange(1,4) - finalTarget.drRoll();
  finalTarget.damage(dmg,trap);
  if (finalTarget == Dungeon.hero && !finalTarget.isAlive()) {
    Dungeon.fail(trap.getClass());
  }
  Buff.affect(finalTarget,Poison.class).set(Poison.durationFactor(finalTarget) * (4 + Dungeon.depth));
  Sample.INSTANCE.play(Assets.SND_HIT,1,1,Random.Float(0.8f,1.25f));
  finalTarget.sprite.bloodBurstA(finalTarget.sprite.center(),dmg);
  finalTarget.sprite.flash();
  Actor.remove(toRemove);
  next();
}",0.9598432908912832
163918,"@Override public void activate(){
  Char target=Actor.findChar(pos);
  if (target == null) {
    for (    Char ch : Actor.chars()) {
      Ballistica bolt=new Ballistica(pos,ch.pos,Ballistica.PROJECTILE);
      if (bolt.collisionPos == ch.pos && (target == null || Dungeon.level.distance(pos,ch.pos) < Dungeon.level.distance(pos,target.pos))) {
        target=ch;
      }
    }
  }
  if (target != null) {
    final Char finalTarget=target;
    final PoisonDartTrap trap=this;
    if (Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[target.pos]) {
      ((MissileSprite)ShatteredPixelDungeon.scene().recycle(MissileSprite.class)).reset(pos,target.sprite,new Dart(),new Callback(){
        @Override public void call(){
          int dmg=Random.NormalIntRange(1,4) - finalTarget.drRoll();
          finalTarget.damage(dmg,trap);
          if (finalTarget == Dungeon.hero && !finalTarget.isAlive()) {
            Dungeon.fail(getClass());
          }
          Buff.affect(finalTarget,Poison.class).set(Poison.durationFactor(finalTarget) * (4 + Dungeon.depth));
          Sample.INSTANCE.play(Assets.SND_HIT,1,1,Random.Float(0.8f,1.25f));
          finalTarget.sprite.bloodBurstA(finalTarget.sprite.center(),dmg);
          finalTarget.sprite.flash();
        }
      }
);
    }
 else {
      finalTarget.damage(Random.NormalIntRange(1,4) - finalTarget.drRoll(),trap);
      Buff.affect(finalTarget,Poison.class).set(Poison.durationFactor(finalTarget) * (4 + Dungeon.depth));
    }
  }
}","@Override public void activate(){
  Char target=Actor.findChar(pos);
  if (target == null) {
    for (    Char ch : Actor.chars()) {
      Ballistica bolt=new Ballistica(pos,ch.pos,Ballistica.PROJECTILE);
      if (bolt.collisionPos == ch.pos && (target == null || Dungeon.level.distance(pos,ch.pos) < Dungeon.level.distance(pos,target.pos))) {
        target=ch;
      }
    }
  }
  if (target != null) {
    final Char finalTarget=target;
    final PoisonDartTrap trap=this;
    if (Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[target.pos]) {
      Actor.add(new Actor(){
{
          actPriority=Integer.MIN_VALUE;
        }
        @Override protected boolean act(){
          final Actor toRemove=this;
          ((MissileSprite)ShatteredPixelDungeon.scene().recycle(MissileSprite.class)).reset(pos,finalTarget.sprite,new Dart(),new Callback(){
            @Override public void call(){
              int dmg=Random.NormalIntRange(1,4) - finalTarget.drRoll();
              finalTarget.damage(dmg,trap);
              if (finalTarget == Dungeon.hero && !finalTarget.isAlive()) {
                Dungeon.fail(trap.getClass());
              }
              Buff.affect(finalTarget,Poison.class).set(Poison.durationFactor(finalTarget) * (4 + Dungeon.depth));
              Sample.INSTANCE.play(Assets.SND_HIT,1,1,Random.Float(0.8f,1.25f));
              finalTarget.sprite.bloodBurstA(finalTarget.sprite.center(),dmg);
              finalTarget.sprite.flash();
              Actor.remove(toRemove);
              next();
            }
          }
);
          return false;
        }
      }
);
    }
 else {
      finalTarget.damage(Random.NormalIntRange(1,4) - finalTarget.drRoll(),trap);
      Buff.affect(finalTarget,Poison.class).set(Poison.durationFactor(finalTarget) * (4 + Dungeon.depth));
    }
  }
}",0.8170547323858482
163919,"@Override public void call(){
  int dmg=Random.NormalIntRange(1,4) - finalTarget.drRoll();
  finalTarget.damage(dmg,trap);
  if (finalTarget == Dungeon.hero && !finalTarget.isAlive()) {
    Dungeon.fail(getClass());
  }
  Sample.INSTANCE.play(Assets.SND_HIT,1,1,Random.Float(0.8f,1.25f));
  finalTarget.sprite.bloodBurstA(finalTarget.sprite.center(),dmg);
  finalTarget.sprite.flash();
}","@Override public void call(){
  int dmg=Random.NormalIntRange(1,4) - finalTarget.drRoll();
  finalTarget.damage(dmg,trap);
  if (finalTarget == Dungeon.hero && !finalTarget.isAlive()) {
    Dungeon.fail(trap.getClass());
  }
  Sample.INSTANCE.play(Assets.SND_HIT,1,1,Random.Float(0.8f,1.25f));
  finalTarget.sprite.bloodBurstA(finalTarget.sprite.center(),dmg);
  finalTarget.sprite.flash();
  Actor.remove(toRemove);
  next();
}",0.9496932515337424
163920,"@Override public void activate(){
  Char target=Actor.findChar(pos);
  if (target == null) {
    for (    Char ch : Actor.chars()) {
      Ballistica bolt=new Ballistica(pos,ch.pos,Ballistica.PROJECTILE);
      if (bolt.collisionPos == ch.pos && (target == null || Dungeon.level.distance(pos,ch.pos) < Dungeon.level.distance(pos,target.pos))) {
        target=ch;
      }
    }
  }
  if (target != null) {
    final Char finalTarget=target;
    final WornDartTrap trap=this;
    if (Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[target.pos]) {
      ((MissileSprite)ShatteredPixelDungeon.scene().recycle(MissileSprite.class)).reset(pos,target.sprite,new Dart(),new Callback(){
        @Override public void call(){
          int dmg=Random.NormalIntRange(1,4) - finalTarget.drRoll();
          finalTarget.damage(dmg,trap);
          if (finalTarget == Dungeon.hero && !finalTarget.isAlive()) {
            Dungeon.fail(getClass());
          }
          Sample.INSTANCE.play(Assets.SND_HIT,1,1,Random.Float(0.8f,1.25f));
          finalTarget.sprite.bloodBurstA(finalTarget.sprite.center(),dmg);
          finalTarget.sprite.flash();
        }
      }
);
    }
 else {
      finalTarget.damage(Random.NormalIntRange(1,4) - finalTarget.drRoll(),trap);
    }
  }
}","@Override public void activate(){
  Char target=Actor.findChar(pos);
  if (target == null) {
    for (    Char ch : Actor.chars()) {
      Ballistica bolt=new Ballistica(pos,ch.pos,Ballistica.PROJECTILE);
      if (bolt.collisionPos == ch.pos && (target == null || Dungeon.level.distance(pos,ch.pos) < Dungeon.level.distance(pos,target.pos))) {
        target=ch;
      }
    }
  }
  if (target != null) {
    final Char finalTarget=target;
    final WornDartTrap trap=this;
    if (Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[target.pos]) {
      Actor.add(new Actor(){
{
          actPriority=Integer.MIN_VALUE;
        }
        @Override protected boolean act(){
          final Actor toRemove=this;
          ((MissileSprite)ShatteredPixelDungeon.scene().recycle(MissileSprite.class)).reset(pos,finalTarget.sprite,new Dart(),new Callback(){
            @Override public void call(){
              int dmg=Random.NormalIntRange(1,4) - finalTarget.drRoll();
              finalTarget.damage(dmg,trap);
              if (finalTarget == Dungeon.hero && !finalTarget.isAlive()) {
                Dungeon.fail(trap.getClass());
              }
              Sample.INSTANCE.play(Assets.SND_HIT,1,1,Random.Float(0.8f,1.25f));
              finalTarget.sprite.bloodBurstA(finalTarget.sprite.center(),dmg);
              finalTarget.sprite.flash();
              Actor.remove(toRemove);
              next();
            }
          }
);
          return false;
        }
      }
);
    }
 else {
      finalTarget.damage(Random.NormalIntRange(1,4) - finalTarget.drRoll(),trap);
    }
  }
}",0.7991617184771219
163921,"public Plant plant(Plant.Seed seed,int pos){
  if (Dungeon.isChallenged(Challenges.NO_HERBALISM)) {
    return null;
  }
  Plant plant=plants.get(pos);
  if (plant != null) {
    plant.wither();
  }
  if (map[pos] == Terrain.HIGH_GRASS || map[pos] == Terrain.EMPTY || map[pos] == Terrain.EMBERS || map[pos] == Terrain.EMPTY_DECO) {
    map[pos]=Terrain.GRASS;
    flamable[pos]=true;
  }
  plant=seed.couch(pos);
  plants.put(pos,plant);
  GameScene.plantSeed(pos);
  return plant;
}","public Plant plant(Plant.Seed seed,int pos){
  if (Dungeon.isChallenged(Challenges.NO_HERBALISM)) {
    return null;
  }
  Plant plant=plants.get(pos);
  if (plant != null) {
    plant.wither();
  }
  if (map[pos] == Terrain.HIGH_GRASS || map[pos] == Terrain.EMPTY || map[pos] == Terrain.EMBERS || map[pos] == Terrain.EMPTY_DECO) {
    map[pos]=Terrain.GRASS;
    flamable[pos]=true;
  }
  plant=seed.couch(pos,this);
  plants.put(pos,plant);
  GameScene.plantSeed(pos);
  return plant;
}",0.9557157569515964
163922,"public Plant couch(int pos){
  try {
    if (Dungeon.level.heroFOV != null && Dungeon.level.heroFOV[pos]) {
      Sample.INSTANCE.play(Assets.SND_PLANT);
    }
    Plant plant=plantClass.newInstance();
    plant.pos=pos;
    return plant;
  }
 catch (  Exception e) {
    ShatteredPixelDungeon.reportException(e);
    return null;
  }
}","public Plant couch(int pos,Level level){
  try {
    if (level.heroFOV != null && level.heroFOV[pos]) {
      Sample.INSTANCE.play(Assets.SND_PLANT);
    }
    Plant plant=plantClass.newInstance();
    plant.pos=pos;
    return plant;
  }
 catch (  Exception e) {
    ShatteredPixelDungeon.reportException(e);
    return null;
  }
}",0.9580838323353292
163923,"@Override protected void evolve(){
  boolean[] flamable=Dungeon.level.flamable;
  int cell;
  int fire;
  Freezing freeze=(Freezing)Dungeon.level.blobs.get(Freezing.class);
  boolean observe=false;
  for (int i=area.left - 1; i <= area.right; i++) {
    for (int j=area.top - 1; j <= area.bottom; j++) {
      cell=i + j * Dungeon.level.width();
      if (cur[cell] > 0) {
        if (freeze != null && freeze.cur[cell] > 0) {
          freeze.clear(cell);
          off[cell]=cur[cell]=0;
          continue;
        }
        burn(cell);
        fire=cur[cell] - 1;
        if (fire <= 0 && flamable[cell]) {
          Dungeon.level.destroy(cell);
          observe=true;
          GameScene.updateMap(cell);
        }
      }
 else       if (freeze == null || freeze.cur[cell] < 0) {
        if (flamable[cell] && (cur[cell - 1] > 0 || cur[cell + 1] > 0 || cur[cell - Dungeon.level.width()] > 0 || cur[cell + Dungeon.level.width()] > 0)) {
          fire=4;
          burn(cell);
          area.union(i,j);
        }
 else {
          fire=0;
        }
      }
 else {
        fire=0;
      }
      volume+=(off[cell]=fire);
    }
  }
  if (observe) {
    Dungeon.observe();
  }
}","@Override protected void evolve(){
  boolean[] flamable=Dungeon.level.flamable;
  int cell;
  int fire;
  Freezing freeze=(Freezing)Dungeon.level.blobs.get(Freezing.class);
  boolean observe=false;
  for (int i=area.left - 1; i <= area.right; i++) {
    for (int j=area.top - 1; j <= area.bottom; j++) {
      cell=i + j * Dungeon.level.width();
      if (cur[cell] > 0) {
        if (freeze != null && freeze.volume > 0 && freeze.cur[cell] > 0) {
          freeze.clear(cell);
          off[cell]=cur[cell]=0;
          continue;
        }
        burn(cell);
        fire=cur[cell] - 1;
        if (fire <= 0 && flamable[cell]) {
          Dungeon.level.destroy(cell);
          observe=true;
          GameScene.updateMap(cell);
        }
      }
 else       if (freeze == null || freeze.volume <= 0 || freeze.cur[cell] < 0) {
        if (flamable[cell] && (cur[cell - 1] > 0 || cur[cell + 1] > 0 || cur[cell - Dungeon.level.width()] > 0 || cur[cell + Dungeon.level.width()] > 0)) {
          fire=4;
          burn(cell);
          area.union(i,j);
        }
 else {
          fire=0;
        }
      }
 else {
        fire=0;
      }
      volume+=(off[cell]=fire);
    }
  }
  if (observe) {
    Dungeon.observe();
  }
}",0.8368617683686177
163924,"@Override protected void evolve(){
  boolean[] water=Dungeon.level.water;
  int cell;
  Fire fire=(Fire)Dungeon.level.blobs.get(Fire.class);
  for (int i=area.left - 1; i <= area.right; i++) {
    for (int j=area.top - 1; j <= area.bottom; j++) {
      cell=i + j * Dungeon.level.width();
      if (cur[cell] > 0) {
        if (fire != null && fire.cur[cell] > 0) {
          fire.clear(cell);
          off[cell]=cur[cell]=0;
          continue;
        }
        Char ch=Actor.findChar(cell);
        if (ch != null) {
          if (ch.buff(Frost.class) != null) {
            Buff.affect(ch,Frost.class,2f);
          }
 else {
            Buff.affect(ch,Chill.class,water[cell] ? 5f : 3f);
            Chill chill=ch.buff(Chill.class);
            if (chill != null && chill.cooldown() >= 10f) {
              Buff.affect(ch,Frost.class,5f);
            }
          }
        }
        Heap heap=Dungeon.level.heaps.get(cell);
        if (heap != null)         heap.freeze();
        off[cell]=cur[cell] - 1;
        volume+=off[cell];
      }
 else {
        off[cell]=0;
      }
    }
  }
}","@Override protected void evolve(){
  boolean[] water=Dungeon.level.water;
  int cell;
  Fire fire=(Fire)Dungeon.level.blobs.get(Fire.class);
  for (int i=area.left - 1; i <= area.right; i++) {
    for (int j=area.top - 1; j <= area.bottom; j++) {
      cell=i + j * Dungeon.level.width();
      if (cur[cell] > 0) {
        if (fire != null && fire.volume > 0 && fire.cur[cell] > 0) {
          fire.clear(cell);
          off[cell]=cur[cell]=0;
          continue;
        }
        Char ch=Actor.findChar(cell);
        if (ch != null) {
          if (ch.buff(Frost.class) != null) {
            Buff.affect(ch,Frost.class,2f);
          }
 else {
            Buff.affect(ch,Chill.class,water[cell] ? 5f : 3f);
            Chill chill=ch.buff(Chill.class);
            if (chill != null && chill.cooldown() >= 10f) {
              Buff.affect(ch,Frost.class,5f);
            }
          }
        }
        Heap heap=Dungeon.level.heaps.get(cell);
        if (heap != null)         heap.freeze();
        off[cell]=cur[cell] - 1;
        volume+=off[cell];
      }
 else {
        off[cell]=0;
      }
    }
  }
}",0.991406603346902
163925,"@Override public void activate(){
  CellEmitter.get(pos).start(Speck.factory(Speck.LIGHT),0.2f,3);
  Sample.INSTANCE.play(Assets.SND_TELEPORT);
  Char ch=Actor.findChar(pos);
  if (ch instanceof Hero) {
    ScrollOfTeleportation.teleportHero((Hero)ch);
    BArray.setFalse(Dungeon.level.visited);
    BArray.setFalse(Dungeon.level.mapped);
    Dungeon.observe();
  }
 else   if (ch != null) {
    int count=10;
    int pos;
    do {
      pos=Dungeon.level.randomRespawnCell();
      if (count-- <= 0) {
        break;
      }
    }
 while (pos == -1);
    if (pos == -1 || Dungeon.bossLevel()) {
      GLog.w(Messages.get(ScrollOfTeleportation.class,""String_Node_Str""));
    }
 else {
      ch.pos=pos;
      if (ch instanceof Mob && ((Mob)ch).state == ((Mob)ch).HUNTING) {
        ((Mob)ch).state=((Mob)ch).WANDERING;
      }
      ch.sprite.place(ch.pos);
      ch.sprite.visible=Dungeon.level.heroFOV[pos];
    }
  }
  Heap heap=Dungeon.level.heaps.get(pos);
  if (heap != null) {
    int cell=Dungeon.level.randomRespawnCell();
    Item item=heap.pickUp();
    if (cell != -1) {
      Dungeon.level.drop(item,cell);
    }
  }
}","@Override public void activate(){
  CellEmitter.get(pos).start(Speck.factory(Speck.LIGHT),0.2f,3);
  Sample.INSTANCE.play(Assets.SND_TELEPORT);
  Char ch=Actor.findChar(pos);
  if (ch instanceof Hero) {
    ScrollOfTeleportation.teleportHero((Hero)ch);
    BArray.setFalse(Dungeon.level.visited);
    BArray.setFalse(Dungeon.level.mapped);
    GameScene.updateFog();
    Dungeon.observe();
  }
 else   if (ch != null) {
    int count=10;
    int pos;
    do {
      pos=Dungeon.level.randomRespawnCell();
      if (count-- <= 0) {
        break;
      }
    }
 while (pos == -1);
    if (pos == -1 || Dungeon.bossLevel()) {
      GLog.w(Messages.get(ScrollOfTeleportation.class,""String_Node_Str""));
    }
 else {
      ch.pos=pos;
      if (ch instanceof Mob && ((Mob)ch).state == ((Mob)ch).HUNTING) {
        ((Mob)ch).state=((Mob)ch).WANDERING;
      }
      ch.sprite.place(ch.pos);
      ch.sprite.visible=Dungeon.level.heroFOV[pos];
    }
  }
  Heap heap=Dungeon.level.heaps.get(pos);
  if (heap != null) {
    int cell=Dungeon.level.randomRespawnCell();
    Item item=heap.pickUp();
    if (cell != -1) {
      Dungeon.level.drop(item,cell);
    }
  }
}",0.9882147533828024
163926,"@Override public boolean act(boolean enemyInFOV,boolean justAlerted){
  if (beamCharged && canAttack(enemy)) {
    enemySeen=enemyInFOV;
    return doAttack(enemy);
  }
  return super.act(enemyInFOV,justAlerted);
}","@Override public boolean act(boolean enemyInFOV,boolean justAlerted){
  if (beamCharged && enemy != null && canAttack(enemy)) {
    enemySeen=enemyInFOV;
    return doAttack(enemy);
  }
  return super.act(enemyInFOV,justAlerted);
}",0.9617977528089888
163927,"public void saySpawned(){
  if (Messages.lang() != Languages.ENGLISH)   return;
  int i=(Dungeon.depth - 1) / 5;
  if (chooseEnemy() == null)   yell(Random.element(VOICE_AMBIENT[i]));
 else   yell(Random.element(VOICE_ENEMIES[i][Dungeon.bossLevel() ? 1 : 0]));
  Sample.INSTANCE.play(Assets.SND_GHOST);
}","public void saySpawned(){
  if (Messages.lang() != Languages.ENGLISH)   return;
  int i=(Dungeon.depth - 1) / 5;
  fieldOfView=new boolean[Dungeon.level.length()];
  Dungeon.level.updateFieldOfView(this,fieldOfView);
  if (chooseEnemy() == null)   yell(Random.element(VOICE_AMBIENT[i]));
 else   yell(Random.element(VOICE_ENEMIES[i][Dungeon.bossLevel() ? 1 : 0]));
  Sample.INSTANCE.play(Assets.SND_GHOST);
}",0.8539325842696629
163928,"@Override protected Char chooseEnemy(){
  if (enemy == null || !enemy.isAlive() || !Dungeon.level.mobs.contains(enemy) || Dungeon.level.distance(enemy.pos,Dungeon.hero.pos) > 8 || enemy.alignment != Alignment.ENEMY || state == WANDERING) {
    HashSet<Mob> enemies=new HashSet<>();
    for (    Mob mob : Dungeon.level.mobs) {
      if (mob.alignment == Alignment.ENEMY && fieldOfView[mob.pos] && Dungeon.level.distance(mob.pos,Dungeon.hero.pos) <= 8 && mob.state != mob.PASSIVE) {
        enemies.add(mob);
      }
    }
    Char closest=null;
    for (    Char curr : enemies) {
      if (closest == null || Dungeon.level.distance(pos,curr.pos) < Dungeon.level.distance(pos,closest.pos)) {
        closest=curr;
      }
    }
    return closest;
  }
  return enemy;
}","@Override protected Char chooseEnemy(){
  Char enemy=super.chooseEnemy();
  if (enemy != null && Dungeon.level.distance(enemy.pos,Dungeon.hero.pos) <= 8) {
    return enemy;
  }
 else {
    return null;
  }
}",0.2640736949846469
163929,"public CustomTiledVisual create(){
  x=tileX * SIZE;
  y=tileY * SIZE;
  return this;
}","public CustomTiledVisual create(){
  camera=null;
  x=tileX * SIZE;
  y=tileY * SIZE;
  return this;
}",0.9206349206349206
163930,"private static Item pickItem(Hero hero){
  Item item=null;
  if (Random.Int(2) == 0) {
switch (Random.Int(5)) {
case 0:
      item=hero.belongings.weapon;
    break;
case 1:
  item=hero.belongings.armor;
break;
case 2:
item=hero.belongings.misc1;
break;
case 3:
item=hero.belongings.misc2;
break;
case 4:
item=Dungeon.quickslot.randomNonePlaceholder();
break;
}
if (item == null || item.bones) return pickItem(hero);
}
 else {
Iterator<Item> iterator=hero.belongings.backpack.iterator();
Item curItem;
ArrayList<Item> items=new ArrayList<Item>();
while (iterator.hasNext()) {
curItem=iterator.next();
if (curItem.bones) items.add(curItem);
}
if (Random.Int(3) < items.size()) {
item=Random.element(items);
if (item.stackable) {
item.quantity(Random.NormalIntRange(1,(item.quantity() + 1) / 2));
}
}
}
if (item == null) {
if (Dungeon.gold > 100) {
item=new Gold(Random.NormalIntRange(50,Dungeon.gold / 2));
}
 else {
item=new Gold(50);
}
}
return item;
}","private static Item pickItem(Hero hero){
  Item item=null;
  if (Random.Int(2) == 0) {
switch (Random.Int(5)) {
case 0:
      item=hero.belongings.weapon;
    break;
case 1:
  item=hero.belongings.armor;
break;
case 2:
item=hero.belongings.misc1;
break;
case 3:
item=hero.belongings.misc2;
break;
case 4:
item=Dungeon.quickslot.randomNonePlaceholder();
break;
}
if (item == null || !item.bones) {
return pickItem(hero);
}
}
 else {
Iterator<Item> iterator=hero.belongings.backpack.iterator();
Item curItem;
ArrayList<Item> items=new ArrayList<Item>();
while (iterator.hasNext()) {
curItem=iterator.next();
if (curItem.bones) items.add(curItem);
}
if (Random.Int(3) < items.size()) {
item=Random.element(items);
if (item.stackable) {
item.quantity(Random.NormalIntRange(1,(item.quantity() + 1) / 2));
}
}
}
if (item == null) {
if (Dungeon.gold > 100) {
item=new Gold(Random.NormalIntRange(50,Dungeon.gold / 2));
}
 else {
item=new Gold(50);
}
}
return item;
}",0.9848246991104134
163931,"@Override protected void evolve(){
  int cell;
  for (int i=area.top - 1; i <= area.bottom; i++) {
    for (int j=area.left - 1; j <= area.right; j++) {
      cell=j + i * Dungeon.level.width();
      if (Dungeon.level.insideMap(cell)) {
        off[cell]=cur[cell];
        volume+=off[cell];
        if (off[cell] > 0 && Dungeon.level.heroFOV[cell]) {
          Notes.add(Notes.Landmark.ALCHEMY);
        }
      }
    }
  }
}","@Override protected void evolve(){
  int cell;
  for (int i=area.top - 1; i <= area.bottom; i++) {
    for (int j=area.left - 1; j <= area.right; j++) {
      cell=j + i * Dungeon.level.width();
      if (Dungeon.level.insideMap(cell)) {
        off[cell]=cur[cell];
        volume+=off[cell];
        if (off[cell] > 0 && Dungeon.level.heroFOV[cell]) {
          Notes.add(Notes.Landmark.ALCHEMY);
        }
        while (off[cell] > 0 && Dungeon.level.heaps.get(cell) != null) {
          int n;
          do {
            n=cell + PathFinder.NEIGHBOURS8[Random.Int(8)];
          }
 while (!Dungeon.level.passable[n]);
          Dungeon.level.drop(Dungeon.level.heaps.get(cell).pickUp(),n).sprite.drop(pos);
        }
      }
    }
  }
}",0.7322497861420018
163932,"public boolean canInstakill(Char defender){
  return this == LVL_5 && !defender.properties().contains(Char.Property.MINIBOSS) && !defender.properties().contains(Char.Property.MINIBOSS);
}","public boolean canInstakill(Char defender){
  return this == LVL_5 && !defender.properties().contains(Char.Property.MINIBOSS) && !defender.properties().contains(Char.Property.BOSS);
}",0.9891891891891892
163933,"public static void spawn(CityLevel level){
  if (!spawned && Dungeon.depth > 16 && Random.Int(20 - Dungeon.depth) == 0) {
    Imp npc=new Imp();
    do {
      npc.pos=level.randomRespawnCell();
    }
 while (npc.pos == -1 || level.heaps.get(npc.pos) != null || level.findMob(npc.pos) != null || !(Dungeon.level.passable[npc.pos + PathFinder.CIRCLE4[0]] && Dungeon.level.passable[npc.pos + PathFinder.CIRCLE4[2]]) || !(Dungeon.level.passable[npc.pos + PathFinder.CIRCLE4[1]] && Dungeon.level.passable[npc.pos + PathFinder.CIRCLE4[3]]));
    level.mobs.add(npc);
    spawned=true;
    alternative=Random.Int(2) == 0;
    given=false;
    do {
      reward=(Ring)Generator.random(Generator.Category.RING);
    }
 while (reward.cursed);
    reward.upgrade(2);
    reward.cursed=true;
  }
}","public static void spawn(CityLevel level){
  if (!spawned && Dungeon.depth > 16 && Random.Int(20 - Dungeon.depth) == 0) {
    Imp npc=new Imp();
    do {
      npc.pos=level.randomRespawnCell();
    }
 while (npc.pos == -1 || level.heaps.get(npc.pos) != null || level.findMob(npc.pos) != null || !(level.passable[npc.pos + PathFinder.CIRCLE4[0]] && level.passable[npc.pos + PathFinder.CIRCLE4[2]]) || !(level.passable[npc.pos + PathFinder.CIRCLE4[1]] && level.passable[npc.pos + PathFinder.CIRCLE4[3]]));
    level.mobs.add(npc);
    spawned=true;
    alternative=Random.Int(2) == 0;
    given=false;
    do {
      reward=(Ring)Generator.random(Generator.Category.RING);
    }
 while (reward.cursed);
    reward.upgrade(2);
    reward.cursed=true;
  }
}",0.9792207792207792
163934,"private void confirmCancelation(){
  GameScene.show(new WndOptions(name(),Messages.get(this,""String_Node_Str""),Messages.get(this,""String_Node_Str""),Messages.get(this,""String_Node_Str"")){
    @Override protected void onSelect(    int index){
switch (index) {
case 0:
        curUser.spendAndNext(TIME_TO_READ);
      identifiedByUse=false;
    break;
case 1:
  GameScene.selectItem(itemSelector,mode,inventoryTitle);
break;
}
}
public void onBackPressed(){
}
}
);
}","private void confirmCancelation(){
  GameScene.show(new WndOptions(Messages.titleCase(name()),Messages.get(this,""String_Node_Str""),Messages.get(this,""String_Node_Str""),Messages.get(this,""String_Node_Str"")){
    @Override protected void onSelect(    int index){
switch (index) {
case 0:
        curUser.spendAndNext(TIME_TO_READ);
      identifiedByUse=false;
    break;
case 1:
  GameScene.selectItem(itemSelector,mode,inventoryTitle);
break;
}
}
public void onBackPressed(){
}
}
);
}",0.9683544303797468
163935,"public Heap drop(Item item,int cell){
  if ((Dungeon.isChallenged(Challenges.NO_FOOD) && (item instanceof Food || item instanceof BlandfruitBush.Seed)) || (Dungeon.isChallenged(Challenges.NO_ARMOR) && item instanceof Armor) || (Dungeon.isChallenged(Challenges.NO_HEALING) && item instanceof PotionOfHealing)|| (Dungeon.isChallenged(Challenges.NO_HERBALISM) && (item instanceof Plant.Seed || item instanceof Dewdrop || item instanceof SeedPouch))|| (Dungeon.isChallenged(Challenges.NO_SCROLLS) && ((item instanceof Scroll && !(item instanceof ScrollOfUpgrade || item instanceof ScrollOfMagicalInfusion)) || item instanceof ScrollHolder))|| item == null) {
    Heap heap=new Heap();
    ItemSprite sprite=heap.sprite=new ItemSprite();
    sprite.link(heap);
    return heap;
  }
  if ((map[cell] == Terrain.ALCHEMY) && (!(item instanceof Plant.Seed || item instanceof Blandfruit) || item instanceof BlandfruitBush.Seed || (item instanceof Blandfruit && (((Blandfruit)item).potionAttrib != null || heaps.get(cell) != null))|| Dungeon.hero.buff(AlchemistsToolkit.alchemy.class) != null && Dungeon.hero.buff(AlchemistsToolkit.alchemy.class).isCursed())) {
    int n;
    do {
      n=cell + PathFinder.NEIGHBOURS8[Random.Int(8)];
    }
 while (map[n] != Terrain.EMPTY_SP);
    cell=n;
  }
  Heap heap=heaps.get(cell);
  if (heap == null) {
    heap=new Heap();
    heap.seen=Dungeon.level == this && heroFOV[cell];
    heap.pos=cell;
    if (map[cell] == Terrain.CHASM || (Dungeon.level != null && pit[cell])) {
      Dungeon.dropToChasm(item);
      GameScene.discard(heap);
    }
 else {
      heaps.put(cell,heap);
      GameScene.add(heap);
    }
  }
 else   if (heap.type == Heap.Type.LOCKED_CHEST || heap.type == Heap.Type.CRYSTAL_CHEST) {
    int n;
    do {
      n=cell + PathFinder.NEIGHBOURS8[Random.Int(8)];
    }
 while (!passable[n] && !avoid[n]);
    return drop(item,n);
  }
  heap.drop(item);
  if (Dungeon.level != null) {
    press(cell,null);
  }
  return heap;
}","public Heap drop(Item item,int cell){
  if ((Dungeon.isChallenged(Challenges.NO_FOOD) && (item instanceof Food || item instanceof BlandfruitBush.Seed)) || (Dungeon.isChallenged(Challenges.NO_ARMOR) && item instanceof Armor) || (Dungeon.isChallenged(Challenges.NO_HEALING) && item instanceof PotionOfHealing)|| (Dungeon.isChallenged(Challenges.NO_HERBALISM) && (item instanceof Plant.Seed || item instanceof Dewdrop || item instanceof SeedPouch))|| (Dungeon.isChallenged(Challenges.NO_SCROLLS) && ((item instanceof Scroll && !(item instanceof ScrollOfUpgrade || item instanceof ScrollOfMagicalInfusion)) || item instanceof ScrollHolder))|| item == null) {
    Heap heap=new Heap();
    ItemSprite sprite=heap.sprite=new ItemSprite();
    sprite.link(heap);
    return heap;
  }
  Heap heap=heaps.get(cell);
  if (heap == null) {
    heap=new Heap();
    heap.seen=Dungeon.level == this && heroFOV[cell];
    heap.pos=cell;
    if (map[cell] == Terrain.CHASM || (Dungeon.level != null && pit[cell])) {
      Dungeon.dropToChasm(item);
      GameScene.discard(heap);
    }
 else {
      heaps.put(cell,heap);
      GameScene.add(heap);
    }
  }
 else   if (heap.type == Heap.Type.LOCKED_CHEST || heap.type == Heap.Type.CRYSTAL_CHEST) {
    int n;
    do {
      n=cell + PathFinder.NEIGHBOURS8[Random.Int(8)];
    }
 while (!passable[n] && !avoid[n]);
    return drop(item,n);
  }
  heap.drop(item);
  if (Dungeon.level != null) {
    press(cell,null);
  }
  return heap;
}",0.5381269933314005
163936,"@Override public boolean act(){
  if (Dungeon.level.map[target.pos] == Terrain.GRASS) {
    Dungeon.level.set(target.pos,Terrain.EMBERS);
    GameScene.updateMap(target.pos);
  }
  spend(TICK);
  left-=TICK;
  if (left < 5) {
    BuffIndicator.refreshHero();
  }
 else   if (left <= 0) {
    detach();
  }
  return true;
}","@Override public boolean act(){
  if (Dungeon.level.map[target.pos] == Terrain.GRASS) {
    Dungeon.level.set(target.pos,Terrain.EMBERS);
    GameScene.updateMap(target.pos);
  }
  spend(TICK);
  left-=TICK;
  if (left <= 0) {
    detach();
  }
 else   if (left < 5) {
    BuffIndicator.refreshHero();
  }
  return true;
}",0.8229813664596274
163937,"@Override public boolean act(){
  GameScene.add(Blob.seed(target.pos,50,ToxicGas.class));
  spend(TICK);
  left-=TICK;
  if (left <= 0)   detach();
  return true;
}","@Override public boolean act(){
  GameScene.add(Blob.seed(target.pos,50,ToxicGas.class));
  spend(TICK);
  left-=TICK;
  if (left <= 0) {
    detach();
  }
 else   if (left < 5) {
    BuffIndicator.refreshHero();
  }
  return true;
}",0.760705289672544
163938,"@Override protected void evolve(){
  boolean[] flamable=Dungeon.level.flamable;
  int cell;
  int fire;
  Freezing freeze=(Freezing)Dungeon.level.blobs.get(Freezing.class);
  boolean observe=false;
  for (int i=area.left - 1; i <= area.right; i++) {
    for (int j=area.top - 1; j <= area.bottom; j++) {
      cell=i + j * Dungeon.level.width();
      if (cur[cell] > 0) {
        if (freeze != null && freeze.volume > 0 && freeze.cur[cell] > 0) {
          freeze.clear(cell);
          off[cell]=cur[cell]=0;
          continue;
        }
        burn(cell);
        fire=cur[cell] - 1;
        if (fire <= 0 && flamable[cell]) {
          Dungeon.level.destroy(cell);
          observe=true;
          GameScene.updateMap(cell);
        }
      }
 else       if (freeze == null || freeze.volume <= 0 || freeze.cur[cell] < 0) {
        if (flamable[cell] && (cur[cell - 1] > 0 || cur[cell + 1] > 0 || cur[cell - Dungeon.level.width()] > 0 || cur[cell + Dungeon.level.width()] > 0)) {
          fire=4;
          burn(cell);
          area.union(i,j);
        }
 else {
          fire=0;
        }
      }
 else {
        fire=0;
      }
      volume+=(off[cell]=fire);
    }
  }
  if (observe) {
    Dungeon.observe();
  }
}","@Override protected void evolve(){
  boolean[] flamable=Dungeon.level.flamable;
  int cell;
  int fire;
  Freezing freeze=(Freezing)Dungeon.level.blobs.get(Freezing.class);
  boolean observe=false;
  for (int i=area.left - 1; i <= area.right; i++) {
    for (int j=area.top - 1; j <= area.bottom; j++) {
      cell=i + j * Dungeon.level.width();
      if (cur[cell] > 0) {
        if (freeze != null && freeze.volume > 0 && freeze.cur[cell] > 0) {
          freeze.clear(cell);
          off[cell]=cur[cell]=0;
          continue;
        }
        burn(cell);
        fire=cur[cell] - 1;
        if (fire <= 0 && flamable[cell]) {
          Dungeon.level.destroy(cell);
          observe=true;
          GameScene.updateMap(cell);
        }
      }
 else       if (freeze == null || freeze.volume <= 0 || freeze.cur[cell] <= 0) {
        if (flamable[cell] && (cur[cell - 1] > 0 || cur[cell + 1] > 0 || cur[cell - Dungeon.level.width()] > 0 || cur[cell + Dungeon.level.width()] > 0)) {
          fire=4;
          burn(cell);
          area.union(i,j);
        }
 else {
          fire=0;
        }
      }
 else {
        fire=0;
      }
      volume+=(off[cell]=fire);
    }
  }
  if (observe) {
    Dungeon.observe();
  }
}",0.999592335915206
163939,"private void corruptEnemy(Mob enemy){
  if (enemy.buff(Corruption.class) != null || enemy.buff(Doom.class) != null) {
    GLog.w(Messages.get(this,""String_Node_Str""));
    return;
  }
  if (!enemy.properties().contains(Char.Property.BOSS) && !enemy.properties().contains(Char.Property.MINIBOSS) && !enemy.immunities().contains(Corruption.class)) {
    enemy.HP=enemy.HT;
    for (    Buff buff : enemy.buffs()) {
      buff.detach();
    }
    Buff.affect(enemy,Corruption.class);
    if (enemy.EXP > 0) {
      curUser.sprite.showStatus(CharSprite.POSITIVE,Messages.get(enemy,""String_Node_Str"",enemy.EXP));
      curUser.earnExp(enemy.EXP);
      enemy.EXP=0;
    }
  }
 else {
    Buff.affect(enemy,Doom.class);
  }
}","private void corruptEnemy(Mob enemy){
  if (enemy.buff(Corruption.class) != null || enemy.buff(Doom.class) != null) {
    GLog.w(Messages.get(this,""String_Node_Str""));
    return;
  }
  if (!enemy.properties().contains(Char.Property.BOSS) && !enemy.properties().contains(Char.Property.MINIBOSS) && !enemy.immunities().contains(Corruption.class)) {
    enemy.HP=enemy.HT;
    for (    Buff buff : enemy.buffs()) {
      buff.detach();
    }
    Buff.affect(enemy,Corruption.class);
    if (enemy.EXP > 0 && curUser.lvl <= enemy.maxLvl) {
      curUser.sprite.showStatus(CharSprite.POSITIVE,Messages.get(enemy,""String_Node_Str"",enemy.EXP));
      curUser.earnExp(enemy.EXP);
      enemy.EXP=0;
    }
  }
 else {
    Buff.affect(enemy,Doom.class);
  }
}",0.9788972089857044
163940,"public void add(State state){
switch (state) {
case BURNING:
    burning=emitter();
  burning.pour(FlameParticle.FACTORY,0.06f);
if (visible) {
  Sample.INSTANCE.play(Assets.SND_BURNING);
}
break;
case LEVITATING:
levitation=emitter();
levitation.pour(Speck.factory(Speck.JET),0.02f);
break;
case INVISIBLE:
if (parent != null) {
if (invisible != null) invisible.killAndErase();
invisible=new AlphaTweener(this,0.4f,0.4f);
parent.add(invisible);
}
 else alpha(0.4f);
break;
case PARALYSED:
paused=true;
break;
case FROZEN:
iceBlock=IceBlock.freeze(this);
paused=true;
break;
case ILLUMINATED:
GameScene.effect(halo=new TorchHalo(this));
break;
case CHILLED:
chilled=emitter();
chilled.pour(SnowParticle.FACTORY,0.1f);
break;
case DARKENED:
darkBlock=DarkBlock.darken(this);
break;
case MARKED:
marked=emitter();
marked.pour(ShadowParticle.UP,0.1f);
break;
case HEALING:
healing=emitter();
healing.pour(Speck.factory(Speck.HEALING),0.5f);
}
}","public void add(State state){
switch (state) {
case BURNING:
    burning=emitter();
  burning.pour(FlameParticle.FACTORY,0.06f);
if (visible) {
  Sample.INSTANCE.play(Assets.SND_BURNING);
}
break;
case LEVITATING:
levitation=emitter();
levitation.pour(Speck.factory(Speck.JET),0.02f);
break;
case INVISIBLE:
if (invisible != null) {
invisible.killAndErase();
}
invisible=new AlphaTweener(this,0.4f,0.4f);
if (parent != null) {
parent.add(invisible);
}
 else alpha(0.4f);
break;
case PARALYSED:
paused=true;
break;
case FROZEN:
iceBlock=IceBlock.freeze(this);
paused=true;
break;
case ILLUMINATED:
GameScene.effect(halo=new TorchHalo(this));
break;
case CHILLED:
chilled=emitter();
chilled.pour(SnowParticle.FACTORY,0.1f);
break;
case DARKENED:
darkBlock=DarkBlock.darken(this);
break;
case MARKED:
marked=emitter();
marked.pour(ShadowParticle.UP,0.1f);
break;
case HEALING:
healing=emitter();
healing.pour(Speck.factory(Speck.HEALING),0.5f);
}
}",0.9501590668080594
163941,"@Override public boolean canConnect(Point p){
  return super.canConnect(p) && p.x > top + 1;
}","@Override public boolean canConnect(Point p){
  return super.canConnect(p) && p.y > top + 1;
}",0.9893617021276596
163942,"@Override public void play(Animation anim){
  if (curAnim != die) {
    super.play(anim);
  }
}","@Override public void play(Animation anim){
  if (curAnim == null || curAnim != die) {
    super.play(anim);
  }
}",0.9090909090909092
163943,"public Plant couch(int pos){
  try {
    if (Dungeon.visible[pos]) {
      Sample.INSTANCE.play(Assets.SND_PLANT);
    }
    Plant plant=plantClass.newInstance();
    plant.pos=pos;
    return plant;
  }
 catch (  Exception e) {
    ShatteredPixelDungeon.reportException(e);
    return null;
  }
}","public Plant couch(int pos){
  try {
    if (Dungeon.visible != null && Dungeon.visible[pos]) {
      Sample.INSTANCE.play(Assets.SND_PLANT);
    }
    Plant plant=plantClass.newInstance();
    plant.pos=pos;
    return plant;
  }
 catch (  Exception e) {
    ShatteredPixelDungeon.reportException(e);
    return null;
  }
}",0.9565217391304348
163944,"public static void refreshHero(){
  if (heroInstance != null) {
    heroInstance.layout();
  }
}","public static void refreshHero(){
  if (heroInstance != null) {
    heroInstance.needsRefresh=true;
  }
}",0.8855721393034826
163945,"@Override protected boolean canAttack(Char enemy){
  if (beamCooldown == 0) {
    Ballistica aim=new Ballistica(pos,enemy.pos,Ballistica.STOP_TERRAIN);
    if (enemy.invisible == 0 && Level.fieldOfView[enemy.pos] && aim.subPath(1,aim.dist).contains(enemy.pos)) {
      beam=aim;
      beamTarget=aim.collisionPos;
      return true;
    }
 else     return beamCharged;
  }
 else   return super.canAttack(enemy);
}","@Override protected boolean canAttack(Char enemy){
  if (beamCooldown == 0) {
    Ballistica aim=new Ballistica(pos,enemy.pos,Ballistica.STOP_TERRAIN);
    if (enemy.invisible == 0 && !isCharmedBy(enemy) && Level.fieldOfView[enemy.pos] && aim.subPath(1,aim.dist).contains(enemy.pos)) {
      beam=aim;
      beamTarget=aim.collisionPos;
      return true;
    }
 else     return beamCharged;
  }
 else   return super.canAttack(enemy);
}",0.972909305064782
163946,"@Override public boolean act(boolean enemyInFOV,boolean justAlerted){
  if (beamCharged && enemy != null)   enemyInFOV=true;
  return super.act(enemyInFOV,justAlerted);
}","@Override public boolean act(boolean enemyInFOV,boolean justAlerted){
  if (beamCharged && canAttack(enemy)) {
    enemySeen=enemyInFOV;
    return doAttack(enemy);
  }
  return super.act(enemyInFOV,justAlerted);
}",0.7760416666666666
163947,"@Override public boolean interact(){
  updateRose();
  if (rose != null && !rose.talkedTo) {
    rose.talkedTo=true;
    GameScene.show(new WndQuest(this,Messages.get(this,""String_Node_Str"")));
    return false;
  }
 else {
    int curPos=pos;
    moveSprite(pos,Dungeon.hero.pos);
    move(Dungeon.hero.pos);
    Dungeon.hero.sprite.move(Dungeon.hero.pos,curPos);
    Dungeon.hero.move(curPos);
    Dungeon.hero.spend(1 / Dungeon.hero.speed());
    Dungeon.hero.busy();
    return true;
  }
}","@Override public boolean interact(){
  updateRose();
  if (rose != null && !rose.talkedTo) {
    rose.talkedTo=true;
    GameScene.show(new WndQuest(this,Messages.get(this,""String_Node_Str"")));
    return false;
  }
 else   if (Level.passable[pos] || Dungeon.hero.flying) {
    int curPos=pos;
    moveSprite(pos,Dungeon.hero.pos);
    move(Dungeon.hero.pos);
    Dungeon.hero.sprite.move(Dungeon.hero.pos,curPos);
    Dungeon.hero.move(curPos);
    Dungeon.hero.spend(1 / Dungeon.hero.speed());
    Dungeon.hero.busy();
    return true;
  }
 else {
    return false;
  }
}",0.924953095684803
163948,"@Override protected void onZap(Ballistica bolt){
  Char ch=Actor.findChar(bolt.collisionPos);
  if (ch != null) {
    if (ch.buff(Corruption.class) != null) {
      GLog.w(Messages.get(this,""String_Node_Str""));
      return;
    }
    if (ch.properties().contains(Char.Property.BOSS) || ch.properties().contains(Char.Property.MINIBOSS)) {
      GLog.w(Messages.get(this,""String_Node_Str""));
      return;
    }
    int basePower=10 + 2 * level();
    int mobPower=Random.IntRange(0,ch.HT) + ch.HP * 2;
    for (    Buff buff : ch.buffs()) {
      if (buff.type == Buff.buffType.NEGATIVE) {
        mobPower*=0.67;
        break;
      }
    }
    int extraCharges=0;
    while (basePower <= mobPower) {
      extraCharges++;
      basePower+=5 + level();
    }
    if (extraCharges >= curCharges) {
      curCharges=1;
      GLog.w(Messages.get(this,""String_Node_Str""));
      return;
    }
    Buff.append(ch,Corruption.class);
    ch.HP=ch.HT;
    curCharges-=extraCharges;
    usagesToKnow-=extraCharges;
    processSoulMark(ch,extraCharges + chargesPerCast());
  }
}","@Override protected void onZap(Ballistica bolt){
  Char ch=Actor.findChar(bolt.collisionPos);
  if (ch != null && !(ch instanceof NPC)) {
    if (ch.buff(Corruption.class) != null) {
      GLog.w(Messages.get(this,""String_Node_Str""));
      return;
    }
    if (ch.properties().contains(Char.Property.BOSS) || ch.properties().contains(Char.Property.MINIBOSS)) {
      GLog.w(Messages.get(this,""String_Node_Str""));
      return;
    }
    int basePower=10 + 2 * level();
    int mobPower=Random.IntRange(0,ch.HT) + ch.HP * 2;
    for (    Buff buff : ch.buffs()) {
      if (buff.type == Buff.buffType.NEGATIVE) {
        mobPower*=0.67;
        break;
      }
    }
    int extraCharges=0;
    while (basePower <= mobPower) {
      extraCharges++;
      basePower+=5 + level();
    }
    if (extraCharges >= curCharges) {
      curCharges=1;
      GLog.w(Messages.get(this,""String_Node_Str""));
      return;
    }
    Buff.append(ch,Corruption.class);
    ch.HP=ch.HT;
    curCharges-=extraCharges;
    usagesToKnow-=extraCharges;
    processSoulMark(ch,extraCharges + chargesPerCast());
  }
}",0.988909426987061
163949,"private void recreateLines(){
  for (  Entry entry : entries) {
    lastEntry=PixelScene.renderMultiline(entry.text,6);
    lastEntry.hardlight(lastColor=entry.color);
    add(lastEntry);
  }
}","private synchronized void recreateLines(){
  for (  Entry entry : entries) {
    lastEntry=PixelScene.renderMultiline(entry.text,6);
    lastEntry.hardlight(lastColor=entry.color);
    add(lastEntry);
  }
}",0.9674185463659148
163950,"public void newLine(){
  lastEntry=null;
}","public synchronized void newLine(){
  lastEntry=null;
}",0.865979381443299
163951,"@Override public void onSignal(String text){
  if (length != entries.size()) {
    clear();
    recreateLines();
  }
  int color=CharSprite.DEFAULT;
  if (text.startsWith(GLog.POSITIVE)) {
    text=text.substring(GLog.POSITIVE.length());
    color=CharSprite.POSITIVE;
  }
 else   if (text.startsWith(GLog.NEGATIVE)) {
    text=text.substring(GLog.NEGATIVE.length());
    color=CharSprite.NEGATIVE;
  }
 else   if (text.startsWith(GLog.WARNING)) {
    text=text.substring(GLog.WARNING.length());
    color=CharSprite.WARNING;
  }
 else   if (text.startsWith(GLog.HIGHLIGHT)) {
    text=text.substring(GLog.HIGHLIGHT.length());
    color=CharSprite.NEUTRAL;
  }
  if (lastEntry != null && color == lastColor && lastEntry.nLines < MAX_LINES) {
    String lastMessage=lastEntry.text();
    lastEntry.text(lastMessage.length() == 0 ? text : lastMessage + ""String_Node_Str"" + text);
    entries.get(entries.size() - 1).text=lastEntry.text();
  }
 else {
    lastEntry=PixelScene.renderMultiline(text,6);
    lastEntry.hardlight(color);
    lastColor=color;
    add(lastEntry);
    entries.add(new Entry(text,color));
  }
  if (length > 0) {
    int nLines;
    do {
      nLines=0;
      for (int i=0; i < length - 1; i++) {
        nLines+=((RenderedTextMultiline)members.get(i)).nLines;
      }
      if (nLines > MAX_LINES) {
        RenderedTextMultiline r=((RenderedTextMultiline)members.get(0));
        remove(r);
        r.destroy();
        entries.remove(0);
      }
    }
 while (nLines > MAX_LINES);
    if (entries.isEmpty()) {
      lastEntry=null;
    }
  }
  layout();
}","@Override public synchronized void onSignal(String text){
  if (length != entries.size()) {
    clear();
    recreateLines();
  }
  int color=CharSprite.DEFAULT;
  if (text.startsWith(GLog.POSITIVE)) {
    text=text.substring(GLog.POSITIVE.length());
    color=CharSprite.POSITIVE;
  }
 else   if (text.startsWith(GLog.NEGATIVE)) {
    text=text.substring(GLog.NEGATIVE.length());
    color=CharSprite.NEGATIVE;
  }
 else   if (text.startsWith(GLog.WARNING)) {
    text=text.substring(GLog.WARNING.length());
    color=CharSprite.WARNING;
  }
 else   if (text.startsWith(GLog.HIGHLIGHT)) {
    text=text.substring(GLog.HIGHLIGHT.length());
    color=CharSprite.NEUTRAL;
  }
  if (lastEntry != null && color == lastColor && lastEntry.nLines < MAX_LINES) {
    String lastMessage=lastEntry.text();
    lastEntry.text(lastMessage.length() == 0 ? text : lastMessage + ""String_Node_Str"" + text);
    entries.get(entries.size() - 1).text=lastEntry.text();
  }
 else {
    lastEntry=PixelScene.renderMultiline(text,6);
    lastEntry.hardlight(color);
    lastColor=color;
    add(lastEntry);
    entries.add(new Entry(text,color));
  }
  if (length > 0) {
    int nLines;
    do {
      nLines=0;
      for (int i=0; i < length - 1; i++) {
        nLines+=((RenderedTextMultiline)members.get(i)).nLines;
      }
      if (nLines > MAX_LINES) {
        RenderedTextMultiline r=((RenderedTextMultiline)members.get(0));
        remove(r);
        r.destroy();
        entries.remove(0);
      }
    }
 while (nLines > MAX_LINES);
    if (entries.isEmpty()) {
      lastEntry=null;
    }
  }
  layout();
}",0.9959055118110236
163952,"protected static Rect findFreeSpace(Point start,ArrayList<Room> collision,int maxSize){
  Rect space=new Rect(start.x - maxSize,start.y - maxSize,start.x + maxSize,start.y + maxSize);
  ArrayList<Room> colliding=new ArrayList<>(collision);
  do {
    Iterator<Room> it=colliding.iterator();
    while (it.hasNext()) {
      Room room=it.next();
      if (Math.max(space.left,room.left) >= Math.min(space.right,room.right) || Math.max(space.top,room.top) >= Math.min(space.bottom,room.bottom)) {
        it.remove();
      }
    }
    Room closestRoom=null;
    int closestDiff=Integer.MAX_VALUE;
    boolean inside=true;
    int curDiff=0;
    for (    Room curRoom : colliding) {
      if (start.x <= curRoom.left) {
        inside=false;
        curDiff+=curRoom.left - start.x;
      }
 else       if (start.x >= curRoom.right) {
        inside=false;
        curDiff+=start.x - curRoom.right;
      }
      if (start.y <= curRoom.top) {
        inside=false;
        curDiff+=curRoom.top - start.y;
      }
 else       if (start.y >= curRoom.bottom) {
        inside=false;
        curDiff+=start.y - curRoom.bottom;
      }
      if (inside) {
        space.set(start.x,start.y,start.x,start.y);
        return space;
      }
      if (curDiff < closestDiff) {
        closestDiff=curDiff;
        closestRoom=curRoom;
      }
    }
    int wDiff, hDiff;
    if (closestRoom != null) {
      wDiff=Integer.MAX_VALUE;
      if (closestRoom.left >= start.x) {
        wDiff=(space.right - closestRoom.left) * (space.height() + 1);
      }
 else       if (closestRoom.right <= start.x) {
        wDiff=(closestRoom.right - space.left) * (space.height() + 1);
      }
      hDiff=Integer.MAX_VALUE;
      if (closestRoom.top >= start.y) {
        hDiff=(space.bottom - closestRoom.top) * (space.width() + 1);
      }
 else       if (closestRoom.bottom <= start.y) {
        hDiff=(closestRoom.bottom - space.top) * (space.width() + 1);
      }
      if (wDiff < hDiff || wDiff == hDiff && Random.Int(2) == 0) {
        if (closestRoom.left >= start.x && closestRoom.left < space.right)         space.right=closestRoom.left;
        if (closestRoom.right <= start.x && closestRoom.right > space.left)         space.left=closestRoom.right;
      }
 else {
        if (closestRoom.top >= start.y && closestRoom.top < space.bottom)         space.bottom=closestRoom.top;
        if (closestRoom.bottom <= start.y && closestRoom.bottom > space.top)         space.top=closestRoom.bottom;
      }
      colliding.remove(closestRoom);
    }
 else {
      colliding.clear();
    }
  }
 while (!colliding.isEmpty());
  return space;
}","protected static Rect findFreeSpace(Point start,ArrayList<Room> collision,int maxSize){
  Rect space=new Rect(start.x - maxSize,start.y - maxSize,start.x + maxSize,start.y + maxSize);
  ArrayList<Room> colliding=new ArrayList<>(collision);
  do {
    Iterator<Room> it=colliding.iterator();
    while (it.hasNext()) {
      Room room=it.next();
      if (room.isEmpty() || Math.max(space.left,room.left) >= Math.min(space.right,room.right) || Math.max(space.top,room.top) >= Math.min(space.bottom,room.bottom)) {
        it.remove();
      }
    }
    Room closestRoom=null;
    int closestDiff=Integer.MAX_VALUE;
    boolean inside=true;
    int curDiff=0;
    for (    Room curRoom : colliding) {
      if (start.x <= curRoom.left) {
        inside=false;
        curDiff+=curRoom.left - start.x;
      }
 else       if (start.x >= curRoom.right) {
        inside=false;
        curDiff+=start.x - curRoom.right;
      }
      if (start.y <= curRoom.top) {
        inside=false;
        curDiff+=curRoom.top - start.y;
      }
 else       if (start.y >= curRoom.bottom) {
        inside=false;
        curDiff+=start.y - curRoom.bottom;
      }
      if (inside) {
        space.set(start.x,start.y,start.x,start.y);
        return space;
      }
      if (curDiff < closestDiff) {
        closestDiff=curDiff;
        closestRoom=curRoom;
      }
    }
    int wDiff, hDiff;
    if (closestRoom != null) {
      wDiff=Integer.MAX_VALUE;
      if (closestRoom.left >= start.x) {
        wDiff=(space.right - closestRoom.left) * (space.height() + 1);
      }
 else       if (closestRoom.right <= start.x) {
        wDiff=(closestRoom.right - space.left) * (space.height() + 1);
      }
      hDiff=Integer.MAX_VALUE;
      if (closestRoom.top >= start.y) {
        hDiff=(space.bottom - closestRoom.top) * (space.width() + 1);
      }
 else       if (closestRoom.bottom <= start.y) {
        hDiff=(closestRoom.bottom - space.top) * (space.width() + 1);
      }
      if (wDiff < hDiff || wDiff == hDiff && Random.Int(2) == 0) {
        if (closestRoom.left >= start.x && closestRoom.left < space.right)         space.right=closestRoom.left;
        if (closestRoom.right <= start.x && closestRoom.right > space.left)         space.left=closestRoom.right;
      }
 else {
        if (closestRoom.top >= start.y && closestRoom.top < space.bottom)         space.bottom=closestRoom.top;
        if (closestRoom.bottom <= start.y && closestRoom.bottom > space.top)         space.top=closestRoom.bottom;
      }
      colliding.remove(closestRoom);
    }
 else {
      colliding.clear();
    }
  }
 while (!colliding.isEmpty());
  return space;
}",0.9965818458032664
163953,"protected void setupRooms(ArrayList<Room> rooms){
  entrance=exit=shop=null;
  singleConnections.clear();
  multiConnections.clear();
  for (  Room r : rooms) {
    if (r instanceof EntranceRoom) {
      entrance=r;
    }
 else     if (r instanceof ExitRoom) {
      exit=r;
    }
 else     if (r instanceof ShopRoom && r.maxConnections(Room.ALL) == 1) {
      shop=r;
    }
 else     if (r.maxConnections(Room.ALL) > 1) {
      multiConnections.add(r);
    }
 else     if (r.maxConnections(Room.ALL) == 1) {
      singleConnections.add(r);
    }
  }
  weightRooms(multiConnections);
  Random.shuffle(multiConnections);
  multiConnections=new ArrayList<>(new LinkedHashSet<>(multiConnections));
}","protected void setupRooms(ArrayList<Room> rooms){
  for (  Room r : rooms) {
    r.setEmpty();
  }
  entrance=exit=shop=null;
  singleConnections.clear();
  multiConnections.clear();
  for (  Room r : rooms) {
    if (r instanceof EntranceRoom) {
      entrance=r;
    }
 else     if (r instanceof ExitRoom) {
      exit=r;
    }
 else     if (r instanceof ShopRoom && r.maxConnections(Room.ALL) == 1) {
      shop=r;
    }
 else     if (r.maxConnections(Room.ALL) > 1) {
      multiConnections.add(r);
    }
 else     if (r.maxConnections(Room.ALL) == 1) {
      singleConnections.add(r);
    }
  }
  weightRooms(multiConnections);
  Random.shuffle(multiConnections);
  multiConnections=new ArrayList<>(new LinkedHashSet<>(multiConnections));
}",0.965995836224844
163954,"private void fillBetweenPoints(Level level,Point from,Point to,int floor){
  if (from.y == to.y || from.x == to.x) {
    Painter.fill(level,Math.min(from.x,to.x),Math.min(from.y,to.y),spaceBetween(from.x,to.x) + 2,spaceBetween(from.y,to.y) + 2,floor);
    return;
  }
  if (corners == null) {
    corners=new Point[4];
    corners[0]=new Point(left + 2,top + 2);
    corners[1]=new Point(right - 2,top + 2);
    corners[2]=new Point(right - 2,bottom - 2);
    corners[3]=new Point(left + 2,bottom - 2);
  }
  for (  Point c : corners) {
    if ((c.x == from.x || c.y == from.y) && (c.x == to.x || c.y == to.y)) {
      Painter.drawLine(level,from,c,floor);
      Painter.drawLine(level,c,to,floor);
      return;
    }
  }
  Point side;
  if (from.y == top + 1 || from.y == bottom - 1) {
    if (spaceBetween(left,from.x) + spaceBetween(left,to.x) <= spaceBetween(right,from.x) + spaceBetween(right,to.x)) {
      side=new Point(left + 1,top + height() / 2);
    }
 else {
      side=new Point(right - 1,top + height() / 2);
    }
  }
 else {
    if (spaceBetween(top,from.y) + spaceBetween(top,to.y) <= spaceBetween(bottom,from.y) + spaceBetween(bottom,to.y)) {
      side=new Point(left + width() / 2,top + 1);
    }
 else {
      side=new Point(left + width() / 2,bottom - 1);
    }
  }
  fillBetweenPoints(level,from,side,floor);
  fillBetweenPoints(level,side,to,floor);
}","private void fillBetweenPoints(Level level,Point from,Point to,int floor){
  if (from.y == to.y || from.x == to.x) {
    Painter.fill(level,Math.min(from.x,to.x),Math.min(from.y,to.y),spaceBetween(from.x,to.x) + 2,spaceBetween(from.y,to.y) + 2,floor);
    return;
  }
  if (corners == null) {
    corners=new Point[4];
    corners[0]=new Point(left + 2,top + 2);
    corners[1]=new Point(right - 2,top + 2);
    corners[2]=new Point(right - 2,bottom - 2);
    corners[3]=new Point(left + 2,bottom - 2);
  }
  for (  Point c : corners) {
    if ((c.x == from.x || c.y == from.y) && (c.x == to.x || c.y == to.y)) {
      Painter.drawLine(level,from,c,floor);
      Painter.drawLine(level,c,to,floor);
      return;
    }
  }
  Point side;
  if (from.y == top + 2 || from.y == bottom - 2) {
    if (spaceBetween(left,from.x) + spaceBetween(left,to.x) <= spaceBetween(right,from.x) + spaceBetween(right,to.x)) {
      side=new Point(left + 2,top + height() / 2);
    }
 else {
      side=new Point(right - 2,top + height() / 2);
    }
  }
 else {
    if (spaceBetween(top,from.y) + spaceBetween(top,to.y) <= spaceBetween(bottom,from.y) + spaceBetween(bottom,to.y)) {
      side=new Point(left + width() / 2,top + 2);
    }
 else {
      side=new Point(left + width() / 2,bottom - 2);
    }
  }
  fillBetweenPoints(level,from,side,floor);
  fillBetweenPoints(level,side,to,floor);
}",0.9956427015250544
163955,"@Override public void paint(Level level){
  Painter.fill(level,this,Terrain.WALL);
  Rect c=getConnectionSpace();
  if (connected.size() <= 3) {
    for (    Door door : connected.values()) {
      Point start;
      Point mid;
      Point end;
      start=new Point(door);
      if (start.x == left)       start.x+=2;
 else       if (start.y == top)       start.y+=2;
 else       if (start.x == right)       start.x-=2;
 else       if (start.y == bottom)       start.y-=2;
      int rightShift;
      int downShift;
      if (start.x < c.left)       rightShift=c.left - start.x;
 else       if (start.x > c.right)       rightShift=c.right - start.x;
 else       rightShift=0;
      if (start.y < c.top)       downShift=c.top - start.y;
 else       if (start.y > c.bottom)       downShift=c.bottom - start.y;
 else       downShift=0;
      if (door.x == left || door.x == right) {
        mid=new Point(start.x + rightShift,start.y);
        end=new Point(mid.x,mid.y + downShift);
      }
 else {
        mid=new Point(start.x,start.y + downShift);
        end=new Point(mid.x + rightShift,mid.y);
      }
      Painter.drawLine(level,start,mid,Terrain.WATER);
      Painter.drawLine(level,mid,end,Terrain.WATER);
    }
  }
 else {
    ArrayList<Point> pointsToFill=new ArrayList<>();
    for (    Point door : connected.values()) {
      Point p=new Point(door);
      if (p.y == top) {
        p.y+=2;
      }
 else       if (p.y == bottom) {
        p.y-=2;
      }
 else       if (p.x == left) {
        p.x+=2;
      }
 else {
        p.x-=2;
      }
      pointsToFill.add(p);
    }
    ArrayList<Point> pointsFilled=new ArrayList<>();
    pointsFilled.add(pointsToFill.remove(0));
    Point from=null, to=null;
    int shortestDistance;
    while (!pointsToFill.isEmpty()) {
      shortestDistance=Integer.MAX_VALUE;
      for (      Point f : pointsFilled) {
        for (        Point t : pointsToFill) {
          int dist=distanceBetweenPoints(f,t);
          if (dist < shortestDistance) {
            from=f;
            to=t;
            shortestDistance=dist;
          }
        }
      }
      fillBetweenPoints(level,from,to,Terrain.WATER);
      pointsFilled.add(to);
      pointsToFill.remove(to);
    }
  }
  for (  Point p : getPoints()) {
    int cell=level.pointToCell(p);
    if (level.map[cell] == Terrain.WATER) {
      for (      int i : PathFinder.NEIGHBOURS8) {
        if (level.map[cell + i] == Terrain.WALL) {
          Painter.set(level,cell + i,Terrain.EMPTY);
        }
      }
    }
  }
  for (  Door door : connected.values()) {
    door.set(Door.Type.UNLOCKED);
  }
}","@Override public void paint(Level level){
  Painter.fill(level,this,Terrain.WALL);
  Rect c=getConnectionSpace();
  if (connected.size() <= 2) {
    for (    Door door : connected.values()) {
      Point start;
      Point mid;
      Point end;
      start=new Point(door);
      if (start.x == left)       start.x+=2;
 else       if (start.y == top)       start.y+=2;
 else       if (start.x == right)       start.x-=2;
 else       if (start.y == bottom)       start.y-=2;
      int rightShift;
      int downShift;
      if (start.x < c.left)       rightShift=c.left - start.x;
 else       if (start.x > c.right)       rightShift=c.right - start.x;
 else       rightShift=0;
      if (start.y < c.top)       downShift=c.top - start.y;
 else       if (start.y > c.bottom)       downShift=c.bottom - start.y;
 else       downShift=0;
      if (door.x == left || door.x == right) {
        mid=new Point(start.x + rightShift,start.y);
        end=new Point(mid.x,mid.y + downShift);
      }
 else {
        mid=new Point(start.x,start.y + downShift);
        end=new Point(mid.x + rightShift,mid.y);
      }
      Painter.drawLine(level,start,mid,Terrain.WATER);
      Painter.drawLine(level,mid,end,Terrain.WATER);
    }
  }
 else {
    ArrayList<Point> pointsToFill=new ArrayList<>();
    for (    Point door : connected.values()) {
      Point p=new Point(door);
      if (p.y == top) {
        p.y+=2;
      }
 else       if (p.y == bottom) {
        p.y-=2;
      }
 else       if (p.x == left) {
        p.x+=2;
      }
 else {
        p.x-=2;
      }
      pointsToFill.add(p);
    }
    ArrayList<Point> pointsFilled=new ArrayList<>();
    pointsFilled.add(pointsToFill.remove(0));
    Point from=null, to=null;
    int shortestDistance;
    while (!pointsToFill.isEmpty()) {
      shortestDistance=Integer.MAX_VALUE;
      for (      Point f : pointsFilled) {
        for (        Point t : pointsToFill) {
          int dist=distanceBetweenPoints(f,t);
          if (dist < shortestDistance) {
            from=f;
            to=t;
            shortestDistance=dist;
          }
        }
      }
      fillBetweenPoints(level,from,to,Terrain.WATER);
      pointsFilled.add(to);
      pointsToFill.remove(to);
    }
  }
  for (  Point p : getPoints()) {
    int cell=level.pointToCell(p);
    if (level.map[cell] == Terrain.WATER) {
      for (      int i : PathFinder.NEIGHBOURS8) {
        if (level.map[cell + i] == Terrain.WALL) {
          Painter.set(level,cell + i,Terrain.EMPTY);
        }
      }
    }
  }
  for (  Door door : connected.values()) {
    door.set(Door.Type.UNLOCKED);
  }
}",0.9996164173379364
163956,"public static void process(){
  if (spawned && given && !processed&& (depth == Dungeon.depth)) {
    GLog.n(Messages.get(Ghost.class,""String_Node_Str""));
    Sample.INSTANCE.play(Assets.SND_GHOST);
    processed=true;
    Generator.Category.ARTIFACT.probs[10]=1;
  }
}","public static void process(){
  if (spawned && given && !processed&& (depth == Dungeon.depth)) {
    GLog.n(Messages.get(Ghost.class,""String_Node_Str""));
    Sample.INSTANCE.play(Assets.SND_GHOST);
    processed=true;
  }
}",0.9083503054989815
163957,"public static boolean completed(){
  return spawned && processed;
}","public static boolean completed(){
  return processed() && weapon == null && armor == null;
}",0.7
163958,"@Override public float speed(){
  return Quest.completed() ? 2f : 0.5f;
}","@Override public float speed(){
  return Quest.processed() ? 2f : 0.5f;
}",0.9315068493150684
163959,"@Override protected boolean act(){
  if (Quest.completed())   target=Dungeon.hero.pos;
  return super.act();
}","@Override protected boolean act(){
  if (Quest.processed())   target=Dungeon.hero.pos;
  return super.act();
}",0.9545454545454546
163960,"public static void initArtifacts(){
  Category.ARTIFACT.probs=Category.INITIAL_ARTIFACT_PROBS.clone();
  if (Ghost.Quest.completed())   Category.ARTIFACT.probs[10]=1;
  spawnedArtifacts=new ArrayList<>();
}","public static void initArtifacts(){
  Category.ARTIFACT.probs=Category.INITIAL_ARTIFACT_PROBS.clone();
  spawnedArtifacts=new ArrayList<>();
}",0.8160919540229885
163961,"@Override public String status(){
  if (cooldown != 0)   return Messages.format(""String_Node_Str"",cooldown);
  if (chargeCap == 100)   return Messages.format(""String_Node_Str"",charge);
  if (chargeCap > 0)   return Messages.format(""String_Node_Str"",charge,chargeCap);
  if (charge != 0)   return Messages.format(""String_Node_Str"",charge);
  return null;
}","@Override public String status(){
  if (!isIdentified() || cursed) {
    return null;
  }
  if (cooldown != 0)   return Messages.format(""String_Node_Str"",cooldown);
  if (chargeCap == 100)   return Messages.format(""String_Node_Str"",charge);
  if (chargeCap > 0)   return Messages.format(""String_Node_Str"",charge,chargeCap);
  if (charge != 0)   return Messages.format(""String_Node_Str"",charge);
  return null;
}",0.9268929503916448
163962,"public static void restoreGhostHero(Level level,int pos){
  if (heldGhost != null) {
    level.mobs.add(heldGhost);
    int ghostPos;
    do {
      ghostPos=pos + PathFinder.NEIGHBOURS8[Random.Int(8)];
    }
 while (Level.solid[ghostPos] || level.findMob(ghostPos) != null);
    heldGhost.pos=pos;
    heldGhost=null;
  }
}","public static void restoreGhostHero(Level level,int pos){
  if (heldGhost != null) {
    level.mobs.add(heldGhost);
    int ghostPos;
    do {
      ghostPos=pos + PathFinder.NEIGHBOURS8[Random.Int(8)];
    }
 while (Level.solid[ghostPos] || level.findMob(ghostPos) != null);
    heldGhost.pos=ghostPos;
    heldGhost=null;
  }
}",0.9892802450229708
163963,"@Override public ArrayList<String> actions(Hero hero){
  ArrayList<String> actions=super.actions(hero);
  if (isEquipped(hero) && charge == chargeCap && !cursed) {
    actions.add(AC_SUMMON);
  }
  if (isIdentified() && !cursed) {
    actions.add(AC_OUTFIT);
  }
  return actions;
}","@Override public ArrayList<String> actions(Hero hero){
  ArrayList<String> actions=super.actions(hero);
  if (!Ghost.Quest.completed()) {
    actions.remove(AC_EQUIP);
    return actions;
  }
  if (isEquipped(hero) && charge == chargeCap && !cursed) {
    actions.add(AC_SUMMON);
  }
  if (isIdentified() && !cursed) {
    actions.add(AC_OUTFIT);
  }
  return actions;
}",0.8650306748466258
163964,"@Override public String desc(){
  String desc=super.desc();
  if (isEquipped(Dungeon.hero)) {
    if (!cursed) {
      if (level() < levelCap)       desc+=""String_Node_Str"" + Messages.get(this,""String_Node_Str"");
    }
 else     desc+=""String_Node_Str"" + Messages.get(this,""String_Node_Str"");
  }
  return desc;
}","@Override public String desc(){
  if (!Ghost.Quest.completed() && !isIdentified()) {
    return Messages.get(this,""String_Node_Str"");
  }
  String desc=super.desc();
  if (isEquipped(Dungeon.hero)) {
    if (!cursed) {
      if (level() < levelCap)       desc+=""String_Node_Str"" + Messages.get(this,""String_Node_Str"");
    }
 else     desc+=""String_Node_Str"" + Messages.get(this,""String_Node_Str"");
  }
  return desc;
}",0.855191256830601
163965,"public void create(){
  Random.seed(Dungeon.seedCurDepth());
  if (!(Dungeon.bossLevel() || Dungeon.depth == 21)) {
    addItemToSpawn(Generator.random(Generator.Category.FOOD));
    if (Dungeon.posNeeded()) {
      addItemToSpawn(new PotionOfStrength());
      Dungeon.LimitedDrops.STRENGTH_POTIONS.count++;
    }
    if (Dungeon.souNeeded()) {
      addItemToSpawn(new ScrollOfUpgrade());
      Dungeon.LimitedDrops.UPGRADE_SCROLLS.count++;
    }
    if (Dungeon.asNeeded()) {
      addItemToSpawn(new Stylus());
      Dungeon.LimitedDrops.ARCANE_STYLI.count++;
    }
    DriedRose rose=Dungeon.hero.belongings.getItem(DriedRose.class);
    if (rose != null && !rose.cursed) {
      int petalsNeeded=(int)Math.ceil((float)((Dungeon.depth / 2) - rose.droppedPetals) / 3);
      for (int i=1; i <= petalsNeeded; i++) {
        if (rose.droppedPetals < 11) {
          addItemToSpawn(new DriedRose.Petal());
          rose.droppedPetals++;
        }
      }
    }
    if (Dungeon.depth > 1) {
switch (Random.Int(10)) {
case 0:
        if (!Dungeon.bossLevel(Dungeon.depth + 1)) {
          feeling=Feeling.CHASM;
        }
      break;
case 1:
    feeling=Feeling.WATER;
  break;
case 2:
feeling=Feeling.GRASS;
break;
case 3:
feeling=Feeling.DARK;
addItemToSpawn(new Torch());
viewDistance=Math.round(viewDistance / 2f);
break;
}
}
}
do {
width=height=length=0;
mobs=new HashSet<>();
heaps=new SparseArray<>();
blobs=new HashMap<>();
plants=new SparseArray<>();
traps=new SparseArray<>();
customTiles=new HashSet<>();
customWalls=new HashSet<>();
}
 while (!build());
buildFlagMaps();
cleanWalls();
createMobs();
createItems();
Random.seed();
}","public void create(){
  Random.seed(Dungeon.seedCurDepth());
  if (!(Dungeon.bossLevel() || Dungeon.depth == 21)) {
    addItemToSpawn(Generator.random(Generator.Category.FOOD));
    if (Dungeon.posNeeded()) {
      addItemToSpawn(new PotionOfStrength());
      Dungeon.LimitedDrops.STRENGTH_POTIONS.count++;
    }
    if (Dungeon.souNeeded()) {
      addItemToSpawn(new ScrollOfUpgrade());
      Dungeon.LimitedDrops.UPGRADE_SCROLLS.count++;
    }
    if (Dungeon.asNeeded()) {
      addItemToSpawn(new Stylus());
      Dungeon.LimitedDrops.ARCANE_STYLI.count++;
    }
    DriedRose rose=Dungeon.hero.belongings.getItem(DriedRose.class);
    if (rose != null && rose.isIdentified() && !rose.cursed) {
      int petalsNeeded=(int)Math.ceil((float)((Dungeon.depth / 2) - rose.droppedPetals) / 3);
      for (int i=1; i <= petalsNeeded; i++) {
        if (rose.droppedPetals < 11) {
          addItemToSpawn(new DriedRose.Petal());
          rose.droppedPetals++;
        }
      }
    }
    if (Dungeon.depth > 1) {
switch (Random.Int(10)) {
case 0:
        if (!Dungeon.bossLevel(Dungeon.depth + 1)) {
          feeling=Feeling.CHASM;
        }
      break;
case 1:
    feeling=Feeling.WATER;
  break;
case 2:
feeling=Feeling.GRASS;
break;
case 3:
feeling=Feeling.DARK;
addItemToSpawn(new Torch());
viewDistance=Math.round(viewDistance / 2f);
break;
}
}
}
do {
width=height=length=0;
mobs=new HashSet<>();
heaps=new SparseArray<>();
blobs=new HashMap<>();
plants=new SparseArray<>();
traps=new SparseArray<>();
customTiles=new HashSet<>();
customWalls=new HashSet<>();
}
 while (!build());
buildFlagMaps();
cleanWalls();
createMobs();
createItems();
Random.seed();
}",0.993049259595044
163966,"@Override protected void onClick(){
  if (rose.armor != null) {
    if (rose.armor.doPickUp(Dungeon.hero)) {
      item(new WndBag.Placeholder(ItemSpriteSheet.ARMOR_HOLDER));
    }
 else {
      Dungeon.level.drop(rose.armor,Dungeon.hero.pos);
    }
    rose.armor=null;
  }
 else {
    GameScene.selectItem(new WndBag.Listener(){
      @Override public void onSelect(      Item item){
        if (!(item instanceof Armor)) {
        }
 else         if (item.unique || ((Armor)item).checkSeal() != null) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else         if (!item.isIdentified()) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else         if (item.cursed) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else         if (((Armor)item).STRReq() > rose.ghostStrength()) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else {
          if (item.isEquipped(Dungeon.hero)) {
            ((Armor)item).doUnequip(Dungeon.hero,false,false);
          }
 else {
            item.detach(Dungeon.hero.belongings.backpack);
          }
          rose.armor=(Armor)item;
          item(rose.armor);
        }
      }
    }
,WndBag.Mode.ARMOR,Messages.get(WndGhostHero.class,""String_Node_Str""));
  }
}","@Override protected void onClick(){
  if (rose.armor != null) {
    item(new WndBag.Placeholder(ItemSpriteSheet.ARMOR_HOLDER));
    if (!rose.armor.doPickUp(Dungeon.hero)) {
      Dungeon.level.drop(rose.armor,Dungeon.hero.pos);
    }
    rose.armor=null;
  }
 else {
    GameScene.selectItem(new WndBag.Listener(){
      @Override public void onSelect(      Item item){
        if (!(item instanceof Armor)) {
        }
 else         if (item.unique || ((Armor)item).checkSeal() != null) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else         if (!item.isIdentified()) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else         if (item.cursed) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else         if (((Armor)item).STRReq() > rose.ghostStrength()) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else {
          if (item.isEquipped(Dungeon.hero)) {
            ((Armor)item).doUnequip(Dungeon.hero,false,false);
          }
 else {
            item.detach(Dungeon.hero.belongings.backpack);
          }
          rose.armor=(Armor)item;
          item(rose.armor);
        }
      }
    }
,WndBag.Mode.ARMOR,Messages.get(WndGhostHero.class,""String_Node_Str""));
  }
}",0.9668921324314704
163967,"WndGhostHero(final DriedRose rose){
  IconTitle titlebar=new IconTitle();
  titlebar.icon(new ItemSprite(rose));
  titlebar.label(Messages.get(this,""String_Node_Str""));
  titlebar.setRect(0,0,WIDTH,0);
  add(titlebar);
  RenderedTextMultiline message=PixelScene.renderMultiline(Messages.get(this,""String_Node_Str"",rose.ghostStrength()),6);
  message.maxWidth(WIDTH);
  message.setPos(0,titlebar.bottom() + GAP);
  add(message);
  btnWeapon=new WndBlacksmith.ItemButton(){
    @Override protected void onClick(){
      if (rose.weapon != null) {
        if (rose.weapon.doPickUp(Dungeon.hero)) {
          item(new WndBag.Placeholder(ItemSpriteSheet.WEAPON_HOLDER));
        }
 else {
          Dungeon.level.drop(rose.weapon,Dungeon.hero.pos);
        }
        rose.weapon=null;
      }
 else {
        GameScene.selectItem(new WndBag.Listener(){
          @Override public void onSelect(          Item item){
            if (!(item instanceof MeleeWeapon || item instanceof Boomerang)) {
            }
 else             if (item.unique || item instanceof Boomerang) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (!item.isIdentified()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (item.cursed) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (((MeleeWeapon)item).STRReq() > rose.ghostStrength()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else {
              if (item.isEquipped(Dungeon.hero)) {
                ((MeleeWeapon)item).doUnequip(Dungeon.hero,false,false);
              }
 else {
                item.detach(Dungeon.hero.belongings.backpack);
              }
              rose.weapon=(MeleeWeapon)item;
              item(rose.weapon);
            }
          }
        }
,WndBag.Mode.WEAPON,Messages.get(WndGhostHero.class,""String_Node_Str""));
      }
    }
  }
;
  btnWeapon.setRect((WIDTH - BTN_GAP) / 2 - BTN_SIZE,message.top() + message.height() + GAP,BTN_SIZE,BTN_SIZE);
  if (rose.weapon != null) {
    btnWeapon.item(rose.weapon);
  }
 else {
    btnWeapon.item(new WndBag.Placeholder(ItemSpriteSheet.WEAPON_HOLDER));
  }
  add(btnWeapon);
  btnArmor=new WndBlacksmith.ItemButton(){
    @Override protected void onClick(){
      if (rose.armor != null) {
        if (rose.armor.doPickUp(Dungeon.hero)) {
          item(new WndBag.Placeholder(ItemSpriteSheet.ARMOR_HOLDER));
        }
 else {
          Dungeon.level.drop(rose.armor,Dungeon.hero.pos);
        }
        rose.armor=null;
      }
 else {
        GameScene.selectItem(new WndBag.Listener(){
          @Override public void onSelect(          Item item){
            if (!(item instanceof Armor)) {
            }
 else             if (item.unique || ((Armor)item).checkSeal() != null) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (!item.isIdentified()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (item.cursed) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (((Armor)item).STRReq() > rose.ghostStrength()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else {
              if (item.isEquipped(Dungeon.hero)) {
                ((Armor)item).doUnequip(Dungeon.hero,false,false);
              }
 else {
                item.detach(Dungeon.hero.belongings.backpack);
              }
              rose.armor=(Armor)item;
              item(rose.armor);
            }
          }
        }
,WndBag.Mode.ARMOR,Messages.get(WndGhostHero.class,""String_Node_Str""));
      }
    }
  }
;
  btnArmor.setRect(btnWeapon.right() + BTN_GAP,btnWeapon.top(),BTN_SIZE,BTN_SIZE);
  if (rose.armor != null) {
    btnArmor.item(rose.armor);
  }
 else {
    btnArmor.item(new WndBag.Placeholder(ItemSpriteSheet.ARMOR_HOLDER));
  }
  add(btnArmor);
  resize(WIDTH,(int)(btnArmor.bottom() + GAP));
}","WndGhostHero(final DriedRose rose){
  IconTitle titlebar=new IconTitle();
  titlebar.icon(new ItemSprite(rose));
  titlebar.label(Messages.get(this,""String_Node_Str""));
  titlebar.setRect(0,0,WIDTH,0);
  add(titlebar);
  RenderedTextMultiline message=PixelScene.renderMultiline(Messages.get(this,""String_Node_Str"",rose.ghostStrength()),6);
  message.maxWidth(WIDTH);
  message.setPos(0,titlebar.bottom() + GAP);
  add(message);
  btnWeapon=new WndBlacksmith.ItemButton(){
    @Override protected void onClick(){
      if (rose.weapon != null) {
        item(new WndBag.Placeholder(ItemSpriteSheet.WEAPON_HOLDER));
        if (!rose.weapon.doPickUp(Dungeon.hero)) {
          Dungeon.level.drop(rose.weapon,Dungeon.hero.pos);
        }
        rose.weapon=null;
      }
 else {
        GameScene.selectItem(new WndBag.Listener(){
          @Override public void onSelect(          Item item){
            if (!(item instanceof MeleeWeapon || item instanceof Boomerang)) {
            }
 else             if (item.unique || item instanceof Boomerang) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (!item.isIdentified()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (item.cursed) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (((MeleeWeapon)item).STRReq() > rose.ghostStrength()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else {
              if (item.isEquipped(Dungeon.hero)) {
                ((MeleeWeapon)item).doUnequip(Dungeon.hero,false,false);
              }
 else {
                item.detach(Dungeon.hero.belongings.backpack);
              }
              rose.weapon=(MeleeWeapon)item;
              item(rose.weapon);
            }
          }
        }
,WndBag.Mode.WEAPON,Messages.get(WndGhostHero.class,""String_Node_Str""));
      }
    }
  }
;
  btnWeapon.setRect((WIDTH - BTN_GAP) / 2 - BTN_SIZE,message.top() + message.height() + GAP,BTN_SIZE,BTN_SIZE);
  if (rose.weapon != null) {
    btnWeapon.item(rose.weapon);
  }
 else {
    btnWeapon.item(new WndBag.Placeholder(ItemSpriteSheet.WEAPON_HOLDER));
  }
  add(btnWeapon);
  btnArmor=new WndBlacksmith.ItemButton(){
    @Override protected void onClick(){
      if (rose.armor != null) {
        item(new WndBag.Placeholder(ItemSpriteSheet.ARMOR_HOLDER));
        if (!rose.armor.doPickUp(Dungeon.hero)) {
          Dungeon.level.drop(rose.armor,Dungeon.hero.pos);
        }
        rose.armor=null;
      }
 else {
        GameScene.selectItem(new WndBag.Listener(){
          @Override public void onSelect(          Item item){
            if (!(item instanceof Armor)) {
            }
 else             if (item.unique || ((Armor)item).checkSeal() != null) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (!item.isIdentified()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (item.cursed) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (((Armor)item).STRReq() > rose.ghostStrength()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else {
              if (item.isEquipped(Dungeon.hero)) {
                ((Armor)item).doUnequip(Dungeon.hero,false,false);
              }
 else {
                item.detach(Dungeon.hero.belongings.backpack);
              }
              rose.armor=(Armor)item;
              item(rose.armor);
            }
          }
        }
,WndBag.Mode.ARMOR,Messages.get(WndGhostHero.class,""String_Node_Str""));
      }
    }
  }
;
  btnArmor.setRect(btnWeapon.right() + BTN_GAP,btnWeapon.top(),BTN_SIZE,BTN_SIZE);
  if (rose.armor != null) {
    btnArmor.item(rose.armor);
  }
 else {
    btnArmor.item(new WndBag.Placeholder(ItemSpriteSheet.ARMOR_HOLDER));
  }
  add(btnArmor);
  resize(WIDTH,(int)(btnArmor.bottom() + GAP));
}",0.9772251917267024
163968,"public void updateArmor(){
  TextureFilm film=new TextureFilm(tiers(),((Hero)ch).tier(),FRAME_WIDTH,FRAME_HEIGHT);
  idle=new Animation(1,true);
  idle.frames(film,0,0,0,1,0,0,1,1);
  run=new Animation(RUN_FRAMERATE,true);
  run.frames(film,2,3,4,5,6,7);
  die=new Animation(20,false);
  die.frames(film,8,9,10,11,12,11);
  attack=new Animation(15,false);
  attack.frames(film,13,14,15,0);
  zap=attack.clone();
  operate=new Animation(8,false);
  operate.frames(film,16,17,16,17);
  fly=new Animation(1,true);
  fly.frames(film,18);
  read=new Animation(20,false);
  read.frames(film,19,20,20,20,20,20,20,20,20,19);
}","public void updateArmor(){
  TextureFilm film=new TextureFilm(tiers(),((Hero)ch).tier(),FRAME_WIDTH,FRAME_HEIGHT);
  idle=new Animation(1,true);
  idle.frames(film,0,0,0,1,0,0,1,1);
  run=new Animation(RUN_FRAMERATE,true);
  run.frames(film,2,3,4,5,6,7);
  die=new Animation(20,false);
  die.frames(film,8,9,10,11,12,11);
  attack=new Animation(15,false);
  attack.frames(film,13,14,15,0);
  zap=attack.clone();
  operate=new Animation(8,false);
  operate.frames(film,16,17,16,17);
  fly=new Animation(1,true);
  fly.frames(film,18);
  read=new Animation(20,false);
  read.frames(film,19,20,20,20,20,20,20,20,20,19);
  idle();
}",0.9919743178170144
163969,"public void restoreFromBundle(Bundle bundle){
  if (bundle.contains(""String_Node_Str"")) {
    int[] ironKeys=bundle.getIntArray(""String_Node_Str"");
    for (int i=0; i < ironKeys.length; i++) {
      if (ironKeys[i] > 0) {
        Notes.add((Key)new IronKey(i).quantity(ironKeys[i]));
      }
    }
  }
  if (bundle.contains(""String_Node_Str"")) {
    int[] specialKeys=bundle.getIntArray(""String_Node_Str"");
    for (int i=0; i < specialKeys.length; i++) {
      if (specialKeys[i] > 0) {
        if (i % 5 == 0) {
          Notes.add((Key)new GoldenKey(i).quantity(specialKeys[i]));
        }
 else {
          Notes.add((Key)new SkeletonKey(i).quantity(specialKeys[i]));
        }
      }
    }
  }
  backpack.clear();
  backpack.restoreFromBundle(bundle);
  weapon=(KindOfWeapon)bundle.get(WEAPON);
  if (weapon != null) {
    weapon.activate(owner);
  }
  armor=(Armor)bundle.get(ARMOR);
  if (armor != null) {
    armor.activate(owner);
  }
  misc1=(KindofMisc)bundle.get(MISC1);
  if (misc1 != null) {
    misc1.activate(owner);
  }
  misc2=(KindofMisc)bundle.get(MISC2);
  if (misc2 != null) {
    misc2.activate(owner);
  }
}","public void restoreFromBundle(Bundle bundle){
  if (bundle.contains(""String_Node_Str"")) {
    int[] ironKeys=bundle.getIntArray(""String_Node_Str"");
    for (int i=0; i < ironKeys.length; i++) {
      if (ironKeys[i] > 0) {
        Notes.add((Key)new IronKey(i).quantity(ironKeys[i]));
      }
    }
  }
  if (bundle.contains(""String_Node_Str"")) {
    int[] specialKeys=bundle.getIntArray(""String_Node_Str"");
    for (int i=0; i < specialKeys.length; i++) {
      if (specialKeys[i] > 0) {
        if (i % 5 == 0) {
          Notes.add((Key)new SkeletonKey(i).quantity(specialKeys[i]));
        }
 else {
          Notes.add((Key)new GoldenKey(i).quantity(specialKeys[i]));
        }
      }
    }
  }
  backpack.clear();
  backpack.restoreFromBundle(bundle);
  weapon=(KindOfWeapon)bundle.get(WEAPON);
  if (weapon != null) {
    weapon.activate(owner);
  }
  armor=(Armor)bundle.get(ARMOR);
  if (armor != null) {
    armor.activate(owner);
  }
  misc1=(KindofMisc)bundle.get(MISC1);
  if (misc1 != null) {
    misc1.activate(owner);
  }
  misc2=(KindofMisc)bundle.get(MISC2);
  if (misc2 != null) {
    misc2.activate(owner);
  }
}",0.9232127096204766
163970,"private boolean actUnlock(HeroAction.Unlock action){
  int doorCell=action.dst;
  if (Dungeon.level.adjacent(pos,doorCell)) {
    boolean hasKey=false;
    int door=Dungeon.level.map[doorCell];
    if (door == Terrain.LOCKED_DOOR && Notes.keyCount(new IronKey(Dungeon.depth)) > 0) {
      hasKey=true;
    }
 else     if (door == Terrain.LOCKED_EXIT && Notes.keyCount(new GoldenKey(Dungeon.depth)) > 0) {
      hasKey=true;
    }
    if (hasKey) {
      spend(Key.TIME_TO_UNLOCK);
      sprite.operate(doorCell);
      Sample.INSTANCE.play(Assets.SND_UNLOCK);
    }
 else {
      GLog.w(Messages.get(this,""String_Node_Str""));
      ready();
    }
    return false;
  }
 else   if (getCloser(doorCell)) {
    return true;
  }
 else {
    ready();
    return false;
  }
}","private boolean actUnlock(HeroAction.Unlock action){
  int doorCell=action.dst;
  if (Dungeon.level.adjacent(pos,doorCell)) {
    boolean hasKey=false;
    int door=Dungeon.level.map[doorCell];
    if (door == Terrain.LOCKED_DOOR && Notes.keyCount(new IronKey(Dungeon.depth)) > 0) {
      hasKey=true;
    }
 else     if (door == Terrain.LOCKED_EXIT && Notes.keyCount(new SkeletonKey(Dungeon.depth)) > 0) {
      hasKey=true;
    }
    if (hasKey) {
      spend(Key.TIME_TO_UNLOCK);
      sprite.operate(doorCell);
      Sample.INSTANCE.play(Assets.SND_UNLOCK);
    }
 else {
      GLog.w(Messages.get(this,""String_Node_Str""));
      ready();
    }
    return false;
  }
 else   if (getCloser(doorCell)) {
    return true;
  }
 else {
    ready();
    return false;
  }
}",0.9922077922077922
163971,"public static void load(){
  if (loaded) {
    return;
  }
  Badges.loadGlobal();
  if (Badges.global.contains(Badges.Badge.ALL_ITEMS_IDENTIFIED)) {
    for (    LinkedHashMap<Class<? extends Item>,Boolean> cat : allCatalogs) {
      for (      Class<? extends Item> item : cat.keySet()) {
        cat.put(item,true);
      }
    }
    loaded=true;
    return;
  }
  for (  LinkedHashMap<Class<? extends Item>,Boolean> cat : allCatalogs) {
    if (Badges.global.contains(catalogBadges.get(cat))) {
      for (      Class<? extends Item> item : cat.keySet()) {
        cat.put(item,true);
      }
    }
  }
  try {
    InputStream input=Game.instance.openFileInput(""String_Node_Str"");
    Bundle bundle=Bundle.read(input);
    input.close();
    List<String> seen=Arrays.asList(bundle.getStringArray(""String_Node_Str""));
    for (    LinkedHashMap<Class<? extends Item>,Boolean> cat : allCatalogs) {
      for (      Class<? extends Item> item : cat.keySet()) {
        cat.put(item,seen.contains(item.getSimpleName()));
      }
    }
    loaded=true;
  }
 catch (  IOException e) {
  }
}","public static void load(){
  if (loaded) {
    return;
  }
  Badges.loadGlobal();
  if (Badges.global.contains(Badges.Badge.ALL_ITEMS_IDENTIFIED)) {
    for (    LinkedHashMap<Class<? extends Item>,Boolean> cat : allCatalogs) {
      for (      Class<? extends Item> item : cat.keySet()) {
        cat.put(item,true);
      }
    }
    loaded=true;
    return;
  }
  for (  LinkedHashMap<Class<? extends Item>,Boolean> cat : allCatalogs) {
    if (Badges.global.contains(catalogBadges.get(cat))) {
      for (      Class<? extends Item> item : cat.keySet()) {
        cat.put(item,true);
      }
    }
  }
  try {
    InputStream input=Game.instance.openFileInput(""String_Node_Str"");
    Bundle bundle=Bundle.read(input);
    input.close();
    List<String> seen=Arrays.asList(bundle.getStringArray(""String_Node_Str""));
    for (    LinkedHashMap<Class<? extends Item>,Boolean> cat : allCatalogs) {
      for (      Class<? extends Item> item : cat.keySet()) {
        if (seen.contains(item.getSimpleName())) {
          cat.put(item,true);
        }
      }
    }
    loaded=true;
  }
 catch (  IOException e) {
  }
}",0.9537624660018132
163972,"public static void restoreGhostHero(Level level,int pos){
  if (heldGhost != null) {
    level.mobs.add(heldGhost);
    int ghostPos;
    do {
      ghostPos=pos + PathFinder.NEIGHBOURS8[Random.Int(8)];
    }
 while (!Level.solid[ghostPos] || level.findMob(ghostPos) != null);
    heldGhost.pos=pos;
    heldGhost=null;
  }
}","public static void restoreGhostHero(Level level,int pos){
  if (heldGhost != null) {
    level.mobs.add(heldGhost);
    int ghostPos;
    do {
      ghostPos=pos + PathFinder.NEIGHBOURS8[Random.Int(8)];
    }
 while (Level.solid[ghostPos] || level.findMob(ghostPos) != null);
    heldGhost.pos=pos;
    heldGhost=null;
  }
}",0.9984591679506932
163973,"@Override public int randomRespawnCell(){
  int count=0;
  int cell=-1;
  while (true) {
    if (++count > 30) {
      return -1;
    }
    Room room=randomRoom(StandardRoom.class);
    if (room == null || room == roomEntrance) {
      continue;
    }
    cell=pointToCell(room.random());
    if (!Dungeon.visible[cell] && Actor.findChar(cell) == null && Level.passable[cell] && cell != exit) {
      return cell;
    }
  }
}","@Override public int randomRespawnCell(){
  int count=0;
  int cell=-1;
  while (true) {
    if (++count > 30) {
      return -1;
    }
    Room room=randomRoom(StandardRoom.class);
    if (room == null || room == roomEntrance) {
      continue;
    }
    if (room.width() >= 6 && room.height() >= 6) {
      cell=pointToCell(room.random(2));
    }
 else {
      cell=pointToCell(room.random(1));
    }
    if (!Dungeon.visible[cell] && Actor.findChar(cell) == null && Level.passable[cell] && cell != exit) {
      return cell;
    }
  }
}",0.8755186721991701
163974,"@Override public int minHeight(){
  return Math.max(super.minHeight(),5);
}","@Override public int minHeight(){
  return Math.max(super.minHeight(),6);
}",0.9866666666666668
163975,"@Override public int minWidth(){
  return Math.max(super.minWidth(),5);
}","@Override public int minWidth(){
  return Math.max(super.minWidth(),6);
}",0.9863013698630136
163976,"@Override public void restoreFromBundle(Bundle bundle){
  super.restoreFromBundle(bundle);
  if ((ticksToKnow=bundle.getInt(UNFAMILIRIARITY)) == 0) {
    ticksToKnow=TICKS_TO_KNOW;
  }
}","@Override public void restoreFromBundle(Bundle bundle){
  super.restoreFromBundle(bundle);
  if ((ticksToKnow=bundle.getInt(UNFAMILIRIARITY)) == 0) {
    ticksToKnow=TICKS_TO_KNOW;
  }
  if (level() < 0) {
    upgrade(-level());
  }
}",0.8857142857142857
163977,"public static boolean uncurse(Hero hero,Item... items){
  boolean procced=false;
  for (  Item item : items) {
    if (item != null && item.cursed) {
      item.cursed=false;
      procced=true;
    }
    if (item instanceof Weapon) {
      Weapon w=(Weapon)item;
      if (w.hasCurseEnchant()) {
        w.enchant(null);
        w.cursed=false;
        procced=true;
      }
    }
    if (item instanceof Armor) {
      Armor a=(Armor)item;
      if (a.hasCurseGlyph()) {
        a.inscribe(null);
        a.cursed=false;
        procced=true;
      }
    }
    if (item instanceof Ring && item.level() <= 0) {
      item.upgrade(1 - item.level());
    }
    if (item instanceof Bag) {
      for (      Item bagItem : ((Bag)item).items) {
        if (bagItem != null && bagItem.cursed) {
          bagItem.cursed=false;
          procced=true;
        }
      }
    }
  }
  if (procced) {
    hero.sprite.emitter().start(ShadowParticle.UP,0.05f,10);
  }
  return procced;
}","public static boolean uncurse(Hero hero,Item... items){
  boolean procced=false;
  for (  Item item : items) {
    if (item != null && item.cursed) {
      item.cursed=false;
      procced=true;
    }
    if (item instanceof Weapon) {
      Weapon w=(Weapon)item;
      if (w.hasCurseEnchant()) {
        w.enchant(null);
        w.cursed=false;
        procced=true;
      }
    }
    if (item instanceof Armor) {
      Armor a=(Armor)item;
      if (a.hasCurseGlyph()) {
        a.inscribe(null);
        a.cursed=false;
        procced=true;
      }
    }
    if (item instanceof Bag) {
      for (      Item bagItem : ((Bag)item).items) {
        if (bagItem != null && bagItem.cursed) {
          bagItem.cursed=false;
          procced=true;
        }
      }
    }
  }
  if (procced) {
    hero.sprite.emitter().start(ShadowParticle.UP,0.05f,10);
  }
  return procced;
}",0.9475958941112912
163978,"@SuppressWarnings(""String_Node_Str"") public static void switchLevel(final Level level,int pos){
  if (pos < 0 || pos >= level.length()) {
    pos=level.exit;
  }
  PathFinder.setMapSize(level.width(),level.height());
  Dungeon.level=level;
  DriedRose.restoreGhostHero(level,pos + PathFinder.NEIGHBOURS8[Random.Int(8)]);
  Actor.init();
  visible=new boolean[level.length()];
  Actor respawner=level.respawner();
  if (respawner != null) {
    Actor.add(level.respawner());
  }
  hero.pos=pos;
  Light light=hero.buff(Light.class);
  hero.viewDistance=light == null ? level.viewDistance : Math.max(Light.DISTANCE,level.viewDistance);
  hero.curAction=hero.lastAction=null;
  observe();
  try {
    saveAll();
  }
 catch (  IOException e) {
    ShatteredPixelDungeon.reportException(e);
  }
}","@SuppressWarnings(""String_Node_Str"") public static void switchLevel(final Level level,int pos){
  if (pos < 0 || pos >= level.length()) {
    pos=level.exit;
  }
  PathFinder.setMapSize(level.width(),level.height());
  Dungeon.level=level;
  DriedRose.restoreGhostHero(level,pos);
  Actor.init();
  visible=new boolean[level.length()];
  Actor respawner=level.respawner();
  if (respawner != null) {
    Actor.add(level.respawner());
  }
  hero.pos=pos;
  Light light=hero.buff(Light.class);
  hero.viewDistance=light == null ? level.viewDistance : Math.max(Light.DISTANCE,level.viewDistance);
  hero.curAction=hero.lastAction=null;
  observe();
  try {
    saveAll();
  }
 catch (  IOException e) {
    ShatteredPixelDungeon.reportException(e);
  }
}",0.974059662775616
163979,"public static void restoreGhostHero(Level level,int pos){
  if (heldGhost != null) {
    level.mobs.add(heldGhost);
    heldGhost.pos=pos;
    heldGhost=null;
  }
}","public static void restoreGhostHero(Level level,int pos){
  if (heldGhost != null) {
    level.mobs.add(heldGhost);
    int ghostPos;
    do {
      ghostPos=pos + PathFinder.NEIGHBOURS8[Random.Int(8)];
    }
 while (!Level.solid[ghostPos] || level.findMob(ghostPos) != null);
    heldGhost.pos=pos;
    heldGhost=null;
  }
}",0.5357873210633947
163980,"@Override protected void onClick(){
  if (rose.armor != null) {
    if (rose.armor.doPickUp(Dungeon.hero)) {
      item(new WndBag.Placeholder(ItemSpriteSheet.ARMOR_HOLDER));
    }
 else {
      Dungeon.level.drop(rose.armor,Dungeon.hero.pos);
    }
    rose.armor=null;
  }
 else {
    GameScene.selectItem(new WndBag.Listener(){
      @Override public void onSelect(      Item item){
        if (!(item instanceof Armor)) {
          hide();
        }
 else         if (item.unique || ((Armor)item).checkSeal() != null) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else         if (!item.isIdentified()) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else         if (item.cursed) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else         if (((Armor)item).STRReq() > rose.ghostStrength()) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else {
          if (item.isEquipped(Dungeon.hero)) {
            ((Armor)item).doUnequip(Dungeon.hero,false,false);
          }
 else {
            item.detach(Dungeon.hero.belongings.backpack);
          }
          rose.armor=(Armor)item;
          item(rose.armor);
        }
      }
    }
,WndBag.Mode.ARMOR,Messages.get(WndGhostHero.class,""String_Node_Str""));
  }
}","@Override protected void onClick(){
  if (rose.armor != null) {
    if (rose.armor.doPickUp(Dungeon.hero)) {
      item(new WndBag.Placeholder(ItemSpriteSheet.ARMOR_HOLDER));
    }
 else {
      Dungeon.level.drop(rose.armor,Dungeon.hero.pos);
    }
    rose.armor=null;
  }
 else {
    GameScene.selectItem(new WndBag.Listener(){
      @Override public void onSelect(      Item item){
        if (!(item instanceof Armor)) {
        }
 else         if (item.unique || ((Armor)item).checkSeal() != null) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else         if (!item.isIdentified()) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else         if (item.cursed) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else         if (((Armor)item).STRReq() > rose.ghostStrength()) {
          GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
          hide();
        }
 else {
          if (item.isEquipped(Dungeon.hero)) {
            ((Armor)item).doUnequip(Dungeon.hero,false,false);
          }
 else {
            item.detach(Dungeon.hero.belongings.backpack);
          }
          rose.armor=(Armor)item;
          item(rose.armor);
        }
      }
    }
,WndBag.Mode.ARMOR,Messages.get(WndGhostHero.class,""String_Node_Str""));
  }
}",0.9936664320900774
163981,"WndGhostHero(final DriedRose rose){
  IconTitle titlebar=new IconTitle();
  titlebar.icon(new ItemSprite(rose));
  titlebar.label(Messages.get(this,""String_Node_Str""));
  titlebar.setRect(0,0,WIDTH,0);
  add(titlebar);
  RenderedTextMultiline message=PixelScene.renderMultiline(Messages.get(this,""String_Node_Str"",rose.ghostStrength()),6);
  message.maxWidth(WIDTH);
  message.setPos(0,titlebar.bottom() + GAP);
  add(message);
  btnWeapon=new WndBlacksmith.ItemButton(){
    @Override protected void onClick(){
      if (rose.weapon != null) {
        if (rose.weapon.doPickUp(Dungeon.hero)) {
          item(new WndBag.Placeholder(ItemSpriteSheet.WEAPON_HOLDER));
        }
 else {
          Dungeon.level.drop(rose.weapon,Dungeon.hero.pos);
        }
        rose.weapon=null;
      }
 else {
        GameScene.selectItem(new WndBag.Listener(){
          @Override public void onSelect(          Item item){
            if (item.unique) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (!(item instanceof MeleeWeapon)) {
              hide();
            }
 else             if (!item.isIdentified()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (item.cursed) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (((MeleeWeapon)item).STRReq() > rose.ghostStrength()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else {
              if (item.isEquipped(Dungeon.hero)) {
                ((MeleeWeapon)item).doUnequip(Dungeon.hero,false,false);
              }
 else {
                item.detach(Dungeon.hero.belongings.backpack);
              }
              rose.weapon=(MeleeWeapon)item;
              item(rose.weapon);
            }
          }
        }
,WndBag.Mode.WEAPON,Messages.get(WndGhostHero.class,""String_Node_Str""));
      }
    }
  }
;
  btnWeapon.setRect((WIDTH - BTN_GAP) / 2 - BTN_SIZE,message.top() + message.height() + GAP,BTN_SIZE,BTN_SIZE);
  if (rose.weapon != null) {
    btnWeapon.item(rose.weapon);
  }
 else {
    btnWeapon.item(new WndBag.Placeholder(ItemSpriteSheet.WEAPON_HOLDER));
  }
  add(btnWeapon);
  btnArmor=new WndBlacksmith.ItemButton(){
    @Override protected void onClick(){
      if (rose.armor != null) {
        if (rose.armor.doPickUp(Dungeon.hero)) {
          item(new WndBag.Placeholder(ItemSpriteSheet.ARMOR_HOLDER));
        }
 else {
          Dungeon.level.drop(rose.armor,Dungeon.hero.pos);
        }
        rose.armor=null;
      }
 else {
        GameScene.selectItem(new WndBag.Listener(){
          @Override public void onSelect(          Item item){
            if (!(item instanceof Armor)) {
              hide();
            }
 else             if (item.unique || ((Armor)item).checkSeal() != null) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (!item.isIdentified()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (item.cursed) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (((Armor)item).STRReq() > rose.ghostStrength()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else {
              if (item.isEquipped(Dungeon.hero)) {
                ((Armor)item).doUnequip(Dungeon.hero,false,false);
              }
 else {
                item.detach(Dungeon.hero.belongings.backpack);
              }
              rose.armor=(Armor)item;
              item(rose.armor);
            }
          }
        }
,WndBag.Mode.ARMOR,Messages.get(WndGhostHero.class,""String_Node_Str""));
      }
    }
  }
;
  btnArmor.setRect(btnWeapon.right() + BTN_GAP,btnWeapon.top(),BTN_SIZE,BTN_SIZE);
  if (rose.armor != null) {
    btnArmor.item(rose.armor);
  }
 else {
    btnArmor.item(new WndBag.Placeholder(ItemSpriteSheet.ARMOR_HOLDER));
  }
  add(btnArmor);
  resize(WIDTH,(int)(btnArmor.bottom() + GAP));
}","WndGhostHero(final DriedRose rose){
  IconTitle titlebar=new IconTitle();
  titlebar.icon(new ItemSprite(rose));
  titlebar.label(Messages.get(this,""String_Node_Str""));
  titlebar.setRect(0,0,WIDTH,0);
  add(titlebar);
  RenderedTextMultiline message=PixelScene.renderMultiline(Messages.get(this,""String_Node_Str"",rose.ghostStrength()),6);
  message.maxWidth(WIDTH);
  message.setPos(0,titlebar.bottom() + GAP);
  add(message);
  btnWeapon=new WndBlacksmith.ItemButton(){
    @Override protected void onClick(){
      if (rose.weapon != null) {
        if (rose.weapon.doPickUp(Dungeon.hero)) {
          item(new WndBag.Placeholder(ItemSpriteSheet.WEAPON_HOLDER));
        }
 else {
          Dungeon.level.drop(rose.weapon,Dungeon.hero.pos);
        }
        rose.weapon=null;
      }
 else {
        GameScene.selectItem(new WndBag.Listener(){
          @Override public void onSelect(          Item item){
            if (!(item instanceof MeleeWeapon || item instanceof Boomerang)) {
            }
 else             if (item.unique || item instanceof Boomerang) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (!item.isIdentified()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (item.cursed) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (((MeleeWeapon)item).STRReq() > rose.ghostStrength()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else {
              if (item.isEquipped(Dungeon.hero)) {
                ((MeleeWeapon)item).doUnequip(Dungeon.hero,false,false);
              }
 else {
                item.detach(Dungeon.hero.belongings.backpack);
              }
              rose.weapon=(MeleeWeapon)item;
              item(rose.weapon);
            }
          }
        }
,WndBag.Mode.WEAPON,Messages.get(WndGhostHero.class,""String_Node_Str""));
      }
    }
  }
;
  btnWeapon.setRect((WIDTH - BTN_GAP) / 2 - BTN_SIZE,message.top() + message.height() + GAP,BTN_SIZE,BTN_SIZE);
  if (rose.weapon != null) {
    btnWeapon.item(rose.weapon);
  }
 else {
    btnWeapon.item(new WndBag.Placeholder(ItemSpriteSheet.WEAPON_HOLDER));
  }
  add(btnWeapon);
  btnArmor=new WndBlacksmith.ItemButton(){
    @Override protected void onClick(){
      if (rose.armor != null) {
        if (rose.armor.doPickUp(Dungeon.hero)) {
          item(new WndBag.Placeholder(ItemSpriteSheet.ARMOR_HOLDER));
        }
 else {
          Dungeon.level.drop(rose.armor,Dungeon.hero.pos);
        }
        rose.armor=null;
      }
 else {
        GameScene.selectItem(new WndBag.Listener(){
          @Override public void onSelect(          Item item){
            if (!(item instanceof Armor)) {
            }
 else             if (item.unique || ((Armor)item).checkSeal() != null) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (!item.isIdentified()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (item.cursed) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else             if (((Armor)item).STRReq() > rose.ghostStrength()) {
              GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
              hide();
            }
 else {
              if (item.isEquipped(Dungeon.hero)) {
                ((Armor)item).doUnequip(Dungeon.hero,false,false);
              }
 else {
                item.detach(Dungeon.hero.belongings.backpack);
              }
              rose.armor=(Armor)item;
              item(rose.armor);
            }
          }
        }
,WndBag.Mode.ARMOR,Messages.get(WndGhostHero.class,""String_Node_Str""));
      }
    }
  }
;
  btnArmor.setRect(btnWeapon.right() + BTN_GAP,btnWeapon.top(),BTN_SIZE,BTN_SIZE);
  if (rose.armor != null) {
    btnArmor.item(rose.armor);
  }
 else {
    btnArmor.item(new WndBag.Placeholder(ItemSpriteSheet.ARMOR_HOLDER));
  }
  add(btnArmor);
  resize(WIDTH,(int)(btnArmor.bottom() + GAP));
}",0.9719582850521435
163982,"@Override public void onSelect(Item item){
  if (!(item instanceof Armor)) {
    hide();
  }
 else   if (item.unique || ((Armor)item).checkSeal() != null) {
    GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
    hide();
  }
 else   if (!item.isIdentified()) {
    GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
    hide();
  }
 else   if (item.cursed) {
    GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
    hide();
  }
 else   if (((Armor)item).STRReq() > rose.ghostStrength()) {
    GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
    hide();
  }
 else {
    if (item.isEquipped(Dungeon.hero)) {
      ((Armor)item).doUnequip(Dungeon.hero,false,false);
    }
 else {
      item.detach(Dungeon.hero.belongings.backpack);
    }
    rose.armor=(Armor)item;
    item(rose.armor);
  }
}","@Override public void onSelect(Item item){
  if (!(item instanceof Armor)) {
  }
 else   if (item.unique || ((Armor)item).checkSeal() != null) {
    GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
    hide();
  }
 else   if (!item.isIdentified()) {
    GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
    hide();
  }
 else   if (item.cursed) {
    GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
    hide();
  }
 else   if (((Armor)item).STRReq() > rose.ghostStrength()) {
    GLog.w(Messages.get(WndGhostHero.class,""String_Node_Str""));
    hide();
  }
 else {
    if (item.isEquipped(Dungeon.hero)) {
      ((Armor)item).doUnequip(Dungeon.hero,false,false);
    }
 else {
      item.detach(Dungeon.hero.belongings.backpack);
    }
    rose.armor=(Armor)item;
    item(rose.armor);
  }
}",0.9927623642943304
163983,"@Override protected void createMobs(){
  int mobsToSpawn=Dungeon.depth == 1 ? 10 : nMobs();
  ArrayList<Room> stdRooms=new ArrayList<>();
  for (  Room room : rooms) {
    if ((room instanceof StandardRoom || room.legacyType.equals(""String_Node_Str"")) && room != roomEntrance) {
      for (int i=0; i < ((StandardRoom)room).sizeCat.roomValue; i++) {
        stdRooms.add(room);
      }
    }
  }
  Random.shuffle(stdRooms);
  Iterator<Room> stdRoomIter=stdRooms.iterator();
  while (mobsToSpawn > 0) {
    if (!stdRoomIter.hasNext())     stdRoomIter=stdRooms.iterator();
    Room roomToSpawn=stdRoomIter.next();
    Mob mob=Bestiary.mob(Dungeon.depth);
    mob.pos=pointToCell(roomToSpawn.random());
    if (findMob(mob.pos) == null && Level.passable[mob.pos]) {
      mobsToSpawn--;
      mobs.add(mob);
      if (mobsToSpawn > 0 && Random.Int(4) == 0) {
        mob=Bestiary.mob(Dungeon.depth);
        mob.pos=pointToCell(roomToSpawn.random());
        if (findMob(mob.pos) == null && Level.passable[mob.pos]) {
          mobsToSpawn--;
          mobs.add(mob);
        }
      }
    }
  }
  for (  Mob m : mobs) {
    if (map[m.pos] == Terrain.HIGH_GRASS) {
      map[m.pos]=Terrain.GRASS;
      losBlocking[m.pos]=false;
    }
  }
}","@Override protected void createMobs(){
  int mobsToSpawn=Dungeon.depth == 1 ? 10 : nMobs();
  ArrayList<Room> stdRooms=new ArrayList<>();
  for (  Room room : rooms) {
    if (room instanceof StandardRoom && room != roomEntrance) {
      for (int i=0; i < ((StandardRoom)room).sizeCat.roomValue; i++) {
        stdRooms.add(room);
      }
    }
 else     if (room.legacyType.equals(""String_Node_Str"")) {
      stdRooms.add(room);
    }
  }
  Random.shuffle(stdRooms);
  Iterator<Room> stdRoomIter=stdRooms.iterator();
  while (mobsToSpawn > 0) {
    if (!stdRoomIter.hasNext())     stdRoomIter=stdRooms.iterator();
    Room roomToSpawn=stdRoomIter.next();
    Mob mob=Bestiary.mob(Dungeon.depth);
    mob.pos=pointToCell(roomToSpawn.random());
    if (findMob(mob.pos) == null && Level.passable[mob.pos]) {
      mobsToSpawn--;
      mobs.add(mob);
      if (mobsToSpawn > 0 && Random.Int(4) == 0) {
        mob=Bestiary.mob(Dungeon.depth);
        mob.pos=pointToCell(roomToSpawn.random());
        if (findMob(mob.pos) == null && Level.passable[mob.pos]) {
          mobsToSpawn--;
          mobs.add(mob);
        }
      }
    }
  }
  for (  Mob m : mobs) {
    if (map[m.pos] == Terrain.HIGH_GRASS) {
      map[m.pos]=Terrain.GRASS;
      losBlocking[m.pos]=false;
    }
  }
}",0.8800635424940428
163984,"@SuppressWarnings(""String_Node_Str"") public static <K>K chances(HashMap<K,Float> chances){
  int size=chances.size();
  Object[] values=chances.keySet().toArray();
  float[] probs=new float[size];
  float sum=0;
  for (int i=0; i < size; i++) {
    probs[i]=chances.get(values[i]);
    sum+=probs[i];
  }
  float value=Float(sum);
  sum=probs[0];
  for (int i=0; i < size; i++) {
    if (value < sum) {
      return (K)values[i];
    }
    sum+=probs[i + 1];
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") public static <K>K chances(HashMap<K,Float> chances){
  int size=chances.size();
  Object[] values=chances.keySet().toArray();
  float[] probs=new float[size];
  float sum=0;
  for (int i=0; i < size; i++) {
    probs[i]=chances.get(values[i]);
    sum+=probs[i];
  }
  if (sum <= 0) {
    return null;
  }
  float value=Float(sum);
  sum=probs[0];
  for (int i=0; i < size; i++) {
    if (value < sum) {
      return (K)values[i];
    }
    sum+=probs[i + 1];
  }
  return null;
}",0.9608826479438316
163985,"@Override protected void createMobs(){
  int mobsToSpawn=Dungeon.depth == 1 ? 10 : nMobs();
  ArrayList<Room> stdRooms=new ArrayList<>();
  for (  Room room : rooms) {
    if (room instanceof StandardRoom && room != roomEntrance) {
      for (int i=0; i < ((StandardRoom)room).sizeCat.roomValue; i++) {
        stdRooms.add(room);
      }
    }
  }
  Random.shuffle(rooms);
  Iterator<Room> stdRoomIter=stdRooms.iterator();
  while (mobsToSpawn > 0) {
    if (!stdRoomIter.hasNext())     stdRoomIter=stdRooms.iterator();
    Room roomToSpawn=stdRoomIter.next();
    Mob mob=Bestiary.mob(Dungeon.depth);
    mob.pos=pointToCell(roomToSpawn.random());
    if (findMob(mob.pos) == null && Level.passable[mob.pos]) {
      mobsToSpawn--;
      mobs.add(mob);
      if (mobsToSpawn > 0 && Random.Int(4) == 0) {
        mob=Bestiary.mob(Dungeon.depth);
        mob.pos=pointToCell(roomToSpawn.random());
        if (findMob(mob.pos) == null && Level.passable[mob.pos]) {
          mobsToSpawn--;
          mobs.add(mob);
        }
      }
    }
  }
  for (  Mob m : mobs) {
    if (map[m.pos] == Terrain.HIGH_GRASS) {
      map[m.pos]=Terrain.GRASS;
      losBlocking[m.pos]=false;
    }
  }
}","@Override protected void createMobs(){
  int mobsToSpawn=Dungeon.depth == 1 ? 10 : nMobs();
  ArrayList<Room> stdRooms=new ArrayList<>();
  for (  Room room : rooms) {
    if ((room instanceof StandardRoom || room.legacyType.equals(""String_Node_Str"")) && room != roomEntrance) {
      for (int i=0; i < ((StandardRoom)room).sizeCat.roomValue; i++) {
        stdRooms.add(room);
      }
    }
  }
  Random.shuffle(stdRooms);
  Iterator<Room> stdRoomIter=stdRooms.iterator();
  while (mobsToSpawn > 0) {
    if (!stdRoomIter.hasNext())     stdRoomIter=stdRooms.iterator();
    Room roomToSpawn=stdRoomIter.next();
    Mob mob=Bestiary.mob(Dungeon.depth);
    mob.pos=pointToCell(roomToSpawn.random());
    if (findMob(mob.pos) == null && Level.passable[mob.pos]) {
      mobsToSpawn--;
      mobs.add(mob);
      if (mobsToSpawn > 0 && Random.Int(4) == 0) {
        mob=Bestiary.mob(Dungeon.depth);
        mob.pos=pointToCell(roomToSpawn.random());
        if (findMob(mob.pos) == null && Level.passable[mob.pos]) {
          mobsToSpawn--;
          mobs.add(mob);
        }
      }
    }
  }
  for (  Mob m : mobs) {
    if (map[m.pos] == Terrain.HIGH_GRASS) {
      map[m.pos]=Terrain.GRASS;
      losBlocking[m.pos]=false;
    }
  }
}",0.9785478547854786
163986,"public synchronized void updateFogCell(int cell){
  updateFogArea(cell % mapWidth,cell / mapHeight,1,1);
}","public synchronized void updateFogCell(int cell){
  updateFogArea(cell % mapWidth,cell / mapWidth,1,1);
}",0.966824644549763
163987,"protected static Rect findFreeSpace(Point start,ArrayList<Room> collision,int maxSize){
  Rect space=new Rect(start.x - maxSize,start.y - maxSize,start.x + maxSize,start.y + maxSize);
  ArrayList<Room> colliding=new ArrayList<>(collision);
  do {
    Iterator<Room> it=colliding.iterator();
    while (it.hasNext()) {
      Room room=it.next();
      if (Math.max(space.left,room.left) >= Math.min(space.right,room.right) || Math.max(space.top,room.top) >= Math.min(space.bottom,room.bottom)) {
        it.remove();
      }
    }
    Room biggestCollision=null;
    int wDiff, hDiff, biggestDiff=0;
    boolean widthCollision=false;
    for (    Room room : colliding) {
      wDiff=Integer.MAX_VALUE;
      if (room.left >= start.x) {
        wDiff=(space.right - room.left) * (space.height() + 1);
      }
 else       if (room.right <= start.x) {
        wDiff=(room.right - space.left) * (space.height() + 1);
      }
      hDiff=Integer.MAX_VALUE;
      if (room.top >= start.y) {
        hDiff=(space.bottom - room.top) * (space.width() + 1);
      }
 else       if (room.bottom <= start.y) {
        hDiff=(room.bottom - space.top) * (space.width() + 1);
      }
      if (hDiff == Integer.MAX_VALUE && wDiff == Integer.MAX_VALUE) {
        space.set(0,0,0,0);
        return space;
      }
 else {
        if (wDiff < hDiff || (wDiff == hDiff && Random.Int(2) == 0)) {
          if (wDiff >= biggestDiff) {
            biggestDiff=wDiff;
            biggestCollision=room;
            widthCollision=true;
          }
        }
 else {
          if (hDiff >= biggestDiff) {
            biggestDiff=hDiff;
            biggestCollision=room;
            widthCollision=false;
          }
        }
      }
    }
    if (biggestCollision != null) {
      if (widthCollision) {
        if (biggestCollision.left >= start.x && biggestCollision.left < space.right)         space.right=biggestCollision.left;
        if (biggestCollision.right <= start.x && biggestCollision.right > space.left)         space.left=biggestCollision.right;
      }
 else {
        if (biggestCollision.top >= start.y && biggestCollision.top < space.bottom)         space.bottom=biggestCollision.top;
        if (biggestCollision.bottom <= start.y && biggestCollision.bottom > space.top)         space.top=biggestCollision.bottom;
      }
      colliding.remove(biggestCollision);
    }
 else {
      colliding.clear();
    }
  }
 while (!colliding.isEmpty());
  return space;
}","protected static Rect findFreeSpace(Point start,ArrayList<Room> collision,int maxSize){
  Rect space=new Rect(start.x - maxSize,start.y - maxSize,start.x + maxSize,start.y + maxSize);
  ArrayList<Room> colliding=new ArrayList<>(collision);
  do {
    Iterator<Room> it=colliding.iterator();
    while (it.hasNext()) {
      Room room=it.next();
      if (Math.max(space.left,room.left) >= Math.min(space.right,room.right) || Math.max(space.top,room.top) >= Math.min(space.bottom,room.bottom)) {
        it.remove();
      }
    }
    Room closestRoom=null;
    int closestDiff=Integer.MAX_VALUE;
    boolean inside=true;
    int curDiff=0;
    for (    Room curRoom : colliding) {
      if (start.x <= curRoom.left) {
        inside=false;
        curDiff+=curRoom.left - start.x;
      }
 else       if (start.x >= curRoom.right) {
        inside=false;
        curDiff+=start.x - curRoom.right;
      }
      if (start.y <= curRoom.top) {
        inside=false;
        curDiff+=curRoom.top - start.y;
      }
 else       if (start.y >= curRoom.bottom) {
        inside=false;
        curDiff+=start.y - curRoom.bottom;
      }
      if (inside) {
        space.set(start.x,start.y,start.x,start.y);
        return space;
      }
      if (curDiff < closestDiff) {
        closestDiff=curDiff;
        closestRoom=curRoom;
      }
    }
    int wDiff, hDiff;
    if (closestRoom != null) {
      wDiff=Integer.MAX_VALUE;
      if (closestRoom.left >= start.x) {
        wDiff=(space.right - closestRoom.left) * (space.height() + 1);
      }
 else       if (closestRoom.right <= start.x) {
        wDiff=(closestRoom.right - space.left) * (space.height() + 1);
      }
      hDiff=Integer.MAX_VALUE;
      if (closestRoom.top >= start.y) {
        hDiff=(space.bottom - closestRoom.top) * (space.width() + 1);
      }
 else       if (closestRoom.bottom <= start.y) {
        hDiff=(closestRoom.bottom - space.top) * (space.width() + 1);
      }
      if (wDiff < hDiff || wDiff == hDiff && Random.Int(2) == 0) {
        if (closestRoom.left >= start.x && closestRoom.left < space.right)         space.right=closestRoom.left;
        if (closestRoom.right <= start.x && closestRoom.right > space.left)         space.left=closestRoom.right;
      }
 else {
        if (closestRoom.top >= start.y && closestRoom.top < space.bottom)         space.bottom=closestRoom.top;
        if (closestRoom.bottom <= start.y && closestRoom.bottom > space.top)         space.top=closestRoom.bottom;
      }
      colliding.remove(closestRoom);
    }
 else {
      colliding.clear();
    }
  }
 while (!colliding.isEmpty());
  return space;
}",0.3227075954348681
163988,"protected static float angleBetweenRooms(Room from,Room to){
  PointF fromCenter=new PointF((from.left + from.right) / 2f,(from.top + from.bottom) / 2f);
  PointF toCenter=new PointF((to.left + to.right) / 2f,(to.top + to.bottom) / 2f);
  double m=(toCenter.y - fromCenter.y) / (toCenter.x - fromCenter.x);
  return (float)(A * (Math.atan(m) + Math.PI / 2f));
}","protected static float angleBetweenRooms(Room from,Room to){
  PointF fromCenter=new PointF((from.left + from.right) / 2f,(from.top + from.bottom) / 2f);
  PointF toCenter=new PointF((to.left + to.right) / 2f,(to.top + to.bottom) / 2f);
  double m=(toCenter.y - fromCenter.y) / (toCenter.x - fromCenter.x);
  float angle=(float)(A * (Math.atan(m) + Math.PI / 2.0));
  if (fromCenter.x > toCenter.x)   angle-=180f;
  return angle;
}",0.8863636363636364
163989,"@Override public ArrayList<Room> build(ArrayList<Room> rooms){
  setupRooms(rooms);
  if (entrance == null) {
    return null;
  }
  entrance.setSize();
  entrance.setPos(0,0);
  float startAngle=Random.Float(0,360);
  ArrayList<Room> loop=new ArrayList<>();
  int roomsOnLoop=(int)(multiConnections.size() * pathLength) + Random.chances(pathLenJitterChances);
  roomsOnLoop=Math.min(roomsOnLoop,multiConnections.size());
  roomsOnLoop++;
  for (int i=0; i < roomsOnLoop; i++) {
    if (i == 0)     loop.add(entrance);
 else     loop.add(multiConnections.remove(0));
    int tunnels=Random.chances(pathTunnelChances);
    for (int j=0; j < tunnels; j++) {
      loop.add(ConnectionRoom.createRoom());
    }
  }
  if (exit != null)   loop.add(loop.size() / 2,exit);
  Room prev=entrance;
  float targetAngle;
  for (int i=1; i < loop.size(); i++) {
    Room r=loop.get(i);
    targetAngle=startAngle + targetAngle(i / (float)loop.size());
    if (placeRoom(rooms,prev,r,targetAngle) != -1) {
      prev=r;
      if (!rooms.contains(prev))       rooms.add(prev);
    }
 else {
      return null;
    }
  }
  if (!prev.connect(entrance)) {
    return null;
  }
  if (shop != null) {
    float angle;
    do {
      angle=placeRoom(loop,entrance,shop,Random.Float(360f));
    }
 while (angle == -1);
  }
  ArrayList<Room> branchable=new ArrayList<>(loop);
  ArrayList<Room> roomsToBranch=new ArrayList<>();
  roomsToBranch.addAll(multiConnections);
  roomsToBranch.addAll(singleConnections);
  weightRooms(branchable);
  createBranches(rooms,branchable,roomsToBranch,branchTunnelChances);
  findNeighbours(rooms);
  for (  Room r : rooms) {
    for (    Room n : r.neigbours) {
      if (!n.connected.containsKey(r) && Random.Float() < extraConnectionChance) {
        r.connect(n);
      }
    }
  }
  return rooms;
}","@Override public ArrayList<Room> build(ArrayList<Room> rooms){
  setupRooms(rooms);
  if (entrance == null) {
    return null;
  }
  entrance.setSize();
  entrance.setPos(0,0);
  float startAngle=Random.Float(0,360);
  ArrayList<Room> loop=new ArrayList<>();
  int roomsOnLoop=(int)(multiConnections.size() * pathLength) + Random.chances(pathLenJitterChances);
  roomsOnLoop=Math.min(roomsOnLoop,multiConnections.size());
  roomsOnLoop++;
  for (int i=0; i < roomsOnLoop; i++) {
    if (i == 0)     loop.add(entrance);
 else     loop.add(multiConnections.remove(0));
    int tunnels=Random.chances(pathTunnelChances);
    for (int j=0; j < tunnels; j++) {
      loop.add(ConnectionRoom.createRoom());
    }
  }
  if (exit != null)   loop.add((loop.size() + 1) / 2,exit);
  Room prev=entrance;
  float targetAngle;
  for (int i=1; i < loop.size(); i++) {
    Room r=loop.get(i);
    targetAngle=startAngle + targetAngle(i / (float)loop.size());
    if (placeRoom(rooms,prev,r,targetAngle) != -1) {
      prev=r;
      if (!rooms.contains(prev))       rooms.add(prev);
    }
 else {
      return null;
    }
  }
  while (!prev.connect(entrance)) {
    ConnectionRoom c=ConnectionRoom.createRoom();
    if (placeRoom(loop,prev,c,angleBetweenRooms(prev,entrance)) == -1) {
      return null;
    }
    loop.add(c);
    rooms.add(c);
    prev=c;
  }
  if (shop != null) {
    float angle;
    int tries=10;
    do {
      angle=placeRoom(loop,entrance,shop,Random.Float(360f));
      tries--;
    }
 while (angle == -1 && tries >= 0);
    if (angle == -1)     return null;
  }
  ArrayList<Room> branchable=new ArrayList<>(loop);
  ArrayList<Room> roomsToBranch=new ArrayList<>();
  roomsToBranch.addAll(multiConnections);
  roomsToBranch.addAll(singleConnections);
  weightRooms(branchable);
  createBranches(rooms,branchable,roomsToBranch,branchTunnelChances);
  findNeighbours(rooms);
  for (  Room r : rooms) {
    for (    Room n : r.neigbours) {
      if (!n.connected.containsKey(r) && Random.Float() < extraConnectionChance) {
        r.connect(n);
      }
    }
  }
  return rooms;
}",0.8964102564102564
163990,"protected static void createBranches(ArrayList<Room> rooms,ArrayList<Room> branchable,ArrayList<Room> roomsToBranch,float[] connChances){
  int i=0;
  float angle;
  int tries;
  Room curr;
  ArrayList<Room> connectingRoomsThisBranch=new ArrayList<>();
  while (i < roomsToBranch.size()) {
    connectingRoomsThisBranch.clear();
    curr=Random.element(branchable);
    int connectingRooms=Random.chances(connChances);
    for (int j=0; j < connectingRooms; j++) {
      ConnectionRoom t=ConnectionRoom.createRoom();
      tries=10;
      do {
        angle=placeRoom(rooms,curr,t,Random.Float(360f));
        tries--;
      }
 while (angle == -1 && tries >= 0);
      if (angle == -1) {
        for (        Room r : connectingRoomsThisBranch) {
          r.clearConnections();
          rooms.remove(r);
        }
        connectingRoomsThisBranch.clear();
        break;
      }
 else {
        connectingRoomsThisBranch.add(t);
        rooms.add(t);
      }
      curr=t;
    }
    if (connectingRoomsThisBranch.size() != connectingRooms) {
      continue;
    }
    Room r=roomsToBranch.get(i);
    tries=10;
    do {
      angle=placeRoom(rooms,curr,r,Random.Float(360f));
      tries--;
    }
 while (angle == -1 && tries >= 0);
    if (angle == -1) {
      for (      Room t : connectingRoomsThisBranch) {
        t.clearConnections();
        rooms.remove(t);
      }
      connectingRoomsThisBranch.clear();
      continue;
    }
    branchable.addAll(connectingRoomsThisBranch);
    if (r.maxConnections(Room.ALL) > 1) {
      if (r instanceof StandardRoom) {
        for (int j=0; j < ((StandardRoom)r).sizeCat.connectionWeight(); j++) {
          branchable.add(r);
        }
      }
 else {
        branchable.add(r);
      }
    }
    i++;
  }
}","protected static void createBranches(ArrayList<Room> rooms,ArrayList<Room> branchable,ArrayList<Room> roomsToBranch,float[] connChances){
  int i=0;
  float angle;
  int tries;
  Room curr;
  ArrayList<Room> connectingRoomsThisBranch=new ArrayList<>();
  while (i < roomsToBranch.size()) {
    connectingRoomsThisBranch.clear();
    curr=Random.element(branchable);
    int connectingRooms=Random.chances(connChances);
    for (int j=0; j < connectingRooms; j++) {
      ConnectionRoom t=ConnectionRoom.createRoom();
      tries=10;
      do {
        angle=placeRoom(rooms,curr,t,Random.Float(360f));
        tries--;
      }
 while (angle == -1 && tries >= 0);
      if (angle == -1) {
        for (        Room r : connectingRoomsThisBranch) {
          r.clearConnections();
          rooms.remove(r);
        }
        connectingRoomsThisBranch.clear();
        break;
      }
 else {
        connectingRoomsThisBranch.add(t);
        rooms.add(t);
      }
      curr=t;
    }
    if (connectingRoomsThisBranch.size() != connectingRooms) {
      continue;
    }
    Room r=roomsToBranch.get(i);
    tries=10;
    do {
      angle=placeRoom(rooms,curr,r,Random.Float(360f));
      tries--;
    }
 while (angle == -1 && tries >= 0);
    if (angle == -1) {
      for (      Room t : connectingRoomsThisBranch) {
        t.clearConnections();
        rooms.remove(t);
      }
      connectingRoomsThisBranch.clear();
      continue;
    }
    if (Random.Float() < 0.33f)     branchable.addAll(connectingRoomsThisBranch);
    if (r.maxConnections(Room.ALL) > 1) {
      if (r instanceof StandardRoom) {
        for (int j=0; j < ((StandardRoom)r).sizeCat.connectionWeight(); j++) {
          branchable.add(r);
        }
      }
 else {
        branchable.add(r);
      }
    }
    i++;
  }
}",0.990990990990991
163991,"@SuppressWarnings(""String_Node_Str"") private static void buildDistanceMap(int to,boolean[] passable){
  System.arraycopy(maxVal,0,distance,0,maxVal.length);
  int head=0;
  int tail=0;
  queue[tail++]=to;
  distance[to]=0;
  while (head < tail) {
    int step=queue[head++];
    int nextDistance=distance[step] + 1;
    for (int i=0; i < dir.length; i++) {
      int n=step + dir[i];
      if (n >= 0 && n < size && passable[n] && (distance[n] > nextDistance)) {
        queue[tail++]=n;
        distance[n]=nextDistance;
      }
    }
  }
}","public static void buildDistanceMap(int to,boolean[] passable){
  System.arraycopy(maxVal,0,distance,0,maxVal.length);
  int head=0;
  int tail=0;
  queue[tail++]=to;
  distance[to]=0;
  while (head < tail) {
    int step=queue[head++];
    int nextDistance=distance[step] + 1;
    int start=(step % width == 0 ? 3 : 0);
    int end=((step + 1) % width == 0 ? 3 : 0);
    for (int i=start; i < dirLR.length - end; i++) {
      int n=step + dirLR[i];
      if (n >= 0 && n < size && passable[n] && (distance[n] > nextDistance)) {
        queue[tail++]=n;
        distance[n]=nextDistance;
      }
    }
  }
}",0.8641114982578397
163992,"private static int buildEscapeDistanceMap(int cur,int from,float factor,boolean[] passable){
  System.arraycopy(maxVal,0,distance,0,maxVal.length);
  int destDist=Integer.MAX_VALUE;
  int head=0;
  int tail=0;
  queue[tail++]=from;
  distance[from]=0;
  int dist=0;
  while (head < tail) {
    int step=queue[head++];
    dist=distance[step];
    if (dist > destDist) {
      return destDist;
    }
    if (step == cur) {
      destDist=(int)(dist * factor) + 1;
    }
    int nextDistance=dist + 1;
    for (int i=0; i < dir.length; i++) {
      int n=step + dir[i];
      if (n >= 0 && n < size && passable[n] && distance[n] > nextDistance) {
        queue[tail++]=n;
        distance[n]=nextDistance;
      }
    }
  }
  return dist;
}","private static int buildEscapeDistanceMap(int cur,int from,float factor,boolean[] passable){
  System.arraycopy(maxVal,0,distance,0,maxVal.length);
  int destDist=Integer.MAX_VALUE;
  int head=0;
  int tail=0;
  queue[tail++]=from;
  distance[from]=0;
  int dist=0;
  while (head < tail) {
    int step=queue[head++];
    dist=distance[step];
    if (dist > destDist) {
      return destDist;
    }
    if (step == cur) {
      destDist=(int)(dist * factor) + 1;
    }
    int nextDistance=dist + 1;
    int start=(step % width == 0 ? 3 : 0);
    int end=((step + 1) % width == 0 ? 3 : 0);
    for (int i=start; i < dirLR.length - end; i++) {
      int n=step + dirLR[i];
      if (n >= 0 && n < size && passable[n] && distance[n] > nextDistance) {
        queue[tail++]=n;
        distance[n]=nextDistance;
      }
    }
  }
  return dist;
}",0.918987341772152
163993,"public static void setMapSize(int width,int height){
  int size=width * height;
  PathFinder.size=size;
  distance=new int[size];
  goals=new boolean[size];
  queue=new int[size];
  maxVal=new int[size];
  Arrays.fill(maxVal,Integer.MAX_VALUE);
  dir=new int[]{-1,+1,-width,+width,-width - 1,-width + 1,+width - 1,+width + 1};
  NEIGHBOURS4=new int[]{-width,-1,+1,+width};
  NEIGHBOURS8=new int[]{-width - 1,-width,-width + 1,-1,+1,+width - 1,+width,+width + 1};
  NEIGHBOURS9=new int[]{-width - 1,-width,-width + 1,-1,0,+1,+width - 1,+width,+width + 1};
  CIRCLE4=new int[]{-width,+1,+width,-1};
  CIRCLE8=new int[]{-width - 1,-width,-width + 1,+1,+width + 1,+width,+width - 1,-1};
}","public static void setMapSize(int width,int height){
  PathFinder.width=width;
  PathFinder.size=width * height;
  distance=new int[size];
  goals=new boolean[size];
  queue=new int[size];
  maxVal=new int[size];
  Arrays.fill(maxVal,Integer.MAX_VALUE);
  dir=new int[]{-1,+1,-width,+width,-width - 1,-width + 1,+width - 1,+width + 1};
  dirLR=new int[]{-1 - width,-1,-1 + width,-width,+width,+1 - width,+1,+1 + width};
  NEIGHBOURS4=new int[]{-width,-1,+1,+width};
  NEIGHBOURS8=new int[]{-width - 1,-width,-width + 1,-1,+1,+width - 1,+width,+width + 1};
  NEIGHBOURS9=new int[]{-width - 1,-width,-width + 1,-1,0,+1,+width - 1,+width,+width + 1};
  CIRCLE4=new int[]{-width,+1,+width,-1};
  CIRCLE8=new int[]{-width - 1,-width,-width + 1,+1,+width + 1,+width,+width - 1,-1};
}",0.893908281998631
163994,"public static boolean[] generate(int w,int h,float fill,int clustering,boolean forceFillRate){
  int length=w * h;
  boolean[] cur=new boolean[length];
  boolean[] off=new boolean[length];
  int fillDiff=-Math.round(length * fill);
  if (forceFillRate && clustering > 0) {
    fill+=(0.5f - fill) * 0.5f;
  }
  for (int i=0; i < length; i++) {
    off[i]=Random.Float() < fill;
    if (off[i])     fillDiff++;
  }
  for (int i=0; i < clustering; i++) {
    for (int y=0; y < h; y++) {
      for (int x=0; x < w; x++) {
        int pos=x + y * w;
        int count=0;
        int neighbours=0;
        if (y > 0) {
          if (x > 0) {
            if (off[pos - w - 1])             count++;
            neighbours++;
          }
          if (off[pos - w])           count++;
          neighbours++;
          if (x < (w - 1)) {
            if (off[pos - w + 1])             count++;
            neighbours++;
          }
        }
        if (x > 0) {
          if (off[pos - 1])           count++;
          neighbours++;
        }
        if (off[pos])         count++;
        neighbours++;
        if (x < (w - 1)) {
          if (off[pos + 1])           count++;
          neighbours++;
        }
        if (y < (h - 1)) {
          if (x > 0) {
            if (off[pos + w - 1])             count++;
            neighbours++;
          }
          if (off[pos + w])           count++;
          neighbours++;
          if (x < (w - 1)) {
            if (off[pos + w + 1])             count++;
            neighbours++;
          }
        }
        cur[pos]=2 * count >= neighbours;
        if (cur[pos] != off[pos])         fillDiff+=cur[pos] ? +1 : -1;
      }
    }
    boolean[] tmp=cur;
    cur=off;
    off=tmp;
  }
  if (forceFillRate) {
    int[] neighbours=new int[]{-w - 1,-w,-w + 1,-1,0,+1,+w - 1,+w,+w + 1};
    boolean growing=fillDiff < 0;
    while (fillDiff != 0) {
      int cell;
      int tries=0;
      do {
        cell=Random.Int(1,w - 1) + Random.Int(1,h - 1) * w;
        tries++;
      }
 while (off[cell] != growing && tries * 10 < length);
      for (      int i : neighbours) {
        if (fillDiff != 0 && off[cell + i] != growing) {
          off[cell + i]=growing;
          fillDiff+=growing ? +1 : -1;
        }
      }
    }
  }
  return off;
}","public static boolean[] generate(int w,int h,float fill,int clustering,boolean forceFillRate){
  int length=w * h;
  boolean[] cur=new boolean[length];
  boolean[] off=new boolean[length];
  int fillDiff=-Math.round(length * fill);
  if (forceFillRate && clustering > 0) {
    fill+=(0.5f - fill) * 0.5f;
  }
  for (int i=0; i < length; i++) {
    off[i]=Random.Float() < fill;
    if (off[i])     fillDiff++;
  }
  for (int i=0; i < clustering; i++) {
    for (int y=0; y < h; y++) {
      for (int x=0; x < w; x++) {
        int pos=x + y * w;
        int count=0;
        int neighbours=0;
        if (y > 0) {
          if (x > 0) {
            if (off[pos - w - 1])             count++;
            neighbours++;
          }
          if (off[pos - w])           count++;
          neighbours++;
          if (x < (w - 1)) {
            if (off[pos - w + 1])             count++;
            neighbours++;
          }
        }
        if (x > 0) {
          if (off[pos - 1])           count++;
          neighbours++;
        }
        if (off[pos])         count++;
        neighbours++;
        if (x < (w - 1)) {
          if (off[pos + 1])           count++;
          neighbours++;
        }
        if (y < (h - 1)) {
          if (x > 0) {
            if (off[pos + w - 1])             count++;
            neighbours++;
          }
          if (off[pos + w])           count++;
          neighbours++;
          if (x < (w - 1)) {
            if (off[pos + w + 1])             count++;
            neighbours++;
          }
        }
        cur[pos]=2 * count >= neighbours;
        if (cur[pos] != off[pos])         fillDiff+=cur[pos] ? +1 : -1;
      }
    }
    boolean[] tmp=cur;
    cur=off;
    off=tmp;
  }
  if (forceFillRate && Math.min(w,h) > 2) {
    int[] neighbours=new int[]{-w - 1,-w,-w + 1,-1,0,+1,+w - 1,+w,+w + 1};
    boolean growing=fillDiff < 0;
    while (fillDiff != 0) {
      int cell;
      int tries=0;
      do {
        cell=Random.Int(1,w - 1) + Random.Int(1,h - 1) * w;
        tries++;
      }
 while (off[cell] != growing && tries * 10 < length);
      for (      int i : neighbours) {
        if (fillDiff != 0 && off[cell + i] != growing) {
          off[cell + i]=growing;
          fillDiff+=growing ? +1 : -1;
        }
      }
    }
  }
  return off;
}",0.995429815016322
163995,"public void paint(Level level){
  Painter.fill(level,this,Terrain.WALL);
  Painter.fill(level,this,1,Terrain.EMPTY_SP);
  Door entrance=entrance();
  Painter.fill(level,left + 1,top + 1,width() - 2,1,Terrain.BOOKSHELF);
  if (entrance.y == top) {
    Painter.set(level,entrance.x,entrance.y + 1,Terrain.EMPTY_SP);
  }
 else   if (entrance.y == top + 1) {
    if (entrance.x == left) {
      Painter.set(level,entrance.x + 1,entrance.y,Terrain.EMPTY_SP);
    }
 else {
      Painter.set(level,entrance.x + 1,entrance.y,Terrain.EMPTY_SP);
    }
  }
  int n=Random.IntRange(2,3);
  for (int i=0; i < n; i++) {
    int pos;
    do {
      pos=level.pointToCell(random());
    }
 while (level.map[pos] != Terrain.EMPTY_SP || level.heaps.get(pos) != null);
    Item item;
    if (i == 0)     item=Random.Int(2) == 0 ? new ScrollOfIdentify() : new ScrollOfRemoveCurse();
 else     item=prize(level);
    level.drop(item,pos);
  }
  entrance.set(Door.Type.LOCKED);
  level.addItemToSpawn(new IronKey(Dungeon.depth));
}","public void paint(Level level){
  Painter.fill(level,this,Terrain.WALL);
  Painter.fill(level,this,1,Terrain.EMPTY_SP);
  Door entrance=entrance();
  Painter.fill(level,left + 1,top + 1,width() - 2,1,Terrain.BOOKSHELF);
  Painter.drawInside(level,this,entrance,1,Terrain.EMPTY_SP);
  int n=Random.IntRange(2,3);
  for (int i=0; i < n; i++) {
    int pos;
    do {
      pos=level.pointToCell(random());
    }
 while (level.map[pos] != Terrain.EMPTY_SP || level.heaps.get(pos) != null);
    Item item;
    if (i == 0)     item=Random.Int(2) == 0 ? new ScrollOfIdentify() : new ScrollOfRemoveCurse();
 else     item=prize(level);
    level.drop(item,pos);
  }
  entrance.set(Door.Type.LOCKED);
  level.addItemToSpawn(new IronKey(Dungeon.depth));
}",0.8136752136752137
163996,"public Point random(int m){
  return new Point(Random.Int(left + m,right - m),Random.Int(top + m,bottom - m));
}","public Point random(int m){
  return new Point(Random.IntRange(left + m,right - m),Random.IntRange(top + m,bottom - m));
}",0.9572649572649572
163997,"public void setSize(int w,int h){
  width=w;
  height=h;
  length=w * h;
  map=new int[length];
  Arrays.fill(map,Terrain.WALL);
  Arrays.fill(map,feeling == Level.Feeling.CHASM ? Terrain.CHASM : Terrain.WALL);
  visited=new boolean[length];
  mapped=new boolean[length];
  Dungeon.visible=new boolean[length];
  fieldOfView=new boolean[length()];
  passable=new boolean[length()];
  losBlocking=new boolean[length()];
  flamable=new boolean[length()];
  secret=new boolean[length()];
  solid=new boolean[length()];
  avoid=new boolean[length()];
  water=new boolean[length()];
  pit=new boolean[length()];
}","public void setSize(int w,int h){
  width=w;
  height=h;
  length=w * h;
  map=new int[length];
  Arrays.fill(map,Terrain.WALL);
  Arrays.fill(map,feeling == Level.Feeling.CHASM ? Terrain.CHASM : Terrain.WALL);
  visited=new boolean[length];
  mapped=new boolean[length];
  Dungeon.visible=new boolean[length];
  fieldOfView=new boolean[length()];
  passable=new boolean[length()];
  losBlocking=new boolean[length()];
  flamable=new boolean[length()];
  secret=new boolean[length()];
  solid=new boolean[length()];
  avoid=new boolean[length()];
  water=new boolean[length()];
  pit=new boolean[length()];
  PathFinder.setMapSize(w,h);
}",0.9759229534510432
163998,"public static void resetMap(){
  if (scene != null) {
    scene.tiles.map(Dungeon.level.map,Dungeon.level.width());
    scene.terrainFeatures.map(Dungeon.level.map,Dungeon.level.width());
    scene.walls.map(Dungeon.level.map,Dungeon.level.width());
  }
  updateFog();
}","public static void resetMap(){
  if (scene != null) {
    scene.tiles.map(Dungeon.level.map,Dungeon.level.width());
    scene.visualGrid.map(Dungeon.level.map,Dungeon.level.width());
    scene.terrainFeatures.map(Dungeon.level.map,Dungeon.level.width());
    scene.walls.map(Dungeon.level.map,Dungeon.level.width());
  }
  updateFog();
}",0.8896210873146623
163999,"@Override protected void layout(){
  super.layout();
  icon.x=x + (width - icon.width) / 2;
  icon.y=y + (height - icon.height) / 2;
  if (topLeft != null) {
    topLeft.x=x;
    topLeft.y=y;
  }
  if (topRight != null) {
    topRight.x=x + (width - topRight.width());
    topRight.y=y;
  }
  if (bottomRight != null) {
    bottomRight.x=x + (width - bottomRight.width());
    bottomRight.y=y + (height - bottomRight.height());
  }
  if (bottomRightIcon != null) {
    bottomRightIcon.x=x + (width - bottomRightIcon.width()) - 1;
    bottomRightIcon.y=y + (height - bottomRightIcon.height());
  }
}","@Override protected void layout(){
  super.layout();
  icon.x=x + (width - icon.width) / 2f;
  icon.y=y + (height - icon.height) / 2f;
  PixelScene.align(icon);
  if (topLeft != null) {
    topLeft.x=x;
    topLeft.y=y;
    PixelScene.align(topLeft);
  }
  if (topRight != null) {
    topRight.x=x + (width - topRight.width());
    topRight.y=y;
    PixelScene.align(topRight);
  }
  if (bottomRight != null) {
    bottomRight.x=x + (width - bottomRight.width());
    bottomRight.y=y + (height - bottomRight.height());
    PixelScene.align(bottomRight);
  }
  if (bottomRightIcon != null) {
    bottomRightIcon.x=x + (width - bottomRightIcon.width()) - 1;
    bottomRightIcon.y=y + (height - bottomRightIcon.height());
    PixelScene.align(bottomRightIcon);
  }
}",0.878765613519471
164000,"@Override protected void layout(){
  health.visible=!Float.isNaN(healthLvl);
  imIcon.x=x + (Math.max(0,8 - imIcon.width() / 2));
  imIcon.y=y + (Math.max(0,8 - imIcon.height() / 2));
  int imWidth=(int)Math.max(imIcon.width(),16);
  int imHeight=(int)Math.max(imIcon.height(),16);
  tfLabel.maxWidth((int)(width - (imWidth + GAP)));
  tfLabel.setPos(x + imWidth + GAP,imHeight > tfLabel.height() ? y + (imHeight - tfLabel.height()) / 2 : y);
  PixelScene.align(tfLabel);
  if (health.visible) {
    health.setRect(tfLabel.left(),tfLabel.bottom(),tfLabel.maxWidth(),0);
    height=Math.max(imHeight,health.bottom());
  }
 else {
    height=Math.max(imHeight,tfLabel.height());
  }
}","@Override protected void layout(){
  health.visible=!Float.isNaN(healthLvl);
  imIcon.x=x + (Math.max(0,8 - imIcon.width() / 2));
  imIcon.y=y + (Math.max(0,8 - imIcon.height() / 2));
  PixelScene.align(imIcon);
  int imWidth=(int)Math.max(imIcon.width(),16);
  int imHeight=(int)Math.max(imIcon.height(),16);
  tfLabel.maxWidth((int)(width - (imWidth + GAP)));
  tfLabel.setPos(x + imWidth + GAP,imHeight > tfLabel.height() ? y + (imHeight - tfLabel.height()) / 2 : y);
  PixelScene.align(tfLabel);
  if (health.visible) {
    health.setRect(tfLabel.left(),tfLabel.bottom(),tfLabel.maxWidth(),0);
    height=Math.max(imHeight,health.bottom());
  }
 else {
    height=Math.max(imHeight,tfLabel.height());
  }
}",0.9798850574712644
