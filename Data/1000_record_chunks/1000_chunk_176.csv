record_number,buggy_code,fixed_code,code_similarity
175001,"public Object[] call(){
  Cache c=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
  StringBuilder ff=new StringBuilder(initfile).append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).append(""String_Node_Str"");
  final File f=c.newFile(ff.toString());
  if (f == null) {
    return new Object[]{ff.toString(),null};
  }
  GeoImageReader gir2=imagePool.get();
  String next=new StringBuilder().append(level).append(""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).toString();
  if (gir2 == null) {
    return new Object[]{f.getAbsolutePath(),next,null};
  }
  try {
    int x=i * (1 << level) * Constant.TILE_SIZE_IMG_LAYER - xpadding;
    int y=j * (1 << level) * Constant.TILE_SIZE_IMG_LAYER - ypadding;
    float zoom=(1 << level);
    final BufferedImage out=createImage(gir2,x,y,Constant.TILE_SIZE_IMG_LAYER,Constant.TILE_SIZE_IMG_LAYER,zoom);
    ImageIO.write(out,""String_Node_Str"",f);
    return new Object[]{f.getAbsolutePath(),next,out};
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
    imagePool.release(gir2);
  }
  return new Object[]{f.getAbsolutePath(),next,null};
}","public TileInfo call(){
  Cache c=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
  StringBuilder ff=new StringBuilder(initfile).append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).append(""String_Node_Str"");
  final File f=c.newFile(ff.toString());
  if (f == null) {
    return new TileInfo(null,ff.toString(),null);
  }
  GeoImageReader gir2=imagePool.get();
  String next=new StringBuilder().append(level).append(""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).toString();
  if (gir2 == null) {
    return new TileInfo(next,f.getAbsolutePath(),null);
  }
  try {
    int x=i * (1 << level) * Constant.TILE_SIZE_IMG_LAYER - xpadding;
    int y=j * (1 << level) * Constant.TILE_SIZE_IMG_LAYER - ypadding;
    float zoom=(1 << level);
    final BufferedImage out=createImage(gir2,x,y,Constant.TILE_SIZE_IMG_LAYER,Constant.TILE_SIZE_IMG_LAYER,zoom);
    ImageIO.write(out,""String_Node_Str"",f);
    return new TileInfo(next,f.getAbsolutePath(),out);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
    imagePool.release(gir2);
  }
  return new TileInfo(next,f.getAbsolutePath(),null);
}",0.9255025620811984
175002,"/** 
 * @param initfile file tile
 * @param level	   zoom level
 * @param i
 * @param j
 */
public void addTileToQueue(final String initfile,final int level,final int i,final int j){
  String tilesStr=new StringBuffer(level).append(""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).toString();
  if (!submitedTiles.contains(tilesStr)) {
    submitedTiles.add(tilesStr);
    futures.add(0,poolExcutorService.submit(new ServiceTile(initfile,level,i,j)));
  }
}","/** 
 * @param initfile file tile
 * @param level	   zoom level
 * @param i
 * @param j
 */
public void addTileToQueue(final String initfile,final int level,final int i,final int j){
  String tilesStr=this.buildTileId(level,i,j);
  if (!submitedTiles.contains(tilesStr)) {
    submitedTiles.add(tilesStr);
    futures.add(0,poolExcutorService.submit(new ServiceTile(initfile,level,i,j)));
  }
}",0.7961165048543689
175003,"public ServiceTile(File tilefile,int level,int i,int j){
  super();
  this.tileFile=tilefile;
  this.i=i;
  this.j=j;
  this.level=level;
}","public ServiceTile(String initfile,int level,int i,int j){
  super();
  this.initfile=initfile;
  this.i=i;
  this.j=j;
  this.level=level;
}",0.9
175004,"private boolean tryFileCache(GL2 gl,File file,int level,int i,int j,float xmin,float xmax,float ymin,float ymax){
  String tileId=this.buildTileId(level,i,j);
  boolean ok=true;
  if (file.exists() && !submitedTiles.contains(tileId)) {
    BufferedImage temp=null;
    try {
      try {
        temp=ImageIO.read(file);
      }
 catch (      Exception ex) {
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
        temp=ImageIO.read(file);
      }
      if (temp == null) {
        ok=false;
      }
    }
 catch (    Exception ex) {
      ok=false;
      logger.warn(""String_Node_Str"" + file.getPath() + ""String_Node_Str""+ ex.getMessage());
    }
 finally {
      pngReader.dispose();
    }
    if (ok) {
      if (temp.getColorModel().getNumComponents() == 1) {
        temp=rescale.filter(temp,rescale.createCompatibleDestImage(temp,temp.getColorModel()));
      }
      Texture t=AWTTextureIO.newTexture(gl.getGLProfile(),temp,false);
      tcm.add(file.getAbsolutePath(),t);
      bindTexture(gl,t,xmin,xmax,ymin,ymax);
    }
  }
 else {
    ok=false;
  }
  return ok;
}","private boolean tryFileCache(GL gl,String file,int level,int i,int j,float xmin,float xmax,float ymin,float ymax){
  String tileId=new StringBuilder(""String_Node_Str"").append(level).append(""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).toString();
  Cache cacheInstance=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
  boolean ok=true;
  if (cacheInstance.contains(file) & !submitedTiles.contains(tileId)) {
    BufferedImage temp=null;
    try {
      try {
        temp=ImageIO.read(cacheInstance.newFile(file));
      }
 catch (      Exception ex) {
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
        temp=ImageIO.read(cacheInstance.newFile(file));
      }
      if (temp == null) {
        ok=false;
      }
    }
 catch (    Exception ex) {
      ok=false;
      logger.warn(""String_Node_Str"" + file + ""String_Node_Str""+ ex.getMessage());
    }
 finally {
      pngReader.dispose();
    }
    if (ok) {
      if (temp.getColorModel().getNumComponents() == 1) {
        temp=rescale.filter(temp,rescale.createCompatibleDestImage(temp,temp.getColorModel()));
      }
      Texture t=AWTTextureIO.newTexture(gl.getGLProfile(),temp,false);
      tcm.add(file,t);
      bindTexture(gl,t,xmin,xmax,ymin,ymax);
    }
  }
 else {
    ok=false;
  }
  return ok;
}",0.762481089258699
175005,"/** 
 * @param gl
 * @param texture
 * @param xmin
 * @param xmax
 * @param ymin
 * @param ymax
 */
private void bindTexture(GL2 gl,Texture texture,float xmin,float xmax,float ymin,float ymax){
  texture.enable(gl);
  texture.bind(gl);
  TextureCoords coords=texture.getImageTexCoords();
  gl.glBegin(GL2.GL_POLYGON);
  gl.glTexCoord2f(coords.left(),coords.top());
  gl.glVertex2f(xmin,1 - ymin);
  gl.glTexCoord2f(coords.right(),coords.top());
  gl.glVertex2f(xmax,1 - ymin);
  gl.glTexCoord2f(coords.right(),coords.bottom());
  gl.glVertex2f(xmax,1 - ymax);
  gl.glTexCoord2f(coords.left(),coords.bottom());
  gl.glVertex2f(xmin,1 - ymax);
  gl.glEnd();
  texture.disable(gl);
}","/** 
 * @param gl
 * @param texture
 * @param xmin
 * @param xmax
 * @param ymin
 * @param ymax
 */
private void bindTexture(GL gl,Texture texture,float xmin,float xmax,float ymin,float ymax){
  texture.enable(gl);
  texture.bind(gl);
  TextureCoords coords=texture.getImageTexCoords();
  gl.getGL2().glBegin(GL2.GL_QUADS);
  gl.getGL2().glTexCoord2f(coords.left(),coords.top());
  gl.getGL2().glVertex2f(xmin,1 - ymin);
  gl.getGL2().glTexCoord2f(coords.right(),coords.top());
  gl.getGL2().glVertex2f(xmax,1 - ymin);
  gl.getGL2().glTexCoord2f(coords.right(),coords.bottom());
  gl.getGL2().glVertex2f(xmax,1 - ymax);
  gl.getGL2().glTexCoord2f(coords.left(),coords.bottom());
  gl.getGL2().glVertex2f(xmin,1 - ymax);
  gl.getGL2().glEnd();
  texture.disable(gl);
}",0.9191430545957152
175006,"private void disposeSync(){
  poolExcutorService.shutdownNow();
  poolExcutorService=null;
  activeGir.dispose();
  activeGir=null;
  tcm.clear();
  tcm=null;
  submitedTiles.clear();
  submitedTiles=null;
  imagePool.dispose();
  imagePool=null;
  SumoPlatform.getApplication().getLayerManager().removeLayer(this);
}","private void disposeSync(){
  poolExcutorService.shutdownNow();
  poolExcutorService=null;
  activeGir.dispose();
  activeGir=null;
  tcm.clear();
  tcm=null;
  submitedTiles.clear();
  submitedTiles=null;
  SumoPlatform.getApplication().getLayerManager().removeLayer(this);
}",0.7689713322091062
175007,"@Override public void dispose(){
  disposed=true;
  if (poolExcutorService != null) {
    poolExcutorService.shutdownNow();
    poolExcutorService=null;
  }
  if (activeGir != null) {
    activeGir.dispose();
    activeGir=null;
  }
  if (tcm != null) {
    tcm.clear();
    tcm=null;
  }
  if (submitedTiles != null) {
    submitedTiles.clear();
    submitedTiles=null;
  }
  if (imagePool != null) {
    imagePool.dispose();
    imagePool=null;
  }
  SumoPlatform.getApplication().getLayerManager().removeLayer(this);
}","@Override public void dispose(){
  disposed=true;
  if (poolExcutorService != null) {
    poolExcutorService.shutdownNow();
    poolExcutorService=null;
  }
  if (activeGir != null) {
    activeGir.dispose();
    activeGir=null;
  }
  if (tcm != null) {
    tcm.clear();
    tcm=null;
  }
  if (submitedTiles != null) {
    submitedTiles.clear();
    submitedTiles=null;
  }
  SumoPlatform.getApplication().getLayerManager().removeLayer(this);
}",0.7991718426501035
175008,"/** 
 * @param gl
 */
private void updateFutures(GL gl){
  List<Future<TileInfo>> remove1=new ArrayList<Future<TileInfo>>();
  for (  Future<TileInfo> f : futures) {
    if (f.isDone() || f.isCancelled()) {
      remove1.add(f);
      try {
        TileInfo o=f.get();
        submitedTiles.remove(o.idTile);
        if (o.pngImage != null) {
          tcm.add(o.path.getAbsolutePath(),AWTTextureIO.newTexture(gl.getGLProfile(),o.pngImage,false));
        }
      }
 catch (      Exception ex) {
        logger.error(ex.getMessage(),ex);
      }
    }
  }
  futures.removeAll(remove1);
}","/** 
 * @param gl
 */
private void updateFutures(GL gl){
  List<Future<Object[]>> remove1=new ArrayList<Future<Object[]>>();
  for (  Future<Object[]> f : futures) {
    if (f.isDone() || f.isCancelled()) {
      remove1.add(f);
      try {
        Object[] o=f.get();
        submitedTiles.remove(o[1]);
        if (o.length > 2 && o[2] != null) {
          tcm.add((String)o[0],AWTTextureIO.newTexture(gl.getGLProfile(),(BufferedImage)o[2],false));
        }
      }
 catch (      Exception ex) {
        logger.error(ex.getMessage(),ex);
      }
    }
  }
  futures.removeAll(remove1);
}",0.7748513169073916
175009,"@Override public void render(Object glContext){
  OpenGLContext context=(OpenGLContext)glContext;
  if (activeGir != null) {
    if (torescale) {
      torescale=false;
      tcm.clear();
    }
    GL2 gl=context.getGL().getGL2();
    updateFutures(gl);
    float zoom=context.getZoom();
    int width=context.getWidth();
    int height=context.getHeight();
    int x=context.getX();
    int y=context.getY();
    int xx=(int)(x + xpadding);
    int yy=(int)(y + ypadding);
    int max=maxnumberoftiles;
    Cache c=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
    gl.glTexEnvi(GL2.GL_TEXTURE_ENV,GL2.GL_TEXTURE_ENV_MODE,GL2.GL_REPLACE);
    if (zoom >= 1) {
      curlevel=(int)Math.sqrt(zoom + 1);
      for (int lll=maxlevels; (lll > curlevel - 1); lll--) {
        if (lll > maxlevels) {
          break;
        }
        lll+=increaseLevel;
        if (lll < 0) {
          continue;
        }
        if (this.mylevel != curlevel) {
          this.mylevel=curlevel;
          poolExcutorService.shutdown();
          poolExcutorService=new ThreadPoolExecutor(1,poolSize,100,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
        }
        int w0=xx / ((1 << lll) << 8);
        int h0=yy / ((1 << lll) << 8);
        final String initfile=new StringBuffer(""String_Node_Str"").append((int)lll).append(""String_Node_Str"").append((activeGir instanceof TiledBufferedImage ? ((TiledBufferedImage)activeGir).getDescription() + ""String_Node_Str"" : ""String_Node_Str"")).toString();
        for (int k=0; k < max; k++) {
          for (int j=0; j < max; j++) {
            if (j + h0 < 0) {
              continue;
            }
            for (int i=0; i < max; i++) {
              if (i + w0 < 0) {
                continue;
              }
              if (arrayReadTilesOrder[i][j] == k) {
                float ymin=(float)(((j + h0) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - yy) / (height * zoom));
                float ymax=(float)(((j + h0 + 1) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - yy) / (height * zoom));
                float xmin=(float)(((i + w0) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - xx) / (1d * width * zoom));
                float xmax=(float)(((i + w0 + 1) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - xx) / (1d * width * zoom));
                if (ymin > 1 || ymax < 0) {
                  continue;
                }
                if (xmin > 1 || xmax < 0) {
                  continue;
                }
                final String file=new StringBuffer(""String_Node_Str"" + lll + ""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append((i + w0)).append(""String_Node_Str"").append((j + h0)).append(""String_Node_Str"").toString();
                final File f=c.newFile(file);
                if (!tryMemoryCache(gl,f.getAbsolutePath(),lll,(i + w0),(j + h0),xmin,xmax,ymin,ymax)) {
                  if (!tryFileCache(gl,f,lll,(i + w0),(j + h0),xmin,xmax,ymin,ymax)) {
                    if (curlevel == 0 && lll == 0) {
                      addTileToQueue(f,lll,(i + w0),(j + h0));
                    }
 else                     if (curlevel == lll) {
                      addTileToQueue(f,lll,(i + w0),(j + h0));
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
 else     if (zoom > 0) {
      curlevel=0;
      int w0=xx / Constant.TILE_SIZE_IMG_LAYER;
      int h0=yy / Constant.TILE_SIZE_IMG_LAYER;
      final String initfile=new StringBuilder(c.getPath().toString()).append(""String_Node_Str"").append((activeGir instanceof TiledBufferedImage ? ((TiledBufferedImage)activeGir).getDescription() + ""String_Node_Str"" : ""String_Node_Str"")).toString();
      for (int j=0; j < max; j++) {
        if (j + h0 < 0) {
          continue;
        }
        for (int i=0; i < max; i++) {
          if (i + w0 < 0) {
            continue;
          }
          float ymin=(float)(((j + h0) * Constant.OVERVIEW_SIZE_DOUBLE - yy) / (height * zoom));
          float ymax=(float)(((j + h0 + 1) * Constant.OVERVIEW_SIZE_DOUBLE - yy) / (height * zoom));
          float xmin=(float)(((i + w0) * Constant.OVERVIEW_SIZE_DOUBLE - xx) / (1d * width * zoom));
          float xmax=(float)(((i + w0 + 1) * Constant.OVERVIEW_SIZE_DOUBLE - xx) / (1d * width * zoom));
          if (ymin > 1 || ymax < 0) {
            continue;
          }
          if (xmin > 1 || xmax < 0) {
            continue;
          }
          String file=new StringBuilder(""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append((i + w0)).append(""String_Node_Str"").append((j + h0)).append(""String_Node_Str"").toString();
          final File f=c.newFile(file);
          if (!tryMemoryCache(gl,f.getAbsolutePath(),0,(i + w0),(j + h0),xmin,xmax,ymin,ymax)) {
            if (!tryFileCache(gl,f,0,(i + w0),(j + h0),xmin,xmax,ymin,ymax)) {
              addTileToQueue(f,0,(i + w0),(j + h0));
            }
          }
        }
      }
    }
    displayDownloading(futures.size());
    SumoPlatform.getApplication().refresh();
    if (this.disposed) {
      disposeSync();
    }
  }
}","@Override public void render(Object glContext){
  OpenGLContext context=(OpenGLContext)glContext;
  if (activeGir != null) {
    if (torescale) {
      torescale=false;
      tcm.clear();
    }
    GL gl=context.getGL();
    updateFutures(gl);
    float zoom=context.getZoom();
    int width=context.getWidth();
    int height=context.getHeight();
    int x=context.getX();
    int y=context.getY();
    int xx=(int)(x + xpadding);
    int yy=(int)(y + ypadding);
    int max=maxnumberoftiles;
    Cache c=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
    gl.getGL2().glTexEnvi(GL2.GL_TEXTURE_ENV,GL2.GL_TEXTURE_ENV_MODE,GL2.GL_REPLACE);
    if (zoom >= 1) {
      curlevel=(int)Math.sqrt(zoom + 1);
      for (int lll=maxlevels; (lll > curlevel - 1); lll--) {
        if (lll > maxlevels) {
          break;
        }
        lll+=increaseLevel;
        if (lll < 0) {
          continue;
        }
        if (this.mylevel != curlevel) {
          this.mylevel=curlevel;
          poolExcutorService.shutdown();
          poolExcutorService=new ThreadPoolExecutor(1,poolSize,100,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
        }
        int w0=xx / ((1 << lll) << 8);
        int h0=yy / ((1 << lll) << 8);
        final String initfile=new StringBuffer(""String_Node_Str"").append((int)lll).append(""String_Node_Str"").append((activeGir instanceof TiledBufferedImage ? ((TiledBufferedImage)activeGir).getDescription() + ""String_Node_Str"" : ""String_Node_Str"")).toString();
        for (int k=0; k < max; k++) {
          for (int j=0; j < max; j++) {
            if (j + h0 < 0) {
              continue;
            }
            for (int i=0; i < max; i++) {
              if (i + w0 < 0) {
                continue;
              }
              if (arrayReadTilesOrder[i][j] == k) {
                float ymin=(float)(((j + h0) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - yy) / (height * zoom));
                float ymax=(float)(((j + h0 + 1) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - yy) / (height * zoom));
                float xmin=(float)(((i + w0) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - xx) / (1d * width * zoom));
                float xmax=(float)(((i + w0 + 1) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - xx) / (1d * width * zoom));
                if (ymin > 1 || ymax < 0) {
                  continue;
                }
                if (xmin > 1 || xmax < 0) {
                  continue;
                }
                String file=new StringBuffer(initfile).append(getBandFolder(activeBand)).append(""String_Node_Str"").append((i + w0)).append(""String_Node_Str"").append((j + h0)).append(""String_Node_Str"").toString();
                if (!tryMemoryCache(gl,file,xmin,xmax,ymin,ymax)) {
                  if (!tryFileCache(gl,file,lll,(i + w0),(j + h0),xmin,xmax,ymin,ymax)) {
                    if (curlevel == 0 && lll == 0) {
                      addTileToQueue(initfile,lll,(i + w0),(j + h0));
                    }
 else                     if (curlevel == lll) {
                      addTileToQueue(initfile,lll,(i + w0),(j + h0));
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
 else     if (zoom > 0) {
      curlevel=0;
      int w0=xx / Constant.TILE_SIZE_IMG_LAYER;
      int h0=yy / Constant.TILE_SIZE_IMG_LAYER;
      final String initfile=new StringBuilder(""String_Node_Str"").append((activeGir instanceof TiledBufferedImage ? ((TiledBufferedImage)activeGir).getDescription() + ""String_Node_Str"" : ""String_Node_Str"")).toString();
      for (int j=0; j < max; j++) {
        if (j + h0 < 0) {
          continue;
        }
        for (int i=0; i < max; i++) {
          if (i + w0 < 0) {
            continue;
          }
          float ymin=(float)(((j + h0) * Constant.OVERVIEW_SIZE_DOUBLE - yy) / (height * zoom));
          float ymax=(float)(((j + h0 + 1) * Constant.OVERVIEW_SIZE_DOUBLE - yy) / (height * zoom));
          float xmin=(float)(((i + w0) * Constant.OVERVIEW_SIZE_DOUBLE - xx) / (1d * width * zoom));
          float xmax=(float)(((i + w0 + 1) * Constant.OVERVIEW_SIZE_DOUBLE - xx) / (1d * width * zoom));
          if (ymin > 1 || ymax < 0) {
            continue;
          }
          if (xmin > 1 || xmax < 0) {
            continue;
          }
          String file=new StringBuilder(initfile).append(getBandFolder(activeBand)).append(""String_Node_Str"").append((i + w0)).append(""String_Node_Str"").append((j + h0)).append(""String_Node_Str"").toString();
          if (!tryMemoryCache(gl,file,xmin,xmax,ymin,ymax)) {
            if (!tryFileCache(gl,file,0,(i + w0),(j + h0),xmin,xmax,ymin,ymax)) {
              addTileToQueue(initfile,0,(i + w0),(j + h0));
            }
          }
        }
      }
    }
    displayDownloading(futures.size());
    SumoPlatform.getApplication().refresh();
    if (this.disposed) {
      disposeSync();
    }
  }
}",0.8967569175840524
175010,"/** 
 * @param gir
 */
public ImageLayer(GeoImageReader gir){
  iReader=ImageIO.getImageReadersByFormatName(""String_Node_Str"");
  pngReader=(ImageReader)iReader.next();
  this.activeGir=gir;
  poolSize=Integer.parseInt(ResourceBundle.getBundle(""String_Node_Str"").getString(""String_Node_Str""));
  poolExcutorService=new ThreadPoolExecutor(1,poolSize,100,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
  submitedTiles=new ArrayList<String>();
  imagePool=new ImagePool(gir,poolSize);
  setName(gir);
  activeBand=0;
  levels=(int)(Math.sqrt(Math.max(gir.getWidth() / Constant.TILE_SIZE_DOUBLE,gir.getHeight() / Constant.TILE_SIZE_DOUBLE))) + 1;
  maxlevels=(int)(Math.sqrt(Math.max(gir.getWidth() / (Constant.TILE_SIZE_DOUBLE * 2),gir.getHeight() / (Constant.TILE_SIZE_DOUBLE * 2)))) + 1;
  curlevel=levels;
  xpadding=(((1 << levels) << 8) - gir.getWidth()) / 2;
  ypadding=(((1 << levels) << 8) - gir.getHeight()) / 2;
  String temp=SumoPlatform.getApplication().getConfiguration().getMaxTileBuffer();
  int maxBuffer=Integer.parseInt(temp);
  tcm=new TextureCacheManager(maxBuffer);
  setInitialContrast();
  maxnumberoftiles=SumoPlatform.getApplication().getConfiguration().getMaxNumOfTiles();
  createMatrixTileOrder();
  int tileSize=(int)(Constant.TILESIZE / gir.getPixelsize()[0]);
  if (tileSize < Constant.TILESIZEPIXELS)   tileSize=Constant.TILESIZEPIXELS;
  this.horizontalTilesImage=gir.getWidth() / tileSize;
  this.verticalTilesImage=gir.getHeight() / tileSize;
  this.realTileSizeX=gir.getWidth() / horizontalTilesImage;
  this.realTileSizeY=gir.getHeight() / verticalTilesImage;
}","/** 
 * @param gir
 */
public ImageLayer(GeoImageReader gir){
  iReader=ImageIO.getImageReadersByFormatName(""String_Node_Str"");
  pngReader=(ImageReader)iReader.next();
  this.activeGir=gir;
  poolSize=Integer.parseInt(ResourceBundle.getBundle(""String_Node_Str"").getString(""String_Node_Str""));
  poolExcutorService=new ThreadPoolExecutor(1,poolSize,100,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
  submitedTiles=new ArrayList<String>();
  setName(gir);
  activeBand=0;
  levels=(int)(Math.sqrt(Math.max(gir.getWidth() / Constant.TILE_SIZE_DOUBLE,gir.getHeight() / Constant.TILE_SIZE_DOUBLE))) + 1;
  maxlevels=(int)(Math.sqrt(Math.max(gir.getWidth() / (Constant.TILE_SIZE_DOUBLE * 2),gir.getHeight() / (Constant.TILE_SIZE_DOUBLE * 2)))) + 1;
  curlevel=levels;
  xpadding=(((1 << levels) << 8) - gir.getWidth()) / 2;
  ypadding=(((1 << levels) << 8) - gir.getHeight()) / 2;
  String temp=SumoPlatform.getApplication().getConfiguration().getMaxTileBuffer();
  int maxBuffer=Integer.parseInt(temp);
  tcm=new TextureCacheManager(maxBuffer);
  setInitialContrast();
  maxnumberoftiles=SumoPlatform.getApplication().getConfiguration().getMaxNumOfTiles();
  createMatrixTileOrder();
  int tileSize=(int)(Constant.TILESIZE / gir.getPixelsize()[0]);
  if (tileSize < Constant.TILESIZEPIXELS)   tileSize=Constant.TILESIZEPIXELS;
  this.horizontalTilesImage=gir.getWidth() / tileSize;
  this.verticalTilesImage=gir.getHeight() / tileSize;
  this.realTileSizeX=gir.getWidth() / horizontalTilesImage;
  this.realTileSizeY=gir.getHeight() / verticalTilesImage;
}",0.9870866141732284
175011,"public TileInfo call(){
  if (tileFile == null) {
    return null;
  }
  GeoImageReader gir2=imagePool.get();
  String next=buildTileId(level,i,j);
  if (gir2 == null) {
    return new TileInfo(next,tileFile,null);
  }
  try {
    int x=i * (1 << level) * Constant.TILE_SIZE_IMG_LAYER - xpadding;
    int y=j * (1 << level) * Constant.TILE_SIZE_IMG_LAYER - ypadding;
    float zoom=(1 << level);
    final BufferedImage out=createImage(gir2,x,y,Constant.TILE_SIZE_IMG_LAYER,Constant.TILE_SIZE_IMG_LAYER,zoom);
    ImageIO.write(out,""String_Node_Str"",tileFile);
    return new TileInfo(next,tileFile,out);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
    imagePool.release(gir2);
  }
  return new TileInfo(next,tileFile,null);
}","public Object[] call(){
  Cache c=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
  StringBuilder ff=new StringBuilder(initfile).append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).append(""String_Node_Str"");
  final File f=c.newFile(ff.toString());
  if (f == null) {
    return new Object[]{ff.toString(),null};
  }
  String next=new StringBuilder().append(level).append(""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).toString();
  try {
    int x=i * (1 << level) * Constant.TILE_SIZE_IMG_LAYER - xpadding;
    int y=j * (1 << level) * Constant.TILE_SIZE_IMG_LAYER - ypadding;
    float zoom=(1 << level);
    final BufferedImage out=createImage(activeGir,x,y,Constant.TILE_SIZE_IMG_LAYER,Constant.TILE_SIZE_IMG_LAYER,zoom);
    ImageIO.write(out,""String_Node_Str"",f);
    return new Object[]{f.getAbsolutePath(),next,out};
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
  return new Object[]{f.getAbsolutePath(),next,null};
}",0.528101802757158
175012,"private boolean tryMemoryCache(GL2 gl,String file,int level,int i,int j,float xmin,float xmax,float ymin,float ymax){
  Texture t=tcm.getTexture(file);
  if (t != null) {
    bindTexture(gl,t,xmin,xmax,ymin,ymax);
    return true;
  }
  return false;
}","private boolean tryMemoryCache(GL gl,String file,float xmin,float xmax,float ymin,float ymax){
  Texture t=tcm.getTexture(file);
  if (t != null) {
    bindTexture(gl,t,xmin,xmax,ymin,ymax);
    return true;
  }
  return false;
}",0.9521829521829522
175013,"/** 
 * @param initfile file tile
 * @param level	   zoom level
 * @param i
 * @param j
 */
public void addTileToQueue(final File tileFile,final int level,final int i,final int j){
  String tilesStr=this.buildTileId(level,i,j);
  if (!submitedTiles.contains(tilesStr)) {
    submitedTiles.add(tilesStr);
    futures.add(0,poolExcutorService.submit(new ServiceTile(tileFile,level,i,j)));
  }
}","/** 
 * @param initfile file tile
 * @param level	   zoom level
 * @param i
 * @param j
 */
public void addTileToQueue(final String initfile,final int level,final int i,final int j){
  String tilesStr=new StringBuffer(level).append(""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).toString();
  if (!submitedTiles.contains(tilesStr)) {
    submitedTiles.add(tilesStr);
    futures.add(0,poolExcutorService.submit(new ServiceTile(initfile,level,i,j)));
  }
}",0.6270270270270271
175014,"/** 
 * @param gl
 */
private void updateFutures(GL gl){
  List<Future<Object[]>> remove1=new ArrayList<Future<Object[]>>();
  for (  Future<Object[]> f : futures) {
    if (f.isDone() || f.isCancelled()) {
      remove1.add(f);
      try {
        Object[] o=f.get();
        submitedTiles.remove(o[1]);
        if (o.length > 2 && o[2] != null) {
          tcm.add((String)o[0],AWTTextureIO.newTexture(gl.getGLProfile(),(BufferedImage)o[2],false));
        }
      }
 catch (      Exception ex) {
        logger.error(ex.getMessage(),ex);
      }
    }
  }
  futures.removeAll(remove1);
}","/** 
 * @param gl
 */
private void updateFutures(GL gl){
  List<Future<TileInfo>> remove1=new ArrayList<Future<TileInfo>>();
  for (  Future<TileInfo> f : futures) {
    if (f.isDone() || f.isCancelled()) {
      remove1.add(f);
      try {
        TileInfo o=f.get();
        submitedTiles.remove(o.idTile);
        if (o.pngImage != null) {
          tcm.add(o.idTile,AWTTextureIO.newTexture(gl.getGLProfile(),o.pngImage,false));
        }
      }
 catch (      Exception ex) {
        logger.error(ex.getMessage(),ex);
      }
    }
  }
  futures.removeAll(remove1);
}",0.7717484926787253
175015,"private boolean tryFileCache(GL gl,String file,int level,int i,int j,float xmin,float xmax,float ymin,float ymax){
  String tileId=new StringBuilder(""String_Node_Str"").append(level).append(""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).toString();
  Cache cacheInstance=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
  boolean ok=true;
  if (cacheInstance.contains(file) & !submitedTiles.contains(tileId)) {
    BufferedImage temp=null;
    try {
      try {
        temp=ImageIO.read(cacheInstance.newFile(file));
      }
 catch (      Exception ex) {
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
        temp=ImageIO.read(cacheInstance.newFile(file));
      }
      if (temp == null) {
        ok=false;
      }
    }
 catch (    Exception ex) {
      ok=false;
      logger.warn(""String_Node_Str"" + file + ""String_Node_Str""+ ex.getMessage());
    }
 finally {
      pngReader.dispose();
    }
    if (ok) {
      if (temp.getColorModel().getNumComponents() == 1) {
        temp=rescale.filter(temp,rescale.createCompatibleDestImage(temp,temp.getColorModel()));
      }
      Texture t=AWTTextureIO.newTexture(gl.getGLProfile(),temp,false);
      tcm.add(file,t);
      bindTexture(gl,t,xmin,xmax,ymin,ymax);
    }
  }
 else {
    ok=false;
  }
  return ok;
}","private boolean tryFileCache(GL gl,String file,int level,int i,int j,float xmin,float xmax,float ymin,float ymax){
  String tileId=this.buildTileId(level,i,j);
  Cache cacheInstance=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
  boolean ok=true;
  if (cacheInstance.contains(file) && !submitedTiles.contains(tileId)) {
    BufferedImage temp=null;
    try {
      try {
        temp=ImageIO.read(cacheInstance.newFile(file));
      }
 catch (      Exception ex) {
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
        temp=ImageIO.read(cacheInstance.newFile(file));
      }
      if (temp == null) {
        ok=false;
      }
    }
 catch (    Exception ex) {
      ok=false;
      logger.warn(""String_Node_Str"" + file + ""String_Node_Str""+ ex.getMessage());
    }
 finally {
      pngReader.dispose();
    }
    if (ok) {
      if (temp.getColorModel().getNumComponents() == 1) {
        temp=rescale.filter(temp,rescale.createCompatibleDestImage(temp,temp.getColorModel()));
      }
      Texture t=AWTTextureIO.newTexture(gl.getGLProfile(),temp,false);
      tcm.add(file,t);
      bindTexture(gl,t,xmin,xmax,ymin,ymax);
    }
  }
 else {
    ok=false;
  }
  return ok;
}",0.9266883351390394
175016,"/** 
 * @param gl
 * @param texture
 * @param xmin
 * @param xmax
 * @param ymin
 * @param ymax
 */
private void bindTexture(GL gl,Texture texture,float xmin,float xmax,float ymin,float ymax){
  texture.enable(gl);
  texture.bind(gl);
  TextureCoords coords=texture.getImageTexCoords();
  gl.getGL2().glBegin(GL2.GL_QUADS);
  gl.getGL2().glTexCoord2f(coords.left(),coords.top());
  gl.getGL2().glVertex2f(xmin,1 - ymin);
  gl.getGL2().glTexCoord2f(coords.right(),coords.top());
  gl.getGL2().glVertex2f(xmax,1 - ymin);
  gl.getGL2().glTexCoord2f(coords.right(),coords.bottom());
  gl.getGL2().glVertex2f(xmax,1 - ymax);
  gl.getGL2().glTexCoord2f(coords.left(),coords.bottom());
  gl.getGL2().glVertex2f(xmin,1 - ymax);
  gl.getGL2().glEnd();
  texture.disable(gl);
}","/** 
 * @param gl
 * @param texture
 * @param xmin
 * @param xmax
 * @param ymin
 * @param ymax
 */
private void bindTexture(GL gl,Texture texture,float xmin,float xmax,float ymin,float ymax){
  texture.enable(gl);
  texture.bind(gl);
  TextureCoords coords=texture.getImageTexCoords();
  gl.getGL2().glBegin(GL2.GL_POLYGON);
  gl.getGL2().glTexCoord2f(coords.left(),coords.top());
  gl.getGL2().glVertex2f(xmin,1 - ymin);
  gl.getGL2().glTexCoord2f(coords.right(),coords.top());
  gl.getGL2().glVertex2f(xmax,1 - ymin);
  gl.getGL2().glTexCoord2f(coords.right(),coords.bottom());
  gl.getGL2().glVertex2f(xmax,1 - ymax);
  gl.getGL2().glTexCoord2f(coords.left(),coords.bottom());
  gl.getGL2().glVertex2f(xmin,1 - ymax);
  gl.getGL2().glEnd();
  texture.disable(gl);
}",0.9921875
175017,"public Object[] call(){
  Cache c=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
  StringBuilder ff=new StringBuilder(initfile).append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).append(""String_Node_Str"");
  final File f=c.newFile(ff.toString());
  if (f == null) {
    return new Object[]{ff.toString(),null};
  }
  GeoImageReader gir2=imagePool.get();
  String next=new StringBuilder().append(level).append(""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).toString();
  if (gir2 == null) {
    return new Object[]{f.getAbsolutePath(),next,null};
  }
  try {
    int x=i * (1 << level) * Constant.TILE_SIZE_IMG_LAYER - xpadding;
    int y=j * (1 << level) * Constant.TILE_SIZE_IMG_LAYER - ypadding;
    float zoom=(1 << level);
    final BufferedImage out=createImage(gir2,x,y,Constant.TILE_SIZE_IMG_LAYER,Constant.TILE_SIZE_IMG_LAYER,zoom);
    ImageIO.write(out,""String_Node_Str"",f);
    return new Object[]{f.getAbsolutePath(),next,out};
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
    imagePool.release(gir2);
  }
  return new Object[]{f.getAbsolutePath(),next,null};
}","public TileInfo call(){
  Cache c=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
  StringBuilder ff=new StringBuilder(initfile).append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).append(""String_Node_Str"");
  final File f=c.newFile(ff.toString());
  if (f == null) {
    return new TileInfo(null,ff.toString(),null);
  }
  GeoImageReader gir2=imagePool.get();
  String next=new StringBuilder().append(level).append(""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).toString();
  if (gir2 == null) {
    return new TileInfo(next,f.getAbsolutePath(),null);
  }
  try {
    int x=i * (1 << level) * Constant.TILE_SIZE_IMG_LAYER - xpadding;
    int y=j * (1 << level) * Constant.TILE_SIZE_IMG_LAYER - ypadding;
    float zoom=(1 << level);
    final BufferedImage out=createImage(gir2,x,y,Constant.TILE_SIZE_IMG_LAYER,Constant.TILE_SIZE_IMG_LAYER,zoom);
    ImageIO.write(out,""String_Node_Str"",f);
    return new TileInfo(next,f.getAbsolutePath(),out);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
    imagePool.release(gir2);
  }
  return new TileInfo(next,f.getAbsolutePath(),null);
}",0.9255025620811984
175018,"/** 
 * @param initfile file tile
 * @param level	   zoom level
 * @param i
 * @param j
 */
public void addTileToQueue(final String initfile,final int level,final int i,final int j){
  String tilesStr=new StringBuffer(level).append(""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).toString();
  if (!submitedTiles.contains(tilesStr)) {
    submitedTiles.add(tilesStr);
    futures.add(0,poolExcutorService.submit(new ServiceTile(initfile,level,i,j)));
  }
}","/** 
 * @param initfile file tile
 * @param level	   zoom level
 * @param i
 * @param j
 */
public void addTileToQueue(final String initfile,final int level,final int i,final int j){
  String tilesStr=this.buildTileId(level,i,j);
  if (!submitedTiles.contains(tilesStr)) {
    submitedTiles.add(tilesStr);
    futures.add(0,poolExcutorService.submit(new ServiceTile(initfile,level,i,j)));
  }
}",0.7961165048543689
175019,"public boolean contains(String fileName){
  if (fileName == null) {
    return false;
  }
  fileName=clean(fileName);
  java.io.File file;
  if (fileName.startsWith(getPath().getAbsolutePath())) {
    file=new java.io.File(fileName);
  }
 else {
    file=new File(new StringBuilder(getPath().getAbsolutePath()).append(""String_Node_Str"").append(fileName).toString());
  }
  if (file.exists()) {
    return true;
  }
  return false;
}","/** 
 * @param fileName
 * @return
 */
public boolean contains(String fileName){
  if (fileName == null) {
    return false;
  }
  fileName=clean(fileName);
  java.io.File file;
  if (fileName.startsWith(getPath().getAbsolutePath())) {
    file=new java.io.File(fileName);
  }
 else {
    file=new File(new StringBuilder(getPath().getAbsolutePath()).append(""String_Node_Str"").append(fileName).toString());
  }
  if (file.exists()) {
    return true;
  }
  return false;
}",0.956810631229236
175020,"/** 
 * Reads single pixel value of the curent band.
 * @param x
 * @param y
 * @return pixel value
 */
public int readPixel(int x,int y,int band);","/** 
 * Reads single pixel value of the curent band.
 * @param x
 * @param y
 * @return pixel value
 */
public long readPixel(int x,int y,int band);",0.9830508474576272
175021,"@Override public int readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  t.setSourceRegion(new Rectangle(x,y,1,1));
  int[] pix=new int[1];
  tiffRaster.getPixel(x,y,pix);
  return pix[0];
}","@Override public long readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  t.setSourceRegion(new Rectangle(x,y,1,1));
  int[] pix=new int[1];
  tiffRaster.getPixel(x,y,pix);
  return pix[0];
}",0.9842696629213484
175022,"public int readPixel(int x,int y,int band){
  return readTile(x,y,1,1,band)[0];
}","public long readPixel(int x,int y,int band){
  return readTile(x,y,1,1,band)[0];
}",0.9693251533742332
175023,"@Override public int readPixel(int x,int y,int band){
  return read(x,y,1,1,band)[0];
}","@Override public long readPixel(int x,int y,int band){
  return read(x,y,1,1,band)[0];
}",0.9714285714285714
175024,"@Override public int[] readTile(int x,int y,int width,int height,int band){
  TIFF tiff=(TIFF)getImage(band);
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(tiff.getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.width * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  int yOffset=tiff.xSize;
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=preloadedData[temp];
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}","@Override public int[] readTile(int x,int y,int width,int height,int band){
  TIFF tiff=(TIFF)getImage(band);
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(tiff.getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.width * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  int yOffset=tiff.xSize;
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=(int)preloadedData[temp];
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}",0.9973890339425588
175025,"@Override public void preloadLineTile(int y,int length,int band){
  TIFF tiff=(TIFF)getImage(band);
  if (y < 0) {
    return;
  }
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,tiff.xSize,length);
  rect=tiff.getBounds().intersection(rect);
  try {
    BufferedImage bi=null;
    try {
      bi=tiff.read(0,rect);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.read(0,rect);
    }
    WritableRaster raster=bi.getRaster();
    preloadedData=(short[])raster.getDataElements(0,0,raster.getWidth(),raster.getHeight(),null);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}","@Override public void preloadLineTile(int y,int length,int band){
  TIFF tiff=(TIFF)getImage(band);
  if (y < 0) {
    return;
  }
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,tiff.xSize,length);
  rect=tiff.getBounds().intersection(rect);
  try {
    BufferedImage bi=null;
    try {
      bi=tiff.read(0,rect);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.read(0,rect);
    }
    WritableRaster raster=bi.getRaster();
    preloadedData=(Short[])raster.getDataElements(0,0,raster.getWidth(),raster.getHeight(),null);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}",0.9988479262672812
175026,"@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(getImage(band).getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.width * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  int yOffset=getImage(band).xSize;
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=preloadedData[temp];
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}","@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(getImage(band).getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.width * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
  }
  int yOffset=getImage(band).xSize;
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=((Short)preloadedData[temp]).intValue();
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}",0.9694369973190348
175027,"@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,getImage(band).xSize,length);
  TIFF tiff=getImage(band);
  rect=tiff.getBounds().intersection(rect);
  try {
    BufferedImage bi=null;
    try {
      bi=tiff.read(0,rect);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.read(0,rect);
    }
    WritableRaster raster=bi.getRaster();
    preloadedData=(short[])raster.getDataElements(0,0,raster.getWidth(),raster.getHeight(),null);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}","@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,getImage(band).xSize,length);
  TIFF tiff=getImage(band);
  rect=tiff.getBounds().intersection(rect);
  try {
    BufferedImage bi=null;
    try {
      bi=tiff.read(0,rect);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.read(0,rect);
    }
    WritableRaster raster=bi.getRaster();
    short[] ss=(short[])raster.getDataElements(0,0,raster.getWidth(),raster.getHeight(),null);
    preloadedData=ArrayUtils.toObject(ss);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}",0.9607623318385652
175028,"@Override public int readPixel(int x,int y,int band){
  return read(x,y,1,1,band)[0];
}","@Override public long readPixel(int x,int y,int band){
  return read(x,y,1,1,band)[0];
}",0.9714285714285714
175029,"@Override public int[] read(int x,int y,int width,int height,int band){
  int data[]=null;
  GeoToolsGDALReader tiff=(GeoToolsGDALReader)getImage(band);
  try {
    short[] b=tiff.readShortValues(x,y,width,height);
    data=new int[b.length];
    for (int i=0; i < b.length; i++)     data[i]=b[i];
  }
 catch (  Exception ex) {
    logger.warn(ex.getMessage());
  }
 finally {
  }
  return data;
}","@Override public int[] read(int x,int y,int width,int height,int band){
  int data[]=null;
  GeoToolsGDALReader tiff=(GeoToolsGDALReader)getImage(band);
  try {
    int[] b=tiff.readPixValues(x,y,width,height);
    data=new int[b.length];
    for (int i=0; i < b.length; i++)     data[i]=b[i];
  }
 catch (  Exception ex) {
    logger.warn(ex.getMessage());
  }
 finally {
  }
  return data;
}",0.9443037974683544
175030,"@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(getImage(band).getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.y * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
  }
  int yOffset=getImage(band).getxSize();
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=preloadedData[temp];
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}","@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(getImage(band).getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.y * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
  }
  int yOffset=getImage(band).getxSize();
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=(int)preloadedData[temp];
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}",0.9972451790633609
175031,"@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  GeoToolsGDALReader tiff=(GeoToolsGDALReader)getImage(band);
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,tiff.getxSize(),length);
  rect=tiff.getBounds().intersection(rect);
  try {
    short[] bi=null;
    try {
      bi=tiff.readShortValues(0,y,rect.width,rect.height);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.readShortValues(0,y,rect.width,rect.height);
    }
    preloadedData=bi;
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}","@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  GeoToolsGDALReader tiff=(GeoToolsGDALReader)getImage(band);
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,tiff.getxSize(),length);
  rect=tiff.getBounds().intersection(rect);
  try {
    int[] bi=null;
    try {
      bi=tiff.readPixValues(0,y,rect.width,rect.height);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.readPixValues(0,y,rect.width,rect.height);
    }
    preloadedData=ArrayUtils.toObject(bi);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}",0.9734199645599528
175032,"@Override public int readPixel(int x,int y,int band){
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(getImage(band).getBounds());
  short data[]=null;
  GeoToolsGDALReader img=(GeoToolsGDALReader)getImage(band);
  try {
    data=img.readShortValues(x,y,1,1);
  }
  finally {
  }
  return data[0];
}","@Override public long readPixel(int x,int y,int band){
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(getImage(band).getBounds());
  int data[]=null;
  GeoToolsGDALReader img=(GeoToolsGDALReader)getImage(band);
  try {
    data=img.readPixValues(x,y,1,1);
  }
  finally {
  }
  return data[0];
}",0.9667194928684628
175033,"@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(getImage(band).getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.y * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
  }
  int yOffset=getImage(band).getxSize();
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=preloadedData[temp];
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}","@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(getImage(band).getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.y * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
  }
  int yOffset=getImage(band).getxSize();
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=(int)preloadedData[temp];
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}",0.9972451790633609
175034,"@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  CeosBinaryReader tiff=(CeosBinaryReader)getImage(band);
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,tiff.getxSize(),length);
  rect=tiff.getBounds().intersection(rect);
  try {
    short[] bi=null;
    try {
      bi=tiff.readShort(0,y,rect.width,rect.height);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.readShort(0,y,rect.width,rect.height);
    }
    preloadedData=bi;
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}","@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  CeosBinaryReader tiff=(CeosBinaryReader)getImage(band);
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,tiff.getxSize(),length);
  rect=tiff.getBounds().intersection(rect);
  try {
    int[] bi=null;
    try {
      bi=tiff.readInt(0,y,rect.width,rect.height);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.readInt(0,y,rect.width,rect.height);
    }
    preloadedData=ArrayUtils.toObject(bi);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}",0.975316074653823
175035,"@Override public int readPixel(int x,int y,int band){
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(getImage(band).getBounds());
  short data[]=null;
  CeosBinaryReader img=(CeosBinaryReader)getImage(band);
  try {
    data=img.readShort(x,y,1,1);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return data[0];
}","@Override public long readPixel(int x,int y,int band){
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(getImage(band).getBounds());
  short data[]=null;
  CeosBinaryReader img=(CeosBinaryReader)getImage(band);
  try {
    data=img.readShort(x,y,1,1);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return data[0];
}",0.9899280575539569
175036,"public int readPixel(int x,int y,int band){
  if (x < 0 || y < 0 || x > xSize || y > ySize) {
    return -1;
  }
  stride[1]=1;
  stride[0]=1;
  dims[1]=1;
  dims[0]=1;
  starts[1]=x;
  starts[0]=y;
  try {
    Object o2=imagedata.read();
    return Array.getInt(o2,0) & 0xFFFF;
  }
 catch (  Exception ex) {
    logger.error(null,ex);
    return 0;
  }
}","public long readPixel(int x,int y,int band){
  if (x < 0 || y < 0 || x > xSize || y > ySize) {
    return -1;
  }
  stride[1]=1;
  stride[0]=1;
  dims[1]=1;
  dims[0]=1;
  starts[1]=x;
  starts[0]=y;
  try {
    Object o2=imagedata.read();
    return Array.getInt(o2,0) & 0xFFFF;
  }
 catch (  Exception ex) {
    logger.error(null,ex);
    return 0;
  }
}",0.9901547116736992
175037,"@Override public int readPixel(int x,int y,int band){
  int result=0;
  long temp=0;
  byte[] pixelByte=new byte[2];
  if (x >= 0 & y >= 0 & x < xSize & y < ySize) {
    try {
      temp=(y * (xOffset + xSize * 2) + xOffset + x * 2);
      fss.seek(temp + offsetBand);
      fss.read(pixelByte,0,2);
      int interm1=pixelByte[0];
      int interm2=pixelByte[1];
      result=((interm1) << 8 | interm2 & 0xff);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
    }
  }
  return result;
}","@Override public long readPixel(int x,int y,int band){
  int result=0;
  long temp=0;
  byte[] pixelByte=new byte[2];
  if (x >= 0 & y >= 0 & x < xSize & y < ySize) {
    try {
      temp=(y * (xOffset + xSize * 2) + xOffset + x * 2);
      fss.seek(temp + offsetBand);
      fss.read(pixelByte,0,2);
      int interm1=pixelByte[0];
      int interm2=pixelByte[1];
      result=((interm1) << 8 | interm2 & 0xff);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
    }
  }
  return result;
}",0.9937777777777778
175038,"@Override public int readPixel(int x,int y,int band){
  int result=0;
  long temp=0;
  byte[] pixelByte=new byte[4];
  if (x >= 0 & y >= 0 & x < xSize & y < ySize) {
    try {
      temp=(y * (xOffset + xSize * 4) + xOffset + x * 4);
      fss.seek(temp + offsetBand);
      fss.read(pixelByte,0,4);
      byte interm0=pixelByte[0];
      byte interm1=pixelByte[1];
      byte interm2=pixelByte[2];
      byte interm3=pixelByte[3];
      long real=((interm0) << 8) | (interm1 & 0xFF);
      long img=((interm2) << 8) | (interm3 & 0xFF);
      result=(int)Math.sqrt(real * real + img * img);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
    }
  }
  return result;
}","@Override public long readPixel(int x,int y,int band){
  int result=0;
  long temp=0;
  byte[] pixelByte=new byte[4];
  if (x >= 0 & y >= 0 & x < xSize & y < ySize) {
    try {
      temp=(y * (xOffset + xSize * 4) + xOffset + x * 4);
      fss.seek(temp + offsetBand);
      fss.read(pixelByte,0,4);
      byte interm0=pixelByte[0];
      byte interm1=pixelByte[1];
      byte interm2=pixelByte[2];
      byte interm3=pixelByte[3];
      long real=((interm0) << 8) | (interm1 & 0xFF);
      long img=((interm2) << 8) | (interm3 & 0xFF);
      result=(int)Math.sqrt(real * real + img * img);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
    }
  }
  return result;
}",0.99527983816588
175039,"@Override public int readPixel(int x,int y,int band){
  int result=0;
  long temp=0;
  byte[] pixelByte=new byte[2];
  if (x >= 0 & y >= 0 & x < xSize & y < ySize) {
    if (numberOfBytes == 2) {
      try {
        temp=(y * (xOffset + xSize * 2) + xOffset + x * 2);
        dat.seek(temp + offsetImage);
        dat.read(pixelByte,0,2);
        int interm1=pixelByte[0];
        int interm2=pixelByte[1];
        result=((interm1 & 0xff) << 8 | interm2 & 0xff);
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
      }
    }
 else {
      try {
        temp=(y * (xOffset + xSize) + xOffset + x);
        dat.seek(temp + offsetImage);
        dat.read(pixelByte,0,1);
        result=pixelByte[0];
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
      }
    }
  }
  return result;
}","@Override public long readPixel(int x,int y,int band){
  int result=0;
  long temp=0;
  byte[] pixelByte=new byte[2];
  if (x >= 0 & y >= 0 & x < xSize & y < ySize) {
    if (numberOfBytes == 2) {
      try {
        temp=(y * (xOffset + xSize * 2) + xOffset + x * 2);
        dat.seek(temp + offsetImage);
        dat.read(pixelByte,0,2);
        int interm1=pixelByte[0];
        int interm2=pixelByte[1];
        result=((interm1 & 0xff) << 8 | interm2 & 0xff);
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
      }
    }
 else {
      try {
        temp=(y * (xOffset + xSize) + xOffset + x);
        dat.seek(temp + offsetImage);
        dat.read(pixelByte,0,1);
        result=pixelByte[0];
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
      }
    }
  }
  return result;
}",0.9962864721485412
175040,"@Override public int readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  t.setSourceRegion(new Rectangle(x,y,1,1));
  TIFF tiff=getImage(band);
  try {
    return tiff.read(0,t).getRGB(x,y);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
  return -1;
}","@Override public long readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  t.setSourceRegion(new Rectangle(x,y,1,1));
  TIFF tiff=getImage(band);
  try {
    return tiff.read(0,t).getRGB(x,y);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
  return -1;
}",0.9887640449438202
175041,"@Override public int readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int img=tiff.read(0,t).getRaster().getSample(0,0,1);
    int real=tiff.read(0,t).getRaster().getSample(0,0,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
    ex.printStackTrace();
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return -1;
}","@Override public long readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int img=tiff.read(0,t).getRaster().getSample(0,0,1);
    int real=tiff.read(0,t).getRaster().getSample(0,0,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
    ex.printStackTrace();
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return -1;
}",0.9950106913756236
175042,"public MaskGeometries(String maskName,List<Geometry> maskGeometries,String fileName){
  this.maskName=maskName;
  this.maskGeometries=maskGeometries;
  intersectedMapCache=new HashMap<String,Boolean>();
  includesMapCache=new HashMap<String,Boolean>();
  this.fileName=fileName;
}","public MaskGeometries(String maskName,List<Geometry> maskGeometries,String fileName){
  this.maskName=maskName;
  this.maskGeometries=maskGeometries;
  intersectedMapCache=new HashMap<String,Boolean>();
  includesMapCache=new HashMap<String,Boolean>();
  this.fileName=fileName;
  splitMultiPolygons();
}",0.958904109589041
175043,"/** 
 * rasterize the mask clipped with the Rectangle scaled back to full size with an offset onto a BufferedImage
 */
public int[] getRasterDataMask(int x,int y,int w,int h,int offsetX,int offsetY,double scalingFactor){
  Rectangle rect=new Rectangle(x,y,w,h);
  BufferedImage bi=this.rasterize(rect,offsetX,offsetY,scalingFactor);
  Raster rastermask=bi.getData();
  int[] maskdata=rastermask.getPixels(0,0,rastermask.getWidth(),rastermask.getHeight(),(int[])null);
  return maskdata;
}","/** 
 * rasterize the mask clipped with the Rectangle scaled back to full size with an offset onto a BufferedImage
 */
public int[] getRasterDataMask(int x,int y,int w,int h,int offsetX,int offsetY,double scalingFactor){
  Rectangle rect=new Rectangle(x,y,w,h);
  BufferedImage bi=this.rasterize(rect,offsetX,offsetY,scalingFactor);
  Raster rastermask=bi.getData();
  int[] maskdata=rastermask.getSamples(0,0,rastermask.getWidth(),rastermask.getHeight(),0,(int[])null);
  return maskdata;
}",0.9867211440245148
175044,"/** 
 * rasterize the mask clipped with the Rectangle scaled back to full size with an offset onto a BufferedImage
 */
public BufferedImage rasterize(Rectangle rect,int offsetX,int offsetY,double scalingFactor){
  BufferedImage image=new BufferedImage(rect.width,rect.height,BufferedImage.TYPE_BYTE_BINARY);
  GeometryFactory gf=new GeometryFactory();
  Coordinate[] coords=new Coordinate[]{new Coordinate((int)(((double)rect.getMinX() / scalingFactor)),(int)(((double)rect.getMinY() / scalingFactor))),new Coordinate((int)(((double)rect.getMaxX() / scalingFactor)),(int)(((double)rect.getMinY() / scalingFactor))),new Coordinate((int)(((double)rect.getMaxX() / scalingFactor)),(int)(((double)rect.getMaxY() / scalingFactor))),new Coordinate((int)(((double)rect.getMinX() / scalingFactor)),(int)(((double)rect.getMaxY() / scalingFactor))),new Coordinate((int)(((double)rect.getMinX() / scalingFactor)),(int)(((double)rect.getMinY() / scalingFactor)))};
  Polygon geom=gf.createPolygon(gf.createLinearRing(coords));
  Graphics g2d=image.getGraphics();
  g2d.setColor(Color.WHITE);
  for (  Geometry p : maskGeometries) {
    if (p.intersects(geom)) {
      int[] xPoints=new int[p.getNumPoints()];
      int[] yPoints=new int[p.getNumPoints()];
      int i=0;
      for (      Coordinate c : p.getCoordinates()) {
        xPoints[i]=(int)((c.x + offsetX) * scalingFactor);
        yPoints[i]=(int)((c.y + offsetY) * scalingFactor);
        i++;
      }
      g2d.fillPolygon(xPoints,yPoints,p.getNumPoints());
    }
  }
  g2d.dispose();
  return image;
}","/** 
 * rasterize the mask clipped with the Rectangle scaled back to full size with an offset onto a BufferedImage
 */
public BufferedImage rasterize(Rectangle rect,int offsetX,int offsetY,double scalingFactor){
  BufferedImage image=new BufferedImage(rect.width,rect.height,BufferedImage.TYPE_BYTE_BINARY);
  GeometryFactory gf=new GeometryFactory();
  Coordinate[] coords=new Coordinate[]{new Coordinate((int)(((double)rect.getMinX() / scalingFactor)),(int)(((double)rect.getMinY() / scalingFactor))),new Coordinate((int)(((double)rect.getMaxX() / scalingFactor)),(int)(((double)rect.getMinY() / scalingFactor))),new Coordinate((int)(((double)rect.getMaxX() / scalingFactor)),(int)(((double)rect.getMaxY() / scalingFactor))),new Coordinate((int)(((double)rect.getMinX() / scalingFactor)),(int)(((double)rect.getMaxY() / scalingFactor))),new Coordinate((int)(((double)rect.getMinX() / scalingFactor)),(int)(((double)rect.getMinY() / scalingFactor)))};
  Polygon geom=gf.createPolygon(gf.createLinearRing(coords));
  Graphics g2d=image.getGraphics();
  g2d.setColor(Color.white);
  for (  Geometry p : maskGeometries) {
    if (p.intersects(geom)) {
      int[] xPoints=new int[p.getNumPoints()];
      int[] yPoints=new int[p.getNumPoints()];
      int i=0;
      for (      Coordinate c : p.getCoordinates()) {
        xPoints[i]=(int)((c.x + offsetX) * scalingFactor);
        yPoints[i]=(int)((c.y + offsetY) * scalingFactor);
        i++;
      }
      g2d.fillPolygon(xPoints,yPoints,i);
    }
  }
  g2d.dispose();
  return image;
}",0.9653833710773212
175045,"/** 
 * aggregate using the neighbours within tilesize
 * @param neighboursdistance
 * @param tilesize
 * @param removelandconnectedpixels
 * @param bands
 * @param mask
 * @param kdist
 * @throws IOException
 */
private void aggregate(DetectedPixels detPixels,int neighboursdistance,int tilesize,boolean removelandconnectedpixels,int[] bands,MaskGeometries mask,KDistributionEstimation kdist) throws IOException {
  int id=0;
  DetectedPixels.BoatPixel pixels[]=detPixels.getAllDetectedPixelsValues().toArray(new DetectedPixels.BoatPixel[0]);
  int count=0;
  for (  DetectedPixels.BoatPixel detectedPix : pixels) {
    count++;
    int xx=detectedPix.x;
    int yy=detectedPix.y;
    if ((count % 100) == 0) {
      if (logger.isInfoEnabled())       logger.info(new StringBuilder().append(""String_Node_Str"").append(count).append(""String_Node_Str"").append(xx).append(""String_Node_Str"").append(yy).toString());
    }
    boolean checked=false;
    for (    BoatConnectedPixelMap boatpixel : detPixels.listboatneighbours) {
      if (boatpixel.containsPixel(xx,yy)) {
        checked=true;
        break;
      }
    }
    if (checked) {
      continue;
    }
    int cornerx=Math.min(Math.max(0,xx - tilesize / 2),gir.getWidth() - tilesize);
    int cornery=Math.min(Math.max(0,yy - tilesize / 2),gir.getHeight() - tilesize);
    int boatx=xx - cornerx;
    int boaty=yy - cornery;
    int numberbands=bands.length;
    int[][] data=new int[numberbands][];
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      data[bandcounter]=gir.read(cornerx,cornery,tilesize,tilesize,bands[bandcounter]);
    }
    int row=(cornery + 1) / this.verTilesImage;
    int col=(cornerx + 1) / this.horTilesImage;
    TileAnalysis ta=null;
    if (this.blackBorderAnalysis != null)     ta=this.blackBorderAnalysis.getAnalysisTile(row,col);
    double[][] statistics=AnalysisUtil.calculateImagemapStatistics(cornerx,cornery,tilesize,tilesize,row,col,bands,data,kdist,ta);
    double[][] thresholdvalues=new double[numberbands][2];
    boolean pixelabove=false;
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      double mean=(statistics[bandcounter][1] + statistics[bandcounter][2] + statistics[bandcounter][3]+ statistics[bandcounter][4]) / 4;
      thresholdvalues[bandcounter][0]=mean + 3 * mean * statistics[bandcounter][0];
      thresholdvalues[bandcounter][1]=mean + 5 * mean * statistics[bandcounter][0];
      int value=data[bandcounter][boatx + boaty * tilesize];
      if (value > thresholdvalues[bandcounter][1]) {
        pixelabove=true;
      }
    }
    if (pixelabove) {
      int[] dataMask=createDataMask(cornerx,cornery,tilesize,tilesize,0,0);
      BoatConnectedPixelMap boatpixel=null;
      try {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][boatx + boaty * tilesize]);
      }
 catch (      Exception e) {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][(boatx + boaty * tilesize) - 1]);
      }
      for (int iBand=0; iBand < numberbands; iBand++) {
        String bb=gir.getBandName(bands[iBand]);
        float thresholdBand=this.thresholdsBandParams.get(bb);
        TileAnalysis bbAnalysis=null;
        if (blackBorderAnalysis != null)         bbAnalysis=blackBorderAnalysis.getAnalysisTile(row,col);
        kdist.setImageData(cornerx,cornery,tilesize,tilesize,iBand,bbAnalysis);
        int[] newdata=gir.read(cornerx,cornery,tilesize,tilesize,bands[iBand]);
        kdist.estimate(newdata,newdata);
        double[] treshTile=kdist.getDetectThresh();
        double threshTotal=treshTile[0] + treshTile[1] + treshTile[2]+ treshTile[3];
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,treshTile);
        double tileAvg=0;
        int i=0;
        int y=-1;
        for (; i < data[iBand].length; i++) {
          int x=i % 200;
          if (x == 0)           y++;
          try {
            if (dataMask == null || dataMask[x + (y * tilesize)] == 0) {
              tileAvg=tileAvg + data[iBand][i];
            }
          }
 catch (          Exception e) {
            logger.warn(new StringBuilder(e.getMessage()).append(""String_Node_Str"").append(x).append(""String_Node_Str"").append(y).append(""String_Node_Str"").toString());
          }
        }
        tileAvg=tileAvg / i;
        double tileStdDev=treshTile[0] * threshTotal / treshTile[5];
        boatpixel.getStatMap().setTreshold(Precision.round((threshWindowsVals[0] + threshWindowsVals[1] + threshWindowsVals[2]+ threshWindowsVals[3]) / 4,3),bb);
        boatpixel.getStatMap().setTileStd(Precision.round(tileStdDev,3),bb);
        boatpixel.getStatMap().setTileAvg(Precision.round(tileAvg,3),bb);
      }
      detPixels.listboatneighbours.add(boatpixel);
      List<int[]> boataggregatedpixels=new ArrayList<int[]>();
      boolean result=detPixels.checkNeighbours(boataggregatedpixels,data,thresholdvalues,new int[]{boatx,boaty},neighboursdistance,tilesize,dataMask);
      boatpixel.setTouchesLandMask(result);
      for (      int[] pixel : boataggregatedpixels) {
        boatpixel.addConnectedPixel(pixel[0] + cornerx,pixel[1] + cornery,pixel[2],pixel[3] == 1 ? true : false);
      }
    }
  }
  if (removelandconnectedpixels) {
    List<BoatConnectedPixelMap> toRemove=new ArrayList<BoatConnectedPixelMap>();
    for (int i=0; i < detPixels.listboatneighbours.size(); i++) {
      BoatConnectedPixelMap boat=detPixels.listboatneighbours.get(i);
      if (boat.touchesLand()) {
        toRemove.add(boat);
      }
    }
    detPixels.listboatneighbours.removeAll(toRemove);
  }
}","/** 
 * aggregate using the neighbours within tilesize
 * @param neighboursdistance
 * @param tilesize
 * @param removelandconnectedpixels
 * @param bands
 * @param mask
 * @param kdist
 * @throws IOException
 */
private void aggregate(DetectedPixels detPixels,int neighboursdistance,int tilesize,boolean removelandconnectedpixels,int[] bands,MaskGeometries mask,KDistributionEstimation kdist) throws IOException {
  int id=0;
  DetectedPixels.BoatPixel pixels[]=detPixels.getAllDetectedPixelsValues().toArray(new DetectedPixels.BoatPixel[0]);
  int count=0;
  for (  DetectedPixels.BoatPixel detectedPix : pixels) {
    count++;
    int xx=detectedPix.x;
    int yy=detectedPix.y;
    if ((count % 100) == 0) {
      if (logger.isInfoEnabled())       logger.info(new StringBuilder().append(""String_Node_Str"").append(count).append(""String_Node_Str"").append(xx).append(""String_Node_Str"").append(yy).toString());
    }
    boolean checked=false;
    for (    BoatConnectedPixelMap boatpixel : detPixels.listboatneighbours) {
      if (boatpixel.containsPixel(xx,yy)) {
        checked=true;
        break;
      }
    }
    if (checked) {
      continue;
    }
    int cornerx=Math.min(Math.max(0,xx - tilesize / 2),gir.getWidth() - tilesize);
    int cornery=Math.min(Math.max(0,yy - tilesize / 2),gir.getHeight() - tilesize);
    int boatx=xx - cornerx;
    int boaty=yy - cornery;
    int numberbands=bands.length;
    int[][] data=new int[numberbands][];
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      data[bandcounter]=gir.read(cornerx,cornery,tilesize,tilesize,bands[bandcounter]);
    }
    int row=(cornery + 1) / this.verTilesImage;
    int col=(cornerx + 1) / this.horTilesImage;
    TileAnalysis ta=null;
    if (this.blackBorderAnalysis != null)     ta=this.blackBorderAnalysis.getAnalysisTile(row,col);
    double[][] statistics=AnalysisUtil.calculateImagemapStatistics(cornerx,cornery,tilesize,tilesize,row,col,bands,data,kdist,ta);
    double[][] thresholdvalues=new double[numberbands][2];
    boolean pixelabove=false;
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      double mean=(statistics[bandcounter][1] + statistics[bandcounter][2] + statistics[bandcounter][3]+ statistics[bandcounter][4]) / 4;
      thresholdvalues[bandcounter][0]=mean + 3 * mean * statistics[bandcounter][0];
      thresholdvalues[bandcounter][1]=mean + 5 * mean * statistics[bandcounter][0];
      int value=data[bandcounter][boatx + boaty * tilesize];
      if (value > thresholdvalues[bandcounter][1]) {
        pixelabove=true;
      }
 else {
      }
    }
    if (pixelabove) {
      int[] dataMask=createDataMask(cornerx,cornery,tilesize,tilesize,0,0);
      BoatConnectedPixelMap boatpixel=null;
      try {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][boatx + boaty * tilesize]);
      }
 catch (      Exception e) {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][(boatx + boaty * tilesize) - 1]);
      }
      for (int iBand=0; iBand < numberbands; iBand++) {
        String bb=gir.getBandName(bands[iBand]);
        float thresholdBand=this.thresholdsBandParams.get(bb);
        TileAnalysis bbAnalysis=null;
        if (blackBorderAnalysis != null)         bbAnalysis=blackBorderAnalysis.getAnalysisTile(row,col);
        kdist.setImageData(cornerx,cornery,tilesize,tilesize,iBand,bbAnalysis);
        int[] newdata=gir.read(cornerx,cornery,tilesize,tilesize,bands[iBand]);
        kdist.estimate(newdata,newdata);
        double[] treshTile=kdist.getDetectThresh();
        double threshTotal=treshTile[0] + treshTile[1] + treshTile[2]+ treshTile[3];
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,treshTile);
        double tileAvg=0;
        int i=0;
        int y=-1;
        for (; i < data[iBand].length; i++) {
          int x=i % tilesize;
          if (x == 0)           y++;
          try {
            if (dataMask == null || dataMask[x + (y * tilesize)] == 0) {
              tileAvg=tileAvg + data[iBand][i];
            }
          }
 catch (          Exception e) {
            logger.warn(new StringBuilder(e.getMessage()).append(""String_Node_Str"").append(x).append(""String_Node_Str"").append(y).append(""String_Node_Str"").toString());
          }
        }
        tileAvg=tileAvg / i;
        double tileStdDev=treshTile[0] * threshTotal / treshTile[5];
        boatpixel.getStatMap().setTreshold(Precision.round((threshWindowsVals[0] + threshWindowsVals[1] + threshWindowsVals[2]+ threshWindowsVals[3]) / 4,3),bb);
        boatpixel.getStatMap().setTileStd(Precision.round(tileStdDev,3),bb);
        boatpixel.getStatMap().setTileAvg(Precision.round(tileAvg,3),bb);
      }
      detPixels.listboatneighbours.add(boatpixel);
      List<int[]> boataggregatedpixels=new ArrayList<int[]>();
      boolean result=detPixels.checkNeighbours(boataggregatedpixels,data,thresholdvalues,new int[]{boatx,boaty},neighboursdistance,tilesize,dataMask);
      boatpixel.setTouchesLandMask(result);
      for (      int[] pixel : boataggregatedpixels) {
        boatpixel.addConnectedPixel(pixel[0] + cornerx,pixel[1] + cornery,pixel[2],pixel[3] == 1 ? true : false);
      }
    }
  }
  if (removelandconnectedpixels) {
    List<BoatConnectedPixelMap> toRemove=new ArrayList<BoatConnectedPixelMap>();
    for (int i=0; i < detPixels.listboatneighbours.size(); i++) {
      BoatConnectedPixelMap boat=detPixels.listboatneighbours.get(i);
      if (boat.touchesLand()) {
        toRemove.add(boat);
      }
    }
    detPixels.listboatneighbours.removeAll(toRemove);
  }
}",0.9976006398293789
175046,"@Override public boolean executeFromConsole(){
  try {
    SarImageReader sar=(SarImageReader)SumoPlatform.getApplication().getCurrentImageReader();
    ImageLayer layer=LayerManager.getIstanceManager().getCurrentImageLayer();
    if (layer != null && commandLine.length >= 3) {
      String arg0=commandLine[1];
      String arg1=commandLine[2];
      String arg2=commandLine[3];
      if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        if (commandLine.length == 2 && arg1.equalsIgnoreCase(""String_Node_Str"")) {
          runBBAnalysis();
        }
 else {
          int row=Integer.parseInt(arg1);
          int col=Integer.parseInt(arg2);
          yy=layer.getRealTileSizeY() * row;
          xx=layer.getRealTileSizeX() * col;
          tileSizeY=layer.getRealTileSizeY();
          tileSizeX=layer.getRealTileSizeY();
          String direction=""String_Node_Str"";
          if (commandLine.length == 5)           direction=commandLine[4];
          BlackBorderAnalysis borderAn=new BlackBorderAnalysis(sar,layer.getRealTileSizeX(),layer.getRealTileSizeY(),null);
          int[] threshs=borderAn.analyse(row,col,direction.equalsIgnoreCase(""String_Node_Str""));
          List<Geometry> points=new ArrayList<>();
          GeometryFactory gf=new GeometryFactory();
          for (int i=0; i < threshs.length; i++) {
            int offset=threshs[i];
            if (direction.equalsIgnoreCase(""String_Node_Str"")) {
              if (xx < (sar.getWidth() / 2)) {
                Point p=gf.createPoint(new Coordinate(xx + offset,yy + i));
                points.add(p);
              }
            }
 else {
            }
          }
          GeometryImage giPoint=new GeometryImage(arg2,points);
          SimpleGeometryLayer offset=new SimpleGeometryLayer(layer,""String_Node_Str"" + row + ""String_Node_Str""+ col,giPoint);
          offset.setColor(Color.ORANGE);
          offset.setWidth(2.0f);
          LayerManager.addLayerInThread(offset);
          com.vividsolutions.jts.geom.Polygon box=JTSUtil.createPolygon(xx,yy,layer.getRealTileSizeX(),layer.getRealTileSizeY());
          List<Geometry> geoms=new ArrayList<>();
          geoms.add(box);
          GeometryImage gi=new GeometryImage(arg2,geoms);
          SimpleGeometryLayer sgl=new SimpleGeometryLayer(layer,""String_Node_Str"" + row + ""String_Node_Str""+ col,gi);
          sgl.setColor(Color.ORANGE);
          sgl.setWidth(2.0f);
          LayerManager.addLayerInThread(sgl);
        }
      }
 else       if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        int row=Integer.parseInt(arg1);
        int col=Integer.parseInt(arg2);
        Float hh=1.5f;
        Float hv=1.5f;
        Float vh=1.5f;
        Float vv=1.5f;
        Float buffer=0.0f;
        if (commandLine.length >= 5) {
          buffer=Float.parseFloat(commandLine[4]);
          if (commandLine.length > 5) {
            hh=Float.parseFloat(commandLine[5]);
            hv=Float.parseFloat(commandLine[6]);
            vh=Float.parseFloat(commandLine[7]);
            vv=Float.parseFloat(commandLine[8]);
          }
        }
        MaskVectorLayer coastlineMask=null;
        MaskVectorLayer iceMasks=null;
        for (        ILayer l : LayerManager.getIstanceManager().getChilds(layer)) {
          if (l instanceof IMask) {
            if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.COASTLINE_MASK) {
              coastlineMask=(MaskVectorLayer)l;
            }
 else             if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.ICE_MASK) {
              iceMasks=(MaskVectorLayer)l;
            }
          }
        }
        MaskGeometries mg=null;
        IMask bufferedMask=null;
        if (coastlineMask != null) {
          bufferedMask=FactoryLayer.createMaskLayer(coastlineMask.getName(),coastlineMask.getType(),0,((MaskVectorLayer)coastlineMask).getGeometriclayer(),coastlineMask.getMaskType());
          mg=new MaskGeometries(""String_Node_Str"",bufferedMask.getGeometries(),bufferedMask.getName());
        }
        MaskGeometries ice=null;
        IMask iceMask=null;
        if (iceMasks != null) {
          iceMask=FactoryLayer.createMaskLayer(iceMasks.getName(),iceMasks.getType(),0,((MaskVectorLayer)iceMasks).getGeometriclayer(),iceMasks.getMaskType());
          ice=new MaskGeometries(""String_Node_Str"",iceMask.getGeometries(),bufferedMask.getName());
        }
        VDSAnalysis analysis=new VDSAnalysis(sar,mg,ice,Float.parseFloat(sar.getENL()),new Float[]{hh,hv,vh,vv},layer.getRealTileSizeX(),layer.getRealTileSizeY(),layer.getHorizontalTilesImage(),layer.getVerticalTilesImage());
        analysis.setAnalyseSingleTile(true);
        analysis.setxTileToAnalyze(col);
        analysis.setyTileToAnalyze(row);
        proc=new AnalysisProcess(sar,Float.parseFloat(sar.getENL()),analysis,0,0,null);
        proc.addProcessListener(this);
        proc.call();
        yy=layer.getRealTileSizeY() * row;
        xx=layer.getRealTileSizeX() * col;
        tileSizeY=layer.getRealTileSizeY();
        tileSizeX=layer.getRealTileSizeX();
      }
    }
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
    return false;
  }
 finally {
  }
  return true;
}","@Override public boolean executeFromConsole(){
  try {
    SarImageReader sar=(SarImageReader)SumoPlatform.getApplication().getCurrentImageReader();
    ImageLayer layer=LayerManager.getIstanceManager().getCurrentImageLayer();
    if (layer != null && commandLine.length >= 3) {
      String arg0=commandLine[1];
      String arg1=commandLine[2];
      String arg2=commandLine[3];
      if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        if (commandLine.length == 2 && arg1.equalsIgnoreCase(""String_Node_Str"")) {
          runBBAnalysis();
        }
 else {
          int row=Integer.parseInt(arg1);
          int col=Integer.parseInt(arg2);
          yy=layer.getRealTileSizeY() * row;
          xx=layer.getRealTileSizeX() * col;
          tileSizeY=layer.getRealTileSizeY();
          tileSizeX=layer.getRealTileSizeY();
          String direction=""String_Node_Str"";
          if (commandLine.length == 5)           direction=commandLine[4];
          BlackBorderAnalysis borderAn=new BlackBorderAnalysis(sar,layer.getRealTileSizeX(),layer.getRealTileSizeY(),null);
          int[] threshs=borderAn.analyse(row,col,direction.equalsIgnoreCase(""String_Node_Str""));
          List<Geometry> points=new ArrayList<>();
          GeometryFactory gf=new GeometryFactory();
          for (int i=0; i < threshs.length; i++) {
            int offset=threshs[i];
            if (direction.equalsIgnoreCase(""String_Node_Str"")) {
              if (xx < (sar.getWidth() / 2)) {
                Point p=gf.createPoint(new Coordinate(xx + offset,yy + i));
                points.add(p);
              }
            }
 else {
            }
          }
          GeometryImage giPoint=new GeometryImage(arg2,points);
          SimpleGeometryLayer offset=new SimpleGeometryLayer(layer,""String_Node_Str"" + row + ""String_Node_Str""+ col,giPoint);
          offset.setColor(Color.ORANGE);
          offset.setWidth(2.0f);
          LayerManager.addLayerInThread(offset);
          com.vividsolutions.jts.geom.Polygon box=JTSUtil.createPolygon(xx,yy,layer.getRealTileSizeX(),layer.getRealTileSizeY());
          List<Geometry> geoms=new ArrayList<>();
          geoms.add(box);
          GeometryImage gi=new GeometryImage(arg2,geoms);
          SimpleGeometryLayer sgl=new SimpleGeometryLayer(layer,""String_Node_Str"" + row + ""String_Node_Str""+ col,gi);
          sgl.setColor(Color.ORANGE);
          sgl.setWidth(2.0f);
          LayerManager.addLayerInThread(sgl);
        }
      }
 else       if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        int row=Integer.parseInt(arg1);
        int col=Integer.parseInt(arg2);
        Float hh=1.5f;
        Float hv=1.5f;
        Float vh=1.5f;
        Float vv=1.5f;
        Float buffer=0.0f;
        if (commandLine.length >= 5) {
          buffer=Float.parseFloat(commandLine[4]);
          if (commandLine.length > 5) {
            hh=Float.parseFloat(commandLine[5]);
            hv=Float.parseFloat(commandLine[6]);
            vh=Float.parseFloat(commandLine[7]);
            vv=Float.parseFloat(commandLine[8]);
          }
        }
        MaskVectorLayer coastlineMask=null;
        MaskVectorLayer iceMasks=null;
        for (        ILayer l : LayerManager.getIstanceManager().getChilds(layer)) {
          if (l instanceof IMask) {
            if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.COASTLINE_MASK) {
              coastlineMask=(MaskVectorLayer)l;
            }
 else             if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.ICE_MASK) {
              iceMasks=(MaskVectorLayer)l;
            }
          }
        }
        MaskGeometries mg=null;
        IMask bufferedMask=null;
        if (coastlineMask != null) {
          bufferedMask=FactoryLayer.createMaskLayer(coastlineMask.getName(),coastlineMask.getType(),0,((MaskVectorLayer)coastlineMask).getGeometriclayer(),coastlineMask.getMaskType());
          mg=new MaskGeometries(""String_Node_Str"",bufferedMask.getGeometries(),bufferedMask.getName());
        }
        MaskGeometries ice=null;
        IMask iceMask=null;
        if (iceMasks != null) {
          iceMask=FactoryLayer.createMaskLayer(iceMasks.getName(),iceMasks.getType(),0,((MaskVectorLayer)iceMasks).getGeometriclayer(),iceMasks.getMaskType());
          ice=new MaskGeometries(""String_Node_Str"",iceMask.getGeometries(),bufferedMask.getName());
        }
        yy=layer.getRealTileSizeY() * row;
        xx=layer.getRealTileSizeX() * col;
        tileSizeY=layer.getRealTileSizeY();
        tileSizeX=layer.getRealTileSizeX();
        VDSAnalysis analysis=new VDSAnalysis(sar,mg,ice,Float.parseFloat(sar.getENL()),new Float[]{hh,hv,vh,vv},layer.getRealTileSizeX(),layer.getRealTileSizeY(),layer.getHorizontalTilesImage(),layer.getVerticalTilesImage());
        analysis.setAnalyseSingleTile(true);
        analysis.setxTileToAnalyze(col);
        analysis.setyTileToAnalyze(row);
        proc=new AnalysisProcess(sar,Float.parseFloat(sar.getENL()),analysis,0,0,null);
        proc.addProcessListener(this);
        proc.call();
      }
    }
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
    return false;
  }
 finally {
  }
  return true;
}",0.9663247532417264
175047,"/** 
 * Exec the analysis process
 */
public Results call(){
  final Thread currentThread=Thread.currentThread();
  final String oldName=currentThread.getName();
  currentThread.setName(""String_Node_Str"" + gir.getImId());
  try {
    List<ComplexEditVDSVectorLayer> resultLayers=new ArrayList<>();
    String coastMaskName=analysis.getCoastMask() != null ? analysis.getCoastMask().getFileName() : ""String_Node_Str"";
    String iceMaskName=analysis.getIceMask() != null ? analysis.getIceMask().getFileName() : ""String_Node_Str"";
    notifyStartProcessListener(""String_Node_Str"" + coastMaskName + ""String_Node_Str""+ iceMaskName);
    SarImageReader reader=((SarImageReader)gir);
    String[] thresholdsString=StringUtils.join(analysis.getThresholdsParams(),""String_Node_Str"").split(""String_Node_Str"");
    BlackBorderAnalysis blackBorderAnalysis=runBBAnalysis();
    analysis.setBlackBorderAnalysis(blackBorderAnalysis);
    int numberofbands=gir.getNBand();
    int[] bands=new int[numberofbands];
    int noiseFloor=SumoPlatform.getApplication().getConfiguration().getNoiseFloor(0);
    int thresPixelMin=SumoPlatform.getApplication().getConfiguration().getThreshMinPixelValue(500);
    final KDistributionEstimation kdist=new KDistributionEstimation(ENL,noiseFloor,thresPixelMin);
    DetectedPixels mergePixels=new DetectedPixels(reader.getRangeSpacing(),reader.getAzimuthSpacing());
    DetectedPixels banddetectedpixels[]=new DetectedPixels[numberofbands];
    String timeStampStart=reader.getTimeStampStart();
    double azimuth=reader.getAzimuthSpacing();
    int xtileSize=analysis.getRealSizeX();
    int ytileSize=analysis.getRealSizeY();
    try {
      for (int band=0; band < numberofbands && !stop; band++) {
        notifyAnalysisBand(new StringBuilder().append(""String_Node_Str"").append(gir.getBandName(band)).toString());
        int vTiles=analysis.getVerTiles();
        notifyVDSAnalysis(""String_Node_Str"",vTiles);
        analysis.addProgressListener(this);
        banddetectedpixels[band]=analysis.analyse(kdist,band);
        if (numPointLimit != 0 && banddetectedpixels[band].getAllDetectedPixels().size() > numPointLimit) {
          logger.warn(""String_Node_Str"");
          return null;
        }
        if (mergePixels == null) {
          mergePixels=banddetectedpixels[band];
        }
 else {
          mergePixels.merge(banddetectedpixels[band]);
        }
        bands[band]=band;
        String polarization=reader.getBands()[band];
        if (numberofbands < 1 || displaybandanalysis) {
          notifyAgglomerating(new StringBuilder().append(""String_Node_Str"").append(polarization).toString());
          Boat[] boats=null;
          if (agglomerationMethodology.startsWith(""String_Node_Str"")) {
            banddetectedpixels[band].agglomerate();
            banddetectedpixels[band].computeBoatsAttributes(polarization);
          }
 else {
            if (stop)             break;
            boats=analysis.agglomerateNeighbours(banddetectedpixels[band],neighbouringDistance,neighbourTilesize,removelandconnectedpixels,(analysis.getCoastMask() != null) ? analysis.getCoastMask() : null,kdist,polarization,band);
          }
          String layerName=new StringBuilder(""String_Node_Str"").append(polarization).append(""String_Node_Str"").append(analysis.getThresholdParam(polarization)).toString();
          ComplexEditVDSVectorLayer vdsanalysisLayer=new ComplexEditVDSVectorLayer(LayerManager.getIstanceManager().getCurrentImageLayer(),layerName,""String_Node_Str"",new GeometryImage(""String_Node_Str"",""String_Node_Str"",timeStampStart,azimuth,boats),thresholdsString,ENL,buffer,bufferedMaskName,""String_Node_Str"" + band);
          vdsanalysisLayer.addDetectedPixels(banddetectedpixels[band].getAllDetectedPixels(),display);
          if (!agglomerationMethodology.startsWith(""String_Node_Str"")) {
            vdsanalysisLayer.addThreshAggPixels(banddetectedpixels[band].getThresholdaggregatePixels(),display);
            vdsanalysisLayer.addThresholdPixels(banddetectedpixels[band].getThresholdclipPixels(),display);
          }
          notifyCalcAzimuth(""String_Node_Str"");
          AzimuthAmbiguity azimuthAmbiguity=new AzimuthAmbiguity(boats,(SarImageReader)gir,band);
          azimuthAmbiguity.process();
          List<Geometry> az=azimuthAmbiguity.getAmbiguityboatgeometry();
          vdsanalysisLayer.addAzimuthAmbiguities(az,display);
          if (gir instanceof Sentinel1) {
            if (((Sentinel1)gir).getInstumentationMode().equalsIgnoreCase(""String_Node_Str"") || ((Sentinel1)gir).getInstumentationMode().equalsIgnoreCase(""String_Node_Str"")) {
              notifyCalcAzimuth(""String_Node_Str"");
              S1ArtefactsAmbiguity arAmbiguity=new S1ArtefactsAmbiguity(boats,(SarImageReader)gir,band);
              arAmbiguity.process();
              List<Geometry> artefactsA=arAmbiguity.getAmbiguityboatgeometry();
              vdsanalysisLayer.addArtefactsAmbiguities(artefactsA,display);
            }
          }
          if ((analysis.getCoastMask() != null)) {
            vdsanalysisLayer.addGeometries(""String_Node_Str"",Color.BLUE,1,GeometryImage.POLYGON,analysis.getCoastMask().getMaskGeometries(),true);
          }
          vdsanalysisLayer.addGeometries(""String_Node_Str"",new Color(0xFF00FF),1,GeometryImage.LINESTRING,GeometryExtractor.getTiles(gir.getWidth(),gir.getHeight(),xtileSize,ytileSize),false);
          notifyLayerReady(vdsanalysisLayer);
          resultLayers.add(vdsanalysisLayer);
        }
      }
      if (stop) {
        return null;
      }
      if (bands.length > 1) {
        notifyAgglomerating(""String_Node_Str"");
        Boat[] boats=null;
        if (agglomerationMethodology.startsWith(""String_Node_Str"")) {
          mergePixels.agglomerate();
          mergePixels.computeBoatsAttributes(""String_Node_Str"");
        }
 else {
          boats=analysis.agglomerateNeighbours(mergePixels,neighbouringDistance,neighbourTilesize,removelandconnectedpixels,(analysis.getCoastMask() != null) ? analysis.getCoastMask() : null,kdist,""String_Node_Str"",bands);
        }
        if (stop) {
          return null;
        }
        ComplexEditVDSVectorLayer vdsanalysisLayer=new ComplexEditVDSVectorLayer(LayerManager.getIstanceManager().getCurrentImageLayer(),""String_Node_Str"",""String_Node_Str"",new GeometryImage(""String_Node_Str"",""String_Node_Str"",timeStampStart,azimuth,boats),thresholdsString,ENL,buffer,bufferedMaskName,""String_Node_Str"");
        boolean display=SumoPlatform.getApplication().getConfiguration().getDisplayPixel();
        if (!agglomerationMethodology.startsWith(""String_Node_Str"")) {
          vdsanalysisLayer.addThreshAggPixels(mergePixels.getThresholdaggregatePixels(),display);
          vdsanalysisLayer.addThresholdPixels(mergePixels.getThresholdclipPixels(),display);
        }
        vdsanalysisLayer.addDetectedPixels(mergePixels.getAllDetectedPixels(),display);
        if ((analysis.getCoastMask() != null)) {
          vdsanalysisLayer.addGeometries(""String_Node_Str"",new Color(0x0000FF),1,GeometryImage.POLYGON,analysis.getCoastMask().getMaskGeometries(),true);
        }
        vdsanalysisLayer.addGeometries(""String_Node_Str"",new Color(0xFF00FF),1,GeometryImage.LINESTRING,GeometryExtractor.getTiles(gir.getWidth(),gir.getHeight(),xtileSize,ytileSize),false);
        notifyCalcAzimuth(""String_Node_Str"");
        AzimuthAmbiguity azimuthAmbiguity=new AzimuthAmbiguity(boats,(SarImageReader)gir,bands);
        azimuthAmbiguity.process();
        List<Geometry> az=azimuthAmbiguity.getAmbiguityboatgeometry();
        vdsanalysisLayer.addAzimuthAmbiguities(az,display);
        if (gir instanceof Sentinel1) {
          if (((Sentinel1)gir).getInstumentationMode().equalsIgnoreCase(""String_Node_Str"") || ((Sentinel1)gir).getInstumentationMode().equalsIgnoreCase(""String_Node_Str"")) {
            notifyCalcAzimuth(""String_Node_Str"");
            S1ArtefactsAmbiguity arAmbiguity=new S1ArtefactsAmbiguity(boats,(SarImageReader)gir,bands);
            arAmbiguity.process();
            List<Geometry> artefactsA=arAmbiguity.getAmbiguityboatgeometry();
            vdsanalysisLayer.addArtefactsAmbiguities(artefactsA,display);
          }
        }
        notifyLayerReady(vdsanalysisLayer);
        resultLayers.add(vdsanalysisLayer);
      }
      notifyEndProcessListener();
    }
 catch (    Exception ee) {
      ee.printStackTrace();
    }
 finally {
      if (this.listeners != null)       removeAllProcessListener();
    }
    return new Results(reader,resultLayers);
  }
  finally {
    currentThread.setName(oldName);
  }
}","/** 
 * Exec the analysis process
 */
public Results call(){
  final Thread currentThread=Thread.currentThread();
  final String oldName=currentThread.getName();
  currentThread.setName(""String_Node_Str"" + gir.getImId());
  try {
    List<ComplexEditVDSVectorLayer> resultLayers=new ArrayList<>();
    String coastMaskName=analysis.getCoastMask() != null ? analysis.getCoastMask().getFileName() : ""String_Node_Str"";
    String iceMaskName=analysis.getIceMask() != null ? analysis.getIceMask().getFileName() : ""String_Node_Str"";
    notifyStartProcessListener(""String_Node_Str"" + coastMaskName + ""String_Node_Str""+ iceMaskName);
    SarImageReader reader=((SarImageReader)gir);
    String[] thresholdsString=StringUtils.join(analysis.getThresholdsParams(),""String_Node_Str"").split(""String_Node_Str"");
    BlackBorderAnalysis blackBorderAnalysis=runBBAnalysis();
    analysis.setBlackBorderAnalysis(blackBorderAnalysis);
    int numberofbands=gir.getNBand();
    int[] bands=new int[numberofbands];
    int noiseFloor=SumoPlatform.getApplication().getConfiguration().getNoiseFloor(0);
    int thresPixelMin=SumoPlatform.getApplication().getConfiguration().getThreshMinPixelValue(500);
    final KDistributionEstimation kdist=new KDistributionEstimation(ENL,noiseFloor,thresPixelMin);
    DetectedPixels mergePixels=new DetectedPixels(reader.getRangeSpacing(),reader.getAzimuthSpacing());
    DetectedPixels banddetectedpixels[]=new DetectedPixels[numberofbands];
    String timeStampStart=reader.getTimeStampStart();
    double azimuth=reader.getAzimuthSpacing();
    int xtileSize=analysis.getRealSizeX();
    int ytileSize=analysis.getRealSizeY();
    try {
      for (int band=0; band < numberofbands && !stop; band++) {
        notifyAnalysisBand(new StringBuilder().append(""String_Node_Str"").append(gir.getBandName(band)).toString());
        int vTiles=analysis.getVerTiles();
        notifyVDSAnalysis(""String_Node_Str"",vTiles);
        analysis.addProgressListener(this);
        banddetectedpixels[band]=analysis.analyse(kdist,band);
        if (numPointLimit != 0 && banddetectedpixels[band].getAllDetectedPixels().size() > numPointLimit) {
          logger.warn(""String_Node_Str"");
          return null;
        }
        if (mergePixels == null) {
          mergePixels=banddetectedpixels[band];
        }
 else {
          mergePixels.merge(banddetectedpixels[band]);
        }
        bands[band]=band;
        String polarization=reader.getBands()[band];
        if (numberofbands < 1 || displaybandanalysis) {
          notifyAgglomerating(new StringBuilder().append(""String_Node_Str"").append(polarization).toString());
          Boat[] boats=null;
          if (agglomerationMethodology.startsWith(""String_Node_Str"")) {
            banddetectedpixels[band].agglomerate();
            banddetectedpixels[band].computeBoatsAttributes(polarization);
          }
 else {
            if (stop)             break;
            boats=analysis.agglomerateNeighbours(banddetectedpixels[band],neighbouringDistance,neighbourTilesize,removelandconnectedpixels,(analysis.getCoastMask() != null) ? analysis.getCoastMask() : null,kdist,polarization,band);
          }
          String layerName=new StringBuilder(""String_Node_Str"").append(polarization).append(""String_Node_Str"").append(analysis.getThresholdParam(polarization)).toString();
          ComplexEditVDSVectorLayer vdsanalysisLayer=new ComplexEditVDSVectorLayer(LayerManager.getIstanceManager().getCurrentImageLayer(),layerName,""String_Node_Str"",new GeometryImage(""String_Node_Str"",""String_Node_Str"",timeStampStart,azimuth,boats),thresholdsString,ENL,buffer,bufferedMaskName,""String_Node_Str"" + band);
          vdsanalysisLayer.addDetectedPixels(banddetectedpixels[band].getAllDetectedPixels(),display);
          if (!agglomerationMethodology.startsWith(""String_Node_Str"")) {
            vdsanalysisLayer.addThreshAggPixels(banddetectedpixels[band].getThresholdaggregatePixels(),display);
            vdsanalysisLayer.addThresholdPixels(banddetectedpixels[band].getThresholdclipPixels(),display);
          }
          notifyCalcAzimuth(""String_Node_Str"");
          AzimuthAmbiguity azimuthAmbiguity=new AzimuthAmbiguity(boats,(SarImageReader)gir,band);
          azimuthAmbiguity.process();
          List<Geometry> az=azimuthAmbiguity.getAmbiguityboatgeometry();
          vdsanalysisLayer.addAzimuthAmbiguities(az,display);
          if (gir instanceof Sentinel1) {
            if (((Sentinel1)gir).getInstumentationMode().equalsIgnoreCase(""String_Node_Str"") || ((Sentinel1)gir).getInstumentationMode().equalsIgnoreCase(""String_Node_Str"")) {
              notifyCalcAzimuth(""String_Node_Str"");
              S1ArtefactsAmbiguity arAmbiguity=new S1ArtefactsAmbiguity(boats,(SarImageReader)gir,band);
              arAmbiguity.process();
              List<Geometry> artefactsA=arAmbiguity.getAmbiguityboatgeometry();
              vdsanalysisLayer.addArtefactsAmbiguities(artefactsA,display);
            }
          }
          if ((analysis.getCoastMask() != null)) {
            vdsanalysisLayer.addGeometries(""String_Node_Str"",Color.BLUE,1,GeometryImage.POLYGON,analysis.getCoastMask().getMaskGeometries(),true);
          }
          vdsanalysisLayer.addGeometries(""String_Node_Str"",new Color(0xFF00FF),1,GeometryImage.LINESTRING,GeometryExtractor.getTiles(gir.getWidth(),gir.getHeight(),xtileSize,ytileSize),false);
          notifyLayerReady(vdsanalysisLayer);
          resultLayers.add(vdsanalysisLayer);
        }
      }
      if (stop) {
        return null;
      }
      if (bands.length > 1) {
        notifyAgglomerating(""String_Node_Str"");
        Boat[] boats=null;
        if (agglomerationMethodology.startsWith(""String_Node_Str"")) {
          mergePixels.agglomerate();
          mergePixels.computeBoatsAttributes(""String_Node_Str"");
        }
 else {
          boats=analysis.agglomerateNeighbours(mergePixels,neighbouringDistance,neighbourTilesize,removelandconnectedpixels,(analysis.getCoastMask() != null) ? analysis.getCoastMask() : null,kdist,""String_Node_Str"",bands);
        }
        if (stop) {
          return null;
        }
        ComplexEditVDSVectorLayer vdsanalysisLayer=new ComplexEditVDSVectorLayer(LayerManager.getIstanceManager().getCurrentImageLayer(),""String_Node_Str"",""String_Node_Str"",new GeometryImage(""String_Node_Str"",""String_Node_Str"",timeStampStart,azimuth,boats),thresholdsString,ENL,buffer,bufferedMaskName,""String_Node_Str"");
        boolean display=SumoPlatform.getApplication().getConfiguration().getDisplayPixel();
        if (!agglomerationMethodology.startsWith(""String_Node_Str"")) {
          vdsanalysisLayer.addThreshAggPixels(mergePixels.getThresholdaggregatePixels(),display);
          vdsanalysisLayer.addThresholdPixels(mergePixels.getThresholdclipPixels(),display);
        }
        vdsanalysisLayer.addDetectedPixels(mergePixels.getAllDetectedPixels(),display);
        if ((analysis.getCoastMask() != null)) {
          vdsanalysisLayer.addGeometries(""String_Node_Str"",new Color(0x0000FF),1,GeometryImage.POLYGON,analysis.getCoastMask().getMaskGeometries(),true);
        }
        vdsanalysisLayer.addGeometries(""String_Node_Str"",new Color(0xFF00FF),1,GeometryImage.LINESTRING,GeometryExtractor.getTiles(gir.getWidth(),gir.getHeight(),xtileSize,ytileSize),false);
        notifyCalcAzimuth(""String_Node_Str"");
        AzimuthAmbiguity azimuthAmbiguity=new AzimuthAmbiguity(boats,(SarImageReader)gir,bands);
        azimuthAmbiguity.process();
        List<Geometry> az=azimuthAmbiguity.getAmbiguityboatgeometry();
        vdsanalysisLayer.addAzimuthAmbiguities(az,display);
        if (gir instanceof Sentinel1) {
          if (((Sentinel1)gir).getInstumentationMode().equalsIgnoreCase(""String_Node_Str"")) {
            notifyCalcAzimuth(""String_Node_Str"");
            S1ArtefactsAmbiguity arAmbiguity=new S1ArtefactsAmbiguity(boats,(SarImageReader)gir,bands);
            arAmbiguity.process();
            List<Geometry> artefactsA=arAmbiguity.getAmbiguityboatgeometry();
            vdsanalysisLayer.addArtefactsAmbiguities(artefactsA,display);
          }
        }
        notifyLayerReady(vdsanalysisLayer);
        resultLayers.add(vdsanalysisLayer);
      }
      notifyEndProcessListener();
    }
 catch (    Exception ee) {
      ee.printStackTrace();
    }
 finally {
      if (this.listeners != null)       removeAllProcessListener();
    }
    return new Results(reader,resultLayers);
  }
  finally {
    currentThread.setName(oldName);
  }
}",0.9916822867853796
175048,"/** 
 * @param shpInput
 * @param bbox
 * @param transform
 * @return
 */
public static GeometryImage createIntersectedLayer(File shpInput,Polygon bbox,GeoTransform transform){
  GeometryImage glout=null;
  DataStore dataStore=null;
  try {
    if (shpInput != null) {
      Map<String,Serializable> params=new HashMap<String,Serializable>();
      params.put(""String_Node_Str"",shpInput.toURI().toURL());
      dataStore=DataStoreFinder.getDataStore(params);
      SimpleFeatureSource featureSource=(SimpleFeatureSource)dataStore.getFeatureSource(dataStore.getTypeNames()[0]);
      Polygon imageP=bbox;
      ClipProcess clip=new ClipProcess();
      SimpleFeatureCollection fc=clip.execute(featureSource.getFeatures(),imageP,true);
      if (fc.isEmpty()) {
        return null;
      }
      String[] schemaStr=createSchema(fc.getSchema().getDescriptors());
      String[] types=createTypes(fc.getSchema().getDescriptors());
      String geoName=fc.getSchema().getGeometryDescriptor().getType().getName().toString();
      boolean applayT=false;
      if (transform != null)       applayT=true;
      glout=GeometryImage.createFromSimpleGeometry(imageP,geoName,fc,schemaStr,types,applayT,transform);
      glout.setName(shpInput.getName());
    }
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
    if (dataStore != null)     dataStore.dispose();
  }
  return glout;
}","/** 
 * @param shpInput
 * @param bbox
 * @param transform
 * @return
 */
public static GeometryImage createIntersectedLayer(File shpInput,Polygon bbox,GeoTransform transform){
  GeometryImage glout=null;
  DataStore dataStore=null;
  try {
    if (shpInput != null) {
      Map<String,Serializable> params=new HashMap<String,Serializable>();
      params.put(""String_Node_Str"",shpInput.toURI().toURL());
      dataStore=DataStoreFinder.getDataStore(params);
      SimpleFeatureSource featureSource=(SimpleFeatureSource)dataStore.getFeatureSource(dataStore.getTypeNames()[0]);
      Polygon imageP=bbox;
      ClipProcess clip=new ClipProcess();
      SimpleFeatureCollection fc=clip.execute(featureSource.getFeatures(),imageP,true);
      if (fc.isEmpty()) {
        return null;
      }
      String[] schemaStr=createSchema(fc.getSchema().getDescriptors());
      String[] types=createTypes(fc.getSchema().getDescriptors());
      String geoName=fc.getSchema().getGeometryDescriptor().getType().getName().toString();
      boolean applayT=false;
      if (transform != null)       applayT=true;
      glout=GeometryImage.createFromSimpleGeometry(imageP,geoName,fc,schemaStr,types,applayT,transform);
      glout.setName(shpInput.getName());
      glout.splitMultiPolygons();
    }
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
    if (dataStore != null)     dataStore.dispose();
  }
  return glout;
}",0.98805340829234
175049,"@Override public void render(Object gcC){
  OpenGLContext context=(OpenGLContext)gcC;
  if (!context.isDirty() || SumoPlatform.isBatchMode()) {
    return;
  }
  int x=context.getX();
  int y=context.getY();
  float zoom=context.getZoom();
  float width=context.getWidth() * zoom;
  float height=context.getHeight() * zoom;
  if (glayer != null) {
    List<Geometry> geomList=glayer.getGeometries();
    if (!threshable && geomList != null) {
      if (getType().equalsIgnoreCase(GeometryImage.POINT)) {
switch (this.displaysymbol) {
case point:
{
            GL2ShapesRender.renderPolygons(context,width,height,geomList,this.renderWidth,color);
            if (selectedGeometry != null) {
              GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth,color);
            }
          }
        break;
case circle:
{
        GL2ShapesRender.renderCircle(context,width,height,geomList,selectedGeometry,this.renderWidth,color);
      }
    break;
case square:
{
    GL2ShapesRender.renderSquare(context,width,height,geomList,selectedGeometry,renderWidth,color);
  }
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.POLYGON)) {
for (Geometry tmp : geomList) {
if (tmp instanceof Polygon) {
Polygon polygon=(Polygon)tmp;
if (polygon.getCoordinates().length < 1) {
continue;
}
float rWidth=polygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
int interior=polygon.getNumInteriorRing();
if (interior > 0) {
LineString line=polygon.getExteriorRing();
GL2ShapesRender.drawPoly(context,line.getCoordinates(),width,height,x,y,rWidth,color);
for (int i=0; i < interior; i++) {
LineString line2=polygon.getInteriorRingN(i);
GL2ShapesRender.drawPoly(context,line2.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else {
GL2ShapesRender.drawPoly(context,polygon.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else if (tmp instanceof MultiPolygon) {
MultiPolygon mpolygon=(MultiPolygon)tmp;
if (mpolygon.getCoordinates().length < 1) {
continue;
}
float rWidth=mpolygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
GL2ShapesRender.drawPoly(context,mpolygon.getCoordinates(),width,height,x,y,rWidth,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.LINESTRING)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.MIXED)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof LineString || temp instanceof Polygon) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
 else if (temp instanceof MultiPoint) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
}
 else {
if (getType().equalsIgnoreCase(GeometryImage.POINT) && geomList != null) {
List<Geometry> toVisualize=new ArrayList<>();
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
toVisualize.add(temp);
}
}
switch (this.displaysymbol) {
case point:
{
GL2ShapesRender.renderPolygons(context,width,height,toVisualize,this.renderWidth,color);
if (selectedGeometry != null) {
GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth * 2,color);
}
}
break;
case circle:
{
GL2ShapesRender.renderCircle(context,width,height,toVisualize,selectedGeometry,this.renderWidth,color);
}
break;
case square:
{
GL2ShapesRender.renderSquare(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.POLYGON) || getType().equalsIgnoreCase(GeometryImage.LINESTRING)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.MIXED)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof Polygon || temp instanceof LineString) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
}
}
}
}
}
}","@Override public void render(Object gcC){
  OpenGLContext context=(OpenGLContext)gcC;
  if (!context.isDirty() || SumoPlatform.isBatchMode()) {
    return;
  }
  int x=context.getX();
  int y=context.getY();
  float zoom=context.getZoom();
  float width=context.getWidth() * zoom;
  float height=context.getHeight() * zoom;
  if (glayer != null) {
    List<Geometry> geomList=glayer.getGeometries();
    if (!threshable && geomList != null) {
      if (getType().equalsIgnoreCase(GeometryImage.POINT)) {
switch (this.displaysymbol) {
case point:
{
            GL2ShapesRender.renderPolygons(context,width,height,geomList,this.renderWidth,color);
            if (selectedGeometry != null) {
              GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth,color);
            }
          }
        break;
case circle:
{
        GL2ShapesRender.renderCircle(context,width,height,geomList,selectedGeometry,this.renderWidth,color);
      }
    break;
case square:
{
    GL2ShapesRender.renderSquare(context,width,height,geomList,selectedGeometry,renderWidth,color);
  }
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.POLYGON)) {
for (Geometry tmp : geomList) {
if (tmp instanceof Polygon) {
Polygon polygon=(Polygon)tmp;
if (polygon.getCoordinates().length < 1) {
continue;
}
float rWidth=polygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
int interior=polygon.getNumInteriorRing();
if (interior > 0) {
LineString line=polygon.getExteriorRing();
GL2ShapesRender.drawPoly(context,line.getCoordinates(),width,height,x,y,rWidth,color);
for (int i=0; i < interior; i++) {
LineString line2=polygon.getInteriorRingN(i);
GL2ShapesRender.drawPoly(context,line2.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else {
GL2ShapesRender.drawPoly(context,polygon.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else if (tmp instanceof MultiPolygon) {
MultiPolygon mpolygon=(MultiPolygon)tmp;
if (mpolygon.getCoordinates().length < 1) {
continue;
}
float rWidth=mpolygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
GL2ShapesRender.drawMultiPoly(context,mpolygon,width,height,x,y,rWidth,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.LINESTRING)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.MIXED)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof LineString || temp instanceof Polygon) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
 else if (temp instanceof MultiPoint) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
}
 else {
if (getType().equalsIgnoreCase(GeometryImage.POINT) && geomList != null) {
List<Geometry> toVisualize=new ArrayList<>();
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
toVisualize.add(temp);
}
}
switch (this.displaysymbol) {
case point:
{
GL2ShapesRender.renderPolygons(context,width,height,toVisualize,this.renderWidth,color);
if (selectedGeometry != null) {
GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth * 2,color);
}
}
break;
case circle:
{
GL2ShapesRender.renderCircle(context,width,height,toVisualize,selectedGeometry,this.renderWidth,color);
}
break;
case square:
{
GL2ShapesRender.renderSquare(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.POLYGON) || getType().equalsIgnoreCase(GeometryImage.LINESTRING)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.MIXED)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof Polygon || temp instanceof LineString) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
}
}
}
}
}
}",0.9981161157732488
175050,"@Override public long readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int img=tiff.read(0,t).getRaster().getSample(0,0,1);
    int real=tiff.read(0,t).getRaster().getSample(0,0,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
    ex.printStackTrace();
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return -1;
}","@Override public long readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int img=tiff.read(0,t).getRaster().getSample(0,0,1);
    int real=tiff.read(0,t).getRaster().getSample(0,0,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(""String_Node_Str"" + ex.getMessage());
  }
catch (  IllegalArgumentException iae) {
    logger.warn(""String_Node_Str"" + iae.getMessage());
  }
 finally {
  }
  return -1;
}",0.8744710860366713
175051,"@Override public void render(Object glContext){
  OpenGLContext context=(OpenGLContext)glContext;
  if (activeGir != null) {
    if (torescale) {
      torescale=false;
      tcm.clear();
    }
    GL gl=context.getGL();
    updateFutures(gl);
    float zoom=context.getZoom();
    int width=context.getWidth();
    int height=context.getHeight();
    int x=context.getX();
    int y=context.getY();
    int xx=(int)(x + xpadding);
    int yy=(int)(y + ypadding);
    int max=maxnumberoftiles;
    Cache c=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
    gl.getGL2().glTexEnvi(GL2.GL_TEXTURE_ENV,GL2.GL_TEXTURE_ENV_MODE,GL2.GL_REPLACE);
    if (zoom >= 1) {
      curlevel=(int)Math.sqrt(zoom + 1);
      for (int lll=maxlevels; (lll > curlevel - 1); lll--) {
        if (lll > maxlevels) {
          break;
        }
        lll+=increaseLevel;
        if (lll < 0) {
          continue;
        }
        if (this.mylevel != curlevel) {
          this.mylevel=curlevel;
          poolExcutorService.shutdown();
          poolExcutorService=new ThreadPoolExecutor(1,poolSize,100,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
        }
        int w0=xx / ((1 << lll) << 8);
        int h0=yy / ((1 << lll) << 8);
        final String initfile=new StringBuffer(""String_Node_Str"").append((int)lll).append(""String_Node_Str"").append((activeGir instanceof TiledBufferedImage ? ((TiledBufferedImage)activeGir).getDescription() + ""String_Node_Str"" : ""String_Node_Str"")).toString();
        for (int k=0; k < max; k++) {
          for (int j=0; j < max; j++) {
            if (j + h0 < 0) {
              continue;
            }
            for (int i=0; i < max; i++) {
              if (i + w0 < 0) {
                continue;
              }
              if (arrayReadTilesOrder[i][j] == k) {
                float ymin=(float)(((j + h0) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - yy) / (height * zoom));
                float ymax=(float)(((j + h0 + 1) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - yy) / (height * zoom));
                float xmin=(float)(((i + w0) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - xx) / (1d * width * zoom));
                float xmax=(float)(((i + w0 + 1) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - xx) / (1d * width * zoom));
                if (ymin > 1 || ymax < 0) {
                  continue;
                }
                if (xmin > 1 || xmax < 0) {
                  continue;
                }
                String file=new StringBuffer(initfile).append(getBandFolder(activeBand)).append(""String_Node_Str"").append((i + w0)).append(""String_Node_Str"").append((j + h0)).append(""String_Node_Str"").toString();
                if (!tryMemoryCache(gl,file,xmin,xmax,ymin,ymax)) {
                  if (!tryFileCache(gl,file,lll,(i + w0),(j + h0),xmin,xmax,ymin,ymax)) {
                    if (curlevel == 0 && lll == 0) {
                      addTileToQueue(initfile,lll,(i + w0),(j + h0));
                    }
 else                     if (curlevel == lll) {
                      addTileToQueue(initfile,lll,(i + w0),(j + h0));
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
 else     if (zoom > 0) {
      curlevel=0;
      int w0=xx / Constant.TILE_SIZE_IMG_LAYER;
      int h0=yy / Constant.TILE_SIZE_IMG_LAYER;
      final String initfile=new StringBuilder(c.getPath().toString()).append(""String_Node_Str"").append((activeGir instanceof TiledBufferedImage ? ((TiledBufferedImage)activeGir).getDescription() + ""String_Node_Str"" : ""String_Node_Str"")).toString();
      for (int j=0; j < max; j++) {
        if (j + h0 < 0) {
          continue;
        }
        for (int i=0; i < max; i++) {
          if (i + w0 < 0) {
            continue;
          }
          float ymin=(float)(((j + h0) * Constant.OVERVIEW_SIZE_DOUBLE - yy) / (height * zoom));
          float ymax=(float)(((j + h0 + 1) * Constant.OVERVIEW_SIZE_DOUBLE - yy) / (height * zoom));
          float xmin=(float)(((i + w0) * Constant.OVERVIEW_SIZE_DOUBLE - xx) / (1d * width * zoom));
          float xmax=(float)(((i + w0 + 1) * Constant.OVERVIEW_SIZE_DOUBLE - xx) / (1d * width * zoom));
          if (ymin > 1 || ymax < 0) {
            continue;
          }
          if (xmin > 1 || xmax < 0) {
            continue;
          }
          String file=new StringBuilder(initfile).append(getBandFolder(activeBand)).append(""String_Node_Str"").append((i + w0)).append(""String_Node_Str"").append((j + h0)).append(""String_Node_Str"").toString();
          if (!tryMemoryCache(gl,file,xmin,xmax,ymin,ymax)) {
            if (!tryFileCache(gl,file,0,(i + w0),(j + h0),xmin,xmax,ymin,ymax)) {
              addTileToQueue(initfile,0,(i + w0),(j + h0));
            }
          }
        }
      }
    }
    displayDownloading(futures.size());
    SumoPlatform.getApplication().refresh();
    if (this.disposed) {
      disposeSync();
    }
  }
}","@Override public void render(Object glContext){
  OpenGLContext context=(OpenGLContext)glContext;
  if (activeGir != null) {
    if (torescale) {
      torescale=false;
      tcm.clear();
    }
    GL gl=context.getGL();
    updateFutures(gl);
    float zoom=context.getZoom();
    int width=context.getWidth();
    int height=context.getHeight();
    int x=context.getX();
    int y=context.getY();
    int xx=(int)(x + xpadding);
    int yy=(int)(y + ypadding);
    int max=maxnumberoftiles;
    Cache c=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
    gl.getGL2().glTexEnvi(GL2.GL_TEXTURE_ENV,GL2.GL_TEXTURE_ENV_MODE,GL2.GL_REPLACE);
    if (zoom >= 1) {
      curlevel=(int)Math.sqrt(zoom + 1);
      for (int lll=maxlevels; (lll > curlevel - 1); lll--) {
        if (lll > maxlevels) {
          break;
        }
        lll+=increaseLevel;
        if (lll < 0) {
          continue;
        }
        if (this.mylevel != curlevel) {
          this.mylevel=curlevel;
          poolExcutorService.shutdown();
          poolExcutorService=new ThreadPoolExecutor(1,poolSize,1000,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
        }
        int w0=xx / ((1 << lll) << 8);
        int h0=yy / ((1 << lll) << 8);
        final String initfile=new StringBuffer(File.separator).append((int)lll).append(File.separator).append((activeGir instanceof TiledBufferedImage ? ((TiledBufferedImage)activeGir).getDescription() + File.separator : ""String_Node_Str"")).toString();
        for (int k=0; k < max; k++) {
          for (int j=0; j < max; j++) {
            if (j + h0 < 0) {
              continue;
            }
            for (int i=0; i < max; i++) {
              if (i + w0 < 0) {
                continue;
              }
              if (arrayReadTilesOrder[i][j] == k) {
                float ymin=(float)(((j + h0) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - yy) / (height * zoom));
                float ymax=(float)(((j + h0 + 1) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - yy) / (height * zoom));
                float xmin=(float)(((i + w0) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - xx) / (1d * width * zoom));
                float xmax=(float)(((i + w0 + 1) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - xx) / (1d * width * zoom));
                if (ymin > 1 || ymax < 0) {
                  continue;
                }
                if (xmin > 1 || xmax < 0) {
                  continue;
                }
                String file=new StringBuffer(initfile).append(getBandFolder(activeBand)).append(File.separator).append((i + w0)).append(""String_Node_Str"").append((j + h0)).append(""String_Node_Str"").toString();
                Texture t=tryMemoryCache(gl,file,xmin,xmax,ymin,ymax);
                if (t == null) {
                  BufferedImage tile=tryFileCache(gl,file,lll,(i + w0),(j + h0),xmin,xmax,ymin,ymax);
                  if (tile != null) {
                    t=AWTTextureIO.newTexture(gl.getGLProfile(),tile,false);
                    tcm.add(file,t);
                  }
                }
                if (t != null) {
                  bindTexture(gl,t,xmin,xmax,ymin,ymax);
                }
 else                 if ((curlevel == 0 && lll == 0) || (curlevel == lll)) {
                  addTileToQueue(initfile,lll,(i + w0),(j + h0));
                }
              }
            }
          }
        }
      }
    }
 else     if (zoom > 0) {
      curlevel=0;
      int w0=xx / Constant.TILE_SIZE_IMG_LAYER;
      int h0=yy / Constant.TILE_SIZE_IMG_LAYER;
      final String initfile=new StringBuilder(c.getPath().toString()).append(""String_Node_Str"").append((activeGir instanceof TiledBufferedImage ? ((TiledBufferedImage)activeGir).getDescription() + ""String_Node_Str"" : ""String_Node_Str"")).toString();
      for (int j=0; j < max; j++) {
        if (j + h0 < 0) {
          continue;
        }
        for (int i=0; i < max; i++) {
          if (i + w0 < 0) {
            continue;
          }
          float ymin=(float)(((j + h0) * Constant.OVERVIEW_SIZE_DOUBLE - yy) / (height * zoom));
          float ymax=(float)(((j + h0 + 1) * Constant.OVERVIEW_SIZE_DOUBLE - yy) / (height * zoom));
          float xmin=(float)(((i + w0) * Constant.OVERVIEW_SIZE_DOUBLE - xx) / (1d * width * zoom));
          float xmax=(float)(((i + w0 + 1) * Constant.OVERVIEW_SIZE_DOUBLE - xx) / (1d * width * zoom));
          if (ymin > 1 || ymax < 0) {
            continue;
          }
          if (xmin > 1 || xmax < 0) {
            continue;
          }
          String file=new StringBuilder(initfile).append(getBandFolder(activeBand)).append(""String_Node_Str"").append((i + w0)).append(""String_Node_Str"").append((j + h0)).append(""String_Node_Str"").toString();
          Texture t=tryMemoryCache(gl,file,xmin,xmax,ymin,ymax);
          if (t == null) {
            BufferedImage tile=tryFileCache(gl,file,0,(i + w0),(j + h0),xmin,xmax,ymin,ymax);
            if (tile != null) {
              t=AWTTextureIO.newTexture(gl.getGLProfile(),tile,false);
              tcm.add(file,t);
            }
          }
          if (t != null) {
            bindTexture(gl,t,xmin,xmax,ymin,ymax);
          }
 else {
            addTileToQueue(initfile,0,(i + w0),(j + h0));
          }
        }
      }
    }
    displayDownloading(futures.size());
    SumoPlatform.getApplication().refresh();
    if (this.disposed) {
      disposeSync();
    }
  }
}",0.8518625469246318
175052,"private boolean tryFileCache(GL gl,String file,int level,int i,int j,float xmin,float xmax,float ymin,float ymax){
  String tileId=new StringBuilder(""String_Node_Str"").append(level).append(""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).toString();
  Cache cacheInstance=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
  boolean ok=true;
  if (cacheInstance.contains(file) & !submitedTiles.contains(tileId)) {
    BufferedImage temp=null;
    try {
      try {
        temp=ImageIO.read(cacheInstance.newFile(file));
      }
 catch (      Exception ex) {
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
        temp=ImageIO.read(cacheInstance.newFile(file));
      }
      if (temp == null) {
        ok=false;
      }
    }
 catch (    Exception ex) {
      ok=false;
      logger.warn(""String_Node_Str"" + file + ""String_Node_Str""+ ex.getMessage());
    }
 finally {
      pngReader.dispose();
    }
    if (ok) {
      if (temp.getColorModel().getNumComponents() == 1) {
        temp=rescale.filter(temp,rescale.createCompatibleDestImage(temp,temp.getColorModel()));
      }
      Texture t=AWTTextureIO.newTexture(gl.getGLProfile(),temp,false);
      tcm.add(file,t);
      bindTexture(gl,t,xmin,xmax,ymin,ymax);
    }
  }
 else {
    ok=false;
  }
  return ok;
}","/** 
 * search for tiles in the file cache
 * @param gl
 * @param file
 * @param level
 * @param i
 * @param j
 * @param xmin
 * @param xmax
 * @param ymin
 * @param ymax
 * @return
 */
private BufferedImage tryFileCache(GL gl,String file,int level,int i,int j,float xmin,float xmax,float ymin,float ymax){
  String tileId=new StringBuilder(""String_Node_Str"").append(level).append(""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).toString();
  Cache cacheInstance=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
  BufferedImage temp=null;
  if (cacheInstance.contains(file) & !submitedTiles.contains(tileId)) {
    try {
      try {
        temp=ImageIO.read(cacheInstance.newFile(file));
      }
 catch (      Exception ex) {
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
        temp=ImageIO.read(cacheInstance.newFile(file));
      }
    }
 catch (    Exception ex) {
      logger.warn(""String_Node_Str"" + file + ""String_Node_Str""+ ex.getMessage());
      return null;
    }
 finally {
      pngReader.dispose();
    }
    if (temp.getColorModel().getNumComponents() == 1) {
      temp=rescale.filter(temp,rescale.createCompatibleDestImage(temp,temp.getColorModel()));
    }
  }
  return temp;
}",0.5748168817579351
175053,"private void displayDownloading(int size){
  GeoImageViewerView view=((GeoImageViewerView)SumoPlatform.getApplication().getMainView());
  if (currentSize != size) {
    if (size == 0) {
      view.setInfo(""String_Node_Str"",-1);
    }
 else {
      view.setInfo(new StringBuilder(""String_Node_Str"").append(size).toString());
    }
    currentSize=size;
  }
}","private void displayDownloading(int size){
  if (currentSize != size) {
    if (size == 0) {
      SumoPlatform.getApplication().setMessageInfo(""String_Node_Str"");
    }
 else {
      SumoPlatform.getApplication().setMessageInfo(new StringBuilder(""String_Node_Str"").append(size).toString());
    }
    currentSize=size;
  }
}",0.718475073313783
175054,"private boolean tryMemoryCache(GL gl,String file,float xmin,float xmax,float ymin,float ymax){
  Texture t=tcm.getTexture(file);
  if (t != null) {
    bindTexture(gl,t,xmin,xmax,ymin,ymax);
    return true;
  }
  return false;
}","/** 
 * search for the tiles on memory
 * @param gl
 * @param file
 * @param xmin
 * @param xmax
 * @param ymin
 * @param ymax
 * @return
 */
private Texture tryMemoryCache(GL gl,String file,float xmin,float xmax,float ymin,float ymax){
  Texture t=tcm.getTexture(file);
  return t;
}",0.4951267056530214
175055,"/** 
 * Reads single pixel value of the curent band.
 * @param x
 * @param y
 * @return pixel value
 */
public int readPixel(int x,int y,int band);","/** 
 * Reads single pixel value of the curent band.
 * @param x
 * @param y
 * @return pixel value
 */
public long readPixel(int x,int y,int band);",0.9830508474576272
175056,"@Override public int readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  t.setSourceRegion(new Rectangle(x,y,1,1));
  int[] pix=new int[1];
  tiffRaster.getPixel(x,y,pix);
  return pix[0];
}","@Override public long readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  t.setSourceRegion(new Rectangle(x,y,1,1));
  int[] pix=new int[1];
  tiffRaster.getPixel(x,y,pix);
  return pix[0];
}",0.9842696629213484
175057,"public int readPixel(int x,int y,int band){
  return readTile(x,y,1,1,band)[0];
}","public long readPixel(int x,int y,int band){
  return readTile(x,y,1,1,band)[0];
}",0.9693251533742332
175058,"@Override public int readPixel(int x,int y,int band){
  return read(x,y,1,1,band)[0];
}","@Override public long readPixel(int x,int y,int band){
  return read(x,y,1,1,band)[0];
}",0.9714285714285714
175059,"@Override public int[] readTile(int x,int y,int width,int height,int band){
  TIFF tiff=(TIFF)getImage(band);
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(tiff.getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.width * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  int yOffset=tiff.xSize;
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=preloadedData[temp];
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}","@Override public int[] readTile(int x,int y,int width,int height,int band){
  TIFF tiff=(TIFF)getImage(band);
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(tiff.getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.width * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  int yOffset=tiff.xSize;
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=(int)preloadedData[temp];
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}",0.9973890339425588
175060,"@Override public void preloadLineTile(int y,int length,int band){
  TIFF tiff=(TIFF)getImage(band);
  if (y < 0) {
    return;
  }
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,tiff.xSize,length);
  rect=tiff.getBounds().intersection(rect);
  try {
    BufferedImage bi=null;
    try {
      bi=tiff.read(0,rect);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.read(0,rect);
    }
    WritableRaster raster=bi.getRaster();
    preloadedData=(short[])raster.getDataElements(0,0,raster.getWidth(),raster.getHeight(),null);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}","@Override public void preloadLineTile(int y,int length,int band){
  TIFF tiff=(TIFF)getImage(band);
  if (y < 0) {
    return;
  }
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,tiff.xSize,length);
  rect=tiff.getBounds().intersection(rect);
  try {
    BufferedImage bi=null;
    try {
      bi=tiff.read(0,rect);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.read(0,rect);
    }
    WritableRaster raster=bi.getRaster();
    preloadedData=(Short[])raster.getDataElements(0,0,raster.getWidth(),raster.getHeight(),null);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}",0.9988479262672812
175061,"@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(getImage(band).getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.width * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  int yOffset=getImage(band).xSize;
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=preloadedData[temp];
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}","@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(getImage(band).getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.width * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
  }
  int yOffset=getImage(band).xSize;
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=((Short)preloadedData[temp]).intValue();
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}",0.9694369973190348
175062,"@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,getImage(band).xSize,length);
  TIFF tiff=getImage(band);
  rect=tiff.getBounds().intersection(rect);
  try {
    BufferedImage bi=null;
    try {
      bi=tiff.read(0,rect);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.read(0,rect);
    }
    WritableRaster raster=bi.getRaster();
    preloadedData=(short[])raster.getDataElements(0,0,raster.getWidth(),raster.getHeight(),null);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}","@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,getImage(band).xSize,length);
  TIFF tiff=getImage(band);
  rect=tiff.getBounds().intersection(rect);
  try {
    BufferedImage bi=null;
    try {
      bi=tiff.read(0,rect);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.read(0,rect);
    }
    WritableRaster raster=bi.getRaster();
    short[] ss=(short[])raster.getDataElements(0,0,raster.getWidth(),raster.getHeight(),null);
    preloadedData=ArrayUtils.toObject(ss);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}",0.9607623318385652
175063,"@Override public int readPixel(int x,int y,int band){
  return read(x,y,1,1,band)[0];
}","@Override public long readPixel(int x,int y,int band){
  return read(x,y,1,1,band)[0];
}",0.9714285714285714
175064,"@Override public int[] read(int x,int y,int width,int height,int band){
  int data[]=null;
  GeoToolsGDALReader tiff=(GeoToolsGDALReader)getImage(band);
  try {
    short[] b=tiff.readShortValues(x,y,width,height);
    data=new int[b.length];
    for (int i=0; i < b.length; i++)     data[i]=b[i];
  }
 catch (  Exception ex) {
    logger.warn(ex.getMessage());
  }
 finally {
  }
  return data;
}","@Override public int[] read(int x,int y,int width,int height,int band){
  int data[]=null;
  GeoToolsGDALReader tiff=(GeoToolsGDALReader)getImage(band);
  try {
    int[] b=tiff.readPixValues(x,y,width,height);
    data=new int[b.length];
    for (int i=0; i < b.length; i++)     data[i]=b[i];
  }
 catch (  Exception ex) {
    logger.warn(ex.getMessage());
  }
 finally {
  }
  return data;
}",0.9443037974683544
175065,"@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(getImage(band).getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.y * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
  }
  int yOffset=getImage(band).getxSize();
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=preloadedData[temp];
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}","@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(getImage(band).getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.y * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
  }
  int yOffset=getImage(band).getxSize();
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=(int)preloadedData[temp];
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}",0.9972451790633609
175066,"@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  GeoToolsGDALReader tiff=(GeoToolsGDALReader)getImage(band);
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,tiff.getxSize(),length);
  rect=tiff.getBounds().intersection(rect);
  try {
    short[] bi=null;
    try {
      bi=tiff.readShortValues(0,y,rect.width,rect.height);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.readShortValues(0,y,rect.width,rect.height);
    }
    preloadedData=bi;
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}","@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  GeoToolsGDALReader tiff=(GeoToolsGDALReader)getImage(band);
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,tiff.getxSize(),length);
  rect=tiff.getBounds().intersection(rect);
  try {
    int[] bi=null;
    try {
      bi=tiff.readPixValues(0,y,rect.width,rect.height);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.readPixValues(0,y,rect.width,rect.height);
    }
    preloadedData=ArrayUtils.toObject(bi);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}",0.9734199645599528
175067,"@Override public int readPixel(int x,int y,int band){
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(getImage(band).getBounds());
  short data[]=null;
  GeoToolsGDALReader img=(GeoToolsGDALReader)getImage(band);
  try {
    data=img.readShortValues(x,y,1,1);
  }
  finally {
  }
  return data[0];
}","@Override public long readPixel(int x,int y,int band){
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(getImage(band).getBounds());
  int data[]=null;
  GeoToolsGDALReader img=(GeoToolsGDALReader)getImage(band);
  try {
    data=img.readPixValues(x,y,1,1);
  }
  finally {
  }
  return data[0];
}",0.9667194928684628
175068,"@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(getImage(band).getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.y * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
  }
  int yOffset=getImage(band).getxSize();
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=preloadedData[temp];
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}","@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(getImage(band).getBounds());
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] || rect.y + rect.height != preloadedInterval[1] || preloadedData.length < (rect.y * rect.height - 1)) {
    preloadLineTile(rect.y,rect.height,band);
  }
 else {
  }
  int yOffset=getImage(band).getxSize();
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      try {
        tile[(i + yinit) * width + j + xinit]=(int)preloadedData[temp];
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return tile;
}",0.9972451790633609
175069,"@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  CeosBinaryReader tiff=(CeosBinaryReader)getImage(band);
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,tiff.getxSize(),length);
  rect=tiff.getBounds().intersection(rect);
  try {
    short[] bi=null;
    try {
      bi=tiff.readShort(0,y,rect.width,rect.height);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.readShort(0,y,rect.width,rect.height);
    }
    preloadedData=bi;
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}","@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  CeosBinaryReader tiff=(CeosBinaryReader)getImage(band);
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,tiff.getxSize(),length);
  rect=tiff.getBounds().intersection(rect);
  try {
    int[] bi=null;
    try {
      bi=tiff.readInt(0,y,rect.width,rect.height);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"" + 0 + ""String_Node_Str""+ y+ ""String_Node_Str"");
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException exx) {
        Thread.currentThread().interrupt();
      }
      bi=tiff.readInt(0,y,rect.width,rect.height);
    }
    preloadedData=ArrayUtils.toObject(bi);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}",0.975316074653823
175070,"@Override public int readPixel(int x,int y,int band){
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(getImage(band).getBounds());
  short data[]=null;
  CeosBinaryReader img=(CeosBinaryReader)getImage(band);
  try {
    data=img.readShort(x,y,1,1);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return data[0];
}","@Override public long readPixel(int x,int y,int band){
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(getImage(band).getBounds());
  short data[]=null;
  CeosBinaryReader img=(CeosBinaryReader)getImage(band);
  try {
    data=img.readShort(x,y,1,1);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return data[0];
}",0.9899280575539569
175071,"public int readPixel(int x,int y,int band){
  if (x < 0 || y < 0 || x > xSize || y > ySize) {
    return -1;
  }
  stride[1]=1;
  stride[0]=1;
  dims[1]=1;
  dims[0]=1;
  starts[1]=x;
  starts[0]=y;
  try {
    Object o2=imagedata.read();
    return Array.getInt(o2,0) & 0xFFFF;
  }
 catch (  Exception ex) {
    logger.error(null,ex);
    return 0;
  }
}","public long readPixel(int x,int y,int band){
  if (x < 0 || y < 0 || x > xSize || y > ySize) {
    return -1;
  }
  stride[1]=1;
  stride[0]=1;
  dims[1]=1;
  dims[0]=1;
  starts[1]=x;
  starts[0]=y;
  try {
    Object o2=imagedata.read();
    return Array.getInt(o2,0) & 0xFFFF;
  }
 catch (  Exception ex) {
    logger.error(null,ex);
    return 0;
  }
}",0.9901547116736992
175072,"@Override public int readPixel(int x,int y,int band){
  int result=0;
  long temp=0;
  byte[] pixelByte=new byte[2];
  if (x >= 0 & y >= 0 & x < xSize & y < ySize) {
    try {
      temp=(y * (xOffset + xSize * 2) + xOffset + x * 2);
      fss.seek(temp + offsetBand);
      fss.read(pixelByte,0,2);
      int interm1=pixelByte[0];
      int interm2=pixelByte[1];
      result=((interm1) << 8 | interm2 & 0xff);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
    }
  }
  return result;
}","@Override public long readPixel(int x,int y,int band){
  int result=0;
  long temp=0;
  byte[] pixelByte=new byte[2];
  if (x >= 0 & y >= 0 & x < xSize & y < ySize) {
    try {
      temp=(y * (xOffset + xSize * 2) + xOffset + x * 2);
      fss.seek(temp + offsetBand);
      fss.read(pixelByte,0,2);
      int interm1=pixelByte[0];
      int interm2=pixelByte[1];
      result=((interm1) << 8 | interm2 & 0xff);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
    }
  }
  return result;
}",0.9937777777777778
175073,"@Override public int readPixel(int x,int y,int band){
  int result=0;
  long temp=0;
  byte[] pixelByte=new byte[4];
  if (x >= 0 & y >= 0 & x < xSize & y < ySize) {
    try {
      temp=(y * (xOffset + xSize * 4) + xOffset + x * 4);
      fss.seek(temp + offsetBand);
      fss.read(pixelByte,0,4);
      byte interm0=pixelByte[0];
      byte interm1=pixelByte[1];
      byte interm2=pixelByte[2];
      byte interm3=pixelByte[3];
      long real=((interm0) << 8) | (interm1 & 0xFF);
      long img=((interm2) << 8) | (interm3 & 0xFF);
      result=(int)Math.sqrt(real * real + img * img);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
    }
  }
  return result;
}","@Override public long readPixel(int x,int y,int band){
  int result=0;
  long temp=0;
  byte[] pixelByte=new byte[4];
  if (x >= 0 & y >= 0 & x < xSize & y < ySize) {
    try {
      temp=(y * (xOffset + xSize * 4) + xOffset + x * 4);
      fss.seek(temp + offsetBand);
      fss.read(pixelByte,0,4);
      byte interm0=pixelByte[0];
      byte interm1=pixelByte[1];
      byte interm2=pixelByte[2];
      byte interm3=pixelByte[3];
      long real=((interm0) << 8) | (interm1 & 0xFF);
      long img=((interm2) << 8) | (interm3 & 0xFF);
      result=(int)Math.sqrt(real * real + img * img);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
    }
  }
  return result;
}",0.99527983816588
175074,"@Override public int readPixel(int x,int y,int band){
  int result=0;
  long temp=0;
  byte[] pixelByte=new byte[2];
  if (x >= 0 & y >= 0 & x < xSize & y < ySize) {
    if (numberOfBytes == 2) {
      try {
        temp=(y * (xOffset + xSize * 2) + xOffset + x * 2);
        dat.seek(temp + offsetImage);
        dat.read(pixelByte,0,2);
        int interm1=pixelByte[0];
        int interm2=pixelByte[1];
        result=((interm1 & 0xff) << 8 | interm2 & 0xff);
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
      }
    }
 else {
      try {
        temp=(y * (xOffset + xSize) + xOffset + x);
        dat.seek(temp + offsetImage);
        dat.read(pixelByte,0,1);
        result=pixelByte[0];
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
      }
    }
  }
  return result;
}","@Override public long readPixel(int x,int y,int band){
  int result=0;
  long temp=0;
  byte[] pixelByte=new byte[2];
  if (x >= 0 & y >= 0 & x < xSize & y < ySize) {
    if (numberOfBytes == 2) {
      try {
        temp=(y * (xOffset + xSize * 2) + xOffset + x * 2);
        dat.seek(temp + offsetImage);
        dat.read(pixelByte,0,2);
        int interm1=pixelByte[0];
        int interm2=pixelByte[1];
        result=((interm1 & 0xff) << 8 | interm2 & 0xff);
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
      }
    }
 else {
      try {
        temp=(y * (xOffset + xSize) + xOffset + x);
        dat.seek(temp + offsetImage);
        dat.read(pixelByte,0,1);
        result=pixelByte[0];
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"",e);
      }
    }
  }
  return result;
}",0.9962864721485412
175075,"@Override public int readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  t.setSourceRegion(new Rectangle(x,y,1,1));
  TIFF tiff=getImage(band);
  try {
    return tiff.read(0,t).getRGB(x,y);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
  return -1;
}","@Override public long readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  t.setSourceRegion(new Rectangle(x,y,1,1));
  TIFF tiff=getImage(band);
  try {
    return tiff.read(0,t).getRGB(x,y);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
  return -1;
}",0.9887640449438202
175076,"@Override public int readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int img=tiff.read(0,t).getRaster().getSample(0,0,1);
    int real=tiff.read(0,t).getRaster().getSample(0,0,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
    ex.printStackTrace();
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return -1;
}","@Override public long readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int img=tiff.read(0,t).getRaster().getSample(0,0,1);
    int real=tiff.read(0,t).getRaster().getSample(0,0,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
    ex.printStackTrace();
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return -1;
}",0.9950106913756236
175077,"@Override public int[] getAmbiguityCorrection(final int xPos,final int yPos){
  orbitInclination=FastMath.toRadians(getSatelliteOrbitInclination());
  double temp, deltaAzimuth, deltaRange;
  int[] output=new int[2];
  try {
    double incidenceAngle=getIncidence(xPos);
    double[] lonlat=geotransform.getGeoFromPixel(xPos,yPos);
    double slantRange=getSlanteRange(lonlat[0],lonlat[1]);
    double prf=getPRF(xPos,yPos);
    double sampleDistAzim=getPixelsize()[1];
    double sampleDistRange=getPixelsize()[0];
    temp=(getRadarWaveLenght() * slantRange * prf) / (2 * satelliteSpeed * (1 - FastMath.cos(orbitInclination) / getRevolutionsPerday()));
    deltaAzimuth=temp / sampleDistAzim;
    deltaRange=(temp * temp) / (2 * slantRange * sampleDistRange* FastMath.sin(incidenceAngle));
    output[0]=(int)FastMath.floor(deltaAzimuth);
    output[1]=(int)FastMath.floor(deltaRange);
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"" + ex.getMessage(),ex);
  }
  return output;
}","@Override public int[] getAmbiguityCorrection(final int xPos,final int yPos){
  orbitInclination=FastMath.toRadians(getSatelliteOrbitInclination());
  double temp, deltaAzimuth, deltaRange;
  int[] output=new int[2];
  try {
    double incidenceAngle=getIncidence(xPos);
    double[] lonlat=geotransform.getGeoFromPixel(xPos,yPos);
    double slantRange=getSlanteRange(lonlat[1],lonlat[0]);
    double prf=getPRF(xPos,yPos);
    double sampleDistAzim=getPixelsize()[1];
    double sampleDistRange=getPixelsize()[0];
    temp=(getRadarWaveLenght() * slantRange * prf) / (2 * satelliteSpeed * (1 - FastMath.cos(orbitInclination) / getRevolutionsPerday()));
    deltaAzimuth=temp / sampleDistAzim;
    deltaRange=(temp * temp) / (2 * slantRange * sampleDistRange* FastMath.sin(incidenceAngle));
    output[0]=(int)FastMath.floor(deltaAzimuth);
    output[1]=(int)FastMath.floor(deltaRange);
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"" + ex.getMessage(),ex);
  }
  return output;
}",0.5410821643286573
175078,"@Override public int[] getAmbiguityCorrection(final int xPos,final int yPos){
  orbitInclination=FastMath.toRadians(getSatelliteOrbitInclination());
  double temp, deltaAzimuth, deltaRange;
  int[] output=new int[2];
  try {
    double incidenceAngle=getIncidence(xPos);
    double[] lonlat=geotransform.getGeoFromPixel(xPos,yPos);
    double slantRange=getSlanteRange(lonlat[0],lonlat[1]);
    double prf=getPRF(xPos,yPos);
    double sampleDistAzim=getPixelsize()[1];
    double sampleDistRange=getPixelsize()[0];
    temp=(getRadarWaveLenght() * slantRange * prf) / (2 * satelliteSpeed * (1 - FastMath.cos(orbitInclination) / getRevolutionsPerday()));
    deltaAzimuth=temp / sampleDistAzim;
    deltaRange=(temp * temp) / (2 * slantRange * sampleDistRange* FastMath.sin(incidenceAngle));
    output[0]=(int)FastMath.floor(deltaAzimuth);
    output[1]=(int)FastMath.floor(deltaRange);
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"" + ex.getMessage(),ex);
  }
  return output;
}","@Override public int[] getAmbiguityCorrection(final int xPos,final int yPos){
  orbitInclination=FastMath.toRadians(getSatelliteOrbitInclination());
  double temp, deltaAzimuth, deltaRange;
  int[] output=new int[2];
  try {
    double incidenceAngle=getIncidence(xPos);
    double[] lonlat=geotransform.getGeoFromPixel(xPos,yPos);
    double slantRange=getSlanteRange(lonlat[1],lonlat[0]);
    double prf=getPRF(xPos,yPos);
    double sampleDistAzim=getPixelsize()[1];
    double sampleDistRange=getPixelsize()[0];
    temp=(getRadarWaveLenght() * slantRange * prf) / (2 * satelliteSpeed * (1 - FastMath.cos(orbitInclination) / getRevolutionsPerday()));
    deltaAzimuth=temp / sampleDistAzim;
    deltaRange=(temp * temp) / (2 * slantRange * sampleDistRange* FastMath.sin(incidenceAngle));
    output[0]=(int)FastMath.floor(deltaAzimuth);
    output[1]=(int)FastMath.floor(deltaRange);
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"" + ex.getMessage(),ex);
  }
  return output;
}",0.5410821643286573
175079,"public MaskGeometries(String maskName,List<Geometry> maskGeometries,String fileName){
  this.maskName=maskName;
  this.maskGeometries=maskGeometries;
  intersectedMapCache=new HashMap<String,Boolean>();
  includesMapCache=new HashMap<String,Boolean>();
  this.fileName=fileName;
}","public MaskGeometries(String maskName,List<Geometry> maskGeometries,String fileName){
  this.maskName=maskName;
  this.maskGeometries=maskGeometries;
  intersectedMapCache=new HashMap<String,Boolean>();
  includesMapCache=new HashMap<String,Boolean>();
  this.fileName=fileName;
  splitMultiPolygons();
}",0.958904109589041
175080,"/** 
 * rasterize the mask clipped with the Rectangle scaled back to full size with an offset onto a BufferedImage
 */
public int[] getRasterDataMask(int x,int y,int w,int h,int offsetX,int offsetY,double scalingFactor){
  Rectangle rect=new Rectangle(x,y,w,h);
  BufferedImage bi=this.rasterize(rect,offsetX,offsetY,scalingFactor);
  Raster rastermask=bi.getData();
  int[] maskdata=rastermask.getPixels(0,0,rastermask.getWidth(),rastermask.getHeight(),(int[])null);
  return maskdata;
}","/** 
 * rasterize the mask clipped with the Rectangle scaled back to full size with an offset onto a BufferedImage
 */
public int[] getRasterDataMask(int x,int y,int w,int h,int offsetX,int offsetY,double scalingFactor){
  Rectangle rect=new Rectangle(x,y,w,h);
  BufferedImage bi=this.rasterize(rect,offsetX,offsetY,scalingFactor);
  Raster rastermask=bi.getData();
  int[] maskdata=rastermask.getSamples(0,0,rastermask.getWidth(),rastermask.getHeight(),0,(int[])null);
  return maskdata;
}",0.9867211440245148
175081,"/** 
 * rasterize the mask clipped with the Rectangle scaled back to full size with an offset onto a BufferedImage
 */
public BufferedImage rasterize(Rectangle rect,int offsetX,int offsetY,double scalingFactor){
  BufferedImage image=new BufferedImage(rect.width,rect.height,BufferedImage.TYPE_BYTE_BINARY);
  GeometryFactory gf=new GeometryFactory();
  Coordinate[] coords=new Coordinate[]{new Coordinate((int)(((double)rect.getMinX() / scalingFactor)),(int)(((double)rect.getMinY() / scalingFactor))),new Coordinate((int)(((double)rect.getMaxX() / scalingFactor)),(int)(((double)rect.getMinY() / scalingFactor))),new Coordinate((int)(((double)rect.getMaxX() / scalingFactor)),(int)(((double)rect.getMaxY() / scalingFactor))),new Coordinate((int)(((double)rect.getMinX() / scalingFactor)),(int)(((double)rect.getMaxY() / scalingFactor))),new Coordinate((int)(((double)rect.getMinX() / scalingFactor)),(int)(((double)rect.getMinY() / scalingFactor)))};
  Polygon geom=gf.createPolygon(gf.createLinearRing(coords));
  Graphics g2d=image.getGraphics();
  g2d.setColor(Color.WHITE);
  for (  Geometry p : maskGeometries) {
    if (p.intersects(geom)) {
      int[] xPoints=new int[p.getNumPoints()];
      int[] yPoints=new int[p.getNumPoints()];
      int i=0;
      for (      Coordinate c : p.getCoordinates()) {
        xPoints[i]=(int)((c.x + offsetX) * scalingFactor);
        yPoints[i]=(int)((c.y + offsetY) * scalingFactor);
        i++;
      }
      g2d.fillPolygon(xPoints,yPoints,p.getNumPoints());
    }
  }
  g2d.dispose();
  return image;
}","/** 
 * rasterize the mask clipped with the Rectangle scaled back to full size with an offset onto a BufferedImage
 */
public BufferedImage rasterize(Rectangle rect,int offsetX,int offsetY,double scalingFactor){
  BufferedImage image=new BufferedImage(rect.width,rect.height,BufferedImage.TYPE_BYTE_BINARY);
  GeometryFactory gf=new GeometryFactory();
  Coordinate[] coords=new Coordinate[]{new Coordinate((int)(((double)rect.getMinX() / scalingFactor)),(int)(((double)rect.getMinY() / scalingFactor))),new Coordinate((int)(((double)rect.getMaxX() / scalingFactor)),(int)(((double)rect.getMinY() / scalingFactor))),new Coordinate((int)(((double)rect.getMaxX() / scalingFactor)),(int)(((double)rect.getMaxY() / scalingFactor))),new Coordinate((int)(((double)rect.getMinX() / scalingFactor)),(int)(((double)rect.getMaxY() / scalingFactor))),new Coordinate((int)(((double)rect.getMinX() / scalingFactor)),(int)(((double)rect.getMinY() / scalingFactor)))};
  Polygon geom=gf.createPolygon(gf.createLinearRing(coords));
  Graphics g2d=image.getGraphics();
  g2d.setColor(Color.white);
  for (  Geometry p : maskGeometries) {
    if (p.intersects(geom)) {
      int[] xPoints=new int[p.getNumPoints()];
      int[] yPoints=new int[p.getNumPoints()];
      int i=0;
      for (      Coordinate c : p.getCoordinates()) {
        xPoints[i]=(int)((c.x + offsetX) * scalingFactor);
        yPoints[i]=(int)((c.y + offsetY) * scalingFactor);
        i++;
      }
      g2d.fillPolygon(xPoints,yPoints,i);
    }
  }
  g2d.dispose();
  return image;
}",0.9653833710773212
175082,"/** 
 * aggregate using the neighbours within tilesize
 * @param neighboursdistance
 * @param tilesize
 * @param removelandconnectedpixels
 * @param bands
 * @param mask
 * @param kdist
 * @throws IOException
 */
private void aggregate(DetectedPixels detPixels,int neighboursdistance,int tilesize,boolean removelandconnectedpixels,int[] bands,MaskGeometries mask,KDistributionEstimation kdist) throws IOException {
  int id=0;
  DetectedPixels.BoatPixel pixels[]=detPixels.getAllDetectedPixelsValues().toArray(new DetectedPixels.BoatPixel[0]);
  int count=0;
  for (  DetectedPixels.BoatPixel detectedPix : pixels) {
    count++;
    int xx=detectedPix.x;
    int yy=detectedPix.y;
    if ((count % 100) == 0) {
      if (logger.isInfoEnabled())       logger.info(new StringBuilder().append(""String_Node_Str"").append(count).append(""String_Node_Str"").append(xx).append(""String_Node_Str"").append(yy).toString());
    }
    boolean checked=false;
    for (    BoatConnectedPixelMap boatpixel : detPixels.listboatneighbours) {
      if (boatpixel.containsPixel(xx,yy)) {
        checked=true;
        break;
      }
    }
    if (checked) {
      continue;
    }
    int cornerx=Math.min(Math.max(0,xx - tilesize / 2),gir.getWidth() - tilesize);
    int cornery=Math.min(Math.max(0,yy - tilesize / 2),gir.getHeight() - tilesize);
    int boatx=xx - cornerx;
    int boaty=yy - cornery;
    int numberbands=bands.length;
    int[][] data=new int[numberbands][];
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      data[bandcounter]=gir.read(cornerx,cornery,tilesize,tilesize,bands[bandcounter]);
    }
    int row=(cornery + 1) / this.verTilesImage;
    int col=(cornerx + 1) / this.horTilesImage;
    TileAnalysis ta=null;
    if (this.blackBorderAnalysis != null)     ta=this.blackBorderAnalysis.getAnalysisTile(row,col);
    double[][] statistics=AnalysisUtil.calculateImagemapStatistics(cornerx,cornery,tilesize,tilesize,row,col,bands,data,kdist,ta);
    double[][] thresholdvalues=new double[numberbands][2];
    boolean pixelabove=false;
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      double mean=(statistics[bandcounter][1] + statistics[bandcounter][2] + statistics[bandcounter][3]+ statistics[bandcounter][4]) / 4;
      thresholdvalues[bandcounter][0]=mean + 3 * mean * statistics[bandcounter][0];
      thresholdvalues[bandcounter][1]=mean + 5 * mean * statistics[bandcounter][0];
      int value=data[bandcounter][boatx + boaty * tilesize];
      if (value > thresholdvalues[bandcounter][1]) {
        pixelabove=true;
      }
    }
    if (pixelabove) {
      int[] dataMask=createDataMask(cornerx,cornery,tilesize,tilesize,0,0);
      BoatConnectedPixelMap boatpixel=null;
      try {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][boatx + boaty * tilesize]);
      }
 catch (      Exception e) {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][(boatx + boaty * tilesize) - 1]);
      }
      for (int iBand=0; iBand < numberbands; iBand++) {
        String bb=gir.getBandName(bands[iBand]);
        float thresholdBand=this.thresholdsBandParams.get(bb);
        TileAnalysis bbAnalysis=null;
        if (blackBorderAnalysis != null)         bbAnalysis=blackBorderAnalysis.getAnalysisTile(row,col);
        kdist.setImageData(cornerx,cornery,tilesize,tilesize,iBand,bbAnalysis);
        int[] newdata=gir.read(cornerx,cornery,tilesize,tilesize,bands[iBand]);
        kdist.estimate(newdata,newdata);
        double[] treshTile=kdist.getDetectThresh();
        double threshTotal=treshTile[0] + treshTile[1] + treshTile[2]+ treshTile[3];
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,treshTile);
        double tileAvg=0;
        int i=0;
        int y=-1;
        for (; i < data[iBand].length; i++) {
          int x=i % 200;
          if (x == 0)           y++;
          try {
            if (dataMask == null || dataMask[x + (y * tilesize)] == 0) {
              tileAvg=tileAvg + data[iBand][i];
            }
          }
 catch (          Exception e) {
            logger.warn(new StringBuilder(e.getMessage()).append(""String_Node_Str"").append(x).append(""String_Node_Str"").append(y).append(""String_Node_Str"").toString());
          }
        }
        tileAvg=tileAvg / i;
        double tileStdDev=treshTile[0] * threshTotal / treshTile[5];
        boatpixel.getStatMap().setTreshold(Precision.round((threshWindowsVals[0] + threshWindowsVals[1] + threshWindowsVals[2]+ threshWindowsVals[3]) / 4,3),bb);
        boatpixel.getStatMap().setTileStd(Precision.round(tileStdDev,3),bb);
        boatpixel.getStatMap().setTileAvg(Precision.round(tileAvg,3),bb);
      }
      detPixels.listboatneighbours.add(boatpixel);
      List<int[]> boataggregatedpixels=new ArrayList<int[]>();
      boolean result=detPixels.checkNeighbours(boataggregatedpixels,data,thresholdvalues,new int[]{boatx,boaty},neighboursdistance,tilesize,dataMask);
      boatpixel.setTouchesLandMask(result);
      for (      int[] pixel : boataggregatedpixels) {
        boatpixel.addConnectedPixel(pixel[0] + cornerx,pixel[1] + cornery,pixel[2],pixel[3] == 1 ? true : false);
      }
    }
  }
  if (removelandconnectedpixels) {
    List<BoatConnectedPixelMap> toRemove=new ArrayList<BoatConnectedPixelMap>();
    for (int i=0; i < detPixels.listboatneighbours.size(); i++) {
      BoatConnectedPixelMap boat=detPixels.listboatneighbours.get(i);
      if (boat.touchesLand()) {
        toRemove.add(boat);
      }
    }
    detPixels.listboatneighbours.removeAll(toRemove);
  }
}","/** 
 * aggregate using the neighbours within tilesize
 * @param neighboursdistance
 * @param tilesize
 * @param removelandconnectedpixels
 * @param bands
 * @param mask
 * @param kdist
 * @throws IOException
 */
private void aggregate(DetectedPixels detPixels,int neighboursdistance,int tilesize,boolean removelandconnectedpixels,int[] bands,MaskGeometries mask,KDistributionEstimation kdist) throws IOException {
  int id=0;
  DetectedPixels.BoatPixel pixels[]=detPixels.getAllDetectedPixelsValues().toArray(new DetectedPixels.BoatPixel[0]);
  int count=0;
  for (  DetectedPixels.BoatPixel detectedPix : pixels) {
    count++;
    int xx=detectedPix.x;
    int yy=detectedPix.y;
    if ((count % 100) == 0) {
      if (logger.isInfoEnabled())       logger.info(new StringBuilder().append(""String_Node_Str"").append(count).append(""String_Node_Str"").append(xx).append(""String_Node_Str"").append(yy).toString());
    }
    boolean checked=false;
    for (    BoatConnectedPixelMap boatpixel : detPixels.listboatneighbours) {
      if (boatpixel.containsPixel(xx,yy)) {
        checked=true;
        break;
      }
    }
    if (checked) {
      continue;
    }
    int cornerx=Math.min(Math.max(0,xx - tilesize / 2),gir.getWidth() - tilesize);
    int cornery=Math.min(Math.max(0,yy - tilesize / 2),gir.getHeight() - tilesize);
    int boatx=xx - cornerx;
    int boaty=yy - cornery;
    int numberbands=bands.length;
    int[][] data=new int[numberbands][];
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      data[bandcounter]=gir.read(cornerx,cornery,tilesize,tilesize,bands[bandcounter]);
    }
    int row=(cornery + 1) / this.verTilesImage;
    int col=(cornerx + 1) / this.horTilesImage;
    TileAnalysis ta=null;
    if (this.blackBorderAnalysis != null)     ta=this.blackBorderAnalysis.getAnalysisTile(row,col);
    double[][] statistics=AnalysisUtil.calculateImagemapStatistics(cornerx,cornery,tilesize,tilesize,row,col,bands,data,kdist,ta);
    double[][] thresholdvalues=new double[numberbands][2];
    boolean pixelabove=false;
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      double mean=(statistics[bandcounter][1] + statistics[bandcounter][2] + statistics[bandcounter][3]+ statistics[bandcounter][4]) / 4;
      thresholdvalues[bandcounter][0]=mean + 3 * mean * statistics[bandcounter][0];
      thresholdvalues[bandcounter][1]=mean + 5 * mean * statistics[bandcounter][0];
      int value=data[bandcounter][boatx + boaty * tilesize];
      if (value > thresholdvalues[bandcounter][1]) {
        pixelabove=true;
      }
 else {
      }
    }
    if (pixelabove) {
      int[] dataMask=createDataMask(cornerx,cornery,tilesize,tilesize,0,0);
      BoatConnectedPixelMap boatpixel=null;
      try {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][boatx + boaty * tilesize]);
      }
 catch (      Exception e) {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][(boatx + boaty * tilesize) - 1]);
      }
      for (int iBand=0; iBand < numberbands; iBand++) {
        String bb=gir.getBandName(bands[iBand]);
        float thresholdBand=this.thresholdsBandParams.get(bb);
        TileAnalysis bbAnalysis=null;
        if (blackBorderAnalysis != null)         bbAnalysis=blackBorderAnalysis.getAnalysisTile(row,col);
        kdist.setImageData(cornerx,cornery,tilesize,tilesize,iBand,bbAnalysis);
        int[] newdata=gir.read(cornerx,cornery,tilesize,tilesize,bands[iBand]);
        kdist.estimate(newdata,newdata);
        double[] treshTile=kdist.getDetectThresh();
        double threshTotal=treshTile[0] + treshTile[1] + treshTile[2]+ treshTile[3];
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,treshTile);
        double tileAvg=0;
        int i=0;
        int y=-1;
        for (; i < data[iBand].length; i++) {
          int x=i % tilesize;
          if (x == 0)           y++;
          try {
            if (dataMask == null || dataMask[x + (y * tilesize)] == 0) {
              tileAvg=tileAvg + data[iBand][i];
            }
          }
 catch (          Exception e) {
            logger.warn(new StringBuilder(e.getMessage()).append(""String_Node_Str"").append(x).append(""String_Node_Str"").append(y).append(""String_Node_Str"").toString());
          }
        }
        tileAvg=tileAvg / i;
        double tileStdDev=treshTile[0] * threshTotal / treshTile[5];
        boatpixel.getStatMap().setTreshold(Precision.round((threshWindowsVals[0] + threshWindowsVals[1] + threshWindowsVals[2]+ threshWindowsVals[3]) / 4,3),bb);
        boatpixel.getStatMap().setTileStd(Precision.round(tileStdDev,3),bb);
        boatpixel.getStatMap().setTileAvg(Precision.round(tileAvg,3),bb);
      }
      detPixels.listboatneighbours.add(boatpixel);
      List<int[]> boataggregatedpixels=new ArrayList<int[]>();
      boolean result=detPixels.checkNeighbours(boataggregatedpixels,data,thresholdvalues,new int[]{boatx,boaty},neighboursdistance,tilesize,dataMask);
      boatpixel.setTouchesLandMask(result);
      for (      int[] pixel : boataggregatedpixels) {
        boatpixel.addConnectedPixel(pixel[0] + cornerx,pixel[1] + cornery,pixel[2],pixel[3] == 1 ? true : false);
      }
    }
  }
  if (removelandconnectedpixels) {
    List<BoatConnectedPixelMap> toRemove=new ArrayList<BoatConnectedPixelMap>();
    for (int i=0; i < detPixels.listboatneighbours.size(); i++) {
      BoatConnectedPixelMap boat=detPixels.listboatneighbours.get(i);
      if (boat.touchesLand()) {
        toRemove.add(boat);
      }
    }
    detPixels.listboatneighbours.removeAll(toRemove);
  }
}",0.9976006398293789
175083,"@Override public boolean executeFromConsole(){
  try {
    SarImageReader sar=(SarImageReader)SumoPlatform.getApplication().getCurrentImageReader();
    ImageLayer layer=LayerManager.getIstanceManager().getCurrentImageLayer();
    if (layer != null && commandLine.length >= 3) {
      String arg0=commandLine[1];
      String arg1=commandLine[2];
      String arg2=commandLine[3];
      if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        if (commandLine.length == 2 && arg1.equalsIgnoreCase(""String_Node_Str"")) {
          runBBAnalysis();
        }
 else {
          int row=Integer.parseInt(arg1);
          int col=Integer.parseInt(arg2);
          yy=layer.getRealTileSizeY() * row;
          xx=layer.getRealTileSizeX() * col;
          tileSizeY=layer.getRealTileSizeY();
          tileSizeX=layer.getRealTileSizeY();
          String direction=""String_Node_Str"";
          if (commandLine.length == 5)           direction=commandLine[4];
          BlackBorderAnalysis borderAn=new BlackBorderAnalysis(sar,layer.getRealTileSizeX(),layer.getRealTileSizeY(),null);
          int[] threshs=borderAn.analyse(row,col,direction.equalsIgnoreCase(""String_Node_Str""));
          List<Geometry> points=new ArrayList<>();
          GeometryFactory gf=new GeometryFactory();
          for (int i=0; i < threshs.length; i++) {
            int offset=threshs[i];
            if (direction.equalsIgnoreCase(""String_Node_Str"")) {
              if (xx < (sar.getWidth() / 2)) {
                Point p=gf.createPoint(new Coordinate(xx + offset,yy + i));
                points.add(p);
              }
            }
 else {
            }
          }
          GeometryImage giPoint=new GeometryImage(arg2,points);
          SimpleGeometryLayer offset=new SimpleGeometryLayer(layer,""String_Node_Str"" + row + ""String_Node_Str""+ col,giPoint);
          offset.setColor(Color.ORANGE);
          offset.setWidth(2.0f);
          LayerManager.addLayerInThread(offset);
          com.vividsolutions.jts.geom.Polygon box=JTSUtil.createPolygon(xx,yy,layer.getRealTileSizeX(),layer.getRealTileSizeY());
          List<Geometry> geoms=new ArrayList<>();
          geoms.add(box);
          GeometryImage gi=new GeometryImage(arg2,geoms);
          SimpleGeometryLayer sgl=new SimpleGeometryLayer(layer,""String_Node_Str"" + row + ""String_Node_Str""+ col,gi);
          sgl.setColor(Color.ORANGE);
          sgl.setWidth(2.0f);
          LayerManager.addLayerInThread(sgl);
        }
      }
 else       if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        int row=Integer.parseInt(arg1);
        int col=Integer.parseInt(arg2);
        Float hh=1.5f;
        Float hv=1.5f;
        Float vh=1.5f;
        Float vv=1.5f;
        Float buffer=0.0f;
        if (commandLine.length >= 5) {
          buffer=Float.parseFloat(commandLine[4]);
          if (commandLine.length > 5) {
            hh=Float.parseFloat(commandLine[5]);
            hv=Float.parseFloat(commandLine[6]);
            vh=Float.parseFloat(commandLine[7]);
            vv=Float.parseFloat(commandLine[8]);
          }
        }
        MaskVectorLayer coastlineMask=null;
        MaskVectorLayer iceMasks=null;
        for (        ILayer l : LayerManager.getIstanceManager().getChilds(layer)) {
          if (l instanceof IMask) {
            if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.COASTLINE_MASK) {
              coastlineMask=(MaskVectorLayer)l;
            }
 else             if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.ICE_MASK) {
              iceMasks=(MaskVectorLayer)l;
            }
          }
        }
        MaskGeometries mg=null;
        IMask bufferedMask=null;
        if (coastlineMask != null) {
          bufferedMask=FactoryLayer.createMaskLayer(coastlineMask.getName(),coastlineMask.getType(),0,((MaskVectorLayer)coastlineMask).getGeometriclayer(),coastlineMask.getMaskType());
          mg=new MaskGeometries(""String_Node_Str"",bufferedMask.getGeometries(),bufferedMask.getName());
        }
        MaskGeometries ice=null;
        IMask iceMask=null;
        if (iceMasks != null) {
          iceMask=FactoryLayer.createMaskLayer(iceMasks.getName(),iceMasks.getType(),0,((MaskVectorLayer)iceMasks).getGeometriclayer(),iceMasks.getMaskType());
          ice=new MaskGeometries(""String_Node_Str"",iceMask.getGeometries(),bufferedMask.getName());
        }
        VDSAnalysis analysis=new VDSAnalysis(sar,mg,ice,Float.parseFloat(sar.getENL()),new Float[]{hh,hv,vh,vv},layer.getRealTileSizeX(),layer.getRealTileSizeY(),layer.getHorizontalTilesImage(),layer.getVerticalTilesImage());
        analysis.setAnalyseSingleTile(true);
        analysis.setxTileToAnalyze(col);
        analysis.setyTileToAnalyze(row);
        proc=new AnalysisProcess(sar,Float.parseFloat(sar.getENL()),analysis,0,0,null);
        proc.addProcessListener(this);
        proc.call();
        yy=layer.getRealTileSizeY() * row;
        xx=layer.getRealTileSizeX() * col;
        tileSizeY=layer.getRealTileSizeY();
        tileSizeX=layer.getRealTileSizeX();
      }
    }
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
    return false;
  }
 finally {
  }
  return true;
}","@Override public boolean executeFromConsole(){
  try {
    SarImageReader sar=(SarImageReader)SumoPlatform.getApplication().getCurrentImageReader();
    ImageLayer layer=LayerManager.getIstanceManager().getCurrentImageLayer();
    if (layer != null && commandLine.length >= 3) {
      String arg0=commandLine[1];
      String arg1=commandLine[2];
      String arg2=commandLine[3];
      if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        if (commandLine.length == 2 && arg1.equalsIgnoreCase(""String_Node_Str"")) {
          runBBAnalysis();
        }
 else {
          int row=Integer.parseInt(arg1);
          int col=Integer.parseInt(arg2);
          yy=layer.getRealTileSizeY() * row;
          xx=layer.getRealTileSizeX() * col;
          tileSizeY=layer.getRealTileSizeY();
          tileSizeX=layer.getRealTileSizeY();
          String direction=""String_Node_Str"";
          if (commandLine.length == 5)           direction=commandLine[4];
          BlackBorderAnalysis borderAn=new BlackBorderAnalysis(sar,layer.getRealTileSizeX(),layer.getRealTileSizeY(),null);
          int[] threshs=borderAn.analyse(row,col,direction.equalsIgnoreCase(""String_Node_Str""));
          List<Geometry> points=new ArrayList<>();
          GeometryFactory gf=new GeometryFactory();
          for (int i=0; i < threshs.length; i++) {
            int offset=threshs[i];
            if (direction.equalsIgnoreCase(""String_Node_Str"")) {
              if (xx < (sar.getWidth() / 2)) {
                Point p=gf.createPoint(new Coordinate(xx + offset,yy + i));
                points.add(p);
              }
            }
 else {
            }
          }
          GeometryImage giPoint=new GeometryImage(arg2,points);
          SimpleGeometryLayer offset=new SimpleGeometryLayer(layer,""String_Node_Str"" + row + ""String_Node_Str""+ col,giPoint);
          offset.setColor(Color.ORANGE);
          offset.setWidth(2.0f);
          LayerManager.addLayerInThread(offset);
          com.vividsolutions.jts.geom.Polygon box=JTSUtil.createPolygon(xx,yy,layer.getRealTileSizeX(),layer.getRealTileSizeY());
          List<Geometry> geoms=new ArrayList<>();
          geoms.add(box);
          GeometryImage gi=new GeometryImage(arg2,geoms);
          SimpleGeometryLayer sgl=new SimpleGeometryLayer(layer,""String_Node_Str"" + row + ""String_Node_Str""+ col,gi);
          sgl.setColor(Color.ORANGE);
          sgl.setWidth(2.0f);
          LayerManager.addLayerInThread(sgl);
        }
      }
 else       if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        int row=Integer.parseInt(arg1);
        int col=Integer.parseInt(arg2);
        Float hh=1.5f;
        Float hv=1.5f;
        Float vh=1.5f;
        Float vv=1.5f;
        Float buffer=0.0f;
        if (commandLine.length >= 5) {
          buffer=Float.parseFloat(commandLine[4]);
          if (commandLine.length > 5) {
            hh=Float.parseFloat(commandLine[5]);
            hv=Float.parseFloat(commandLine[6]);
            vh=Float.parseFloat(commandLine[7]);
            vv=Float.parseFloat(commandLine[8]);
          }
        }
        MaskVectorLayer coastlineMask=null;
        MaskVectorLayer iceMasks=null;
        for (        ILayer l : LayerManager.getIstanceManager().getChilds(layer)) {
          if (l instanceof IMask) {
            if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.COASTLINE_MASK) {
              coastlineMask=(MaskVectorLayer)l;
            }
 else             if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.ICE_MASK) {
              iceMasks=(MaskVectorLayer)l;
            }
          }
        }
        MaskGeometries mg=null;
        IMask bufferedMask=null;
        if (coastlineMask != null) {
          bufferedMask=FactoryLayer.createMaskLayer(coastlineMask.getName(),coastlineMask.getType(),0,((MaskVectorLayer)coastlineMask).getGeometriclayer(),coastlineMask.getMaskType());
          mg=new MaskGeometries(""String_Node_Str"",bufferedMask.getGeometries(),bufferedMask.getName());
        }
        MaskGeometries ice=null;
        IMask iceMask=null;
        if (iceMasks != null) {
          iceMask=FactoryLayer.createMaskLayer(iceMasks.getName(),iceMasks.getType(),0,((MaskVectorLayer)iceMasks).getGeometriclayer(),iceMasks.getMaskType());
          ice=new MaskGeometries(""String_Node_Str"",iceMask.getGeometries(),bufferedMask.getName());
        }
        yy=layer.getRealTileSizeY() * row;
        xx=layer.getRealTileSizeX() * col;
        tileSizeY=layer.getRealTileSizeY();
        tileSizeX=layer.getRealTileSizeX();
        VDSAnalysis analysis=new VDSAnalysis(sar,mg,ice,Float.parseFloat(sar.getENL()),new Float[]{hh,hv,vh,vv},layer.getRealTileSizeX(),layer.getRealTileSizeY(),layer.getHorizontalTilesImage(),layer.getVerticalTilesImage());
        analysis.setAnalyseSingleTile(true);
        analysis.setxTileToAnalyze(col);
        analysis.setyTileToAnalyze(row);
        proc=new AnalysisProcess(sar,Float.parseFloat(sar.getENL()),analysis,0,0,null);
        proc.addProcessListener(this);
        proc.call();
      }
    }
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
    return false;
  }
 finally {
  }
  return true;
}",0.9663247532417264
175084,"/** 
 * Exec the analysis process
 */
public Results call(){
  final Thread currentThread=Thread.currentThread();
  final String oldName=currentThread.getName();
  currentThread.setName(""String_Node_Str"" + gir.getImId());
  try {
    List<ComplexEditVDSVectorLayer> resultLayers=new ArrayList<>();
    String coastMaskName=analysis.getCoastMask() != null ? analysis.getCoastMask().getFileName() : ""String_Node_Str"";
    String iceMaskName=analysis.getIceMask() != null ? analysis.getIceMask().getFileName() : ""String_Node_Str"";
    notifyStartProcessListener(""String_Node_Str"" + coastMaskName + ""String_Node_Str""+ iceMaskName);
    SarImageReader reader=((SarImageReader)gir);
    String[] thresholdsString=StringUtils.join(analysis.getThresholdsParams(),""String_Node_Str"").split(""String_Node_Str"");
    BlackBorderAnalysis blackBorderAnalysis=runBBAnalysis();
    analysis.setBlackBorderAnalysis(blackBorderAnalysis);
    int numberofbands=gir.getNBand();
    int[] bands=new int[numberofbands];
    int noiseFloor=SumoPlatform.getApplication().getConfiguration().getNoiseFloor(0);
    int thresPixelMin=SumoPlatform.getApplication().getConfiguration().getThreshMinPixelValue(500);
    final KDistributionEstimation kdist=new KDistributionEstimation(ENL,noiseFloor,thresPixelMin);
    DetectedPixels mergePixels=new DetectedPixels(reader.getRangeSpacing(),reader.getAzimuthSpacing());
    DetectedPixels banddetectedpixels[]=new DetectedPixels[numberofbands];
    String timeStampStart=reader.getTimeStampStart();
    double azimuth=reader.getAzimuthSpacing();
    int xtileSize=analysis.getRealSizeX();
    int ytileSize=analysis.getRealSizeY();
    try {
      for (int band=0; band < numberofbands && !stop; band++) {
        notifyAnalysisBand(new StringBuilder().append(""String_Node_Str"").append(gir.getBandName(band)).toString());
        int vTiles=analysis.getVerTiles();
        notifyVDSAnalysis(""String_Node_Str"",vTiles);
        analysis.addProgressListener(this);
        banddetectedpixels[band]=analysis.analyse(kdist,band);
        if (numPointLimit != 0 && banddetectedpixels[band].getAllDetectedPixels().size() > numPointLimit) {
          logger.warn(""String_Node_Str"");
          return null;
        }
        if (mergePixels == null) {
          mergePixels=banddetectedpixels[band];
        }
 else {
          mergePixels.merge(banddetectedpixels[band]);
        }
        bands[band]=band;
        String polarization=reader.getBands()[band];
        if (numberofbands < 1 || displaybandanalysis) {
          notifyAgglomerating(new StringBuilder().append(""String_Node_Str"").append(polarization).toString());
          Boat[] boats=null;
          if (agglomerationMethodology.startsWith(""String_Node_Str"")) {
            banddetectedpixels[band].agglomerate();
            banddetectedpixels[band].computeBoatsAttributes(polarization);
          }
 else {
            if (stop)             break;
            boats=analysis.agglomerateNeighbours(banddetectedpixels[band],neighbouringDistance,neighbourTilesize,removelandconnectedpixels,(analysis.getCoastMask() != null) ? analysis.getCoastMask() : null,kdist,polarization,band);
          }
          String layerName=new StringBuilder(""String_Node_Str"").append(polarization).append(""String_Node_Str"").append(analysis.getThresholdParam(polarization)).toString();
          ComplexEditVDSVectorLayer vdsanalysisLayer=new ComplexEditVDSVectorLayer(LayerManager.getIstanceManager().getCurrentImageLayer(),layerName,""String_Node_Str"",new GeometryImage(""String_Node_Str"",""String_Node_Str"",timeStampStart,azimuth,boats),thresholdsString,ENL,buffer,bufferedMaskName,""String_Node_Str"" + band);
          vdsanalysisLayer.addDetectedPixels(banddetectedpixels[band].getAllDetectedPixels(),display);
          if (!agglomerationMethodology.startsWith(""String_Node_Str"")) {
            vdsanalysisLayer.addThreshAggPixels(banddetectedpixels[band].getThresholdaggregatePixels(),display);
            vdsanalysisLayer.addThresholdPixels(banddetectedpixels[band].getThresholdclipPixels(),display);
          }
          notifyCalcAzimuth(""String_Node_Str"");
          AzimuthAmbiguity azimuthAmbiguity=new AzimuthAmbiguity(boats,(SarImageReader)gir,band);
          azimuthAmbiguity.process();
          List<Geometry> az=azimuthAmbiguity.getAmbiguityboatgeometry();
          vdsanalysisLayer.addAzimuthAmbiguities(az,display);
          if (gir instanceof Sentinel1) {
            if (((Sentinel1)gir).getInstumentationMode().equalsIgnoreCase(""String_Node_Str"") || ((Sentinel1)gir).getInstumentationMode().equalsIgnoreCase(""String_Node_Str"")) {
              notifyCalcAzimuth(""String_Node_Str"");
              S1ArtefactsAmbiguity arAmbiguity=new S1ArtefactsAmbiguity(boats,(SarImageReader)gir,band);
              arAmbiguity.process();
              List<Geometry> artefactsA=arAmbiguity.getAmbiguityboatgeometry();
              vdsanalysisLayer.addArtefactsAmbiguities(artefactsA,display);
            }
          }
          if ((analysis.getCoastMask() != null)) {
            vdsanalysisLayer.addGeometries(""String_Node_Str"",Color.BLUE,1,GeometryImage.POLYGON,analysis.getCoastMask().getMaskGeometries(),true);
          }
          vdsanalysisLayer.addGeometries(""String_Node_Str"",new Color(0xFF00FF),1,GeometryImage.LINESTRING,GeometryExtractor.getTiles(gir.getWidth(),gir.getHeight(),xtileSize,ytileSize),false);
          notifyLayerReady(vdsanalysisLayer);
          resultLayers.add(vdsanalysisLayer);
        }
      }
      if (stop) {
        return null;
      }
      if (bands.length > 1) {
        notifyAgglomerating(""String_Node_Str"");
        Boat[] boats=null;
        if (agglomerationMethodology.startsWith(""String_Node_Str"")) {
          mergePixels.agglomerate();
          mergePixels.computeBoatsAttributes(""String_Node_Str"");
        }
 else {
          boats=analysis.agglomerateNeighbours(mergePixels,neighbouringDistance,neighbourTilesize,removelandconnectedpixels,(analysis.getCoastMask() != null) ? analysis.getCoastMask() : null,kdist,""String_Node_Str"",bands);
        }
        if (stop) {
          return null;
        }
        ComplexEditVDSVectorLayer vdsanalysisLayer=new ComplexEditVDSVectorLayer(LayerManager.getIstanceManager().getCurrentImageLayer(),""String_Node_Str"",""String_Node_Str"",new GeometryImage(""String_Node_Str"",""String_Node_Str"",timeStampStart,azimuth,boats),thresholdsString,ENL,buffer,bufferedMaskName,""String_Node_Str"");
        boolean display=SumoPlatform.getApplication().getConfiguration().getDisplayPixel();
        if (!agglomerationMethodology.startsWith(""String_Node_Str"")) {
          vdsanalysisLayer.addThreshAggPixels(mergePixels.getThresholdaggregatePixels(),display);
          vdsanalysisLayer.addThresholdPixels(mergePixels.getThresholdclipPixels(),display);
        }
        vdsanalysisLayer.addDetectedPixels(mergePixels.getAllDetectedPixels(),display);
        if ((analysis.getCoastMask() != null)) {
          vdsanalysisLayer.addGeometries(""String_Node_Str"",new Color(0x0000FF),1,GeometryImage.POLYGON,analysis.getCoastMask().getMaskGeometries(),true);
        }
        vdsanalysisLayer.addGeometries(""String_Node_Str"",new Color(0xFF00FF),1,GeometryImage.LINESTRING,GeometryExtractor.getTiles(gir.getWidth(),gir.getHeight(),xtileSize,ytileSize),false);
        notifyCalcAzimuth(""String_Node_Str"");
        AzimuthAmbiguity azimuthAmbiguity=new AzimuthAmbiguity(boats,(SarImageReader)gir,bands);
        azimuthAmbiguity.process();
        List<Geometry> az=azimuthAmbiguity.getAmbiguityboatgeometry();
        vdsanalysisLayer.addAzimuthAmbiguities(az,display);
        if (gir instanceof Sentinel1) {
          if (((Sentinel1)gir).getInstumentationMode().equalsIgnoreCase(""String_Node_Str"") || ((Sentinel1)gir).getInstumentationMode().equalsIgnoreCase(""String_Node_Str"")) {
            notifyCalcAzimuth(""String_Node_Str"");
            S1ArtefactsAmbiguity arAmbiguity=new S1ArtefactsAmbiguity(boats,(SarImageReader)gir,bands);
            arAmbiguity.process();
            List<Geometry> artefactsA=arAmbiguity.getAmbiguityboatgeometry();
            vdsanalysisLayer.addArtefactsAmbiguities(artefactsA,display);
          }
        }
        notifyLayerReady(vdsanalysisLayer);
        resultLayers.add(vdsanalysisLayer);
      }
      notifyEndProcessListener();
    }
 catch (    Exception ee) {
      ee.printStackTrace();
    }
 finally {
      if (this.listeners != null)       removeAllProcessListener();
    }
    return new Results(reader,resultLayers);
  }
  finally {
    currentThread.setName(oldName);
  }
}","/** 
 * Exec the analysis process
 */
public Results call(){
  final Thread currentThread=Thread.currentThread();
  final String oldName=currentThread.getName();
  currentThread.setName(""String_Node_Str"" + gir.getImId());
  try {
    List<ComplexEditVDSVectorLayer> resultLayers=new ArrayList<>();
    String coastMaskName=analysis.getCoastMask() != null ? analysis.getCoastMask().getFileName() : ""String_Node_Str"";
    String iceMaskName=analysis.getIceMask() != null ? analysis.getIceMask().getFileName() : ""String_Node_Str"";
    notifyStartProcessListener(""String_Node_Str"" + coastMaskName + ""String_Node_Str""+ iceMaskName);
    SarImageReader reader=((SarImageReader)gir);
    String[] thresholdsString=StringUtils.join(analysis.getThresholdsParams(),""String_Node_Str"").split(""String_Node_Str"");
    BlackBorderAnalysis blackBorderAnalysis=runBBAnalysis();
    analysis.setBlackBorderAnalysis(blackBorderAnalysis);
    int numberofbands=gir.getNBand();
    int[] bands=new int[numberofbands];
    int noiseFloor=SumoPlatform.getApplication().getConfiguration().getNoiseFloor(0);
    int thresPixelMin=SumoPlatform.getApplication().getConfiguration().getThreshMinPixelValue(500);
    final KDistributionEstimation kdist=new KDistributionEstimation(ENL,noiseFloor,thresPixelMin);
    DetectedPixels mergePixels=new DetectedPixels(reader.getRangeSpacing(),reader.getAzimuthSpacing());
    DetectedPixels banddetectedpixels[]=new DetectedPixels[numberofbands];
    String timeStampStart=reader.getTimeStampStart();
    double azimuth=reader.getAzimuthSpacing();
    int xtileSize=analysis.getRealSizeX();
    int ytileSize=analysis.getRealSizeY();
    try {
      for (int band=0; band < numberofbands && !stop; band++) {
        notifyAnalysisBand(new StringBuilder().append(""String_Node_Str"").append(gir.getBandName(band)).toString());
        int vTiles=analysis.getVerTiles();
        notifyVDSAnalysis(""String_Node_Str"",vTiles);
        analysis.addProgressListener(this);
        banddetectedpixels[band]=analysis.analyse(kdist,band);
        if (numPointLimit != 0 && banddetectedpixels[band].getAllDetectedPixels().size() > numPointLimit) {
          logger.warn(""String_Node_Str"");
          return null;
        }
        if (mergePixels == null) {
          mergePixels=banddetectedpixels[band];
        }
 else {
          mergePixels.merge(banddetectedpixels[band]);
        }
        bands[band]=band;
        String polarization=reader.getBands()[band];
        if (numberofbands < 1 || displaybandanalysis) {
          notifyAgglomerating(new StringBuilder().append(""String_Node_Str"").append(polarization).toString());
          Boat[] boats=null;
          if (agglomerationMethodology.startsWith(""String_Node_Str"")) {
            banddetectedpixels[band].agglomerate();
            banddetectedpixels[band].computeBoatsAttributes(polarization);
          }
 else {
            if (stop)             break;
            boats=analysis.agglomerateNeighbours(banddetectedpixels[band],neighbouringDistance,neighbourTilesize,removelandconnectedpixels,(analysis.getCoastMask() != null) ? analysis.getCoastMask() : null,kdist,polarization,band);
          }
          String layerName=new StringBuilder(""String_Node_Str"").append(polarization).append(""String_Node_Str"").append(analysis.getThresholdParam(polarization)).toString();
          ComplexEditVDSVectorLayer vdsanalysisLayer=new ComplexEditVDSVectorLayer(LayerManager.getIstanceManager().getCurrentImageLayer(),layerName,""String_Node_Str"",new GeometryImage(""String_Node_Str"",""String_Node_Str"",timeStampStart,azimuth,boats),thresholdsString,ENL,buffer,bufferedMaskName,""String_Node_Str"" + band);
          vdsanalysisLayer.addDetectedPixels(banddetectedpixels[band].getAllDetectedPixels(),display);
          if (!agglomerationMethodology.startsWith(""String_Node_Str"")) {
            vdsanalysisLayer.addThreshAggPixels(banddetectedpixels[band].getThresholdaggregatePixels(),display);
            vdsanalysisLayer.addThresholdPixels(banddetectedpixels[band].getThresholdclipPixels(),display);
          }
          notifyCalcAzimuth(""String_Node_Str"");
          AzimuthAmbiguity azimuthAmbiguity=new AzimuthAmbiguity(boats,(SarImageReader)gir,band);
          azimuthAmbiguity.process();
          List<Geometry> az=azimuthAmbiguity.getAmbiguityboatgeometry();
          vdsanalysisLayer.addAzimuthAmbiguities(az,display);
          if (gir instanceof Sentinel1) {
            if (((Sentinel1)gir).getInstumentationMode().equalsIgnoreCase(""String_Node_Str"") || ((Sentinel1)gir).getInstumentationMode().equalsIgnoreCase(""String_Node_Str"")) {
              notifyCalcAzimuth(""String_Node_Str"");
              S1ArtefactsAmbiguity arAmbiguity=new S1ArtefactsAmbiguity(boats,(SarImageReader)gir,band);
              arAmbiguity.process();
              List<Geometry> artefactsA=arAmbiguity.getAmbiguityboatgeometry();
              vdsanalysisLayer.addArtefactsAmbiguities(artefactsA,display);
            }
          }
          if ((analysis.getCoastMask() != null)) {
            vdsanalysisLayer.addGeometries(""String_Node_Str"",Color.BLUE,1,GeometryImage.POLYGON,analysis.getCoastMask().getMaskGeometries(),true);
          }
          vdsanalysisLayer.addGeometries(""String_Node_Str"",new Color(0xFF00FF),1,GeometryImage.LINESTRING,GeometryExtractor.getTiles(gir.getWidth(),gir.getHeight(),xtileSize,ytileSize),false);
          notifyLayerReady(vdsanalysisLayer);
          resultLayers.add(vdsanalysisLayer);
        }
      }
      if (stop) {
        return null;
      }
      if (bands.length > 1) {
        notifyAgglomerating(""String_Node_Str"");
        Boat[] boats=null;
        if (agglomerationMethodology.startsWith(""String_Node_Str"")) {
          mergePixels.agglomerate();
          mergePixels.computeBoatsAttributes(""String_Node_Str"");
        }
 else {
          boats=analysis.agglomerateNeighbours(mergePixels,neighbouringDistance,neighbourTilesize,removelandconnectedpixels,(analysis.getCoastMask() != null) ? analysis.getCoastMask() : null,kdist,""String_Node_Str"",bands);
        }
        if (stop) {
          return null;
        }
        ComplexEditVDSVectorLayer vdsanalysisLayer=new ComplexEditVDSVectorLayer(LayerManager.getIstanceManager().getCurrentImageLayer(),""String_Node_Str"",""String_Node_Str"",new GeometryImage(""String_Node_Str"",""String_Node_Str"",timeStampStart,azimuth,boats),thresholdsString,ENL,buffer,bufferedMaskName,""String_Node_Str"");
        boolean display=SumoPlatform.getApplication().getConfiguration().getDisplayPixel();
        if (!agglomerationMethodology.startsWith(""String_Node_Str"")) {
          vdsanalysisLayer.addThreshAggPixels(mergePixels.getThresholdaggregatePixels(),display);
          vdsanalysisLayer.addThresholdPixels(mergePixels.getThresholdclipPixels(),display);
        }
        vdsanalysisLayer.addDetectedPixels(mergePixels.getAllDetectedPixels(),display);
        if ((analysis.getCoastMask() != null)) {
          vdsanalysisLayer.addGeometries(""String_Node_Str"",new Color(0x0000FF),1,GeometryImage.POLYGON,analysis.getCoastMask().getMaskGeometries(),true);
        }
        vdsanalysisLayer.addGeometries(""String_Node_Str"",new Color(0xFF00FF),1,GeometryImage.LINESTRING,GeometryExtractor.getTiles(gir.getWidth(),gir.getHeight(),xtileSize,ytileSize),false);
        notifyCalcAzimuth(""String_Node_Str"");
        AzimuthAmbiguity azimuthAmbiguity=new AzimuthAmbiguity(boats,(SarImageReader)gir,bands);
        azimuthAmbiguity.process();
        List<Geometry> az=azimuthAmbiguity.getAmbiguityboatgeometry();
        vdsanalysisLayer.addAzimuthAmbiguities(az,display);
        if (gir instanceof Sentinel1) {
          if (((Sentinel1)gir).getInstumentationMode().equalsIgnoreCase(""String_Node_Str"")) {
            notifyCalcAzimuth(""String_Node_Str"");
            S1ArtefactsAmbiguity arAmbiguity=new S1ArtefactsAmbiguity(boats,(SarImageReader)gir,bands);
            arAmbiguity.process();
            List<Geometry> artefactsA=arAmbiguity.getAmbiguityboatgeometry();
            vdsanalysisLayer.addArtefactsAmbiguities(artefactsA,display);
          }
        }
        notifyLayerReady(vdsanalysisLayer);
        resultLayers.add(vdsanalysisLayer);
      }
      notifyEndProcessListener();
    }
 catch (    Exception ee) {
      ee.printStackTrace();
    }
 finally {
      if (this.listeners != null)       removeAllProcessListener();
    }
    return new Results(reader,resultLayers);
  }
  finally {
    currentThread.setName(oldName);
  }
}",0.9916822867853796
175085,"/** 
 * @param shpInput
 * @param bbox
 * @param transform
 * @return
 */
public static GeometryImage createIntersectedLayer(File shpInput,Polygon bbox,GeoTransform transform){
  GeometryImage glout=null;
  DataStore dataStore=null;
  try {
    if (shpInput != null) {
      Map<String,Serializable> params=new HashMap<String,Serializable>();
      params.put(""String_Node_Str"",shpInput.toURI().toURL());
      dataStore=DataStoreFinder.getDataStore(params);
      SimpleFeatureSource featureSource=(SimpleFeatureSource)dataStore.getFeatureSource(dataStore.getTypeNames()[0]);
      Polygon imageP=bbox;
      ClipProcess clip=new ClipProcess();
      SimpleFeatureCollection fc=clip.execute(featureSource.getFeatures(),imageP,true);
      if (fc.isEmpty()) {
        return null;
      }
      String[] schemaStr=createSchema(fc.getSchema().getDescriptors());
      String[] types=createTypes(fc.getSchema().getDescriptors());
      String geoName=fc.getSchema().getGeometryDescriptor().getType().getName().toString();
      boolean applayT=false;
      if (transform != null)       applayT=true;
      glout=GeometryImage.createFromSimpleGeometry(imageP,geoName,fc,schemaStr,types,applayT,transform);
      glout.setName(shpInput.getName());
    }
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
    if (dataStore != null)     dataStore.dispose();
  }
  return glout;
}","/** 
 * @param shpInput
 * @param bbox
 * @param transform
 * @return
 */
public static GeometryImage createIntersectedLayer(File shpInput,Polygon bbox,GeoTransform transform){
  GeometryImage glout=null;
  DataStore dataStore=null;
  try {
    if (shpInput != null) {
      Map<String,Serializable> params=new HashMap<String,Serializable>();
      params.put(""String_Node_Str"",shpInput.toURI().toURL());
      dataStore=DataStoreFinder.getDataStore(params);
      SimpleFeatureSource featureSource=(SimpleFeatureSource)dataStore.getFeatureSource(dataStore.getTypeNames()[0]);
      Polygon imageP=bbox;
      ClipProcess clip=new ClipProcess();
      SimpleFeatureCollection fc=clip.execute(featureSource.getFeatures(),imageP,true);
      if (fc.isEmpty()) {
        return null;
      }
      String[] schemaStr=createSchema(fc.getSchema().getDescriptors());
      String[] types=createTypes(fc.getSchema().getDescriptors());
      String geoName=fc.getSchema().getGeometryDescriptor().getType().getName().toString();
      boolean applayT=false;
      if (transform != null)       applayT=true;
      glout=GeometryImage.createFromSimpleGeometry(imageP,geoName,fc,schemaStr,types,applayT,transform);
      glout.setName(shpInput.getName());
      glout.splitMultiPolygons();
    }
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
    if (dataStore != null)     dataStore.dispose();
  }
  return glout;
}",0.98805340829234
175086,"@Override public void render(Object gcC){
  OpenGLContext context=(OpenGLContext)gcC;
  if (!context.isDirty() || SumoPlatform.isBatchMode()) {
    return;
  }
  int x=context.getX();
  int y=context.getY();
  float zoom=context.getZoom();
  float width=context.getWidth() * zoom;
  float height=context.getHeight() * zoom;
  if (glayer != null) {
    List<Geometry> geomList=glayer.getGeometries();
    if (!threshable && geomList != null) {
      if (getType().equalsIgnoreCase(GeometryImage.POINT)) {
switch (this.displaysymbol) {
case point:
{
            GL2ShapesRender.renderPolygons(context,width,height,geomList,this.renderWidth,color);
            if (selectedGeometry != null) {
              GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth,color);
            }
          }
        break;
case circle:
{
        GL2ShapesRender.renderCircle(context,width,height,geomList,selectedGeometry,this.renderWidth,color);
      }
    break;
case square:
{
    GL2ShapesRender.renderSquare(context,width,height,geomList,selectedGeometry,renderWidth,color);
  }
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.POLYGON)) {
for (Geometry tmp : geomList) {
if (tmp instanceof Polygon) {
Polygon polygon=(Polygon)tmp;
if (polygon.getCoordinates().length < 1) {
continue;
}
float rWidth=polygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
int interior=polygon.getNumInteriorRing();
if (interior > 0) {
LineString line=polygon.getExteriorRing();
GL2ShapesRender.drawPoly(context,line.getCoordinates(),width,height,x,y,rWidth,color);
for (int i=0; i < interior; i++) {
LineString line2=polygon.getInteriorRingN(i);
GL2ShapesRender.drawPoly(context,line2.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else {
GL2ShapesRender.drawPoly(context,polygon.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else if (tmp instanceof MultiPolygon) {
MultiPolygon mpolygon=(MultiPolygon)tmp;
if (mpolygon.getCoordinates().length < 1) {
continue;
}
float rWidth=mpolygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
GL2ShapesRender.drawPoly(context,mpolygon.getCoordinates(),width,height,x,y,rWidth,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.LINESTRING)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.MIXED)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof LineString || temp instanceof Polygon) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
 else if (temp instanceof MultiPoint) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
}
 else {
if (getType().equalsIgnoreCase(GeometryImage.POINT) && geomList != null) {
List<Geometry> toVisualize=new ArrayList<>();
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
toVisualize.add(temp);
}
}
switch (this.displaysymbol) {
case point:
{
GL2ShapesRender.renderPolygons(context,width,height,toVisualize,this.renderWidth,color);
if (selectedGeometry != null) {
GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth * 2,color);
}
}
break;
case circle:
{
GL2ShapesRender.renderCircle(context,width,height,toVisualize,selectedGeometry,this.renderWidth,color);
}
break;
case square:
{
GL2ShapesRender.renderSquare(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.POLYGON) || getType().equalsIgnoreCase(GeometryImage.LINESTRING)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.MIXED)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof Polygon || temp instanceof LineString) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
}
}
}
}
}
}","@Override public void render(Object gcC){
  OpenGLContext context=(OpenGLContext)gcC;
  if (!context.isDirty() || SumoPlatform.isBatchMode()) {
    return;
  }
  int x=context.getX();
  int y=context.getY();
  float zoom=context.getZoom();
  float width=context.getWidth() * zoom;
  float height=context.getHeight() * zoom;
  if (glayer != null) {
    List<Geometry> geomList=glayer.getGeometries();
    if (!threshable && geomList != null) {
      if (getType().equalsIgnoreCase(GeometryImage.POINT)) {
switch (this.displaysymbol) {
case point:
{
            GL2ShapesRender.renderPolygons(context,width,height,geomList,this.renderWidth,color);
            if (selectedGeometry != null) {
              GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth,color);
            }
          }
        break;
case circle:
{
        GL2ShapesRender.renderCircle(context,width,height,geomList,selectedGeometry,this.renderWidth,color);
      }
    break;
case square:
{
    GL2ShapesRender.renderSquare(context,width,height,geomList,selectedGeometry,renderWidth,color);
  }
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.POLYGON)) {
for (Geometry tmp : geomList) {
if (tmp instanceof Polygon) {
Polygon polygon=(Polygon)tmp;
if (polygon.getCoordinates().length < 1) {
continue;
}
float rWidth=polygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
int interior=polygon.getNumInteriorRing();
if (interior > 0) {
LineString line=polygon.getExteriorRing();
GL2ShapesRender.drawPoly(context,line.getCoordinates(),width,height,x,y,rWidth,color);
for (int i=0; i < interior; i++) {
LineString line2=polygon.getInteriorRingN(i);
GL2ShapesRender.drawPoly(context,line2.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else {
GL2ShapesRender.drawPoly(context,polygon.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else if (tmp instanceof MultiPolygon) {
MultiPolygon mpolygon=(MultiPolygon)tmp;
if (mpolygon.getCoordinates().length < 1) {
continue;
}
float rWidth=mpolygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
GL2ShapesRender.drawMultiPoly(context,mpolygon,width,height,x,y,rWidth,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.LINESTRING)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.MIXED)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof LineString || temp instanceof Polygon) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
 else if (temp instanceof MultiPoint) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
}
 else {
if (getType().equalsIgnoreCase(GeometryImage.POINT) && geomList != null) {
List<Geometry> toVisualize=new ArrayList<>();
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
toVisualize.add(temp);
}
}
switch (this.displaysymbol) {
case point:
{
GL2ShapesRender.renderPolygons(context,width,height,toVisualize,this.renderWidth,color);
if (selectedGeometry != null) {
GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth * 2,color);
}
}
break;
case circle:
{
GL2ShapesRender.renderCircle(context,width,height,toVisualize,selectedGeometry,this.renderWidth,color);
}
break;
case square:
{
GL2ShapesRender.renderSquare(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.POLYGON) || getType().equalsIgnoreCase(GeometryImage.LINESTRING)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometryImage.MIXED)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof Polygon || temp instanceof LineString) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
}
}
}
}
}
}",0.9981161157732488
175087,"@Override public long readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int img=tiff.read(0,t).getRaster().getSample(0,0,1);
    int real=tiff.read(0,t).getRaster().getSample(0,0,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
    ex.printStackTrace();
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return -1;
}","@Override public long readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int img=tiff.read(0,t).getRaster().getSample(0,0,1);
    int real=tiff.read(0,t).getRaster().getSample(0,0,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(""String_Node_Str"" + ex.getMessage());
  }
catch (  IllegalArgumentException iae) {
    logger.warn(""String_Node_Str"" + iae.getMessage());
  }
 finally {
  }
  return -1;
}",0.8744710860366713
175088,"@Override public void render(Object glContext){
  OpenGLContext context=(OpenGLContext)glContext;
  if (activeGir != null) {
    if (torescale) {
      torescale=false;
      tcm.clear();
    }
    GL gl=context.getGL();
    updateFutures(gl);
    float zoom=context.getZoom();
    int width=context.getWidth();
    int height=context.getHeight();
    int x=context.getX();
    int y=context.getY();
    int xx=(int)(x + xpadding);
    int yy=(int)(y + ypadding);
    int max=maxnumberoftiles;
    Cache c=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
    gl.getGL2().glTexEnvi(GL2.GL_TEXTURE_ENV,GL2.GL_TEXTURE_ENV_MODE,GL2.GL_REPLACE);
    if (zoom >= 1) {
      curlevel=(int)Math.sqrt(zoom + 1);
      for (int lll=maxlevels; (lll > curlevel - 1); lll--) {
        if (lll > maxlevels) {
          break;
        }
        lll+=increaseLevel;
        if (lll < 0) {
          continue;
        }
        if (this.mylevel != curlevel) {
          this.mylevel=curlevel;
          poolExcutorService.shutdown();
          poolExcutorService=new ThreadPoolExecutor(1,poolSize,100,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
        }
        int w0=xx / ((1 << lll) << 8);
        int h0=yy / ((1 << lll) << 8);
        final String initfile=new StringBuffer(""String_Node_Str"").append((int)lll).append(""String_Node_Str"").append((activeGir instanceof TiledBufferedImage ? ((TiledBufferedImage)activeGir).getDescription() + ""String_Node_Str"" : ""String_Node_Str"")).toString();
        for (int k=0; k < max; k++) {
          for (int j=0; j < max; j++) {
            if (j + h0 < 0) {
              continue;
            }
            for (int i=0; i < max; i++) {
              if (i + w0 < 0) {
                continue;
              }
              if (arrayReadTilesOrder[i][j] == k) {
                float ymin=(float)(((j + h0) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - yy) / (height * zoom));
                float ymax=(float)(((j + h0 + 1) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - yy) / (height * zoom));
                float xmin=(float)(((i + w0) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - xx) / (1d * width * zoom));
                float xmax=(float)(((i + w0 + 1) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - xx) / (1d * width * zoom));
                if (ymin > 1 || ymax < 0) {
                  continue;
                }
                if (xmin > 1 || xmax < 0) {
                  continue;
                }
                String file=new StringBuffer(initfile).append(getBandFolder(activeBand)).append(""String_Node_Str"").append((i + w0)).append(""String_Node_Str"").append((j + h0)).append(""String_Node_Str"").toString();
                if (!tryMemoryCache(gl,file,xmin,xmax,ymin,ymax)) {
                  if (!tryFileCache(gl,file,lll,(i + w0),(j + h0),xmin,xmax,ymin,ymax)) {
                    if (curlevel == 0 && lll == 0) {
                      addTileToQueue(initfile,lll,(i + w0),(j + h0));
                    }
 else                     if (curlevel == lll) {
                      addTileToQueue(initfile,lll,(i + w0),(j + h0));
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
 else     if (zoom > 0) {
      curlevel=0;
      int w0=xx / Constant.TILE_SIZE_IMG_LAYER;
      int h0=yy / Constant.TILE_SIZE_IMG_LAYER;
      final String initfile=new StringBuilder(c.getPath().toString()).append(""String_Node_Str"").append((activeGir instanceof TiledBufferedImage ? ((TiledBufferedImage)activeGir).getDescription() + ""String_Node_Str"" : ""String_Node_Str"")).toString();
      for (int j=0; j < max; j++) {
        if (j + h0 < 0) {
          continue;
        }
        for (int i=0; i < max; i++) {
          if (i + w0 < 0) {
            continue;
          }
          float ymin=(float)(((j + h0) * Constant.OVERVIEW_SIZE_DOUBLE - yy) / (height * zoom));
          float ymax=(float)(((j + h0 + 1) * Constant.OVERVIEW_SIZE_DOUBLE - yy) / (height * zoom));
          float xmin=(float)(((i + w0) * Constant.OVERVIEW_SIZE_DOUBLE - xx) / (1d * width * zoom));
          float xmax=(float)(((i + w0 + 1) * Constant.OVERVIEW_SIZE_DOUBLE - xx) / (1d * width * zoom));
          if (ymin > 1 || ymax < 0) {
            continue;
          }
          if (xmin > 1 || xmax < 0) {
            continue;
          }
          String file=new StringBuilder(initfile).append(getBandFolder(activeBand)).append(""String_Node_Str"").append((i + w0)).append(""String_Node_Str"").append((j + h0)).append(""String_Node_Str"").toString();
          if (!tryMemoryCache(gl,file,xmin,xmax,ymin,ymax)) {
            if (!tryFileCache(gl,file,0,(i + w0),(j + h0),xmin,xmax,ymin,ymax)) {
              addTileToQueue(initfile,0,(i + w0),(j + h0));
            }
          }
        }
      }
    }
    displayDownloading(futures.size());
    SumoPlatform.getApplication().refresh();
    if (this.disposed) {
      disposeSync();
    }
  }
}","@Override public void render(Object glContext){
  OpenGLContext context=(OpenGLContext)glContext;
  if (activeGir != null) {
    if (torescale) {
      torescale=false;
      tcm.clear();
    }
    GL gl=context.getGL();
    updateFutures(gl);
    float zoom=context.getZoom();
    int width=context.getWidth();
    int height=context.getHeight();
    int x=context.getX();
    int y=context.getY();
    int xx=(int)(x + xpadding);
    int yy=(int)(y + ypadding);
    int max=maxnumberoftiles;
    Cache c=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
    gl.getGL2().glTexEnvi(GL2.GL_TEXTURE_ENV,GL2.GL_TEXTURE_ENV_MODE,GL2.GL_REPLACE);
    if (zoom >= 1) {
      curlevel=(int)Math.sqrt(zoom + 1);
      for (int lll=maxlevels; (lll > curlevel - 1); lll--) {
        if (lll > maxlevels) {
          break;
        }
        lll+=increaseLevel;
        if (lll < 0) {
          continue;
        }
        if (this.mylevel != curlevel) {
          this.mylevel=curlevel;
          poolExcutorService.shutdown();
          poolExcutorService=new ThreadPoolExecutor(1,poolSize,1000,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
        }
        int w0=xx / ((1 << lll) << 8);
        int h0=yy / ((1 << lll) << 8);
        final String initfile=new StringBuffer(File.separator).append((int)lll).append(File.separator).append((activeGir instanceof TiledBufferedImage ? ((TiledBufferedImage)activeGir).getDescription() + File.separator : ""String_Node_Str"")).toString();
        for (int k=0; k < max; k++) {
          for (int j=0; j < max; j++) {
            if (j + h0 < 0) {
              continue;
            }
            for (int i=0; i < max; i++) {
              if (i + w0 < 0) {
                continue;
              }
              if (arrayReadTilesOrder[i][j] == k) {
                float ymin=(float)(((j + h0) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - yy) / (height * zoom));
                float ymax=(float)(((j + h0 + 1) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - yy) / (height * zoom));
                float xmin=(float)(((i + w0) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - xx) / (1d * width * zoom));
                float xmax=(float)(((i + w0 + 1) * Constant.TILE_SIZE_DOUBLE * (1 << lll) - xx) / (1d * width * zoom));
                if (ymin > 1 || ymax < 0) {
                  continue;
                }
                if (xmin > 1 || xmax < 0) {
                  continue;
                }
                String file=new StringBuffer(initfile).append(getBandFolder(activeBand)).append(File.separator).append((i + w0)).append(""String_Node_Str"").append((j + h0)).append(""String_Node_Str"").toString();
                Texture t=tryMemoryCache(gl,file,xmin,xmax,ymin,ymax);
                if (t == null) {
                  BufferedImage tile=tryFileCache(gl,file,lll,(i + w0),(j + h0),xmin,xmax,ymin,ymax);
                  if (tile != null) {
                    t=AWTTextureIO.newTexture(gl.getGLProfile(),tile,false);
                    tcm.add(file,t);
                  }
                }
                if (t != null) {
                  bindTexture(gl,t,xmin,xmax,ymin,ymax);
                }
 else                 if ((curlevel == 0 && lll == 0) || (curlevel == lll)) {
                  addTileToQueue(initfile,lll,(i + w0),(j + h0));
                }
              }
            }
          }
        }
      }
    }
 else     if (zoom > 0) {
      curlevel=0;
      int w0=xx / Constant.TILE_SIZE_IMG_LAYER;
      int h0=yy / Constant.TILE_SIZE_IMG_LAYER;
      final String initfile=new StringBuilder(c.getPath().toString()).append(""String_Node_Str"").append((activeGir instanceof TiledBufferedImage ? ((TiledBufferedImage)activeGir).getDescription() + ""String_Node_Str"" : ""String_Node_Str"")).toString();
      for (int j=0; j < max; j++) {
        if (j + h0 < 0) {
          continue;
        }
        for (int i=0; i < max; i++) {
          if (i + w0 < 0) {
            continue;
          }
          float ymin=(float)(((j + h0) * Constant.OVERVIEW_SIZE_DOUBLE - yy) / (height * zoom));
          float ymax=(float)(((j + h0 + 1) * Constant.OVERVIEW_SIZE_DOUBLE - yy) / (height * zoom));
          float xmin=(float)(((i + w0) * Constant.OVERVIEW_SIZE_DOUBLE - xx) / (1d * width * zoom));
          float xmax=(float)(((i + w0 + 1) * Constant.OVERVIEW_SIZE_DOUBLE - xx) / (1d * width * zoom));
          if (ymin > 1 || ymax < 0) {
            continue;
          }
          if (xmin > 1 || xmax < 0) {
            continue;
          }
          String file=new StringBuilder(initfile).append(getBandFolder(activeBand)).append(""String_Node_Str"").append((i + w0)).append(""String_Node_Str"").append((j + h0)).append(""String_Node_Str"").toString();
          Texture t=tryMemoryCache(gl,file,xmin,xmax,ymin,ymax);
          if (t == null) {
            BufferedImage tile=tryFileCache(gl,file,0,(i + w0),(j + h0),xmin,xmax,ymin,ymax);
            if (tile != null) {
              t=AWTTextureIO.newTexture(gl.getGLProfile(),tile,false);
              tcm.add(file,t);
            }
          }
          if (t != null) {
            bindTexture(gl,t,xmin,xmax,ymin,ymax);
          }
 else {
            addTileToQueue(initfile,0,(i + w0),(j + h0));
          }
        }
      }
    }
    displayDownloading(futures.size());
    SumoPlatform.getApplication().refresh();
    if (this.disposed) {
      disposeSync();
    }
  }
}",0.8518625469246318
175089,"private boolean tryFileCache(GL gl,String file,int level,int i,int j,float xmin,float xmax,float ymin,float ymax){
  String tileId=new StringBuilder(""String_Node_Str"").append(level).append(""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).toString();
  Cache cacheInstance=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
  boolean ok=true;
  if (cacheInstance.contains(file) & !submitedTiles.contains(tileId)) {
    BufferedImage temp=null;
    try {
      try {
        temp=ImageIO.read(cacheInstance.newFile(file));
      }
 catch (      Exception ex) {
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
        temp=ImageIO.read(cacheInstance.newFile(file));
      }
      if (temp == null) {
        ok=false;
      }
    }
 catch (    Exception ex) {
      ok=false;
      logger.warn(""String_Node_Str"" + file + ""String_Node_Str""+ ex.getMessage());
    }
 finally {
      pngReader.dispose();
    }
    if (ok) {
      if (temp.getColorModel().getNumComponents() == 1) {
        temp=rescale.filter(temp,rescale.createCompatibleDestImage(temp,temp.getColorModel()));
      }
      Texture t=AWTTextureIO.newTexture(gl.getGLProfile(),temp,false);
      tcm.add(file,t);
      bindTexture(gl,t,xmin,xmax,ymin,ymax);
    }
  }
 else {
    ok=false;
  }
  return ok;
}","/** 
 * search for tiles in the file cache
 * @param gl
 * @param file
 * @param level
 * @param i
 * @param j
 * @param xmin
 * @param xmax
 * @param ymin
 * @param ymax
 * @return
 */
private BufferedImage tryFileCache(GL gl,String file,int level,int i,int j,float xmin,float xmax,float ymin,float ymax){
  String tileId=new StringBuilder(""String_Node_Str"").append(level).append(""String_Node_Str"").append(getBandFolder(activeBand)).append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j).toString();
  Cache cacheInstance=CacheManager.getCacheInstance(activeGir.getDisplayName(activeBand));
  BufferedImage temp=null;
  if (cacheInstance.contains(file) & !submitedTiles.contains(tileId)) {
    try {
      try {
        temp=ImageIO.read(cacheInstance.newFile(file));
      }
 catch (      Exception ex) {
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
        temp=ImageIO.read(cacheInstance.newFile(file));
      }
    }
 catch (    Exception ex) {
      logger.warn(""String_Node_Str"" + file + ""String_Node_Str""+ ex.getMessage());
      return null;
    }
 finally {
      pngReader.dispose();
    }
    if (temp.getColorModel().getNumComponents() == 1) {
      temp=rescale.filter(temp,rescale.createCompatibleDestImage(temp,temp.getColorModel()));
    }
  }
  return temp;
}",0.5748168817579351
175090,"private void displayDownloading(int size){
  GeoImageViewerView view=((GeoImageViewerView)SumoPlatform.getApplication().getMainView());
  if (currentSize != size) {
    if (size == 0) {
      view.setInfo(""String_Node_Str"",-1);
    }
 else {
      view.setInfo(new StringBuilder(""String_Node_Str"").append(size).toString());
    }
    currentSize=size;
  }
}","private void displayDownloading(int size){
  if (currentSize != size) {
    if (size == 0) {
      SumoPlatform.getApplication().setMessageInfo(""String_Node_Str"");
    }
 else {
      SumoPlatform.getApplication().setMessageInfo(new StringBuilder(""String_Node_Str"").append(size).toString());
    }
    currentSize=size;
  }
}",0.718475073313783
175091,"private boolean tryMemoryCache(GL gl,String file,float xmin,float xmax,float ymin,float ymax){
  Texture t=tcm.getTexture(file);
  if (t != null) {
    bindTexture(gl,t,xmin,xmax,ymin,ymax);
    return true;
  }
  return false;
}","/** 
 * search for the tiles on memory
 * @param gl
 * @param file
 * @param xmin
 * @param xmax
 * @param ymin
 * @param ymax
 * @return
 */
private Texture tryMemoryCache(GL gl,String file,float xmin,float xmax,float ymin,float ymax){
  Texture t=tcm.getTexture(file);
  return t;
}",0.4951267056530214
175092,"/** 
 * @param kdist
 * @param thresholdBandParams
 * @return
 * @throws IOException
 */
public DetectedPixels analyse(final KDistributionEstimation kdist,final int band) throws IOException {
  DetectedPixels dpixels=new DetectedPixels(gir.getRangeSpacing(),gir.getAzimuthSpacing());
  String bb=((SarImageReader)gir).getBands()[band];
  float thresholdBand=this.thresholdsBandParams.get(bb);
  int xLeftTile=0;
  int xRightTile=0;
  int yTopTile=0;
  int yBottomTile=0;
  double[][][] tileStat=new double[verTilesImage][horTilesImage][5];
  int dy=0;
  for (int rowIndex=0; rowIndex < verTilesImage; rowIndex++) {
    if (isAnalyseSingleTile()) {
      if (rowIndex != yTileToAnalyze)       continue;
    }
    notifyStartNextRowProcessing(rowIndex);
    if (rowIndex == verTilesImage - 1) {
      dy=gir.getHeight() - ((verTilesImage - 1) * realSizeY) - realSizeY;
    }
    xLeftTile=0;
    xRightTile=0;
    yTopTile=rowIndex * realSizeY;
    yBottomTile=yTopTile + realSizeY + dy;
    int dx=0;
    for (int colIndex=0; colIndex < horTilesImage; colIndex++) {
      if (isAnalyseSingleTile()) {
        if (colIndex != xTileToAnalyze)         continue;
      }
      if (colIndex == horTilesImage - 1) {
        dx=(gir.getWidth() - ((horTilesImage - 1) * realSizeX)) - realSizeX;
      }
      xLeftTile=colIndex * realSizeX;
      xRightTile=xLeftTile + realSizeX + dx;
      boolean containsMinPixelValid=false;
      int[] maskdata=null;
      if (coastMask == null || !intersects(xLeftTile,xRightTile,yTopTile,yBottomTile)) {
        maskdata=null;
      }
 else {
        if (includes(xLeftTile,xRightTile,yTopTile,yBottomTile))         continue;
        maskdata=createDataMask(xLeftTile,yTopTile,realSizeX,realSizeY,dx,dy);
        int inValidPixelCount=0;
        for (int count=0; count < maskdata.length; count++)         inValidPixelCount+=maskdata[count];
        containsMinPixelValid=((double)inValidPixelCount / maskdata.length) <= MIN_TRESH_FOR_ANALYSIS;
        if (!containsMinPixelValid) {
          maskdata=createDataMask(xLeftTile - 30,yTopTile - 30,realSizeX + 30,realSizeY + 30,dx,dy);
          inValidPixelCount=0;
          for (int count=0; count < maskdata.length; count++)           inValidPixelCount+=maskdata[count];
          containsMinPixelValid=((double)inValidPixelCount / maskdata.length) <= MIN_TRESH_FOR_ANALYSIS;
        }
      }
      if (containsMinPixelValid || maskdata == null) {
        TileAnalysis bbAnalysis=null;
        if (blackBorderAnalysis != null)         bbAnalysis=blackBorderAnalysis.getAnalysisTile(rowIndex,colIndex);
        int[] data=gir.readTile(xLeftTile,yTopTile,realSizeX + dx,realSizeY + dy,band);
        kdist.setImageData(xLeftTile,yTopTile,realSizeX + dx,realSizeY + dy,band,bbAnalysis);
        kdist.estimate(maskdata,data);
        double[] thresh=kdist.getDetectThresh();
        tileStat[rowIndex][0]=kdist.getTileStat();
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,thresh);
        for (int k=0; k < (realSizeY + dy); k++) {
          for (int h=0; h < (realSizeX + dx); h++) {
            if (maskdata == null || (maskdata[h + ((realSizeX + dx) * k)] == 0)) {
              int subwindow=1;
              if (h < (realSizeX + dx) / 2) {
                if (k < (realSizeY + dy) / 2) {
                  subwindow=1;
                }
 else {
                  subwindow=3;
                }
              }
 else {
                if (k < (realSizeY + dy) / 2) {
                  subwindow=2;
                }
 else {
                  subwindow=4;
                }
              }
              int pix=data[k * (realSizeX + dx) + h];
              if (pix > threshWindowsVals[subwindow - 1]) {
                double tileAvg=thresh[subwindow] / thresh[5];
                double tileStdDev=thresh[0] * thresh[subwindow] / thresh[5];
                dpixels.add(h + xLeftTile,k + yTopTile,pix,tileAvg,tileStdDev,thresh[5],band);
              }
            }
          }
        }
      }
    }
    System.out.println(rowIndex + ""String_Node_Str"" + verTilesImage);
  }
  System.out.println(""String_Node_Str"" + dpixels.getAllDetectedPixels().size());
  return dpixels;
}","/** 
 * @param kdist
 * @param thresholdBandParams
 * @return
 * @throws IOException
 */
public DetectedPixels analyse(final KDistributionEstimation kdist,final int band) throws IOException {
  DetectedPixels dpixels=new DetectedPixels(gir.getRangeSpacing(),gir.getAzimuthSpacing());
  String bb=((SarImageReader)gir).getBands()[band];
  float thresholdBand=this.thresholdsBandParams.get(bb);
  int xLeftTile=0;
  int xRightTile=0;
  int yTopTile=0;
  int yBottomTile=0;
  double[][][] tileStat=new double[verTilesImage][horTilesImage][5];
  int dy=0;
  for (int rowIndex=0; rowIndex < verTilesImage; rowIndex++) {
    if (isAnalyseSingleTile()) {
      if (rowIndex != yTileToAnalyze)       continue;
    }
    notifyStartNextRowProcessing(rowIndex);
    if (rowIndex == verTilesImage - 1) {
      dy=gir.getHeight() - ((verTilesImage - 1) * realSizeY) - realSizeY;
    }
    xLeftTile=0;
    xRightTile=0;
    yTopTile=rowIndex * realSizeY;
    yBottomTile=yTopTile + realSizeY + dy;
    int dx=0;
    for (int colIndex=0; colIndex < horTilesImage; colIndex++) {
      if (isAnalyseSingleTile()) {
        if (colIndex != xTileToAnalyze)         continue;
      }
      if (colIndex == horTilesImage - 1) {
        dx=(gir.getWidth() - ((horTilesImage - 1) * realSizeX)) - realSizeX;
      }
      xLeftTile=colIndex * realSizeX;
      xRightTile=xLeftTile + realSizeX + dx;
      boolean containsMinPixelValid=false;
      int[] maskdata=null;
      int[] enlargedMaskData=null;
      int offsetEnlarge=30;
      if (coastMask == null || !intersects(xLeftTile,xRightTile,yTopTile,yBottomTile)) {
        maskdata=null;
      }
 else {
        if (includes(xLeftTile,xRightTile,yTopTile,yBottomTile))         continue;
        maskdata=createDataMask(xLeftTile,yTopTile,realSizeX,realSizeY,dx,dy);
        int inValidPixelCount=0;
        for (int count=0; count < maskdata.length; count++)         inValidPixelCount+=maskdata[count];
        containsMinPixelValid=((double)inValidPixelCount / maskdata.length) <= MIN_TRESH_FOR_ANALYSIS;
        if (!containsMinPixelValid) {
          enlargedMaskData=createDataMask(xLeftTile - offsetEnlarge,yTopTile - offsetEnlarge,realSizeX + offsetEnlarge,realSizeY + offsetEnlarge,dx,dy);
          inValidPixelCount=0;
          for (int count=0; count < enlargedMaskData.length; count++)           inValidPixelCount+=enlargedMaskData[count];
          containsMinPixelValid=((double)inValidPixelCount / enlargedMaskData.length) <= MIN_TRESH_FOR_ANALYSIS;
        }
      }
      if (containsMinPixelValid || maskdata == null) {
        TileAnalysis bbAnalysis=null;
        if (blackBorderAnalysis != null)         bbAnalysis=blackBorderAnalysis.getAnalysisTile(rowIndex,colIndex);
        int[] data=gir.readTile(xLeftTile,yTopTile,realSizeX + dx,realSizeY + dy,band);
        if (enlargedMaskData == null) {
          kdist.setImageData(xLeftTile,yTopTile,realSizeX + dx,realSizeY + dy,band,bbAnalysis);
          kdist.estimate(maskdata,data);
        }
 else {
          int[] dataEn=gir.readTile(xLeftTile - offsetEnlarge,yTopTile - offsetEnlarge,realSizeX + dx + offsetEnlarge,realSizeY + dy + offsetEnlarge,band);
          kdist.setImageData(xLeftTile - offsetEnlarge,yTopTile - offsetEnlarge,realSizeX + offsetEnlarge + dx,realSizeY + offsetEnlarge + dy,band,bbAnalysis);
          kdist.estimate(enlargedMaskData,dataEn);
        }
        double[] thresh=kdist.getDetectThresh();
        tileStat[rowIndex][0]=kdist.getTileStat();
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,thresh);
        for (int k=0; k < (realSizeY + dy); k++) {
          for (int h=0; h < (realSizeX + dx); h++) {
            if (maskdata == null || (maskdata[h + ((realSizeX + dx) * k)] == 0)) {
              int subwindow=1;
              if (h < (realSizeX + dx) / 2) {
                if (k < (realSizeY + dy) / 2) {
                  subwindow=1;
                }
 else {
                  subwindow=3;
                }
              }
 else {
                if (k < (realSizeY + dy) / 2) {
                  subwindow=2;
                }
 else {
                  subwindow=4;
                }
              }
              int pix=data[k * (realSizeX + dx) + h];
              if (pix > threshWindowsVals[subwindow - 1]) {
                double tileAvg=thresh[subwindow] / thresh[5];
                double tileStdDev=thresh[0] * thresh[subwindow] / thresh[5];
                dpixels.add(h + xLeftTile,k + yTopTile,pix,tileAvg,tileStdDev,thresh[5],band);
              }
            }
          }
        }
      }
    }
    System.out.println(rowIndex + ""String_Node_Str"" + verTilesImage);
  }
  System.out.println(""String_Node_Str"" + dpixels.getAllDetectedPixels().size());
  return dpixels;
}",0.9117843617732234
175093,"/** 
 * aggregate using the neighbours within tilesize
 * @param neighboursdistance
 * @param tilesize
 * @param removelandconnectedpixels
 * @param bands
 * @param mask
 * @param kdist
 * @throws IOException
 */
private void aggregate(DetectedPixels detPixels,int neighboursdistance,int tilesize,boolean removelandconnectedpixels,int[] bands,MaskGeometries mask,KDistributionEstimation kdist) throws IOException {
  int id=0;
  DetectedPixels.BoatPixel pixels[]=detPixels.getAllDetectedPixelsValues().toArray(new DetectedPixels.BoatPixel[0]);
  int count=0;
  for (  DetectedPixels.BoatPixel detectedPix : pixels) {
    count++;
    int xx=detectedPix.x;
    int yy=detectedPix.y;
    if ((count % 100) == 0)     logger.info(new StringBuilder().append(""String_Node_Str"").append(count).append(""String_Node_Str"").append(xx).append(""String_Node_Str"").append(yy).toString());
    boolean checked=false;
    for (    BoatConnectedPixelMap boatpixel : detPixels.listboatneighbours) {
      if (boatpixel.containsPixel(xx,yy)) {
        checked=true;
        break;
      }
    }
    if (checked) {
      continue;
    }
    int cornerx=Math.min(Math.max(0,xx - tilesize / 2),gir.getWidth() - tilesize);
    int cornery=Math.min(Math.max(0,yy - tilesize / 2),gir.getHeight() - tilesize);
    int boatx=xx - cornerx;
    int boaty=yy - cornery;
    int numberbands=bands.length;
    int[][] data=new int[numberbands][];
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      data[bandcounter]=gir.read(cornerx,cornery,tilesize,tilesize,bands[bandcounter]);
    }
    int row=(cornery + 1) / this.verTilesImage;
    int col=(cornerx + 1) / this.horTilesImage;
    TileAnalysis ta=null;
    if (this.blackBorderAnalysis != null)     ta=this.blackBorderAnalysis.getAnalysisTile(row,col);
    double[][] statistics=AnalysisUtil.calculateImagemapStatistics(cornerx,cornery,tilesize,tilesize,row,col,bands,data,kdist,ta);
    double[][] thresholdvalues=new double[numberbands][2];
    boolean pixelabove=false;
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      double mean=(statistics[bandcounter][1] + statistics[bandcounter][2] + statistics[bandcounter][3]+ statistics[bandcounter][4]) / 4;
      thresholdvalues[bandcounter][0]=mean + 3 * mean * statistics[bandcounter][0];
      thresholdvalues[bandcounter][1]=mean + 5 * mean * statistics[bandcounter][0];
      int value=data[bandcounter][boatx + boaty * tilesize];
      if (value > thresholdvalues[bandcounter][1]) {
        pixelabove=true;
      }
    }
    if (pixelabove) {
      int[] dataMask=createDataMask(cornerx,cornery,tilesize,tilesize,0,0);
      BoatConnectedPixelMap boatpixel=null;
      try {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][boatx + boaty * tilesize]);
      }
 catch (      Exception e) {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][(boatx + boaty * tilesize) - 1]);
      }
      for (int iBand=0; iBand < numberbands; iBand++) {
        String bb=gir.getBandName(bands[iBand]);
        float thresholdBand=this.thresholdsBandParams.get(bb);
        TileAnalysis bbAnalysis=null;
        if (blackBorderAnalysis != null)         bbAnalysis=blackBorderAnalysis.getAnalysisTile(row,col);
        kdist.setImageData(cornerx,cornery,tilesize,tilesize,iBand,bbAnalysis);
        int[] newdata=gir.read(cornerx,cornery,tilesize,tilesize,bands[iBand]);
        kdist.estimate(newdata,newdata);
        double[] treshTile=kdist.getDetectThresh();
        double threshTotal=treshTile[0] + treshTile[1] + treshTile[2]+ treshTile[3];
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,treshTile);
        double tileAvg=0;
        int i=0;
        int y=-1;
        for (; i < data[iBand].length; i++) {
          int x=i % 200;
          if (x == 0)           y++;
          try {
            if (dataMask == null || dataMask[x + (y * tilesize)] == 0) {
              tileAvg=tileAvg + data[iBand][i];
            }
          }
 catch (          Exception e) {
            System.out.print(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"");
          }
        }
        tileAvg=tileAvg / i;
        double tileStdDev=treshTile[0] * threshTotal / treshTile[5];
        boatpixel.getStatMap().setTreshold(Precision.round((threshWindowsVals[0] + threshWindowsVals[1] + threshWindowsVals[2]+ threshWindowsVals[3]) / 4,3),bb);
        boatpixel.getStatMap().setTileStd(Precision.round(tileStdDev,3),bb);
        boatpixel.getStatMap().setTileAvg(Precision.round(tileAvg,3),bb);
      }
      detPixels.listboatneighbours.add(boatpixel);
      List<int[]> boataggregatedpixels=new ArrayList<int[]>();
      boolean result=detPixels.checkNeighbours(boataggregatedpixels,data,thresholdvalues,new int[]{boatx,boaty},neighboursdistance,tilesize,dataMask);
      boatpixel.setTouchesLandMask(result);
      for (      int[] pixel : boataggregatedpixels) {
        boatpixel.addConnectedPixel(pixel[0] + cornerx,pixel[1] + cornery,pixel[2],pixel[3] == 1 ? true : false);
      }
    }
  }
  if (removelandconnectedpixels) {
    List<BoatConnectedPixelMap> toRemove=new ArrayList<BoatConnectedPixelMap>();
    for (int i=0; i < detPixels.listboatneighbours.size(); i++) {
      BoatConnectedPixelMap boat=detPixels.listboatneighbours.get(i);
      if (boat.touchesLand()) {
        toRemove.add(boat);
      }
    }
    detPixels.listboatneighbours.removeAll(toRemove);
  }
}","/** 
 * aggregate using the neighbours within tilesize
 * @param neighboursdistance
 * @param tilesize
 * @param removelandconnectedpixels
 * @param bands
 * @param mask
 * @param kdist
 * @throws IOException
 */
private void aggregate(DetectedPixels detPixels,int neighboursdistance,int tilesize,boolean removelandconnectedpixels,int[] bands,MaskGeometries mask,KDistributionEstimation kdist) throws IOException {
  int id=0;
  DetectedPixels.BoatPixel pixels[]=detPixels.getAllDetectedPixelsValues().toArray(new DetectedPixels.BoatPixel[0]);
  int count=0;
  for (  DetectedPixels.BoatPixel detectedPix : pixels) {
    count++;
    int xx=detectedPix.x;
    int yy=detectedPix.y;
    if ((count % 100) == 0) {
      if (logger.isInfoEnabled())       logger.info(new StringBuilder().append(""String_Node_Str"").append(count).append(""String_Node_Str"").append(xx).append(""String_Node_Str"").append(yy).toString());
    }
    boolean checked=false;
    for (    BoatConnectedPixelMap boatpixel : detPixels.listboatneighbours) {
      if (boatpixel.containsPixel(xx,yy)) {
        checked=true;
        break;
      }
    }
    if (checked) {
      continue;
    }
    int cornerx=Math.min(Math.max(0,xx - tilesize / 2),gir.getWidth() - tilesize);
    int cornery=Math.min(Math.max(0,yy - tilesize / 2),gir.getHeight() - tilesize);
    int boatx=xx - cornerx;
    int boaty=yy - cornery;
    int numberbands=bands.length;
    int[][] data=new int[numberbands][];
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      data[bandcounter]=gir.read(cornerx,cornery,tilesize,tilesize,bands[bandcounter]);
    }
    int row=(cornery + 1) / this.verTilesImage;
    int col=(cornerx + 1) / this.horTilesImage;
    TileAnalysis ta=null;
    if (this.blackBorderAnalysis != null)     ta=this.blackBorderAnalysis.getAnalysisTile(row,col);
    double[][] statistics=AnalysisUtil.calculateImagemapStatistics(cornerx,cornery,tilesize,tilesize,row,col,bands,data,kdist,ta);
    double[][] thresholdvalues=new double[numberbands][2];
    boolean pixelabove=false;
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      double mean=(statistics[bandcounter][1] + statistics[bandcounter][2] + statistics[bandcounter][3]+ statistics[bandcounter][4]) / 4;
      thresholdvalues[bandcounter][0]=mean + 3 * mean * statistics[bandcounter][0];
      thresholdvalues[bandcounter][1]=mean + 5 * mean * statistics[bandcounter][0];
      int value=data[bandcounter][boatx + boaty * tilesize];
      if (value > thresholdvalues[bandcounter][1]) {
        pixelabove=true;
      }
    }
    if (pixelabove) {
      int[] dataMask=createDataMask(cornerx,cornery,tilesize,tilesize,0,0);
      BoatConnectedPixelMap boatpixel=null;
      try {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][boatx + boaty * tilesize]);
      }
 catch (      Exception e) {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][(boatx + boaty * tilesize) - 1]);
      }
      for (int iBand=0; iBand < numberbands; iBand++) {
        String bb=gir.getBandName(bands[iBand]);
        float thresholdBand=this.thresholdsBandParams.get(bb);
        TileAnalysis bbAnalysis=null;
        if (blackBorderAnalysis != null)         bbAnalysis=blackBorderAnalysis.getAnalysisTile(row,col);
        kdist.setImageData(cornerx,cornery,tilesize,tilesize,iBand,bbAnalysis);
        int[] newdata=gir.read(cornerx,cornery,tilesize,tilesize,bands[iBand]);
        kdist.estimate(newdata,newdata);
        double[] treshTile=kdist.getDetectThresh();
        double threshTotal=treshTile[0] + treshTile[1] + treshTile[2]+ treshTile[3];
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,treshTile);
        double tileAvg=0;
        int i=0;
        int y=-1;
        for (; i < data[iBand].length; i++) {
          int x=i % 200;
          if (x == 0)           y++;
          try {
            if (dataMask == null || dataMask[x + (y * tilesize)] == 0) {
              tileAvg=tileAvg + data[iBand][i];
            }
          }
 catch (          Exception e) {
            logger.warn(new StringBuilder(e.getMessage()).append(""String_Node_Str"").append(x).append(""String_Node_Str"").append(y).append(""String_Node_Str"").toString());
          }
        }
        tileAvg=tileAvg / i;
        double tileStdDev=treshTile[0] * threshTotal / treshTile[5];
        boatpixel.getStatMap().setTreshold(Precision.round((threshWindowsVals[0] + threshWindowsVals[1] + threshWindowsVals[2]+ threshWindowsVals[3]) / 4,3),bb);
        boatpixel.getStatMap().setTileStd(Precision.round(tileStdDev,3),bb);
        boatpixel.getStatMap().setTileAvg(Precision.round(tileAvg,3),bb);
      }
      detPixels.listboatneighbours.add(boatpixel);
      List<int[]> boataggregatedpixels=new ArrayList<int[]>();
      boolean result=detPixels.checkNeighbours(boataggregatedpixels,data,thresholdvalues,new int[]{boatx,boaty},neighboursdistance,tilesize,dataMask);
      boatpixel.setTouchesLandMask(result);
      for (      int[] pixel : boataggregatedpixels) {
        boatpixel.addConnectedPixel(pixel[0] + cornerx,pixel[1] + cornery,pixel[2],pixel[3] == 1 ? true : false);
      }
    }
  }
  if (removelandconnectedpixels) {
    List<BoatConnectedPixelMap> toRemove=new ArrayList<BoatConnectedPixelMap>();
    for (int i=0; i < detPixels.listboatneighbours.size(); i++) {
      BoatConnectedPixelMap boat=detPixels.listboatneighbours.get(i);
      if (boat.touchesLand()) {
        toRemove.add(boat);
      }
    }
    detPixels.listboatneighbours.removeAll(toRemove);
  }
}",0.9847039769659888
175094,"/** 
 * @param kdist
 * @param thresholdBandParams
 * @return
 * @throws IOException
 */
public DetectedPixels analyse(final KDistributionEstimation kdist,final int band) throws IOException {
  DetectedPixels dpixels=new DetectedPixels(gir.getRangeSpacing(),gir.getAzimuthSpacing());
  String bb=((SarImageReader)gir).getBands()[band];
  float thresholdBand=this.thresholdsBandParams.get(bb);
  int xLeftTile=0;
  int xRightTile=0;
  int yTopTile=0;
  int yBottomTile=0;
  double[][][] tileStat=new double[verTilesImage][horTilesImage][5];
  int dy=0;
  for (int rowIndex=0; rowIndex < verTilesImage; rowIndex++) {
    if (isAnalyseSingleTile()) {
      if (rowIndex != yTileToAnalyze)       continue;
    }
    notifyStartNextRowProcessing(rowIndex);
    if (rowIndex == verTilesImage - 1) {
      dy=gir.getHeight() - ((verTilesImage - 1) * realSizeY) - realSizeY;
    }
    xLeftTile=0;
    xRightTile=0;
    yTopTile=rowIndex * realSizeY;
    yBottomTile=yTopTile + realSizeY + dy;
    int dx=0;
    for (int colIndex=0; colIndex < horTilesImage; colIndex++) {
      if (isAnalyseSingleTile()) {
        if (colIndex != xTileToAnalyze)         continue;
      }
      if (colIndex == horTilesImage - 1) {
        dx=(gir.getWidth() - ((horTilesImage - 1) * realSizeX)) - realSizeX;
      }
      xLeftTile=colIndex * realSizeX;
      xRightTile=xLeftTile + realSizeX + dx;
      boolean containsMinPixelValid=false;
      int[] maskdata=null;
      if (coastMask == null || !intersects(xLeftTile,xRightTile,yTopTile,yBottomTile)) {
        maskdata=null;
      }
 else {
        if (includes(xLeftTile,xRightTile,yTopTile,yBottomTile))         continue;
        maskdata=createDataMask(xLeftTile,yTopTile,realSizeX,realSizeY,dx,dy);
        int inValidPixelCount=0;
        for (int count=0; count < maskdata.length; count++)         inValidPixelCount+=maskdata[count];
        containsMinPixelValid=((double)inValidPixelCount / maskdata.length) <= MIN_TRESH_FOR_ANALYSIS;
        if (!containsMinPixelValid) {
          maskdata=createDataMask(xLeftTile - 30,yTopTile - 30,realSizeX + 30,realSizeY + 30,dx,dy);
          inValidPixelCount=0;
          for (int count=0; count < maskdata.length; count++)           inValidPixelCount+=maskdata[count];
          containsMinPixelValid=((double)inValidPixelCount / maskdata.length) <= MIN_TRESH_FOR_ANALYSIS;
        }
      }
      if (containsMinPixelValid || maskdata == null) {
        TileAnalysis bbAnalysis=null;
        if (blackBorderAnalysis != null)         bbAnalysis=blackBorderAnalysis.getAnalysisTile(rowIndex,colIndex);
        int[] data=gir.readTile(xLeftTile,yTopTile,realSizeX + dx,realSizeY + dy,band);
        kdist.setImageData(xLeftTile,yTopTile,realSizeX + dx,realSizeY + dy,band,bbAnalysis);
        kdist.estimate(maskdata,data);
        double[] thresh=kdist.getDetectThresh();
        tileStat[rowIndex][0]=kdist.getTileStat();
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,thresh);
        for (int k=0; k < (realSizeY + dy); k++) {
          for (int h=0; h < (realSizeX + dx); h++) {
            if (maskdata == null || (maskdata[h + ((realSizeX + dx) * k)] == 0)) {
              int subwindow=1;
              if (h < (realSizeX + dx) / 2) {
                if (k < (realSizeY + dy) / 2) {
                  subwindow=1;
                }
 else {
                  subwindow=3;
                }
              }
 else {
                if (k < (realSizeY + dy) / 2) {
                  subwindow=2;
                }
 else {
                  subwindow=4;
                }
              }
              int pix=data[k * (realSizeX + dx) + h];
              if (pix > threshWindowsVals[subwindow - 1]) {
                double tileAvg=thresh[subwindow] / thresh[5];
                double tileStdDev=thresh[0] * thresh[subwindow] / thresh[5];
                dpixels.add(h + xLeftTile,k + yTopTile,pix,tileAvg,tileStdDev,thresh[5],band);
              }
            }
          }
        }
      }
    }
    System.out.println(rowIndex + ""String_Node_Str"" + verTilesImage);
  }
  System.out.println(""String_Node_Str"" + dpixels.getAllDetectedPixels().size());
  return dpixels;
}","/** 
 * @param kdist
 * @param thresholdBandParams
 * @return
 * @throws IOException
 */
public DetectedPixels analyse(final KDistributionEstimation kdist,final int band) throws IOException {
  DetectedPixels dpixels=new DetectedPixels(gir.getRangeSpacing(),gir.getAzimuthSpacing());
  String bb=((SarImageReader)gir).getBands()[band];
  float thresholdBand=this.thresholdsBandParams.get(bb);
  int xLeftTile=0;
  int xRightTile=0;
  int yTopTile=0;
  int yBottomTile=0;
  double[][][] tileStat=new double[verTilesImage][horTilesImage][5];
  int dy=0;
  for (int rowIndex=0; rowIndex < verTilesImage; rowIndex++) {
    if (isAnalyseSingleTile()) {
      if (rowIndex != yTileToAnalyze)       continue;
    }
    notifyStartNextRowProcessing(rowIndex);
    if (rowIndex == verTilesImage - 1) {
      dy=gir.getHeight() - ((verTilesImage - 1) * realSizeY) - realSizeY;
    }
    xLeftTile=0;
    xRightTile=0;
    yTopTile=rowIndex * realSizeY;
    yBottomTile=yTopTile + realSizeY + dy;
    int dx=0;
    for (int colIndex=0; colIndex < horTilesImage; colIndex++) {
      if (isAnalyseSingleTile()) {
        if (colIndex != xTileToAnalyze)         continue;
      }
      if (colIndex == horTilesImage - 1) {
        dx=(gir.getWidth() - ((horTilesImage - 1) * realSizeX)) - realSizeX;
      }
      xLeftTile=colIndex * realSizeX;
      xRightTile=xLeftTile + realSizeX + dx;
      boolean containsMinPixelValid=false;
      int[] maskdata=null;
      int[] enlargedMaskData=null;
      int offsetEnlarge=30;
      if (coastMask == null || !intersects(xLeftTile,xRightTile,yTopTile,yBottomTile)) {
        maskdata=null;
      }
 else {
        if (includes(xLeftTile,xRightTile,yTopTile,yBottomTile))         continue;
        maskdata=createDataMask(xLeftTile,yTopTile,realSizeX,realSizeY,dx,dy);
        int inValidPixelCount=0;
        for (int count=0; count < maskdata.length; count++)         inValidPixelCount+=maskdata[count];
        containsMinPixelValid=((double)inValidPixelCount / maskdata.length) <= MIN_TRESH_FOR_ANALYSIS;
        if (!containsMinPixelValid) {
          enlargedMaskData=createDataMask(xLeftTile - offsetEnlarge,yTopTile - offsetEnlarge,realSizeX + offsetEnlarge,realSizeY + offsetEnlarge,dx,dy);
          inValidPixelCount=0;
          for (int count=0; count < enlargedMaskData.length; count++)           inValidPixelCount+=enlargedMaskData[count];
          containsMinPixelValid=((double)inValidPixelCount / enlargedMaskData.length) <= MIN_TRESH_FOR_ANALYSIS;
        }
      }
      if (containsMinPixelValid || maskdata == null) {
        TileAnalysis bbAnalysis=null;
        if (blackBorderAnalysis != null)         bbAnalysis=blackBorderAnalysis.getAnalysisTile(rowIndex,colIndex);
        int[] data=gir.readTile(xLeftTile,yTopTile,realSizeX + dx,realSizeY + dy,band);
        if (enlargedMaskData == null) {
          kdist.setImageData(xLeftTile,yTopTile,realSizeX + dx,realSizeY + dy,band,bbAnalysis);
          kdist.estimate(maskdata,data);
        }
 else {
          int[] dataEn=gir.readTile(xLeftTile - offsetEnlarge,yTopTile - offsetEnlarge,realSizeX + dx + offsetEnlarge,realSizeY + dy + offsetEnlarge,band);
          kdist.setImageData(xLeftTile - offsetEnlarge,yTopTile - offsetEnlarge,realSizeX + offsetEnlarge + dx,realSizeY + offsetEnlarge + dy,band,bbAnalysis);
          kdist.estimate(enlargedMaskData,dataEn);
        }
        double[] thresh=kdist.getDetectThresh();
        tileStat[rowIndex][0]=kdist.getTileStat();
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,thresh);
        for (int k=0; k < (realSizeY + dy); k++) {
          for (int h=0; h < (realSizeX + dx); h++) {
            if (maskdata == null || (maskdata[h + ((realSizeX + dx) * k)] == 0)) {
              int subwindow=1;
              if (h < (realSizeX + dx) / 2) {
                if (k < (realSizeY + dy) / 2) {
                  subwindow=1;
                }
 else {
                  subwindow=3;
                }
              }
 else {
                if (k < (realSizeY + dy) / 2) {
                  subwindow=2;
                }
 else {
                  subwindow=4;
                }
              }
              int pix=data[k * (realSizeX + dx) + h];
              if (pix > threshWindowsVals[subwindow - 1]) {
                double tileAvg=thresh[subwindow] / thresh[5];
                double tileStdDev=thresh[0] * thresh[subwindow] / thresh[5];
                dpixels.add(h + xLeftTile,k + yTopTile,pix,tileAvg,tileStdDev,thresh[5],band);
              }
            }
          }
        }
      }
    }
    System.out.println(rowIndex + ""String_Node_Str"" + verTilesImage);
  }
  System.out.println(""String_Node_Str"" + dpixels.getAllDetectedPixels().size());
  return dpixels;
}",0.9117843617732234
175095,"/** 
 * aggregate using the neighbours within tilesize
 * @param neighboursdistance
 * @param tilesize
 * @param removelandconnectedpixels
 * @param bands
 * @param mask
 * @param kdist
 * @throws IOException
 */
private void aggregate(DetectedPixels detPixels,int neighboursdistance,int tilesize,boolean removelandconnectedpixels,int[] bands,MaskGeometries mask,KDistributionEstimation kdist) throws IOException {
  int id=0;
  DetectedPixels.BoatPixel pixels[]=detPixels.getAllDetectedPixelsValues().toArray(new DetectedPixels.BoatPixel[0]);
  int count=0;
  for (  DetectedPixels.BoatPixel detectedPix : pixels) {
    count++;
    int xx=detectedPix.x;
    int yy=detectedPix.y;
    if ((count % 100) == 0)     logger.info(new StringBuilder().append(""String_Node_Str"").append(count).append(""String_Node_Str"").append(xx).append(""String_Node_Str"").append(yy).toString());
    boolean checked=false;
    for (    BoatConnectedPixelMap boatpixel : detPixels.listboatneighbours) {
      if (boatpixel.containsPixel(xx,yy)) {
        checked=true;
        break;
      }
    }
    if (checked) {
      continue;
    }
    int cornerx=Math.min(Math.max(0,xx - tilesize / 2),gir.getWidth() - tilesize);
    int cornery=Math.min(Math.max(0,yy - tilesize / 2),gir.getHeight() - tilesize);
    int boatx=xx - cornerx;
    int boaty=yy - cornery;
    int numberbands=bands.length;
    int[][] data=new int[numberbands][];
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      data[bandcounter]=gir.read(cornerx,cornery,tilesize,tilesize,bands[bandcounter]);
    }
    int row=(cornery + 1) / this.verTilesImage;
    int col=(cornerx + 1) / this.horTilesImage;
    TileAnalysis ta=null;
    if (this.blackBorderAnalysis != null)     ta=this.blackBorderAnalysis.getAnalysisTile(row,col);
    double[][] statistics=AnalysisUtil.calculateImagemapStatistics(cornerx,cornery,tilesize,tilesize,row,col,bands,data,kdist,ta);
    double[][] thresholdvalues=new double[numberbands][2];
    boolean pixelabove=false;
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      double mean=(statistics[bandcounter][1] + statistics[bandcounter][2] + statistics[bandcounter][3]+ statistics[bandcounter][4]) / 4;
      thresholdvalues[bandcounter][0]=mean + 3 * mean * statistics[bandcounter][0];
      thresholdvalues[bandcounter][1]=mean + 5 * mean * statistics[bandcounter][0];
      int value=data[bandcounter][boatx + boaty * tilesize];
      if (value > thresholdvalues[bandcounter][1]) {
        pixelabove=true;
      }
    }
    if (pixelabove) {
      int[] dataMask=createDataMask(cornerx,cornery,tilesize,tilesize,0,0);
      BoatConnectedPixelMap boatpixel=null;
      try {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][boatx + boaty * tilesize]);
      }
 catch (      Exception e) {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][(boatx + boaty * tilesize) - 1]);
      }
      for (int iBand=0; iBand < numberbands; iBand++) {
        String bb=gir.getBandName(bands[iBand]);
        float thresholdBand=this.thresholdsBandParams.get(bb);
        TileAnalysis bbAnalysis=null;
        if (blackBorderAnalysis != null)         bbAnalysis=blackBorderAnalysis.getAnalysisTile(row,col);
        kdist.setImageData(cornerx,cornery,tilesize,tilesize,iBand,bbAnalysis);
        int[] newdata=gir.read(cornerx,cornery,tilesize,tilesize,bands[iBand]);
        kdist.estimate(newdata,newdata);
        double[] treshTile=kdist.getDetectThresh();
        double threshTotal=treshTile[0] + treshTile[1] + treshTile[2]+ treshTile[3];
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,treshTile);
        double tileAvg=0;
        int i=0;
        int y=-1;
        for (; i < data[iBand].length; i++) {
          int x=i % 200;
          if (x == 0)           y++;
          try {
            if (dataMask == null || dataMask[x + (y * tilesize)] == 0) {
              tileAvg=tileAvg + data[iBand][i];
            }
          }
 catch (          Exception e) {
            System.out.print(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"");
          }
        }
        tileAvg=tileAvg / i;
        double tileStdDev=treshTile[0] * threshTotal / treshTile[5];
        boatpixel.getStatMap().setTreshold(Precision.round((threshWindowsVals[0] + threshWindowsVals[1] + threshWindowsVals[2]+ threshWindowsVals[3]) / 4,3),bb);
        boatpixel.getStatMap().setTileStd(Precision.round(tileStdDev,3),bb);
        boatpixel.getStatMap().setTileAvg(Precision.round(tileAvg,3),bb);
      }
      detPixels.listboatneighbours.add(boatpixel);
      List<int[]> boataggregatedpixels=new ArrayList<int[]>();
      boolean result=detPixels.checkNeighbours(boataggregatedpixels,data,thresholdvalues,new int[]{boatx,boaty},neighboursdistance,tilesize,dataMask);
      boatpixel.setTouchesLandMask(result);
      for (      int[] pixel : boataggregatedpixels) {
        boatpixel.addConnectedPixel(pixel[0] + cornerx,pixel[1] + cornery,pixel[2],pixel[3] == 1 ? true : false);
      }
    }
  }
  if (removelandconnectedpixels) {
    List<BoatConnectedPixelMap> toRemove=new ArrayList<BoatConnectedPixelMap>();
    for (int i=0; i < detPixels.listboatneighbours.size(); i++) {
      BoatConnectedPixelMap boat=detPixels.listboatneighbours.get(i);
      if (boat.touchesLand()) {
        toRemove.add(boat);
      }
    }
    detPixels.listboatneighbours.removeAll(toRemove);
  }
}","/** 
 * aggregate using the neighbours within tilesize
 * @param neighboursdistance
 * @param tilesize
 * @param removelandconnectedpixels
 * @param bands
 * @param mask
 * @param kdist
 * @throws IOException
 */
private void aggregate(DetectedPixels detPixels,int neighboursdistance,int tilesize,boolean removelandconnectedpixels,int[] bands,MaskGeometries mask,KDistributionEstimation kdist) throws IOException {
  int id=0;
  DetectedPixels.BoatPixel pixels[]=detPixels.getAllDetectedPixelsValues().toArray(new DetectedPixels.BoatPixel[0]);
  int count=0;
  for (  DetectedPixels.BoatPixel detectedPix : pixels) {
    count++;
    int xx=detectedPix.x;
    int yy=detectedPix.y;
    if ((count % 100) == 0) {
      if (logger.isInfoEnabled())       logger.info(new StringBuilder().append(""String_Node_Str"").append(count).append(""String_Node_Str"").append(xx).append(""String_Node_Str"").append(yy).toString());
    }
    boolean checked=false;
    for (    BoatConnectedPixelMap boatpixel : detPixels.listboatneighbours) {
      if (boatpixel.containsPixel(xx,yy)) {
        checked=true;
        break;
      }
    }
    if (checked) {
      continue;
    }
    int cornerx=Math.min(Math.max(0,xx - tilesize / 2),gir.getWidth() - tilesize);
    int cornery=Math.min(Math.max(0,yy - tilesize / 2),gir.getHeight() - tilesize);
    int boatx=xx - cornerx;
    int boaty=yy - cornery;
    int numberbands=bands.length;
    int[][] data=new int[numberbands][];
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      data[bandcounter]=gir.read(cornerx,cornery,tilesize,tilesize,bands[bandcounter]);
    }
    int row=(cornery + 1) / this.verTilesImage;
    int col=(cornerx + 1) / this.horTilesImage;
    TileAnalysis ta=null;
    if (this.blackBorderAnalysis != null)     ta=this.blackBorderAnalysis.getAnalysisTile(row,col);
    double[][] statistics=AnalysisUtil.calculateImagemapStatistics(cornerx,cornery,tilesize,tilesize,row,col,bands,data,kdist,ta);
    double[][] thresholdvalues=new double[numberbands][2];
    boolean pixelabove=false;
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      double mean=(statistics[bandcounter][1] + statistics[bandcounter][2] + statistics[bandcounter][3]+ statistics[bandcounter][4]) / 4;
      thresholdvalues[bandcounter][0]=mean + 3 * mean * statistics[bandcounter][0];
      thresholdvalues[bandcounter][1]=mean + 5 * mean * statistics[bandcounter][0];
      int value=data[bandcounter][boatx + boaty * tilesize];
      if (value > thresholdvalues[bandcounter][1]) {
        pixelabove=true;
      }
    }
    if (pixelabove) {
      int[] dataMask=createDataMask(cornerx,cornery,tilesize,tilesize,0,0);
      BoatConnectedPixelMap boatpixel=null;
      try {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][boatx + boaty * tilesize]);
      }
 catch (      Exception e) {
        boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][(boatx + boaty * tilesize) - 1]);
      }
      for (int iBand=0; iBand < numberbands; iBand++) {
        String bb=gir.getBandName(bands[iBand]);
        float thresholdBand=this.thresholdsBandParams.get(bb);
        TileAnalysis bbAnalysis=null;
        if (blackBorderAnalysis != null)         bbAnalysis=blackBorderAnalysis.getAnalysisTile(row,col);
        kdist.setImageData(cornerx,cornery,tilesize,tilesize,iBand,bbAnalysis);
        int[] newdata=gir.read(cornerx,cornery,tilesize,tilesize,bands[iBand]);
        kdist.estimate(newdata,newdata);
        double[] treshTile=kdist.getDetectThresh();
        double threshTotal=treshTile[0] + treshTile[1] + treshTile[2]+ treshTile[3];
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,treshTile);
        double tileAvg=0;
        int i=0;
        int y=-1;
        for (; i < data[iBand].length; i++) {
          int x=i % 200;
          if (x == 0)           y++;
          try {
            if (dataMask == null || dataMask[x + (y * tilesize)] == 0) {
              tileAvg=tileAvg + data[iBand][i];
            }
          }
 catch (          Exception e) {
            logger.warn(new StringBuilder(e.getMessage()).append(""String_Node_Str"").append(x).append(""String_Node_Str"").append(y).append(""String_Node_Str"").toString());
          }
        }
        tileAvg=tileAvg / i;
        double tileStdDev=treshTile[0] * threshTotal / treshTile[5];
        boatpixel.getStatMap().setTreshold(Precision.round((threshWindowsVals[0] + threshWindowsVals[1] + threshWindowsVals[2]+ threshWindowsVals[3]) / 4,3),bb);
        boatpixel.getStatMap().setTileStd(Precision.round(tileStdDev,3),bb);
        boatpixel.getStatMap().setTileAvg(Precision.round(tileAvg,3),bb);
      }
      detPixels.listboatneighbours.add(boatpixel);
      List<int[]> boataggregatedpixels=new ArrayList<int[]>();
      boolean result=detPixels.checkNeighbours(boataggregatedpixels,data,thresholdvalues,new int[]{boatx,boaty},neighboursdistance,tilesize,dataMask);
      boatpixel.setTouchesLandMask(result);
      for (      int[] pixel : boataggregatedpixels) {
        boatpixel.addConnectedPixel(pixel[0] + cornerx,pixel[1] + cornery,pixel[2],pixel[3] == 1 ? true : false);
      }
    }
  }
  if (removelandconnectedpixels) {
    List<BoatConnectedPixelMap> toRemove=new ArrayList<BoatConnectedPixelMap>();
    for (int i=0; i < detPixels.listboatneighbours.size(); i++) {
      BoatConnectedPixelMap boat=detPixels.listboatneighbours.get(i);
      if (boat.touchesLand()) {
        toRemove.add(boat);
      }
    }
    detPixels.listboatneighbours.removeAll(toRemove);
  }
}",0.9847039769659888
175096,"public static List<ImagePlanning> getImagePlanning(String dbname) throws Exception {
  List<ImagePlanning> listImageplanning=new ArrayList<ImagePlanning>();
  Connection conn=DriverManager.getConnection(""String_Node_Str"" + dbname + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Statement stat=conn.createStatement();
  String sql=""String_Node_Str"";
  ResultSet res=stat.executeQuery(sql);
  WKTReader wktr=new WKTReader();
  Geometry imageGeom=null;
  while (!res.isClosed() && res.next()) {
    ImagePlanning imagePlanning=new ImagePlanning();
    imagePlanning.setName(res.getString(""String_Node_Str""));
    imagePlanning.setAcquisitionTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
    imagePlanning.setAcquisitionStopTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
    imagePlanning.setRemoteLocation(new URL(res.getString(""String_Node_Str"")));
    imagePlanning.setAction(res.getString(""String_Node_Str""));
    try {
      imageGeom=wktr.read(res.getString(""String_Node_Str""));
    }
 catch (    Exception e) {
      imageGeom=null;
    }
    imagePlanning.setArea(imageGeom);
    if (imagePlanning.getAcquisitionStopTime().getTime() - System.currentTimeMillis() < 0) {
      try {
        stat.execute(""String_Node_Str"" + res.getString(""String_Node_Str"") + ""String_Node_Str""+ res.getString(""String_Node_Str"")+ ""String_Node_Str"");
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"" + res.getString(""String_Node_Str""));
      }
    }
 else {
      listImageplanning.add(imagePlanning);
    }
  }
  stat.close();
  conn.close();
  return listImageplanning;
}","public static List<ImagePlanning> getImagePlanning(String dbname) throws Exception {
  List<ImagePlanning> listImageplanning=new ArrayList<ImagePlanning>();
  Connection conn=DriverManager.getConnection(""String_Node_Str"" + dbname + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String sqlCheckEx=""String_Node_Str"";
  Statement statEx=conn.createStatement();
  ResultSet res=statEx.executeQuery(sqlCheckEx);
  res.next();
  int count=res.getInt(1);
  if (count != 0) {
    Statement stat=conn.createStatement();
    String sql=""String_Node_Str"";
    res=stat.executeQuery(sql);
    WKTReader wktr=new WKTReader();
    Geometry imageGeom=null;
    while (!res.isClosed() && res.next()) {
      ImagePlanning imagePlanning=new ImagePlanning();
      imagePlanning.setName(res.getString(""String_Node_Str""));
      imagePlanning.setAcquisitionTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
      imagePlanning.setAcquisitionStopTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
      imagePlanning.setRemoteLocation(new URL(res.getString(""String_Node_Str"")));
      imagePlanning.setAction(res.getString(""String_Node_Str""));
      try {
        imageGeom=wktr.read(res.getString(""String_Node_Str""));
      }
 catch (      Exception e) {
        imageGeom=null;
      }
      imagePlanning.setArea(imageGeom);
      if (imagePlanning.getAcquisitionStopTime().getTime() - System.currentTimeMillis() < 0) {
        try {
          stat.execute(""String_Node_Str"" + res.getString(""String_Node_Str"") + ""String_Node_Str""+ res.getString(""String_Node_Str"")+ ""String_Node_Str"");
        }
 catch (        Exception e) {
          System.out.println(""String_Node_Str"" + res.getString(""String_Node_Str""));
        }
      }
 else {
        listImageplanning.add(imagePlanning);
      }
    }
    stat.close();
    statEx.close();
    conn.close();
  }
  return listImageplanning;
}",0.8683314415437003
175097,"public void add(ImageLayer layer){
  try {
    if (layer == null)     return;
    GeoImageReader reader=layer.getImageReader();
    List<double[]> imageframe=layer.getImageReader().getFrameLatLon(reader.getWidth(),reader.getHeight());
    if (imageframe != null) {
      List<LatLon> ll=new ArrayList<LatLon>();
      for (      double[] c : imageframe) {
        ll.add(new LatLon(Angle.fromDegreesLatitude(c[1]),Angle.fromDegreesLongitude(c[0])));
      }
      WWGeoImage gi=new WWGeoImage(new Polyline(ll,1000),new GlobeAnnotation(layer.getName() + ""String_Node_Str"",new Position(new LatLon(Angle.fromDegreesLatitude(imageframe.get(0)[1]),Angle.fromDegreesLongitude(imageframe.get(0)[0])),2000)),layer.isActive() ? Color.CYAN : Color.BLUE,layer.isActive() ? Color.CYAN : Color.BLUE);
      gi.setAnnotationVisible(layer.isActive());
      gi.setDelegateOwner(layer);
      imageLayer.addRenderable(gi);
    }
  }
 catch (  Exception e) {
    logger.error(e.getMessage(),e);
  }
}","public void add(ImageLayer layer){
  try {
    if (layer == null)     return;
    initGlobe();
    GeoImageReader reader=layer.getImageReader();
    List<double[]> imageframe=layer.getImageReader().getFrameLatLon(reader.getWidth(),reader.getHeight());
    if (imageframe != null) {
      List<LatLon> ll=new ArrayList<LatLon>();
      for (      double[] c : imageframe) {
        ll.add(new LatLon(Angle.fromDegreesLatitude(c[1]),Angle.fromDegreesLongitude(c[0])));
      }
      WWGeoImage gi=new WWGeoImage(new Polyline(ll,1000),new GlobeAnnotation(layer.getName() + ""String_Node_Str"",new Position(new LatLon(Angle.fromDegreesLatitude(imageframe.get(0)[1]),Angle.fromDegreesLongitude(imageframe.get(0)[0])),2000)),layer.isActive() ? Color.CYAN : Color.BLUE,layer.isActive() ? Color.CYAN : Color.BLUE);
      gi.setAnnotationVisible(layer.isActive());
      gi.setDelegateOwner(layer);
      imageLayer.addRenderable(gi);
    }
  }
 catch (  Exception e) {
    logger.error(e.getMessage(),e);
  }
}",0.9914271306101866
175098,"/** 
 * Creates new form WWJPanel 
 */
public WWJPanel(){
  initComponents();
  CatalogPanel catalogPanel=new CatalogPanel(this);
  catalogPanel.setSize(new Dimension(200,jTabbedPane1.getHeight() / 2));
  catalogPanel.setBorder(new LineBorder(new Color(255)));
  jTabbedPane1.add(""String_Node_Str"",catalogPanel);
  PlanningPanel planningPanel=new PlanningPanel(this);
  jTabbedPane1.add(""String_Node_Str"",planningPanel);
  this.addComponentListener(new ComponentListener(){
    @Override public void componentShown(    ComponentEvent e){
      if (acquisitionLayer == null) {
        acquisitionLayer=new TimeRenderableLayer();
        wwjCanvas.getModel().getLayers().add(acquisitionLayer);
      }
      if (imageLayer == null) {
        imageLayer=new TimeRenderableLayer();
        wwjCanvas.getModel().getLayers().add(imageLayer);
      }
    }
    @Override public void componentResized(    ComponentEvent e){
    }
    @Override public void componentMoved(    ComponentEvent e){
    }
    @Override public void componentHidden(    ComponentEvent e){
    }
  }
);
}","/** 
 * Creates new form WWJPanel 
 */
public WWJPanel(){
  initComponents();
  CatalogPanel catalogPanel=new CatalogPanel(this);
  catalogPanel.setSize(new Dimension(200,jTabbedPane1.getHeight() / 2));
  catalogPanel.setBorder(new LineBorder(new Color(255)));
  jTabbedPane1.add(""String_Node_Str"",catalogPanel);
  PlanningPanel planningPanel=new PlanningPanel(this);
  jTabbedPane1.add(""String_Node_Str"",planningPanel);
  this.addComponentListener(new ComponentListener(){
    @Override public void componentShown(    ComponentEvent e){
      initGlobe();
    }
    @Override public void componentResized(    ComponentEvent e){
    }
    @Override public void componentMoved(    ComponentEvent e){
    }
    @Override public void componentHidden(    ComponentEvent e){
    }
  }
);
}",0.8334231805929919
175099,"public static List<ImagePlanning> getImagePlanning(String dbname) throws Exception {
  List<ImagePlanning> listImageplanning=new ArrayList<ImagePlanning>();
  Connection conn=DriverManager.getConnection(""String_Node_Str"" + dbname + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String sqlCheckEx=""String_Node_Str"";
  Statement statEx=conn.createStatement();
  ResultSet res=statEx.executeQuery(sqlCheckEx);
  res.next();
  int count=res.getInt(1);
  if (count != 0) {
    Statement stat=conn.createStatement();
    String sql=""String_Node_Str"";
    res=stat.executeQuery(sql);
    WKTReader wktr=new WKTReader();
    Geometry imageGeom=null;
    while (!res.isClosed() && res.next()) {
      ImagePlanning imagePlanning=new ImagePlanning();
      imagePlanning.setName(res.getString(""String_Node_Str""));
      imagePlanning.setAcquisitionTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
      imagePlanning.setAcquisitionStopTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
      imagePlanning.setRemoteLocation(new URL(res.getString(""String_Node_Str"")));
      imagePlanning.setAction(res.getString(""String_Node_Str""));
      try {
        imageGeom=wktr.read(res.getString(""String_Node_Str""));
      }
 catch (      Exception e) {
        imageGeom=null;
      }
      imagePlanning.setArea(imageGeom);
      if (imagePlanning.getAcquisitionStopTime().getTime() - System.currentTimeMillis() < 0) {
        try {
          stat.execute(""String_Node_Str"" + res.getString(""String_Node_Str"") + ""String_Node_Str""+ res.getString(""String_Node_Str"")+ ""String_Node_Str"");
        }
 catch (        Exception e) {
          System.out.println(""String_Node_Str"" + res.getString(""String_Node_Str""));
        }
      }
 else {
        listImageplanning.add(imagePlanning);
      }
    }
    stat.close();
    statEx.close();
    conn.close();
  }
  return listImageplanning;
}","public static List<ImagePlanning> getImagePlanning(String dbname) throws Exception {
  List<ImagePlanning> listImageplanning=new ArrayList<ImagePlanning>();
  Connection conn=DriverManager.getConnection(""String_Node_Str"" + dbname + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String sqlCheckEx=""String_Node_Str"";
  Statement statEx=conn.createStatement();
  ResultSet res=statEx.executeQuery(sqlCheckEx);
  res.next();
  int count=res.getInt(1);
  if (count != 0) {
    Statement stat=conn.createStatement();
    String sql=""String_Node_Str"";
    res=stat.executeQuery(sql);
    WKTReader wktr=new WKTReader();
    Geometry imageGeom=null;
    while (!res.isClosed() && res.next()) {
      ImagePlanning imagePlanning=new ImagePlanning();
      imagePlanning.setName(res.getString(""String_Node_Str""));
      imagePlanning.setAcquisitionTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
      imagePlanning.setAcquisitionStopTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
      imagePlanning.setRemoteLocation(new URL(res.getString(""String_Node_Str"")));
      imagePlanning.setAction(res.getString(""String_Node_Str""));
      try {
        imageGeom=wktr.read(res.getString(""String_Node_Str""));
      }
 catch (      Exception e) {
        imageGeom=null;
      }
      imagePlanning.setArea(imageGeom);
      if (imagePlanning.getAcquisitionStopTime().getTime() - System.currentTimeMillis() < 0) {
        try {
          stat.execute(""String_Node_Str"" + res.getString(""String_Node_Str"") + ""String_Node_Str""+ res.getString(""String_Node_Str"")+ ""String_Node_Str"");
        }
 catch (        Exception e) {
          System.out.println(""String_Node_Str"" + res.getString(""String_Node_Str""));
        }
      }
 else {
        listImageplanning.add(imagePlanning);
      }
    }
    stat.close();
    conn.close();
  }
  statEx.close();
  return listImageplanning;
}",0.9752109704641352
175100,"public void add(ImageLayer layer){
  try {
    if (layer == null)     return;
    GeoImageReader reader=layer.getImageReader();
    List<double[]> imageframe=layer.getImageReader().getFrameLatLon(reader.getWidth(),reader.getHeight());
    if (imageframe != null) {
      List<LatLon> ll=new ArrayList<LatLon>();
      for (      double[] c : imageframe) {
        ll.add(new LatLon(Angle.fromDegreesLatitude(c[1]),Angle.fromDegreesLongitude(c[0])));
      }
      WWGeoImage gi=new WWGeoImage(new Polyline(ll,1000),new GlobeAnnotation(layer.getName() + ""String_Node_Str"",new Position(new LatLon(Angle.fromDegreesLatitude(imageframe.get(0)[1]),Angle.fromDegreesLongitude(imageframe.get(0)[0])),2000)),layer.isActive() ? Color.CYAN : Color.BLUE,layer.isActive() ? Color.CYAN : Color.BLUE);
      gi.setAnnotationVisible(layer.isActive());
      gi.setDelegateOwner(layer);
      imageLayer.addRenderable(gi);
    }
  }
 catch (  Exception e) {
    logger.error(e.getMessage(),e);
  }
}","public void add(ImageLayer layer){
  try {
    if (layer == null)     return;
    initGlobe();
    GeoImageReader reader=layer.getImageReader();
    List<double[]> imageframe=layer.getImageReader().getFrameLatLon(reader.getWidth(),reader.getHeight());
    if (imageframe != null) {
      List<LatLon> ll=new ArrayList<LatLon>();
      for (      double[] c : imageframe) {
        ll.add(new LatLon(Angle.fromDegreesLatitude(c[1]),Angle.fromDegreesLongitude(c[0])));
      }
      WWGeoImage gi=new WWGeoImage(new Polyline(ll,1000),new GlobeAnnotation(layer.getName() + ""String_Node_Str"",new Position(new LatLon(Angle.fromDegreesLatitude(imageframe.get(0)[1]),Angle.fromDegreesLongitude(imageframe.get(0)[0])),2000)),layer.isActive() ? Color.CYAN : Color.BLUE,layer.isActive() ? Color.CYAN : Color.BLUE);
      gi.setAnnotationVisible(layer.isActive());
      gi.setDelegateOwner(layer);
      imageLayer.addRenderable(gi);
    }
  }
 catch (  Exception e) {
    logger.error(e.getMessage(),e);
  }
}",0.9914271306101866
175101,"/** 
 * Creates new form WWJPanel 
 */
public WWJPanel(){
  initComponents();
  CatalogPanel catalogPanel=new CatalogPanel(this);
  catalogPanel.setSize(new Dimension(200,jTabbedPane1.getHeight() / 2));
  catalogPanel.setBorder(new LineBorder(new Color(255)));
  jTabbedPane1.add(""String_Node_Str"",catalogPanel);
  PlanningPanel planningPanel=new PlanningPanel(this);
  jTabbedPane1.add(""String_Node_Str"",planningPanel);
  this.addComponentListener(new ComponentListener(){
    @Override public void componentShown(    ComponentEvent e){
      if (acquisitionLayer == null) {
        acquisitionLayer=new TimeRenderableLayer();
        wwjCanvas.getModel().getLayers().add(acquisitionLayer);
      }
      if (imageLayer == null) {
        imageLayer=new TimeRenderableLayer();
        wwjCanvas.getModel().getLayers().add(imageLayer);
      }
    }
    @Override public void componentResized(    ComponentEvent e){
    }
    @Override public void componentMoved(    ComponentEvent e){
    }
    @Override public void componentHidden(    ComponentEvent e){
    }
  }
);
}","/** 
 * Creates new form WWJPanel 
 */
public WWJPanel(){
  initComponents();
  CatalogPanel catalogPanel=new CatalogPanel(this);
  catalogPanel.setSize(new Dimension(200,jTabbedPane1.getHeight() / 2));
  catalogPanel.setBorder(new LineBorder(new Color(255)));
  jTabbedPane1.add(""String_Node_Str"",catalogPanel);
  PlanningPanel planningPanel=new PlanningPanel(this);
  jTabbedPane1.add(""String_Node_Str"",planningPanel);
  this.addComponentListener(new ComponentListener(){
    @Override public void componentShown(    ComponentEvent e){
      initGlobe();
    }
    @Override public void componentResized(    ComponentEvent e){
    }
    @Override public void componentMoved(    ComponentEvent e){
    }
    @Override public void componentHidden(    ComponentEvent e){
    }
  }
);
}",0.8334231805929919
175102,"public static List<ImagePlanning> getImagePlanning(String dbname) throws Exception {
  List<ImagePlanning> listImageplanning=new ArrayList<ImagePlanning>();
  Connection conn=DriverManager.getConnection(""String_Node_Str"" + dbname + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String sqlCheckEx=""String_Node_Str"";
  Statement statEx=conn.createStatement();
  ResultSet res=statEx.executeQuery(sqlCheckEx);
  res.next();
  int count=res.getInt(1);
  if (count != 0) {
    Statement stat=conn.createStatement();
    String sql=""String_Node_Str"";
    res=stat.executeQuery(sql);
    WKTReader wktr=new WKTReader();
    Geometry imageGeom=null;
    while (!res.isClosed() && res.next()) {
      ImagePlanning imagePlanning=new ImagePlanning();
      imagePlanning.setName(res.getString(""String_Node_Str""));
      imagePlanning.setAcquisitionTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
      imagePlanning.setAcquisitionStopTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
      imagePlanning.setRemoteLocation(new URL(res.getString(""String_Node_Str"")));
      imagePlanning.setAction(res.getString(""String_Node_Str""));
      try {
        imageGeom=wktr.read(res.getString(""String_Node_Str""));
      }
 catch (      Exception e) {
        imageGeom=null;
      }
      imagePlanning.setArea(imageGeom);
      if (imagePlanning.getAcquisitionStopTime().getTime() - System.currentTimeMillis() < 0) {
        try {
          stat.execute(""String_Node_Str"" + res.getString(""String_Node_Str"") + ""String_Node_Str""+ res.getString(""String_Node_Str"")+ ""String_Node_Str"");
        }
 catch (        Exception e) {
          System.out.println(""String_Node_Str"" + res.getString(""String_Node_Str""));
        }
      }
 else {
        listImageplanning.add(imagePlanning);
      }
    }
    stat.close();
    statEx.close();
    conn.close();
  }
  return listImageplanning;
}","public static List<ImagePlanning> getImagePlanning(String dbname) throws Exception {
  List<ImagePlanning> listImageplanning=new ArrayList<ImagePlanning>();
  Connection conn=DriverManager.getConnection(""String_Node_Str"" + dbname + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String sqlCheckEx=""String_Node_Str"";
  Statement statEx=conn.createStatement();
  ResultSet res=statEx.executeQuery(sqlCheckEx);
  res.next();
  int count=res.getInt(1);
  if (count != 0) {
    Statement stat=conn.createStatement();
    String sql=""String_Node_Str"";
    res=stat.executeQuery(sql);
    WKTReader wktr=new WKTReader();
    Geometry imageGeom=null;
    while (!res.isClosed() && res.next()) {
      ImagePlanning imagePlanning=new ImagePlanning();
      imagePlanning.setName(res.getString(""String_Node_Str""));
      imagePlanning.setAcquisitionTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
      imagePlanning.setAcquisitionStopTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
      imagePlanning.setRemoteLocation(new URL(res.getString(""String_Node_Str"")));
      imagePlanning.setAction(res.getString(""String_Node_Str""));
      try {
        imageGeom=wktr.read(res.getString(""String_Node_Str""));
      }
 catch (      Exception e) {
        imageGeom=null;
      }
      imagePlanning.setArea(imageGeom);
      if (imagePlanning.getAcquisitionStopTime().getTime() - System.currentTimeMillis() < 0) {
        try {
          stat.execute(""String_Node_Str"" + res.getString(""String_Node_Str"") + ""String_Node_Str""+ res.getString(""String_Node_Str"")+ ""String_Node_Str"");
        }
 catch (        Exception e) {
          System.out.println(""String_Node_Str"" + res.getString(""String_Node_Str""));
        }
      }
 else {
        listImageplanning.add(imagePlanning);
      }
    }
    stat.close();
    conn.close();
  }
  statEx.close();
  return listImageplanning;
}",0.9752109704641352
175103,"public static List<ImagePlanning> getImagePlanning(String dbname) throws Exception {
  List<ImagePlanning> listImageplanning=new ArrayList<ImagePlanning>();
  Connection conn=DriverManager.getConnection(""String_Node_Str"" + dbname + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Statement stat=conn.createStatement();
  String sql=""String_Node_Str"";
  ResultSet res=stat.executeQuery(sql);
  WKTReader wktr=new WKTReader();
  Geometry imageGeom=null;
  while (!res.isClosed() && res.next()) {
    ImagePlanning imagePlanning=new ImagePlanning();
    imagePlanning.setName(res.getString(""String_Node_Str""));
    imagePlanning.setAcquisitionTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
    imagePlanning.setAcquisitionStopTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
    imagePlanning.setRemoteLocation(new URL(res.getString(""String_Node_Str"")));
    imagePlanning.setAction(res.getString(""String_Node_Str""));
    try {
      imageGeom=wktr.read(res.getString(""String_Node_Str""));
    }
 catch (    Exception e) {
      imageGeom=null;
    }
    imagePlanning.setArea(imageGeom);
    if (imagePlanning.getAcquisitionStopTime().getTime() - System.currentTimeMillis() < 0) {
      try {
        stat.execute(""String_Node_Str"" + res.getString(""String_Node_Str"") + ""String_Node_Str""+ res.getString(""String_Node_Str"")+ ""String_Node_Str"");
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"" + res.getString(""String_Node_Str""));
      }
    }
 else {
      listImageplanning.add(imagePlanning);
    }
  }
  stat.close();
  conn.close();
  return listImageplanning;
}","public static List<ImagePlanning> getImagePlanning(String dbname) throws Exception {
  List<ImagePlanning> listImageplanning=new ArrayList<ImagePlanning>();
  Connection conn=DriverManager.getConnection(""String_Node_Str"" + dbname + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String sqlCheckEx=""String_Node_Str"";
  Statement statEx=conn.createStatement();
  ResultSet res=statEx.executeQuery(sqlCheckEx);
  res.next();
  int count=res.getInt(1);
  if (count != 0) {
    Statement stat=conn.createStatement();
    String sql=""String_Node_Str"";
    res=stat.executeQuery(sql);
    WKTReader wktr=new WKTReader();
    Geometry imageGeom=null;
    while (!res.isClosed() && res.next()) {
      ImagePlanning imagePlanning=new ImagePlanning();
      imagePlanning.setName(res.getString(""String_Node_Str""));
      imagePlanning.setAcquisitionTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
      imagePlanning.setAcquisitionStopTime(Timestamp.valueOf(res.getString(""String_Node_Str"")));
      imagePlanning.setRemoteLocation(new URL(res.getString(""String_Node_Str"")));
      imagePlanning.setAction(res.getString(""String_Node_Str""));
      try {
        imageGeom=wktr.read(res.getString(""String_Node_Str""));
      }
 catch (      Exception e) {
        imageGeom=null;
      }
      imagePlanning.setArea(imageGeom);
      if (imagePlanning.getAcquisitionStopTime().getTime() - System.currentTimeMillis() < 0) {
        try {
          stat.execute(""String_Node_Str"" + res.getString(""String_Node_Str"") + ""String_Node_Str""+ res.getString(""String_Node_Str"")+ ""String_Node_Str"");
        }
 catch (        Exception e) {
          System.out.println(""String_Node_Str"" + res.getString(""String_Node_Str""));
        }
      }
 else {
        listImageplanning.add(imagePlanning);
      }
    }
    stat.close();
    statEx.close();
    conn.close();
  }
  return listImageplanning;
}",0.8683314415437003
175104,"public BlackBorderAnalysis(GeoImageReader gir,int hTileSize,int vTileSize,List<Geometry> land){
  this.gir=gir;
  int nb=gir.getNBand();
  if (nb > 1) {
    for (int i=0; i < nb; i++) {
      if (gir.getBandName(i).equalsIgnoreCase(""String_Node_Str"") || gir.getBandName(i).equalsIgnoreCase(""String_Node_Str"")) {
        bandAnalysis=i;
        break;
      }
    }
  }
  sizeX=hTileSize;
  sizeY=vTileSize;
  iNPixExtremes=tileSize / 10;
  this.land=land;
}","public BlackBorderAnalysis(GeoImageReader gir,int hTileSize,int vTileSize,List<Geometry> land){
  this.gir=gir;
  int nb=gir.getNBand();
  if (nb > 1) {
    for (int i=0; i < nb; i++) {
      if (gir.getBandName(i).equalsIgnoreCase(""String_Node_Str"") || gir.getBandName(i).equalsIgnoreCase(""String_Node_Str"")) {
        bandAnalysis=i;
        break;
      }
    }
  }
  sizeX=hTileSize;
  sizeY=vTileSize;
  iNPixExtremes=hTileSize < vTileSize ? vTileSize / 10 : hTileSize / 10;
  this.land=land;
}",0.9539748953974896
175105,"/** 
 * analyze single tile
 * @param row
 * @param col
 */
public void analyse(int row,int col,boolean horizontalAnalysis){
  int iniX=(col - 1) * sizeX;
  int iniY=(row - 1) * sizeY;
  boolean normalDirection=true;
  if ((iniX > (gir.getWidth() / 2) && horizontalAnalysis)) {
    normalDirection=false;
  }
  if ((iniY > (gir.getWidth() / 2) && !horizontalAnalysis)) {
    normalDirection=false;
  }
  analyzeTile(iniX,iniY,horizontalAnalysis,normalDirection);
}","/** 
 * analyze single tile
 * @param row
 * @param col
 * @return the threshold values for this tile
 */
public int[] analyse(int row,int col,boolean horizontalAnalysis){
  int iniX=(col - 1) * sizeX;
  int iniY=(row - 1) * sizeY;
  boolean normalDirection=true;
  if ((iniX > (gir.getWidth() / 2) && horizontalAnalysis)) {
    normalDirection=false;
  }
  if ((iniY > (gir.getWidth() / 2) && !horizontalAnalysis)) {
    normalDirection=false;
  }
  int[] trheshs=analyzeTile(iniX,iniY,horizontalAnalysis,normalDirection);
  return trheshs;
}",0.913604766633565
175106,"@Override public boolean executeFromConsole(){
  try {
    SarImageReader sar=(SarImageReader)SumoPlatform.getApplication().getCurrentImageReader();
    ImageLayer layer=LayerManager.getIstanceManager().getCurrentImageLayer();
    if (layer != null && commandLine.length >= 3) {
      String arg0=commandLine[1];
      String arg1=commandLine[2];
      String arg2=commandLine[3];
      if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        if (commandLine.length == 2 && arg1.equalsIgnoreCase(""String_Node_Str"")) {
          runBBAnalysis();
        }
 else {
          int row=Integer.parseInt(arg1);
          int col=Integer.parseInt(arg2);
          String direction=""String_Node_Str"";
          if (commandLine.length == 4)           direction=arg2;
          BlackBorderAnalysis borderAn=new BlackBorderAnalysis(sar,layer.getRealTileSizeX(),layer.getRealTileSizeY(),null);
          borderAn.analyse(row,col,direction.equalsIgnoreCase(""String_Node_Str""));
          yy=borderAn.getSizeY() * row;
          xx=borderAn.getSizeX() * col;
          tileSizeY=borderAn.getSizeY();
          tileSizeX=borderAn.getSizeX();
          com.vividsolutions.jts.geom.Polygon box=JTSUtil.createPolygon(xx,yy,layer.getRealTileSizeX(),layer.getRealTileSizeY());
          GeometryImage gi=new GeometryImage(arg2,box);
          SimpleGeometryLayer sgl=new SimpleGeometryLayer(layer,gi);
          LayerManager.addLayerInThread(sgl);
        }
      }
 else       if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        int row=Integer.parseInt(arg1);
        int col=Integer.parseInt(arg2);
        Float hh=1.5f;
        Float hv=1.5f;
        Float vh=1.5f;
        Float vv=1.5f;
        Float buffer=0.0f;
        if (commandLine.length >= 5) {
          buffer=Float.parseFloat(commandLine[4]);
          hh=Float.parseFloat(commandLine[5]);
          hv=Float.parseFloat(commandLine[6]);
          vh=Float.parseFloat(commandLine[7]);
          vv=Float.parseFloat(commandLine[8]);
        }
        MaskVectorLayer coastlineMask=null;
        MaskVectorLayer iceMasks=null;
        for (        ILayer l : LayerManager.getIstanceManager().getChilds(layer)) {
          if (l instanceof IMask) {
            if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.COASTLINE_MASK) {
              coastlineMask=(MaskVectorLayer)l;
            }
 else             if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.ICE_MASK) {
              iceMasks=(MaskVectorLayer)l;
            }
          }
        }
        MaskGeometries mg=null;
        IMask bufferedMask=null;
        if (coastlineMask != null) {
          bufferedMask=FactoryLayer.createMaskLayer(coastlineMask.getName(),coastlineMask.getType(),0,((MaskVectorLayer)coastlineMask).getGeometriclayer(),coastlineMask.getMaskType());
          mg=new MaskGeometries(""String_Node_Str"",bufferedMask.getGeometries());
        }
        MaskGeometries ice=null;
        IMask iceMask=null;
        if (iceMasks != null) {
          iceMask=FactoryLayer.createMaskLayer(iceMasks.getName(),iceMasks.getType(),0,((MaskVectorLayer)iceMasks).getGeometriclayer(),iceMasks.getMaskType());
          ice=new MaskGeometries(""String_Node_Str"",iceMask.getGeometries());
        }
        VDSAnalysis analysis=new VDSAnalysis(sar,mg,ice,Float.parseFloat(sar.getENL()),new Float[]{hh,hv,vh,vv},layer.getRealTileSizeX(),layer.getRealTileSizeY(),layer.getHorizontalTilesImage(),layer.getVerticalTilesImage());
        analysis.setAnalyseSingleTile(true);
        analysis.setxTileToAnalyze(col);
        analysis.setyTileToAnalyze(row);
        proc=new AnalysisProcess(sar,Float.parseFloat(sar.getENL()),analysis,0,0,null);
        proc.addProcessListener(this);
        Thread t=new Thread(proc);
        t.setName(""String_Node_Str"" + sar.getDisplayName(0));
        t.start();
        yy=layer.getRealTileSizeY() * row;
        xx=layer.getRealTileSizeX() * col;
        tileSizeY=layer.getRealTileSizeY();
        tileSizeX=layer.getRealTileSizeX();
      }
    }
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
    return false;
  }
 finally {
  }
  return true;
}","@Override public boolean executeFromConsole(){
  try {
    SarImageReader sar=(SarImageReader)SumoPlatform.getApplication().getCurrentImageReader();
    ImageLayer layer=LayerManager.getIstanceManager().getCurrentImageLayer();
    if (layer != null && commandLine.length >= 3) {
      String arg0=commandLine[1];
      String arg1=commandLine[2];
      String arg2=commandLine[3];
      if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        if (commandLine.length == 2 && arg1.equalsIgnoreCase(""String_Node_Str"")) {
          runBBAnalysis();
        }
 else {
          int row=Integer.parseInt(arg1);
          int col=Integer.parseInt(arg2);
          yy=layer.getRealTileSizeY() * row;
          xx=layer.getRealTileSizeX() * col;
          tileSizeY=layer.getRealTileSizeY();
          tileSizeX=layer.getRealTileSizeY();
          String direction=""String_Node_Str"";
          if (commandLine.length == 5)           direction=commandLine[4];
          BlackBorderAnalysis borderAn=new BlackBorderAnalysis(sar,layer.getRealTileSizeX(),layer.getRealTileSizeY(),null);
          int[] threshs=borderAn.analyse(row,col,direction.equalsIgnoreCase(""String_Node_Str""));
          List<Geometry> points=new ArrayList<>();
          GeometryFactory gf=new GeometryFactory();
          for (int i=0; i < threshs.length; i++) {
            int offset=threshs[i];
            if (direction.equalsIgnoreCase(""String_Node_Str"")) {
              if (xx < (sar.getWidth() / 2)) {
                Point p=gf.createPoint(new Coordinate(xx + offset,yy + i));
                points.add(p);
              }
            }
 else {
            }
          }
          GeometryImage giPoint=new GeometryImage(arg2,points);
          SimpleGeometryLayer offset=new SimpleGeometryLayer(layer,""String_Node_Str"" + row + ""String_Node_Str""+ col,giPoint);
          offset.setColor(Color.ORANGE);
          offset.setWidth(2.0f);
          LayerManager.addLayerInThread(offset);
          com.vividsolutions.jts.geom.Polygon box=JTSUtil.createPolygon(xx,yy,layer.getRealTileSizeX(),layer.getRealTileSizeY());
          List<Geometry> geoms=new ArrayList<>();
          geoms.add(box);
          GeometryImage gi=new GeometryImage(arg2,geoms);
          SimpleGeometryLayer sgl=new SimpleGeometryLayer(layer,""String_Node_Str"" + row + ""String_Node_Str""+ col,gi);
          sgl.setColor(Color.ORANGE);
          sgl.setWidth(2.0f);
          LayerManager.addLayerInThread(sgl);
        }
      }
 else       if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        int row=Integer.parseInt(arg1);
        int col=Integer.parseInt(arg2);
        Float hh=1.5f;
        Float hv=1.5f;
        Float vh=1.5f;
        Float vv=1.5f;
        Float buffer=0.0f;
        if (commandLine.length >= 5) {
          buffer=Float.parseFloat(commandLine[4]);
          hh=Float.parseFloat(commandLine[5]);
          hv=Float.parseFloat(commandLine[6]);
          vh=Float.parseFloat(commandLine[7]);
          vv=Float.parseFloat(commandLine[8]);
        }
        MaskVectorLayer coastlineMask=null;
        MaskVectorLayer iceMasks=null;
        for (        ILayer l : LayerManager.getIstanceManager().getChilds(layer)) {
          if (l instanceof IMask) {
            if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.COASTLINE_MASK) {
              coastlineMask=(MaskVectorLayer)l;
            }
 else             if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.ICE_MASK) {
              iceMasks=(MaskVectorLayer)l;
            }
          }
        }
        MaskGeometries mg=null;
        IMask bufferedMask=null;
        if (coastlineMask != null) {
          bufferedMask=FactoryLayer.createMaskLayer(coastlineMask.getName(),coastlineMask.getType(),0,((MaskVectorLayer)coastlineMask).getGeometriclayer(),coastlineMask.getMaskType());
          mg=new MaskGeometries(""String_Node_Str"",bufferedMask.getGeometries());
        }
        MaskGeometries ice=null;
        IMask iceMask=null;
        if (iceMasks != null) {
          iceMask=FactoryLayer.createMaskLayer(iceMasks.getName(),iceMasks.getType(),0,((MaskVectorLayer)iceMasks).getGeometriclayer(),iceMasks.getMaskType());
          ice=new MaskGeometries(""String_Node_Str"",iceMask.getGeometries());
        }
        VDSAnalysis analysis=new VDSAnalysis(sar,mg,ice,Float.parseFloat(sar.getENL()),new Float[]{hh,hv,vh,vv},layer.getRealTileSizeX(),layer.getRealTileSizeY(),layer.getHorizontalTilesImage(),layer.getVerticalTilesImage());
        analysis.setAnalyseSingleTile(true);
        analysis.setxTileToAnalyze(col);
        analysis.setyTileToAnalyze(row);
        proc=new AnalysisProcess(sar,Float.parseFloat(sar.getENL()),analysis,0,0,null);
        proc.addProcessListener(this);
        Thread t=new Thread(proc);
        t.setName(""String_Node_Str"" + sar.getDisplayName(0));
        t.start();
        yy=layer.getRealTileSizeY() * row;
        xx=layer.getRealTileSizeX() * col;
        tileSizeY=layer.getRealTileSizeY();
        tileSizeX=layer.getRealTileSizeX();
      }
    }
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
    return false;
  }
 finally {
  }
  return true;
}",0.8520671834625323
175107,"public void render(Object gcC){
  OpenGLContext context=(OpenGLContext)gcC;
  if (!context.isDirty()) {
    return;
  }
  int x=context.getX();
  int y=context.getY();
  float zoom=context.getZoom();
  float width=context.getWidth() * zoom;
  float height=context.getHeight() * zoom;
  GL2 gl=context.getGL().getGL2();
  float[] c=color.getColorComponents(null);
  gl.glColor3f(c[0],c[1],c[2]);
  if (geometries != null) {
    if (getType().equalsIgnoreCase(POINT)) {
switch (this.displaysymbol) {
case point:
{
          gl.glPointSize(this.renderWidth);
          gl.glBegin(GL.GL_POINTS);
          for (          Geometry temp : geometries) {
            Coordinate point=temp.getCoordinate();
            gl.glVertex2d((point.x - x) / width,1 - (point.y - y) / height);
          }
          gl.glEnd();
          gl.glFlush();
        }
      break;
case circle:
{
      gl.glBegin(GL.GL_LINE_LOOP);
      gl.glLineWidth(this.renderWidth);
      for (      Geometry temp : geometries) {
        Coordinate point=temp.getCoordinate();
        double dx=(point.x - x) / width;
        double dy=1 - (point.y - y) / height;
        for (int i=0; i < 360; i++) {
          double angle=2 * Math.PI * i / 300;
          double xx=Math.cos(angle);
          double yy=Math.sin(angle);
          gl.glVertex2d(xx + dx,yy + dy);
        }
      }
      gl.glEnd();
      gl.glFlush();
    }
  break;
case square:
{
  for (  Geometry temp : geometries) {
    gl.glLineWidth(this.renderWidth);
    Coordinate point=new Coordinate(temp.getCoordinate());
    point.x=(point.x - x) / width;
    point.y=1 - (point.y - y) / height;
    double rectwidth=0.01;
    gl.glBegin(GL.GL_LINE_STRIP);
    gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
    gl.glVertex2d(point.x - rectwidth,point.y + rectwidth);
    gl.glVertex2d(point.x + rectwidth,point.y + rectwidth);
    gl.glVertex2d(point.x + rectwidth,point.y - rectwidth);
    gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
    gl.glEnd();
    gl.glFlush();
  }
}
break;
case cross:
{
for (Geometry temp : geometries) {
gl.glLineWidth(this.renderWidth);
Coordinate point=new Coordinate(temp.getCoordinate());
point.x=(point.x - x) / width;
point.y=1 - (point.y - y) / height;
double rectwidth=0.01;
gl.glBegin(GL.GL_LINE_STRIP);
gl.glVertex2d(point.x - rectwidth,point.y);
gl.glVertex2d(point.x + rectwidth,point.y);
gl.glEnd();
gl.glBegin(GL.GL_LINE_STRIP);
gl.glVertex2d(point.x,point.y - rectwidth);
gl.glVertex2d(point.x,point.y + rectwidth);
gl.glEnd();
gl.glFlush();
}
}
break;
case triangle:
{
for (Geometry temp : geometries) {
gl.glLineWidth(this.renderWidth);
Coordinate point=new Coordinate(temp.getCoordinate());
point.x=(point.x - x) / width;
point.y=1 - (point.y - y) / height;
double rectwidth=0.01;
gl.glBegin(GL.GL_LINE_STRIP);
gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
gl.glVertex2d(point.x,point.y + rectwidth);
gl.glVertex2d(point.x + rectwidth,point.y - rectwidth);
gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
gl.glEnd();
gl.glFlush();
}
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(POLYGON)) {
for (Geometry tmp : geometries) {
Polygon polygon=(Polygon)tmp;
if (polygon.getCoordinates().length < 1) {
continue;
}
float rWidth=this.renderWidth;
int interior=polygon.getNumInteriorRing();
if (interior > 0) {
LineString line=polygon.getExteriorRing();
drawPoly(gl,line.getCoordinates(),width,height,x,y,rWidth);
for (int i=0; i < interior; i++) {
LineString line2=polygon.getInteriorRingN(i);
drawPoly(gl,line2.getCoordinates(),width,height,x,y,rWidth);
}
}
 else {
drawPoly(gl,polygon.getCoordinates(),width,height,x,y,rWidth);
}
}
}
 else if (getType().equalsIgnoreCase(LINESTRING)) {
for (Geometry temp : geometries) {
if (temp.getCoordinates().length < 1) {
continue;
}
gl.glLineWidth(this.renderWidth);
gl.glBegin(GL.GL_LINE_STRIP);
Coordinate[] cs=temp.getCoordinates();
for (int p=0; p < cs.length; p++) {
gl.glVertex2d((cs[p].x - x) / width,1 - (cs[p].y - y) / height);
}
gl.glEnd();
gl.glFlush();
}
}
}
}","public void render(Object gcC){
  OpenGLContext context=(OpenGLContext)gcC;
  if (!context.isDirty()) {
    return;
  }
  int x=context.getX();
  int y=context.getY();
  float zoom=context.getZoom();
  float width=context.getWidth() * zoom;
  float height=context.getHeight() * zoom;
  GL2 gl=context.getGL().getGL2();
  float[] c=color.getColorComponents(null);
  gl.glColor3f(c[0],c[1],c[2]);
  if (geometries != null) {
    if (getType().equalsIgnoreCase(POINT) || getType().equalsIgnoreCase(MIXED)) {
switch (this.displaysymbol) {
case point:
{
          gl.glPointSize(this.renderWidth);
          gl.glBegin(GL.GL_POINTS);
          for (          Geometry temp : geometries) {
            Coordinate point=temp.getCoordinate();
            gl.glVertex2d((point.x - x) / width,1 - (point.y - y) / height);
          }
          gl.glEnd();
          gl.glFlush();
        }
      break;
case circle:
{
      gl.glBegin(GL.GL_LINE_LOOP);
      gl.glLineWidth(this.renderWidth);
      for (      Geometry temp : geometries) {
        Coordinate point=temp.getCoordinate();
        double dx=(point.x - x) / width;
        double dy=1 - (point.y - y) / height;
        for (int i=0; i < 360; i++) {
          double angle=2 * Math.PI * i / 300;
          double xx=Math.cos(angle);
          double yy=Math.sin(angle);
          gl.glVertex2d(xx + dx,yy + dy);
        }
      }
      gl.glEnd();
      gl.glFlush();
    }
  break;
case square:
{
  for (  Geometry temp : geometries) {
    gl.glLineWidth(this.renderWidth);
    Coordinate point=new Coordinate(temp.getCoordinate());
    point.x=(point.x - x) / width;
    point.y=1 - (point.y - y) / height;
    double rectwidth=0.01;
    gl.glBegin(GL.GL_LINE_STRIP);
    gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
    gl.glVertex2d(point.x - rectwidth,point.y + rectwidth);
    gl.glVertex2d(point.x + rectwidth,point.y + rectwidth);
    gl.glVertex2d(point.x + rectwidth,point.y - rectwidth);
    gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
    gl.glEnd();
    gl.glFlush();
  }
}
break;
case cross:
{
for (Geometry temp : geometries) {
gl.glLineWidth(this.renderWidth);
Coordinate point=new Coordinate(temp.getCoordinate());
point.x=(point.x - x) / width;
point.y=1 - (point.y - y) / height;
double rectwidth=0.01;
gl.glBegin(GL.GL_LINE_STRIP);
gl.glVertex2d(point.x - rectwidth,point.y);
gl.glVertex2d(point.x + rectwidth,point.y);
gl.glEnd();
gl.glBegin(GL.GL_LINE_STRIP);
gl.glVertex2d(point.x,point.y - rectwidth);
gl.glVertex2d(point.x,point.y + rectwidth);
gl.glEnd();
gl.glFlush();
}
}
break;
case triangle:
{
for (Geometry temp : geometries) {
gl.glLineWidth(this.renderWidth);
Coordinate point=new Coordinate(temp.getCoordinate());
point.x=(point.x - x) / width;
point.y=1 - (point.y - y) / height;
double rectwidth=0.01;
gl.glBegin(GL.GL_LINE_STRIP);
gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
gl.glVertex2d(point.x,point.y + rectwidth);
gl.glVertex2d(point.x + rectwidth,point.y - rectwidth);
gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
gl.glEnd();
gl.glFlush();
}
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(POLYGON)) {
for (Geometry tmp : geometries) {
Polygon polygon=(Polygon)tmp;
if (polygon.getCoordinates().length < 1) {
continue;
}
float rWidth=this.renderWidth;
int interior=polygon.getNumInteriorRing();
if (interior > 0) {
LineString line=polygon.getExteriorRing();
drawPoly(gl,line.getCoordinates(),width,height,x,y,rWidth);
for (int i=0; i < interior; i++) {
LineString line2=polygon.getInteriorRingN(i);
drawPoly(gl,line2.getCoordinates(),width,height,x,y,rWidth);
}
}
 else {
drawPoly(gl,polygon.getCoordinates(),width,height,x,y,rWidth);
}
}
}
 else if (getType().equalsIgnoreCase(LINESTRING)) {
for (Geometry temp : geometries) {
if (temp.getCoordinates().length < 1) {
continue;
}
gl.glLineWidth(this.renderWidth);
gl.glBegin(GL.GL_LINE_STRIP);
Coordinate[] cs=temp.getCoordinates();
for (int p=0; p < cs.length; p++) {
gl.glVertex2d((cs[p].x - x) / width,1 - (cs[p].y - y) / height);
}
gl.glEnd();
gl.glFlush();
}
}
}
}",0.9954405422057916
175108,"public BlackBorderAnalysis(GeoImageReader gir,int hTileSize,int vTileSize,List<Geometry> land){
  this.gir=gir;
  int nb=gir.getNBand();
  if (nb > 1) {
    for (int i=0; i < nb; i++) {
      if (gir.getBandName(i).equalsIgnoreCase(""String_Node_Str"") || gir.getBandName(i).equalsIgnoreCase(""String_Node_Str"")) {
        bandAnalysis=i;
        break;
      }
    }
  }
  sizeX=hTileSize;
  sizeY=vTileSize;
  iNPixExtremes=tileSize / 10;
  this.land=land;
}","public BlackBorderAnalysis(GeoImageReader gir,int hTileSize,int vTileSize,List<Geometry> land){
  this.gir=gir;
  int nb=gir.getNBand();
  if (nb > 1) {
    for (int i=0; i < nb; i++) {
      if (gir.getBandName(i).equalsIgnoreCase(""String_Node_Str"") || gir.getBandName(i).equalsIgnoreCase(""String_Node_Str"")) {
        bandAnalysis=i;
        break;
      }
    }
  }
  sizeX=hTileSize;
  sizeY=vTileSize;
  iNPixExtremes=hTileSize < vTileSize ? vTileSize / 10 : hTileSize / 10;
  this.land=land;
}",0.9539748953974896
175109,"/** 
 * analyze single tile
 * @param row
 * @param col
 */
public void analyse(int row,int col,boolean horizontalAnalysis){
  int iniX=(col - 1) * sizeX;
  int iniY=(row - 1) * sizeY;
  boolean normalDirection=true;
  if ((iniX > (gir.getWidth() / 2) && horizontalAnalysis)) {
    normalDirection=false;
  }
  if ((iniY > (gir.getWidth() / 2) && !horizontalAnalysis)) {
    normalDirection=false;
  }
  analyzeTile(iniX,iniY,horizontalAnalysis,normalDirection);
}","/** 
 * analyze single tile
 * @param row
 * @param col
 * @return the threshold values for this tile
 */
public int[] analyse(int row,int col,boolean horizontalAnalysis){
  int iniX=(col - 1) * sizeX;
  int iniY=(row - 1) * sizeY;
  boolean normalDirection=true;
  if ((iniX > (gir.getWidth() / 2) && horizontalAnalysis)) {
    normalDirection=false;
  }
  if ((iniY > (gir.getWidth() / 2) && !horizontalAnalysis)) {
    normalDirection=false;
  }
  int[] trheshs=analyzeTile(iniX,iniY,horizontalAnalysis,normalDirection);
  return trheshs;
}",0.913604766633565
175110,"@Override public boolean executeFromConsole(){
  try {
    SarImageReader sar=(SarImageReader)SumoPlatform.getApplication().getCurrentImageReader();
    ImageLayer layer=LayerManager.getIstanceManager().getCurrentImageLayer();
    if (layer != null && commandLine.length >= 3) {
      String arg0=commandLine[1];
      String arg1=commandLine[2];
      String arg2=commandLine[3];
      if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        if (commandLine.length == 2 && arg1.equalsIgnoreCase(""String_Node_Str"")) {
          runBBAnalysis();
        }
 else {
          int row=Integer.parseInt(arg1);
          int col=Integer.parseInt(arg2);
          String direction=""String_Node_Str"";
          if (commandLine.length == 4)           direction=arg2;
          BlackBorderAnalysis borderAn=new BlackBorderAnalysis(sar,layer.getRealTileSizeX(),layer.getRealTileSizeY(),null);
          borderAn.analyse(row,col,direction.equalsIgnoreCase(""String_Node_Str""));
          yy=borderAn.getSizeY() * row;
          xx=borderAn.getSizeX() * col;
          tileSizeY=borderAn.getSizeY();
          tileSizeX=borderAn.getSizeX();
          com.vividsolutions.jts.geom.Polygon box=JTSUtil.createPolygon(xx,yy,layer.getRealTileSizeX(),layer.getRealTileSizeY());
          GeometryImage gi=new GeometryImage(arg2,box);
          SimpleGeometryLayer sgl=new SimpleGeometryLayer(layer,gi);
          LayerManager.addLayerInThread(sgl);
        }
      }
 else       if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        int row=Integer.parseInt(arg1);
        int col=Integer.parseInt(arg2);
        Float hh=1.5f;
        Float hv=1.5f;
        Float vh=1.5f;
        Float vv=1.5f;
        Float buffer=0.0f;
        if (commandLine.length >= 5) {
          buffer=Float.parseFloat(commandLine[4]);
          hh=Float.parseFloat(commandLine[5]);
          hv=Float.parseFloat(commandLine[6]);
          vh=Float.parseFloat(commandLine[7]);
          vv=Float.parseFloat(commandLine[8]);
        }
        MaskVectorLayer coastlineMask=null;
        MaskVectorLayer iceMasks=null;
        for (        ILayer l : LayerManager.getIstanceManager().getChilds(layer)) {
          if (l instanceof IMask) {
            if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.COASTLINE_MASK) {
              coastlineMask=(MaskVectorLayer)l;
            }
 else             if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.ICE_MASK) {
              iceMasks=(MaskVectorLayer)l;
            }
          }
        }
        MaskGeometries mg=null;
        IMask bufferedMask=null;
        if (coastlineMask != null) {
          bufferedMask=FactoryLayer.createMaskLayer(coastlineMask.getName(),coastlineMask.getType(),0,((MaskVectorLayer)coastlineMask).getGeometriclayer(),coastlineMask.getMaskType());
          mg=new MaskGeometries(""String_Node_Str"",bufferedMask.getGeometries());
        }
        MaskGeometries ice=null;
        IMask iceMask=null;
        if (iceMasks != null) {
          iceMask=FactoryLayer.createMaskLayer(iceMasks.getName(),iceMasks.getType(),0,((MaskVectorLayer)iceMasks).getGeometriclayer(),iceMasks.getMaskType());
          ice=new MaskGeometries(""String_Node_Str"",iceMask.getGeometries());
        }
        VDSAnalysis analysis=new VDSAnalysis(sar,mg,ice,Float.parseFloat(sar.getENL()),new Float[]{hh,hv,vh,vv},layer.getRealTileSizeX(),layer.getRealTileSizeY(),layer.getHorizontalTilesImage(),layer.getVerticalTilesImage());
        analysis.setAnalyseSingleTile(true);
        analysis.setxTileToAnalyze(col);
        analysis.setyTileToAnalyze(row);
        proc=new AnalysisProcess(sar,Float.parseFloat(sar.getENL()),analysis,0,0,null);
        proc.addProcessListener(this);
        Thread t=new Thread(proc);
        t.setName(""String_Node_Str"" + sar.getDisplayName(0));
        t.start();
        yy=layer.getRealTileSizeY() * row;
        xx=layer.getRealTileSizeX() * col;
        tileSizeY=layer.getRealTileSizeY();
        tileSizeX=layer.getRealTileSizeX();
      }
    }
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
    return false;
  }
 finally {
  }
  return true;
}","@Override public boolean executeFromConsole(){
  try {
    SarImageReader sar=(SarImageReader)SumoPlatform.getApplication().getCurrentImageReader();
    ImageLayer layer=LayerManager.getIstanceManager().getCurrentImageLayer();
    if (layer != null && commandLine.length >= 3) {
      String arg0=commandLine[1];
      String arg1=commandLine[2];
      String arg2=commandLine[3];
      if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        if (commandLine.length == 2 && arg1.equalsIgnoreCase(""String_Node_Str"")) {
          runBBAnalysis();
        }
 else {
          int row=Integer.parseInt(arg1);
          int col=Integer.parseInt(arg2);
          yy=layer.getRealTileSizeY() * row;
          xx=layer.getRealTileSizeX() * col;
          tileSizeY=layer.getRealTileSizeY();
          tileSizeX=layer.getRealTileSizeY();
          String direction=""String_Node_Str"";
          if (commandLine.length == 5)           direction=commandLine[4];
          BlackBorderAnalysis borderAn=new BlackBorderAnalysis(sar,layer.getRealTileSizeX(),layer.getRealTileSizeY(),null);
          int[] threshs=borderAn.analyse(row,col,direction.equalsIgnoreCase(""String_Node_Str""));
          List<Geometry> points=new ArrayList<>();
          GeometryFactory gf=new GeometryFactory();
          for (int i=0; i < threshs.length; i++) {
            int offset=threshs[i];
            if (direction.equalsIgnoreCase(""String_Node_Str"")) {
              if (xx < (sar.getWidth() / 2)) {
                Point p=gf.createPoint(new Coordinate(xx + offset,yy + i));
                points.add(p);
              }
            }
 else {
            }
          }
          GeometryImage giPoint=new GeometryImage(arg2,points);
          SimpleGeometryLayer offset=new SimpleGeometryLayer(layer,""String_Node_Str"" + row + ""String_Node_Str""+ col,giPoint);
          offset.setColor(Color.ORANGE);
          offset.setWidth(2.0f);
          LayerManager.addLayerInThread(offset);
          com.vividsolutions.jts.geom.Polygon box=JTSUtil.createPolygon(xx,yy,layer.getRealTileSizeX(),layer.getRealTileSizeY());
          List<Geometry> geoms=new ArrayList<>();
          geoms.add(box);
          GeometryImage gi=new GeometryImage(arg2,geoms);
          SimpleGeometryLayer sgl=new SimpleGeometryLayer(layer,""String_Node_Str"" + row + ""String_Node_Str""+ col,gi);
          sgl.setColor(Color.ORANGE);
          sgl.setWidth(2.0f);
          LayerManager.addLayerInThread(sgl);
        }
      }
 else       if (arg0.equalsIgnoreCase(""String_Node_Str"")) {
        int row=Integer.parseInt(arg1);
        int col=Integer.parseInt(arg2);
        Float hh=1.5f;
        Float hv=1.5f;
        Float vh=1.5f;
        Float vv=1.5f;
        Float buffer=0.0f;
        if (commandLine.length >= 5) {
          buffer=Float.parseFloat(commandLine[4]);
          hh=Float.parseFloat(commandLine[5]);
          hv=Float.parseFloat(commandLine[6]);
          vh=Float.parseFloat(commandLine[7]);
          vv=Float.parseFloat(commandLine[8]);
        }
        MaskVectorLayer coastlineMask=null;
        MaskVectorLayer iceMasks=null;
        for (        ILayer l : LayerManager.getIstanceManager().getChilds(layer)) {
          if (l instanceof IMask) {
            if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.COASTLINE_MASK) {
              coastlineMask=(MaskVectorLayer)l;
            }
 else             if (((MaskVectorLayer)l).getMaskType() == MaskVectorLayer.ICE_MASK) {
              iceMasks=(MaskVectorLayer)l;
            }
          }
        }
        MaskGeometries mg=null;
        IMask bufferedMask=null;
        if (coastlineMask != null) {
          bufferedMask=FactoryLayer.createMaskLayer(coastlineMask.getName(),coastlineMask.getType(),0,((MaskVectorLayer)coastlineMask).getGeometriclayer(),coastlineMask.getMaskType());
          mg=new MaskGeometries(""String_Node_Str"",bufferedMask.getGeometries());
        }
        MaskGeometries ice=null;
        IMask iceMask=null;
        if (iceMasks != null) {
          iceMask=FactoryLayer.createMaskLayer(iceMasks.getName(),iceMasks.getType(),0,((MaskVectorLayer)iceMasks).getGeometriclayer(),iceMasks.getMaskType());
          ice=new MaskGeometries(""String_Node_Str"",iceMask.getGeometries());
        }
        VDSAnalysis analysis=new VDSAnalysis(sar,mg,ice,Float.parseFloat(sar.getENL()),new Float[]{hh,hv,vh,vv},layer.getRealTileSizeX(),layer.getRealTileSizeY(),layer.getHorizontalTilesImage(),layer.getVerticalTilesImage());
        analysis.setAnalyseSingleTile(true);
        analysis.setxTileToAnalyze(col);
        analysis.setyTileToAnalyze(row);
        proc=new AnalysisProcess(sar,Float.parseFloat(sar.getENL()),analysis,0,0,null);
        proc.addProcessListener(this);
        Thread t=new Thread(proc);
        t.setName(""String_Node_Str"" + sar.getDisplayName(0));
        t.start();
        yy=layer.getRealTileSizeY() * row;
        xx=layer.getRealTileSizeX() * col;
        tileSizeY=layer.getRealTileSizeY();
        tileSizeX=layer.getRealTileSizeX();
      }
    }
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
    return false;
  }
 finally {
  }
  return true;
}",0.8520671834625323
175111,"public void render(Object gcC){
  OpenGLContext context=(OpenGLContext)gcC;
  if (!context.isDirty()) {
    return;
  }
  int x=context.getX();
  int y=context.getY();
  float zoom=context.getZoom();
  float width=context.getWidth() * zoom;
  float height=context.getHeight() * zoom;
  GL2 gl=context.getGL().getGL2();
  float[] c=color.getColorComponents(null);
  gl.glColor3f(c[0],c[1],c[2]);
  if (geometries != null) {
    if (getType().equalsIgnoreCase(POINT)) {
switch (this.displaysymbol) {
case point:
{
          gl.glPointSize(this.renderWidth);
          gl.glBegin(GL.GL_POINTS);
          for (          Geometry temp : geometries) {
            Coordinate point=temp.getCoordinate();
            gl.glVertex2d((point.x - x) / width,1 - (point.y - y) / height);
          }
          gl.glEnd();
          gl.glFlush();
        }
      break;
case circle:
{
      gl.glBegin(GL.GL_LINE_LOOP);
      gl.glLineWidth(this.renderWidth);
      for (      Geometry temp : geometries) {
        Coordinate point=temp.getCoordinate();
        double dx=(point.x - x) / width;
        double dy=1 - (point.y - y) / height;
        for (int i=0; i < 360; i++) {
          double angle=2 * Math.PI * i / 300;
          double xx=Math.cos(angle);
          double yy=Math.sin(angle);
          gl.glVertex2d(xx + dx,yy + dy);
        }
      }
      gl.glEnd();
      gl.glFlush();
    }
  break;
case square:
{
  for (  Geometry temp : geometries) {
    gl.glLineWidth(this.renderWidth);
    Coordinate point=new Coordinate(temp.getCoordinate());
    point.x=(point.x - x) / width;
    point.y=1 - (point.y - y) / height;
    double rectwidth=0.01;
    gl.glBegin(GL.GL_LINE_STRIP);
    gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
    gl.glVertex2d(point.x - rectwidth,point.y + rectwidth);
    gl.glVertex2d(point.x + rectwidth,point.y + rectwidth);
    gl.glVertex2d(point.x + rectwidth,point.y - rectwidth);
    gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
    gl.glEnd();
    gl.glFlush();
  }
}
break;
case cross:
{
for (Geometry temp : geometries) {
gl.glLineWidth(this.renderWidth);
Coordinate point=new Coordinate(temp.getCoordinate());
point.x=(point.x - x) / width;
point.y=1 - (point.y - y) / height;
double rectwidth=0.01;
gl.glBegin(GL.GL_LINE_STRIP);
gl.glVertex2d(point.x - rectwidth,point.y);
gl.glVertex2d(point.x + rectwidth,point.y);
gl.glEnd();
gl.glBegin(GL.GL_LINE_STRIP);
gl.glVertex2d(point.x,point.y - rectwidth);
gl.glVertex2d(point.x,point.y + rectwidth);
gl.glEnd();
gl.glFlush();
}
}
break;
case triangle:
{
for (Geometry temp : geometries) {
gl.glLineWidth(this.renderWidth);
Coordinate point=new Coordinate(temp.getCoordinate());
point.x=(point.x - x) / width;
point.y=1 - (point.y - y) / height;
double rectwidth=0.01;
gl.glBegin(GL.GL_LINE_STRIP);
gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
gl.glVertex2d(point.x,point.y + rectwidth);
gl.glVertex2d(point.x + rectwidth,point.y - rectwidth);
gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
gl.glEnd();
gl.glFlush();
}
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(POLYGON)) {
for (Geometry tmp : geometries) {
Polygon polygon=(Polygon)tmp;
if (polygon.getCoordinates().length < 1) {
continue;
}
float rWidth=this.renderWidth;
int interior=polygon.getNumInteriorRing();
if (interior > 0) {
LineString line=polygon.getExteriorRing();
drawPoly(gl,line.getCoordinates(),width,height,x,y,rWidth);
for (int i=0; i < interior; i++) {
LineString line2=polygon.getInteriorRingN(i);
drawPoly(gl,line2.getCoordinates(),width,height,x,y,rWidth);
}
}
 else {
drawPoly(gl,polygon.getCoordinates(),width,height,x,y,rWidth);
}
}
}
 else if (getType().equalsIgnoreCase(LINESTRING)) {
for (Geometry temp : geometries) {
if (temp.getCoordinates().length < 1) {
continue;
}
gl.glLineWidth(this.renderWidth);
gl.glBegin(GL.GL_LINE_STRIP);
Coordinate[] cs=temp.getCoordinates();
for (int p=0; p < cs.length; p++) {
gl.glVertex2d((cs[p].x - x) / width,1 - (cs[p].y - y) / height);
}
gl.glEnd();
gl.glFlush();
}
}
}
}","public void render(Object gcC){
  OpenGLContext context=(OpenGLContext)gcC;
  if (!context.isDirty()) {
    return;
  }
  int x=context.getX();
  int y=context.getY();
  float zoom=context.getZoom();
  float width=context.getWidth() * zoom;
  float height=context.getHeight() * zoom;
  GL2 gl=context.getGL().getGL2();
  float[] c=color.getColorComponents(null);
  gl.glColor3f(c[0],c[1],c[2]);
  if (geometries != null) {
    if (getType().equalsIgnoreCase(POINT) || getType().equalsIgnoreCase(MIXED)) {
switch (this.displaysymbol) {
case point:
{
          gl.glPointSize(this.renderWidth);
          gl.glBegin(GL.GL_POINTS);
          for (          Geometry temp : geometries) {
            Coordinate point=temp.getCoordinate();
            gl.glVertex2d((point.x - x) / width,1 - (point.y - y) / height);
          }
          gl.glEnd();
          gl.glFlush();
        }
      break;
case circle:
{
      gl.glBegin(GL.GL_LINE_LOOP);
      gl.glLineWidth(this.renderWidth);
      for (      Geometry temp : geometries) {
        Coordinate point=temp.getCoordinate();
        double dx=(point.x - x) / width;
        double dy=1 - (point.y - y) / height;
        for (int i=0; i < 360; i++) {
          double angle=2 * Math.PI * i / 300;
          double xx=Math.cos(angle);
          double yy=Math.sin(angle);
          gl.glVertex2d(xx + dx,yy + dy);
        }
      }
      gl.glEnd();
      gl.glFlush();
    }
  break;
case square:
{
  for (  Geometry temp : geometries) {
    gl.glLineWidth(this.renderWidth);
    Coordinate point=new Coordinate(temp.getCoordinate());
    point.x=(point.x - x) / width;
    point.y=1 - (point.y - y) / height;
    double rectwidth=0.01;
    gl.glBegin(GL.GL_LINE_STRIP);
    gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
    gl.glVertex2d(point.x - rectwidth,point.y + rectwidth);
    gl.glVertex2d(point.x + rectwidth,point.y + rectwidth);
    gl.glVertex2d(point.x + rectwidth,point.y - rectwidth);
    gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
    gl.glEnd();
    gl.glFlush();
  }
}
break;
case cross:
{
for (Geometry temp : geometries) {
gl.glLineWidth(this.renderWidth);
Coordinate point=new Coordinate(temp.getCoordinate());
point.x=(point.x - x) / width;
point.y=1 - (point.y - y) / height;
double rectwidth=0.01;
gl.glBegin(GL.GL_LINE_STRIP);
gl.glVertex2d(point.x - rectwidth,point.y);
gl.glVertex2d(point.x + rectwidth,point.y);
gl.glEnd();
gl.glBegin(GL.GL_LINE_STRIP);
gl.glVertex2d(point.x,point.y - rectwidth);
gl.glVertex2d(point.x,point.y + rectwidth);
gl.glEnd();
gl.glFlush();
}
}
break;
case triangle:
{
for (Geometry temp : geometries) {
gl.glLineWidth(this.renderWidth);
Coordinate point=new Coordinate(temp.getCoordinate());
point.x=(point.x - x) / width;
point.y=1 - (point.y - y) / height;
double rectwidth=0.01;
gl.glBegin(GL.GL_LINE_STRIP);
gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
gl.glVertex2d(point.x,point.y + rectwidth);
gl.glVertex2d(point.x + rectwidth,point.y - rectwidth);
gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
gl.glEnd();
gl.glFlush();
}
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(POLYGON)) {
for (Geometry tmp : geometries) {
Polygon polygon=(Polygon)tmp;
if (polygon.getCoordinates().length < 1) {
continue;
}
float rWidth=this.renderWidth;
int interior=polygon.getNumInteriorRing();
if (interior > 0) {
LineString line=polygon.getExteriorRing();
drawPoly(gl,line.getCoordinates(),width,height,x,y,rWidth);
for (int i=0; i < interior; i++) {
LineString line2=polygon.getInteriorRingN(i);
drawPoly(gl,line2.getCoordinates(),width,height,x,y,rWidth);
}
}
 else {
drawPoly(gl,polygon.getCoordinates(),width,height,x,y,rWidth);
}
}
}
 else if (getType().equalsIgnoreCase(LINESTRING)) {
for (Geometry temp : geometries) {
if (temp.getCoordinates().length < 1) {
continue;
}
gl.glLineWidth(this.renderWidth);
gl.glBegin(GL.GL_LINE_STRIP);
Coordinate[] cs=temp.getCoordinates();
for (int p=0; p < cs.length; p++) {
gl.glVertex2d((cs[p].x - x) / width,1 - (cs[p].y - y) / height);
}
gl.glEnd();
gl.glFlush();
}
}
}
}",0.9954405422057916
175112,"@Override public Date getImageDate(){
  Timestamp t=Timestamp.valueOf(getTimeStampStart());
  return new Date(t.getTime());
}","@Override public Date getImageDate(){
  String ts=getTimeStampStart();
  ts=ts.replace(""String_Node_Str"",""String_Node_Str"");
  Timestamp t=Timestamp.valueOf(ts);
  return new Date(t.getTime());
}",0.66875
175113,"public static float getFromGeoImageReader(SarImageReader gir){
  float enl=1;
  if (gir instanceof Radarsat1Image) {
    int ENLColumn=0, ENLLine=0;
    String processor=gir.getProcessor();
    String mode=gir.getMode();
    if (processor.charAt(0) == 'K' || processor.charAt(0) == 'S') {
      ENLColumn=0;
    }
 else {
      ENLColumn=1;
    }
    if (mode.equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=0;
    }
    if (mode.equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=1;
    }
    if (mode.equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=2;
    }
    if (((String)gir.getProduct()).equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=3;
    }
    enl=radarsatENLArray[ENLLine][ENLColumn];
  }
 else   if (gir instanceof Sentinel1SLC) {
    enl=1;
  }
 else   if (gir instanceof Sentinel1GRD || gir instanceof GDALSentinel1) {
    String name=((Sentinel1)gir).getSafeFilePath();
    String folder=new File(name).getParentFile().getAbsolutePath();
    if (folder.contains(""String_Node_Str"")) {
      enl=3.5F;
    }
 else     if (folder.contains(""String_Node_Str"")) {
      if (folder.matches(""String_Node_Str"")) {
        enl=27F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=4.4F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=2.7F;
      }
    }
 else     if (folder.contains(""String_Node_Str"")) {
      if (folder.matches(""String_Node_Str"")) {
        enl=50F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=50.0F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=9.6F;
      }
    }
  }
 else   if (gir instanceof EnvisatImage) {
    String swath=gir.getSwath();
    enl=Float.parseFloat(envisatENLMap.get(swath));
  }
 else   if (gir instanceof Radarsat2Image) {
    String temp=gir.getENL();
    enl=Float.parseFloat(temp);
  }
 else   if (gir instanceof TerrasarXImage) {
    enl=Float.parseFloat(gir.getENL());
  }
  return enl;
}","public static float getFromGeoImageReader(SarImageReader gir){
  float enl=1;
  if (gir instanceof Radarsat1Image) {
    int ENLColumn=0, ENLLine=0;
    String processor=gir.getProcessor();
    String mode=gir.getMode();
    if (processor.charAt(0) == 'K' || processor.charAt(0) == 'S') {
      ENLColumn=0;
    }
 else {
      ENLColumn=1;
    }
    if (mode.equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=0;
    }
    if (mode.equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=1;
    }
    if (mode.equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=2;
    }
    if (((String)gir.getProduct()).equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=3;
    }
    enl=radarsatENLArray[ENLLine][ENLColumn];
  }
 else   if (gir instanceof Sentinel1SLC) {
    enl=1;
  }
 else   if (gir instanceof Sentinel1GRD || gir instanceof GDALSentinel1) {
    String name=((Sentinel1)gir).getSafeFilePath();
    String folder=new File(name).getParentFile().getAbsolutePath();
    if (folder.contains(""String_Node_Str"")) {
      enl=3.5F;
    }
 else     if (folder.contains(""String_Node_Str"")) {
      if (folder.matches(""String_Node_Str"")) {
        enl=27F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=4.4F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=2.7F;
      }
    }
 else     if (folder.contains(""String_Node_Str"")) {
      if (folder.matches(""String_Node_Str"")) {
        enl=50F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=50.0F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=9.6F;
      }
    }
  }
 else   if (gir instanceof EnvisatImage) {
    String swath=gir.getSwath();
    enl=Float.parseFloat(envisatENLMap.get(swath));
  }
 else   if (gir instanceof Radarsat2Image) {
    String temp=gir.getENL();
    enl=Float.parseFloat(temp);
  }
 else   if (gir instanceof TerrasarXImage) {
    enl=Float.parseFloat(gir.getENL());
  }
 else {
    enl=1;
  }
  return enl;
}",0.9942021678850516
175114,"@Override public Date getImageDate(){
  Timestamp t=Timestamp.valueOf(getTimeStampStart());
  return new Date(t.getTime());
}","@Override public Date getImageDate(){
  String ts=getTimeStampStart();
  ts=ts.replace(""String_Node_Str"",""String_Node_Str"");
  Timestamp t=Timestamp.valueOf(ts);
  return new Date(t.getTime());
}",0.66875
175115,"public static float getFromGeoImageReader(SarImageReader gir){
  float enl=1;
  if (gir instanceof Radarsat1Image) {
    int ENLColumn=0, ENLLine=0;
    String processor=gir.getProcessor();
    String mode=gir.getMode();
    if (processor.charAt(0) == 'K' || processor.charAt(0) == 'S') {
      ENLColumn=0;
    }
 else {
      ENLColumn=1;
    }
    if (mode.equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=0;
    }
    if (mode.equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=1;
    }
    if (mode.equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=2;
    }
    if (((String)gir.getProduct()).equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=3;
    }
    enl=radarsatENLArray[ENLLine][ENLColumn];
  }
 else   if (gir instanceof Sentinel1SLC) {
    enl=1;
  }
 else   if (gir instanceof Sentinel1GRD || gir instanceof GDALSentinel1) {
    String name=((Sentinel1)gir).getSafeFilePath();
    String folder=new File(name).getParentFile().getAbsolutePath();
    if (folder.contains(""String_Node_Str"")) {
      enl=3.5F;
    }
 else     if (folder.contains(""String_Node_Str"")) {
      if (folder.matches(""String_Node_Str"")) {
        enl=27F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=4.4F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=2.7F;
      }
    }
 else     if (folder.contains(""String_Node_Str"")) {
      if (folder.matches(""String_Node_Str"")) {
        enl=50F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=50.0F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=9.6F;
      }
    }
  }
 else   if (gir instanceof EnvisatImage) {
    String swath=gir.getSwath();
    enl=Float.parseFloat(envisatENLMap.get(swath));
  }
 else   if (gir instanceof Radarsat2Image) {
    String temp=gir.getENL();
    enl=Float.parseFloat(temp);
  }
 else   if (gir instanceof TerrasarXImage) {
    enl=Float.parseFloat(gir.getENL());
  }
  return enl;
}","public static float getFromGeoImageReader(SarImageReader gir){
  float enl=1;
  if (gir instanceof Radarsat1Image) {
    int ENLColumn=0, ENLLine=0;
    String processor=gir.getProcessor();
    String mode=gir.getMode();
    if (processor.charAt(0) == 'K' || processor.charAt(0) == 'S') {
      ENLColumn=0;
    }
 else {
      ENLColumn=1;
    }
    if (mode.equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=0;
    }
    if (mode.equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=1;
    }
    if (mode.equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=2;
    }
    if (((String)gir.getProduct()).equalsIgnoreCase(""String_Node_Str"")) {
      ENLLine=3;
    }
    enl=radarsatENLArray[ENLLine][ENLColumn];
  }
 else   if (gir instanceof Sentinel1SLC) {
    enl=1;
  }
 else   if (gir instanceof Sentinel1GRD || gir instanceof GDALSentinel1) {
    String name=((Sentinel1)gir).getSafeFilePath();
    String folder=new File(name).getParentFile().getAbsolutePath();
    if (folder.contains(""String_Node_Str"")) {
      enl=3.5F;
    }
 else     if (folder.contains(""String_Node_Str"")) {
      if (folder.matches(""String_Node_Str"")) {
        enl=27F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=4.4F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=2.7F;
      }
    }
 else     if (folder.contains(""String_Node_Str"")) {
      if (folder.matches(""String_Node_Str"")) {
        enl=50F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=50.0F;
      }
 else       if (folder.contains(""String_Node_Str"")) {
        enl=9.6F;
      }
    }
  }
 else   if (gir instanceof EnvisatImage) {
    String swath=gir.getSwath();
    enl=Float.parseFloat(envisatENLMap.get(swath));
  }
 else   if (gir instanceof Radarsat2Image) {
    String temp=gir.getENL();
    enl=Float.parseFloat(temp);
  }
 else   if (gir instanceof TerrasarXImage) {
    enl=Float.parseFloat(gir.getENL());
  }
 else {
    enl=1;
  }
  return enl;
}",0.9942021678850516
175116,"/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP.buffer(1),gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=(Geometry)o[i][0];
            if (applayTransformation && transform != null) {
              g=transform.transformGeometryPixelFromGeo(g);
            }
            if (!g.isValid()) {
              Geometry b0=g.buffer(0);
              if (!g.isSimple() && (b0.getArea() / g.getArea()) < 0.75) {
                Coordinate[] cc=g.getCoordinates();
                CoordinateList cl=new CoordinateList();
                cl.add(cc,false);
                for (int ii=0; ii < cl.size(); ii++) {
                  if (b0.contains(gf.createPoint(cl.getCoordinate(ii))) || b0.touches(gf.createPoint(cl.getCoordinate(ii)))) {
                    cl.remove(ii);
                  }
                }
                cl.closeRing();
                Geometry newGeom=gf.createPolygon(cl.toCoordinateArray());
                if (!newGeom.isValid())                 newGeom=TopologyPreservingSimplifier.simplify(newGeom,0.0001);
                g=newGeom.buffer(0);
              }
 else {
                g=b0;
              }
            }
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}","/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP.buffer(1),gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=(Geometry)o[i][0];
            if (applayTransformation && transform != null) {
              g=transform.transformGeometryPixelFromGeo(g);
            }
            if (!g.isValid()) {
              g=JTSUtil.repair(g);
            }
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}",0.9095042216930072
175117,"/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP.buffer(1),gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=(Geometry)o[i][0];
            if (applayTransformation && transform != null) {
              g=transform.transformGeometryPixelFromGeo(g);
            }
            if (!g.isValid()) {
              Geometry b0=g.buffer(0);
              if (!g.isSimple() && (b0.getArea() / g.getArea()) < 0.75) {
                Coordinate[] cc=g.getCoordinates();
                CoordinateList cl=new CoordinateList();
                cl.add(cc,false);
                for (int ii=0; ii < cl.size(); ii++) {
                  if (b0.contains(gf.createPoint(cl.getCoordinate(ii))) || b0.touches(gf.createPoint(cl.getCoordinate(ii)))) {
                    cl.remove(ii);
                  }
                }
                cl.closeRing();
                Geometry newGeom=gf.createPolygon(cl.toCoordinateArray());
                if (!newGeom.isValid())                 newGeom=TopologyPreservingSimplifier.simplify(newGeom,0.0001);
                g=newGeom.buffer(0);
              }
 else {
                g=b0;
              }
            }
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}","/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP.buffer(1),gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=(Geometry)o[i][0];
            if (applayTransformation && transform != null) {
              g=transform.transformGeometryPixelFromGeo(g);
            }
            if (!g.isValid()) {
              g=JTSUtil.repair(g);
            }
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}",0.9095042216930072
175118,"@SuppressWarnings(""String_Node_Str"") public boolean initialise(){
  try {
    this.imgName=super.manifestFile.getName();
    this.imgName=this.imgName.substring(0,this.imgName.lastIndexOf(""String_Node_Str""));
    this.displayName=super.manifestFile.getName();
    if (group != null && !group.equalsIgnoreCase(""String_Node_Str""))     this.displayName=this.displayName + ""String_Node_Str"" + group;
    h5file=new H5File(super.manifestFile.getAbsolutePath(),H5File.READ);
    imagedata=(H5ScalarDS)h5file.get(internalImage);
    extractQuickLook();
    List<Object> metadata=new ArrayList<Object>();
    metadata.addAll(h5file.get(""String_Node_Str"").getMetadata());
    if (imagedata == null)     return false;
    metadata.addAll(imagedata.getMetadata());
    long[] selected=imagedata.getSelectedDims();
    selected[0]=1;
    if (selected.length > 2)     selected[2]=2;
    xSize=(int)imagedata.getDims()[1];
    ySize=(int)imagedata.getDims()[0];
    stride=imagedata.getStride();
    dims=imagedata.getSelectedDims();
    starts=imagedata.getStartDims();
    setMetaWidth(xSize);
    setMetaHeight(ySize);
    bounds=new Rectangle(0,0,xSize,ySize);
    gcps=new ArrayList<Gcp>();
    for (    Object o : metadata) {
      Attribute a=(Attribute)o;
      if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        Gcp gcp=new Gcp();
        gcp.setXpix(0);
        gcp.setOriginalXpix(0.0);
        gcp.setYpix(ySize);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        Gcp gcp=new Gcp();
        gcp.setXpix(xSize);
        gcp.setOriginalXpix(new Double(xSize));
        gcp.setYpix(ySize);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        Gcp gcp=new Gcp();
        gcp.setXpix(0);
        gcp.setOriginalXpix(new Double(0));
        gcp.setYpix(0);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        Gcp gcp=new Gcp();
        gcp.setXpix(xSize);
        gcp.setOriginalXpix(new Double(xSize));
        gcp.setYpix(0);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setTimeStampStart(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setTimeStampStop(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setENL(String.valueOf(val[0]));
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setRangeSpacing(new Float(val[0]));
        pixelsize[0]=getRangeSpacing();
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setIncidenceFar(new Float(val[0]));
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setIncidenceNear(new Float(val[0]));
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setAzimuthSpacing(new Float(val[0]));
        pixelsize[1]=getAzimuthSpacing();
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setLookDirection(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setOrbitDirection(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setProcessor(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setRadarWaveLenght(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setType(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setSatellite(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setSatelliteAltitude(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setPolarization(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setBeam(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setPRF(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setPRF(val[0]);
      }
      setSatelliteOrbitInclination(97.86);
      setRevolutionsPerday(14.8125);
    }
    setSensor(""String_Node_Str"");
    if (getType().startsWith(""String_Node_Str"")) {
      complex=true;
    }
    geotransform=GeoTransformFactory.createFromGcps(gcps,""String_Node_Str"");
  }
 catch (  Exception ex) {
    logger.error(null,ex);
    return false;
  }
  return true;
}","@SuppressWarnings(""String_Node_Str"") public boolean initialise(){
  try {
    this.imgName=super.manifestFile.getName();
    this.imgName=this.imgName.substring(0,this.imgName.lastIndexOf(""String_Node_Str""));
    this.displayName=super.manifestFile.getName();
    if (group != null && !group.equalsIgnoreCase(""String_Node_Str""))     this.displayName=this.displayName + ""String_Node_Str"" + group;
    h5file=new H5File(super.manifestFile.getAbsolutePath(),H5File.READ);
    imagedata=(H5ScalarDS)h5file.get(internalImage);
    if (imagedata == null)     return false;
    extractQuickLook();
    HashMap<String,Object> metadata=new HashMap<>();
    List<Attribute> attrs=(imagedata.getMetadata());
    attrs.addAll(h5file.get(""String_Node_Str"").getMetadata());
    List<HObject> hobs=((H5Group)h5file.get(""String_Node_Str"")).getMemberList();
    for (    HObject ho : hobs) {
      attrs.addAll(ho.getMetadata());
    }
    for (    Attribute att : attrs) {
      metadata.put(att.getName(),att.getValue());
    }
    long[] selected=imagedata.getSelectedDims();
    selected[0]=1;
    if (selected.length > 2)     selected[2]=2;
    xSize=(int)imagedata.getDims()[1];
    ySize=(int)imagedata.getDims()[0];
    stride=imagedata.getStride();
    dims=imagedata.getSelectedDims();
    starts=imagedata.getStartDims();
    setMetaWidth(xSize);
    setMetaHeight(ySize);
    bounds=new Rectangle(0,0,xSize,ySize);
    gcps=new ArrayList<Gcp>();
    for (    String a : metadata.keySet()) {
      if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        Gcp gcp=new Gcp();
        gcp.setXpix(0);
        gcp.setOriginalXpix(0.0);
        gcp.setYpix(ySize);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        Gcp gcp=new Gcp();
        gcp.setXpix(xSize);
        gcp.setOriginalXpix(new Double(xSize));
        gcp.setYpix(ySize);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        Gcp gcp=new Gcp();
        gcp.setXpix(0);
        gcp.setOriginalXpix(new Double(0));
        gcp.setYpix(0);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        Gcp gcp=new Gcp();
        gcp.setXpix(xSize);
        gcp.setOriginalXpix(new Double(xSize));
        gcp.setYpix(0);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setTimeStampStart(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setTimeStampStop(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setENL(String.valueOf(val[0]));
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setRangeSpacing(new Float(val[0]));
        pixelsize[0]=getRangeSpacing();
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setIncidenceFar(new Float(val[0]));
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setIncidenceNear(new Float(val[0]));
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setAzimuthSpacing(new Float(val[0]));
        pixelsize[1]=getAzimuthSpacing();
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setLookDirection(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setOrbitDirection(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setProcessor(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setRadarWaveLenght(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setType(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setSatellite(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setSatelliteAltitude(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setPolarization(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setBeam(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setPRF(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setPRF(val[0]);
      }
      setSatelliteOrbitInclination(97.86);
      setRevolutionsPerday(14.8125);
    }
    setSensor(""String_Node_Str"");
    if (getType().startsWith(""String_Node_Str"")) {
      complex=true;
    }
    geotransform=GeoTransformFactory.createFromGcps(gcps,""String_Node_Str"");
  }
 catch (  Exception ex) {
    logger.error(null,ex);
    return false;
  }
  return true;
}",0.4284692417739628
175119,"public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=54.81;
    double lon=-5.81;
    double p=6180.1;
    double l=13476.0;
    try {
      double r3[]=gc.geoFromPixel(l,p);
      System.out.println(""String_Node_Str"" + r3[0] + ""String_Node_Str""+ r3[1]);
      System.out.println(""String_Node_Str"" + GeoUtils.getGeoidH(r3[0],r3[1]));
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
}","public static void main(String args[]){
  String metaF=""String_Node_Str"" + ""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=54.81;
    double lon=-5.81;
    double p=6180.1;
    double l=13476.0;
    try {
      double r3[]=gc.geoFromPixel(l,p);
      System.out.println(""String_Node_Str"" + r3[0] + ""String_Node_Str""+ r3[1]);
      System.out.println(""String_Node_Str"" + GeoUtils.getGeoidH(r3[0],r3[1]));
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
}",0.9826689774696707
175120,"/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP,gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=(Geometry)o[i][0];
            if (applayTransformation && transform != null)             g=transform.transformGeometryPixelFromGeo(g);
            if (!g.isValid()) {
              Geometry b0=g.buffer(0);
              if (!g.isSimple() && (b0.getArea() / g.getArea()) < 0.75) {
                Coordinate[] cc=g.getCoordinates();
                CoordinateList cl=new CoordinateList();
                cl.add(cc,false);
                for (int ii=0; ii < cl.size(); ii++) {
                  if (b0.contains(gf.createPoint(cl.getCoordinate(ii))) || b0.touches(gf.createPoint(cl.getCoordinate(ii)))) {
                    cl.remove(ii);
                  }
                }
                cl.closeRing();
                Geometry newGeom=gf.createPolygon(cl.toCoordinateArray());
                g=newGeom.buffer(0);
              }
 else {
                g=b0;
              }
            }
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}","/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP.buffer(1),gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=(Geometry)o[i][0];
            if (applayTransformation && transform != null) {
              g=transform.transformGeometryPixelFromGeo(g);
            }
            if (!g.isValid()) {
              Geometry b0=g.buffer(0);
              if (!g.isSimple() && (b0.getArea() / g.getArea()) < 0.75) {
                Coordinate[] cc=g.getCoordinates();
                CoordinateList cl=new CoordinateList();
                cl.add(cc,false);
                for (int ii=0; ii < cl.size(); ii++) {
                  if (b0.contains(gf.createPoint(cl.getCoordinate(ii))) || b0.touches(gf.createPoint(cl.getCoordinate(ii)))) {
                    cl.remove(ii);
                  }
                }
                cl.closeRing();
                Geometry newGeom=gf.createPolygon(cl.toCoordinateArray());
                g=newGeom.buffer(0);
              }
 else {
                g=b0;
              }
            }
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}",0.997134670487106
175121,"/** 
 * @param annotationFile
 * @throws GeoTransformException
 */
public GeoTransformOrbitState(SumoAnnotationReader annotationFile) throws GeoTransformException {
  try {
    geocoding=new S1GeoCodingImpl(annotationFile);
    pGeo=new ParallelGeoCoding(geocoding);
  }
 catch (  MathException e) {
    throw new GeoTransformException(e.getMessage());
  }
}","/** 
 * @param annotationFile
 * @throws GeoTransformException
 */
public GeoTransformOrbitState(SumoAnnotationReader annotationFile) throws GeoTransformException {
  try {
    S1Metadata meta=new S1Metadata(annotationFile);
    meta.initMetaData();
    geocoding=new S1GeoCodingImpl(meta);
    pGeo=new ParallelGeoCoding(geocoding);
  }
 catch (  Exception e) {
    throw new GeoTransformException(e.getMessage());
  }
}",0.8369704749679076
175122,"public static void main(String[] args){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=41.31735;
    double lon=2.17263;
    Coordinate c=new Coordinate(lat,lon);
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
}","public static void main(String[] args){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    S1Metadata meta=new S1Metadata(metaF);
    meta.initMetaData();
    gc=new S1GeoCodingImpl(meta);
    double lat=41.31735;
    double lon=2.17263;
    Coordinate c=new Coordinate(lat,lon);
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
}",0.8854003139717426
175123,"/** 
 * @param annotationFile
 * @throws GeoTransformException
 */
public GeoTransformOrbitState(SumoAnnotationReader annotationFile) throws GeoTransformException {
  try {
    geocoding=new S1GeoCodingImpl(annotationFile);
    pGeo=new ParallelGeoCoding(geocoding);
  }
 catch (  MathException e) {
    throw new GeoTransformException(e.getMessage());
  }
}","/** 
 * @param annotationFile
 * @throws GeoTransformException
 */
public GeoTransformOrbitState(SumoAnnotationReader annotationFile) throws GeoTransformException {
  try {
    S1Metadata meta=new S1Metadata(annotationFile);
    meta.initMetaData();
    geocoding=new S1GeoCodingImpl(meta);
    pGeo=new ParallelGeoCoding(geocoding);
  }
 catch (  Exception e) {
    throw new GeoTransformException(e.getMessage());
  }
}",0.8369704749679076
175124,"public static void main(String[] args){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=41.31735;
    double lon=2.17263;
    Coordinate c=new Coordinate(lat,lon);
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
}","public static void main(String[] args){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    S1Metadata meta=new S1Metadata(metaF);
    meta.initMetaData();
    gc=new S1GeoCodingImpl(meta);
    double lat=41.31735;
    double lon=2.17263;
    Coordinate c=new Coordinate(lat,lon);
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
}",0.8854003139717426
175125,"/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP,gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=(Geometry)o[i][0];
            if (applayTransformation && transform != null)             g=transform.transformGeometryPixelFromGeo(g);
            if (!g.isValid()) {
              Geometry b0=g.buffer(0);
              if (!g.isSimple() && (b0.getArea() / g.getArea()) < 0.75) {
                Coordinate[] cc=g.getCoordinates();
                CoordinateList cl=new CoordinateList();
                cl.add(cc,false);
                for (int ii=0; ii < cl.size(); ii++) {
                  if (b0.contains(gf.createPoint(cl.getCoordinate(ii))) || b0.touches(gf.createPoint(cl.getCoordinate(ii)))) {
                    cl.remove(ii);
                  }
                }
                cl.closeRing();
                Geometry newGeom=gf.createPolygon(cl.toCoordinateArray());
                g=newGeom.buffer(0);
              }
 else {
                g=b0;
              }
            }
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}","/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP.buffer(1),gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=(Geometry)o[i][0];
            if (applayTransformation && transform != null) {
              g=transform.transformGeometryPixelFromGeo(g);
            }
            if (!g.isValid()) {
              Geometry b0=g.buffer(0);
              if (!g.isSimple() && (b0.getArea() / g.getArea()) < 0.75) {
                Coordinate[] cc=g.getCoordinates();
                CoordinateList cl=new CoordinateList();
                cl.add(cc,false);
                for (int ii=0; ii < cl.size(); ii++) {
                  if (b0.contains(gf.createPoint(cl.getCoordinate(ii))) || b0.touches(gf.createPoint(cl.getCoordinate(ii)))) {
                    cl.remove(ii);
                  }
                }
                cl.closeRing();
                Geometry newGeom=gf.createPolygon(cl.toCoordinateArray());
                g=newGeom.buffer(0);
              }
 else {
                g=b0;
              }
            }
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}",0.997134670487106
175126,"@SuppressWarnings(""String_Node_Str"") public boolean initialise(){
  try {
    this.imgName=super.manifestFile.getName();
    this.imgName=this.imgName.substring(0,this.imgName.lastIndexOf(""String_Node_Str""));
    this.displayName=super.manifestFile.getName();
    if (group != null && !group.equalsIgnoreCase(""String_Node_Str""))     this.displayName=this.displayName + ""String_Node_Str"" + group;
    h5file=new H5File(super.manifestFile.getAbsolutePath(),H5File.READ);
    imagedata=(H5ScalarDS)h5file.get(internalImage);
    extractQuickLook();
    List<Object> metadata=new ArrayList<Object>();
    metadata.addAll(h5file.get(""String_Node_Str"").getMetadata());
    if (imagedata == null)     return false;
    metadata.addAll(imagedata.getMetadata());
    long[] selected=imagedata.getSelectedDims();
    selected[0]=1;
    if (selected.length > 2)     selected[2]=2;
    xSize=(int)imagedata.getDims()[1];
    ySize=(int)imagedata.getDims()[0];
    stride=imagedata.getStride();
    dims=imagedata.getSelectedDims();
    starts=imagedata.getStartDims();
    setMetaWidth(xSize);
    setMetaHeight(ySize);
    bounds=new Rectangle(0,0,xSize,ySize);
    gcps=new ArrayList<Gcp>();
    for (    Object o : metadata) {
      Attribute a=(Attribute)o;
      if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        Gcp gcp=new Gcp();
        gcp.setXpix(0);
        gcp.setOriginalXpix(0.0);
        gcp.setYpix(ySize);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        Gcp gcp=new Gcp();
        gcp.setXpix(xSize);
        gcp.setOriginalXpix(new Double(xSize));
        gcp.setYpix(ySize);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        Gcp gcp=new Gcp();
        gcp.setXpix(0);
        gcp.setOriginalXpix(new Double(0));
        gcp.setYpix(0);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        Gcp gcp=new Gcp();
        gcp.setXpix(xSize);
        gcp.setOriginalXpix(new Double(xSize));
        gcp.setYpix(0);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setTimeStampStart(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setTimeStampStop(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setENL(String.valueOf(val[0]));
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setRangeSpacing(new Float(val[0]));
        pixelsize[0]=getRangeSpacing();
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setIncidenceFar(new Float(val[0]));
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setIncidenceNear(new Float(val[0]));
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setAzimuthSpacing(new Float(val[0]));
        pixelsize[1]=getAzimuthSpacing();
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setLookDirection(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setOrbitDirection(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setProcessor(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setRadarWaveLenght(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setType(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setSatellite(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setSatelliteAltitude(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setPolarization(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        String[] val=(String[])a.getValue();
        setBeam(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setPRF(val[0]);
      }
 else       if (a.getName().equals(""String_Node_Str"")) {
        double[] val=(double[])a.getValue();
        setPRF(val[0]);
      }
      setSatelliteOrbitInclination(97.86);
      setRevolutionsPerday(14.8125);
    }
    setSensor(""String_Node_Str"");
    if (getType().startsWith(""String_Node_Str"")) {
      complex=true;
    }
    geotransform=GeoTransformFactory.createFromGcps(gcps,""String_Node_Str"");
  }
 catch (  Exception ex) {
    logger.error(null,ex);
    return false;
  }
  return true;
}","@SuppressWarnings(""String_Node_Str"") public boolean initialise(){
  try {
    this.imgName=super.manifestFile.getName();
    this.imgName=this.imgName.substring(0,this.imgName.lastIndexOf(""String_Node_Str""));
    this.displayName=super.manifestFile.getName();
    if (group != null && !group.equalsIgnoreCase(""String_Node_Str""))     this.displayName=this.displayName + ""String_Node_Str"" + group;
    h5file=new H5File(super.manifestFile.getAbsolutePath(),H5File.READ);
    imagedata=(H5ScalarDS)h5file.get(internalImage);
    if (imagedata == null)     return false;
    extractQuickLook();
    HashMap<String,Object> metadata=new HashMap<>();
    List<Attribute> attrs=(imagedata.getMetadata());
    attrs.addAll(h5file.get(""String_Node_Str"").getMetadata());
    List<HObject> hobs=((H5Group)h5file.get(""String_Node_Str"")).getMemberList();
    for (    HObject ho : hobs) {
      attrs.addAll(ho.getMetadata());
    }
    for (    Attribute att : attrs) {
      metadata.put(att.getName(),att.getValue());
    }
    long[] selected=imagedata.getSelectedDims();
    selected[0]=1;
    if (selected.length > 2)     selected[2]=2;
    xSize=(int)imagedata.getDims()[1];
    ySize=(int)imagedata.getDims()[0];
    stride=imagedata.getStride();
    dims=imagedata.getSelectedDims();
    starts=imagedata.getStartDims();
    setMetaWidth(xSize);
    setMetaHeight(ySize);
    bounds=new Rectangle(0,0,xSize,ySize);
    gcps=new ArrayList<Gcp>();
    for (    String a : metadata.keySet()) {
      if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        Gcp gcp=new Gcp();
        gcp.setXpix(0);
        gcp.setOriginalXpix(0.0);
        gcp.setYpix(ySize);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        Gcp gcp=new Gcp();
        gcp.setXpix(xSize);
        gcp.setOriginalXpix(new Double(xSize));
        gcp.setYpix(ySize);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        Gcp gcp=new Gcp();
        gcp.setXpix(0);
        gcp.setOriginalXpix(new Double(0));
        gcp.setYpix(0);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        Gcp gcp=new Gcp();
        gcp.setXpix(xSize);
        gcp.setOriginalXpix(new Double(xSize));
        gcp.setYpix(0);
        gcp.setXgeo(val[1]);
        gcp.setYgeo(val[0]);
        gcps.add(gcp);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setTimeStampStart(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setTimeStampStop(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setENL(String.valueOf(val[0]));
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setRangeSpacing(new Float(val[0]));
        pixelsize[0]=getRangeSpacing();
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setIncidenceFar(new Float(val[0]));
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setIncidenceNear(new Float(val[0]));
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setAzimuthSpacing(new Float(val[0]));
        pixelsize[1]=getAzimuthSpacing();
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setLookDirection(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setOrbitDirection(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setProcessor(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setRadarWaveLenght(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setType(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setSatellite(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setSatelliteAltitude(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setPolarization(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        String[] val=(String[])metadata.get(a);
        setBeam(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setPRF(val[0]);
      }
 else       if (a.equals(""String_Node_Str"")) {
        double[] val=(double[])metadata.get(a);
        setPRF(val[0]);
      }
      setSatelliteOrbitInclination(97.86);
      setRevolutionsPerday(14.8125);
    }
    setSensor(""String_Node_Str"");
    if (getType().startsWith(""String_Node_Str"")) {
      complex=true;
    }
    geotransform=GeoTransformFactory.createFromGcps(gcps,""String_Node_Str"");
  }
 catch (  Exception ex) {
    logger.error(null,ex);
    return false;
  }
  return true;
}",0.4284692417739628
175127,"public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=54.81;
    double lon=-5.81;
    double p=6180.1;
    double l=13476.0;
    try {
      double r3[]=gc.geoFromPixel(l,p);
      System.out.println(""String_Node_Str"" + r3[0] + ""String_Node_Str""+ r3[1]);
      System.out.println(""String_Node_Str"" + GeoUtils.getGeoidH(r3[0],r3[1]));
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
}","public static void main(String args[]){
  String metaF=""String_Node_Str"" + ""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=54.81;
    double lon=-5.81;
    double p=6180.1;
    double l=13476.0;
    try {
      double r3[]=gc.geoFromPixel(l,p);
      System.out.println(""String_Node_Str"" + r3[0] + ""String_Node_Str""+ r3[1]);
      System.out.println(""String_Node_Str"" + GeoUtils.getGeoidH(r3[0],r3[1]));
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
}",0.9826689774696707
175128,"/** 
 * try to create the correct reader starting from file name
 * @param file
 * @return
 */
public static List<GeoImageReader> createReaderForName(String file){
  List<GeoImageReader> girList=new ArrayList<GeoImageReader>();
  try {
    File f=new File(file);
    String parent=f.getParent();
    if (parent != null && (parent.contains(""String_Node_Str"") || file.contains(""String_Node_Str""))) {
      H5File h5file=new H5File(file,H5File.READ);
      H5Group group=((H5Group)h5file.get(""String_Node_Str""));
      List<HObject> hObjs=group.getMemberList();
      Iterator<HObject> it=hObjs.iterator();
      while (it.hasNext()) {
        HObject obj=it.next();
        CosmoSkymedImage cosmo;
        if (obj.getName().equals(""String_Node_Str""))         cosmo=new CosmoSkymedImage(f,obj.getName(),null);
 else         cosmo=new CosmoSkymedImage(f,obj.getName() + ""String_Node_Str"",obj.getName());
        if (cosmo.initialise()) {
          girList.add(cosmo);
          logger.info(""String_Node_Str"",new Object[]{file,cosmo.getClass()});
        }
        if (girList.size() > 1)         cosmo.setContainsMultipleImage(true);
      }
    }
 else     if (parent.contains(""String_Node_Str"") || parent.contains(""String_Node_Str"")) {
      final SumoJaxbSafeReader safeReader=new SumoJaxbSafeReader(f.getAbsolutePath());
      boolean multipleImages=false;
      String[] swath=safeReader.getSwaths();
      if (swath.length > 1)       multipleImages=true;
      Sentinel1 sentinel=null;
      for (      String sw : swath) {
        if (parent.contains(""String_Node_Str"")) {
          sentinel=new Sentinel1SLC(sw,f);
        }
 else {
          sentinel=new Sentinel1GRD(sw,f);
        }
        sentinel.setContainsMultipleImage(multipleImages);
        if (sentinel.initialise()) {
          logger.info(""String_Node_Str"",new Object[]{file,sentinel.getClass()});
        }
 else {
          logger.warn(""String_Node_Str"",new Object[]{file,sentinel.getClass()});
        }
        girList.add(sentinel);
      }
    }
 else {
      GeoImageReader gir=null;
      if (parent.contains(""String_Node_Str"")) {
        gir=new TerrasarXImage(f);
      }
 else       if (parent.contains(""String_Node_Str"")) {
        gir=new TerrasarXImage(f);
      }
 else       if (parent.contains(""String_Node_Str"") || parent.contains(""String_Node_Str"")) {
        gir=new TerrasarXImage_SLC(f);
      }
 else       if (parent.contains(""String_Node_Str"") && parent.contains(""String_Node_Str"")) {
        gir=new Radarsat2Image_SLC(f);
      }
 else       if (parent.contains(""String_Node_Str"") && !parent.contains(""String_Node_Str"")) {
        gir=new Radarsat2Image(f);
      }
 else       if (parent.contains(""String_Node_Str"")) {
        gir=new Radarsat1Image(f);
      }
 else       if (parent.contains(""String_Node_Str"")) {
        gir=new EnvisatImage_SLC(f);
      }
 else {
        return null;
      }
      if (gir.initialise()) {
        logger.info(""String_Node_Str"",new Object[]{file,gir.getClass()});
        girList.add(gir);
      }
 else {
        girList=null;
      }
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"" + file,ex);
    girList=null;
  }
 finally {
    return girList;
  }
}","/** 
 * try to create the correct reader starting from file name
 * @param file
 * @return
 */
public static List<GeoImageReader> createReaderForName(String file){
  List<GeoImageReader> girList=new ArrayList<GeoImageReader>();
  try {
    File f=new File(file);
    String parent=f.getParent();
    if (parent != null && (parent.contains(""String_Node_Str"") || file.contains(""String_Node_Str""))) {
      H5File h5file=new H5File(file,H5File.READ);
      H5Group group=((H5Group)h5file.get(""String_Node_Str""));
      List<HObject> hObjs=group.getMemberList();
      Iterator<HObject> it=hObjs.iterator();
      while (it.hasNext()) {
        HObject obj=it.next();
        AbstractCosmoSkymedImage cosmo=null;
        if (obj.getName().equals(""String_Node_Str"")) {
          cosmo=CosmoSkyFactory.instanceCosmoSkymed(h5file,obj.getName(),null);
        }
 else {
          if (h5file.get(obj.getName() + ""String_Node_Str"") != null)           cosmo=CosmoSkyFactory.instanceCosmoSkymed(h5file,obj.getName() + ""String_Node_Str"",obj.getName());
        }
        if (cosmo != null) {
          if (cosmo.initialise()) {
            girList.add(cosmo);
            logger.info(""String_Node_Str"",new Object[]{file,cosmo.getClass()});
          }
          if (girList.size() > 1)           cosmo.setContainsMultipleImage(true);
        }
      }
    }
 else     if (parent.contains(""String_Node_Str"") || parent.contains(""String_Node_Str"")) {
      final SumoJaxbSafeReader safeReader=new SumoJaxbSafeReader(f.getAbsolutePath());
      boolean multipleImages=false;
      String[] swath=safeReader.getSwaths();
      if (swath.length > 1)       multipleImages=true;
      Sentinel1 sentinel=null;
      for (      String sw : swath) {
        if (parent.contains(""String_Node_Str"")) {
          sentinel=new Sentinel1SLC(sw,f);
        }
 else {
          sentinel=new Sentinel1GRD(sw,f);
        }
        sentinel.setContainsMultipleImage(multipleImages);
        if (sentinel.initialise()) {
          logger.info(""String_Node_Str"",new Object[]{file,sentinel.getClass()});
        }
 else {
          logger.warn(""String_Node_Str"",new Object[]{file,sentinel.getClass()});
        }
        girList.add(sentinel);
      }
    }
 else {
      GeoImageReader gir=null;
      if (parent.contains(""String_Node_Str"")) {
        gir=new TerrasarXImage(f);
      }
 else       if (parent.contains(""String_Node_Str"")) {
        gir=new TerrasarXImage(f);
      }
 else       if (parent.contains(""String_Node_Str"") || parent.contains(""String_Node_Str"")) {
        gir=new TerrasarXImage_SLC(f);
      }
 else       if (parent.contains(""String_Node_Str"") && parent.contains(""String_Node_Str"")) {
        gir=new Radarsat2Image_SLC(f);
      }
 else       if (parent.contains(""String_Node_Str"") && !parent.contains(""String_Node_Str"")) {
        gir=new Radarsat2Image(f);
      }
 else       if (parent.contains(""String_Node_Str"")) {
        gir=new Radarsat1Image(f);
      }
 else       if (parent.contains(""String_Node_Str"")) {
        gir=new EnvisatImage_SLC(f);
      }
 else {
        return null;
      }
      if (gir.initialise()) {
        logger.info(""String_Node_Str"",new Object[]{file,gir.getClass()});
        girList.add(gir);
      }
 else {
        girList=null;
      }
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"" + file,ex);
    girList=null;
  }
 finally {
    return girList;
  }
}",0.949132075471698
175129,"public static void renderCircle(OpenGLContext context,float zoomWidth,float zoomHeight,List<Geometry> geometries,float size,Color color){
  GL2 gl=context.getGL().getGL2();
  gl.glBegin(GL.GL_POINTS);
  gl.glLineWidth(size);
  for (int ii=0; ii < geometries.size(); ii++) {
    Geometry temp=geometries.get(ii);
    Coordinate point=temp.getCoordinate();
    double dx=(point.x - context.getX()) / zoomWidth;
    double dy=1 - (point.y - context.getY()) / zoomHeight;
    for (int i=0; i < 360; i++) {
      double xx=dx + Math.sin(i) * 0.005;
      double yy=dy + Math.cos(i) * 0.005;
      gl.glVertex2d(xx,yy);
    }
  }
  gl.glEnd();
  gl.glFlush();
}","public static void renderCircle(OpenGLContext context,float zoomWidth,float zoomHeight,List<Geometry> geometries,Geometry selectedGeometry,float size,Color color){
  GL2 gl=context.getGL().getGL2();
  float[] c=color.brighter().getColorComponents(null);
  gl.glColor3f(c[0],c[1],c[2]);
  gl.glBegin(GL.GL_POINTS);
  for (int ii=0; ii < geometries.size(); ii++) {
    Geometry temp=geometries.get(ii);
    gl.glLineWidth(temp == selectedGeometry ? size * 2 : size);
    gl.glPointSize(temp == selectedGeometry ? size * 2 : size);
    Coordinate point=temp.getCoordinate();
    double dx=(point.x - context.getX()) / zoomWidth;
    double dy=1 - (point.y - context.getY()) / zoomHeight;
    for (int i=0; i < 360; i++) {
      double xx=dx + Math.sin(i) * 0.005;
      double yy=dy + Math.cos(i) * 0.005;
      gl.glVertex2d(xx,yy);
    }
  }
  gl.glEnd();
  gl.glFlush();
}",0.8264571054354944
175130,"@Override public void render(OpenGLContext context){
  if (!context.isDirty() || SumoPlatform.isBatchMode()) {
    return;
  }
  int x=context.getX();
  int y=context.getY();
  float zoom=context.getZoom();
  float width=context.getWidth() * zoom;
  float height=context.getHeight() * zoom;
  if (glayer != null) {
    List<Geometry> geomList=glayer.getGeometries();
    if (!threshable && geomList != null) {
      if (getType().equalsIgnoreCase(GeometricLayer.POINT)) {
switch (this.displaysymbol) {
case point:
{
            GL2ShapesRender.renderPolygons(context,width,height,geomList,this.renderWidth,color);
            if (selectedGeometry != null) {
              GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth,color);
            }
          }
        break;
case circle:
{
        GL2ShapesRender.renderCircle(context,width,height,geomList,this.renderWidth,color);
      }
    break;
case square:
{
    GL2ShapesRender.renderSquare(context,width,height,geomList,selectedGeometry,renderWidth,color);
  }
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.POLYGON)) {
for (Geometry tmp : geomList) {
if (tmp instanceof Polygon) {
Polygon polygon=(Polygon)tmp;
if (polygon.getCoordinates().length < 1) {
continue;
}
float rWidth=polygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
int interior=polygon.getNumInteriorRing();
if (interior > 0) {
LineString line=polygon.getExteriorRing();
GL2ShapesRender.drawPoly(context,line.getCoordinates(),width,height,x,y,rWidth,color);
for (int i=0; i < interior; i++) {
LineString line2=polygon.getInteriorRingN(i);
GL2ShapesRender.drawPoly(context,line2.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else {
GL2ShapesRender.drawPoly(context,polygon.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else if (tmp instanceof MultiPolygon) {
MultiPolygon mpolygon=(MultiPolygon)tmp;
if (mpolygon.getCoordinates().length < 1) {
continue;
}
float rWidth=mpolygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
GL2ShapesRender.drawPoly(context,mpolygon.getCoordinates(),width,height,x,y,rWidth,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.LINESTRING)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.MIXED)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof LineString || temp instanceof Polygon) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
 else if (temp instanceof MultiPoint) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
}
 else {
if (getType().equalsIgnoreCase(GeometricLayer.POINT) && geomList != null) {
List<Geometry> toVisualize=new ArrayList<>();
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
toVisualize.add(temp);
}
}
switch (this.displaysymbol) {
case point:
{
GL2ShapesRender.renderPolygons(context,width,height,toVisualize,this.renderWidth,color);
if (selectedGeometry != null) {
GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth * 2,color);
}
}
break;
case circle:
{
GL2ShapesRender.renderCircle(context,width,height,toVisualize,this.renderWidth,color);
}
break;
case square:
{
GL2ShapesRender.renderSquare(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.POLYGON) || getType().equalsIgnoreCase(GeometricLayer.LINESTRING)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.MIXED)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof Polygon || temp instanceof LineString) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
}
}
}
}
}
}","@Override public void render(OpenGLContext context){
  if (!context.isDirty() || SumoPlatform.isBatchMode()) {
    return;
  }
  int x=context.getX();
  int y=context.getY();
  float zoom=context.getZoom();
  float width=context.getWidth() * zoom;
  float height=context.getHeight() * zoom;
  if (glayer != null) {
    List<Geometry> geomList=glayer.getGeometries();
    if (!threshable && geomList != null) {
      if (getType().equalsIgnoreCase(GeometricLayer.POINT)) {
switch (this.displaysymbol) {
case point:
{
            GL2ShapesRender.renderPolygons(context,width,height,geomList,this.renderWidth,color);
            if (selectedGeometry != null) {
              GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth,color);
            }
          }
        break;
case circle:
{
        GL2ShapesRender.renderCircle(context,width,height,geomList,selectedGeometry,this.renderWidth,color);
      }
    break;
case square:
{
    GL2ShapesRender.renderSquare(context,width,height,geomList,selectedGeometry,renderWidth,color);
  }
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.POLYGON)) {
for (Geometry tmp : geomList) {
if (tmp instanceof Polygon) {
Polygon polygon=(Polygon)tmp;
if (polygon.getCoordinates().length < 1) {
continue;
}
float rWidth=polygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
int interior=polygon.getNumInteriorRing();
if (interior > 0) {
LineString line=polygon.getExteriorRing();
GL2ShapesRender.drawPoly(context,line.getCoordinates(),width,height,x,y,rWidth,color);
for (int i=0; i < interior; i++) {
LineString line2=polygon.getInteriorRingN(i);
GL2ShapesRender.drawPoly(context,line2.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else {
GL2ShapesRender.drawPoly(context,polygon.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else if (tmp instanceof MultiPolygon) {
MultiPolygon mpolygon=(MultiPolygon)tmp;
if (mpolygon.getCoordinates().length < 1) {
continue;
}
float rWidth=mpolygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
GL2ShapesRender.drawPoly(context,mpolygon.getCoordinates(),width,height,x,y,rWidth,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.LINESTRING)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.MIXED)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof LineString || temp instanceof Polygon) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
 else if (temp instanceof MultiPoint) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
}
 else {
if (getType().equalsIgnoreCase(GeometricLayer.POINT) && geomList != null) {
List<Geometry> toVisualize=new ArrayList<>();
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
toVisualize.add(temp);
}
}
switch (this.displaysymbol) {
case point:
{
GL2ShapesRender.renderPolygons(context,width,height,toVisualize,this.renderWidth,color);
if (selectedGeometry != null) {
GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth * 2,color);
}
}
break;
case circle:
{
GL2ShapesRender.renderCircle(context,width,height,toVisualize,selectedGeometry,this.renderWidth,color);
}
break;
case square:
{
GL2ShapesRender.renderSquare(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.POLYGON) || getType().equalsIgnoreCase(GeometricLayer.LINESTRING)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.MIXED)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof Polygon || temp instanceof LineString) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
}
}
}
}
}
}",0.9970704807858004
175131,"@Override public void render(OpenGLContext context){
  checkRemoved();
  super.render(context);
  if (!context.isDirty() || glayer == null || !this.edit) {
    return;
  }
  float zoom=context.getZoom(), width=context.getWidth() * zoom, height=context.getHeight() * zoom;
  if (type.equalsIgnoreCase(GeometricLayer.POLYGON) || type.equalsIgnoreCase(GeometricLayer.LINESTRING)) {
    GL2ShapesRender.renderPolygons(context,width,height,glayer.getGeometries(),width * 2,getColor());
  }
  if (editedPoint != null) {
    GL2ShapesRender.renderPoint(context,width,height,editedPoint,width * 3,getColor());
  }
}","@Override public void render(OpenGLContext context){
  checkRemoved();
  super.render(context);
  if (!context.isDirty() || glayer == null || !this.edit) {
    return;
  }
  float zoom=context.getZoom(), width=context.getWidth() * zoom, height=context.getHeight() * zoom;
  if (type.equalsIgnoreCase(GeometricLayer.POLYGON) || type.equalsIgnoreCase(GeometricLayer.LINESTRING)) {
    GL2ShapesRender.renderPolygons(context,width,height,glayer.getGeometries(),2,getColor());
  }
  if (editedPoint != null) {
    GL2ShapesRender.renderPoint(context,width,height,editedPoint,4,getColor());
  }
}",0.9849749582637728
175132,"/** 
 * try to create the correct reader starting from file name
 * @param file
 * @return
 */
public static List<GeoImageReader> createReaderForName(String file){
  List<GeoImageReader> girList=new ArrayList<GeoImageReader>();
  try {
    File f=new File(file);
    String parent=f.getParent();
    if (parent != null && (parent.contains(""String_Node_Str"") || file.contains(""String_Node_Str""))) {
      H5File h5file=new H5File(file,H5File.READ);
      H5Group group=((H5Group)h5file.get(""String_Node_Str""));
      List<HObject> hObjs=group.getMemberList();
      Iterator<HObject> it=hObjs.iterator();
      while (it.hasNext()) {
        HObject obj=it.next();
        CosmoSkymedImage cosmo;
        if (obj.getName().equals(""String_Node_Str""))         cosmo=new CosmoSkymedImage(f,obj.getName(),null);
 else         cosmo=new CosmoSkymedImage(f,obj.getName() + ""String_Node_Str"",obj.getName());
        if (cosmo.initialise()) {
          girList.add(cosmo);
          logger.info(""String_Node_Str"",new Object[]{file,cosmo.getClass()});
        }
        if (girList.size() > 1)         cosmo.setContainsMultipleImage(true);
      }
    }
 else     if (parent.contains(""String_Node_Str"") || parent.contains(""String_Node_Str"")) {
      final SumoJaxbSafeReader safeReader=new SumoJaxbSafeReader(f.getAbsolutePath());
      boolean multipleImages=false;
      String[] swath=safeReader.getSwaths();
      if (swath.length > 1)       multipleImages=true;
      Sentinel1 sentinel=null;
      for (      String sw : swath) {
        if (parent.contains(""String_Node_Str"")) {
          sentinel=new Sentinel1SLC(sw,f);
        }
 else {
          sentinel=new Sentinel1GRD(sw,f);
        }
        sentinel.setContainsMultipleImage(multipleImages);
        if (sentinel.initialise()) {
          logger.info(""String_Node_Str"",new Object[]{file,sentinel.getClass()});
        }
 else {
          logger.warn(""String_Node_Str"",new Object[]{file,sentinel.getClass()});
        }
        girList.add(sentinel);
      }
    }
 else {
      GeoImageReader gir=null;
      if (parent.contains(""String_Node_Str"")) {
        gir=new TerrasarXImage(f);
      }
 else       if (parent.contains(""String_Node_Str"")) {
        gir=new TerrasarXImage(f);
      }
 else       if (parent.contains(""String_Node_Str"") || parent.contains(""String_Node_Str"")) {
        gir=new TerrasarXImage_SLC(f);
      }
 else       if (parent.contains(""String_Node_Str"") && parent.contains(""String_Node_Str"")) {
        gir=new Radarsat2Image_SLC(f);
      }
 else       if (parent.contains(""String_Node_Str"") && !parent.contains(""String_Node_Str"")) {
        gir=new Radarsat2Image(f);
      }
 else       if (parent.contains(""String_Node_Str"")) {
        gir=new Radarsat1Image(f);
      }
 else       if (parent.contains(""String_Node_Str"")) {
        gir=new EnvisatImage_SLC(f);
      }
 else {
        return null;
      }
      if (gir.initialise()) {
        logger.info(""String_Node_Str"",new Object[]{file,gir.getClass()});
        girList.add(gir);
      }
 else {
        girList=null;
      }
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"" + file,ex);
    girList=null;
  }
 finally {
    return girList;
  }
}","/** 
 * try to create the correct reader starting from file name
 * @param file
 * @return
 */
public static List<GeoImageReader> createReaderForName(String file){
  List<GeoImageReader> girList=new ArrayList<GeoImageReader>();
  try {
    File f=new File(file);
    String parent=f.getParent();
    if (parent != null && (parent.contains(""String_Node_Str"") || file.contains(""String_Node_Str""))) {
      H5File h5file=new H5File(file,H5File.READ);
      H5Group group=((H5Group)h5file.get(""String_Node_Str""));
      List<HObject> hObjs=group.getMemberList();
      Iterator<HObject> it=hObjs.iterator();
      while (it.hasNext()) {
        HObject obj=it.next();
        AbstractCosmoSkymedImage cosmo=null;
        if (obj.getName().equals(""String_Node_Str"")) {
          cosmo=CosmoSkyFactory.instanceCosmoSkymed(h5file,obj.getName(),null);
        }
 else {
          if (h5file.get(obj.getName() + ""String_Node_Str"") != null)           cosmo=CosmoSkyFactory.instanceCosmoSkymed(h5file,obj.getName() + ""String_Node_Str"",obj.getName());
        }
        if (cosmo != null) {
          if (cosmo.initialise()) {
            girList.add(cosmo);
            logger.info(""String_Node_Str"",new Object[]{file,cosmo.getClass()});
          }
          if (girList.size() > 1)           cosmo.setContainsMultipleImage(true);
        }
      }
    }
 else     if (parent.contains(""String_Node_Str"") || parent.contains(""String_Node_Str"")) {
      final SumoJaxbSafeReader safeReader=new SumoJaxbSafeReader(f.getAbsolutePath());
      boolean multipleImages=false;
      String[] swath=safeReader.getSwaths();
      if (swath.length > 1)       multipleImages=true;
      Sentinel1 sentinel=null;
      for (      String sw : swath) {
        if (parent.contains(""String_Node_Str"")) {
          sentinel=new Sentinel1SLC(sw,f);
        }
 else {
          sentinel=new Sentinel1GRD(sw,f);
        }
        sentinel.setContainsMultipleImage(multipleImages);
        if (sentinel.initialise()) {
          logger.info(""String_Node_Str"",new Object[]{file,sentinel.getClass()});
        }
 else {
          logger.warn(""String_Node_Str"",new Object[]{file,sentinel.getClass()});
        }
        girList.add(sentinel);
      }
    }
 else {
      GeoImageReader gir=null;
      if (parent.contains(""String_Node_Str"")) {
        gir=new TerrasarXImage(f);
      }
 else       if (parent.contains(""String_Node_Str"")) {
        gir=new TerrasarXImage(f);
      }
 else       if (parent.contains(""String_Node_Str"") || parent.contains(""String_Node_Str"")) {
        gir=new TerrasarXImage_SLC(f);
      }
 else       if (parent.contains(""String_Node_Str"") && parent.contains(""String_Node_Str"")) {
        gir=new Radarsat2Image_SLC(f);
      }
 else       if (parent.contains(""String_Node_Str"") && !parent.contains(""String_Node_Str"")) {
        gir=new Radarsat2Image(f);
      }
 else       if (parent.contains(""String_Node_Str"")) {
        gir=new Radarsat1Image(f);
      }
 else       if (parent.contains(""String_Node_Str"")) {
        gir=new EnvisatImage_SLC(f);
      }
 else {
        return null;
      }
      if (gir.initialise()) {
        logger.info(""String_Node_Str"",new Object[]{file,gir.getClass()});
        girList.add(gir);
      }
 else {
        girList=null;
      }
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"" + file,ex);
    girList=null;
  }
 finally {
    return girList;
  }
}",0.949132075471698
175133,"public AttributesGeometry(String[] attributesSchema){
  this.schema=attributesSchema;
  attributes=new HashMap<String,Object>();
  types=new HashMap<String,Class>();
  types.put(""String_Node_Str"",Integer.class);
}","public AttributesGeometry(String[] attributesSchema,Class[] typesAttr){
  this.schema=attributesSchema;
  attributes=new HashMap<String,Object>();
  types=new HashMap<String,Class>();
  for (int i=0; i < attributesSchema.length; i++) {
    types.put(attributesSchema[i],typesAttr[i]);
  }
}",0.679920477137177
175134,"/** 
 * @param source
 * @return
 */
public AttributesGeometry emptyCloneAttributes(){
  AttributesGeometry out=new AttributesGeometry(getSchema());
  for (int i=0; i < schema.length; i++) {
    if (getValues() != null) {
      out.attributes.put(schema[i],null);
      out.types.put(schema[i],get(schema[i]).getClass());
    }
  }
  return out;
}","/** 
 * @param source
 * @return
 */
public AttributesGeometry emptyCloneAttributes(){
  AttributesGeometry out=new AttributesGeometry(getSchema());
  for (int i=0; i < schema.length; i++) {
    if (getValues() != null) {
      out.attributes.put(schema[i],null);
      if (get(schema[i]) != null)       out.types.put(schema[i],get(schema[i]).getClass());
    }
  }
  return out;
}",0.9532967032967034
175135,"protected void performAdd(java.awt.Point imagePosition,OpenGLContext context){
  if (type.equals(GeometricLayer.POINT)) {
    selectedGeometry=gf.createPoint(new Coordinate(imagePosition.x,imagePosition.y));
    int size=glayer.getGeometries().size();
    Integer maxVal=0;
    for (int i=0; i < size; i++) {
      Integer val=(Integer)((AttributesGeometry)glayer.getGeometries().get(i).getUserData()).get(VDSSchema.ID);
      if (val > maxVal)       maxVal=val;
    }
    maxVal++;
    AttributesGeometry source=(AttributesGeometry)glayer.getGeometries().get(0).getUserData();
    AttributesGeometry atts=source.emptyCloneAttributes();
    atts.set(VDSSchema.ID,maxVal);
    final AttributesEditor ae=new AttributesEditor(new java.awt.Frame(),true);
    ae.setAttributes(atts);
    ae.setVisible(true);
    HashMap<String,Object> newMapVals=ae.getAttributesValues();
    atts=setNewAttributeValues(atts,newMapVals);
    glayer.put(selectedGeometry,atts);
    ae.addWindowListener(new WindowAdapter(){
      public void windowClosed(      WindowEvent e){
        try {
        }
 catch (        Throwable t) {
          t.printStackTrace();
        }
      }
    }
);
  }
}","protected void performAdd(java.awt.Point imagePosition,OpenGLContext context){
  if (type.equals(GeometricLayer.POINT)) {
    selectedGeometry=gf.createPoint(new Coordinate(imagePosition.x,imagePosition.y));
    int size=glayer.getGeometries().size();
    Integer maxVal=0;
    for (int i=0; i < size; i++) {
      Integer val=(Integer)((AttributesGeometry)glayer.getGeometries().get(i).getUserData()).get(VDSSchema.ID);
      if (val > maxVal)       maxVal=val;
    }
    maxVal++;
    AttributesGeometry atts=null;
    atts=new AttributesGeometry(VDSSchema.schema,VDSSchema.types);
    atts.set(VDSSchema.ID,maxVal);
    final AttributesEditor ae=new AttributesEditor(new java.awt.Frame(),true);
    ae.setAttributes(atts);
    ae.setVisible(true);
    HashMap<String,Object> newMapVals=ae.getAttributesValues();
    atts=setNewAttributeValues(atts,newMapVals);
    glayer.put(selectedGeometry,atts);
    ae.addWindowListener(new WindowAdapter(){
      public void windowClosed(      WindowEvent e){
        try {
        }
 catch (        Throwable t) {
          t.printStackTrace();
        }
      }
    }
);
  }
}",0.9297863061491496
175136,"protected AttributesGeometry setNewAttributeValues(AttributesGeometry attr,HashMap<String,Object> map){
  Collection<String> keys=map.keySet();
  SimpleDateFormat df=new SimpleDateFormat(""String_Node_Str"");
  for (int i=0; i < keys.size(); i++) {
    String att=attr.getSchema()[i];
    Class<?> type=attr.getType(attr.getSchema()[i]);
    String val=((String)map.get(att));
    if (val != null && !""String_Node_Str"".equals(val)) {
      try {
        if (type == Double.class) {
          attr.set(att,Double.parseDouble(val));
        }
 else         if (type == String.class) {
          attr.set(att,val);
        }
 else         if (type == Date.class) {
          attr.set(att,df.parse(val));
        }
 else         if (type == Timestamp.class) {
          Date d=df.parse(val);
          attr.set(att,new Timestamp(d.getTime()));
        }
 else         if (type == Integer.class) {
          attr.set(att,Integer.parseInt(val));
        }
 else         if (type == Boolean.class) {
          attr.set(att,Boolean.parseBoolean(val));
        }
 else         if (type.isArray()) {
          int bb=Integer.parseInt(band);
          if (type == int[].class) {
            int[] a=new int[4];
            int id=PlatformConfiguration.getConfigurationInstance().getIdPolarization(SumoPlatform.getApplication().getCurrentImageReader().getBandName(bb));
            a[id]=Integer.parseInt(val);
            attr.set(att,a);
          }
          if (type == double[].class) {
            double[] a=new double[4];
            int id=PlatformConfiguration.getConfigurationInstance().getIdPolarization(SumoPlatform.getApplication().getCurrentImageReader().getBandName(bb));
            a[id]=Double.parseDouble(val);
            attr.set(att,a);
          }
        }
 else {
          attr.set(att,val);
        }
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + att,e.getMessage());
      }
    }
  }
  return attr;
}","protected AttributesGeometry setNewAttributeValues(AttributesGeometry attr,HashMap<String,Object> map){
  Collection<String> keys=map.keySet();
  SimpleDateFormat df=new SimpleDateFormat(""String_Node_Str"");
  for (int i=0; i < keys.size(); i++) {
    String att=attr.getSchema()[i];
    Class<?> type=attr.getType(attr.getSchema()[i]);
    String val=((String)map.get(att));
    if (val != null && !""String_Node_Str"".equals(val)) {
      try {
        if (type == Double.class) {
          attr.set(att,Double.parseDouble(val));
        }
 else         if (type == String.class) {
          attr.set(att,val);
        }
 else         if (type == Date.class) {
          attr.set(att,df.parse(val));
        }
 else         if (type == Timestamp.class) {
          Date d=df.parse(val);
          attr.set(att,new Timestamp(d.getTime()));
        }
 else         if (type == Integer.class) {
          attr.set(att,Integer.parseInt(val));
        }
 else         if (type == Boolean.class) {
          attr.set(att,Boolean.parseBoolean(val));
        }
 else         if (type.isArray()) {
          int bb=Integer.parseInt(band);
          if (type == int[].class || type == Integer[].class) {
            int[] a=new int[4];
            int id=PlatformConfiguration.getConfigurationInstance().getIdPolarization(SumoPlatform.getApplication().getCurrentImageReader().getBandName(bb));
            a[id]=Integer.parseInt(val);
            attr.set(att,a);
          }
          if (type == double[].class || type == Double[].class) {
            double[] a=new double[4];
            int id=PlatformConfiguration.getConfigurationInstance().getIdPolarization(SumoPlatform.getApplication().getCurrentImageReader().getBandName(bb));
            a[id]=Double.parseDouble(val);
            attr.set(att,a);
          }
        }
 else {
          attr.set(att,val);
        }
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + att,e.getMessage());
      }
    }
  }
  return attr;
}",0.9865788807292986
175137,"/** 
 */
protected void saveResults(String imageName,IMask[] masks,SarImageReader reader){
  if (layerResults != null) {
    String outfolder=new StringBuilder(params.outputFolder).append(File.separator).append(imageName).toString();
    File folder=new File(outfolder);
    if (!folder.exists())     folder.mkdirs();
    File xmlOutFolder=null;
    xmlOutFolder=new File(params.xmlOutputFolder);
    if (!xmlOutFolder.exists())     xmlOutFolder.mkdirs();
    for (    ComplexEditVDSVectorLayer l : layerResults) {
      StringBuilder outfileName=new StringBuilder(outfolder).append(File.separator).append(reader.getImId()).append(""String_Node_Str"");
      if (l.getBand().equalsIgnoreCase(""String_Node_Str"")) {
        outfileName.append(l.getBand());
      }
 else {
        outfileName.append(reader.getBandName(Integer.valueOf(l.getBand())));
      }
      if (reader.isContainsMultipleImage() && reader instanceof CosmoSkymedImage) {
        outfileName=outfileName.append(""String_Node_Str"").append(((CosmoSkymedImage)reader).getGroup());
      }
      l.save(outfileName.toString() + ""String_Node_Str"",ComplexEditVDSVectorLayer.OPT_EXPORT_XML_SUMO_OLD,params.epsg);
      File outFile=new File(outfileName.toString() + ""String_Node_Str"");
      SumoXMLWriter.saveNewXML(outFile,l,params.epsg,reader,params.thresholdArrayValues,params.buffer,params.enl,params.shapeFile,runVersion,runVersionNumber);
      try {
        if (layerResults.size() == 1 || l.getBand().equals(""String_Node_Str"")) {
          FileUtils.copyFile(outFile,new File(params.xmlOutputFolder + ""String_Node_Str"" + reader.getImId()+ ""String_Node_Str""));
        }
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
      }
      try {
        String bbox=outfolder + ""String_Node_Str"";
        List<Geometry> ggBbox=new ArrayList<Geometry>();
        try {
          ggBbox.add(reader.getBbox(PlatformConfiguration.getConfigurationInstance().getLandMaskMargin(0)));
          SimpleShapefile.exportGeometriesToShapeFile(ggBbox,new File(bbox),""String_Node_Str"",null,null,null);
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"" + e.getLocalizedMessage(),e);
        }
        String bboxcsv=params.outputFolder + ""String_Node_Str"";
        GenericCSVIO.geomCsv(new File(bboxcsv),ggBbox,null,imageName,true);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + imageName,e);
      }
      try {
        String targets=outfileName.append(""String_Node_Str"").toString();
        SimpleShapefile.exportGeometriesToShapeFile(l.getGeometriclayer().getGeometries(),new File(targets),""String_Node_Str"",reader.getGeoTransform(),null,null);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + e.getLocalizedMessage(),e);
      }
      if (l.getBand().equals(""String_Node_Str"") || layerResults.size() == 1) {
        try {
          String targetscsv=params.outputFolder + ""String_Node_Str"";
          List<Geometry> targets=new ArrayList<Geometry>(l.getGeometriclayer().getGeometries());
          List<Geometry> ambi=new ArrayList<>();
          if (l.getGeometriesByTag(ComplexEditVDSVectorLayer.AZIMUTH_AMBIGUITY_TAG) != null)           ambi.addAll(l.getGeometriesByTag(ComplexEditVDSVectorLayer.AZIMUTH_AMBIGUITY_TAG).getGeometries());
          if (l.getGeometriesByTag(ComplexEditVDSVectorLayer.ARTEFACTS_AMBIGUITY_TAG) != null)           ambi.addAll(l.getGeometriesByTag(ComplexEditVDSVectorLayer.ARTEFACTS_AMBIGUITY_TAG).getGeometries());
          if (!ambi.isEmpty()) {
            for (            Geometry geom : targets) {
              if (ambi.contains(geom)) {
                targets.remove(geom);
              }
            }
          }
          GenericCSVIO.geomCsv(new File(targetscsv),targets,null,imageName,true);
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"" + imageName,e);
        }
      }
    }
    try {
      String bbox=outfolder + ""String_Node_Str"";
      List<Geometry> ggBbox=new ArrayList<Geometry>();
      try {
        ggBbox.add(reader.getBbox(PlatformConfiguration.getConfigurationInstance().getLandMaskMargin(0)));
        SimpleShapefile.exportGeometriesToShapeFile(ggBbox,new File(bbox),""String_Node_Str"",null,null,null);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + e.getLocalizedMessage(),e);
      }
      String bboxcsv=params.outputFolder + ""String_Node_Str"";
      GenericCSVIO.geomCsv(new File(bboxcsv),ggBbox,null,imageName,true);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"" + imageName,e);
    }
  }
}","/** 
 */
protected void saveResults(String imageName,IMask[] masks,SarImageReader reader){
  if (layerResults != null) {
    String outfolder=new StringBuilder(params.outputFolder).append(File.separator).append(imageName).toString();
    File folder=new File(outfolder);
    if (!folder.exists())     folder.mkdirs();
    File xmlOutFolder=null;
    xmlOutFolder=new File(params.xmlOutputFolder);
    if (!xmlOutFolder.exists())     xmlOutFolder.mkdirs();
    for (    ComplexEditVDSVectorLayer l : layerResults) {
      StringBuilder outfileName=new StringBuilder(outfolder).append(File.separator).append(reader.getImId()).append(""String_Node_Str"");
      if (l.getBand().equalsIgnoreCase(""String_Node_Str"")) {
        outfileName.append(l.getBand());
      }
 else {
        outfileName.append(reader.getBandName(Integer.valueOf(l.getBand())));
      }
      if (reader.isContainsMultipleImage() && reader instanceof CosmoSkymedImage) {
        outfileName=outfileName.append(""String_Node_Str"").append(((CosmoSkymedImage)reader).getGroup());
      }
      l.save(outfileName.toString() + ""String_Node_Str"",ComplexEditVDSVectorLayer.OPT_EXPORT_XML_SUMO_OLD,params.epsg);
      File outFile=new File(outfileName.toString() + ""String_Node_Str"");
      SumoXMLWriter.saveNewXML(outFile,l,params.epsg,reader,params.thresholdArrayValues,params.buffer,params.enl,params.shapeFile,runVersion,runVersionNumber);
      try {
        if (layerResults.size() == 1 || l.getBand().equals(""String_Node_Str"")) {
          FileUtils.copyFile(outFile,new File(params.xmlOutputFolder + ""String_Node_Str"" + reader.getImId()+ ""String_Node_Str""));
        }
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
      }
      try {
        String bbox=outfolder + ""String_Node_Str"";
        List<Geometry> ggBbox=new ArrayList<Geometry>();
        try {
          ggBbox.add(reader.getBbox(PlatformConfiguration.getConfigurationInstance().getLandMaskMargin(0)));
          SimpleShapefile.exportGeometriesToShapeFile(ggBbox,new File(bbox),""String_Node_Str"",reader.getGeoTransform(),null,null);
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"" + e.getLocalizedMessage(),e);
        }
        String bboxcsv=params.outputFolder + ""String_Node_Str"";
        GenericCSVIO.geomCsv(new File(bboxcsv),ggBbox,null,imageName,true);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + imageName,e);
      }
      try {
        String targets=outfileName.append(""String_Node_Str"").toString();
        SimpleShapefile.exportGeometriesToShapeFile(l.getGeometriclayer().getGeometries(),new File(targets),""String_Node_Str"",reader.getGeoTransform(),null,null);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + e.getLocalizedMessage(),e);
      }
      if (l.getBand().equals(""String_Node_Str"") || layerResults.size() == 1) {
        try {
          String targetscsv=params.outputFolder + ""String_Node_Str"";
          List<Geometry> targets=new ArrayList<Geometry>(l.getGeometriclayer().getGeometries());
          List<Geometry> ambi=new ArrayList<>();
          if (l.getGeometriesByTag(ComplexEditVDSVectorLayer.AZIMUTH_AMBIGUITY_TAG) != null)           ambi.addAll(l.getGeometriesByTag(ComplexEditVDSVectorLayer.AZIMUTH_AMBIGUITY_TAG).getGeometries());
          if (l.getGeometriesByTag(ComplexEditVDSVectorLayer.ARTEFACTS_AMBIGUITY_TAG) != null)           ambi.addAll(l.getGeometriesByTag(ComplexEditVDSVectorLayer.ARTEFACTS_AMBIGUITY_TAG).getGeometries());
          List<Geometry> toRemove=new ArrayList<>();
          if (!ambi.isEmpty()) {
            for (            Geometry geom : targets) {
              if (ambi.contains(geom)) {
                toRemove.add(geom);
              }
            }
          }
          targets.removeAll(toRemove);
          GenericCSVIO.geomCsv(new File(targetscsv),targets,reader.getGeoTransform(),imageName,true);
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"" + imageName,e);
        }
      }
    }
    try {
      String bbox=outfolder + ""String_Node_Str"";
      List<Geometry> ggBbox=new ArrayList<Geometry>();
      try {
        ggBbox.add(reader.getBbox(PlatformConfiguration.getConfigurationInstance().getLandMaskMargin(0)));
        SimpleShapefile.exportGeometriesToShapeFile(ggBbox,new File(bbox),""String_Node_Str"",null,null,null);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + e.getLocalizedMessage(),e);
      }
      String bboxcsv=params.outputFolder + ""String_Node_Str"";
      GenericCSVIO.geomCsv(new File(bboxcsv),ggBbox,null,imageName,true);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"" + imageName,e);
    }
  }
}",0.98272921108742
175138,"/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP,gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=gf.createGeometry((Geometry)o[i][0]);
            if (applayTransformation && transform != null)             g=transform.transformGeometryPixelFromGeo(g);
            out.put(g,(AttributesGeometry)o[i][1]);
            System.out.println(g.toText());
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}","/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP,gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=gf.createGeometry((Geometry)o[i][0]);
            if (applayTransformation && transform != null)             g=transform.transformGeometryPixelFromGeo(g);
            if (!g.isValid()) {
              if (!g.isSimple()) {
                Geometry b0=g.buffer(0);
                Coordinate[] cc=g.getCoordinates();
                CoordinateList cl=new CoordinateList();
                cl.add(cc,false);
                for (int ii=0; ii < cl.size(); ii++) {
                  if (b0.contains(gf.createPoint(cl.getCoordinate(ii))) || b0.touches(gf.createPoint(cl.getCoordinate(ii)))) {
                    cl.remove(ii);
                  }
                }
                Geometry newGeom=gf.createPolygon(cl.toCoordinateArray());
                g=newGeom.buffer(0);
              }
            }
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}",0.9227846686780646
175139,"@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,getImage(band).xSize,length);
  TIFFImageReadParam tirp=new TIFFImageReadParam();
  tirp.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    preloadedDataReal=tiff.getReader().read(0,tirp).getRaster().getSamples(0,0,getImage(band).xSize,length,0,(int[])null);
    preloadedDataImg=tiff.getReader().read(0,tirp).getRaster().getSamples(0,0,getImage(band).xSize,length,1,(int[])null);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
}","@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,getImage(band).xSize,length);
  TIFFImageReadParam tirp=new TIFFImageReadParam();
  tirp.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    preloadedDataReal=tiff.getReader().read(0,tirp).getRaster().getSamples(0,0,rect.width,rect.height,0,(int[])null);
    preloadedDataImg=tiff.getReader().read(0,tirp).getRaster().getSamples(0,0,rect.width,rect.height,1,(int[])null);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
}",0.9231974921630094
175140,"@Override public int readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int img=tiff.getReader().read(0,t).getRaster().getSample(0,0,1);
    int real=tiff.getReader().read(0,t).getRaster().getSample(0,0,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return -1;
}","@Override public int readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int img=tiff.getReader().readRaster(0,t).getSample(0,0,1);
    int real=tiff.getReader().read(0,t).getRaster().getSample(0,0,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
    ex.printStackTrace();
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return -1;
}",0.9689703808180536
175141,"/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP,gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=gf.createGeometry((Geometry)o[i][0]);
            if (applayTransformation && transform != null)             g=transform.transformGeometryPixelFromGeo(g);
            if (!g.isValid()) {
              if (!g.isSimple()) {
                Geometry b0=g.buffer(0);
                Coordinate[] cc=g.getCoordinates();
                CoordinateList cl=new CoordinateList();
                cl.add(cc,false);
                for (int ii=0; ii < cl.size(); ii++) {
                  if (b0.contains(gf.createPoint(cl.getCoordinate(ii))) || b0.touches(gf.createPoint(cl.getCoordinate(ii)))) {
                    cl.remove(ii);
                  }
                }
                Geometry newGeom=gf.createPolygon(cl.toCoordinateArray());
                g=newGeom.buffer(0);
              }
            }
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}","/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP,gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=gf.createGeometry((Geometry)o[i][0]);
            if (applayTransformation && transform != null)             g=transform.transformGeometryPixelFromGeo(g);
            if (!g.isValid()) {
              Geometry b0=g.buffer(0);
              if (!g.isSimple() && (b0.getArea() / g.getArea()) < 0.75) {
                Coordinate[] cc=g.getCoordinates();
                CoordinateList cl=new CoordinateList();
                cl.add(cc,false);
                for (int ii=0; ii < cl.size(); ii++) {
                  if (b0.contains(gf.createPoint(cl.getCoordinate(ii))) || b0.touches(gf.createPoint(cl.getCoordinate(ii)))) {
                    cl.remove(ii);
                  }
                }
                cl.closeRing();
                Geometry newGeom=gf.createPolygon(cl.toCoordinateArray());
                g=newGeom.buffer(0);
              }
 else {
                g=b0;
              }
            }
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}",0.9804489500362056
175142,"@Override public int[] read(int x,int y,int w,int h,int band){
  int[] data=new int[w * h];
  TIFFImageReadParam t=new TIFFImageReadParam();
  t.setSourceRegion(new Rectangle(x,y,w,h));
  TIFF tiff=getImage(band);
  try {
    int[] img=tiff.getReader().read(0,t).getRaster().getSamples(x,y,w,h,1,(int[])null);
    int[] real=tiff.getReader().read(0,t).getRaster().getSamples(x,y,w,h,0,(int[])null);
    for (int i=0; i < img.length; i++) {
      data[i]=(int)Math.sqrt(real[i] * real[i] + img[i] * img[i]);
    }
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return data;
}","@Override public int[] read(int x,int y,int w,int h,int band){
  int[] data=new int[w * h];
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,w,h);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int[] img=tiff.getReader().read(0,t).getRaster().getSamples(0,0,w,h,1,(int[])null);
    int[] real=tiff.getReader().read(0,t).getRaster().getSamples(0,0,w,h,0,(int[])null);
    for (int i=0; i < img.length; i++) {
      data[i]=(int)Math.sqrt(real[i] * real[i] + img[i] * img[i]);
    }
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return data;
}",0.9302899444787168
175143,"@Override public int readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  t.setSourceRegion(new Rectangle(x,y,1,1));
  TIFF tiff=getImage(band);
  try {
    int img=tiff.getReader().read(0,t).getRaster().getSample(x,y,1);
    int real=tiff.getReader().read(0,t).getRaster().getSample(x,y,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return -1;
}","@Override public int readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int img=tiff.getReader().read(0,t).getRaster().getSample(0,0,1);
    int real=tiff.getReader().read(0,t).getRaster().getSample(0,0,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return -1;
}",0.9157345264727816
175144,"@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(bounds);
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] | rect.y + rect.height != preloadedInterval[1]) {
    preloadLineTile(rect.y,rect.height,band);
  }
  int yOffset=getImage(band).xSize;
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      long real=preloadedDataReal[temp];
      long img=preloadedDataImg[temp];
      tile[(i + yinit) * width + j + xinit]=(int)Math.sqrt(real * real + img * img);
    }
  }
  return tile;
}","@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(bounds);
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] | rect.y + rect.height != preloadedInterval[1]) {
    preloadLineTile(rect.y,rect.height,band);
  }
  int yOffset=getImage(band).xSize;
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  int temp=0;
  try {
    for (int i=0; i < rect.height; i++) {
      for (int j=0; j < rect.width; j++) {
        temp=(i * yOffset + j + rect.x);
        long real=preloadedDataReal[temp];
        long img=preloadedDataImg[temp];
        tile[(i + yinit) * width + j + xinit]=(int)Math.sqrt(real * real + img * img);
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return tile;
}",0.9296116504854368
175145,"/** 
 * @param geoms
 * @param fileOutput
 * @param geomType
 * @param transform
 * @throws IOException
 * @throws SchemaException
 */
public static void exportGeometriesToShapeFile(final List<Geometry> geoms,File fileOutput,String geomType,GeoTransform transform,SimpleFeatureType featureType,List<AttributesGeometry> atts) throws IOException, SchemaException {
  FileDataStoreFactorySpi factory=new ShapefileDataStoreFactory();
  Map map=Collections.singletonMap(""String_Node_Str"",fileOutput.toURI().toURL());
  DataStore data=factory.createNewDataStore(map);
  if (featureType == null)   featureType=DataUtilities.createType(""String_Node_Str"",""String_Node_Str"" + geomType + ""String_Node_Str"");
  data.createSchema(featureType);
  Transaction transaction=new DefaultTransaction();
  FeatureWriter<SimpleFeatureType,SimpleFeature> writer=data.getFeatureWriterAppend(data.getTypeNames()[0],transaction);
  SimpleFeatureBuilder featureBuilder=new SimpleFeatureBuilder(featureType);
  GeometryFactory gb=new GeometryFactory();
  try {
    int fid=0;
    for (    final Geometry g : geoms) {
      Geometry clone=gb.createGeometry(g);
      if (transform != null)       clone=transform.transformGeometryGeoFromPixel(clone);
      featureBuilder.add(""String_Node_Str"");
      featureBuilder.add(clone);
      SimpleFeature sf=featureBuilder.buildFeature(""String_Node_Str"" + fid++);
      SimpleFeature sfout=writer.next();
      sfout.setAttributes(sf.getAttributes());
      if (atts != null && !atts.isEmpty()) {
        AttributesGeometry att=atts.get(fid - 1);
        String sch[]=att.getSchema();
        for (int i=0; i < sch.length; i++) {
          Object val=att.get(sch[i]);
          if (val.getClass().isArray()) {
            Object o=ArrayUtils.toString(val);
            sfout.setAttribute(sch[i],o);
          }
 else {
            sfout.setAttribute(sch[i],val);
          }
        }
      }
      sfout.setDefaultGeometry(clone);
      writer.write();
    }
    transaction.commit();
    logger.info(""String_Node_Str"" + fileOutput.getAbsolutePath());
  }
 catch (  Exception problem) {
    problem.printStackTrace();
    transaction.rollback();
    logger.error(""String_Node_Str"",problem);
  }
 finally {
    writer.close();
    transaction.close();
    data.dispose();
  }
}","/** 
 * @param geoms
 * @param fileOutput
 * @param geomType
 * @param transform
 * @throws IOException
 * @throws SchemaException
 */
public static void exportGeometriesToShapeFile(final List<Geometry> geoms,File fileOutput,String geomType,GeoTransform transform,SimpleFeatureType featureType) throws IOException, SchemaException {
  FileDataStoreFactorySpi factory=new ShapefileDataStoreFactory();
  Map map=Collections.singletonMap(""String_Node_Str"",fileOutput.toURI().toURL());
  DataStore data=factory.createNewDataStore(map);
  boolean addAttr=true;
  if (featureType == null) {
    featureType=DataUtilities.createType(""String_Node_Str"",""String_Node_Str"" + geomType + ""String_Node_Str"");
    addAttr=false;
  }
  data.createSchema(featureType);
  Transaction transaction=new DefaultTransaction();
  FeatureWriter<SimpleFeatureType,SimpleFeature> writer=data.getFeatureWriterAppend(data.getTypeNames()[0],transaction);
  SimpleFeatureBuilder featureBuilder=new SimpleFeatureBuilder(featureType);
  GeometryFactory gb=new GeometryFactory();
  try {
    int fid=0;
    for (    final Geometry g : geoms) {
      Geometry clone=gb.createGeometry(g);
      if (transform != null)       clone=transform.transformGeometryGeoFromPixel(clone);
      featureBuilder.add(""String_Node_Str"");
      featureBuilder.add(clone);
      SimpleFeature sf=featureBuilder.buildFeature(""String_Node_Str"" + fid++);
      SimpleFeature sfout=writer.next();
      sfout.setAttributes(sf.getAttributes());
      AttributesGeometry att=(AttributesGeometry)g.getUserData();
      try {
        if (att != null && addAttr) {
          String sch[]=att.getSchema();
          for (int i=0; i < sch.length; i++) {
            Object val=att.get(sch[i]);
            if (val.getClass().isArray()) {
              Object o=ArrayUtils.toString(val);
              sfout.setAttribute(sch[i],o);
            }
 else {
              sfout.setAttribute(sch[i],val);
            }
          }
        }
      }
 catch (      Exception e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
      sfout.setDefaultGeometry(clone);
      writer.write();
    }
    transaction.commit();
    logger.info(""String_Node_Str"" + fileOutput.getAbsolutePath());
  }
 catch (  Exception problem) {
    problem.printStackTrace();
    transaction.rollback();
    logger.error(""String_Node_Str"",problem);
  }
 finally {
    writer.close();
    transaction.close();
    data.dispose();
  }
}",0.879949452401011
175146,"public static void main(String[] args){
  double cc[][]=new double[][]{{200.0,200.0},{500.0,200.0},{500.0,500.0},{200.0,500.0},{200.0,200.0}};
  try {
    Polygon p=PolygonOp.createPolygon(cc);
    List<Geometry> geoms=new ArrayList<>();
    geoms.add(p);
    SimpleShapefile.exportGeometriesToShapeFile(geoms,new File(""String_Node_Str""),""String_Node_Str"",null,null,null);
  }
 catch (  IOException|SchemaException e) {
    e.printStackTrace();
  }
catch (  ParseException e) {
    e.printStackTrace();
  }
}","public static void main(String[] args){
  double cc[][]=new double[][]{{200.0,200.0},{500.0,200.0},{500.0,500.0},{200.0,500.0},{200.0,200.0}};
  try {
    Polygon p=PolygonOp.createPolygon(cc);
    List<Geometry> geoms=new ArrayList<>();
    geoms.add(p);
    SimpleShapefile.exportGeometriesToShapeFile(geoms,new File(""String_Node_Str""),""String_Node_Str"",null,null);
  }
 catch (  IOException|SchemaException e) {
    e.printStackTrace();
  }
catch (  ParseException e) {
    e.printStackTrace();
  }
}",0.9950544015825916
175147,"/** 
 * @param output
 * @param layer
 * @param projection
 * @param reader
 */
public static void exportLayer(File output,GeometricLayer layer,String projection,GeoTransform transform){
  try {
    String type=layer.getGeometries().get(0).getGeometryType();
    SimpleFeatureType featureType=createFeatureType(layer.getGeometries().get(0).getClass(),layer.getAttributes().get(0));
    exportGeometriesToShapeFile(layer.getGeometries(),output,type,transform,featureType,layer.getAttributes());
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}","/** 
 * @param output
 * @param layer
 * @param projection
 * @param reader
 */
public static void exportLayer(File output,GeometricLayer layer,String projection,GeoTransform transform){
  try {
    String type=layer.getGeometries().get(0).getGeometryType();
    SimpleFeatureType featureType=createFeatureType(layer.getGeometries().get(0).getClass(),(AttributesGeometry)layer.getGeometries().get(0).getUserData());
    exportGeometriesToShapeFile(layer.getGeometries(),output,type,transform,featureType);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}",0.9370748299319728
175148,"private void calculateMaxMinTresh(){
  minThresh=Double.MAX_VALUE;
  maxThresh=Double.MIN_VALUE;
  for (  AttributesGeometry att : glayer.getAttributes()) {
    double temp=new Double(""String_Node_Str"" + att.get(VDSSchema.SIGNIFICANCE));
    if (temp < minThresh) {
      minThresh=temp;
    }
    if (temp > maxThresh) {
      maxThresh=temp;
    }
  }
  currentThresh=minThresh - 0.01;
}","private void calculateMaxMinTresh(){
  minThresh=Double.MAX_VALUE;
  maxThresh=Double.MIN_VALUE;
  for (  Geometry geoms : glayer.getGeometries()) {
    AttributesGeometry att=(AttributesGeometry)geoms.getUserData();
    double temp=new Double(""String_Node_Str"" + att.get(VDSSchema.SIGNIFICANCE));
    if (temp < minThresh) {
      minThresh=temp;
    }
    if (temp > maxThresh) {
      maxThresh=temp;
    }
  }
  currentThresh=minThresh - 0.01;
}",0.8782816229116945
175149,"public Date[] getDates(){
  Date[] out=new Date[2];
  out[1]=new Date(0);
  out[0]=new Date(Long.MAX_VALUE);
  for (  AttributesGeometry at : glayer.getAttributes()) {
    Date temp=(Date)at.get(timeColumn);
    if (out[0].after(temp)) {
      out[0]=temp;
    }
    if (out[1].before(temp)) {
      out[1]=temp;
    }
  }
  return out;
}","public Date[] getDates(){
  Date[] out=new Date[2];
  out[1]=new Date(0);
  out[0]=new Date(Long.MAX_VALUE);
  for (  Geometry g : glayer.getGeometries()) {
    AttributesGeometry at=(AttributesGeometry)g.getUserData();
    Date temp=(Date)at.get(timeColumn);
    if (out[0].after(temp)) {
      out[0]=temp;
    }
    if (out[1].before(temp)) {
      out[1]=temp;
    }
  }
  return out;
}",0.4697802197802198
175150,"/** 
 * @param geoms
 * @param fileOutput
 * @param geomType
 * @param transform
 * @throws IOException
 * @throws SchemaException
 */
public static void exportGeometriesToShapeFile(final List<Geometry> geoms,File fileOutput,String geomType,GeoTransform transform,SimpleFeatureType featureType,List<AttributesGeometry> atts) throws IOException, SchemaException {
  FileDataStoreFactorySpi factory=new ShapefileDataStoreFactory();
  Map map=Collections.singletonMap(""String_Node_Str"",fileOutput.toURI().toURL());
  DataStore data=factory.createNewDataStore(map);
  if (featureType == null)   featureType=DataUtilities.createType(""String_Node_Str"",""String_Node_Str"" + geomType + ""String_Node_Str"");
  data.createSchema(featureType);
  Transaction transaction=new DefaultTransaction();
  FeatureWriter<SimpleFeatureType,SimpleFeature> writer=data.getFeatureWriterAppend(data.getTypeNames()[0],transaction);
  SimpleFeatureBuilder featureBuilder=new SimpleFeatureBuilder(featureType);
  GeometryFactory gb=new GeometryFactory();
  try {
    int fid=0;
    for (    final Geometry g : geoms) {
      Geometry clone=gb.createGeometry(g);
      if (transform != null)       clone=transform.transformGeometryGeoFromPixel(clone);
      featureBuilder.add(""String_Node_Str"");
      featureBuilder.add(clone);
      SimpleFeature sf=featureBuilder.buildFeature(""String_Node_Str"" + fid++);
      SimpleFeature sfout=writer.next();
      sfout.setAttributes(sf.getAttributes());
      if (atts != null && !atts.isEmpty()) {
        AttributesGeometry att=atts.get(fid - 1);
        String sch[]=att.getSchema();
        for (int i=0; i < sch.length; i++) {
          Object val=att.get(sch[i]);
          if (val.getClass().isArray()) {
            Object o=ArrayUtils.toString(val);
            sfout.setAttribute(sch[i],o);
          }
 else {
            sfout.setAttribute(sch[i],val);
          }
        }
      }
      sfout.setDefaultGeometry(clone);
      writer.write();
    }
    transaction.commit();
    logger.info(""String_Node_Str"" + fileOutput.getAbsolutePath());
  }
 catch (  Exception problem) {
    problem.printStackTrace();
    transaction.rollback();
    logger.error(""String_Node_Str"",problem);
  }
 finally {
    writer.close();
    transaction.close();
    data.dispose();
  }
}","/** 
 * @param geoms
 * @param fileOutput
 * @param geomType
 * @param transform
 * @throws IOException
 * @throws SchemaException
 */
public static void exportGeometriesToShapeFile(final List<Geometry> geoms,File fileOutput,String geomType,GeoTransform transform,SimpleFeatureType featureType) throws IOException, SchemaException {
  FileDataStoreFactorySpi factory=new ShapefileDataStoreFactory();
  Map map=Collections.singletonMap(""String_Node_Str"",fileOutput.toURI().toURL());
  DataStore data=factory.createNewDataStore(map);
  boolean addAttr=true;
  if (featureType == null) {
    featureType=DataUtilities.createType(""String_Node_Str"",""String_Node_Str"" + geomType + ""String_Node_Str"");
    addAttr=false;
  }
  data.createSchema(featureType);
  Transaction transaction=new DefaultTransaction();
  FeatureWriter<SimpleFeatureType,SimpleFeature> writer=data.getFeatureWriterAppend(data.getTypeNames()[0],transaction);
  SimpleFeatureBuilder featureBuilder=new SimpleFeatureBuilder(featureType);
  GeometryFactory gb=new GeometryFactory();
  try {
    int fid=0;
    for (    final Geometry g : geoms) {
      Geometry clone=gb.createGeometry(g);
      if (transform != null)       clone=transform.transformGeometryGeoFromPixel(clone);
      featureBuilder.add(""String_Node_Str"");
      featureBuilder.add(clone);
      SimpleFeature sf=featureBuilder.buildFeature(""String_Node_Str"" + fid++);
      SimpleFeature sfout=writer.next();
      sfout.setAttributes(sf.getAttributes());
      AttributesGeometry att=(AttributesGeometry)g.getUserData();
      try {
        if (att != null && addAttr) {
          String sch[]=att.getSchema();
          for (int i=0; i < sch.length; i++) {
            Object val=att.get(sch[i]);
            if (val.getClass().isArray()) {
              Object o=ArrayUtils.toString(val);
              sfout.setAttribute(sch[i],o);
            }
 else {
              sfout.setAttribute(sch[i],val);
            }
          }
        }
      }
 catch (      Exception e) {
        logger.warn(""String_Node_Str"" + e.getMessage());
      }
      sfout.setDefaultGeometry(clone);
      writer.write();
    }
    transaction.commit();
    logger.info(""String_Node_Str"" + fileOutput.getAbsolutePath());
  }
 catch (  Exception problem) {
    problem.printStackTrace();
    transaction.rollback();
    logger.error(""String_Node_Str"",problem);
  }
 finally {
    writer.close();
    transaction.close();
    data.dispose();
  }
}",0.879949452401011
175151,"public static void main(String[] args){
  double cc[][]=new double[][]{{200.0,200.0},{500.0,200.0},{500.0,500.0},{200.0,500.0},{200.0,200.0}};
  try {
    Polygon p=PolygonOp.createPolygon(cc);
    List<Geometry> geoms=new ArrayList<>();
    geoms.add(p);
    SimpleShapefile.exportGeometriesToShapeFile(geoms,new File(""String_Node_Str""),""String_Node_Str"",null,null,null);
  }
 catch (  IOException|SchemaException e) {
    e.printStackTrace();
  }
catch (  ParseException e) {
    e.printStackTrace();
  }
}","public static void main(String[] args){
  double cc[][]=new double[][]{{200.0,200.0},{500.0,200.0},{500.0,500.0},{200.0,500.0},{200.0,200.0}};
  try {
    Polygon p=PolygonOp.createPolygon(cc);
    List<Geometry> geoms=new ArrayList<>();
    geoms.add(p);
    SimpleShapefile.exportGeometriesToShapeFile(geoms,new File(""String_Node_Str""),""String_Node_Str"",null,null);
  }
 catch (  IOException|SchemaException e) {
    e.printStackTrace();
  }
catch (  ParseException e) {
    e.printStackTrace();
  }
}",0.9950544015825916
175152,"/** 
 * @param output
 * @param layer
 * @param projection
 * @param reader
 */
public static void exportLayer(File output,GeometricLayer layer,String projection,GeoTransform transform){
  try {
    String type=layer.getGeometries().get(0).getGeometryType();
    SimpleFeatureType featureType=createFeatureType(layer.getGeometries().get(0).getClass(),layer.getAttributes().get(0));
    exportGeometriesToShapeFile(layer.getGeometries(),output,type,transform,featureType,layer.getAttributes());
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}","/** 
 * @param output
 * @param layer
 * @param projection
 * @param reader
 */
public static void exportLayer(File output,GeometricLayer layer,String projection,GeoTransform transform){
  try {
    String type=layer.getGeometries().get(0).getGeometryType();
    SimpleFeatureType featureType=createFeatureType(layer.getGeometries().get(0).getClass(),(AttributesGeometry)layer.getGeometries().get(0).getUserData());
    exportGeometriesToShapeFile(layer.getGeometries(),output,type,transform,featureType);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
  }
}",0.9370748299319728
175153,"private void calculateMaxMinTresh(){
  minThresh=Double.MAX_VALUE;
  maxThresh=Double.MIN_VALUE;
  for (  AttributesGeometry att : glayer.getAttributes()) {
    double temp=new Double(""String_Node_Str"" + att.get(VDSSchema.SIGNIFICANCE));
    if (temp < minThresh) {
      minThresh=temp;
    }
    if (temp > maxThresh) {
      maxThresh=temp;
    }
  }
  currentThresh=minThresh - 0.01;
}","private void calculateMaxMinTresh(){
  minThresh=Double.MAX_VALUE;
  maxThresh=Double.MIN_VALUE;
  for (  Geometry geoms : glayer.getGeometries()) {
    AttributesGeometry att=(AttributesGeometry)geoms.getUserData();
    double temp=new Double(""String_Node_Str"" + att.get(VDSSchema.SIGNIFICANCE));
    if (temp < minThresh) {
      minThresh=temp;
    }
    if (temp > maxThresh) {
      maxThresh=temp;
    }
  }
  currentThresh=minThresh - 0.01;
}",0.8782816229116945
175154,"public Date[] getDates(){
  Date[] out=new Date[2];
  out[1]=new Date(0);
  out[0]=new Date(Long.MAX_VALUE);
  for (  AttributesGeometry at : glayer.getAttributes()) {
    Date temp=(Date)at.get(timeColumn);
    if (out[0].after(temp)) {
      out[0]=temp;
    }
    if (out[1].before(temp)) {
      out[1]=temp;
    }
  }
  return out;
}","public Date[] getDates(){
  Date[] out=new Date[2];
  out[1]=new Date(0);
  out[0]=new Date(Long.MAX_VALUE);
  for (  Geometry g : glayer.getGeometries()) {
    AttributesGeometry at=(AttributesGeometry)g.getUserData();
    Date temp=(Date)at.get(timeColumn);
    if (out[0].after(temp)) {
      out[0]=temp;
    }
    if (out[1].before(temp)) {
      out[1]=temp;
    }
  }
  return out;
}",0.4697802197802198
175155,"public static void renderCircle(OpenGLContext context,float zoomWidth,float zoomHeight,List<Geometry> geometries,float size,Color color){
  GL2 gl=context.getGL().getGL2();
  gl.glBegin(GL.GL_POINTS);
  gl.glLineWidth(size);
  for (int ii=0; ii < geometries.size(); ii++) {
    Geometry temp=geometries.get(ii);
    Coordinate point=temp.getCoordinate();
    double dx=(point.x - context.getX()) / zoomWidth;
    double dy=1 - (point.y - context.getY()) / zoomHeight;
    for (int i=0; i < 360; i++) {
      double xx=dx + Math.sin(i) * 0.005;
      double yy=dy + Math.cos(i) * 0.005;
      gl.glVertex2d(xx,yy);
    }
  }
  gl.glEnd();
  gl.glFlush();
}","public static void renderCircle(OpenGLContext context,float zoomWidth,float zoomHeight,List<Geometry> geometries,Geometry selectedGeometry,float size,Color color){
  GL2 gl=context.getGL().getGL2();
  float[] c=color.brighter().getColorComponents(null);
  gl.glColor3f(c[0],c[1],c[2]);
  gl.glBegin(GL.GL_POINTS);
  for (int ii=0; ii < geometries.size(); ii++) {
    Geometry temp=geometries.get(ii);
    gl.glLineWidth(temp == selectedGeometry ? size * 2 : size);
    gl.glPointSize(temp == selectedGeometry ? size * 2 : size);
    Coordinate point=temp.getCoordinate();
    double dx=(point.x - context.getX()) / zoomWidth;
    double dy=1 - (point.y - context.getY()) / zoomHeight;
    for (int i=0; i < 360; i++) {
      double xx=dx + Math.sin(i) * 0.005;
      double yy=dy + Math.cos(i) * 0.005;
      gl.glVertex2d(xx,yy);
    }
  }
  gl.glEnd();
  gl.glFlush();
}",0.8264571054354944
175156,"@Override public void render(OpenGLContext context){
  if (!context.isDirty() || SumoPlatform.isBatchMode()) {
    return;
  }
  int x=context.getX();
  int y=context.getY();
  float zoom=context.getZoom();
  float width=context.getWidth() * zoom;
  float height=context.getHeight() * zoom;
  if (glayer != null) {
    List<Geometry> geomList=glayer.getGeometries();
    if (!threshable && geomList != null) {
      if (getType().equalsIgnoreCase(GeometricLayer.POINT)) {
switch (this.displaysymbol) {
case point:
{
            GL2ShapesRender.renderPolygons(context,width,height,geomList,this.renderWidth,color);
            if (selectedGeometry != null) {
              GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth,color);
            }
          }
        break;
case circle:
{
        GL2ShapesRender.renderCircle(context,width,height,geomList,this.renderWidth,color);
      }
    break;
case square:
{
    GL2ShapesRender.renderSquare(context,width,height,geomList,selectedGeometry,renderWidth,color);
  }
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.POLYGON)) {
for (Geometry tmp : geomList) {
if (tmp instanceof Polygon) {
Polygon polygon=(Polygon)tmp;
if (polygon.getCoordinates().length < 1) {
continue;
}
float rWidth=polygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
int interior=polygon.getNumInteriorRing();
if (interior > 0) {
LineString line=polygon.getExteriorRing();
GL2ShapesRender.drawPoly(context,line.getCoordinates(),width,height,x,y,rWidth,color);
for (int i=0; i < interior; i++) {
LineString line2=polygon.getInteriorRingN(i);
GL2ShapesRender.drawPoly(context,line2.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else {
GL2ShapesRender.drawPoly(context,polygon.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else if (tmp instanceof MultiPolygon) {
MultiPolygon mpolygon=(MultiPolygon)tmp;
if (mpolygon.getCoordinates().length < 1) {
continue;
}
float rWidth=mpolygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
GL2ShapesRender.drawPoly(context,mpolygon.getCoordinates(),width,height,x,y,rWidth,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.LINESTRING)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.MIXED)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof LineString || temp instanceof Polygon) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
 else if (temp instanceof MultiPoint) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
}
 else {
if (getType().equalsIgnoreCase(GeometricLayer.POINT) && geomList != null) {
List<Geometry> toVisualize=new ArrayList<>();
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
toVisualize.add(temp);
}
}
switch (this.displaysymbol) {
case point:
{
GL2ShapesRender.renderPolygons(context,width,height,toVisualize,this.renderWidth,color);
if (selectedGeometry != null) {
GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth * 2,color);
}
}
break;
case circle:
{
GL2ShapesRender.renderCircle(context,width,height,toVisualize,this.renderWidth,color);
}
break;
case square:
{
GL2ShapesRender.renderSquare(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.POLYGON) || getType().equalsIgnoreCase(GeometricLayer.LINESTRING)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.MIXED)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof Polygon || temp instanceof LineString) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
}
}
}
}
}
}","@Override public void render(OpenGLContext context){
  if (!context.isDirty() || SumoPlatform.isBatchMode()) {
    return;
  }
  int x=context.getX();
  int y=context.getY();
  float zoom=context.getZoom();
  float width=context.getWidth() * zoom;
  float height=context.getHeight() * zoom;
  if (glayer != null) {
    List<Geometry> geomList=glayer.getGeometries();
    if (!threshable && geomList != null) {
      if (getType().equalsIgnoreCase(GeometricLayer.POINT)) {
switch (this.displaysymbol) {
case point:
{
            GL2ShapesRender.renderPolygons(context,width,height,geomList,this.renderWidth,color);
            if (selectedGeometry != null) {
              GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth,color);
            }
          }
        break;
case circle:
{
        GL2ShapesRender.renderCircle(context,width,height,geomList,selectedGeometry,this.renderWidth,color);
      }
    break;
case square:
{
    GL2ShapesRender.renderSquare(context,width,height,geomList,selectedGeometry,renderWidth,color);
  }
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,geomList,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.POLYGON)) {
for (Geometry tmp : geomList) {
if (tmp instanceof Polygon) {
Polygon polygon=(Polygon)tmp;
if (polygon.getCoordinates().length < 1) {
continue;
}
float rWidth=polygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
int interior=polygon.getNumInteriorRing();
if (interior > 0) {
LineString line=polygon.getExteriorRing();
GL2ShapesRender.drawPoly(context,line.getCoordinates(),width,height,x,y,rWidth,color);
for (int i=0; i < interior; i++) {
LineString line2=polygon.getInteriorRingN(i);
GL2ShapesRender.drawPoly(context,line2.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else {
GL2ShapesRender.drawPoly(context,polygon.getCoordinates(),width,height,x,y,rWidth,color);
}
}
 else if (tmp instanceof MultiPolygon) {
MultiPolygon mpolygon=(MultiPolygon)tmp;
if (mpolygon.getCoordinates().length < 1) {
continue;
}
float rWidth=mpolygon == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
GL2ShapesRender.drawPoly(context,mpolygon.getCoordinates(),width,height,x,y,rWidth,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.LINESTRING)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.MIXED)) {
for (Geometry temp : geomList) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof LineString || temp instanceof Polygon) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
 else if (temp instanceof MultiPoint) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
}
 else {
if (getType().equalsIgnoreCase(GeometricLayer.POINT) && geomList != null) {
List<Geometry> toVisualize=new ArrayList<>();
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
toVisualize.add(temp);
}
}
switch (this.displaysymbol) {
case point:
{
GL2ShapesRender.renderPolygons(context,width,height,toVisualize,this.renderWidth,color);
if (selectedGeometry != null) {
GL2ShapesRender.renderPoint(context,width,height,selectedGeometry.getCoordinate(),this.renderWidth * 2,color);
}
}
break;
case circle:
{
GL2ShapesRender.renderCircle(context,width,height,toVisualize,selectedGeometry,this.renderWidth,color);
}
break;
case square:
{
GL2ShapesRender.renderSquare(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case cross:
{
GL2ShapesRender.renderCross(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
case triangle:
{
GL2ShapesRender.renderTriangle(context,width,height,toVisualize,selectedGeometry,renderWidth,color);
}
break;
default :
{
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.POLYGON) || getType().equalsIgnoreCase(GeometricLayer.LINESTRING)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
}
}
 else if (getType().equalsIgnoreCase(GeometricLayer.MIXED)) {
for (Geometry temp : geomList) {
if (((Double)glayer.getAttributes(temp).get(VDSSchema.SIGNIFICANCE)) > currentThresh) {
if (temp.getCoordinates().length < 1) {
continue;
}
if (temp instanceof Polygon || temp instanceof LineString) {
float size=(temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth);
GL2ShapesRender.renderPolygon(context,width,height,temp.getCoordinates(),size,color);
}
 else if (temp instanceof Point) {
float size=temp == selectedGeometry ? this.renderWidth * 2 : this.renderWidth;
Coordinate point=temp.getCoordinate();
GL2ShapesRender.renderPoint(context,width,height,point,size,color);
}
}
}
}
}
}
}",0.9970704807858004
175157,"@Override public void render(OpenGLContext context){
  checkRemoved();
  super.render(context);
  if (!context.isDirty() || glayer == null || !this.edit) {
    return;
  }
  float zoom=context.getZoom(), width=context.getWidth() * zoom, height=context.getHeight() * zoom;
  if (type.equalsIgnoreCase(GeometricLayer.POLYGON) || type.equalsIgnoreCase(GeometricLayer.LINESTRING)) {
    GL2ShapesRender.renderPolygons(context,width,height,glayer.getGeometries(),width * 2,getColor());
  }
  if (editedPoint != null) {
    GL2ShapesRender.renderPoint(context,width,height,editedPoint,width * 3,getColor());
  }
}","@Override public void render(OpenGLContext context){
  checkRemoved();
  super.render(context);
  if (!context.isDirty() || glayer == null || !this.edit) {
    return;
  }
  float zoom=context.getZoom(), width=context.getWidth() * zoom, height=context.getHeight() * zoom;
  if (type.equalsIgnoreCase(GeometricLayer.POLYGON) || type.equalsIgnoreCase(GeometricLayer.LINESTRING)) {
    GL2ShapesRender.renderPolygons(context,width,height,glayer.getGeometries(),2,getColor());
  }
  if (editedPoint != null) {
    GL2ShapesRender.renderPoint(context,width,height,editedPoint,4,getColor());
  }
}",0.9849749582637728
175158,"@Override public int[] read(int x,int y,int w,int h,int band){
  int[] data=new int[w * h];
  TIFFImageReadParam t=new TIFFImageReadParam();
  t.setSourceRegion(new Rectangle(x,y,w,h));
  TIFF tiff=getImage(band);
  try {
    int[] img=tiff.getReader().read(0,t).getRaster().getSamples(x,y,w,h,1,(int[])null);
    int[] real=tiff.getReader().read(0,t).getRaster().getSamples(x,y,w,h,0,(int[])null);
    for (int i=0; i < img.length; i++) {
      data[i]=(int)Math.sqrt(real[i] * real[i] + img[i] * img[i]);
    }
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return data;
}","@Override public int[] read(int x,int y,int w,int h,int band){
  int[] data=new int[w * h];
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,w,h);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int[] img=tiff.getReader().read(0,t).getRaster().getSamples(0,0,w,h,1,(int[])null);
    int[] real=tiff.getReader().read(0,t).getRaster().getSamples(0,0,w,h,0,(int[])null);
    for (int i=0; i < img.length; i++) {
      data[i]=(int)Math.sqrt(real[i] * real[i] + img[i] * img[i]);
    }
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return data;
}",0.9302899444787168
175159,"@Override public int readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  t.setSourceRegion(new Rectangle(x,y,1,1));
  TIFF tiff=getImage(band);
  try {
    int img=tiff.getReader().read(0,t).getRaster().getSample(x,y,1);
    int real=tiff.getReader().read(0,t).getRaster().getSample(x,y,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return -1;
}","@Override public int readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int img=tiff.getReader().read(0,t).getRaster().getSample(0,0,1);
    int real=tiff.getReader().read(0,t).getRaster().getSample(0,0,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return -1;
}",0.9157345264727816
175160,"@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(bounds);
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] | rect.y + rect.height != preloadedInterval[1]) {
    preloadLineTile(rect.y,rect.height,band);
  }
  int yOffset=getImage(band).xSize;
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  for (int i=0; i < rect.height; i++) {
    for (int j=0; j < rect.width; j++) {
      int temp=i * yOffset + j + rect.x;
      long real=preloadedDataReal[temp];
      long img=preloadedDataImg[temp];
      tile[(i + yinit) * width + j + xinit]=(int)Math.sqrt(real * real + img * img);
    }
  }
  return tile;
}","@Override public int[] readTile(int x,int y,int width,int height,int band){
  Rectangle rect=new Rectangle(x,y,width,height);
  rect=rect.intersection(bounds);
  int[] tile=new int[height * width];
  if (rect.isEmpty()) {
    return tile;
  }
  if (rect.y != preloadedInterval[0] | rect.y + rect.height != preloadedInterval[1]) {
    preloadLineTile(rect.y,rect.height,band);
  }
  int yOffset=getImage(band).xSize;
  int xinit=rect.x - x;
  int yinit=rect.y - y;
  int temp=0;
  try {
    for (int i=0; i < rect.height; i++) {
      for (int j=0; j < rect.width; j++) {
        temp=(i * yOffset + j + rect.x);
        long real=preloadedDataReal[temp];
        long img=preloadedDataImg[temp];
        tile[(i + yinit) * width + j + xinit]=(int)Math.sqrt(real * real + img * img);
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return tile;
}",0.9296116504854368
175161,"/** 
 */
protected void saveResults(String imageName,IMask[] masks,SarImageReader reader){
  if (layerResults != null) {
    String outfolder=new StringBuilder(params.outputFolder).append(File.separator).append(imageName).toString();
    File folder=new File(outfolder);
    if (!folder.exists())     folder.mkdirs();
    File xmlOutFolder=null;
    xmlOutFolder=new File(params.xmlOutputFolder);
    if (!xmlOutFolder.exists())     xmlOutFolder.mkdirs();
    for (    ComplexEditVDSVectorLayer l : layerResults) {
      StringBuilder outfileName=new StringBuilder(outfolder).append(File.separator).append(reader.getImId()).append(""String_Node_Str"");
      if (l.getBand().equalsIgnoreCase(""String_Node_Str"")) {
        outfileName.append(l.getBand());
      }
 else {
        outfileName.append(reader.getBandName(Integer.valueOf(l.getBand())));
      }
      if (reader.isContainsMultipleImage() && reader instanceof CosmoSkymedImage) {
        outfileName=outfileName.append(""String_Node_Str"").append(((CosmoSkymedImage)reader).getGroup());
      }
      l.save(outfileName.toString() + ""String_Node_Str"",ComplexEditVDSVectorLayer.OPT_EXPORT_XML_SUMO_OLD,params.epsg);
      File outFile=new File(outfileName.toString() + ""String_Node_Str"");
      SumoXMLWriter.saveNewXML(outFile,l,params.epsg,reader,params.thresholdArrayValues,params.buffer,params.enl,params.shapeFile,runVersion,runVersionNumber);
      try {
        if (layerResults.size() == 1 || l.getBand().equals(""String_Node_Str"")) {
          FileUtils.copyFile(outFile,new File(params.xmlOutputFolder + ""String_Node_Str"" + reader.getImId()+ ""String_Node_Str""));
        }
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
      }
      try {
        String bbox=outfolder + ""String_Node_Str"";
        List<Geometry> ggBbox=new ArrayList<Geometry>();
        try {
          ggBbox.add(reader.getBbox(PlatformConfiguration.getConfigurationInstance().getLandMaskMargin(0)));
          SimpleShapefile.exportGeometriesToShapeFile(ggBbox,new File(bbox),""String_Node_Str"",null,null,null);
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"" + e.getLocalizedMessage(),e);
        }
        String bboxcsv=params.outputFolder + ""String_Node_Str"";
        GenericCSVIO.geomCsv(new File(bboxcsv),ggBbox,null,imageName,true);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + imageName,e);
      }
      try {
        String targets=outfileName.append(""String_Node_Str"").toString();
        SimpleShapefile.exportGeometriesToShapeFile(l.getGeometriclayer().getGeometries(),new File(targets),""String_Node_Str"",reader.getGeoTransform(),null,null);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + e.getLocalizedMessage(),e);
      }
      if (l.getBand().equals(""String_Node_Str"") || layerResults.size() == 1) {
        try {
          String targetscsv=params.outputFolder + ""String_Node_Str"";
          List<Geometry> targets=new ArrayList<Geometry>(l.getGeometriclayer().getGeometries());
          List<Geometry> ambi=new ArrayList<>();
          if (l.getGeometriesByTag(ComplexEditVDSVectorLayer.AZIMUTH_AMBIGUITY_TAG) != null)           ambi.addAll(l.getGeometriesByTag(ComplexEditVDSVectorLayer.AZIMUTH_AMBIGUITY_TAG).getGeometries());
          if (l.getGeometriesByTag(ComplexEditVDSVectorLayer.ARTEFACTS_AMBIGUITY_TAG) != null)           ambi.addAll(l.getGeometriesByTag(ComplexEditVDSVectorLayer.ARTEFACTS_AMBIGUITY_TAG).getGeometries());
          if (!ambi.isEmpty()) {
            for (            Geometry geom : targets) {
              if (ambi.contains(geom)) {
                targets.remove(geom);
              }
            }
          }
          GenericCSVIO.geomCsv(new File(targetscsv),targets,null,imageName,true);
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"" + imageName,e);
        }
      }
    }
    try {
      String bbox=outfolder + ""String_Node_Str"";
      List<Geometry> ggBbox=new ArrayList<Geometry>();
      try {
        ggBbox.add(reader.getBbox(PlatformConfiguration.getConfigurationInstance().getLandMaskMargin(0)));
        SimpleShapefile.exportGeometriesToShapeFile(ggBbox,new File(bbox),""String_Node_Str"",null,null,null);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + e.getLocalizedMessage(),e);
      }
      String bboxcsv=params.outputFolder + ""String_Node_Str"";
      GenericCSVIO.geomCsv(new File(bboxcsv),ggBbox,null,imageName,true);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"" + imageName,e);
    }
  }
}","/** 
 */
protected void saveResults(String imageName,IMask[] masks,SarImageReader reader){
  if (layerResults != null) {
    String outfolder=new StringBuilder(params.outputFolder).append(File.separator).append(imageName).toString();
    File folder=new File(outfolder);
    if (!folder.exists())     folder.mkdirs();
    File xmlOutFolder=null;
    xmlOutFolder=new File(params.xmlOutputFolder);
    if (!xmlOutFolder.exists())     xmlOutFolder.mkdirs();
    for (    ComplexEditVDSVectorLayer l : layerResults) {
      StringBuilder outfileName=new StringBuilder(outfolder).append(File.separator).append(reader.getImId()).append(""String_Node_Str"");
      if (l.getBand().equalsIgnoreCase(""String_Node_Str"")) {
        outfileName.append(l.getBand());
      }
 else {
        outfileName.append(reader.getBandName(Integer.valueOf(l.getBand())));
      }
      if (reader.isContainsMultipleImage() && reader instanceof CosmoSkymedImage) {
        outfileName=outfileName.append(""String_Node_Str"").append(((CosmoSkymedImage)reader).getGroup());
      }
      l.save(outfileName.toString() + ""String_Node_Str"",ComplexEditVDSVectorLayer.OPT_EXPORT_XML_SUMO_OLD,params.epsg);
      File outFile=new File(outfileName.toString() + ""String_Node_Str"");
      SumoXMLWriter.saveNewXML(outFile,l,params.epsg,reader,params.thresholdArrayValues,params.buffer,params.enl,params.shapeFile,runVersion,runVersionNumber);
      try {
        if (layerResults.size() == 1 || l.getBand().equals(""String_Node_Str"")) {
          FileUtils.copyFile(outFile,new File(params.xmlOutputFolder + ""String_Node_Str"" + reader.getImId()+ ""String_Node_Str""));
        }
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
      }
      try {
        String bbox=outfolder + ""String_Node_Str"";
        List<Geometry> ggBbox=new ArrayList<Geometry>();
        try {
          ggBbox.add(reader.getBbox(PlatformConfiguration.getConfigurationInstance().getLandMaskMargin(0)));
          SimpleShapefile.exportGeometriesToShapeFile(ggBbox,new File(bbox),""String_Node_Str"",reader.getGeoTransform(),null,null);
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"" + e.getLocalizedMessage(),e);
        }
        String bboxcsv=params.outputFolder + ""String_Node_Str"";
        GenericCSVIO.geomCsv(new File(bboxcsv),ggBbox,null,imageName,true);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + imageName,e);
      }
      try {
        String targets=outfileName.append(""String_Node_Str"").toString();
        SimpleShapefile.exportGeometriesToShapeFile(l.getGeometriclayer().getGeometries(),new File(targets),""String_Node_Str"",reader.getGeoTransform(),null,null);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + e.getLocalizedMessage(),e);
      }
      if (l.getBand().equals(""String_Node_Str"") || layerResults.size() == 1) {
        try {
          String targetscsv=params.outputFolder + ""String_Node_Str"";
          List<Geometry> targets=new ArrayList<Geometry>(l.getGeometriclayer().getGeometries());
          List<Geometry> ambi=new ArrayList<>();
          if (l.getGeometriesByTag(ComplexEditVDSVectorLayer.AZIMUTH_AMBIGUITY_TAG) != null)           ambi.addAll(l.getGeometriesByTag(ComplexEditVDSVectorLayer.AZIMUTH_AMBIGUITY_TAG).getGeometries());
          if (l.getGeometriesByTag(ComplexEditVDSVectorLayer.ARTEFACTS_AMBIGUITY_TAG) != null)           ambi.addAll(l.getGeometriesByTag(ComplexEditVDSVectorLayer.ARTEFACTS_AMBIGUITY_TAG).getGeometries());
          List<Geometry> toRemove=new ArrayList<>();
          if (!ambi.isEmpty()) {
            for (            Geometry geom : targets) {
              if (ambi.contains(geom)) {
                toRemove.add(geom);
              }
            }
          }
          targets.removeAll(toRemove);
          GenericCSVIO.geomCsv(new File(targetscsv),targets,reader.getGeoTransform(),imageName,true);
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"" + imageName,e);
        }
      }
    }
    try {
      String bbox=outfolder + ""String_Node_Str"";
      List<Geometry> ggBbox=new ArrayList<Geometry>();
      try {
        ggBbox.add(reader.getBbox(PlatformConfiguration.getConfigurationInstance().getLandMaskMargin(0)));
        SimpleShapefile.exportGeometriesToShapeFile(ggBbox,new File(bbox),""String_Node_Str"",null,null,null);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + e.getLocalizedMessage(),e);
      }
      String bboxcsv=params.outputFolder + ""String_Node_Str"";
      GenericCSVIO.geomCsv(new File(bboxcsv),ggBbox,null,imageName,true);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"" + imageName,e);
    }
  }
}",0.98272921108742
175162,"/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP,gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=gf.createGeometry((Geometry)o[i][0]);
            if (applayTransformation && transform != null)             g=transform.transformGeometryPixelFromGeo(g);
            out.put(g,(AttributesGeometry)o[i][1]);
            System.out.println(g.toText());
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}","/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP,gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=gf.createGeometry((Geometry)o[i][0]);
            if (applayTransformation && transform != null)             g=transform.transformGeometryPixelFromGeo(g);
            if (!g.isValid()) {
              if (!g.isSimple()) {
                Geometry b0=g.buffer(0);
                Coordinate[] cc=g.getCoordinates();
                CoordinateList cl=new CoordinateList();
                cl.add(cc,false);
                for (int ii=0; ii < cl.size(); ii++) {
                  if (b0.contains(gf.createPoint(cl.getCoordinate(ii))) || b0.touches(gf.createPoint(cl.getCoordinate(ii)))) {
                    cl.remove(ii);
                  }
                }
                Geometry newGeom=gf.createPolygon(cl.toCoordinateArray());
                g=newGeom.buffer(0);
              }
            }
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}",0.9227846686780646
175163,"/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP,gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=gf.createGeometry((Geometry)o[i][0]);
            if (applayTransformation && transform != null)             g=transform.transformGeometryPixelFromGeo(g);
            if (!g.isValid()) {
              if (!g.isSimple()) {
                Geometry b0=g.buffer(0);
                Coordinate[] cc=g.getCoordinates();
                CoordinateList cl=new CoordinateList();
                cl.add(cc,false);
                for (int ii=0; ii < cl.size(); ii++) {
                  if (b0.contains(gf.createPoint(cl.getCoordinate(ii))) || b0.touches(gf.createPoint(cl.getCoordinate(ii)))) {
                    cl.remove(ii);
                  }
                }
                Geometry newGeom=gf.createPolygon(cl.toCoordinateArray());
                g=newGeom.buffer(0);
              }
            }
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}","/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  GeometryFactory gf=new GeometryFactory();
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                if (f.getProperty(schema[i]).getValue() != null)                 at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              g=PolygonOp.removeInteriorRing(g);
              Geometry gbuff=g.buffer(0);
              if (imageP.contains(gbuff)) {
                Object[] o=new Object[2];
                o[0]=gbuff;
                o[1]=at;
                result.add(o);
              }
 else               if (imageP.intersects(gbuff)) {
                Geometry p2=EnhancedPrecisionOp.intersection(imageP,gbuff);
                p2=p2.buffer(0);
                if (!p2.isEmpty()) {
                  for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                    Object[] o=new Object[2];
                    o[0]=p2.getGeometryN(ii);
                    o[1]=at;
                    result.add(o);
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=gf.createGeometry((Geometry)o[i][0]);
            if (applayTransformation && transform != null)             g=transform.transformGeometryPixelFromGeo(g);
            if (!g.isValid()) {
              Geometry b0=g.buffer(0);
              if (!g.isSimple() && (b0.getArea() / g.getArea()) < 0.75) {
                Coordinate[] cc=g.getCoordinates();
                CoordinateList cl=new CoordinateList();
                cl.add(cc,false);
                for (int ii=0; ii < cl.size(); ii++) {
                  if (b0.contains(gf.createPoint(cl.getCoordinate(ii))) || b0.touches(gf.createPoint(cl.getCoordinate(ii)))) {
                    cl.remove(ii);
                  }
                }
                cl.closeRing();
                Geometry newGeom=gf.createPolygon(cl.toCoordinateArray());
                g=newGeom.buffer(0);
              }
 else {
                g=b0;
              }
            }
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}",0.9804489500362056
175164,"public AttributesGeometry(String[] attributesSchema){
  this.schema=attributesSchema;
  attributes=new HashMap<String,Object>();
  types=new HashMap<String,Class>();
  types.put(""String_Node_Str"",Integer.class);
}","public AttributesGeometry(String[] attributesSchema,Class[] typesAttr){
  this.schema=attributesSchema;
  attributes=new HashMap<String,Object>();
  types=new HashMap<String,Class>();
  for (int i=0; i < attributesSchema.length; i++) {
    types.put(attributesSchema[i],typesAttr[i]);
  }
}",0.679920477137177
175165,"/** 
 * @param source
 * @return
 */
public AttributesGeometry emptyCloneAttributes(){
  AttributesGeometry out=new AttributesGeometry(getSchema());
  for (int i=0; i < schema.length; i++) {
    if (getValues() != null) {
      out.attributes.put(schema[i],null);
      out.types.put(schema[i],get(schema[i]).getClass());
    }
  }
  return out;
}","/** 
 * @param source
 * @return
 */
public AttributesGeometry emptyCloneAttributes(){
  AttributesGeometry out=new AttributesGeometry(getSchema());
  for (int i=0; i < schema.length; i++) {
    if (getValues() != null) {
      out.attributes.put(schema[i],null);
      if (get(schema[i]) != null)       out.types.put(schema[i],get(schema[i]).getClass());
    }
  }
  return out;
}",0.9532967032967034
175166,"protected void performAdd(java.awt.Point imagePosition,OpenGLContext context){
  if (type.equals(GeometricLayer.POINT)) {
    selectedGeometry=gf.createPoint(new Coordinate(imagePosition.x,imagePosition.y));
    int size=glayer.getGeometries().size();
    Integer maxVal=0;
    for (int i=0; i < size; i++) {
      Integer val=(Integer)((AttributesGeometry)glayer.getGeometries().get(i).getUserData()).get(VDSSchema.ID);
      if (val > maxVal)       maxVal=val;
    }
    maxVal++;
    AttributesGeometry source=(AttributesGeometry)glayer.getGeometries().get(0).getUserData();
    AttributesGeometry atts=source.emptyCloneAttributes();
    atts.set(VDSSchema.ID,maxVal);
    final AttributesEditor ae=new AttributesEditor(new java.awt.Frame(),true);
    ae.setAttributes(atts);
    ae.setVisible(true);
    HashMap<String,Object> newMapVals=ae.getAttributesValues();
    atts=setNewAttributeValues(atts,newMapVals);
    glayer.put(selectedGeometry,atts);
    ae.addWindowListener(new WindowAdapter(){
      public void windowClosed(      WindowEvent e){
        try {
        }
 catch (        Throwable t) {
          t.printStackTrace();
        }
      }
    }
);
  }
}","protected void performAdd(java.awt.Point imagePosition,OpenGLContext context){
  if (type.equals(GeometricLayer.POINT)) {
    selectedGeometry=gf.createPoint(new Coordinate(imagePosition.x,imagePosition.y));
    int size=glayer.getGeometries().size();
    Integer maxVal=0;
    for (int i=0; i < size; i++) {
      Integer val=(Integer)((AttributesGeometry)glayer.getGeometries().get(i).getUserData()).get(VDSSchema.ID);
      if (val > maxVal)       maxVal=val;
    }
    maxVal++;
    AttributesGeometry atts=null;
    atts=new AttributesGeometry(VDSSchema.schema,VDSSchema.types);
    atts.set(VDSSchema.ID,maxVal);
    final AttributesEditor ae=new AttributesEditor(new java.awt.Frame(),true);
    ae.setAttributes(atts);
    ae.setVisible(true);
    HashMap<String,Object> newMapVals=ae.getAttributesValues();
    atts=setNewAttributeValues(atts,newMapVals);
    glayer.put(selectedGeometry,atts);
    ae.addWindowListener(new WindowAdapter(){
      public void windowClosed(      WindowEvent e){
        try {
        }
 catch (        Throwable t) {
          t.printStackTrace();
        }
      }
    }
);
  }
}",0.9297863061491496
175167,"protected AttributesGeometry setNewAttributeValues(AttributesGeometry attr,HashMap<String,Object> map){
  Collection<String> keys=map.keySet();
  SimpleDateFormat df=new SimpleDateFormat(""String_Node_Str"");
  for (int i=0; i < keys.size(); i++) {
    String att=attr.getSchema()[i];
    Class<?> type=attr.getType(attr.getSchema()[i]);
    String val=((String)map.get(att));
    if (val != null && !""String_Node_Str"".equals(val)) {
      try {
        if (type == Double.class) {
          attr.set(att,Double.parseDouble(val));
        }
 else         if (type == String.class) {
          attr.set(att,val);
        }
 else         if (type == Date.class) {
          attr.set(att,df.parse(val));
        }
 else         if (type == Timestamp.class) {
          Date d=df.parse(val);
          attr.set(att,new Timestamp(d.getTime()));
        }
 else         if (type == Integer.class) {
          attr.set(att,Integer.parseInt(val));
        }
 else         if (type == Boolean.class) {
          attr.set(att,Boolean.parseBoolean(val));
        }
 else         if (type.isArray()) {
          int bb=Integer.parseInt(band);
          if (type == int[].class) {
            int[] a=new int[4];
            int id=PlatformConfiguration.getConfigurationInstance().getIdPolarization(SumoPlatform.getApplication().getCurrentImageReader().getBandName(bb));
            a[id]=Integer.parseInt(val);
            attr.set(att,a);
          }
          if (type == double[].class) {
            double[] a=new double[4];
            int id=PlatformConfiguration.getConfigurationInstance().getIdPolarization(SumoPlatform.getApplication().getCurrentImageReader().getBandName(bb));
            a[id]=Double.parseDouble(val);
            attr.set(att,a);
          }
        }
 else {
          attr.set(att,val);
        }
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + att,e.getMessage());
      }
    }
  }
  return attr;
}","protected AttributesGeometry setNewAttributeValues(AttributesGeometry attr,HashMap<String,Object> map){
  Collection<String> keys=map.keySet();
  SimpleDateFormat df=new SimpleDateFormat(""String_Node_Str"");
  for (int i=0; i < keys.size(); i++) {
    String att=attr.getSchema()[i];
    Class<?> type=attr.getType(attr.getSchema()[i]);
    String val=((String)map.get(att));
    if (val != null && !""String_Node_Str"".equals(val)) {
      try {
        if (type == Double.class) {
          attr.set(att,Double.parseDouble(val));
        }
 else         if (type == String.class) {
          attr.set(att,val);
        }
 else         if (type == Date.class) {
          attr.set(att,df.parse(val));
        }
 else         if (type == Timestamp.class) {
          Date d=df.parse(val);
          attr.set(att,new Timestamp(d.getTime()));
        }
 else         if (type == Integer.class) {
          attr.set(att,Integer.parseInt(val));
        }
 else         if (type == Boolean.class) {
          attr.set(att,Boolean.parseBoolean(val));
        }
 else         if (type.isArray()) {
          int bb=Integer.parseInt(band);
          if (type == int[].class || type == Integer[].class) {
            int[] a=new int[4];
            int id=PlatformConfiguration.getConfigurationInstance().getIdPolarization(SumoPlatform.getApplication().getCurrentImageReader().getBandName(bb));
            a[id]=Integer.parseInt(val);
            attr.set(att,a);
          }
          if (type == double[].class || type == Double[].class) {
            double[] a=new double[4];
            int id=PlatformConfiguration.getConfigurationInstance().getIdPolarization(SumoPlatform.getApplication().getCurrentImageReader().getBandName(bb));
            a[id]=Double.parseDouble(val);
            attr.set(att,a);
          }
        }
 else {
          attr.set(att,val);
        }
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + att,e.getMessage());
      }
    }
  }
  return attr;
}",0.9865788807292986
175168,"@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,getImage(band).xSize,length);
  TIFFImageReadParam tirp=new TIFFImageReadParam();
  tirp.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    preloadedDataReal=tiff.getReader().read(0,tirp).getRaster().getSamples(0,0,getImage(band).xSize,length,0,(int[])null);
    preloadedDataImg=tiff.getReader().read(0,tirp).getRaster().getSamples(0,0,getImage(band).xSize,length,1,(int[])null);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
}","@Override public void preloadLineTile(int y,int length,int band){
  if (y < 0) {
    return;
  }
  preloadedInterval=new int[]{y,y + length};
  Rectangle rect=new Rectangle(0,y,getImage(band).xSize,length);
  TIFFImageReadParam tirp=new TIFFImageReadParam();
  tirp.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    preloadedDataReal=tiff.getReader().read(0,tirp).getRaster().getSamples(0,0,rect.width,rect.height,0,(int[])null);
    preloadedDataImg=tiff.getReader().read(0,tirp).getRaster().getSamples(0,0,rect.width,rect.height,1,(int[])null);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
}",0.9231974921630094
175169,"@Override public int readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int img=tiff.getReader().read(0,t).getRaster().getSample(0,0,1);
    int real=tiff.getReader().read(0,t).getRaster().getSample(0,0,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return -1;
}","@Override public int readPixel(int x,int y,int band){
  TIFFImageReadParam t=new TIFFImageReadParam();
  Rectangle rect=new Rectangle(x,y,1,1);
  rect=rect.intersection(bounds);
  t.setSourceRegion(rect);
  TIFF tiff=getImage(band);
  try {
    int img=tiff.getReader().readRaster(0,t).getSample(0,0,1);
    int real=tiff.getReader().read(0,t).getRaster().getSample(0,0,0);
    return (int)Math.sqrt(real * real + img * img);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  ArrayIndexOutOfBoundsException ex) {
    logger.warn(ex.getMessage());
    ex.printStackTrace();
  }
catch (  IllegalArgumentException iae) {
    logger.warn(iae.getMessage());
  }
 finally {
  }
  return -1;
}",0.9689703808180536
175170,"@Override public Geometry transformGeometryGeoFromPixel(Geometry geom) throws GeoTransformException {
  try {
    Coordinate[] coords=geom.getCoordinates();
    List<double[]> coordsConv=pGeo.parallelGeoFromPixel(coords);
    for (int i=0; i < coords.length; i++) {
      coords[i].x=coordsConv.get(i)[0];
      coords[i].y=coordsConv.get(i)[1];
    }
    return geom;
  }
 catch (  InterruptedException|ExecutionException ge) {
    throw new GeoTransformException(ge.getMessage());
  }
}","@Override public Geometry transformGeometryGeoFromPixel(final Geometry geom) throws GeoTransformException {
  try {
    Coordinate[] coords=geom.getCoordinates();
    List<double[]> coordsConv=pGeo.parallelGeoFromPixel(coords);
    for (int i=0; i < coords.length; i++) {
      coords[i].x=coordsConv.get(i)[0];
      coords[i].y=coordsConv.get(i)[1];
    }
    return geom;
  }
 catch (  InterruptedException|ExecutionException ge) {
    throw new GeoTransformException(ge.getMessage());
  }
}",0.9938900203665988
175171,"/** 
 * @param args
 */
private void addShapeFile(String[] args){
  File file=null;
  if (args.length >= 2) {
    file=new File(args[2].split(""String_Node_Str"")[1].replace(""String_Node_Str"",""String_Node_Str""));
  }
 else {
    file=selectFile();
  }
  ImageLayer imgLayer=LayerManager.getIstanceManager().getCurrentImageLayer();
  if (imgLayer != null) {
    try {
      Polygon imageP=((SarImageReader)imgLayer.getImageReader()).getBbox(PlatformConfiguration.getConfigurationInstance().getLandMaskMargin(0));
      GeometricLayer gl=SimpleShapefile.createIntersectedLayer(file,imageP,((SarImageReader)imgLayer.getImageReader()).getGeoTransform());
      if (args.length == 3) {
        if (gl != null) {
          gl.setName(args[3]);
        }
      }
      done=LayerManager.addLayerInThread(FactoryLayer.TYPE_NON_COMPLEX,gl,imgLayer);
    }
 catch (    Exception ex) {
      logger.error(ex.getMessage(),ex);
    }
  }
}","/** 
 * @param args
 */
private void addShapeFile(String[] args){
  File file=null;
  if (args.length >= 2) {
    file=new File(args[2].split(""String_Node_Str"")[1].replace(""String_Node_Str"",""String_Node_Str""));
  }
 else {
    file=selectFile();
  }
  ImageLayer imgLayer=LayerManager.getIstanceManager().getCurrentImageLayer();
  if (imgLayer != null) {
    try {
      Polygon imageP=((SarImageReader)imgLayer.getImageReader()).getBbox(PlatformConfiguration.getConfigurationInstance().getLandMaskMargin(0));
      long start=System.currentTimeMillis();
      GeometricLayer gl=SimpleShapefile.createIntersectedLayer(file,imageP,((SarImageReader)imgLayer.getImageReader()).getGeoTransform());
      long end=System.currentTimeMillis();
      System.out.println(""String_Node_Str"" + (end - start));
      if (args.length == 3) {
        if (gl != null) {
          gl.setName(args[3]);
        }
      }
      done=LayerManager.addLayerInThread(FactoryLayer.TYPE_NON_COMPLEX,gl,imgLayer);
    }
 catch (    Exception ex) {
      logger.error(ex.getMessage(),ex);
    }
  }
}",0.9253880821231848
175172,"@Override public boolean execute(String[] args){
  if (args.length >= 1) {
    if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      FileWriter fw=null;
      BufferedWriter bw=null;
      try {
        GeoImageReader reader=SumoPlatform.getApplication().getCurrentImageReader();
        File f=new File(reader.getFilesList()[0]);
        fw=new FileWriter(f.getParent() + ""String_Node_Str"");
        bw=new BufferedWriter(fw);
        MaskVectorLayer mask=LayerManager.getIstanceManager().getChildMaskLayer(LayerManager.getIstanceManager().getCurrentImageLayer());
        List<Geometry> geoms=mask.getGeometries();
        for (int i=0; i < geoms.size(); i++) {
          Geometry g=geoms.get(i);
          if (!g.isValid()) {
            System.out.println(""String_Node_Str"");
            fw.write(g.toText() + '\n');
            System.out.println(""String_Node_Str"" + g.isValid());
          }
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
 finally {
        try {
          bw.close();
          fw.close();
        }
 catch (        Exception e) {
        }
      }
    }
 else {
      Integer bufferSize=Integer.parseInt(args[0]);
      MaskVectorLayer mask=LayerManager.getIstanceManager().getChildMaskLayer(LayerManager.getIstanceManager().getCurrentImageLayer());
      final IMask[] bufferedMask=new IMask[1];
      bufferedMask[0]=FactoryLayer.createMaskLayer(""String_Node_Str"" + bufferSize,mask.getType(),bufferSize,((MaskVectorLayer)mask).getGeometriclayer());
      LayerManager.getIstanceManager().addLayer(bufferedMask[0]);
    }
  }
  return true;
}","@Override public boolean execute(String[] args){
  if (args.length >= 1) {
    final GeoImageReader reader=SumoPlatform.getApplication().getCurrentImageReader();
    if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      FileWriter fw=null;
      BufferedWriter bw=null;
      try {
        File f=new File(reader.getFilesList()[0]);
        fw=new FileWriter(f.getParent() + ""String_Node_Str"");
        bw=new BufferedWriter(fw);
        MaskVectorLayer mask=LayerManager.getIstanceManager().getChildMaskLayer(LayerManager.getIstanceManager().getCurrentImageLayer());
        List<Geometry> geoms=mask.getGeometries();
        for (int i=0; i < geoms.size(); i++) {
          Geometry g=geoms.get(i);
          if (!g.isValid()) {
            System.out.println(""String_Node_Str"");
            Geometry geo=reader.getGeoTransform().transformGeometryGeoFromPixel(g);
            fw.write(g.toText() + '\n');
            fw.write('\n');
          }
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
 finally {
        try {
          bw.close();
          fw.close();
        }
 catch (        Exception e) {
        }
      }
    }
    if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      String fname=""String_Node_Str"";
      GeometricLayer shpLayer=null;
      try {
        shpLayer=SimpleShapefile.createIntersectedLayer(new File(fname),((SarImageReader)reader).getBbox(100),reader.getGeoTransform());
        final List<Geometry> geoms=shpLayer.getGeometries();
        Thread check=new Thread(){
          public void run(){
            try {
              for (int i=0; i < geoms.size(); i++) {
                Geometry g=reader.getGeoTransform().transformGeometryPixelFromGeo(geoms.get(i));
                if (!g.isValid()) {
                  System.out.println(""String_Node_Str"");
                  Geometry simplify=TopologyPreservingSimplifier.simplify(geoms.get(i),0.003);
                  simplify=reader.getGeoTransform().transformGeometryPixelFromGeo(geoms.get(i));
                  System.out.println(""String_Node_Str"" + simplify.isValid());
                  if (!simplify.isValid()) {
                    simplify=TopologyPreservingSimplifier.simplify(geoms.get(i),0.005);
                    simplify=reader.getGeoTransform().transformGeometryPixelFromGeo(geoms.get(i));
                    System.out.println(""String_Node_Str"" + simplify.isValid());
                  }
                }
              }
            }
 catch (            Exception e) {
              e.printStackTrace();
            }
          }
        }
;
        check.start();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
 else {
      Integer bufferSize=Integer.parseInt(args[0]);
      MaskVectorLayer mask=LayerManager.getIstanceManager().getChildMaskLayer(LayerManager.getIstanceManager().getCurrentImageLayer());
      final IMask[] bufferedMask=new IMask[1];
      bufferedMask[0]=FactoryLayer.createMaskLayer(""String_Node_Str"" + bufferSize,mask.getType(),bufferSize,((MaskVectorLayer)mask).getGeometriclayer());
      LayerManager.getIstanceManager().addLayer(bufferedMask[0]);
    }
  }
  return true;
}",0.5954070981210856
175173,"/** 
 * @param shpInput
 * @param bbox
 * @param transform
 * @return
 */
public static GeometricLayer createIntersectedLayer(File shpInput,Polygon bbox,GeoTransform transform){
  GeometricLayer glout=null;
  DataStore dataStore=null;
  try {
    if (shpInput != null) {
      Map<String,Serializable> params=new HashMap<String,Serializable>();
      params.put(""String_Node_Str"",shpInput.toURI().toURL());
      dataStore=DataStoreFinder.getDataStore(params);
      SimpleFeatureSource featureSource=(SimpleFeatureSource)dataStore.getFeatureSource(dataStore.getTypeNames()[0]);
      Polygon imageP=bbox;
      ClipProcess clip=new ClipProcess();
      SimpleFeatureCollection fc=clip.execute(featureSource.getFeatures(),imageP,true);
      if (fc.isEmpty()) {
        return null;
      }
      String[] schema=createSchema(fc.getSchema().getDescriptors());
      String[] types=createTypes(fc.getSchema().getDescriptors());
      String geoName=fc.getSchema().getGeometryDescriptor().getType().getName().toString();
      GeometricLayer out=GeometricLayer.createFromSimpleGeometry(imageP,geoName,fc,schema,types);
      out.setName(shpInput.getName());
      glout=GeometricLayer.createImageProjectedLayer(out,transform,null);
    }
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
    if (dataStore != null)     dataStore.dispose();
  }
  return glout;
}","/** 
 * @param shpInput
 * @param bbox
 * @param transform
 * @return
 */
public static GeometricLayer createIntersectedLayer(File shpInput,Polygon bbox,GeoTransform transform){
  GeometricLayer glout=null;
  DataStore dataStore=null;
  try {
    if (shpInput != null) {
      Map<String,Serializable> params=new HashMap<String,Serializable>();
      params.put(""String_Node_Str"",shpInput.toURI().toURL());
      dataStore=DataStoreFinder.getDataStore(params);
      SimpleFeatureSource featureSource=(SimpleFeatureSource)dataStore.getFeatureSource(dataStore.getTypeNames()[0]);
      Polygon imageP=bbox;
      ClipProcess clip=new ClipProcess();
      SimpleFeatureCollection fc=clip.execute(featureSource.getFeatures(),imageP,true);
      if (fc.isEmpty()) {
        return null;
      }
      String[] schema=createSchema(fc.getSchema().getDescriptors());
      String[] types=createTypes(fc.getSchema().getDescriptors());
      String geoName=fc.getSchema().getGeometryDescriptor().getType().getName().toString();
      boolean applayT=false;
      if (transform != null)       applayT=true;
      glout=GeometricLayer.createFromSimpleGeometry(imageP,geoName,fc,schema,types,applayT,transform);
      glout.setName(shpInput.getName());
    }
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
    if (dataStore != null)     dataStore.dispose();
  }
  return glout;
}",0.9259391771019678
175174,"/** 
 * Modify the GeometricLayer so the layer coordinate system matches the image coordinate system (""pixel"" projection).
 */
public static GeometricLayer createImageProjectedLayer(GeometricLayer oldPositions,AffineTransform geoTransform){
  GeometricLayer positions=oldPositions.clone();
  for (  Geometry geom : positions.geoms) {
    for (    Coordinate pos : geom.getCoordinates()) {
      Point2D.Double temp=new Point2D.Double();
      try {
        geoTransform.inverseTransform(new Point2D.Double(pos.x,pos.y),temp);
      }
 catch (      NoninvertibleTransformException e) {
        e.printStackTrace();
      }
      pos.x=temp.x;
      pos.y=temp.y;
    }
  }
  return positions;
}","/** 
 * Modify the GeometricLayer so the layer coordinate system matches the image coordinate system (""pixel"" projection).
 */
public static GeometricLayer createImageProjectedLayer(GeometricLayer layer,AffineTransform geoTransform){
  for (  Geometry geom : layer.geoms) {
    for (    Coordinate pos : geom.getCoordinates()) {
      Point2D.Double temp=new Point2D.Double();
      try {
        geoTransform.inverseTransform(new Point2D.Double(pos.x,pos.y),temp);
      }
 catch (      NoninvertibleTransformException e) {
        e.printStackTrace();
      }
      pos.x=temp.x;
      pos.y=temp.y;
    }
  }
  return layer;
}",0.9183055975794252
175175,"/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types) throws IOException {
  GeometricLayer out=null;
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              Geometry gbuff=g.buffer(0);
              for (int i=0; i < gbuff.getNumGeometries(); i++) {
                if (imageP.contains(gbuff)) {
                  Object[] o=new Object[2];
                  o[0]=gbuff;
                  o[1]=at;
                  result.add(o);
                }
 else                 if (imageP.intersects(gbuff)) {
                  Geometry p2=EnhancedPrecisionOp.intersection(imageP,gbuff);
                  p2=p2.buffer(0);
                  if (!p2.isEmpty()) {
                    for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                      Object[] o=new Object[2];
                      o[0]=p2.getGeometryN(ii);
                      o[1]=at;
                      result.add(o);
                    }
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            out.put((Geometry)o[i][0],(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          out.put(p2,at);
        }
      }
    }
  finally {
      fi.close();
    }
  }
  return out;
}","/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              Geometry gbuff=g.buffer(0);
              for (int i=0; i < gbuff.getNumGeometries(); i++) {
                if (imageP.contains(gbuff)) {
                  Object[] o=new Object[2];
                  o[0]=gbuff;
                  o[1]=at;
                  result.add(o);
                }
 else                 if (imageP.intersects(gbuff)) {
                  Geometry p2=EnhancedPrecisionOp.intersection(imageP,gbuff);
                  p2=p2.buffer(0);
                  if (!p2.isEmpty()) {
                    for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                      Object[] o=new Object[2];
                      o[0]=p2.getGeometryN(ii);
                      o[1]=at;
                      result.add(o);
                    }
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=(Geometry)o[i][0];
            if (applayTransformation && transform != null)             g=transform.transformGeometryPixelFromGeo(g);
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}",0.9414797628254704
175176,"public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=60;
    double lon=15;
    double r[];
    try {
      System.out.println(""String_Node_Str"" + GeoUtils.getGeoidH(lon,lat));
      r=gc.pixelFromGeo(lon,lat);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
      r=gc.geoFromPixel(r[1],r[0]);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
}","public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=54.81;
    double lon=-5.81;
    double p=6180.1;
    double l=13476.0;
    try {
      double r3[]=gc.geoFromPixel(l,p);
      System.out.println(""String_Node_Str"" + r3[0] + ""String_Node_Str""+ r3[1]);
      System.out.println(""String_Node_Str"" + GeoUtils.getGeoidH(r3[0],r3[1]));
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
}",0.6267664172901081
175177,"/** 
 * @see In matlab: reverse geolocation
 */
@Override public double[] pixelFromGeo(final double lon,final double lat) throws GeoLocationException {
  double[] resultReverse=new double[2];
  double[] pXYZ=GeoUtils.convertFromGeoToEarthCentred(lat,lon);
  Double dd2[]=(Double[])orbitInterpolation.getTimeStampInterp().toArray(new Double[0]);
  double[] results=findZeroDoppler(statepVecInterp,pXYZ,ArrayUtils.toPrimitive(dd2));
  double zeroDopplerTime=results[0];
  double srdist=results[1];
  double lNominatore=(zeroDopplerTime - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double lDenom=(orbitInterpolation.getZeroDopplerTimeLastRef() - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double l=(lNominatore / lDenom) * (meta.getNlines() - 1);
  if (meta.getCoordinateConversion() != null && meta.getCoordinateConversion().length > 0) {
    double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
    int index=0;
    for (    S1Metadata.CoordinateConversion cc : coordConv) {
      groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
      index++;
    }
    int idx=0;
    if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
      idx=0;
    }
 else     if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
      idx=groundToSlantRangePolyTimesSeconds.length - 2;
    }
 else {
      for (idx=groundToSlantRangePolyTimesSeconds.length - 1; idx > 0; idx--) {
        if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)         break;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length - 1) {
        idx=idx - 1;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length) {
        idx=idx - 2;
      }
    }
    double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double[] groundToSlantRangeCoefficientsInterp=new double[coordConv[idx].groundToSlantRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
      groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].groundToSlantRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].groundToSlantRangeCoefficients[idCoeff];
    }
    double[] slantToGroundRangeCoefficientsInterp=new double[coordConv[idx].slantToGroundRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
      slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].slantToGroundRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].slantToGroundRangeCoefficients[idCoeff];
    }
    double newD=0;
    double oldD=0;
    int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
    int[] numCoeffs=new int[nCoeffs];
    int[] numExps=new int[nCoeffs];
    int[] denomCoeffs=new int[nCoeffs];
    int[] denomExps=new int[nCoeffs];
    for (int i=0; i < nCoeffs; i++) {
      numCoeffs[i]=i - 1;
      numExps[i]=i;
      denomCoeffs[i]=i;
      denomExps[i]=i - 1;
    }
    denomExps[0]=0;
    double deltaD=0;
    do {
      double numCoeffsXGround=0;
      double denomCoeffsXGround=0;
      double scalNum=0;
      double scalDen=0;
      for (int i=0; i < groundToSlantRangeCoefficientsInterp.length; i++) {
        double dExp=FastMath.pow(oldD,numExps[i]);
        double denomExp=FastMath.pow(oldD,denomExps[i]);
        numCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * numCoeffs[i];
        denomCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * denomCoeffs[i];
        scalNum=scalNum + dExp * numCoeffsXGround;
        scalDen=scalDen + denomExp * denomCoeffsXGround;
      }
      double num=srdist + scalNum;
      newD=num / scalDen;
      deltaD=FastMath.abs(newD - oldD);
      oldD=newD;
    }
 while (deltaD > 1);
    double p=0;
    if (meta.isPixelTimeOrderingAscending()) {
      p=(newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
 else {
      p=meta.getNumberOfSamplesPerLine() - 1 - (newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
    resultReverse[0]=p;
    resultReverse[1]=l;
    logger.debug(""String_Node_Str"" + l + ""String_Node_Str""+ ""String_Node_Str""+ p);
  }
  return resultReverse;
}","/** 
 * @see In matlab: reverse geolocation
 * @result r[o]=p r[1]=l
 */
@Override public double[] pixelFromGeo(final double lon,final double lat) throws GeoLocationException {
  double[] resultReverse=new double[2];
  double[] pXYZ=GeoUtils.convertFromGeoToEarthCentred(lat,lon);
  Double dd2[]=(Double[])orbitInterpolation.getTimeStampInterp().toArray(new Double[0]);
  double[] results=findZeroDoppler(statepVecInterp,pXYZ,ArrayUtils.toPrimitive(dd2));
  double zeroDopplerTime=results[0];
  double srdist=results[1];
  double lNominatore=(zeroDopplerTime - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double lDenom=(orbitInterpolation.getZeroDopplerTimeLastRef() - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double l=(lNominatore / lDenom) * (meta.getNlines() - 1);
  if (meta.getCoordinateConversion() != null && meta.getCoordinateConversion().length > 0) {
    double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
    int index=0;
    for (    S1Metadata.CoordinateConversion cc : coordConv) {
      groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
      index++;
    }
    int idx=0;
    if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
      idx=0;
    }
 else     if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
      idx=groundToSlantRangePolyTimesSeconds.length - 2;
    }
 else {
      for (idx=groundToSlantRangePolyTimesSeconds.length - 1; idx > 0; idx--) {
        if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)         break;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length - 1) {
        idx=idx - 1;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length) {
        idx=idx - 2;
      }
    }
    double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double[] groundToSlantRangeCoefficientsInterp=new double[coordConv[idx].groundToSlantRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
      groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].groundToSlantRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].groundToSlantRangeCoefficients[idCoeff];
    }
    double[] slantToGroundRangeCoefficientsInterp=new double[coordConv[idx].slantToGroundRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
      slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].slantToGroundRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].slantToGroundRangeCoefficients[idCoeff];
    }
    double newD=0;
    double oldD=0;
    int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
    int[] numCoeffs=new int[nCoeffs];
    int[] numExps=new int[nCoeffs];
    int[] denomCoeffs=new int[nCoeffs];
    int[] denomExps=new int[nCoeffs];
    for (int i=0; i < nCoeffs; i++) {
      numCoeffs[i]=i - 1;
      numExps[i]=i;
      denomCoeffs[i]=i;
      denomExps[i]=i - 1;
    }
    denomExps[0]=0;
    double deltaD=0;
    do {
      double numCoeffsXGround=0;
      double denomCoeffsXGround=0;
      double scalNum=0;
      double scalDen=0;
      for (int i=0; i < groundToSlantRangeCoefficientsInterp.length; i++) {
        double dExp=FastMath.pow(oldD,numExps[i]);
        double denomExp=FastMath.pow(oldD,denomExps[i]);
        numCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * numCoeffs[i];
        denomCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * denomCoeffs[i];
        scalNum=scalNum + dExp * numCoeffsXGround;
        scalDen=scalDen + denomExp * denomCoeffsXGround;
      }
      double num=srdist + scalNum;
      newD=num / scalDen;
      deltaD=FastMath.abs(newD - oldD);
      oldD=newD;
    }
 while (deltaD > 1);
    double p=0;
    if (meta.isPixelTimeOrderingAscending()) {
      p=(newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
 else {
      p=meta.getNumberOfSamplesPerLine() - 1 - (newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
    resultReverse[0]=p;
    resultReverse[1]=l;
    logger.debug(""String_Node_Str"" + l + ""String_Node_Str""+ ""String_Node_Str""+ p);
  }
  return resultReverse;
}",0.9973299156253338
175178,"/** 
 * @see In Matlab forwardgeolocation
 */
@Override public double[] geoFromPixel(final double l,final double p) throws GeoLocationException {
  try {
    double[] results=new double[2];
    double lon=0;
    double lat=0;
    double t0=0;
    int idxStartT0=0;
    if (meta.getType().equalsIgnoreCase(""String_Node_Str"") && meta.getProductType().equalsIgnoreCase(""String_Node_Str"") && (meta.getMode().equalsIgnoreCase(""String_Node_Str"") || meta.getMode().equalsIgnoreCase(""String_Node_Str""))) {
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    }
 else {
      double t01=(orbitInterpolation.getZeroDopplerTimeFirstRef()) * (meta.getNlines() - 1 - l);
      double t02=orbitInterpolation.getZeroDopplerTimeLastRef() * l;
      t0=(t01 + t02) / (meta.getNlines() - 1);
      for (idxStartT0=0; idxStartT0 < orbitInterpolation.getTimeStampInterp().size(); idxStartT0++) {
        if (orbitInterpolation.getTimeStampInterp().get(idxStartT0) >= t0) {
          break;
        }
      }
      if (idxStartT0 == statepVecInterp.size())       idxStartT0--;
    }
    final double[] pT0=statepVecInterp.get(idxStartT0);
    final double[] vT0=statevVecInterp.get(idxStartT0);
    double distance=0;
    if (meta.isPixelTimeOrderingAscending()) {
      distance=p * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
 else {
      distance=(meta.getNumberOfSamplesPerLine() - 1 - p) * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
    if (coordConv != null) {
      double zeroDopplerTime=t0;
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
      double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
      int index=0;
      for (      S1Metadata.CoordinateConversion cc : coordConv) {
        groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
        index++;
      }
      int idx=0;
      if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
        idx=1;
      }
 else       if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
        idx=groundToSlantRangePolyTimesSeconds.length - 2;
      }
 else {
        for (idx=groundToSlantRangePolyTimesSeconds.length - 1; idx > 0; idx--) {
          if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)           break;
        }
      }
      double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double[] groundToSlantRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].groundToSlantRangeCoefficients);
      double[] groundToSlantRangeCoefficientsInterp2=coordConv[idx + 1].groundToSlantRangeCoefficients;
      for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
        groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * groundToSlantRangeCoefficientsInterp[idCoeff] + factor2 * groundToSlantRangeCoefficientsInterp2[idCoeff];
      }
      double[] slantToGroundRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].slantToGroundRangeCoefficients);
      double[] slantToGroundRangeCoefficientsInterp2=coordConv[idx + 1].slantToGroundRangeCoefficients;
      for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
        slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * slantToGroundRangeCoefficientsInterp[idCoeff] + factor2 * slantToGroundRangeCoefficientsInterp2[idCoeff];
      }
      int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
      int[] vExps=new int[nCoeffs];
      for (int i=0; i < nCoeffs; i++) {
        vExps[i]=i;
      }
      double tmpD=distance - meta.getGroundRangeOrigin();
      double[] pows=MathUtil.powValue2Coeffs(tmpD,vExps);
      double sRdist=MathUtil.dot(groundToSlantRangeCoefficientsInterp,pows);
      logger.debug(""String_Node_Str"" + sRdist);
      double normPt0=MathUtil.norm(pT0);
      double vRadial=MathUtil.dot(vT0,pT0) / normPt0;
      double vTangential=FastMath.sqrt(FastMath.pow(MathUtil.norm(vT0),2) - FastMath.pow(vRadial,2));
      double tanPsi=vRadial / vTangential;
      double[] zsUnit=MathUtil.divVectByVal(pT0,-normPt0);
      double[] vTmp=MathUtil.crossProd3x3(zsUnit,vT0);
      double[] ysUnit=MathUtil.divVectByVal(vTmp,MathUtil.norm(vTmp));
      double[] xsUnit=MathUtil.crossProd3x3(ysUnit,zsUnit);
      double pH=0;
      double rEarth=normPt0 / FastMath.sqrt((pT0[0] * pT0[0] + pT0[1] * pT0[1]) / GeoUtils.semiMajorAxis2 + (pT0[2] * pT0[2]) / GeoUtils.semiMinorAxis2);
      for (int iidx=0; iidx < 2; iidx++) {
        rEarth=rEarth + pH;
        double rEarthOld=rEarth;
        double rEarthChange=100000;
        double[] q=new double[3];
        for (; rEarthChange > 0.1; ) {
          double Rz=(normPt0 * normPt0 + sRdist * sRdist - rEarth * rEarth) / (2 * normPt0);
          double Rx=Rz * tanPsi;
          double Ry=FastMath.sqrt(sRdist * sRdist - Rz * Rz - Rx * Rx);
          if (!meta.getAntennaPointing().equalsIgnoreCase(""String_Node_Str"")) {
            Ry=-Ry;
          }
          double[][] sRvect=new double[][]{{Rx},{Ry},{Rz - normPt0}};
          double[][] qbig=new double[][]{xsUnit,ysUnit,zsUnit};
          qbig=MathUtil.transpose(qbig);
          double[][] qmat=MathUtil.multiplyMatrix(qbig,sRvect);
          q[0]=qmat[0][0];
          q[1]=qmat[1][0];
          q[2]=qmat[2][0];
          rEarth=MathUtil.norm(q) / FastMath.sqrt((q[0] * q[0] + q[1] * q[1]) / GeoUtils.semiMajorAxis2 + (q[2] * q[2] / GeoUtils.semiMinorAxis2)) + pH;
          rEarthChange=FastMath.abs(rEarth - rEarthOld);
          rEarthOld=rEarth;
        }
        lon=FastMath.atan2(q[1],q[0]) * 180 / FastMath.PI;
        double lattmp=FastMath.asin(q[2] / FastMath.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]));
        lat=FastMath.atan(FastMath.tan(lattmp) * FastMath.pow((GeoUtils.semiMajorAxis + pH),2) / FastMath.pow((GeoUtils.semiMinorAxis + pH),2)) * 180 / FastMath.PI;
        pH=GeoUtils.getGeoidH(lon,lat);
      }
    }
    logger.debug(""String_Node_Str"" + lat + ""String_Node_Str""+ lon);
    results[0]=lon;
    results[1]=lat;
    return results;
  }
 catch (  MathException me) {
    throw new GeoLocationException(GeoLocationException.MSG_CONV_FROM_PIXEL_TO_GEO + ""String_Node_Str"" + me.getMessage());
  }
}","/** 
 * @see In Matlab forwardgeolocation
 * @return   r[0]=lon r[1]=lat
 */
@Override public double[] geoFromPixel(final double l,final double p) throws GeoLocationException {
  try {
    double[] results=new double[2];
    double lon=0;
    double lat=0;
    double t0=0;
    int idxStartT0=0;
    if (meta.getType().equalsIgnoreCase(""String_Node_Str"") && meta.getProductType().equalsIgnoreCase(""String_Node_Str"") && (meta.getMode().equalsIgnoreCase(""String_Node_Str"") || meta.getMode().equalsIgnoreCase(""String_Node_Str""))) {
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    }
 else {
      double t01=(orbitInterpolation.getZeroDopplerTimeFirstRef()) * (meta.getNlines() - 1 - l);
      double t02=orbitInterpolation.getZeroDopplerTimeLastRef() * l;
      t0=(t01 + t02) / (meta.getNlines() - 1);
      for (idxStartT0=0; idxStartT0 < orbitInterpolation.getTimeStampInterp().size(); idxStartT0++) {
        if (orbitInterpolation.getTimeStampInterp().get(idxStartT0) >= t0) {
          break;
        }
      }
      if (idxStartT0 == statepVecInterp.size())       idxStartT0--;
    }
    final double[] pT0=statepVecInterp.get(idxStartT0);
    final double[] vT0=statevVecInterp.get(idxStartT0);
    double distance=0;
    if (meta.isPixelTimeOrderingAscending()) {
      distance=p * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
 else {
      distance=(meta.getNumberOfSamplesPerLine() - 1 - p) * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
    if (coordConv != null) {
      double zeroDopplerTime=t0;
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
      double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
      int index=0;
      for (      S1Metadata.CoordinateConversion cc : coordConv) {
        groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
        index++;
      }
      int idx=0;
      if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
        idx=1;
      }
 else       if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
        idx=groundToSlantRangePolyTimesSeconds.length - 2;
      }
 else {
        for (idx=groundToSlantRangePolyTimesSeconds.length - 1; idx > 0; idx--) {
          if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)           break;
        }
      }
      double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double[] groundToSlantRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].groundToSlantRangeCoefficients);
      double[] groundToSlantRangeCoefficientsInterp2=coordConv[idx + 1].groundToSlantRangeCoefficients;
      for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
        groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * groundToSlantRangeCoefficientsInterp[idCoeff] + factor2 * groundToSlantRangeCoefficientsInterp2[idCoeff];
      }
      double[] slantToGroundRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].slantToGroundRangeCoefficients);
      double[] slantToGroundRangeCoefficientsInterp2=coordConv[idx + 1].slantToGroundRangeCoefficients;
      for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
        slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * slantToGroundRangeCoefficientsInterp[idCoeff] + factor2 * slantToGroundRangeCoefficientsInterp2[idCoeff];
      }
      int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
      int[] vExps=new int[nCoeffs];
      for (int i=0; i < nCoeffs; i++) {
        vExps[i]=i;
      }
      double tmpD=distance - meta.getGroundRangeOrigin();
      double[] pows=MathUtil.powValue2Coeffs(tmpD,vExps);
      double sRdist=MathUtil.dot(groundToSlantRangeCoefficientsInterp,pows);
      logger.debug(""String_Node_Str"" + sRdist);
      double normPt0=MathUtil.norm(pT0);
      double vRadial=MathUtil.dot(vT0,pT0) / normPt0;
      double vTangential=FastMath.sqrt(FastMath.pow(MathUtil.norm(vT0),2) - FastMath.pow(vRadial,2));
      double tanPsi=vRadial / vTangential;
      double[] zsUnit=MathUtil.divVectByVal(pT0,-normPt0);
      double[] vTmp=MathUtil.crossProd3x3(zsUnit,vT0);
      double[] ysUnit=MathUtil.divVectByVal(vTmp,MathUtil.norm(vTmp));
      double[] xsUnit=MathUtil.crossProd3x3(ysUnit,zsUnit);
      double pH=0;
      double rEarth=normPt0 / FastMath.sqrt((pT0[0] * pT0[0] + pT0[1] * pT0[1]) / GeoUtils.semiMajorAxis2 + (pT0[2] * pT0[2]) / GeoUtils.semiMinorAxis2);
      for (int iidx=0; iidx < 2; iidx++) {
        rEarth=rEarth + pH;
        double rEarthOld=rEarth;
        double rEarthChange=100000;
        double[] q=new double[3];
        for (; rEarthChange > 0.1; ) {
          double Rz=(normPt0 * normPt0 + sRdist * sRdist - rEarth * rEarth) / (2 * normPt0);
          double Rx=Rz * tanPsi;
          double Ry=FastMath.sqrt(sRdist * sRdist - Rz * Rz - Rx * Rx);
          if (!meta.getAntennaPointing().equalsIgnoreCase(""String_Node_Str"")) {
            Ry=-Ry;
          }
          double[][] sRvect=new double[][]{{Rx},{Ry},{Rz - normPt0}};
          double[][] qbig=new double[][]{xsUnit,ysUnit,zsUnit};
          qbig=MathUtil.transpose(qbig);
          double[][] qmat=MathUtil.multiplyMatrix(qbig,sRvect);
          q[0]=qmat[0][0];
          q[1]=qmat[1][0];
          q[2]=qmat[2][0];
          rEarth=MathUtil.norm(q) / FastMath.sqrt((q[0] * q[0] + q[1] * q[1]) / GeoUtils.semiMajorAxis2 + (q[2] * q[2] / GeoUtils.semiMinorAxis2)) + pH;
          rEarthChange=FastMath.abs(rEarth - rEarthOld);
          rEarthOld=rEarth;
        }
        lon=FastMath.atan2(q[1],q[0]) * 180 / FastMath.PI;
        double lattmp=FastMath.asin(q[2] / FastMath.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]));
        lat=FastMath.atan(FastMath.tan(lattmp) * FastMath.pow((GeoUtils.semiMajorAxis + pH),2) / FastMath.pow((GeoUtils.semiMinorAxis + pH),2)) * 180 / FastMath.PI;
        pH=GeoUtils.getGeoidH(lon,lat);
      }
    }
    logger.debug(""String_Node_Str"" + lat + ""String_Node_Str""+ lon);
    results[0]=lon;
    results[1]=lat;
    return results;
  }
 catch (  MathException me) {
    throw new GeoLocationException(GeoLocationException.MSG_CONV_FROM_PIXEL_TO_GEO + ""String_Node_Str"" + me.getMessage());
  }
}",0.9976850123217086
175179,"@Override public Geometry transformGeometryGeoFromPixel(Geometry geom) throws GeoTransformException {
  try {
    Coordinate[] coords=geom.getCoordinates();
    List<double[]> coordsConv=pGeo.parallelGeoFromPixel(coords);
    for (int i=0; i < coords.length; i++) {
      coords[i].x=coordsConv.get(i)[0];
      coords[i].y=coordsConv.get(i)[1];
    }
    return geom;
  }
 catch (  InterruptedException|ExecutionException ge) {
    throw new GeoTransformException(ge.getMessage());
  }
}","@Override public Geometry transformGeometryGeoFromPixel(final Geometry geom) throws GeoTransformException {
  try {
    Coordinate[] coords=geom.getCoordinates();
    List<double[]> coordsConv=pGeo.parallelGeoFromPixel(coords);
    for (int i=0; i < coords.length; i++) {
      coords[i].x=coordsConv.get(i)[0];
      coords[i].y=coordsConv.get(i)[1];
    }
    return geom;
  }
 catch (  InterruptedException|ExecutionException ge) {
    throw new GeoTransformException(ge.getMessage());
  }
}",0.9938900203665988
175180,"/** 
 * @param args
 */
private void addShapeFile(String[] args){
  File file=null;
  if (args.length >= 2) {
    file=new File(args[2].split(""String_Node_Str"")[1].replace(""String_Node_Str"",""String_Node_Str""));
  }
 else {
    file=selectFile();
  }
  ImageLayer imgLayer=LayerManager.getIstanceManager().getCurrentImageLayer();
  if (imgLayer != null) {
    try {
      Polygon imageP=((SarImageReader)imgLayer.getImageReader()).getBbox(PlatformConfiguration.getConfigurationInstance().getLandMaskMargin(0));
      GeometricLayer gl=SimpleShapefile.createIntersectedLayer(file,imageP,((SarImageReader)imgLayer.getImageReader()).getGeoTransform());
      if (args.length == 3) {
        if (gl != null) {
          gl.setName(args[3]);
        }
      }
      done=LayerManager.addLayerInThread(FactoryLayer.TYPE_NON_COMPLEX,gl,imgLayer);
    }
 catch (    Exception ex) {
      logger.error(ex.getMessage(),ex);
    }
  }
}","/** 
 * @param args
 */
private void addShapeFile(String[] args){
  File file=null;
  if (args.length >= 2) {
    file=new File(args[2].split(""String_Node_Str"")[1].replace(""String_Node_Str"",""String_Node_Str""));
  }
 else {
    file=selectFile();
  }
  ImageLayer imgLayer=LayerManager.getIstanceManager().getCurrentImageLayer();
  if (imgLayer != null) {
    try {
      Polygon imageP=((SarImageReader)imgLayer.getImageReader()).getBbox(PlatformConfiguration.getConfigurationInstance().getLandMaskMargin(0));
      long start=System.currentTimeMillis();
      GeometricLayer gl=SimpleShapefile.createIntersectedLayer(file,imageP,((SarImageReader)imgLayer.getImageReader()).getGeoTransform());
      long end=System.currentTimeMillis();
      System.out.println(""String_Node_Str"" + (end - start));
      if (args.length == 3) {
        if (gl != null) {
          gl.setName(args[3]);
        }
      }
      done=LayerManager.addLayerInThread(FactoryLayer.TYPE_NON_COMPLEX,gl,imgLayer);
    }
 catch (    Exception ex) {
      logger.error(ex.getMessage(),ex);
    }
  }
}",0.9253880821231848
175181,"@Override public boolean execute(String[] args){
  if (args.length >= 1) {
    if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      FileWriter fw=null;
      BufferedWriter bw=null;
      try {
        GeoImageReader reader=SumoPlatform.getApplication().getCurrentImageReader();
        File f=new File(reader.getFilesList()[0]);
        fw=new FileWriter(f.getParent() + ""String_Node_Str"");
        bw=new BufferedWriter(fw);
        MaskVectorLayer mask=LayerManager.getIstanceManager().getChildMaskLayer(LayerManager.getIstanceManager().getCurrentImageLayer());
        List<Geometry> geoms=mask.getGeometries();
        for (int i=0; i < geoms.size(); i++) {
          Geometry g=geoms.get(i);
          if (!g.isValid()) {
            System.out.println(""String_Node_Str"");
            fw.write(g.toText() + '\n');
            System.out.println(""String_Node_Str"" + g.isValid());
          }
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
 finally {
        try {
          bw.close();
          fw.close();
        }
 catch (        Exception e) {
        }
      }
    }
 else {
      Integer bufferSize=Integer.parseInt(args[0]);
      MaskVectorLayer mask=LayerManager.getIstanceManager().getChildMaskLayer(LayerManager.getIstanceManager().getCurrentImageLayer());
      final IMask[] bufferedMask=new IMask[1];
      bufferedMask[0]=FactoryLayer.createMaskLayer(""String_Node_Str"" + bufferSize,mask.getType(),bufferSize,((MaskVectorLayer)mask).getGeometriclayer());
      LayerManager.getIstanceManager().addLayer(bufferedMask[0]);
    }
  }
  return true;
}","@Override public boolean execute(String[] args){
  if (args.length >= 1) {
    final GeoImageReader reader=SumoPlatform.getApplication().getCurrentImageReader();
    if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      FileWriter fw=null;
      BufferedWriter bw=null;
      try {
        File f=new File(reader.getFilesList()[0]);
        fw=new FileWriter(f.getParent() + ""String_Node_Str"");
        bw=new BufferedWriter(fw);
        MaskVectorLayer mask=LayerManager.getIstanceManager().getChildMaskLayer(LayerManager.getIstanceManager().getCurrentImageLayer());
        List<Geometry> geoms=mask.getGeometries();
        for (int i=0; i < geoms.size(); i++) {
          Geometry g=geoms.get(i);
          if (!g.isValid()) {
            System.out.println(""String_Node_Str"");
            Geometry geo=reader.getGeoTransform().transformGeometryGeoFromPixel(g);
            fw.write(g.toText() + '\n');
            fw.write('\n');
          }
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
 finally {
        try {
          bw.close();
          fw.close();
        }
 catch (        Exception e) {
        }
      }
    }
    if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      String fname=""String_Node_Str"";
      GeometricLayer shpLayer=null;
      try {
        shpLayer=SimpleShapefile.createIntersectedLayer(new File(fname),((SarImageReader)reader).getBbox(100),reader.getGeoTransform());
        final List<Geometry> geoms=shpLayer.getGeometries();
        Thread check=new Thread(){
          public void run(){
            try {
              for (int i=0; i < geoms.size(); i++) {
                Geometry g=reader.getGeoTransform().transformGeometryPixelFromGeo(geoms.get(i));
                if (!g.isValid()) {
                  System.out.println(""String_Node_Str"");
                  Geometry simplify=TopologyPreservingSimplifier.simplify(geoms.get(i),0.003);
                  simplify=reader.getGeoTransform().transformGeometryPixelFromGeo(geoms.get(i));
                  System.out.println(""String_Node_Str"" + simplify.isValid());
                  if (!simplify.isValid()) {
                    simplify=TopologyPreservingSimplifier.simplify(geoms.get(i),0.005);
                    simplify=reader.getGeoTransform().transformGeometryPixelFromGeo(geoms.get(i));
                    System.out.println(""String_Node_Str"" + simplify.isValid());
                  }
                }
              }
            }
 catch (            Exception e) {
              e.printStackTrace();
            }
          }
        }
;
        check.start();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
 else {
      Integer bufferSize=Integer.parseInt(args[0]);
      MaskVectorLayer mask=LayerManager.getIstanceManager().getChildMaskLayer(LayerManager.getIstanceManager().getCurrentImageLayer());
      final IMask[] bufferedMask=new IMask[1];
      bufferedMask[0]=FactoryLayer.createMaskLayer(""String_Node_Str"" + bufferSize,mask.getType(),bufferSize,((MaskVectorLayer)mask).getGeometriclayer());
      LayerManager.getIstanceManager().addLayer(bufferedMask[0]);
    }
  }
  return true;
}",0.5954070981210856
175182,"/** 
 * @param shpInput
 * @param bbox
 * @param transform
 * @return
 */
public static GeometricLayer createIntersectedLayer(File shpInput,Polygon bbox,GeoTransform transform){
  GeometricLayer glout=null;
  DataStore dataStore=null;
  try {
    if (shpInput != null) {
      Map<String,Serializable> params=new HashMap<String,Serializable>();
      params.put(""String_Node_Str"",shpInput.toURI().toURL());
      dataStore=DataStoreFinder.getDataStore(params);
      SimpleFeatureSource featureSource=(SimpleFeatureSource)dataStore.getFeatureSource(dataStore.getTypeNames()[0]);
      Polygon imageP=bbox;
      ClipProcess clip=new ClipProcess();
      SimpleFeatureCollection fc=clip.execute(featureSource.getFeatures(),imageP,true);
      if (fc.isEmpty()) {
        return null;
      }
      String[] schema=createSchema(fc.getSchema().getDescriptors());
      String[] types=createTypes(fc.getSchema().getDescriptors());
      String geoName=fc.getSchema().getGeometryDescriptor().getType().getName().toString();
      GeometricLayer out=GeometricLayer.createFromSimpleGeometry(imageP,geoName,fc,schema,types);
      out.setName(shpInput.getName());
      glout=GeometricLayer.createImageProjectedLayer(out,transform,null);
    }
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
    if (dataStore != null)     dataStore.dispose();
  }
  return glout;
}","/** 
 * @param shpInput
 * @param bbox
 * @param transform
 * @return
 */
public static GeometricLayer createIntersectedLayer(File shpInput,Polygon bbox,GeoTransform transform){
  GeometricLayer glout=null;
  DataStore dataStore=null;
  try {
    if (shpInput != null) {
      Map<String,Serializable> params=new HashMap<String,Serializable>();
      params.put(""String_Node_Str"",shpInput.toURI().toURL());
      dataStore=DataStoreFinder.getDataStore(params);
      SimpleFeatureSource featureSource=(SimpleFeatureSource)dataStore.getFeatureSource(dataStore.getTypeNames()[0]);
      Polygon imageP=bbox;
      ClipProcess clip=new ClipProcess();
      SimpleFeatureCollection fc=clip.execute(featureSource.getFeatures(),imageP,true);
      if (fc.isEmpty()) {
        return null;
      }
      String[] schema=createSchema(fc.getSchema().getDescriptors());
      String[] types=createTypes(fc.getSchema().getDescriptors());
      String geoName=fc.getSchema().getGeometryDescriptor().getType().getName().toString();
      boolean applayT=false;
      if (transform != null)       applayT=true;
      glout=GeometricLayer.createFromSimpleGeometry(imageP,geoName,fc,schema,types,applayT,transform);
      glout.setName(shpInput.getName());
    }
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
 finally {
    if (dataStore != null)     dataStore.dispose();
  }
  return glout;
}",0.9259391771019678
175183,"/** 
 * Modify the GeometricLayer so the layer coordinate system matches the image coordinate system (""pixel"" projection).
 */
public static GeometricLayer createImageProjectedLayer(GeometricLayer oldPositions,AffineTransform geoTransform){
  GeometricLayer positions=oldPositions.clone();
  for (  Geometry geom : positions.geoms) {
    for (    Coordinate pos : geom.getCoordinates()) {
      Point2D.Double temp=new Point2D.Double();
      try {
        geoTransform.inverseTransform(new Point2D.Double(pos.x,pos.y),temp);
      }
 catch (      NoninvertibleTransformException e) {
        e.printStackTrace();
      }
      pos.x=temp.x;
      pos.y=temp.y;
    }
  }
  return positions;
}","/** 
 * Modify the GeometricLayer so the layer coordinate system matches the image coordinate system (""pixel"" projection).
 */
public static GeometricLayer createImageProjectedLayer(GeometricLayer layer,AffineTransform geoTransform){
  for (  Geometry geom : layer.geoms) {
    for (    Coordinate pos : geom.getCoordinates()) {
      Point2D.Double temp=new Point2D.Double();
      try {
        geoTransform.inverseTransform(new Point2D.Double(pos.x,pos.y),temp);
      }
 catch (      NoninvertibleTransformException e) {
        e.printStackTrace();
      }
      pos.x=temp.x;
      pos.y=temp.y;
    }
  }
  return layer;
}",0.9183055975794252
175184,"/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types) throws IOException {
  GeometricLayer out=null;
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              Geometry gbuff=g.buffer(0);
              for (int i=0; i < gbuff.getNumGeometries(); i++) {
                if (imageP.contains(gbuff)) {
                  Object[] o=new Object[2];
                  o[0]=gbuff;
                  o[1]=at;
                  result.add(o);
                }
 else                 if (imageP.intersects(gbuff)) {
                  Geometry p2=EnhancedPrecisionOp.intersection(imageP,gbuff);
                  p2=p2.buffer(0);
                  if (!p2.isEmpty()) {
                    for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                      Object[] o=new Object[2];
                      o[0]=p2.getGeometryN(ii);
                      o[1]=at;
                      result.add(o);
                    }
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            out.put((Geometry)o[i][0],(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          out.put(p2,at);
        }
      }
    }
  finally {
      fi.close();
    }
  }
  return out;
}","/** 
 * @param imageP poligono creato con i punti di riferimento dell'immagine
 * @param geoName
 * @param dataStore  shape file
 * @param fc
 * @param schema
 * @param types
 * @return Polygons (geometry) that are the intersection between the shape file and the sar image
 * @throws IOException
 */
public static GeometricLayer createFromSimpleGeometry(final Polygon imageP,final String geoName,FeatureCollection fc,final String[] schema,final String[] types,boolean applayTransformation,GeoTransform transform) throws IOException {
  GeometricLayer out=null;
  if (geoName.contains(""String_Node_Str"") || geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POLYGON);
    out.setFeatureCollection(fc);
    FeatureIterator<?> fi=fc.features();
    try {
      ThreadPoolExecutor executor=new ThreadPoolExecutor(2,Runtime.getRuntime().availableProcessors(),2,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
      List<Callable<Object[][]>> tasks=new ArrayList<Callable<Object[][]>>();
      while (fi.hasNext()) {
        final Feature f=fi.next();
        Callable<Object[][]> run=new Callable<Object[][]>(){
          Geometry g=(Geometry)f.getDefaultGeometryProperty().getValue();
          @Override public Object[][] call(){
            List<Object[]> result=java.util.Collections.synchronizedList(new ArrayList<Object[]>());
            try {
              AttributesGeometry at=new AttributesGeometry(schema);
              for (int i=0; i < f.getProperties().size(); i++) {
                at.set(schema[i],f.getProperty(schema[i]).getValue());
              }
              Geometry gbuff=g.buffer(0);
              for (int i=0; i < gbuff.getNumGeometries(); i++) {
                if (imageP.contains(gbuff)) {
                  Object[] o=new Object[2];
                  o[0]=gbuff;
                  o[1]=at;
                  result.add(o);
                }
 else                 if (imageP.intersects(gbuff)) {
                  Geometry p2=EnhancedPrecisionOp.intersection(imageP,gbuff);
                  p2=p2.buffer(0);
                  if (!p2.isEmpty()) {
                    for (int ii=0; ii < p2.getNumGeometries(); ii++) {
                      Object[] o=new Object[2];
                      o[0]=p2.getGeometryN(ii);
                      o[1]=at;
                      result.add(o);
                    }
                  }
                }
              }
            }
 catch (            Exception ex) {
              logger.error(ex.getMessage(),ex);
            }
            return result.toArray(new Object[0][]);
          }
        }
;
        tasks.add(run);
      }
      List<Future<Object[][]>> results=executor.invokeAll(tasks);
      executor.shutdown();
      for (      Future<Object[][]> f : results) {
        Object o[][]=f.get();
        if (o != null) {
          for (int i=0; i < o.length; i++) {
            Geometry g=(Geometry)o[i][0];
            if (applayTransformation && transform != null)             g=transform.transformGeometryPixelFromGeo(g);
            out.put(g,(AttributesGeometry)o[i][1]);
          }
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
 else   if (geoName.contains(""String_Node_Str"")) {
    out=new GeometricLayer(GeometricLayer.POINT);
    FeatureIterator<?> fi=fc.features();
    try {
      while (fi.hasNext()) {
        Feature f=fi.next();
        AttributesGeometry at=new AttributesGeometry(schema);
        for (int i=0; i < f.getProperties().size(); i++) {
          at.set(schema[i],f.getProperty(schema[i]).getValue());
        }
        Geometry p2=((Geometry)(f.getDefaultGeometryProperty().getValue())).intersection(imageP);
        if (!p2.isEmpty()) {
          if (applayTransformation && transform != null)           p2=transform.transformGeometryPixelFromGeo(p2);
          out.put(p2,at);
        }
      }
    }
 catch (    Exception e) {
      logger.error(e.getMessage(),e);
    }
 finally {
      fi.close();
    }
  }
  return out;
}",0.9414797628254704
175185,"public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=60;
    double lon=15;
    double r[];
    try {
      System.out.println(""String_Node_Str"" + GeoUtils.getGeoidH(lon,lat));
      r=gc.pixelFromGeo(lon,lat);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
      r=gc.geoFromPixel(r[1],r[0]);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
}","public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=54.81;
    double lon=-5.81;
    double p=6180.1;
    double l=13476.0;
    try {
      double r3[]=gc.geoFromPixel(l,p);
      System.out.println(""String_Node_Str"" + r3[0] + ""String_Node_Str""+ r3[1]);
      System.out.println(""String_Node_Str"" + GeoUtils.getGeoidH(r3[0],r3[1]));
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
}",0.6267664172901081
175186,"/** 
 * @see In matlab: reverse geolocation
 */
@Override public double[] pixelFromGeo(final double lon,final double lat) throws GeoLocationException {
  double[] resultReverse=new double[2];
  double[] pXYZ=GeoUtils.convertFromGeoToEarthCentred(lat,lon);
  Double dd2[]=(Double[])orbitInterpolation.getTimeStampInterp().toArray(new Double[0]);
  double[] results=findZeroDoppler(statepVecInterp,pXYZ,ArrayUtils.toPrimitive(dd2));
  double zeroDopplerTime=results[0];
  double srdist=results[1];
  double lNominatore=(zeroDopplerTime - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double lDenom=(orbitInterpolation.getZeroDopplerTimeLastRef() - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double l=(lNominatore / lDenom) * (meta.getNlines() - 1);
  if (meta.getCoordinateConversion() != null && meta.getCoordinateConversion().length > 0) {
    double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
    int index=0;
    for (    S1Metadata.CoordinateConversion cc : coordConv) {
      groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
      index++;
    }
    int idx=0;
    if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
      idx=0;
    }
 else     if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
      idx=groundToSlantRangePolyTimesSeconds.length - 2;
    }
 else {
      for (idx=groundToSlantRangePolyTimesSeconds.length - 1; idx > 0; idx--) {
        if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)         break;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length - 1) {
        idx=idx - 1;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length) {
        idx=idx - 2;
      }
    }
    double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double[] groundToSlantRangeCoefficientsInterp=new double[coordConv[idx].groundToSlantRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
      groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].groundToSlantRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].groundToSlantRangeCoefficients[idCoeff];
    }
    double[] slantToGroundRangeCoefficientsInterp=new double[coordConv[idx].slantToGroundRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
      slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].slantToGroundRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].slantToGroundRangeCoefficients[idCoeff];
    }
    double newD=0;
    double oldD=0;
    int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
    int[] numCoeffs=new int[nCoeffs];
    int[] numExps=new int[nCoeffs];
    int[] denomCoeffs=new int[nCoeffs];
    int[] denomExps=new int[nCoeffs];
    for (int i=0; i < nCoeffs; i++) {
      numCoeffs[i]=i - 1;
      numExps[i]=i;
      denomCoeffs[i]=i;
      denomExps[i]=i - 1;
    }
    denomExps[0]=0;
    double deltaD=0;
    do {
      double numCoeffsXGround=0;
      double denomCoeffsXGround=0;
      double scalNum=0;
      double scalDen=0;
      for (int i=0; i < groundToSlantRangeCoefficientsInterp.length; i++) {
        double dExp=FastMath.pow(oldD,numExps[i]);
        double denomExp=FastMath.pow(oldD,denomExps[i]);
        numCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * numCoeffs[i];
        denomCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * denomCoeffs[i];
        scalNum=scalNum + dExp * numCoeffsXGround;
        scalDen=scalDen + denomExp * denomCoeffsXGround;
      }
      double num=srdist + scalNum;
      newD=num / scalDen;
      deltaD=FastMath.abs(newD - oldD);
      oldD=newD;
    }
 while (deltaD > 1);
    double p=0;
    if (meta.isPixelTimeOrderingAscending()) {
      p=(newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
 else {
      p=meta.getNumberOfSamplesPerLine() - 1 - (newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
    resultReverse[0]=p;
    resultReverse[1]=l;
    logger.debug(""String_Node_Str"" + l + ""String_Node_Str""+ ""String_Node_Str""+ p);
  }
  return resultReverse;
}","/** 
 * @see In matlab: reverse geolocation
 * @result r[o]=p r[1]=l
 */
@Override public double[] pixelFromGeo(final double lon,final double lat) throws GeoLocationException {
  double[] resultReverse=new double[2];
  double[] pXYZ=GeoUtils.convertFromGeoToEarthCentred(lat,lon);
  Double dd2[]=(Double[])orbitInterpolation.getTimeStampInterp().toArray(new Double[0]);
  double[] results=findZeroDoppler(statepVecInterp,pXYZ,ArrayUtils.toPrimitive(dd2));
  double zeroDopplerTime=results[0];
  double srdist=results[1];
  double lNominatore=(zeroDopplerTime - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double lDenom=(orbitInterpolation.getZeroDopplerTimeLastRef() - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double l=(lNominatore / lDenom) * (meta.getNlines() - 1);
  if (meta.getCoordinateConversion() != null && meta.getCoordinateConversion().length > 0) {
    double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
    int index=0;
    for (    S1Metadata.CoordinateConversion cc : coordConv) {
      groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
      index++;
    }
    int idx=0;
    if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
      idx=0;
    }
 else     if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
      idx=groundToSlantRangePolyTimesSeconds.length - 2;
    }
 else {
      for (idx=groundToSlantRangePolyTimesSeconds.length - 1; idx > 0; idx--) {
        if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)         break;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length - 1) {
        idx=idx - 1;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length) {
        idx=idx - 2;
      }
    }
    double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double[] groundToSlantRangeCoefficientsInterp=new double[coordConv[idx].groundToSlantRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
      groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].groundToSlantRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].groundToSlantRangeCoefficients[idCoeff];
    }
    double[] slantToGroundRangeCoefficientsInterp=new double[coordConv[idx].slantToGroundRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
      slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].slantToGroundRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].slantToGroundRangeCoefficients[idCoeff];
    }
    double newD=0;
    double oldD=0;
    int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
    int[] numCoeffs=new int[nCoeffs];
    int[] numExps=new int[nCoeffs];
    int[] denomCoeffs=new int[nCoeffs];
    int[] denomExps=new int[nCoeffs];
    for (int i=0; i < nCoeffs; i++) {
      numCoeffs[i]=i - 1;
      numExps[i]=i;
      denomCoeffs[i]=i;
      denomExps[i]=i - 1;
    }
    denomExps[0]=0;
    double deltaD=0;
    do {
      double numCoeffsXGround=0;
      double denomCoeffsXGround=0;
      double scalNum=0;
      double scalDen=0;
      for (int i=0; i < groundToSlantRangeCoefficientsInterp.length; i++) {
        double dExp=FastMath.pow(oldD,numExps[i]);
        double denomExp=FastMath.pow(oldD,denomExps[i]);
        numCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * numCoeffs[i];
        denomCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * denomCoeffs[i];
        scalNum=scalNum + dExp * numCoeffsXGround;
        scalDen=scalDen + denomExp * denomCoeffsXGround;
      }
      double num=srdist + scalNum;
      newD=num / scalDen;
      deltaD=FastMath.abs(newD - oldD);
      oldD=newD;
    }
 while (deltaD > 1);
    double p=0;
    if (meta.isPixelTimeOrderingAscending()) {
      p=(newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
 else {
      p=meta.getNumberOfSamplesPerLine() - 1 - (newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
    resultReverse[0]=p;
    resultReverse[1]=l;
    logger.debug(""String_Node_Str"" + l + ""String_Node_Str""+ ""String_Node_Str""+ p);
  }
  return resultReverse;
}",0.9973299156253338
175187,"/** 
 * @see In Matlab forwardgeolocation
 */
@Override public double[] geoFromPixel(final double l,final double p) throws GeoLocationException {
  try {
    double[] results=new double[2];
    double lon=0;
    double lat=0;
    double t0=0;
    int idxStartT0=0;
    if (meta.getType().equalsIgnoreCase(""String_Node_Str"") && meta.getProductType().equalsIgnoreCase(""String_Node_Str"") && (meta.getMode().equalsIgnoreCase(""String_Node_Str"") || meta.getMode().equalsIgnoreCase(""String_Node_Str""))) {
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    }
 else {
      double t01=(orbitInterpolation.getZeroDopplerTimeFirstRef()) * (meta.getNlines() - 1 - l);
      double t02=orbitInterpolation.getZeroDopplerTimeLastRef() * l;
      t0=(t01 + t02) / (meta.getNlines() - 1);
      for (idxStartT0=0; idxStartT0 < orbitInterpolation.getTimeStampInterp().size(); idxStartT0++) {
        if (orbitInterpolation.getTimeStampInterp().get(idxStartT0) >= t0) {
          break;
        }
      }
      if (idxStartT0 == statepVecInterp.size())       idxStartT0--;
    }
    final double[] pT0=statepVecInterp.get(idxStartT0);
    final double[] vT0=statevVecInterp.get(idxStartT0);
    double distance=0;
    if (meta.isPixelTimeOrderingAscending()) {
      distance=p * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
 else {
      distance=(meta.getNumberOfSamplesPerLine() - 1 - p) * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
    if (coordConv != null) {
      double zeroDopplerTime=t0;
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
      double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
      int index=0;
      for (      S1Metadata.CoordinateConversion cc : coordConv) {
        groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
        index++;
      }
      int idx=0;
      if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
        idx=1;
      }
 else       if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
        idx=groundToSlantRangePolyTimesSeconds.length - 2;
      }
 else {
        for (idx=groundToSlantRangePolyTimesSeconds.length - 1; idx > 0; idx--) {
          if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)           break;
        }
      }
      double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double[] groundToSlantRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].groundToSlantRangeCoefficients);
      double[] groundToSlantRangeCoefficientsInterp2=coordConv[idx + 1].groundToSlantRangeCoefficients;
      for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
        groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * groundToSlantRangeCoefficientsInterp[idCoeff] + factor2 * groundToSlantRangeCoefficientsInterp2[idCoeff];
      }
      double[] slantToGroundRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].slantToGroundRangeCoefficients);
      double[] slantToGroundRangeCoefficientsInterp2=coordConv[idx + 1].slantToGroundRangeCoefficients;
      for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
        slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * slantToGroundRangeCoefficientsInterp[idCoeff] + factor2 * slantToGroundRangeCoefficientsInterp2[idCoeff];
      }
      int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
      int[] vExps=new int[nCoeffs];
      for (int i=0; i < nCoeffs; i++) {
        vExps[i]=i;
      }
      double tmpD=distance - meta.getGroundRangeOrigin();
      double[] pows=MathUtil.powValue2Coeffs(tmpD,vExps);
      double sRdist=MathUtil.dot(groundToSlantRangeCoefficientsInterp,pows);
      logger.debug(""String_Node_Str"" + sRdist);
      double normPt0=MathUtil.norm(pT0);
      double vRadial=MathUtil.dot(vT0,pT0) / normPt0;
      double vTangential=FastMath.sqrt(FastMath.pow(MathUtil.norm(vT0),2) - FastMath.pow(vRadial,2));
      double tanPsi=vRadial / vTangential;
      double[] zsUnit=MathUtil.divVectByVal(pT0,-normPt0);
      double[] vTmp=MathUtil.crossProd3x3(zsUnit,vT0);
      double[] ysUnit=MathUtil.divVectByVal(vTmp,MathUtil.norm(vTmp));
      double[] xsUnit=MathUtil.crossProd3x3(ysUnit,zsUnit);
      double pH=0;
      double rEarth=normPt0 / FastMath.sqrt((pT0[0] * pT0[0] + pT0[1] * pT0[1]) / GeoUtils.semiMajorAxis2 + (pT0[2] * pT0[2]) / GeoUtils.semiMinorAxis2);
      for (int iidx=0; iidx < 2; iidx++) {
        rEarth=rEarth + pH;
        double rEarthOld=rEarth;
        double rEarthChange=100000;
        double[] q=new double[3];
        for (; rEarthChange > 0.1; ) {
          double Rz=(normPt0 * normPt0 + sRdist * sRdist - rEarth * rEarth) / (2 * normPt0);
          double Rx=Rz * tanPsi;
          double Ry=FastMath.sqrt(sRdist * sRdist - Rz * Rz - Rx * Rx);
          if (!meta.getAntennaPointing().equalsIgnoreCase(""String_Node_Str"")) {
            Ry=-Ry;
          }
          double[][] sRvect=new double[][]{{Rx},{Ry},{Rz - normPt0}};
          double[][] qbig=new double[][]{xsUnit,ysUnit,zsUnit};
          qbig=MathUtil.transpose(qbig);
          double[][] qmat=MathUtil.multiplyMatrix(qbig,sRvect);
          q[0]=qmat[0][0];
          q[1]=qmat[1][0];
          q[2]=qmat[2][0];
          rEarth=MathUtil.norm(q) / FastMath.sqrt((q[0] * q[0] + q[1] * q[1]) / GeoUtils.semiMajorAxis2 + (q[2] * q[2] / GeoUtils.semiMinorAxis2)) + pH;
          rEarthChange=FastMath.abs(rEarth - rEarthOld);
          rEarthOld=rEarth;
        }
        lon=FastMath.atan2(q[1],q[0]) * 180 / FastMath.PI;
        double lattmp=FastMath.asin(q[2] / FastMath.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]));
        lat=FastMath.atan(FastMath.tan(lattmp) * FastMath.pow((GeoUtils.semiMajorAxis + pH),2) / FastMath.pow((GeoUtils.semiMinorAxis + pH),2)) * 180 / FastMath.PI;
        pH=GeoUtils.getGeoidH(lon,lat);
      }
    }
    logger.debug(""String_Node_Str"" + lat + ""String_Node_Str""+ lon);
    results[0]=lon;
    results[1]=lat;
    return results;
  }
 catch (  MathException me) {
    throw new GeoLocationException(GeoLocationException.MSG_CONV_FROM_PIXEL_TO_GEO + ""String_Node_Str"" + me.getMessage());
  }
}","/** 
 * @see In Matlab forwardgeolocation
 * @return   r[0]=lon r[1]=lat
 */
@Override public double[] geoFromPixel(final double l,final double p) throws GeoLocationException {
  try {
    double[] results=new double[2];
    double lon=0;
    double lat=0;
    double t0=0;
    int idxStartT0=0;
    if (meta.getType().equalsIgnoreCase(""String_Node_Str"") && meta.getProductType().equalsIgnoreCase(""String_Node_Str"") && (meta.getMode().equalsIgnoreCase(""String_Node_Str"") || meta.getMode().equalsIgnoreCase(""String_Node_Str""))) {
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    }
 else {
      double t01=(orbitInterpolation.getZeroDopplerTimeFirstRef()) * (meta.getNlines() - 1 - l);
      double t02=orbitInterpolation.getZeroDopplerTimeLastRef() * l;
      t0=(t01 + t02) / (meta.getNlines() - 1);
      for (idxStartT0=0; idxStartT0 < orbitInterpolation.getTimeStampInterp().size(); idxStartT0++) {
        if (orbitInterpolation.getTimeStampInterp().get(idxStartT0) >= t0) {
          break;
        }
      }
      if (idxStartT0 == statepVecInterp.size())       idxStartT0--;
    }
    final double[] pT0=statepVecInterp.get(idxStartT0);
    final double[] vT0=statevVecInterp.get(idxStartT0);
    double distance=0;
    if (meta.isPixelTimeOrderingAscending()) {
      distance=p * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
 else {
      distance=(meta.getNumberOfSamplesPerLine() - 1 - p) * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
    if (coordConv != null) {
      double zeroDopplerTime=t0;
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
      double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
      int index=0;
      for (      S1Metadata.CoordinateConversion cc : coordConv) {
        groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
        index++;
      }
      int idx=0;
      if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
        idx=1;
      }
 else       if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
        idx=groundToSlantRangePolyTimesSeconds.length - 2;
      }
 else {
        for (idx=groundToSlantRangePolyTimesSeconds.length - 1; idx > 0; idx--) {
          if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)           break;
        }
      }
      double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double[] groundToSlantRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].groundToSlantRangeCoefficients);
      double[] groundToSlantRangeCoefficientsInterp2=coordConv[idx + 1].groundToSlantRangeCoefficients;
      for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
        groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * groundToSlantRangeCoefficientsInterp[idCoeff] + factor2 * groundToSlantRangeCoefficientsInterp2[idCoeff];
      }
      double[] slantToGroundRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].slantToGroundRangeCoefficients);
      double[] slantToGroundRangeCoefficientsInterp2=coordConv[idx + 1].slantToGroundRangeCoefficients;
      for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
        slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * slantToGroundRangeCoefficientsInterp[idCoeff] + factor2 * slantToGroundRangeCoefficientsInterp2[idCoeff];
      }
      int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
      int[] vExps=new int[nCoeffs];
      for (int i=0; i < nCoeffs; i++) {
        vExps[i]=i;
      }
      double tmpD=distance - meta.getGroundRangeOrigin();
      double[] pows=MathUtil.powValue2Coeffs(tmpD,vExps);
      double sRdist=MathUtil.dot(groundToSlantRangeCoefficientsInterp,pows);
      logger.debug(""String_Node_Str"" + sRdist);
      double normPt0=MathUtil.norm(pT0);
      double vRadial=MathUtil.dot(vT0,pT0) / normPt0;
      double vTangential=FastMath.sqrt(FastMath.pow(MathUtil.norm(vT0),2) - FastMath.pow(vRadial,2));
      double tanPsi=vRadial / vTangential;
      double[] zsUnit=MathUtil.divVectByVal(pT0,-normPt0);
      double[] vTmp=MathUtil.crossProd3x3(zsUnit,vT0);
      double[] ysUnit=MathUtil.divVectByVal(vTmp,MathUtil.norm(vTmp));
      double[] xsUnit=MathUtil.crossProd3x3(ysUnit,zsUnit);
      double pH=0;
      double rEarth=normPt0 / FastMath.sqrt((pT0[0] * pT0[0] + pT0[1] * pT0[1]) / GeoUtils.semiMajorAxis2 + (pT0[2] * pT0[2]) / GeoUtils.semiMinorAxis2);
      for (int iidx=0; iidx < 2; iidx++) {
        rEarth=rEarth + pH;
        double rEarthOld=rEarth;
        double rEarthChange=100000;
        double[] q=new double[3];
        for (; rEarthChange > 0.1; ) {
          double Rz=(normPt0 * normPt0 + sRdist * sRdist - rEarth * rEarth) / (2 * normPt0);
          double Rx=Rz * tanPsi;
          double Ry=FastMath.sqrt(sRdist * sRdist - Rz * Rz - Rx * Rx);
          if (!meta.getAntennaPointing().equalsIgnoreCase(""String_Node_Str"")) {
            Ry=-Ry;
          }
          double[][] sRvect=new double[][]{{Rx},{Ry},{Rz - normPt0}};
          double[][] qbig=new double[][]{xsUnit,ysUnit,zsUnit};
          qbig=MathUtil.transpose(qbig);
          double[][] qmat=MathUtil.multiplyMatrix(qbig,sRvect);
          q[0]=qmat[0][0];
          q[1]=qmat[1][0];
          q[2]=qmat[2][0];
          rEarth=MathUtil.norm(q) / FastMath.sqrt((q[0] * q[0] + q[1] * q[1]) / GeoUtils.semiMajorAxis2 + (q[2] * q[2] / GeoUtils.semiMinorAxis2)) + pH;
          rEarthChange=FastMath.abs(rEarth - rEarthOld);
          rEarthOld=rEarth;
        }
        lon=FastMath.atan2(q[1],q[0]) * 180 / FastMath.PI;
        double lattmp=FastMath.asin(q[2] / FastMath.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]));
        lat=FastMath.atan(FastMath.tan(lattmp) * FastMath.pow((GeoUtils.semiMajorAxis + pH),2) / FastMath.pow((GeoUtils.semiMinorAxis + pH),2)) * 180 / FastMath.PI;
        pH=GeoUtils.getGeoidH(lon,lat);
      }
    }
    logger.debug(""String_Node_Str"" + lat + ""String_Node_Str""+ lon);
    results[0]=lon;
    results[1]=lat;
    return results;
  }
 catch (  MathException me) {
    throw new GeoLocationException(GeoLocationException.MSG_CONV_FROM_PIXEL_TO_GEO + ""String_Node_Str"" + me.getMessage());
  }
}",0.9976850123217086
175188,"/** 
 * calculate new statistics using tile centered around pixel
 * @param cornerx
 * @param cornery
 * @param width
 * @param height
 * @param bands
 * @param data
 * @param kdist
 * @return
 */
public static double[][] calculateImagemapStatistics(int cornerx,int cornery,int width,int height,int[] bands,int data[][],KDistributionEstimation kdist){
  int numberofbands=bands.length;
  double[][] imagestat=new double[numberofbands][5];
  for (int i=0; i < numberofbands; i++) {
    int band=bands[i];
    kdist.setImageData(cornerx,cornery,width,height,0,0,band);
    kdist.estimate(null,data[i]);
    double[] thresh=kdist.getDetectThresh();
    imagestat[i][0]=thresh[0];
    imagestat[i][1]=thresh[1] / thresh[5];
    imagestat[i][2]=thresh[2] / thresh[5];
    imagestat[i][3]=thresh[3] / thresh[5];
    imagestat[i][4]=thresh[4] / thresh[5];
  }
  return imagestat;
}","/** 
 * calculate new statistics using tile centered around pixel
 * @param cornerx
 * @param cornery
 * @param width
 * @param height
 * @param bands
 * @param data
 * @param kdist
 * @return
 */
public static double[][] calculateImagemapStatistics(int cornerx,int cornery,int width,int height,int row,int col,int[] bands,int data[][],KDistributionEstimation kdist){
  int numberofbands=bands.length;
  double[][] imagestat=new double[numberofbands][5];
  for (int i=0; i < numberofbands; i++) {
    int band=bands[i];
    kdist.setImageData(cornerx,cornery,width,height,row,col,band);
    kdist.estimate(null,data[i]);
    double[] thresh=kdist.getDetectThresh();
    imagestat[i][0]=thresh[0];
    imagestat[i][1]=thresh[1] / thresh[5];
    imagestat[i][2]=thresh[2] / thresh[5];
    imagestat[i][3]=thresh[3] / thresh[5];
    imagestat[i][4]=thresh[4] / thresh[5];
  }
  return imagestat;
}",0.9852941176470588
175189,"/** 
 * aggregate using the neighbours within tilesize
 * @param neighboursdistance
 * @param tilesize
 * @param removelandconnectedpixels
 * @param bands
 * @param mask
 * @param kdist
 * @throws IOException
 */
private void aggregate(DetectedPixels detPixels,int neighboursdistance,int tilesize,boolean removelandconnectedpixels,int[] bands,IMask mask,KDistributionEstimation kdist) throws IOException {
  int id=0;
  Pixel pixels[]=detPixels.getAllDetectedPixelsValues().toArray(new Pixel[0]);
  int count=0;
  for (  Pixel detectedPix : pixels) {
    count++;
    int xx=detectedPix.x;
    int yy=detectedPix.y;
    if ((count % 100) == 0)     logger.info(new StringBuilder().append(""String_Node_Str"").append(count).append(""String_Node_Str"").append(xx).append(""String_Node_Str"").append(yy).toString());
    boolean checked=false;
    for (    BoatConnectedPixelMap boatpixel : detPixels.listboatneighbours) {
      if (boatpixel.containsPixel(xx,yy)) {
        checked=true;
        break;
      }
    }
    if (checked) {
      continue;
    }
    int cornerx=Math.min(Math.max(0,xx - tilesize / 2),gir.getWidth() - tilesize);
    int cornery=Math.min(Math.max(0,yy - tilesize / 2),gir.getHeight() - tilesize);
    int boatx=xx - cornerx;
    int boaty=yy - cornery;
    int numberbands=bands.length;
    int[][] data=new int[numberbands][];
    try {
      for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
        data[bandcounter]=gir.read(cornerx,cornery,tilesize,tilesize,bands[bandcounter]);
      }
    }
 catch (    IOException e) {
      logger.error(e.getMessage());
      throw e;
    }
    double[][] statistics=AnalysisUtil.calculateImagemapStatistics(cornerx,cornery,tilesize,tilesize,bands,data,kdist);
    double[][] thresholdvalues=new double[numberbands][2];
    int[] maxValue=new int[numberbands];
    boolean pixelabove=false;
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      double mean=(statistics[bandcounter][1] + statistics[bandcounter][2] + statistics[bandcounter][3]+ statistics[bandcounter][4]) / 4;
      thresholdvalues[bandcounter][0]=mean + 3 * mean * statistics[bandcounter][0];
      thresholdvalues[bandcounter][1]=mean + 5 * mean * statistics[bandcounter][0];
      int value=data[bandcounter][boatx + boaty * tilesize];
      if (value > thresholdvalues[bandcounter][1]) {
        pixelabove=true;
      }
      if (value > maxValue[bandcounter]) {
        maxValue[bandcounter]=data[bandcounter][boatx + boaty * tilesize];
      }
    }
    if (pixelabove) {
      Raster rastermask=null;
      if (mask != null) {
        if (mask.intersects(cornerx,cornery,tilesize,tilesize)) {
          rastermask=(mask.rasterize(cornerx,cornery,tilesize,tilesize,-cornerx,-cornery,1.0)).getData();
        }
      }
      BoatConnectedPixelMap boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][boatx + boaty * tilesize]);
      for (int iBand=0; iBand < numberbands; iBand++) {
        String bb=((SarImageReader)gir).getBands()[iBand];
        float thresholdBand=this.thresholdsBandParams.get(bb);
        int row=(cornery + 1) / this.verTiles;
        int col=(cornerx + 1) / this.horTiles;
        kdist.setImageData(cornerx,cornery,tilesize,tilesize,row,col,iBand);
        int[] newdata=gir.readTile(cornerx,cornery,tilesize,tilesize,iBand);
        kdist.estimate(rastermask,newdata);
        double[] treshTile=kdist.getDetectThresh();
        double threshTotal=treshTile[0] + treshTile[1] + treshTile[2]+ treshTile[3];
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,treshTile);
        double tileAvg=threshTotal / treshTile[5];
        double tileStdDev=treshTile[0] * threshTotal / treshTile[5];
        int idxBand=idxOn4Band(bb);
        boatpixel.putMeanValue(idxBand,(statistics[iBand][1] + statistics[iBand][2] + statistics[iBand][3]+ statistics[iBand][4]) / 4);
        boatpixel.putThresholdValue(idxBand,(threshWindowsVals[0] + threshWindowsVals[1] + threshWindowsVals[2]+ threshWindowsVals[3]) / 4);
        boatpixel.putMaxValue(idxBand,maxValue[iBand]);
        boatpixel.putStDevValue(idxBand,tileStdDev);
        double significance=(maxValue[iBand] - tileAvg) / tileStdDev;
        boatpixel.putSignificanceValue(idxBand,significance);
        boatpixel.putAvgValue(idxBand,tileAvg);
      }
      detPixels.listboatneighbours.add(boatpixel);
      List<int[]> boataggregatedpixels=new ArrayList<int[]>();
      int[] imagemap=new int[tilesize * tilesize];
      for (int i=0; i < tilesize * tilesize; i++) {
        imagemap[i]=0;
      }
      boolean result=detPixels.checkNeighbours(boataggregatedpixels,imagemap,data,thresholdvalues,new int[]{boatx,boaty},neighboursdistance,tilesize,rastermask);
      boatpixel.setTouchesLandMask(result);
      for (      int[] pixel : boataggregatedpixels) {
        boatpixel.addConnectedPixel(pixel[0] + cornerx,pixel[1] + cornery,pixel[2],pixel[3] == 1 ? true : false);
      }
    }
  }
  if (removelandconnectedpixels) {
    List<BoatConnectedPixelMap> toRemove=new ArrayList<BoatConnectedPixelMap>();
    for (int i=0; i < detPixels.listboatneighbours.size(); i++) {
      BoatConnectedPixelMap boat=detPixels.listboatneighbours.get(i);
      if (boat.touchesLand()) {
        toRemove.add(boat);
      }
    }
    detPixels.listboatneighbours.removeAll(toRemove);
  }
  detPixels.computeBoatsAttributesAndStatistics(detPixels.listboatneighbours);
}","/** 
 * aggregate using the neighbours within tilesize
 * @param neighboursdistance
 * @param tilesize
 * @param removelandconnectedpixels
 * @param bands
 * @param mask
 * @param kdist
 * @throws IOException
 */
private void aggregate(DetectedPixels detPixels,int neighboursdistance,int tilesize,boolean removelandconnectedpixels,int[] bands,IMask mask,KDistributionEstimation kdist) throws IOException {
  int id=0;
  Pixel pixels[]=detPixels.getAllDetectedPixelsValues().toArray(new Pixel[0]);
  int count=0;
  for (  Pixel detectedPix : pixels) {
    count++;
    int xx=detectedPix.x;
    int yy=detectedPix.y;
    if ((count % 100) == 0)     logger.info(new StringBuilder().append(""String_Node_Str"").append(count).append(""String_Node_Str"").append(xx).append(""String_Node_Str"").append(yy).toString());
    boolean checked=false;
    for (    BoatConnectedPixelMap boatpixel : detPixels.listboatneighbours) {
      if (boatpixel.containsPixel(xx,yy)) {
        checked=true;
        break;
      }
    }
    if (checked) {
      continue;
    }
    int cornerx=Math.min(Math.max(0,xx - tilesize / 2),gir.getWidth() - tilesize);
    int cornery=Math.min(Math.max(0,yy - tilesize / 2),gir.getHeight() - tilesize);
    int boatx=xx - cornerx;
    int boaty=yy - cornery;
    int numberbands=bands.length;
    int[][] data=new int[numberbands][];
    try {
      for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
        data[bandcounter]=gir.read(cornerx,cornery,tilesize,tilesize,bands[bandcounter]);
      }
    }
 catch (    IOException e) {
      logger.error(e.getMessage());
      throw e;
    }
    int row=(cornery + 1) / this.verTiles;
    int col=(cornerx + 1) / this.horTiles;
    double[][] statistics=AnalysisUtil.calculateImagemapStatistics(cornerx,cornery,tilesize,tilesize,row,col,bands,data,kdist);
    double[][] thresholdvalues=new double[numberbands][2];
    int[] maxValue=new int[numberbands];
    boolean pixelabove=false;
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      double mean=(statistics[bandcounter][1] + statistics[bandcounter][2] + statistics[bandcounter][3]+ statistics[bandcounter][4]) / 4;
      thresholdvalues[bandcounter][0]=mean + 3 * mean * statistics[bandcounter][0];
      thresholdvalues[bandcounter][1]=mean + 5 * mean * statistics[bandcounter][0];
      int value=data[bandcounter][boatx + boaty * tilesize];
      if (value > thresholdvalues[bandcounter][1]) {
        pixelabove=true;
      }
      if (value > maxValue[bandcounter]) {
        maxValue[bandcounter]=data[bandcounter][boatx + boaty * tilesize];
      }
    }
    if (pixelabove) {
      Raster rastermask=null;
      if (mask != null) {
        if (mask.intersects(cornerx,cornery,tilesize,tilesize)) {
          rastermask=(mask.rasterize(cornerx,cornery,tilesize,tilesize,-cornerx,-cornery,1.0)).getData();
        }
      }
      BoatConnectedPixelMap boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][boatx + boaty * tilesize]);
      for (int iBand=0; iBand < numberbands; iBand++) {
        String bb=((SarImageReader)gir).getBands()[iBand];
        float thresholdBand=this.thresholdsBandParams.get(bb);
        kdist.setImageData(cornerx,cornery,tilesize,tilesize,row,col,iBand);
        int[] newdata=gir.readTile(cornerx,cornery,tilesize,tilesize,iBand);
        kdist.estimate(rastermask,newdata);
        double[] treshTile=kdist.getDetectThresh();
        double threshTotal=treshTile[0] + treshTile[1] + treshTile[2]+ treshTile[3];
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,treshTile);
        double tileAvg=threshTotal / treshTile[5];
        double tileStdDev=treshTile[0] * threshTotal / treshTile[5];
        int idxBand=idxOn4Band(bb);
        boatpixel.putMeanValue(idxBand,(statistics[iBand][1] + statistics[iBand][2] + statistics[iBand][3]+ statistics[iBand][4]) / 4);
        boatpixel.putThresholdValue(idxBand,(threshWindowsVals[0] + threshWindowsVals[1] + threshWindowsVals[2]+ threshWindowsVals[3]) / 4);
        boatpixel.putMaxValue(idxBand,maxValue[iBand]);
        boatpixel.putStDevValue(idxBand,tileStdDev);
        double significance=(maxValue[iBand] - tileAvg) / tileStdDev;
        boatpixel.putSignificanceValue(idxBand,significance);
        boatpixel.putAvgValue(idxBand,tileAvg);
      }
      detPixels.listboatneighbours.add(boatpixel);
      List<int[]> boataggregatedpixels=new ArrayList<int[]>();
      int[] imagemap=new int[tilesize * tilesize];
      for (int i=0; i < tilesize * tilesize; i++) {
        imagemap[i]=0;
      }
      boolean result=detPixels.checkNeighbours(boataggregatedpixels,imagemap,data,thresholdvalues,new int[]{boatx,boaty},neighboursdistance,tilesize,rastermask);
      boatpixel.setTouchesLandMask(result);
      for (      int[] pixel : boataggregatedpixels) {
        boatpixel.addConnectedPixel(pixel[0] + cornerx,pixel[1] + cornery,pixel[2],pixel[3] == 1 ? true : false);
      }
    }
  }
  if (removelandconnectedpixels) {
    List<BoatConnectedPixelMap> toRemove=new ArrayList<BoatConnectedPixelMap>();
    for (int i=0; i < detPixels.listboatneighbours.size(); i++) {
      BoatConnectedPixelMap boat=detPixels.listboatneighbours.get(i);
      if (boat.touchesLand()) {
        toRemove.add(boat);
      }
    }
    detPixels.listboatneighbours.removeAll(toRemove);
  }
  detPixels.computeBoatsAttributesAndStatistics(detPixels.listboatneighbours);
}",0.9827838827838828
175190,"/** 
 * @param gir
 * @param mask
 * @param enlf
 * @param thresholdHH
 * @param thresholdHV
 * @param thresholdVH
 * @param thresholdVV
 * @param progressBar
 */
public VDSAnalysis(SarImageReader gir,IMask[] mask,float enlf,float thresholdHH,float thresholdHV,float thresholdVH,float thresholdVV){
  this.enl=""String_Node_Str"" + (int)(enlf * 10);
  if (this.enl.length() == 2) {
    this.enl=""String_Node_Str"" + this.enl;
  }
  thresholdsBandParams.put(""String_Node_Str"",thresholdHH);
  thresholdsBandParams.put(""String_Node_Str"",thresholdHV);
  thresholdsBandParams.put(""String_Node_Str"",thresholdVH);
  thresholdsBandParams.put(""String_Node_Str"",thresholdVV);
  this.gir=gir;
  this.mask=mask;
  this.tileSize=(int)(ConstantVDSAnalysis.TILESIZE / gir.getPixelsize()[0]);
  if (this.tileSize < ConstantVDSAnalysis.TILESIZEPIXELS)   this.tileSize=ConstantVDSAnalysis.TILESIZEPIXELS;
  this.verTiles=gir.getHeight() / this.tileSize;
  this.horTiles=gir.getWidth() / this.tileSize;
  progressListener=new ArrayList<ProgressListener>();
}","/** 
 * @param gir
 * @param mask
 * @param enlf
 * @param thresholdHH
 * @param thresholdHV
 * @param thresholdVH
 * @param thresholdVV
 * @param progressBar
 */
public VDSAnalysis(SarImageReader gir,IMask[] mask,float enlf,Map<String,Float> trhresholdMap){
  this.enl=""String_Node_Str"" + (int)(enlf * 10);
  if (this.enl.length() == 2) {
    this.enl=""String_Node_Str"" + this.enl;
  }
  this.thresholdsBandParams=trhresholdMap;
  this.gir=gir;
  this.mask=mask;
  this.tileSize=(int)(ConstantVDSAnalysis.TILESIZE / gir.getPixelsize()[0]);
  if (this.tileSize < ConstantVDSAnalysis.TILESIZEPIXELS)   this.tileSize=ConstantVDSAnalysis.TILESIZEPIXELS;
  this.verTiles=gir.getHeight() / this.tileSize;
  this.horTiles=gir.getWidth() / this.tileSize;
  progressListener=new ArrayList<ProgressListener>();
}",0.8200108754758021
175191,"/** 
 * run the analysis called from ActionDialog
 */
public boolean execute(String[] args){
  int bufferingDistance=Double.valueOf((Platform.getConfiguration()).getBufferingDistance()).intValue();
  Platform.getMain().addStopListener(this);
  if (args.length < 2) {
    return true;
  }
 else {
    if (args[0].equals(""String_Node_Str"")) {
      done=false;
      ImageLayer cl=Platform.getCurrentImageLayer();
      GeoImageReader reader=((ImageLayer)cl).getImageReader();
      if (reader instanceof SarImageReader || reader instanceof TiledBufferedImage) {
        gir=reader;
      }
      if (gir == null) {
        done=true;
        return false;
      }
      float thrHH=0;
      float thrHV=0;
      float thrVH=0;
      float thrVV=0;
      int numberofbands=gir.getNBand();
      for (int bb=0; bb < numberofbands; bb++) {
        if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thrHH=Float.parseFloat(args[bb + 1]);
        }
 else         if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thrHV=Float.parseFloat(args[bb + 1]);
        }
 else         if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thrVH=Float.parseFloat(args[bb + 1]);
        }
 else         if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thrVV=Float.parseFloat(args[bb + 1]);
        }
      }
      final float thresholdHH=thrHH;
      final float thresholdHV=thrHV;
      final float thresholdVH=thrVH;
      final float thresholdVV=thrVV;
      mask=new ArrayList<IMask>();
      for (      ILayer l : Platform.getLayerManager().getChilds(cl)) {
        if (l instanceof IMask & l.getName().startsWith(args[numberofbands + 1])) {
          mask.add((IMask)l);
        }
      }
      bufferingDistance=Integer.parseInt(args[numberofbands + 2]);
      final float ENL=Float.parseFloat(args[numberofbands + 3]);
      final IMask[] bufferedMask=new IMask[mask.size()];
      for (int i=0; i < mask.size(); i++) {
        IMask maskList=mask.get(i);
        bufferedMask[i]=FactoryLayer.createMaskLayer(maskList.getName(),maskList.getType(),bufferingDistance,((MaskVectorLayer)maskList).getGeometriclayer());
      }
      final VDSAnalysis analysis=new VDSAnalysis((SarImageReader)gir,bufferedMask,ENL,thresholdHH,thresholdHV,thresholdVH,thresholdVV);
      proc=new AnalysisProcess(reader,ENL,analysis,bufferedMask,bufferingDistance,0);
      proc.addProcessListener(this);
      Thread t=new Thread(proc);
      t.setName(""String_Node_Str"" + gir.getDisplayName(0));
      t.start();
    }
    return true;
  }
}","/** 
 * run the analysis called from ActionDialog
 */
public boolean execute(String[] args){
  int bufferingDistance=Double.valueOf((Platform.getConfiguration()).getBufferingDistance()).intValue();
  Platform.getMain().addStopListener(this);
  if (args.length < 2) {
    return true;
  }
 else {
    if (args[0].equals(""String_Node_Str"")) {
      done=false;
      ImageLayer cl=Platform.getCurrentImageLayer();
      GeoImageReader reader=((ImageLayer)cl).getImageReader();
      if (reader instanceof SarImageReader || reader instanceof TiledBufferedImage) {
        gir=reader;
      }
      if (gir == null) {
        done=true;
        return false;
      }
      java.util.HashMap<String,Float> thresholds=new java.util.HashMap<>();
      int numberofbands=gir.getNBand();
      thresholds.put(""String_Node_Str"",0.0f);
      thresholds.put(""String_Node_Str"",0.0f);
      thresholds.put(""String_Node_Str"",0.0f);
      thresholds.put(""String_Node_Str"",0.0f);
      for (int bb=0; bb < numberofbands; bb++) {
        if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thresholds.put(""String_Node_Str"",Float.parseFloat(args[bb + 1]));
        }
 else         if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thresholds.put(""String_Node_Str"",Float.parseFloat(args[bb + 1]));
        }
 else         if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thresholds.put(""String_Node_Str"",Float.parseFloat(args[bb + 1]));
        }
 else         if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thresholds.put(""String_Node_Str"",Float.parseFloat(args[bb + 1]));
        }
      }
      mask=new ArrayList<IMask>();
      for (      ILayer l : Platform.getLayerManager().getChilds(cl)) {
        if (l instanceof IMask & l.getName().startsWith(args[numberofbands + 1])) {
          mask.add((IMask)l);
        }
      }
      bufferingDistance=Integer.parseInt(args[numberofbands + 2]);
      final float ENL=Float.parseFloat(args[numberofbands + 3]);
      final IMask[] bufferedMask=new IMask[mask.size()];
      for (int i=0; i < mask.size(); i++) {
        IMask maskList=mask.get(i);
        bufferedMask[i]=FactoryLayer.createMaskLayer(maskList.getName(),maskList.getType(),bufferingDistance,((MaskVectorLayer)maskList).getGeometriclayer());
      }
      final VDSAnalysis analysis=new VDSAnalysis((SarImageReader)gir,bufferedMask,ENL,thresholds);
      proc=new AnalysisProcess(reader,ENL,analysis,bufferedMask,bufferingDistance,0);
      proc.addProcessListener(this);
      Thread t=new Thread(proc);
      t.setName(""String_Node_Str"" + gir.getDisplayName(0));
      t.start();
    }
    return true;
  }
}",0.8636606665478525
175192,"/** 
 * run analysis for 1 image
 */
public void analizeImage(SarImageReader reader,IMask[] masks,AnalysisParams params){
  analysis=new VDSAnalysis(reader,masks,params.enl,params.thresholdArrayValues[0],params.thresholdArrayValues[1],params.thresholdArrayValues[2],params.thresholdArrayValues[3]);
  final String[] thresholds={""String_Node_Str"" + params.thresholdArrayValues[0],""String_Node_Str"" + params.thresholdArrayValues[1],""String_Node_Str"" + params.thresholdArrayValues[2],""String_Node_Str"" + params.thresholdArrayValues[3]};
  layerResults=runBatchAnalysis(reader,params.enl,analysis,masks,thresholds,params.buffer);
}","/** 
 * run analysis for 1 image
 */
public void analizeImage(SarImageReader reader,IMask[] masks,AnalysisParams params){
  java.util.HashMap<String,Float> thresholdsMap=new java.util.HashMap<>();
  thresholdsMap.put(""String_Node_Str"",params.thresholdArrayValues[0]);
  thresholdsMap.put(""String_Node_Str"",params.thresholdArrayValues[1]);
  thresholdsMap.put(""String_Node_Str"",params.thresholdArrayValues[2]);
  thresholdsMap.put(""String_Node_Str"",params.thresholdArrayValues[3]);
  analysis=new VDSAnalysis(reader,masks,params.enl,thresholdsMap);
  final String[] thresholds={""String_Node_Str"" + params.thresholdArrayValues[0],""String_Node_Str"" + params.thresholdArrayValues[1],""String_Node_Str"" + params.thresholdArrayValues[2],""String_Node_Str"" + params.thresholdArrayValues[3]};
  layerResults=runBatchAnalysis(reader,params.enl,analysis,masks,thresholds,params.buffer);
}",0.6706586826347305
175193,"/** 
 * calculate new statistics using tile centered around pixel
 * @param cornerx
 * @param cornery
 * @param width
 * @param height
 * @param bands
 * @param data
 * @param kdist
 * @return
 */
public static double[][] calculateImagemapStatistics(int cornerx,int cornery,int width,int height,int[] bands,int data[][],KDistributionEstimation kdist){
  int numberofbands=bands.length;
  double[][] imagestat=new double[numberofbands][5];
  for (int i=0; i < numberofbands; i++) {
    int band=bands[i];
    kdist.setImageData(cornerx,cornery,width,height,0,0,band);
    kdist.estimate(null,data[i]);
    double[] thresh=kdist.getDetectThresh();
    imagestat[i][0]=thresh[0];
    imagestat[i][1]=thresh[1] / thresh[5];
    imagestat[i][2]=thresh[2] / thresh[5];
    imagestat[i][3]=thresh[3] / thresh[5];
    imagestat[i][4]=thresh[4] / thresh[5];
  }
  return imagestat;
}","/** 
 * calculate new statistics using tile centered around pixel
 * @param cornerx
 * @param cornery
 * @param width
 * @param height
 * @param bands
 * @param data
 * @param kdist
 * @return
 */
public static double[][] calculateImagemapStatistics(int cornerx,int cornery,int width,int height,int row,int col,int[] bands,int data[][],KDistributionEstimation kdist){
  int numberofbands=bands.length;
  double[][] imagestat=new double[numberofbands][5];
  for (int i=0; i < numberofbands; i++) {
    int band=bands[i];
    kdist.setImageData(cornerx,cornery,width,height,row,col,band);
    kdist.estimate(null,data[i]);
    double[] thresh=kdist.getDetectThresh();
    imagestat[i][0]=thresh[0];
    imagestat[i][1]=thresh[1] / thresh[5];
    imagestat[i][2]=thresh[2] / thresh[5];
    imagestat[i][3]=thresh[3] / thresh[5];
    imagestat[i][4]=thresh[4] / thresh[5];
  }
  return imagestat;
}",0.9852941176470588
175194,"/** 
 * aggregate using the neighbours within tilesize
 * @param neighboursdistance
 * @param tilesize
 * @param removelandconnectedpixels
 * @param bands
 * @param mask
 * @param kdist
 * @throws IOException
 */
private void aggregate(DetectedPixels detPixels,int neighboursdistance,int tilesize,boolean removelandconnectedpixels,int[] bands,IMask mask,KDistributionEstimation kdist) throws IOException {
  int id=0;
  Pixel pixels[]=detPixels.getAllDetectedPixelsValues().toArray(new Pixel[0]);
  int count=0;
  for (  Pixel detectedPix : pixels) {
    count++;
    int xx=detectedPix.x;
    int yy=detectedPix.y;
    if ((count % 100) == 0)     logger.info(new StringBuilder().append(""String_Node_Str"").append(count).append(""String_Node_Str"").append(xx).append(""String_Node_Str"").append(yy).toString());
    boolean checked=false;
    for (    BoatConnectedPixelMap boatpixel : detPixels.listboatneighbours) {
      if (boatpixel.containsPixel(xx,yy)) {
        checked=true;
        break;
      }
    }
    if (checked) {
      continue;
    }
    int cornerx=Math.min(Math.max(0,xx - tilesize / 2),gir.getWidth() - tilesize);
    int cornery=Math.min(Math.max(0,yy - tilesize / 2),gir.getHeight() - tilesize);
    int boatx=xx - cornerx;
    int boaty=yy - cornery;
    int numberbands=bands.length;
    int[][] data=new int[numberbands][];
    try {
      for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
        data[bandcounter]=gir.read(cornerx,cornery,tilesize,tilesize,bands[bandcounter]);
      }
    }
 catch (    IOException e) {
      logger.error(e.getMessage());
      throw e;
    }
    double[][] statistics=AnalysisUtil.calculateImagemapStatistics(cornerx,cornery,tilesize,tilesize,bands,data,kdist);
    double[][] thresholdvalues=new double[numberbands][2];
    int[] maxValue=new int[numberbands];
    boolean pixelabove=false;
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      double mean=(statistics[bandcounter][1] + statistics[bandcounter][2] + statistics[bandcounter][3]+ statistics[bandcounter][4]) / 4;
      thresholdvalues[bandcounter][0]=mean + 3 * mean * statistics[bandcounter][0];
      thresholdvalues[bandcounter][1]=mean + 5 * mean * statistics[bandcounter][0];
      int value=data[bandcounter][boatx + boaty * tilesize];
      if (value > thresholdvalues[bandcounter][1]) {
        pixelabove=true;
      }
      if (value > maxValue[bandcounter]) {
        maxValue[bandcounter]=data[bandcounter][boatx + boaty * tilesize];
      }
    }
    if (pixelabove) {
      Raster rastermask=null;
      if (mask != null) {
        if (mask.intersects(cornerx,cornery,tilesize,tilesize)) {
          rastermask=(mask.rasterize(cornerx,cornery,tilesize,tilesize,-cornerx,-cornery,1.0)).getData();
        }
      }
      BoatConnectedPixelMap boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][boatx + boaty * tilesize]);
      for (int iBand=0; iBand < numberbands; iBand++) {
        String bb=((SarImageReader)gir).getBands()[iBand];
        float thresholdBand=this.thresholdsBandParams.get(bb);
        int row=(cornery + 1) / this.verTiles;
        int col=(cornerx + 1) / this.horTiles;
        kdist.setImageData(cornerx,cornery,tilesize,tilesize,row,col,iBand);
        int[] newdata=gir.readTile(cornerx,cornery,tilesize,tilesize,iBand);
        kdist.estimate(rastermask,newdata);
        double[] treshTile=kdist.getDetectThresh();
        double threshTotal=treshTile[0] + treshTile[1] + treshTile[2]+ treshTile[3];
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,treshTile);
        double tileAvg=threshTotal / treshTile[5];
        double tileStdDev=treshTile[0] * threshTotal / treshTile[5];
        int idxBand=idxOn4Band(bb);
        boatpixel.putMeanValue(idxBand,(statistics[iBand][1] + statistics[iBand][2] + statistics[iBand][3]+ statistics[iBand][4]) / 4);
        boatpixel.putThresholdValue(idxBand,(threshWindowsVals[0] + threshWindowsVals[1] + threshWindowsVals[2]+ threshWindowsVals[3]) / 4);
        boatpixel.putMaxValue(idxBand,maxValue[iBand]);
        boatpixel.putStDevValue(idxBand,tileStdDev);
        double significance=(maxValue[iBand] - tileAvg) / tileStdDev;
        boatpixel.putSignificanceValue(idxBand,significance);
        boatpixel.putAvgValue(idxBand,tileAvg);
      }
      detPixels.listboatneighbours.add(boatpixel);
      List<int[]> boataggregatedpixels=new ArrayList<int[]>();
      int[] imagemap=new int[tilesize * tilesize];
      for (int i=0; i < tilesize * tilesize; i++) {
        imagemap[i]=0;
      }
      boolean result=detPixels.checkNeighbours(boataggregatedpixels,imagemap,data,thresholdvalues,new int[]{boatx,boaty},neighboursdistance,tilesize,rastermask);
      boatpixel.setTouchesLandMask(result);
      for (      int[] pixel : boataggregatedpixels) {
        boatpixel.addConnectedPixel(pixel[0] + cornerx,pixel[1] + cornery,pixel[2],pixel[3] == 1 ? true : false);
      }
    }
  }
  if (removelandconnectedpixels) {
    List<BoatConnectedPixelMap> toRemove=new ArrayList<BoatConnectedPixelMap>();
    for (int i=0; i < detPixels.listboatneighbours.size(); i++) {
      BoatConnectedPixelMap boat=detPixels.listboatneighbours.get(i);
      if (boat.touchesLand()) {
        toRemove.add(boat);
      }
    }
    detPixels.listboatneighbours.removeAll(toRemove);
  }
  detPixels.computeBoatsAttributesAndStatistics(detPixels.listboatneighbours);
}","/** 
 * aggregate using the neighbours within tilesize
 * @param neighboursdistance
 * @param tilesize
 * @param removelandconnectedpixels
 * @param bands
 * @param mask
 * @param kdist
 * @throws IOException
 */
private void aggregate(DetectedPixels detPixels,int neighboursdistance,int tilesize,boolean removelandconnectedpixels,int[] bands,IMask mask,KDistributionEstimation kdist) throws IOException {
  int id=0;
  Pixel pixels[]=detPixels.getAllDetectedPixelsValues().toArray(new Pixel[0]);
  int count=0;
  for (  Pixel detectedPix : pixels) {
    count++;
    int xx=detectedPix.x;
    int yy=detectedPix.y;
    if ((count % 100) == 0)     logger.info(new StringBuilder().append(""String_Node_Str"").append(count).append(""String_Node_Str"").append(xx).append(""String_Node_Str"").append(yy).toString());
    boolean checked=false;
    for (    BoatConnectedPixelMap boatpixel : detPixels.listboatneighbours) {
      if (boatpixel.containsPixel(xx,yy)) {
        checked=true;
        break;
      }
    }
    if (checked) {
      continue;
    }
    int cornerx=Math.min(Math.max(0,xx - tilesize / 2),gir.getWidth() - tilesize);
    int cornery=Math.min(Math.max(0,yy - tilesize / 2),gir.getHeight() - tilesize);
    int boatx=xx - cornerx;
    int boaty=yy - cornery;
    int numberbands=bands.length;
    int[][] data=new int[numberbands][];
    try {
      for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
        data[bandcounter]=gir.read(cornerx,cornery,tilesize,tilesize,bands[bandcounter]);
      }
    }
 catch (    IOException e) {
      logger.error(e.getMessage());
      throw e;
    }
    int row=(cornery + 1) / this.verTiles;
    int col=(cornerx + 1) / this.horTiles;
    double[][] statistics=AnalysisUtil.calculateImagemapStatistics(cornerx,cornery,tilesize,tilesize,row,col,bands,data,kdist);
    double[][] thresholdvalues=new double[numberbands][2];
    int[] maxValue=new int[numberbands];
    boolean pixelabove=false;
    for (int bandcounter=0; bandcounter < numberbands; bandcounter++) {
      double mean=(statistics[bandcounter][1] + statistics[bandcounter][2] + statistics[bandcounter][3]+ statistics[bandcounter][4]) / 4;
      thresholdvalues[bandcounter][0]=mean + 3 * mean * statistics[bandcounter][0];
      thresholdvalues[bandcounter][1]=mean + 5 * mean * statistics[bandcounter][0];
      int value=data[bandcounter][boatx + boaty * tilesize];
      if (value > thresholdvalues[bandcounter][1]) {
        pixelabove=true;
      }
      if (value > maxValue[bandcounter]) {
        maxValue[bandcounter]=data[bandcounter][boatx + boaty * tilesize];
      }
    }
    if (pixelabove) {
      Raster rastermask=null;
      if (mask != null) {
        if (mask.intersects(cornerx,cornery,tilesize,tilesize)) {
          rastermask=(mask.rasterize(cornerx,cornery,tilesize,tilesize,-cornerx,-cornery,1.0)).getData();
        }
      }
      BoatConnectedPixelMap boatpixel=new BoatConnectedPixelMap(cornerx,cornery,xx,yy,id++,data[0][boatx + boaty * tilesize]);
      for (int iBand=0; iBand < numberbands; iBand++) {
        String bb=((SarImageReader)gir).getBands()[iBand];
        float thresholdBand=this.thresholdsBandParams.get(bb);
        kdist.setImageData(cornerx,cornery,tilesize,tilesize,row,col,iBand);
        int[] newdata=gir.readTile(cornerx,cornery,tilesize,tilesize,iBand);
        kdist.estimate(rastermask,newdata);
        double[] treshTile=kdist.getDetectThresh();
        double threshTotal=treshTile[0] + treshTile[1] + treshTile[2]+ treshTile[3];
        double threshWindowsVals[]=AnalysisUtil.calcThreshWindowVals(thresholdBand,treshTile);
        double tileAvg=threshTotal / treshTile[5];
        double tileStdDev=treshTile[0] * threshTotal / treshTile[5];
        int idxBand=idxOn4Band(bb);
        boatpixel.putMeanValue(idxBand,(statistics[iBand][1] + statistics[iBand][2] + statistics[iBand][3]+ statistics[iBand][4]) / 4);
        boatpixel.putThresholdValue(idxBand,(threshWindowsVals[0] + threshWindowsVals[1] + threshWindowsVals[2]+ threshWindowsVals[3]) / 4);
        boatpixel.putMaxValue(idxBand,maxValue[iBand]);
        boatpixel.putStDevValue(idxBand,tileStdDev);
        double significance=(maxValue[iBand] - tileAvg) / tileStdDev;
        boatpixel.putSignificanceValue(idxBand,significance);
        boatpixel.putAvgValue(idxBand,tileAvg);
      }
      detPixels.listboatneighbours.add(boatpixel);
      List<int[]> boataggregatedpixels=new ArrayList<int[]>();
      int[] imagemap=new int[tilesize * tilesize];
      for (int i=0; i < tilesize * tilesize; i++) {
        imagemap[i]=0;
      }
      boolean result=detPixels.checkNeighbours(boataggregatedpixels,imagemap,data,thresholdvalues,new int[]{boatx,boaty},neighboursdistance,tilesize,rastermask);
      boatpixel.setTouchesLandMask(result);
      for (      int[] pixel : boataggregatedpixels) {
        boatpixel.addConnectedPixel(pixel[0] + cornerx,pixel[1] + cornery,pixel[2],pixel[3] == 1 ? true : false);
      }
    }
  }
  if (removelandconnectedpixels) {
    List<BoatConnectedPixelMap> toRemove=new ArrayList<BoatConnectedPixelMap>();
    for (int i=0; i < detPixels.listboatneighbours.size(); i++) {
      BoatConnectedPixelMap boat=detPixels.listboatneighbours.get(i);
      if (boat.touchesLand()) {
        toRemove.add(boat);
      }
    }
    detPixels.listboatneighbours.removeAll(toRemove);
  }
  detPixels.computeBoatsAttributesAndStatistics(detPixels.listboatneighbours);
}",0.9827838827838828
175195,"/** 
 * @param gir
 * @param mask
 * @param enlf
 * @param thresholdHH
 * @param thresholdHV
 * @param thresholdVH
 * @param thresholdVV
 * @param progressBar
 */
public VDSAnalysis(SarImageReader gir,IMask[] mask,float enlf,float thresholdHH,float thresholdHV,float thresholdVH,float thresholdVV){
  this.enl=""String_Node_Str"" + (int)(enlf * 10);
  if (this.enl.length() == 2) {
    this.enl=""String_Node_Str"" + this.enl;
  }
  thresholdsBandParams.put(""String_Node_Str"",thresholdHH);
  thresholdsBandParams.put(""String_Node_Str"",thresholdHV);
  thresholdsBandParams.put(""String_Node_Str"",thresholdVH);
  thresholdsBandParams.put(""String_Node_Str"",thresholdVV);
  this.gir=gir;
  this.mask=mask;
  this.tileSize=(int)(ConstantVDSAnalysis.TILESIZE / gir.getPixelsize()[0]);
  if (this.tileSize < ConstantVDSAnalysis.TILESIZEPIXELS)   this.tileSize=ConstantVDSAnalysis.TILESIZEPIXELS;
  this.verTiles=gir.getHeight() / this.tileSize;
  this.horTiles=gir.getWidth() / this.tileSize;
  progressListener=new ArrayList<ProgressListener>();
}","/** 
 * @param gir
 * @param mask
 * @param enlf
 * @param thresholdHH
 * @param thresholdHV
 * @param thresholdVH
 * @param thresholdVV
 * @param progressBar
 */
public VDSAnalysis(SarImageReader gir,IMask[] mask,float enlf,Map<String,Float> trhresholdMap){
  this.enl=""String_Node_Str"" + (int)(enlf * 10);
  if (this.enl.length() == 2) {
    this.enl=""String_Node_Str"" + this.enl;
  }
  this.thresholdsBandParams=trhresholdMap;
  this.gir=gir;
  this.mask=mask;
  this.tileSize=(int)(ConstantVDSAnalysis.TILESIZE / gir.getPixelsize()[0]);
  if (this.tileSize < ConstantVDSAnalysis.TILESIZEPIXELS)   this.tileSize=ConstantVDSAnalysis.TILESIZEPIXELS;
  this.verTiles=gir.getHeight() / this.tileSize;
  this.horTiles=gir.getWidth() / this.tileSize;
  progressListener=new ArrayList<ProgressListener>();
}",0.8200108754758021
175196,"/** 
 * run the analysis called from ActionDialog
 */
public boolean execute(String[] args){
  int bufferingDistance=Double.valueOf((Platform.getConfiguration()).getBufferingDistance()).intValue();
  Platform.getMain().addStopListener(this);
  if (args.length < 2) {
    return true;
  }
 else {
    if (args[0].equals(""String_Node_Str"")) {
      done=false;
      ImageLayer cl=Platform.getCurrentImageLayer();
      GeoImageReader reader=((ImageLayer)cl).getImageReader();
      if (reader instanceof SarImageReader || reader instanceof TiledBufferedImage) {
        gir=reader;
      }
      if (gir == null) {
        done=true;
        return false;
      }
      float thrHH=0;
      float thrHV=0;
      float thrVH=0;
      float thrVV=0;
      int numberofbands=gir.getNBand();
      for (int bb=0; bb < numberofbands; bb++) {
        if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thrHH=Float.parseFloat(args[bb + 1]);
        }
 else         if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thrHV=Float.parseFloat(args[bb + 1]);
        }
 else         if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thrVH=Float.parseFloat(args[bb + 1]);
        }
 else         if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thrVV=Float.parseFloat(args[bb + 1]);
        }
      }
      final float thresholdHH=thrHH;
      final float thresholdHV=thrHV;
      final float thresholdVH=thrVH;
      final float thresholdVV=thrVV;
      mask=new ArrayList<IMask>();
      for (      ILayer l : Platform.getLayerManager().getChilds(cl)) {
        if (l instanceof IMask & l.getName().startsWith(args[numberofbands + 1])) {
          mask.add((IMask)l);
        }
      }
      bufferingDistance=Integer.parseInt(args[numberofbands + 2]);
      final float ENL=Float.parseFloat(args[numberofbands + 3]);
      final IMask[] bufferedMask=new IMask[mask.size()];
      for (int i=0; i < mask.size(); i++) {
        IMask maskList=mask.get(i);
        bufferedMask[i]=FactoryLayer.createMaskLayer(maskList.getName(),maskList.getType(),bufferingDistance,((MaskVectorLayer)maskList).getGeometriclayer());
      }
      final VDSAnalysis analysis=new VDSAnalysis((SarImageReader)gir,bufferedMask,ENL,thresholdHH,thresholdHV,thresholdVH,thresholdVV);
      proc=new AnalysisProcess(reader,ENL,analysis,bufferedMask,bufferingDistance,0);
      proc.addProcessListener(this);
      Thread t=new Thread(proc);
      t.setName(""String_Node_Str"" + gir.getDisplayName(0));
      t.start();
    }
    return true;
  }
}","/** 
 * run the analysis called from ActionDialog
 */
public boolean execute(String[] args){
  int bufferingDistance=Double.valueOf((Platform.getConfiguration()).getBufferingDistance()).intValue();
  Platform.getMain().addStopListener(this);
  if (args.length < 2) {
    return true;
  }
 else {
    if (args[0].equals(""String_Node_Str"")) {
      done=false;
      ImageLayer cl=Platform.getCurrentImageLayer();
      GeoImageReader reader=((ImageLayer)cl).getImageReader();
      if (reader instanceof SarImageReader || reader instanceof TiledBufferedImage) {
        gir=reader;
      }
      if (gir == null) {
        done=true;
        return false;
      }
      java.util.HashMap<String,Float> thresholds=new java.util.HashMap<>();
      int numberofbands=gir.getNBand();
      thresholds.put(""String_Node_Str"",0.0f);
      thresholds.put(""String_Node_Str"",0.0f);
      thresholds.put(""String_Node_Str"",0.0f);
      thresholds.put(""String_Node_Str"",0.0f);
      for (int bb=0; bb < numberofbands; bb++) {
        if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thresholds.put(""String_Node_Str"",Float.parseFloat(args[bb + 1]));
        }
 else         if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thresholds.put(""String_Node_Str"",Float.parseFloat(args[bb + 1]));
        }
 else         if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thresholds.put(""String_Node_Str"",Float.parseFloat(args[bb + 1]));
        }
 else         if (gir.getBandName(bb).equals(""String_Node_Str"") || gir.getBandName(bb).equals(""String_Node_Str"")) {
          thresholds.put(""String_Node_Str"",Float.parseFloat(args[bb + 1]));
        }
      }
      mask=new ArrayList<IMask>();
      for (      ILayer l : Platform.getLayerManager().getChilds(cl)) {
        if (l instanceof IMask & l.getName().startsWith(args[numberofbands + 1])) {
          mask.add((IMask)l);
        }
      }
      bufferingDistance=Integer.parseInt(args[numberofbands + 2]);
      final float ENL=Float.parseFloat(args[numberofbands + 3]);
      final IMask[] bufferedMask=new IMask[mask.size()];
      for (int i=0; i < mask.size(); i++) {
        IMask maskList=mask.get(i);
        bufferedMask[i]=FactoryLayer.createMaskLayer(maskList.getName(),maskList.getType(),bufferingDistance,((MaskVectorLayer)maskList).getGeometriclayer());
      }
      final VDSAnalysis analysis=new VDSAnalysis((SarImageReader)gir,bufferedMask,ENL,thresholds);
      proc=new AnalysisProcess(reader,ENL,analysis,bufferedMask,bufferingDistance,0);
      proc.addProcessListener(this);
      Thread t=new Thread(proc);
      t.setName(""String_Node_Str"" + gir.getDisplayName(0));
      t.start();
    }
    return true;
  }
}",0.8636606665478525
175197,"/** 
 * run analysis for 1 image
 */
public void analizeImage(SarImageReader reader,IMask[] masks,AnalysisParams params){
  analysis=new VDSAnalysis(reader,masks,params.enl,params.thresholdArrayValues[0],params.thresholdArrayValues[1],params.thresholdArrayValues[2],params.thresholdArrayValues[3]);
  final String[] thresholds={""String_Node_Str"" + params.thresholdArrayValues[0],""String_Node_Str"" + params.thresholdArrayValues[1],""String_Node_Str"" + params.thresholdArrayValues[2],""String_Node_Str"" + params.thresholdArrayValues[3]};
  layerResults=runBatchAnalysis(reader,params.enl,analysis,masks,thresholds,params.buffer);
}","/** 
 * run analysis for 1 image
 */
public void analizeImage(SarImageReader reader,IMask[] masks,AnalysisParams params){
  java.util.HashMap<String,Float> thresholdsMap=new java.util.HashMap<>();
  thresholdsMap.put(""String_Node_Str"",params.thresholdArrayValues[0]);
  thresholdsMap.put(""String_Node_Str"",params.thresholdArrayValues[1]);
  thresholdsMap.put(""String_Node_Str"",params.thresholdArrayValues[2]);
  thresholdsMap.put(""String_Node_Str"",params.thresholdArrayValues[3]);
  analysis=new VDSAnalysis(reader,masks,params.enl,thresholdsMap);
  final String[] thresholds={""String_Node_Str"" + params.thresholdArrayValues[0],""String_Node_Str"" + params.thresholdArrayValues[1],""String_Node_Str"" + params.thresholdArrayValues[2],""String_Node_Str"" + params.thresholdArrayValues[3]};
  layerResults=runBatchAnalysis(reader,params.enl,analysis,masks,thresholds,params.buffer);
}",0.6706586826347305
175198,"/** 
 * in Matlab is reverse
 * @param lat
 * @param lon
 */
public abstract double[] pixelFromGeo(double lat,double lon) throws GeoLocationException ;","/** 
 * in Matlab is reverse
 * @param lat
 * @param lon
 */
public abstract double[] pixelFromGeo(double lon,double lat) throws GeoLocationException ;",0.9735099337748344
175199,"public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=36.950;
    double lon=-3.6315;
    double r[];
    try {
      r=gc.pixelFromGeo(55.55,-21.12);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
      r=gc.geoFromPixel(2907.080,19312.507);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}","public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=-27.49984;
    double lon=30.69116;
    double pixel=370.5;
    double line=16482.2;
    double r[];
    try {
      r=gc.geoFromPixel(line,pixel);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}",0.7862318840579711
175200,"/** 
 * @see In Matlab forwardgeolocation
 */
@Override public double[] geoFromPixel(final double l,final double p) throws GeoLocationException {
  try {
    double[] results=new double[2];
    double lon=0;
    double lat=0;
    double t0=0;
    int idxStartT0=0;
    if (meta.getType().equalsIgnoreCase(""String_Node_Str"") && meta.getProductType().equalsIgnoreCase(""String_Node_Str"") && (meta.getMode().equalsIgnoreCase(""String_Node_Str"") || meta.getMode().equalsIgnoreCase(""String_Node_Str""))) {
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    }
 else {
      double t01=(orbitInterpolation.getZeroDopplerTimeFirstRef()) * (meta.getNlines() - 1 - l);
      double t02=orbitInterpolation.getZeroDopplerTimeLastRef() * l;
      t0=(t01 + t02) / (meta.getNlines() - 1);
      for (idxStartT0=0; idxStartT0 < orbitInterpolation.getTimeStampInterp().size(); idxStartT0++) {
        if (orbitInterpolation.getTimeStampInterp().get(idxStartT0) >= t0) {
          break;
        }
      }
      if (idxStartT0 == statepVecInterp.size())       idxStartT0--;
    }
    final double[] pT0=statepVecInterp.get(idxStartT0);
    final double[] vT0=statevVecInterp.get(idxStartT0);
    double distance=0;
    if (meta.isPixelTimeOrderingAscending()) {
      distance=p * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
 else {
      distance=(meta.getNumberOfSamplesPerLine() - 1 - p) * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
    if (coordConv != null) {
      double zeroDopplerTime=t0;
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
      double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
      int index=0;
      for (      S1Metadata.CoordinateConversion cc : coordConv) {
        groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
        index++;
      }
      int idx=0;
      if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
        idx=1;
      }
 else       if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
        idx=groundToSlantRangePolyTimesSeconds.length - 2;
      }
 else {
        for (idx=groundToSlantRangePolyTimesSeconds.length - 1; idx > 0; idx--) {
          if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)           break;
        }
      }
      double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double[] groundToSlantRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].groundToSlantRangeCoefficients);
      double[] groundToSlantRangeCoefficientsInterp2=coordConv[idx + 1].groundToSlantRangeCoefficients;
      for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
        groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * groundToSlantRangeCoefficientsInterp[idCoeff] + factor2 * groundToSlantRangeCoefficientsInterp2[idCoeff];
      }
      double[] slantToGroundRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].slantToGroundRangeCoefficients);
      double[] slantToGroundRangeCoefficientsInterp2=coordConv[idx + 1].slantToGroundRangeCoefficients;
      for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
        slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * slantToGroundRangeCoefficientsInterp[idCoeff] + factor2 * slantToGroundRangeCoefficientsInterp2[idCoeff];
      }
      int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
      int[] vExps=new int[nCoeffs];
      for (int i=0; i < nCoeffs; i++) {
        vExps[i]=i;
      }
      double tmpD=distance - meta.getGroundRangeOrigin();
      double[] pows=MathUtil.powValue2Coeffs(tmpD,vExps);
      double sRdist=MathUtil.vectorProd1XN(groundToSlantRangeCoefficientsInterp,pows);
      logger.debug(""String_Node_Str"" + sRdist);
      double normPt0=MathUtil.norm(pT0);
      double vRadial=MathUtil.vectorProd1XN(vT0,pT0) / normPt0;
      double vTangential=FastMath.sqrt(FastMath.pow(MathUtil.norm(vT0),2) - FastMath.pow(vRadial,2));
      double tanPsi=vRadial / vTangential;
      double[] zsUnit=MathUtil.divVectByVal(pT0,-normPt0);
      double[] vTmp=MathUtil.crossProd3x3(zsUnit,vT0);
      double[] ysUnit=MathUtil.divVectByVal(vTmp,MathUtil.norm(vTmp));
      double[] xsUnit=MathUtil.crossProd3x3(ysUnit,zsUnit);
      double pH=0;
      double rEarth=normPt0 / FastMath.sqrt((pT0[0] * pT0[0] + pT0[1] * pT0[1]) / GeoUtils.semiMajorAxis2 + (pT0[2] * pT0[2]) / GeoUtils.semiMinorAxis2);
      for (int iidx=0; iidx < 2; iidx++) {
        rEarth=rEarth + pH;
        double rEarthOld=rEarth;
        double rEarthChange=100000;
        double[] q=new double[3];
        for (; rEarthChange > 0.1; ) {
          double Rz=(normPt0 * normPt0 + sRdist * sRdist - rEarth * rEarth) / (2 * normPt0);
          double Rx=Rz * tanPsi;
          double Ry=FastMath.sqrt(sRdist * sRdist - Rz * Rz - Rx * Rx);
          if (!meta.getAntennaPointing().equalsIgnoreCase(""String_Node_Str"")) {
            Ry=-Ry;
          }
          double[][] sRvect=new double[][]{{Rx},{Ry},{Rz - normPt0}};
          double[][] qbig=new double[][]{xsUnit,ysUnit,zsUnit};
          qbig=MathUtil.transpose(qbig);
          double[][] qmat=MathUtil.multiplyMatrix(qbig,sRvect);
          q[0]=qmat[0][0];
          q[1]=qmat[1][0];
          q[2]=qmat[2][0];
          rEarth=MathUtil.norm(q) / FastMath.sqrt((q[0] * q[0] + q[1] * q[1]) / GeoUtils.semiMajorAxis2 + (q[2] * q[2] / GeoUtils.semiMinorAxis2)) + pH;
          rEarthChange=FastMath.abs(rEarth - rEarthOld);
          rEarthOld=rEarth;
        }
        lon=FastMath.atan2(q[1],q[0]) * 180 / FastMath.PI;
        double lattmp=FastMath.asin(q[2] / FastMath.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]));
        lat=FastMath.atan(FastMath.tan(lattmp) * FastMath.pow((GeoUtils.semiMajorAxis + pH),2) / FastMath.pow((GeoUtils.semiMinorAxis + pH),2)) * 180 / FastMath.PI;
        pH=GeoUtils.getGeoidH(lon,lat);
      }
    }
    logger.debug(""String_Node_Str"" + lat + ""String_Node_Str""+ lon);
    results[0]=lon;
    results[1]=lat;
    return results;
  }
 catch (  MathException me) {
    throw new GeoLocationException(GeoLocationException.MSG_CONV_FROM_PIXEL_TO_GEO + ""String_Node_Str"" + me.getMessage());
  }
}","/** 
 * @see In Matlab forwardgeolocation
 */
@Override public double[] geoFromPixel(final double l,final double p) throws GeoLocationException {
  try {
    double[] results=new double[2];
    double lon=0;
    double lat=0;
    double t0=0;
    int idxStartT0=0;
    if (meta.getType().equalsIgnoreCase(""String_Node_Str"") && meta.getProductType().equalsIgnoreCase(""String_Node_Str"") && (meta.getMode().equalsIgnoreCase(""String_Node_Str"") || meta.getMode().equalsIgnoreCase(""String_Node_Str""))) {
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    }
 else {
      double t01=(orbitInterpolation.getZeroDopplerTimeFirstRef()) * (meta.getNlines() - 1 - l);
      double t02=orbitInterpolation.getZeroDopplerTimeLastRef() * l;
      t0=(t01 + t02) / (meta.getNlines() - 1);
      for (idxStartT0=0; idxStartT0 < orbitInterpolation.getTimeStampInterp().size(); idxStartT0++) {
        if (orbitInterpolation.getTimeStampInterp().get(idxStartT0) >= t0) {
          break;
        }
      }
      if (idxStartT0 == statepVecInterp.size())       idxStartT0--;
    }
    final double[] pT0=statepVecInterp.get(idxStartT0);
    final double[] vT0=statevVecInterp.get(idxStartT0);
    double distance=0;
    if (meta.isPixelTimeOrderingAscending()) {
      distance=p * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
 else {
      distance=(meta.getNumberOfSamplesPerLine() - 1 - p) * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
    if (coordConv != null) {
      double zeroDopplerTime=t0;
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
      double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
      int index=0;
      for (      S1Metadata.CoordinateConversion cc : coordConv) {
        groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
        index++;
      }
      int idx=0;
      if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
        idx=1;
      }
 else       if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
        idx=groundToSlantRangePolyTimesSeconds.length - 2;
      }
 else {
        for (idx=groundToSlantRangePolyTimesSeconds.length - 1; idx > 0; idx--) {
          if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)           break;
        }
      }
      double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double[] groundToSlantRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].groundToSlantRangeCoefficients);
      double[] groundToSlantRangeCoefficientsInterp2=coordConv[idx + 1].groundToSlantRangeCoefficients;
      for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
        groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * groundToSlantRangeCoefficientsInterp[idCoeff] + factor2 * groundToSlantRangeCoefficientsInterp2[idCoeff];
      }
      double[] slantToGroundRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].slantToGroundRangeCoefficients);
      double[] slantToGroundRangeCoefficientsInterp2=coordConv[idx + 1].slantToGroundRangeCoefficients;
      for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
        slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * slantToGroundRangeCoefficientsInterp[idCoeff] + factor2 * slantToGroundRangeCoefficientsInterp2[idCoeff];
      }
      int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
      int[] vExps=new int[nCoeffs];
      for (int i=0; i < nCoeffs; i++) {
        vExps[i]=i;
      }
      double tmpD=distance - meta.getGroundRangeOrigin();
      double[] pows=MathUtil.powValue2Coeffs(tmpD,vExps);
      double sRdist=MathUtil.dot(groundToSlantRangeCoefficientsInterp,pows);
      logger.debug(""String_Node_Str"" + sRdist);
      double normPt0=MathUtil.norm(pT0);
      double vRadial=MathUtil.dot(vT0,pT0) / normPt0;
      double vTangential=FastMath.sqrt(FastMath.pow(MathUtil.norm(vT0),2) - FastMath.pow(vRadial,2));
      double tanPsi=vRadial / vTangential;
      double[] zsUnit=MathUtil.divVectByVal(pT0,-normPt0);
      double[] vTmp=MathUtil.crossProd3x3(zsUnit,vT0);
      double[] ysUnit=MathUtil.divVectByVal(vTmp,MathUtil.norm(vTmp));
      double[] xsUnit=MathUtil.crossProd3x3(ysUnit,zsUnit);
      double pH=0;
      double rEarth=normPt0 / FastMath.sqrt((pT0[0] * pT0[0] + pT0[1] * pT0[1]) / GeoUtils.semiMajorAxis2 + (pT0[2] * pT0[2]) / GeoUtils.semiMinorAxis2);
      for (int iidx=0; iidx < 2; iidx++) {
        rEarth=rEarth + pH;
        double rEarthOld=rEarth;
        double rEarthChange=100000;
        double[] q=new double[3];
        for (; rEarthChange > 0.1; ) {
          double Rz=(normPt0 * normPt0 + sRdist * sRdist - rEarth * rEarth) / (2 * normPt0);
          double Rx=Rz * tanPsi;
          double Ry=FastMath.sqrt(sRdist * sRdist - Rz * Rz - Rx * Rx);
          if (!meta.getAntennaPointing().equalsIgnoreCase(""String_Node_Str"")) {
            Ry=-Ry;
          }
          double[][] sRvect=new double[][]{{Rx},{Ry},{Rz - normPt0}};
          double[][] qbig=new double[][]{xsUnit,ysUnit,zsUnit};
          qbig=MathUtil.transpose(qbig);
          double[][] qmat=MathUtil.multiplyMatrix(qbig,sRvect);
          q[0]=qmat[0][0];
          q[1]=qmat[1][0];
          q[2]=qmat[2][0];
          rEarth=MathUtil.norm(q) / FastMath.sqrt((q[0] * q[0] + q[1] * q[1]) / GeoUtils.semiMajorAxis2 + (q[2] * q[2] / GeoUtils.semiMinorAxis2)) + pH;
          rEarthChange=FastMath.abs(rEarth - rEarthOld);
          rEarthOld=rEarth;
        }
        lon=FastMath.atan2(q[1],q[0]) * 180 / FastMath.PI;
        double lattmp=FastMath.asin(q[2] / FastMath.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]));
        lat=FastMath.atan(FastMath.tan(lattmp) * FastMath.pow((GeoUtils.semiMajorAxis + pH),2) / FastMath.pow((GeoUtils.semiMinorAxis + pH),2)) * 180 / FastMath.PI;
        pH=GeoUtils.getGeoidH(lon,lat);
      }
    }
    logger.debug(""String_Node_Str"" + lat + ""String_Node_Str""+ lon);
    results[0]=lon;
    results[1]=lat;
    return results;
  }
 catch (  MathException me) {
    throw new GeoLocationException(GeoLocationException.MSG_CONV_FROM_PIXEL_TO_GEO + ""String_Node_Str"" + me.getMessage());
  }
}",0.9976083707025412
175201,"/** 
 * @param subTimesDiffRef : valori delle differenze tra i tempi e il timeref per i punti che mi interessano . Li uso per calcolare l'incremento medio (periodo di campionamento)
 * @throws MathException 
 */
public static void interpolation(double[] subTimesDiffRef,List<S1Metadata.OrbitStatePosVelox> vpList,Double timeStampInitSecondsRefPointsInterp[],int idxInitTime,int idxEndTime,double deltaT,List<double[]> interpPpointsOutput,List<double[]> interpVpointsOutput,List<Double> timeStampInterpSecondsRefOutput) throws MathException {
  int nPoints=subTimesDiffRef.length;
  double[][] hermiteMatrix=hermiteMatrix(nPoints);
  hermiteMatrix=invertMatrix(hermiteMatrix);
  double meanTimeRef=1;
  int m=vpList.size();
  int n=3;
  double[][] state=new double[2 * m][n];
  for (int i=0; i < 2 * m; i+=2) {
    OrbitStatePosVelox obj=vpList.get(i / 2);
    state[i][0]=obj.px;
    state[i][1]=obj.py;
    state[i][2]=obj.pz;
    state[i + 1][0]=obj.vx * meanTimeRef;
    state[i + 1][1]=obj.vy * meanTimeRef;
    state[i + 1][2]=obj.vz * meanTimeRef;
  }
  double[] interTime=new double[timeStampInitSecondsRefPointsInterp.length];
  int index=0;
  for (  double v : timeStampInitSecondsRefPointsInterp) {
    interTime[index]=v / meanTimeRef;
    index++;
  }
  int powerMax=2 * m - 1;
  double[][] vTmpPos=MathUtil.multiplyMatrix(hermiteMatrix,state);
  double[][] vTmpVel=new double[2 * m][n];
  for (int i=0; i < 2 * m; i++) {
    for (int j=0; j < n; j++) {
      vTmpVel[i][j]=vTmpPos[i][j] / meanTimeRef;
    }
  }
  for (int idx=idxInitTime; idx <= idxEndTime; idx++) {
    double[][] ptvec=new double[1][powerMax + 1];
    double[][] vtvec=new double[1][powerMax + 1];
    for (int i=0; i <= powerMax; i++) {
      ptvec[0][i]=FastMath.pow(interTime[idx],powerMax - i);
      vtvec[0][i]=FastMath.pow((interTime[idx]),FastMath.abs(i - 1));
    }
    for (int i=0; i <= powerMax; i++) {
      vtvec[0][powerMax - i]=i * vtvec[0][i];
    }
    interpPpointsOutput.add(idx - idxInitTime,MathUtil.multiplyMatrix(ptvec,vTmpPos)[0]);
    interpVpointsOutput.add(idx - idxInitTime,MathUtil.multiplyMatrix(vtvec,vTmpVel)[0]);
    timeStampInterpSecondsRefOutput.add(idx - idxInitTime,timeStampInitSecondsRefPointsInterp[idx]);
  }
}","/** 
 * @param subTimesDiffRef : valori delle differenze tra i tempi e il timeref per i punti che mi interessano . Li uso per calcolare l'incremento medio (periodo di campionamento)
 * @throws MathException 
 */
public static void interpolation(double[] subTimesDiffRef,List<S1Metadata.OrbitStatePosVelox> vpList,Double timeStampInitSecondsRefPointsInterp[],int idxInitTime,int idxEndTime,double deltaT,List<double[]> interpPpointsOutput,List<double[]> interpVpointsOutput,List<Double> timeStampInterpSecondsRefOutput) throws MathException {
  int nPoints=subTimesDiffRef.length;
  double[][] hermiteMatrix=hermiteMatrix(nPoints);
  hermiteMatrix=invertMatrix(hermiteMatrix);
  double meanTimeRef=1;
  int m=vpList.size();
  int n=3;
  double[][] state=new double[2 * m][n];
  for (int i=0; i < 2 * m; i+=2) {
    OrbitStatePosVelox obj=vpList.get(i / 2);
    state[i][0]=obj.px;
    state[i][1]=obj.py;
    state[i][2]=obj.pz;
    state[i + 1][0]=obj.vx * meanTimeRef;
    state[i + 1][1]=obj.vy * meanTimeRef;
    state[i + 1][2]=obj.vz * meanTimeRef;
  }
  double[] interTime=new double[timeStampInitSecondsRefPointsInterp.length];
  int index=0;
  for (  double v : timeStampInitSecondsRefPointsInterp) {
    interTime[index]=v / meanTimeRef;
    index++;
  }
  int powerMax=2 * m - 1;
  double[][] vTmpPos=MathUtil.multiplyMatrix(hermiteMatrix,state);
  double[][] vTmpVel=new double[2 * m][n];
  for (int i=0; i < 2 * m; i++) {
    for (int j=0; j < n; j++) {
      vTmpVel[i][j]=vTmpPos[i][j] / meanTimeRef;
    }
  }
  for (int idx=idxInitTime; idx <= idxEndTime; idx++) {
    double[][] ptvec=new double[1][powerMax + 1];
    double[][] vtvec=new double[1][powerMax + 1];
    for (int i=0; i <= powerMax; i++) {
      ptvec[0][i]=FastMath.pow(interTime[idx],powerMax - i);
      vtvec[0][i]=FastMath.pow((interTime[idx]),FastMath.abs(powerMax - i - 1));
    }
    for (int i=0; i <= powerMax; i++) {
      vtvec[0][powerMax - i]=i * vtvec[0][i];
    }
    interpPpointsOutput.add(idx - idxInitTime,MathUtil.multiplyMatrix(ptvec,vTmpPos)[0]);
    interpVpointsOutput.add(idx - idxInitTime,MathUtil.multiplyMatrix(vtvec,vTmpVel)[0]);
    timeStampInterpSecondsRefOutput.add(idx - idxInitTime,timeStampInitSecondsRefPointsInterp[idx]);
  }
}",0.997546285969217
175202,"/** 
 * AG inserted a test to filter boats by length
 * @param list
 */
protected void computeBoatsAttributesAndStatistics(List<BoatConnectedPixelMap> list){
  List<Boat> boatsTemp=new ArrayList<Boat>();
  for (  BoatConnectedPixelMap boatPxMap : list) {
    boatPxMap.computeValues(pixsam,pixrec);
    if (boatPxMap.getBoatlength() > this.filterminSize && boatPxMap.getBoatlength() < this.filtermaxSize) {
      Boat b=new Boat(boatPxMap.getId(),(int)boatPxMap.getBoatposition()[0],(int)boatPxMap.getBoatposition()[1],(int)boatPxMap.getBoatnumberofpixels(),(int)boatPxMap.getBoatlength(),(int)boatPxMap.getBoatwidth(),(int)boatPxMap.getBoatheading());
      List<Double> thresholdsTile=boatPxMap.getThresholdValue();
      double max=boatPxMap.getMaximumValue();
      for (      Double t : thresholdsTile) {
      }
      boatsTemp.add(b);
    }
  }
  boatsTemp.clear();
  boatsTemp=sortBoats(boatsTemp);
  boatArray=boatsTemp.toArray(new Boat[0]);
}","/** 
 * AG inserted a test to filter boats by length
 * @param list
 */
protected void computeBoatsAttributesAndStatistics(List<BoatConnectedPixelMap> list){
  List<Boat> boatsTemp=new ArrayList<Boat>();
  for (  BoatConnectedPixelMap boatPxMap : list) {
    boatPxMap.computeValues(pixsam,pixrec);
    if (boatPxMap.getBoatlength() > this.filterminSize && boatPxMap.getBoatlength() < this.filtermaxSize) {
      Boat b=new Boat(boatPxMap.getId(),(int)boatPxMap.getBoatposition()[0],(int)boatPxMap.getBoatposition()[1],(int)boatPxMap.getBoatnumberofpixels(),(int)boatPxMap.getBoatlength(),(int)boatPxMap.getBoatwidth(),(int)boatPxMap.getBoatheading());
      List<Double> thresholdsTile=boatPxMap.getThresholdValue();
      double max=boatPxMap.getMaximumValue();
      for (      Double t : thresholdsTile) {
      }
      boatsTemp.add(b);
    }
  }
  boatsTemp=sortBoats(boatsTemp);
  boatArray=boatsTemp.toArray(new Boat[0]);
}",0.9888475836431226
175203,"public static void renderCross(OpenGLContext context,float zoomWidth,float zoomHeight,List<Geometry> geometries,Geometry selectedGeometry,float renderWidth,Color color){
  GL2 gl=context.getGL().getGL2();
  float[] c=color.brighter().getColorComponents(null);
  gl.glColor3f(c[0],c[1],c[2]);
  for (  Geometry temp : geometries) {
    gl.glLineWidth(temp == selectedGeometry ? renderWidth * 2 : renderWidth);
    Coordinate point=new Coordinate(temp.getCoordinate());
    point.x=(point.x - context.getX()) / zoomWidth;
    point.y=1 - (point.y - context.getY()) / zoomHeight;
    double rectwidth=0.01;
    gl.glBegin(GL.GL_LINE_STRIP);
    gl.glVertex2d(point.x - rectwidth,point.y);
    gl.glVertex2d(point.x + rectwidth,point.y);
    gl.glEnd();
    gl.glBegin(GL.GL_LINE_STRIP);
    gl.glVertex2d(point.x,point.y - rectwidth);
    gl.glVertex2d(point.x,point.y + rectwidth);
    gl.glEnd();
    gl.glFlush();
  }
}","public static void renderCross(OpenGLContext context,float zoomWidth,float zoomHeight,List<Geometry> geometries,Geometry selectedGeometry,float renderWidth,Color color){
  GL2 gl=context.getGL().getGL2();
  float[] c=color.brighter().getColorComponents(null);
  gl.glColor3f(c[0],c[1],c[2]);
  if (geometries != null) {
    for (    Geometry temp : geometries) {
      gl.glLineWidth(temp == selectedGeometry ? renderWidth * 2 : renderWidth);
      Coordinate point=new Coordinate(temp.getCoordinate());
      point.x=(point.x - context.getX()) / zoomWidth;
      point.y=1 - (point.y - context.getY()) / zoomHeight;
      double rectwidth=0.01;
      gl.glBegin(GL.GL_LINE_STRIP);
      gl.glVertex2d(point.x - rectwidth,point.y);
      gl.glVertex2d(point.x + rectwidth,point.y);
      gl.glEnd();
      gl.glBegin(GL.GL_LINE_STRIP);
      gl.glVertex2d(point.x,point.y - rectwidth);
      gl.glVertex2d(point.x,point.y + rectwidth);
      gl.glEnd();
      gl.glFlush();
    }
  }
}",0.9611344537815126
175204,"public static void renderTriangle(OpenGLContext context,float zoomWidth,float zoomHeight,List<Geometry> geometries,Geometry selectedGeometry,float renderWidth,Color color){
  GL2 gl=context.getGL().getGL2();
  float[] c=color.brighter().getColorComponents(null);
  gl.glColor3f(c[0],c[1],c[2]);
  for (  Geometry temp : geometries) {
    gl.glLineWidth(temp == selectedGeometry ? renderWidth * 2 : renderWidth);
    Coordinate point=new Coordinate(temp.getCoordinate());
    point.x=(point.x - context.getX()) / zoomWidth;
    point.y=1 - (point.y - context.getY()) / zoomHeight;
    double rectwidth=0.01;
    gl.glBegin(GL.GL_LINE_STRIP);
    gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
    gl.glVertex2d(point.x,point.y + rectwidth);
    gl.glVertex2d(point.x + rectwidth,point.y - rectwidth);
    gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
    gl.glEnd();
    gl.glFlush();
  }
}","public static void renderTriangle(OpenGLContext context,float zoomWidth,float zoomHeight,List<Geometry> geometries,Geometry selectedGeometry,float renderWidth,Color color){
  GL2 gl=context.getGL().getGL2();
  float[] c=color.brighter().getColorComponents(null);
  gl.glColor3f(c[0],c[1],c[2]);
  if (geometries != null) {
    for (    Geometry temp : geometries) {
      gl.glLineWidth(temp == selectedGeometry ? renderWidth * 2 : renderWidth);
      Coordinate point=new Coordinate(temp.getCoordinate());
      point.x=(point.x - context.getX()) / zoomWidth;
      point.y=1 - (point.y - context.getY()) / zoomHeight;
      double rectwidth=0.01;
      gl.glBegin(GL.GL_LINE_STRIP);
      gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
      gl.glVertex2d(point.x,point.y + rectwidth);
      gl.glVertex2d(point.x + rectwidth,point.y - rectwidth);
      gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
      gl.glEnd();
      gl.glFlush();
    }
  }
}",0.9627263045793396
175205,"/** 
 * in Matlab is reverse
 * @param lat
 * @param lon
 */
public abstract double[] pixelFromGeo(double lat,double lon) throws GeoLocationException ;","/** 
 * in Matlab is reverse
 * @param lat
 * @param lon
 */
public abstract double[] pixelFromGeo(double lon,double lat) throws GeoLocationException ;",0.9735099337748344
175206,"public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=36.950;
    double lon=-3.6315;
    double r[];
    try {
      r=gc.pixelFromGeo(55.55,-21.12);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
      r=gc.geoFromPixel(2907.080,19312.507);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}","public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=-27.49984;
    double lon=30.69116;
    double pixel=370.5;
    double line=16482.2;
    double r[];
    try {
      r=gc.geoFromPixel(line,pixel);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}",0.7862318840579711
175207,"/** 
 * @see In Matlab forwardgeolocation
 */
@Override public double[] geoFromPixel(final double l,final double p) throws GeoLocationException {
  try {
    double[] results=new double[2];
    double lon=0;
    double lat=0;
    double t0=0;
    int idxStartT0=0;
    if (meta.getType().equalsIgnoreCase(""String_Node_Str"") && meta.getProductType().equalsIgnoreCase(""String_Node_Str"") && (meta.getMode().equalsIgnoreCase(""String_Node_Str"") || meta.getMode().equalsIgnoreCase(""String_Node_Str""))) {
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    }
 else {
      double t01=(orbitInterpolation.getZeroDopplerTimeFirstRef()) * (meta.getNlines() - 1 - l);
      double t02=orbitInterpolation.getZeroDopplerTimeLastRef() * l;
      t0=(t01 + t02) / (meta.getNlines() - 1);
      for (idxStartT0=0; idxStartT0 < orbitInterpolation.getTimeStampInterp().size(); idxStartT0++) {
        if (orbitInterpolation.getTimeStampInterp().get(idxStartT0) >= t0) {
          break;
        }
      }
      if (idxStartT0 == statepVecInterp.size())       idxStartT0--;
    }
    final double[] pT0=statepVecInterp.get(idxStartT0);
    final double[] vT0=statevVecInterp.get(idxStartT0);
    double distance=0;
    if (meta.isPixelTimeOrderingAscending()) {
      distance=p * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
 else {
      distance=(meta.getNumberOfSamplesPerLine() - 1 - p) * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
    if (coordConv != null) {
      double zeroDopplerTime=t0;
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
      double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
      int index=0;
      for (      S1Metadata.CoordinateConversion cc : coordConv) {
        groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
        index++;
      }
      int idx=0;
      if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
        idx=1;
      }
 else       if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
        idx=groundToSlantRangePolyTimesSeconds.length - 2;
      }
 else {
        for (idx=groundToSlantRangePolyTimesSeconds.length - 1; idx > 0; idx--) {
          if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)           break;
        }
      }
      double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double[] groundToSlantRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].groundToSlantRangeCoefficients);
      double[] groundToSlantRangeCoefficientsInterp2=coordConv[idx + 1].groundToSlantRangeCoefficients;
      for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
        groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * groundToSlantRangeCoefficientsInterp[idCoeff] + factor2 * groundToSlantRangeCoefficientsInterp2[idCoeff];
      }
      double[] slantToGroundRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].slantToGroundRangeCoefficients);
      double[] slantToGroundRangeCoefficientsInterp2=coordConv[idx + 1].slantToGroundRangeCoefficients;
      for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
        slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * slantToGroundRangeCoefficientsInterp[idCoeff] + factor2 * slantToGroundRangeCoefficientsInterp2[idCoeff];
      }
      int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
      int[] vExps=new int[nCoeffs];
      for (int i=0; i < nCoeffs; i++) {
        vExps[i]=i;
      }
      double tmpD=distance - meta.getGroundRangeOrigin();
      double[] pows=MathUtil.powValue2Coeffs(tmpD,vExps);
      double sRdist=MathUtil.vectorProd1XN(groundToSlantRangeCoefficientsInterp,pows);
      logger.debug(""String_Node_Str"" + sRdist);
      double normPt0=MathUtil.norm(pT0);
      double vRadial=MathUtil.vectorProd1XN(vT0,pT0) / normPt0;
      double vTangential=FastMath.sqrt(FastMath.pow(MathUtil.norm(vT0),2) - FastMath.pow(vRadial,2));
      double tanPsi=vRadial / vTangential;
      double[] zsUnit=MathUtil.divVectByVal(pT0,-normPt0);
      double[] vTmp=MathUtil.crossProd3x3(zsUnit,vT0);
      double[] ysUnit=MathUtil.divVectByVal(vTmp,MathUtil.norm(vTmp));
      double[] xsUnit=MathUtil.crossProd3x3(ysUnit,zsUnit);
      double pH=0;
      double rEarth=normPt0 / FastMath.sqrt((pT0[0] * pT0[0] + pT0[1] * pT0[1]) / GeoUtils.semiMajorAxis2 + (pT0[2] * pT0[2]) / GeoUtils.semiMinorAxis2);
      for (int iidx=0; iidx < 2; iidx++) {
        rEarth=rEarth + pH;
        double rEarthOld=rEarth;
        double rEarthChange=100000;
        double[] q=new double[3];
        for (; rEarthChange > 0.1; ) {
          double Rz=(normPt0 * normPt0 + sRdist * sRdist - rEarth * rEarth) / (2 * normPt0);
          double Rx=Rz * tanPsi;
          double Ry=FastMath.sqrt(sRdist * sRdist - Rz * Rz - Rx * Rx);
          if (!meta.getAntennaPointing().equalsIgnoreCase(""String_Node_Str"")) {
            Ry=-Ry;
          }
          double[][] sRvect=new double[][]{{Rx},{Ry},{Rz - normPt0}};
          double[][] qbig=new double[][]{xsUnit,ysUnit,zsUnit};
          qbig=MathUtil.transpose(qbig);
          double[][] qmat=MathUtil.multiplyMatrix(qbig,sRvect);
          q[0]=qmat[0][0];
          q[1]=qmat[1][0];
          q[2]=qmat[2][0];
          rEarth=MathUtil.norm(q) / FastMath.sqrt((q[0] * q[0] + q[1] * q[1]) / GeoUtils.semiMajorAxis2 + (q[2] * q[2] / GeoUtils.semiMinorAxis2)) + pH;
          rEarthChange=FastMath.abs(rEarth - rEarthOld);
          rEarthOld=rEarth;
        }
        lon=FastMath.atan2(q[1],q[0]) * 180 / FastMath.PI;
        double lattmp=FastMath.asin(q[2] / FastMath.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]));
        lat=FastMath.atan(FastMath.tan(lattmp) * FastMath.pow((GeoUtils.semiMajorAxis + pH),2) / FastMath.pow((GeoUtils.semiMinorAxis + pH),2)) * 180 / FastMath.PI;
        pH=GeoUtils.getGeoidH(lon,lat);
      }
    }
    logger.debug(""String_Node_Str"" + lat + ""String_Node_Str""+ lon);
    results[0]=lon;
    results[1]=lat;
    return results;
  }
 catch (  MathException me) {
    throw new GeoLocationException(GeoLocationException.MSG_CONV_FROM_PIXEL_TO_GEO + ""String_Node_Str"" + me.getMessage());
  }
}","/** 
 * @see In Matlab forwardgeolocation
 */
@Override public double[] geoFromPixel(final double l,final double p) throws GeoLocationException {
  try {
    double[] results=new double[2];
    double lon=0;
    double lat=0;
    double t0=0;
    int idxStartT0=0;
    if (meta.getType().equalsIgnoreCase(""String_Node_Str"") && meta.getProductType().equalsIgnoreCase(""String_Node_Str"") && (meta.getMode().equalsIgnoreCase(""String_Node_Str"") || meta.getMode().equalsIgnoreCase(""String_Node_Str""))) {
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    }
 else {
      double t01=(orbitInterpolation.getZeroDopplerTimeFirstRef()) * (meta.getNlines() - 1 - l);
      double t02=orbitInterpolation.getZeroDopplerTimeLastRef() * l;
      t0=(t01 + t02) / (meta.getNlines() - 1);
      for (idxStartT0=0; idxStartT0 < orbitInterpolation.getTimeStampInterp().size(); idxStartT0++) {
        if (orbitInterpolation.getTimeStampInterp().get(idxStartT0) >= t0) {
          break;
        }
      }
      if (idxStartT0 == statepVecInterp.size())       idxStartT0--;
    }
    final double[] pT0=statepVecInterp.get(idxStartT0);
    final double[] vT0=statevVecInterp.get(idxStartT0);
    double distance=0;
    if (meta.isPixelTimeOrderingAscending()) {
      distance=p * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
 else {
      distance=(meta.getNumberOfSamplesPerLine() - 1 - p) * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
    if (coordConv != null) {
      double zeroDopplerTime=t0;
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
      double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
      int index=0;
      for (      S1Metadata.CoordinateConversion cc : coordConv) {
        groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
        index++;
      }
      int idx=0;
      if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
        idx=1;
      }
 else       if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
        idx=groundToSlantRangePolyTimesSeconds.length - 2;
      }
 else {
        for (idx=groundToSlantRangePolyTimesSeconds.length - 1; idx > 0; idx--) {
          if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)           break;
        }
      }
      double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double[] groundToSlantRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].groundToSlantRangeCoefficients);
      double[] groundToSlantRangeCoefficientsInterp2=coordConv[idx + 1].groundToSlantRangeCoefficients;
      for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
        groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * groundToSlantRangeCoefficientsInterp[idCoeff] + factor2 * groundToSlantRangeCoefficientsInterp2[idCoeff];
      }
      double[] slantToGroundRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].slantToGroundRangeCoefficients);
      double[] slantToGroundRangeCoefficientsInterp2=coordConv[idx + 1].slantToGroundRangeCoefficients;
      for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
        slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * slantToGroundRangeCoefficientsInterp[idCoeff] + factor2 * slantToGroundRangeCoefficientsInterp2[idCoeff];
      }
      int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
      int[] vExps=new int[nCoeffs];
      for (int i=0; i < nCoeffs; i++) {
        vExps[i]=i;
      }
      double tmpD=distance - meta.getGroundRangeOrigin();
      double[] pows=MathUtil.powValue2Coeffs(tmpD,vExps);
      double sRdist=MathUtil.dot(groundToSlantRangeCoefficientsInterp,pows);
      logger.debug(""String_Node_Str"" + sRdist);
      double normPt0=MathUtil.norm(pT0);
      double vRadial=MathUtil.dot(vT0,pT0) / normPt0;
      double vTangential=FastMath.sqrt(FastMath.pow(MathUtil.norm(vT0),2) - FastMath.pow(vRadial,2));
      double tanPsi=vRadial / vTangential;
      double[] zsUnit=MathUtil.divVectByVal(pT0,-normPt0);
      double[] vTmp=MathUtil.crossProd3x3(zsUnit,vT0);
      double[] ysUnit=MathUtil.divVectByVal(vTmp,MathUtil.norm(vTmp));
      double[] xsUnit=MathUtil.crossProd3x3(ysUnit,zsUnit);
      double pH=0;
      double rEarth=normPt0 / FastMath.sqrt((pT0[0] * pT0[0] + pT0[1] * pT0[1]) / GeoUtils.semiMajorAxis2 + (pT0[2] * pT0[2]) / GeoUtils.semiMinorAxis2);
      for (int iidx=0; iidx < 2; iidx++) {
        rEarth=rEarth + pH;
        double rEarthOld=rEarth;
        double rEarthChange=100000;
        double[] q=new double[3];
        for (; rEarthChange > 0.1; ) {
          double Rz=(normPt0 * normPt0 + sRdist * sRdist - rEarth * rEarth) / (2 * normPt0);
          double Rx=Rz * tanPsi;
          double Ry=FastMath.sqrt(sRdist * sRdist - Rz * Rz - Rx * Rx);
          if (!meta.getAntennaPointing().equalsIgnoreCase(""String_Node_Str"")) {
            Ry=-Ry;
          }
          double[][] sRvect=new double[][]{{Rx},{Ry},{Rz - normPt0}};
          double[][] qbig=new double[][]{xsUnit,ysUnit,zsUnit};
          qbig=MathUtil.transpose(qbig);
          double[][] qmat=MathUtil.multiplyMatrix(qbig,sRvect);
          q[0]=qmat[0][0];
          q[1]=qmat[1][0];
          q[2]=qmat[2][0];
          rEarth=MathUtil.norm(q) / FastMath.sqrt((q[0] * q[0] + q[1] * q[1]) / GeoUtils.semiMajorAxis2 + (q[2] * q[2] / GeoUtils.semiMinorAxis2)) + pH;
          rEarthChange=FastMath.abs(rEarth - rEarthOld);
          rEarthOld=rEarth;
        }
        lon=FastMath.atan2(q[1],q[0]) * 180 / FastMath.PI;
        double lattmp=FastMath.asin(q[2] / FastMath.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]));
        lat=FastMath.atan(FastMath.tan(lattmp) * FastMath.pow((GeoUtils.semiMajorAxis + pH),2) / FastMath.pow((GeoUtils.semiMinorAxis + pH),2)) * 180 / FastMath.PI;
        pH=GeoUtils.getGeoidH(lon,lat);
      }
    }
    logger.debug(""String_Node_Str"" + lat + ""String_Node_Str""+ lon);
    results[0]=lon;
    results[1]=lat;
    return results;
  }
 catch (  MathException me) {
    throw new GeoLocationException(GeoLocationException.MSG_CONV_FROM_PIXEL_TO_GEO + ""String_Node_Str"" + me.getMessage());
  }
}",0.9976083707025412
175208,"/** 
 * @param subTimesDiffRef : valori delle differenze tra i tempi e il timeref per i punti che mi interessano . Li uso per calcolare l'incremento medio (periodo di campionamento)
 * @throws MathException 
 */
public static void interpolation(double[] subTimesDiffRef,List<S1Metadata.OrbitStatePosVelox> vpList,Double timeStampInitSecondsRefPointsInterp[],int idxInitTime,int idxEndTime,double deltaT,List<double[]> interpPpointsOutput,List<double[]> interpVpointsOutput,List<Double> timeStampInterpSecondsRefOutput) throws MathException {
  int nPoints=subTimesDiffRef.length;
  double[][] hermiteMatrix=hermiteMatrix(nPoints);
  hermiteMatrix=invertMatrix(hermiteMatrix);
  double meanTimeRef=1;
  int m=vpList.size();
  int n=3;
  double[][] state=new double[2 * m][n];
  for (int i=0; i < 2 * m; i+=2) {
    OrbitStatePosVelox obj=vpList.get(i / 2);
    state[i][0]=obj.px;
    state[i][1]=obj.py;
    state[i][2]=obj.pz;
    state[i + 1][0]=obj.vx * meanTimeRef;
    state[i + 1][1]=obj.vy * meanTimeRef;
    state[i + 1][2]=obj.vz * meanTimeRef;
  }
  double[] interTime=new double[timeStampInitSecondsRefPointsInterp.length];
  int index=0;
  for (  double v : timeStampInitSecondsRefPointsInterp) {
    interTime[index]=v / meanTimeRef;
    index++;
  }
  int powerMax=2 * m - 1;
  double[][] vTmpPos=MathUtil.multiplyMatrix(hermiteMatrix,state);
  double[][] vTmpVel=new double[2 * m][n];
  for (int i=0; i < 2 * m; i++) {
    for (int j=0; j < n; j++) {
      vTmpVel[i][j]=vTmpPos[i][j] / meanTimeRef;
    }
  }
  for (int idx=idxInitTime; idx <= idxEndTime; idx++) {
    double[][] ptvec=new double[1][powerMax + 1];
    double[][] vtvec=new double[1][powerMax + 1];
    for (int i=0; i <= powerMax; i++) {
      ptvec[0][i]=FastMath.pow(interTime[idx],powerMax - i);
      vtvec[0][i]=FastMath.pow((interTime[idx]),FastMath.abs(i - 1));
    }
    for (int i=0; i <= powerMax; i++) {
      vtvec[0][powerMax - i]=i * vtvec[0][i];
    }
    interpPpointsOutput.add(idx - idxInitTime,MathUtil.multiplyMatrix(ptvec,vTmpPos)[0]);
    interpVpointsOutput.add(idx - idxInitTime,MathUtil.multiplyMatrix(vtvec,vTmpVel)[0]);
    timeStampInterpSecondsRefOutput.add(idx - idxInitTime,timeStampInitSecondsRefPointsInterp[idx]);
  }
}","/** 
 * @param subTimesDiffRef : valori delle differenze tra i tempi e il timeref per i punti che mi interessano . Li uso per calcolare l'incremento medio (periodo di campionamento)
 * @throws MathException 
 */
public static void interpolation(double[] subTimesDiffRef,List<S1Metadata.OrbitStatePosVelox> vpList,Double timeStampInitSecondsRefPointsInterp[],int idxInitTime,int idxEndTime,double deltaT,List<double[]> interpPpointsOutput,List<double[]> interpVpointsOutput,List<Double> timeStampInterpSecondsRefOutput) throws MathException {
  int nPoints=subTimesDiffRef.length;
  double[][] hermiteMatrix=hermiteMatrix(nPoints);
  hermiteMatrix=invertMatrix(hermiteMatrix);
  double meanTimeRef=1;
  int m=vpList.size();
  int n=3;
  double[][] state=new double[2 * m][n];
  for (int i=0; i < 2 * m; i+=2) {
    OrbitStatePosVelox obj=vpList.get(i / 2);
    state[i][0]=obj.px;
    state[i][1]=obj.py;
    state[i][2]=obj.pz;
    state[i + 1][0]=obj.vx * meanTimeRef;
    state[i + 1][1]=obj.vy * meanTimeRef;
    state[i + 1][2]=obj.vz * meanTimeRef;
  }
  double[] interTime=new double[timeStampInitSecondsRefPointsInterp.length];
  int index=0;
  for (  double v : timeStampInitSecondsRefPointsInterp) {
    interTime[index]=v / meanTimeRef;
    index++;
  }
  int powerMax=2 * m - 1;
  double[][] vTmpPos=MathUtil.multiplyMatrix(hermiteMatrix,state);
  double[][] vTmpVel=new double[2 * m][n];
  for (int i=0; i < 2 * m; i++) {
    for (int j=0; j < n; j++) {
      vTmpVel[i][j]=vTmpPos[i][j] / meanTimeRef;
    }
  }
  for (int idx=idxInitTime; idx <= idxEndTime; idx++) {
    double[][] ptvec=new double[1][powerMax + 1];
    double[][] vtvec=new double[1][powerMax + 1];
    for (int i=0; i <= powerMax; i++) {
      ptvec[0][i]=FastMath.pow(interTime[idx],powerMax - i);
      vtvec[0][i]=FastMath.pow((interTime[idx]),FastMath.abs(powerMax - i - 1));
    }
    for (int i=0; i <= powerMax; i++) {
      vtvec[0][powerMax - i]=i * vtvec[0][i];
    }
    interpPpointsOutput.add(idx - idxInitTime,MathUtil.multiplyMatrix(ptvec,vTmpPos)[0]);
    interpVpointsOutput.add(idx - idxInitTime,MathUtil.multiplyMatrix(vtvec,vTmpVel)[0]);
    timeStampInterpSecondsRefOutput.add(idx - idxInitTime,timeStampInitSecondsRefPointsInterp[idx]);
  }
}",0.997546285969217
175209,"/** 
 * AG inserted a test to filter boats by length
 * @param list
 */
protected void computeBoatsAttributesAndStatistics(List<BoatConnectedPixelMap> list){
  List<Boat> boatsTemp=new ArrayList<Boat>();
  for (  BoatConnectedPixelMap boatPxMap : list) {
    boatPxMap.computeValues(pixsam,pixrec);
    if (boatPxMap.getBoatlength() > this.filterminSize && boatPxMap.getBoatlength() < this.filtermaxSize) {
      Boat b=new Boat(boatPxMap.getId(),(int)boatPxMap.getBoatposition()[0],(int)boatPxMap.getBoatposition()[1],(int)boatPxMap.getBoatnumberofpixels(),(int)boatPxMap.getBoatlength(),(int)boatPxMap.getBoatwidth(),(int)boatPxMap.getBoatheading());
      List<Double> thresholdsTile=boatPxMap.getThresholdValue();
      double max=boatPxMap.getMaximumValue();
      for (      Double t : thresholdsTile) {
      }
      boatsTemp.add(b);
    }
  }
  boatsTemp.clear();
  boatsTemp=sortBoats(boatsTemp);
  boatArray=boatsTemp.toArray(new Boat[0]);
}","/** 
 * AG inserted a test to filter boats by length
 * @param list
 */
protected void computeBoatsAttributesAndStatistics(List<BoatConnectedPixelMap> list){
  List<Boat> boatsTemp=new ArrayList<Boat>();
  for (  BoatConnectedPixelMap boatPxMap : list) {
    boatPxMap.computeValues(pixsam,pixrec);
    if (boatPxMap.getBoatlength() > this.filterminSize && boatPxMap.getBoatlength() < this.filtermaxSize) {
      Boat b=new Boat(boatPxMap.getId(),(int)boatPxMap.getBoatposition()[0],(int)boatPxMap.getBoatposition()[1],(int)boatPxMap.getBoatnumberofpixels(),(int)boatPxMap.getBoatlength(),(int)boatPxMap.getBoatwidth(),(int)boatPxMap.getBoatheading());
      List<Double> thresholdsTile=boatPxMap.getThresholdValue();
      double max=boatPxMap.getMaximumValue();
      for (      Double t : thresholdsTile) {
      }
      boatsTemp.add(b);
    }
  }
  boatsTemp=sortBoats(boatsTemp);
  boatArray=boatsTemp.toArray(new Boat[0]);
}",0.9888475836431226
175210,"public static void renderCross(OpenGLContext context,float zoomWidth,float zoomHeight,List<Geometry> geometries,Geometry selectedGeometry,float renderWidth,Color color){
  GL2 gl=context.getGL().getGL2();
  float[] c=color.brighter().getColorComponents(null);
  gl.glColor3f(c[0],c[1],c[2]);
  for (  Geometry temp : geometries) {
    gl.glLineWidth(temp == selectedGeometry ? renderWidth * 2 : renderWidth);
    Coordinate point=new Coordinate(temp.getCoordinate());
    point.x=(point.x - context.getX()) / zoomWidth;
    point.y=1 - (point.y - context.getY()) / zoomHeight;
    double rectwidth=0.01;
    gl.glBegin(GL.GL_LINE_STRIP);
    gl.glVertex2d(point.x - rectwidth,point.y);
    gl.glVertex2d(point.x + rectwidth,point.y);
    gl.glEnd();
    gl.glBegin(GL.GL_LINE_STRIP);
    gl.glVertex2d(point.x,point.y - rectwidth);
    gl.glVertex2d(point.x,point.y + rectwidth);
    gl.glEnd();
    gl.glFlush();
  }
}","public static void renderCross(OpenGLContext context,float zoomWidth,float zoomHeight,List<Geometry> geometries,Geometry selectedGeometry,float renderWidth,Color color){
  GL2 gl=context.getGL().getGL2();
  float[] c=color.brighter().getColorComponents(null);
  gl.glColor3f(c[0],c[1],c[2]);
  if (geometries != null) {
    for (    Geometry temp : geometries) {
      gl.glLineWidth(temp == selectedGeometry ? renderWidth * 2 : renderWidth);
      Coordinate point=new Coordinate(temp.getCoordinate());
      point.x=(point.x - context.getX()) / zoomWidth;
      point.y=1 - (point.y - context.getY()) / zoomHeight;
      double rectwidth=0.01;
      gl.glBegin(GL.GL_LINE_STRIP);
      gl.glVertex2d(point.x - rectwidth,point.y);
      gl.glVertex2d(point.x + rectwidth,point.y);
      gl.glEnd();
      gl.glBegin(GL.GL_LINE_STRIP);
      gl.glVertex2d(point.x,point.y - rectwidth);
      gl.glVertex2d(point.x,point.y + rectwidth);
      gl.glEnd();
      gl.glFlush();
    }
  }
}",0.9611344537815126
175211,"public static void renderTriangle(OpenGLContext context,float zoomWidth,float zoomHeight,List<Geometry> geometries,Geometry selectedGeometry,float renderWidth,Color color){
  GL2 gl=context.getGL().getGL2();
  float[] c=color.brighter().getColorComponents(null);
  gl.glColor3f(c[0],c[1],c[2]);
  for (  Geometry temp : geometries) {
    gl.glLineWidth(temp == selectedGeometry ? renderWidth * 2 : renderWidth);
    Coordinate point=new Coordinate(temp.getCoordinate());
    point.x=(point.x - context.getX()) / zoomWidth;
    point.y=1 - (point.y - context.getY()) / zoomHeight;
    double rectwidth=0.01;
    gl.glBegin(GL.GL_LINE_STRIP);
    gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
    gl.glVertex2d(point.x,point.y + rectwidth);
    gl.glVertex2d(point.x + rectwidth,point.y - rectwidth);
    gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
    gl.glEnd();
    gl.glFlush();
  }
}","public static void renderTriangle(OpenGLContext context,float zoomWidth,float zoomHeight,List<Geometry> geometries,Geometry selectedGeometry,float renderWidth,Color color){
  GL2 gl=context.getGL().getGL2();
  float[] c=color.brighter().getColorComponents(null);
  gl.glColor3f(c[0],c[1],c[2]);
  if (geometries != null) {
    for (    Geometry temp : geometries) {
      gl.glLineWidth(temp == selectedGeometry ? renderWidth * 2 : renderWidth);
      Coordinate point=new Coordinate(temp.getCoordinate());
      point.x=(point.x - context.getX()) / zoomWidth;
      point.y=1 - (point.y - context.getY()) / zoomHeight;
      double rectwidth=0.01;
      gl.glBegin(GL.GL_LINE_STRIP);
      gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
      gl.glVertex2d(point.x,point.y + rectwidth);
      gl.glVertex2d(point.x + rectwidth,point.y - rectwidth);
      gl.glVertex2d(point.x - rectwidth,point.y - rectwidth);
      gl.glEnd();
      gl.glFlush();
    }
  }
}",0.9627263045793396
175212,"public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=36.950;
    double lon=-3.6315;
    double r[];
    try {
      r=gc.pixelFromGeo(2.17235,41.31749);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}","public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=36.950;
    double lon=-3.6315;
    double r[];
    try {
      r=gc.geoFromPixel(4623,7445);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}",0.9645542427497314
175213,"public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=36.950;
    double lon=-3.6315;
    double r[];
    try {
      r=gc.pixelFromGeo(2.17235,41.31749);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}","public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=36.950;
    double lon=-3.6315;
    double r[];
    try {
      r=gc.geoFromPixel(4623,7445);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}",0.9645542427497314
175214,"/** 
 * @param lon
 * @param lat
 * @return the geoid Height for a point (lon,lat)
 */
public static double getGeoidH(final double lon,final double lat){
  double h=0;
  double lonRad=lon * FastMath.PI / 180;
  double latRad=lat * FastMath.PI / 180;
  boolean finded=false;
  for (int row=0; row < geoidPoints.length && !finded; row++) {
    int middle=geoidPoints[0].length / 2;
    Geoid geoRow[]=geoidPoints[row];
    Geoid g=geoRow[middle];
    double middleDist=distance(lonRad,lat,g.lonRad,g.latRad);
    if (middleDist < 110) {
      h=g.h;
    }
 else {
      int left=0;
      int right=geoidPoints[0].length;
      for (; right - left > 1; ) {
        int middleLeft=(left + middle) / 2;
        int middleRight=middle + (right - middle) / 2;
        double middleDistL=distance(lonRad,latRad,geoRow[middleLeft].lonRad,geoRow[middleLeft].latRad);
        double middleDistR=distance(lonRad,latRad,geoRow[middleRight].lonRad,geoRow[middleRight].latRad);
        if (middleDistL < middleDistR) {
          right=middle;
          middle=left + (right - left) / 2;
          middleDist=middleDistL;
        }
 else {
          left=middle;
          middle=left + (right - left) / 2;
          middleDist=middleDistR;
        }
        if (middleDist < 110) {
          h=geoRow[middle].h;
          finded=true;
          break;
        }
      }
    }
  }
  return h;
}","/** 
 * @param lon
 * @param lat
 * @return the geoid Height for a point (lon,lat)
 */
public static double getGeoidH(final double lon,final double lat){
  double h=0;
  double lonRad=lon * FastMath.PI / 180;
  double latRad=lat * FastMath.PI / 180;
  boolean finded=false;
  for (int row=0; row < geoidPoints.length && !finded; row++) {
    int middle=geoidPoints[0].length / 2;
    Geoid geoRow[]=geoidPoints[row];
    Geoid g=geoRow[middle];
    double middleDist=distance(lonRad,latRad,g.lonRad,g.latRad);
    if (middleDist < 50) {
      h=g.h;
    }
 else {
      int left=0;
      int right=geoidPoints[0].length;
      for (; right - left > 1; ) {
        int middleLeft=(left + middle) / 2;
        int middleRight=middle + (right - middle) / 2;
        double middleDistL=distance(lonRad,latRad,geoRow[middleLeft].lonRad,geoRow[middleLeft].latRad);
        double middleDistR=distance(lonRad,latRad,geoRow[middleRight].lonRad,geoRow[middleRight].latRad);
        if (middleDistL < middleDistR) {
          right=middle;
          middle=left + (right - left) / 2;
          middleDist=middleDistL;
        }
 else {
          left=middle;
          middle=left + (right - left) / 2;
          middleDist=middleDistR;
        }
        if (middleDist < 50) {
          h=geoRow[middle].h;
          finded=true;
          break;
        }
      }
    }
  }
  return h;
}",0.9967355821545156
175215,"/** 
 * @param statepVecInterp
 * @param pXYZ
 * @param timeStampInterp
 * @return double array with 2 elements [0]=zeroDopplerTimeSmooth  [1]=sRdistSmooth
 */
public double[] findZeroDoppler(List<double[]> statepVecInterp,double[] pXYZ,double[] timeStampInterp){
  try {
    int iOptFactor=10;
    int nPointsAroundMin=100;
    int nWindowLength=7;
    double nWindowLengthSize=FastMath.floor(nWindowLength / 2);
    int size=statepVecInterp.size();
    int sizeFactor=size / iOptFactor;
    double[][] diffSubsample=new double[sizeFactor][statepVecInterp.get(0).length];
    double[] vDistSubsample=new double[sizeFactor];
    for (int i=0; i < sizeFactor; i++) {
      int pos=i * iOptFactor;
      diffSubsample[i][0]=(statepVecInterp.get(pos)[0] - pXYZ[0]) * (statepVecInterp.get(pos)[0] - pXYZ[0]);
      diffSubsample[i][1]=(statepVecInterp.get(pos)[1] - pXYZ[1]) * (statepVecInterp.get(pos)[1] - pXYZ[1]);
      diffSubsample[i][2]=(statepVecInterp.get(pos)[2] - pXYZ[2]) * (statepVecInterp.get(pos)[2] - pXYZ[2]);
      vDistSubsample[i]=diffSubsample[i][0] + diffSubsample[i][1] + diffSubsample[i][2];
    }
    int idxMinSubsample=0;
    double distMinSubsample=vDistSubsample[0];
    for (int i=1; i < vDistSubsample.length; i++) {
      if (distMinSubsample > vDistSubsample[i]) {
        distMinSubsample=vDistSubsample[i];
        idxMinSubsample=i;
      }
    }
    double idxMin=(idxMinSubsample) * iOptFactor;
    double[] vDist=new double[size];
    for (int i=0; i < vDistSubsample.length; i++) {
      for (int j=0; j < iOptFactor; j++) {
        vDist[(i * iOptFactor) + j]=vDistSubsample[i];
      }
    }
    double iDistWInit=idxMin - nPointsAroundMin;
    if (iDistWInit <= 0)     iDistWInit=1;
    double iDistWEnd=idxMin + nPointsAroundMin;
    if (iDistWEnd > vDist.length)     iDistWEnd=vDist.length;
    int start=((Double)iDistWInit).intValue();
    double[] vDistOptimization=new double[((Double)iDistWEnd).intValue() - start];
    for (int i=start; i < iDistWEnd; i++) {
      double v1=(statepVecInterp.get(i)[0] - pXYZ[0]) * (statepVecInterp.get(i)[0] - pXYZ[0]);
      double v2=(statepVecInterp.get(i)[1] - pXYZ[1]) * (statepVecInterp.get(i)[1] - pXYZ[1]);
      double v3=(statepVecInterp.get(i)[2] - pXYZ[2]) * (statepVecInterp.get(i)[2] - pXYZ[2]);
      vDistOptimization[i - start]=v1 + v2 + v3;
    }
    double w[]=new double[nWindowLength];
    Arrays.fill(w,1.0 / nWindowLength);
    double[] vdistSmooth=MathUtil.linearConvolutionMatlabValid(vDistOptimization,w);
    double distMinSmooth=vdistSmooth[0];
    int idxMinSmoothW=0;
    for (int i=0; i < vdistSmooth.length; i++) {
      if (distMinSmooth > vdistSmooth[i]) {
        distMinSmooth=vdistSmooth[i];
        idxMinSmoothW=i;
      }
    }
    int idxMinSmooth=new Double(idxMinSmoothW + iDistWInit + nWindowLengthSize - 1).intValue();
    double res[]={timeStampInterp[idxMinSmooth],FastMath.sqrt(distMinSmooth)};
    return res;
  }
 catch (  Exception e) {
    logger.error(e.getMessage(),e);
    throw e;
  }
}","/** 
 * @param statepVecInterp
 * @param pXYZ
 * @param timeStampInterp
 * @return double array with 2 elements [0]=zeroDopplerTimeSmooth  [1]=sRdistSmooth
 */
public double[] findZeroDoppler(final List<double[]> statepVecInterp,double[] pXYZ,double[] timeStampInterp){
  try {
    int iOptFactor=10;
    int nPointsAroundMin=100;
    int nWindowLength=7;
    double nWindowLengthSize=FastMath.floor(nWindowLength / 2);
    int size=statepVecInterp.size();
    int sizeFactor=(int)Math.ceil((new Double(size * 1.0 / iOptFactor)));
    double[][] diffSubsample=new double[sizeFactor][statepVecInterp.get(0).length];
    double[] vDistSubsample=new double[sizeFactor];
    for (int i=0; i < sizeFactor; i++) {
      int pos=i * iOptFactor;
      diffSubsample[i][0]=(statepVecInterp.get(pos)[0] - pXYZ[0]) * (statepVecInterp.get(pos)[0] - pXYZ[0]);
      diffSubsample[i][1]=(statepVecInterp.get(pos)[1] - pXYZ[1]) * (statepVecInterp.get(pos)[1] - pXYZ[1]);
      diffSubsample[i][2]=(statepVecInterp.get(pos)[2] - pXYZ[2]) * (statepVecInterp.get(pos)[2] - pXYZ[2]);
      vDistSubsample[i]=diffSubsample[i][0] + diffSubsample[i][1] + diffSubsample[i][2];
    }
    int idxMinSubsample=0;
    double distMinSubsample=vDistSubsample[0];
    for (int i=1; i < vDistSubsample.length; i++) {
      if (distMinSubsample > vDistSubsample[i]) {
        distMinSubsample=vDistSubsample[i];
        idxMinSubsample=i;
      }
    }
    double idxMin=(idxMinSubsample) * iOptFactor;
    double[] vDist=new double[size];
    for (int i=0; i < vDistSubsample.length; i++) {
      for (int j=0; j < iOptFactor && ((i * iOptFactor) + j) < vDist.length; j++) {
        vDist[(i * iOptFactor) + j]=vDistSubsample[i];
      }
    }
    double iDistWInit=idxMin - nPointsAroundMin;
    if (iDistWInit <= 0)     iDistWInit=1;
    double iDistWEnd=idxMin + nPointsAroundMin + 1;
    if (iDistWEnd > vDist.length)     iDistWEnd=vDist.length;
    int start=((Double)iDistWInit).intValue();
    double[] vDistOptimization=new double[((Double)iDistWEnd).intValue() - start];
    for (int i=start; i < iDistWEnd; i++) {
      double v1=(statepVecInterp.get(i)[0] - pXYZ[0]) * (statepVecInterp.get(i)[0] - pXYZ[0]);
      double v2=(statepVecInterp.get(i)[1] - pXYZ[1]) * (statepVecInterp.get(i)[1] - pXYZ[1]);
      double v3=(statepVecInterp.get(i)[2] - pXYZ[2]) * (statepVecInterp.get(i)[2] - pXYZ[2]);
      vDistOptimization[i - start]=v1 + v2 + v3;
    }
    double w[]=new double[nWindowLength];
    Arrays.fill(w,1.0 / nWindowLength);
    double[] vdistSmooth=MathUtil.linearConvolutionMatlabValid(vDistOptimization,w);
    double distMinSmooth=vdistSmooth[0];
    int idxMinSmoothW=0;
    for (int i=0; i < vdistSmooth.length; i++) {
      if (distMinSmooth > vdistSmooth[i]) {
        distMinSmooth=vdistSmooth[i];
        idxMinSmoothW=i;
      }
    }
    int idxMinSmooth=new Double(idxMinSmoothW + iDistWInit + nWindowLengthSize - 1).intValue();
    double res[]={timeStampInterp[idxMinSmooth],FastMath.sqrt(distMinSmooth)};
    return res;
  }
 catch (  Exception e) {
    logger.error(e.getMessage(),e);
    throw e;
  }
}",0.9858144464373064
175216,"/** 
 * @param lon
 * @param lat
 * @return the geoid Height for a point (lon,lat)
 */
public static double getGeoidH(final double lon,final double lat){
  double h=0;
  double lonRad=lon * FastMath.PI / 180;
  double latRad=lat * FastMath.PI / 180;
  boolean finded=false;
  for (int row=0; row < geoidPoints.length && !finded; row++) {
    int middle=geoidPoints[0].length / 2;
    Geoid geoRow[]=geoidPoints[row];
    Geoid g=geoRow[middle];
    double middleDist=distance(lonRad,lat,g.lonRad,g.latRad);
    if (middleDist < 110) {
      h=g.h;
    }
 else {
      int left=0;
      int right=geoidPoints[0].length;
      for (; right - left > 1; ) {
        int middleLeft=(left + middle) / 2;
        int middleRight=middle + (right - middle) / 2;
        double middleDistL=distance(lonRad,latRad,geoRow[middleLeft].lonRad,geoRow[middleLeft].latRad);
        double middleDistR=distance(lonRad,latRad,geoRow[middleRight].lonRad,geoRow[middleRight].latRad);
        if (middleDistL < middleDistR) {
          right=middle;
          middle=left + (right - left) / 2;
          middleDist=middleDistL;
        }
 else {
          left=middle;
          middle=left + (right - left) / 2;
          middleDist=middleDistR;
        }
        if (middleDist < 110) {
          h=geoRow[middle].h;
          finded=true;
          break;
        }
      }
    }
  }
  return h;
}","/** 
 * @param lon
 * @param lat
 * @return the geoid Height for a point (lon,lat)
 */
public static double getGeoidH(final double lon,final double lat){
  double h=0;
  double lonRad=lon * FastMath.PI / 180;
  double latRad=lat * FastMath.PI / 180;
  boolean finded=false;
  for (int row=0; row < geoidPoints.length && !finded; row++) {
    int middle=geoidPoints[0].length / 2;
    Geoid geoRow[]=geoidPoints[row];
    Geoid g=geoRow[middle];
    double middleDist=distance(lonRad,latRad,g.lonRad,g.latRad);
    if (middleDist < 50) {
      h=g.h;
    }
 else {
      int left=0;
      int right=geoidPoints[0].length;
      for (; right - left > 1; ) {
        int middleLeft=(left + middle) / 2;
        int middleRight=middle + (right - middle) / 2;
        double middleDistL=distance(lonRad,latRad,geoRow[middleLeft].lonRad,geoRow[middleLeft].latRad);
        double middleDistR=distance(lonRad,latRad,geoRow[middleRight].lonRad,geoRow[middleRight].latRad);
        if (middleDistL < middleDistR) {
          right=middle;
          middle=left + (right - left) / 2;
          middleDist=middleDistL;
        }
 else {
          left=middle;
          middle=left + (right - left) / 2;
          middleDist=middleDistR;
        }
        if (middleDist < 50) {
          h=geoRow[middle].h;
          finded=true;
          break;
        }
      }
    }
  }
  return h;
}",0.9967355821545156
175217,"/** 
 * @param statepVecInterp
 * @param pXYZ
 * @param timeStampInterp
 * @return double array with 2 elements [0]=zeroDopplerTimeSmooth  [1]=sRdistSmooth
 */
public double[] findZeroDoppler(List<double[]> statepVecInterp,double[] pXYZ,double[] timeStampInterp){
  try {
    int iOptFactor=10;
    int nPointsAroundMin=100;
    int nWindowLength=7;
    double nWindowLengthSize=FastMath.floor(nWindowLength / 2);
    int size=statepVecInterp.size();
    int sizeFactor=size / iOptFactor;
    double[][] diffSubsample=new double[sizeFactor][statepVecInterp.get(0).length];
    double[] vDistSubsample=new double[sizeFactor];
    for (int i=0; i < sizeFactor; i++) {
      int pos=i * iOptFactor;
      diffSubsample[i][0]=(statepVecInterp.get(pos)[0] - pXYZ[0]) * (statepVecInterp.get(pos)[0] - pXYZ[0]);
      diffSubsample[i][1]=(statepVecInterp.get(pos)[1] - pXYZ[1]) * (statepVecInterp.get(pos)[1] - pXYZ[1]);
      diffSubsample[i][2]=(statepVecInterp.get(pos)[2] - pXYZ[2]) * (statepVecInterp.get(pos)[2] - pXYZ[2]);
      vDistSubsample[i]=diffSubsample[i][0] + diffSubsample[i][1] + diffSubsample[i][2];
    }
    int idxMinSubsample=0;
    double distMinSubsample=vDistSubsample[0];
    for (int i=1; i < vDistSubsample.length; i++) {
      if (distMinSubsample > vDistSubsample[i]) {
        distMinSubsample=vDistSubsample[i];
        idxMinSubsample=i;
      }
    }
    double idxMin=(idxMinSubsample) * iOptFactor;
    double[] vDist=new double[size];
    for (int i=0; i < vDistSubsample.length; i++) {
      for (int j=0; j < iOptFactor; j++) {
        vDist[(i * iOptFactor) + j]=vDistSubsample[i];
      }
    }
    double iDistWInit=idxMin - nPointsAroundMin;
    if (iDistWInit <= 0)     iDistWInit=1;
    double iDistWEnd=idxMin + nPointsAroundMin;
    if (iDistWEnd > vDist.length)     iDistWEnd=vDist.length;
    int start=((Double)iDistWInit).intValue();
    double[] vDistOptimization=new double[((Double)iDistWEnd).intValue() - start];
    for (int i=start; i < iDistWEnd; i++) {
      double v1=(statepVecInterp.get(i)[0] - pXYZ[0]) * (statepVecInterp.get(i)[0] - pXYZ[0]);
      double v2=(statepVecInterp.get(i)[1] - pXYZ[1]) * (statepVecInterp.get(i)[1] - pXYZ[1]);
      double v3=(statepVecInterp.get(i)[2] - pXYZ[2]) * (statepVecInterp.get(i)[2] - pXYZ[2]);
      vDistOptimization[i - start]=v1 + v2 + v3;
    }
    double w[]=new double[nWindowLength];
    Arrays.fill(w,1.0 / nWindowLength);
    double[] vdistSmooth=MathUtil.linearConvolutionMatlabValid(vDistOptimization,w);
    double distMinSmooth=vdistSmooth[0];
    int idxMinSmoothW=0;
    for (int i=0; i < vdistSmooth.length; i++) {
      if (distMinSmooth > vdistSmooth[i]) {
        distMinSmooth=vdistSmooth[i];
        idxMinSmoothW=i;
      }
    }
    int idxMinSmooth=new Double(idxMinSmoothW + iDistWInit + nWindowLengthSize - 1).intValue();
    double res[]={timeStampInterp[idxMinSmooth],FastMath.sqrt(distMinSmooth)};
    return res;
  }
 catch (  Exception e) {
    logger.error(e.getMessage(),e);
    throw e;
  }
}","/** 
 * @param statepVecInterp
 * @param pXYZ
 * @param timeStampInterp
 * @return double array with 2 elements [0]=zeroDopplerTimeSmooth  [1]=sRdistSmooth
 */
public double[] findZeroDoppler(final List<double[]> statepVecInterp,double[] pXYZ,double[] timeStampInterp){
  try {
    int iOptFactor=10;
    int nPointsAroundMin=100;
    int nWindowLength=7;
    double nWindowLengthSize=FastMath.floor(nWindowLength / 2);
    int size=statepVecInterp.size();
    int sizeFactor=(int)Math.ceil((new Double(size * 1.0 / iOptFactor)));
    double[][] diffSubsample=new double[sizeFactor][statepVecInterp.get(0).length];
    double[] vDistSubsample=new double[sizeFactor];
    for (int i=0; i < sizeFactor; i++) {
      int pos=i * iOptFactor;
      diffSubsample[i][0]=(statepVecInterp.get(pos)[0] - pXYZ[0]) * (statepVecInterp.get(pos)[0] - pXYZ[0]);
      diffSubsample[i][1]=(statepVecInterp.get(pos)[1] - pXYZ[1]) * (statepVecInterp.get(pos)[1] - pXYZ[1]);
      diffSubsample[i][2]=(statepVecInterp.get(pos)[2] - pXYZ[2]) * (statepVecInterp.get(pos)[2] - pXYZ[2]);
      vDistSubsample[i]=diffSubsample[i][0] + diffSubsample[i][1] + diffSubsample[i][2];
    }
    int idxMinSubsample=0;
    double distMinSubsample=vDistSubsample[0];
    for (int i=1; i < vDistSubsample.length; i++) {
      if (distMinSubsample > vDistSubsample[i]) {
        distMinSubsample=vDistSubsample[i];
        idxMinSubsample=i;
      }
    }
    double idxMin=(idxMinSubsample) * iOptFactor;
    double[] vDist=new double[size];
    for (int i=0; i < vDistSubsample.length; i++) {
      for (int j=0; j < iOptFactor && ((i * iOptFactor) + j) < vDist.length; j++) {
        vDist[(i * iOptFactor) + j]=vDistSubsample[i];
      }
    }
    double iDistWInit=idxMin - nPointsAroundMin;
    if (iDistWInit <= 0)     iDistWInit=1;
    double iDistWEnd=idxMin + nPointsAroundMin + 1;
    if (iDistWEnd > vDist.length)     iDistWEnd=vDist.length;
    int start=((Double)iDistWInit).intValue();
    double[] vDistOptimization=new double[((Double)iDistWEnd).intValue() - start];
    for (int i=start; i < iDistWEnd; i++) {
      double v1=(statepVecInterp.get(i)[0] - pXYZ[0]) * (statepVecInterp.get(i)[0] - pXYZ[0]);
      double v2=(statepVecInterp.get(i)[1] - pXYZ[1]) * (statepVecInterp.get(i)[1] - pXYZ[1]);
      double v3=(statepVecInterp.get(i)[2] - pXYZ[2]) * (statepVecInterp.get(i)[2] - pXYZ[2]);
      vDistOptimization[i - start]=v1 + v2 + v3;
    }
    double w[]=new double[nWindowLength];
    Arrays.fill(w,1.0 / nWindowLength);
    double[] vdistSmooth=MathUtil.linearConvolutionMatlabValid(vDistOptimization,w);
    double distMinSmooth=vdistSmooth[0];
    int idxMinSmoothW=0;
    for (int i=0; i < vdistSmooth.length; i++) {
      if (distMinSmooth > vdistSmooth[i]) {
        distMinSmooth=vdistSmooth[i];
        idxMinSmoothW=i;
      }
    }
    int idxMinSmooth=new Double(idxMinSmoothW + iDistWInit + nWindowLengthSize - 1).intValue();
    double res[]={timeStampInterp[idxMinSmooth],FastMath.sqrt(distMinSmooth)};
    return res;
  }
 catch (  Exception e) {
    logger.error(e.getMessage(),e);
    throw e;
  }
}",0.9858144464373064
175218,"public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=61.77994;
    double lon=-65.66427;
    double r[];
    try {
      r=gc.pixelFromGeo(lon,lat);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}","public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=36.950;
    double lon=-3.6315;
    double r[];
    try {
      r=gc.geoFromPixel(24223,16704);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}",0.853448275862069
175219,"/** 
 */
@Override public double[] pixelFromGeo(final double lon,final double lat) throws GeoLocationException {
  double[] resultReverse=new double[2];
  double[] pXYZ=GeoUtils.convertFromGeoToEarthCentred(lat,lon);
  Double dd2[]=(Double[])orbitInterpolation.getTimeStampInterp().toArray(new Double[0]);
  double[] results=findZeroDoppler(statepVecInterp,pXYZ,ArrayUtils.toPrimitive(dd2));
  double zeroDopplerTime=results[0];
  double srdist=results[1];
  double lNominatore=(zeroDopplerTime - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double lDenom=(orbitInterpolation.getZeroDopplerTimeLastRef() - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double l=(lNominatore / lDenom) * (meta.getNlines() - 1);
  if (meta.getCoordinateConversion() != null && meta.getCoordinateConversion().length > 0) {
    double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
    int index=0;
    for (    S1Metadata.CoordinateConversion cc : coordConv) {
      groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
      index++;
    }
    int idx=0;
    if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
      idx=0;
    }
 else     if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
      idx=groundToSlantRangePolyTimesSeconds.length - 2;
    }
 else {
      for (idx=0; idx < groundToSlantRangePolyTimesSeconds.length; idx++) {
        if (groundToSlantRangePolyTimesSeconds[idx] > zeroDopplerTime)         break;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length - 1) {
        idx=idx - 1;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length) {
        idx=idx - 2;
      }
    }
    double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double[] groundToSlantRangeCoefficientsInterp=new double[coordConv[idx].groundToSlantRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
      groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].groundToSlantRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].groundToSlantRangeCoefficients[idCoeff];
    }
    double[] slantToGroundRangeCoefficientsInterp=new double[coordConv[idx].slantToGroundRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
      slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].slantToGroundRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].slantToGroundRangeCoefficients[idCoeff];
    }
    double newD=0;
    double oldD=0;
    int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
    int[] numCoeffs=new int[nCoeffs];
    int[] numExps=new int[nCoeffs];
    int[] denomCoeffs=new int[nCoeffs];
    int[] denomExps=new int[nCoeffs];
    for (int i=0; i < nCoeffs; i++) {
      numCoeffs[i]=i - 1;
      numExps[i]=i;
      denomCoeffs[i]=i;
      denomExps[i]=i - 1;
    }
    denomExps[0]=0;
    double deltaD=0;
    do {
      double numCoeffsXGround=0;
      double denomCoeffsXGround=0;
      double scalNum=0;
      double scalDen=0;
      for (int i=0; i < groundToSlantRangeCoefficientsInterp.length; i++) {
        double dExp=FastMath.pow(oldD,numExps[i]);
        double denomExp=FastMath.pow(oldD,denomExps[i]);
        numCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * numCoeffs[i];
        denomCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * denomCoeffs[i];
        scalNum=scalNum + dExp * numCoeffsXGround;
        scalDen=scalDen + denomExp * denomCoeffsXGround;
      }
      double num=srdist + scalNum;
      newD=num / scalDen;
      deltaD=FastMath.abs(newD - oldD);
      oldD=newD;
    }
 while (deltaD > 1);
    double p=0;
    if (meta.isPixelTimeOrderingAscending()) {
      p=(newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
 else {
      p=meta.getNumberOfSamplesPerLine() - 1 - (newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
    resultReverse[0]=p;
    resultReverse[1]=l;
    logger.debug(""String_Node_Str"" + l + ""String_Node_Str""+ ""String_Node_Str""+ p);
  }
  return resultReverse;
}","/** 
 * @see In matlab: reverse geolocation
 */
@Override public double[] pixelFromGeo(final double lon,final double lat) throws GeoLocationException {
  double[] resultReverse=new double[2];
  double[] pXYZ=GeoUtils.convertFromGeoToEarthCentred(lat,lon);
  Double dd2[]=(Double[])orbitInterpolation.getTimeStampInterp().toArray(new Double[0]);
  double[] results=findZeroDoppler(statepVecInterp,pXYZ,ArrayUtils.toPrimitive(dd2));
  double zeroDopplerTime=results[0];
  double srdist=results[1];
  double lNominatore=(zeroDopplerTime - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double lDenom=(orbitInterpolation.getZeroDopplerTimeLastRef() - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double l=(lNominatore / lDenom) * (meta.getNlines() - 1);
  if (meta.getCoordinateConversion() != null && meta.getCoordinateConversion().length > 0) {
    double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
    int index=0;
    for (    S1Metadata.CoordinateConversion cc : coordConv) {
      groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
      index++;
    }
    int idx=0;
    if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
      idx=0;
    }
 else     if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
      idx=groundToSlantRangePolyTimesSeconds.length - 2;
    }
 else {
      for (idx=0; idx < groundToSlantRangePolyTimesSeconds.length; idx++) {
        if (groundToSlantRangePolyTimesSeconds[idx] > zeroDopplerTime)         break;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length - 1) {
        idx=idx - 1;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length) {
        idx=idx - 2;
      }
    }
    double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double[] groundToSlantRangeCoefficientsInterp=new double[coordConv[idx].groundToSlantRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
      groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].groundToSlantRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].groundToSlantRangeCoefficients[idCoeff];
    }
    double[] slantToGroundRangeCoefficientsInterp=new double[coordConv[idx].slantToGroundRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
      slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].slantToGroundRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].slantToGroundRangeCoefficients[idCoeff];
    }
    double newD=0;
    double oldD=0;
    int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
    int[] numCoeffs=new int[nCoeffs];
    int[] numExps=new int[nCoeffs];
    int[] denomCoeffs=new int[nCoeffs];
    int[] denomExps=new int[nCoeffs];
    for (int i=0; i < nCoeffs; i++) {
      numCoeffs[i]=i - 1;
      numExps[i]=i;
      denomCoeffs[i]=i;
      denomExps[i]=i - 1;
    }
    denomExps[0]=0;
    double deltaD=0;
    do {
      double numCoeffsXGround=0;
      double denomCoeffsXGround=0;
      double scalNum=0;
      double scalDen=0;
      for (int i=0; i < groundToSlantRangeCoefficientsInterp.length; i++) {
        double dExp=FastMath.pow(oldD,numExps[i]);
        double denomExp=FastMath.pow(oldD,denomExps[i]);
        numCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * numCoeffs[i];
        denomCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * denomCoeffs[i];
        scalNum=scalNum + dExp * numCoeffsXGround;
        scalDen=scalDen + denomExp * denomCoeffsXGround;
      }
      double num=srdist + scalNum;
      newD=num / scalDen;
      deltaD=FastMath.abs(newD - oldD);
      oldD=newD;
    }
 while (deltaD > 1);
    double p=0;
    if (meta.isPixelTimeOrderingAscending()) {
      p=(newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
 else {
      p=meta.getNumberOfSamplesPerLine() - 1 - (newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
    resultReverse[0]=p;
    resultReverse[1]=l;
    logger.debug(""String_Node_Str"" + l + ""String_Node_Str""+ ""String_Node_Str""+ p);
  }
  return resultReverse;
}",0.9958023894091056
175220,"/** 
 * In Matlab forwardgeolocation
 */
@Override public double[] geoFromPixel(final double p,final double l) throws GeoLocationException {
  try {
    double[] results=new double[2];
    double lon=0;
    double lat=0;
    double t0=0;
    int idxStartT0=0;
    if (meta.getType().equalsIgnoreCase(""String_Node_Str"") && meta.getProductType().equalsIgnoreCase(""String_Node_Str"") && (meta.getMode().equalsIgnoreCase(""String_Node_Str"") || meta.getMode().equalsIgnoreCase(""String_Node_Str""))) {
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    }
 else {
      double t01=(orbitInterpolation.getZeroDopplerTimeFirstRef()) * (meta.getNlines() - 1 - l);
      double t02=orbitInterpolation.getZeroDopplerTimeLastRef() * l;
      t0=(t01 + t02) / (meta.getNlines() - 1);
      for (idxStartT0=0; idxStartT0 < orbitInterpolation.getTimeStampInterp().size(); idxStartT0++) {
        if (orbitInterpolation.getTimeStampInterp().get(idxStartT0) >= t0) {
          break;
        }
      }
      if (idxStartT0 == statepVecInterp.size())       idxStartT0--;
    }
    final double[] pT0=statepVecInterp.get(idxStartT0);
    final double[] vT0=statevVecInterp.get(idxStartT0);
    double distance=0;
    if (meta.isPixelTimeOrderingAscending()) {
      distance=p * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
 else {
      distance=(meta.getNumberOfSamplesPerLine() - 1 - p) * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
    if (coordConv != null) {
      double zeroDopplerTime=t0;
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
      double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
      int index=0;
      for (      S1Metadata.CoordinateConversion cc : coordConv) {
        groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
        index++;
      }
      int idx=0;
      if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
        idx=1;
      }
 else       if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
        idx=groundToSlantRangePolyTimesSeconds.length - 2;
      }
 else {
        for (idx=0; idx < groundToSlantRangePolyTimesSeconds.length; idx++) {
          if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)           break;
        }
      }
      double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double[] groundToSlantRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].groundToSlantRangeCoefficients);
      double[] groundToSlantRangeCoefficientsInterp2=coordConv[idx + 1].groundToSlantRangeCoefficients;
      for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
        groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * groundToSlantRangeCoefficientsInterp[idCoeff] + factor2 * groundToSlantRangeCoefficientsInterp2[idCoeff];
      }
      double[] slantToGroundRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].slantToGroundRangeCoefficients);
      double[] slantToGroundRangeCoefficientsInterp2=coordConv[idx + 1].slantToGroundRangeCoefficients;
      for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
        slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * slantToGroundRangeCoefficientsInterp[idCoeff] + factor2 * slantToGroundRangeCoefficientsInterp2[idCoeff];
      }
      int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
      int[] vExps=new int[nCoeffs];
      for (int i=0; i < nCoeffs; i++) {
        vExps[i]=i;
      }
      double tmpD=distance - meta.getGroundRangeOrigin();
      double[] pows=MathUtil.powValue2Coeffs(tmpD,vExps);
      double sRdist=MathUtil.vectorProd1XN(groundToSlantRangeCoefficientsInterp,pows);
      logger.debug(""String_Node_Str"" + sRdist);
      double normPt0=MathUtil.norm(pT0);
      double vRadial=MathUtil.vectorProd1XN(vT0,pT0) / normPt0;
      double vTangential=FastMath.sqrt(FastMath.pow(MathUtil.norm(vT0),2) - FastMath.pow(vRadial,2));
      double tanPsi=vRadial / vTangential;
      double[] zsUnit=MathUtil.divVectByVal(pT0,-normPt0);
      double[] vTmp=MathUtil.crossProd3x3(zsUnit,vT0);
      double[] ysUnit=MathUtil.divVectByVal(vTmp,MathUtil.norm(vTmp));
      double[] xsUnit=MathUtil.crossProd3x3(ysUnit,zsUnit);
      double pH=0;
      double rEarth=normPt0 / FastMath.sqrt((pT0[0] * pT0[0] + pT0[1] * pT0[1]) / GeoUtils.semiMajorAxis2 + (pT0[2] * pT0[2]) / GeoUtils.semiMinorAxis2);
      for (int iidx=0; iidx < 2; iidx++) {
        rEarth=rEarth + pH;
        double rEarthOld=rEarth;
        double rEarthChange=100000;
        double[] q=new double[3];
        for (; rEarthChange > 0.1; ) {
          double Rz=(normPt0 * normPt0 + sRdist * sRdist - rEarth * rEarth) / (2 * normPt0);
          double Rx=Rz * tanPsi;
          double Ry=FastMath.sqrt(sRdist * sRdist - Rz * Rz - Rx * Rx);
          if (!meta.getAntennaPointing().equalsIgnoreCase(""String_Node_Str"")) {
            Ry=-Ry;
          }
          double[][] sRvect=new double[][]{{Rx},{Ry},{Rz - normPt0}};
          double[][] qbig=new double[][]{xsUnit,ysUnit,zsUnit};
          qbig=MathUtil.transpose(qbig);
          double[][] qmat=MathUtil.multiplyMatrix(qbig,sRvect);
          q[0]=qmat[0][0];
          q[1]=qmat[1][0];
          q[2]=qmat[2][0];
          rEarth=MathUtil.norm(q) / FastMath.sqrt((q[0] * q[0] + q[1] * q[1]) / GeoUtils.semiMajorAxis2 + (q[2] * q[2] / GeoUtils.semiMinorAxis2)) + pH;
          rEarthChange=FastMath.abs(rEarth - rEarthOld);
          rEarthOld=rEarth;
        }
        lon=FastMath.atan2(q[1],q[0]) * 180 / FastMath.PI;
        double lattmp=FastMath.asin(q[2] / FastMath.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]));
        lat=FastMath.atan(FastMath.tan(lattmp) * FastMath.pow((GeoUtils.semiMajorAxis + pH),2) / FastMath.pow((GeoUtils.semiMinorAxis + pH),2)) * 180 / FastMath.PI;
        pH=GeoUtils.getGeoidH(lon,lat);
      }
    }
    logger.debug(""String_Node_Str"" + lat + ""String_Node_Str""+ lon);
    results[0]=lon;
    results[1]=lat;
    return results;
  }
 catch (  MathException me) {
    throw new GeoLocationException(GeoLocationException.MSG_CONV_FROM_PIXEL_TO_GEO + ""String_Node_Str"" + me.getMessage());
  }
}","/** 
 * @see In Matlab forwardgeolocation
 */
@Override public double[] geoFromPixel(final double p,final double l) throws GeoLocationException {
  try {
    double[] results=new double[2];
    double lon=0;
    double lat=0;
    double t0=0;
    int idxStartT0=0;
    if (meta.getType().equalsIgnoreCase(""String_Node_Str"") && meta.getProductType().equalsIgnoreCase(""String_Node_Str"") && (meta.getMode().equalsIgnoreCase(""String_Node_Str"") || meta.getMode().equalsIgnoreCase(""String_Node_Str""))) {
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    }
 else {
      double t01=(orbitInterpolation.getZeroDopplerTimeFirstRef()) * (meta.getNlines() - 1 - l);
      double t02=orbitInterpolation.getZeroDopplerTimeLastRef() * l;
      t0=(t01 + t02) / (meta.getNlines() - 1);
      for (idxStartT0=0; idxStartT0 < orbitInterpolation.getTimeStampInterp().size(); idxStartT0++) {
        if (orbitInterpolation.getTimeStampInterp().get(idxStartT0) >= t0) {
          break;
        }
      }
      if (idxStartT0 == statepVecInterp.size())       idxStartT0--;
    }
    final double[] pT0=statepVecInterp.get(idxStartT0);
    final double[] vT0=statevVecInterp.get(idxStartT0);
    double distance=0;
    if (meta.isPixelTimeOrderingAscending()) {
      distance=p * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
 else {
      distance=(meta.getNumberOfSamplesPerLine() - 1 - p) * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
    if (coordConv != null) {
      double zeroDopplerTime=t0;
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
      double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
      int index=0;
      for (      S1Metadata.CoordinateConversion cc : coordConv) {
        groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
        index++;
      }
      int idx=0;
      if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
        idx=1;
      }
 else       if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
        idx=groundToSlantRangePolyTimesSeconds.length - 2;
      }
 else {
        for (idx=0; idx < groundToSlantRangePolyTimesSeconds.length; idx++) {
          if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)           break;
        }
      }
      double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double[] groundToSlantRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].groundToSlantRangeCoefficients);
      double[] groundToSlantRangeCoefficientsInterp2=coordConv[idx + 1].groundToSlantRangeCoefficients;
      for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
        groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * groundToSlantRangeCoefficientsInterp[idCoeff] + factor2 * groundToSlantRangeCoefficientsInterp2[idCoeff];
      }
      double[] slantToGroundRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].slantToGroundRangeCoefficients);
      double[] slantToGroundRangeCoefficientsInterp2=coordConv[idx + 1].slantToGroundRangeCoefficients;
      for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
        slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * slantToGroundRangeCoefficientsInterp[idCoeff] + factor2 * slantToGroundRangeCoefficientsInterp2[idCoeff];
      }
      int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
      int[] vExps=new int[nCoeffs];
      for (int i=0; i < nCoeffs; i++) {
        vExps[i]=i;
      }
      double tmpD=distance - meta.getGroundRangeOrigin();
      double[] pows=MathUtil.powValue2Coeffs(tmpD,vExps);
      double sRdist=MathUtil.vectorProd1XN(groundToSlantRangeCoefficientsInterp,pows);
      logger.debug(""String_Node_Str"" + sRdist);
      double normPt0=MathUtil.norm(pT0);
      double vRadial=MathUtil.vectorProd1XN(vT0,pT0) / normPt0;
      double vTangential=FastMath.sqrt(FastMath.pow(MathUtil.norm(vT0),2) - FastMath.pow(vRadial,2));
      double tanPsi=vRadial / vTangential;
      double[] zsUnit=MathUtil.divVectByVal(pT0,-normPt0);
      double[] vTmp=MathUtil.crossProd3x3(zsUnit,vT0);
      double[] ysUnit=MathUtil.divVectByVal(vTmp,MathUtil.norm(vTmp));
      double[] xsUnit=MathUtil.crossProd3x3(ysUnit,zsUnit);
      double pH=0;
      double rEarth=normPt0 / FastMath.sqrt((pT0[0] * pT0[0] + pT0[1] * pT0[1]) / GeoUtils.semiMajorAxis2 + (pT0[2] * pT0[2]) / GeoUtils.semiMinorAxis2);
      for (int iidx=0; iidx < 2; iidx++) {
        rEarth=rEarth + pH;
        double rEarthOld=rEarth;
        double rEarthChange=100000;
        double[] q=new double[3];
        for (; rEarthChange > 0.1; ) {
          double Rz=(normPt0 * normPt0 + sRdist * sRdist - rEarth * rEarth) / (2 * normPt0);
          double Rx=Rz * tanPsi;
          double Ry=FastMath.sqrt(sRdist * sRdist - Rz * Rz - Rx * Rx);
          if (!meta.getAntennaPointing().equalsIgnoreCase(""String_Node_Str"")) {
            Ry=-Ry;
          }
          double[][] sRvect=new double[][]{{Rx},{Ry},{Rz - normPt0}};
          double[][] qbig=new double[][]{xsUnit,ysUnit,zsUnit};
          qbig=MathUtil.transpose(qbig);
          double[][] qmat=MathUtil.multiplyMatrix(qbig,sRvect);
          q[0]=qmat[0][0];
          q[1]=qmat[1][0];
          q[2]=qmat[2][0];
          rEarth=MathUtil.norm(q) / FastMath.sqrt((q[0] * q[0] + q[1] * q[1]) / GeoUtils.semiMajorAxis2 + (q[2] * q[2] / GeoUtils.semiMinorAxis2)) + pH;
          rEarthChange=FastMath.abs(rEarth - rEarthOld);
          rEarthOld=rEarth;
        }
        lon=FastMath.atan2(q[1],q[0]) * 180 / FastMath.PI;
        double lattmp=FastMath.asin(q[2] / FastMath.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]));
        lat=FastMath.atan(FastMath.tan(lattmp) * FastMath.pow((GeoUtils.semiMajorAxis + pH),2) / FastMath.pow((GeoUtils.semiMinorAxis + pH),2)) * 180 / FastMath.PI;
        pH=GeoUtils.getGeoidH(lon,lat);
      }
    }
    logger.debug(""String_Node_Str"" + lat + ""String_Node_Str""+ lon);
    results[0]=lon;
    results[1]=lat;
    return results;
  }
 catch (  MathException me) {
    throw new GeoLocationException(GeoLocationException.MSG_CONV_FROM_PIXEL_TO_GEO + ""String_Node_Str"" + me.getMessage());
  }
}",0.9996265033241204
175221,"public void orbitInterpolation(List<S1Metadata.OrbitStatePosVelox> vpList,double zeroDopplerTimeFirstLineSeconds,double zeroDopplerTimeLastLineSeconds,double samplingf,double iSafetyBufferAz) throws MathException {
  this.iSafetyBufferAz=iSafetyBufferAz;
  double deltaT=1 / samplingf;
  double deltaTinv=1 / deltaT;
  int nPoints=vpList.size();
  double reftime=0;
  double firstTime=vpList.get(0).time;
  double lastTime=vpList.get(vpList.size() - 1).time;
  if (firstTime < (lastTime)) {
    reftime=firstTime;
  }
 else {
    reftime=lastTime;
  }
  int idx=0;
  secondsDiffFromRefTime=new double[vpList.size()];
  for (  S1Metadata.OrbitStatePosVelox vp : vpList) {
    secondsDiffFromRefTime[idx]=(vp.time - reftime);
    idx++;
  }
  zeroDopplerTimeFirstRef=(zeroDopplerTimeFirstLineSeconds - reftime);
  zeroDopplerTimeLastRef=(zeroDopplerTimeLastLineSeconds - reftime);
  double minT=0;
  double maxT=0;
  double zeroDopplerTimeFirstLineWSafetyBufSecondsRef=0;
  double zeroDopplerTimeLastLineWSafetyBufSecondsRef=0;
  if (zeroDopplerTimeFirstRef < zeroDopplerTimeLastRef) {
    zeroDopplerTimeFirstLineWSafetyBufSecondsRef=zeroDopplerTimeFirstRef - iSafetyBufferAz * deltaT;
    zeroDopplerTimeLastLineWSafetyBufSecondsRef=zeroDopplerTimeLastRef + iSafetyBufferAz * deltaT;
    minT=FastMath.min(0,zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
    maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeLastLineWSafetyBufSecondsRef);
  }
 else {
    zeroDopplerTimeFirstLineWSafetyBufSecondsRef=zeroDopplerTimeFirstRef + iSafetyBufferAz * deltaT;
    zeroDopplerTimeLastLineWSafetyBufSecondsRef=zeroDopplerTimeLastRef - iSafetyBufferAz * deltaT;
    if (firstTime < (lastTime)) {
      minT=FastMath.min(secondsDiffFromRefTime[0],zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
      maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
    }
 else {
      minT=FastMath.min(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
      maxT=FastMath.max(secondsDiffFromRefTime[0],zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
    }
  }
  int limit=((Double)((maxT - minT) / deltaT)).intValue();
  Double[] timeStampInterpSecondsRef=new Double[limit + 1];
  double nextVal=0;
  for (int j=0; j <= limit; j++) {
    timeStampInterpSecondsRef[j]=nextVal;
    nextVal=deltaT + nextVal;
  }
  double zeroDopplerTimeInitRef=zeroDopplerTimeFirstRef;
  double zeroDopplerTimeEndRef=zeroDopplerTimeLastRef;
  if (zeroDopplerTimeFirstRef > zeroDopplerTimeLastRef) {
    zeroDopplerTimeInitRef=zeroDopplerTimeLastRef;
    zeroDopplerTimeEndRef=zeroDopplerTimeFirstRef;
  }
  if (zeroDopplerTimeInitRef < timeStampInterpSecondsRef[1]) {
    int size=Math.min(nPoints,N_ORB_POINT_INTERP);
    double[] subTimesDiffRef=Arrays.copyOfRange(secondsDiffFromRefTime,0,nPoints);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < size; i++) {
      double valMax=timeStampInterpSecondsRef[size - 1];
      if (timeStampInterpSecondsRef[i] < valMax) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<IMetadata.OrbitStatePosVelox> subList=vpList.subList(0,size);
    double initTime=zeroDopplerTimeInitRef;
    int idxInitTime=-1;
    boolean finded=false;
    double endTime=secondsDiffFromRefTime[0];
    int idxEndTime=-1;
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= initTime && !finded) {
        idxInitTime=i;
        finded=true;
      }
      if (timeStampInterpSecondsRef[i] < endTime) {
        idxEndTime=i;
      }
    }
    logger.debug(""String_Node_Str"" + idxInitTime + ""String_Node_Str""+ idxEndTime);
    Double[] t0=(Double[])timeStampInitSecondsRefPointsInterp.toArray(new Double[0]);
    if (idxInitTime != -1 && idxEndTime != -1 && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(subTimesDiffRef,subList,t0,idxInitTime,idxEndTime,deltaTinv,vPoints,pPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampOutput);
 else       timeStampInterp.addAll(timeStampOutput);
    }
  }
  for (int orbPoint=1; orbPoint < nPoints; orbPoint++) {
    if (secondsDiffFromRefTime[orbPoint - 1] < zeroDopplerTimeEndRef || secondsDiffFromRefTime[orbPoint] > zeroDopplerTimeEndRef) {
      int idxStart=0;
      int idxEnd=0;
      if (N_ORB_POINT_INTERP > nPoints) {
        idxEnd=nPoints;
      }
 else {
        idxStart=orbPoint - new Double(Math.floor(N_ORB_POINT_INTERP / 2)).intValue();
        idxEnd=idxStart + N_ORB_POINT_INTERP - 1;
        if (idxStart < 1) {
          idxStart=0;
          idxEnd=N_ORB_POINT_INTERP - 1;
        }
        if (idxEnd >= nPoints) {
          idxStart=nPoints - N_ORB_POINT_INTERP;
          idxEnd=nPoints - 1;
        }
      }
      double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,idxStart,idxEnd + 1);
      List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
      for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
        if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[idxStart] && timeStampInterpSecondsRef[i] < secondsDiffFromRefTime[idxEnd]) {
          timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
        }
      }
      List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(idxStart,idxEnd + 1);
      double initTime=Math.max(secondsDiffFromRefTime[orbPoint - 1],zeroDopplerTimeInitRef);
      int idxInitTime=0;
      boolean findIdxInitTime=false;
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
        if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
          idxInitTime=i;
          findIdxInitTime=true;
        }
      }
      double endTime=Math.min(secondsDiffFromRefTime[orbPoint],zeroDopplerTimeEndRef);
      int idxEndTime=0;
      boolean findIdxEndTime=false;
      for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
        if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
          idxEndTime=i;
          findIdxEndTime=true;
        }
      }
      double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
      Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
        timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
      }
      if (findIdxEndTime && findIdxInitTime && initTime < endTime && idxInitTime < idxEndTime) {
        List<double[]> vPoints=new ArrayList<double[]>();
        List<double[]> pPoints=new ArrayList<double[]>();
        List<Double> timeStampOutput=new ArrayList<Double>();
        HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
        addPointsToResult(vPoints,pPoints);
        List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
        for (int i=0; i < timeStampOutput.size(); i++) {
          timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
        }
        if (timeStampInterp == null)         timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else         timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
      }
    }
  }
  if (zeroDopplerTimeEndRef > secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1]) {
    int vOrbPointsInit=(nPoints - Math.min(nPoints,N_ORB_POINT_INTERP));
    int vOrbPointsEnd=nPoints - 1;
    double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,vOrbPointsInit,vOrbPointsEnd + 1);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[vOrbPointsInit]) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(vOrbPointsInit,vOrbPointsEnd + 1);
    double initTime=secondsDiffFromRefTime[vOrbPointsEnd];
    int idxInitTime=0;
    boolean findIdxInitTime=false;
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
      if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
        idxInitTime=i;
        findIdxInitTime=true;
      }
    }
    double endTime=zeroDopplerTimeEndRef;
    int idxEndTime=0;
    boolean findIdxEndTime=false;
    for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
      if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
        idxEndTime=i;
        findIdxEndTime=true;
      }
    }
    double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
    Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
      timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
    }
    if (findIdxEndTime && findIdxInitTime && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
      for (int i=0; i < timeStampOutput.size(); i++) {
        timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
      }
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else       timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
    }
  }
}","public void orbitInterpolation(List<S1Metadata.OrbitStatePosVelox> vpList,double zeroDopplerTimeFirstLineSeconds,double zeroDopplerTimeLastLineSeconds,double samplingf,double iSafetyBufferAz) throws MathException {
  this.iSafetyBufferAz=iSafetyBufferAz;
  double deltaT=1 / samplingf;
  double deltaTinv=1 / deltaT;
  int nPoints=vpList.size();
  double reftime=0;
  double firstTime=vpList.get(0).time;
  double lastTime=vpList.get(vpList.size() - 1).time;
  if (firstTime < (lastTime)) {
    reftime=firstTime;
  }
 else {
    reftime=lastTime;
  }
  int idx=0;
  secondsDiffFromRefTime=new double[vpList.size()];
  for (  S1Metadata.OrbitStatePosVelox vp : vpList) {
    secondsDiffFromRefTime[idx]=(vp.time - reftime);
    idx++;
  }
  zeroDopplerTimeFirstRef=(zeroDopplerTimeFirstLineSeconds - reftime);
  zeroDopplerTimeLastRef=(zeroDopplerTimeLastLineSeconds - reftime);
  double minT=0;
  double maxT=0;
  double zeroDopplerTimeFirstLineWSafetyBufSecondsRef=0;
  double zeroDopplerTimeLastLineWSafetyBufSecondsRef=0;
  if (zeroDopplerTimeFirstRef < zeroDopplerTimeLastRef) {
    zeroDopplerTimeFirstLineWSafetyBufSecondsRef=zeroDopplerTimeFirstRef - iSafetyBufferAz * deltaT;
    zeroDopplerTimeLastLineWSafetyBufSecondsRef=zeroDopplerTimeLastRef + iSafetyBufferAz * deltaT;
    minT=FastMath.min(0,zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
    maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeLastLineWSafetyBufSecondsRef);
  }
 else {
    zeroDopplerTimeFirstLineWSafetyBufSecondsRef=zeroDopplerTimeFirstRef + iSafetyBufferAz * deltaT;
    zeroDopplerTimeLastLineWSafetyBufSecondsRef=zeroDopplerTimeLastRef - iSafetyBufferAz * deltaT;
    if (firstTime < (lastTime)) {
      minT=FastMath.min(secondsDiffFromRefTime[0],zeroDopplerTimeLastLineWSafetyBufSecondsRef);
      maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
    }
 else {
      minT=FastMath.min(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeLastLineWSafetyBufSecondsRef);
      maxT=FastMath.max(secondsDiffFromRefTime[0],zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
    }
  }
  int limit=((Double)((maxT - minT) / deltaT)).intValue();
  Double[] timeStampInterpSecondsRef=new Double[limit + 1];
  double nextVal=0;
  for (int j=0; j <= limit; j++) {
    timeStampInterpSecondsRef[j]=nextVal;
    nextVal=deltaT + nextVal;
  }
  double zeroDopplerTimeInitRef=zeroDopplerTimeFirstLineWSafetyBufSecondsRef;
  double zeroDopplerTimeEndRef=zeroDopplerTimeLastLineWSafetyBufSecondsRef;
  if (zeroDopplerTimeFirstLineWSafetyBufSecondsRef > zeroDopplerTimeLastLineWSafetyBufSecondsRef) {
    zeroDopplerTimeInitRef=zeroDopplerTimeLastLineWSafetyBufSecondsRef;
    zeroDopplerTimeEndRef=zeroDopplerTimeFirstLineWSafetyBufSecondsRef;
  }
  if (zeroDopplerTimeInitRef < timeStampInterpSecondsRef[1]) {
    int size=Math.min(nPoints,N_ORB_POINT_INTERP);
    double[] subTimesDiffRef=Arrays.copyOfRange(secondsDiffFromRefTime,0,nPoints);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < size; i++) {
      double valMax=timeStampInterpSecondsRef[size - 1];
      if (timeStampInterpSecondsRef[i] < valMax) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<IMetadata.OrbitStatePosVelox> subList=vpList.subList(0,size);
    double initTime=zeroDopplerTimeInitRef;
    int idxInitTime=-1;
    boolean finded=false;
    double endTime=secondsDiffFromRefTime[0];
    int idxEndTime=-1;
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= initTime && !finded) {
        idxInitTime=i;
        finded=true;
      }
      if (timeStampInterpSecondsRef[i] < endTime) {
        idxEndTime=i;
      }
    }
    logger.debug(""String_Node_Str"" + idxInitTime + ""String_Node_Str""+ idxEndTime);
    Double[] t0=(Double[])timeStampInitSecondsRefPointsInterp.toArray(new Double[0]);
    if (idxInitTime != -1 && idxEndTime != -1 && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(subTimesDiffRef,subList,t0,idxInitTime,idxEndTime,deltaTinv,vPoints,pPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampOutput);
 else       timeStampInterp.addAll(timeStampOutput);
    }
  }
  for (int orbPoint=1; orbPoint < nPoints; orbPoint++) {
    if (secondsDiffFromRefTime[orbPoint - 1] < zeroDopplerTimeEndRef || secondsDiffFromRefTime[orbPoint] > zeroDopplerTimeEndRef) {
      int idxStart=0;
      int idxEnd=0;
      if (N_ORB_POINT_INTERP > nPoints) {
        idxEnd=nPoints;
      }
 else {
        idxStart=orbPoint - new Double(Math.floor(N_ORB_POINT_INTERP / 2)).intValue();
        idxEnd=idxStart + N_ORB_POINT_INTERP - 1;
        if (idxStart < 1) {
          idxStart=0;
          idxEnd=N_ORB_POINT_INTERP - 1;
        }
        if (idxEnd >= nPoints) {
          idxStart=nPoints - N_ORB_POINT_INTERP;
          idxEnd=nPoints - 1;
        }
      }
      double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,idxStart,idxEnd + 1);
      List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
      for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
        if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[idxStart] && timeStampInterpSecondsRef[i] < secondsDiffFromRefTime[idxEnd]) {
          timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
        }
      }
      List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(idxStart,idxEnd + 1);
      double initTime=Math.max(secondsDiffFromRefTime[orbPoint - 1],zeroDopplerTimeInitRef);
      int idxInitTime=0;
      boolean findIdxInitTime=false;
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
        if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
          idxInitTime=i;
          findIdxInitTime=true;
        }
      }
      double endTime=Math.min(secondsDiffFromRefTime[orbPoint],zeroDopplerTimeEndRef);
      int idxEndTime=0;
      boolean findIdxEndTime=false;
      for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
        if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
          idxEndTime=i;
          findIdxEndTime=true;
        }
      }
      double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
      Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
        timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
      }
      if (findIdxEndTime && findIdxInitTime && initTime < endTime && idxInitTime < idxEndTime) {
        List<double[]> vPoints=new ArrayList<double[]>();
        List<double[]> pPoints=new ArrayList<double[]>();
        List<Double> timeStampOutput=new ArrayList<Double>();
        HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
        addPointsToResult(vPoints,pPoints);
        List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
        for (int i=0; i < timeStampOutput.size(); i++) {
          timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
        }
        if (timeStampInterp == null)         timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else         timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
      }
    }
  }
  if (zeroDopplerTimeEndRef > secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1]) {
    int vOrbPointsInit=(nPoints - Math.min(nPoints,N_ORB_POINT_INTERP));
    int vOrbPointsEnd=nPoints - 1;
    double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,vOrbPointsInit,vOrbPointsEnd + 1);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[vOrbPointsInit]) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(vOrbPointsInit,vOrbPointsEnd + 1);
    double initTime=secondsDiffFromRefTime[vOrbPointsEnd];
    int idxInitTime=0;
    boolean findIdxInitTime=false;
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
      if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
        idxInitTime=i;
        findIdxInitTime=true;
      }
    }
    double endTime=zeroDopplerTimeEndRef;
    int idxEndTime=0;
    boolean findIdxEndTime=false;
    for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
      if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
        idxEndTime=i;
        findIdxEndTime=true;
      }
    }
    double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
    Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
      timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
    }
    if (findIdxEndTime && findIdxInitTime && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
      for (int i=0; i < timeStampOutput.size(); i++) {
        timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
      }
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else       timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
    }
  }
}",0.9935447123599772
175222,"public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=61.77994;
    double lon=-65.66427;
    double r[];
    try {
      r=gc.pixelFromGeo(lon,lat);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}","public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=36.950;
    double lon=-3.6315;
    double r[];
    try {
      r=gc.geoFromPixel(24223,16704);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}",0.853448275862069
175223,"/** 
 */
@Override public double[] pixelFromGeo(final double lon,final double lat) throws GeoLocationException {
  double[] resultReverse=new double[2];
  double[] pXYZ=GeoUtils.convertFromGeoToEarthCentred(lat,lon);
  Double dd2[]=(Double[])orbitInterpolation.getTimeStampInterp().toArray(new Double[0]);
  double[] results=findZeroDoppler(statepVecInterp,pXYZ,ArrayUtils.toPrimitive(dd2));
  double zeroDopplerTime=results[0];
  double srdist=results[1];
  double lNominatore=(zeroDopplerTime - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double lDenom=(orbitInterpolation.getZeroDopplerTimeLastRef() - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double l=(lNominatore / lDenom) * (meta.getNlines() - 1);
  if (meta.getCoordinateConversion() != null && meta.getCoordinateConversion().length > 0) {
    double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
    int index=0;
    for (    S1Metadata.CoordinateConversion cc : coordConv) {
      groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
      index++;
    }
    int idx=0;
    if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
      idx=0;
    }
 else     if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
      idx=groundToSlantRangePolyTimesSeconds.length - 2;
    }
 else {
      for (idx=0; idx < groundToSlantRangePolyTimesSeconds.length; idx++) {
        if (groundToSlantRangePolyTimesSeconds[idx] > zeroDopplerTime)         break;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length - 1) {
        idx=idx - 1;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length) {
        idx=idx - 2;
      }
    }
    double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double[] groundToSlantRangeCoefficientsInterp=new double[coordConv[idx].groundToSlantRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
      groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].groundToSlantRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].groundToSlantRangeCoefficients[idCoeff];
    }
    double[] slantToGroundRangeCoefficientsInterp=new double[coordConv[idx].slantToGroundRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
      slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].slantToGroundRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].slantToGroundRangeCoefficients[idCoeff];
    }
    double newD=0;
    double oldD=0;
    int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
    int[] numCoeffs=new int[nCoeffs];
    int[] numExps=new int[nCoeffs];
    int[] denomCoeffs=new int[nCoeffs];
    int[] denomExps=new int[nCoeffs];
    for (int i=0; i < nCoeffs; i++) {
      numCoeffs[i]=i - 1;
      numExps[i]=i;
      denomCoeffs[i]=i;
      denomExps[i]=i - 1;
    }
    denomExps[0]=0;
    double deltaD=0;
    do {
      double numCoeffsXGround=0;
      double denomCoeffsXGround=0;
      double scalNum=0;
      double scalDen=0;
      for (int i=0; i < groundToSlantRangeCoefficientsInterp.length; i++) {
        double dExp=FastMath.pow(oldD,numExps[i]);
        double denomExp=FastMath.pow(oldD,denomExps[i]);
        numCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * numCoeffs[i];
        denomCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * denomCoeffs[i];
        scalNum=scalNum + dExp * numCoeffsXGround;
        scalDen=scalDen + denomExp * denomCoeffsXGround;
      }
      double num=srdist + scalNum;
      newD=num / scalDen;
      deltaD=FastMath.abs(newD - oldD);
      oldD=newD;
    }
 while (deltaD > 1);
    double p=0;
    if (meta.isPixelTimeOrderingAscending()) {
      p=(newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
 else {
      p=meta.getNumberOfSamplesPerLine() - 1 - (newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
    resultReverse[0]=p;
    resultReverse[1]=l;
    logger.debug(""String_Node_Str"" + l + ""String_Node_Str""+ ""String_Node_Str""+ p);
  }
  return resultReverse;
}","/** 
 * @see In matlab: reverse geolocation
 */
@Override public double[] pixelFromGeo(final double lon,final double lat) throws GeoLocationException {
  double[] resultReverse=new double[2];
  double[] pXYZ=GeoUtils.convertFromGeoToEarthCentred(lat,lon);
  Double dd2[]=(Double[])orbitInterpolation.getTimeStampInterp().toArray(new Double[0]);
  double[] results=findZeroDoppler(statepVecInterp,pXYZ,ArrayUtils.toPrimitive(dd2));
  double zeroDopplerTime=results[0];
  double srdist=results[1];
  double lNominatore=(zeroDopplerTime - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double lDenom=(orbitInterpolation.getZeroDopplerTimeLastRef() - orbitInterpolation.getZeroDopplerTimeFirstRef());
  double l=(lNominatore / lDenom) * (meta.getNlines() - 1);
  if (meta.getCoordinateConversion() != null && meta.getCoordinateConversion().length > 0) {
    double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
    int index=0;
    for (    S1Metadata.CoordinateConversion cc : coordConv) {
      groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
      index++;
    }
    int idx=0;
    if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
      idx=0;
    }
 else     if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
      idx=groundToSlantRangePolyTimesSeconds.length - 2;
    }
 else {
      for (idx=0; idx < groundToSlantRangePolyTimesSeconds.length; idx++) {
        if (groundToSlantRangePolyTimesSeconds[idx] > zeroDopplerTime)         break;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length - 1) {
        idx=idx - 1;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length) {
        idx=idx - 2;
      }
    }
    double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double[] groundToSlantRangeCoefficientsInterp=new double[coordConv[idx].groundToSlantRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
      groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].groundToSlantRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].groundToSlantRangeCoefficients[idCoeff];
    }
    double[] slantToGroundRangeCoefficientsInterp=new double[coordConv[idx].slantToGroundRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
      slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].slantToGroundRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].slantToGroundRangeCoefficients[idCoeff];
    }
    double newD=0;
    double oldD=0;
    int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
    int[] numCoeffs=new int[nCoeffs];
    int[] numExps=new int[nCoeffs];
    int[] denomCoeffs=new int[nCoeffs];
    int[] denomExps=new int[nCoeffs];
    for (int i=0; i < nCoeffs; i++) {
      numCoeffs[i]=i - 1;
      numExps[i]=i;
      denomCoeffs[i]=i;
      denomExps[i]=i - 1;
    }
    denomExps[0]=0;
    double deltaD=0;
    do {
      double numCoeffsXGround=0;
      double denomCoeffsXGround=0;
      double scalNum=0;
      double scalDen=0;
      for (int i=0; i < groundToSlantRangeCoefficientsInterp.length; i++) {
        double dExp=FastMath.pow(oldD,numExps[i]);
        double denomExp=FastMath.pow(oldD,denomExps[i]);
        numCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * numCoeffs[i];
        denomCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * denomCoeffs[i];
        scalNum=scalNum + dExp * numCoeffsXGround;
        scalDen=scalDen + denomExp * denomCoeffsXGround;
      }
      double num=srdist + scalNum;
      newD=num / scalDen;
      deltaD=FastMath.abs(newD - oldD);
      oldD=newD;
    }
 while (deltaD > 1);
    double p=0;
    if (meta.isPixelTimeOrderingAscending()) {
      p=(newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
 else {
      p=meta.getNumberOfSamplesPerLine() - 1 - (newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
    resultReverse[0]=p;
    resultReverse[1]=l;
    logger.debug(""String_Node_Str"" + l + ""String_Node_Str""+ ""String_Node_Str""+ p);
  }
  return resultReverse;
}",0.9958023894091056
175224,"/** 
 * In Matlab forwardgeolocation
 */
@Override public double[] geoFromPixel(final double p,final double l) throws GeoLocationException {
  try {
    double[] results=new double[2];
    double lon=0;
    double lat=0;
    double t0=0;
    int idxStartT0=0;
    if (meta.getType().equalsIgnoreCase(""String_Node_Str"") && meta.getProductType().equalsIgnoreCase(""String_Node_Str"") && (meta.getMode().equalsIgnoreCase(""String_Node_Str"") || meta.getMode().equalsIgnoreCase(""String_Node_Str""))) {
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    }
 else {
      double t01=(orbitInterpolation.getZeroDopplerTimeFirstRef()) * (meta.getNlines() - 1 - l);
      double t02=orbitInterpolation.getZeroDopplerTimeLastRef() * l;
      t0=(t01 + t02) / (meta.getNlines() - 1);
      for (idxStartT0=0; idxStartT0 < orbitInterpolation.getTimeStampInterp().size(); idxStartT0++) {
        if (orbitInterpolation.getTimeStampInterp().get(idxStartT0) >= t0) {
          break;
        }
      }
      if (idxStartT0 == statepVecInterp.size())       idxStartT0--;
    }
    final double[] pT0=statepVecInterp.get(idxStartT0);
    final double[] vT0=statevVecInterp.get(idxStartT0);
    double distance=0;
    if (meta.isPixelTimeOrderingAscending()) {
      distance=p * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
 else {
      distance=(meta.getNumberOfSamplesPerLine() - 1 - p) * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
    if (coordConv != null) {
      double zeroDopplerTime=t0;
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
      double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
      int index=0;
      for (      S1Metadata.CoordinateConversion cc : coordConv) {
        groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
        index++;
      }
      int idx=0;
      if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
        idx=1;
      }
 else       if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
        idx=groundToSlantRangePolyTimesSeconds.length - 2;
      }
 else {
        for (idx=0; idx < groundToSlantRangePolyTimesSeconds.length; idx++) {
          if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)           break;
        }
      }
      double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double[] groundToSlantRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].groundToSlantRangeCoefficients);
      double[] groundToSlantRangeCoefficientsInterp2=coordConv[idx + 1].groundToSlantRangeCoefficients;
      for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
        groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * groundToSlantRangeCoefficientsInterp[idCoeff] + factor2 * groundToSlantRangeCoefficientsInterp2[idCoeff];
      }
      double[] slantToGroundRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].slantToGroundRangeCoefficients);
      double[] slantToGroundRangeCoefficientsInterp2=coordConv[idx + 1].slantToGroundRangeCoefficients;
      for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
        slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * slantToGroundRangeCoefficientsInterp[idCoeff] + factor2 * slantToGroundRangeCoefficientsInterp2[idCoeff];
      }
      int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
      int[] vExps=new int[nCoeffs];
      for (int i=0; i < nCoeffs; i++) {
        vExps[i]=i;
      }
      double tmpD=distance - meta.getGroundRangeOrigin();
      double[] pows=MathUtil.powValue2Coeffs(tmpD,vExps);
      double sRdist=MathUtil.vectorProd1XN(groundToSlantRangeCoefficientsInterp,pows);
      logger.debug(""String_Node_Str"" + sRdist);
      double normPt0=MathUtil.norm(pT0);
      double vRadial=MathUtil.vectorProd1XN(vT0,pT0) / normPt0;
      double vTangential=FastMath.sqrt(FastMath.pow(MathUtil.norm(vT0),2) - FastMath.pow(vRadial,2));
      double tanPsi=vRadial / vTangential;
      double[] zsUnit=MathUtil.divVectByVal(pT0,-normPt0);
      double[] vTmp=MathUtil.crossProd3x3(zsUnit,vT0);
      double[] ysUnit=MathUtil.divVectByVal(vTmp,MathUtil.norm(vTmp));
      double[] xsUnit=MathUtil.crossProd3x3(ysUnit,zsUnit);
      double pH=0;
      double rEarth=normPt0 / FastMath.sqrt((pT0[0] * pT0[0] + pT0[1] * pT0[1]) / GeoUtils.semiMajorAxis2 + (pT0[2] * pT0[2]) / GeoUtils.semiMinorAxis2);
      for (int iidx=0; iidx < 2; iidx++) {
        rEarth=rEarth + pH;
        double rEarthOld=rEarth;
        double rEarthChange=100000;
        double[] q=new double[3];
        for (; rEarthChange > 0.1; ) {
          double Rz=(normPt0 * normPt0 + sRdist * sRdist - rEarth * rEarth) / (2 * normPt0);
          double Rx=Rz * tanPsi;
          double Ry=FastMath.sqrt(sRdist * sRdist - Rz * Rz - Rx * Rx);
          if (!meta.getAntennaPointing().equalsIgnoreCase(""String_Node_Str"")) {
            Ry=-Ry;
          }
          double[][] sRvect=new double[][]{{Rx},{Ry},{Rz - normPt0}};
          double[][] qbig=new double[][]{xsUnit,ysUnit,zsUnit};
          qbig=MathUtil.transpose(qbig);
          double[][] qmat=MathUtil.multiplyMatrix(qbig,sRvect);
          q[0]=qmat[0][0];
          q[1]=qmat[1][0];
          q[2]=qmat[2][0];
          rEarth=MathUtil.norm(q) / FastMath.sqrt((q[0] * q[0] + q[1] * q[1]) / GeoUtils.semiMajorAxis2 + (q[2] * q[2] / GeoUtils.semiMinorAxis2)) + pH;
          rEarthChange=FastMath.abs(rEarth - rEarthOld);
          rEarthOld=rEarth;
        }
        lon=FastMath.atan2(q[1],q[0]) * 180 / FastMath.PI;
        double lattmp=FastMath.asin(q[2] / FastMath.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]));
        lat=FastMath.atan(FastMath.tan(lattmp) * FastMath.pow((GeoUtils.semiMajorAxis + pH),2) / FastMath.pow((GeoUtils.semiMinorAxis + pH),2)) * 180 / FastMath.PI;
        pH=GeoUtils.getGeoidH(lon,lat);
      }
    }
    logger.debug(""String_Node_Str"" + lat + ""String_Node_Str""+ lon);
    results[0]=lon;
    results[1]=lat;
    return results;
  }
 catch (  MathException me) {
    throw new GeoLocationException(GeoLocationException.MSG_CONV_FROM_PIXEL_TO_GEO + ""String_Node_Str"" + me.getMessage());
  }
}","/** 
 * @see In Matlab forwardgeolocation
 */
@Override public double[] geoFromPixel(final double p,final double l) throws GeoLocationException {
  try {
    double[] results=new double[2];
    double lon=0;
    double lat=0;
    double t0=0;
    int idxStartT0=0;
    if (meta.getType().equalsIgnoreCase(""String_Node_Str"") && meta.getProductType().equalsIgnoreCase(""String_Node_Str"") && (meta.getMode().equalsIgnoreCase(""String_Node_Str"") || meta.getMode().equalsIgnoreCase(""String_Node_Str""))) {
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    }
 else {
      double t01=(orbitInterpolation.getZeroDopplerTimeFirstRef()) * (meta.getNlines() - 1 - l);
      double t02=orbitInterpolation.getZeroDopplerTimeLastRef() * l;
      t0=(t01 + t02) / (meta.getNlines() - 1);
      for (idxStartT0=0; idxStartT0 < orbitInterpolation.getTimeStampInterp().size(); idxStartT0++) {
        if (orbitInterpolation.getTimeStampInterp().get(idxStartT0) >= t0) {
          break;
        }
      }
      if (idxStartT0 == statepVecInterp.size())       idxStartT0--;
    }
    final double[] pT0=statepVecInterp.get(idxStartT0);
    final double[] vT0=statevVecInterp.get(idxStartT0);
    double distance=0;
    if (meta.isPixelTimeOrderingAscending()) {
      distance=p * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
 else {
      distance=(meta.getNumberOfSamplesPerLine() - 1 - p) * meta.getSamplePixelSpacing() - meta.getGroundRangeOrigin();
    }
    if (coordConv != null) {
      double zeroDopplerTime=t0;
      double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
      double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
      int index=0;
      for (      S1Metadata.CoordinateConversion cc : coordConv) {
        groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
        index++;
      }
      int idx=0;
      if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
        idx=1;
      }
 else       if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
        idx=groundToSlantRangePolyTimesSeconds.length - 2;
      }
 else {
        for (idx=0; idx < groundToSlantRangePolyTimesSeconds.length; idx++) {
          if (groundToSlantRangePolyTimesSeconds[idx] < zeroDopplerTime)           break;
        }
      }
      double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
      double[] groundToSlantRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].groundToSlantRangeCoefficients);
      double[] groundToSlantRangeCoefficientsInterp2=coordConv[idx + 1].groundToSlantRangeCoefficients;
      for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
        groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * groundToSlantRangeCoefficientsInterp[idCoeff] + factor2 * groundToSlantRangeCoefficientsInterp2[idCoeff];
      }
      double[] slantToGroundRangeCoefficientsInterp=ArrayUtils.clone(coordConv[idx].slantToGroundRangeCoefficients);
      double[] slantToGroundRangeCoefficientsInterp2=coordConv[idx + 1].slantToGroundRangeCoefficients;
      for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
        slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * slantToGroundRangeCoefficientsInterp[idCoeff] + factor2 * slantToGroundRangeCoefficientsInterp2[idCoeff];
      }
      int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
      int[] vExps=new int[nCoeffs];
      for (int i=0; i < nCoeffs; i++) {
        vExps[i]=i;
      }
      double tmpD=distance - meta.getGroundRangeOrigin();
      double[] pows=MathUtil.powValue2Coeffs(tmpD,vExps);
      double sRdist=MathUtil.vectorProd1XN(groundToSlantRangeCoefficientsInterp,pows);
      logger.debug(""String_Node_Str"" + sRdist);
      double normPt0=MathUtil.norm(pT0);
      double vRadial=MathUtil.vectorProd1XN(vT0,pT0) / normPt0;
      double vTangential=FastMath.sqrt(FastMath.pow(MathUtil.norm(vT0),2) - FastMath.pow(vRadial,2));
      double tanPsi=vRadial / vTangential;
      double[] zsUnit=MathUtil.divVectByVal(pT0,-normPt0);
      double[] vTmp=MathUtil.crossProd3x3(zsUnit,vT0);
      double[] ysUnit=MathUtil.divVectByVal(vTmp,MathUtil.norm(vTmp));
      double[] xsUnit=MathUtil.crossProd3x3(ysUnit,zsUnit);
      double pH=0;
      double rEarth=normPt0 / FastMath.sqrt((pT0[0] * pT0[0] + pT0[1] * pT0[1]) / GeoUtils.semiMajorAxis2 + (pT0[2] * pT0[2]) / GeoUtils.semiMinorAxis2);
      for (int iidx=0; iidx < 2; iidx++) {
        rEarth=rEarth + pH;
        double rEarthOld=rEarth;
        double rEarthChange=100000;
        double[] q=new double[3];
        for (; rEarthChange > 0.1; ) {
          double Rz=(normPt0 * normPt0 + sRdist * sRdist - rEarth * rEarth) / (2 * normPt0);
          double Rx=Rz * tanPsi;
          double Ry=FastMath.sqrt(sRdist * sRdist - Rz * Rz - Rx * Rx);
          if (!meta.getAntennaPointing().equalsIgnoreCase(""String_Node_Str"")) {
            Ry=-Ry;
          }
          double[][] sRvect=new double[][]{{Rx},{Ry},{Rz - normPt0}};
          double[][] qbig=new double[][]{xsUnit,ysUnit,zsUnit};
          qbig=MathUtil.transpose(qbig);
          double[][] qmat=MathUtil.multiplyMatrix(qbig,sRvect);
          q[0]=qmat[0][0];
          q[1]=qmat[1][0];
          q[2]=qmat[2][0];
          rEarth=MathUtil.norm(q) / FastMath.sqrt((q[0] * q[0] + q[1] * q[1]) / GeoUtils.semiMajorAxis2 + (q[2] * q[2] / GeoUtils.semiMinorAxis2)) + pH;
          rEarthChange=FastMath.abs(rEarth - rEarthOld);
          rEarthOld=rEarth;
        }
        lon=FastMath.atan2(q[1],q[0]) * 180 / FastMath.PI;
        double lattmp=FastMath.asin(q[2] / FastMath.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]));
        lat=FastMath.atan(FastMath.tan(lattmp) * FastMath.pow((GeoUtils.semiMajorAxis + pH),2) / FastMath.pow((GeoUtils.semiMinorAxis + pH),2)) * 180 / FastMath.PI;
        pH=GeoUtils.getGeoidH(lon,lat);
      }
    }
    logger.debug(""String_Node_Str"" + lat + ""String_Node_Str""+ lon);
    results[0]=lon;
    results[1]=lat;
    return results;
  }
 catch (  MathException me) {
    throw new GeoLocationException(GeoLocationException.MSG_CONV_FROM_PIXEL_TO_GEO + ""String_Node_Str"" + me.getMessage());
  }
}",0.9996265033241204
175225,"public void orbitInterpolation(List<S1Metadata.OrbitStatePosVelox> vpList,double zeroDopplerTimeFirstLineSeconds,double zeroDopplerTimeLastLineSeconds,double samplingf,double iSafetyBufferAz) throws MathException {
  this.iSafetyBufferAz=iSafetyBufferAz;
  double deltaT=1 / samplingf;
  double deltaTinv=1 / deltaT;
  int nPoints=vpList.size();
  double reftime=0;
  double firstTime=vpList.get(0).time;
  double lastTime=vpList.get(vpList.size() - 1).time;
  if (firstTime < (lastTime)) {
    reftime=firstTime;
  }
 else {
    reftime=lastTime;
  }
  int idx=0;
  secondsDiffFromRefTime=new double[vpList.size()];
  for (  S1Metadata.OrbitStatePosVelox vp : vpList) {
    secondsDiffFromRefTime[idx]=(vp.time - reftime);
    idx++;
  }
  zeroDopplerTimeFirstRef=(zeroDopplerTimeFirstLineSeconds - reftime);
  zeroDopplerTimeLastRef=(zeroDopplerTimeLastLineSeconds - reftime);
  double minT=0;
  double maxT=0;
  double zeroDopplerTimeFirstLineWSafetyBufSecondsRef=0;
  double zeroDopplerTimeLastLineWSafetyBufSecondsRef=0;
  if (zeroDopplerTimeFirstRef < zeroDopplerTimeLastRef) {
    zeroDopplerTimeFirstLineWSafetyBufSecondsRef=zeroDopplerTimeFirstRef - iSafetyBufferAz * deltaT;
    zeroDopplerTimeLastLineWSafetyBufSecondsRef=zeroDopplerTimeLastRef + iSafetyBufferAz * deltaT;
    minT=FastMath.min(0,zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
    maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeLastLineWSafetyBufSecondsRef);
  }
 else {
    zeroDopplerTimeFirstLineWSafetyBufSecondsRef=zeroDopplerTimeFirstRef + iSafetyBufferAz * deltaT;
    zeroDopplerTimeLastLineWSafetyBufSecondsRef=zeroDopplerTimeLastRef - iSafetyBufferAz * deltaT;
    if (firstTime < (lastTime)) {
      minT=FastMath.min(secondsDiffFromRefTime[0],zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
      maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
    }
 else {
      minT=FastMath.min(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
      maxT=FastMath.max(secondsDiffFromRefTime[0],zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
    }
  }
  int limit=((Double)((maxT - minT) / deltaT)).intValue();
  Double[] timeStampInterpSecondsRef=new Double[limit + 1];
  double nextVal=0;
  for (int j=0; j <= limit; j++) {
    timeStampInterpSecondsRef[j]=nextVal;
    nextVal=deltaT + nextVal;
  }
  double zeroDopplerTimeInitRef=zeroDopplerTimeFirstRef;
  double zeroDopplerTimeEndRef=zeroDopplerTimeLastRef;
  if (zeroDopplerTimeFirstRef > zeroDopplerTimeLastRef) {
    zeroDopplerTimeInitRef=zeroDopplerTimeLastRef;
    zeroDopplerTimeEndRef=zeroDopplerTimeFirstRef;
  }
  if (zeroDopplerTimeInitRef < timeStampInterpSecondsRef[1]) {
    int size=Math.min(nPoints,N_ORB_POINT_INTERP);
    double[] subTimesDiffRef=Arrays.copyOfRange(secondsDiffFromRefTime,0,nPoints);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < size; i++) {
      double valMax=timeStampInterpSecondsRef[size - 1];
      if (timeStampInterpSecondsRef[i] < valMax) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<IMetadata.OrbitStatePosVelox> subList=vpList.subList(0,size);
    double initTime=zeroDopplerTimeInitRef;
    int idxInitTime=-1;
    boolean finded=false;
    double endTime=secondsDiffFromRefTime[0];
    int idxEndTime=-1;
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= initTime && !finded) {
        idxInitTime=i;
        finded=true;
      }
      if (timeStampInterpSecondsRef[i] < endTime) {
        idxEndTime=i;
      }
    }
    logger.debug(""String_Node_Str"" + idxInitTime + ""String_Node_Str""+ idxEndTime);
    Double[] t0=(Double[])timeStampInitSecondsRefPointsInterp.toArray(new Double[0]);
    if (idxInitTime != -1 && idxEndTime != -1 && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(subTimesDiffRef,subList,t0,idxInitTime,idxEndTime,deltaTinv,vPoints,pPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampOutput);
 else       timeStampInterp.addAll(timeStampOutput);
    }
  }
  for (int orbPoint=1; orbPoint < nPoints; orbPoint++) {
    if (secondsDiffFromRefTime[orbPoint - 1] < zeroDopplerTimeEndRef || secondsDiffFromRefTime[orbPoint] > zeroDopplerTimeEndRef) {
      int idxStart=0;
      int idxEnd=0;
      if (N_ORB_POINT_INTERP > nPoints) {
        idxEnd=nPoints;
      }
 else {
        idxStart=orbPoint - new Double(Math.floor(N_ORB_POINT_INTERP / 2)).intValue();
        idxEnd=idxStart + N_ORB_POINT_INTERP - 1;
        if (idxStart < 1) {
          idxStart=0;
          idxEnd=N_ORB_POINT_INTERP - 1;
        }
        if (idxEnd >= nPoints) {
          idxStart=nPoints - N_ORB_POINT_INTERP;
          idxEnd=nPoints - 1;
        }
      }
      double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,idxStart,idxEnd + 1);
      List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
      for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
        if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[idxStart] && timeStampInterpSecondsRef[i] < secondsDiffFromRefTime[idxEnd]) {
          timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
        }
      }
      List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(idxStart,idxEnd + 1);
      double initTime=Math.max(secondsDiffFromRefTime[orbPoint - 1],zeroDopplerTimeInitRef);
      int idxInitTime=0;
      boolean findIdxInitTime=false;
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
        if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
          idxInitTime=i;
          findIdxInitTime=true;
        }
      }
      double endTime=Math.min(secondsDiffFromRefTime[orbPoint],zeroDopplerTimeEndRef);
      int idxEndTime=0;
      boolean findIdxEndTime=false;
      for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
        if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
          idxEndTime=i;
          findIdxEndTime=true;
        }
      }
      double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
      Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
        timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
      }
      if (findIdxEndTime && findIdxInitTime && initTime < endTime && idxInitTime < idxEndTime) {
        List<double[]> vPoints=new ArrayList<double[]>();
        List<double[]> pPoints=new ArrayList<double[]>();
        List<Double> timeStampOutput=new ArrayList<Double>();
        HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
        addPointsToResult(vPoints,pPoints);
        List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
        for (int i=0; i < timeStampOutput.size(); i++) {
          timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
        }
        if (timeStampInterp == null)         timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else         timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
      }
    }
  }
  if (zeroDopplerTimeEndRef > secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1]) {
    int vOrbPointsInit=(nPoints - Math.min(nPoints,N_ORB_POINT_INTERP));
    int vOrbPointsEnd=nPoints - 1;
    double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,vOrbPointsInit,vOrbPointsEnd + 1);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[vOrbPointsInit]) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(vOrbPointsInit,vOrbPointsEnd + 1);
    double initTime=secondsDiffFromRefTime[vOrbPointsEnd];
    int idxInitTime=0;
    boolean findIdxInitTime=false;
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
      if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
        idxInitTime=i;
        findIdxInitTime=true;
      }
    }
    double endTime=zeroDopplerTimeEndRef;
    int idxEndTime=0;
    boolean findIdxEndTime=false;
    for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
      if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
        idxEndTime=i;
        findIdxEndTime=true;
      }
    }
    double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
    Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
      timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
    }
    if (findIdxEndTime && findIdxInitTime && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
      for (int i=0; i < timeStampOutput.size(); i++) {
        timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
      }
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else       timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
    }
  }
}","public void orbitInterpolation(List<S1Metadata.OrbitStatePosVelox> vpList,double zeroDopplerTimeFirstLineSeconds,double zeroDopplerTimeLastLineSeconds,double samplingf,double iSafetyBufferAz) throws MathException {
  this.iSafetyBufferAz=iSafetyBufferAz;
  double deltaT=1 / samplingf;
  double deltaTinv=1 / deltaT;
  int nPoints=vpList.size();
  double reftime=0;
  double firstTime=vpList.get(0).time;
  double lastTime=vpList.get(vpList.size() - 1).time;
  if (firstTime < (lastTime)) {
    reftime=firstTime;
  }
 else {
    reftime=lastTime;
  }
  int idx=0;
  secondsDiffFromRefTime=new double[vpList.size()];
  for (  S1Metadata.OrbitStatePosVelox vp : vpList) {
    secondsDiffFromRefTime[idx]=(vp.time - reftime);
    idx++;
  }
  zeroDopplerTimeFirstRef=(zeroDopplerTimeFirstLineSeconds - reftime);
  zeroDopplerTimeLastRef=(zeroDopplerTimeLastLineSeconds - reftime);
  double minT=0;
  double maxT=0;
  double zeroDopplerTimeFirstLineWSafetyBufSecondsRef=0;
  double zeroDopplerTimeLastLineWSafetyBufSecondsRef=0;
  if (zeroDopplerTimeFirstRef < zeroDopplerTimeLastRef) {
    zeroDopplerTimeFirstLineWSafetyBufSecondsRef=zeroDopplerTimeFirstRef - iSafetyBufferAz * deltaT;
    zeroDopplerTimeLastLineWSafetyBufSecondsRef=zeroDopplerTimeLastRef + iSafetyBufferAz * deltaT;
    minT=FastMath.min(0,zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
    maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeLastLineWSafetyBufSecondsRef);
  }
 else {
    zeroDopplerTimeFirstLineWSafetyBufSecondsRef=zeroDopplerTimeFirstRef + iSafetyBufferAz * deltaT;
    zeroDopplerTimeLastLineWSafetyBufSecondsRef=zeroDopplerTimeLastRef - iSafetyBufferAz * deltaT;
    if (firstTime < (lastTime)) {
      minT=FastMath.min(secondsDiffFromRefTime[0],zeroDopplerTimeLastLineWSafetyBufSecondsRef);
      maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
    }
 else {
      minT=FastMath.min(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeLastLineWSafetyBufSecondsRef);
      maxT=FastMath.max(secondsDiffFromRefTime[0],zeroDopplerTimeFirstLineWSafetyBufSecondsRef);
    }
  }
  int limit=((Double)((maxT - minT) / deltaT)).intValue();
  Double[] timeStampInterpSecondsRef=new Double[limit + 1];
  double nextVal=0;
  for (int j=0; j <= limit; j++) {
    timeStampInterpSecondsRef[j]=nextVal;
    nextVal=deltaT + nextVal;
  }
  double zeroDopplerTimeInitRef=zeroDopplerTimeFirstLineWSafetyBufSecondsRef;
  double zeroDopplerTimeEndRef=zeroDopplerTimeLastLineWSafetyBufSecondsRef;
  if (zeroDopplerTimeFirstLineWSafetyBufSecondsRef > zeroDopplerTimeLastLineWSafetyBufSecondsRef) {
    zeroDopplerTimeInitRef=zeroDopplerTimeLastLineWSafetyBufSecondsRef;
    zeroDopplerTimeEndRef=zeroDopplerTimeFirstLineWSafetyBufSecondsRef;
  }
  if (zeroDopplerTimeInitRef < timeStampInterpSecondsRef[1]) {
    int size=Math.min(nPoints,N_ORB_POINT_INTERP);
    double[] subTimesDiffRef=Arrays.copyOfRange(secondsDiffFromRefTime,0,nPoints);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < size; i++) {
      double valMax=timeStampInterpSecondsRef[size - 1];
      if (timeStampInterpSecondsRef[i] < valMax) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<IMetadata.OrbitStatePosVelox> subList=vpList.subList(0,size);
    double initTime=zeroDopplerTimeInitRef;
    int idxInitTime=-1;
    boolean finded=false;
    double endTime=secondsDiffFromRefTime[0];
    int idxEndTime=-1;
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= initTime && !finded) {
        idxInitTime=i;
        finded=true;
      }
      if (timeStampInterpSecondsRef[i] < endTime) {
        idxEndTime=i;
      }
    }
    logger.debug(""String_Node_Str"" + idxInitTime + ""String_Node_Str""+ idxEndTime);
    Double[] t0=(Double[])timeStampInitSecondsRefPointsInterp.toArray(new Double[0]);
    if (idxInitTime != -1 && idxEndTime != -1 && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(subTimesDiffRef,subList,t0,idxInitTime,idxEndTime,deltaTinv,vPoints,pPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampOutput);
 else       timeStampInterp.addAll(timeStampOutput);
    }
  }
  for (int orbPoint=1; orbPoint < nPoints; orbPoint++) {
    if (secondsDiffFromRefTime[orbPoint - 1] < zeroDopplerTimeEndRef || secondsDiffFromRefTime[orbPoint] > zeroDopplerTimeEndRef) {
      int idxStart=0;
      int idxEnd=0;
      if (N_ORB_POINT_INTERP > nPoints) {
        idxEnd=nPoints;
      }
 else {
        idxStart=orbPoint - new Double(Math.floor(N_ORB_POINT_INTERP / 2)).intValue();
        idxEnd=idxStart + N_ORB_POINT_INTERP - 1;
        if (idxStart < 1) {
          idxStart=0;
          idxEnd=N_ORB_POINT_INTERP - 1;
        }
        if (idxEnd >= nPoints) {
          idxStart=nPoints - N_ORB_POINT_INTERP;
          idxEnd=nPoints - 1;
        }
      }
      double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,idxStart,idxEnd + 1);
      List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
      for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
        if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[idxStart] && timeStampInterpSecondsRef[i] < secondsDiffFromRefTime[idxEnd]) {
          timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
        }
      }
      List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(idxStart,idxEnd + 1);
      double initTime=Math.max(secondsDiffFromRefTime[orbPoint - 1],zeroDopplerTimeInitRef);
      int idxInitTime=0;
      boolean findIdxInitTime=false;
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
        if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
          idxInitTime=i;
          findIdxInitTime=true;
        }
      }
      double endTime=Math.min(secondsDiffFromRefTime[orbPoint],zeroDopplerTimeEndRef);
      int idxEndTime=0;
      boolean findIdxEndTime=false;
      for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
        if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
          idxEndTime=i;
          findIdxEndTime=true;
        }
      }
      double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
      Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
        timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
      }
      if (findIdxEndTime && findIdxInitTime && initTime < endTime && idxInitTime < idxEndTime) {
        List<double[]> vPoints=new ArrayList<double[]>();
        List<double[]> pPoints=new ArrayList<double[]>();
        List<Double> timeStampOutput=new ArrayList<Double>();
        HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
        addPointsToResult(vPoints,pPoints);
        List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
        for (int i=0; i < timeStampOutput.size(); i++) {
          timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
        }
        if (timeStampInterp == null)         timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else         timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
      }
    }
  }
  if (zeroDopplerTimeEndRef > secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1]) {
    int vOrbPointsInit=(nPoints - Math.min(nPoints,N_ORB_POINT_INTERP));
    int vOrbPointsEnd=nPoints - 1;
    double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,vOrbPointsInit,vOrbPointsEnd + 1);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[vOrbPointsInit]) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(vOrbPointsInit,vOrbPointsEnd + 1);
    double initTime=secondsDiffFromRefTime[vOrbPointsEnd];
    int idxInitTime=0;
    boolean findIdxInitTime=false;
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
      if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
        idxInitTime=i;
        findIdxInitTime=true;
      }
    }
    double endTime=zeroDopplerTimeEndRef;
    int idxEndTime=0;
    boolean findIdxEndTime=false;
    for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
      if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
        idxEndTime=i;
        findIdxEndTime=true;
      }
    }
    double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
    Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
      timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
    }
    if (findIdxEndTime && findIdxInitTime && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
      for (int i=0; i < timeStampOutput.size(); i++) {
        timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
      }
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else       timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
    }
  }
}",0.9935447123599772
175226,"/** 
 * @param imageFile
 * @param band form files with multiple band
 */
public TIFF(File imageFile,int band){
  this.imageFile=imageFile;
  try {
    Iterator<ImageReader> readers=ImageIO.getImageReadersByFormatName(""String_Node_Str"");
    boolean worked=false;
    while (readers.hasNext() && !worked) {
      Object obj=readers.next();
      if (obj instanceof TIFFImageReader) {
        reader=(TIFFImageReader)obj;
        ImageInputStream iis=ImageIO.createImageInputStream(imageFile);
        reader.setInput(iis);
        xSize=reader.getWidth(band);
        ySize=reader.getHeight(band);
        bounds=new Rectangle(0,0,xSize,ySize);
        worked=true;
      }
 else {
      }
    }
    if (!worked) {
      logger.warn(""String_Node_Str"");
    }
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
}","/** 
 * @param imageFile
 * @param band form files with multiple band
 */
public TIFF(File imageFile,int band){
  this.imageFile=imageFile;
  try {
    Iterator<ImageReader> readers=ImageIO.getImageReadersByFormatName(""String_Node_Str"");
    boolean worked=false;
    while (readers.hasNext() && !worked) {
      Object obj=readers.next();
      if (obj instanceof TIFFImageReader) {
        reader=(TIFFImageReader)obj;
        ImageInputStream iis=ImageIO.createImageInputStream(imageFile);
        reader.setInput(iis);
        try {
          xSize=reader.getWidth(band);
          ySize=reader.getHeight(band);
          bounds=new Rectangle(0,0,xSize,ySize);
        }
 catch (        Exception e) {
          bounds=null;
          logger.warn(""String_Node_Str"");
        }
        worked=true;
      }
 else {
      }
    }
    if (!worked) {
      logger.warn(""String_Node_Str"");
    }
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
}",0.9244444444444444
175227,"public void parseProductXML(File productxml) throws TransformException {
  try {
    SAXBuilder builder=new SAXBuilder();
    doc=builder.build(productxml);
    Element atts=doc.getRootElement().getChild(""String_Node_Str"");
    setSatellite(""String_Node_Str"");
    setSensor(""String_Node_Str"");
    String pols=""String_Node_Str"";
    for (    Object o : atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChildren(""String_Node_Str"")) {
      Element elem=(Element)o;
      pols=pols + elem.getText() + ""String_Node_Str"";
    }
    pols.substring(0,pols.length() - 1);
    setPolarization(pols);
    setLookDirection(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setMode(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setProduct(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setOrbitDirection(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setMetaHeight(Integer.parseInt(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    String w=atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setMetaWidth(Integer.parseInt(w));
    setRangeSpacing(Float.parseFloat(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    setAzimuthSpacing(Float.parseFloat(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    setNumberOfBytes(new Integer(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()) / 8);
    setENL(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setHeadingAngle(Double.parseDouble(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    rangeTimeStart=Double.valueOf(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    rangeTimeStop=Double.valueOf(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    String time=atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setTimeStampStart(time.replaceAll(""String_Node_Str"",""String_Node_Str""));
    time=atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setTimeStampStop(time.replaceAll(""String_Node_Str"",""String_Node_Str""));
    atts=doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"");
    double xvelocity=Double.valueOf(atts.getChildText(""String_Node_Str""));
    double yvelocity=Double.valueOf(atts.getChildText(""String_Node_Str""));
    double zvelocity=Double.valueOf(atts.getChildText(""String_Node_Str""));
    double satellite_speed=Math.sqrt(xvelocity * xvelocity + yvelocity * yvelocity + zvelocity * zvelocity);
    setSatelliteSpeed(satellite_speed);
    xposition=Double.valueOf(atts.getChildText(""String_Node_Str""));
    yposition=Double.valueOf(atts.getChildText(""String_Node_Str""));
    zposition=Double.valueOf(atts.getChildText(""String_Node_Str""));
    float radarFrequency=new Float(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setRadarWaveLenght(299792457.9 / radarFrequency);
    setSatelliteOrbitInclination(97.44);
    setRevolutionsPerday(11);
    Double[] prf=new Double[3];
    if (getMode().equals(""String_Node_Str"")) {
      int prf_count=0;
      for (      Object o : doc.getRootElement().getChild(""String_Node_Str"").getChildren(""String_Node_Str"")) {
        Element elem=(Element)o;
        prf[prf_count]=Double.parseDouble(elem.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
        prf_count++;
      }
      setPRF1(prf[0]);
      setPRF2(prf[1]);
      setPRF3(prf[2]);
      setPRF(null);
      int b=0;
      int strip[]=new int[3];
      for (      Object o : doc.getRootElement().getChild(""String_Node_Str"").getChildren(""String_Node_Str"")) {
        if (b == 3) {
          continue;
        }
        Element elem=(Element)o;
        double start_range_time=new Double(elem.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
        double stop_range_time=new Double(elem.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
        double aver_range_time=start_range_time + (stop_range_time - start_range_time) / 2;
        int width=Integer.parseInt(w);
        int stripBound=new Double(((aver_range_time - rangeTimeStart) * width) / (rangeTimeStop - rangeTimeStart)).intValue();
        strip[0]=new Integer(stripBound);
        b++;
      }
      setStripBound1(strip[0]);
      setStripBound2(strip[1]);
      setStripBound3(strip[2]);
    }
    String val=doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setK(Double.parseDouble(val));
    MGRows=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGCols=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGRefRow=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGRefCol=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGRowSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGColSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    String MGtTimes=doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    MGtTimes=MGtTimes.substring(0,MGtTimes.length() - 1);
    MGtTime=Timestamp.valueOf(MGtTimes.replaceAll(""String_Node_Str"",""String_Node_Str"")).getTime();
    MGtauTime=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    ImageRowSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    ImageColSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
  }
 catch (  JDOMException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
}","public void parseProductXML(File productxml) throws TransformException {
  try {
    SAXBuilder builder=new SAXBuilder();
    doc=builder.build(productxml);
    Element atts=doc.getRootElement().getChild(""String_Node_Str"");
    setSatellite(""String_Node_Str"");
    setSensor(""String_Node_Str"");
    String pols=""String_Node_Str"";
    for (    Object o : atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChildren(""String_Node_Str"")) {
      Element elem=(Element)o;
      pols=pols + elem.getText() + ""String_Node_Str"";
    }
    pols.substring(0,pols.length() - 1);
    setPolarization(pols);
    setLookDirection(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setMode(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setProduct(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setOrbitDirection(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setMetaHeight(Integer.parseInt(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    String w=atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setMetaWidth(Integer.parseInt(w));
    setRangeSpacing(Float.parseFloat(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    setAzimuthSpacing(Float.parseFloat(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    setNumberOfBytes(new Integer(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()) / 8);
    setENL(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setHeadingAngle(Double.parseDouble(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    rangeTimeStart=Double.valueOf(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    rangeTimeStop=Double.valueOf(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    String time=atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setTimeStampStart(time.replaceAll(""String_Node_Str"",""String_Node_Str""));
    time=atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setTimeStampStop(time.replaceAll(""String_Node_Str"",""String_Node_Str""));
    atts=doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"");
    double xvelocity=Double.valueOf(atts.getChildText(""String_Node_Str""));
    double yvelocity=Double.valueOf(atts.getChildText(""String_Node_Str""));
    double zvelocity=Double.valueOf(atts.getChildText(""String_Node_Str""));
    double satellite_speed=Math.sqrt(xvelocity * xvelocity + yvelocity * yvelocity + zvelocity * zvelocity);
    setSatelliteSpeed(satellite_speed);
    xposition=Double.valueOf(atts.getChildText(""String_Node_Str""));
    yposition=Double.valueOf(atts.getChildText(""String_Node_Str""));
    zposition=Double.valueOf(atts.getChildText(""String_Node_Str""));
    float radarFrequency=new Float(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setRadarWaveLenght(299792457.9 / radarFrequency);
    setSatelliteOrbitInclination(97.44);
    setRevolutionsPerday(11);
    Double[] prf=null;
    if (getMode().equals(""String_Node_Str"")) {
      List<Element> sets=doc.getRootElement().getChild(""String_Node_Str"").getChildren(""String_Node_Str"");
      prf=new Double[sets.size()];
      int prf_count=0;
      for (      Object o : sets) {
        Element elem=(Element)o;
        prf[prf_count]=Double.parseDouble(elem.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
        prf_count++;
      }
      setPRF1(prf[0]);
      setPRF2(prf[1]);
      setPRF3(prf[2]);
      setPRF(null);
      int b=0;
      int strip[]=new int[3];
      for (      Object o : doc.getRootElement().getChild(""String_Node_Str"").getChildren(""String_Node_Str"")) {
        if (b == 3) {
          continue;
        }
        Element elem=(Element)o;
        double start_range_time=new Double(elem.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
        double stop_range_time=new Double(elem.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
        double aver_range_time=start_range_time + (stop_range_time - start_range_time) / 2;
        int width=Integer.parseInt(w);
        int stripBound=new Double(((aver_range_time - rangeTimeStart) * width) / (rangeTimeStop - rangeTimeStart)).intValue();
        strip[0]=new Integer(stripBound);
        b++;
      }
      setStripBound1(strip[0]);
      setStripBound2(strip[1]);
      setStripBound3(strip[2]);
    }
    String val=doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setK(Double.parseDouble(val));
    MGRows=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGCols=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGRefRow=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGRefCol=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGRowSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGColSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    String MGtTimes=doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    MGtTimes=MGtTimes.substring(0,MGtTimes.length() - 1);
    MGtTime=Timestamp.valueOf(MGtTimes.replaceAll(""String_Node_Str"",""String_Node_Str"")).getTime();
    MGtauTime=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    ImageRowSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    ImageColSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
  }
 catch (  JDOMException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
}",0.9787437632424304
175228,"@Override public boolean initialise(){
  try {
    this.displayName=manifestFile.getName();
    setFile(manifestFile);
    parseProductXML(productxml);
    tiffImages=getImages();
    TIFF image=tiffImages.values().iterator().next();
    bounds=new Rectangle(0,0,image.xSize,image.ySize);
    gcps=getGcps();
    if (gcps == null) {
      dispose();
      return false;
    }
    geotransform=GeoTransformFactory.createFromGcps(gcps,""String_Node_Str"");
    double radialdist=Math.pow(xposition * xposition + yposition * yposition + zposition * zposition,0.5);
    MathTransform convert;
    double[] latlon=getGeoTransform().getGeoFromPixel(0,0);
    double[] position=new double[3];
    convert=CRS.findMathTransform(DefaultGeographicCRS.WGS84,DefaultGeocentricCRS.CARTESIAN);
    convert.transform(latlon,0,position,0,1);
    double earthradial=Math.pow(position[0] * position[0] + position[1] * position[1] + position[2] * position[2],0.5);
    setSatelliteAltitude(radialdist - earthradial);
    float firstIncidenceangle=(float)(this.gcps.get(0).getAngle());
    float lastIncidenceAngle=(float)(this.gcps.get(this.gcps.size() - 1).getAngle());
    setIncidenceNear(firstIncidenceangle < lastIncidenceAngle ? firstIncidenceangle : lastIncidenceAngle);
    setIncidenceFar(firstIncidenceangle > lastIncidenceAngle ? firstIncidenceangle : lastIncidenceAngle);
  }
 catch (  TransformException|FactoryException|GeoTransformException ex) {
    logger.error(ex.getMessage(),ex);
  }
  return true;
}","@Override public boolean initialise(){
  try {
    this.displayName=manifestFile.getName();
    setFile(manifestFile);
    parseProductXML(productxml);
    tiffImages=getImages();
    bounds=new Rectangle(0,0,getMetaWidth(),getMetaHeight());
    gcps=getGcps();
    if (gcps == null) {
      dispose();
      return false;
    }
    geotransform=GeoTransformFactory.createFromGcps(gcps,""String_Node_Str"");
    double radialdist=Math.pow(xposition * xposition + yposition * yposition + zposition * zposition,0.5);
    MathTransform convert;
    double[] latlon=getGeoTransform().getGeoFromPixel(0,0);
    double[] position=new double[3];
    convert=CRS.findMathTransform(DefaultGeographicCRS.WGS84,DefaultGeocentricCRS.CARTESIAN);
    convert.transform(latlon,0,position,0,1);
    double earthradial=Math.pow(position[0] * position[0] + position[1] * position[1] + position[2] * position[2],0.5);
    setSatelliteAltitude(radialdist - earthradial);
    float firstIncidenceangle=(float)(this.gcps.get(0).getAngle());
    float lastIncidenceAngle=(float)(this.gcps.get(this.gcps.size() - 1).getAngle());
    setIncidenceNear(firstIncidenceangle < lastIncidenceAngle ? firstIncidenceangle : lastIncidenceAngle);
    setIncidenceFar(firstIncidenceangle > lastIncidenceAngle ? firstIncidenceangle : lastIncidenceAngle);
  }
 catch (  TransformException|FactoryException|GeoTransformException ex) {
    logger.error(ex.getMessage(),ex);
  }
  return true;
}",0.9644188410708234
175229,"/** 
 * @return
 */
private Map<String,TIFF> getImages(){
  @SuppressWarnings(""String_Node_Str"") List<Object> elements=doc.getRootElement().getChild(""String_Node_Str"").getChildren(""String_Node_Str"");
  Map<String,TIFF> tiffs=new HashMap<String,TIFF>();
  bands=new Vector<String>();
  for (  Object o : elements) {
    if (o instanceof Element) {
      StringBuilder f=new StringBuilder(productxml.getParent()).append(""String_Node_Str"").append(((Element)o).getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()).append(""String_Node_Str"").append(((Element)o).getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
      String polarisation=((Element)o).getChild(""String_Node_Str"").getValue();
      tiffs.put(polarisation,new TIFF(new File(f.toString()),0));
      bands.add(polarisation);
    }
  }
  return tiffs;
}","/** 
 * @return
 */
private Map<String,TIFF> getImages(){
  @SuppressWarnings(""String_Node_Str"") List<Object> elements=doc.getRootElement().getChild(""String_Node_Str"").getChildren(""String_Node_Str"");
  Map<String,TIFF> tiffs=new HashMap<String,TIFF>();
  bands=new Vector<String>();
  for (  Object o : elements) {
    if (o instanceof Element) {
      StringBuilder f=new StringBuilder(productxml.getParent()).append(""String_Node_Str"").append(((Element)o).getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()).append(""String_Node_Str"").append(((Element)o).getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
      String polarisation=((Element)o).getChild(""String_Node_Str"").getValue();
      TIFF t=new TIFF(new File(f.toString()),0);
      t.setxSize(getMetaWidth());
      t.setySize(getMetaHeight());
      tiffs.put(polarisation,t);
      bands.add(polarisation);
    }
  }
  return tiffs;
}",0.9260244811069718
175230,"/** 
 * @param imageFile
 * @param band form files with multiple band
 */
public TIFF(File imageFile,int band){
  this.imageFile=imageFile;
  try {
    Iterator<ImageReader> readers=ImageIO.getImageReadersByFormatName(""String_Node_Str"");
    boolean worked=false;
    while (readers.hasNext() && !worked) {
      Object obj=readers.next();
      if (obj instanceof TIFFImageReader) {
        reader=(TIFFImageReader)obj;
        ImageInputStream iis=ImageIO.createImageInputStream(imageFile);
        reader.setInput(iis);
        xSize=reader.getWidth(band);
        ySize=reader.getHeight(band);
        bounds=new Rectangle(0,0,xSize,ySize);
        worked=true;
      }
 else {
      }
    }
    if (!worked) {
      logger.warn(""String_Node_Str"");
    }
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
}","/** 
 * @param imageFile
 * @param band form files with multiple band
 */
public TIFF(File imageFile,int band){
  this.imageFile=imageFile;
  try {
    Iterator<ImageReader> readers=ImageIO.getImageReadersByFormatName(""String_Node_Str"");
    boolean worked=false;
    while (readers.hasNext() && !worked) {
      Object obj=readers.next();
      if (obj instanceof TIFFImageReader) {
        reader=(TIFFImageReader)obj;
        ImageInputStream iis=ImageIO.createImageInputStream(imageFile);
        reader.setInput(iis);
        try {
          xSize=reader.getWidth(band);
          ySize=reader.getHeight(band);
          bounds=new Rectangle(0,0,xSize,ySize);
        }
 catch (        Exception e) {
          bounds=null;
          logger.warn(""String_Node_Str"");
        }
        worked=true;
      }
 else {
      }
    }
    if (!worked) {
      logger.warn(""String_Node_Str"");
    }
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
  }
}",0.9244444444444444
175231,"public void parseProductXML(File productxml) throws TransformException {
  try {
    SAXBuilder builder=new SAXBuilder();
    doc=builder.build(productxml);
    Element atts=doc.getRootElement().getChild(""String_Node_Str"");
    setSatellite(""String_Node_Str"");
    setSensor(""String_Node_Str"");
    String pols=""String_Node_Str"";
    for (    Object o : atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChildren(""String_Node_Str"")) {
      Element elem=(Element)o;
      pols=pols + elem.getText() + ""String_Node_Str"";
    }
    pols.substring(0,pols.length() - 1);
    setPolarization(pols);
    setLookDirection(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setMode(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setProduct(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setOrbitDirection(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setMetaHeight(Integer.parseInt(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    String w=atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setMetaWidth(Integer.parseInt(w));
    setRangeSpacing(Float.parseFloat(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    setAzimuthSpacing(Float.parseFloat(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    setNumberOfBytes(new Integer(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()) / 8);
    setENL(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setHeadingAngle(Double.parseDouble(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    rangeTimeStart=Double.valueOf(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    rangeTimeStop=Double.valueOf(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    String time=atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setTimeStampStart(time.replaceAll(""String_Node_Str"",""String_Node_Str""));
    time=atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setTimeStampStop(time.replaceAll(""String_Node_Str"",""String_Node_Str""));
    atts=doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"");
    double xvelocity=Double.valueOf(atts.getChildText(""String_Node_Str""));
    double yvelocity=Double.valueOf(atts.getChildText(""String_Node_Str""));
    double zvelocity=Double.valueOf(atts.getChildText(""String_Node_Str""));
    double satellite_speed=Math.sqrt(xvelocity * xvelocity + yvelocity * yvelocity + zvelocity * zvelocity);
    setSatelliteSpeed(satellite_speed);
    xposition=Double.valueOf(atts.getChildText(""String_Node_Str""));
    yposition=Double.valueOf(atts.getChildText(""String_Node_Str""));
    zposition=Double.valueOf(atts.getChildText(""String_Node_Str""));
    float radarFrequency=new Float(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setRadarWaveLenght(299792457.9 / radarFrequency);
    setSatelliteOrbitInclination(97.44);
    setRevolutionsPerday(11);
    Double[] prf=new Double[3];
    if (getMode().equals(""String_Node_Str"")) {
      int prf_count=0;
      for (      Object o : doc.getRootElement().getChild(""String_Node_Str"").getChildren(""String_Node_Str"")) {
        Element elem=(Element)o;
        prf[prf_count]=Double.parseDouble(elem.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
        prf_count++;
      }
      setPRF1(prf[0]);
      setPRF2(prf[1]);
      setPRF3(prf[2]);
      setPRF(null);
      int b=0;
      int strip[]=new int[3];
      for (      Object o : doc.getRootElement().getChild(""String_Node_Str"").getChildren(""String_Node_Str"")) {
        if (b == 3) {
          continue;
        }
        Element elem=(Element)o;
        double start_range_time=new Double(elem.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
        double stop_range_time=new Double(elem.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
        double aver_range_time=start_range_time + (stop_range_time - start_range_time) / 2;
        int width=Integer.parseInt(w);
        int stripBound=new Double(((aver_range_time - rangeTimeStart) * width) / (rangeTimeStop - rangeTimeStart)).intValue();
        strip[0]=new Integer(stripBound);
        b++;
      }
      setStripBound1(strip[0]);
      setStripBound2(strip[1]);
      setStripBound3(strip[2]);
    }
    String val=doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setK(Double.parseDouble(val));
    MGRows=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGCols=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGRefRow=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGRefCol=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGRowSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGColSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    String MGtTimes=doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    MGtTimes=MGtTimes.substring(0,MGtTimes.length() - 1);
    MGtTime=Timestamp.valueOf(MGtTimes.replaceAll(""String_Node_Str"",""String_Node_Str"")).getTime();
    MGtauTime=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    ImageRowSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    ImageColSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
  }
 catch (  JDOMException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
}","public void parseProductXML(File productxml) throws TransformException {
  try {
    SAXBuilder builder=new SAXBuilder();
    doc=builder.build(productxml);
    Element atts=doc.getRootElement().getChild(""String_Node_Str"");
    setSatellite(""String_Node_Str"");
    setSensor(""String_Node_Str"");
    String pols=""String_Node_Str"";
    for (    Object o : atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChildren(""String_Node_Str"")) {
      Element elem=(Element)o;
      pols=pols + elem.getText() + ""String_Node_Str"";
    }
    pols.substring(0,pols.length() - 1);
    setPolarization(pols);
    setLookDirection(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setMode(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setProduct(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setOrbitDirection(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setMetaHeight(Integer.parseInt(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    String w=atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setMetaWidth(Integer.parseInt(w));
    setRangeSpacing(Float.parseFloat(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    setAzimuthSpacing(Float.parseFloat(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    setNumberOfBytes(new Integer(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()) / 8);
    setENL(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setHeadingAngle(Double.parseDouble(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()));
    rangeTimeStart=Double.valueOf(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    rangeTimeStop=Double.valueOf(atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    String time=atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setTimeStampStart(time.replaceAll(""String_Node_Str"",""String_Node_Str""));
    time=atts.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setTimeStampStop(time.replaceAll(""String_Node_Str"",""String_Node_Str""));
    atts=doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"");
    double xvelocity=Double.valueOf(atts.getChildText(""String_Node_Str""));
    double yvelocity=Double.valueOf(atts.getChildText(""String_Node_Str""));
    double zvelocity=Double.valueOf(atts.getChildText(""String_Node_Str""));
    double satellite_speed=Math.sqrt(xvelocity * xvelocity + yvelocity * yvelocity + zvelocity * zvelocity);
    setSatelliteSpeed(satellite_speed);
    xposition=Double.valueOf(atts.getChildText(""String_Node_Str""));
    yposition=Double.valueOf(atts.getChildText(""String_Node_Str""));
    zposition=Double.valueOf(atts.getChildText(""String_Node_Str""));
    float radarFrequency=new Float(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    setRadarWaveLenght(299792457.9 / radarFrequency);
    setSatelliteOrbitInclination(97.44);
    setRevolutionsPerday(11);
    Double[] prf=null;
    if (getMode().equals(""String_Node_Str"")) {
      List<Element> sets=doc.getRootElement().getChild(""String_Node_Str"").getChildren(""String_Node_Str"");
      prf=new Double[sets.size()];
      int prf_count=0;
      for (      Object o : sets) {
        Element elem=(Element)o;
        prf[prf_count]=Double.parseDouble(elem.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
        prf_count++;
      }
      setPRF1(prf[0]);
      setPRF2(prf[1]);
      setPRF3(prf[2]);
      setPRF(null);
      int b=0;
      int strip[]=new int[3];
      for (      Object o : doc.getRootElement().getChild(""String_Node_Str"").getChildren(""String_Node_Str"")) {
        if (b == 3) {
          continue;
        }
        Element elem=(Element)o;
        double start_range_time=new Double(elem.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
        double stop_range_time=new Double(elem.getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
        double aver_range_time=start_range_time + (stop_range_time - start_range_time) / 2;
        int width=Integer.parseInt(w);
        int stripBound=new Double(((aver_range_time - rangeTimeStart) * width) / (rangeTimeStop - rangeTimeStart)).intValue();
        strip[0]=new Integer(stripBound);
        b++;
      }
      setStripBound1(strip[0]);
      setStripBound2(strip[1]);
      setStripBound3(strip[2]);
    }
    String val=doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    setK(Double.parseDouble(val));
    MGRows=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGCols=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGRefRow=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGRefCol=new Integer(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGRowSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    MGColSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    String MGtTimes=doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText();
    MGtTimes=MGtTimes.substring(0,MGtTimes.length() - 1);
    MGtTime=Timestamp.valueOf(MGtTimes.replaceAll(""String_Node_Str"",""String_Node_Str"")).getTime();
    MGtauTime=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    ImageRowSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
    ImageColSpacing=Double.valueOf(doc.getRootElement().getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
  }
 catch (  JDOMException ex) {
    logger.error(ex.getMessage(),ex);
  }
catch (  IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
}",0.9787437632424304
175232,"@Override public boolean initialise(){
  try {
    this.displayName=manifestFile.getName();
    setFile(manifestFile);
    parseProductXML(productxml);
    tiffImages=getImages();
    TIFF image=tiffImages.values().iterator().next();
    bounds=new Rectangle(0,0,image.xSize,image.ySize);
    gcps=getGcps();
    if (gcps == null) {
      dispose();
      return false;
    }
    geotransform=GeoTransformFactory.createFromGcps(gcps,""String_Node_Str"");
    double radialdist=Math.pow(xposition * xposition + yposition * yposition + zposition * zposition,0.5);
    MathTransform convert;
    double[] latlon=getGeoTransform().getGeoFromPixel(0,0);
    double[] position=new double[3];
    convert=CRS.findMathTransform(DefaultGeographicCRS.WGS84,DefaultGeocentricCRS.CARTESIAN);
    convert.transform(latlon,0,position,0,1);
    double earthradial=Math.pow(position[0] * position[0] + position[1] * position[1] + position[2] * position[2],0.5);
    setSatelliteAltitude(radialdist - earthradial);
    float firstIncidenceangle=(float)(this.gcps.get(0).getAngle());
    float lastIncidenceAngle=(float)(this.gcps.get(this.gcps.size() - 1).getAngle());
    setIncidenceNear(firstIncidenceangle < lastIncidenceAngle ? firstIncidenceangle : lastIncidenceAngle);
    setIncidenceFar(firstIncidenceangle > lastIncidenceAngle ? firstIncidenceangle : lastIncidenceAngle);
  }
 catch (  TransformException|FactoryException|GeoTransformException ex) {
    logger.error(ex.getMessage(),ex);
  }
  return true;
}","@Override public boolean initialise(){
  try {
    this.displayName=manifestFile.getName();
    setFile(manifestFile);
    parseProductXML(productxml);
    tiffImages=getImages();
    bounds=new Rectangle(0,0,getMetaWidth(),getMetaHeight());
    gcps=getGcps();
    if (gcps == null) {
      dispose();
      return false;
    }
    geotransform=GeoTransformFactory.createFromGcps(gcps,""String_Node_Str"");
    double radialdist=Math.pow(xposition * xposition + yposition * yposition + zposition * zposition,0.5);
    MathTransform convert;
    double[] latlon=getGeoTransform().getGeoFromPixel(0,0);
    double[] position=new double[3];
    convert=CRS.findMathTransform(DefaultGeographicCRS.WGS84,DefaultGeocentricCRS.CARTESIAN);
    convert.transform(latlon,0,position,0,1);
    double earthradial=Math.pow(position[0] * position[0] + position[1] * position[1] + position[2] * position[2],0.5);
    setSatelliteAltitude(radialdist - earthradial);
    float firstIncidenceangle=(float)(this.gcps.get(0).getAngle());
    float lastIncidenceAngle=(float)(this.gcps.get(this.gcps.size() - 1).getAngle());
    setIncidenceNear(firstIncidenceangle < lastIncidenceAngle ? firstIncidenceangle : lastIncidenceAngle);
    setIncidenceFar(firstIncidenceangle > lastIncidenceAngle ? firstIncidenceangle : lastIncidenceAngle);
  }
 catch (  TransformException|FactoryException|GeoTransformException ex) {
    logger.error(ex.getMessage(),ex);
  }
  return true;
}",0.9644188410708234
175233,"/** 
 * @return
 */
private Map<String,TIFF> getImages(){
  @SuppressWarnings(""String_Node_Str"") List<Object> elements=doc.getRootElement().getChild(""String_Node_Str"").getChildren(""String_Node_Str"");
  Map<String,TIFF> tiffs=new HashMap<String,TIFF>();
  bands=new Vector<String>();
  for (  Object o : elements) {
    if (o instanceof Element) {
      StringBuilder f=new StringBuilder(productxml.getParent()).append(""String_Node_Str"").append(((Element)o).getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()).append(""String_Node_Str"").append(((Element)o).getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
      String polarisation=((Element)o).getChild(""String_Node_Str"").getValue();
      tiffs.put(polarisation,new TIFF(new File(f.toString()),0));
      bands.add(polarisation);
    }
  }
  return tiffs;
}","/** 
 * @return
 */
private Map<String,TIFF> getImages(){
  @SuppressWarnings(""String_Node_Str"") List<Object> elements=doc.getRootElement().getChild(""String_Node_Str"").getChildren(""String_Node_Str"");
  Map<String,TIFF> tiffs=new HashMap<String,TIFF>();
  bands=new Vector<String>();
  for (  Object o : elements) {
    if (o instanceof Element) {
      StringBuilder f=new StringBuilder(productxml.getParent()).append(""String_Node_Str"").append(((Element)o).getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText()).append(""String_Node_Str"").append(((Element)o).getChild(""String_Node_Str"").getChild(""String_Node_Str"").getChild(""String_Node_Str"").getText());
      String polarisation=((Element)o).getChild(""String_Node_Str"").getValue();
      TIFF t=new TIFF(new File(f.toString()),0);
      t.setxSize(getMetaWidth());
      t.setySize(getMetaHeight());
      tiffs.put(polarisation,t);
      bands.add(polarisation);
    }
  }
  return tiffs;
}",0.9260244811069718
175234,"public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=41.31735;
    double lon=2.17263;
    double r[];
    try {
      r=gc.geoFromPixel(4756,2655);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
      r=gc.pixelFromGeo(9.6081,40.9034);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}","public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=61.77994;
    double lon=-65.66427;
    double r[];
    try {
      r=gc.pixelFromGeo(lon,lat);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}",0.830945558739255
175235,"/** 
 */
@Override public double[] pixelFromGeo(final double lon,final double lat) throws GeoLocationException {
  double[] resultReverse=new double[2];
  double[] pXYZ=GeoUtils.convertFromGeoToEarthCentred(lat,lon);
  Double dd2[]=(Double[])orbitInterpolation.getTimeStampInterp().toArray(new Double[0]);
  double[] results=findZeroDoppler(statepVecInterp,pXYZ,ArrayUtils.toPrimitive(dd2));
  double zeroDopplerTime=results[0];
  double srdist=results[1];
  double lNominatore=(zeroDopplerTime - orbitInterpolation.getZeroDopplerTimeFirstRef() - iSafetyBufferAz / meta.getSamplingf());
  double lDenom=(orbitInterpolation.getZeroDopplerTimeLastRef() - orbitInterpolation.getZeroDopplerTimeFirstRef() - 2 * (iSafetyBufferAz / meta.getSamplingf()));
  double l=(lNominatore / lDenom) * (meta.getNlines() - 1);
  if (meta.getCoordinateConversion() != null && meta.getCoordinateConversion().length > 0) {
    double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
    int index=0;
    for (    S1Metadata.CoordinateConversion cc : coordConv) {
      groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
      index++;
    }
    int idx=0;
    if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
      idx=0;
    }
 else     if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
      idx=groundToSlantRangePolyTimesSeconds.length - 2;
    }
 else {
      for (idx=0; idx < groundToSlantRangePolyTimesSeconds.length; idx++) {
        if (groundToSlantRangePolyTimesSeconds[idx] > zeroDopplerTime)         break;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length - 1) {
        idx=idx - 1;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length) {
        idx=idx - 2;
      }
    }
    double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double[] groundToSlantRangeCoefficientsInterp=new double[coordConv[idx].groundToSlantRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
      groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].groundToSlantRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].groundToSlantRangeCoefficients[idCoeff];
    }
    double[] slantToGroundRangeCoefficientsInterp=new double[coordConv[idx].slantToGroundRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
      slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].slantToGroundRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].slantToGroundRangeCoefficients[idCoeff];
    }
    double newD=0;
    double oldD=0;
    int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
    int[] numCoeffs=new int[nCoeffs];
    int[] numExps=new int[nCoeffs];
    int[] denomCoeffs=new int[nCoeffs];
    int[] denomExps=new int[nCoeffs];
    for (int i=0; i < nCoeffs; i++) {
      numCoeffs[i]=i - 1;
      numExps[i]=i;
      denomCoeffs[i]=i;
      denomExps[i]=i - 1;
    }
    denomExps[0]=0;
    double deltaD=0;
    do {
      double numCoeffsXGround[]=new double[nCoeffs];
      double denomCoeffsXGround[]=new double[nCoeffs];
      double scalNum=0;
      double scalDen=0;
      for (int i=0; i < groundToSlantRangeCoefficientsInterp.length; i++) {
        double dExp=FastMath.pow(oldD,numExps[i]);
        double denomExp=FastMath.pow(oldD,denomExps[i]);
        numCoeffsXGround[i]=groundToSlantRangeCoefficientsInterp[i] * numCoeffs[i];
        denomCoeffsXGround[i]=groundToSlantRangeCoefficientsInterp[i] * denomCoeffs[i];
        scalNum=scalNum + dExp * numCoeffsXGround[i];
        scalDen=scalDen + denomExp * denomCoeffsXGround[i];
      }
      double num=srdist + scalNum;
      newD=num / scalDen;
      deltaD=FastMath.abs(newD - oldD);
      oldD=newD;
    }
 while (deltaD > 1);
    double p=0;
    if (meta.isPixelTimeOrderingAscending()) {
      p=(newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
 else {
      p=meta.getNumberOfSamplesPerLine() - 1 - (newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
    resultReverse[0]=p;
    resultReverse[1]=l;
    logger.debug(""String_Node_Str"" + l + ""String_Node_Str""+ ""String_Node_Str""+ p);
  }
  return resultReverse;
}","/** 
 */
@Override public double[] pixelFromGeo(final double lon,final double lat) throws GeoLocationException {
  double[] resultReverse=new double[2];
  double[] pXYZ=GeoUtils.convertFromGeoToEarthCentred(lat,lon);
  Double dd2[]=(Double[])orbitInterpolation.getTimeStampInterp().toArray(new Double[0]);
  double[] results=findZeroDoppler(statepVecInterp,pXYZ,ArrayUtils.toPrimitive(dd2));
  double zeroDopplerTime=results[0];
  double srdist=results[1];
  double lNominatore=(zeroDopplerTime - orbitInterpolation.getZeroDopplerTimeFirstRef() - iSafetyBufferAz / meta.getSamplingf());
  double lDenom=(orbitInterpolation.getZeroDopplerTimeLastRef() - orbitInterpolation.getZeroDopplerTimeFirstRef() - 2 * (iSafetyBufferAz / meta.getSamplingf()));
  double l=(lNominatore / lDenom) * (meta.getNlines() - 1);
  if (meta.getCoordinateConversion() != null && meta.getCoordinateConversion().length > 0) {
    double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
    int index=0;
    for (    S1Metadata.CoordinateConversion cc : coordConv) {
      groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
      index++;
    }
    int idx=0;
    if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
      idx=0;
    }
 else     if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
      idx=groundToSlantRangePolyTimesSeconds.length - 2;
    }
 else {
      for (idx=0; idx < groundToSlantRangePolyTimesSeconds.length; idx++) {
        if (groundToSlantRangePolyTimesSeconds[idx] > zeroDopplerTime)         break;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length - 1) {
        idx=idx - 1;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length) {
        idx=idx - 2;
      }
    }
    double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double[] groundToSlantRangeCoefficientsInterp=new double[coordConv[idx].groundToSlantRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
      groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].groundToSlantRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].groundToSlantRangeCoefficients[idCoeff];
    }
    double[] slantToGroundRangeCoefficientsInterp=new double[coordConv[idx].slantToGroundRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
      slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].slantToGroundRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].slantToGroundRangeCoefficients[idCoeff];
    }
    double newD=0;
    double oldD=0;
    int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
    int[] numCoeffs=new int[nCoeffs];
    int[] numExps=new int[nCoeffs];
    int[] denomCoeffs=new int[nCoeffs];
    int[] denomExps=new int[nCoeffs];
    for (int i=0; i < nCoeffs; i++) {
      numCoeffs[i]=i - 1;
      numExps[i]=i;
      denomCoeffs[i]=i;
      denomExps[i]=i - 1;
    }
    denomExps[0]=0;
    double deltaD=0;
    do {
      double numCoeffsXGround=0;
      double denomCoeffsXGround=0;
      double scalNum=0;
      double scalDen=0;
      for (int i=0; i < groundToSlantRangeCoefficientsInterp.length; i++) {
        double dExp=FastMath.pow(oldD,numExps[i]);
        double denomExp=FastMath.pow(oldD,denomExps[i]);
        numCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * numCoeffs[i];
        denomCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * denomCoeffs[i];
        scalNum=scalNum + dExp * numCoeffsXGround;
        scalDen=scalDen + denomExp * denomCoeffsXGround;
      }
      double num=srdist + scalNum;
      newD=num / scalDen;
      deltaD=FastMath.abs(newD - oldD);
      oldD=newD;
    }
 while (deltaD > 1);
    double p=0;
    if (meta.isPixelTimeOrderingAscending()) {
      p=(newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
 else {
      p=meta.getNumberOfSamplesPerLine() - 1 - (newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
    resultReverse[0]=p;
    resultReverse[1]=l;
    logger.debug(""String_Node_Str"" + l + ""String_Node_Str""+ ""String_Node_Str""+ p);
  }
  return resultReverse;
}",0.9936682144364712
175236,"public void orbitInterpolation(List<S1Metadata.OrbitStatePosVelox> vpList,double zeroDopplerTimeFirstLineSeconds,double zeroDopplerTimeLastLineSeconds,double samplingf,double iSafetyBufferAz) throws MathException {
  this.iSafetyBufferAz=iSafetyBufferAz;
  double deltaT=1 / samplingf;
  double deltaTinv=1 / deltaT;
  int nPoints=vpList.size();
  double reftime=0;
  double firstTime=vpList.get(0).time;
  double lastTime=vpList.get(vpList.size() - 1).time;
  if (firstTime < (lastTime)) {
    reftime=firstTime;
  }
 else {
    reftime=lastTime;
  }
  int idx=0;
  secondsDiffFromRefTime=new double[vpList.size()];
  for (  S1Metadata.OrbitStatePosVelox vp : vpList) {
    secondsDiffFromRefTime[idx]=(vp.time - reftime);
    idx++;
  }
  zeroDopplerTimeFirstRef=(zeroDopplerTimeFirstLineSeconds - reftime) - iSafetyBufferAz * deltaT;
  zeroDopplerTimeLastRef=(zeroDopplerTimeLastLineSeconds - reftime) + iSafetyBufferAz * deltaT;
  double minT=0;
  double maxT=0;
  if (zeroDopplerTimeFirstRef < zeroDopplerTimeLastRef) {
    minT=FastMath.min(0,zeroDopplerTimeFirstRef);
    maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeLastRef);
  }
 else {
    if (firstTime < (lastTime)) {
      minT=FastMath.min(secondsDiffFromRefTime[0],zeroDopplerTimeLastRef);
      maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeFirstRef);
    }
 else {
      minT=FastMath.min(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeLastRef);
      maxT=FastMath.max(secondsDiffFromRefTime[0],zeroDopplerTimeFirstRef);
    }
  }
  int limit=((Double)((maxT - minT) / deltaT)).intValue();
  Double[] timeStampInterpSecondsRef=new Double[limit + 1];
  double nextVal=0;
  for (int j=0; j <= limit; j++) {
    timeStampInterpSecondsRef[j]=nextVal;
    nextVal=deltaT + nextVal;
  }
  double zeroDopplerTimeInitRef=zeroDopplerTimeFirstRef;
  double zeroDopplerTimeEndRef=zeroDopplerTimeLastRef;
  if (zeroDopplerTimeFirstRef > zeroDopplerTimeLastRef) {
    zeroDopplerTimeInitRef=zeroDopplerTimeLastRef;
    zeroDopplerTimeEndRef=zeroDopplerTimeFirstRef;
  }
  if (zeroDopplerTimeInitRef < timeStampInterpSecondsRef[1]) {
    int size=Math.min(nPoints,N_ORB_POINT_INTERP);
    double[] subTimesDiffRef=Arrays.copyOfRange(secondsDiffFromRefTime,0,nPoints);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < size; i++) {
      double valMax=timeStampInterpSecondsRef[size - 1];
      if (timeStampInterpSecondsRef[i] < valMax) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<IMetadata.OrbitStatePosVelox> subList=vpList.subList(0,size);
    double initTime=zeroDopplerTimeInitRef;
    int idxInitTime=-1;
    boolean finded=false;
    double endTime=secondsDiffFromRefTime[0];
    int idxEndTime=-1;
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= initTime && !finded) {
        idxInitTime=i;
        finded=true;
      }
      if (timeStampInterpSecondsRef[i] < endTime) {
        idxEndTime=i;
      }
    }
    logger.debug(""String_Node_Str"" + idxInitTime + ""String_Node_Str""+ idxEndTime);
    Double[] t0=(Double[])timeStampInitSecondsRefPointsInterp.toArray();
    if (idxInitTime != -1 && idxEndTime != -1 && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(subTimesDiffRef,subList,t0,idxInitTime,idxEndTime,deltaTinv,vPoints,pPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampOutput);
 else       timeStampInterp.addAll(timeStampOutput);
    }
  }
  for (int orbPoint=1; orbPoint < nPoints; orbPoint++) {
    if (secondsDiffFromRefTime[orbPoint - 1] < zeroDopplerTimeEndRef || secondsDiffFromRefTime[orbPoint] > zeroDopplerTimeEndRef) {
      int idxStart=0;
      int idxEnd=0;
      if (N_ORB_POINT_INTERP > nPoints) {
        idxEnd=nPoints;
      }
 else {
        idxStart=orbPoint - new Double(Math.floor(N_ORB_POINT_INTERP / 2)).intValue();
        idxEnd=idxStart + N_ORB_POINT_INTERP - 1;
        if (idxStart < 1) {
          idxStart=0;
          idxEnd=N_ORB_POINT_INTERP - 1;
        }
        if (idxEnd >= nPoints) {
          idxStart=nPoints - N_ORB_POINT_INTERP;
          idxEnd=nPoints - 1;
        }
      }
      double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,idxStart,idxEnd + 1);
      List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
      for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
        if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[idxStart] && timeStampInterpSecondsRef[i] < secondsDiffFromRefTime[idxEnd]) {
          timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
        }
      }
      List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(idxStart,idxEnd + 1);
      double initTime=Math.max(secondsDiffFromRefTime[orbPoint - 1],zeroDopplerTimeInitRef);
      int idxInitTime=0;
      boolean findIdxInitTime=false;
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
        if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
          idxInitTime=i;
          findIdxInitTime=true;
        }
      }
      double endTime=Math.min(secondsDiffFromRefTime[orbPoint],zeroDopplerTimeEndRef);
      int idxEndTime=0;
      boolean findIdxEndTime=false;
      for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
        if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
          idxEndTime=i;
          findIdxEndTime=true;
        }
      }
      double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
      Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
        timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
      }
      if (findIdxEndTime && findIdxInitTime && initTime < endTime && idxInitTime < idxEndTime) {
        List<double[]> vPoints=new ArrayList<double[]>();
        List<double[]> pPoints=new ArrayList<double[]>();
        List<Double> timeStampOutput=new ArrayList<Double>();
        HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
        addPointsToResult(vPoints,pPoints);
        List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
        for (int i=0; i < timeStampOutput.size(); i++) {
          timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
        }
        if (timeStampInterp == null)         timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else         timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
      }
    }
  }
  if (zeroDopplerTimeEndRef > secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1]) {
    int vOrbPointsInit=(nPoints - Math.min(nPoints,N_ORB_POINT_INTERP));
    int vOrbPointsEnd=nPoints - 1;
    double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,vOrbPointsInit,vOrbPointsEnd + 1);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[vOrbPointsInit]) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(vOrbPointsInit,vOrbPointsEnd + 1);
    double initTime=secondsDiffFromRefTime[vOrbPointsEnd];
    int idxInitTime=0;
    boolean findIdxInitTime=false;
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
      if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
        idxInitTime=i;
        findIdxInitTime=true;
      }
    }
    double endTime=zeroDopplerTimeEndRef;
    int idxEndTime=0;
    boolean findIdxEndTime=false;
    for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
      if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
        idxEndTime=i;
        findIdxEndTime=true;
      }
    }
    double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
    Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
      timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
    }
    if (findIdxEndTime && findIdxInitTime && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
      for (int i=0; i < timeStampOutput.size(); i++) {
        timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
      }
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else       timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
    }
  }
}","public void orbitInterpolation(List<S1Metadata.OrbitStatePosVelox> vpList,double zeroDopplerTimeFirstLineSeconds,double zeroDopplerTimeLastLineSeconds,double samplingf,double iSafetyBufferAz) throws MathException {
  this.iSafetyBufferAz=iSafetyBufferAz;
  double deltaT=1 / samplingf;
  double deltaTinv=1 / deltaT;
  int nPoints=vpList.size();
  double reftime=0;
  double firstTime=vpList.get(0).time;
  double lastTime=vpList.get(vpList.size() - 1).time;
  if (firstTime < (lastTime)) {
    reftime=firstTime;
  }
 else {
    reftime=lastTime;
  }
  int idx=0;
  secondsDiffFromRefTime=new double[vpList.size()];
  for (  S1Metadata.OrbitStatePosVelox vp : vpList) {
    secondsDiffFromRefTime[idx]=(vp.time - reftime);
    idx++;
  }
  zeroDopplerTimeFirstRef=(zeroDopplerTimeFirstLineSeconds - reftime) - iSafetyBufferAz * deltaT;
  zeroDopplerTimeLastRef=(zeroDopplerTimeLastLineSeconds - reftime) + iSafetyBufferAz * deltaT;
  double minT=0;
  double maxT=0;
  if (zeroDopplerTimeFirstRef < zeroDopplerTimeLastRef) {
    minT=FastMath.min(0,zeroDopplerTimeFirstRef);
    maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeLastRef);
  }
 else {
    if (firstTime < (lastTime)) {
      minT=FastMath.min(secondsDiffFromRefTime[0],zeroDopplerTimeLastRef);
      maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeFirstRef);
    }
 else {
      minT=FastMath.min(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeLastRef);
      maxT=FastMath.max(secondsDiffFromRefTime[0],zeroDopplerTimeFirstRef);
    }
  }
  int limit=((Double)((maxT - minT) / deltaT)).intValue();
  Double[] timeStampInterpSecondsRef=new Double[limit + 1];
  double nextVal=0;
  for (int j=0; j <= limit; j++) {
    timeStampInterpSecondsRef[j]=nextVal;
    nextVal=deltaT + nextVal;
  }
  double zeroDopplerTimeInitRef=zeroDopplerTimeFirstRef;
  double zeroDopplerTimeEndRef=zeroDopplerTimeLastRef;
  if (zeroDopplerTimeFirstRef > zeroDopplerTimeLastRef) {
    zeroDopplerTimeInitRef=zeroDopplerTimeLastRef;
    zeroDopplerTimeEndRef=zeroDopplerTimeFirstRef;
  }
  if (zeroDopplerTimeInitRef < timeStampInterpSecondsRef[1]) {
    int size=Math.min(nPoints,N_ORB_POINT_INTERP);
    double[] subTimesDiffRef=Arrays.copyOfRange(secondsDiffFromRefTime,0,nPoints);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < size; i++) {
      double valMax=timeStampInterpSecondsRef[size - 1];
      if (timeStampInterpSecondsRef[i] < valMax) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<IMetadata.OrbitStatePosVelox> subList=vpList.subList(0,size);
    double initTime=zeroDopplerTimeInitRef;
    int idxInitTime=-1;
    boolean finded=false;
    double endTime=secondsDiffFromRefTime[0];
    int idxEndTime=-1;
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= initTime && !finded) {
        idxInitTime=i;
        finded=true;
      }
      if (timeStampInterpSecondsRef[i] < endTime) {
        idxEndTime=i;
      }
    }
    logger.debug(""String_Node_Str"" + idxInitTime + ""String_Node_Str""+ idxEndTime);
    Double[] t0=(Double[])timeStampInitSecondsRefPointsInterp.toArray(new Double[0]);
    if (idxInitTime != -1 && idxEndTime != -1 && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(subTimesDiffRef,subList,t0,idxInitTime,idxEndTime,deltaTinv,vPoints,pPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampOutput);
 else       timeStampInterp.addAll(timeStampOutput);
    }
  }
  for (int orbPoint=1; orbPoint < nPoints; orbPoint++) {
    if (secondsDiffFromRefTime[orbPoint - 1] < zeroDopplerTimeEndRef || secondsDiffFromRefTime[orbPoint] > zeroDopplerTimeEndRef) {
      int idxStart=0;
      int idxEnd=0;
      if (N_ORB_POINT_INTERP > nPoints) {
        idxEnd=nPoints;
      }
 else {
        idxStart=orbPoint - new Double(Math.floor(N_ORB_POINT_INTERP / 2)).intValue();
        idxEnd=idxStart + N_ORB_POINT_INTERP - 1;
        if (idxStart < 1) {
          idxStart=0;
          idxEnd=N_ORB_POINT_INTERP - 1;
        }
        if (idxEnd >= nPoints) {
          idxStart=nPoints - N_ORB_POINT_INTERP;
          idxEnd=nPoints - 1;
        }
      }
      double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,idxStart,idxEnd + 1);
      List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
      for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
        if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[idxStart] && timeStampInterpSecondsRef[i] < secondsDiffFromRefTime[idxEnd]) {
          timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
        }
      }
      List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(idxStart,idxEnd + 1);
      double initTime=Math.max(secondsDiffFromRefTime[orbPoint - 1],zeroDopplerTimeInitRef);
      int idxInitTime=0;
      boolean findIdxInitTime=false;
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
        if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
          idxInitTime=i;
          findIdxInitTime=true;
        }
      }
      double endTime=Math.min(secondsDiffFromRefTime[orbPoint],zeroDopplerTimeEndRef);
      int idxEndTime=0;
      boolean findIdxEndTime=false;
      for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
        if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
          idxEndTime=i;
          findIdxEndTime=true;
        }
      }
      double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
      Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
        timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
      }
      if (findIdxEndTime && findIdxInitTime && initTime < endTime && idxInitTime < idxEndTime) {
        List<double[]> vPoints=new ArrayList<double[]>();
        List<double[]> pPoints=new ArrayList<double[]>();
        List<Double> timeStampOutput=new ArrayList<Double>();
        HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
        addPointsToResult(vPoints,pPoints);
        List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
        for (int i=0; i < timeStampOutput.size(); i++) {
          timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
        }
        if (timeStampInterp == null)         timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else         timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
      }
    }
  }
  if (zeroDopplerTimeEndRef > secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1]) {
    int vOrbPointsInit=(nPoints - Math.min(nPoints,N_ORB_POINT_INTERP));
    int vOrbPointsEnd=nPoints - 1;
    double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,vOrbPointsInit,vOrbPointsEnd + 1);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[vOrbPointsInit]) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(vOrbPointsInit,vOrbPointsEnd + 1);
    double initTime=secondsDiffFromRefTime[vOrbPointsEnd];
    int idxInitTime=0;
    boolean findIdxInitTime=false;
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
      if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
        idxInitTime=i;
        findIdxInitTime=true;
      }
    }
    double endTime=zeroDopplerTimeEndRef;
    int idxEndTime=0;
    boolean findIdxEndTime=false;
    for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
      if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
        idxEndTime=i;
        findIdxEndTime=true;
      }
    }
    double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
    Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
      timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
    }
    if (findIdxEndTime && findIdxInitTime && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
      for (int i=0; i < timeStampOutput.size(); i++) {
        timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
      }
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else       timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
    }
  }
}",0.999342005365187
175237,"public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=41.31735;
    double lon=2.17263;
    double r[];
    try {
      r=gc.geoFromPixel(4756,2655);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
      r=gc.pixelFromGeo(9.6081,40.9034);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}","public static void main(String args[]){
  String metaF=""String_Node_Str"";
  GeoCoding gc;
  try {
    gc=new S1GeoCodingImpl(metaF);
    double lat=61.77994;
    double lon=-65.66427;
    double r[];
    try {
      r=gc.pixelFromGeo(lon,lat);
      System.out.println(""String_Node_Str"" + r[1] + ""String_Node_Str""+ r[0]);
    }
 catch (    GeoLocationException e) {
      e.printStackTrace();
    }
  }
 catch (  MathException e1) {
    e1.printStackTrace();
  }
}",0.830945558739255
175238,"/** 
 */
@Override public double[] pixelFromGeo(final double lon,final double lat) throws GeoLocationException {
  double[] resultReverse=new double[2];
  double[] pXYZ=GeoUtils.convertFromGeoToEarthCentred(lat,lon);
  Double dd2[]=(Double[])orbitInterpolation.getTimeStampInterp().toArray(new Double[0]);
  double[] results=findZeroDoppler(statepVecInterp,pXYZ,ArrayUtils.toPrimitive(dd2));
  double zeroDopplerTime=results[0];
  double srdist=results[1];
  double lNominatore=(zeroDopplerTime - orbitInterpolation.getZeroDopplerTimeFirstRef() - iSafetyBufferAz / meta.getSamplingf());
  double lDenom=(orbitInterpolation.getZeroDopplerTimeLastRef() - orbitInterpolation.getZeroDopplerTimeFirstRef() - 2 * (iSafetyBufferAz / meta.getSamplingf()));
  double l=(lNominatore / lDenom) * (meta.getNlines() - 1);
  if (meta.getCoordinateConversion() != null && meta.getCoordinateConversion().length > 0) {
    double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
    int index=0;
    for (    S1Metadata.CoordinateConversion cc : coordConv) {
      groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
      index++;
    }
    int idx=0;
    if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
      idx=0;
    }
 else     if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
      idx=groundToSlantRangePolyTimesSeconds.length - 2;
    }
 else {
      for (idx=0; idx < groundToSlantRangePolyTimesSeconds.length; idx++) {
        if (groundToSlantRangePolyTimesSeconds[idx] > zeroDopplerTime)         break;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length - 1) {
        idx=idx - 1;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length) {
        idx=idx - 2;
      }
    }
    double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double[] groundToSlantRangeCoefficientsInterp=new double[coordConv[idx].groundToSlantRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
      groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].groundToSlantRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].groundToSlantRangeCoefficients[idCoeff];
    }
    double[] slantToGroundRangeCoefficientsInterp=new double[coordConv[idx].slantToGroundRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
      slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].slantToGroundRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].slantToGroundRangeCoefficients[idCoeff];
    }
    double newD=0;
    double oldD=0;
    int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
    int[] numCoeffs=new int[nCoeffs];
    int[] numExps=new int[nCoeffs];
    int[] denomCoeffs=new int[nCoeffs];
    int[] denomExps=new int[nCoeffs];
    for (int i=0; i < nCoeffs; i++) {
      numCoeffs[i]=i - 1;
      numExps[i]=i;
      denomCoeffs[i]=i;
      denomExps[i]=i - 1;
    }
    denomExps[0]=0;
    double deltaD=0;
    do {
      double numCoeffsXGround[]=new double[nCoeffs];
      double denomCoeffsXGround[]=new double[nCoeffs];
      double scalNum=0;
      double scalDen=0;
      for (int i=0; i < groundToSlantRangeCoefficientsInterp.length; i++) {
        double dExp=FastMath.pow(oldD,numExps[i]);
        double denomExp=FastMath.pow(oldD,denomExps[i]);
        numCoeffsXGround[i]=groundToSlantRangeCoefficientsInterp[i] * numCoeffs[i];
        denomCoeffsXGround[i]=groundToSlantRangeCoefficientsInterp[i] * denomCoeffs[i];
        scalNum=scalNum + dExp * numCoeffsXGround[i];
        scalDen=scalDen + denomExp * denomCoeffsXGround[i];
      }
      double num=srdist + scalNum;
      newD=num / scalDen;
      deltaD=FastMath.abs(newD - oldD);
      oldD=newD;
    }
 while (deltaD > 1);
    double p=0;
    if (meta.isPixelTimeOrderingAscending()) {
      p=(newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
 else {
      p=meta.getNumberOfSamplesPerLine() - 1 - (newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
    resultReverse[0]=p;
    resultReverse[1]=l;
    logger.debug(""String_Node_Str"" + l + ""String_Node_Str""+ ""String_Node_Str""+ p);
  }
  return resultReverse;
}","/** 
 */
@Override public double[] pixelFromGeo(final double lon,final double lat) throws GeoLocationException {
  double[] resultReverse=new double[2];
  double[] pXYZ=GeoUtils.convertFromGeoToEarthCentred(lat,lon);
  Double dd2[]=(Double[])orbitInterpolation.getTimeStampInterp().toArray(new Double[0]);
  double[] results=findZeroDoppler(statepVecInterp,pXYZ,ArrayUtils.toPrimitive(dd2));
  double zeroDopplerTime=results[0];
  double srdist=results[1];
  double lNominatore=(zeroDopplerTime - orbitInterpolation.getZeroDopplerTimeFirstRef() - iSafetyBufferAz / meta.getSamplingf());
  double lDenom=(orbitInterpolation.getZeroDopplerTimeLastRef() - orbitInterpolation.getZeroDopplerTimeFirstRef() - 2 * (iSafetyBufferAz / meta.getSamplingf()));
  double l=(lNominatore / lDenom) * (meta.getNlines() - 1);
  if (meta.getCoordinateConversion() != null && meta.getCoordinateConversion().length > 0) {
    double timeRef=meta.getOrbitStatePosVelox().get(0).timeStampInitSeconds - orbitInterpolation.getSecondsDiffFromRefTime()[0];
    double[] groundToSlantRangePolyTimesSeconds=new double[coordConv.length];
    int index=0;
    for (    S1Metadata.CoordinateConversion cc : coordConv) {
      groundToSlantRangePolyTimesSeconds[index]=cc.groundToSlantRangePolyTimesSeconds - timeRef;
      index++;
    }
    int idx=0;
    if (zeroDopplerTime < groundToSlantRangePolyTimesSeconds[0]) {
      idx=0;
    }
 else     if (zeroDopplerTime > groundToSlantRangePolyTimesSeconds[groundToSlantRangePolyTimesSeconds.length - 1]) {
      idx=groundToSlantRangePolyTimesSeconds.length - 2;
    }
 else {
      for (idx=0; idx < groundToSlantRangePolyTimesSeconds.length; idx++) {
        if (groundToSlantRangePolyTimesSeconds[idx] > zeroDopplerTime)         break;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length - 1) {
        idx=idx - 1;
      }
      if (idx == groundToSlantRangePolyTimesSeconds.length) {
        idx=idx - 2;
      }
    }
    double factor1=(groundToSlantRangePolyTimesSeconds[idx + 1] - zeroDopplerTime) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double factor2=(zeroDopplerTime - groundToSlantRangePolyTimesSeconds[idx]) / (groundToSlantRangePolyTimesSeconds[idx + 1] - groundToSlantRangePolyTimesSeconds[idx]);
    double[] groundToSlantRangeCoefficientsInterp=new double[coordConv[idx].groundToSlantRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < groundToSlantRangeCoefficientsInterp.length; idCoeff++) {
      groundToSlantRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].groundToSlantRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].groundToSlantRangeCoefficients[idCoeff];
    }
    double[] slantToGroundRangeCoefficientsInterp=new double[coordConv[idx].slantToGroundRangeCoefficients.length];
    for (int idCoeff=0; idCoeff < slantToGroundRangeCoefficientsInterp.length; idCoeff++) {
      slantToGroundRangeCoefficientsInterp[idCoeff]=factor1 * coordConv[idx].slantToGroundRangeCoefficients[idCoeff] + factor2 * coordConv[idx + 1].slantToGroundRangeCoefficients[idCoeff];
    }
    double newD=0;
    double oldD=0;
    int nCoeffs=groundToSlantRangeCoefficientsInterp.length;
    int[] numCoeffs=new int[nCoeffs];
    int[] numExps=new int[nCoeffs];
    int[] denomCoeffs=new int[nCoeffs];
    int[] denomExps=new int[nCoeffs];
    for (int i=0; i < nCoeffs; i++) {
      numCoeffs[i]=i - 1;
      numExps[i]=i;
      denomCoeffs[i]=i;
      denomExps[i]=i - 1;
    }
    denomExps[0]=0;
    double deltaD=0;
    do {
      double numCoeffsXGround=0;
      double denomCoeffsXGround=0;
      double scalNum=0;
      double scalDen=0;
      for (int i=0; i < groundToSlantRangeCoefficientsInterp.length; i++) {
        double dExp=FastMath.pow(oldD,numExps[i]);
        double denomExp=FastMath.pow(oldD,denomExps[i]);
        numCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * numCoeffs[i];
        denomCoeffsXGround=groundToSlantRangeCoefficientsInterp[i] * denomCoeffs[i];
        scalNum=scalNum + dExp * numCoeffsXGround;
        scalDen=scalDen + denomExp * denomCoeffsXGround;
      }
      double num=srdist + scalNum;
      newD=num / scalDen;
      deltaD=FastMath.abs(newD - oldD);
      oldD=newD;
    }
 while (deltaD > 1);
    double p=0;
    if (meta.isPixelTimeOrderingAscending()) {
      p=(newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
 else {
      p=meta.getNumberOfSamplesPerLine() - 1 - (newD + meta.getGroundRangeOrigin()) / meta.getSamplePixelSpacing();
    }
    resultReverse[0]=p;
    resultReverse[1]=l;
    logger.debug(""String_Node_Str"" + l + ""String_Node_Str""+ ""String_Node_Str""+ p);
  }
  return resultReverse;
}",0.9936682144364712
175239,"public void orbitInterpolation(List<S1Metadata.OrbitStatePosVelox> vpList,double zeroDopplerTimeFirstLineSeconds,double zeroDopplerTimeLastLineSeconds,double samplingf,double iSafetyBufferAz) throws MathException {
  this.iSafetyBufferAz=iSafetyBufferAz;
  double deltaT=1 / samplingf;
  double deltaTinv=1 / deltaT;
  int nPoints=vpList.size();
  double reftime=0;
  double firstTime=vpList.get(0).time;
  double lastTime=vpList.get(vpList.size() - 1).time;
  if (firstTime < (lastTime)) {
    reftime=firstTime;
  }
 else {
    reftime=lastTime;
  }
  int idx=0;
  secondsDiffFromRefTime=new double[vpList.size()];
  for (  S1Metadata.OrbitStatePosVelox vp : vpList) {
    secondsDiffFromRefTime[idx]=(vp.time - reftime);
    idx++;
  }
  zeroDopplerTimeFirstRef=(zeroDopplerTimeFirstLineSeconds - reftime) - iSafetyBufferAz * deltaT;
  zeroDopplerTimeLastRef=(zeroDopplerTimeLastLineSeconds - reftime) + iSafetyBufferAz * deltaT;
  double minT=0;
  double maxT=0;
  if (zeroDopplerTimeFirstRef < zeroDopplerTimeLastRef) {
    minT=FastMath.min(0,zeroDopplerTimeFirstRef);
    maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeLastRef);
  }
 else {
    if (firstTime < (lastTime)) {
      minT=FastMath.min(secondsDiffFromRefTime[0],zeroDopplerTimeLastRef);
      maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeFirstRef);
    }
 else {
      minT=FastMath.min(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeLastRef);
      maxT=FastMath.max(secondsDiffFromRefTime[0],zeroDopplerTimeFirstRef);
    }
  }
  int limit=((Double)((maxT - minT) / deltaT)).intValue();
  Double[] timeStampInterpSecondsRef=new Double[limit + 1];
  double nextVal=0;
  for (int j=0; j <= limit; j++) {
    timeStampInterpSecondsRef[j]=nextVal;
    nextVal=deltaT + nextVal;
  }
  double zeroDopplerTimeInitRef=zeroDopplerTimeFirstRef;
  double zeroDopplerTimeEndRef=zeroDopplerTimeLastRef;
  if (zeroDopplerTimeFirstRef > zeroDopplerTimeLastRef) {
    zeroDopplerTimeInitRef=zeroDopplerTimeLastRef;
    zeroDopplerTimeEndRef=zeroDopplerTimeFirstRef;
  }
  if (zeroDopplerTimeInitRef < timeStampInterpSecondsRef[1]) {
    int size=Math.min(nPoints,N_ORB_POINT_INTERP);
    double[] subTimesDiffRef=Arrays.copyOfRange(secondsDiffFromRefTime,0,nPoints);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < size; i++) {
      double valMax=timeStampInterpSecondsRef[size - 1];
      if (timeStampInterpSecondsRef[i] < valMax) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<IMetadata.OrbitStatePosVelox> subList=vpList.subList(0,size);
    double initTime=zeroDopplerTimeInitRef;
    int idxInitTime=-1;
    boolean finded=false;
    double endTime=secondsDiffFromRefTime[0];
    int idxEndTime=-1;
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= initTime && !finded) {
        idxInitTime=i;
        finded=true;
      }
      if (timeStampInterpSecondsRef[i] < endTime) {
        idxEndTime=i;
      }
    }
    logger.debug(""String_Node_Str"" + idxInitTime + ""String_Node_Str""+ idxEndTime);
    Double[] t0=(Double[])timeStampInitSecondsRefPointsInterp.toArray();
    if (idxInitTime != -1 && idxEndTime != -1 && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(subTimesDiffRef,subList,t0,idxInitTime,idxEndTime,deltaTinv,vPoints,pPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampOutput);
 else       timeStampInterp.addAll(timeStampOutput);
    }
  }
  for (int orbPoint=1; orbPoint < nPoints; orbPoint++) {
    if (secondsDiffFromRefTime[orbPoint - 1] < zeroDopplerTimeEndRef || secondsDiffFromRefTime[orbPoint] > zeroDopplerTimeEndRef) {
      int idxStart=0;
      int idxEnd=0;
      if (N_ORB_POINT_INTERP > nPoints) {
        idxEnd=nPoints;
      }
 else {
        idxStart=orbPoint - new Double(Math.floor(N_ORB_POINT_INTERP / 2)).intValue();
        idxEnd=idxStart + N_ORB_POINT_INTERP - 1;
        if (idxStart < 1) {
          idxStart=0;
          idxEnd=N_ORB_POINT_INTERP - 1;
        }
        if (idxEnd >= nPoints) {
          idxStart=nPoints - N_ORB_POINT_INTERP;
          idxEnd=nPoints - 1;
        }
      }
      double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,idxStart,idxEnd + 1);
      List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
      for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
        if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[idxStart] && timeStampInterpSecondsRef[i] < secondsDiffFromRefTime[idxEnd]) {
          timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
        }
      }
      List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(idxStart,idxEnd + 1);
      double initTime=Math.max(secondsDiffFromRefTime[orbPoint - 1],zeroDopplerTimeInitRef);
      int idxInitTime=0;
      boolean findIdxInitTime=false;
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
        if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
          idxInitTime=i;
          findIdxInitTime=true;
        }
      }
      double endTime=Math.min(secondsDiffFromRefTime[orbPoint],zeroDopplerTimeEndRef);
      int idxEndTime=0;
      boolean findIdxEndTime=false;
      for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
        if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
          idxEndTime=i;
          findIdxEndTime=true;
        }
      }
      double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
      Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
        timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
      }
      if (findIdxEndTime && findIdxInitTime && initTime < endTime && idxInitTime < idxEndTime) {
        List<double[]> vPoints=new ArrayList<double[]>();
        List<double[]> pPoints=new ArrayList<double[]>();
        List<Double> timeStampOutput=new ArrayList<Double>();
        HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
        addPointsToResult(vPoints,pPoints);
        List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
        for (int i=0; i < timeStampOutput.size(); i++) {
          timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
        }
        if (timeStampInterp == null)         timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else         timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
      }
    }
  }
  if (zeroDopplerTimeEndRef > secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1]) {
    int vOrbPointsInit=(nPoints - Math.min(nPoints,N_ORB_POINT_INTERP));
    int vOrbPointsEnd=nPoints - 1;
    double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,vOrbPointsInit,vOrbPointsEnd + 1);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[vOrbPointsInit]) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(vOrbPointsInit,vOrbPointsEnd + 1);
    double initTime=secondsDiffFromRefTime[vOrbPointsEnd];
    int idxInitTime=0;
    boolean findIdxInitTime=false;
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
      if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
        idxInitTime=i;
        findIdxInitTime=true;
      }
    }
    double endTime=zeroDopplerTimeEndRef;
    int idxEndTime=0;
    boolean findIdxEndTime=false;
    for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
      if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
        idxEndTime=i;
        findIdxEndTime=true;
      }
    }
    double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
    Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
      timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
    }
    if (findIdxEndTime && findIdxInitTime && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
      for (int i=0; i < timeStampOutput.size(); i++) {
        timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
      }
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else       timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
    }
  }
}","public void orbitInterpolation(List<S1Metadata.OrbitStatePosVelox> vpList,double zeroDopplerTimeFirstLineSeconds,double zeroDopplerTimeLastLineSeconds,double samplingf,double iSafetyBufferAz) throws MathException {
  this.iSafetyBufferAz=iSafetyBufferAz;
  double deltaT=1 / samplingf;
  double deltaTinv=1 / deltaT;
  int nPoints=vpList.size();
  double reftime=0;
  double firstTime=vpList.get(0).time;
  double lastTime=vpList.get(vpList.size() - 1).time;
  if (firstTime < (lastTime)) {
    reftime=firstTime;
  }
 else {
    reftime=lastTime;
  }
  int idx=0;
  secondsDiffFromRefTime=new double[vpList.size()];
  for (  S1Metadata.OrbitStatePosVelox vp : vpList) {
    secondsDiffFromRefTime[idx]=(vp.time - reftime);
    idx++;
  }
  zeroDopplerTimeFirstRef=(zeroDopplerTimeFirstLineSeconds - reftime) - iSafetyBufferAz * deltaT;
  zeroDopplerTimeLastRef=(zeroDopplerTimeLastLineSeconds - reftime) + iSafetyBufferAz * deltaT;
  double minT=0;
  double maxT=0;
  if (zeroDopplerTimeFirstRef < zeroDopplerTimeLastRef) {
    minT=FastMath.min(0,zeroDopplerTimeFirstRef);
    maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeLastRef);
  }
 else {
    if (firstTime < (lastTime)) {
      minT=FastMath.min(secondsDiffFromRefTime[0],zeroDopplerTimeLastRef);
      maxT=FastMath.max(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeFirstRef);
    }
 else {
      minT=FastMath.min(secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1],zeroDopplerTimeLastRef);
      maxT=FastMath.max(secondsDiffFromRefTime[0],zeroDopplerTimeFirstRef);
    }
  }
  int limit=((Double)((maxT - minT) / deltaT)).intValue();
  Double[] timeStampInterpSecondsRef=new Double[limit + 1];
  double nextVal=0;
  for (int j=0; j <= limit; j++) {
    timeStampInterpSecondsRef[j]=nextVal;
    nextVal=deltaT + nextVal;
  }
  double zeroDopplerTimeInitRef=zeroDopplerTimeFirstRef;
  double zeroDopplerTimeEndRef=zeroDopplerTimeLastRef;
  if (zeroDopplerTimeFirstRef > zeroDopplerTimeLastRef) {
    zeroDopplerTimeInitRef=zeroDopplerTimeLastRef;
    zeroDopplerTimeEndRef=zeroDopplerTimeFirstRef;
  }
  if (zeroDopplerTimeInitRef < timeStampInterpSecondsRef[1]) {
    int size=Math.min(nPoints,N_ORB_POINT_INTERP);
    double[] subTimesDiffRef=Arrays.copyOfRange(secondsDiffFromRefTime,0,nPoints);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < size; i++) {
      double valMax=timeStampInterpSecondsRef[size - 1];
      if (timeStampInterpSecondsRef[i] < valMax) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<IMetadata.OrbitStatePosVelox> subList=vpList.subList(0,size);
    double initTime=zeroDopplerTimeInitRef;
    int idxInitTime=-1;
    boolean finded=false;
    double endTime=secondsDiffFromRefTime[0];
    int idxEndTime=-1;
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= initTime && !finded) {
        idxInitTime=i;
        finded=true;
      }
      if (timeStampInterpSecondsRef[i] < endTime) {
        idxEndTime=i;
      }
    }
    logger.debug(""String_Node_Str"" + idxInitTime + ""String_Node_Str""+ idxEndTime);
    Double[] t0=(Double[])timeStampInitSecondsRefPointsInterp.toArray(new Double[0]);
    if (idxInitTime != -1 && idxEndTime != -1 && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(subTimesDiffRef,subList,t0,idxInitTime,idxEndTime,deltaTinv,vPoints,pPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampOutput);
 else       timeStampInterp.addAll(timeStampOutput);
    }
  }
  for (int orbPoint=1; orbPoint < nPoints; orbPoint++) {
    if (secondsDiffFromRefTime[orbPoint - 1] < zeroDopplerTimeEndRef || secondsDiffFromRefTime[orbPoint] > zeroDopplerTimeEndRef) {
      int idxStart=0;
      int idxEnd=0;
      if (N_ORB_POINT_INTERP > nPoints) {
        idxEnd=nPoints;
      }
 else {
        idxStart=orbPoint - new Double(Math.floor(N_ORB_POINT_INTERP / 2)).intValue();
        idxEnd=idxStart + N_ORB_POINT_INTERP - 1;
        if (idxStart < 1) {
          idxStart=0;
          idxEnd=N_ORB_POINT_INTERP - 1;
        }
        if (idxEnd >= nPoints) {
          idxStart=nPoints - N_ORB_POINT_INTERP;
          idxEnd=nPoints - 1;
        }
      }
      double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,idxStart,idxEnd + 1);
      List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
      for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
        if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[idxStart] && timeStampInterpSecondsRef[i] < secondsDiffFromRefTime[idxEnd]) {
          timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
        }
      }
      List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(idxStart,idxEnd + 1);
      double initTime=Math.max(secondsDiffFromRefTime[orbPoint - 1],zeroDopplerTimeInitRef);
      int idxInitTime=0;
      boolean findIdxInitTime=false;
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
        if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
          idxInitTime=i;
          findIdxInitTime=true;
        }
      }
      double endTime=Math.min(secondsDiffFromRefTime[orbPoint],zeroDopplerTimeEndRef);
      int idxEndTime=0;
      boolean findIdxEndTime=false;
      for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
        if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
          idxEndTime=i;
          findIdxEndTime=true;
        }
      }
      double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
      Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
      for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
        timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
      }
      if (findIdxEndTime && findIdxInitTime && initTime < endTime && idxInitTime < idxEndTime) {
        List<double[]> vPoints=new ArrayList<double[]>();
        List<double[]> pPoints=new ArrayList<double[]>();
        List<Double> timeStampOutput=new ArrayList<Double>();
        HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
        addPointsToResult(vPoints,pPoints);
        List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
        for (int i=0; i < timeStampOutput.size(); i++) {
          timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
        }
        if (timeStampInterp == null)         timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else         timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
      }
    }
  }
  if (zeroDopplerTimeEndRef > secondsDiffFromRefTime[secondsDiffFromRefTime.length - 1]) {
    int vOrbPointsInit=(nPoints - Math.min(nPoints,N_ORB_POINT_INTERP));
    int vOrbPointsEnd=nPoints - 1;
    double[] timeStampInitSecondsRefPoints=Arrays.copyOfRange(secondsDiffFromRefTime,vOrbPointsInit,vOrbPointsEnd + 1);
    List<Double> timeStampInitSecondsRefPointsInterp=new ArrayList<Double>();
    for (int i=0; i < timeStampInterpSecondsRef.length; i++) {
      if (timeStampInterpSecondsRef[i] >= secondsDiffFromRefTime[vOrbPointsInit]) {
        timeStampInitSecondsRefPointsInterp.add(timeStampInterpSecondsRef[i]);
      }
    }
    List<S1Metadata.OrbitStatePosVelox> stateVecPoints=vpList.subList(vOrbPointsInit,vOrbPointsEnd + 1);
    double initTime=secondsDiffFromRefTime[vOrbPointsEnd];
    int idxInitTime=0;
    boolean findIdxInitTime=false;
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size() && !findIdxInitTime; i++) {
      if (timeStampInitSecondsRefPointsInterp.get(i) >= initTime) {
        idxInitTime=i;
        findIdxInitTime=true;
      }
    }
    double endTime=zeroDopplerTimeEndRef;
    int idxEndTime=0;
    boolean findIdxEndTime=false;
    for (int i=timeStampInitSecondsRefPointsInterp.size() - 1; i >= 0 && !findIdxEndTime; i--) {
      if (timeStampInitSecondsRefPointsInterp.get(i) < endTime) {
        idxEndTime=i;
        findIdxEndTime=true;
      }
    }
    double timeRef=timeStampInitSecondsRefPointsInterp.get(0);
    Double[] timeStampInitSecondsRefPointsInterp0=new Double[timeStampInitSecondsRefPointsInterp.size()];
    for (int i=0; i < timeStampInitSecondsRefPointsInterp.size(); i++) {
      timeStampInitSecondsRefPointsInterp0[i]=timeStampInitSecondsRefPointsInterp.get(i) - timeRef;
    }
    if (findIdxEndTime && findIdxInitTime && initTime < endTime) {
      List<double[]> vPoints=new ArrayList<double[]>();
      List<double[]> pPoints=new ArrayList<double[]>();
      List<Double> timeStampOutput=new ArrayList<Double>();
      HermiteInterpolation.interpolation(timeStampInitSecondsRefPoints,stateVecPoints,timeStampInitSecondsRefPointsInterp0,idxInitTime,idxEndTime,deltaTinv,pPoints,vPoints,timeStampOutput);
      addPointsToResult(vPoints,pPoints);
      List<Double> timeStampInterpSecondsRefOutput=new ArrayList<Double>();
      for (int i=0; i < timeStampOutput.size(); i++) {
        timeStampInterpSecondsRefOutput.add(timeStampOutput.get(i) + timeRef);
      }
      if (timeStampInterp == null)       timeStampInterp=new ArrayList<>(timeStampInterpSecondsRefOutput);
 else       timeStampInterp.addAll(timeStampInterpSecondsRefOutput);
    }
  }
}",0.999342005365187
175240,"@Override public List<FieldInListPageBo> getListPageFiledList(Integer tabId,String lang){
  List<FieldInListPageBo> fieldInListPageBoList=new ArrayList<>();
  Search search=new Search();
  search.addFilterEqual(""String_Node_Str"",tabId);
  search.addSortAsc(""String_Node_Str"");
  search.addSortAsc(""String_Node_Str"");
  List<FieldPo> fieldPoList=fieldDao.search(search);
  for (  FieldPo fieldPo : fieldPoList) {
    FieldInListPageBo fieldInListPageBo=new FieldInListPageBo();
    fieldInListPageBo.setId(fieldPo.getId());
    fieldInListPageBo.setFieldPo(fieldPo);
    Search trlSearch=new Search();
    trlSearch.addFilterEqual(""String_Node_Str"",lang);
    trlSearch.addFilterEqual(""String_Node_Str"",fieldPo.getId());
    FieldTrlPo fieldTrlPo=fieldTrlDao.searchUnique(trlSearch);
    TableColumnPo tableColumnPo=tableColumnDao.find(fieldPo.getColumnId());
    JavaDataType dataType=JavaDataType.getJavaDataTypeByKey(tableColumnPo.getDataType());
    FieldInputType fieldInputType=FieldInputType.getFieldInputTypeByKey(fieldPo.getInputType());
    fieldInListPageBo.setDataType(dataType);
    fieldInListPageBo.setFieldInputType(fieldInputType);
    if (fieldTrlPo != null) {
      fieldInListPageBo.setName(fieldTrlPo.getName());
    }
 else {
      fieldInListPageBo.setName(fieldPo.getName());
    }
    if (dataType == JavaDataType.DATE) {
      if (fieldInputType == FieldInputType.DATEPICKER) {
        fieldInListPageBo.setPattern(""String_Node_Str"");
      }
 else       if (fieldInputType == FieldInputType.DATETIMEPICKER) {
        fieldInListPageBo.setPattern(""String_Node_Str"");
      }
    }
    fieldInListPageBoList.add(fieldInListPageBo);
  }
  return fieldInListPageBoList;
}","@Override public List<FieldInListPageBo> getListPageFiledList(Integer tabId,String lang){
  List<FieldInListPageBo> fieldInListPageBoList=new ArrayList<>();
  Search search=new Search();
  search.addFilterEqual(""String_Node_Str"",tabId);
  search.addSortAsc(""String_Node_Str"");
  search.addSortAsc(""String_Node_Str"");
  List<FieldPo> fieldPoList=fieldDao.search(search);
  for (  FieldPo fieldPo : fieldPoList) {
    FieldInListPageBo fieldInListPageBo=new FieldInListPageBo();
    fieldInListPageBo.setId(fieldPo.getId());
    fieldInListPageBo.setFieldPo(fieldPo);
    Search trlSearch=new Search();
    trlSearch.addFilterEqual(""String_Node_Str"",lang);
    trlSearch.addFilterEqual(""String_Node_Str"",fieldPo.getId());
    FieldTrlPo fieldTrlPo=fieldTrlDao.searchUnique(trlSearch);
    TableColumnPo tableColumnPo=tableColumnDao.find(fieldPo.getColumnId());
    JavaDataType dataType=JavaDataType.getJavaDataTypeByKey(tableColumnPo.getDataType());
    FieldInputType fieldInputType=FieldInputType.getFieldInputTypeByKey(fieldPo.getInputType().getKey());
    fieldInListPageBo.setDataType(dataType);
    fieldInListPageBo.setFieldInputType(fieldInputType);
    if (fieldTrlPo != null) {
      fieldInListPageBo.setName(fieldTrlPo.getName());
    }
 else {
      fieldInListPageBo.setName(fieldPo.getName());
    }
    if (dataType == JavaDataType.DATE) {
      if (fieldInputType == FieldInputType.DATEPICKER) {
        fieldInListPageBo.setPattern(""String_Node_Str"");
      }
 else       if (fieldInputType == FieldInputType.DATETIMEPICKER) {
        fieldInListPageBo.setPattern(""String_Node_Str"");
      }
    }
    fieldInListPageBoList.add(fieldInListPageBo);
  }
  return fieldInListPageBoList;
}",0.9973490427098676
175241,"@Override public TabFormStructureBo getFormPageFieldList(Integer tabId,String lang){
  TabFormStructureBo tabFormStructureBo=new TabFormStructureBo();
  List<FieldStructureBo> fieldStructureBoList=new ArrayList<>();
  Search search=new Search();
  search.addSortAsc(""String_Node_Str"");
  search.addSortAsc(""String_Node_Str"");
  search.addFilterEqual(""String_Node_Str"",tabId);
  List<FieldPo> fieldPoList=fieldDao.search(search);
  for (  FieldPo fieldPo : fieldPoList) {
    FieldStructureBo fieldStructureBo=new FieldStructureBo();
    Search fieldTrlSearch=new Search();
    fieldTrlSearch.addFilterEqual(""String_Node_Str"",fieldPo.getId());
    fieldTrlSearch.addFilterEqual(""String_Node_Str"",lang);
    FieldTrlPo fieldTrlPo=fieldTrlDao.searchUnique(fieldTrlSearch);
    if (fieldTrlPo == null) {
      fieldTrlPo=new FieldTrlPo();
      fieldTrlPo.setName(fieldPo.getName());
      fieldTrlPo.setDescription(fieldPo.getDescription());
      fieldTrlPo.setHelp(""String_Node_Str"");
    }
    FieldInputType fieldInputType=FieldInputType.getFieldInputTypeByKey(fieldPo.getInputType());
    fieldStructureBo.setFieldInputType(fieldInputType);
    fieldStructureBo.setFieldPo(fieldPo);
    fieldStructureBo.setFieldTrlPo(fieldTrlPo);
    Search fieldValidatorSearch=new Search();
    fieldValidatorSearch.addFilterEqual(""String_Node_Str"",fieldPo.getId());
    List<FieldValidatorPo> fieldValidatorPoList=fieldValidatorDao.search(fieldValidatorSearch);
    fieldStructureBo.setFieldValidatorPoList(fieldValidatorPoList);
    if (FieldInputType.CHECKBOX == fieldInputType) {
      Search checkSearch=new Search();
      checkSearch.addFilterEqual(""String_Node_Str"",fieldPo.getElementId());
      ElementCheckboxPo elementCheckboxPo=elementCheckboxDao.searchUnique(checkSearch);
      fieldStructureBo.setFalseValue(elementCheckboxPo.getUncheckedValue());
      fieldStructureBo.setTrueValue(elementCheckboxPo.getCheckedValue());
    }
    fieldStructureBoList.add(fieldStructureBo);
  }
  tabFormStructureBo.setFieldStructureBoList(fieldStructureBoList);
  return tabFormStructureBo;
}","@Override public TabFormStructureBo getFormPageFieldList(Integer tabId,String lang){
  TabFormStructureBo tabFormStructureBo=new TabFormStructureBo();
  List<FieldStructureBo> fieldStructureBoList=new ArrayList<>();
  Search search=new Search();
  search.addSortAsc(""String_Node_Str"");
  search.addSortAsc(""String_Node_Str"");
  search.addFilterEqual(""String_Node_Str"",tabId);
  List<FieldPo> fieldPoList=fieldDao.search(search);
  for (  FieldPo fieldPo : fieldPoList) {
    FieldStructureBo fieldStructureBo=new FieldStructureBo();
    Search fieldTrlSearch=new Search();
    fieldTrlSearch.addFilterEqual(""String_Node_Str"",fieldPo.getId());
    fieldTrlSearch.addFilterEqual(""String_Node_Str"",lang);
    FieldTrlPo fieldTrlPo=fieldTrlDao.searchUnique(fieldTrlSearch);
    if (fieldTrlPo == null) {
      fieldTrlPo=new FieldTrlPo();
      fieldTrlPo.setName(fieldPo.getName());
      fieldTrlPo.setDescription(fieldPo.getDescription());
      fieldTrlPo.setHelp(""String_Node_Str"");
    }
    FieldInputType fieldInputType=FieldInputType.getFieldInputTypeByKey(fieldPo.getInputType().getKey());
    fieldStructureBo.setFieldInputType(fieldInputType);
    fieldStructureBo.setFieldPo(fieldPo);
    fieldStructureBo.setFieldTrlPo(fieldTrlPo);
    Search fieldValidatorSearch=new Search();
    fieldValidatorSearch.addFilterEqual(""String_Node_Str"",fieldPo.getId());
    List<FieldValidatorPo> fieldValidatorPoList=fieldValidatorDao.search(fieldValidatorSearch);
    fieldStructureBo.setFieldValidatorPoList(fieldValidatorPoList);
    if (FieldInputType.CHECKBOX == fieldInputType) {
      Search checkSearch=new Search();
      checkSearch.addFilterEqual(""String_Node_Str"",fieldPo.getElementId());
      ElementCheckboxPo elementCheckboxPo=elementCheckboxDao.searchUnique(checkSearch);
      fieldStructureBo.setFalseValue(elementCheckboxPo.getUncheckedValue());
      fieldStructureBo.setTrueValue(elementCheckboxPo.getCheckedValue());
    }
    fieldStructureBoList.add(fieldStructureBo);
  }
  tabFormStructureBo.setFieldStructureBoList(fieldStructureBoList);
  return tabFormStructureBo;
}",0.99784327821711
175242,"@RequiresPermissions(value=""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public JsonResult<String> getInputType(){
  JsonObject listObject=new JsonObject();
  JsonArray jsonArray=new JsonArray();
  for (  FieldInputType fieldInputType : FieldInputType.values()) {
    JsonObject jsonObject=new JsonObject();
    jsonObject.addProperty(""String_Node_Str"",fieldInputType.getKey());
    jsonObject.addProperty(""String_Node_Str"",fieldInputType.getDesc());
    jsonArray.add(jsonObject);
  }
  listObject.add(""String_Node_Str"",jsonArray);
  return JsonResult.success(listObject.toString());
}","@RequiresPermissions(value=""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public JsonResult<String> getInputType(){
  JsonObject listObject=new JsonObject();
  JsonArray jsonArray=new JsonArray();
  for (  FieldInputType fieldInputType : FieldInputType.values()) {
    JsonObject jsonObject=new JsonObject();
    jsonObject.addProperty(""String_Node_Str"",fieldInputType.name());
    jsonObject.addProperty(""String_Node_Str"",fieldInputType.getDesc());
    jsonArray.add(jsonObject);
  }
  listObject.add(""String_Node_Str"",jsonArray);
  return JsonResult.success(listObject.toString());
}",0.9921630094043888
175243,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(""String_Node_Str"") public JsonResult<PaginationResult<FieldPo>> fieldList(HttpSession session,@RequestBody Integer columnId){
  Search search=SearchHelper.getSearchParam(URI,session);
  PaginationResult<FieldPo> paginationResult=fieldService.getFieldListByColumnId(search,columnId);
  return JsonResult.success(paginationResult);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(""String_Node_Str"") public JsonResult<PaginationResult<FieldPo>> fieldList(HttpSession session,@RequestBody Integer tabId){
  Search search=SearchHelper.getSearchParam(URI,session);
  PaginationResult<FieldPo> paginationResult=fieldService.getFieldListByTabId(search,tabId);
  return JsonResult.success(paginationResult);
}",0.968494749124854
175244,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<OrgBo> saveForUpdated(@Validated @RequestBody OrgBo orgBo){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (orgBo.getId() == null) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  orgService.save(orgBo);
  return get(orgBo.getId());
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<OrgBo> saveForUpdated(@Validated @RequestBody OrgBo orgBo){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (orgBo.getId() == null) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  if (orgService.getOrgByNo(orgBo.getNo()).getId() != orgBo.getId()) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  orgService.save(orgBo);
  return get(orgBo.getId());
}",0.8394849785407725
175245,"private static String parse(String all){
  String comment=null;
  int index=all.indexOf(""String_Node_Str"");
  if (index < 0) {
    return ""String_Node_Str"";
  }
  comment=all.substring(index + 9);
  comment=comment.substring(0,comment.length() - 1);
  try {
    comment=new String(comment.getBytes(""String_Node_Str""));
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
  return comment;
}","private static String parse(String all){
  String comment=null;
  int index=all.indexOf(""String_Node_Str"");
  if (index < 0) {
    return ""String_Node_Str"";
  }
  comment=all.substring(index + 9);
  comment=comment.substring(0,comment.length() - 1);
  try {
    comment=new String(comment.getBytes(""String_Node_Str""),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
  return comment;
}",0.9787735849056604
175246,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<TableMetaDataBo> getTableInfo(String tableName){
  TableMetaDataBo tableMetaDataBo=tableService.getTableDescription(tableName);
  return JsonResult.success(tableMetaDataBo);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<TableMetaDataBo> getTableInfo(String tableName,HttpSession session){
  UserResource userResource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (tableName == null && tableName.equals(""String_Node_Str"")) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),userResource.getMessage(""String_Node_Str""));
  }
  if (tableService.findExistTableByName(tableName)) {
    TableMetaDataBo tableMetaDataBo=tableService.getTableDescription(tableName);
    return JsonResult.success(tableMetaDataBo);
  }
 else {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),userResource.getMessage(""String_Node_Str""));
  }
}",0.5640107430617726
175247,"/** 
 * @param languageBo
 * @return
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<LanguageBo> saveForUpdated(@RequestBody LanguageBo languageBo){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (languageBo.getCode() == null || languageBo.getCode().isEmpty()) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  languageService.save(languageBo);
  return get(languageBo.getCode());
}","/** 
 * @param languageBo
 * @return
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<LanguageBo> saveForUpdated(@RequestBody LanguageBo languageBo){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (languageBo.getCode() == null || languageBo.getCode().isEmpty()) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  if (languageService.findExistLanguageByName(languageBo.getName())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  languageService.save(languageBo);
  return get(languageBo.getCode());
}",0.8636032093362509
175248,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<LanguageBo> saveForCreated(@RequestBody LanguageBo languageBo){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (languageService.findExistLanguage(languageBo.getCode())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  languageService.save(languageBo);
  return get(languageBo.getCode());
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<LanguageBo> saveForCreated(@RequestBody LanguageBo languageBo){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (languageService.findExistLanguage(languageBo.getCode())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  if (languageService.findExistLanguageByName(languageBo.getName())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  languageService.save(languageBo);
  return get(languageBo.getCode());
}",0.8533333333333334
175249,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<RoleBo> saveForUpdated(@RequestBody RoleBo roleBo,HttpSession session){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (roleService.findExistRole(roleBo.getName())) {
    RoleBo role=roleService.getRoleBo(roleBo.getId());
    role.setIsactive(roleBo.getIsactive());
    role.setRoleOrgAccessBoList(roleBo.getRoleOrgAccessBoList());
    role.setModuleRoleBoList(roleBo.getModuleRoleBoList());
    role.setRemark(roleBo.getRemark());
    roleService.save(role);
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  roleService.save(roleBo);
  return get(roleBo.getId(),session);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<RoleBo> saveForUpdated(@RequestBody RoleBo roleBo,HttpSession session){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (roleService.findExistRole(roleBo.getName())) {
    if (roleService.findExistRoleByName(roleBo.getName()).getId() == roleBo.getId()) {
      roleService.save(roleBo);
    }
 else {
      return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
    }
  }
 else {
    roleService.save(roleBo);
  }
  return get(roleBo.getId(),session);
}",0.7394736842105263
175250,"/** 
 * @param clientBo
 * @return
 */
@RequiresPermissions(""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public JsonResult<ClientBo> saveForCreate(@Validated @RequestBody ClientBo clientBo){
  if (clientService.findExistClient(clientBo.getNo())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),getMessage(""String_Node_Str""));
  }
  clientService.save(clientBo);
  return get(clientBo.getId());
}","/** 
 * @param clientBo
 * @return
 */
@RequiresPermissions(""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public JsonResult<ClientBo> saveForCreate(@Validated @RequestBody ClientBo clientBo){
  if (clientService.findExistClient(clientBo.getNo())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),getMessage(""String_Node_Str""));
  }
  if (clientService.findExistClientByName(clientBo.getName())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),getMessage(""String_Node_Str""));
  }
  clientService.save(clientBo);
  return get(clientBo.getId());
}",0.8450450450450451
175251,"@RequiresPermissions(""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public JsonResult<ClientBo> saveForUpdate(@Validated @RequestBody ClientBo clientBo){
  if (clientBo.getId() == null) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),getMessage(""String_Node_Str""));
  }
  clientService.save(clientBo);
  return get(clientBo.getId());
}","@RequiresPermissions(""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public JsonResult<ClientBo> saveForUpdate(@Validated @RequestBody ClientBo clientBo){
  if (clientBo.getId() == null) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),getMessage(""String_Node_Str""));
  }
  if (clientService.findExistClientByName(clientBo.getName())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),getMessage(""String_Node_Str""));
  }
  clientService.save(clientBo);
  return get(clientBo.getId());
}",0.8255578093306288
175252,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<SearchBo> saveForUpdated(@RequestBody @Validated SearchBo searchBo,HttpSession session){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (searchBo.getId() == null) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  searchBo=searchService.saveSearchBo(searchBo);
  return get(searchBo.getId());
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<SearchBo> saveForUpdated(@RequestBody @Validated SearchBo searchBo,HttpSession session){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (searchBo.getId() == null) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  if (searchService.getSearchBoByUri(searchBo.getUri()) != null) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  searchBo=searchService.saveSearchBo(searchBo);
  return get(searchBo.getId());
}",0.8472983555207517
175253,"/** 
 * @param searchBo
 * @return
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<SearchBo> saveForCreated(@RequestBody @Validated SearchBo searchBo){
  searchBo=searchService.saveSearchBo(searchBo);
  return get(searchBo.getId());
}","/** 
 * @param searchBo
 * @return
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<SearchBo> saveForCreated(@RequestBody @Validated SearchBo searchBo,HttpSession session){
  UserResource userResource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (searchService.getSearchBoByUri(searchBo.getUri()) != null) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),userResource.getMessage(""String_Node_Str""));
  }
  searchBo=searchService.saveSearchBo(searchBo);
  return get(searchBo.getId());
}",0.6742738589211619
175254,boolean findExistClientByName(String clientName);,ClientBo findExistClientByName(String clientName);,0.8686868686868687
175255,"@Override public boolean findExistClientByName(String clientName){
  Search search=new Search();
  search.addFilterEqual(""String_Node_Str"",clientName);
  List<ClientPo> clientPoList=clientDao.search(search);
  if (clientPoList != null && clientPoList.size() > 0) {
    return true;
  }
 else {
    return false;
  }
}","@Override public ClientBo findExistClientByName(String clientName){
  Search search=new Search();
  search.addFilterEqual(""String_Node_Str"",clientName);
  ClientPo clientPo=clientDao.searchUnique(search);
  ClientBo clientBo=modelMapper.map(clientPo,ClientBo.class);
  return clientBo;
}",0.6324503311258278
175256,boolean findExistLanguageByName(String languageName);,LanguageBo findExistLanguageByName(String languageName);,0.8807339449541285
175257,"@Override public boolean findExistLanguageByName(String languageName){
  Search search=new Search();
  search.addFilterEqual(""String_Node_Str"",languageName);
  List<LanguagePo> languagePoList=languageDao.search(search);
  if (languagePoList != null && languagePoList.size() > 0) {
    return true;
  }
 else {
    return false;
  }
}","@Override public LanguageBo findExistLanguageByName(String languageName){
  Search search=new Search();
  search.addFilterEqual(""String_Node_Str"",languageName);
  LanguagePo languagePo=languageDao.searchUnique(search);
  LanguageBo languageBo=modelMapper.map(languagePo,LanguageBo.class);
  return languageBo;
}",0.639751552795031
175258,"/** 
 * @param clientBo
 * @return
 */
@RequiresPermissions(""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public JsonResult<ClientBo> saveForCreate(@Validated @RequestBody ClientBo clientBo){
  if (clientService.findExistClient(clientBo.getNo())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),getMessage(""String_Node_Str""));
  }
  if (clientService.findExistClientByName(clientBo.getName())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),getMessage(""String_Node_Str""));
  }
  clientService.save(clientBo);
  return get(clientBo.getId());
}","/** 
 * @param clientBo
 * @return
 */
@RequiresPermissions(""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public JsonResult<ClientBo> saveForCreate(@Validated @RequestBody ClientBo clientBo){
  if (clientService.findExistClient(clientBo.getNo())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),getMessage(""String_Node_Str""));
  }
  if (clientService.findExistClientName(clientBo.getName())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),getMessage(""String_Node_Str""));
  }
  clientService.save(clientBo);
  return get(clientBo.getId());
}",0.9984326018808778
175259,"@RequiresPermissions(""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public JsonResult<ClientBo> saveForUpdate(@Validated @RequestBody ClientBo clientBo){
  if (clientBo.getId() == null) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),getMessage(""String_Node_Str""));
  }
  if (clientService.findExistClientByName(clientBo.getName())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),getMessage(""String_Node_Str""));
  }
  clientService.save(clientBo);
  return get(clientBo.getId());
}","@RequiresPermissions(""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public JsonResult<ClientBo> saveForUpdate(@Validated @RequestBody ClientBo clientBo){
  if (clientBo.getId() == null) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),getMessage(""String_Node_Str""));
  }
  if (clientService.findExistClientName(clientBo.getName())) {
    if (clientService.findExistClientByName(clientBo.getName()).getId() == clientBo.getId()) {
      clientService.save(clientBo);
    }
 else {
      return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),getMessage(""String_Node_Str""));
    }
  }
 else {
    clientService.save(clientBo);
  }
  return get(clientBo.getId());
}",0.8749052312357847
175260,"/** 
 * @param languageBo
 * @return
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<LanguageBo> saveForUpdated(@RequestBody LanguageBo languageBo){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (languageBo.getCode() == null || languageBo.getCode().isEmpty()) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  if (languageService.findExistLanguageByName(languageBo.getName())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  languageService.save(languageBo);
  return get(languageBo.getCode());
}","/** 
 * @param languageBo
 * @return
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<LanguageBo> saveForUpdated(@RequestBody LanguageBo languageBo){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (languageBo.getCode() == null || languageBo.getCode().isEmpty()) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  if (languageService.findExistLanguageName(languageBo.getName())) {
    if (languageService.findExistLanguageByName(languageBo.getName()).getCode().equals(languageBo.getCode())) {
      languageService.save(languageBo);
    }
 else {
      return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
    }
  }
 else {
    languageService.save(languageBo);
  }
  return get(languageBo.getCode());
}",0.8931034482758621
175261,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<LanguageBo> saveForCreated(@RequestBody LanguageBo languageBo){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (languageService.findExistLanguage(languageBo.getCode())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  if (languageService.findExistLanguageByName(languageBo.getName())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  languageService.save(languageBo);
  return get(languageBo.getCode());
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<LanguageBo> saveForCreated(@RequestBody LanguageBo languageBo){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (languageService.findExistLanguage(languageBo.getCode())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  if (languageService.findExistLanguageName(languageBo.getName())) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  languageService.save(languageBo);
  return get(languageBo.getCode());
}",0.9986263736263736
175262,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<SearchBo> saveForUpdated(@RequestBody @Validated SearchBo searchBo,HttpSession session){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (searchBo.getId() == null) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  if (searchService.getSearchBoByUri(searchBo.getUri()) != null) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  searchBo=searchService.saveSearchBo(searchBo);
  return get(searchBo.getId());
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<SearchBo> saveForUpdated(@RequestBody @Validated SearchBo searchBo,HttpSession session){
  UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
  if (searchBo.getId() == null) {
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  if (searchService.getSearchBoByUri(searchBo.getUri()) != null) {
    if (searchService.getSearchBoByUri(searchBo.getUri()).getId() == searchBo.getId()) {
      searchBo=searchService.saveSearchBo(searchBo);
    }
 else {
      return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
    }
  }
 else {
    searchBo=searchService.saveSearchBo(searchBo);
  }
  return get(searchBo.getId());
}",0.8910648714810282
175263,"/** 
 * getModuleToJsp:页面跳转
 * @return
 */
@RequiresPermissions(value=""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView getModuleToJsp(){
  ModelAndView modelAndView=new ModelAndView(""String_Node_Str"");
  modelAndView.addObject(""String_Node_Str"",PagingSettingResult.getDefault());
  return modelAndView;
}","/** 
 * getModuleToJsp:页面跳转
 * @return
 */
@RequiresPermissions(value=""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView getModuleToJsp(){
  ModelAndView modelAndView=new ModelAndView(""String_Node_Str"");
  modelAndView.addObject(""String_Node_Str"",PagingSettingResult.getDefault());
  modelAndView.addObject(WebConst.PAGE_URI,URI);
  return modelAndView;
}",0.8868660598179454
175264,"/** 
 * deleteModuleList:模块设置批量删除
 * @param ids
 * @return
 */
@RequiresPermissions(value=""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public JsonResult<List<ModuleBo>> deleteModuleList(@RequestBody Integer[] ids,HttpSession session){
  if (ids.length == 0) {
    UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  moduleService.deleteModuleList(ids);
  return getModuleList();
}","/** 
 * deleteModuleList:模块设置批量删除
 * @param ids
 * @return
 */
@RequiresPermissions(value=""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public JsonResult<List<ModuleBo>> deleteModuleList(@RequestBody Integer[] ids,HttpSession session){
  if (ids.length == 0) {
    UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  moduleService.deleteModuleList(ids);
  return getModuleList(session);
}",0.9940222032450896
175265,"/** 
 * getModuleList:模块设置列表
 * @param
 * @return
 */
@RequiresPermissions(value=""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public JsonResult<List<ModuleBo>> getModuleList(){
  List<ModuleBo> moduleList=moduleService.getModuleList(new Search());
  return JsonResult.success(moduleList);
}","/** 
 * getModuleList:模块设置列表
 * @param
 * @return
 */
@RequiresPermissions(value=""String_Node_Str"") @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public JsonResult<List<ModuleBo>> getModuleList(HttpSession session){
  Search search=SearchHelper.getSearchParam(URI,session);
  List<ModuleBo> moduleList=moduleService.getModuleList(search);
  return JsonResult.success(moduleList);
}",0.8751642575558476
175266,"@Override public PageMenuBo getPageMenuBo(Integer id){
  PageMenuPo pageMenuPo=pageMenuDao.find(id);
  PageMenuBo pageMenuBo=modelMapper.map(pageMenuPo,PageMenuBo.class);
  List<PageMenuTrlBo> pageMenuTrlBo=modelMapper.map(pageMenuPo.getPageMenuTrlPoList(),new TypeToken<List<PageMenuTrlBo>>(){
  }
.getType());
  List<LanguageBo> languageBoList=languageService.findLanguageListForActivated();
  List<PageMenuTrlBo> pagemenuList=new ArrayList<PageMenuTrlBo>();
  for (  LanguageBo lan : languageBoList) {
    PageMenuTrlBo pagemenu=new PageMenuTrlBo();
    pagemenu.setLanguageCode(lan.getCode());
    if (pageMenuTrlBo.size() > 0) {
      for (      PageMenuTrlBo pm : pageMenuTrlBo) {
        if (lan.getCode().equals(pm.getLanguageCode())) {
          pagemenu.setName(pm.getName());
          pagemenu.setRemark(pm.getRemark());
        }
      }
    }
    pagemenuList.add(pagemenu);
  }
  pageMenuBo.setPageMenuTrlBo(pagemenuList);
  return pageMenuBo;
}","@Override public PageMenuBo getPageMenuBo(Integer id){
  PageMenuPo pageMenuPo=pageMenuDao.find(id);
  PageMenuBo pageMenuBo=modelMapper.map(pageMenuPo,PageMenuBo.class);
  List<PageMenuTrlBo> pageMenuTrlBo=modelMapper.map(pageMenuPo.getPageMenuTrlPoList(),new TypeToken<List<PageMenuTrlBo>>(){
  }
.getType());
  List<LanguageBo> languageBoList=languageService.findLanguageListForActivated();
  List<PageMenuTrlBo> pagemenuList=new ArrayList<PageMenuTrlBo>();
  for (  LanguageBo lan : languageBoList) {
    PageMenuTrlBo pagemenu=new PageMenuTrlBo();
    pagemenu.setLanguageCode(lan.getCode());
    if (pageMenuTrlBo.size() > 0) {
      for (      PageMenuTrlBo pm : pageMenuTrlBo) {
        if (lan.getCode().equals(pm.getLanguageCode())) {
          pagemenu.setId(pm.getId());
          pagemenu.setName(pm.getName());
          pagemenu.setRemark(pm.getRemark());
        }
      }
    }
    pagemenuList.add(pagemenu);
  }
  pageMenuBo.setPageMenuTrlBo(pagemenuList);
  return pageMenuBo;
}",0.9805924412665986
175267,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<List<PageMenuBo>> deletes(@RequestBody Integer[] ids,HttpSession session){
  if (ids == null) {
    UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  pageMenuService.deleteMenuById(ids);
  return list(session);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<List<PageMenuBo>> deletes(@RequestBody Integer[] ids,HttpSession session){
  if (ids == null) {
    UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
  for (  Integer id : ids) {
    Search search=new Search();
    search.addFilterEqual(""String_Node_Str"",id);
    List<PageMenuBo> pageMenuBos=pageMenuService.findPageMenu(search);
    if (pageMenuBos.size() > 0) {
      UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
      return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
    }
  }
  pageMenuService.deleteMenuById(ids);
  return list(session);
}",0.7037552155771906
175268,"/** 
 * getListMenuType:获取父菜单列表
 * @return
 * @author :Bobo
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<List<PageMenuBo>> getListMenuType(){
  List<PageMenuBo> pageMenuBoList=pageMenuService.getListMenuType();
  return JsonResult.success(pageMenuBoList);
}","/** 
 * getListMenuType:获取父菜单列表
 * @return
 * @author :Bobo
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<List<PageMenuBo>> getListMenuType(){
  List<PageMenuBo> pageMenuBoList=pageMenuService.getListMenuType();
  PageMenuBo pageMenuBo=new PageMenuBo();
  pageMenuBo.setId(null);
  pageMenuBo.setName(""String_Node_Str"");
  pageMenuBoList.add(0,pageMenuBo);
  return JsonResult.success(pageMenuBoList);
}",0.8327566320645905
175269,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<PageMenuBo> get(Integer id,HttpSession session){
  PageMenuBo pageMenuBo=null;
  if (id == null) {
    UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
 else {
    pageMenuBo=pageMenuService.getPageMenuBo(id);
  }
  return JsonResult.success(pageMenuBo);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody @RequiresPermissions(value=""String_Node_Str"") public JsonResult<PageMenuBo> get(Integer id,HttpSession session){
  PageMenuBo pageMenuBo=null;
  if (id == null) {
    UserResource resource=(UserResource)session.getAttribute(WebConst.SESSION_RESOURCE);
    return JsonResult.fail(ErrorCodes.BUSINESS_EXCEPTION.getCode(),resource.getMessage(""String_Node_Str""));
  }
 else {
    pageMenuBo=pageMenuService.getPageMenuBo(id);
    pageMenuBo.setIsCheck(""String_Node_Str"");
  }
  return JsonResult.success(pageMenuBo);
}",0.9597197898423818
175270,"@Override public void onAnimationUpdate(ValueAnimator animation){
  int update=(int)(animation.getAnimatedValue());
  int incr=360 / maxProgress;
  int value=(update / incr);
  progressUpdate=update;
  progressText=value + ""String_Node_Str"";
  invalidate();
}","@Override public void onAnimationUpdate(ValueAnimator animation){
  float update=(float)(animation.getAnimatedValue());
  float incr=360 / maxProgress;
  float value=(update / incr);
  progressUpdate=update;
  progressText=((int)value) + ""String_Node_Str"";
  invalidate();
}",0.8855534709193246
175271,"public void setProgress(int progress){
  lastProgress=this.progress;
  this.progress=progress;
  post(new Runnable(){
    @Override public void run(){
      int incr=360 / maxProgress;
      Log.e(""String_Node_Str"",""String_Node_Str"" + lastProgress + ""String_Node_Str""+ BatteryProgressView.this.progress);
      if (lastProgress < BatteryProgressView.this.progress) {
        Log.e(""String_Node_Str"",lastProgress + ""String_Node_Str"" + (incr * (BatteryProgressView.this.progress))+ ""String_Node_Str""+ lastProgress);
        animator=ValueAnimator.ofInt(incr * lastProgress,incr * (BatteryProgressView.this.progress));
        animator.setDuration(800);
        animator.addUpdateListener(animatorUpdateListener);
        animator.setInterpolator(new DecelerateInterpolator());
        animator.start();
      }
 else {
        Log.e(""String_Node_Str"",lastProgress + ""String_Node_Str"" + (incr * (BatteryProgressView.this.progress))+ ""String_Node_Str""+ lastProgress);
        animator=ValueAnimator.ofInt((incr * lastProgress),incr * (BatteryProgressView.this.progress));
        animator.setDuration(800);
        animator.addUpdateListener(animatorUpdateListener);
        animator.setInterpolator(new DecelerateInterpolator());
        animator.start();
      }
    }
  }
);
}","public void setProgress(int progress){
  lastProgress=this.progress;
  this.progress=progress;
  post(new Runnable(){
    @Override public void run(){
      float incr=360 / maxProgress;
      Log.e(""String_Node_Str"",""String_Node_Str"" + lastProgress + ""String_Node_Str""+ BatteryProgressView.this.progress);
      if (lastProgress < BatteryProgressView.this.progress) {
        Log.e(""String_Node_Str"",lastProgress + ""String_Node_Str"" + (incr * (BatteryProgressView.this.progress))+ ""String_Node_Str""+ lastProgress);
        animator=ValueAnimator.ofFloat(incr * lastProgress,incr * (BatteryProgressView.this.progress));
        animator.setDuration(800);
        animator.addUpdateListener(animatorUpdateListener);
        animator.setInterpolator(new DecelerateInterpolator());
        animator.start();
      }
 else {
        Log.e(""String_Node_Str"",lastProgress + ""String_Node_Str"" + (incr * (BatteryProgressView.this.progress))+ ""String_Node_Str""+ lastProgress);
        animator=ValueAnimator.ofFloat((incr * lastProgress),incr * (BatteryProgressView.this.progress));
        animator.setDuration(800);
        animator.addUpdateListener(animatorUpdateListener);
        animator.setInterpolator(new DecelerateInterpolator());
        animator.start();
      }
    }
  }
);
}",0.9929577464788732
175272,"@Override public void run(){
  int incr=360 / maxProgress;
  Log.e(""String_Node_Str"",""String_Node_Str"" + lastProgress + ""String_Node_Str""+ BatteryProgressView.this.progress);
  if (lastProgress < BatteryProgressView.this.progress) {
    Log.e(""String_Node_Str"",lastProgress + ""String_Node_Str"" + (incr * (BatteryProgressView.this.progress))+ ""String_Node_Str""+ lastProgress);
    animator=ValueAnimator.ofInt(incr * lastProgress,incr * (BatteryProgressView.this.progress));
    animator.setDuration(800);
    animator.addUpdateListener(animatorUpdateListener);
    animator.setInterpolator(new DecelerateInterpolator());
    animator.start();
  }
 else {
    Log.e(""String_Node_Str"",lastProgress + ""String_Node_Str"" + (incr * (BatteryProgressView.this.progress))+ ""String_Node_Str""+ lastProgress);
    animator=ValueAnimator.ofInt((incr * lastProgress),incr * (BatteryProgressView.this.progress));
    animator.setDuration(800);
    animator.addUpdateListener(animatorUpdateListener);
    animator.setInterpolator(new DecelerateInterpolator());
    animator.start();
  }
}","@Override public void run(){
  float incr=360 / maxProgress;
  Log.e(""String_Node_Str"",""String_Node_Str"" + lastProgress + ""String_Node_Str""+ BatteryProgressView.this.progress);
  if (lastProgress < BatteryProgressView.this.progress) {
    Log.e(""String_Node_Str"",lastProgress + ""String_Node_Str"" + (incr * (BatteryProgressView.this.progress))+ ""String_Node_Str""+ lastProgress);
    animator=ValueAnimator.ofFloat(incr * lastProgress,incr * (BatteryProgressView.this.progress));
    animator.setDuration(800);
    animator.addUpdateListener(animatorUpdateListener);
    animator.setInterpolator(new DecelerateInterpolator());
    animator.start();
  }
 else {
    Log.e(""String_Node_Str"",lastProgress + ""String_Node_Str"" + (incr * (BatteryProgressView.this.progress))+ ""String_Node_Str""+ lastProgress);
    animator=ValueAnimator.ofFloat((incr * lastProgress),incr * (BatteryProgressView.this.progress));
    animator.setDuration(800);
    animator.addUpdateListener(animatorUpdateListener);
    animator.setInterpolator(new DecelerateInterpolator());
    animator.start();
  }
}",0.9916279069767442
175273,"@Test public void createNamedQueryWhere(){
  UserInfo userInfo=ebeanQueryChannelService.createNamedQuery(UserInfo.class,""String_Node_Str"").where().eq(""String_Node_Str"",""String_Node_Str"").findUnique();
  assertEquals(""String_Node_Str"",userInfo.getFirstName());
  assertEquals(""String_Node_Str"",userInfo.getEmailAddress());
}","@Test public void createNamedQueryWhere(){
  UserInfo userInfo=ebeanQueryChannelService.createNamedQuery(UserInfo.class,""String_Node_Str"").where().eq(""String_Node_Str"",""String_Node_Str"").findOne();
  assertEquals(""String_Node_Str"",userInfo.getFirstName());
  assertEquals(""String_Node_Str"",userInfo.getEmailAddress());
}",0.989113530326594
175274,"/** 
 * Convert spring data Sort to Ebean OrderBy.
 * @param sort
 * @param < T >
 * @return
 */
public static <T>OrderBy<T> convertToEbeanOrder(Sort sort){
  List<String> list=new ArrayList<>();
  while (sort.iterator().hasNext()) {
    Sort.Order so=sort.iterator().next();
    list.add(so.getDirection() == Sort.Direction.ASC ? so.getProperty() + ""String_Node_Str"" : so.getProperty() + ""String_Node_Str"");
  }
  return new OrderBy<T>(StringUtils.collectionToCommaDelimitedString(list));
}","/** 
 * Convert spring data Sort to Ebean OrderBy.
 * @param sort
 * @param < T >
 * @return
 */
public static <T>OrderBy<T> convertToEbeanOrder(Sort sort){
  if (sort == null) {
    return null;
  }
  List<String> list=new ArrayList<>();
  while (sort.iterator().hasNext()) {
    Sort.Order so=sort.iterator().next();
    list.add(so.getDirection() == Sort.Direction.ASC ? so.getProperty() + ""String_Node_Str"" : so.getProperty() + ""String_Node_Str"");
  }
  return new OrderBy<T>(StringUtils.collectionToCommaDelimitedString(list));
}",0.9580487804878048
175275,"/** 
 * This method will be called if some permissions have previously been set not to ask again.
 * @param context     the android context.
 * @param blockedList the list of permissions which have been set not to ask again.
 * @return The overrider of this method should return true if no further action is needed,and should return false if the default action is to be taken, i.e. send user to settings. <br><br> Note: If the option  {@link Permissions.Options#sendDontAskAgainToSettings(boolean)} has beenset to false, the user won't be sent to settings by default.
 */
@SuppressWarnings(""String_Node_Str"") public boolean onBlocked(Context context,ArrayList<String> blockedList){
  if (Permissions.loggingEnabled) {
    StringBuilder builder=new StringBuilder();
    builder.append(""String_Node_Str"");
    for (    String permission : blockedList) {
      builder.append(""String_Node_Str"");
      builder.append(permission);
    }
    Permissions.log(builder.toString());
  }
  return false;
}","/** 
 * This method will be called if some permissions have previously been set not to ask again.
 * @param context     the application context.
 * @param blockedList the list of permissions which have been set not to ask again.
 * @return The overrider of this method should return true if no further action is needed,and should return false if the default action is to be taken, i.e. send user to settings. <br><br> Note: If the option  {@link Permissions.Options#sendDontAskAgainToSettings(boolean)} has beenset to false, the user won't be sent to settings by default.
 */
@SuppressWarnings(""String_Node_Str"") public boolean onBlocked(Context context,ArrayList<String> blockedList){
  if (Permissions.loggingEnabled) {
    StringBuilder builder=new StringBuilder();
    builder.append(""String_Node_Str"");
    for (    String permission : blockedList) {
      builder.append(""String_Node_Str"");
      builder.append(permission);
    }
    Permissions.log(builder.toString());
  }
  return false;
}",0.99197592778335
175276,"/** 
 * This method will be called if some of the requested permissions have been denied.
 * @param context           The android context.
 * @param deniedPermissions The list of permissions which have been denied.
 */
public void onDenied(Context context,ArrayList<String> deniedPermissions){
  if (Permissions.loggingEnabled) {
    StringBuilder builder=new StringBuilder();
    builder.append(""String_Node_Str"");
    for (    String permission : deniedPermissions) {
      builder.append(""String_Node_Str"");
      builder.append(permission);
    }
    Permissions.log(builder.toString());
  }
  Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}","/** 
 * This method will be called if some of the requested permissions have been denied.
 * @param context           The application context.
 * @param deniedPermissions The list of permissions which have been denied.
 */
public void onDenied(Context context,ArrayList<String> deniedPermissions){
  if (Permissions.loggingEnabled) {
    StringBuilder builder=new StringBuilder();
    builder.append(""String_Node_Str"");
    for (    String permission : deniedPermissions) {
      builder.append(""String_Node_Str"");
      builder.append(permission);
    }
    Permissions.log(builder.toString());
  }
  Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}",0.9880597014925372
175277,"/** 
 * This method will be called if some permissions have just been set not to ask again.
 * @param context           The android context.
 * @param justBlockedList   The list of permissions which have just been set not to ask again.
 * @param deniedPermissions The list of currently unavailable permissions.
 */
public void onJustBlocked(Context context,ArrayList<String> justBlockedList,ArrayList<String> deniedPermissions){
  if (Permissions.loggingEnabled) {
    StringBuilder builder=new StringBuilder();
    builder.append(""String_Node_Str"");
    for (    String permission : justBlockedList) {
      builder.append(""String_Node_Str"");
      builder.append(permission);
    }
    Permissions.log(builder.toString());
  }
  onDenied(context,deniedPermissions);
}","/** 
 * This method will be called if some permissions have just been set not to ask again.
 * @param context           The application context.
 * @param justBlockedList   The list of permissions which have just been set not to ask again.
 * @param deniedPermissions The list of currently unavailable permissions.
 */
public void onJustBlocked(Context context,ArrayList<String> justBlockedList,ArrayList<String> deniedPermissions){
  if (Permissions.loggingEnabled) {
    StringBuilder builder=new StringBuilder();
    builder.append(""String_Node_Str"");
    for (    String permission : justBlockedList) {
      builder.append(""String_Node_Str"");
      builder.append(permission);
    }
    Permissions.log(builder.toString());
  }
  onDenied(context,deniedPermissions);
}",0.9896238651102464
175278,"@TargetApi(Build.VERSION_CODES.M) @Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Intent intent=getIntent();
  if (intent == null || !intent.hasExtra(EXTRA_PERMISSIONS)) {
    finish();
    return;
  }
  getWindow().setStatusBarColor(0);
  allPermissions=(ArrayList<String>)intent.getSerializableExtra(EXTRA_PERMISSIONS);
  options=(Permissions.Options)intent.getSerializableExtra(EXTRA_OPTIONS);
  if (options == null) {
    options=new Permissions.Options();
  }
  deniedPermissions=new ArrayList<>();
  noRationaleList=new ArrayList<>();
  boolean noRationale=true;
  for (  String permission : allPermissions) {
    if (checkSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {
      deniedPermissions.add(permission);
      if (shouldShowRequestPermissionRationale(permission)) {
        noRationale=false;
      }
 else {
        noRationaleList.add(permission);
      }
    }
  }
  String rationale=intent.getStringExtra(EXTRA_RATIONALE);
  if (noRationale || TextUtils.isEmpty(rationale)) {
    Permissions.log(""String_Node_Str"");
    requestPermissions(deniedPermissions.toArray(new String[0]),RC_PERMISSION);
  }
 else {
    Permissions.log(""String_Node_Str"");
    showRationale(rationale);
  }
}","@TargetApi(Build.VERSION_CODES.M) @Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Intent intent=getIntent();
  if (intent == null || !intent.hasExtra(EXTRA_PERMISSIONS)) {
    finish();
    return;
  }
  getWindow().setStatusBarColor(0);
  allPermissions=(ArrayList<String>)intent.getSerializableExtra(EXTRA_PERMISSIONS);
  options=(Permissions.Options)intent.getSerializableExtra(EXTRA_OPTIONS);
  if (options == null) {
    options=new Permissions.Options();
  }
  deniedPermissions=new ArrayList<>();
  noRationaleList=new ArrayList<>();
  boolean noRationale=true;
  for (  String permission : allPermissions) {
    if (checkSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {
      deniedPermissions.add(permission);
      if (shouldShowRequestPermissionRationale(permission)) {
        noRationale=false;
      }
 else {
        noRationaleList.add(permission);
      }
    }
  }
  if (deniedPermissions.isEmpty()) {
    grant();
    return;
  }
  String rationale=intent.getStringExtra(EXTRA_RATIONALE);
  if (noRationale || TextUtils.isEmpty(rationale)) {
    Permissions.log(""String_Node_Str"");
    requestPermissions(toArray(deniedPermissions),RC_PERMISSION);
  }
 else {
    Permissions.log(""String_Node_Str"");
    showRationale(rationale);
  }
}",0.956153846153846
175279,"private void deny(){
  if (permissionHandler != null) {
    permissionHandler.onDenied(this,deniedPermissions);
  }
  finish();
}","private void deny(){
  if (permissionHandler != null) {
    permissionHandler.onDenied(getApplicationContext(),deniedPermissions);
  }
  finish();
}",0.9169675090252708
175280,"@SuppressWarnings(""String_Node_Str"") @Override public void onRequestPermissionsResult(int requestCode,String[] permissions,int[] grantResults){
  if (grantResults.length == 0) {
    deny();
  }
 else {
    deniedPermissions.clear();
    for (int i=0; i < grantResults.length; i++) {
      if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {
        deniedPermissions.add(permissions[i]);
      }
    }
    if (deniedPermissions.size() == 0) {
      Permissions.log(""String_Node_Str"");
      grant();
    }
 else {
      ArrayList<String> blockedList=new ArrayList<>();
      ArrayList<String> justBlockedList=new ArrayList<>();
      ArrayList<String> justDeniedList=new ArrayList<>();
      for (      String permission : deniedPermissions) {
        if (shouldShowRequestPermissionRationale(permission)) {
          justDeniedList.add(permission);
        }
 else {
          blockedList.add(permission);
          if (!noRationaleList.contains(permission)) {
            justBlockedList.add(permission);
          }
        }
      }
      if (justBlockedList.size() > 0) {
        if (permissionHandler != null) {
          permissionHandler.onJustBlocked(this,justBlockedList,deniedPermissions);
        }
        finish();
      }
 else       if (justDeniedList.size() > 0) {
        deny();
      }
 else {
        if (permissionHandler != null && !permissionHandler.onBlocked(this,blockedList)) {
          sendToSettings();
        }
 else         finish();
      }
    }
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void onRequestPermissionsResult(int requestCode,String[] permissions,int[] grantResults){
  if (grantResults.length == 0) {
    deny();
  }
 else {
    deniedPermissions.clear();
    for (int i=0; i < grantResults.length; i++) {
      if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {
        deniedPermissions.add(permissions[i]);
      }
    }
    if (deniedPermissions.size() == 0) {
      Permissions.log(""String_Node_Str"");
      grant();
    }
 else {
      ArrayList<String> blockedList=new ArrayList<>();
      ArrayList<String> justBlockedList=new ArrayList<>();
      ArrayList<String> justDeniedList=new ArrayList<>();
      for (      String permission : deniedPermissions) {
        if (shouldShowRequestPermissionRationale(permission)) {
          justDeniedList.add(permission);
        }
 else {
          blockedList.add(permission);
          if (!noRationaleList.contains(permission)) {
            justBlockedList.add(permission);
          }
        }
      }
      if (justBlockedList.size() > 0) {
        if (permissionHandler != null) {
          permissionHandler.onJustBlocked(getApplicationContext(),justBlockedList,deniedPermissions);
        }
        finish();
      }
 else       if (justDeniedList.size() > 0) {
        deny();
      }
 else {
        if (permissionHandler != null && !permissionHandler.onBlocked(getApplicationContext(),blockedList)) {
          sendToSettings();
        }
 else         finish();
      }
    }
  }
}",0.9821546596166556
175281,"private void showRationale(String rationale){
  DialogInterface.OnClickListener listener=new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      if (which == DialogInterface.BUTTON_POSITIVE) {
        requestPermissions(deniedPermissions.toArray(new String[0]),RC_PERMISSION);
      }
 else {
        deny();
      }
    }
  }
;
  new AlertDialog.Builder(this).setTitle(options.rationaleDialogTitle).setMessage(rationale).setPositiveButton(android.R.string.ok,listener).setNegativeButton(android.R.string.cancel,listener).setOnCancelListener(new DialogInterface.OnCancelListener(){
    @Override public void onCancel(    DialogInterface dialog){
      deny();
    }
  }
).create().show();
}","private void showRationale(String rationale){
  DialogInterface.OnClickListener listener=new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      if (which == DialogInterface.BUTTON_POSITIVE) {
        requestPermissions(toArray(deniedPermissions),RC_PERMISSION);
      }
 else {
        deny();
      }
    }
  }
;
  new AlertDialog.Builder(this).setTitle(options.rationaleDialogTitle).setMessage(rationale).setPositiveButton(android.R.string.ok,listener).setNegativeButton(android.R.string.cancel,listener).setOnCancelListener(new DialogInterface.OnCancelListener(){
    @Override public void onCancel(    DialogInterface dialog){
      deny();
    }
  }
).create().show();
}",0.9799732977303072
175282,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == RC_SETTINGS && permissionHandler != null) {
    Permissions.check(this,allPermissions.toArray(new String[0]),null,options,permissionHandler);
    cleanHandlerOnDestroy=false;
  }
  finish();
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == RC_SETTINGS && permissionHandler != null) {
    Permissions.check(this,toArray(allPermissions),null,options,permissionHandler);
    cleanHandlerOnDestroy=false;
  }
  finish();
}",0.689419795221843
175283,"public void start(){
  try {
    FileChannel fileChannel=new RandomAccessFile(Constants.RESULT_HOME + File.separator + Constants.RESULT_FILE_NAME,""String_Node_Str"").getChannel();
    nativeClient.start(fileChannel);
    fileChannel.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void start(){
  try {
    FileChannel fileChannel=new RandomAccessFile(Constants.RESULT_HOME + File.separator + Constants.RESULT_FILE_NAME,""String_Node_Str"").getChannel();
    nativeClient.start(fileChannel);
    fileChannel.close();
    System.exit(0);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.967948717948718
175284,"void compute(){
  while (nextIndex < endIndex) {
    localOperations.add(scanOneRecord());
  }
}","void compute(){
  while (nextIndex < endIndex) {
    LogOperation logOperation=scanOneRecord();
    if (logOperation != null) {
      localOperations.add(logOperation);
    }
  }
}",0.6014492753623188
175285,"void waitForSend() throws InterruptedException, ExecutionException {
  LogOperation[] logOperations=localOperations.toArray(new LogOperation[0]);
  prevFuture.get();
  PipelinedComputation.blockingQueue.put(logOperations);
}","void waitForSend() throws InterruptedException, ExecutionException {
  LogOperation[] logOperations=localOperations.toArray(new LogOperation[0]);
  localOperations.clear();
  prevFuture.get();
  if (logOperations.length != 0)   PipelinedComputation.blockingQueue.put(logOperations);
}",0.8818897637795275
175286,"private LogOperation scanOneRecord(){
  skipHeader();
  byte operation=mappedByteBuffer.get(nextIndex + 1);
  LogOperation logOperation;
  skipKey();
  if (operation == U_OPERATION) {
    long prevKey=getNextLongForUpdate();
    if (nextIndex + primaryKeyDigitNum + 2 < mappedByteBuffer.limit() && mappedByteBuffer.get(nextIndex + primaryKeyDigitNum + 1) == '|' && (mappedByteBuffer.get(nextIndex + primaryKeyDigitNum + 2) == 's' || mappedByteBuffer.get(nextIndex + primaryKeyDigitNum + 2) == 'f' || mappedByteBuffer.get(nextIndex + primaryKeyDigitNum + 2) == 'l')) {
      nextIndex+=primaryKeyDigitNum + 1;
      logOperation=new UpdateOperation(prevKey);
      int localIndex=skipFieldName();
      skipField(localIndex);
      getNextBytesIntoTmp();
      ((UpdateOperation)logOperation).addData(localIndex,tmpBuffer);
    }
 else {
      long curKey=getNextLong();
      logOperation=new UpdateKeyOperation(prevKey,curKey);
    }
  }
 else   if (operation == I_OPERATION) {
    skipNull();
    logOperation=new InsertOperation(getNextLong());
    int localIndex=0;
    while (mappedByteBuffer.get(nextIndex + 1) != LINE_SPLITTER) {
      skipFieldForInsert(localIndex);
      skipNull();
      getNextBytesIntoTmp();
      ((InsertOperation)logOperation).addData(localIndex,tmpBuffer);
      localIndex++;
    }
  }
 else {
    logOperation=new DeleteOperation(getNextLong());
    skipNull();
    while (mappedByteBuffer.get(nextIndex + 1) != LINE_SPLITTER) {
      int localIndex=skipFieldName();
      skipField(localIndex);
      skipNull();
    }
  }
  nextIndex+=2;
  return logOperation;
}","private LogOperation scanOneRecord(){
  skipHeader();
  byte operation=mappedByteBuffer.get(nextIndex + 1);
  LogOperation logOperation=null;
  boolean flag=false;
  skipKey();
  if (operation == U_OPERATION) {
    long prevKey=getNextLongForUpdate();
    if (nextIndex + primaryKeyDigitNum + 2 < mappedByteBuffer.limit() && mappedByteBuffer.get(nextIndex + primaryKeyDigitNum + 1) == '|' && (mappedByteBuffer.get(nextIndex + primaryKeyDigitNum + 2) == 's' || mappedByteBuffer.get(nextIndex + primaryKeyDigitNum + 2) == 'f' || mappedByteBuffer.get(nextIndex + primaryKeyDigitNum + 2) == 'l')) {
      nextIndex+=primaryKeyDigitNum + 1;
      if (isKeyInRange(prevKey)) {
        flag=true;
        logOperation=new UpdateOperation(prevKey);
      }
      int localIndex=skipFieldName();
      skipField(localIndex);
      getNextBytesIntoTmp();
      if (flag)       ((UpdateOperation)logOperation).addData(localIndex,tmpBuffer);
    }
 else {
      long curKey=getNextLong();
      logOperation=new UpdateKeyOperation(prevKey,curKey);
    }
  }
 else   if (operation == I_OPERATION) {
    skipNull();
    long pk=getNextLong();
    if (isKeyInRange(pk)) {
      logOperation=new InsertOperation(pk);
      flag=true;
    }
    int localIndex=0;
    while (mappedByteBuffer.get(nextIndex + 1) != LINE_SPLITTER) {
      skipFieldForInsert(localIndex);
      skipNull();
      getNextBytesIntoTmp();
      if (flag)       ((InsertOperation)logOperation).addData(localIndex,tmpBuffer);
      localIndex++;
    }
  }
 else {
    long pk=getNextLong();
    if (isKeyInRange(pk)) {
      logOperation=new DeleteOperation(pk);
    }
    skipNull();
    while (mappedByteBuffer.get(nextIndex + 1) != LINE_SPLITTER) {
      int localIndex=skipFieldName();
      skipField(localIndex);
      skipNull();
    }
  }
  nextIndex+=2;
  return logOperation;
}",0.8925667828106852
175287,"@Override public void act(){
  InsertOperation insertOperation=(InsertOperation)recordMap.get(this);
  if (PipelinedComputation.isKeyInRange(this.relevantKey)) {
    inRangeRecordSet.remove(this);
  }
  insertOperation.changePK(this.changedKey);
  recordMap.put(insertOperation);
  if (PipelinedComputation.isKeyInRange(insertOperation.relevantKey)) {
    inRangeRecordSet.add(insertOperation);
  }
}","@Override public void act(){
  if (PipelinedComputation.isKeyInRange(this.relevantKey)) {
    inRangeRecordSet.remove(this);
  }
  InsertOperation insertOperation=new InsertOperation(this.changedKey);
  recordMap.put(insertOperation);
  if (PipelinedComputation.isKeyInRange(insertOperation.relevantKey)) {
    inRangeRecordSet.add(insertOperation);
  }
}",0.4688741721854305
175288,"public static void main(String[] args){
  logger.info(""String_Node_Str"" + System.currentTimeMillis());
  new Client(args[0]).start();
  logger.info(""String_Node_Str"" + System.currentTimeMillis());
}","public static void main(String[] args){
  initProperties();
  logger=LoggerFactory.getLogger(Client.class);
  logger.info(""String_Node_Str"" + System.currentTimeMillis());
  new Client(args[0]).start();
  logger.info(""String_Node_Str"" + System.currentTimeMillis());
}",0.853448275862069
175289,"public Client(String ip){
  initProperties();
  logger=LoggerFactory.getLogger(Client.class);
  nativeClient=new NioClient(ip,Constants.SERVER_PORT);
}","public Client(String ip){
  nativeClient=new NioClient(ip,Constants.SERVER_PORT);
}",0.7094017094017094
175290,"private void fetchNextMmapChunk() throws IOException {
  currChunkLength=nextIndex != maxIndex ? CHUNK_SIZE : lastChunkLength;
  if (mappedByteBuffer != null) {
    unmap(mappedByteBuffer);
  }
  mappedByteBuffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,nextIndex * CHUNK_SIZE,currChunkLength);
  mappedByteBuffer.load();
}","private void fetchNextMmapChunk() throws IOException {
  currChunkLength=nextIndex != maxIndex ? CHUNK_SIZE : lastChunkLength;
  if (mappedByteBuffer != null) {
    unmap(mappedByteBuffer);
  }
  mappedByteBuffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,nextIndex * CHUNK_SIZE,currChunkLength);
  mappedByteBuffer.load();
  if (RecordField.isInit()) {
    new RecordField(mappedByteBuffer).initFieldIndexMap();
  }
}",0.8758344459279038
175291,"public static void initRecordField() throws IOException {
  MappedByteBuffer mappedByteBuffer;
  FileChannel fileChannel=new RandomAccessFile(""String_Node_Str"",""String_Node_Str"").getChannel();
  mappedByteBuffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,0,1024 * 1024);
  mappedByteBuffer.load();
  if (!RecordField.isInit())   new RecordField(mappedByteBuffer).initFieldIndexMap();
  FileUtil.unmap(mappedByteBuffer);
  for (  Map.Entry<ByteBuffer,Integer> entry : fieldIndexMap.entrySet()) {
    System.out.println(""String_Node_Str"" + new String(entry.getKey().array()) + ""String_Node_Str""+ entry.getValue());
  }
}","static void initRecordField() throws IOException {
  MappedByteBuffer mappedByteBuffer;
  FileChannel fileChannel=new RandomAccessFile(""String_Node_Str"",""String_Node_Str"").getChannel();
  mappedByteBuffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,0,1024 * 1024);
  mappedByteBuffer.load();
  if (!RecordField.isInit())   new RecordField(mappedByteBuffer).initFieldIndexMap();
  FileUtil.unmap(mappedByteBuffer);
  for (  Map.Entry<ByteBuffer,Integer> entry : fieldIndexMap.entrySet()) {
    System.out.println(""String_Node_Str"" + new String(entry.getKey().array()) + ""String_Node_Str""+ entry.getValue());
  }
}",0.994331983805668
175292,"public static void main(String[] args) throws IOException {
  RecordFieldTest.initRecordField();
  StringBuilder stringBuilder=new StringBuilder(""String_Node_Str"").append('\n');
  stringBuilder.append(""String_Node_Str"").append('\n');
  stringBuilder.append(""String_Node_Str"").append('\n');
  byte[] myBytes=stringBuilder.toString().getBytes();
  System.out.println(""String_Node_Str"" + new String(myBytes));
  ByteBuffer byteBuffer=ByteBuffer.wrap(myBytes);
  ByteBuffer retByteBuffer=ByteBuffer.allocate(1024 * 1024);
  ArrayList<RecordKeyValuePair> recordKeyValuePairArrayList=new ArrayList<>();
  RecordScanner recordScanner=new RecordScanner(byteBuffer,0,byteBuffer.limit(),retByteBuffer,recordKeyValuePairArrayList);
  recordScanner.compute();
  retByteBuffer.flip();
  System.out.println(new String(retByteBuffer.array(),0,retByteBuffer.limit()));
}","public static void main(String[] args) throws IOException {
  RecordFieldTest.initRecordField();
  StringBuilder stringBuilder=new StringBuilder(""String_Node_Str"").append('\n');
  stringBuilder.append(""String_Node_Str"").append('\n');
  stringBuilder.append(""String_Node_Str"").append('\n');
  stringBuilder.append(""String_Node_Str"").append('\n');
  stringBuilder.append(""String_Node_Str"").append('\n');
  byte[] myBytes=stringBuilder.toString().getBytes();
  System.out.println(""String_Node_Str"" + new String(myBytes));
  ByteBuffer byteBuffer=ByteBuffer.wrap(myBytes);
  ByteBuffer retByteBuffer=ByteBuffer.allocate(1024 * 1024);
  ArrayList<RecordKeyValuePair> recordKeyValuePairArrayList=new ArrayList<>();
  RecordScanner recordScanner=new RecordScanner(byteBuffer,0,byteBuffer.limit(),retByteBuffer,recordKeyValuePairArrayList);
  recordScanner.compute();
  RecordScanner recordScanner2=new RecordScanner(byteBuffer,0,byteBuffer.limit(),retByteBuffer,recordKeyValuePairArrayList);
  recordScanner2.compute();
  retByteBuffer.flip();
  System.out.println(new String(retByteBuffer.array(),0,retByteBuffer.limit()));
  for (  RecordKeyValuePair recordKeyValuePair : recordKeyValuePairArrayList) {
    ObjectMapper mapper=new ObjectMapper();
    String jsonInString=mapper.writerWithDefaultPrettyPrinter().writeValueAsString(recordKeyValuePair);
    System.out.println(jsonInString);
  }
}",0.6910387873383861
175293,"RecordKeyValuePair(KeyOperation keyOperation,ValueIndexArrWrapper valueIndexArrWrapper){
  this.keyOperation=keyOperation;
  this.valueIndexArrWrapper=valueIndexArrWrapper;
}","public RecordKeyValuePair(KeyOperation keyOperation,ValueIndexArrWrapper valueIndexArrWrapper){
  this.keyOperation=keyOperation;
  this.valueIndexArrWrapper=valueIndexArrWrapper;
}",0.9802816901408452
175294,"void compute(){
  while (nextIndex < endIndex) {
    recordWrapperArrayList.add(scanOneRecord());
  }
}","public void compute(){
  while (nextIndex < endIndex) {
    recordWrapperArrayList.add(scanOneRecord());
  }
}",0.9671361502347418
175295,"private void putIntoByteBufferUntilFieldSplitter(){
  byte myByte;
  while ((myByte=mappedByteBuffer.get(nextIndex)) != FILED_SPLITTER) {
    retByteBuffer.put(myByte);
    nextIndex++;
  }
  retByteBuffer.put(mappedByteBuffer.get(nextIndex));
  nextIndex++;
}","private void putIntoByteBufferUntilFieldSplitter(){
  if (mappedByteBuffer.get(nextIndex) == FILED_SPLITTER) {
    nextIndex++;
  }
  byte myByte;
  while ((myByte=mappedByteBuffer.get(nextIndex)) != FILED_SPLITTER) {
    retByteBuffer.put(myByte);
    nextIndex++;
  }
  retByteBuffer.put(LINE_SPLITTER);
}",0.6208112874779541
175296,"RecordScanner(ByteBuffer mappedByteBuffer,int startIndex,int endIndex,ByteBuffer retByteBuffer,ArrayList<RecordKeyValuePair> retRecordWrapperArrayList){
  this.mappedByteBuffer=mappedByteBuffer.asReadOnlyBuffer();
  this.nextIndex=startIndex;
  this.endIndex=endIndex;
  this.retByteBuffer=retByteBuffer;
  this.recordWrapperArrayList=retRecordWrapperArrayList;
}","public RecordScanner(ByteBuffer mappedByteBuffer,int startIndex,int endIndex,ByteBuffer retByteBuffer,ArrayList<RecordKeyValuePair> retRecordWrapperArrayList){
  this.mappedByteBuffer=mappedByteBuffer.asReadOnlyBuffer();
  this.nextIndex=startIndex;
  this.endIndex=endIndex;
  this.retByteBuffer=retByteBuffer;
  this.recordWrapperArrayList=retRecordWrapperArrayList;
}",0.990450204638472
175297,"private RecordKeyValuePair scanOneRecord(){
  for (int i=0; i < 4; i++) {
    skipField();
  }
  byte operation=mappedByteBuffer.get(nextIndex + 1);
  nextIndex+=2;
  KeyOperation keyOperation=new KeyOperation(operation);
  skipField();
  if (operation == I_OPERATION) {
    skipField();
    keyOperation.curKey(getNextLong());
  }
 else   if (operation == D_OPERATION) {
    keyOperation.preKey(getNextLong());
    skipField();
  }
 else {
    keyOperation.preKey(getNextLong());
    keyOperation.curKey(getNextLong());
  }
  ValueIndexArrWrapper valueIndexArrWrapper=null;
  while (mappedByteBuffer.get(nextIndex + 1) != LINE_SPLITTER) {
    if (valueIndexArrWrapper == null) {
      valueIndexArrWrapper=new ValueIndexArrWrapper();
    }
    skipFieldNameAndUpdateStates();
    long curOffset=retByteBuffer.limit();
    skipField();
    putIntoByteBufferUntilFieldSplitter();
    long nextOffset=retByteBuffer.limit();
    valueIndexArrWrapper.addIndex(mappedByteBuffer,curOffset,(short)(nextOffset - curOffset));
  }
  return new RecordKeyValuePair(keyOperation,valueIndexArrWrapper);
}","private RecordKeyValuePair scanOneRecord(){
  for (int i=0; i < 4; i++) {
    skipField();
  }
  byte operation=mappedByteBuffer.get(nextIndex + 1);
  nextIndex+=2;
  KeyOperation keyOperation=new KeyOperation(operation);
  skipField();
  if (operation == I_OPERATION) {
    skipField();
    keyOperation.curKey(getNextLong());
  }
 else   if (operation == D_OPERATION) {
    keyOperation.preKey(getNextLong());
    skipField();
  }
 else {
    keyOperation.preKey(getNextLong());
    keyOperation.curKey(getNextLong());
  }
  ValueIndexArrWrapper valueIndexArrWrapper=null;
  while (mappedByteBuffer.get(nextIndex + 1) != LINE_SPLITTER) {
    if (valueIndexArrWrapper == null) {
      valueIndexArrWrapper=new ValueIndexArrWrapper();
    }
    skipFieldName();
    long curOffset=retByteBuffer.position();
    skipField();
    putIntoByteBufferUntilFieldSplitter();
    long nextOffset=retByteBuffer.position();
    valueIndexArrWrapper.addIndex(fieldNameBuffer,curOffset,(short)(nextOffset - curOffset));
  }
  nextIndex+=2;
  return new RecordKeyValuePair(keyOperation,valueIndexArrWrapper);
}",0.8124428179322964
175298,"ValueIndexArrWrapper(){
  valueIndexArr=new IndexPair[RecordField.FILED_NUM];
  for (  IndexPair indexPair : valueIndexArr) {
    System.out.println(indexPair);
  }
}","ValueIndexArrWrapper(){
  valueIndexArr=new IndexPair[RecordField.FILED_NUM];
}",0.6448979591836734
175299,"void addIndex(ByteBuffer keyBytes,long offset,short length){
  valueIndexArr[RecordField.fieldIndexMap.get(keyBytes)]=new IndexPair(offset,length);
}","void addIndex(ByteBuffer keyBytes,long offset,short length){
  System.out.println(""String_Node_Str"" + RecordField.fieldIndexMap.get(keyBytes) + ""String_Node_Str""+ new String(keyBytes.array(),0,keyBytes.limit()));
  valueIndexArr[RecordField.fieldIndexMap.get(keyBytes)]=new IndexPair(offset,length);
}",0.6622222222222223
175300,"public static void main(String[] args) throws IOException {
  MappedByteBuffer mappedByteBuffer;
  FileChannel fileChannel=new RandomAccessFile(""String_Node_Str"",""String_Node_Str"").getChannel();
  mappedByteBuffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,0,1024 * 1024);
  mappedByteBuffer.load();
  if (!RecordField.isInit())   new RecordField(mappedByteBuffer).initFieldIndexMap();
  FileUtil.unmap(mappedByteBuffer);
  for (  Map.Entry<ByteBuffer,Integer> entry : fieldIndexMap.entrySet()) {
    System.out.println(new String(entry.getKey().array()) + ""String_Node_Str"" + entry.getValue());
  }
  System.out.println(""String_Node_Str"" + RecordField.FILED_NUM);
}","public static void main(String[] args) throws IOException {
  initRecordField();
  System.out.println(""String_Node_Str"" + RecordField.FILED_NUM);
}",0.3602941176470588
175301,"public byte[] readLineBytes() throws IOException {
  if (nextChunkIndex >= maxChunkIndex && inChunkIndex >= maxChunkLength) {
    FileUtil.unmap(mappedByteBuffer);
    return null;
  }
  for (int i=0; i < 4; i++) {
    skipOneStringBytes();
  }
  return getLineBytes();
}","public byte[] readLineBytes() throws IOException {
  if (nextChunkIndex >= maxChunkIndex && inChunkIndex >= maxChunkLength - 1) {
    FileUtil.unmap(mappedByteBuffer);
    return null;
  }
  for (int i=0; i < 4; i++) {
    skipOneStringBytes();
  }
  if (nextChunkIndex >= maxChunkIndex && maxChunkLength - inChunkIndex < 1000) {
    System.out.println(new String(getLineBytes()));
  }
  return getLineBytes();
}",0.7291361639824304
175302,"private void fetchNextChunk() throws IOException {
  maxChunkLength=nextChunkIndex != maxChunkIndex ? CHUNK_SIZE : lastChunkLength;
  if (mappedByteBuffer != null) {
    FileUtil.unmap(mappedByteBuffer);
  }
  mappedByteBuffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,nextChunkIndex * CHUNK_SIZE,maxChunkLength);
  mappedByteBuffer.load();
  inChunkIndex=0;
  nextChunkIndex++;
}","private void fetchNextChunk() throws IOException {
  if (nextChunkIndex > maxChunkIndex) {
    System.out.println(""String_Node_Str"" + inChunkIndex);
    System.out.println(""String_Node_Str"" + maxChunkLength);
    System.out.println(""String_Node_Str"" + nextChunkIndex);
  }
  maxChunkLength=nextChunkIndex != maxChunkIndex ? CHUNK_SIZE : lastChunkLength;
  System.out.println(""String_Node_Str"" + maxChunkLength + ""String_Node_Str""+ nextChunkIndex+ ""String_Node_Str""+ maxChunkIndex);
  if (mappedByteBuffer != null) {
    FileUtil.unmap(mappedByteBuffer);
  }
  mappedByteBuffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,nextChunkIndex * CHUNK_SIZE,maxChunkLength);
  mappedByteBuffer.load();
  inChunkIndex=0;
  nextChunkIndex++;
}",0.6869409660107334
175303,"public static void main(String[] args) throws IOException, InterruptedException {
  Thread.sleep(5000);
  long programStart=System.currentTimeMillis();
  initRange(100000,2000000);
  initFindResultListener(new FindResultListener(){
    @Override public void sendToClient(    String result){
    }
  }
);
  for (  String name : myFiles)   OneRoundComputation(name);
  JoinComputationThread();
  BufferedWriter bufferedWriter=new BufferedWriter(new FileWriter(""String_Node_Str""));
  for (  Map.Entry<Long,String> entry : ServerPipelinedComputation.inRangeRecord.entrySet()) {
    bufferedWriter.write(entry.getValue());
    bufferedWriter.newLine();
  }
  bufferedWriter.close();
  long programEnd=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (programEnd - programStart));
}","public static void main(String[] args) throws IOException, InterruptedException {
  long programStart=System.currentTimeMillis();
  initRange(100000,2000000);
  initFindResultListener(new FindResultListener(){
    @Override public void sendToClient(    String result){
    }
  }
);
  for (  String name : myFiles)   OneRoundComputation(name);
  JoinComputationThread();
  BufferedWriter bufferedWriter=new BufferedWriter(new FileWriter(""String_Node_Str""));
  for (  Map.Entry<Long,String> entry : ServerPipelinedComputation.inRangeRecord.entrySet()) {
    bufferedWriter.write(entry.getValue());
    bufferedWriter.newLine();
  }
  bufferedWriter.close();
  long programEnd=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (programEnd - programStart));
}",0.9859872611464968
175304,"public static void main(String[] args) throws IOException {
  LineDirectReader lineDirectReader=new LineDirectReader(""String_Node_Str"");
  byte[] nextBytes;
  int i=0;
  while ((nextBytes=lineDirectReader.readLineBytes()) != null) {
    if (i < 10)     System.out.println(new String(nextBytes));
    i++;
  }
  System.out.println(""String_Node_Str"" + i);
}","public static void main(String[] args) throws IOException, InterruptedException {
  for (int i=1; i < 11; i++)   directFileReaderTest(""String_Node_Str"" + i + ""String_Node_Str"");
}",0.3895131086142322
175305,"public void initFieldIndexMap(){
  for (int i=0; i < 8; i++) {
    skipField();
  }
  while (mappedByteBuffer.get(nextFieldIndex + 1) != LINE_SPLITTER) {
    ByteBuffer nextField=getNextField();
    fieldIndexMap.put(nextField,nextFieldIndex);
    nextFieldIndex++;
    skipField();
    skipField();
  }
}","public void initFieldIndexMap(){
  for (int i=0; i < 8; i++) {
    skipField();
  }
  while (mappedByteBuffer.get(nextIndex + 1) != LINE_SPLITTER) {
    ByteBuffer nextField=getNextField();
    fieldIndexMap.put(nextField,nextFieldIndex);
    nextFieldIndex++;
    skipField();
    skipField();
  }
}",0.9917355371900828
175306,"public void write(byte[] data,int offset,int length) throws IOException {
  int expectEnd=currentInnerChunkIndex + length;
  if (expectEnd < CHUNK_SIZE) {
    mappedByteBuffer.put(data,offset,length);
    currentInnerChunkIndex=expectEnd;
    realSize+=length;
  }
 else {
    int writeLength=CHUNK_SIZE - currentInnerChunkIndex;
    mappedByteBuffer.put(data,offset,writeLength);
    realSize+=writeLength;
    getNextChunk();
    write(data,offset + writeLength,length - writeLength);
    currentInnerChunkIndex+=(length - writeLength);
    realSize+=(length - writeLength);
  }
  if (currentInnerChunkIndex == CHUNK_SIZE)   getNextChunk();
}","public void write(byte[] data,int offset,int length) throws IOException {
  if (length <= 0)   return;
  int expectEnd=currentInnerChunkIndex + length;
  if (expectEnd <= CHUNK_SIZE) {
    mappedByteBuffer.put(data,offset,length);
    currentInnerChunkIndex=expectEnd;
    realSize+=length;
  }
 else {
    int writeLength=CHUNK_SIZE - currentInnerChunkIndex;
    mappedByteBuffer.put(data,offset,writeLength);
    realSize+=writeLength;
    getNextChunk();
    write(data,offset + writeLength,length - writeLength);
  }
  if (currentInnerChunkIndex == CHUNK_SIZE)   getNextChunk();
}",0.9022801302931596
175307,"private void findFirstValidChar(){
  while (inChunkIndex >= 0 && internalBuff.get(inChunkIndex) == LINE_SPLITTER) {
    inChunkIndex--;
  }
}","private void findFirstValidChar(){
  while (inChunkIndex >= 0 && mappedByteBuffer.get(inChunkIndex) == LINE_SPLITTER) {
    inChunkIndex--;
  }
}",0.944055944055944
175308,"private void constructString() throws IOException {
  byte ch;
  while (inChunkIndex >= 0 && (ch=internalBuff.get(inChunkIndex)) != LINE_SPLITTER) {
    byteBuffer.put(ch);
    inChunkIndex--;
  }
  if (inChunkIndex == -1 && nextIndex != -1) {
    initMappedByteBuffer();
    constructString();
  }
}","private void constructString() throws IOException {
  byte ch;
  while (inChunkIndex >= 0 && (ch=mappedByteBuffer.get(inChunkIndex)) != LINE_SPLITTER) {
    byteBuffer.put(ch);
    inChunkIndex--;
  }
  if (inChunkIndex == -1 && nextIndex != -1) {
    initMappedByteBuffer();
    constructString();
  }
}",0.956953642384106
175309,"private void initMappedByteBuffer() throws IOException {
  if (nextIndex != maxIndex) {
    unmap(mappedByteBuffer);
    mappedByteBuffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,nextIndex * CHUNK_SIZE,CHUNK_SIZE);
    inChunkIndex=CHUNK_SIZE - 1;
  }
 else {
    mappedByteBuffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,nextIndex * CHUNK_SIZE,lastChunkLength);
    inChunkIndex=lastChunkLength - 1;
  }
  mappedByteBuffer.load();
  internalBuff.clear();
  mappedByteBuffer.get(internalBuff.array(),0,mappedByteBuffer.limit());
  internalBuff.flip();
  nextIndex--;
}","private void initMappedByteBuffer() throws IOException {
  if (nextIndex != maxIndex) {
    unmap(mappedByteBuffer);
    mappedByteBuffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,nextIndex * CHUNK_SIZE,CHUNK_SIZE);
    inChunkIndex=CHUNK_SIZE - 1;
  }
 else {
    mappedByteBuffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,nextIndex * CHUNK_SIZE,lastChunkLength);
    inChunkIndex=lastChunkLength - 1;
  }
  mappedByteBuffer.load();
  nextIndex--;
}",0.8841698841698842
175310,"public static void JoinComputationThread(){
  pageCachePool.shutdown();
  try {
    pageCachePool.awaitTermination(Long.MAX_VALUE,TimeUnit.NANOSECONDS);
  }
 catch (  InterruptedException e) {
    Server.logger.info(""String_Node_Str"");
    e.printStackTrace();
  }
  transformPool.shutdown();
  try {
    transformPool.awaitTermination(Long.MAX_VALUE,TimeUnit.NANOSECONDS);
  }
 catch (  InterruptedException e) {
    Server.logger.info(""String_Node_Str"");
    e.printStackTrace();
  }
  transCompMediatorPool.shutdown();
  try {
    transCompMediatorPool.awaitTermination(Long.MAX_VALUE,TimeUnit.NANOSECONDS);
  }
 catch (  InterruptedException e) {
    Server.logger.info(""String_Node_Str"");
    e.printStackTrace();
  }
  computationPool.shutdown();
  try {
    computationPool.awaitTermination(Long.MAX_VALUE,TimeUnit.NANOSECONDS);
  }
 catch (  InterruptedException e) {
    Server.logger.info(""String_Node_Str"");
    e.printStackTrace();
  }
  for (int i=0; i < EVAL_UPDATE_WORKER_NUM; i++) {
    evalUpdateApplyPools[i].shutdown();
    try {
      evalUpdateApplyPools[i].awaitTermination(Long.MAX_VALUE,TimeUnit.NANOSECONDS);
    }
 catch (    InterruptedException e) {
      Server.logger.info(""String_Node_Str"" + i);
      e.printStackTrace();
    }
  }
}","public static void JoinComputationThread(){
  pageCachePool.shutdown();
  try {
    pageCachePool.awaitTermination(Long.MAX_VALUE,TimeUnit.NANOSECONDS);
  }
 catch (  InterruptedException e) {
    Server.logger.info(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
  transCompMediatorPool.shutdown();
  try {
    transCompMediatorPool.awaitTermination(Long.MAX_VALUE,TimeUnit.NANOSECONDS);
  }
 catch (  InterruptedException e) {
    Server.logger.info(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
  transformPool.shutdown();
  try {
    transformPool.awaitTermination(Long.MAX_VALUE,TimeUnit.NANOSECONDS);
  }
 catch (  InterruptedException e) {
    Server.logger.info(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
  computationPool.shutdown();
  try {
    computationPool.awaitTermination(Long.MAX_VALUE,TimeUnit.NANOSECONDS);
  }
 catch (  InterruptedException e) {
    Server.logger.info(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
  for (int i=0; i < EVAL_UPDATE_WORKER_NUM; i++) {
    evalUpdateApplyPools[i].shutdown();
    try {
      evalUpdateApplyPools[i].awaitTermination(Long.MAX_VALUE,TimeUnit.NANOSECONDS);
    }
 catch (    InterruptedException e) {
      Server.logger.info(""String_Node_Str"" + i);
      System.out.println(""String_Node_Str"" + i);
      e.printStackTrace();
    }
  }
}",0.8964013086150491
175311,"public void start() throws IOException {
  for (int i=10; i > 0; i--) {
    OneRoundComputation(Constants.DATA_HOME + File.separator + dataFiles.get(i - 1));
  }
  nativeServer.start();
  JoinComputationThread();
  nativeServer.finish();
  int i=0;
  for (  Map.Entry<Long,String> entry : ServerPipelinedComputation.inRangeRecord.entrySet()) {
    if (i < 10)     logger.info(entry.getValue());
    i++;
  }
  logger.info(""String_Node_Str"" + ServerPipelinedComputation.inRangeRecord.size());
  logger.info(""String_Node_Str"");
}","public void start() throws IOException {
  for (int i=10; i > 0; i--) {
    OneRoundComputation(Constants.DATA_HOME + File.separator + dataFiles.get(i - 1));
  }
  JoinComputationThread();
  nativeServer.finish();
  int i=0;
  for (  Map.Entry<Long,String> entry : ServerPipelinedComputation.inRangeRecord.entrySet()) {
    if (i < 10)     logger.info(entry.getValue());
    i++;
  }
  logger.info(""String_Node_Str"" + ServerPipelinedComputation.inRangeRecord.size());
  logger.info(""String_Node_Str"");
}",0.9766990291262136
175312,"public static void main(String[] args){
  Server.initProperties();
  logger=LoggerFactory.getLogger(Server.class);
  logger.info(""String_Node_Str"" + System.currentTimeMillis());
  nativeServer=new NativeServer(args,Constants.SERVER_PORT);
  ArrayList<String> reverseOrderFiles=new ArrayList<>();
  for (int i=10; i > 0; i--) {
    reverseOrderFiles.add(Constants.DATA_HOME + File.separator + dataFiles.get(i - 1));
  }
  try {
    ServerPipelinedComputation.readFilesIntoPageCache(reverseOrderFiles);
  }
 catch (  IOException e) {
    logger.info(""String_Node_Str"");
    logger.info(e.getMessage());
    e.printStackTrace();
  }
  ServerPipelinedComputation.initSchemaTable(args[0],args[1]);
  ServerPipelinedComputation.initRange(Long.parseLong(args[2]),Long.parseLong(args[3]));
  ServerPipelinedComputation.initFindResultListener(new ServerPipelinedComputation.FindResultListener(){
    @Override public void sendToClient(    String result){
      nativeServer.send(result);
    }
  }
);
  try {
    new Server(args).start();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public static void main(String[] args){
  Server.initProperties();
  logger=LoggerFactory.getLogger(Server.class);
  logger.info(""String_Node_Str"" + System.currentTimeMillis());
  nativeServer=new NativeServer(args,Constants.SERVER_PORT);
  nativeServer.start();
  ArrayList<String> reverseOrderFiles=new ArrayList<>();
  for (int i=10; i > 0; i--) {
    reverseOrderFiles.add(Constants.DATA_HOME + File.separator + dataFiles.get(i - 1));
  }
  try {
    ServerPipelinedComputation.readFilesIntoPageCache(reverseOrderFiles);
  }
 catch (  IOException e) {
    logger.info(""String_Node_Str"");
    logger.info(e.getMessage());
    e.printStackTrace();
  }
  ServerPipelinedComputation.initSchemaTable(args[0],args[1]);
  ServerPipelinedComputation.initRange(Long.parseLong(args[2]),Long.parseLong(args[3]));
  ServerPipelinedComputation.initFindResultListener(new ServerPipelinedComputation.FindResultListener(){
    @Override public void sendToClient(    String result){
      nativeServer.send(result);
    }
  }
);
  try {
    new Server(args).start();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9891205802357208
175313,"public void start(){
  try {
    outputChannel.write(NetworkStringMessage.buildMessage(NetworkConstant.REQUIRE_ARGS,""String_Node_Str""));
    outputChannel.flush();
    String message=inputChannel.readLine();
    if (message.charAt(0) == NetworkConstant.REQUIRE_ARGS) {
      logger.info(""String_Node_Str"");
      logger.info(Arrays.toString(new ArgumentsPayloadBuilder(message.substring(1)).args));
      receivePooledThread.execute(new Runnable(){
        @Override public void run(){
          while (true) {
            try {
              String message=inputChannel.readLine();
              if (message.length() <= 3 && message.charAt(0) == NetworkConstant.FINISHED_ALL) {
                logger.info(""String_Node_Str"");
                finishLock.lock();
                isStoped=true;
                finishCondition.signal();
                finishLock.unlock();
                break;
              }
 else {
                try {
                  long pk=ClientComputation.extractPK(message);
                  resultMap.put(pk,message);
                }
 catch (                NumberFormatException e) {
                  logger.info(""String_Node_Str"");
                }
              }
            }
 catch (            IOException e) {
              e.printStackTrace();
            }
          }
        }
      }
);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void start(){
  establishConnection();
  logger.info(""String_Node_Str"");
  try {
    outputChannel.write(NetworkStringMessage.buildMessage(NetworkConstant.REQUIRE_ARGS,""String_Node_Str""));
    outputChannel.flush();
    String message=inputChannel.readLine();
    if (message.charAt(0) == NetworkConstant.REQUIRE_ARGS) {
      logger.info(""String_Node_Str"");
      logger.info(Arrays.toString(new ArgumentsPayloadBuilder(message.substring(1)).args));
      receivePooledThread.execute(new Runnable(){
        @Override public void run(){
          while (true) {
            try {
              String message=inputChannel.readLine();
              if (message.length() <= 3 && message.charAt(0) == NetworkConstant.FINISHED_ALL) {
                logger.info(""String_Node_Str"");
                finishLock.lock();
                isStoped=true;
                finishCondition.signal();
                finishLock.unlock();
                break;
              }
 else {
                try {
                  long pk=ClientComputation.extractPK(message);
                  resultMap.put(pk,message);
                }
 catch (                NumberFormatException e) {
                  logger.info(""String_Node_Str"");
                }
              }
            }
 catch (            IOException e) {
              e.printStackTrace();
            }
          }
        }
      }
);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9794066317626527
175314,"public NativeClient(String hostName,int port){
  logger=LoggerFactory.getLogger(NativeClient.class);
  this.hostName=hostName;
  this.port=port;
  establishConnection();
  logger.info(""String_Node_Str"");
}","public NativeClient(String hostName,int port){
  logger=LoggerFactory.getLogger(NativeClient.class);
  this.hostName=hostName;
  this.port=port;
}",0.8319088319088319
175315,"public void finish(){
  while (!isStoped) {
    finishLock.lock();
    if (!isStoped) {
      try {
        finishCondition.await();
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    finishLock.unlock();
  }
  receivePooledThread.shutdown();
  try {
    receivePooledThread.awaitTermination(3000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","public void finish(){
  while (!isStoped) {
    finishLock.lock();
    if (!isStoped) {
      try {
        finishCondition.await();
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    finishLock.unlock();
  }
  receivePooledThread.shutdown();
  try {
    receivePooledThread.awaitTermination(3000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  try {
    outputChannel.close();
    inputChannel.close();
    clientSocket.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.8534906588003933
175316,"private void establishConnection(){
  clientSocket=new Socket();
  while (true) {
    try {
      clientSocket.connect(new InetSocketAddress(hostName,port),1000);
      clientSocket.setKeepAlive(true);
      clientSocket.setReceiveBufferSize(NetworkConstant.SEND_BUFF_SIZE);
      clientSocket.setTcpNoDelay(true);
      inputChannel=new BufferedReader(new InputStreamReader(clientSocket.getInputStream()),NetworkConstant.SEND_BUFF_SIZE);
      outputChannel=new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream()));
      break;
    }
 catch (    IOException e) {
      logger.info(""String_Node_Str"");
    }
    try {
      TimeUnit.MILLISECONDS.sleep(1000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}","private void establishConnection(){
  while (true) {
    clientSocket=new Socket();
    try {
      clientSocket.connect(new InetSocketAddress(hostName,port),1000);
      clientSocket.setKeepAlive(true);
      clientSocket.setReceiveBufferSize(NetworkConstant.SEND_BUFF_SIZE);
      clientSocket.setTcpNoDelay(true);
      inputChannel=new BufferedReader(new InputStreamReader(clientSocket.getInputStream()),NetworkConstant.SEND_BUFF_SIZE);
      outputChannel=new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream()));
      break;
    }
 catch (    IOException e) {
      logger.info(""String_Node_Str"");
    }
    try {
      TimeUnit.MILLISECONDS.sleep(3000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    clientSocket=null;
  }
}",0.9605177993527508
175317,"public void start(){
  try {
    if (!isStoped) {
      clientSocket=serverSocket.accept();
      clientSocket.setKeepAlive(true);
      clientSocket.setSendBufferSize(NetworkConstant.SEND_BUFF_SIZE);
      outputChannel=new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream()),NetworkConstant.SEND_BUFF_SIZE);
      inputChannel=new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
      String message=inputChannel.readLine();
      if (message.charAt(0) == NetworkConstant.REQUIRE_ARGS) {
        logger.info(""String_Node_Str"");
        ArgumentsPayloadBuilder argsPayload=new ArgumentsPayloadBuilder(this.args);
        outputChannel.write(NetworkStringMessage.buildMessage(NetworkConstant.REQUIRE_ARGS,argsPayload.toString()));
        outputChannel.flush();
        sendServicePooledThread.execute(new Runnable(){
          @Override public void run(){
            while (true) {
              try {
                String message=sendQueue.take();
                try {
                  outputChannel.write(message);
                  outputChannel.newLine();
                }
 catch (                IOException e1) {
                  e1.printStackTrace();
                }
                if (message.length() <= 3 && message.charAt(0) == NetworkConstant.FINISHED_ALL) {
                  logger.info(""String_Node_Str"");
                  break;
                }
              }
 catch (              InterruptedException e) {
                e.printStackTrace();
              }
            }
          }
        }
);
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void start(){
  bossServicePooledThread.execute(new Runnable(){
    @Override public void run(){
      try {
        if (!isStoped) {
          clientSocket=serverSocket.accept();
          clientSocket.setKeepAlive(true);
          clientSocket.setSendBufferSize(NetworkConstant.SEND_BUFF_SIZE);
          outputChannel=new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream()),NetworkConstant.SEND_BUFF_SIZE);
          inputChannel=new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
          String message=inputChannel.readLine();
          if (message.charAt(0) == NetworkConstant.REQUIRE_ARGS) {
            logger.info(""String_Node_Str"");
            ArgumentsPayloadBuilder argsPayload=new ArgumentsPayloadBuilder(NativeServer.args);
            outputChannel.write(NetworkStringMessage.buildMessage(NetworkConstant.REQUIRE_ARGS,argsPayload.toString()));
            outputChannel.flush();
            sendServicePooledThread.execute(new Runnable(){
              @Override public void run(){
                while (true) {
                  try {
                    String message=sendQueue.take();
                    try {
                      outputChannel.write(message);
                      outputChannel.newLine();
                    }
 catch (                    IOException e1) {
                      e1.printStackTrace();
                    }
                    if (message.length() <= 3 && message.charAt(0) == NetworkConstant.FINISHED_ALL) {
                      logger.info(""String_Node_Str"");
                      break;
                    }
                  }
 catch (                  InterruptedException e) {
                    e.printStackTrace();
                  }
                }
              }
            }
);
          }
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
);
}",0.9214365881032548
175318,"public void finish(){
  try {
    isStoped=true;
    send(NetworkConstant.FINISHED_ALL + ""String_Node_Str"");
    while (!sendQueue.isEmpty()) {
    }
    ;
    try {
      outputChannel.flush();
      outputChannel.close();
      inputChannel.close();
      clientSocket.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    sendServicePooledThread.shutdown();
    sendServicePooledThread.awaitTermination(5000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","public void finish(){
  try {
    isStoped=true;
    send(NetworkConstant.FINISHED_ALL + ""String_Node_Str"");
    while (!sendQueue.isEmpty()) {
    }
    ;
    try {
      outputChannel.flush();
      outputChannel.close();
      inputChannel.close();
      clientSocket.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    sendServicePooledThread.shutdown();
    bossServicePooledThread.shutdown();
    sendServicePooledThread.awaitTermination(5000,TimeUnit.MILLISECONDS);
    bossServicePooledThread.awaitTermination(5000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}",0.9032258064516128
175319,"public void waitReceiveFinish(){
  NettyClient.finishedLock.lock();
  if (!NettyClient.finished) {
    try {
      NettyClient.finishedConditionWait.await();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  NettyClient.finishedLock.unlock();
}","public void waitReceiveFinish(){
  Client.logger.info(""String_Node_Str"");
  while (!NettyClient.finished) {
    NettyClient.finishedLock.lock();
    if (!NettyClient.finished) {
      try {
        NettyClient.finishedConditionWait.await();
        Client.logger.info(""String_Node_Str"");
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
        Client.logger.info(e.getMessage());
      }
 finally {
        NettyClient.finishedLock.unlock();
      }
    }
 else {
      NettyClient.finishedLock.unlock();
    }
  }
  Client.logger.info(""String_Node_Str"");
}",0.5886442641946698
175320,"public void start(){
  Bootstrap bootstrap=new Bootstrap();
  bootstrap.group(workGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>(){
    @Override protected void initChannel(    SocketChannel ch) throws Exception {
      ch.pipeline().addLast(new SnappyFrameEncoder(),new SnappyFrameDecoder());
      ch.pipeline().addLast(new DelimiterBasedFrameDecoder(NetworkConstant.MAX_CHUNK_SIZE,Unpooled.wrappedBuffer(NetworkConstant.END_OF_TRANSMISSION.getBytes())));
      ch.pipeline().addLast(new StringEncoder(CharsetUtil.UTF_8),new StringDecoder(CharsetUtil.UTF_8));
      ch.pipeline().addLast(new NettyClientHandler());
    }
  }
).option(ChannelOption.TCP_NODELAY,true);
  sendFuture=bootstrap.connect(ip,port);
}","public void start(){
  final Bootstrap bootstrap=new Bootstrap();
  bootstrap.group(workGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>(){
    @Override protected void initChannel(    SocketChannel ch) throws Exception {
      ch.pipeline().addLast(new SnappyFrameEncoder(),new SnappyFrameDecoder());
      ch.pipeline().addLast(new DelimiterBasedFrameDecoder(NetworkConstant.MAX_CHUNK_SIZE,Unpooled.wrappedBuffer(NetworkConstant.END_OF_TRANSMISSION.getBytes())));
      ch.pipeline().addLast(new StringEncoder(CharsetUtil.UTF_8),new StringDecoder(CharsetUtil.UTF_8));
      ch.pipeline().addLast(new NettyClientHandler());
    }
  }
).option(ChannelOption.TCP_NODELAY,true);
  sendFuture=bootstrap.connect(ip,port);
  sendFuture.addListener(new ChannelFutureListener(){
    @Override public void operationComplete(    ChannelFuture future) throws Exception {
      if (!future.isSuccess()) {
        Client.logger.info(""String_Node_Str"");
        Thread.sleep(1000,0);
        sendFuture=bootstrap.connect(ip,port);
        sendFuture.addListener(this);
      }
    }
  }
);
}",0.8040794417606012
175321,"public void start(){
  bossGroup=new NioEventLoopGroup(1);
  workerGroup=new NioEventLoopGroup(1);
  ServerBootstrap bootstrap=new ServerBootstrap();
  bootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel ch) throws Exception {
      ch.pipeline().addLast(new SnappyFrameEncoder(),new SnappyFrameDecoder());
      ch.pipeline().addLast(new DelimiterBasedFrameDecoder(NetworkConstant.MAX_CHUNK_SIZE,Unpooled.wrappedBuffer(NetworkConstant.END_OF_TRANSMISSION.getBytes())));
      ch.pipeline().addLast(new StringEncoder(CharsetUtil.UTF_8),new StringDecoder(CharsetUtil.UTF_8));
      ch.pipeline().addLast(new NettyServerHandler());
    }
  }
).option(ChannelOption.SO_BACKLOG,128).childOption(ChannelOption.SO_KEEPALIVE,true);
  logger.info(""String_Node_Str"" + port);
  bindFuture=bootstrap.bind(port);
  logger.info(""String_Node_Str"");
}","public void start(){
  bossGroup=new NioEventLoopGroup(1);
  workerGroup=new NioEventLoopGroup(2);
  ServerBootstrap bootstrap=new ServerBootstrap();
  bootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel ch) throws Exception {
      ch.pipeline().addLast(new SnappyFrameEncoder(),new SnappyFrameDecoder());
      ch.pipeline().addLast(new DelimiterBasedFrameDecoder(NetworkConstant.MAX_CHUNK_SIZE,Unpooled.wrappedBuffer(NetworkConstant.END_OF_TRANSMISSION.getBytes())));
      ch.pipeline().addLast(new StringEncoder(CharsetUtil.UTF_8),new StringDecoder(CharsetUtil.UTF_8));
      ch.pipeline().addLast(new NettyServerHandler());
    }
  }
).option(ChannelOption.SO_BACKLOG,128).childOption(ChannelOption.SO_KEEPALIVE,true);
  logger.info(""String_Node_Str"" + port);
  bindFuture=bootstrap.bind(port);
  logger.info(""String_Node_Str"");
}",0.9989701338825951
175322,"@Override public void channelActive(ChannelHandlerContext ctx){
  if (NettyServer.clientChannel == null || !NettyServer.clientChannel.isActive()) {
    NettyServer.clientChannel=ctx.channel();
  }
}","@Override public void channelActive(ChannelHandlerContext ctx){
  logger.info(""String_Node_Str"");
}",0.5185185185185185
175323,"private void checkQueueAndSendData(){
  while (!NettyServer.finished) {
    try {
      String message=NettyServer.sendQueue.take();
      logger.info(""String_Node_Str"");
      ChannelFuture f=NettyServer.clientChannel.writeAndFlush(message);
      if (message.charAt(0) == NetworkConstant.FINISHED_ALL) {
        f.addListener(new ChannelFutureListener(){
          @Override public void operationComplete(          ChannelFuture future) throws Exception {
            logger.info(""String_Node_Str"");
          }
        }
);
      }
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
      logger.warn(""String_Node_Str"");
      logger.warn(e.getMessage());
    }
  }
}","private void checkQueueAndSendData(ChannelHandlerContext ctx){
  while (true) {
    try {
      String message=NettyServer.sendQueue.take();
      logger.info(""String_Node_Str"");
      ChannelFuture f=ctx.writeAndFlush(message);
      if (message.charAt(0) == NetworkConstant.FINISHED_ALL) {
        f.addListener(new ChannelFutureListener(){
          @Override public void operationComplete(          ChannelFuture future) throws Exception {
            logger.info(""String_Node_Str"");
          }
        }
);
      }
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
      logger.warn(""String_Node_Str"");
      logger.warn(e.getMessage());
    }
  }
}",0.9428989751098096
175324,"@Override protected void channelRead0(ChannelHandlerContext ctx,String msg) throws Exception {
  logger.info(""String_Node_Str"");
  char TYPE=msg.charAt(0);
  if (TYPE == NetworkConstant.REQUIRE_ARGS) {
    logger.info(""String_Node_Str"");
    ArgumentsPayloadBuilder argsPayload=new ArgumentsPayloadBuilder(NettyServer.args);
    ChannelFuture f=ctx.writeAndFlush(NetworkStringMessage.buildMessage(NetworkConstant.REQUIRE_ARGS,argsPayload.toString()));
    f.addListener(new ChannelFutureListener(){
      @Override public void operationComplete(      ChannelFuture future) throws Exception {
        logger.info(""String_Node_Str"");
      }
    }
);
  }
  checkQueueAndSendData();
}","@Override protected void channelRead0(ChannelHandlerContext ctx,String msg) throws Exception {
  logger.info(""String_Node_Str"");
  char TYPE=msg.charAt(0);
  if (TYPE == NetworkConstant.REQUIRE_ARGS) {
    if (NettyServer.clientChannel == null || !NettyServer.clientChannel.isActive()) {
      NettyServer.clientChannel=ctx.channel();
    }
    logger.info(""String_Node_Str"");
    ArgumentsPayloadBuilder argsPayload=new ArgumentsPayloadBuilder(NettyServer.args);
    ChannelFuture f=ctx.writeAndFlush(NetworkStringMessage.buildMessage(NetworkConstant.REQUIRE_ARGS,argsPayload.toString()));
    f.addListener(new ChannelFutureListener(){
      @Override public void operationComplete(      ChannelFuture future) throws Exception {
        logger.info(""String_Node_Str"");
      }
    }
);
    checkQueueAndSendData(ctx);
  }
}",0.901726427622842
175325,"static void readFileIntoPageCache(String filePath) throws IOException {
  File file=new File(filePath);
  int fileSize=(int)file.length();
  int CHUNK_SIZE=64 * 1024 * 1024;
  int maxIndex=fileSize % CHUNK_SIZE != 0 ? fileSize / CHUNK_SIZE : fileSize / CHUNK_SIZE - 1;
  int lastChunkLength=fileSize % CHUNK_SIZE != 0 ? fileSize % CHUNK_SIZE : CHUNK_SIZE;
  FileChannel fileChannel=new RandomAccessFile(filePath,""String_Node_Str"").getChannel();
  MappedByteBuffer mappedByteBuffer;
  mappedByteBuffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,maxIndex * CHUNK_SIZE,lastChunkLength);
  mappedByteBuffer.load();
  unmap(mappedByteBuffer);
  for (int i=maxIndex - 1; i >= 0; i--) {
    System.out.println(i);
    mappedByteBuffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,i * CHUNK_SIZE,CHUNK_SIZE);
    mappedByteBuffer.load();
    unmap(mappedByteBuffer);
  }
  System.out.println(maxIndex);
}","static void readFileIntoPageCache(String filePath) throws IOException {
  File file=new File(filePath);
  int fileSize=(int)file.length();
  int CHUNK_SIZE=64 * 1024 * 1024;
  int maxIndex=fileSize % CHUNK_SIZE != 0 ? fileSize / CHUNK_SIZE : fileSize / CHUNK_SIZE - 1;
  int lastChunkLength=fileSize % CHUNK_SIZE != 0 ? fileSize % CHUNK_SIZE : CHUNK_SIZE;
  FileChannel fileChannel=new RandomAccessFile(filePath,""String_Node_Str"").getChannel();
  MappedByteBuffer mappedByteBuffer;
  mappedByteBuffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,maxIndex * CHUNK_SIZE,lastChunkLength);
  mappedByteBuffer.load();
  unmap(mappedByteBuffer);
  for (int i=maxIndex - 1; i >= 0; i--) {
    mappedByteBuffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,i * CHUNK_SIZE,CHUNK_SIZE);
    mappedByteBuffer.load();
    unmap(mappedByteBuffer);
  }
}",0.9661114302125215
175326,"public RecordLazyEval(String recordStr,StringBuilder stringBuilder){
  this.curIndex=0;
  this.stringBuilder=stringBuilder;
  this.recordStr=recordStr;
  for (int i=0; i < 2; i++) {
    skipNextString();
  }
  String schema=getNextString();
  if (!schema.equals(RecordLazyEval.schema)) {
    this.isSchemaTableValid=false;
    return;
  }
  String table=getNextString();
  if (!table.equals(RecordLazyEval.table)) {
    this.isSchemaTableValid=false;
    return;
  }
  curIndex++;
  this.operationType=this.recordStr.charAt(curIndex);
  curIndex++;
  skipNextString();
  if (this.operationType == INSERT_OPERATION) {
    this.prevPKVal=-1;
    skipNextString();
  }
 else {
    this.prevPKVal=Long.valueOf(getNextString());
  }
  if (this.operationType == DELETE_OPERATION) {
    this.curPKVal=this.prevPKVal;
    this.recordStr=null;
  }
 else {
    this.curPKVal=Long.valueOf(getNextString());
  }
}","public RecordLazyEval(String recordStr){
  this.curIndex=0;
  this.recordStr=recordStr;
  this.stringBuilder=new StringBuilder();
  for (int i=0; i < 2; i++) {
    skipNextString();
  }
  String schema=getNextString();
  if (!schema.equals(RecordLazyEval.schema)) {
    this.isSchemaTableValid=false;
    return;
  }
  String table=getNextString();
  if (!table.equals(RecordLazyEval.table)) {
    this.isSchemaTableValid=false;
    return;
  }
  curIndex++;
  this.operationType=this.recordStr.charAt(curIndex);
  curIndex++;
  skipNextString();
  if (this.operationType == INSERT_OPERATION) {
    this.prevPKVal=-1;
    skipNextString();
  }
 else {
    this.prevPKVal=Long.valueOf(getNextString());
  }
  if (this.operationType == DELETE_OPERATION) {
    this.curPKVal=this.prevPKVal;
    this.recordStr=null;
    this.stringBuilder=null;
  }
 else {
    this.curPKVal=Long.valueOf(getNextString());
  }
}",0.8988391376451078
175327,"@Override public RecordLazyEvalTaskBuffer call() throws Exception {
  StringBuilder stringBuilder=new StringBuilder();
  RecordLazyEvalTaskBuffer recordLazyEvalTaskBuffer=new RecordLazyEvalTaskBuffer(endIdx - startIdx);
  for (int i=startIdx; i < endIdx; i++) {
    recordLazyEvalTaskBuffer.addData(new RecordLazyEval(taskBuffer.get(i),stringBuilder));
  }
  return recordLazyEvalTaskBuffer;
}","@Override public RecordLazyEvalTaskBuffer call() throws Exception {
  RecordLazyEvalTaskBuffer recordLazyEvalTaskBuffer=new RecordLazyEvalTaskBuffer(endIdx - startIdx);
  for (int i=startIdx; i < endIdx; i++) {
    recordLazyEvalTaskBuffer.addData(new RecordLazyEval(taskBuffer.get(i)));
  }
  return recordLazyEvalTaskBuffer;
}",0.9098474341192788
175328,"private static void testOne(String record,StringBuilder stringBuilder) throws IOException {
  System.out.println(record);
  RecordLazyEval recordLazyEval=new RecordLazyEval(record,stringBuilder);
  prettyPrint(recordLazyEval);
  if (recordLazyEval.operationType != DELETE_OPERATION)   iterateThough(recordLazyEval);
  System.out.println();
}","private static void testOne(String record) throws IOException {
  System.out.println(record);
  RecordLazyEval recordLazyEval=new RecordLazyEval(record);
  prettyPrint(recordLazyEval);
  if (recordLazyEval.operationType != DELETE_OPERATION)   iterateThough(recordLazyEval);
  System.out.println();
}",0.646875
175329,"public static void main(String[] args) throws IOException {
  RecordLazyEval.schema=""String_Node_Str"";
  RecordLazyEval.table=""String_Node_Str"";
  String[] records={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  StringBuilder stringBuilder=new StringBuilder();
  for (  String record : records) {
    testOne(record,stringBuilder);
  }
}","public static void main(String[] args) throws IOException {
  RecordLazyEval.schema=""String_Node_Str"";
  RecordLazyEval.table=""String_Node_Str"";
  String[] records={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  String record : records) {
    testOne(record);
  }
}",0.7496251874062968
175330,"public String compute(){
  for (int i=upperIdx; i > lowerIdx; i--) {
    recordLazyEval=new RecordLazyEval(fileChunk.get(i),stringBuilder);
    if (recordLazyEval.operationType == DELETE_OPERATION) {
      actForDeleteOperation();
    }
 else     if (recordLazyEval.operationType == INSERT_OPERATION) {
      actForInsertOperation();
    }
 else     if (recordLazyEval.operationType == UPDATE_OPERATION) {
      actForUpdateOperation();
    }
  }
  ChunkMergeResult chunkMergeResult=new ChunkMergeResult(activeKeys,deadKeys,insertOnlyUpdates);
  return String.valueOf(chunkMergeResult);
}","public String compute(){
  for (int i=upperIdx; i > lowerIdx; i--) {
    recordLazyEval=new RecordLazyEval(fileChunk.get(i));
    if (recordLazyEval.operationType == DELETE_OPERATION) {
      actForDeleteOperation();
    }
 else     if (recordLazyEval.operationType == INSERT_OPERATION) {
      actForInsertOperation();
    }
 else     if (recordLazyEval.operationType == UPDATE_OPERATION) {
      actForUpdateOperation();
    }
  }
  ChunkMergeResult chunkMergeResult=new ChunkMergeResult(activeKeys,deadKeys,insertOnlyUpdates);
  return String.valueOf(chunkMergeResult);
}",0.9879518072289156
175331,"public ComputationTask(RecordLazyEvalTaskBuffer recordLazyEvalTaskBuffer,FindResultListener findResultListener){
  this.recordLazyEvalTaskBuffer=recordLazyEvalTaskBuffer;
  this.findResultListener=findResultListener;
}","ComputationTask(RecordLazyEvalTaskBuffer recordLazyEvalTaskBuffer,FindResultListener findResultListener){
  this.recordLazyEvalTaskBuffer=recordLazyEvalTaskBuffer;
  this.findResultListener=findResultListener;
}",0.9836829836829836
175332,"@Override public void run(){
  try {
    while (lazyEvalTaskQueue.size() > 0) {
      Future<RecordLazyEvalTaskBuffer> futureWork=lazyEvalTaskQueue.peek();
      if (futureWork.isDone()) {
        computationPool.execute(new ComputationTask(futureWork.get(),findResultListener));
        lazyEvalTaskQueue.poll();
      }
 else {
        break;
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  Future<RecordLazyEvalTaskBuffer> recordLazyEvalTaskBufferFuture=transformPool.submit(new TransformTask(taskBuffer,0,taskBuffer.length()));
  lazyEvalTaskQueue.add(recordLazyEvalTaskBufferFuture);
}","@Override public void run(){
  MediatorTask.syncConsumeReadyJobs(findResultListener);
}",0.1906116642958748
175333,"public static void OneRoundComputation(String fileName,FindResultListener findResultListener) throws IOException {
  long startTime=System.currentTimeMillis();
  ReversedLinesDirectReader reversedLinesFileReader=new ReversedLinesDirectReader(fileName);
  String line;
  long lineCount=0;
  while ((line=reversedLinesFileReader.readLine()) != null) {
    if (strTaskBuffer.isFull()) {
      mediatorPool.execute(new MediatorTask(strTaskBuffer,findResultListener));
      strTaskBuffer=new StringTaskBuffer();
    }
    strTaskBuffer.addData(line);
    lineCount+=line.length();
  }
  mediatorPool.execute(new MediatorTask(strTaskBuffer,findResultListener));
  long endTime=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (endTime - startTime));
  if (Server.logger != null) {
    Server.logger.info(""String_Node_Str"" + (endTime - startTime));
    Server.logger.info(""String_Node_Str"" + lineCount);
  }
  MediatorTask.syncConsumeReadyJobs(findResultListener);
}","public static void OneRoundComputation(String fileName,final FindResultListener findResultListener) throws IOException {
  long startTime=System.currentTimeMillis();
  ReversedLinesDirectReader reversedLinesFileReader=new ReversedLinesDirectReader(fileName);
  String line;
  long lineCount=0;
  StringTaskBuffer strTaskBuffer=new StringTaskBuffer();
  while ((line=reversedLinesFileReader.readLine()) != null) {
    if (strTaskBuffer.isFull()) {
      mediatorPool.execute(new MediatorTask(strTaskBuffer,findResultListener));
      strTaskBuffer=new StringTaskBuffer();
    }
    strTaskBuffer.addData(line);
    lineCount+=line.length();
  }
  mediatorPool.execute(new MediatorTask(strTaskBuffer,findResultListener));
  mediatorPool.execute(new Runnable(){
    @Override public void run(){
      MediatorTask.syncConsumeReadyJobs(findResultListener);
    }
  }
);
  long endTime=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (endTime - startTime));
  if (Server.logger != null) {
    Server.logger.info(""String_Node_Str"" + (endTime - startTime));
    Server.logger.info(""String_Node_Str"" + lineCount);
  }
}",0.8740530303030303
175334,"public RecordLazyEval(String recordStr,StringBuilder stringBuilder){
  this.curIndex=0;
  this.stringBuilder=stringBuilder;
  this.recordStr=recordStr;
  for (int i=0; i < 4; i++) {
    skipNextString();
  }
  curIndex++;
  this.operationType=this.recordStr.charAt(curIndex);
  curIndex++;
  skipNextString();
  if (this.operationType == INSERT_OPERATION) {
    this.prevPKVal=-1;
    skipNextString();
  }
 else {
    this.prevPKVal=Long.valueOf(getNextString());
  }
  if (this.operationType == DELETE_OPERATION) {
    this.curPKVal=this.prevPKVal;
    skipNextString();
  }
 else {
    this.curPKVal=Long.valueOf(getNextString());
  }
}","public RecordLazyEval(String recordStr,StringBuilder stringBuilder){
  this.curIndex=0;
  this.stringBuilder=stringBuilder;
  this.recordStr=recordStr;
  for (int i=0; i < 4; i++) {
    skipNextString();
  }
  curIndex++;
  this.operationType=this.recordStr.charAt(curIndex);
  curIndex++;
  skipNextString();
  if (this.operationType == INSERT_OPERATION) {
    this.prevPKVal=-1;
    skipNextString();
  }
 else {
    this.prevPKVal=Long.valueOf(getNextString());
  }
  if (this.operationType == DELETE_OPERATION) {
    this.curPKVal=this.prevPKVal;
  }
 else {
    this.curPKVal=Long.valueOf(getNextString());
  }
}",0.982484076433121
175335,"@Override public boolean hasNext(){
  return curIndex + 1 <= recordStr.length() - 1;
}","@Override public boolean hasNext(){
  return this.operationType != DELETE_OPERATION && curIndex + 1 <= recordStr.length() - 1;
}",0.8037383177570093
175336,"public boolean isPKUpdate(){
  return prevPKVal == curPKVal;
}","public boolean isPKUpdate(){
  return prevPKVal != curPKVal;
}",0.9838709677419356
175337,"public static void main(String[] args) throws IOException {
  String record=""String_Node_Str"";
  String record2=""String_Node_Str"";
  String record3=""String_Node_Str"";
  StringBuilder stringBuilder=new StringBuilder();
  RecordLazyEval recordLazyEval=new RecordLazyEval(record,stringBuilder);
  prettyPrint(recordLazyEval);
  iterateThough(recordLazyEval);
  recordLazyEval=new RecordLazyEval(record2,stringBuilder);
  prettyPrint(recordLazyEval);
  iterateThough(recordLazyEval);
  recordLazyEval=new RecordLazyEval(record3,stringBuilder);
  prettyPrint(recordLazyEval);
  iterateThough(recordLazyEval);
}","public static void main(String[] args) throws IOException {
  String[] records={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  StringBuilder stringBuilder=new StringBuilder();
  for (  String record : records) {
    testOne(record,stringBuilder);
  }
}",0.200902934537246
175338,"public static boolean isSchemaTableOkay(String recordStr,String schema,String table){
  int curIndex=0;
  char ch;
  for (int i=0; i < 2; i++) {
    if (recordStr.charAt(curIndex) == SPLIT_CHAR)     curIndex++;
    while (recordStr.charAt(curIndex) != SPLIT_CHAR) {
      curIndex++;
    }
  }
  curIndex++;
  StringBuilder stringBuilder=new StringBuilder();
  while ((ch=recordStr.charAt(curIndex)) != SPLIT_CHAR) {
    curIndex++;
    stringBuilder.append(ch);
  }
  String schemaString=stringBuilder.toString();
  curIndex++;
  stringBuilder.setLength(0);
  while ((ch=recordStr.charAt(curIndex)) != SPLIT_CHAR) {
    curIndex++;
    stringBuilder.append(ch);
  }
  String pair=schemaString + '\t' + stringBuilder.toString();
  if (!hashSet.contains(pair)) {
    hashSet.add(pair);
  }
  if (!schema.equals(stringBuilder.toString())) {
    return false;
  }
  return table.equals(stringBuilder.toString());
}","public static boolean isSchemaTableOkay(String recordStr,String schema,String table){
  int curIndex=0;
  char ch;
  for (int i=0; i < 2; i++) {
    if (recordStr.charAt(curIndex) == SPLIT_CHAR)     curIndex++;
    while (recordStr.charAt(curIndex) != SPLIT_CHAR) {
      curIndex++;
    }
  }
  curIndex++;
  StringBuilder stringBuilder=new StringBuilder();
  while ((ch=recordStr.charAt(curIndex)) != SPLIT_CHAR) {
    curIndex++;
    stringBuilder.append(ch);
  }
  String schemaString=stringBuilder.toString();
  curIndex++;
  stringBuilder.setLength(0);
  while ((ch=recordStr.charAt(curIndex)) != SPLIT_CHAR) {
    curIndex++;
    stringBuilder.append(ch);
  }
  String pair=schemaString + '\t' + stringBuilder.toString();
  if (!hashSet.contains(pair)) {
    hashSet.add(pair);
  }
  if (!schema.equals(schemaString)) {
    return false;
  }
  return table.equals(stringBuilder.toString());
}",0.923756906077348
175339,"public void stop(){
  NettyServer.finished=true;
  try {
    sendQueue.put(""String_Node_Str"");
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    logger.warn(""String_Node_Str"");
    logger.warn(e.getMessage());
  }
  while (!NettyServer.sendQueue.isEmpty()) {
  }
  bindFuture.channel().closeFuture();
  logger.info(""String_Node_Str"");
  workerGroup.shutdownGracefully();
  bossGroup.shutdownGracefully();
}","public void stop(){
  NettyServer.finished=true;
  while (!NettyServer.sendFinished) {
  }
  bindFuture.channel().closeFuture();
  logger.info(""String_Node_Str"");
  workerGroup.shutdownGracefully();
  bossGroup.shutdownGracefully();
}",0.2427921092564491
175340,"private void checkQueueAndSendData(){
  while (!NettyServer.finished) {
    while (!NettyServer.sendQueue.isEmpty()) {
      try {
        String message=NettyServer.sendQueue.take();
        if (message.equals(""String_Node_Str""))         break;
        logger.info(""String_Node_Str"");
        NettyServer.clientChannel.writeAndFlush(message);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
        logger.warn(""String_Node_Str"");
        logger.warn(e.getMessage());
      }
    }
  }
}","private void checkQueueAndSendData(){
  while (!NettyServer.finished) {
    while (!NettyServer.sendQueue.isEmpty()) {
      try {
        String message=NettyServer.sendQueue.take();
        logger.info(""String_Node_Str"");
        ChannelFuture f=NettyServer.clientChannel.writeAndFlush(message);
        if (message.charAt(0) == NetworkConstant.FINISHED_ALL) {
          f.addListener(new ChannelFutureListener(){
            @Override public void operationComplete(            ChannelFuture future) throws Exception {
              NettyServer.sendFinished=true;
            }
          }
);
          f.channel().close().sync();
          break;
        }
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
        logger.warn(""String_Node_Str"");
        logger.warn(e.getMessage());
      }
    }
  }
}",0.4148148148148148
175341,"@Override public void operationComplete(ChannelFuture future) throws Exception {
  logger.info(""String_Node_Str"");
}","@Override public void operationComplete(ChannelFuture future) throws Exception {
  NettyServer.sendFinished=true;
}",0.8138528138528138
175342,"private void applyAttributes(AttributeSet attrs){
  TypedArray a=getContext().getTheme().obtainStyledAttributes(attrs,R.styleable.EditCredit,0,0);
  try {
    setSeparator(Separator.values()[a.getInt(R.styleable.EditCredit_separator,Separator.NONE.ordinal())]);
    setDisabledCardsInternal(a.getInt(R.styleable.EditCredit_disabledCards,0));
    setDrawableGravity(Gravity.values()[a.getInt(R.styleable.EditCredit_iconGravity,Gravity.END.ordinal())]);
  }
  finally {
    a.recycle();
  }
}","private void applyAttributes(AttributeSet attrs){
  TypedArray a=getContext().getTheme().obtainStyledAttributes(attrs,R.styleable.EditCredit,0,0);
  try {
    setSeparator(Separator.values()[a.getInt(R.styleable.EditCredit_separator,Separator.NONE.ordinal())]);
    setDisabledCardsInternal(a.getInt(R.styleable.EditCredit_disabledCards,0));
    setDrawableGravity(Gravity.values()[a.getInt(R.styleable.EditCredit_drawableGravity,Gravity.END.ordinal())]);
  }
  finally {
    a.recycle();
  }
}",0.9878048780487804
175343,"private void setDisabledCardsInternal(int disabledCards){
  List<Card> cards=new ArrayList<>();
  if (containsFlag(disabledCards,Card.VISA.value)) {
    cards.add(Card.VISA);
  }
  if (containsFlag(disabledCards,Card.MASTERCARD.value)) {
    cards.add(Card.MASTERCARD);
  }
  if (!containsFlag(disabledCards,Card.AMEX.value)) {
    cards.add(Card.AMEX);
  }
  setDisabledCards(cards.toArray(new Card[0]));
}","private void setDisabledCardsInternal(int disabledCards){
  List<Card> cards=new ArrayList<>();
  if (containsFlag(disabledCards,Card.VISA.value)) {
    cards.add(Card.VISA);
  }
  if (containsFlag(disabledCards,Card.MASTERCARD.value)) {
    cards.add(Card.MASTERCARD);
  }
  if (containsFlag(disabledCards,Card.AMEX.value)) {
    cards.add(Card.AMEX);
  }
  setDisabledCards(cards.toArray(new Card[0]));
}",0.998769987699877
175344,"private void findViewsById(){
  mEditCredit=findViewById(R.id.editcredit);
  separatorsRadioGroup=findViewById(R.id.separators_radio_group);
  gravityRadioGroup=findViewById(R.id.gravity_radio_group);
  validateButton=findViewById(R.id.btn_validate);
  getNumberButton=findViewById(R.id.btn_get_number);
  visaCheckBox=findViewById(R.id.chk_visa);
  masterCardCheckBox=findViewById(R.id.chk_mastercard);
  americanExpressCheckBox=findViewById(R.id.chk_amex);
}","private void findViewsById(){
  mEditCredit=findViewById(R.id.editcredit);
  separatorsRadioGroup=findViewById(R.id.separators_radio_group);
  gravityRadioGroup=findViewById(R.id.gravity_radio_group);
  validateButton=findViewById(R.id.btn_validate);
  getNumberButton=findViewById(R.id.btn_get_number);
  visaCheckBox=findViewById(R.id.chk_visa);
  masterCardCheckBox=findViewById(R.id.chk_mastercard);
  americanExpressCheckBox=findViewById(R.id.chk_amex);
  discoverCheckBox=findViewById(R.id.chk_discover);
}",0.9465020576131687
175345,"@Bean(""String_Node_Str"") public AuthorizingRealm authRealm(@Qualifier(""String_Node_Str"") SimpleCredentialsMatcher matcher){
  RestAuthRealm authRealm=new RestAuthRealm();
  authRealm.setCredentialsMatcher(matcher);
  return authRealm;
}","@Bean(""String_Node_Str"") public AuthorizingRealm authRealm(@Qualifier(""String_Node_Str"") CredentialsMatcher matcher){
  RestAuthRealm authRealm=new RestAuthRealm();
  authRealm.setCredentialsMatcher(matcher);
  return authRealm;
}",0.9871244635193132
175346,"protected Result response(AdminVersionLicense license,Map<String,Object> result){
  try {
    String json=JSON.toJSONString(result);
    PrivateKey privateKey=SerializeUtil.deserialize(Base64.getDecoder().decode(license.getPrivateKey()),PrivateKey.class);
    String data=Base64.getEncoder().encodeToString(RSAUtil.encrypt(json.getBytes(),privateKey));
    return Result.wrapResult(data);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","protected Result response(AdminVersionLicense license,Map<String,Object> result){
  try {
    String json=JSON.toJSONString(result);
    String key=DESUtil.buildSecurityKey();
    String encryptString=DESUtil.encrypt(json,key);
    PrivateKey privateKey=SerializeUtil.deserialize(Base64.getDecoder().decode(license.getPrivateKey()),PrivateKey.class);
    String encryptKey=Base64.getEncoder().encodeToString(RSAUtil.encrypt(key.getBytes(),privateKey));
    ClientVO client=new ClientVO();
    client.setCode(encryptString);
    client.setKey(encryptKey);
    return Result.wrapResult(JSON.toJSONString(client));
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.7897872340425532
175347,"protected Result<JSONObject> checkParam(ClientApiRequestParam param){
  if (StringUtils.isBlank(param.getLicenseKey())) {
    return Result.wrapResult(AdminVersionLicenseLang.NOT_FOUND);
  }
{
    if (StringUtils.isEmpty(param.getUuid())) {
      log.error(""String_Node_Str"");
      return Result.wrapResult(SystemLang.PARAM_WRONG);
    }
    AdminUsers buildUser=adminUsersDao.findByUuid(param.getUuid());
    if (buildUser == null) {
      log.error(""String_Node_Str"");
      return Result.wrapResult(SystemLang.PARAM_WRONG);
    }
    AdminAuthGroupAccess access=adminAuthGroupAccessDao.findByUidAndGroupId(buildUser.getId(),2L);
    if (access == null) {
      log.error(""String_Node_Str"");
      return Result.wrapResult(SystemLang.PARAM_WRONG);
    }
  }
  AdminVersionLicense license=adminVersionLicenseDao.findByLicense(param.getLicenseKey());
  if (license == null) {
    return Result.wrapResult(AdminVersionLicenseLang.NOT_FOUND);
  }
  if (license.getStatus() != 1) {
    return Result.wrapResult(AdminVersionLicenseLang.ILLEGAL_STATUS);
  }
  if (DateTime.now().isAfter(license.getExpireTime().getTime())) {
    return Result.wrapResult(AdminVersionLicenseLang.LICENSE_HAD_EXPIRE);
  }
  try {
    PrivateKey privateKey=SerializeUtil.deserialize(Base64.getDecoder().decode(license.getPrivateKey()),PrivateKey.class);
    JSONObject object=JSON.parseObject(RSAUtil.decrypt(Base64.getDecoder().decode(param.getCode()),privateKey),JSONObject.class);
    object.put(""String_Node_Str"",license);
    return Result.wrapResult(object);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",JSON.toJSONString(param));
  }
  return Result.wrapResult(SystemLang.ERROR);
}","protected Result<JSONObject> checkParam(ClientApiRequestParam param){
  if (StringUtils.isBlank(param.getLicenseKey())) {
    return Result.wrapResult(AdminVersionLicenseLang.NOT_FOUND);
  }
{
    if (StringUtils.isEmpty(param.getUuid())) {
      log.error(""String_Node_Str"");
      return Result.wrapResult(SystemLang.PARAM_WRONG);
    }
    AdminUsers buildUser=adminUsersDao.findByUuid(param.getUuid());
    if (buildUser == null) {
      log.error(""String_Node_Str"");
      return Result.wrapResult(SystemLang.PARAM_WRONG);
    }
    AdminAuthGroupAccess access=adminAuthGroupAccessDao.findByUidAndGroupId(buildUser.getId(),2L);
    if (access == null) {
      log.error(""String_Node_Str"");
      return Result.wrapResult(SystemLang.PARAM_WRONG);
    }
  }
  AdminVersionLicense license=adminVersionLicenseDao.findByLicense(param.getLicenseKey());
  if (license == null) {
    return Result.wrapResult(AdminVersionLicenseLang.NOT_FOUND);
  }
  if (license.getStatus() != 1) {
    return Result.wrapResult(AdminVersionLicenseLang.ILLEGAL_STATUS);
  }
  if (DateTime.now().isAfter(license.getExpireTime().getTime())) {
    return Result.wrapResult(AdminVersionLicenseLang.LICENSE_HAD_EXPIRE);
  }
  try {
    PrivateKey privateKey=SerializeUtil.deserialize(Base64.getDecoder().decode(license.getPrivateKey()),PrivateKey.class);
    JSONObject object=JSON.parseObject(RSAUtil.decrypt(Base64.getDecoder().decode(URLDecoder.decode(param.getCode(),""String_Node_Str"")),privateKey),JSONObject.class);
    object.put(""String_Node_Str"",license);
    return Result.wrapResult(object);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",JSON.toJSONString(param));
  }
  return Result.wrapResult(SystemLang.ERROR);
}",0.9891080365027966
175348,"private List<Menu> buildMenu(AdminUsers buildUser){
  List<AdminAdminNav> navList=adminAdminNavService.getClientMenu(buildUser);
  Map<Long,List<AdminAdminNav>> navMap=new HashMap<>();
  for (  AdminAdminNav item : navList) {
    List<AdminAdminNav> list=navMap.get(item.getPid());
    if (CollectionUtils.isEmpty(list)) {
      list=new ArrayList<>();
    }
    list.add(item);
    navMap.put(item.getPid(),list);
  }
  List<Menu> menus=new ArrayList<>();
  for (  AdminAdminNav item : navMap.get(0L)) {
    Menu menu=BeanUtil.copy(item,Menu.class);
    menu.setChild(processMenu(item,navMap));
    menus.add(menu);
  }
  return menus;
}","private List<Menu> buildMenu(AdminUsers buildUser){
  List<AdminAdminNav> navList=adminAdminNavService.getClientMenu(buildUser);
  Map<Long,List<AdminAdminNav>> navMap=new HashMap<>();
  for (  AdminAdminNav item : navList) {
    List<AdminAdminNav> list=navMap.get(item.getPid());
    if (CollectionUtils.isEmpty(list)) {
      list=new ArrayList<>();
    }
    list.add(item);
    navMap.put(item.getPid(),list);
  }
  List<Menu> menus=new ArrayList<>();
  if (CollectionUtils.isEmpty(navMap)) {
    return menus;
  }
  for (  AdminAdminNav item : navMap.get(0L)) {
    Menu menu=BeanUtil.copy(item,Menu.class);
    menu.setChild(processMenu(item,navMap));
    menus.add(menu);
  }
  return menus;
}",0.9529499626587006
175349,"private String request(String api,Map<String,Object> param){
  String url=String.format(""String_Node_Str"",rbacShiroUrl,api);
  try {
    Connection.Response response=Jsoup.connect(url).method(Connection.Method.POST).timeout(300).data(ImmutableMap.of(""String_Node_Str"",RSAUtil.encrypt(param,publicKey),""String_Node_Str"",uuid,""String_Node_Str"",licenseKey)).ignoreContentType(true).execute();
    JSONObject object=JSONObject.parseObject(response.body(),JSONObject.class);
    if (!object.getBoolean(""String_Node_Str"")) {
      throw new AuthenticationException(response.body());
    }
    byte[] jsonBytes=RSAUtil.decrypt(Base64.getDecoder().decode(object.getString(""String_Node_Str"")),publicKey);
    return new String(jsonBytes,""String_Node_Str"");
  }
 catch (  Exception e) {
    throw new AuthenticationException(""String_Node_Str"",e);
  }
}","private String request(String api,Map<String,Object> param){
  String url=String.format(""String_Node_Str"",rbacShiroUrl,api);
  try {
    Connection.Response response=Jsoup.connect(url).method(Connection.Method.POST).timeout(300).data(ImmutableMap.of(""String_Node_Str"",URLEncoder.encode(RSAUtil.encrypt(param,publicKey),""String_Node_Str""),""String_Node_Str"",uuid,""String_Node_Str"",licenseKey)).ignoreContentType(true).execute();
    JSONObject object=JSONObject.parseObject(response.body(),JSONObject.class);
    if (!object.getBoolean(""String_Node_Str"")) {
      throw new AuthenticationException(response.body());
    }
    String data=object.getString(""String_Node_Str"");
    JSONObject client=JSON.parseObject(data);
    String encryptKey=client.getString(""String_Node_Str"");
    byte[] jsonBytes=RSAUtil.decrypt(Base64.getDecoder().decode(encryptKey),publicKey);
    String key=new String(jsonBytes,""String_Node_Str"");
    return DESUtil.decrypt(client.getString(""String_Node_Str""),key);
  }
 catch (  Exception e) {
    throw new AuthenticationException(""String_Node_Str"",e);
  }
}",0.8220031136481578
175350,"/** 
 * 给登录用户授权
 * @param principalCollection
 * @return
 */
@Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection){
  Profile profile=(Profile)principalCollection.fromRealm(this.getClass().getName()).iterator().next();
  Map<String,Object> param=new HashMap<>();
  param.put(""String_Node_Str"",profile.getUuid());
  String result=request(""String_Node_Str"",param);
  SimpleAuthorizationInfo info=new SimpleAuthorizationInfo();
  AuthInfo authInfo=JSON.parseObject(result,new TypeReference<AuthInfo>(){
  }
.getType());
  Set<String> permissions=new HashSet<>();
  permissions.addAll(authInfo.getPermissions());
  info.addStringPermissions(permissions);
  Subject subject=SecurityUtils.getSubject();
  Session session=subject.getSession();
  session.setAttribute(""String_Node_Str"",authInfo);
  session.setAttribute(""String_Node_Str"",profile);
  return info;
}","/** 
 * 给登录用户授权
 * @param principalCollection
 * @return
 */
@Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection){
  Profile profile=(Profile)principalCollection.fromRealm(this.getClass().getName()).iterator().next();
  Map<String,Object> param=new HashMap<>();
  param.put(""String_Node_Str"",profile.getUuid());
  String result=request(""String_Node_Str"",param);
  SimpleAuthorizationInfo info=new SimpleAuthorizationInfo();
  AuthInfo authInfo=JSON.parseObject(result,new TypeReference<AuthInfo>(){
  }
.getType());
  Set<String> permissions=new HashSet<>();
  permissions.addAll(authInfo.getPermission());
  info.addStringPermissions(permissions);
  Subject subject=SecurityUtils.getSubject();
  Session session=subject.getSession();
  session.setAttribute(""String_Node_Str"",authInfo);
  session.setAttribute(""String_Node_Str"",profile);
  return info;
}",0.9994465965688988
175351,"private static void updateNavbarData(Context context,XpNavBarSetting setting){
  List<ShortCut> shortCutData=setting.getShortCutData();
  int iconScale=setting.getIconSize();
  int homePosition=setting.getHomePointPosition();
  boolean rootDown=setting.isRootDown();
  int clearMemLevel=setting.getClearMenLevel();
  boolean chameleonNavbar=setting.isChameleonNavbar();
  int navbarHeight=setting.getNavbarHeight();
  boolean vibrate=setting.isVibrate();
  boolean navbarHightOpt=setting.isNavbarHeightOpt();
  setHomePointPosition(onHomeNavbar);
  DataHook.rootDown=rootDown;
  DataHook.iconScale=iconScale;
  DataHook.clearMenLevel=clearMemLevel;
  DataHook.chameleonNavbar=chameleonNavbar;
  DataHook.homePointPosition=homePosition;
  DataHook.vibrate=vibrate;
  DataHook.navbarOpt=navbarHightOpt;
  musicControllerPanel.updateIconSize();
  btnFuncFactory.clearAllBtn();
  if (shortCutData != null && shortCutData.size() != 0) {
    DataHook.shortCutList=shortCutData;
    for (    ShortCut sc : shortCutData) {
      btnFuncFactory.createBtnAndSetFunc(exNavbar,sc);
    }
  }
  if (DataHook.navbarHeight != navbarHeight && navbarHightOpt) {
    setNavbarHeight(context,navbarHeight);
    DataHook.navbarHeight=navbarHeight;
  }
 else   if (!navbarHightOpt) {
    navbarHeight=-1;
    DataHook.navbarHeight=-1;
    setNavbarHeight(context,navbarHeight);
  }
}","private static void updateNavbarData(Context context,XpNavBarSetting setting){
  List<ShortCut> shortCutData=setting.getShortCutData();
  int iconScale=setting.getIconSize();
  int homePosition=setting.getHomePointPosition();
  boolean rootDown=setting.isRootDown();
  int clearMemLevel=setting.getClearMenLevel();
  boolean chameleonNavbar=setting.isChameleonNavbar();
  int navbarHeight=setting.getNavbarHeight();
  boolean vibrate=setting.isVibrate();
  boolean navbarHightOpt=setting.isNavbarHeightOpt();
  setHomePointPosition(onHomeNavbar);
  DataHook.rootDown=rootDown;
  DataHook.iconScale=iconScale;
  DataHook.clearMenLevel=clearMemLevel;
  DataHook.chameleonNavbar=chameleonNavbar;
  DataHook.homePointPosition=homePosition;
  DataHook.vibrate=vibrate;
  DataHook.navbarOpt=navbarHightOpt;
  musicControllerPanel.updateIconSize();
  btnFuncFactory.clearAllBtn();
  if (shortCutData != null && shortCutData.size() != 0) {
    DataHook.shortCutList=shortCutData;
    for (    ShortCut sc : shortCutData) {
      btnFuncFactory.createBtnAndSetFunc(exNavbar,sc);
    }
  }
  if (navbarHightOpt) {
    setNavbarHeight(context,navbarHeight);
    DataHook.navbarHeight=navbarHeight;
  }
 else {
    navbarHeight=-1;
    DataHook.navbarHeight=-1;
    setNavbarHeight(context,navbarHeight);
  }
}",0.97593984962406
175352,"private static void hookNavBar(ViewGroup rootView,ViewGroup navbarView){
  rootNavbarView=rootView;
  Context context=rootView.getContext();
  ViewPager vpXpHook=new ViewPager(context);
  exNavbar=new LinearLayout(context);
  musicControllerPanel=new MusicControllerPanel(context);
  onHomeNavbar=new LinearLayout(context);
  initExNavbar(vpXpHook,exNavbar);
  initHomeNavbar(onHomeNavbar,vpXpHook);
  initMusicPanel(musicControllerPanel);
  initVpHook(vpXpHook,navbarView,exNavbar,musicControllerPanel,onHomeNavbar);
  initBroadcast(context);
  initClipBoardListener(context);
  ViewGroup.LayoutParams params=new ViewGroup.LayoutParams(ViewPager.LayoutParams.MATCH_PARENT,ViewPager.LayoutParams.MATCH_PARENT);
  rootView.addView(vpXpHook,0,params);
  setNavbarHeight(context,DataHook.navbarHeight);
}","private static void hookNavBar(ViewGroup rootView,ViewGroup navbarView){
  rootNavbarView=rootView;
  Context context=rootView.getContext();
  ViewPager vpXpHook=new ViewPager(context);
  exNavbar=new LinearLayout(context);
  musicControllerPanel=new MusicControllerPanel(context);
  onHomeNavbar=new LinearLayout(context);
  initExNavbar(vpXpHook,exNavbar);
  initHomeNavbar(onHomeNavbar,vpXpHook);
  initMusicPanel(musicControllerPanel);
  initVpHook(vpXpHook,navbarView,exNavbar,musicControllerPanel,onHomeNavbar);
  initBroadcast(context);
  initClipBoardListener(context);
  ViewGroup.LayoutParams params=new ViewGroup.LayoutParams(ViewPager.LayoutParams.MATCH_PARENT,ViewPager.LayoutParams.MATCH_PARENT);
  rootView.addView(vpXpHook,0,params);
  if (DataHook.navbarOpt) {
    setNavbarHeight(context,DataHook.navbarHeight);
  }
}",0.9792176039119804
175353,"public static void hook(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable {
  String pwmClassPath;
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
    pwmClassPath=PHONE_WINDOW_MANAGER_M;
  }
 else {
    pwmClassPath=PHONE_WINDOW_MANAGER_L;
  }
  Class<?> pwmClass=loadPackageParam.classLoader.loadClass(pwmClassPath);
  XposedBridge.hookAllMethods(pwmClass,""String_Node_Str"",new XC_MethodHook(){
    @Override protected void afterHookedMethod(    final MethodHookParam param) throws Throwable {
      final Context mContext=(Context)XposedHelpers.getObjectField(param.thisObject,""String_Node_Str"");
      WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
      screenH=wm.getDefaultDisplay().getHeight();
      final Resources resources=mContext.getResources();
      final int resourceId=resources.getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      defaultNavbarH=resources.getDimensionPixelSize(resourceId);
      navbarH=defaultNavbarH;
      if (navbarH == 0) {
        navbarH=150;
      }
      BroadcastReceiver screenShotReceiver=new BroadcastReceiver(){
        @Override public void onReceive(        Context context,        Intent intent){
          try {
            int type=intent.getIntExtra(ConstantStr.TYPE,-1);
switch (type) {
case ConstantStr.TAKE_SCREENSHOT:
              if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M) {
                XposedHelpers.callMethod(param.thisObject,""String_Node_Str"",1);
              }
 else {
                XposedHelpers.callMethod(param.thisObject,""String_Node_Str"");
              }
            break;
case ConstantStr.HIDE_NAVBAR:
{
            setNavBarDimensions(param.thisObject,0,defaultNavbarH);
          }
        break;
case ConstantStr.NAVBAR_H:
{
        navbarH=resources.getDimensionPixelSize(resourceId);
        navbarH=(int)(navbarH * (((float)intent.getIntExtra(ConstantStr.NAVBAR_HEIGHT,100) / 100)));
        setNavBarDimensions(param.thisObject,navbarH,defaultNavbarH);
      }
    break;
}
}
 catch (Exception e) {
XpLog.e(e);
}
}
}
;
IntentFilter filter=new IntentFilter(XpNavBarAction.ACTION_PHONE_WINDOW_MANAGER);
mContext.registerReceiver(screenShotReceiver,filter);
gesturesListener=new GesturesListener(mContext,new GesturesListener.Callbacks(){
@Override public void onSwipeFromTop(){
}
@Override public void onSwipeFromBottom(){
setNavBarDimensions(param.thisObject,navbarH,defaultNavbarH);
}
@Override public void onSwipeFromRight(){
}
@Override public void onDebug(){
}
}
);
}
}
);
}","public static void hook(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable {
  String pwmClassPath;
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
    pwmClassPath=PHONE_WINDOW_MANAGER_M;
  }
 else {
    pwmClassPath=PHONE_WINDOW_MANAGER_L;
  }
  Class<?> pwmClass=loadPackageParam.classLoader.loadClass(pwmClassPath);
  XposedBridge.hookAllMethods(pwmClass,""String_Node_Str"",new XC_MethodHook(){
    @Override protected void afterHookedMethod(    final MethodHookParam param) throws Throwable {
      final Context mContext=(Context)XposedHelpers.getObjectField(param.thisObject,""String_Node_Str"");
      WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
      screenH=wm.getDefaultDisplay().getHeight();
      final Resources resources=mContext.getResources();
      final int resourceId=resources.getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      defaultNavbarH=resources.getDimensionPixelSize(resourceId);
      navbarH=defaultNavbarH;
      if (navbarH == 0) {
        navbarH=150;
      }
      BroadcastReceiver screenShotReceiver=new BroadcastReceiver(){
        @Override public void onReceive(        Context context,        Intent intent){
          try {
            int type=intent.getIntExtra(ConstantStr.TYPE,-1);
switch (type) {
case ConstantStr.TAKE_SCREENSHOT:
              if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M) {
                XposedHelpers.callMethod(param.thisObject,""String_Node_Str"",1);
              }
 else {
                XposedHelpers.callMethod(param.thisObject,""String_Node_Str"");
              }
            break;
case ConstantStr.HIDE_NAVBAR:
{
            setNavBarDimensions(param.thisObject,0,defaultNavbarH);
          }
        break;
case ConstantStr.NAVBAR_H:
{
        navbarH=resources.getDimensionPixelSize(resourceId);
        navbarH=(int)(navbarH * (((float)intent.getIntExtra(ConstantStr.NAVBAR_HEIGHT,100) / 100)));
        setNavBarDimensions(param.thisObject,navbarH,defaultNavbarH);
      }
    break;
}
}
 catch (Exception e) {
XpLog.e(e);
}
}
}
;
IntentFilter filter=new IntentFilter(XpNavBarAction.ACTION_PHONE_WINDOW_MANAGER);
mContext.registerReceiver(screenShotReceiver,filter);
gesturesListener=new GesturesListener(mContext,new GesturesListener.Callbacks(){
@Override public void onSwipeFromTop(){
}
@Override public void onSwipeFromBottom(){
setNavBarDimensions(param.thisObject,navbarH,defaultNavbarH);
}
@Override public void onSwipeFromRight(){
}
@Override public void onDebug(){
}
}
);
}
}
);
XposedHelpers.findAndHookMethod(pwmClass,""String_Node_Str"",Display.class,int.class,int.class,int.class,new XC_MethodHook(){
@Override protected void afterHookedMethod(MethodHookParam param) throws Throwable {
setNavBarDimensions(param.thisObject,navbarH,defaultNavbarH);
}
}
);
}",0.9484803558191252
175354,"@Override protected void afterHookedMethod(final MethodHookParam param) throws Throwable {
  final Context mContext=(Context)XposedHelpers.getObjectField(param.thisObject,""String_Node_Str"");
  WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
  screenH=wm.getDefaultDisplay().getHeight();
  final Resources resources=mContext.getResources();
  final int resourceId=resources.getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  defaultNavbarH=resources.getDimensionPixelSize(resourceId);
  navbarH=defaultNavbarH;
  if (navbarH == 0) {
    navbarH=150;
  }
  BroadcastReceiver screenShotReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      try {
        int type=intent.getIntExtra(ConstantStr.TYPE,-1);
switch (type) {
case ConstantStr.TAKE_SCREENSHOT:
          if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M) {
            XposedHelpers.callMethod(param.thisObject,""String_Node_Str"",1);
          }
 else {
            XposedHelpers.callMethod(param.thisObject,""String_Node_Str"");
          }
        break;
case ConstantStr.HIDE_NAVBAR:
{
        setNavBarDimensions(param.thisObject,0,defaultNavbarH);
      }
    break;
case ConstantStr.NAVBAR_H:
{
    navbarH=resources.getDimensionPixelSize(resourceId);
    navbarH=(int)(navbarH * (((float)intent.getIntExtra(ConstantStr.NAVBAR_HEIGHT,100) / 100)));
    setNavBarDimensions(param.thisObject,navbarH,defaultNavbarH);
  }
break;
}
}
 catch (Exception e) {
XpLog.e(e);
}
}
}
;
IntentFilter filter=new IntentFilter(XpNavBarAction.ACTION_PHONE_WINDOW_MANAGER);
mContext.registerReceiver(screenShotReceiver,filter);
gesturesListener=new GesturesListener(mContext,new GesturesListener.Callbacks(){
@Override public void onSwipeFromTop(){
}
@Override public void onSwipeFromBottom(){
setNavBarDimensions(param.thisObject,navbarH,defaultNavbarH);
}
@Override public void onSwipeFromRight(){
}
@Override public void onDebug(){
}
}
);
}","@Override protected void afterHookedMethod(MethodHookParam param) throws Throwable {
  setNavBarDimensions(param.thisObject,navbarH,defaultNavbarH);
}",0.1394052044609665
175355,"public static void hook(ClassLoader classLoader) throws Throwable {
  final Class<?> slideTouchEvent=classLoader.loadClass(""String_Node_Str"");
  XposedHelpers.findAndHookMethod(slideTouchEvent,""String_Node_Str"",float.class,new XC_MethodReplacement(){
    @Override protected Object replaceHookedMethod(    MethodHookParam param) throws Throwable {
      return null;
    }
  }
);
}","public static void hook(ClassLoader classLoader) throws Throwable {
  try {
    final Class<?> slideTouchEvent=classLoader.loadClass(""String_Node_Str"");
    XposedHelpers.findAndHookMethod(slideTouchEvent,""String_Node_Str"",float.class,new XC_MethodReplacement(){
      @Override protected Object replaceHookedMethod(      MethodHookParam param) throws Throwable {
        return null;
      }
    }
);
  }
 catch (  Exception e) {
  }
}",0.9326805385556916
175356,"/** 
 * @param poolId 根据指定id获取一个连接池
 * @return RedisPools对象
 * @throws Exception 加载异常
 */
public RedisPools getRedisPool(String poolId) throws Exception {
  currentPoolId=poolId;
  RedisPools pool=null;
  if (poolMap.containsKey(poolId)) {
    logger.info(NoticeInfo.ALREADY_EXIST_POOL + poolId);
    return poolMap.get(poolId);
  }
  try {
    configFile=PropertyFile.getProperties(propertyFile);
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new ReadConfigException(ExceptionInfo.OPEN_CONFIG_FAILED + propertyFile,e,PoolManagement.class);
  }
  String pre=poolId + Configs.SEPARATE;
  RedisPoolProperty poolProperty;
  if (configFile.getString(pre + Configs.NAME) == null) {
    logger.error(ExceptionInfo.POOL_NOT_EXIST_CONFIG);
    throw new Exception(ExceptionInfo.POOL_NOT_EXIST_CONFIG);
  }
 else {
    pool=new RedisPools();
    poolProperty=RedisPoolProperty.initByIdFromConfig(poolId);
    pool.setProperty(poolProperty);
  }
  pool.initialPool();
  logger.info(""String_Node_Str"" + poolId + ""String_Node_Str""+ pool+ ""String_Node_Str""+ poolProperty.toString());
  if (pool.available()) {
    poolMap.put(poolId,pool);
    return pool;
  }
 else {
    throw new RedisConnectionException(ExceptionInfo.POOL_NOT_AVAILABLE,PoolManagement.class);
  }
}","/** 
 * @param poolId 根据指定id获取一个连接池
 * @return RedisPools对象
 * @throws Exception 加载异常
 */
public RedisPools getRedisPool(String poolId) throws Exception {
  currentPoolId=poolId;
  RedisPools pool=null;
  if (poolMap.containsKey(poolId)) {
    logger.info(NoticeInfo.ALREADY_EXIST_POOL + poolId);
    return poolMap.get(poolId);
  }
  try {
    configFile=PropertyFile.getProperties(propertyFile);
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new ReadConfigException(ExceptionInfo.OPEN_CONFIG_FAILED + propertyFile,e,PoolManagement.class);
  }
  String pre=poolId + Configs.SEPARATE;
  RedisPoolProperty poolProperty;
  if (configFile.getString(pre + Configs.NAME) == null) {
    throw new RedisConnectionException(ExceptionInfo.POOL_NOT_EXIST_CONFIG,PoolManagement.class);
  }
 else {
    pool=new RedisPools();
    poolProperty=RedisPoolProperty.initByIdFromConfig(poolId);
    pool.setProperty(poolProperty);
  }
  pool.initialPool();
  logger.info(""String_Node_Str"" + poolId + ""String_Node_Str""+ pool+ ""String_Node_Str""+ poolProperty.toString());
  if (pool.available()) {
    poolMap.put(poolId,pool);
    return pool;
  }
 else {
    throw new RedisConnectionException(ExceptionInfo.POOL_NOT_AVAILABLE,PoolManagement.class);
  }
}",0.9490722463482038
175357,"public static Map<String,RedisPoolProperty> getAllPoolConfig() throws ReadConfigException {
  Map<String,RedisPoolProperty> map=new HashMap<>();
  int maxId=0;
  MythProperties properties=null;
  try {
    maxId=getMaxId();
    properties=getProperties(Configs.propertyFile);
  }
 catch (  IOException e) {
    e.printStackTrace();
    logger.error(""String_Node_Str"");
  }
  for (int i=Configs.START_ID; i <= maxId; i++) {
    String poolId=properties.getString(i + Configs.SEPARATE + Configs.POOL_ID);
    if (poolId == null)     continue;
    RedisPoolProperty property=RedisPoolProperty.initByIdFromConfig(poolId);
    map.put(poolId,property);
  }
  return map;
}","public static Map<String,RedisPoolProperty> getAllPoolConfig() throws ReadConfigException {
  Map<String,RedisPoolProperty> map=new HashMap<>();
  int maxId=0;
  MythProperties properties=null;
  try {
    maxId=getMaxId();
    properties=getProperties(Configs.propertyFile);
  }
 catch (  IOException e) {
    e.printStackTrace();
    logger.error(ExceptionInfo.OPEN_CONFIG_FAILED,e);
    return map;
  }
  for (int i=Configs.START_ID; i <= maxId; i++) {
    String poolId=properties.getString(i + Configs.SEPARATE + Configs.POOL_ID);
    if (poolId == null)     continue;
    RedisPoolProperty property=RedisPoolProperty.initByIdFromConfig(poolId);
    map.put(poolId,property);
  }
  return map;
}",0.9539136795903438
175358,"public static int getMaxId() throws IOException {
  MythProperties props=getProperties(Configs.propertyFile);
  String maxId=props.getString(""String_Node_Str"");
  if (maxId == null) {
    save(""String_Node_Str"",Configs.START_ID + ""String_Node_Str"");
    props=getProperties(Configs.propertyFile);
    maxId=props.getString(""String_Node_Str"");
  }
  return Integer.parseInt(maxId);
}","/** 
 * 获得最大的id，如果最开始没有就要新增
 * @return 返回最大的id（已用）
 * @throws IOException 文件异常
 */
public static int getMaxId() throws IOException {
  MythProperties props=getProperties(Configs.propertyFile);
  String maxId=props.getString(Configs.MAX_POOL_ID);
  if (maxId == null) {
    save(Configs.MAX_POOL_ID,Configs.START_ID + ""String_Node_Str"");
    props=getProperties(Configs.propertyFile);
    maxId=props.getString(Configs.MAX_POOL_ID);
  }
  return Integer.parseInt(maxId);
}",0.776084407971864
175359,"/** 
 * 得到配置文件对象
 * @param propertyFile 文件名以及路径（完整）
 * @return
 * @throws IOException
 */
public static MythProperties getProperties(String propertyFile) throws IOException {
  MythProperties props=new MythProperties();
  File file=new File(propertyFile);
  if (!file.exists())   if (file.createNewFile()) {
    logger.info(""String_Node_Str"");
  }
 else {
    logger.info(""String_Node_Str"");
  }
  InputStream is;
  try {
    is=new BufferedInputStream(new FileInputStream(propertyFile));
  }
 catch (  FileNotFoundException e) {
    throw new IllegalArgumentException();
  }
  props.load(is);
  is.close();
  return props;
}","/** 
 * 得到配置文件对象
 * @param propertyFile 文件名以及路径（完整）
 * @return 配置文件的对象
 * @throws IOException
 */
public static MythProperties getProperties(String propertyFile) throws IOException {
  MythProperties props=new MythProperties();
  File file=new File(propertyFile);
  if (!file.exists()) {
    if (file.createNewFile()) {
      logger.info(ExceptionInfo.CREATE_CONFIG_SUCCESS);
    }
 else {
      logger.info(ExceptionInfo.CREATE_CONFIG_FIALED);
    }
  }
  InputStream is;
  try {
    is=new BufferedInputStream(new FileInputStream(propertyFile));
  }
 catch (  FileNotFoundException e) {
    throw new IllegalArgumentException();
  }
  props.load(is);
  is.close();
  return props;
}",0.533231474407945
175360,"public static RedisPoolProperty initByIdFromConfig(String id){
  RedisPoolProperty property=new RedisPoolProperty();
  String pre=id + Configs.SEPARATE;
  List<String> lists=MythReflect.getFieldByClass(RedisPoolProperty.class);
  Map<String,Object> map=new HashMap<>();
  MythProperties config=null;
  try {
    config=PropertyFile.getProperties(Configs.propertyFile);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  for (  String field : lists) {
    map.put(field,config.getString(pre + field));
  }
  try {
    property=(RedisPoolProperty)MythReflect.setFieldsValue(property,map);
  }
 catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
  return property;
}","public static RedisPoolProperty initByIdFromConfig(String id){
  RedisPoolProperty property=new RedisPoolProperty();
  String pre=id + Configs.SEPARATE;
  List<String> lists=MythReflect.getFieldByClass(RedisPoolProperty.class);
  Map<String,Object> map=new HashMap<>();
  MythProperties config=null;
  try {
    config=PropertyFile.getProperties(Configs.propertyFile);
    for (    String field : lists) {
      map.put(field,config.getString(pre + field));
    }
    property=(RedisPoolProperty)MythReflect.setFieldsValue(property,map);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return property;
}",0.6482758620689655
175361,"/** 
 * 初始化Redis连接池
 */
protected void initialPool(){
  try {
    JedisPoolConfig config=new JedisPoolConfig();
    config.setMaxTotal(property.getMaxActive());
    config.setMaxIdle(property.getMaxIdle());
    config.setMaxWaitMillis(property.getMaxWaitMills());
    config.setTestOnBorrow(property.isTestOnBorrow());
    if (property.getPassword() != null && property.getPassword().length() > 0) {
      jedisPool=new JedisPool(config,property.getHost(),property.getPort(),property.getTimeout(),property.getPassword());
    }
 else {
      jedisPool=new JedisPool(config,property.getHost(),property.getPort(),property.getTimeout());
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + e);
  }
}","/** 
 * 初始化Redis连接池
 */
protected void initialPool(){
  try {
    JedisPoolConfig config=new JedisPoolConfig();
    config.setMaxTotal(property.getMaxActive());
    config.setMaxIdle(property.getMaxIdle());
    config.setMaxWaitMillis(property.getMaxWaitMills());
    config.setTestOnBorrow(property.isTestOnBorrow());
    if (property.getPassword() != null && property.getPassword().length() > 0) {
      jedisPool=new JedisPool(config,property.getHost(),property.getPort(),property.getTimeout(),property.getPassword());
    }
 else {
      jedisPool=new JedisPool(config,property.getHost(),property.getPort(),property.getTimeout());
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    logger.error(""String_Node_Str"" + e);
  }
}",0.9828414550446122
175362,"/** 
 * @param object 要赋值的对象
 * @param maps 属性名-属性值 映射
 * @throws IllegalAccessException 可能没有权限
 */
public static Object setFieldsValue(Object object,Map<String,Object> maps) throws IllegalAccessException {
  target=object.getClass();
  Field[] fields=target.getDeclaredFields();
  for (  Field field : fields) {
    field.setAccessible(true);
    String type=field.getType().getName();
switch (type) {
case ""String_Node_Str"":
      field.set(object,Integer.parseInt(maps.get(field.getName()).toString()));
    break;
case ""String_Node_Str"":
  field.set(object,maps.get(field.getName()));
break;
case ""String_Node_Str"":
field.set(object,""String_Node_Str"".equals(maps.get(field.getName()).toString()));
break;
}
}
return object;
}","/** 
 * @param object 要赋值的对象
 * @param maps 属性名-属性值 映射
 * @throws IllegalAccessException 可能没有权限
 */
public static Object setFieldsValue(Object object,Map<String,Object> maps) throws IllegalAccessException {
  target=object.getClass();
  for (  Field field : target.getDeclaredFields()) {
    field.setAccessible(true);
    String type=field.getType().getName();
switch (type) {
case ""String_Node_Str"":
      field.set(object,Integer.parseInt(maps.get(field.getName()).toString()));
    break;
case ""String_Node_Str"":
  field.set(object,maps.get(field.getName()));
break;
case ""String_Node_Str"":
field.set(object,""String_Node_Str"".equals(maps.get(field.getName()).toString()));
break;
}
}
return object;
}",0.9602233077459874
175363,"/** 
 * @param object 对象
 * @return 返回 对象的所有 属性-值 map
 * @throws IllegalAccessException 没有权限访问
 */
public static Map<String,Object> getFieldsValue(Object object) throws IllegalAccessException {
  Map<String,Object> map=new HashMap<>();
  target=object.getClass();
  Field[] fields=target.getDeclaredFields();
  for (  Field field : fields) {
    field.setAccessible(true);
    Object value=field.get(object);
    String name=field.getName();
    map.put(name,value);
  }
  return map;
}","/** 
 * @param object 对象
 * @return 返回 对象的所有 属性-值 map
 * @throws IllegalAccessException 没有权限访问
 */
public static Map<String,Object> getFieldsValue(Object object) throws IllegalAccessException {
  Map<String,Object> map=new HashMap<>();
  target=object.getClass();
  for (  Field field : target.getDeclaredFields()) {
    field.setAccessible(true);
    Object value=field.get(object);
    String name=field.getName();
    map.put(name,value);
  }
  return map;
}",0.9524815205913412
175364,"@Test @InSequence(1) public void countedConstructorCalled(){
  long count=1L + Math.round(Math.random() * 10);
  for (int i=0; i < count; i++)   instance.get();
  assertThat(""String_Node_Str"",registry.getCounters(),hasKey(COUNTER_NAME));
  Counter counter=registry.getCounters().get(COUNTER_NAME);
  assertThat(""String_Node_Str"",counter.getCount(),is(equalTo(count)));
}","@Test @InSequence(1) public void countedConstructorCalled(){
  long count=1L + Math.round(Math.random() * 10);
  for (int i=0; i < count; i++) {
    instance.get();
  }
  assertThat(""String_Node_Str"",registry.getCounters(),hasKey(COUNTER_NAME));
  Counter counter=registry.getCounters().get(COUNTER_NAME);
  assertThat(""String_Node_Str"",counter.getCount(),is(equalTo(count)));
}",0.9438502673796793
175365,"@Test @InSequence(1) public void meteredConstructorCalled(){
  long count=1L + Math.round(Math.random() * 10);
  for (int i=0; i < count; i++)   instance.get();
  assertThat(""String_Node_Str"",registry.getMeters(),hasKey(METER_NAME));
  Meter meter=registry.getMeters().get(METER_NAME);
  assertThat(""String_Node_Str"",meter.getCount(),is(equalTo(count)));
}","@Test @InSequence(1) public void meteredConstructorCalled(){
  long count=1L + Math.round(Math.random() * 10);
  for (int i=0; i < count; i++) {
    instance.get();
  }
  assertThat(""String_Node_Str"",registry.getMeters(),hasKey(METER_NAME));
  Meter meter=registry.getMeters().get(METER_NAME);
  assertThat(""String_Node_Str"",meter.getCount(),is(equalTo(count)));
}",0.9416666666666668
175366,"@Override public boolean hasNext(){
  if (this.exception != null) {
    throw new RuntimeException(""String_Node_Str"",this.exception);
  }
  return this.cursor < this.entities.size() - 1;
}","@Override public boolean hasNext(){
  if (this.exception != null) {
    throw new RuntimeException(""String_Node_Str"",this.exception);
  }
  return this.cursor < this.entities.size();
}",0.989247311827957
175367,"private double getMaxLongitude(DataTilePos pos){
  return this.getLongitude(pos) + this.tileSize.getZ();
}","private double getMaxLongitude(DataTilePos pos){
  return (pos.getTileZ() + 1) * this.tileSize.getZ();
}",0.8857142857142857
175368,"private double getMaxLatitude(DataTilePos pos){
  return this.getLatitude(pos) + this.tileSize.getX();
}","private double getMaxLatitude(DataTilePos pos){
  return (pos.getTileX() + 1) * this.tileSize.getX();
}",0.8888888888888888
175369,"private boolean isWayInBounds(OsmWay way,double minLatitude,double minLongitude,double maxLatitude,double maxLongitude){
  double wayMinLatitude=Double.MAX_VALUE;
  double wayMinLongitude=Double.MAX_VALUE;
  double wayMaxLatitude=-Double.MAX_VALUE;
  double wayMaxLongitude=-Double.MAX_VALUE;
  for (int i=0; i < way.getNumberOfNodes(); i++) {
    try {
      OsmNode node=this.getNode(way.getNodeId(i));
      double latitude=node.getLatitude();
      if (latitude < wayMinLatitude) {
        wayMinLatitude=latitude;
      }
      if (latitude > wayMaxLatitude) {
        wayMaxLatitude=latitude;
      }
      double longitude=node.getLongitude();
      if (longitude < wayMinLongitude) {
        wayMinLongitude=longitude;
      }
      if (longitude > wayMaxLongitude) {
        wayMaxLongitude=longitude;
      }
    }
 catch (    EntityNotFoundException e) {
    }
  }
  return true;
}","private boolean isWayInBounds(OsmWay way,double minLatitude,double minLongitude,double maxLatitude,double maxLongitude){
  double wayMinLatitude=Double.MAX_VALUE;
  double wayMinLongitude=Double.MAX_VALUE;
  double wayMaxLatitude=-Double.MAX_VALUE;
  double wayMaxLongitude=-Double.MAX_VALUE;
  for (int i=0; i < way.getNumberOfNodes(); i++) {
    try {
      OsmNode node=this.getNode(way.getNodeId(i));
      double latitude=node.getLatitude();
      if (latitude < wayMinLatitude) {
        wayMinLatitude=latitude;
      }
      if (latitude > wayMaxLatitude) {
        wayMaxLatitude=latitude;
      }
      double longitude=node.getLongitude();
      if (longitude < wayMinLongitude) {
        wayMinLongitude=longitude;
      }
      if (longitude > wayMaxLongitude) {
        wayMaxLongitude=longitude;
      }
    }
 catch (    EntityNotFoundException e) {
    }
  }
  return minLatitude < wayMaxLatitude && maxLatitude > wayMinLatitude && minLongitude < wayMaxLongitude && maxLongitude > wayMinLongitude;
}",0.9318658280922432
175370,"@Override public TerrariumDataProvider buildDataProvider(){
  int heightOrigin=this.properties.getInteger(HEIGHT_ORIGIN);
  SrtmHeightSource heightSource=new SrtmHeightSource(this.srtmRaster,""String_Node_Str"");
  DataLayer<ShortRasterTile> heightSampler=new ShortTileSampleLayer(heightSource);
  DataLayer<ShortRasterTile> heightProducer=this.createHeightProducer(heightSampler);
  DataLayer<CoverRasterTile> coverProducer=this.createCoverProducer();
  DataLayer<OsmTile> osmProducer=this.createOsmProducer();
  DataLayer<ShortRasterTile> waterBankLayer=new WaterBankPopulatorLayer(coverProducer,heightProducer);
  waterBankLayer=new OsmCoastlineLayer(waterBankLayer,osmProducer,this.earthCoordinates);
  waterBankLayer=new OsmWaterBodyLayer(waterBankLayer,osmProducer,this.earthCoordinates);
  DataLayer<WaterRasterTile> waterProducer=new WaterProcessorLayer(waterBankLayer);
  return TerrariumDataProvider.builder().withComponent(RegionComponentType.HEIGHT,heightProducer).withComponent(RegionComponentType.SLOPE,this.createSlopeProducer(heightSampler)).withComponent(RegionComponentType.COVER,coverProducer).withComponent(EarthComponentTypes.OSM,osmProducer).withComponent(EarthComponentTypes.WATER,waterProducer).withAdapter(new WaterApplyAdapter(this.earthCoordinates,EarthComponentTypes.WATER,RegionComponentType.HEIGHT,RegionComponentType.COVER)).withAdapter(new OsmAreaCoverAdapter(this.earthCoordinates,EarthComponentTypes.OSM,RegionComponentType.COVER)).withAdapter(new HeightTransformAdapter(this.world,RegionComponentType.HEIGHT,this.properties.getDouble(HEIGHT_SCALE) * this.worldScale,heightOrigin)).withAdapter(new WaterLevelingAdapter(EarthComponentTypes.WATER,RegionComponentType.HEIGHT,heightOrigin + 1)).withAdapter(new WaterCarveAdapter(EarthComponentTypes.WATER,RegionComponentType.HEIGHT,this.properties.getInteger(OCEAN_DEPTH))).withAdapter(new BeachAdapter(this.world,RegionComponentType.COVER,EarthComponentTypes.WATER,this.properties.getInteger(BEACH_SIZE),EarthCoverTypes.BEACH)).build();
}","@Override public TerrariumDataProvider buildDataProvider(){
  int heightOrigin=this.properties.getInteger(HEIGHT_ORIGIN);
  SrtmHeightSource heightSource=new SrtmHeightSource(this.srtmRaster,""String_Node_Str"");
  DataLayer<ShortRasterTile> heightSampler=new ShortTileSampleLayer(heightSource);
  DataLayer<ShortRasterTile> heightProducer=this.createHeightProducer(heightSampler);
  DataLayer<CoverRasterTile> coverProducer=this.createCoverProducer();
  DataLayer<OsmTile> osmProducer=this.createOsmProducer();
  DataLayer<ShortRasterTile> waterBankLayer=new WaterBankPopulatorLayer(coverProducer,heightProducer);
  waterBankLayer=new OsmCoastlineLayer(waterBankLayer,osmProducer,this.earthCoordinates);
  waterBankLayer=new OsmWaterBodyLayer(waterBankLayer,osmProducer,this.earthCoordinates);
  DataLayer<WaterRasterTile> waterProducer=new WaterProcessorLayer(waterBankLayer);
  return TerrariumDataProvider.builder().withComponent(RegionComponentType.HEIGHT,heightProducer).withComponent(RegionComponentType.SLOPE,this.createSlopeProducer(heightSampler)).withComponent(RegionComponentType.COVER,coverProducer).withComponent(EarthComponentTypes.OSM,osmProducer).withComponent(EarthComponentTypes.WATER,waterProducer).withAdapter(new WaterApplyAdapter(this.earthCoordinates,EarthComponentTypes.WATER,RegionComponentType.HEIGHT,RegionComponentType.COVER)).withAdapter(new OsmAreaCoverAdapter(this.earthCoordinates,EarthComponentTypes.OSM,RegionComponentType.COVER)).withAdapter(new HeightNoiseAdapter(this.world,RegionComponentType.HEIGHT,2,0.08,this.properties.getDouble(NOISE_SCALE))).withAdapter(new HeightTransformAdapter(this.world,RegionComponentType.HEIGHT,this.properties.getDouble(HEIGHT_SCALE) * this.worldScale,heightOrigin)).withAdapter(new WaterLevelingAdapter(EarthComponentTypes.WATER,RegionComponentType.HEIGHT,heightOrigin + 1)).withAdapter(new WaterCarveAdapter(EarthComponentTypes.WATER,RegionComponentType.HEIGHT,this.properties.getInteger(OCEAN_DEPTH))).withAdapter(new BeachAdapter(this.world,RegionComponentType.COVER,EarthComponentTypes.WATER,this.properties.getInteger(BEACH_SIZE),EarthCoverTypes.BEACH)).build();
}",0.970878459687124
175371,"private Collection<Result> collectPolygons(OsmTile osmTile){
  List<Result> results=new ArrayList<>();
  for (  Type type : this.polygonTypes) {
    Collection<MultiPolygon> coverPolygons=osmTile.collectPolygons(type.filter);
    if (!coverPolygons.isEmpty()) {
      results.add(new Result(type.id,coverPolygons));
    }
  }
  return results;
}","private Collection<Result> collectPolygons(DataView view,OsmTile osmTile){
  List<Result> results=new ArrayList<>();
  for (  Type type : this.polygonTypes) {
    Collection<MultiPolygon> coverPolygons=osmTile.collectPolygons(view,this.geoCoordinateState,type.filter);
    if (!coverPolygons.isEmpty()) {
      results.add(new Result(type.id,coverPolygons));
    }
  }
  return results;
}",0.941336971350614
175372,"@Override public void adapt(RegionData data,int x,int z,int width,int height){
  OsmTile osmTile=data.getOrExcept(this.osmComponent);
  CoverRasterTile coverTile=data.getOrExcept(this.coverComponent);
  Collection<Result> polygons=this.collectPolygons(osmTile);
  if (!polygons.isEmpty()) {
    RasterCanvas canvas=new RasterCanvas(width,height);
    canvas.setOrigin(x,z);
    for (    Result result : polygons) {
      canvas.setColor(result.id + 1);
      for (      MultiPolygon polygon : result.polygons) {
        Area shape=OsmShapeProducer.toShape(polygon,this.geoCoordinateState);
        Rectangle bounds=shape.getBounds();
        if (bounds.getWidth() > 2 && bounds.getHeight() > 2) {
          canvas.fill(shape);
        }
      }
    }
    for (int localZ=0; localZ < height; localZ++) {
      for (int localX=0; localX < width; localX++) {
        int value=canvas.getData(localX,localZ);
        if (value != 0) {
          CoverType<?> coverType=this.coverTypes.get(value - 1);
          coverTile.set(localX,localZ,coverType);
        }
      }
    }
  }
}","@Override public void adapt(RegionData data,int x,int z,int width,int height){
  OsmTile osmTile=data.getOrExcept(this.osmComponent);
  CoverRasterTile coverTile=data.getOrExcept(this.coverComponent);
  Collection<Result> polygons=this.collectPolygons(new DataView(x,z,width,height),osmTile);
  if (!polygons.isEmpty()) {
    RasterCanvas canvas=new RasterCanvas(width,height);
    canvas.setOrigin(x,z);
    for (    Result result : polygons) {
      canvas.setColor(result.id + 1);
      for (      MultiPolygon polygon : result.polygons) {
        Area shape=OsmShapeProducer.toShape(polygon,this.geoCoordinateState);
        Rectangle bounds=shape.getBounds();
        if (bounds.getWidth() > 2 && bounds.getHeight() > 2) {
          canvas.fill(shape);
        }
      }
    }
    for (int localZ=0; localZ < height; localZ++) {
      for (int localX=0; localX < width; localX++) {
        int value=canvas.getData(localX,localZ);
        if (value != 0) {
          CoverType<?> coverType=this.coverTypes.get(value - 1);
          coverTile.set(localX,localZ,coverType);
        }
      }
    }
  }
}",0.9857863365428704
175373,"protected void rasterizeLineSegment(DataView view,ShortRasterTile resultTile,double originX,double originY,double targetX,double targetY,int bankType){
  Interpolation.interpolateLine(originX,originY,targetX,targetY,false,point -> {
    int localX=point.x - view.getX();
    int localY=point.y - view.getY();
    if (localX >= 0 && localY >= 0 && localX < view.getWidth() && localY < view.getHeight()) {
      resultTile.setShort(localX,localY,(short)bankType);
      this.freeNeighbors(view,resultTile,localX,localY);
    }
  }
);
}","protected void rasterizeLineSegment(DataView view,ShortRasterTile resultTile,double originX,double originY,double targetX,double targetY,int bankType){
  Interpolation.interpolateLine(originX,originY,targetX,targetY,false,point -> {
    int localX=point.x - view.getX();
    int localY=point.y - view.getY();
    if (localX >= 0 && localY >= 0 && localX < view.getWidth() && localY < view.getHeight()) {
      short currentBankType=resultTile.getShort(localX,localY);
      if ((currentBankType & TYPE_MASK) != BANK) {
        resultTile.setShort(localX,localY,(short)bankType);
      }
 else {
        resultTile.setShort(localX,localY,(short)(currentBankType | (bankType & ~TYPE_MASK)));
      }
      this.freeNeighbors(view,resultTile,localX,localY);
    }
  }
);
}",0.8003072196620584
175374,"@Override protected ShortRasterTile applyWater(DataView view,ShortRasterTile waterTile,OsmTile osmTile){
  List<OsmWay> coastlines=osmTile.getWays().stream().filter(way -> OsmDataParser.hasTag(way,""String_Node_Str"",""String_Node_Str"")).collect(Collectors.toList());
  if (!coastlines.isEmpty()) {
    ShortRasterTile resultTile=waterTile.copy();
    short[] bankMap=resultTile.getShortData();
    for (    OsmWay coastline : coastlines) {
      List<Point> linePoints=this.collectLinePoints(OsmDataParser.createLines(osmTile,coastline));
      this.rasterizeLine(view,resultTile,linePoints);
    }
    this.reduceProblematicPoints(view,bankMap);
    this.floodCoastMap(view,resultTile);
    return resultTile;
  }
  return waterTile;
}","@Override protected ShortRasterTile applyWater(DataView view,ShortRasterTile waterTile,OsmTile osmTile){
  List<OsmWay> coastlines=osmTile.getWays().stream().filter(way -> OsmDataParser.hasTag(way,""String_Node_Str"",""String_Node_Str"")).collect(Collectors.toList());
  if (!coastlines.isEmpty()) {
    ShortRasterTile resultTile=waterTile.copy();
    short[] bankMap=resultTile.getShortData();
    for (    OsmWay coastline : coastlines) {
      List<Point> linePoints=this.collectLinePoints(OsmDataParser.createLines(osmTile,coastline));
      this.rasterizeLine(view,resultTile,linePoints);
    }
    this.reduceProblematicPoints(view,bankMap);
    DebugImageWriter.write(""String_Node_Str"" + view.getX() + ""String_Node_Str""+ view.getY(),bankMap,BANK_DEBUG,view.getWidth(),view.getHeight());
    this.floodCoastMap(view,resultTile);
    DebugImageWriter.write(""String_Node_Str"" + view.getX() + ""String_Node_Str""+ view.getY()+ ""String_Node_Str"",bankMap,BANK_DEBUG,view.getWidth(),view.getHeight());
    return resultTile;
  }
  return waterTile;
}",0.8150646430578977
175375,"protected void reduceProblematicPoints(DataView view,short[] bankMap){
  int width=view.getWidth();
  int height=view.getHeight();
  for (int localY=0; localY < height; localY++) {
    for (int localX=0; localX < width; localX++) {
      int index=localX + localY * width;
      int bankType=bankMap[index];
      if (this.isFillingBankType(bankType)) {
        int upType=(localY > 0) ? bankMap[index - width] : bankType;
        int leftType=(localX > 0) ? bankMap[index - 1] : bankType;
        int downType=(localY < height - 1) ? bankMap[index + width] : bankType;
        int rightType=(localX < width - 1) ? bankMap[index + 1] : bankType;
        if ((upType != bankType && downType != bankType) ^ (leftType != bankType && rightType != bankType)) {
          bankMap[index]=BANK;
        }
      }
    }
  }
}","protected void reduceProblematicPoints(DataView view,short[] bankMap){
  int width=view.getWidth();
  int height=view.getHeight();
  for (int localY=0; localY < height; localY++) {
    for (int localX=0; localX < width; localX++) {
      int index=localX + localY * width;
      int bankType=bankMap[index];
      if (this.isFillingBankType(bankType)) {
        if ((bankType & BANK_UP_FLAG) != 0 && (bankType & BANK_DOWN_FLAG) != 0) {
          bankMap[index]=BANK;
        }
 else {
          int upType=(localY > 0) ? bankMap[index - width] : bankType;
          int leftType=(localX > 0) ? bankMap[index - 1] : bankType;
          int downType=(localY < height - 1) ? bankMap[index + width] : bankType;
          int rightType=(localX < width - 1) ? bankMap[index + 1] : bankType;
          if ((upType != bankType && downType != bankType) && (leftType != bankType && rightType != bankType)) {
            bankMap[index]=BANK;
          }
        }
      }
    }
  }
}",0.4574944071588367
175376,"@Override public DataView getParentView(DataView view){
  return view.grow(8,8,8,8);
}","@Override public DataView getParentView(DataView view){
  return view;
}",0.9113924050632912
175377,"@Override protected ShortRasterTile applyWater(DataView view,ShortRasterTile waterTile,OsmTile osmTile){
  Collection<MultiPolygon> waterPolygons=osmTile.collectPolygons(this::isWaterArea);
  if (!waterPolygons.isEmpty()) {
    ShortRasterTile resultTile=waterTile.copy();
    RasterCanvas canvas=new RasterCanvas(view.getWidth(),view.getHeight());
    canvas.setOrigin(view.getX(),view.getY());
    canvas.setColor(RIVER_COLOR);
    for (    MultiPolygon polygon : waterPolygons) {
      Area shape=OsmShapeProducer.toShape(polygon,this.geoCoordinateState);
      Rectangle bounds=shape.getBounds();
      if (bounds.getWidth() > 2 && bounds.getHeight() > 2) {
        canvas.fill(shape);
      }
    }
    this.fillExistingWater(view,resultTile,canvas);
    for (int localZ=0; localZ < view.getHeight(); localZ++) {
      for (int localX=0; localX < view.getWidth(); localX++) {
        int value=canvas.getData(localX,localZ);
        if (value == RIVER_COLOR) {
          resultTile.setShort(localX,localZ,RIVER);
        }
      }
    }
    return resultTile;
  }
  return waterTile;
}","@Override protected ShortRasterTile applyWater(DataView view,ShortRasterTile waterTile,OsmTile osmTile){
  Collection<MultiPolygon> waterPolygons=osmTile.collectPolygons(view,this.geoCoordinateState,this::isWaterArea);
  if (!waterPolygons.isEmpty()) {
    ShortRasterTile resultTile=waterTile.copy();
    RasterCanvas canvas=new RasterCanvas(view.getWidth(),view.getHeight());
    canvas.setOrigin(view.getX(),view.getY());
    canvas.setColor(RIVER_COLOR);
    for (    MultiPolygon polygon : waterPolygons) {
      Area shape=OsmShapeProducer.toShape(polygon,this.geoCoordinateState);
      Rectangle bounds=shape.getBounds();
      if (bounds.getWidth() > 2 && bounds.getHeight() > 2) {
        canvas.fill(shape);
      }
    }
    this.fillExistingWater(view,resultTile,canvas);
    DebugImageWriter.write(""String_Node_Str"" + view.getX() + ""String_Node_Str""+ view.getY(),resultTile.getData(),OsmCoastlineLayer.BANK_DEBUG,view.getWidth(),view.getHeight());
    for (int localZ=0; localZ < view.getHeight(); localZ++) {
      for (int localX=0; localX < view.getWidth(); localX++) {
        int value=canvas.getData(localX,localZ);
        if (value == RIVER_COLOR) {
          resultTile.setShort(localX,localZ,RIVER);
        }
      }
    }
    DebugImageWriter.write(""String_Node_Str"" + view.getX() + ""String_Node_Str""+ view.getY()+ ""String_Node_Str"",resultTile.getData(),OsmCoastlineLayer.BANK_DEBUG,view.getWidth(),view.getHeight());
    return resultTile;
  }
  return waterTile;
}",0.838884585592564
175378,"public Collection<MultiPolygon> collectPolygons(Predicate<OsmEntity> filter){
  List<MultiPolygon> polygons=this.getRelations().stream().filter(filter).map(relation -> OsmDataParser.createArea(this,relation)).filter(Objects::nonNull).collect(Collectors.toList());
  polygons.addAll(this.getWays().stream().filter(filter).map(way -> OsmDataParser.createArea(this,way)).filter(Objects::nonNull).collect(Collectors.toList()));
  return polygons;
}","public Collection<MultiPolygon> collectPolygons(DataView view,CoordinateState geoCoordinate,Predicate<OsmEntity> filter){
  double minLatitude=geoCoordinate.getZ(view.getX(),view.getY());
  double minLongitude=geoCoordinate.getX(view.getMaxX(),view.getMaxY());
  double maxLatitude=geoCoordinate.getZ(view.getMaxX(),view.getMaxY());
  double maxLongitude=geoCoordinate.getX(view.getX(),view.getY());
  List<MultiPolygon> polygons=this.getRelations().stream().filter(filter).filter(relation -> this.isRelationInBounds(relation,minLatitude,minLongitude,maxLatitude,maxLongitude)).map(relation -> OsmDataParser.createArea(this,relation)).filter(Objects::nonNull).collect(Collectors.toList());
  polygons.addAll(this.getWays().stream().filter(filter).filter(way -> this.isWayInBounds(way,minLatitude,minLongitude,maxLatitude,maxLongitude)).map(way -> OsmDataParser.createArea(this,way)).filter(Objects::nonNull).collect(Collectors.toList()));
  return polygons;
}",0.6329294369208838
175379,"private void collectCompletedTiles(){
  if (this.queuedTiles.isEmpty()) {
    return;
  }
  Set<DataTileKey<?>> completedTiles=new HashSet<>();
  for (  TileFuture<?> future : this.queuedTiles.values()) {
    if (future.isComplete()) {
      TiledDataAccess parsedResult=this.parseResult(future);
      this.tileCache.put(future.key,parsedResult);
      completedTiles.add(future.key);
    }
  }
  completedTiles.forEach(this.queuedTiles::remove);
  System.out.println(this.tileCache.size());
}","private void collectCompletedTiles(){
  if (this.queuedTiles.isEmpty()) {
    return;
  }
  Set<DataTileKey<?>> completedTiles=new HashSet<>();
  for (  TileFuture<?> future : this.queuedTiles.values()) {
    if (future.isComplete()) {
      TiledDataAccess parsedResult=this.parseResult(future);
      this.tileCache.put(future.key,parsedResult);
      completedTiles.add(future.key);
    }
  }
  completedTiles.forEach(this.queuedTiles::remove);
}",0.9522799575821844
175380,"private void buildFaces(BufferBuilder builder,List<EnumFacing> faces,IBlockState state,Biome biome,BlockPos pos){
  int color=this.getBlockColor(state,biome,pos);
  int red=(color >> 16) & 0xFF;
  int green=(color >> 8) & 0xFF;
  int blue=color & 0xFF;
  builder.setTranslation(pos.getX(),pos.getY(),pos.getZ());
  for (  EnumFacing face : faces) {
    this.buildFace(builder,face,red,green,blue);
  }
}","private void buildFaces(BufferBuilder builder,List<EnumFacing> faces,IBlockState state,Biome biome,BlockPos pos,int x,int z){
  int color=this.getBlockColor(state,biome,pos);
  int red=(color >> 16) & 0xFF;
  int green=(color >> 8) & 0xFF;
  int blue=color & 0xFF;
  builder.setTranslation(x,pos.getY(),z);
  for (  EnumFacing face : faces) {
    this.buildFace(builder,face,red,green,blue);
  }
}",0.83
175381,"public PreviewChunk(ChunkPrimer chunk,Biome[] biomes,ChunkPos pos,IBlockAccess previewAccess){
  this.chunk=chunk;
  this.biomes=biomes;
  this.pos=pos;
  this.previewAccess=previewAccess;
}","public PreviewChunk(ChunkPrimer chunk,Biome[] biomes,ChunkPos pos,IBlockAccess previewAccess){
  this.chunk=chunk;
  this.biomes=biomes;
  this.pos=pos;
  this.previewAccess=previewAccess;
  this.globalX=this.pos.getXStart();
  this.globalZ=this.pos.getZStart();
}",0.8370044052863436
175382,"public void buildBlocks(BufferBuilder builder){
  builder.begin(GL11.GL_QUADS,TerrariumVertexFormats.POSITION_COLOR_NORMAL);
  ChunkPrimer chunk=this.chunk;
  IBlockAccess previewAccess=this.previewAccess;
  int globalX=this.pos.x << 4;
  int globalZ=this.pos.z << 4;
  BlockPos.MutableBlockPos pos=new BlockPos.MutableBlockPos();
  for (int z=0; z < 16; z++) {
    for (int x=0; x < 16; x++) {
      Biome biome=this.biomes[x + z * 16];
      for (int y=0; y < 256; y++) {
        IBlockState state=chunk.getBlockState(x,y,z);
        if (state.getBlock() != Blocks.AIR) {
          pos.setPos(globalX + x,y,globalZ + z);
          List<EnumFacing> faces=new ArrayList<>(6);
          for (          EnumFacing facing : PREVIEW_FACES) {
            BlockPos offset=pos.offset(facing);
            IBlockState neighbourState;
            if (x > 0 && x < 15 && z > 0 && z < 15 && y > 0 && y < 255) {
              neighbourState=chunk.getBlockState(offset.getX() & 15,offset.getY(),offset.getZ() & 15);
            }
 else {
              neighbourState=previewAccess.getBlockState(offset);
            }
            if (neighbourState.getBlock() == Blocks.AIR) {
              faces.add(facing);
            }
          }
          if (!faces.isEmpty()) {
            this.buildFaces(builder,faces,state,biome,pos);
          }
        }
      }
    }
  }
  builder.setTranslation(0.0,0.0,0.0);
}","public void buildBlocks(BufferBuilder builder){
  builder.begin(GL11.GL_QUADS,TerrariumVertexFormats.POSITION_COLOR_NORMAL);
  ChunkPrimer chunk=this.chunk;
  IBlockAccess previewAccess=this.previewAccess;
  int globalX=this.globalX;
  int globalZ=this.globalZ;
  BlockPos.MutableBlockPos pos=new BlockPos.MutableBlockPos();
  for (int z=0; z < 16; z++) {
    for (int x=0; x < 16; x++) {
      Biome biome=this.biomes[x + z * 16];
      for (int y=0; y < 256; y++) {
        IBlockState state=chunk.getBlockState(x,y,z);
        if (state.getBlock() != Blocks.AIR) {
          pos.setPos(globalX + x,y,globalZ + z);
          List<EnumFacing> faces=new ArrayList<>(6);
          for (          EnumFacing facing : PREVIEW_FACES) {
            BlockPos offset=pos.offset(facing);
            IBlockState neighbourState;
            if (x > 0 && x < 15 && z > 0 && z < 15 && y > 0 && y < 255) {
              neighbourState=chunk.getBlockState(offset.getX() & 15,offset.getY(),offset.getZ() & 15);
            }
 else {
              neighbourState=previewAccess.getBlockState(offset);
            }
            if (neighbourState.getBlock() == Blocks.AIR) {
              faces.add(facing);
            }
          }
          if (!faces.isEmpty()) {
            this.buildFaces(builder,faces,state,biome,pos,x,z);
          }
        }
      }
    }
  }
  builder.setTranslation(0.0,0.0,0.0);
}",0.9863896848137536
175383,"public void render(WorldPreview preview,float zoom,float rotationX,float rotationY){
  this.renderBackground();
  if (preview != null) {
    ScaledResolution resolution=new ScaledResolution(MC);
    double scaleFactor=resolution.getScaleFactor();
    BlockPos centerPos=preview.getCenterBlockPos();
    GlStateManager.pushMatrix();
    GlStateManager.scale(scaleFactor,scaleFactor,scaleFactor);
    GL11.glEnable(GL11.GL_SCISSOR_TEST);
    GuiRenderUtils.scissor(this.x,this.y,this.width,this.height);
    GlStateManager.enableRescaleNormal();
    GlStateManager.disableTexture2D();
    GlStateManager.enableDepth();
    GlStateManager.translate(this.gui.width / scaleFactor / 2.0,(this.y + this.height / 2) / scaleFactor,0.0);
    GlStateManager.scale(zoom,-zoom,zoom);
    GlStateManager.rotate(rotationX,1.0F,0.0F,0.0F);
    GlStateManager.rotate(rotationY,0.0F,1.0F,0.0F);
    GlStateManager.translate(-centerPos.getX(),-preview.getHeightOffset(),-centerPos.getZ());
    RenderHelper.enableStandardItemLighting();
    preview.render();
    GlStateManager.disableLighting();
    GlStateManager.disableDepth();
    GlStateManager.enableTexture2D();
    GlStateManager.disableRescaleNormal();
    GL11.glDisable(GL11.GL_SCISSOR_TEST);
    GlStateManager.popMatrix();
  }
}","public void render(WorldPreview preview,float zoom,float rotationX,float rotationY){
  this.renderBackground();
  if (preview != null) {
    ScaledResolution resolution=new ScaledResolution(MC);
    double scaleFactor=resolution.getScaleFactor();
    GlStateManager.pushMatrix();
    GlStateManager.scale(scaleFactor,scaleFactor,scaleFactor);
    GL11.glEnable(GL11.GL_SCISSOR_TEST);
    GuiRenderUtils.scissor(this.x,this.y,this.width,this.height);
    GlStateManager.enableRescaleNormal();
    GlStateManager.disableTexture2D();
    GlStateManager.enableDepth();
    GlStateManager.translate(this.gui.width / scaleFactor / 2.0,(this.y + this.height / 2) / scaleFactor,0.0);
    GlStateManager.scale(zoom,-zoom,zoom);
    GlStateManager.rotate(rotationX,1.0F,0.0F,0.0F);
    GlStateManager.rotate(rotationY,0.0F,1.0F,0.0F);
    GlStateManager.translate(0.0,-preview.getHeightOffset(),0.0);
    RenderHelper.enableStandardItemLighting();
    preview.render();
    GlStateManager.disableLighting();
    GlStateManager.disableDepth();
    GlStateManager.enableTexture2D();
    GlStateManager.disableRescaleNormal();
    GL11.glDisable(GL11.GL_SCISSOR_TEST);
    GlStateManager.popMatrix();
  }
}",0.9626926196269262
175384,"public void render(){
  List<PreviewChunk> previewChunks=this.previewChunks;
  if (previewChunks != null) {
    this.performUploads(previewChunks);
    for (    PreviewChunk chunk : previewChunks) {
      chunk.render();
    }
  }
}","public void render(){
  List<PreviewChunk> previewChunks=this.previewChunks;
  if (previewChunks != null) {
    this.performUploads(previewChunks);
    for (    PreviewChunk chunk : previewChunks) {
      chunk.render(this.centerBlockPos.getX(),this.centerBlockPos.getZ());
    }
  }
}",0.8974854932301741
175385,"@Override public void adapt(EarthGenerationSettings settings,RegionData data,int x,int z,int width,int height){
  OverpassTileAccess overpassTile=data.getOverpassTile();
  short[] heightBuffer=data.getHeights();
  GlobType[] globBuffer=data.getGlobcover();
  List<OverpassSource.Element> coastlines=overpassTile.getElements().stream().filter(element -> element.isType(""String_Node_Str"",""String_Node_Str"")).collect(Collectors.toList());
  if (!coastlines.isEmpty()) {
    int[] landmap=new int[width * height];
    for (int i=0; i < landmap.length; i++) {
      landmap[i]=globBuffer[i] == GlobType.WATER ? OCEAN : LAND;
    }
    Object2IntMap<FloodFill.Point> floodPoints=new Object2IntOpenHashMap<>();
    for (    OverpassSource.Element coastline : coastlines) {
      List<OverpassSource.Element> nodes=coastline.collectNodes(overpassTile);
      for (int nodeIndex=1; nodeIndex < nodes.size(); nodeIndex++) {
        OverpassSource.Element current=nodes.get(nodeIndex - 1);
        OverpassSource.Element next=nodes.get(nodeIndex);
        Coordinate currentCoordinate=Coordinate.fromLatLng(settings,current.getLatitude(),current.getLongitude());
        double originX=currentCoordinate.getBlockX();
        double originZ=currentCoordinate.getBlockZ();
        Coordinate nextCoordinate=Coordinate.fromLatLng(settings,next.getLatitude(),next.getLongitude());
        while (Math.abs(nextCoordinate.getBlockX() - originX) < 3.0 && Math.abs(nextCoordinate.getBlockZ() - originZ) < 3.0) {
          if (++nodeIndex >= nodes.size()) {
            break;
          }
          OverpassSource.Element node=nodes.get(nodeIndex);
          nextCoordinate=Coordinate.fromLatLng(settings,node.getLatitude(),node.getLongitude());
        }
        double targetX=nextCoordinate.getBlockX();
        double targetZ=nextCoordinate.getBlockZ();
        int lineType=this.getLineType(currentCoordinate,nextCoordinate);
        int coastType=lineType & 252;
        List<Point> points=new ArrayList<>();
        Interpolation.interpolateLine(originX,originZ,targetX,targetZ,false,point -> {
          int localX=point.x - x;
          int localZ=point.y - z;
          if (localX >= 0 && localZ >= 0 && localX < width && localZ < height) {
            landmap[localX + localZ * width]=lineType;
            this.freeNeighbours(width,height,landmap,localX,localZ);
            points.add(point);
          }
        }
);
        if (points.size() > 2) {
          for (int i=1; i < points.size() - 1; i++) {
            Point point=points.get(i);
            int localX=point.x - x;
            int localZ=point.y - z;
            if (coastType != 0) {
              if (localX > 0) {
                int left=coastType == COAST_UP ? LAND : OCEAN;
                floodPoints.put(new FloodFill.Point(localX - 1,localZ),left);
              }
              if (localX < width - 1) {
                int right=coastType == COAST_UP ? OCEAN : LAND;
                floodPoints.put(new FloodFill.Point(localX + 1,localZ),right);
              }
            }
          }
        }
      }
    }
    for (    Map.Entry<FloodFill.Point,Integer> entry : floodPoints.entrySet()) {
      FloodFill.Point point=entry.getKey();
      int floodType=entry.getValue();
      int sampled=landmap[point.getX() + point.getZ() * width];
      FillVisitor visitor=new FillVisitor(floodType);
      if (visitor.canVisit(sampled)) {
        FloodFill.floodVisit(landmap,width,height,point,visitor);
      }
    }
    List<FloodFill.Point> unselectedPoints=new LinkedList<>();
    for (int i=0; i < globBuffer.length; i++) {
      GlobType glob=globBuffer[i];
      int landType=landmap[i] & 3;
      if (landType == OCEAN) {
        globBuffer[i]=GlobType.WATER;
        heightBuffer[i]=1;
      }
 else       if (glob == GlobType.WATER) {
        globBuffer[i]=GlobType.UNSELECTED;
        unselectedPoints.add(new FloodFill.Point(i % width,i / width));
      }
    }
    for (    FloodFill.Point point : unselectedPoints) {
      GlobSelectVisitor visitor=new GlobSelectVisitor();
      FloodFill.floodVisit(globBuffer,width,height,point,visitor);
      globBuffer[point.getX() + point.getZ() * width]=visitor.getResult();
    }
  }
}","@Override public void adapt(EarthGenerationSettings settings,RegionData data,int x,int z,int width,int height){
  OverpassTileAccess overpassTile=data.getOverpassTile();
  short[] heightBuffer=data.getHeights();
  GlobType[] globBuffer=data.getGlobcover();
  List<OverpassSource.Element> coastlines=overpassTile.getElements().stream().filter(element -> element.isType(""String_Node_Str"",""String_Node_Str"")).collect(Collectors.toList());
  if (!coastlines.isEmpty()) {
    int[] landmap=new int[width * height];
    for (int i=0; i < landmap.length; i++) {
      landmap[i]=globBuffer[i] == GlobType.WATER ? OCEAN : LAND;
    }
    Object2IntMap<FloodFill.Point> floodPoints=new Object2IntOpenHashMap<>();
    for (    OverpassSource.Element coastline : coastlines) {
      List<OverpassSource.Element> nodes=coastline.collectNodes(overpassTile);
      for (int nodeIndex=1; nodeIndex < nodes.size(); nodeIndex++) {
        OverpassSource.Element current=nodes.get(nodeIndex - 1);
        OverpassSource.Element next=nodes.get(nodeIndex);
        Coordinate currentCoordinate=Coordinate.fromLatLng(settings,current.getLatitude(),current.getLongitude());
        double originX=currentCoordinate.getBlockX();
        double originZ=currentCoordinate.getBlockZ();
        Coordinate nextCoordinate=Coordinate.fromLatLng(settings,next.getLatitude(),next.getLongitude());
        while (Math.abs(nextCoordinate.getBlockX() - originX) < 3.0 && Math.abs(nextCoordinate.getBlockZ() - originZ) < 3.0) {
          if (++nodeIndex >= nodes.size()) {
            break;
          }
          OverpassSource.Element node=nodes.get(nodeIndex);
          nextCoordinate=Coordinate.fromLatLng(settings,node.getLatitude(),node.getLongitude());
        }
        double targetX=nextCoordinate.getBlockX();
        double targetZ=nextCoordinate.getBlockZ();
        int lineType=this.getLineType(currentCoordinate,nextCoordinate);
        int coastType=lineType & 252;
        List<Point> points=new ArrayList<>();
        Interpolation.interpolateLine(originX,originZ,targetX,targetZ,false,point -> {
          int localX=point.x - x;
          int localZ=point.y - z;
          if (localX >= 0 && localZ >= 0 && localX < width && localZ < height) {
            landmap[localX + localZ * width]=lineType;
            this.freeNeighbours(width,height,landmap,localX,localZ);
            points.add(point);
          }
        }
);
        if (points.size() > 2) {
          for (int i=1; i < points.size() - 1; i++) {
            Point point=points.get(i);
            int localX=point.x - x;
            int localZ=point.y - z;
            if (coastType != 0) {
              if (localX > 0) {
                int left=coastType == COAST_UP ? LAND : OCEAN;
                floodPoints.put(new FloodFill.Point(localX - 1,localZ),left);
              }
              if (localX < width - 1) {
                int right=coastType == COAST_UP ? OCEAN : LAND;
                floodPoints.put(new FloodFill.Point(localX + 1,localZ),right);
              }
            }
          }
        }
      }
    }
    for (    Map.Entry<FloodFill.Point,Integer> entry : floodPoints.entrySet()) {
      FloodFill.Point point=entry.getKey();
      int floodType=entry.getValue();
      int sampled=landmap[point.getX() + point.getZ() * width];
      FillVisitor visitor=new FillVisitor(floodType);
      if (visitor.canVisit(sampled)) {
        FloodFill.floodVisit(landmap,width,height,point,visitor);
      }
    }
    List<FloodFill.Point> unselectedPoints=new LinkedList<>();
    for (int i=0; i < globBuffer.length; i++) {
      GlobType glob=globBuffer[i];
      int landType=landmap[i] & 3;
      if (landType == OCEAN) {
        if (globBuffer[i] != GlobType.WATER) {
          globBuffer[i]=GlobType.WATER;
          heightBuffer[i]=1;
        }
      }
 else       if (glob == GlobType.WATER) {
        globBuffer[i]=GlobType.UNSELECTED;
        unselectedPoints.add(new FloodFill.Point(i % width,i / width));
      }
    }
    for (    FloodFill.Point point : unselectedPoints) {
      GlobSelectVisitor visitor=new GlobSelectVisitor();
      FloodFill.floodVisit(globBuffer,width,height,point,visitor);
      globBuffer[point.getX() + point.getZ() * width]=visitor.getResult();
    }
  }
}",0.9887852673828356
175386,"@SubscribeEvent public void onLivingTick(LivingUpdateEvent evt){
  if (!evt.getEntity().world.isRemote && evt.getEntityLiving() instanceof EntityPlayer) {
    EntityPlayer player=(EntityPlayer)evt.getEntityLiving();
    PlayerData data=player.getCapability(PlayerData.CAPABILITY,null);
    Fortune f=data.getFortune();
    if (f != null) {
      if (f.canShouldBeAppliedNow(player)) {
        if (f.apply(player))         data.setFortune(null);
      }
    }
  }
}","@SubscribeEvent public void onLivingTick(PlayerTickEvent evt){
  if (!evt.player.world.isRemote && evt.phase == Phase.END) {
    PlayerData data=evt.player.getCapability(PlayerData.CAPABILITY,null);
    Fortune f=data.getFortune();
    if (f != null) {
      if (f.canShouldBeAppliedNow(evt.player)) {
        if (f.apply(evt.player))         data.setFortune(null);
      }
    }
  }
}",0.800942285041225
175387,"public boolean fortune(EntityPlayer reader){
  if (consumePower(1000,false)) {
    EntityLivingBase de=getDestinationEntity();
    if (de instanceof EntityPlayer)     return readFortune((EntityPlayer)de,reader);
 else     if (de == null && this.getDestinationPosition() == null)     return readFortune(reader,null);
 else {
      reader.sendStatusMessage(new TextComponentTranslation(""String_Node_Str""),true);
      return false;
    }
  }
  reader.sendStatusMessage(new TextComponentTranslation(""String_Node_Str""),true);
  return false;
}","public boolean fortune(EntityPlayer reader){
  if (consumePower(5000,false)) {
    EntityLivingBase de=getDestinationEntity();
    if (de instanceof EntityPlayer)     return readFortune((EntityPlayer)de,reader);
 else     if (de == null && this.getDestinationPosition() == null)     return readFortune(reader,null);
 else {
      reader.sendStatusMessage(new TextComponentTranslation(""String_Node_Str""),true);
      return false;
    }
  }
  reader.sendStatusMessage(new TextComponentTranslation(""String_Node_Str""),true);
  return false;
}",0.9981447124304268
175388,"private boolean readFortune(@Nonnull EntityPlayer endPlayer,@Nullable EntityPlayer externalReader){
  Fortune fortune=endPlayer.getCapability(PlayerData.CAPABILITY,null).getFortune();
  EntityPlayer messageRecpt=endPlayer;
  if (externalReader != null)   messageRecpt=externalReader;
  if (fortune != null) {
    messageRecpt.sendStatusMessage(new TextComponentTranslation(""String_Node_Str"",fortune.getLocalizedName(endPlayer)),true);
    return false;
  }
  List<Fortune> valid=Fortune.REGISTRY.getValues().parallelStream().filter(f -> f.canBeUsedFor(endPlayer)).collect(Collectors.toList());
  if (valid.size() == 0) {
    messageRecpt.sendStatusMessage(new TextComponentTranslation(""String_Node_Str""),true);
    return false;
  }
  int totalEntries=valid.parallelStream().mapToInt(f -> f.getDrawingWeight()).sum();
  final int draw=endPlayer.getRNG().nextInt(totalEntries);
  int current=0;
  for (  Fortune f : valid) {
    int entries=f.getDrawingWeight();
    if (current < draw && draw < current + entries) {
      fortune=f;
      break;
    }
    current+=entries;
  }
  endPlayer.getCapability(PlayerData.CAPABILITY,null).setFortune(fortune);
  endPlayer.sendStatusMessage(new TextComponentString(fortune.getLocalizedName(endPlayer)),true);
  if (externalReader != null) {
    externalReader.sendStatusMessage(new TextComponentTranslation(""String_Node_Str"",fortune.getLocalizedName(endPlayer)),false);
    locator=ItemStack.EMPTY;
  }
  return true;
}","private boolean readFortune(@Nonnull EntityPlayer endPlayer,@Nullable EntityPlayer externalReader){
  EntityPlayer messageRecpt=endPlayer;
  if (externalReader != null)   messageRecpt=externalReader;
  if (endPlayer.getDistanceSq(this.getPos()) > 25) {
    messageRecpt.sendStatusMessage(new TextComponentTranslation(""String_Node_Str""),true);
    return false;
  }
  Fortune fortune=endPlayer.getCapability(PlayerData.CAPABILITY,null).getFortune();
  if (fortune != null) {
    messageRecpt.sendStatusMessage(new TextComponentTranslation(""String_Node_Str"",fortune.getLocalizedName(endPlayer)),true);
    return false;
  }
  List<Fortune> valid=Fortune.REGISTRY.getValues().parallelStream().filter(f -> f.canBeUsedFor(endPlayer)).collect(Collectors.toList());
  if (valid.size() == 0) {
    messageRecpt.sendStatusMessage(new TextComponentTranslation(""String_Node_Str""),true);
    return false;
  }
  int totalEntries=valid.parallelStream().mapToInt(f -> f.getDrawingWeight()).sum();
  final int draw=endPlayer.getRNG().nextInt(totalEntries);
  int current=0;
  for (  Fortune f : valid) {
    int entries=f.getDrawingWeight();
    if (current < draw && draw < current + entries) {
      fortune=f;
      break;
    }
    current+=entries;
  }
  endPlayer.getCapability(PlayerData.CAPABILITY,null).setFortune(fortune);
  endPlayer.sendStatusMessage(new TextComponentString(fortune.getLocalizedName(endPlayer)),true);
  if (externalReader != null) {
    externalReader.sendStatusMessage(new TextComponentTranslation(""String_Node_Str"",fortune.getLocalizedName(endPlayer)),false);
    locator=ItemStack.EMPTY;
  }
  return true;
}",0.8817622287010042
175389,"private boolean applyBrew(EntityPlayer thrower,ItemStack is){
  if (consumePower(4000,false)) {
    EntityLivingBase de=getDestinationEntity();
    Tuple<BlockPos,Integer> dp=getDestinationPosition();
    if (is.getItem() == ModItems.brew_drinkable) {
      if (de != null)       applyPotion(de,is);
 else       return false;
    }
 else     if (is.getItem() instanceof ItemBrewBase) {
      if (dp != null && this.world.provider.getDimension() == dp.getSecond().intValue()) {
        launchPotion(is,dp,thrower);
      }
    }
 else     return false;
    locator=ItemStack.EMPTY;
    markDirty();
    return true;
  }
  return false;
}","private boolean applyBrew(EntityPlayer thrower,ItemStack is){
  EntityLivingBase de=getDestinationEntity();
  Tuple<BlockPos,Integer> dp=getDestinationPosition();
  if (is.getItem() == ModItems.brew_drinkable) {
    if (de != null) {
      int cost=(int)(10 * de.getDistance(pos.getX(),pos.getY(),pos.getZ()));
      if (de.dimension != this.world.provider.getDimension())       return false;
      if (consumePower(cost,false))       applyPotionEffectsToEntity(de,is);
 else       return false;
    }
 else     return false;
  }
 else   if (is.getItem() instanceof ItemBrewBase) {
    if (dp != null && this.world.provider.getDimension() == dp.getSecond().intValue()) {
      int cost=(int)(50 * dp.getFirst().getDistance(pos.getX(),pos.getY(),pos.getZ()));
      if (consumePower(cost,false))       launchBrew(is,dp,thrower);
 else       return false;
    }
 else     return false;
  }
 else   return false;
  locator=ItemStack.EMPTY;
  markDirty();
  return true;
}",0.6596009975062345
175390,"private void initData(){
  mAddressList=getIntent().getParcelableArrayListExtra(""String_Node_Str"");
  if (mAddressList == null || mAddressList.size() == 0) {
    ToastUtil.toastInCenter(getApplicationContext(),R.string.broke_news_location_failed);
  }
  mSharedPrefUtil=SharedPrefUtil.getInstance(this);
  mLastTimeAddress=mSharedPrefUtil.getString(Constants.LOCATION_ADDRESS_SP_KEY);
  mLinearLayoutManager=new LinearLayoutManager(this);
  mAddressListAdapter=new AddressListAdapter(mAddressList,mLastTimeAddress);
}","private void initData(){
  mAddressList=getIntent().getParcelableArrayListExtra(""String_Node_Str"");
  if (!isLocated()) {
    ToastUtil.toastInCenter(getApplicationContext(),R.string.broke_news_location_failed);
  }
  mSharedPrefUtil=SharedPrefUtil.getInstance(this);
  mLastTimeAddress=mSharedPrefUtil.getString(Constants.LOCATION_ADDRESS_SP_KEY);
  mLinearLayoutManager=new LinearLayoutManager(this);
  mAddressListAdapter=new AddressListAdapter(mAddressList,mLastTimeAddress);
}",0.939879759519038
175391,"@Override public void onClick(View v){
switch (v.getId()) {
case R.id.go_back_btn_address_list:
    Intent intent=new Intent();
  if (mLastTimeAddress != null) {
    if (mLastTimeAddress.equals(""String_Node_Str"")) {
      intent.putExtra(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      intent.putExtra(""String_Node_Str"",mLastTimeAddress);
    }
  }
setResult(0,intent);
finish();
break;
}
}","@Override public void onClick(View v){
switch (v.getId()) {
case R.id.go_back_btn_address_list:
    Intent intent=new Intent();
  if (isLocated() && mLastTimeAddress != null) {
    if (mLastTimeAddress.equals(""String_Node_Str"")) {
      intent.putExtra(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      intent.putExtra(""String_Node_Str"",mLastTimeAddress);
    }
  }
setResult(0,intent);
finish();
break;
}
}",0.98159509202454
175392,"public void clearTask(){
  berkeleyDBSeedManager.clear();
}","public VSCrawler clearTask(){
  berkeleyDBSeedManager.clear();
  return this;
}",0.7971014492753623
175393,"public void pushSeed(String seed){
  berkeleyDBSeedManager.addNewSeeds(Lists.newArrayList(new Seed(seed)));
}","public VSCrawler pushSeed(String seed){
  berkeleyDBSeedManager.addNewSeeds(Lists.newArrayList(new Seed(seed)));
  return this;
}",0.8823529411764706
175394,"public AnnotationProcessorBuilder registryBean(Class<? extends AbstractAutoProcessModel> clazz){
  allExtractors.put(clazz,new ModelExtractor(clazz,this));
  AnnotationSeedProcessor.MatchStrategy matchStrategy=judgeMatchStrategy(clazz);
  if (matchStrategy != null) {
    annotationSeedProcessors.add(new AnnotationSeedProcessor(clazz,this,matchStrategy));
  }
  return this;
}","public AnnotationProcessorBuilder registryBean(Class<? extends AbstractAutoProcessModel> clazz){
  if (allExtractors.containsKey(clazz)) {
    return this;
  }
  allExtractors.put(clazz,new ModelExtractor(clazz,this));
  AnnotationSeedProcessor.MatchStrategy matchStrategy=judgeMatchStrategy(clazz);
  if (matchStrategy != null) {
    annotationSeedProcessors.add(new AnnotationSeedProcessor(clazz,this,matchStrategy));
  }
  return this;
}",0.8788249694002448
175395,"public SeedProcessor build(){
  scan();
  for (  ModelExtractor modelExtractor : allExtractors.values()) {
    modelExtractor.init();
  }
  RouteProcessor routeProcessor=new RouteProcessor();
  for (  AnnotationSeedProcessor annotationSeedProcessor : annotationSeedProcessors) {
    routeProcessor.addRouter(annotationSeedProcessor);
  }
  return routeProcessor;
}","public SeedProcessor build(){
  if (allExtractors.size() == 0 || scanPackage.size() > 0) {
    scan();
  }
  if (allExtractors.size() == 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  for (  ModelExtractor modelExtractor : allExtractors.values()) {
    modelExtractor.init();
  }
  RouteProcessor routeProcessor=new RouteProcessor();
  for (  AnnotationSeedProcessor annotationSeedProcessor : annotationSeedProcessors) {
    routeProcessor.addRouter(annotationSeedProcessor);
  }
  return routeProcessor;
}",0.8179775280898877
175396,"/** 
 * 新产生的种子,如果入库,那么会消重。后加入的种子被reject
 * @param seeds 种子
 */
public void addNewSeeds(Collection<Seed> seeds){
  if (isClosed) {
    log.warn(""String_Node_Str"");
    return;
  }
  Multimap<String,Seed> segmentSeeds=HashMultimap.create();
  for (  Seed seed : seeds) {
    if (seed.getActiveTimeStamp() != null) {
      segmentSeeds.put(String.valueOf(segmentResolver.resolveSegmentKey(seed.getActiveTimeStamp())),seed);
    }
 else {
      segmentSeeds.put(defaultSegment,seed);
    }
  }
  int realAddSeedNumber=0;
  for (  Map.Entry<String,Collection<Seed>> entry : segmentSeeds.asMap().entrySet()) {
    Database runningSeedDatabase=null;
    Database finishedSeedDatabase=null;
    BloomFilter<Seed> bloomFilter=getOrCreate(entry.getKey());
    try {
      lockDBOperate();
      runningSeedDatabase=createOrGetDataBase(RUNNING_SEGMENT_PREFIX + entry.getKey());
      finishedSeedDatabase=createOrGetDataBase(FINISHED_SEGMENT_PREFIX + entry.getKey());
      for (      Seed seed : entry.getValue()) {
        if (bloomFilter.mightContain(seed)) {
          continue;
        }
        if (!StringUtils.equals(entry.getKey(),defaultSegment) && !allSegments.contains(Long.parseLong(entry.getKey()))) {
          allSegments.add(Long.parseLong(entry.getKey()));
          runningSegments.add(Long.parseLong(entry.getKey()));
        }
        DatabaseEntry key=new DatabaseEntry(seedKeyResolver.resolveSeedKey(seed).getBytes());
        DatabaseEntry valueEntry=new DatabaseEntry();
        if (runningSeedDatabase.get(null,key,valueEntry,LockMode.DEFAULT) == OperationStatus.SUCCESS || finishedSeedDatabase.get(null,key,valueEntry,LockMode.DEFAULT) == OperationStatus.SUCCESS) {
          continue;
        }
        DatabaseEntry value=new DatabaseEntry(VSCrawlerCommonUtil.transferSeedToString(seed).getBytes());
        runningSeedDatabase.putNoOverwrite(null,key,value);
        realAddSeedNumber++;
        bloomFilter.put(seed);
        if (isSeedEmpty.compareAndSet(true,false)) {
          if (seed.getActiveTimeStamp() == null) {
            vsCrawlerContext.getAutoEventRegistry().findEventDeclaring(FirstSeedPushEvent.class).firstSeed(vsCrawlerContext,seed);
          }
 else {
            vsCrawlerContext.getAutoEventRegistry().createDelayEventSender(FirstSeedPushEvent.class).sendDelay(seed.getActiveTimeStamp() - System.currentTimeMillis() + 10L).delegate().firstSeed(vsCrawlerContext,seed);
          }
        }
      }
      log.info(""String_Node_Str"",realAddSeedNumber);
    }
  finally {
      unlockDBOperate();
    }
  }
}","/** 
 * 新产生的种子,如果入库,那么会消重。后加入的种子被reject
 * @param seeds 种子
 */
public void addNewSeeds(Collection<Seed> seeds){
  if (isClosed) {
    log.warn(""String_Node_Str"");
    return;
  }
  Multimap<String,Seed> segmentSeeds=HashMultimap.create();
  for (  Seed seed : seeds) {
    if (seed.getActiveTimeStamp() != null) {
      segmentSeeds.put(String.valueOf(segmentResolver.resolveSegmentKey(seed.getActiveTimeStamp())),seed);
    }
 else {
      segmentSeeds.put(defaultSegment,seed);
    }
  }
  int realAddSeedNumber=0;
  for (  Map.Entry<String,Collection<Seed>> entry : segmentSeeds.asMap().entrySet()) {
    BloomFilter<Seed> bloomFilter=getOrCreate(entry.getKey());
    try {
      lockDBOperate();
      Database runningSeedDatabase=createOrGetDataBase(RUNNING_SEGMENT_PREFIX + entry.getKey());
      Database finishedSeedDatabase=createOrGetDataBase(FINISHED_SEGMENT_PREFIX + entry.getKey());
      for (      Seed seed : entry.getValue()) {
        if (bloomFilter.mightContain(seed)) {
          continue;
        }
        if (!StringUtils.equals(entry.getKey(),defaultSegment) && !allSegments.contains(Long.parseLong(entry.getKey()))) {
          allSegments.add(Long.parseLong(entry.getKey()));
          runningSegments.add(Long.parseLong(entry.getKey()));
        }
        DatabaseEntry key=new DatabaseEntry(seedKeyResolver.resolveSeedKey(seed).getBytes());
        DatabaseEntry valueEntry=new DatabaseEntry();
        if (runningSeedDatabase.get(null,key,valueEntry,LockMode.DEFAULT) == OperationStatus.SUCCESS || finishedSeedDatabase.get(null,key,valueEntry,LockMode.DEFAULT) == OperationStatus.SUCCESS) {
          continue;
        }
        DatabaseEntry value=new DatabaseEntry(VSCrawlerCommonUtil.transferSeedToString(seed).getBytes());
        runningSeedDatabase.putNoOverwrite(null,key,value);
        realAddSeedNumber++;
        bloomFilter.put(seed);
        if (isSeedEmpty.compareAndSet(true,false)) {
          if (seed.getActiveTimeStamp() == null) {
            vsCrawlerContext.getAutoEventRegistry().findEventDeclaring(FirstSeedPushEvent.class).firstSeed(vsCrawlerContext,seed);
          }
 else {
            vsCrawlerContext.getAutoEventRegistry().createDelayEventSender(FirstSeedPushEvent.class).sendDelay(seed.getActiveTimeStamp() - System.currentTimeMillis() + 10L).delegate().firstSeed(vsCrawlerContext,seed);
          }
        }
      }
      log.info(""String_Node_Str"",realAddSeedNumber);
    }
  finally {
      unlockDBOperate();
    }
  }
}",0.9807348560079444
175397,"@Override public XpathNode convert(final StringNode from){
  XpathNode ret=new XpathNode(from.getBaseUrl(),null);
  ret.setModel(new SipNodes(Lists.newLinkedList(Iterables.transform(from.createOrGetModel(),new Function<String,SIPNode>(){
    @Override public SIPNode apply(    String input){
      try {
        Document document=Jsoup.parse(input,from.getBaseUrl());
        if (document != null) {
          return SIPNode.e(document);
        }
      }
 catch (      Exception e) {
      }
      return SIPNode.t(input);
    }
  }
))));
  return ret;
}","@Override public XpathNode convert(final StringNode from){
  XpathNode ret=new XpathNode(from.getBaseUrl(),(String)null);
  ret.setModel(new SipNodes(Lists.newLinkedList(Iterables.transform(from.createOrGetModel(),new Function<String,SIPNode>(){
    @Override public SIPNode apply(    String input){
      try {
        Document document=Jsoup.parse(input,from.getBaseUrl());
        if (document != null) {
          return SIPNode.e(document);
        }
      }
 catch (      Exception e) {
      }
      return SIPNode.t(input);
    }
  }
))));
  return ret;
}",0.992844364937388
175398,"private static void registerXpath(){
  register(XpathNode.class,XpathNode.class,new NodeConvert<XpathNode,XpathNode>(){
    @Override public XpathNode convert(    XpathNode from){
      return from;
    }
  }
);
  register(JsonNode.class,XpathNode.class,new NodeConvert<JsonNode,XpathNode>(){
    @Override public XpathNode convert(    JsonNode from){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
  }
);
  register(RawNode.class,XpathNode.class,new NodeConvert<RawNode,XpathNode>(){
    @Override public XpathNode convert(    RawNode from){
      return new XpathNode(from.getBaseUrl(),from.getRawText());
    }
  }
);
  register(StringNode.class,XpathNode.class,new NodeConvert<StringNode,XpathNode>(){
    @Override public XpathNode convert(    final StringNode from){
      XpathNode ret=new XpathNode(from.getBaseUrl(),null);
      ret.setModel(new SipNodes(Lists.newLinkedList(Iterables.transform(from.createOrGetModel(),new Function<String,SIPNode>(){
        @Override public SIPNode apply(        String input){
          try {
            Document document=Jsoup.parse(input,from.getBaseUrl());
            if (document != null) {
              return SIPNode.e(document);
            }
          }
 catch (          Exception e) {
          }
          return SIPNode.t(input);
        }
      }
))));
      return ret;
    }
  }
);
}","private static void registerXpath(){
  register(XpathNode.class,XpathNode.class,new NodeConvert<XpathNode,XpathNode>(){
    @Override public XpathNode convert(    XpathNode from){
      return from;
    }
  }
);
  register(JsonNode.class,XpathNode.class,new NodeConvert<JsonNode,XpathNode>(){
    @Override public XpathNode convert(    JsonNode from){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
  }
);
  register(RawNode.class,XpathNode.class,new NodeConvert<RawNode,XpathNode>(){
    @Override public XpathNode convert(    RawNode from){
      return new XpathNode(from.getBaseUrl(),from.getRawText());
    }
  }
);
  register(StringNode.class,XpathNode.class,new NodeConvert<StringNode,XpathNode>(){
    @Override public XpathNode convert(    final StringNode from){
      XpathNode ret=new XpathNode(from.getBaseUrl(),(String)null);
      ret.setModel(new SipNodes(Lists.newLinkedList(Iterables.transform(from.createOrGetModel(),new Function<String,SIPNode>(){
        @Override public SIPNode apply(        String input){
          try {
            Document document=Jsoup.parse(input,from.getBaseUrl());
            if (document != null) {
              return SIPNode.e(document);
            }
          }
 catch (          Exception e) {
          }
          return SIPNode.t(input);
        }
      }
))));
      return ret;
    }
  }
);
}",0.9970909090909092
175399,"private static void registerJson(){
  register(JsonNode.class,JsonNode.class,new NodeConvert<JsonNode,JsonNode>(){
    @Override public JsonNode convert(    JsonNode from){
      return from;
    }
  }
);
  register(RawNode.class,JsonNode.class,new NodeConvert<RawNode,JsonNode>(){
    @Override public JsonNode convert(    RawNode from){
      return new JsonNode(from.getBaseUrl(),from.getRawText());
    }
  }
);
  register(StringNode.class,JsonNode.class,new NodeConvert<StringNode,JsonNode>(){
    @Override public JsonNode convert(    StringNode from){
      JsonNode jsonNode=new JsonNode(from.getBaseUrl(),null);
      jsonNode.setModel(Lists.transform(from.createOrGetModel(),new Function<String,JSON>(){
        @Override public JSON apply(        String input){
          return (JSON)JSON.parse(input);
        }
      }
));
      return jsonNode;
    }
  }
);
  register(XpathNode.class,JsonNode.class,new NodeConvert<XpathNode,JsonNode>(){
    @Override public JsonNode convert(    XpathNode from){
      JsonNode ret=new JsonNode(from.getBaseUrl(),null);
      ret.setModel(Lists.newLinkedList(Iterables.transform(Iterables.filter(from.createOrGetModel(),new Predicate<SIPNode>(){
        @Override public boolean apply(        SIPNode input){
          return input.isText();
        }
      }
),new Function<SIPNode,JSON>(){
        @Override public JSON apply(        SIPNode input){
          return (JSON)JSON.parse(input.getTextVal());
        }
      }
)));
      return ret;
    }
  }
);
}","private static void registerJson(){
  register(JsonNode.class,JsonNode.class,new NodeConvert<JsonNode,JsonNode>(){
    @Override public JsonNode convert(    JsonNode from){
      return from;
    }
  }
);
  register(RawNode.class,JsonNode.class,new NodeConvert<RawNode,JsonNode>(){
    @Override public JsonNode convert(    RawNode from){
      return new JsonNode(from.getBaseUrl(),from.getRawText());
    }
  }
);
  register(StringNode.class,JsonNode.class,new NodeConvert<StringNode,JsonNode>(){
    @Override public JsonNode convert(    StringNode from){
      JsonNode jsonNode=new JsonNode(from.getBaseUrl(),(String)null);
      jsonNode.setModel(Lists.transform(from.createOrGetModel(),new Function<String,JSON>(){
        @Override public JSON apply(        String input){
          return (JSON)JSON.parse(input);
        }
      }
));
      return jsonNode;
    }
  }
);
  register(XpathNode.class,JsonNode.class,new NodeConvert<XpathNode,JsonNode>(){
    @Override public JsonNode convert(    XpathNode from){
      JsonNode ret=new JsonNode(from.getBaseUrl(),(String)null);
      ret.setModel(Lists.newLinkedList(Iterables.transform(Iterables.filter(from.createOrGetModel(),new Predicate<SIPNode>(){
        @Override public boolean apply(        SIPNode input){
          return input.isText();
        }
      }
),new Function<SIPNode,JSON>(){
        @Override public JSON apply(        SIPNode input){
          return (JSON)JSON.parse(input.getTextVal());
        }
      }
)));
      return ret;
    }
  }
);
}",0.9947368421052633
175400,"public VSCrawlerBuilder addRouteProcessor(SeedRouter seedRouter){
  this.seedRouters.add(seedRouter);
  return this;
}","public VSCrawlerBuilder addRouteProcessor(BindRouteProcessor seedRouter){
  this.seedRouters.add(seedRouter);
  return this;
}",0.9426229508196722
175401,"@Override public void onSessionCreateEvent(CrawlerSession crawlerSession){
  if (!crawlerSession.isValid()) {
    return;
  }
  User user;
  while (true) {
    if ((user=userManager.allocateUser()) != null) {
      break;
    }
    CommonUtil.sleep(5000);
  }
  boolean loginSuccess=loginHandler.onLogin(user,crawlerSession.getCookieStore(),crawlerSession.getCrawlerHttpClient());
  if (loginSuccess) {
    UserUtil.setUser(crawlerSession,user);
  }
 else {
    userManager.returnUser(user);
    log.warn(""String_Node_Str"",user);
  }
}","@Override public void onSessionCreateEvent(CrawlerSession crawlerSession){
  if (!crawlerSession.isValid()) {
    return;
  }
  User user;
  while (true) {
    if ((user=userManager.allocateUser()) != null) {
      break;
    }
    CommonUtil.sleep(5000);
  }
  boolean loginSuccess=loginHandler.onLogin(user,crawlerSession.getCookieStore(),crawlerSession.getCrawlerHttpClient());
  if (loginSuccess) {
    UserUtil.setUser(crawlerSession,user);
  }
 else {
    userManager.returnUser(user);
    log.warn(""String_Node_Str"",JSONObject.toJSONString(user));
  }
}",0.96986301369863
175402,"@Override public void configChange(Properties oldProperties,Properties newProperties){
  String property=newProperties.getProperty(VSCrawlerConstant.USER_RESOURCE_USERINFO);
  hasConfig=property != null;
  if (property == null) {
    crawlerThreadNumber=NumberUtils.toInt(newProperties.getProperty(VSCrawlerConstant.VSCRAWLER_THREAD_NUMBER));
    return;
  }
  if (!property.equals(oldProperties.getProperty(VSCrawlerConstant.USER_RESOURCE_USERINFO))) {
    List<String> allUser=userSplitter.splitToList(property);
    int newUserNum=0;
    for (    String userStr : allUser) {
      User user=new User();
      List<String> strings=userItemSplitter.splitToList(userStr);
      if (strings.size() < 2) {
        log.warn(""String_Node_Str"",userStr);
        continue;
      }
      user.setUserID(strings.get(0));
      user.setPassword(strings.get(1));
      if (strings.size() >= 3) {
        String status=strings.get(2);
        if (StringUtils.equalsIgnoreCase(status,""String_Node_Str"")) {
          AutoEventRegistry.getInstance().findEventDeclaring(UserStateChangeEvent.class).userStatusChange(user,UserStatus.UNKNOWN,UserStatus.FORBID);
          continue;
        }
      }
      user.setUserStatus(UserStatus.INIT);
      userCache.add(user);
      newUserNum++;
    }
    log.info(""String_Node_Str"",newUserNum);
  }
}","@Override public void configChange(Properties oldProperties,Properties newProperties){
  String property=newProperties.getProperty(VSCrawlerConstant.USER_RESOURCE_USERINFO);
  hasConfig=property != null;
  if (property == null) {
    crawlerThreadNumber=NumberUtils.toInt(newProperties.getProperty(VSCrawlerConstant.VSCRAWLER_THREAD_NUMBER));
    return;
  }
  if (oldProperties != null && property.equals(oldProperties.getProperty(VSCrawlerConstant.USER_RESOURCE_USERINFO))) {
    return;
  }
  List<String> allUser=userSplitter.splitToList(property);
  int newUserNum=0;
  for (  String userStr : allUser) {
    User user=new User();
    List<String> strings=userItemSplitter.splitToList(userStr);
    if (strings.size() < 2) {
      log.warn(""String_Node_Str"",userStr);
      continue;
    }
    user.setUserID(strings.get(0));
    user.setPassword(strings.get(1));
    if (strings.size() >= 3) {
      String status=strings.get(2);
      if (StringUtils.equalsIgnoreCase(status,""String_Node_Str"")) {
        AutoEventRegistry.getInstance().findEventDeclaring(UserStateChangeEvent.class).userStatusChange(user,UserStatus.UNKNOWN,UserStatus.FORBID);
        continue;
      }
    }
    user.setUserStatus(UserStatus.INIT);
    userCache.add(user);
    newUserNum++;
  }
  log.info(""String_Node_Str"",newUserNum);
}",0.9666919000757004
175403,"public FilePipLine(String filepath) throws FileNotFoundException {
  this.filepath=filepath;
  printWriter=new PrintWriter(new FileOutputStream(new File(filepath)));
}","public FilePipLine(String filepath) throws FileNotFoundException {
  this.filepath=filepath;
  printWriter=new PrintWriter(new FileOutputStream(new File(filepath),true));
}",0.9852507374631267
175404,"private static void registerJson(){
  register(JsonNode.class,JsonNode.class,new NodeConvert<JsonNode,JsonNode>(){
    @Override public JsonNode convert(    JsonNode from){
      return from;
    }
  }
);
  register(RawNode.class,JsonNode.class,new NodeConvert<RawNode,JsonNode>(){
    @Override public JsonNode convert(    RawNode from){
      return new JsonNode(from.getBaseUrl(),from.getRawText());
    }
  }
);
  register(StringNode.class,JsonNode.class,new NodeConvert<StringNode,JsonNode>(){
    @Override public JsonNode convert(    StringNode from){
      JsonNode jsonNode=new JsonNode(from.getBaseUrl(),null);
      jsonNode.setModel(Lists.transform(from.createOrGetModel(),new Function<String,JSON>(){
        @Override public JSON apply(        String input){
          return (JSON)JSON.toJSON(input);
        }
      }
));
      return jsonNode;
    }
  }
);
  register(XpathNode.class,JsonNode.class,new NodeConvert<XpathNode,JsonNode>(){
    @Override public JsonNode convert(    XpathNode from){
      JsonNode ret=new JsonNode(from.getBaseUrl(),null);
      ret.setModel(Lists.newLinkedList(Iterables.transform(Iterables.filter(from.createOrGetModel(),new Predicate<SIPNode>(){
        @Override public boolean apply(        SIPNode input){
          return input.isText();
        }
      }
),new Function<SIPNode,JSON>(){
        @Override public JSON apply(        SIPNode input){
          return (JSON)JSON.parse(input.getTextVal());
        }
      }
)));
      return ret;
    }
  }
);
}","private static void registerJson(){
  register(JsonNode.class,JsonNode.class,new NodeConvert<JsonNode,JsonNode>(){
    @Override public JsonNode convert(    JsonNode from){
      return from;
    }
  }
);
  register(RawNode.class,JsonNode.class,new NodeConvert<RawNode,JsonNode>(){
    @Override public JsonNode convert(    RawNode from){
      return new JsonNode(from.getBaseUrl(),from.getRawText());
    }
  }
);
  register(StringNode.class,JsonNode.class,new NodeConvert<StringNode,JsonNode>(){
    @Override public JsonNode convert(    StringNode from){
      JsonNode jsonNode=new JsonNode(from.getBaseUrl(),null);
      jsonNode.setModel(Lists.transform(from.createOrGetModel(),new Function<String,JSON>(){
        @Override public JSON apply(        String input){
          return (JSON)JSON.parse(input);
        }
      }
));
      return jsonNode;
    }
  }
);
  register(XpathNode.class,JsonNode.class,new NodeConvert<XpathNode,JsonNode>(){
    @Override public JsonNode convert(    XpathNode from){
      JsonNode ret=new JsonNode(from.getBaseUrl(),null);
      ret.setModel(Lists.newLinkedList(Iterables.transform(Iterables.filter(from.createOrGetModel(),new Predicate<SIPNode>(){
        @Override public boolean apply(        SIPNode input){
          return input.isText();
        }
      }
),new Function<SIPNode,JSON>(){
        @Override public JSON apply(        SIPNode input){
          return (JSON)JSON.parse(input.getTextVal());
        }
      }
)));
      return ret;
    }
  }
);
}",0.9963636363636365
175405,"private SyntaxNode parseFunction(StringFunctionTokenQueue tokenQueue){
  String functionString=tokenQueue.consumeFunction();
  StringFunctionTokenQueue tempTokenQueue=new StringFunctionTokenQueue(functionString);
  String functionName=tempTokenQueue.consumeIdentify();
  StringFunction function=StringFunctionEnv.findFunction(functionName);
  if (function == null) {
    throw new IllegalStateException(""String_Node_Str"" + functionName);
  }
  tempTokenQueue.consumeWhitespace();
  if (tempTokenQueue.isEmpty() || tempTokenQueue.peek() != '(') {
    throw new IllegalStateException(""String_Node_Str"" + functionString + ""String_Node_Str"");
  }
  String paramsStr=tempTokenQueue.chompBalanced('(',')');
  StringFunctionTokenQueue paramTokenQueue=new StringFunctionTokenQueue(paramsStr);
  String parameter;
  List<SyntaxNode> params=Lists.newLinkedList();
  while ((parameter=paramTokenQueue.consumeIgnoreQuote(',')) != null) {
    params.add(new ExpressionParser(new StringFunctionTokenQueue(parameter)).parse());
  }
  return new FunctionSyntaxNode(function,params);
}","private SyntaxNode parseFunction(StringFunctionTokenQueue tokenQueue){
  String functionString=tokenQueue.consumeFunction();
  StringFunctionTokenQueue tempTokenQueue=new StringFunctionTokenQueue(functionString);
  String functionName=tempTokenQueue.consumeIdentify();
  StringFunction function=StringFunctionEnv.findFunction(functionName);
  if (function == null) {
    throw new IllegalStateException(""String_Node_Str"" + functionName);
  }
  tempTokenQueue.consumeWhitespace();
  if (tempTokenQueue.isEmpty() || tempTokenQueue.peek() != '(') {
    throw new IllegalStateException(""String_Node_Str"" + functionString + ""String_Node_Str"");
  }
  String paramsStr=StringUtils.trimToEmpty(tempTokenQueue.chompBalanced('(',')'));
  StringFunctionTokenQueue paramTokenQueue=new StringFunctionTokenQueue(paramsStr);
  String parameter;
  List<SyntaxNode> params=Lists.newLinkedList();
  while ((parameter=paramTokenQueue.consumeIgnoreQuote(',')) != null) {
    params.add(new ExpressionParser(new StringFunctionTokenQueue(parameter)).parse());
  }
  paramTokenQueue.consumeWhitespace();
  if (!paramTokenQueue.isEmpty()) {
    params.add(new ExpressionParser(new StringFunctionTokenQueue(paramTokenQueue.remainder())).parse());
  }
  return new FunctionSyntaxNode(function,params);
}",0.9108742004264392
175406,"public String consumeFunction(){
  String functionName=consumeTo(""String_Node_Str"");
  String params=chompBalanced('(',')');
  return functionName + ""String_Node_Str"" + params+ ""String_Node_Str"";
}","public String consumeFunction(){
  String functionName=consumeTo(""String_Node_Str"");
  String params=chompBalanced('(',')');
  return functionName + ""String_Node_Str"" + (params == null ? ""String_Node_Str"" : params)+ ""String_Node_Str"";
}",0.8822170900692841
175407,"static public PImage createSprite(PApplet papplet,int size,float exp1,float exp2,float mult){
  size=Math.max(32,size);
  PImage pimg=papplet.createImage(size,size,PConstants.ARGB);
  pimg.loadPixels();
  for (int y=0; y < size; y++) {
    for (int x=0; x < size; x++) {
      int pid=y * size + x;
      float xn=(x / (float)size) * 2f - 1f;
      float yn=(y / (float)size) * 2f - 1f;
      float dd=(float)Math.sqrt(xn * xn + yn * yn);
      if (dd < 0)       dd=0;
 else       if (dd > 1)       dd=1;
      dd=(float)Math.pow(dd,exp1);
      dd=1.0f - dd;
      dd=(float)Math.pow(dd,exp2);
      dd*=mult;
      pimg.pixels[pid]=((int)(dd * 255)) << 24 | 0x00FFFFFF;
    }
  }
  pimg.updatePixels();
  return pimg;
}","static public PImage createSprite(PApplet papplet,int size,float exp1,float exp2,float mult){
  size=Math.max(32,size);
  PImage pimg=papplet.createImage(size,size,PConstants.ARGB);
  pimg.loadPixels();
  for (int y=0; y < size; y++) {
    for (int x=0; x < size; x++) {
      int pid=y * size + x;
      float xn=(x / (float)size) * 2f - 1f;
      float yn=(y / (float)size) * 2f - 1f;
      float dd=(float)Math.sqrt(xn * xn + yn * yn);
      dd=DwUtils.clamp(dd,0,1);
      dd=(float)Math.pow(dd,exp1);
      dd=1.0f - dd;
      dd=(float)Math.pow(dd,exp2);
      dd*=mult;
      dd=DwUtils.clamp(dd,0,1);
      pimg.pixels[pid]=((int)(dd * 255)) << 24 | 0x00FFFFFF;
    }
  }
  pimg.updatePixels();
  return pimg;
}",0.7791666666666667
175408,"@Override public boolean reportFixture(Fixture argFixture){
  Body body=argFixture.getBody();
  body_type_cpy=body.getType();
  if (enable_static_drag) {
    body.setType(BodyType.DYNAMIC);
  }
  if (body.getType() == BodyType.DYNAMIC) {
    if (argFixture.testPoint(point)) {
      fixture=argFixture;
      return false;
    }
  }
  return true;
}","@Override public boolean reportFixture(Fixture argFixture){
  Body body=argFixture.getBody();
  BodyType type=body.getType();
  if (BodyType.DYNAMIC == type || enable_static_drag) {
    if (argFixture.testPoint(point)) {
      body_type_cpy=type;
      fixture=argFixture;
      body.setType(BodyType.DYNAMIC);
      return false;
    }
  }
  return true;
}",0.5835694050991501
175409,"@Test public void testLoaderIsFound() throws ClassNotFoundException, IOException, IllegalAccessException, InstantiationException, JAXBException {
  String pathToLocalJar=System.getProperty(""String_Node_Str"");
  JarScanner collectorFinder=new JarScanner(ClassLoader.getSystemClassLoader(),pathToLocalJar);
  collectorFinder.scanJar();
  MonitorStatusCollectorLoader loader=collectorFinder.getStatusCollectorLoader();
  Assert.assertNotNull(loader);
}","@Test(enabled=false) public void testLoaderIsFound() throws ClassNotFoundException, IOException, IllegalAccessException, InstantiationException, JAXBException {
  String pathToLocalJar=System.getProperty(""String_Node_Str"");
  JarScanner collectorFinder=new JarScanner(ClassLoader.getSystemClassLoader(),pathToLocalJar);
  collectorFinder.scanJar();
  MonitorStatusCollectorLoader loader=collectorFinder.getStatusCollectorLoader();
  Assert.assertNotNull(loader);
}",0.9835706462212488
175410,"/** 
 * @return a new map with the names and values provided as fileInfo when the file was uploaded.
 * @apiNote the map may be empty, but it will never be null.
 */
default Map<String,String> getB2FileInfo(){
  final Map<String,String> info=new TreeMap<>();
  for (  String name : getNames()) {
    if (startsWithIgnoreCase(name,FILE_INFO_PREFIX)) {
      final String shortName=name.substring(FILE_INFO_PREFIX.length());
      info.put(shortName,getValueOrNull(name));
    }
  }
  return info;
}","/** 
 * @return a new map with the names and values provided as fileInfo when the file was uploaded.
 * @apiNote the map may be empty, but it will never be null.
 */
default Map<String,String> getB2FileInfo(){
  final Map<String,String> info=new TreeMap<>();
  for (  String name : getNames()) {
    if (startsWithIgnoreCase(name,FILE_INFO_PREFIX)) {
      final String shortName=name.substring(FILE_INFO_PREFIX.length());
      info.put(percentDecode(shortName),percentDecode(getValueOrNull(name)));
    }
  }
  return info;
}",0.953125
175411,"@Test public void testGetFileInfoByName() throws B2Exception {
  final B2GetFileInfoByNameRequest request=B2GetFileInfoByNameRequest.builder(bucketName(1),fileName(1)).build();
  B2FileVersion version=webifier.getFileInfoByName(ACCOUNT_AUTH,request);
  assertEquals(fileId(1),version.getFileId());
  assertEquals(fileName(1),version.getFileName());
  assertEquals(1L,version.getContentLength());
  assertEquals(1L,version.getUploadTimestamp());
  assertEquals(1L,Long.parseLong(version.getFileInfo().get(B2Headers.SRC_LAST_MODIFIED_MILLIS)));
  webApiClient.check(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkRequestCategory(OTHER,w -> w.getFileInfoByName(ACCOUNT_AUTH,request));
}","@Test public void testGetFileInfoByName() throws B2Exception {
  final B2GetFileInfoByNameRequest request=B2GetFileInfoByNameRequest.builder(bucketName(1),fileName(1)).build();
  B2FileVersion version=webifier.getFileInfoByName(ACCOUNT_AUTH,request);
  Map<String,String> expectedFileInfo=new HashMap<>();
  expectedFileInfo.put(""String_Node_Str"",""String_Node_Str"");
  expectedFileInfo.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(fileId(1),version.getFileId());
  assertEquals(fileName(1),version.getFileName());
  assertEquals(1L,version.getContentLength());
  assertEquals(1L,version.getUploadTimestamp());
  assertEquals(expectedFileInfo,version.getFileInfo());
  assertEquals(1L,Long.parseLong(version.getFileInfo().get(""String_Node_Str"")));
  webApiClient.check(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkRequestCategory(OTHER,w -> w.getFileInfoByName(ACCOUNT_AUTH,request));
}",0.8399098083427283
175412,"public static B2Headers makeFileHeaders(int i){
  return B2HeadersImpl.builder().set(FILE_ID,fileId(i)).set(FILE_NAME,percentEncode(fileName(i))).set(CONTENT_LENGTH,Integer.toString(i)).set(UPLOAD_TIMESTAMP,Integer.toString(i)).set(FILE_INFO_PREFIX + SRC_LAST_MODIFIED_MILLIS,Integer.toString(i)).build();
}","public static B2Headers makeFileHeaders(int i){
  return B2HeadersImpl.builder().set(FILE_ID,fileId(i)).set(FILE_NAME,percentEncode(fileName(i))).set(CONTENT_LENGTH,Integer.toString(i)).set(UPLOAD_TIMESTAMP,Integer.toString(i)).set(SRC_LAST_MODIFIED_MILLIS,Integer.toString(i)).set(FILE_INFO_PREFIX + ""String_Node_Str"",""String_Node_Str"").build();
}",0.8030534351145038
175413,"@Override public B2FileVersion getFileInfoByName(B2AccountAuthorization accountAuth,B2GetFileInfoByNameRequest request) throws B2Exception {
  B2Headers headers=webApiClient.head(makeGetFileInfoByNameUrl(accountAuth,request.getBucketName(),request.getFileName()),makeHeaders(accountAuth));
  return new B2FileVersion(headers.getValueOrNull(FILE_ID),headers.getValueOrNull(FILE_NAME),headers.getContentLength(),headers.getContentType(),headers.getContentSha1OrNull(),headers.getB2FileInfo(),""String_Node_Str"",Long.parseLong(headers.getValueOrNull(UPLOAD_TIMESTAMP)));
}","@Override public B2FileVersion getFileInfoByName(B2AccountAuthorization accountAuth,B2GetFileInfoByNameRequest request) throws B2Exception {
  B2Headers headers=webApiClient.head(makeGetFileInfoByNameUrl(accountAuth,request.getBucketName(),request.getFileName()),makeHeaders(accountAuth));
  return new B2FileVersion(headers.getValueOrNull(FILE_ID),percentDecode(headers.getValueOrNull(FILE_NAME)),headers.getContentLength(),headers.getContentType(),headers.getContentSha1OrNull(),headers.getB2FileInfo(),""String_Node_Str"",Long.parseLong(headers.getValueOrNull(UPLOAD_TIMESTAMP)));
}",0.9869678540399652
175414,"public static B2Headers makeFileHeaders(int i){
  return B2HeadersImpl.builder().set(FILE_ID,fileId(i)).set(FILE_NAME,fileName(i)).set(CONTENT_LENGTH,Integer.toString(i)).set(UPLOAD_TIMESTAMP,Integer.toString(i)).set(FILE_INFO_PREFIX + SRC_LAST_MODIFIED_MILLIS,Integer.toString(i)).build();
}","public static B2Headers makeFileHeaders(int i){
  return B2HeadersImpl.builder().set(FILE_ID,fileId(i)).set(FILE_NAME,percentEncode(fileName(i))).set(CONTENT_LENGTH,Integer.toString(i)).set(UPLOAD_TIMESTAMP,Integer.toString(i)).set(FILE_INFO_PREFIX + SRC_LAST_MODIFIED_MILLIS,Integer.toString(i)).build();
}",0.9749582637729548
175415,"public Builder(B2ListUnfinishedLargeFilesRequest orig){
  this.bucketId=orig.bucketId;
  this.startFileId=orig.startFileId;
  this.maxFileCount=orig.maxFileCount;
}","public Builder(B2ListUnfinishedLargeFilesRequest orig){
  this.bucketId=orig.bucketId;
  this.namePrefix=orig.namePrefix;
  this.startFileId=orig.startFileId;
  this.maxFileCount=orig.maxFileCount;
}",0.9035812672176308
175416,"private void changeDarkTheme(boolean isDarkThemeEnabled){
  mTinyDB.putBoolean(getString(R.string.dark_theme_pref),isDarkThemeEnabled);
  recreate();
}","private void changeDarkTheme(boolean isDarkThemeEnabled){
  mTinyDB.putBoolean(getString(R.string.dark_theme_pref),isDarkThemeEnabled);
  Intent intent=getIntent();
  finish();
  startActivity(intent);
}",0.807909604519774
175417,"public MyViewHolder(View view){
  super(view);
  txtView=(TextView)view.findViewById(R.id.txtView);
  tabTag=(TextView)view.findViewById(R.id.tabTag);
  priorityTag=view.findViewById(R.id.priorityTag);
}","MyViewHolder(View view){
  super(view);
  txtView=(TextView)view.findViewById(R.id.txtView);
  tabTag=(TextView)view.findViewById(R.id.tabTag);
  priorityTag=view.findViewById(R.id.priorityTag);
}",0.9824561403508772
175418,"public void setIdeaText(String ideaText){
  mIdea=ideaText;
}","void setIdeaText(String ideaText){
  mIdea=ideaText;
}",0.9391304347826088
175419,"public void setLongClickListener(View.OnLongClickListener l){
  mListener=l;
}","void setLongClickListener(View.OnLongClickListener l){
  mListener=l;
}",0.953020134228188
175420,"@Override public void onBindViewHolder(final MyViewHolder holder,final int position){
  holder.priorityTag.setVisibility(View.GONE);
  holder.tabTag.setVisibility(View.GONE);
  LinearLayout container=(LinearLayout)holder.txtView.getParent();
  DatabaseHelper helper=DatabaseHelper.getInstance(mRecyclerView.getContext());
  if (mBigtext) {
    holder.txtView.setTextSize(22);
  }
 else {
    holder.txtView.setTextSize(18);
  }
  int tab=mTabNumber;
  if (mTabNumber == 4) {
    tab=helper.getTabById((int)mRecyclerView.getTag());
    if (position == 1) {
      holder.tabTag.setVisibility(View.VISIBLE);
      if (mDarkTheme) {
        holder.tabTag.setTextColor(Color.WHITE);
      }
 else {
        holder.tabTag.setTextColor(Color.BLACK);
      }
switch (tab) {
case 1:
        holder.tabTag.setText(R.string.first_tab);
      break;
case 2:
    holder.tabTag.setText(R.string.second_tab);
  break;
case 3:
holder.tabTag.setText(R.string.third_tab);
break;
}
}
}
switch (tab) {
case 1:
switch (position) {
case 0:
holder.txtView.setText(R.string.done_caps);
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.END);
container.setBackgroundResource(R.color.md_green_a400);
holder.txtView.setTextColor(Color.WHITE);
break;
case 1:
holder.txtView.setSingleLine();
holder.txtView.setText(mIdea);
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.START);
if (mDarkTheme) {
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
container.setBackgroundResource(R.drawable.grey_ripple);
}
 else {
container.setBackgroundResource(R.color.md_blue_grey_800);
}
holder.txtView.setTextColor(Color.WHITE);
}
 else {
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
container.setBackgroundResource(R.drawable.white_ripple);
}
 else {
container.setBackgroundResource(R.color.white);
}
holder.txtView.setTextColor(Color.BLACK);
}
RecyclerOnClickListener listener=new RecyclerOnClickListener(mRecyclerView,mTabNumber);
container.setOnClickListener(listener);
container.setOnLongClickListener(mListener);
holder.priorityTag.setVisibility(View.VISIBLE);
holder.priorityTag.setBackgroundResource(helper.getPriorityColorById((int)mRecyclerView.getTag()));
break;
case 2:
holder.txtView.setText(R.string.later);
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.START);
container.setBackgroundResource(R.color.md_pink_a400);
holder.txtView.setTextColor(Color.WHITE);
break;
}
break;
case 2:
switch (position) {
case 0:
holder.txtView.setText(R.string.now);
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.END);
container.setBackgroundResource(R.color.md_indigo_a400);
holder.txtView.setTextColor(Color.WHITE);
break;
case 1:
holder.txtView.setSingleLine();
holder.txtView.setText(mIdea);
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.START);
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
container.setBackgroundResource(R.drawable.white_ripple);
}
 else {
container.setBackgroundResource(R.color.white);
}
holder.txtView.setTextColor(Color.DKGRAY);
RecyclerOnClickListener listener=new RecyclerOnClickListener(mRecyclerView,mTabNumber);
container.setOnClickListener(listener);
container.setOnLongClickListener(mListener);
holder.priorityTag.setVisibility(View.VISIBLE);
holder.priorityTag.setBackgroundResource(helper.getPriorityColorById((int)mRecyclerView.getTag()));
break;
case 2:
holder.txtView.setText(R.string.delete);
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.START);
container.setBackgroundResource(R.color.red);
holder.txtView.setTextColor(Color.WHITE);
break;
}
break;
case 3:
switch (position) {
case 0:
holder.txtView.setText(R.string.recover);
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.END);
container.setBackgroundResource(R.color.md_indigo_a400);
holder.txtView.setTextColor(Color.WHITE);
break;
case 1:
holder.txtView.setSingleLine();
holder.txtView.setText(mIdea);
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.START);
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
container.setBackgroundResource(R.drawable.white_ripple);
}
 else {
container.setBackgroundResource(R.color.white);
}
holder.txtView.setTextColor(Color.GRAY);
RecyclerOnClickListener listener=new RecyclerOnClickListener(mRecyclerView,mTabNumber);
container.setOnClickListener(listener);
container.setOnLongClickListener(mListener);
break;
case 2:
holder.txtView.setText(R.string.delete);
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.START);
container.setBackgroundResource(R.color.red);
holder.txtView.setTextColor(Color.WHITE);
break;
}
break;
}
}","@Override public void onBindViewHolder(final MyViewHolder holder,final int position){
  holder.priorityTag.setVisibility(View.GONE);
  holder.tabTag.setVisibility(View.GONE);
  LinearLayout container=(LinearLayout)holder.txtView.getParent();
  DatabaseHelper helper=DatabaseHelper.getInstance(mRecyclerView.getContext());
  if (mBigtext) {
    holder.txtView.setTextSize(22);
  }
 else {
    holder.txtView.setTextSize(18);
  }
  int tab=mTabNumber;
  if (mTabNumber == 4) {
    tab=helper.getTabById((int)mRecyclerView.getTag());
    if (position == 1) {
      holder.tabTag.setVisibility(View.VISIBLE);
      if (mDarkTheme) {
        holder.tabTag.setTextColor(Color.WHITE);
      }
 else {
        holder.tabTag.setTextColor(Color.BLACK);
      }
switch (tab) {
case 1:
        holder.tabTag.setText(R.string.first_tab);
      break;
case 2:
    holder.tabTag.setText(R.string.second_tab);
  break;
case 3:
holder.tabTag.setText(R.string.third_tab);
break;
}
}
}
switch (tab) {
case 1:
switch (position) {
case 0:
holder.txtView.setText(R.string.done_caps);
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.END);
container.setBackgroundResource(R.color.md_green_a400);
holder.txtView.setTextColor(Color.WHITE);
break;
case 1:
setupIdeaTile(holder,container);
setupPriorityTag(holder,helper);
break;
case 2:
holder.txtView.setText(R.string.later);
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.START);
container.setBackgroundResource(R.color.md_pink_a400);
holder.txtView.setTextColor(Color.WHITE);
break;
}
break;
case 2:
switch (position) {
case 0:
holder.txtView.setText(R.string.now);
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.END);
container.setBackgroundResource(R.color.md_indigo_a400);
holder.txtView.setTextColor(Color.WHITE);
break;
case 1:
setupIdeaTile(holder,container);
setupPriorityTag(holder,helper);
break;
case 2:
holder.txtView.setText(R.string.delete);
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.START);
container.setBackgroundResource(R.color.red);
holder.txtView.setTextColor(Color.WHITE);
break;
}
break;
case 3:
switch (position) {
case 0:
holder.txtView.setText(R.string.recover);
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.END);
container.setBackgroundResource(R.color.md_indigo_a400);
holder.txtView.setTextColor(Color.WHITE);
break;
case 1:
setupIdeaTile(holder,container);
break;
case 2:
holder.txtView.setText(R.string.delete);
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.START);
container.setBackgroundResource(R.color.red);
holder.txtView.setTextColor(Color.WHITE);
break;
}
break;
}
}",0.5691644654525233
175421,"/** 
 * Show a dialog allowing to edit all the attributes of the idea and showing the original ones.
 */
public void editIdeaDialog(){
  mEditIdeaDialog=new LovelyCustomDialog(MainActivity.getInstance(),R.style.EditTextTintTheme).setView(R.layout.new_idea_form).setTopColor(mPrimaryColor).setIcon(R.drawable.ic_edit).setListener(R.id.doneButton,new View.OnClickListener(){
    @Override public void onClick(    View v){
      sendEditIdea();
    }
  }
).configureView(new LovelyCustomDialog.ViewConfigurator(){
    @Override public void configureView(    View v){
      TextView title=(TextView)v.findViewById(R.id.idea_dialog_title);
      Button doneButton=(Button)v.findViewById(R.id.doneButton);
      mDoLater=(Switch)v.findViewById(R.id.doLater);
      mRadioGroup=(RadioGroup)v.findViewById(R.id.radioGroup);
      mIdeaField=(EditText)v.findViewById(R.id.editText);
      mNoteField=(EditText)v.findViewById(R.id.editNote);
      title.setText(R.string.edit_idea);
      doneButton.setText(R.string.edit);
      mError=(TextView)v.findViewById(R.id.new_error_message);
      mIdeaField.addTextChangedListener(new HideErrorOnTextChanged());
      mIdeaField.setOnEditorActionListener(ideaFieldListener);
      mNoteField.setOnEditorActionListener(noteFieldListener);
      mIdeaField.setOnFocusChangeListener(RecyclerOnClickListener.this);
      mNoteField.setOnFocusChangeListener(RecyclerOnClickListener.this);
      String ideaText=mDbHelper.getTextById(mIdRecycler);
      mIdeaField.append(ideaText);
      mNoteField.setText(mDbHelper.getNoteById(mIdRecycler));
      int fromTab=mDbHelper.getTabById(mIdRecycler);
      if (fromTab == 2)       mDoLater.toggle();
      RadioButton radio=null;
switch (mPriority) {
case 1:
        radio=(RadioButton)v.findViewById(R.id.radioButton1);
      break;
case 2:
    radio=(RadioButton)v.findViewById(R.id.radioButton2);
  break;
case 3:
radio=(RadioButton)v.findViewById(R.id.radioButton3);
break;
}
radio.setChecked(true);
}
}
).show();
if (mNoteField.requestFocus() && mIdeaField.requestFocus()) {
mEditIdeaDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
}
}","/** 
 * Show a dialog allowing to edit all the attributes of the idea and showing the original ones.
 */
public void editIdeaDialog(){
  mEditIdeaDialog=new LovelyCustomDialog(context,mDarkTheme ? R.style.EditTextTintThemeDark : R.style.EditTextTintTheme).setView(R.layout.new_idea_form).setTopColor(mPrimaryColor).setIcon(R.drawable.ic_edit).setListener(R.id.doneButton,new View.OnClickListener(){
    @Override public void onClick(    View v){
      sendEditIdea();
    }
  }
).configureView(new LovelyCustomDialog.ViewConfigurator(){
    @Override public void configureView(    View v){
      TextView title=(TextView)v.findViewById(R.id.idea_dialog_title);
      Button doneButton=(Button)v.findViewById(R.id.doneButton);
      mDoLater=(Switch)v.findViewById(R.id.doLater);
      mRadioGroup=(RadioGroup)v.findViewById(R.id.radioGroup);
      mIdeaField=(EditText)v.findViewById(R.id.editText);
      mNoteField=(EditText)v.findViewById(R.id.editNote);
      title.setText(R.string.edit_idea);
      doneButton.setText(R.string.edit);
      mError=(TextView)v.findViewById(R.id.new_error_message);
      mIdeaField.addTextChangedListener(new HideErrorOnTextChanged());
      mIdeaField.setOnEditorActionListener(ideaFieldListener);
      mNoteField.setOnEditorActionListener(noteFieldListener);
      mIdeaField.setOnFocusChangeListener(RecyclerOnClickListener.this);
      mNoteField.setOnFocusChangeListener(RecyclerOnClickListener.this);
      String ideaText=mDbHelper.getTextById(mIdRecycler);
      mIdeaField.append(ideaText);
      mNoteField.setText(mDbHelper.getNoteById(mIdRecycler));
      int fromTab=mDbHelper.getTabById(mIdRecycler);
      if (fromTab == 2)       mDoLater.toggle();
      RadioButton radio=null;
switch (mPriority) {
case 1:
        radio=(RadioButton)v.findViewById(R.id.radioButton1);
      break;
case 2:
    radio=(RadioButton)v.findViewById(R.id.radioButton2);
  break;
case 3:
radio=(RadioButton)v.findViewById(R.id.radioButton3);
break;
}
radio.setChecked(true);
}
}
).show();
if (mNoteField.requestFocus() && mIdeaField.requestFocus()) {
mEditIdeaDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
}
}",0.9821018815970628
175422,"public RecyclerOnClickListener(MyRecyclerView recyclerView,int tabNumber){
  mRecyclerView=recyclerView;
  mTabNumber=tabNumber;
}","public RecyclerOnClickListener(MyRecyclerView recyclerView,int tabNumber){
  this.context=recyclerView.getContext();
  mRecyclerView=recyclerView;
  mTabNumber=tabNumber;
  mDbHelper=DatabaseHelper.getInstance(context);
  TinyDB mTinyDB=new TinyDB(context);
  mDarkTheme=mTinyDB.getBoolean(context.getString(R.string.dark_theme_pref),false);
}",0.5496828752642706
175423,"/** 
 * Show a dialog with the idea's text and note allows to delete or edit the idea
 */
private void showIdeaDialog(){
  mDetailedIdeaDialog=new LovelyCustomDialog(MainActivity.getInstance(),R.style.EditTextTintTheme).setView(R.layout.detailed_idea_form).setTopColor(mPrimaryColor).setIcon(R.drawable.ic_bulb).setListener(R.id.editButton,new View.OnClickListener(){
    @Override public void onClick(    View v){
      editIdeaDialog();
      mDetailedIdeaDialog.dismiss();
    }
  }
).setListener(R.id.deleteButton,new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (mTabNumber == 4) {
        mRecyclerView.muteCellToDelete();
      }
 else {
        mRecyclerView.sendCellToTab(-1);
      }
      mDetailedIdeaDialog.dismiss();
    }
  }
).setListener(R.id.okButton,new View.OnClickListener(){
    @Override public void onClick(    View v){
      mDetailedIdeaDialog.dismiss();
    }
  }
).configureView(new LovelyCustomDialog.ViewConfigurator(){
    @Override public void configureView(    View v){
      mIdeaField=(TextView)v.findViewById(R.id.editText);
      mNoteField=(TextView)v.findViewById(R.id.editNote);
      mIdeaField.append(mDbHelper.getTextById(mIdRecycler));
      mNoteField.setText(mDbHelper.getNoteById(mIdRecycler));
      AppCompatRadioButton radio=(AppCompatRadioButton)v.findViewById(R.id.priorityRadioButton);
      radio.setText(String.format(Locale.getDefault(),""String_Node_Str"",mPriority));
      radio.setHighlightColor(getPriorityColor());
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
        radio.setButtonTintList(ColorStateList.valueOf(getPriorityColor()));
      }
    }
  }
).show();
}","/** 
 * Show a dialog with the idea's text and note allows to delete or edit the idea
 */
private void showIdeaDialog(){
  mDetailedIdeaDialog=new LovelyCustomDialog(context,mDarkTheme ? R.style.EditTextTintThemeDark : R.style.EditTextTintTheme).setView(R.layout.detailed_idea_form).setTopColor(mPrimaryColor).setIcon(R.drawable.ic_bulb).setListener(R.id.editButton,new View.OnClickListener(){
    @Override public void onClick(    View v){
      editIdeaDialog();
      mDetailedIdeaDialog.dismiss();
    }
  }
).setListener(R.id.deleteButton,new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (mTabNumber == 4) {
        mRecyclerView.muteCellToDelete();
      }
 else {
        mRecyclerView.sendCellToTab(-1);
      }
      mDetailedIdeaDialog.dismiss();
    }
  }
).setListener(R.id.okButton,new View.OnClickListener(){
    @Override public void onClick(    View v){
      mDetailedIdeaDialog.dismiss();
    }
  }
).configureView(new LovelyCustomDialog.ViewConfigurator(){
    @Override public void configureView(    View v){
      mIdeaField=(TextView)v.findViewById(R.id.editText);
      mNoteField=(TextView)v.findViewById(R.id.editNote);
      mIdeaField.append(mDbHelper.getTextById(mIdRecycler));
      mNoteField.setText(mDbHelper.getNoteById(mIdRecycler));
      AppCompatRadioButton radio=(AppCompatRadioButton)v.findViewById(R.id.priorityRadioButton);
      radio.setText(String.format(Locale.getDefault(),""String_Node_Str"",mPriority));
      radio.setHighlightColor(getPriorityColor());
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
        radio.setButtonTintList(ColorStateList.valueOf(getPriorityColor()));
      }
    }
  }
).show();
}",0.977004716981132
175424,"/** 
 * Show a dialog with the idea's text and note allows to delete or edit the idea
 */
private void showIdeaDialog(){
  SpannableString text=new SpannableString(mDbHelper.getTextById(mIdRecycler));
  text.setSpan(new AbsoluteSizeSpan(24,true),0,text.length(),0);
  String note=mDbHelper.getNoteById(mIdRecycler);
  new LovelyStandardDialog(MainActivity.getInstance()).setTopColorRes(getPriorityColor()).setIcon(R.drawable.ic_bulb).setTitle(text).setMessage(note).setPositiveButtonColorRes(R.color.md_pink_a200).setPositiveButton(R.string.ok,null).setNeutralButton(R.string.delete,new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (mTabNumber == 4) {
        mRecyclerView.muteCellToDelete();
      }
 else {
        mRecyclerView.sendCellToTab(-1);
      }
    }
  }
).setNeutralButtonColorRes(R.color.md_pink_a200).setNegativeButton(R.string.edit,new View.OnClickListener(){
    @Override public void onClick(    View v){
      editIdeaDialog();
    }
  }
).setNegativeButtonColorRes(R.color.md_pink_a200).show();
}","/** 
 * Show a dialog with the idea's text and note allows to delete or edit the idea
 */
private void showIdeaDialog(){
  mDetailedIdeaDialog=new LovelyCustomDialog(MainActivity.getInstance(),R.style.EditTextTintTheme).setView(R.layout.detailed_idea_form).setTopColor(getPriorityColor()).setIcon(R.drawable.ic_bulb).setListener(R.id.editButton,new View.OnClickListener(){
    @Override public void onClick(    View v){
      editIdeaDialog();
      mDetailedIdeaDialog.dismiss();
    }
  }
).setListener(R.id.deleteButton,new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (mTabNumber == 4) {
        mRecyclerView.muteCellToDelete();
      }
 else {
        mRecyclerView.sendCellToTab(-1);
      }
      mDetailedIdeaDialog.dismiss();
    }
  }
).setListener(R.id.okButton,new View.OnClickListener(){
    @Override public void onClick(    View v){
      mDetailedIdeaDialog.dismiss();
    }
  }
).show();
  TextView title=(TextView)mDetailedIdeaDialog.findViewById(R.id.idea_dialog_title);
  title.setText(R.string.detailed_idea);
  RadioGroup radioGroup=(RadioGroup)mDetailedIdeaDialog.findViewById(R.id.radioGroup);
  mIdeaField=(EditText)mDetailedIdeaDialog.findViewById(R.id.editText);
  mNoteField=(EditText)mDetailedIdeaDialog.findViewById(R.id.editNote);
  mIdeaField.append(mDbHelper.getTextById(mIdRecycler));
  mNoteField.setText(mDbHelper.getNoteById(mIdRecycler));
  mNoteField.setEnabled(false);
  mIdeaField.setEnabled(false);
  RadioButton radio=null;
switch (mPriority) {
case 1:
    radio=(RadioButton)mDetailedIdeaDialog.findViewById(R.id.radioButton1);
  break;
case 2:
radio=(RadioButton)mDetailedIdeaDialog.findViewById(R.id.radioButton2);
break;
case 3:
radio=(RadioButton)mDetailedIdeaDialog.findViewById(R.id.radioButton3);
break;
}
radio.setChecked(true);
for (int i=0; i < radioGroup.getChildCount(); i++) {
radioGroup.getChildAt(i).setEnabled(false);
}
}",0.268013468013468
175425,"private void goToMainActivity(){
  Intent i=new Intent(MyIntro.this,MainActivity.class);
  startActivity(i);
}","private void goToMainActivity(){
  Intent i=new Intent(MyIntro.this,MainActivity.class);
  i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
  startActivity(i);
}",0.6626506024096386
175426,"@Override public void onAnimationEnd(Animation animation){
  FloatingActionButton fab3=(FloatingActionButton)findViewById(R.id.item_p3);
  RelativeLayout.LayoutParams params=(RelativeLayout.LayoutParams)fab3.getLayoutParams();
  params.setMargins(0,0,RADII,0);
  fab3.setLayoutParams(params);
  fab3.clearAnimation();
}","@Override public void onAnimationEnd(Animation animation){
  RelativeLayout.LayoutParams params=(RelativeLayout.LayoutParams)fab3.getLayoutParams();
  params.setMargins(0,0,RADIUS,0);
  fab3.setLayoutParams(params);
  fab3.clearAnimation();
  IdeaMenuItemListener.setReady(true);
}",0.8
175427,"private void setUpIdeaMenuItems(){
  final int RADIUS=mFab.getWidth() * 2;
  final int RADII=(int)(Math.sqrt(2) * RADIUS / 2);
  final int DURATION=2000;
  final int DELAY=500;
  FloatingActionButton fab1=(FloatingActionButton)findViewById(R.id.item_p1);
  AnimationSet set1=new AnimationSet(true);
  set1.setInterpolator(new AccelerateDecelerateInterpolator());
  set1.setDuration(DURATION);
  set1.setFillAfter(true);
  TranslateAnimation tr1=new TranslateAnimation(0f,0f,0f,-RADIUS);
  ScaleAnimation sc1=new ScaleAnimation(0f,1f,0f,1f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
  set1.addAnimation(tr1);
  set1.addAnimation(sc1);
  set1.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      FloatingActionButton fab1=(FloatingActionButton)findViewById(R.id.item_p1);
      RelativeLayout.LayoutParams params=(RelativeLayout.LayoutParams)fab1.getLayoutParams();
      params.setMargins(0,0,0,RADIUS);
      fab1.setLayoutParams(params);
      fab1.clearAnimation();
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
  FloatingActionButton fab2=(FloatingActionButton)findViewById(R.id.item_p2);
  AnimationSet set2=new AnimationSet(true);
  set2.setInterpolator(new AccelerateDecelerateInterpolator());
  set2.setDuration(DURATION);
  set2.setStartOffset(DELAY);
  set2.setFillAfter(true);
  TranslateAnimation tr2=new TranslateAnimation(0f,0f,-RADII,-RADII);
  ScaleAnimation sc2=new ScaleAnimation(0f,1f,0f,1f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
  set2.addAnimation(tr2);
  set2.addAnimation(sc2);
  set2.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      FloatingActionButton fab2=(FloatingActionButton)findViewById(R.id.item_p2);
      RelativeLayout.LayoutParams params=(RelativeLayout.LayoutParams)fab2.getLayoutParams();
      params.setMargins(0,0,RADII,RADII);
      fab2.setLayoutParams(params);
      fab2.clearAnimation();
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
  FloatingActionButton fab3=(FloatingActionButton)findViewById(R.id.item_p3);
  AnimationSet set3=new AnimationSet(true);
  set3.setInterpolator(new AccelerateDecelerateInterpolator());
  set3.setDuration(DURATION);
  set3.setStartOffset(2 * DELAY);
  set3.setFillAfter(true);
  TranslateAnimation tr3=new TranslateAnimation(0f,0f,-RADII,0f);
  ScaleAnimation sc3=new ScaleAnimation(0f,1f,0f,1f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
  set3.addAnimation(tr3);
  set3.addAnimation(sc3);
  set3.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      FloatingActionButton fab3=(FloatingActionButton)findViewById(R.id.item_p3);
      RelativeLayout.LayoutParams params=(RelativeLayout.LayoutParams)fab3.getLayoutParams();
      params.setMargins(0,0,RADII,0);
      fab3.setLayoutParams(params);
      fab3.clearAnimation();
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
  fab1.startAnimation(set1);
  fab2.startAnimation(set2);
  fab3.startAnimation(set3);
}","private void setUpIdeaMenuItems(){
  final int RADIUS=mFab.getWidth() * 2;
  final int RADII=(int)(Math.sqrt(2) * RADIUS / 2);
  final int DURATION=250;
  final int DELAY=30;
  final FloatingActionButton fab1=(FloatingActionButton)findViewById(R.id.item_p1);
  AnimationSet set1=new AnimationSet(true);
  set1.setInterpolator(new AccelerateDecelerateInterpolator());
  set1.setDuration(DURATION);
  set1.setFillAfter(true);
  TranslateAnimation tr1=new TranslateAnimation(0f,0f,0f,-RADIUS);
  ScaleAnimation sc1=new ScaleAnimation(0f,1f,0f,1f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
  set1.addAnimation(tr1);
  set1.addAnimation(sc1);
  set1.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      RelativeLayout.LayoutParams params=(RelativeLayout.LayoutParams)fab1.getLayoutParams();
      params.setMargins(0,0,0,RADIUS);
      fab1.setLayoutParams(params);
      fab1.clearAnimation();
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
  final FloatingActionButton fab2=(FloatingActionButton)findViewById(R.id.item_p2);
  AnimationSet set2=new AnimationSet(true);
  set2.setInterpolator(new AccelerateDecelerateInterpolator());
  set2.setDuration(DURATION);
  set2.setStartOffset(DELAY);
  set2.setFillAfter(true);
  TranslateAnimation tr2=new TranslateAnimation(0f,-RADII,0f,-RADII);
  ScaleAnimation sc2=new ScaleAnimation(0f,1f,0f,1f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
  set2.addAnimation(tr2);
  set2.addAnimation(sc2);
  set2.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      RelativeLayout.LayoutParams params=(RelativeLayout.LayoutParams)fab2.getLayoutParams();
      params.setMargins(0,0,RADII,RADII);
      fab2.setLayoutParams(params);
      fab2.clearAnimation();
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
  final FloatingActionButton fab3=(FloatingActionButton)findViewById(R.id.item_p3);
  AnimationSet set3=new AnimationSet(true);
  set3.setInterpolator(new AccelerateDecelerateInterpolator());
  set3.setDuration(DURATION);
  set3.setStartOffset(2 * DELAY);
  set3.setFillAfter(true);
  TranslateAnimation tr3=new TranslateAnimation(0f,-RADIUS,0f,0f);
  ScaleAnimation sc3=new ScaleAnimation(0f,1f,0f,1f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
  set3.addAnimation(tr3);
  set3.addAnimation(sc3);
  set3.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      RelativeLayout.LayoutParams params=(RelativeLayout.LayoutParams)fab3.getLayoutParams();
      params.setMargins(0,0,RADIUS,0);
      fab3.setLayoutParams(params);
      fab3.clearAnimation();
      IdeaMenuItemListener.setReady(true);
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
  findViewById(R.id.items_priority).setVisibility(View.VISIBLE);
  IdeaMenuItemListener.setReady(false);
  fab1.startAnimation(set1);
  fab2.startAnimation(set2);
  fab3.startAnimation(set3);
}",0.5224312590448625
175428,"@Override public void run(){
  droppedView.setVisibility(View.VISIBLE);
}","@Override public void run(){
  MainActivity.getInstance().rebootIdeaMenuItems();
}",0.5806451612903226
175429,"@Override public boolean onDrag(View v,DragEvent event){
  AnimationSet set=new AnimationSet(true);
  set.setInterpolator(new DecelerateInterpolator());
  Animation scale=new ScaleAnimation(1.2f,3f,1.2f,3f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
  scale.setDuration(500);
  set.addAnimation(scale);
  Animation alpha=new AlphaAnimation(1.0f,0.3f);
  alpha.setDuration(350);
  set.addAnimation(alpha);
switch (event.getAction()) {
case DragEvent.ACTION_DRAG_STARTED:
    break;
case DragEvent.ACTION_DRAG_ENTERED:
  MainActivity.getInstance().feedbackVibration();
Animation anim=new ScaleAnimation(1f,1.2f,1f,1.2f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
anim.setDuration(350);
anim.setInterpolator(new BounceInterpolator());
anim.setFillAfter(true);
v.startAnimation(anim);
break;
case DragEvent.ACTION_DRAG_EXITED:
v.clearAnimation();
break;
case DragEvent.ACTION_DRAG_LOCATION:
break;
case DragEvent.ACTION_DRAG_ENDED:
mScreenDim.setAlpha(0f);
final View droppedView=(View)event.getLocalState();
droppedView.post(new Runnable(){
@Override public void run(){
droppedView.setVisibility(View.VISIBLE);
}
}
);
break;
case DragEvent.ACTION_DROP:
v.startAnimation(set);
MainActivity main=MainActivity.getInstance();
switch (mActionId) {
default :
main.newIdeaDialog(mActionId);
}
break;
default :
break;
}
return true;
}","@Override public boolean onDrag(View v,DragEvent event){
  AnimationSet set=new AnimationSet(true);
  set.setInterpolator(new DecelerateInterpolator());
  set.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      MainActivity.getInstance().rebootIdeaMenuItems();
      dropping=false;
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
  Animation scale=new ScaleAnimation(1.2f,3f,1.2f,3f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
  scale.setDuration(300);
  set.addAnimation(scale);
  Animation alpha=new AlphaAnimation(1.0f,0.2f);
  alpha.setDuration(350);
  set.addAnimation(alpha);
switch (event.getAction()) {
case DragEvent.ACTION_DRAG_STARTED:
    dragging=true;
  break;
case DragEvent.ACTION_DRAG_ENTERED:
if (ready) {
  MainActivity.getInstance().feedbackVibration();
  Animation anim=new ScaleAnimation(1f,1.2f,1f,1.2f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
  anim.setDuration(350);
  anim.setInterpolator(new BounceInterpolator());
  anim.setFillAfter(true);
  v.startAnimation(anim);
}
break;
case DragEvent.ACTION_DRAG_EXITED:
if (ready) {
v.clearAnimation();
}
break;
case DragEvent.ACTION_DRAG_LOCATION:
break;
case DragEvent.ACTION_DROP:
if (ready) {
dropping=true;
v.startAnimation(set);
MainActivity main=MainActivity.getInstance();
switch (mActionId) {
default :
main.newIdeaDialog(mActionId);
}
}
break;
case DragEvent.ACTION_DRAG_ENDED:
if (dragging && !dropping) {
final View droppedView=(View)event.getLocalState();
droppedView.post(new Runnable(){
@Override public void run(){
MainActivity.getInstance().rebootIdeaMenuItems();
}
}
);
dragging=false;
}
break;
default :
break;
}
return true;
}",0.6025442134657152
175430,"private void setUpDrawers(){
  mAddProject=new ProfileSettingDrawerItem().withName(""String_Node_Str"").withIcon(FontAwesome.Icon.faw_plus).withIdentifier(30).withSelectable(false).withOnDrawerItemClickListener(this);
  header=new AccountHeaderBuilder().withActivity(this).withHeaderBackground(R.drawable.header).withProfiles(mProfiles).addProfiles(mAddProject).withProfileImagesVisible(false).build();
  setUpSwitches();
  leftDrawer=new DrawerBuilder(this).withToolbar(mToolbar).withActionBarDrawerToggleAnimated(true).withSelectedItem(-1).withAccountHeader(header).addDrawerItems(new PrimaryDrawerItem().withIdentifier(1).withName(R.string.rename_pro).withIcon(FontAwesome.Icon.faw_i_cursor).withSelectable(false),new PrimaryDrawerItem().withIdentifier(2).withName(R.string.delete_pro).withIcon(FontAwesome.Icon.faw_trash).withSelectable(false),new DividerDrawerItem(),new PrimaryDrawerItem().withIdentifier(4).withName(R.string.all_pro).withIcon(GoogleMaterial.Icon.gmd_inbox).withSelectable(false),new PrimaryDrawerItem().withIdentifier(3).withName(R.string.new_pro).withIcon(FontAwesome.Icon.faw_plus).withSelectable(false),new DividerDrawerItem(),new ExpandableDrawerItem().withName(R.string.settings).withIcon(FontAwesome.Icon.faw_gear).withSelectable(false).withSubItems(doneSwitch,bigTextSwitch),new ExpandableDrawerItem().withName(R.string.help_feedback).withIcon(FontAwesome.Icon.faw_question_circle).withSelectable(false).withSubItems(new SecondaryDrawerItem().withName(R.string.see_app_intro).withLevel(2).withIcon(GoogleMaterial.Icon.gmd_camera_rear).withIdentifier(8).withSelectable(false),new SecondaryDrawerItem().withName(R.string.activate_tuto).withLevel(2).withIcon(GoogleMaterial.Icon.gmd_info).withIdentifier(9).withSelectable(false),new SecondaryDrawerItem().withName(R.string.rate_app).withLevel(2).withIcon(GoogleMaterial.Icon.gmd_star).withIdentifier(11).withSelectable(false),new SecondaryDrawerItem().withName(R.string.feedback).withLevel(2).withIcon(GoogleMaterial.Icon.gmd_bug).withIdentifier(10).withSelectable(false),new SecondaryDrawerItem().withName(R.string.source_code).withLevel(2).withIcon(GoogleMaterial.Icon.gmd_github).withIdentifier(12).withSelectable(false))).withOnDrawerItemClickListener(new Drawer.OnDrawerItemClickListener(){
    @Override public boolean onItemClick(    View view,    int position,    IDrawerItem drawerItem){
      if (drawerItem != null) {
        int id=(int)drawerItem.getIdentifier();
switch (id) {
case 1:
          if (!mNoProject) {
            renameProjectDialog();
          }
 else {
            noProjectSnack();
          }
        break;
case 2:
      if (!mNoProject) {
        deleteProjectDialog();
      }
 else {
        noProjectSnack();
      }
    break;
case 3:
  newProjectDialog();
break;
case 4:
if (!mNoProject) {
header.toggleSelectionList(getApplicationContext());
}
 else {
noProjectSnack();
}
break;
case 8:
forceIntro();
break;
case 9:
leftDrawer.closeDrawer();
Snackbar snackbar=Snackbar.make(findViewById(R.id.main_content),R.string.tuto_mode,Snackbar.LENGTH_SHORT).setCallback(new Snackbar.Callback(){
@Override public void onDismissed(Snackbar snackbar,int event){
mTinyDB.putBoolean(getString(R.string.handle_idea_pref),true);
mTinyDB.putBoolean(getString(R.string.first_project_pref),true);
mTinyDB.putBoolean(getString(R.string.first_idea_pref),true);
mTinyDB.putBoolean(getString(R.string.right_drawer_pref),true);
}
}
);
snackbar.show();
break;
case 10:
Intent browserIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
startActivity(browserIntent);
break;
case 11:
Uri uri=Uri.parse(""String_Node_Str"" + getPackageName());
Intent goToMarket=new Intent(Intent.ACTION_VIEW,uri);
goToMarket.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY | Intent.FLAG_ACTIVITY_NEW_DOCUMENT | Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
try {
startActivity(goToMarket);
}
 catch (ActivityNotFoundException e) {
startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str"" + getPackageName())));
}
break;
case 12:
Intent browserSource=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
startActivity(browserSource);
break;
}
}
return true;
}
}
).withOnDrawerListener(this).build();
mFavoriteButton=(MaterialFavoriteButton)header.getView().findViewById(R.id.favorite_button);
mFavoriteButton.setOnFavoriteChangeListener(new MaterialFavoriteButton.OnFavoriteChangeListener(){
@Override public void onFavoriteChanged(MaterialFavoriteButton buttonView,boolean favorite){
if (favorite) {
mTinyDB.putInt(getString(R.string.favorite_project),getProjectId());
}
 else if (mTinyDB.getInt(getString(R.string.favorite_project)) == mSelectedProfileIndex) {
mTinyDB.putInt(getString(R.string.favorite_project),-1);
}
}
}
);
mColorItem1=new PrimaryDrawerItem().withIdentifier(1).withName(R.string.primary_col).withIcon(FontAwesome.Icon.faw_paint_brush).withIconColor(mPrimaryColor).withSelectable(false);
mColorItem2=new PrimaryDrawerItem().withIdentifier(2).withName(R.string.secondary_col).withIcon(FontAwesome.Icon.faw_paint_brush).withIconColor(mSecondaryColor).withSelectable(false);
mColorItem3=new PrimaryDrawerItem().withIdentifier(3).withName(R.string.text_col).withIcon(FontAwesome.Icon.faw_paint_brush).withIconColor(mTextColor).withSelectable(false);
rightDrawer=new DrawerBuilder(this).withActionBarDrawerToggleAnimated(true).withSelectedItem(-1).addDrawerItems(new SectionDrawerItem().withName(R.string.color_prefs),mColorItem1,mColorItem2,mColorItem3,new PrimaryDrawerItem().withIdentifier(6).withName(R.string.reset_color_prefs).withIcon(FontAwesome.Icon.faw_tint).withSelectable(false),new SectionDrawerItem().withName(R.string.functions),new PrimaryDrawerItem().withIdentifier(4).withName(R.string.clear_done).withIcon(FontAwesome.Icon.faw_check_circle).withSelectable(false),new PrimaryDrawerItem().withIdentifier(5).withName(R.string.sort_priority).withIcon(FontAwesome.Icon.faw_sort_amount_desc).withSelectable(false)).withDrawerGravity(Gravity.END).withStickyFooter(R.layout.footer).withOnDrawerItemClickListener(new Drawer.OnDrawerItemClickListener(){
@Override public boolean onItemClick(View view,int position,IDrawerItem drawerItem){
if (drawerItem != null && !mNoProject) {
int id=(int)drawerItem.getIdentifier();
switch (id) {
case 1:
new SpectrumDialog.Builder(getApplicationContext()).setTitle(R.string.select_prim_col).setColors(R.array.colors).setSelectedColor(mPrimaryColor).setDismissOnColorSelected(false).setFixedColumnCount(4).setOnColorSelectedListener(new SpectrumDialog.OnColorSelectedListener(){
@Override public void onColorSelected(boolean positiveResult,@ColorInt int color){
if (positiveResult) {
mPrimaryColor=color;
changePrimaryColor();
saveProjectColors();
Drawable disk=ContextCompat.getDrawable(getApplicationContext(),R.drawable.disk);
disk.setColorFilter(mPrimaryColor,PorterDuff.Mode.SRC_ATOP);
IProfile p=header.getActiveProfile();
p.withIcon(disk);
header.updateProfile(p);
}
}
}
).build().show(mFragmentManager,""String_Node_Str"");
break;
case 2:
new SpectrumDialog.Builder(getApplicationContext()).setTitle(R.string.select_sec_col).setColors(R.array.accent_colors).setSelectedColor(mSecondaryColor).setDismissOnColorSelected(false).setFixedColumnCount(4).setOnColorSelectedListener(new SpectrumDialog.OnColorSelectedListener(){
@Override public void onColorSelected(boolean positiveResult,@ColorInt int color){
if (positiveResult) {
mSecondaryColor=color;
changeSecondaryColor();
saveProjectColors();
}
}
}
).build().show(mFragmentManager,""String_Node_Str"");
break;
case 3:
new SpectrumDialog.Builder(getApplicationContext()).setTitle(R.string.select_text_col).setColors(R.array.textColors).setSelectedColor(mTextColor).setDismissOnColorSelected(false).setFixedColumnCount(4).setOutlineWidth(2).setOnColorSelectedListener(new SpectrumDialog.OnColorSelectedListener(){
@Override public void onColorSelected(boolean positiveResult,@ColorInt int color){
if (positiveResult) {
mTextColor=color;
changeTextColor();
saveProjectColors();
}
}
}
).build().show(mFragmentManager,""String_Node_Str"");
break;
case 4:
mDbHelper.clearDoneWithSnack(mViewPager);
rightDrawer.closeDrawer();
break;
case 5:
mDbHelper.sortByAscPriority();
rightDrawer.closeDrawer();
break;
case 6:
resetColorsDialog();
break;
}
}
 else {
noProjectSnack();
}
return true;
}
}
).append(leftDrawer);
if (!mNoProject) {
header.setActiveProfile(mProfiles.get(mSelectedProfileIndex));
displayIdeasCount();
refreshStar();
}
 else {
header.setProfiles(mProfiles);
header.setSelectionSecondLine(getString(R.string.no_project));
mPrimaryColor=defaultPrimaryColor;
mSecondaryColor=defaultSecondaryColor;
mTextColor=defaultTextColor;
updateColors();
refreshStar();
}
}","private void setUpDrawers(){
  mAddProject=new ProfileSettingDrawerItem().withName(""String_Node_Str"").withIcon(FontAwesome.Icon.faw_plus).withIdentifier(30).withSelectable(false).withOnDrawerItemClickListener(this);
  header=new AccountHeaderBuilder().withActivity(this).withHeaderBackground(R.drawable.header).withProfiles(mProfiles).addProfiles(mAddProject).withProfileImagesVisible(false).build();
  setUpSwitches();
  leftDrawer=new DrawerBuilder(this).withToolbar(mToolbar).withActionBarDrawerToggleAnimated(true).withSelectedItem(-1).withAccountHeader(header).addDrawerItems(new PrimaryDrawerItem().withIdentifier(1).withName(R.string.rename_pro).withIcon(FontAwesome.Icon.faw_i_cursor).withSelectable(false),new PrimaryDrawerItem().withIdentifier(2).withName(R.string.delete_pro).withIcon(FontAwesome.Icon.faw_trash).withSelectable(false),new DividerDrawerItem(),new PrimaryDrawerItem().withIdentifier(4).withName(R.string.all_pro).withIcon(GoogleMaterial.Icon.gmd_inbox).withSelectable(false),new PrimaryDrawerItem().withIdentifier(3).withName(R.string.new_pro).withIcon(FontAwesome.Icon.faw_plus).withSelectable(false),new DividerDrawerItem(),new ExpandableDrawerItem().withName(R.string.settings).withIcon(FontAwesome.Icon.faw_gear).withSelectable(false).withSubItems(doneSwitch,bigTextSwitch),new ExpandableDrawerItem().withName(R.string.help_feedback).withIcon(FontAwesome.Icon.faw_question_circle).withSelectable(false).withSubItems(new SecondaryDrawerItem().withName(R.string.see_app_intro).withLevel(2).withIcon(GoogleMaterial.Icon.gmd_camera_rear).withIdentifier(8).withSelectable(false),new SecondaryDrawerItem().withName(R.string.activate_tuto).withLevel(2).withIcon(GoogleMaterial.Icon.gmd_info).withIdentifier(9).withSelectable(false),new SecondaryDrawerItem().withName(R.string.rate_app).withLevel(2).withIcon(GoogleMaterial.Icon.gmd_star).withIdentifier(11).withSelectable(false),new SecondaryDrawerItem().withName(R.string.feedback).withLevel(2).withIcon(GoogleMaterial.Icon.gmd_bug).withIdentifier(10).withSelectable(false),new SecondaryDrawerItem().withName(R.string.source_code).withLevel(2).withIcon(GoogleMaterial.Icon.gmd_github).withIdentifier(12).withSelectable(false))).withOnDrawerItemClickListener(this).withOnDrawerListener(this).build();
  mFavoriteButton=(MaterialFavoriteButton)header.getView().findViewById(R.id.favorite_button);
  mFavoriteButton.setOnFavoriteChangeListener(new MaterialFavoriteButton.OnFavoriteChangeListener(){
    @Override public void onFavoriteChanged(    MaterialFavoriteButton buttonView,    boolean favorite){
      if (favorite) {
        mTinyDB.putInt(getString(R.string.favorite_project),getProjectId());
      }
 else       if (mTinyDB.getInt(getString(R.string.favorite_project)) == mSelectedProfileIndex) {
        mTinyDB.putInt(getString(R.string.favorite_project),-1);
      }
    }
  }
);
  mColorItem1=new PrimaryDrawerItem().withIdentifier(1).withName(R.string.primary_col).withIcon(FontAwesome.Icon.faw_paint_brush).withIconColor(mPrimaryColor).withSelectable(false);
  mColorItem2=new PrimaryDrawerItem().withIdentifier(2).withName(R.string.secondary_col).withIcon(FontAwesome.Icon.faw_paint_brush).withIconColor(mSecondaryColor).withSelectable(false);
  mColorItem3=new PrimaryDrawerItem().withIdentifier(3).withName(R.string.text_col).withIcon(FontAwesome.Icon.faw_paint_brush).withIconColor(mTextColor).withSelectable(false);
  rightDrawer=new DrawerBuilder(this).withActionBarDrawerToggleAnimated(true).withSelectedItem(-1).addDrawerItems(new SectionDrawerItem().withName(R.string.color_prefs),mColorItem1,mColorItem2,mColorItem3,new PrimaryDrawerItem().withIdentifier(6).withName(R.string.reset_color_prefs).withIcon(FontAwesome.Icon.faw_tint).withSelectable(false),new SectionDrawerItem().withName(R.string.functions),new PrimaryDrawerItem().withIdentifier(4).withName(R.string.clear_done).withIcon(FontAwesome.Icon.faw_check_circle).withSelectable(false),new PrimaryDrawerItem().withIdentifier(5).withName(R.string.sort_priority).withIcon(FontAwesome.Icon.faw_sort_amount_desc).withSelectable(false)).withDrawerGravity(Gravity.END).withOnDrawerItemClickListener(new Drawer.OnDrawerItemClickListener(){
    @Override public boolean onItemClick(    View view,    int position,    IDrawerItem drawerItem){
      if (drawerItem != null && !mNoProject) {
        int id=(int)drawerItem.getIdentifier();
switch (id) {
case 1:
          new SpectrumDialog.Builder(getApplicationContext()).setTitle(R.string.select_prim_col).setColors(R.array.colors).setSelectedColor(mPrimaryColor).setDismissOnColorSelected(false).setFixedColumnCount(4).setOnColorSelectedListener(new SpectrumDialog.OnColorSelectedListener(){
            @Override public void onColorSelected(            boolean positiveResult,            @ColorInt int color){
              if (positiveResult) {
                mPrimaryColor=color;
                changePrimaryColor();
                saveProjectColors();
                Drawable disk=ContextCompat.getDrawable(getApplicationContext(),R.drawable.disk);
                disk.setColorFilter(mPrimaryColor,PorterDuff.Mode.SRC_ATOP);
                IProfile p=header.getActiveProfile();
                p.withIcon(disk);
                header.updateProfile(p);
              }
            }
          }
).build().show(mFragmentManager,""String_Node_Str"");
        break;
case 2:
      new SpectrumDialog.Builder(getApplicationContext()).setTitle(R.string.select_sec_col).setColors(R.array.accent_colors).setSelectedColor(mSecondaryColor).setDismissOnColorSelected(false).setFixedColumnCount(4).setOnColorSelectedListener(new SpectrumDialog.OnColorSelectedListener(){
        @Override public void onColorSelected(        boolean positiveResult,        @ColorInt int color){
          if (positiveResult) {
            mSecondaryColor=color;
            changeSecondaryColor();
            saveProjectColors();
          }
        }
      }
).build().show(mFragmentManager,""String_Node_Str"");
    break;
case 3:
  new SpectrumDialog.Builder(getApplicationContext()).setTitle(R.string.select_text_col).setColors(R.array.textColors).setSelectedColor(mTextColor).setDismissOnColorSelected(false).setFixedColumnCount(4).setOutlineWidth(2).setOnColorSelectedListener(new SpectrumDialog.OnColorSelectedListener(){
    @Override public void onColorSelected(    boolean positiveResult,    @ColorInt int color){
      if (positiveResult) {
        mTextColor=color;
        changeTextColor();
        saveProjectColors();
      }
    }
  }
).build().show(mFragmentManager,""String_Node_Str"");
break;
case 4:
mDbHelper.clearDoneWithSnack(mViewPager);
rightDrawer.closeDrawer();
break;
case 5:
mDbHelper.sortByAscPriority();
rightDrawer.closeDrawer();
break;
case 6:
resetColorsDialog();
break;
}
}
 else {
noProjectSnack();
}
return true;
}
}
).append(leftDrawer);
if (!mNoProject) {
header.setActiveProfile(mProfiles.get(mSelectedProfileIndex));
displayIdeasCount();
refreshStar();
}
 else {
header.setProfiles(mProfiles);
header.setSelectionSecondLine(getString(R.string.no_project));
mPrimaryColor=defaultPrimaryColor;
mSecondaryColor=defaultSecondaryColor;
mTextColor=defaultTextColor;
updateColors();
refreshStar();
}
}",0.5611383956680519
175431,"@Override public boolean onItemClick(View view,int position,IDrawerItem drawerItem){
  if (drawerItem != null) {
    int id=(int)drawerItem.getIdentifier();
switch (id) {
case 1:
      if (!mNoProject) {
        renameProjectDialog();
      }
 else {
        noProjectSnack();
      }
    break;
case 2:
  if (!mNoProject) {
    deleteProjectDialog();
  }
 else {
    noProjectSnack();
  }
break;
case 3:
newProjectDialog();
break;
case 4:
if (!mNoProject) {
header.toggleSelectionList(getApplicationContext());
}
 else {
noProjectSnack();
}
break;
case 8:
forceIntro();
break;
case 9:
leftDrawer.closeDrawer();
Snackbar snackbar=Snackbar.make(findViewById(R.id.main_content),R.string.tuto_mode,Snackbar.LENGTH_SHORT).setCallback(new Snackbar.Callback(){
@Override public void onDismissed(Snackbar snackbar,int event){
mTinyDB.putBoolean(getString(R.string.handle_idea_pref),true);
mTinyDB.putBoolean(getString(R.string.first_project_pref),true);
mTinyDB.putBoolean(getString(R.string.first_idea_pref),true);
mTinyDB.putBoolean(getString(R.string.right_drawer_pref),true);
}
}
);
snackbar.show();
break;
case 10:
Intent browserIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
startActivity(browserIntent);
break;
case 11:
Uri uri=Uri.parse(""String_Node_Str"" + getPackageName());
Intent goToMarket=new Intent(Intent.ACTION_VIEW,uri);
goToMarket.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY | Intent.FLAG_ACTIVITY_NEW_DOCUMENT | Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
try {
startActivity(goToMarket);
}
 catch (ActivityNotFoundException e) {
startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str"" + getPackageName())));
}
break;
case 12:
Intent browserSource=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
startActivity(browserSource);
break;
case 21:
if (!mNoProject) {
new SpectrumDialog.Builder(getApplicationContext()).setTitle(R.string.select_prim_col).setColors(R.array.colors).setSelectedColor(mPrimaryColor).setDismissOnColorSelected(false).setFixedColumnCount(4).setOnColorSelectedListener(new SpectrumDialog.OnColorSelectedListener(){
@Override public void onColorSelected(boolean positiveResult,@ColorInt int color){
if (positiveResult) {
mPrimaryColor=color;
changePrimaryColor();
saveProjectColors();
Drawable disk=ContextCompat.getDrawable(getApplicationContext(),R.drawable.disk);
disk.setColorFilter(mPrimaryColor,PorterDuff.Mode.SRC_ATOP);
IProfile p=header.getActiveProfile();
p.withIcon(disk);
header.updateProfile(p);
}
}
}
).build().show(mFragmentManager,""String_Node_Str"");
}
 else noProjectSnack();
break;
case 22:
if (!mNoProject) {
new SpectrumDialog.Builder(getApplicationContext()).setTitle(R.string.select_sec_col).setColors(R.array.accent_colors).setSelectedColor(mSecondaryColor).setDismissOnColorSelected(false).setFixedColumnCount(4).setOnColorSelectedListener(new SpectrumDialog.OnColorSelectedListener(){
@Override public void onColorSelected(boolean positiveResult,@ColorInt int color){
if (positiveResult) {
mSecondaryColor=color;
changeSecondaryColor();
saveProjectColors();
}
}
}
).build().show(mFragmentManager,""String_Node_Str"");
}
 else noProjectSnack();
break;
case 23:
if (!mNoProject) {
new SpectrumDialog.Builder(getApplicationContext()).setTitle(R.string.select_text_col).setColors(R.array.textColors).setSelectedColor(mTextColor).setDismissOnColorSelected(false).setFixedColumnCount(4).setOutlineWidth(2).setOnColorSelectedListener(new SpectrumDialog.OnColorSelectedListener(){
@Override public void onColorSelected(boolean positiveResult,@ColorInt int color){
if (positiveResult) {
mTextColor=color;
changeTextColor();
saveProjectColors();
}
}
}
).build().show(mFragmentManager,""String_Node_Str"");
}
 else noProjectSnack();
break;
case 24:
if (!mNoProject) {
mDbHelper.clearDoneWithSnack(mViewPager);
rightDrawer.closeDrawer();
}
 else noProjectSnack();
break;
case 25:
if (!mNoProject) {
mDbHelper.sortByAscPriority();
rightDrawer.closeDrawer();
}
 else noProjectSnack();
break;
case 26:
if (!mNoProject) {
resetColorsDialog();
}
 else noProjectSnack();
break;
case 30:
leftDrawer.openDrawer();
newProjectDialog();
break;
}
}
if (drawerItem != null && drawerItem instanceof IProfile) {
String projectName=((IProfile)drawerItem).getName().getText(MainActivity.this);
switchToProject(projectName);
}
return false;
}","@Override public boolean onItemClick(View view,int position,IDrawerItem drawerItem){
  if (drawerItem != null) {
    int id=(int)drawerItem.getIdentifier();
switch (id) {
case 1:
      if (!mNoProject) {
        renameProjectDialog();
      }
 else {
        noProjectSnack();
      }
    break;
case 2:
  if (!mNoProject) {
    deleteProjectDialog();
  }
 else {
    noProjectSnack();
  }
break;
case 3:
newProjectDialog();
break;
case 4:
if (!mNoProject) {
header.toggleSelectionList(getApplicationContext());
}
 else {
noProjectSnack();
}
break;
case 8:
forceIntro();
break;
case 9:
leftDrawer.closeDrawer();
Snackbar snackbar=Snackbar.make(findViewById(R.id.main_content),R.string.tuto_mode,Snackbar.LENGTH_SHORT).setCallback(new Snackbar.Callback(){
@Override public void onDismissed(Snackbar snackbar,int event){
mTinyDB.putBoolean(getString(R.string.handle_idea_pref),true);
mTinyDB.putBoolean(getString(R.string.first_project_pref),true);
mTinyDB.putBoolean(getString(R.string.first_idea_pref),true);
mTinyDB.putBoolean(getString(R.string.right_drawer_pref),true);
}
}
);
snackbar.show();
break;
case 10:
Intent browserIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
startActivity(browserIntent);
break;
case 11:
Uri uri=Uri.parse(""String_Node_Str"" + getPackageName());
Intent goToMarket=new Intent(Intent.ACTION_VIEW,uri);
goToMarket.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY | Intent.FLAG_ACTIVITY_NEW_DOCUMENT | Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
try {
startActivity(goToMarket);
}
 catch (ActivityNotFoundException e) {
startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str"" + getPackageName())));
}
break;
case 12:
Intent browserSource=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
startActivity(browserSource);
break;
case 21:
if (!mNoProject) {
new SpectrumDialog.Builder(getApplicationContext()).setTitle(R.string.select_prim_col).setColors(R.array.colors).setSelectedColor(mPrimaryColor).setDismissOnColorSelected(false).setFixedColumnCount(4).setOnColorSelectedListener(new SpectrumDialog.OnColorSelectedListener(){
@Override public void onColorSelected(boolean positiveResult,@ColorInt int color){
if (positiveResult) {
mPrimaryColor=color;
changePrimaryColor();
saveProjectColors();
Drawable disk=ContextCompat.getDrawable(getApplicationContext(),R.drawable.disk);
disk.setColorFilter(mPrimaryColor,PorterDuff.Mode.SRC_ATOP);
IProfile p=header.getActiveProfile();
p.withIcon(disk);
header.updateProfile(p);
}
}
}
).build().show(mFragmentManager,""String_Node_Str"");
}
 else noProjectSnack();
break;
case 22:
if (!mNoProject) {
new SpectrumDialog.Builder(getApplicationContext()).setTitle(R.string.select_sec_col).setColors(R.array.accent_colors).setSelectedColor(mSecondaryColor).setDismissOnColorSelected(false).setFixedColumnCount(4).setOnColorSelectedListener(new SpectrumDialog.OnColorSelectedListener(){
@Override public void onColorSelected(boolean positiveResult,@ColorInt int color){
if (positiveResult) {
mSecondaryColor=color;
changeSecondaryColor();
saveProjectColors();
}
}
}
).build().show(mFragmentManager,""String_Node_Str"");
}
 else noProjectSnack();
break;
case 23:
if (!mNoProject) {
new SpectrumDialog.Builder(getApplicationContext()).setTitle(R.string.select_text_col).setColors(R.array.textColors).setSelectedColor(mTextColor).setDismissOnColorSelected(false).setFixedColumnCount(4).setOutlineWidth(2).setOnColorSelectedListener(new SpectrumDialog.OnColorSelectedListener(){
@Override public void onColorSelected(boolean positiveResult,@ColorInt int color){
if (positiveResult) {
mTextColor=color;
changeTextColor();
saveProjectColors();
}
}
}
).build().show(mFragmentManager,""String_Node_Str"");
}
 else noProjectSnack();
break;
case 24:
if (!mNoProject) {
mDbHelper.clearDoneWithSnack(mViewPager);
rightDrawer.closeDrawer();
}
 else noProjectSnack();
break;
case 25:
if (!mNoProject) {
mDbHelper.sortByAscPriority();
rightDrawer.closeDrawer();
}
 else noProjectSnack();
break;
case 26:
if (!mNoProject) {
resetColorsDialog();
}
 else noProjectSnack();
break;
case 30:
newProjectDialog();
return false;
}
}
if (drawerItem != null && drawerItem instanceof IProfile) {
String projectName=((IProfile)drawerItem).getName().getText(MainActivity.this);
switchToProject(projectName);
}
return false;
}",0.9906868451688008
175432,"@Override public View getChildView(int groupPosition,int childPosition,boolean isLastChild,View view,ViewGroup viewGroup){
  ViewHolder holder=new ViewHolder();
  holder.id=childPosition;
  holder.priority=groupPosition;
  MyRecyclerView horizontal_recycler_view;
  if (view == null) {
    view=inflater.inflate(R.layout.child_layout,viewGroup,false);
    horizontal_recycler_view=(MyRecyclerView)view.findViewById(R.id.horizontal_recycler_view);
    ArrayList<Pair<Integer,String>> ideas=readIdeas(groupPosition);
    Pair<Integer,String> pair=ideas.get(childPosition);
    HorizontalAdapter horizontalAdapter=new HorizontalAdapter(pair.second,1);
    horizontal_recycler_view.setTag(pair.first);
    LinearLayoutManager horizontalLayoutManager=new LinearLayoutManager(inflater.getContext(),LinearLayoutManager.HORIZONTAL,false);
    horizontalLayoutManager.scrollToPositionWithOffset(1,0);
    horizontal_recycler_view.setLayoutManager(horizontalLayoutManager);
    horizontal_recycler_view.setAdapter(horizontalAdapter);
  }
  horizontal_recycler_view=(MyRecyclerView)view.findViewById(R.id.horizontal_recycler_view);
  ArrayList<Pair<Integer,String>> ideas=readIdeas(groupPosition);
  Pair<Integer,String> pair=ideas.get(childPosition);
  HorizontalAdapter horizontalAdapter=(HorizontalAdapter)horizontal_recycler_view.getAdapter();
  horizontalAdapter.editText(pair.second);
  horizontalAdapter.notifyDataSetChanged();
  horizontal_recycler_view.setTag(pair.first);
  return view;
}","@Override public View getChildView(int groupPosition,int childPosition,boolean isLastChild,View view,ViewGroup viewGroup){
  view=inflater.inflate(R.layout.child_layout,viewGroup,false);
  MyRecyclerView horizontal_recycler_view=(MyRecyclerView)view.findViewById(R.id.horizontal_recycler_view);
  ArrayList<Pair<Integer,String>> ideas=readIdeas(groupPosition);
  Pair<Integer,String> pair=ideas.get(childPosition);
  HorizontalAdapter horizontalAdapter=new HorizontalAdapter(pair.second,1);
  horizontal_recycler_view.setTag(pair.first);
  LinearLayoutManager horizontalLayoutManager=new LinearLayoutManager(inflater.getContext(),LinearLayoutManager.HORIZONTAL,false);
  horizontalLayoutManager.scrollToPositionWithOffset(1,0);
  horizontal_recycler_view.setLayoutManager(horizontalLayoutManager);
  horizontal_recycler_view.setAdapter(horizontalAdapter);
  horizontal_recycler_view.setUp();
  return view;
}",0.5837160751565762
175433,"@Override public View getView(int position,View view,ViewGroup parent){
  MyRecyclerView horizontal_recycler_view;
  if (view == null) {
    view=inflater.inflate(R.layout.child_layout,parent,false);
    horizontal_recycler_view=(MyRecyclerView)view.findViewById(R.id.horizontal_recycler_view);
    ArrayList<Pair<Integer,String>> ideas=readIdeas();
    Pair<Integer,String> pair=ideas.get(position);
    HorizontalAdapter horizontalAdapter;
    if (mLater)     horizontalAdapter=new HorizontalAdapter(pair.second,2);
 else     horizontalAdapter=new HorizontalAdapter(pair.second,3);
    horizontal_recycler_view.setTag(pair.first);
    LinearLayoutManager horizontalLayoutManager=new LinearLayoutManager(inflater.getContext(),LinearLayoutManager.HORIZONTAL,false);
    horizontalLayoutManager.scrollToPositionWithOffset(1,0);
    horizontal_recycler_view.setLayoutManager(horizontalLayoutManager);
    horizontal_recycler_view.setAdapter(horizontalAdapter);
  }
  horizontal_recycler_view=(MyRecyclerView)view.findViewById(R.id.horizontal_recycler_view);
  ArrayList<Pair<Integer,String>> ideas=readIdeas();
  Pair<Integer,String> pair=ideas.get(position);
  HorizontalAdapter horizontalAdapter=(HorizontalAdapter)horizontal_recycler_view.getAdapter();
  horizontalAdapter.editText(pair.second);
  horizontalAdapter.notifyDataSetChanged();
  horizontal_recycler_view.setTag(pair.first);
  return view;
}","@Override public View getView(int position,View view,ViewGroup parent){
  view=inflater.inflate(R.layout.child_layout,parent,false);
  MyRecyclerView horizontal_recycler_view=(MyRecyclerView)view.findViewById(R.id.horizontal_recycler_view);
  ArrayList<Pair<Integer,String>> ideas=readIdeas();
  Pair<Integer,String> pair=ideas.get(position);
  HorizontalAdapter horizontalAdapter;
  if (mLater)   horizontalAdapter=new HorizontalAdapter(pair.second,2);
 else   horizontalAdapter=new HorizontalAdapter(pair.second,3);
  horizontal_recycler_view.setTag(pair.first);
  LinearLayoutManager horizontalLayoutManager=new LinearLayoutManager(inflater.getContext(),LinearLayoutManager.HORIZONTAL,false);
  horizontalLayoutManager.scrollToPositionWithOffset(1,0);
  horizontal_recycler_view.setLayoutManager(horizontalLayoutManager);
  horizontal_recycler_view.setAdapter(horizontalAdapter);
  horizontal_recycler_view.setUp();
  return view;
}",0.6515604959384352
175434,"@Override public void onBindViewHolder(final MyViewHolder holder,final int position){
switch (mTabNumber) {
case 1:
switch (position) {
case 0:
      holder.txtView.setText(""String_Node_Str"");
    holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.RIGHT);
  holder.txtView.setBackgroundResource(R.color.pink);
holder.txtView.setTextColor(Color.WHITE);
break;
case 1:
holder.txtView.setText(mIdea);
break;
case 2:
holder.txtView.setText(""String_Node_Str"");
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);
holder.txtView.setBackgroundResource(R.color.orange);
holder.txtView.setTextColor(Color.WHITE);
break;
}
break;
case 2:
switch (position) {
case 0:
holder.txtView.setText(""String_Node_Str"");
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.RIGHT);
holder.txtView.setBackgroundResource(R.color.red);
holder.txtView.setTextColor(Color.WHITE);
break;
case 1:
holder.txtView.setText(mIdea);
break;
case 2:
holder.txtView.setText(""String_Node_Str"");
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);
holder.txtView.setBackgroundResource(R.color.green);
holder.txtView.setTextColor(Color.WHITE);
break;
}
break;
case 3:
switch (position) {
case 0:
holder.txtView.setText(""String_Node_Str"");
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.RIGHT);
holder.txtView.setBackgroundResource(R.color.red);
holder.txtView.setTextColor(Color.WHITE);
break;
case 1:
holder.txtView.setText(mIdea);
break;
case 2:
holder.txtView.setText(""String_Node_Str"");
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);
holder.txtView.setBackgroundResource(R.color.purple);
holder.txtView.setTextColor(Color.WHITE);
break;
}
break;
}
}","@Override public void onBindViewHolder(final MyViewHolder holder,final int position){
switch (mTabNumber) {
case 1:
switch (position) {
case 0:
      holder.txtView.setText(""String_Node_Str"");
    holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.RIGHT);
  holder.txtView.setBackgroundResource(R.color.pink);
holder.txtView.setTextColor(Color.WHITE);
break;
case 1:
holder.txtView.setText(mIdea);
holder.txtView.setBackgroundResource(R.color.white);
holder.txtView.setTextColor(Color.BLACK);
break;
case 2:
holder.txtView.setText(""String_Node_Str"");
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);
holder.txtView.setBackgroundResource(R.color.orange);
holder.txtView.setTextColor(Color.WHITE);
break;
}
break;
case 2:
switch (position) {
case 0:
holder.txtView.setText(""String_Node_Str"");
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.RIGHT);
holder.txtView.setBackgroundResource(R.color.red);
holder.txtView.setTextColor(Color.WHITE);
break;
case 1:
holder.txtView.setText(mIdea);
break;
case 2:
holder.txtView.setText(""String_Node_Str"");
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);
holder.txtView.setBackgroundResource(R.color.green);
holder.txtView.setTextColor(Color.WHITE);
break;
}
break;
case 3:
switch (position) {
case 0:
holder.txtView.setText(""String_Node_Str"");
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.RIGHT);
holder.txtView.setBackgroundResource(R.color.red);
holder.txtView.setTextColor(Color.WHITE);
break;
case 1:
holder.txtView.setText(mIdea);
break;
case 2:
holder.txtView.setText(""String_Node_Str"");
holder.txtView.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);
holder.txtView.setBackgroundResource(R.color.purple);
holder.txtView.setTextColor(Color.WHITE);
break;
}
break;
}
}",0.972693302673182
175435,"public MyRecyclerView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
}","public MyRecyclerView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  isActivated=false;
}",0.9098712446351932
175436,"@Override public void onScrollStateChanged(int state){
  LinearLayoutManager manager=(LinearLayoutManager)this.getLayoutManager();
  int width=manager.getChildAt(0).getWidth();
  double limLeft=0.4d * width;
  double limRight=0.6d * width;
  if (state != RecyclerView.SCROLL_STATE_DRAGGING && !isActivated) {
    View child;
    int first=manager.findFirstVisibleItemPosition();
    int last=manager.findLastVisibleItemPosition();
    int left, right;
    if ((child=manager.getChildAt(0)) != null && first == 0) {
      right=child.getRight();
      if (right > limLeft) {
        isActivated=true;
        smoothScrollToPosition(0);
      }
 else       smoothScrollToPosition(1);
    }
 else     if ((child=manager.getChildAt(1)) != null && last == 2) {
      left=child.getLeft();
      if (left < limRight) {
        isActivated=true;
        smoothScrollToPosition(2);
      }
 else       smoothScrollToPosition(1);
    }
  }
 else   if (isActivated && state == RecyclerView.SCROLL_STATE_IDLE) {
    int first=manager.findFirstVisibleItemPosition();
    if ((manager.getChildAt(0)) != null && first == 0) {
      int tagId=(int)this.getTag();
      editEntry(true,tagId);
    }
 else {
      int tagId=(int)this.getTag();
      editEntry(false,tagId);
    }
  }
}","@Override public void onScrollStateChanged(int state){
  int tab=mAdapter.getTabNumber();
switch (tab) {
case 1:
    stateChangedIdea(state);
  break;
case 2:
stateChangeOther(state);
break;
case 3:
stateChangeOther(state);
break;
}
}",0.0972037283621837
175437,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  mDbHelper=DatabaseHelper.getInstance(this);
  mDatabase=mDbHelper.getWritableDatabase();
  mSectionsPagerAdapter=new SectionsPagerAdapter(getSupportFragmentManager());
  mViewPager=(NonSwipeableViewPager)findViewById(R.id.container);
  mViewPager.setAdapter(mSectionsPagerAdapter);
  scrollTillEnd();
  TabLayout tabLayout=(TabLayout)findViewById(R.id.tabLayout);
  tabLayout.setupWithViewPager(mViewPager);
  tabLayout.removeAllTabs();
  tabLayout.addTab(tabLayout.newTab().setText(""String_Node_Str""));
  tabLayout.addTab(tabLayout.newTab().setText(""String_Node_Str""));
  tabLayout.addTab(tabLayout.newTab().setText(""String_Node_Str""));
  FloatingActionButton fab=(FloatingActionButton)findViewById(R.id.fab);
  fab.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      newIdeaDialog();
    }
  }
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  mDbHelper=DatabaseHelper.getInstance(this);
  mDatabase=mDbHelper.getWritableDatabase();
  mSectionsPagerAdapter=new SectionsPagerAdapter(getSupportFragmentManager());
  mViewPager=(NonSwipeableViewPager)findViewById(R.id.container);
  mViewPager.setAdapter(mSectionsPagerAdapter);
  TabLayout tabLayout=(TabLayout)findViewById(R.id.tabLayout);
  tabLayout.setupWithViewPager(mViewPager);
  tabLayout.removeAllTabs();
  tabLayout.addTab(tabLayout.newTab().setText(""String_Node_Str""));
  tabLayout.addTab(tabLayout.newTab().setText(""String_Node_Str""));
  tabLayout.addTab(tabLayout.newTab().setText(""String_Node_Str""));
  FloatingActionButton fab=(FloatingActionButton)findViewById(R.id.fab);
  fab.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      newIdeaDialog();
    }
  }
);
}",0.9911421911421912
175438,"@Override public void connect(ServerInfo target,Callback<Boolean> callback){
}","@Override public void connect(ServerInfo target,Callback<Boolean> callback,Reason reason){
  callback.done(false,null);
}",0.7839195979899497
175439,"private static String loadHeader(){
  StringBuilder header=new StringBuilder();
  try {
    @Cleanup BufferedReader reader=new BufferedReader(new InputStreamReader(BungeeChat.getInstance().getResourceAsStream(CONFIG_FILE_NAME),StandardCharsets.UTF_8));
    do {
      line=reader.readLine();
      header.append(line).append('\n');
    }
 while (line.startsWith(""String_Node_Str""));
  }
 catch (  IOException e) {
    LoggerHelper.error(""String_Node_Str"",e);
  }
  return header.toString();
}","private static String loadHeader(){
  StringBuilder header=new StringBuilder();
  try {
    @Cleanup BufferedReader reader=new BufferedReader(new InputStreamReader(BungeeChat.getInstance().getResourceAsStream(CONFIG_FILE_NAME),StandardCharsets.UTF_8));
    String line;
    do {
      line=reader.readLine();
      header.append(line).append('\n');
    }
 while (line.startsWith(""String_Node_Str""));
  }
 catch (  IOException e) {
    LoggerHelper.error(""String_Node_Str"",e);
  }
  return header.toString();
}",0.983016983016983
175440,"@SneakyThrows(ManagedProcessException.class) public static void startDatabase(){
  final int limit=100;
  int count=0;
  String actualBaseDir;
  String actualDataDir;
  do {
    actualBaseDir=baseDir + count;
  }
 while ((++count < limit) && (new File(actualBaseDir)).exists());
  Preconditions.checkElementIndex(count,limit,""String_Node_Str"" + limit);
  actualDataDir=actualBaseDir + ""String_Node_Str"";
  final DBConfiguration config=DBConfigurationBuilder.newBuilder().setPort(0).setSocket(localhost).setBaseDir(actualBaseDir).setDataDir(actualDataDir).build();
  databaseInstance=DB.newEmbeddedDB(config);
  databaseInstance.start();
  port=databaseInstance.getConfiguration().getPort();
  host=localhost + ':' + port;
  databaseInstance.createDB(""String_Node_Str"");
}","@SneakyThrows(ManagedProcessException.class) @SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public static void startDatabase(){
  final int limit=100;
  int count=0;
  String actualBaseDir;
  String actualDataDir;
  do {
    actualBaseDir=baseDir + count;
  }
 while ((++count < limit) && (new File(actualBaseDir)).exists());
  Preconditions.checkElementIndex(count,limit,""String_Node_Str"" + limit);
  actualDataDir=actualBaseDir + ""String_Node_Str"";
  final DBConfiguration config=DBConfigurationBuilder.newBuilder().setPort(0).setSocket(localhost).setBaseDir(actualBaseDir).setDataDir(actualDataDir).build();
  databaseInstance=DB.newEmbeddedDB(config);
  databaseInstance.start();
  port=databaseInstance.getConfiguration().getPort();
  host=localhost + ':' + port;
  databaseInstance.createDB(""String_Node_Str"");
}",0.9524397776405188
175441,"public static Connection getDatabaseInstance() throws SQLException {
  return DriverManager.getConnection(""String_Node_Str"" + host + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public static Connection getDatabaseInstance() throws SQLException {
  return DriverManager.getConnection(""String_Node_Str"" + host + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.8315098468271335
175442,"public static void deinitBungeeChat() throws IOException {
  FileUtils.deleteDirectory(bungeeChat.getConfigFolder());
  bungeeChat.getConfigFolder().mkdirs();
}","public static void deinitBungeeChat() throws IOException {
  FileUtils.deleteDirectory(bungeeChat.getConfigFolder());
  Preconditions.checkState(bungeeChat.getConfigFolder().mkdirs(),""String_Node_Str"");
}",0.8791208791208791
175443,"private static void cleanTempDir(){
  if (tempDir.exists()) {
    for (    File f : tempDir.listFiles()) {
      f.delete();
    }
    tempDir.delete();
  }
}","@SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") private static void cleanTempDir(){
  if (tempDir.exists()) {
    final File[] files=tempDir.listFiles();
    if (files != null) {
      for (      File f : files) {
        f.delete();
      }
    }
    tempDir.delete();
  }
}",0.3679653679653679
175444,"@Before public void setUp(){
  tempDir.mkdirs();
}","@Before public void setUp(){
  Preconditions.checkState(tempDir.mkdirs(),""String_Node_Str"");
}",0.6944444444444444
175445,"@AfterClass public static void tearDownClass(){
  cleanTempDir();
  tempDir.delete();
}","@AfterClass public static void tearDownClass(){
  cleanTempDir();
}",0.8701298701298701
175446,"@EventHandler(priority=EventPriority.HIGH) public void onPlayerChat(ChatEvent e){
  if (e.isCancelled())   return;
  if (!(e.getSender() instanceof ProxiedPlayer))   return;
  ProxiedPlayer sender=(ProxiedPlayer)e.getSender();
  String message=e.getMessage();
  BungeeChatAccount accout=BungeecordAccountManager.getAccount(sender).get();
  if (ChatUtils.isCommand(message))   return;
  if (accout.getChannelType() == ChannelType.STAFF)   return;
  if (BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getBoolean(""String_Node_Str"")) {
    if (MessagesService.getGlobalPredicate().test(accout)) {
      e.setCancelled(!passToClientServer);
      MessagesService.sendGlobalMessage(sender,message);
      return;
    }
  }
  if (BungeecordAccountManager.getAccount(sender).get().getChannelType() == ChannelType.GLOBAL) {
    if (!MessagesService.getGlobalPredicate().test(accout)) {
      MessagesService.sendMessage(sender,Message.NOT_IN_GLOBAL_SERVER.get());
      return;
    }
    e.setCancelled(!passToClientServer);
    MessagesService.sendGlobalMessage(sender,message);
    return;
  }
  Config section=BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().atPath(""String_Node_Str"");
  if (section.getBoolean(""String_Node_Str"")) {
    String symbol=section.getString(""String_Node_Str"");
    if (message.startsWith(symbol) && !symbol.equals(""String_Node_Str"")) {
      if (!MessagesService.getGlobalPredicate().test(accout)) {
        MessagesService.sendMessage(sender,Message.NOT_IN_GLOBAL_SERVER.get());
        return;
      }
      e.setCancelled(!passToClientServer);
      MessagesService.sendGlobalMessage(sender,message.replaceFirst(symbol,""String_Node_Str""));
    }
  }
}","@EventHandler(priority=EventPriority.HIGH) public void onPlayerChat(ChatEvent e){
  if (e.isCancelled())   return;
  if (!(e.getSender() instanceof ProxiedPlayer))   return;
  ProxiedPlayer sender=(ProxiedPlayer)e.getSender();
  String message=e.getMessage();
  BungeeChatAccount accout=BungeecordAccountManager.getAccount(sender).get();
  if (ChatUtils.isCommand(message))   return;
  if (accout.getChannelType() == ChannelType.STAFF)   return;
  if (BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getBoolean(""String_Node_Str"")) {
    if (MessagesService.getGlobalPredicate().test(accout)) {
      e.setCancelled(!passToClientServer);
      MessagesService.sendGlobalMessage(sender,message);
      return;
    }
  }
  if (BungeecordAccountManager.getAccount(sender).get().getChannelType() == ChannelType.GLOBAL) {
    if (!MessagesService.getGlobalPredicate().test(accout)) {
      MessagesService.sendMessage(sender,Message.NOT_IN_GLOBAL_SERVER.get());
      return;
    }
    e.setCancelled(!passToClientServer);
    MessagesService.sendGlobalMessage(sender,message);
    return;
  }
  Config section=BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getConfig(""String_Node_Str"");
  if (section.getBoolean(""String_Node_Str"")) {
    String symbol=section.getString(""String_Node_Str"");
    if (message.startsWith(symbol) && !symbol.equals(""String_Node_Str"")) {
      if (!MessagesService.getGlobalPredicate().test(accout)) {
        MessagesService.sendMessage(sender,Message.NOT_IN_GLOBAL_SERVER.get());
        return;
      }
      e.setCancelled(!passToClientServer);
      MessagesService.sendGlobalMessage(sender,message.replaceFirst(symbol,""String_Node_Str""));
    }
  }
}",0.9956024626209324
175447,"public static Predicate<BungeeChatAccount> getGlobalPredicate(){
  final Config section=BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().atPath(""String_Node_Str"");
  if (!section.getBoolean(""String_Node_Str""))   return account -> true;
 else {
    List<String> allowedServers=section.getStringList(""String_Node_Str"");
    return account -> allowedServers.contains(account.getServerName());
  }
}","public static Predicate<BungeeChatAccount> getGlobalPredicate(){
  final Config section=BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getConfig(""String_Node_Str"");
  if (!section.getBoolean(""String_Node_Str""))   return account -> true;
 else {
    List<String> allowedServers=section.getStringList(""String_Node_Str"");
    return account -> allowedServers.contains(account.getServerName());
  }
}",0.9816849816849816
175448,"protected void load(){
  Config defaultConfig=ConfigFactory.parseReader(new InputStreamReader(BungeeChat.getInstance().getResourceAsStream(CONFIG_FILE_NAME)),PARSE_OPTIONS);
  if (CONFIG_FILE.exists()) {
    Config fileConfig=ConfigFactory.parseFile(CONFIG_FILE,PARSE_OPTIONS);
    config=fileConfig.withFallback(defaultConfig);
  }
 else {
    config=defaultConfig;
  }
  save();
}","protected void load(){
  Config defaultConfig=ConfigFactory.parseReader(new InputStreamReader(BungeeChat.getInstance().getResourceAsStream(CONFIG_FILE_NAME)),PARSE_OPTIONS);
  if (CONFIG_FILE.exists()) {
    Config fileConfig=ConfigFactory.parseFile(CONFIG_FILE,PARSE_OPTIONS);
    config=fileConfig.withFallback(defaultConfig);
  }
 else {
    config=defaultConfig;
  }
  config=config.resolve();
  save();
}",0.9608091024020228
175449,"public static Predicate<? super BungeeChatAccount> getLocalPredicate(String serverName){
  return account -> serverName.equals(account.getServerName());
}","public static Predicate<BungeeChatAccount> getLocalPredicate(String serverName){
  return account -> serverName.equals(account.getServerName());
}",0.9733333333333334
175450,"public static void sendLocalMessage(BungeeChatContext context) throws InvalidContextError {
  context.require(BungeeChatContext.HAS_SENDER,BungeeChatContext.HAS_MESSAGE);
  Optional<BungeeChatAccount> account=context.getSender();
  Optional<String> finalMessage=preProcessMessage(context,Format.LOCAL_CHAT);
  String localServerName=context.getSender().get().getServerName();
  Predicate<? super BungeeChatAccount> isLocal=getLocalPredicate(localServerName);
  sendToMatchingPlayers(finalMessage,isLocal);
  ChatLoggingManager.logMessage(ChannelType.LOCAL,context);
  if (ModuleManager.isModuleActive(BungeecordModuleManager.SPY_MODULE)) {
    String localSpyMessage=preProcessMessage(context,account,Format.LOCAL_SPY,false).get();
    Predicate<? super BungeeChatAccount> isNotLocal=isLocal.negate();
    sendToMatchingPlayers(localSpyMessage,BungeeChatAccount::hasLocalSpyEnabled,isNotLocal);
  }
}","public static void sendLocalMessage(BungeeChatContext context) throws InvalidContextError {
  context.require(BungeeChatContext.HAS_SENDER,BungeeChatContext.HAS_MESSAGE);
  Optional<BungeeChatAccount> account=context.getSender();
  Optional<String> finalMessage=preProcessMessage(context,Format.LOCAL_CHAT);
  String localServerName=context.getSender().get().getServerName();
  Predicate<BungeeChatAccount> isLocal=getLocalPredicate(localServerName);
  sendToMatchingPlayers(finalMessage,isLocal);
  ChatLoggingManager.logMessage(ChannelType.LOCAL,context);
  if (ModuleManager.isModuleActive(BungeecordModuleManager.SPY_MODULE)) {
    String localSpyMessage=preProcessMessage(context,account,Format.LOCAL_SPY,false).get();
    Predicate<BungeeChatAccount> isNotLocal=isLocal.negate();
    sendToMatchingPlayers(localSpyMessage,BungeeChatAccount::hasLocalSpyEnabled,isNotLocal);
  }
}",0.9910313901345292
175451,"public static Predicate<? super BungeeChatAccount> getGlobalPredicate(){
  final Configuration section=BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getSection(""String_Node_Str"");
  if (!section.getBoolean(""String_Node_Str""))   return account -> true;
 else {
    List<String> allowedServers=section.getStringList(""String_Node_Str"");
    return account -> allowedServers.contains(account.getServerName());
  }
}","public static Predicate<BungeeChatAccount> getGlobalPredicate(){
  final Configuration section=BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getSection(""String_Node_Str"");
  if (!section.getBoolean(""String_Node_Str""))   return account -> true;
 else {
    List<String> allowedServers=section.getStringList(""String_Node_Str"");
    return account -> allowedServers.contains(account.getServerName());
  }
}",0.9905437352245864
175452,"@SafeVarargs @SuppressWarnings(""String_Node_Str"") public static void sendToMatchingPlayers(String finalMessage,Predicate<? super BungeeChatAccount>... playerFilters){
  Predicate<? super BungeeChatAccount> playerFiler=Arrays.stream(playerFilters).reduce(acc -> true,Predicate::and);
  AccountManager.getPlayerAccounts().stream().filter(playerFiler).forEach(account -> BungeecordAccountManager.getCommandSender(account).get().sendMessage(finalMessage));
}","@SafeVarargs @SuppressWarnings(""String_Node_Str"") public static void sendToMatchingPlayers(String finalMessage,Predicate<BungeeChatAccount>... playerFilters){
  Predicate<BungeeChatAccount> playerFiler=Arrays.stream(playerFilters).reduce(Predicate::and).orElse(acc -> true);
  AccountManager.getPlayerAccounts().stream().filter(playerFiler).forEach(account -> BungeecordAccountManager.getCommandSender(account).get().sendMessage(finalMessage));
}",0.94
175453,"private void prepareStatements(){
  try {
    String saveAccountStr=""String_Node_Str"" + tableAccounts + ""String_Node_Str""+ tableAccountsColumnUUID+ ""String_Node_Str""+ tableAccountsColumnChannelType+ ""String_Node_Str""+ tableAccountsColumnVanished+ ""String_Node_Str""+ tableAccountsColumnMessenger+ ""String_Node_Str""+ tableAccountsColumnSocialSpy+ ""String_Node_Str""+ tableAccountsColumnMutedUntil+ ""String_Node_Str""+ tableAccountsColumnStoredPrefix+ ""String_Node_Str""+ tableAccountsColumnStoredSuffix+ ""String_Node_Str""+ tableAccountsColumnChannelType+ ""String_Node_Str""+ tableAccountsColumnChannelType+ ""String_Node_Str""+ tableAccountsColumnVanished+ ""String_Node_Str""+ tableAccountsColumnVanished+ ""String_Node_Str""+ tableAccountsColumnMessenger+ ""String_Node_Str""+ tableAccountsColumnMessenger+ ""String_Node_Str""+ tableAccountsColumnSocialSpy+ ""String_Node_Str""+ tableAccountsColumnSocialSpy+ ""String_Node_Str""+ tableAccountsColumnLocalSpy+ ""String_Node_Str""+ tableAccountsColumnLocalSpy+ ""String_Node_Str""+ tableAccountsColumnMutedUntil+ ""String_Node_Str""+ tableAccountsColumnMutedUntil+ ""String_Node_Str""+ tableAccountsColumnStoredPrefix+ ""String_Node_Str""+ tableAccountsColumnStoredPrefix+ ""String_Node_Str""+ tableAccountsColumnStoredSuffix+ ""String_Node_Str""+ tableAccountsColumnStoredSuffix+ ""String_Node_Str"";
    String loadAccountStr=""String_Node_Str"" + tableAccountsColumnChannelType + ""String_Node_Str""+ tableAccountsColumnVanished+ ""String_Node_Str""+ tableAccountsColumnMessenger+ ""String_Node_Str""+ tableAccountsColumnSocialSpy+ ""String_Node_Str""+ tableAccountsColumnLocalSpy+ ""String_Node_Str""+ tableAccountsColumnMutedUntil+ ""String_Node_Str""+ tableAccountsColumnStoredPrefix+ ""String_Node_Str""+ tableAccountsColumnStoredSuffix+ ""String_Node_Str""+ tableAccounts+ ""String_Node_Str""+ tableAccountsColumnUUID+ ""String_Node_Str"";
    String deleteIgnoresStr=""String_Node_Str"" + tableIgnores + ""String_Node_Str""+ tableIgnoresColumnUser+ ""String_Node_Str"";
    String addIgnoreStr=""String_Node_Str"" + tableIgnores + ""String_Node_Str""+ tableIgnoresColumnUser+ ""String_Node_Str""+ tableIgnoresColumnIgnores+ ""String_Node_Str"";
    String getIgnoresStr=""String_Node_Str"" + tableIgnoresColumnIgnores + ""String_Node_Str""+ tableIgnores+ ""String_Node_Str""+ tableIgnoresColumnUser+ ""String_Node_Str"";
    saveAccount=getPreparedStatement(saveAccountStr);
    loadAccount=getPreparedStatement(loadAccountStr);
    deleteIgnores=getPreparedStatement(deleteIgnoresStr);
    addIgnore=getPreparedStatement(addIgnoreStr);
    getIgnores=getPreparedStatement(getIgnoresStr);
  }
 catch (  SQLException e) {
    LoggerHelper.error(""String_Node_Str"",e);
  }
}","private void prepareStatements(){
  try {
    String saveAccountStr=""String_Node_Str"" + tableAccounts + ""String_Node_Str""+ tableAccountsColumnUUID+ ""String_Node_Str""+ tableAccountsColumnChannelType+ ""String_Node_Str""+ tableAccountsColumnVanished+ ""String_Node_Str""+ tableAccountsColumnMessenger+ ""String_Node_Str""+ tableAccountsColumnSocialSpy+ ""String_Node_Str""+ tableAccountsColumnLocalSpy+ ""String_Node_Str""+ tableAccountsColumnMutedUntil+ ""String_Node_Str""+ tableAccountsColumnStoredPrefix+ ""String_Node_Str""+ tableAccountsColumnStoredSuffix+ ""String_Node_Str""+ tableAccountsColumnChannelType+ ""String_Node_Str""+ tableAccountsColumnChannelType+ ""String_Node_Str""+ tableAccountsColumnVanished+ ""String_Node_Str""+ tableAccountsColumnVanished+ ""String_Node_Str""+ tableAccountsColumnMessenger+ ""String_Node_Str""+ tableAccountsColumnMessenger+ ""String_Node_Str""+ tableAccountsColumnSocialSpy+ ""String_Node_Str""+ tableAccountsColumnSocialSpy+ ""String_Node_Str""+ tableAccountsColumnLocalSpy+ ""String_Node_Str""+ tableAccountsColumnLocalSpy+ ""String_Node_Str""+ tableAccountsColumnMutedUntil+ ""String_Node_Str""+ tableAccountsColumnMutedUntil+ ""String_Node_Str""+ tableAccountsColumnStoredPrefix+ ""String_Node_Str""+ tableAccountsColumnStoredPrefix+ ""String_Node_Str""+ tableAccountsColumnStoredSuffix+ ""String_Node_Str""+ tableAccountsColumnStoredSuffix+ ""String_Node_Str"";
    String loadAccountStr=""String_Node_Str"" + tableAccountsColumnChannelType + ""String_Node_Str""+ tableAccountsColumnVanished+ ""String_Node_Str""+ tableAccountsColumnMessenger+ ""String_Node_Str""+ tableAccountsColumnSocialSpy+ ""String_Node_Str""+ tableAccountsColumnLocalSpy+ ""String_Node_Str""+ tableAccountsColumnMutedUntil+ ""String_Node_Str""+ tableAccountsColumnStoredPrefix+ ""String_Node_Str""+ tableAccountsColumnStoredSuffix+ ""String_Node_Str""+ tableAccounts+ ""String_Node_Str""+ tableAccountsColumnUUID+ ""String_Node_Str"";
    String deleteIgnoresStr=""String_Node_Str"" + tableIgnores + ""String_Node_Str""+ tableIgnoresColumnUser+ ""String_Node_Str"";
    String addIgnoreStr=""String_Node_Str"" + tableIgnores + ""String_Node_Str""+ tableIgnoresColumnUser+ ""String_Node_Str""+ tableIgnoresColumnIgnores+ ""String_Node_Str"";
    String getIgnoresStr=""String_Node_Str"" + tableIgnoresColumnIgnores + ""String_Node_Str""+ tableIgnores+ ""String_Node_Str""+ tableIgnoresColumnUser+ ""String_Node_Str"";
    saveAccount=getPreparedStatement(saveAccountStr);
    loadAccount=getPreparedStatement(loadAccountStr);
    deleteIgnores=getPreparedStatement(deleteIgnoresStr);
    addIgnore=getPreparedStatement(addIgnoreStr);
    getIgnores=getPreparedStatement(getIgnoresStr);
  }
 catch (  SQLException e) {
    LoggerHelper.error(""String_Node_Str"",e);
  }
}",0.9910246821241586
175454,"@Override @SuppressWarnings(""String_Node_Str"") public void execute(CommandSender sender,String[] args){
  if (PermissionManager.hasPermission(sender,Permission.COMMAND_GLOBAL)) {
    if (BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getBoolean(""String_Node_Str"")) {
      sender.sendMessage(Message.GLOBAL_IS_DEFAULT.get());
      return;
    }
    if (Config.get().getBoolean(""String_Node_Str"") && (sender instanceof ProxiedPlayer)) {
      BungeeChatAccount account=BungeecordAccountManager.getAccount(sender).get();
      if (!Config.get().getStringList(""String_Node_Str"").contains(account.getServerName())) {
        sender.sendMessage(Message.NOT_IN_GLOBAL_SERVER.get());
        return;
      }
    }
    if (args.length < 1) {
      if (!(sender instanceof ProxiedPlayer)) {
        sender.sendMessage(Message.NOT_A_PLAYER.get());
        return;
      }
      if (PermissionManager.hasPermission(sender,Permission.COMMAND_GLOBAL_TOGGLE)) {
        BungeeChatAccount player=BungeecordAccountManager.getAccount(sender).get();
        if (player.getChannelType() == ChannelType.GLOBAL) {
          player.setChannelType(ChannelType.LOCAL);
          sender.sendMessage(Message.ENABLE_LOCAL.get());
        }
 else {
          player.setChannelType(ChannelType.GLOBAL);
          sender.sendMessage(Message.ENABLE_GLOBAL.get());
        }
      }
 else {
        sender.sendMessage(Message.INCORRECT_USAGE.get(sender,""String_Node_Str""));
      }
    }
 else {
      StringBuilder stringBuilder=new StringBuilder();
      for (      String arg : args) {
        stringBuilder.append(arg).append(""String_Node_Str"");
      }
      MessagesService.sendGlobalMessage(sender,stringBuilder.toString().trim());
    }
  }
}","@Override @SuppressWarnings(""String_Node_Str"") public void execute(CommandSender sender,String[] args){
  if (PermissionManager.hasPermission(sender,Permission.COMMAND_GLOBAL)) {
    if (BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getBoolean(""String_Node_Str"")) {
      sender.sendMessage(Message.GLOBAL_IS_DEFAULT.get());
      return;
    }
    if (BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getBoolean(""String_Node_Str"") && (sender instanceof ProxiedPlayer)) {
      BungeeChatAccount account=BungeecordAccountManager.getAccount(sender).get();
      if (!BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getStringList(""String_Node_Str"").contains(account.getServerName())) {
        sender.sendMessage(Message.NOT_IN_GLOBAL_SERVER.get());
        return;
      }
    }
    if (args.length < 1) {
      if (!(sender instanceof ProxiedPlayer)) {
        sender.sendMessage(Message.NOT_A_PLAYER.get());
        return;
      }
      if (PermissionManager.hasPermission(sender,Permission.COMMAND_GLOBAL_TOGGLE)) {
        BungeeChatAccount player=BungeecordAccountManager.getAccount(sender).get();
        if (player.getChannelType() == ChannelType.GLOBAL) {
          player.setChannelType(ChannelType.LOCAL);
          sender.sendMessage(Message.ENABLE_LOCAL.get());
        }
 else {
          player.setChannelType(ChannelType.GLOBAL);
          sender.sendMessage(Message.ENABLE_GLOBAL.get());
        }
      }
 else {
        sender.sendMessage(Message.INCORRECT_USAGE.get(sender,""String_Node_Str""));
      }
    }
 else {
      StringBuilder stringBuilder=new StringBuilder();
      for (      String arg : args) {
        stringBuilder.append(arg).append(""String_Node_Str"");
      }
      MessagesService.sendGlobalMessage(sender,stringBuilder.toString().trim());
    }
  }
}",0.9624228827818284
175455,"@EventHandler(priority=EventPriority.LOWEST) public void onPlayerChat(ChatEvent e){
  if (e.isCancelled())   return;
  if (!(e.getSender() instanceof ProxiedPlayer))   return;
  ProxiedPlayer player=(ProxiedPlayer)e.getSender();
  Optional<BungeeChatAccount> bungeeChatAccountOptional=AccountManager.getAccount(player.getUniqueId());
  ChannelType c=bungeeChatAccountOptional.get().getChannelType();
  if ((c.equals(ChannelType.GLOBAL) && !BungeecordModuleManager.isModuleActive(BungeecordModuleManager.GLOBAL_CHAT_MODULE)) || (c.equals(ChannelType.STAFF) && !BungeecordModuleManager.isModuleActive(BungeecordModuleManager.STAFF_CHAT_MODULE))) {
    e.setCancelled(true);
    bungeeChatAccountOptional.get().setChannelType(ChannelType.LOCAL);
    player.sendMessage(Message.BACK_TO_LOCAL.get());
  }
}","@EventHandler(priority=EventPriority.LOWEST) public void onPlayerChat(ChatEvent e){
  if (e.isCancelled())   return;
  if (!(e.getSender() instanceof ProxiedPlayer))   return;
  ProxiedPlayer player=(ProxiedPlayer)e.getSender();
  Optional<BungeeChatAccount> bungeeChatAccountOptional=AccountManager.getAccount(player.getUniqueId());
  ChannelType c=bungeeChatAccountOptional.get().getChannelType();
  if ((c.equals(ChannelType.GLOBAL) && (!BungeecordModuleManager.isModuleActive(BungeecordModuleManager.GLOBAL_CHAT_MODULE) || !PermissionManager.hasPermission(player,Permission.COMMAND_GLOBAL))) || (c.equals(ChannelType.STAFF) && (!BungeecordModuleManager.isModuleActive(BungeecordModuleManager.STAFF_CHAT_MODULE) || !PermissionManager.hasPermission(player,Permission.COMMAND_STAFFCHAT)))) {
    e.setCancelled(true);
    bungeeChatAccountOptional.get().setChannelType(ChannelType.LOCAL);
    player.sendMessage(Message.BACK_TO_LOCAL.get());
  }
}",0.9148084619782731
175456,"@EventHandler public void onPlayerChat(ChatEvent e){
  if (e.isCancelled())   return;
  if (!(e.getSender() instanceof ProxiedPlayer))   return;
  ProxiedPlayer sender=(ProxiedPlayer)e.getSender();
  String message=e.getMessage();
  if ((BungeecordAccountManager.getAccount(sender).get().getChannelType() == ChannelType.GLOBAL) && !ChatUtils.isCommand(message)) {
    if (Config.get().getBoolean(""String_Node_Str"")) {
      BungeeChatAccount account=BungeecordAccountManager.getAccount(sender).get();
      if (!Config.get().getStringList(""String_Node_Str"").contains(account.getServerName())) {
        sender.sendMessage(Message.NOT_IN_GLOBAL_SERVER.get());
        return;
      }
    }
    e.setCancelled(true);
    MessagesService.sendGlobalMessage(sender,message);
    return;
  }
  if (BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getBoolean(""String_Node_Str"")) {
    String symbol=BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getString(""String_Node_Str"");
    if (message.startsWith(symbol) && !symbol.equals(""String_Node_Str"")) {
      if (Config.get().getBoolean(""String_Node_Str"")) {
        BungeeChatAccount account=BungeecordAccountManager.getAccount(sender).get();
        if (!Config.get().getStringList(""String_Node_Str"").contains(account.getServerName())) {
          sender.sendMessage(Message.NOT_IN_GLOBAL_SERVER.get());
          return;
        }
      }
      e.setCancelled(true);
      MessagesService.sendGlobalMessage(sender,message.replaceFirst(symbol,""String_Node_Str""));
    }
  }
}","@EventHandler(priority=EventPriority.LOW) public void onPlayerChat(ChatEvent e){
  if (e.isCancelled())   return;
  if (!(e.getSender() instanceof ProxiedPlayer))   return;
  ProxiedPlayer sender=(ProxiedPlayer)e.getSender();
  String message=e.getMessage();
  if (BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getBoolean(""String_Node_Str"")) {
    if (BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getBoolean(""String_Node_Str"")) {
      BungeeChatAccount account=BungeecordAccountManager.getAccount(sender).get();
      if (BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getStringList(""String_Node_Str"").contains(account.getServerName())) {
        e.setCancelled(true);
        MessagesService.sendGlobalMessage(sender,message);
        return;
      }
    }
  }
  if ((BungeecordAccountManager.getAccount(sender).get().getChannelType() == ChannelType.GLOBAL) && !ChatUtils.isCommand(message)) {
    if (BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getBoolean(""String_Node_Str"")) {
      BungeeChatAccount account=BungeecordAccountManager.getAccount(sender).get();
      if (!BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getStringList(""String_Node_Str"").contains(account.getServerName())) {
        sender.sendMessage(Message.NOT_IN_GLOBAL_SERVER.get());
        return;
      }
    }
    e.setCancelled(true);
    MessagesService.sendGlobalMessage(sender,message);
    return;
  }
  if (BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getBoolean(""String_Node_Str"")) {
    String symbol=BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getString(""String_Node_Str"");
    if (message.startsWith(symbol) && !symbol.equals(""String_Node_Str"")) {
      if (BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getBoolean(""String_Node_Str"")) {
        BungeeChatAccount account=BungeecordAccountManager.getAccount(sender).get();
        if (!BungeecordModuleManager.GLOBAL_CHAT_MODULE.getModuleSection().getStringList(""String_Node_Str"").contains(account.getServerName())) {
          sender.sendMessage(Message.NOT_IN_GLOBAL_SERVER.get());
          return;
        }
      }
      e.setCancelled(true);
      MessagesService.sendGlobalMessage(sender,message.replaceFirst(symbol,""String_Node_Str""));
    }
  }
}",0.7807652533609101
175457,"@EventHandler(priority=EventPriority.LOW) public void onPlayerChat(ChatEvent e){
  if (e.isCancelled())   return;
  if (!(e.getSender() instanceof ProxiedPlayer))   return;
  ProxiedPlayer sender=(ProxiedPlayer)e.getSender();
  String message=e.getMessage();
  if ((BungeecordAccountManager.getAccount(sender).get().getChannelType() == ChannelType.STAFF) && !ChatUtils.isCommand(message)) {
    if (!PermissionManager.hasPermission(sender,Permission.COMMAND_STAFFCHAT)) {
      BungeecordAccountManager.getAccount(sender).get().setChannelType(ChannelType.LOCAL);
      return;
    }
    e.setCancelled(true);
    MessagesService.sendStaffMessage(sender,message);
  }
}","@EventHandler public void onPlayerChat(ChatEvent e){
  if (e.isCancelled())   return;
  if (!(e.getSender() instanceof ProxiedPlayer))   return;
  ProxiedPlayer sender=(ProxiedPlayer)e.getSender();
  String message=e.getMessage();
  if ((BungeecordAccountManager.getAccount(sender).get().getChannelType() == ChannelType.STAFF) && !ChatUtils.isCommand(message)) {
    e.setCancelled(true);
    MessagesService.sendStaffMessage(sender,message);
  }
}",0.8028673835125448
175458,"@Override @SuppressWarnings(""String_Node_Str"") public void execute(CommandSender sender,String[] args){
  if (PermissionManager.hasPermission(sender,Permission.COMMAND_TOGGLE_MESSAGE)) {
    if (!(sender instanceof ProxiedPlayer)) {
      sender.sendMessage(Message.NOT_A_PLAYER.get());
    }
 else {
      BungeeChatAccount player=BungeecordAccountManager.getAccount(sender).get();
      player.toggleVanished();
      if (player.isVanished()) {
        sender.sendMessage(Message.ENABLE_VANISH.get());
      }
 else {
        sender.sendMessage(Message.DISABLE_VANISH.get());
      }
    }
  }
}","@Override @SuppressWarnings(""String_Node_Str"") public void execute(CommandSender sender,String[] args){
  if (PermissionManager.hasPermission(sender,Permission.COMMAND_VANISH)) {
    if (!(sender instanceof ProxiedPlayer)) {
      sender.sendMessage(Message.NOT_A_PLAYER.get());
    }
 else {
      BungeeChatAccount player=BungeecordAccountManager.getAccount(sender).get();
      player.toggleVanished();
      if (player.isVanished()) {
        sender.sendMessage(Message.ENABLE_VANISH.get());
      }
 else {
        sender.sendMessage(Message.DISABLE_VANISH.get());
      }
    }
  }
}",0.9831365935919056
175459,"public void onEnable(boolean prinLoadScreen){
  Config.load();
  PlaceHolders.registerPlaceholders();
  AccountManager.setAccountStorage(new AccountFileStorage());
  if (CONFIG_VERSION != Config.get().getDouble(""String_Node_Str"")) {
    LoggerHelper.info(""String_Node_Str"");
    LoggerHelper.info(""String_Node_Str"");
    return;
  }
  bungeeChatCommand=new BungeeChatCommand();
  bungeecordAccountManager=new BungeecordAccountManager();
  ProxyServer.getInstance().getPluginManager().registerCommand(this,bungeeChatCommand);
  ProxyServer.getInstance().getPluginManager().registerListener(this,bungeecordAccountManager);
  Configuration permissionsManager=Config.get().getSection(""String_Node_Str"");
  BungeecordModuleManager.registerPluginModules();
  ModuleManager.enableModules();
  HookManager.addHook(storedDataHookName,new StoredDataHook());
  HookManager.addHook(defaultHookName,new DefaultHook(permissionsManager.getString(""String_Node_Str""),permissionsManager.getString(""String_Node_Str"")));
  if (prinLoadScreen) {
    loadScreen();
  }
}","public void onEnable(boolean prinLoadScreen){
  Config.load();
  PlaceHolders.registerPlaceholders();
  AccountManager.setAccountStorage(new AccountFileStorage());
  if (CONFIG_VERSION != Config.get().getDouble(""String_Node_Str"")) {
    LoggerHelper.info(""String_Node_Str"");
    LoggerHelper.info(""String_Node_Str"");
    return;
  }
  bungeeChatCommand=new BungeeChatCommand();
  bungeecordAccountManager=new BungeecordAccountManager();
  channelTypeCorrectorListener=new ChannelTypeCorrectorListener();
  ProxyServer.getInstance().getPluginManager().registerCommand(this,bungeeChatCommand);
  ProxyServer.getInstance().getPluginManager().registerListener(this,bungeecordAccountManager);
  ProxyServer.getInstance().getPluginManager().registerListener(this,channelTypeCorrectorListener);
  Configuration permissionsManager=Config.get().getSection(""String_Node_Str"");
  BungeecordModuleManager.registerPluginModules();
  ModuleManager.enableModules();
  HookManager.addHook(storedDataHookName,new StoredDataHook());
  HookManager.addHook(defaultHookName,new DefaultHook(permissionsManager.getString(""String_Node_Str""),permissionsManager.getString(""String_Node_Str"")));
  if (prinLoadScreen) {
    loadScreen();
  }
}",0.9262041537781706
175460,"@Override public void onDisable(){
  HookManager.removeHook(defaultHookName);
  HookManager.removeHook(storedDataHookName);
  ModuleManager.disableModules();
  ProxyServer.getInstance().getPluginManager().unregisterListener(bungeecordAccountManager);
  ProxyServer.getInstance().getPluginManager().unregisterCommand(bungeeChatCommand);
  ProxyServer.getInstance().getPluginManager().unregisterListeners(this);
  ProxyServer.getInstance().getPluginManager().unregisterCommands(this);
  PlaceHolderManager.clear();
  ModuleManager.clearActiveModules();
}","@Override public void onDisable(){
  HookManager.removeHook(defaultHookName);
  HookManager.removeHook(storedDataHookName);
  ModuleManager.disableModules();
  ProxyServer.getInstance().getPluginManager().unregisterListener(bungeecordAccountManager);
  ProxyServer.getInstance().getPluginManager().unregisterCommand(bungeeChatCommand);
  ProxyServer.getInstance().getPluginManager().unregisterListener(channelTypeCorrectorListener);
  ProxyServer.getInstance().getPluginManager().unregisterListeners(this);
  ProxyServer.getInstance().getPluginManager().unregisterCommands(this);
  PlaceHolderManager.clear();
  ModuleManager.clearActiveModules();
}",0.9109075770191508
175461,"@EventHandler public void onPlayerChat(ChatEvent e){
  if (e.isCancelled())   return;
  if (!(e.getSender() instanceof ProxiedPlayer))   return;
  ProxiedPlayer sender=(ProxiedPlayer)e.getSender();
  BungeeChatAccount account=BungeecordAccountManager.getAccount(sender).get();
  String message=e.getMessage();
  if (((account.getChannelType() == ChannelType.NONE) || (account.getChannelType() == ChannelType.LOCAL)) && !ChatUtils.isCommand(message)) {
    e.setCancelled(true);
    MessagesService.sendLocalMessage(sender,message);
  }
}","@EventHandler public void onPlayerChat(ChatEvent e){
  if (e.isCancelled())   return;
  if (!(e.getSender() instanceof ProxiedPlayer))   return;
  ProxiedPlayer sender=(ProxiedPlayer)e.getSender();
  BungeeChatAccount account=BungeecordAccountManager.getAccount(sender).get();
  String message=e.getMessage();
  if (account.getChannelType() == ChannelType.LOCAL && !ChatUtils.isCommand(message)) {
    e.setCancelled(true);
    MessagesService.sendLocalMessage(sender,message);
  }
}",0.9470588235294116
175462,"public static void sendChannelMessage(BungeeChatContext context,ChannelType channel) throws InvalidContextError {
  context.require(BungeeChatContext.HAS_SENDER,BungeeChatContext.HAS_MESSAGE);
switch (channel) {
case GLOBAL:
    sendGlobalMessage(context);
  break;
case LOCAL:
sendLocalMessage(context);
break;
case STAFF:
sendStaffMessage(context);
break;
case HELP:
sendHelpMessage(context);
break;
case GROUP:
break;
case NONE:
default :
break;
}
}","public static void sendChannelMessage(BungeeChatContext context,ChannelType channel) throws InvalidContextError {
  context.require(BungeeChatContext.HAS_SENDER,BungeeChatContext.HAS_MESSAGE);
switch (channel) {
case GLOBAL:
    sendGlobalMessage(context);
  break;
case LOCAL:
sendLocalMessage(context);
break;
case STAFF:
sendStaffMessage(context);
break;
case HELP:
sendHelpMessage(context);
break;
case GROUP:
break;
default :
break;
}
}",0.9876819708846584
175463,"@Override public boolean isContextApplicable(BungeeChatContext context){
  for (  Predicate<? super BungeeChatContext> requirement : requirements) {
    if (requirement.test(context))     return false;
  }
  return true;
}","@Override public boolean isContextApplicable(BungeeChatContext context){
  for (  Predicate<? super BungeeChatContext> requirement : requirements) {
    if (!requirement.test(context))     return false;
  }
  return true;
}",0.997752808988764
175464,"@Override public void onEnable(){
  instance=this;
  BungeeChatInstaceHolder.setInstance(instance);
  Config.load();
  if (CONFIG_VERSION != Config.get().getDouble(""String_Node_Str"")) {
    Logger.info(""String_Node_Str"");
    Logger.info(""String_Node_Str"");
    return;
  }
  ProxyServer.getInstance().getPluginManager().registerCommand(this,new ReloadCommand());
  ProxyServer.getInstance().getPluginManager().registerListener(this,new AccountManager());
  ModuleManager.enableModules();
  loadScreen();
}","@Override public void onEnable(){
  instance=this;
  BungeeChatInstaceHolder.setInstance(instance);
  Config.load();
  PlaceHolders.registerPlaceholders();
  if (CONFIG_VERSION != Config.get().getDouble(""String_Node_Str"")) {
    Logger.info(""String_Node_Str"");
    Logger.info(""String_Node_Str"");
    return;
  }
  ProxyServer.getInstance().getPluginManager().registerCommand(this,new ReloadCommand());
  ProxyServer.getInstance().getPluginManager().registerListener(this,new AccountManager());
  ModuleManager.enableModules();
  loadScreen();
}",0.9628924833491912
175465,"/** 
 * Gives a general answer to a general user input.
 * @param phrase given in input
 * @return  a BrainResponse instance, containing a general answer
 * @see com.github.bot.curiosone.core.nlp.Phrase The Sentence Phrase
 * @see com.github.bot.curiosone.core.nlp.BrainResponse The BrainResponse Class
 */
public static BrainResponse getAnswer(Phrase phrase){
  List<Token> tokenList=phrase.getTokens();
  if (tokenList.size() == 1) {
    return new BrainResponse(phrase.getText() + CONSTANTS[randomIndex(CONSTANTS)],""String_Node_Str"");
  }
 else {
    long count=tokenList.stream().map(Token::isKnown).filter(x -> !x).count();
    if (count > tokenList.size() / 2) {
      return new BrainResponse(ENGLISH_ANSWERS[randomIndex(ENGLISH_ANSWERS)],""String_Node_Str"");
    }
  }
  return new BrainResponse(GENERAL_ANSWERS[randomIndex(GENERAL_ANSWERS)],""String_Node_Str"");
}","/** 
 * Gives a general answer to a general user input.
 * @param phrase given in input
 * @return  a BrainResponse instance, containing a general answer
 * @see com.github.bot.curiosone.core.nlp.Phrase The Sentence Phrase
 * @see com.github.bot.curiosone.core.extraction.BrainResponse The BrainResponse Class
 */
public static BrainResponse getAnswer(Phrase phrase){
  List<Token> tokenList=phrase.getTokens();
  if (tokenList.size() == 1) {
    return new BrainResponse(phrase.getText() + CONSTANTS[randomIndex(CONSTANTS)],""String_Node_Str"");
  }
 else {
    long count=tokenList.stream().map(Token::isKnown).filter(x -> !x).count();
    if (count > tokenList.size() / 2) {
      return new BrainResponse(ENGLISH_ANSWERS[randomIndex(ENGLISH_ANSWERS)],""String_Node_Str"");
    }
  }
  return new BrainResponse(GENERAL_ANSWERS[randomIndex(GENERAL_ANSWERS)],""String_Node_Str"");
}",0.9925586720091586
175466,"/** 
 * @return  the lexical category for this meaning.
 */
public LEX getLEX(){
  return lex;
}","/** 
 * Gets the Lexical category for this Meaning.
 * @return  the Lexical category for this Meaning
 */
public LEX getLEX(){
  return lex;
}",0.7394957983193278
175467,"/** 
 * @return  the part of speech type for this meaning.
 */
public POS getPOS(){
  return pos;
}","/** 
 * Gets the Part of Speech type for this Meaning.
 * @return  the Part of Speech type for this Meaning
 */
public POS getPOS(){
  return pos;
}",0.728744939271255
175468,"/** 
 * @return  frequency for this meaning.
 */
public int getFrequency(){
  return freq;
}","/** 
 * Gets the frequency for this Meaning.
 * @return  frequency for this Meaning
 */
public int getFrequency(){
  return freq;
}",0.8071748878923767
175469,"/** 
 * Compares this Meaning to the other meaning.
 * @param other the other Meaning to be compared against
 * @return a negative value if this is ordered before other;a positive value if this is ordered after other; zero if this and other are ordered together.
 */
@Override public int compareTo(Meaning other){
  return this.freq - other.freq;
}","/** 
 * Compares this Meaning to the other Meaning.
 * @param other the other Meaning to be compared against
 * @return a negative value if this is ordered before other;a positive value if this is ordered after other; zero if this and other are ordered together.
 */
@Override public int compareTo(Meaning other){
  return this.freq - other.freq;
}",0.9971264367816092
175470,"/** 
 * Constructs this Meaning instance with a given POS, LEX and a default frequency.
 * @param pos the part of speech type for this new meaning
 * @param lex the lexical category for this new meaning
 */
public Meaning(POS pos,LEX lex){
  this.pos=pos;
  this.lex=lex;
  this.freq=0;
}","/** 
 * Constructs this Meaning instance with a given POS, LEX and a default frequency.
 * @param pos the part of speech type for this new Meaning
 * @param lex the lexical category for this new Meaning
 */
public Meaning(POS pos,LEX lex){
  this.pos=pos;
  this.lex=lex;
  this.freq=0;
}",0.9409722222222222
175471,"/** 
 * Sets the frequency for this meaning.
 * @param frequency the frequency value to be set. Must be a positive integer
 * @throws IllegalArgumentException if negative frequency is passed
 */
public void setFrequency(int frequency){
  if (frequency < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  freq=frequency;
}","/** 
 * Sets the frequency for this Meaning.
 * @param frequency the frequency value to be set. Must be a positive integer
 * @throws IllegalArgumentException if negative frequency is passed
 */
public void setFrequency(int frequency){
  if (frequency < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  freq=frequency;
}",0.997067448680352
175472,"/** 
 * @return  the subject of this SemanticQuery.
 */
public String getSubject(){
  return subject;
}","/** 
 * Gets the subject of this SemanticQuery.
 * @return  the subject of this SemanticQuery
 */
public String getSubject(){
  return subject;
}",0.8225806451612904
175473,"/** 
 * @return  the object of this SemanticQuery.
 */
public String getObject(){
  return object;
}","/** 
 * Gets the object of this SemanticQuery.
 * @return  the object of this SemanticQuery
 */
public String getObject(){
  return object;
}",0.8215767634854771
175474,"/** 
 * @return  the verb of this SemanticQuery.
 */
public String getVerb(){
  return verb;
}","/** 
 * Gets the verb of this SemanticQuery.
 * @return  the verb of this SemanticQuery
 */
public String getVerb(){
  return verb;
}",0.8193832599118943
175475,"/** 
 * @return  a List containing all the adjectives of this SemanticQuery.
 */
public List<String> getAdjectives(){
  return objAdjectives;
}","/** 
 * Gets the adjectives of this SemanticQuery.
 * @return  a List containing all the adjectives of this SemanticQuery
 */
public List<String> getAdjectives(){
  return objAdjectives;
}",0.8580060422960725
175476,"/** 
 * @return  the relation of this SemanticQuery.
 */
public SemanticRelationType getRelation(){
  return relation;
}","/** 
 * Gets the relation of this SemanticQuery.
 * @return  the relation of this SemanticQuery
 */
public SemanticRelationType getRelation(){
  return relation;
}",0.8409893992932862
175477,"/** 
 * Private constructor. Loads the Semantic Network in memory.
 * @throws IOException if there is a problem with the input file.
 */
private SemanticNetwork() throws IOException {
  this.grafo=new HashMap<>();
  List<String> lines=new ArrayList<>();
  lines=Files.readAllLines(this.percorso);
  for (  String linea : lines) {
    String[] linee=linea.split(""String_Node_Str"");
    Vertex source=new Concept(linee[0]);
    Vertex target=new Concept(linee[2]);
    SemanticRelationType type=SemanticRelationType.valueOf(linee[1].trim());
    SemanticRelation arco=new SemanticRelation(source,target,type,Integer.parseInt(linee[3]));
    this.add(arco);
  }
}","/** 
 * Private constructor. Loads the Semantic Network in memory.
 * @throws IOException if there is a problem with the input file
 */
private SemanticNetwork() throws IOException {
  this.grafo=new HashMap<>();
  List<String> lines=new ArrayList<>();
  lines=Files.readAllLines(this.percorso);
  for (  String linea : lines) {
    String[] linee=linea.split(""String_Node_Str"");
    Vertex source=new Concept(linee[0]);
    Vertex target=new Concept(linee[2]);
    SemanticRelationType type=SemanticRelationType.valueOf(linee[1].trim());
    SemanticRelation arco=new SemanticRelation(source,target,type,Integer.parseInt(linee[3]));
    this.add(arco);
  }
}",0.9992418498862776
175478,"/** 
 * @return  a Set containg all the Semantis Relations outgoing from the given Vertex.
 */
@Override public Set<Edge> outgoingEdges(Vertex v){
  Set<Edge> outgoingEdges=new HashSet<>();
  if (containsVertex(v)) {
    for (    Edge arco : grafo.get(v)) {
      if (arco.getSource().equals(v)) {
        outgoingEdges.add(arco);
      }
    }
  }
  return outgoingEdges;
}","/** 
 * Gets all the outgoing Edges from the given Vertex.
 * @return  a Set containg all the Semantis Relations outgoing from the given Vertex
 */
@Override public Set<Edge> outgoingEdges(Vertex v){
  Set<Edge> outgoingEdges=new HashSet<>();
  if (containsVertex(v)) {
    for (    Edge arco : grafo.get(v)) {
      if (arco.getSource().equals(v)) {
        outgoingEdges.add(arco);
      }
    }
  }
  return outgoingEdges;
}",0.8089887640449438
175479,"/** 
 * @return  a Set containing all the Edges of this SemanticNetwork.
 */
@Override public Set<Edge> edgeSet(){
  Set<Edge> archi=new HashSet<>();
  for (  Set<Edge> archiTemp : grafo.values()) {
    archi.addAll(archiTemp);
  }
  return archi;
}","/** 
 * Gets all the Edges of this SemanticNetwork.
 * @return  a Set containing all the Edges of this SemanticNetwork
 */
@Override public Set<Edge> edgeSet(){
  Set<Edge> archi=new HashSet<>();
  for (  Set<Edge> archiTemp : grafo.values()) {
    archi.addAll(archiTemp);
  }
  return archi;
}",0.8235294117647058
175480,"/** 
 * @return  a Set containg all the Semantis Relations incoming from the given Vertex.
 */
@Override public Set<Edge> incomingEdges(Vertex v){
  Set<Edge> incomingEdges=new HashSet<>();
  if (containsVertex(v)) {
    for (    Edge arco : grafo.get(v)) {
      if (arco.getTarget().equals(v)) {
        incomingEdges.add(arco);
      }
    }
  }
  return incomingEdges;
}","/** 
 * Gets all the incoming Edges to the given Vertex.
 * @return  a Set containg all the Semantis Relations coming to the given Vertex
 */
@Override public Set<Edge> incomingEdges(Vertex v){
  Set<Edge> incomingEdges=new HashSet<>();
  if (containsVertex(v)) {
    for (    Edge arco : grafo.get(v)) {
      if (arco.getTarget().equals(v)) {
        incomingEdges.add(arco);
      }
    }
  }
  return incomingEdges;
}",0.8025157232704403
175481,"/** 
 * @return  the Map representation of this Semantic Network.
 */
@Override public Map<Vertex,Set<Edge>> getGrafo(){
  return grafo;
}","/** 
 * Gets the Map representation of this Semantic Network.
 * @return  the Map representation of this Semantic Network
 */
@Override public Map<Vertex,Set<Edge>> getGrafo(){
  return grafo;
}",0.8253012048192772
175482,"/** 
 * @return  a String representation of this SemanticNetwork.
 */
@Override public String toString(){
  return grafo.toString();
}","/** 
 * Returns a String representation of this SemanticNetwork.
 * @return  a String representation of this SemanticNetwork
 */
@Override public String toString(){
  return grafo.toString();
}",0.8134556574923547
175483,"/** 
 * @return  the Semantic Network.
 */
public static SemanticNetwork getInstance() throws IOException {
  if (curiosoneSemanticNetwork == null) {
    curiosoneSemanticNetwork=new SemanticNetwork();
  }
  return curiosoneSemanticNetwork;
}","/** 
 * Gets the Singleton instance.
 * @return  the Semantic Network
 */
public static SemanticNetwork getInstance() throws IOException {
  if (curiosoneSemanticNetwork == null) {
    curiosoneSemanticNetwork=new SemanticNetwork();
  }
  return curiosoneSemanticNetwork;
}",0.9359223300970874
175484,"/** 
 * @return  a Set containing all the Vertices of this SemanticNetwork.
 */
@Override public Set<Vertex> vertexSet(){
  return grafo.keySet();
}","/** 
 * Gets all the Vertices of this SemanticNetwork.
 * @return  a Set containing all the Vertices of this SemanticNetwork
 */
@Override public Set<Vertex> vertexSet(){
  return grafo.keySet();
}",0.8521739130434782
175485,"/** 
 * @return  the first element of this Pair.
 */
public F getFirst(){
  return first;
}","/** 
 * Gets the first element of this Pair.
 * @return  the first element of this Pair
 */
public F getFirst(){
  return first;
}",0.8144796380090498
175486,"/** 
 * @return  the second element of this Pair.
 */
public S getSecond(){
  return second;
}","/** 
 * Gets the second element of this Pair.
 * @return  the second element of this Pair
 */
public S getSecond(){
  return second;
}",0.8157894736842105
175487,"/** 
 * @return  a String representation of this Pair in the form (first, second).
 */
@Override public String toString(){
  return ""String_Node_Str"" + first + ""String_Node_Str""+ second+ ""String_Node_Str"";
}","/** 
 * Returns a String representation of this Pair.
 * @return  a String representation of this Pair in the form (first, second)
 */
@Override public String toString(){
  return ""String_Node_Str"" + first + ""String_Node_Str""+ second+ ""String_Node_Str"";
}",0.8917748917748918
175488,"/** 
 * @return  the textual representation of this Word.
 */
public String getText(){
  return text;
}","/** 
 * Gets the text of this Word.
 * @return  the textual representation of this Word
 */
public String getText(){
  return text;
}",0.864406779661017
175489,"/** 
 * @return  the Set of the meanings of this Word.
 * @see com.github.bot.curiosone.core.nlp.Meaning The Meaning Class
 */
public Set<Meaning> getMeanings(){
  return means;
}","/** 
 * Gets all the Meanings of this Word.
 * @return  the Set of the meanings of this Word
 * @see com.github.bot.curiosone.core.nlp.Meaning The Meaning Class
 */
public Set<Meaning> getMeanings(){
  return means;
}",0.898989898989899
175490,"/** 
 * @return  a String representation of this Word in the form [text, word, meanings].
 */
@Override public String toString(){
  return ""String_Node_Str"" + text + ""String_Node_Str""+ lemma+ ""String_Node_Str""+ ""String_Node_Str""+ means+ ""String_Node_Str"";
}","/** 
 * Returns a String representation of this Word.
 * @return  a String representation of this Word in the form [text, word, meanings]
 */
@Override public String toString(){
  return ""String_Node_Str"" + text + ""String_Node_Str""+ lemma+ ""String_Node_Str""+ ""String_Node_Str""+ means+ ""String_Node_Str"";
}",0.9110320284697508
175491,"/** 
 * @return  the lemma of this Word.
 */
public String getLemma(){
  return lemma;
}","/** 
 * Gets the lemma of this Word.
 * @return  the lemma of this Word
 */
public String getLemma(){
  return lemma;
}",0.8405797101449275
175492,"/** 
 * @return  the instance of the spelling dictionary.
 */
public static Spelling getInstance(){
  if (instance != null) {
    return instance;
  }
  instance=new Spelling();
  return instance;
}","/** 
 * Gets the Singleton instance.
 * @return  the instance of the spelling dictionary
 */
public static Spelling getInstance(){
  if (instance != null) {
    return instance;
  }
  instance=new Spelling();
  return instance;
}",0.9227166276346604
175493,"/** 
 * @return  a Pair of POS values that match with that in 'from'.
 */
public Pair<POS,POS> getTo(){
  return to;
}","/** 
 * Gets the target POS values of this Rule.
 * @return  a Pair instance, containing the target POS values of this Rule
 */
public Pair<POS,POS> getTo(){
  return to;
}",0.6206896551724138
175494,"/** 
 * @return  a String representation of this Rule in the form F: (T0, T1).
 */
@Override public String toString(){
  return from + ""String_Node_Str"" + to;
}","/** 
 * Returns a String representation of this Rule.
 * @return  a String representation of this Rule in the form F: (T0, T1)
 */
@Override public String toString(){
  return from + ""String_Node_Str"" + to;
}",0.8641304347826086
175495,"/** 
 * @return  the resulting POS value of joining those in 'to'.
 */
public POS getFrom(){
  return from;
}","/** 
 * Gets the source POS of this Rule.
 * @return  the source POS of this Rule
 */
public POS getFrom(){
  return from;
}",0.6695278969957081
175496,"/** 
 * @return  the content of the computed answer.
 */
public String getMessage(){
  return text;
}","/** 
 * Gets the content of the computed answer.
 * @return  the content of the computed answer
 */
public String getMessage(){
  return text;
}",0.8163265306122449
175497,"/** 
 * @return  a String representation of this BrainResponse.
 */
@Override public String toString(){
  return text + ""String_Node_Str"" + scope+ ""String_Node_Str"";
}","/** 
 * Returns a String representation of this BrainResponse.
 * @return  a String representation of this BrainResponse
 */
@Override public String toString(){
  return text + ""String_Node_Str"" + scope+ ""String_Node_Str"";
}",0.8491048593350383
175498,"/** 
 * @return  the scope of the computed answer.
 */
public String getScope(){
  return scope;
}","/** 
 * Gets the scope of the computed answer.
 * @return  the scope of the computed answer
 */
public String getScope(){
  return scope;
}",0.8185654008438819
175499,"/** 
 * @return  the target Vertex of this SemanticRelation.
 */
@Override public Vertex getTarget(){
  return destinazione;
}","/** 
 * Gets the target Vertex of this SemanticRelation.
 * @return  the target Vertex of this SemanticRelation
 */
@Override public Vertex getTarget(){
  return destinazione;
}",0.8250825082508251
175500,"/** 
 * @return  the SemanticRelationType of this SemanticRelation.
 */
@Override public SemanticRelationType getType(){
  return collegamento;
}","/** 
 * Gets the SemanticRelationType of this SemanticRelation.
 * @return  the SemanticRelationType of this SemanticRelation
 */
@Override public SemanticRelationType getType(){
  return collegamento;
}",0.8275862068965517
175501,"/** 
 * @return  the source Vertex of this SemanticRelation.
 */
@Override public Vertex getSource(){
  return sorgente;
}","/** 
 * Gets the source Vertex of this SemanticRelation Relation.
 * @return  the source Vertex of this SemanticRelation
 */
@Override public Vertex getSource(){
  return sorgente;
}",0.7960526315789473
175502,"/** 
 * @return  the weight of this SemanticRelation.
 */
@Override public Integer getWeight(){
  return weight;
}","/** 
 * Gets the weight of this SemanticRelation.
 * @return  the weight of this SemanticRelation
 */
@Override public Integer getWeight(){
  return weight;
}",0.8308823529411765
175503,"/** 
 * @return  a String representation of this SemanticRelation.
 */
@Override public String toString(){
  return sorgente.getId() + ""String_Node_Str"" + collegamento+ ""String_Node_Str""+ destinazione.getId()+ ""String_Node_Str""+ weight+ ""String_Node_Str"";
}","/** 
 * Returns a String representation of this SemanticRelation.
 * @return  a String representation of this SemanticRelation
 */
@Override public String toString(){
  return sorgente.getId() + ""String_Node_Str"" + collegamento+ ""String_Node_Str""+ destinazione.getId()+ ""String_Node_Str""+ weight+ ""String_Node_Str"";
}",0.8850174216027874
175504,"/** 
 * @return  the concatenation of the words of this token.
 */
public String getText(){
  return text;
}","/** 
 * Gets the text of this Token.
 * @return  the text of this Token
 */
public String getText(){
  return text;
}",0.7377777777777778
175505,"/** 
 * @return  {@code true} if this Token has at leas a Meaning;{@code false} otherwise.
 */
public boolean isKnown(){
  return known;
}","/** 
 * Gets whether this Token is known or not.
 * @return  {@code true} if this Token has at leas a Meaning;{@code false} otherwise
 */
public boolean isKnown(){
  return known;
}",0.8589341692789969
175506,"/** 
 * @return  a Set containing all the meanings of this Token.
 * @see com.github.bot.curiosone.core.nlp.Meaning The Meaning Class
 */
public Set<Meaning> getMeanings(){
  return means;
}","/** 
 * Gets all the Meanings of this Token.
 * @return  a Set containing all the meanings of this Token
 * @see com.github.bot.curiosone.core.nlp.Meaning The Meaning Class
 */
public Set<Meaning> getMeanings(){
  return means;
}",0.9021479713603818
175507,"/** 
 * @return  a String representation of this Token, formatted as: [text, word, meanings].
 */
@Override public String toString(){
  return ""String_Node_Str"" + text + ""String_Node_Str""+ means+ ""String_Node_Str"";
}","/** 
 * Returns a String representation of this Token.
 * @return  a String representation of this Token, formatted as: [text, word, meanings]
 */
@Override public String toString(){
  return ""String_Node_Str"" + text + ""String_Node_Str""+ means+ ""String_Node_Str"";
}",0.893970893970894
175508,"/** 
 * @return  the normalized concatenation of the words of this token.
 */
public String getLemma(){
  return lemma;
}","/** 
 * Gets the normalized concatenation of the words of this token.
 * @return  the normalized concatenation of the words of this token
 */
public String getLemma(){
  return lemma;
}",0.7843137254901961
175509,"/** 
 * @return  the min endpoint of this Interval.
 */
public int min(){
  return min;
}","/** 
 * Gets the minumum endpoint of this Interval.
 * @return  the minumum endpoint of this Interval
 */
public int min(){
  return min;
}",0.7280701754385965
175510,"/** 
 * @return  the max endpoint of this Interval.
 */
public int max(){
  return max;
}","/** 
 * Gets the maximum endpoint of this Interval.
 * @return  the maximum endpoint of this Interval
 */
public int max(){
  return max;
}",0.7280701754385965
175511,"/** 
 * @return  the length of this Interval.
 */
public double length(){
  return max - min;
}","/** 
 * Calculates the length of this Interval.
 * @return  the length of this Interval
 */
public double length(){
  return max - min;
}",0.8103448275862069
175512,"/** 
 * @return  a String representation of this interval in the form [min, max].
 */
@Override public String toString(){
  return ""String_Node_Str"" + min + ""String_Node_Str""+ max+ ""String_Node_Str"";
}","/** 
 * Returns a String representation of this Interval.
 * @return  a String representation of this interval in the form [min, max]
 */
@Override public String toString(){
  return ""String_Node_Str"" + min + ""String_Node_Str""+ max+ ""String_Node_Str"";
}",0.8810572687224669
175513,"/** 
 * @return  the Singleton instance.
 */
public static DictionaryLoader getInstance(){
  if (instance == null) {
    instance=new DictionaryLoader();
  }
  return instance;
}","/** 
 * Gets the Singleton instance.
 * @return  the Singleton instance.
 */
public static DictionaryLoader getInstance(){
  if (instance == null) {
    instance=new DictionaryLoader();
  }
  return instance;
}",0.9175257731958762
175514,"/** 
 * Utility method to create a new immutable Pair.
 * @param a the first Object of the new immutable Pair
 * @param b the second Object of the new immutable Pair
 * @return  the new immutable Pair
 */
public static <A,B>Pair<A,B> create(A a,B b){
  return new Pair<A,B>(a,b);
}","/** 
 * Utility method to create a new immutable Pair.
 * @param < A > the type of the first Object in this Pair
 * @param a the first Object of the new immutable Pair
 * @param < B > the type of the second Object in this Pair
 * @param b the second Object of the new immutable Pair
 * @return  the new immutable Pair
 */
public static <A,B>Pair<A,B> create(A a,B b){
  return new Pair<A,B>(a,b);
}",0.7658321060382917
175515,"/** 
 * @return  {@code true} if the original phrase from where the sentence was extracted ends with aquestion mark; {@code false} otherwise
 */
public boolean isQuestion(){
  return question;
}","/** 
 * Gets whether this Sentence is a question or not.
 * @return  {@code true} if the original phrase from where the sentence was extracted ends with aquestion mark; {@code false} otherwise
 */
public boolean isQuestion(){
  return question;
}",0.8818181818181818
175516,"/** 
 * @return  a String representation of this Sentence, formatted as: [text, tokens].
 */
@Override public String toString(){
  return ""String_Node_Str"" + words + ""String_Node_Str""+ lookup+ ""String_Node_Str"";
}","/** 
 * Returns a String representation of this Sentence.
 * @return  a String representation of this Sentence, formatted as: [text, tokens]
 */
@Override public String toString(){
  return ""String_Node_Str"" + words + ""String_Node_Str""+ lookup+ ""String_Node_Str"";
}",0.8870292887029289
175517,"/** 
 * @return  the List of Words of the Sentence.
 * @see com.github.bot.curiosone.core.nlp.Word The Word Class
 */
public List<Word> getWords(){
  return words;
}","/** 
 * Gets the Words of this Sentence.
 * @return  the List of Words of the Sentence
 * @see com.github.bot.curiosone.core.nlp.Word The Word Class
 */
public List<Word> getWords(){
  return words;
}",0.8986301369863013
175518,"/** 
 * @return  the emotion of this Message.
 */
public String getEmotion(){
  return emotion;
}","/** 
 * Gets the emotion of this Message.
 * @return  the emotion of this Message
 */
public String getEmotion(){
  return emotion;
}",0.8347826086956521
175519,"/** 
 * @return  the content of this Message.
 */
public String getMessage(){
  return message;
}","/** 
 * Gets the content of this Message.
 * @return  the content of this Message
 */
public String getMessage(){
  return message;
}",0.8347826086956521
175520,"/** 
 * @return  a String representation of this Message.
 */
@Override public String toString(){
  return message + ""String_Node_Str"" + scope+ ""String_Node_Str""+ emotion+ ""String_Node_Str"";
}","/** 
 * Returns a String representation of this Message.
 * @return  a String representation of this Message
 */
@Override public String toString(){
  return message + ""String_Node_Str"" + scope+ ""String_Node_Str""+ emotion+ ""String_Node_Str"";
}",0.8781609195402299
175521,"/** 
 * @return  the scope of this Message.
 */
public String getScope(){
  return scope;
}","/** 
 * Gets the scope of this Message.
 * @return  the scope of this Message
 */
public String getScope(){
  return scope;
}",0.8333333333333334
175522,"/** 
 * @return  the text content of this Phrase.
 */
public String getText(){
  return text;
}","/** 
 * Gets the text of this Phrase.
 * @return  the text content of this Phrase
 */
public String getText(){
  return text;
}",0.8468468468468469
175523,"/** 
 * @return  the list of tokens extracted from this Phrase.
 */
public List<Token> getTokens(){
  return new ArrayList<Token>(tokens);
}","/** 
 * Gets the Tokens of this Phrase.
 * @return  the list of tokens extracted from this Phrase
 */
public List<Token> getTokens(){
  return new ArrayList<Token>(tokens);
}",0.8853503184713376
175524,"/** 
 * @return  {@code true} if the content is a question, {@code false} otherwise.
 */
public boolean isQuestion(){
  return question;
}","/** 
 * Returns whether this Phrase is a question or not.
 * @return  {@code true} if the content is a question, {@code false} otherwise
 */
public boolean isQuestion(){
  return question;
}",0.8353658536585366
175525,"/** 
 * @return  a String representation of this Phrase in the form [text, tokens].
 */
@Override public String toString(){
  return ""String_Node_Str"" + text + ""String_Node_Str""+ tokens+ ""String_Node_Str"";
}","/** 
 * Returns a String representation of this Phrase.
 * @return  a String representation of this Phrase in the form [text, tokens]
 */
@Override public String toString(){
  return ""String_Node_Str"" + text + ""String_Node_Str""+ tokens+ ""String_Node_Str"";
}",0.8879310344827587
175526,"/** 
 * @return  the ID of this Concept.
 */
@Override public String getId(){
  return id;
}","/** 
 * Gets the ID of this Concept.
 * @return  the ID of this Concept
 */
@Override public String getId(){
  return id;
}",0.8465116279069768
175527,"/** 
 * @return  a String representation of this Concept.
 */
public String toString(){
  return getId();
}","/** 
 * Returns the String representation of this Concept.
 * @return  the String representation of this Concept
 */
public String toString(){
  return getId();
}",0.7657992565055762
175528,"/** 
 * @return  a String representation of this Meaning in the form [pos, lex, frequency].
 */
@Override public String toString(){
  return ""String_Node_Str"" + pos + ""String_Node_Str""+ lex+ ""String_Node_Str""+ freq+ ""String_Node_Str"";
}","/** 
 * Returns a String representation of this Meaning.
 * @return  a String representation of this Meaning in the form [pos, lex, frequency]
 */
@Override public String toString(){
  return ""String_Node_Str"" + pos + ""String_Node_Str""+ lex+ ""String_Node_Str""+ freq+ ""String_Node_Str"";
}",0.8986615678776291
175529,"public static DictionaryLoader getInstance(){
  if (instance == null) {
    instance=new DictionaryLoader();
  }
  return instance;
}","/** 
 * Returns the DictionaryLoader instance.
 */
public static DictionaryLoader getInstance(){
  if (instance == null) {
    instance=new DictionaryLoader();
  }
  return instance;
}",0.8391167192429022
175530,"/** 
 * HashCode basato sull'hashCode del vertice di destinazione e vertice sorgente,
 */
@Override public int hashCode(){
  int result=42;
  result=31 * result + sorgente.hashCode();
  result=31 * result + destinazione.hashCode();
  return result;
}","/** 
 * HashCode basato sull'hashCode del vertice di destinazione e vertice sorgente.
 */
@Override public int hashCode(){
  int result=42;
  result=31 * result + sorgente.hashCode();
  result=31 * result + destinazione.hashCode();
  return result;
}",0.996
175531,"/** 
 * @param v1 vertice Sorgente
 * @param v2 Vertice Destinazione
 * @param type Tipo dell'arco
 */
public SemanticRelation(Vertex v1,Vertex v2,SemanticRelationType type){
  this.sorgente=v1;
  this.destinazione=v2;
  this.collegamento=type;
}","/** 
 * Default class constructor.
 * @param v1 vertice Sorgente
 * @param v2 Vertice Destinazione
 * @param type Tipo dell'arco
 */
public SemanticRelation(Vertex v1,Vertex v2,SemanticRelationType type){
  this.sorgente=v1;
  this.destinazione=v2;
  this.collegamento=type;
}",0.942528735632184
175532,"/** 
 * metodo toString utilizzato per varie prove di debug
 */
@Override public String toString(){
  return sorgente.getId() + ""String_Node_Str"" + collegamento+ ""String_Node_Str""+ destinazione.getId();
}","/** 
 * Metodo toString utilizzato per varie prove di debug.
 */
@Override public String toString(){
  return sorgente.getId() + ""String_Node_Str"" + collegamento+ ""String_Node_Str""+ destinazione.getId();
}",0.9926650366748166
175533,"@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  ThemeDisplay themeDisplay=(ThemeDisplay)actionRequest.getAttribute(WebKeys.THEME_DISPLAY);
  try {
    numberOfDocuments=ParamUtil.getLong(actionRequest,""String_Node_Str"",1);
    baseDocumentTitle=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    baseDocumentDescription=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    folderId=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    groupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",themeDisplay.getScopeGroupId());
    createDocuments(actionRequest,actionResponse);
  }
 catch (  Throwable e) {
    hideDefaultSuccessMessage(actionRequest);
    e.printStackTrace();
  }
  actionResponse.setRenderParameter(""String_Node_Str"",LDFPortletKeys.COMMON);
}","@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  ThemeDisplay themeDisplay=(ThemeDisplay)actionRequest.getAttribute(WebKeys.THEME_DISPLAY);
  try {
    numberOfDocuments=ParamUtil.getLong(actionRequest,""String_Node_Str"",1);
    baseDocumentTitle=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    baseDocumentDescription=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    folderId=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    groupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",themeDisplay.getScopeGroupId());
    createDocuments(actionRequest,actionResponse);
  }
 catch (  Exception e) {
    hideDefaultSuccessMessage(actionRequest);
    _log.error(e,e);
  }
  actionResponse.setRenderParameter(""String_Node_Str"",LDFPortletKeys.COMMON);
}",0.9595842956120092
175534,"/** 
 * Create Web Contents
 * @param actionRequest
 * @param actionResponse
 * @throws Exception 
 */
private void createJournals(ActionRequest actionRequest,ActionResponse actionResponse) throws Exception {
  ThemeDisplay themeDisplay=(ThemeDisplay)actionRequest.getAttribute(WebKeys.THEME_DISPLAY);
  double loader=10;
  ServiceContext serviceContext=ServiceContextFactory.getInstance(Group.class.getName(),actionRequest);
  Locale defaultLocale=LocaleUtil.fromLanguageId(themeDisplay.getUser().getLanguageId());
  Map<Locale,String> descriptionMap=new HashMap<Locale,String>();
  descriptionMap.put(defaultLocale,StringPool.BLANK);
  String content=buildFields(themeDisplay.getCompanyGroupId(),locales,baseArticle);
  System.out.println(""String_Node_Str"" + numberOfArticles + ""String_Node_Str"");
  for (long i=1; i <= numberOfArticles; i++) {
    if (numberOfArticles >= 100) {
      if (i == (int)(numberOfArticles * (loader / 100))) {
        System.out.println(""String_Node_Str"" + (int)loader + ""String_Node_Str"");
        loader=loader + 10;
      }
    }
    StringBundler title=new StringBundler(2);
    title.append(baseTitle);
    title.append(i);
    Map<Locale,String> titleMap=new HashMap<Locale,String>();
    titleMap.put(defaultLocale,title.toString());
    _journalArticleLocalService.addArticle(serviceContext.getUserId(),groupId,folderId,titleMap,descriptionMap,content,LDFPortletKeys._DDM_STRUCTURE_KEY,LDFPortletKeys._DDM_TEMPLATE_KEY,serviceContext);
  }
  SessionMessages.add(actionRequest,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + numberOfArticles + ""String_Node_Str"");
}","/** 
 * Create Web Contents
 * @param actionRequest
 * @param actionResponse
 * @throws Exception 
 */
private void createJournals(ActionRequest actionRequest,ActionResponse actionResponse) throws Exception {
  ThemeDisplay themeDisplay=(ThemeDisplay)actionRequest.getAttribute(WebKeys.THEME_DISPLAY);
  double loader=10;
  ServiceContext serviceContext=ServiceContextFactory.getInstance(Group.class.getName(),actionRequest);
  Locale defaultLocale=LocaleUtil.fromLanguageId(themeDisplay.getUser().getLanguageId());
  Map<Locale,String> descriptionMap=new ConcurrentHashMap<Locale,String>();
  descriptionMap.put(defaultLocale,StringPool.BLANK);
  String content=buildFields(themeDisplay.getCompanyGroupId(),locales,baseArticle);
  System.out.println(""String_Node_Str"" + numberOfArticles + ""String_Node_Str"");
  for (long i=1; i <= numberOfArticles; i++) {
    if (numberOfArticles >= 100) {
      if (i == (int)(numberOfArticles * (loader / 100))) {
        System.out.println(""String_Node_Str"" + (int)loader + ""String_Node_Str"");
        loader=loader + 10;
      }
    }
    StringBundler title=new StringBundler(2);
    title.append(baseTitle);
    title.append(i);
    Map<Locale,String> titleMap=new ConcurrentHashMap<Locale,String>();
    titleMap.put(defaultLocale,title.toString());
    _journalArticleLocalService.addArticle(serviceContext.getUserId(),groupId,folderId,titleMap,descriptionMap,content,LDFPortletKeys._DDM_STRUCTURE_KEY,LDFPortletKeys._DDM_TEMPLATE_KEY,serviceContext);
  }
  SessionMessages.add(actionRequest,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + numberOfArticles + ""String_Node_Str"");
}",0.993849938499385
175535,"@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  ThemeDisplay themeDisplay=(ThemeDisplay)actionRequest.getAttribute(WebKeys.THEME_DISPLAY);
  try {
    numberOfArticles=ParamUtil.getLong(actionRequest,""String_Node_Str"",1);
    baseTitle=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    baseArticle=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    folderId=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    String[] defLang={LocaleUtil.getDefault().toString()};
    locales=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",defLang);
    groupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",themeDisplay.getScopeGroupId());
    createJournals(actionRequest,actionResponse);
  }
 catch (  Throwable e) {
    hideDefaultSuccessMessage(actionRequest);
    e.printStackTrace();
  }
  actionResponse.setRenderParameter(""String_Node_Str"",LDFPortletKeys.COMMON);
}","@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  ThemeDisplay themeDisplay=(ThemeDisplay)actionRequest.getAttribute(WebKeys.THEME_DISPLAY);
  try {
    numberOfArticles=ParamUtil.getLong(actionRequest,""String_Node_Str"",1);
    baseTitle=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    baseArticle=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    folderId=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    String[] defLang={LocaleUtil.getDefault().toString()};
    locales=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",defLang);
    groupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",themeDisplay.getScopeGroupId());
    createJournals(actionRequest,actionResponse);
  }
 catch (  Exception e) {
    hideDefaultSuccessMessage(actionRequest);
    _log.error(e,e);
  }
  actionResponse.setRenderParameter(""String_Node_Str"",LDFPortletKeys.COMMON);
}",0.9643947100712106
175536,"@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  try {
    startIndex=ParamUtil.getLong(actionRequest,""String_Node_Str"",1);
    numberOfOrganizations=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    baseOrganizationName=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    parentOrganizationId=ParamUtil.getInteger(actionRequest,""String_Node_Str"",OrganizationConstants.DEFAULT_PARENT_ORGANIZATION_ID);
    createOrganizations(actionRequest,actionResponse);
  }
 catch (  Throwable e) {
    hideDefaultSuccessMessage(actionRequest);
    e.printStackTrace();
  }
}","@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  try {
    startIndex=ParamUtil.getLong(actionRequest,""String_Node_Str"",1);
    numberOfOrganizations=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    baseOrganizationName=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    parentOrganizationId=ParamUtil.getInteger(actionRequest,""String_Node_Str"",OrganizationConstants.DEFAULT_PARENT_ORGANIZATION_ID);
    createOrganizations(actionRequest,actionResponse);
  }
 catch (  Exception e) {
    hideDefaultSuccessMessage(actionRequest);
    _log.error(e,e);
  }
}",0.8792569659442725
175537,"@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  try {
    numberOfpages=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    basePageName=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    groupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    parentLayoutId=ParamUtil.getLong(actionRequest,""String_Node_Str"",LayoutConstants.DEFAULT_PARENT_LAYOUT_ID);
    layoutType=ParamUtil.getString(actionRequest,""String_Node_Str"",LayoutConstants.TYPE_PORTLET);
    privateLayout=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",false);
    hidden=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",false);
    createPages(actionRequest,actionResponse);
  }
 catch (  Throwable e) {
    hideDefaultSuccessMessage(actionRequest);
    e.printStackTrace();
  }
  actionResponse.setRenderParameter(""String_Node_Str"",LDFPortletKeys.COMMON);
}","@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  try {
    numberOfpages=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    basePageName=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    groupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    parentLayoutId=ParamUtil.getLong(actionRequest,""String_Node_Str"",LayoutConstants.DEFAULT_PARENT_LAYOUT_ID);
    layoutType=ParamUtil.getString(actionRequest,""String_Node_Str"",LayoutConstants.TYPE_PORTLET);
    privateLayout=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",false);
    hidden=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",false);
    createPages(actionRequest,actionResponse);
  }
 catch (  Exception e) {
    hideDefaultSuccessMessage(actionRequest);
    _log.error(e,e);
  }
  actionResponse.setRenderParameter(""String_Node_Str"",LDFPortletKeys.COMMON);
}",0.9621621621621622
175538,"/** 
 * Create Sites
 * @param actionRequest
 * @param actionResponse
 * @throws PortalException 
 */
private void createSites(ActionRequest actionRequest,ActionResponse actionResponse) throws PortalException {
  double loader=10;
  ServiceContext serviceContext=ServiceContextFactory.getInstance(Group.class.getName(),actionRequest);
  System.out.println(""String_Node_Str"" + numberOfSites + ""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") Map<Locale,String> descriptionMap=new ConcurrentHashMap<Locale,String>(){
{
      put(LocaleUtil.getDefault(),StringPool.BLANK);
    }
  }
;
  for (long i=1; i <= numberOfSites; i++) {
    if (numberOfSites >= 100) {
      if (i == (int)(numberOfSites * (loader / 100))) {
        System.out.println(""String_Node_Str"" + (int)loader + ""String_Node_Str"");
        loader=loader + 10;
      }
    }
    StringBundler siteName=new StringBundler(2);
    siteName.append(baseSiteName).append(i);
    @SuppressWarnings(""String_Node_Str"") Map<Locale,String> nameMap=new ConcurrentHashMap<Locale,String>(){
{
        put(LocaleUtil.getDefault(),siteName.toString());
      }
    }
;
    try {
      _groupLocalService.addGroup(serviceContext.getUserId(),parentGroupId,null,0,liveGroupId,nameMap,descriptionMap,siteType,manualMembership,GroupConstants.DEFAULT_MEMBERSHIP_RESTRICTION,StringPool.BLANK,site,inheritContent,active,serviceContext);
    }
 catch (    DuplicateGroupException e) {
      _log.error(""String_Node_Str"" + siteName.toString() + ""String_Node_Str""+ e.getMessage());
    }
  }
  SessionMessages.add(actionRequest,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + numberOfSites + ""String_Node_Str"");
}","/** 
 * Create Sites
 * @param actionRequest
 * @param actionResponse
 * @throws PortalException 
 */
private void createSites(ActionRequest actionRequest,ActionResponse actionResponse) throws PortalException {
  long numberOfSites=0;
  String baseSiteName=StringPool.BLANK;
  int siteType=GroupConstants.TYPE_SITE_OPEN;
  long parentGroupId=GroupConstants.DEFAULT_PARENT_GROUP_ID;
  long liveGroupId=GroupConstants.DEFAULT_LIVE_GROUP_ID;
  boolean manualMembership=false;
  boolean site=true;
  boolean inheritContent=false;
  boolean active=true;
  numberOfSites=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
  baseSiteName=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
  siteType=ParamUtil.getInteger(actionRequest,""String_Node_Str"",GroupConstants.TYPE_SITE_OPEN);
  parentGroupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",GroupConstants.DEFAULT_PARENT_GROUP_ID);
  liveGroupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",GroupConstants.DEFAULT_LIVE_GROUP_ID);
  manualMembership=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",true);
  site=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",true);
  inheritContent=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",false);
  active=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",true);
  double loader=10;
  ServiceContext serviceContext=ServiceContextFactory.getInstance(Group.class.getName(),actionRequest);
  System.out.println(""String_Node_Str"" + numberOfSites + ""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") Map<Locale,String> descriptionMap=new ConcurrentHashMap<Locale,String>(){
{
      put(LocaleUtil.getDefault(),StringPool.BLANK);
    }
  }
;
  for (long i=1; i <= numberOfSites; i++) {
    if (numberOfSites >= 100) {
      if (i == (int)(numberOfSites * (loader / 100))) {
        System.out.println(""String_Node_Str"" + (int)loader + ""String_Node_Str"");
        loader=loader + 10;
      }
    }
    StringBundler siteName=new StringBundler(2);
    siteName.append(baseSiteName).append(i);
    @SuppressWarnings(""String_Node_Str"") Map<Locale,String> nameMap=new ConcurrentHashMap<Locale,String>(){
{
        put(LocaleUtil.getDefault(),siteName.toString());
      }
    }
;
    try {
      _groupLocalService.addGroup(serviceContext.getUserId(),parentGroupId,null,0,liveGroupId,nameMap,descriptionMap,siteType,manualMembership,GroupConstants.DEFAULT_MEMBERSHIP_RESTRICTION,StringPool.BLANK,site,inheritContent,active,serviceContext);
    }
 catch (    DuplicateGroupException e) {
      _log.error(""String_Node_Str"" + siteName.toString() + ""String_Node_Str""+ e.getMessage());
    }
  }
  SessionMessages.add(actionRequest,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + numberOfSites + ""String_Node_Str"");
}",0.290351668169522
175539,"@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  try {
    numberOfSites=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    baseSiteName=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    siteType=ParamUtil.getInteger(actionRequest,""String_Node_Str"",GroupConstants.TYPE_SITE_OPEN);
    parentGroupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",GroupConstants.DEFAULT_PARENT_GROUP_ID);
    liveGroupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",GroupConstants.DEFAULT_LIVE_GROUP_ID);
    manualMembership=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",true);
    site=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",true);
    inheritContent=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",false);
    active=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",true);
    createSites(actionRequest,actionResponse);
  }
 catch (  Throwable e) {
    hideDefaultSuccessMessage(actionRequest);
    e.printStackTrace();
  }
  actionResponse.setRenderParameter(""String_Node_Str"",LDFPortletKeys.COMMON);
}","@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  try {
    createSites(actionRequest,actionResponse);
  }
 catch (  Exception e) {
    hideDefaultSuccessMessage(actionRequest);
    _log.error(e,e);
  }
  actionResponse.setRenderParameter(""String_Node_Str"",LDFPortletKeys.COMMON);
}",0.281767955801105
175540,"@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  try {
    numberOfusers=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    baseScreenName=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    male=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",true);
    password=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    String[] organizations=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    organizationIds=_commonUtil.convertStringToLongArray(organizations);
    String[] groups=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    groupIds=_commonUtil.convertStringToLongArray(groups);
    String[] roles=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    roleIds=_commonUtil.convertStringToLongArray(roles);
    String[] userGroups=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    userGroupIds=_commonUtil.convertStringToLongArray(userGroups);
    createUsers(actionRequest,actionResponse);
  }
 catch (  Throwable e) {
    hideDefaultSuccessMessage(actionRequest);
    e.printStackTrace();
  }
  actionResponse.setRenderParameter(""String_Node_Str"",LDFPortletKeys.COMMON);
}","@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  try {
    numberOfusers=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    baseScreenName=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    male=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",true);
    password=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    String[] organizations=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    organizationIds=_commonUtil.convertStringToLongArray(organizations);
    String[] groups=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    groupIds=_commonUtil.convertStringToLongArray(groups);
    String[] roles=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    roleIds=_commonUtil.convertStringToLongArray(roles);
    String[] userGroups=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    userGroupIds=_commonUtil.convertStringToLongArray(userGroups);
    createUsers(actionRequest,actionResponse);
  }
 catch (  Exception e) {
    hideDefaultSuccessMessage(actionRequest);
    _log.error(e,e);
  }
  actionResponse.setRenderParameter(""String_Node_Str"",LDFPortletKeys.COMMON);
}",0.9722222222222222
175541,"/** 
 * Page Command Pairs
 * @return jsp file name corresponding to the command.
 */
public Map<String,String> getPageFromMode(){
  return renderJSPs;
}","/** 
 * Page Command Pairs
 * @return jsp file name corresponding to the command.
 */
public Map<String,String> getPageFromMode(){
  return LDFPortletKeys.renderJSPs;
}",0.9532710280373832
175542,"@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  ThemeDisplay themeDisplay=(ThemeDisplay)actionRequest.getAttribute(WebKeys.THEME_DISPLAY);
  try {
    numberOfArticles=ParamUtil.getLong(actionRequest,""String_Node_Str"",1);
    baseTitle=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    baseArticle=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    folderId=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    String[] defLang={LocaleUtil.getDefault().toString()};
    locales=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",defLang);
    groupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",themeDisplay.getScopeGroupId());
    createJournals(actionRequest,actionResponse);
  }
 catch (  Throwable e) {
    hideDefaultSuccessMessage(actionRequest);
    e.printStackTrace();
  }
}","@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  ThemeDisplay themeDisplay=(ThemeDisplay)actionRequest.getAttribute(WebKeys.THEME_DISPLAY);
  try {
    numberOfArticles=ParamUtil.getLong(actionRequest,""String_Node_Str"",1);
    baseTitle=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    baseArticle=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    folderId=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    String[] defLang={LocaleUtil.getDefault().toString()};
    locales=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",defLang);
    groupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",themeDisplay.getScopeGroupId());
    createJournals(actionRequest,actionResponse);
  }
 catch (  Throwable e) {
    hideDefaultSuccessMessage(actionRequest);
    e.printStackTrace();
  }
  actionResponse.setRenderParameter(""String_Node_Str"",LDFPortletKeys.COMMON);
}",0.9587737843551796
175543,"@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  try {
    numberOfpages=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    basePageName=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    groupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    parentLayoutId=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    layoutType=ParamUtil.getString(actionRequest,""String_Node_Str"",LayoutConstants.TYPE_PORTLET);
    privateLayout=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",false);
    hidden=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",false);
    createPages(actionRequest,actionResponse);
  }
 catch (  Throwable e) {
    hideDefaultSuccessMessage(actionRequest);
    e.printStackTrace();
  }
}","@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  try {
    numberOfpages=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    basePageName=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    groupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    parentLayoutId=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    layoutType=ParamUtil.getString(actionRequest,""String_Node_Str"",LayoutConstants.TYPE_PORTLET);
    privateLayout=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",false);
    hidden=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",false);
    createPages(actionRequest,actionResponse);
  }
 catch (  Throwable e) {
    hideDefaultSuccessMessage(actionRequest);
    e.printStackTrace();
  }
  actionResponse.setRenderParameter(""String_Node_Str"",LDFPortletKeys.COMMON);
}",0.9540636042402828
175544,"@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  try {
    numberOfSites=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    baseSiteName=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    siteType=ParamUtil.getInteger(actionRequest,""String_Node_Str"",GroupConstants.TYPE_SITE_OPEN);
    parentGroupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",GroupConstants.DEFAULT_PARENT_GROUP_ID);
    liveGroupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",GroupConstants.DEFAULT_LIVE_GROUP_ID);
    manualMembership=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",false);
    site=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",true);
    inheritContent=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",false);
    active=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",true);
    createSites(actionRequest,actionResponse);
  }
 catch (  Throwable e) {
    hideDefaultSuccessMessage(actionRequest);
    e.printStackTrace();
  }
}","@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  try {
    numberOfSites=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    baseSiteName=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    siteType=ParamUtil.getInteger(actionRequest,""String_Node_Str"",GroupConstants.TYPE_SITE_OPEN);
    parentGroupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",GroupConstants.DEFAULT_PARENT_GROUP_ID);
    liveGroupId=ParamUtil.getLong(actionRequest,""String_Node_Str"",GroupConstants.DEFAULT_LIVE_GROUP_ID);
    manualMembership=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",false);
    site=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",true);
    inheritContent=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",false);
    active=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",true);
    createSites(actionRequest,actionResponse);
  }
 catch (  Throwable e) {
    hideDefaultSuccessMessage(actionRequest);
    e.printStackTrace();
  }
  actionResponse.setRenderParameter(""String_Node_Str"",LDFPortletKeys.COMMON);
}",0.963720930232558
175545,"@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  try {
    numberOfusers=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    baseScreenName=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    male=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",true);
    password=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    String[] organizations=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    organizationIds=_commonUtil.convertStringToLongArray(organizations);
    String[] groups=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    groupIds=_commonUtil.convertStringToLongArray(groups);
    String[] roles=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    roleIds=_commonUtil.convertStringToLongArray(roles);
    String[] userGroups=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    userGroupIds=_commonUtil.convertStringToLongArray(userGroups);
    createUsers(actionRequest,actionResponse);
  }
 catch (  Throwable e) {
    hideDefaultSuccessMessage(actionRequest);
    e.printStackTrace();
  }
}","@Override protected void doProcessAction(ActionRequest actionRequest,ActionResponse actionResponse){
  try {
    numberOfusers=ParamUtil.getLong(actionRequest,""String_Node_Str"",0);
    baseScreenName=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    male=ParamUtil.getBoolean(actionRequest,""String_Node_Str"",true);
    password=ParamUtil.getString(actionRequest,""String_Node_Str"",""String_Node_Str"");
    String[] organizations=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    organizationIds=_commonUtil.convertStringToLongArray(organizations);
    String[] groups=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    groupIds=_commonUtil.convertStringToLongArray(groups);
    String[] roles=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    roleIds=_commonUtil.convertStringToLongArray(roles);
    String[] userGroups=ParamUtil.getStringValues(actionRequest,""String_Node_Str"",null);
    userGroupIds=_commonUtil.convertStringToLongArray(userGroups);
    createUsers(actionRequest,actionResponse);
  }
 catch (  Throwable e) {
    hideDefaultSuccessMessage(actionRequest);
    e.printStackTrace();
  }
  actionResponse.setRenderParameter(""String_Node_Str"",LDFPortletKeys.COMMON);
}",0.9681112019623876
175546,"@EventHandler(priority=EventPriority.LOW) public void onInventoryClick(InventoryClickEvent e){
  Player p=(Player)e.getWhoClicked();
  if (!inventories.containsKey(p))   return;
  if (e.getAction() == InventoryAction.COLLECT_TO_CURSOR) {
    e.setCancelled(true);
    return;
  }
  if (e.getClickedInventory() == p.getOpenInventory().getTopInventory()) {
    e.setCancelled(true);
    int row=e.getSlot() / 9;
    int column=e.getSlot() % 9;
    if (row < 0 || column < 0)     return;
    SmartInventory inv=inventories.get(p);
    if (row >= inv.getRows() || column >= inv.getColumns())     return;
    inv.getListeners().stream().filter(listener -> listener.getType() == InventoryClickEvent.class).forEach(listener -> ((InventoryListener<InventoryClickEvent>)listener).accept(e));
    contents.get(p).get(row,column).ifPresent(item -> {
      if (item.getItem() != null && !item.getItem().isSimilar(e.getCurrentItem()))       return;
      if (item.getItem() == null && (e.getCurrentItem() != null && e.getCurrentItem().getType() != Material.AIR))       return;
      item.run(e);
    }
);
  }
}","@EventHandler(priority=EventPriority.LOW) public void onInventoryClick(InventoryClickEvent e){
  Player p=(Player)e.getWhoClicked();
  if (!inventories.containsKey(p))   return;
  if (e.getAction() == InventoryAction.COLLECT_TO_CURSOR) {
    e.setCancelled(true);
    return;
  }
  if (e.getClickedInventory() == p.getOpenInventory().getTopInventory()) {
    e.setCancelled(true);
    int row=e.getSlot() / 9;
    int column=e.getSlot() % 9;
    if (row < 0 || column < 0)     return;
    SmartInventory inv=inventories.get(p);
    if (row >= inv.getRows() || column >= inv.getColumns())     return;
    inv.getListeners().stream().filter(listener -> listener.getType() == InventoryClickEvent.class).forEach(listener -> ((InventoryListener<InventoryClickEvent>)listener).accept(e));
    contents.get(p).get(row,column).ifPresent(item -> item.run(e));
  }
}",0.8673835125448028
175547,"@EventHandler(priority=EventPriority.LOW,ignoreCancelled=true) public void onInventoryOpen(InventoryOpenEvent e){
  Player p=(Player)e.getPlayer();
  if (!inventories.containsKey(p))   return;
  SmartInventory inv=inventories.get(p);
  inv.getListeners().stream().filter(listener -> listener.getType() == InventoryOpenEvent.class).forEach(listener -> ((InventoryListener<InventoryOpenEvent>)listener).accept(e));
}","@EventHandler(priority=EventPriority.LOW) public void onInventoryOpen(InventoryOpenEvent e){
  Player p=(Player)e.getPlayer();
  if (!inventories.containsKey(p))   return;
  SmartInventory inv=inventories.get(p);
  inv.getListeners().stream().filter(listener -> listener.getType() == InventoryOpenEvent.class).forEach(listener -> ((InventoryListener<InventoryOpenEvent>)listener).accept(e));
}",0.9739776951672864
175548,"@EventHandler(priority=EventPriority.LOW,ignoreCancelled=true) public void onPlayerQuit(PlayerQuitEvent e){
  Player p=e.getPlayer();
  if (!inventories.containsKey(p))   return;
  SmartInventory inv=inventories.get(p);
  inv.getListeners().stream().filter(listener -> listener.getType() == PlayerQuitEvent.class).forEach(listener -> ((InventoryListener<PlayerQuitEvent>)listener).accept(e));
  inventories.remove(p);
}","@EventHandler(priority=EventPriority.LOW) public void onPlayerQuit(PlayerQuitEvent e){
  Player p=e.getPlayer();
  if (!inventories.containsKey(p))   return;
  SmartInventory inv=inventories.get(p);
  inv.getListeners().stream().filter(listener -> listener.getType() == PlayerQuitEvent.class).forEach(listener -> ((InventoryListener<PlayerQuitEvent>)listener).accept(e));
  inventories.remove(p);
}",0.9742962056303548
175549,"@EventHandler(priority=EventPriority.LOW,ignoreCancelled=true) public void onInventoryClick(InventoryClickEvent e){
  Player p=(Player)e.getWhoClicked();
  if (!inventories.containsKey(p))   return;
  if (e.getAction() == InventoryAction.COLLECT_TO_CURSOR) {
    e.setCancelled(true);
    return;
  }
  if (e.getClickedInventory() == p.getOpenInventory().getTopInventory()) {
    int row=e.getSlot() / 9;
    int column=e.getSlot() % 9;
    if (row < 0 || column < 0)     return;
    SmartInventory inv=inventories.get(p);
    if (row >= inv.getRows() || column >= inv.getColumns())     return;
    inv.getListeners().stream().filter(listener -> listener.getType() == InventoryClickEvent.class).forEach(listener -> ((InventoryListener<InventoryClickEvent>)listener).accept(e));
    contents.get(p).get(row,column).ifPresent(item -> {
      e.setCancelled(true);
      if (item.getItem() != null && !item.getItem().isSimilar(e.getCurrentItem()))       return;
      if (item.getItem() == null && (e.getCurrentItem() != null && e.getCurrentItem().getType() != Material.AIR))       return;
      item.run(e);
    }
);
  }
}","@EventHandler(priority=EventPriority.LOW) public void onInventoryClick(InventoryClickEvent e){
  Player p=(Player)e.getWhoClicked();
  if (!inventories.containsKey(p))   return;
  if (e.getAction() == InventoryAction.COLLECT_TO_CURSOR) {
    e.setCancelled(true);
    return;
  }
  if (e.getClickedInventory() == p.getOpenInventory().getTopInventory()) {
    e.setCancelled(true);
    int row=e.getSlot() / 9;
    int column=e.getSlot() % 9;
    if (row < 0 || column < 0)     return;
    SmartInventory inv=inventories.get(p);
    if (row >= inv.getRows() || column >= inv.getColumns())     return;
    inv.getListeners().stream().filter(listener -> listener.getType() == InventoryClickEvent.class).forEach(listener -> ((InventoryListener<InventoryClickEvent>)listener).accept(e));
    contents.get(p).get(row,column).ifPresent(item -> {
      if (item.getItem() != null && !item.getItem().isSimilar(e.getCurrentItem()))       return;
      if (item.getItem() == null && (e.getCurrentItem() != null && e.getCurrentItem().getType() != Material.AIR))       return;
      item.run(e);
    }
);
  }
}",0.96617050067659
175550,"@EventHandler(priority=EventPriority.LOW,ignoreCancelled=true) public void onPluginDisable(PluginDisableEvent e){
  new HashSet<>(inventories.values()).forEach(inv -> inv.getListeners().stream().filter(listener -> listener.getType() == PluginDisableEvent.class).forEach(listener -> ((InventoryListener<PluginDisableEvent>)listener).accept(e)));
}","@EventHandler(priority=EventPriority.LOW) public void onPluginDisable(PluginDisableEvent e){
  new HashSet<>(inventories.values()).forEach(inv -> inv.getListeners().stream().filter(listener -> listener.getType() == PluginDisableEvent.class).forEach(listener -> ((InventoryListener<PluginDisableEvent>)listener).accept(e)));
}",0.9687034277198212
175551,"@EventHandler(priority=EventPriority.LOW,ignoreCancelled=true) public void onInventoryClose(InventoryCloseEvent e){
  Player p=(Player)e.getPlayer();
  if (!inventories.containsKey(p))   return;
  SmartInventory inv=inventories.get(p);
  inv.getListeners().stream().filter(listener -> listener.getType() == InventoryCloseEvent.class).forEach(listener -> ((InventoryListener<InventoryCloseEvent>)listener).accept(e));
  if (inv.isCloseable()) {
    e.getInventory().clear();
    inventories.remove(p);
  }
 else   Bukkit.getScheduler().runTask(plugin,() -> p.openInventory(e.getInventory()));
}","@EventHandler(priority=EventPriority.LOW) public void onInventoryClose(InventoryCloseEvent e){
  Player p=(Player)e.getPlayer();
  if (!inventories.containsKey(p))   return;
  SmartInventory inv=inventories.get(p);
  inv.getListeners().stream().filter(listener -> listener.getType() == InventoryCloseEvent.class).forEach(listener -> ((InventoryListener<InventoryCloseEvent>)listener).accept(e));
  if (inv.isCloseable()) {
    e.getInventory().clear();
    inventories.remove(p);
  }
 else   Bukkit.getScheduler().runTask(plugin,() -> p.openInventory(e.getInventory()));
}",0.9819742489270388
175552,"public SmartInventory build(){
  SmartInventory inv=new SmartInventory();
  inv.id=this.id;
  inv.title=this.title;
  inv.type=this.type;
  inv.rows=this.rows;
  inv.columns=this.columns;
  inv.closeable=this.closeable;
  inv.provider=this.provider;
  inv.parent=this.parent;
  inv.listeners=this.listeners;
  return inv;
}","public SmartInventory build(){
  if (this.provider == null)   throw new IllegalStateException(""String_Node_Str"");
  SmartInventory inv=new SmartInventory();
  inv.id=this.id;
  inv.title=this.title;
  inv.type=this.type;
  inv.rows=this.rows;
  inv.columns=this.columns;
  inv.closeable=this.closeable;
  inv.provider=this.provider;
  inv.parent=this.parent;
  inv.listeners=this.listeners;
  return inv;
}",0.8861454046639232
175553,"@Override public InventoryContents set(int row,int column,ClickableItem item){
  contents[row][column]=item;
  update(row,column,item != null ? item.getItem() : null);
  return this;
}","@Override public InventoryContents set(int row,int column,ClickableItem item){
  if (row >= contents.length)   return this;
  if (column >= contents[row].length)   return this;
  contents[row][column]=item;
  update(row,column,item != null ? item.getItem() : null);
  return this;
}",0.7896995708154506
175554,"@Override public Optional<ClickableItem> get(int row,int column){
  return Optional.ofNullable(contents[row][column]);
}","@Override public Optional<ClickableItem> get(int row,int column){
  if (row >= contents.length)   return Optional.empty();
  if (column >= contents[row].length)   return Optional.empty();
  return Optional.ofNullable(contents[row][column]);
}",0.6629834254143646
175555,"@Override public InventoryContents fillRow(int row,ClickableItem item){
  for (int column=0; column < contents[row].length; column++)   set(row,column,item);
  return this;
}","@Override public InventoryContents fillRow(int row,ClickableItem item){
  if (row >= contents.length)   return this;
  for (int column=0; column < contents[row].length; column++)   set(row,column,item);
  return this;
}",0.8854961832061069
175556,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
switch (requestCode) {
case 1:
    if (resultCode == Activity.RESULT_OK) {
      view.showMessage(model.importDatabase(data.getData().getPath()));
    }
  break;
}
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
switch (requestCode) {
case 1:
    if (resultCode == Activity.RESULT_OK) {
      view.exportFinished(model.importDatabase(data.getData().getPath()),this);
    }
  break;
}
}",0.94140625
175557,"/** 
 * Make a call to   {@link DataBackupHandler} to import database from external storage.
 * @param path The string which contains stored database path.
 * @return The String message of whether import was successful or failed.
 */
public String importDatabase(String path){
  return DataBackupHandler.importDb(path,activity);
}","/** 
 * Make a call to   {@link DataBackupHandler} to import database from external storage.
 * @param path The string which contains stored database path.
 * @return The String message of whether import was successful or failed.
 */
public String importDatabase(String path){
  return DataBackupHandler.importDb(path);
}",0.9861751152073732
175558,"/** 
 * Import backed up data into application.
 * @param path     Where database is saved.
 * @param activity Instance of current activity that will be reset after importing database.
 * @return String success or failed message.
 */
public static String importDb(String path,Activity activity){
  try {
    File sd=Environment.getExternalStorageDirectory();
    if (sd.canWrite()) {
      File backupDB=new File(path);
      File currentDB=App.getAppContext().getDatabasePath(DbHelper.DATABASE_NAME);
      FileChannel src=new FileInputStream(backupDB).getChannel();
      FileChannel dst=new FileOutputStream(currentDB).getChannel();
      dst.transferFrom(src,0,src.size());
      src.close();
      dst.close();
      activity.recreate();
      return App.getAppContext().getString(R.string.import_db_success);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    return App.getAppContext().getString(R.string.import_db_fail);
  }
  return App.getAppContext().getString(R.string.import_db_fail);
}","/** 
 * Import backed up data into application.
 * @param path     Where database is saved.
 * @param activity Instance of current activity that will be reset after importing database.
 * @return String success or failed message.
 */
public static String importDb(String path){
  try {
    File sd=Environment.getExternalStorageDirectory();
    if (sd.canWrite()) {
      File backupDB=new File(path);
      File currentDB=App.getAppContext().getDatabasePath(DbHelper.DATABASE_NAME);
      FileChannel src=new FileInputStream(backupDB).getChannel();
      FileChannel dst=new FileOutputStream(currentDB).getChannel();
      dst.transferFrom(src,0,src.size());
      src.close();
      dst.close();
      return App.getAppContext().getString(R.string.import_db_success);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    return App.getAppContext().getString(R.string.import_db_fail);
  }
  return App.getAppContext().getString(R.string.import_db_fail);
}",0.9772612430520464
175559,"/** 
 * Show a message to user using Snackbar.
 * @param message The String message to show to user.
 */
public void showMessage(String message){
  Snackbar.make(mainLayout,message,Snackbar.LENGTH_SHORT).show();
}","/** 
 * Show a message to user using Snackbar.
 * @param message The String message to show to user.
 */
private void showMessage(String message){
  Snackbar.make(mainLayout,message,Snackbar.LENGTH_SHORT).show();
}",0.97423887587822
175560,"public void editMode(NoteStruct note){
  edtTitle.setText(note.getTitle());
  Log.i(""String_Node_Str"",""String_Node_Str"" + note.getDrawing().length);
  BitmapFactory.Options options=new BitmapFactory.Options();
  options.inMutable=true;
  Bitmap bmp=BitmapFactory.decodeByteArray(note.getDrawing(),0,note.getDrawing().length,options);
  painting.paintBitmap(bmp);
}","public void editMode(final NoteStruct note){
  mainLayout.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener(){
    @Override public void onGlobalLayout(){
      edtTitle.setText(note.getTitle());
      BitmapFactory.Options options=new BitmapFactory.Options();
      options.inMutable=true;
      Bitmap bmp=BitmapFactory.decodeByteArray(note.getDrawing(),0,note.getDrawing().length,options);
      painting.paintBitmap(bmp);
      if (Build.VERSION.SDK_INT < 16) {
        mainLayout.getViewTreeObserver().removeGlobalOnLayoutListener(this);
      }
 else {
        mainLayout.getViewTreeObserver().removeOnGlobalLayoutListener(this);
      }
    }
  }
);
}",0.3872180451127819
175561,"public AddDrawingView(@NonNull final Activity activity){
  super(activity);
  View view=inflate(getContext(),R.layout.activity_add_drawing,this);
  edtTitle=(EditText)view.findViewById(R.id.edtTitle);
  painting=(DrawingView)view.findViewById(R.id.painting);
  ImageView imgEraser=(ImageView)view.findViewById(R.id.imgEraser);
  ImageView imgClear=(ImageView)view.findViewById(R.id.imgClear);
  imgEraser.setOnClickListener(this);
  imgClear.setOnClickListener(this);
  imgEraser.setTag(ClickedActionItem.ERASER);
  imgClear.setTag(ClickedActionItem.CLEAR);
  Toolbar toolbar=(Toolbar)view.findViewById(R.id.toolbar);
  toolbar.inflateMenu(R.menu.add_note_toolbar);
  MenuItem save=toolbar.getMenu().findItem(R.id.save);
  toolbar.setNavigationIcon(getIcon(R.drawable.ic_arrow_back_24dp));
  save.setIcon(getIcon(R.drawable.ic_check_24dp));
  save.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener(){
    @Override public boolean onMenuItemClick(    MenuItem item){
      ((OnSaveListener)presenter).onSave(edtTitle.getText().toString(),painting);
      return false;
    }
  }
);
  toolbar.setNavigationOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      activity.finish();
    }
  }
);
}","public AddDrawingView(@NonNull final Activity activity){
  super(activity);
  View view=inflate(getContext(),R.layout.activity_add_drawing,this);
  edtTitle=(EditText)view.findViewById(R.id.edtTitle);
  painting=(DrawingView)view.findViewById(R.id.painting);
  mainLayout=(LinearLayout)view.findViewById(R.id.mainLayout);
  ImageView imgEraser=(ImageView)view.findViewById(R.id.imgEraser);
  ImageView imgClear=(ImageView)view.findViewById(R.id.imgClear);
  imgEraser.setOnClickListener(this);
  imgClear.setOnClickListener(this);
  imgEraser.setTag(ClickedActionItem.ERASER);
  imgClear.setTag(ClickedActionItem.CLEAR);
  Toolbar toolbar=(Toolbar)view.findViewById(R.id.toolbar);
  toolbar.inflateMenu(R.menu.add_note_toolbar);
  MenuItem save=toolbar.getMenu().findItem(R.id.save);
  toolbar.setNavigationIcon(getIcon(R.drawable.ic_arrow_back_24dp));
  save.setIcon(getIcon(R.drawable.ic_check_24dp));
  save.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener(){
    @Override public boolean onMenuItemClick(    MenuItem item){
      ((OnSaveListener)presenter).onSave(edtTitle.getText().toString(),painting);
      return false;
    }
  }
);
  toolbar.setNavigationOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      activity.finish();
    }
  }
);
}",0.9752844252648096
175562,"public void editNoteRequest(NoteStruct note){
  if (note.isPainting()) {
    Intent intent=new Intent(activity,AddNoteActivity.class);
    intent.putExtra(AddNoteModel.FOLDER_ID,note.getFolderId());
    intent.putExtra(AddNoteModel.IS_EDITING,true);
    intent.putExtra(AddNoteModel.NOTE,note);
    activity.startActivity(intent);
  }
 else {
    Intent intent=new Intent(activity,AddDrawingActivity.class);
    intent.putExtra(AddDrawingModel.FOLDER_ID,note.getFolderId());
    intent.putExtra(AddDrawingModel.IS_EDITING,true);
    intent.putExtra(AddDrawingModel.NOTE,note);
    activity.startActivity(intent);
  }
}","public void editNoteRequest(NoteStruct note){
  if (!note.isPainting()) {
    Intent intent=new Intent(activity,AddNoteActivity.class);
    intent.putExtra(AddNoteModel.FOLDER_ID,note.getFolderId());
    intent.putExtra(AddNoteModel.IS_EDITING,true);
    intent.putExtra(AddNoteModel.NOTE,note);
    activity.startActivity(intent);
  }
 else {
    Intent intent=new Intent(activity,AddDrawingActivity.class);
    intent.putExtra(AddDrawingModel.FOLDER_ID,note.getFolderId());
    intent.putExtra(AddDrawingModel.IS_EDITING,true);
    intent.putExtra(AddDrawingModel.NOTE,note);
    activity.startActivity(intent);
  }
}",0.9991915925626516
175563,"public void bindView(final NoteStruct note){
  txtTitle.setText(note.getTitle());
  if (note.getDrawing() == null) {
    setImageDrawable(R.drawable.ic_note_24dp,imgId);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
      txtText.setText(Html.fromHtml(note.getText(),Html.FROM_HTML_MODE_COMPACT));
    }
 else {
      txtText.setText(Html.fromHtml(note.getText()));
    }
  }
 else {
    setImageDrawable(R.drawable.ic_image_24dp,imgId);
    txtText.setVisibility(View.GONE);
  }
  view.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      listener.onNoteSelect(note);
    }
  }
);
}","public void bindView(final NoteStruct note){
  txtTitle.setText(note.getTitle());
  if (note.getDrawing() == null) {
    setImageDrawable(R.drawable.ic_note_24dp,imgId);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
      txtText.setText(Html.fromHtml(note.getText(),Html.FROM_HTML_MODE_COMPACT));
    }
 else {
      txtText.setText(Html.fromHtml(note.getText()));
    }
  }
 else {
    setImageDrawable(R.drawable.ic_image_24dp,imgId);
    txtText.setVisibility(View.GONE);
  }
  view.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      onNoteAdapterClickedListener.onNoteAdapterClicked(note);
    }
  }
);
}",0.9468892261001516
175564,"@Override public void onClick(View view){
  listener.onNoteSelect(note);
}","@Override public void onClick(View view){
  onNoteAdapterClickedListener.onNoteAdapterClicked(note);
}",0.8068181818181818
175565,"public NoteAdapter(Context context,ArrayList<NoteStruct> notes,Listener listener){
  this.context=context;
  this.notes=notes;
  this.listener=listener;
}","public NoteAdapter(Context context,ArrayList<NoteStruct> notes,OnNoteAdapterClickedListener onNoteAdapterClickedListener){
  this.context=context;
  this.notes=notes;
  this.onNoteAdapterClickedListener=onNoteAdapterClickedListener;
}",0.7319587628865979
175566,"public void onCreate(){
}","public void onCreate(){
  view.setPresenter(this);
}",0.6493506493506493
175567,"/** 
 * Save user note using model saveNote method
 * @param title user note title
 * @param text  user note text
 */
public void onSave(String title,Editable text){
  model.saveNote(title,text);
}","/** 
 * Save user note using model saveNote method
 * @param title user note title
 * @param text  user note text
 */
@Override public void onSave(String title,Editable text){
  model.saveNote(title,text);
}",0.9752475247524752
175568,"public AddNoteView(@NonNull final Activity activity){
  super(activity);
  View view=inflate(getContext(),R.layout.activity_add_note,this);
  final EditText edtTitle=(EditText)view.findViewById(R.id.edtTitle);
  edtText=(EditText)view.findViewById(R.id.edtText);
  ImageView imgBold=(ImageView)view.findViewById(R.id.imgBold);
  ImageView imgItalic=(ImageView)view.findViewById(R.id.imgItalic);
  ImageView imgClear=(ImageView)view.findViewById(R.id.imgClear);
  imgBold.setOnClickListener(this);
  imgItalic.setOnClickListener(this);
  imgClear.setOnClickListener(this);
  imgBold.setTag(ClickedActionItem.BOLD);
  imgItalic.setTag(ClickedActionItem.ITALIC);
  imgClear.setTag(ClickedActionItem.CLEAR);
  Toolbar toolbar=(Toolbar)view.findViewById(R.id.toolbar);
  toolbar.inflateMenu(R.menu.add_note_toolbar);
  MenuItem save=toolbar.getMenu().findItem(R.id.save);
  toolbar.setNavigationIcon(getIcon(R.drawable.ic_arrow_back_24dp));
  save.setIcon(getIcon(R.drawable.ic_check_24dp));
  save.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener(){
    @Override public boolean onMenuItemClick(    MenuItem item){
      ((OnSaveListener)getContext()).onSave(edtTitle.getText().toString(),edtText.getText());
      return false;
    }
  }
);
  toolbar.setNavigationOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      activity.finish();
    }
  }
);
}","public AddNoteView(@NonNull final Activity activity){
  super(activity);
  View view=inflate(getContext(),R.layout.activity_add_note,this);
  final EditText edtTitle=(EditText)view.findViewById(R.id.edtTitle);
  edtText=(EditText)view.findViewById(R.id.edtText);
  ImageView imgBold=(ImageView)view.findViewById(R.id.imgBold);
  ImageView imgItalic=(ImageView)view.findViewById(R.id.imgItalic);
  ImageView imgClear=(ImageView)view.findViewById(R.id.imgClear);
  imgBold.setOnClickListener(this);
  imgItalic.setOnClickListener(this);
  imgClear.setOnClickListener(this);
  imgBold.setTag(ClickedActionItem.BOLD);
  imgItalic.setTag(ClickedActionItem.ITALIC);
  imgClear.setTag(ClickedActionItem.CLEAR);
  Toolbar toolbar=(Toolbar)view.findViewById(R.id.toolbar);
  toolbar.inflateMenu(R.menu.add_note_toolbar);
  MenuItem save=toolbar.getMenu().findItem(R.id.save);
  toolbar.setNavigationIcon(getIcon(R.drawable.ic_arrow_back_24dp));
  save.setIcon(getIcon(R.drawable.ic_check_24dp));
  save.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener(){
    @Override public boolean onMenuItemClick(    MenuItem item){
      ((OnSaveListener)presenter).onSave(edtTitle.getText().toString(),edtText.getText());
      return false;
    }
  }
);
  toolbar.setNavigationOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      activity.finish();
    }
  }
);
}",0.992497320471597
175569,"@Override public boolean onMenuItemClick(MenuItem item){
  ((OnSaveListener)getContext()).onSave(edtTitle.getText().toString(),edtText.getText());
  return false;
}","@Override public boolean onMenuItemClick(MenuItem item){
  ((OnSaveListener)presenter).onSave(edtTitle.getText().toString(),edtText.getText());
  return false;
}",0.96
175570,"public ViewHolder(View view){
  super(view);
  this.view=view;
  txtTitle=(TextView)view.findViewById(R.id.txtNoteTitle);
  txtText=(TextView)view.findViewById(R.id.txtNoteText);
  imgId=(ImageView)view.findViewById(R.id.txtCancel);
}","public ViewHolder(View view){
  super(view);
  this.view=view;
  txtTitle=(TextView)view.findViewById(R.id.txtNoteTitle);
  txtText=(TextView)view.findViewById(R.id.txtNoteText);
  imgId=(ImageView)view.findViewById(R.id.imgIdentifier);
}",0.9533898305084746
175571,"@Override public void onLoadFinished(Loader loader,Object data){
  Cursor cursor=(Cursor)data;
  if (data != null) {
    cursor.moveToFirst();
    ArrayList<FolderStruct> folders=new ArrayList<>();
    try {
      while (cursor.moveToNext()) {
        folders.add(new FolderStruct(cursor));
      }
    }
  finally {
      view.updateFolders(folders);
      cursor.close();
    }
  }
}","@Override public void onLoadFinished(Loader<Cursor> loader,Cursor cursor){
  if (cursor != null) {
    cursor.moveToFirst();
    ArrayList<FolderStruct> folders=new ArrayList<>();
    try {
      while (cursor.moveToNext()) {
        folders.add(new FolderStruct(cursor));
      }
    }
  finally {
      view.updateFolders(folders);
    }
  }
}",0.863013698630137
175572,"public NoteView(@NonNull Activity activity){
  super(activity);
  View view=inflate(getContext(),R.layout.activity_note,this);
  mainLayout=(ViewGroup)view.findViewById(R.id.mainLayout);
  FloatingActionButton fabAddNote=(FloatingActionButton)view.findViewById(R.id.fabAddNote);
}","public NoteView(@NonNull Activity activity){
  super(activity);
  View view=inflate(getContext(),R.layout.activity_note,this);
  mainLayout=(ViewGroup)view.findViewById(R.id.mainLayout);
  final FloatingActionButton fabAddText=(FloatingActionButton)view.findViewById(R.id.fabAddText);
  FloatingActionButton fabAddDrawing=(FloatingActionButton)view.findViewById(R.id.fabAddDrawing);
}",0.8192771084337349
175573,"public void addFolder(final String name){
  String[] permissions={Manifest.permission.WRITE_EXTERNAL_STORAGE,Manifest.permission.READ_EXTERNAL_STORAGE};
  new PermissionHandler().checkPermission(activity,permissions,new PermissionHandler.OnPermissionResponse(){
    @Override public void onPermissionGranted(){
      ContentValues values=new ContentValues();
      values.put(DataContract.FoldersEntry.COLUMN_FOLDER_NAME,name);
      App.getAppContext().getContentResolver().insert(DataContract.FoldersEntry.CONTENT_URI,values);
    }
    @Override public void onPermissionDenied(){
    }
  }
);
}","public void addFolder(final String name){
  ContentValues values=new ContentValues();
  values.put(DataContract.FoldersEntry.COLUMN_FOLDER_NAME,name);
  App.getAppContext().getContentResolver().insert(DataContract.FoldersEntry.CONTENT_URI,values);
}",0.4988179669030733
175574,"@Override public void onClick(View v){
  AddNewFolderDialog dialog=new AddNewFolderDialog();
  dialog.setShowsDialog(true);
  dialog.show(fragmentManager,""String_Node_Str"");
}","@Override public void onClick(View v){
  String[] permissions={Manifest.permission.WRITE_EXTERNAL_STORAGE,Manifest.permission.READ_EXTERNAL_STORAGE};
  new PermissionHandler().checkPermission((Activity)getContext(),permissions,new PermissionHandler.OnPermissionResponse(){
    @Override public void onPermissionGranted(){
      AddNewFolderDialog dialog=new AddNewFolderDialog();
      dialog.setShowsDialog(true);
      dialog.show(fragmentManager,""String_Node_Str"");
    }
    @Override public void onPermissionDenied(){
    }
  }
);
}",0.4831460674157303
175575,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  currentOrientationProvider=new GravityCompassProvider((SensorManager)getSystemService(SENSOR_SERVICE));
  mRenderer=new CubeRenderer();
  mRenderer.setOrientationProvider(currentOrientationProvider);
  mGLSurfaceView=new GLSurfaceView(this);
  mGLSurfaceView.setRenderer(mRenderer);
  setContentView(mGLSurfaceView);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  currentOrientationProvider=new ImprovedOrientationSensor2Provider((SensorManager)getSystemService(SENSOR_SERVICE));
  mRenderer=new CubeRenderer();
  mRenderer.setOrientationProvider(currentOrientationProvider);
  mGLSurfaceView=new GLSurfaceView(this);
  mGLSurfaceView.setRenderer(mRenderer);
  setContentView(mGLSurfaceView);
}",0.9577464788732394
175576,"private static Method loadIsMockedMethod(Class<?> registryClass){
  if (registryClass == null) {
    return null;
  }
  try {
    return registryClass.getDeclaredMethod(""String_Node_Str"",registryClass);
  }
 catch (  NoSuchMethodException e) {
    return null;
  }
}","private static Method loadIsMockedMethod(Class<?> registryClass){
  if (registryClass == null) {
    return null;
  }
  try {
    return registryClass.getDeclaredMethod(""String_Node_Str"",String.class);
  }
 catch (  NoSuchMethodException e) {
    return null;
  }
}",0.967984934086629
175577,"@Before public void setUp() throws Exception {
  testee=new MockableClient(registry,realClient,mockClient,mockWhenFunction);
}","@Before public void setUp() throws Exception {
  testee=new MockableClient(registry,realClient,mockClient,lookupFunction);
}",0.96
175578,"private void givenWhenFunctionReturns(boolean result){
  given(mockWhenFunction.call()).willReturn(result);
}","private void givenWhenFunctionReturns(boolean result){
  given(lookupFunction.call()).willReturn(result);
}",0.9537037037037036
175579,"@Test public void callRealClient_NotInRegistry() throws Exception {
  givenEndpointInRegistry(false);
  testee.execute(REQUEST);
  verifyRealClientCalled();
  verifyZeroInteractions(mockWhenFunction);
}","@Test public void callRealClient_NotInRegistry() throws Exception {
  givenEndpointInRegistry(false);
  testee.execute(REQUEST);
  verifyRealClientCalled();
  verifyZeroInteractions(lookupFunction);
}",0.9701492537313432
175580,"public MetricsSpan(MetricsTracer tracer,Span span,String operationName,long startNanoTime,Map<String,Object> tags){
  this.tracer=tracer;
  this.wrappedSpan=span;
  this.operationName=operationName;
  this.startNanoTime=startNanoTime;
  this.tags=tags;
}","public MetricsSpan(MetricsTracer tracer,Span span,String operationName,long startNanoTime,Map<String,Object> tags){
  this.tracer=tracer;
  this.wrappedSpan=span;
  this.operationName=operationName;
  this.startNanoTime=startNanoTime;
  this.tags=new ConcurrentHashMap<String,Object>();
  if (tags != null) {
    this.tags.putAll(tags);
  }
}",0.8322147651006712
175581,"@Override public Span setOperationName(String operationName){
  wrappedSpan.setOperationName(operationName);
  return this;
}","@Override public Span setOperationName(String operationName){
  wrappedSpan.setOperationName(operationName);
  this.operationName=operationName;
  return this;
}",0.8741258741258742
175582,"/** 
 * 根据ID查询 SimplePrincipalCollection
 * @param userIds 用户ID
 * @return
 */
public List<SimplePrincipalCollection> getSimplePrincipalCollectionByUserId(Long... userIds){
  Set<Long> idset=new TreeSet<Long>(Arrays.asList(userIds));
  Collection<Session> sessions=shiroSessionDao.getActiveSessions();
  List<SimplePrincipalCollection> list=new ArrayList<SimplePrincipalCollection>();
  for (  Session session : sessions) {
    Object obj=session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);
    if (null != obj && obj instanceof SimplePrincipalCollection) {
      SimplePrincipalCollection spc=(SimplePrincipalCollection)obj;
      obj=spc.getPrimaryPrincipal();
      if (null != obj && obj instanceof UserEntity) {
        UserEntity user=(UserEntity)obj;
        if (null != user && idset.contains(user.getId())) {
          list.add(spc);
        }
      }
    }
  }
  return list;
}","/** 
 * 根据ID查询 SimplePrincipalCollection
 * @param userIds 用户ID
 * @return
 */
public List<SimplePrincipalCollection> getSimplePrincipalCollectionByUserId(Long... userIds){
  Set<Long> idset=new TreeSet<Long>(Arrays.asList(userIds));
  Collection<Session> sessions=shiroSessionDao.getActiveSessions();
  List<SimplePrincipalCollection> list=new ArrayList<SimplePrincipalCollection>();
  for (  Session session : sessions) {
    Object obj=session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);
    if (null != obj && obj instanceof SimplePrincipalCollection) {
      SimplePrincipalCollection spc=(SimplePrincipalCollection)obj;
      obj=spc.getPrimaryPrincipal();
      if (null != obj && obj instanceof UserEntity) {
        UserEntity user=(UserEntity)obj;
        if (idset.contains(user.getId())) {
          list.add(spc);
        }
      }
    }
  }
  return list;
}",0.9910614525139664
175583,"@Override public void unmarshalDeferrals(PacketInput in) throws IOException {
  in.align(Alignment.TWO);
  in.fullySkipBytes(2 * offset);
  final StringBuilder sb=new StringBuilder(this.length);
  for (int i=0; i < this.length; i++) {
    sb.append(in.readChar());
  }
  this.value=sb.toString();
  if (isNullTerminated())   in.fullySkipBytes(2);
}","@Override public void unmarshalDeferrals(PacketInput in) throws IOException {
  in.align(Alignment.TWO);
  in.fullySkipBytes(2 * offset);
  final int length;
  final boolean nullTerminated;
  if (isNullTerminated() && this.actualCount > 0) {
    length=this.actualCount - 1;
    nullTerminated=true;
  }
 else {
    length=this.actualCount;
    nullTerminated=false;
  }
  final StringBuilder sb=new StringBuilder(length);
  for (int i=0; i < length; i++) {
    sb.append(in.readChar());
  }
  this.value=sb.toString();
  if (nullTerminated)   in.fullySkipBytes(2);
}",0.7278688524590164
175584,"@Override public void unmarshalEntity(PacketInput in) throws IOException {
  in.align(Alignment.FOUR);
  this.offset=readIndex(""String_Node_Str"",in);
  final int actualCount=readIndex(""String_Node_Str"",in);
  this.length=(isNullTerminated() ? (actualCount - 1) : actualCount);
}","@Override public void unmarshalEntity(PacketInput in) throws IOException {
  in.align(Alignment.FOUR);
  this.offset=readIndex(""String_Node_Str"",in);
  this.actualCount=readIndex(""String_Node_Str"",in);
}",0.8232848232848233
175585,"@DataProvider public Object[][] data_marshalDeferrals(){
  return new Object[][]{{false,null,""String_Node_Str"",""String_Node_Str""},{true,null,""String_Node_Str"",""String_Node_Str""},{false,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{false,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{false,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{false,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
}","@DataProvider public Object[][] data_marshalDeferrals(){
  return new Object[][]{{false,null,""String_Node_Str"",""String_Node_Str""},{true,null,""String_Node_Str"",""String_Node_Str""},{false,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{false,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{false,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{false,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{false,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
}",0.8884859474161378
175586,"@DataProvider public Object[][] data_unmarshalDeferrals(){
  return new Object[][]{{false,""String_Node_Str"",0,""String_Node_Str""},{true,""String_Node_Str"",0,""String_Node_Str""},{false,""String_Node_Str"",0,""String_Node_Str""},{true,""String_Node_Str"",0,""String_Node_Str""},{false,""String_Node_Str"",1,""String_Node_Str""},{false,""String_Node_Str"",2,""String_Node_Str""},{false,""String_Node_Str"",3,""String_Node_Str""}};
}","@DataProvider public Object[][] data_unmarshalDeferrals(){
  return new Object[][]{{true,""String_Node_Str"",0,""String_Node_Str""},{false,""String_Node_Str"",0,""String_Node_Str""},{false,""String_Node_Str"",0,""String_Node_Str""},{true,""String_Node_Str"",0,""String_Node_Str""},{false,""String_Node_Str"",0,""String_Node_Str""},{true,""String_Node_Str"",0,""String_Node_Str""},{false,""String_Node_Str"",1,""String_Node_Str""},{false,""String_Node_Str"",2,""String_Node_Str""},{false,""String_Node_Str"",3,""String_Node_Str""}};
}",0.8992248062015504
175587,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return false;
  }
 else   if (!(obj instanceof LSAPR_POLICY_AUDIT_EVENTS_INFO)) {
    return false;
  }
  LSAPR_POLICY_AUDIT_EVENTS_INFO other=(LSAPR_POLICY_AUDIT_EVENTS_INFO)obj;
  return Objects.equals(isAuditingMode(),other.isAuditingMode()) && Arrays.equals(getEventAuditingOptions(),other.getEventAuditingOptions()) && Objects.equals(getMaximumAuditEventCount(),other.getMaximumAuditEventCount());
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
 else   if (!(obj instanceof LSAPR_POLICY_AUDIT_EVENTS_INFO)) {
    return false;
  }
  LSAPR_POLICY_AUDIT_EVENTS_INFO other=(LSAPR_POLICY_AUDIT_EVENTS_INFO)obj;
  return Objects.equals(isAuditingMode(),other.isAuditingMode()) && Arrays.equals(getEventAuditingOptions(),other.getEventAuditingOptions()) && Objects.equals(getMaximumAuditEventCount(),other.getMaximumAuditEventCount());
}",0.9926082365364308
175588,"@Test public void test_equals(){
  LSAPR_POLICY_AUDIT_EVENTS_INFO obj1=new LSAPR_POLICY_AUDIT_EVENTS_INFO();
  LSAPR_POLICY_AUDIT_EVENTS_INFO obj2=new LSAPR_POLICY_AUDIT_EVENTS_INFO();
  assertEquals(obj1,obj2);
  obj1.setAuditingMode(true);
  assertNotEquals(obj1,obj2);
  obj2.setAuditingMode(true);
  assertEquals(obj1,obj2);
  obj1.setEventAuditingOptions(new int[]{1,2,3});
  assertNotEquals(obj1,obj2);
  obj2.setEventAuditingOptions(new int[]{1,2,3});
  assertEquals(obj1,obj2);
  obj1.setMaximumAuditEventCount(5);
  assertNotEquals(obj1,obj2);
  obj2.setMaximumAuditEventCount(5);
  assertEquals(obj1,obj2);
}","@Test public void test_equals(){
  LSAPR_POLICY_AUDIT_EVENTS_INFO obj1=new LSAPR_POLICY_AUDIT_EVENTS_INFO();
  assertNotEquals(obj1,null);
  assertEquals(obj1,obj1);
  LSAPR_POLICY_AUDIT_EVENTS_INFO obj2=new LSAPR_POLICY_AUDIT_EVENTS_INFO();
  assertEquals(obj1,obj2);
  obj1.setAuditingMode(true);
  assertNotEquals(obj1,obj2);
  obj2.setAuditingMode(true);
  assertEquals(obj1,obj2);
  obj1.setEventAuditingOptions(new int[]{1,2,3});
  assertNotEquals(obj1,obj2);
  obj2.setEventAuditingOptions(new int[]{1,2,3});
  assertEquals(obj1,obj2);
  obj1.setMaximumAuditEventCount(5);
  assertNotEquals(obj1,obj2);
  obj2.setMaximumAuditEventCount(5);
  assertEquals(obj1,obj2);
}",0.9559164733178654
175589,"@Override public void marshal(PacketOutput packetOut) throws IOException {
  packetOut.write(handle.getBytes());
  packetOut.writeInt((int)EnumUtils.toLong(desiredAccess));
  packetOut.writeInt(1);
  packetOut.writeByte(sid.getRevision());
  packetOut.writeByte((byte)(sid.getSubAuthorities().length));
  packetOut.write(sid.getSidIdentifierAuthority());
  for (int i=0; i < sid.getSubAuthorities().length; i++) {
    packetOut.writeInt((int)(sid.getSubAuthorities()[i]));
  }
}","@Override public void marshal(PacketOutput packetOut) throws IOException {
  packetOut.write(handle.getBytes());
  packetOut.writeInt((int)EnumUtils.toLong(desiredAccess));
  packetOut.writeInt(sid.getSubAuthorities().length);
  packetOut.writeByte(sid.getRevision());
  packetOut.writeByte((byte)(sid.getSubAuthorities().length));
  packetOut.write(sid.getSidIdentifierAuthority());
  for (int i=0; i < sid.getSubAuthorities().length; i++) {
    packetOut.writeInt((int)(sid.getSubAuthorities()[i]));
  }
}",0.9685279187817258
175590,"/** 
 * The BaseRegEnumKey method is called by the client in order to enumerate a subkey. In response, the server returns a requested subkey.
 * @param hKey A handle to a key that MUST have been opened previously by using one of the open methods:{@link OpenClassesRoot},   {@link OpenCurrentUser},   {@link OpenLocalMachine},   {@link OpenPerformanceData},  {@link OpenUsers},   {@link BaseRegCreateKey},   {@link BaseRegOpenKey},   {@link OpenCurrentConfig},  {@link OpenPerformanceText},   {@link OpenPerformanceNlsText}.
 * @param index The index of the subkey to retrieve.
 * @param nameLen The maximum length of the subkey name to retrieve.
 * @param classLen The maximum length of the subkey class to retrieve.
 */
public BaseRegEnumKeyRequest(final ContextHandle hKey,final int index,final int nameLen,final int classLen){
  super((short)9);
  putBytes(hKey.getBytes());
  putInt(index);
  putStringBuffer(nameLen);
  putStringBufferRef(classLen);
  putLongRef(Long.valueOf(0));
}","/** 
 * The BaseRegEnumKey method is called by the client in order to enumerate a subkey. In response, the server returns a requested subkey.
 * @param hKey A handle to a key that MUST have been opened previously by using one of the open methods:{@link OpenClassesRoot},   {@link OpenCurrentUser},   {@link OpenLocalMachine},   {@link OpenPerformanceData},  {@link OpenUsers}, BaseRegCreateKey,   {@link BaseRegOpenKey},   {@link OpenCurrentConfig},  {@link OpenPerformanceText},   {@link OpenPerformanceNlsText}.
 * @param index The index of the subkey to retrieve.
 * @param nameLen The maximum length of the subkey name to retrieve.
 * @param classLen The maximum length of the subkey class to retrieve.
 */
public BaseRegEnumKeyRequest(final ContextHandle hKey,final int index,final int nameLen,final int classLen){
  super((short)9);
  putBytes(hKey.getBytes());
  putInt(index);
  putStringBuffer(nameLen);
  putStringBufferRef(classLen);
  putLongRef(Long.valueOf(0));
}",0.994908350305499
175591,"/** 
 * @return The method returns 0 (ERROR_SUCCESS) to indicate success; otherwise, it returns a nonzero error code, asspecified in  {@link com.rapid7.client.dcerpc.mserref.SystemErrorCode} in [MS-ERREF]. The most commonerror codes are listed in the following table.<br> <br> <table border=""1""> <tr> <td>Return value/code</td> <td>Description</td> <tr> <tr> <td>ERROR_ACCESS_DENIED (0x00000005)</td> <td>The caller does not have KEY_ENUMERATE_SUB_KEYS access rights.</td> </tr> <tr> <td>ERROR_OUTOFMEMORY (0x0000000E)</td> <td>Not enough storage is available to complete this operation.</td> </tr> <tr> <td>ERROR_INVALID_PARAMETER (0x00000057)</td> <td>A parameter is incorrect.</td> </tr> <tr> <td>ERROR_NO_MORE_ITEMS (0x00000103)</td> <td>No more data is available.</td> </tr> <tr> <td>ERROR_WRITE_PROTECT (0x00000013)</td> <td>A read or write operation was attempted to a volume after it was dismounted. The server can no longer service registry requests because server shutdown has been initiated.</td> </tr> <tr> <td>ERROR_MORE_DATA (0x000000EA)</td> <td>The size of the buffer is not large enough to hold the requested data.</td> </tr> </table>
 */
public int getReturnValue(){
  return returnValue;
}","/** 
 * @return The method returns 0 (ERROR_SUCCESS) to indicate success; otherwise, it returns a nonzero error code, asspecified in  {@link com.rapid7.client.dcerpc.mserref.SystemErrorCode} in [MS-ERREF]. The most commonerror codes are listed in the following table.<br> <br> <table border=""1"" summary=""""> <tr> <td>Return value/code</td> <td>Description</td> <tr> <tr> <td>ERROR_ACCESS_DENIED (0x00000005)</td> <td>The caller does not have KEY_ENUMERATE_SUB_KEYS access rights.</td> </tr> <tr> <td>ERROR_OUTOFMEMORY (0x0000000E)</td> <td>Not enough storage is available to complete this operation.</td> </tr> <tr> <td>ERROR_INVALID_PARAMETER (0x00000057)</td> <td>A parameter is incorrect.</td> </tr> <tr> <td>ERROR_NO_MORE_ITEMS (0x00000103)</td> <td>No more data is available.</td> </tr> <tr> <td>ERROR_WRITE_PROTECT (0x00000013)</td> <td>A read or write operation was attempted to a volume after it was dismounted. The server can no longer service registry requests because server shutdown has been initiated.</td> </tr> <tr> <td>ERROR_MORE_DATA (0x000000EA)</td> <td>The size of the buffer is not large enough to hold the requested data.</td> </tr> </table>
 */
public int getReturnValue(){
  return returnValue;
}",0.9954676555418212
175592,"/** 
 * The BaseRegEnumValue method is called by the client. In response, the server enumerates the value at the specified index for the specified registry key.
 * @param hKey A handle to a key that MUST have been opened previously by using one of the open methods:{@link OpenClassesRoot},   {@link OpenCurrentUser},   {@link OpenLocalMachine},   {@link OpenPerformanceData},  {@link OpenUsers},   {@link BaseRegCreateKey},   {@link BaseRegOpenKey},   {@link OpenCurrentConfig},  {@link OpenPerformanceText},   {@link OpenPerformanceNlsText}.
 * @param index The index of the value to be retrieved.
 * @param valueNameLen The maximum length of the value name to be retrieved.
 * @param dataLen The maximum length of the value data to be retrieved.
 */
public BaseRegEnumValueRequest(final ContextHandle hKey,final int index,final int valueNameLen,final int dataLen){
  super((short)10);
  putBytes(hKey.getBytes());
  putInt(index);
  putStringBuffer(valueNameLen);
  putIntRef(0);
  putEmptyArrayRef(dataLen);
  putIntRef(dataLen);
  putIntRef(0);
}","/** 
 * The BaseRegEnumValue method is called by the client. In response, the server enumerates the value at the specified index for the specified registry key.
 * @param hKey A handle to a key that MUST have been opened previously by using one of the open methods:{@link OpenClassesRoot},   {@link OpenCurrentUser},   {@link OpenLocalMachine},   {@link OpenPerformanceData},  {@link OpenUsers}, BaseRegCreateKey,   {@link BaseRegOpenKey},   {@link OpenCurrentConfig},  {@link OpenPerformanceText},   {@link OpenPerformanceNlsText}.
 * @param index The index of the value to be retrieved.
 * @param valueNameLen The maximum length of the value name to be retrieved.
 * @param dataLen The maximum length of the value data to be retrieved.
 */
public BaseRegEnumValueRequest(final ContextHandle hKey,final int index,final int valueNameLen,final int dataLen){
  super((short)10);
  putBytes(hKey.getBytes());
  putInt(index);
  putStringBuffer(valueNameLen);
  putIntRef(0);
  putEmptyArrayRef(dataLen);
  putIntRef(dataLen);
  putIntRef(0);
}",0.9952153110047848
175593,"/** 
 * @return The method returns 0 (ERROR_SUCCESS) to indicate success; otherwise, it returns a nonzero error code, asspecified in  {@link com.rapid7.client.dcerpc.mserref.SystemErrorCode} in [MS-ERREF]. The most commonerror codes are listed in the following table.<br> <br> <table border=""1""> <tr> <td>ERROR_ACCESS_DENIED (0x00000005)</td> <td>The caller does not have KEY_QUERY_VALUE access rights.</td> </tr> <tr> <td>ERROR_OUTOFMEMORY (0x0000000E)</td> <td>Not enough storage is available to complete this operation.</td> </tr> <tr> <td>ERROR_INVALID_PARAMETER (0x00000057)</td> <td>A parameter is incorrect.</td> </tr> <tr> <td>ERROR_INSUFFICIENT_BUFFER (0x0000007A)</td> <td>The data area passed to a system call is too small.</td> </tr> <tr> <td>ERROR_MORE_DATA (0x000000EA)</td> <td>More data is available.</td> </tr> <tr> <td>ERROR_NO_MORE_ITEMS (0x00000103)</td> <td>No more data is available.</td> </tr> <tr> <td>ERROR_WRITE_PROTECT (0x00000013)</td> <td>A read or write operation was attempted to a volume after it was dismounted. The server can no longer service registry requests because server shutdown has been initiated.</td> </tr> </table>
 */
public int getReturnValue(){
  return returnValue;
}","/** 
 * @return The method returns 0 (ERROR_SUCCESS) to indicate success; otherwise, it returns a nonzero error code, asspecified in  {@link com.rapid7.client.dcerpc.mserref.SystemErrorCode} in [MS-ERREF]. The most commonerror codes are listed in the following table.<br> <br> <table border=""1"" summary=""""> <tr> <td>ERROR_ACCESS_DENIED (0x00000005)</td> <td>The caller does not have KEY_QUERY_VALUE access rights.</td> </tr> <tr> <td>ERROR_OUTOFMEMORY (0x0000000E)</td> <td>Not enough storage is available to complete this operation.</td> </tr> <tr> <td>ERROR_INVALID_PARAMETER (0x00000057)</td> <td>A parameter is incorrect.</td> </tr> <tr> <td>ERROR_INSUFFICIENT_BUFFER (0x0000007A)</td> <td>The data area passed to a system call is too small.</td> </tr> <tr> <td>ERROR_MORE_DATA (0x000000EA)</td> <td>More data is available.</td> </tr> <tr> <td>ERROR_NO_MORE_ITEMS (0x00000103)</td> <td>No more data is available.</td> </tr> <tr> <td>ERROR_WRITE_PROTECT (0x00000013)</td> <td>A read or write operation was attempted to a volume after it was dismounted. The server can no longer service registry requests because server shutdown has been initiated.</td> </tr> </table>
 */
public int getReturnValue(){
  return returnValue;
}",0.9954973393368808
175594,"/** 
 * The BaseRegOpenKey method is called by the client. In response, the server opens a specified key for access and returns a handle to it.
 * @param hKey A handle to a key that MUST have been opened previously by using one of the open methods:{@link OpenClassesRoot},   {@link OpenCurrentUser},   {@link OpenLocalMachine},   {@link OpenPerformanceData},  {@link OpenUsers},   {@link BaseRegCreateKey},   {@link BaseRegOpenKey},   {@link OpenCurrentConfig},  {@link OpenPerformanceText},   {@link OpenPerformanceNlsText}.
 * @param subKey The name of a key to open.
 * @param options Registry key options. The user rights are represented as a bit field. In addition to the standarduser rights, as specified in [MS-DTYP] section 2.4.3, the Windows Remote Registry Protocol SHOULD support the following user rights. <table> <tr> <td>Value</td> <td>Meaning</td> </tr> <tr> <td>0x00000000</td> <td>This key is not volatile. The key and all its values MUST be persisted to the backing store and is preserved when the registry server loses context due to a system restart, reboot, or shut down process.</td> </tr> <tr> <td>0x00000001</td> <td>This key is volatile. The key with all its subkeys and values MUST NOT be preserved when the registry server loses context due to a system restart, reboot, or shut down process.</td> </tr> <tr> <td>0x00000002</td> <td>This key is a symbolic link to another key. The server stores the target of the symbolic link in an implementation-specific format.</td> </tr> </table>
 * @param accessMask A bit field that describes the requested security access for the handle to the key that isbeing opened. <table> <tr> <td>Value</td> <td>Meaning</td> </tr> <tr> <td>KEY_QUERY_VALUE (0x00000001)</td> <td>When set, specifies access to query the values of a registry key.</td> </tr> <tr> <td>KEY_SET_VALUE (0x00000002)</td> <td>When set, specifies access to create, delete, or set a registry value.</td> </tr> <tr> <td>KEY_CREATE_SUB_KEY (0x00000004)</td> <td>When set, specifies access to create a subkey of a registry key. Subkeys directly underneath the HKEY_LOCAL_MACHINE and HKEY_USERS predefined keys cannot be created even if this bit is set.</td> </tr> <tr> <td>KEY_ENUMERATE_SUB_KEYS (0x00000008)</td> <td>When set, specifies access to enumerate the subkeys of a registry key.</td> </tr> <tr> <td>KEY_CREATE_LINK (0x00000020)</td> <td>When set, specifies access to create a symbolic link to another key.</td> </tr> <tr> <td>KEY_WOW64_64KEY (0x00000100)</td> <td>When set, indicates that a registry server on a 64-bit operating system operates on the 64-bit key namespace.</td> </tr> <tr> <td>KEY_WOW64_32KEY (0x00000200)</td> <td>When set, indicates that a registry server on a 64-bit operating system operates on the 32-bit key namespace.</td> </tr> </table>
 * @see {@link <a href=""https://msdn.microsoft.com/en-us/cc244922"">2.2.4 REGSAM</a>}
 * @see {@link <a href=""https://msdn.microsoft.com/en-us/cc230294"">2.4.3 ACCESS_MASK</a>}
 * @see {@link <a href=""https://msdn.microsoft.com/en-us/cc244886"">3.1.1.2 Key Types</a>}
 */
public BaseRegOpenKey(final ContextHandle hKey,final String subKey,final int options,final EnumSet<AccessMask> accessMask){
  super((short)15);
  putBytes(hKey.getBytes());
  putString(subKey,true);
  putInt(options);
  putInt((int)EnumUtils.toLong(accessMask));
}","/** 
 * The BaseRegOpenKey method is called by the client. In response, the server opens a specified key for access and returns a handle to it.
 * @param hKey A handle to a key that MUST have been opened previously by using one of the open methods:{@link OpenClassesRoot},   {@link OpenCurrentUser},   {@link OpenLocalMachine},   {@link OpenPerformanceData},  {@link OpenUsers}, BaseRegCreateKey,   {@link BaseRegOpenKey},   {@link OpenCurrentConfig},  {@link OpenPerformanceText},   {@link OpenPerformanceNlsText}.
 * @param subKey The name of a key to open.
 * @param options Registry key options. The user rights are represented as a bit field. In addition to the standarduser rights, as specified in [MS-DTYP] section 2.4.3, the Windows Remote Registry Protocol SHOULD support the following user rights. <table border=""1"" summary=""""> <tr> <td>Value</td> <td>Meaning</td> </tr> <tr> <td>0x00000000</td> <td>This key is not volatile. The key and all its values MUST be persisted to the backing store and is preserved when the registry server loses context due to a system restart, reboot, or shut down process.</td> </tr> <tr> <td>0x00000001</td> <td>This key is volatile. The key with all its subkeys and values MUST NOT be preserved when the registry server loses context due to a system restart, reboot, or shut down process.</td> </tr> <tr> <td>0x00000002</td> <td>This key is a symbolic link to another key. The server stores the target of the symbolic link in an implementation-specific format.</td> </tr> </table>
 * @param accessMask A bit field that describes the requested security access for the handle to the key that isbeing opened. <table border=""1"" summary=""""> <tr> <td>Value</td> <td>Meaning</td> </tr> <tr> <td>KEY_QUERY_VALUE (0x00000001)</td> <td>When set, specifies access to query the values of a registry key.</td> </tr> <tr> <td>KEY_SET_VALUE (0x00000002)</td> <td>When set, specifies access to create, delete, or set a registry value.</td> </tr> <tr> <td>KEY_CREATE_SUB_KEY (0x00000004)</td> <td>When set, specifies access to create a subkey of a registry key. Subkeys directly underneath the HKEY_LOCAL_MACHINE and HKEY_USERS predefined keys cannot be created even if this bit is set.</td> </tr> <tr> <td>KEY_ENUMERATE_SUB_KEYS (0x00000008)</td> <td>When set, specifies access to enumerate the subkeys of a registry key.</td> </tr> <tr> <td>KEY_CREATE_LINK (0x00000020)</td> <td>When set, specifies access to create a symbolic link to another key.</td> </tr> <tr> <td>KEY_WOW64_64KEY (0x00000100)</td> <td>When set, indicates that a registry server on a 64-bit operating system operates on the 64-bit key namespace.</td> </tr> <tr> <td>KEY_WOW64_32KEY (0x00000200)</td> <td>When set, indicates that a registry server on a 64-bit operating system operates on the 32-bit key namespace.</td> </tr> </table>
 * @see <a href=""https://msdn.microsoft.com/en-us/cc244922"">2.2.4 REGSAM</a>
 * @see <a href=""https://msdn.microsoft.com/en-us/cc230294"">2.4.3 ACCESS_MASK</a>
 * @see <a href=""https://msdn.microsoft.com/en-us/cc244886"">3.1.1.2 Key Types</a>
 */
public BaseRegOpenKey(final ContextHandle hKey,final String subKey,final int options,final EnumSet<AccessMask> accessMask){
  super((short)15);
  putBytes(hKey.getBytes());
  putString(subKey,true);
  putInt(options);
  putInt((int)EnumUtils.toLong(accessMask));
}",0.9883058470764616
175595,"/** 
 * The BaseRegQueryInfoKey method is called by the client. In response, the server returns relevant information on the key that corresponds to the specified key handle.
 * @param hKey A handle to a key that MUST have been opened previously by using one of the open methods that arespecified in section 3.1.5:  {@link OpenClassesRoot},   {@link OpenCurrentUser},   {@link OpenLocalMachine},  {@link OpenPerformanceData},   {@link OpenUsers},   {@link BaseRegCreateKey},   {@link BaseRegOpenKey},  {@link OpenCurrentConfig},   {@link OpenPerformanceText},   {@link OpenPerformanceNlsText}.
 */
public BaseRegQueryInfoKeyRequest(final ContextHandle hKey){
  super((short)16);
  putBytes(hKey.getBytes());
  putStringBuffer(0);
}","/** 
 * The BaseRegQueryInfoKey method is called by the client. In response, the server returns relevant information on the key that corresponds to the specified key handle.
 * @param hKey A handle to a key that MUST have been opened previously by using one of the open methods that arespecified in section 3.1.5:  {@link OpenClassesRoot},   {@link OpenCurrentUser},   {@link OpenLocalMachine},  {@link OpenPerformanceData},   {@link OpenUsers}, BaseRegCreateKey,   {@link BaseRegOpenKey},  {@link OpenCurrentConfig},   {@link OpenPerformanceText},   {@link OpenPerformanceNlsText}.
 */
public BaseRegQueryInfoKeyRequest(final ContextHandle hKey){
  super((short)16);
  putBytes(hKey.getBytes());
  putStringBuffer(0);
}",0.993103448275862
175596,"/** 
 * @return The method returns 0 (ERROR_SUCCESS) to indicate success; otherwise, it returns a nonzero error code, asspecified in  {@link com.rapid7.client.dcerpc.mserref.SystemErrorCode} in [MS-ERREF]. The most commonerror codes are listed in the following table. <table> <td> <td>Return value/code</td> <td>Description</td> </tr> <td> <td>ERROR_ACCESS_DENIED (0x00000005)</td> <td>The caller does not have KEY_QUERY_VALUE access rights.</td> </tr> <td> <td>ERROR_INVALID_PARAMETER (0x00000057)</td> <td>A parameter is incorrect.</td> </tr> <td> <td>ERROR_WRITE_PROTECT (0x00000013)</td> <td>A read or write operation was attempted to a volume after it was dismounted. The server can no longer service registry requests because server shutdown has been initiated.</td> </tr> <td> <td>ERROR_MORE_DATA (0x000000EA)</td> <td>The size of the buffer is not large enough to hold the requested data.</td> </tr> </table>
 */
public int getReturnValue(){
  return returnValue;
}","/** 
 * @return The method returns 0 (ERROR_SUCCESS) to indicate success; otherwise, it returns a nonzero error code, asspecified in  {@link com.rapid7.client.dcerpc.mserref.SystemErrorCode} in [MS-ERREF]. The most commonerror codes are listed in the following table. <table border=""1"" summary=""""> <tr> <td>Return value/code</td> <td>Description</td> </tr> <tr> <td>ERROR_ACCESS_DENIED (0x00000005)</td> <td>The caller does not have KEY_QUERY_VALUE access rights.</td> </tr> <tr> <td>ERROR_INVALID_PARAMETER (0x00000057)</td> <td>A parameter is incorrect.</td> </tr> <tr> <td>ERROR_WRITE_PROTECT (0x00000013)</td> <td>A read or write operation was attempted to a volume after it was dismounted. The server can no longer service registry requests because server shutdown has been initiated.</td> </tr> <tr> <td>ERROR_MORE_DATA (0x000000EA)</td> <td>The size of the buffer is not large enough to hold the requested data.</td> </tr> </table>
 */
public int getReturnValue(){
  return returnValue;
}",0.9796747967479674
175597,"@Override public <T extends RPCResponse>T transact(final RPCRequest<T> request) throws IOException {
  final int callID;
synchronized (this) {
    callID=this.callID++;
  }
  final byte[] requestBytes=request.marshal(callID);
  final byte[] responseBytes=new byte[MAXIMUM_TRANSACT_SIZE];
  namedPipe.transact(requestBytes,responseBytes);
  return request.unmarshal(responseBytes,callID);
}","@Override public <T extends RPCResponse>T transact(final RPCRequest<T> request) throws IOException {
  final int callID;
synchronized (this) {
    callID=this.callID++;
  }
  final byte[] requestBytes=request.marshal(callID);
  final byte[] responseBytes=namedPipe.transact(requestBytes);
  return request.unmarshal(responseBytes,callID);
}",0.8148148148148148
175598,"/** 
 * 删除
 * @param startPos
 */
public void removeRangePartial(int startPos,int count){
  mCompletedBrickInfoList.removeAll(mCompletedBrickInfoList.subList(startPos,startPos + count));
  rebuildPositionCache(mCompletedBrickInfoList);
  mAdapter.removeRange(startPos,count);
}","/** 
 * 删除
 * @param startPos
 */
public void removeRangePartial(int startPos,int count){
  mCompletedBrickInfoList.removeAll(new ArrayList<>(mCompletedBrickInfoList).subList(startPos,startPos + count));
  rebuildPositionCache(mCompletedBrickInfoList);
  mAdapter.removeRange(startPos,count);
}",0.9702276707530648
175599,"public boolean isValidity(){
  return !FP.empty(viewEventElementMap);
}","public boolean isValidity(){
  return !FP.empty(viewEventElementMap) || !FP.empty(brickEventElementMap);
}",0.8022598870056498
175600,"private Element findHandlerElementByValue(String value,Set<? extends Element> brickEventHandlerElementSet){
  for (  Element element : brickEventHandlerElementSet) {
    String handlerValue=element.getAnnotation(BrickEventHandler.class).value();
    if (value.equals(handlerValue)) {
      return element;
    }
  }
  return null;
}","private Element findHandlerElementByValue(String value,Set<? extends Element> brickEventHandlerElementSet){
  for (  Element element : brickEventHandlerElementSet) {
    String handlerValue=element.getAnnotation(BrickEventHandler.class).value();
    if (value.equals(handlerValue)) {
      return element;
    }
  }
  error(""String_Node_Str"" + value);
  return null;
}",0.9171428571428571
175601,"private Element findViewElementByValue(String value,Set<? extends Element> viewElementSet){
  for (  Element element : viewElementSet) {
    String viewValue=element.getAnnotation(BrickView.class).value();
    if (value.equals(viewValue)) {
      return element;
    }
  }
  return null;
}","private Element findViewElementByValue(String value,Set<? extends Element> viewElementSet){
  for (  Element element : viewElementSet) {
    String viewValue=element.getAnnotation(BrickView.class).value();
    if (value.equals(viewValue)) {
      return element;
    }
  }
  error(""String_Node_Str"" + value);
  return null;
}",0.9055374592833876
175602,"private static void init(){
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    Class<?> brickInitClass=classLoader.loadClass(BrickHolder.class.getPackage().getName() + ""String_Node_Str"");
    brickInitClass.getMethod(""String_Node_Str"",Map.class).invoke(null,sBrickBuilders);
    brickInitClass.getMethod(""String_Node_Str"",Map.class).invoke(null,sBrickEventBinderMap);
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
catch (  NoSuchMethodException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
  }
}","public static void init(){
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    Class<?> brickInitClass=classLoader.loadClass(BrickHolder.class.getPackage().getName() + ""String_Node_Str"");
    brickInitClass.getMethod(""String_Node_Str"",Map.class).invoke(null,sBrickBuilders);
    brickInitClass.getMethod(""String_Node_Str"",Map.class).invoke(null,sBrickEventBinderMap);
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
catch (  NoSuchMethodException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
  }
}",0.991869918699187
175603,"protected static Builder builder(){
  return ImmutableColor.builder();
}","private static Builder builder(){
  return ImmutableColor.builder();
}",0.943661971830986
175604,"@Override public final String toString(){
  return value();
}","@Override public String toString(){
  return value;
}",0.9298245614035088
175605,"private static void assertValid(Attachment attachment){
  attachment.fields().forEach(FieldTests::assertValid);
  assertFalse(Strings.isNullOrEmpty(attachment.fallback()));
  Optional.ofNullable(attachment.color()).ifPresent(ColorTests::assertValid);
  attachment.pretext().ifPresent(pretext -> assertFalse(Strings.isNullOrEmpty(pretext)));
  Optional.ofNullable(attachment.author()).ifPresent(AuthorTests::assertValid);
  Optional.ofNullable(attachment.title()).ifPresent(TitleTests::assertValid);
  attachment.text().ifPresent(text -> assertFalse(Strings.isNullOrEmpty(text)));
  attachment.imageUrl().ifPresent(imageUrl -> assertFalse(Strings.isNullOrEmpty(imageUrl.toString())));
  attachment.thumbUrl().ifPresent(thumbUrl -> assertFalse(Strings.isNullOrEmpty(thumbUrl.toString())));
  Optional.ofNullable(attachment.footer()).ifPresent(FooterTests::assertValid);
}","public static void assertValid(Attachment attachment){
  attachment.fields().forEach(FieldTests::assertValid);
  assertFalse(Strings.isNullOrEmpty(attachment.fallback()));
  Optional.ofNullable(attachment.color()).ifPresent(ColorTests::assertValid);
  attachment.pretext().ifPresent(pretext -> assertFalse(Strings.isNullOrEmpty(pretext)));
  Optional.ofNullable(attachment.author()).ifPresent(AuthorTests::assertValid);
  Optional.ofNullable(attachment.title()).ifPresent(TitleTests::assertValid);
  attachment.text().ifPresent(text -> assertFalse(Strings.isNullOrEmpty(text)));
  attachment.imageUrl().ifPresent(imageUrl -> assertFalse(Strings.isNullOrEmpty(imageUrl.toString())));
  attachment.thumbUrl().ifPresent(thumbUrl -> assertFalse(Strings.isNullOrEmpty(thumbUrl.toString())));
  Optional.ofNullable(attachment.footer()).ifPresent(FooterTests::assertValid);
}",0.9936672423719056
175606,"@Override public Stream<? extends Arguments> arguments(ContainerExtensionContext context) throws Exception {
  return ResourcesDeserializer.deserialize(Attachment.class,RESOURCES_DIRECTORY).map(ObjectArrayArguments::create);
}","@Override public Stream<? extends Arguments> arguments(ContainerExtensionContext context) throws Exception {
  return ResourcesReader.readJson(RESOURCES_DIRECTORY).map(ObjectArrayArguments::create);
}",0.8826291079812206
175607,"@ParameterizedTest @ArgumentsSource(SerializedAttachmentsProvider.class) void testDeserialization(Attachment attachment){
  assertValid(attachment);
}","@ParameterizedTest @ArgumentsSource(SerializedAttachmentsProvider.class) void testDeserialization(JsonNode json){
  MoreAssertions.assertSerializable(json,Attachment.class,AttachmentTests::assertValid);
}",0.6666666666666666
175608,"@Override public Stream<? extends Arguments> arguments(ContainerExtensionContext context) throws Exception {
  return ResourcesDeserializer.deserialize(Author.class,RESOURCES_DIRECTORY).map(ObjectArrayArguments::create);
}","@Override public Stream<? extends Arguments> arguments(ContainerExtensionContext context) throws Exception {
  return ResourcesReader.readJson(RESOURCES_DIRECTORY).map(ObjectArrayArguments::create);
}",0.8909952606635071
175609,"@Override public Stream<? extends Arguments> arguments(ContainerExtensionContext context) throws Exception {
  return ResourcesDeserializer.deserialize(Color.class,RESOURCES_DIRECTORY).map(ObjectArrayArguments::create);
}","@Override public Stream<? extends Arguments> arguments(ContainerExtensionContext context) throws Exception {
  return ResourcesReader.readJson(RESOURCES_DIRECTORY).map(ObjectArrayArguments::create);
}",0.8931116389548693
175610,"@Override public Stream<? extends Arguments> arguments(ContainerExtensionContext context) throws Exception {
  return ResourcesDeserializer.deserialize(Field.class,RESOURCES_DIRECTORY).map(ObjectArrayArguments::create);
}","@Override public Stream<? extends Arguments> arguments(ContainerExtensionContext context) throws Exception {
  return ResourcesReader.readJson(RESOURCES_DIRECTORY).map(ObjectArrayArguments::create);
}",0.8931116389548693
175611,"@Override public Stream<? extends Arguments> arguments(ContainerExtensionContext context) throws Exception {
  return ResourcesDeserializer.deserialize(Footer.class,RESOURCES_DIRECTORY).map(ObjectArrayArguments::create);
}","@Override public Stream<? extends Arguments> arguments(ContainerExtensionContext context) throws Exception {
  return ResourcesReader.readJson(RESOURCES_DIRECTORY).map(ObjectArrayArguments::create);
}",0.8909952606635071
175612,"@ParameterizedTest @ArgumentsSource(SerializedFootersProvider.class) void testDeserialization(Footer footer){
  assertValid(footer);
}","@ParameterizedTest @ArgumentsSource(SerializedFootersProvider.class) void testDeserialization(JsonNode json){
  MoreAssertions.assertSerializable(json,Footer.class,FooterTests::assertValid);
}",0.7361963190184049
175613,"public Single<Response<ResponseBody>> downloadWmRelease(final int id,Context context){
  final WhatManagerService wm=WhatManagerService.Creator.newWMApiService(mPreferencesHelper.getWmHost(),context);
  return wm.login(mPreferencesHelper.getWmUser(),mPreferencesHelper.getWmPassword()).flatMap(new Function<Response<ResponseBody>,Single<Response<ResponseBody>>>(){
    @Override public Single<Response<ResponseBody>> apply(    Response<ResponseBody> response) throws Exception {
      return wm.addTorrent(id);
    }
  }
);
}","public Single<Response<ResponseBody>> downloadWmRelease(final int id,Context context){
  try {
    final WhatManagerService wm=WhatManagerService.Creator.newWMApiService(mPreferencesHelper.getWmHost(),context);
    return wm.login(mPreferencesHelper.getWmUser(),mPreferencesHelper.getWmPassword()).flatMap(new Function<Response<ResponseBody>,Single<Response<ResponseBody>>>(){
      @Override public Single<Response<ResponseBody>> apply(      Response<ResponseBody> response) throws Exception {
        return wm.addTorrent(id);
      }
    }
);
  }
 catch (  IllegalArgumentException e) {
    return Single.error(new Exception(""String_Node_Str""));
  }
}",0.8905852417302799
175614,"@Override public void showSendToServerComplete(){
  Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
}","@Override public void showSendToServerComplete(){
  Snackbar.make(getCurrentFocus(),""String_Node_Str"",Snackbar.LENGTH_LONG).show();
}",0.8286852589641435
175615,"@Override public void showError(String message){
}","@Override public void showError(String message){
  Snackbar.make(getCurrentFocus(),message,Snackbar.LENGTH_LONG).show();
}",0.5813953488372093
175616,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == 0) {
    if (resultCode == RESULT_OK) {
      mThreadPresenter.loadPosts(topicId,null,forumNav.getCurrentPageNumber());
      mPostRecycler.smoothScrollToPosition(mPostRecycler.getAdapter().getItemCount());
    }
 else {
    }
    fab.show();
  }
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == 0) {
    if (resultCode == RESULT_OK) {
      mThreadPresenter.addPost(data.getStringExtra(""String_Node_Str""),forumId,topicId);
    }
 else {
    }
    fab.show();
  }
}",0.717219589257504
175617,"public void init(Context context,AttributeSet attrs){
  this.context=context;
  this.attrs=attrs;
  int[] attrsArray=new int[]{R.attr.background_selected_color,R.attr.background_normal_color,R.attr.text_normal_color,R.attr.text_selected_color,R.attr.text_normal_size,R.attr.text_selected_size,R.attr.text_left,R.attr.text_right};
  TypedArray ta=context.obtainStyledAttributes(attrs,attrsArray);
  colorStateSelected=ta.getColor(0,getResources().getColor(R.color.background_selected_color));
  colorStateUnSelected=ta.getColor(1,getResources().getColor(R.color.background_normal_color));
  backgroundColor=colorStateUnSelected;
  text_normal_color=ta.getColor(2,getResources().getColor(R.color.text_normal_color));
  text_selected_color=ta.getColor(3,getResources().getColor(R.color.text_selected_color));
  text_normal_size=ta.getDimensionPixelSize(4,(int)getResources().getDimension(R.dimen.text_normal_size));
  text_selected_size=ta.getDimensionPixelSize(5,(int)getResources().getDimension(R.dimen.text_selected_size));
  lessText=ta.getString(6);
  if (lessText == null) {
    lessText=getResources().getString(R.string.text_left);
  }
  moreText=ta.getString(7);
  if (moreText == null) {
    moreText=getResources().getString(R.string.text_right);
  }
  ta.recycle();
  ovalPaint=new Paint();
  ovalPaint.setColor(backgroundColor);
  ovalPaint.setAntiAlias(true);
  thumbIcon=BitmapFactory.decodeResource(context.getResources(),R.drawable.switch_circle);
  orginalBitmapRect=new Rect();
  drawnBitmapRect=new Rect();
  ovalRectF=new RectF();
  textBounds=new Rect();
  textSelectedPaint=new Paint();
  textSelectedPaint.setColor(text_selected_color);
  textSelectedPaint.setTextSize(text_selected_size);
  textSelectedPaint.setAntiAlias(true);
  textNormalPaint=new Paint();
  textNormalPaint.setColor(text_normal_color);
  textNormalPaint.setTextSize(text_normal_size);
  textNormalPaint.setAntiAlias(true);
}","public void init(Context context,AttributeSet attrs){
  this.context=context;
  this.attrs=attrs;
  TypedArray ta=context.obtainStyledAttributes(attrs,R.styleable.ThreeStateSwitch);
  colorStateSelected=ta.getColor(R.styleable.ThreeStateSwitch_background_selected_color,getResources().getColor(R.color.background_selected_color));
  colorStateUnSelected=ta.getColor(R.styleable.ThreeStateSwitch_background_normal_color,getResources().getColor(R.color.background_normal_color));
  backgroundColor=colorStateUnSelected;
  text_normal_color=ta.getColor(R.styleable.ThreeStateSwitch_text_normal_color,getResources().getColor(R.color.text_normal_color));
  text_selected_color=ta.getColor(R.styleable.ThreeStateSwitch_text_selected_color,getResources().getColor(R.color.text_selected_color));
  text_normal_size=ta.getDimensionPixelSize(R.styleable.ThreeStateSwitch_text_normal_size,(int)getResources().getDimension(R.dimen.text_normal_size));
  text_selected_size=ta.getDimensionPixelSize(R.styleable.ThreeStateSwitch_text_selected_size,(int)getResources().getDimension(R.dimen.text_selected_size));
  lessText=ta.getString(R.styleable.ThreeStateSwitch_text_left);
  if (lessText == null) {
    lessText=getResources().getString(R.string.text_left);
  }
  moreText=ta.getString(R.styleable.ThreeStateSwitch_text_right);
  if (moreText == null) {
    moreText=getResources().getString(R.string.text_right);
  }
  ta.recycle();
  ovalPaint=new Paint();
  ovalPaint.setColor(backgroundColor);
  ovalPaint.setAntiAlias(true);
  thumbIcon=BitmapFactory.decodeResource(context.getResources(),R.drawable.switch_circle);
  orginalBitmapRect=new Rect();
  drawnBitmapRect=new Rect();
  ovalRectF=new RectF();
  textBounds=new Rect();
  textSelectedPaint=new Paint();
  textSelectedPaint.setColor(text_selected_color);
  textSelectedPaint.setTextSize(text_selected_size);
  textSelectedPaint.setAntiAlias(true);
  textNormalPaint=new Paint();
  textNormalPaint.setColor(text_normal_color);
  textNormalPaint.setTextSize(text_normal_size);
  textNormalPaint.setAntiAlias(true);
}",0.8349660889223813
175618,long crypto_box_noncebytes();,NativeLong crypto_box_noncebytes();,0.875
175619,"public static long crytoBoxPublicKeyBytes(){
  return sodium().crypto_box_publickeybytes();
}","public static NativeLong crytoBoxPublicKeyBytes(){
  return sodium().crypto_box_publickeybytes();
}",0.9583333333333334
175620,"/** 
 * Verify message authentication code with the secret key
 * @param mac Message authentication code
 * @param message The message
 * @param key The secret key used to create the authentication code
 * @return true or false
 * @throws SodiumLibraryException on error
 * @see <a href=""https://download.libsodium.org/libsodium/content/secret-key_cryptography/secret-key_authentication.html"" target=""_blank"">Secret-key authentication</a>
 */
public static boolean cryptoAuthVerify(byte[] mac,byte[] message,byte[] key) throws SodiumLibraryException {
  long keySize=sodium().crypto_auth_keybytes();
  if (key.length != keySize) {
    throw new SodiumLibraryException(""String_Node_Str"" + keySize + ""String_Node_Str""+ key.length+ ""String_Node_Str"");
  }
  int rc=sodium().crypto_auth_verify(mac,message,message.length,key);
  if (rc == 0) {
    return true;
  }
 else   if (rc == -1) {
    return false;
  }
  return false;
}","/** 
 * Verify message authentication code with the secret key
 * @param mac Message authentication code
 * @param message The message
 * @param key The secret key used to create the authentication code
 * @return true or false
 * @throws SodiumLibraryException on error
 * @see <a href=""https://download.libsodium.org/libsodium/content/secret-key_cryptography/secret-key_authentication.html"" target=""_blank"">Secret-key authentication</a>
 */
public static boolean cryptoAuthVerify(byte[] mac,byte[] message,byte[] key) throws SodiumLibraryException {
  int keySize=sodium().crypto_auth_keybytes().intValue();
  if (key.length != keySize) {
    throw new SodiumLibraryException(""String_Node_Str"" + keySize + ""String_Node_Str""+ key.length+ ""String_Node_Str"");
  }
  int rc=sodium().crypto_auth_verify(mac,message,message.length,key);
  if (rc == 0) {
    return true;
  }
 else   if (rc == -1) {
    return false;
  }
  return false;
}",0.9903121636167922
175621,"/** 
 * Given a private key, generate the corresponding public key
 * @param privateKey The private key
 * @throws SodiumLibraryException on error
 * @return public key bytes
 */
public static byte[] cryptoPublicKey(byte[] privateKey) throws SodiumLibraryException {
  byte[] publicKey=new byte[(int)sodium().crypto_box_publickeybytes()];
  int rc=sodium().crypto_scalarmult_base(publicKey,privateKey);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return publicKey;
}","/** 
 * Given a private key, generate the corresponding public key
 * @param privateKey The private key
 * @throws SodiumLibraryException on error
 * @return public key bytes
 */
public static byte[] cryptoPublicKey(byte[] privateKey) throws SodiumLibraryException {
  byte[] publicKey=new byte[sodium().crypto_box_publickeybytes().intValue()];
  int rc=sodium().crypto_scalarmult_base(publicKey,privateKey);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return publicKey;
}",0.9849056603773584
175622,"public static long cryptoSecretBoxKeyBytes(){
  return sodium().crypto_secretbox_keybytes();
}","public static NativeLong cryptoSecretBoxKeyBytes(){
  return sodium().crypto_secretbox_keybytes();
}",0.9587628865979382
175623,"public static long crytoBoxSeedBytes(){
  return sodium().crypto_box_seedbytes();
}","public static NativeLong crytoBoxSeedBytes(){
  return sodium().crypto_box_seedbytes();
}",0.9534883720930232
175624,long crypto_auth_keybytes();,NativeLong crypto_auth_keybytes();,0.8709677419354839
175625,"/** 
 * Verifies and decrypts a ciphertext - detached mode
 * @param secretBox {@link SodiumSecretBox} used during encryption
 * @param nonce Nonce used in encryption
 * @param key The key used in encryption
 * @return decrypted plaintext bytes
 * @throws SodiumLibraryException on error
 * @see <a href=""https://download.libsodium.org/libsodium/content/secret-key_cryptography/authenticated_encryption.html"" target=""_blank"">Secret-key authenticated encryption</a>
 */
public static byte[] cryptoSecretBoxOpenDetached(SodiumSecretBox secretBox,byte[] nonce,byte[] key) throws SodiumLibraryException {
  if (key.length != sodium().crypto_secretbox_keybytes()) {
    throw new SodiumLibraryException(""String_Node_Str"" + key.length + ""String_Node_Str"");
  }
  if (nonce.length != sodium().crypto_secretbox_noncebytes()) {
    throw new SodiumLibraryException(""String_Node_Str"" + nonce.length + ""String_Node_Str"");
  }
  byte[] mac=secretBox.getMac();
  if (mac.length != sodium().crypto_secretbox_macbytes()) {
    throw new SodiumLibraryException(""String_Node_Str"" + mac.length + ""String_Node_Str"");
  }
  byte[] message=new byte[secretBox.getCipherText().length];
  byte[] cipherText=secretBox.getCipherText();
  int rc=sodium().crypto_secretbox_open_detached(message,cipherText,mac,cipherText.length,nonce,key);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return message;
}","/** 
 * Verifies and decrypts a ciphertext - detached mode
 * @param secretBox {@link SodiumSecretBox} used during encryption
 * @param nonce Nonce used in encryption
 * @param key The key used in encryption
 * @return decrypted plaintext bytes
 * @throws SodiumLibraryException on error
 * @see <a href=""https://download.libsodium.org/libsodium/content/secret-key_cryptography/authenticated_encryption.html"" target=""_blank"">Secret-key authenticated encryption</a>
 */
public static byte[] cryptoSecretBoxOpenDetached(SodiumSecretBox secretBox,byte[] nonce,byte[] key) throws SodiumLibraryException {
  if (key.length != sodium().crypto_secretbox_keybytes().intValue()) {
    throw new SodiumLibraryException(""String_Node_Str"" + key.length + ""String_Node_Str"");
  }
  if (nonce.length != sodium().crypto_secretbox_noncebytes().intValue()) {
    throw new SodiumLibraryException(""String_Node_Str"" + nonce.length + ""String_Node_Str"");
  }
  byte[] mac=secretBox.getMac();
  if (mac.length != sodium().crypto_secretbox_macbytes().intValue()) {
    throw new SodiumLibraryException(""String_Node_Str"" + mac.length + ""String_Node_Str"");
  }
  byte[] message=new byte[secretBox.getCipherText().length];
  byte[] cipherText=secretBox.getCipherText();
  int rc=sodium().crypto_secretbox_open_detached(message,cipherText,mac,cipherText.length,nonce,key);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return message;
}",0.9886246122026888
175626,"/** 
 * Computes an authentication tag for a message with a secret key.  The operation does not encrypt the message.  Usage: Alice prepares a message and the authentication tag and send it to Bob. Alice does not store the message. Later Bob sends the message and the authentication tag to Alice. Alice calls   {@link SodiumLibrary#cryptoAuthVerify(byte[] mac,byte[] message,byte[] key)}verify that the message is created by her.
 * @param message Computes the tag for this message bytes
 * @param key The secret key. The key size must be crypto_auth_keybytes() long
 * @return Authentication tag bytes
 * @throws SodiumLibraryException on error
 * @see <a href=""https://download.libsodium.org/libsodium/content/secret-key_cryptography/secret-key_authentication.html"" target=""_blank"">Secret-key authentication</a>
 */
public static byte[] cryptoAuth(byte[] message,byte[] key) throws SodiumLibraryException {
  byte[] mac=new byte[(int)sodium().crypto_auth_bytes()];
  long keySize=sodium().crypto_auth_keybytes();
  if (key.length != keySize) {
    throw new SodiumLibraryException(""String_Node_Str"" + keySize + ""String_Node_Str""+ key.length+ ""String_Node_Str"");
  }
  int rc=sodium().crypto_auth(mac,message,message.length,key);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return mac;
}","/** 
 * Computes an authentication tag for a message with a secret key.  The operation does not encrypt the message.  Usage: Alice prepares a message and the authentication tag and send it to Bob. Alice does not store the message. Later Bob sends the message and the authentication tag to Alice. Alice calls   {@link SodiumLibrary#cryptoAuthVerify(byte[] mac,byte[] message,byte[] key)}verify that the message is created by her.
 * @param message Computes the tag for this message bytes
 * @param key The secret key. The key size must be crypto_auth_keybytes() long
 * @return Authentication tag bytes
 * @throws SodiumLibraryException on error
 * @see <a href=""https://download.libsodium.org/libsodium/content/secret-key_cryptography/secret-key_authentication.html"" target=""_blank"">Secret-key authentication</a>
 */
public static byte[] cryptoAuth(byte[] message,byte[] key) throws SodiumLibraryException {
  byte[] mac=new byte[sodium().crypto_auth_bytes().intValue()];
  int keySize=sodium().crypto_auth_keybytes().intValue();
  if (key.length != keySize) {
    throw new SodiumLibraryException(""String_Node_Str"" + keySize + ""String_Node_Str""+ key.length+ ""String_Node_Str"");
  }
  int rc=sodium().crypto_auth(mac,message,message.length,key);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return mac;
}",0.9682890855457228
175627,"public static long cryptoBoxNonceBytes(){
  return sodium().crypto_box_noncebytes();
}","public static NativeLong cryptoBoxNonceBytes(){
  return sodium().crypto_box_noncebytes();
}",0.9550561797752808
175628,"/** 
 * Encrypts a message with recipient's public key. Usage: Alice encrypts a message with Bob's public key and creates authentication tag with her private key
 * @param message The message to encrypt
 * @param nonce {@link SodiumLibrary#cryptoBoxNonceBytes()} bytes of nonce. It must be preserved  because it will be needed during decryption
 * @param publicKey Recipient's public key for encrypting the message
 * @param privateKey Sender's private key for creating authentication tag
 * @throws SodiumLibraryException on error
 * @return encrypted message as an array of bytes
 */
public static byte[] cryptoBoxEasy(byte[] message,byte[] nonce,byte[] publicKey,byte[] privateKey) throws SodiumLibraryException {
  long nonce_len=sodium().crypto_box_noncebytes();
  if (nonce.length != nonce_len) {
    throw new SodiumLibraryException(""String_Node_Str"" + nonce.length + ""String_Node_Str""+ nonce_len+ ""String_Node_Str"");
  }
  byte[] cipherText=new byte[(int)(sodium().crypto_box_macbytes() + message.length)];
  int rc=sodium().crypto_box_easy(cipherText,message,message.length,nonce,publicKey,privateKey);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return cipherText;
}","/** 
 * Encrypts a message with recipient's public key. Usage: Alice encrypts a message with Bob's public key and creates authentication tag with her private key
 * @param message The message to encrypt
 * @param nonce {@link SodiumLibrary#cryptoBoxNonceBytes()} bytes of nonce. It must be preserved  because it will be needed during decryption
 * @param publicKey Recipient's public key for encrypting the message
 * @param privateKey Sender's private key for creating authentication tag
 * @throws SodiumLibraryException on error
 * @return encrypted message as an array of bytes
 */
public static byte[] cryptoBoxEasy(byte[] message,byte[] nonce,byte[] publicKey,byte[] privateKey) throws SodiumLibraryException {
  NativeLong nonce_len=sodium().crypto_box_noncebytes();
  if (nonce.length != nonce_len.intValue()) {
    throw new SodiumLibraryException(""String_Node_Str"" + nonce.length + ""String_Node_Str""+ nonce_len+ ""String_Node_Str"");
  }
  byte[] cipherText=new byte[(sodium().crypto_box_macbytes().intValue() + message.length)];
  int rc=sodium().crypto_box_easy(cipherText,message,message.length,nonce,publicKey,privateKey);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return cipherText;
}",0.985983179815779
175629,"/** 
 * Encrypts a message with recipient's public key. Usage: Alice can anonymously send a message to Bob by encrypting the message with his public key.
 * @param message The message bytes to encrypt
 * @param recipientPublicKey Recipient's public key 
 * @throws SodiumLibraryException on error
 * @return Encrypted message bytes. The length of the cipher text will be {@link SodiumLibrary#cryptoBoxSealBytes()} + message.length
 * @see <a href=""https://download.libsodium.org/libsodium/content/public-key_cryptography/sealed_boxes.html"" target=""_blank"">Sealed boxes</a>
 */
public static byte[] cryptoBoxSeal(byte[] message,byte[] recipientPublicKey) throws SodiumLibraryException {
  logger.info(""String_Node_Str"" + message.length);
  byte[] cipherText=new byte[(int)(sodium().crypto_box_sealbytes() + message.length)];
  int rc=sodium().crypto_box_seal(cipherText,message,message.length,recipientPublicKey);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return cipherText;
}","/** 
 * Encrypts a message with recipient's public key. Usage: Alice can anonymously send a message to Bob by encrypting the message with his public key.
 * @param message The message bytes to encrypt
 * @param recipientPublicKey Recipient's public key 
 * @throws SodiumLibraryException on error
 * @return Encrypted message bytes. The length of the cipher text will be {@link SodiumLibrary#cryptoBoxSealBytes()} + message.length
 * @see <a href=""https://download.libsodium.org/libsodium/content/public-key_cryptography/sealed_boxes.html"" target=""_blank"">Sealed boxes</a>
 */
public static byte[] cryptoBoxSeal(byte[] message,byte[] recipientPublicKey) throws SodiumLibraryException {
  logger.info(""String_Node_Str"" + message.length);
  byte[] cipherText=new byte[(sodium().crypto_box_sealbytes().intValue() + message.length)];
  int rc=sodium().crypto_box_seal(cipherText,message,message.length,recipientPublicKey);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return cipherText;
}",0.9923150816522576
175630,"/** 
 * Decrypts a ciphertext using recipient's  key pair. Only the recipient can decrypt the message with his private key but the recipient can not identify the sender.
 * @param cipherText Ciphertext to decrypt
 * @param pk Recipient's public key
 * @param sk Recipient's private Key
 * @throws SodiumLibraryException on error
 * @return Decrypted plaintext bytes. 
 * @throws SodiumLibraryException on error
 * @see <a href=""https://download.libsodium.org/libsodium/content/public-key_cryptography/sealed_boxes.html"" target=""_blank"">Sealed boxes</a>
 */
public static byte[] cryptoBoxSealOpen(byte[] cipherText,byte[] pk,byte[] sk) throws SodiumLibraryException {
  byte[] decrypted=new byte[(int)(cipherText.length - sodium().crypto_box_sealbytes())];
  int rc=sodium().crypto_box_seal_open(decrypted,cipherText,cipherText.length,pk,sk);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return decrypted;
}","/** 
 * Decrypts a ciphertext using recipient's  key pair. Only the recipient can decrypt the message with his private key but the recipient can not identify the sender.
 * @param cipherText Ciphertext to decrypt
 * @param pk Recipient's public key
 * @param sk Recipient's private Key
 * @throws SodiumLibraryException on error
 * @return Decrypted plaintext bytes. 
 * @throws SodiumLibraryException on error
 * @see <a href=""https://download.libsodium.org/libsodium/content/public-key_cryptography/sealed_boxes.html"" target=""_blank"">Sealed boxes</a>
 */
public static byte[] cryptoBoxSealOpen(byte[] cipherText,byte[] pk,byte[] sk) throws SodiumLibraryException {
  byte[] decrypted=new byte[(int)(cipherText.length - sodium().crypto_box_sealbytes().intValue())];
  int rc=sodium().crypto_box_seal_open(decrypted,cipherText,cipherText.length,pk,sk);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return decrypted;
}",0.9943386515697376
175631,long crypto_box_publickeybytes();,NativeLong crypto_box_publickeybytes();,0.8888888888888888
175632,long crypto_auth_bytes();,NativeLong crypto_auth_bytes();,0.8571428571428571
175633,"public static long cryptoBoxSealBytes(){
  return sodium().crypto_box_sealbytes();
}","public static NativeLong cryptoBoxSealBytes(){
  return sodium().crypto_box_sealbytes();
}",0.9540229885057472
175634,long crypto_secretbox_macbytes();,NativeLong crypto_secretbox_macbytes();,0.8888888888888888
175635,long crypto_box_secretkeybytes();,NativeLong crypto_box_secretkeybytes();,0.8888888888888888
175636,"/** 
 * Encrypts a message with a key and a nonce to keep it confidential - detached mode.
 * @param message The message bytes to encrypt
 * @param nonce The nonce to use in encryption
 * @param key The key to encrypt
 * @return {@link SodiumSecretBox}
 * @throws SodiumLibraryException on error
 * @see <a href=""https://download.libsodium.org/libsodium/content/secret-key_cryptography/authenticated_encryption.html"" target=""_blank"">Secret-key authenticated encryption</a>
 */
public static SodiumSecretBox cryptoSecretBoxDetached(byte[] message,byte[] nonce,byte[] key) throws SodiumLibraryException {
  if (key.length != sodium().crypto_secretbox_keybytes()) {
    throw new SodiumLibraryException(""String_Node_Str"" + key.length + ""String_Node_Str"");
  }
  if (nonce.length != sodium().crypto_secretbox_noncebytes()) {
    throw new SodiumLibraryException(""String_Node_Str"" + nonce.length + ""String_Node_Str"");
  }
  byte[] cipherText=new byte[message.length];
  byte[] mac=new byte[(int)sodium().crypto_secretbox_macbytes()];
  int rc=sodium().crypto_secretbox_detached(cipherText,mac,message,message.length,nonce,key);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  SodiumSecretBox secretBox=new SodiumSecretBox();
  secretBox.setCipherText(cipherText);
  secretBox.setMac(mac);
  return secretBox;
}","/** 
 * Encrypts a message with a key and a nonce to keep it confidential - detached mode.
 * @param message The message bytes to encrypt
 * @param nonce The nonce to use in encryption
 * @param key The key to encrypt
 * @return {@link SodiumSecretBox}
 * @throws SodiumLibraryException on error
 * @see <a href=""https://download.libsodium.org/libsodium/content/secret-key_cryptography/authenticated_encryption.html"" target=""_blank"">Secret-key authenticated encryption</a>
 */
public static SodiumSecretBox cryptoSecretBoxDetached(byte[] message,byte[] nonce,byte[] key) throws SodiumLibraryException {
  if (key.length != sodium().crypto_secretbox_keybytes().intValue()) {
    throw new SodiumLibraryException(""String_Node_Str"" + key.length + ""String_Node_Str"");
  }
  if (nonce.length != sodium().crypto_secretbox_noncebytes().intValue()) {
    throw new SodiumLibraryException(""String_Node_Str"" + nonce.length + ""String_Node_Str"");
  }
  byte[] cipherText=new byte[message.length];
  byte[] mac=new byte[(int)sodium().crypto_secretbox_macbytes().intValue()];
  int rc=sodium().crypto_secretbox_detached(cipherText,mac,message,message.length,nonce,key);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  SodiumSecretBox secretBox=new SodiumSecretBox();
  secretBox.setCipherText(cipherText);
  secretBox.setMac(mac);
  return secretBox;
}",0.9880304678998912
175637,"public static long crytoBoxSecretKeyBytes(){
  return sodium().crypto_box_secretkeybytes();
}","public static NativeLong crytoBoxSecretKeyBytes(){
  return sodium().crypto_box_secretkeybytes();
}",0.9583333333333334
175638,"/** 
 * Encrypts a message with a key and a nonce to keep it confidential. The same key is used to encrypt and decrypt the messages. Therefore, the key must be kept confidential.
 * @param message message bytes to encrypt
 * @param nonce  nonce bytes. The nonce must be {@link SodiumLibrary#cryptoBoxNonceBytes()} bytes long and can be generated bycalling  {@link SodiumLibrary#randomBytes(int)}
 * @param key They key for encryption
 * @throws SodiumLibraryException on error
 * @return Encrypted cipher text bytes 
 * @see <a href=""https://download.libsodium.org/libsodium/content/secret-key_cryptography/authenticated_encryption.html"" target=""_blank"">Secret-key authenticated encryption</a>
 */
public static byte[] cryptoSecretBoxEasy(byte[] message,byte[] nonce,byte[] key) throws SodiumLibraryException {
  long nonce_length=sodium().crypto_secretbox_noncebytes();
  if (nonce_length != nonce.length) {
    throw new SodiumLibraryException(""String_Node_Str"" + nonce.length + ""String_Node_Str""+ nonce_length+ ""String_Node_Str"");
  }
  byte[] cipherText=new byte[(int)(sodium().crypto_box_macbytes() + message.length)];
  int rc=sodium().crypto_secretbox_easy(cipherText,message,message.length,nonce,key);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return cipherText;
}","/** 
 * Encrypts a message with a key and a nonce to keep it confidential. The same key is used to encrypt and decrypt the messages. Therefore, the key must be kept confidential.
 * @param message message bytes to encrypt
 * @param nonce  nonce bytes. The nonce must be {@link SodiumLibrary#cryptoBoxNonceBytes()} bytes long and can be generated bycalling  {@link SodiumLibrary#randomBytes(int)}
 * @param key They key for encryption
 * @throws SodiumLibraryException on error
 * @return Encrypted cipher text bytes 
 * @see <a href=""https://download.libsodium.org/libsodium/content/secret-key_cryptography/authenticated_encryption.html"" target=""_blank"">Secret-key authenticated encryption</a>
 */
public static byte[] cryptoSecretBoxEasy(byte[] message,byte[] nonce,byte[] key) throws SodiumLibraryException {
  int nonce_length=sodium().crypto_secretbox_noncebytes().intValue();
  if (nonce_length != nonce.length) {
    throw new SodiumLibraryException(""String_Node_Str"" + nonce.length + ""String_Node_Str""+ nonce_length+ ""String_Node_Str"");
  }
  byte[] cipherText=new byte[(sodium().crypto_box_macbytes().intValue() + message.length)];
  int rc=sodium().crypto_secretbox_easy(cipherText,message,message.length,nonce,key);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return cipherText;
}",0.9873417721518988
175639,long crypto_secretbox_noncebytes();,NativeLong crypto_secretbox_noncebytes();,0.8947368421052632
175640,"/** 
 * Randomly generates a private key and the corresponding public key
 * @return {@link SodiumKeyPair}
 * @throws SodiumLibraryException on error
 * @see <a href=""https://download.libsodium.org/libsodium/content/public-key_cryptography/authenticated_encryption.html"" target=""_blank"">Public-key authenticated encryption</a>
 */
public static SodiumKeyPair cryptoBoxKeyPair() throws SodiumLibraryException {
  SodiumKeyPair kp=new SodiumKeyPair();
  byte[] publicKey=new byte[(int)sodium().crypto_box_publickeybytes()];
  byte[] privateKey=new byte[(int)sodium().crypto_box_secretkeybytes()];
  int rc=sodium().crypto_box_keypair(publicKey,privateKey);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  kp.setPublicKey(publicKey);
  kp.setPrivateKey(privateKey);
  logger.info(""String_Node_Str"" + publicKey.length);
  logger.info(""String_Node_Str"" + privateKey.length);
  return kp;
}","/** 
 * Randomly generates a private key and the corresponding public key
 * @return {@link SodiumKeyPair}
 * @throws SodiumLibraryException on error
 * @see <a href=""https://download.libsodium.org/libsodium/content/public-key_cryptography/authenticated_encryption.html"" target=""_blank"">Public-key authenticated encryption</a>
 */
public static SodiumKeyPair cryptoBoxKeyPair() throws SodiumLibraryException {
  SodiumKeyPair kp=new SodiumKeyPair();
  byte[] publicKey=new byte[sodium().crypto_box_publickeybytes().intValue()];
  byte[] privateKey=new byte[sodium().crypto_box_secretkeybytes().intValue()];
  int rc=sodium().crypto_box_keypair(publicKey,privateKey);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  kp.setPublicKey(publicKey);
  kp.setPrivateKey(privateKey);
  logger.info(""String_Node_Str"" + publicKey.length);
  logger.info(""String_Node_Str"" + privateKey.length);
  return kp;
}",0.9831045406546992
175641,"/** 
 * Verifies and decrypts a ciphertext. The ciphertext is created by   {@link SodiumLibrary#cryptoSecretBoxEasy(byte[] message,byte[] nonce,byte[] key)}
 * @param cipherText The ciphertext to decrypt
 * @param nonce The nonce used during encryption
 * @param key The key used in encryption
 * @return decrypted plaintext bytes
 * @throws SodiumLibraryException - if nonce size is incorrect or decryption fails
 * @see <a href=""https://download.libsodium.org/libsodium/content/secret-key_cryptography/authenticated_encryption.html"" target=""_blank"">Secret-key authenticated encryption</a><h3>Example</h3> <pre> <code> // don't forget to load the libsodium library first String message = ""This is a message""; // generate nonce long nonceBytesLength = SodiumLibrary.cryptoSecretBoxNonceBytes(); byte[] nonceBytes = SodiumLibrary.randomBytes((int) nonceBytesLength); byte[] messageBytes = message.getBytes(); // generate the encryption key byte[] key = SodiumLibrary.randomBytes((int) SodiumLibrary.cryptoSecretBoxKeyBytes()); // encrypt byte[] cipherText = SodiumLibrary.cryptoSecretBoxEasy(messageBytes, nonceBytes, key); // now decrypt byte[] decryptedMessageBytes = SodiumLibrary.cryptoSecretBoxOpenEasy(cipherText, nonceBytes, key); String decryptedMessage; try { decryptedMessage = new String(decryptedMessageBytes, ""UTF-8""); System.out.println(""Decrypted message: "" + decryptedMessageBytes); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } </code> </pre>
 */
public static byte[] cryptoSecretBoxOpenEasy(byte[] cipherText,byte[] nonce,byte[] key) throws SodiumLibraryException {
  if (key.length != sodium().crypto_secretbox_keybytes()) {
    throw new SodiumLibraryException(""String_Node_Str"" + key.length + ""String_Node_Str"");
  }
  if (nonce.length != sodium().crypto_secretbox_noncebytes()) {
    throw new SodiumLibraryException(""String_Node_Str"" + nonce.length + ""String_Node_Str"");
  }
  byte[] decrypted=new byte[(int)(cipherText.length - sodium().crypto_box_macbytes())];
  int rc=sodium().crypto_secretbox_open_easy(decrypted,cipherText,cipherText.length,nonce,key);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return decrypted;
}","/** 
 * Verifies and decrypts a ciphertext. The ciphertext is created by   {@link SodiumLibrary#cryptoSecretBoxEasy(byte[] message,byte[] nonce,byte[] key)}
 * @param cipherText The ciphertext to decrypt
 * @param nonce The nonce used during encryption
 * @param key The key used in encryption
 * @return decrypted plaintext bytes
 * @throws SodiumLibraryException - if nonce size is incorrect or decryption fails
 * @see <a href=""https://download.libsodium.org/libsodium/content/secret-key_cryptography/authenticated_encryption.html"" target=""_blank"">Secret-key authenticated encryption</a><h3>Example</h3> <pre> <code> // don't forget to load the libsodium library first String message = ""This is a message""; // generate nonce long nonceBytesLength = SodiumLibrary.cryptoSecretBoxNonceBytes(); byte[] nonceBytes = SodiumLibrary.randomBytes((int) nonceBytesLength); byte[] messageBytes = message.getBytes(); // generate the encryption key byte[] key = SodiumLibrary.randomBytes((int) SodiumLibrary.cryptoSecretBoxKeyBytes()); // encrypt byte[] cipherText = SodiumLibrary.cryptoSecretBoxEasy(messageBytes, nonceBytes, key); // now decrypt byte[] decryptedMessageBytes = SodiumLibrary.cryptoSecretBoxOpenEasy(cipherText, nonceBytes, key); String decryptedMessage; try { decryptedMessage = new String(decryptedMessageBytes, ""UTF-8""); System.out.println(""Decrypted message: "" + decryptedMessageBytes); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } </code> </pre>
 */
public static byte[] cryptoSecretBoxOpenEasy(byte[] cipherText,byte[] nonce,byte[] key) throws SodiumLibraryException {
  if (key.length != sodium().crypto_secretbox_keybytes().intValue()) {
    throw new SodiumLibraryException(""String_Node_Str"" + key.length + ""String_Node_Str"");
  }
  if (nonce.length != sodium().crypto_secretbox_noncebytes().intValue()) {
    throw new SodiumLibraryException(""String_Node_Str"" + nonce.length + ""String_Node_Str"");
  }
  byte[] decrypted=new byte[(cipherText.length - sodium().crypto_box_macbytes().intValue())];
  int rc=sodium().crypto_secretbox_open_easy(decrypted,cipherText,cipherText.length,nonce,key);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return decrypted;
}",0.9915140687807056
175642,"public static byte[] cryptoSignEdSkTOcurveSk(byte[] edSK) throws SodiumLibraryException {
  byte[] curveSK=new byte[(int)sodium().crypto_box_publickeybytes()];
  int rc=sodium().crypto_sign_ed25519_sk_to_curve25519(curveSK,edSK);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return curveSK;
}","public static byte[] cryptoSignEdSkTOcurveSk(byte[] edSK) throws SodiumLibraryException {
  byte[] curveSK=new byte[sodium().crypto_box_publickeybytes().intValue()];
  int rc=sodium().crypto_sign_ed25519_sk_to_curve25519(curveSK,edSK);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return curveSK;
}",0.9774647887323944
175643,"public static long cryptoBoxMacBytes(){
  return sodium().crypto_box_macbytes();
}","public static NativeLong cryptoBoxMacBytes(){
  return sodium().crypto_box_macbytes();
}",0.9529411764705882
175644,"/** 
 * Derive a key using Argon2id password hashing scheme <p> The following is taken from <a href=""https://download.libsodium.org/doc/password_hashing/"">libsodium documentation</a>: <blockquote> Argon2 is optimized for the x86 architecture and exploits the cache and memory organization of the recent Intel  and AMD processors. But its implementation remains portable and fast on other architectures. Argon2 has three  variants: Argon2d, Argon2i and Argon2id. Argon2i uses data-independent memory access, which is preferred for  password hashing and password-based key derivation. Argon2i also makes multiple passes over the memory to  protect from tradeoff attacks. Argon2id combines both. </blockquote>
 * @param passwd Array of bytes of password
 * @param salt Salt to use in key generation. The salt should be unpredictable and can be generated by calling SodiumLibary.randomBytes(int)The salt should be saved by the caller as it will be needed to derive the key again from the  password.
 * @return Generated key as an array of bytes
 * @throws SodiumLibraryException if libsodium's crypto_pwhash() does not return 0<code>crypto_pwhash()</code> in <a href=""https://download.libsodium.org/doc/password_hashing/"">Password hashing</a> libsodium page. <a href=""https://github.com/P-H-C/phc-winner-argon2/raw/master/argon2-specs.pdf"">Argon2i v1.3 Algorithm</a>.  <h3>Example</h3> <pre> <code> String password = ""This is a Secret""; salt = SodiumLibary.randomBytes(sodium().crypto_pwhash_saltbytes()); byte[] key = SodiumLibary.cryptoPwhashArgon2i(password.getBytes(),salt); String keyHex = SodiumUtils.bin2hex(key); </code> </pre>
 */
public static byte[] cryptoPwhashArgon2i(byte[] passwd,byte[] salt) throws SodiumLibraryException {
  int saltLength=cryptoPwhashSaltBytes();
  if (salt.length != saltLength) {
    throw new SodiumLibraryException(""String_Node_Str"" + salt.length + ""String_Node_Str""+ saltLength+ ""String_Node_Str"");
  }
  byte[] key=new byte[(int)sodium().crypto_box_seedbytes()];
  logger.info(""String_Node_Str"" + NativeLong.SIZE * 8 + ""String_Node_Str"");
  logger.info(""String_Node_Str"" + sodium().crypto_pwhash_opslimit_interactive());
  logger.info(""String_Node_Str"" + sodium().crypto_pwhash_memlimit_interactive());
  logger.info(""String_Node_Str"" + sodium().crypto_pwhash_alg_argon2id13());
  int rc=sodium().crypto_pwhash(key,key.length,passwd,passwd.length,salt,sodium().crypto_pwhash_opslimit_interactive(),sodium().crypto_pwhash_memlimit_interactive(),sodium().crypto_pwhash_alg_argon2id13());
  logger.info(""String_Node_Str"" + rc);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return key;
}","/** 
 * Derive a key using Argon2id password hashing scheme <p> The following is taken from <a href=""https://download.libsodium.org/doc/password_hashing/"">libsodium documentation</a>: <blockquote> Argon2 is optimized for the x86 architecture and exploits the cache and memory organization of the recent Intel  and AMD processors. But its implementation remains portable and fast on other architectures. Argon2 has three  variants: Argon2d, Argon2i and Argon2id. Argon2i uses data-independent memory access, which is preferred for  password hashing and password-based key derivation. Argon2i also makes multiple passes over the memory to  protect from tradeoff attacks. Argon2id combines both. </blockquote>
 * @param passwd Array of bytes of password
 * @param salt Salt to use in key generation. The salt should be unpredictable and can be generated by calling SodiumLibary.randomBytes(int)The salt should be saved by the caller as it will be needed to derive the key again from the  password.
 * @return Generated key as an array of bytes
 * @throws SodiumLibraryException if libsodium's crypto_pwhash() does not return 0<code>crypto_pwhash()</code> in <a href=""https://download.libsodium.org/doc/password_hashing/"">Password hashing</a> libsodium page. <a href=""https://github.com/P-H-C/phc-winner-argon2/raw/master/argon2-specs.pdf"">Argon2i v1.3 Algorithm</a>.  <h3>Example</h3> <pre> <code> String password = ""This is a Secret""; salt = SodiumLibary.randomBytes(sodium().crypto_pwhash_saltbytes()); byte[] key = SodiumLibary.cryptoPwhashArgon2i(password.getBytes(),salt); String keyHex = SodiumUtils.bin2hex(key); </code> </pre>
 */
public static byte[] cryptoPwhashArgon2i(byte[] passwd,byte[] salt) throws SodiumLibraryException {
  int saltLength=cryptoPwhashSaltBytes();
  if (salt.length != saltLength) {
    throw new SodiumLibraryException(""String_Node_Str"" + salt.length + ""String_Node_Str""+ saltLength+ ""String_Node_Str"");
  }
  byte[] key=new byte[sodium().crypto_box_seedbytes().intValue()];
  logger.info(""String_Node_Str"" + NativeLong.SIZE * 8 + ""String_Node_Str"");
  logger.info(""String_Node_Str"" + sodium().crypto_pwhash_opslimit_interactive());
  logger.info(""String_Node_Str"" + sodium().crypto_pwhash_memlimit_interactive());
  logger.info(""String_Node_Str"" + sodium().crypto_pwhash_alg_argon2id13());
  int rc=sodium().crypto_pwhash(key,key.length,passwd,passwd.length,salt,sodium().crypto_pwhash_opslimit_interactive(),sodium().crypto_pwhash_memlimit_interactive(),sodium().crypto_pwhash_alg_argon2id13());
  logger.info(""String_Node_Str"" + rc);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return key;
}",0.997018263138278
175645,long crypto_box_seedbytes();,NativeLong crypto_box_seedbytes();,0.8709677419354839
175646,"/** 
 * Recipient decrypts a message with his private key. Usage: Bob (recipient) verifies the message with Alice's (sender) public key and  decrypts the message with his private key.
 * @param cipherText Message to decrypt
 * @param nonce Nonce used during encryption 
 * @param publicKey Sender's (Alice) public key for verifying the message
 * @param privateKey Recipient's (Bob)  Private key to decrypt the message
 * @throws SodiumLibraryException on error
 * @return Decrypted message as an array of bytes.
 */
public static byte[] cryptoBoxOpenEasy(byte[] cipherText,byte[] nonce,byte[] publicKey,byte[] privateKey) throws SodiumLibraryException {
  long nonce_len=sodium().crypto_box_noncebytes();
  if (nonce.length != nonce_len) {
    throw new SodiumLibraryException(""String_Node_Str"" + nonce.length + ""String_Node_Str""+ nonce_len+ ""String_Node_Str"");
  }
  byte[] decrypted=new byte[(int)(cipherText.length - sodium().crypto_box_macbytes())];
  int rc=sodium().crypto_box_open_easy(decrypted,cipherText,cipherText.length,nonce,publicKey,privateKey);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return decrypted;
}","/** 
 * Recipient decrypts a message with his private key. Usage: Bob (recipient) verifies the message with Alice's (sender) public key and  decrypts the message with his private key.
 * @param cipherText Message to decrypt
 * @param nonce Nonce used during encryption 
 * @param publicKey Sender's (Alice) public key for verifying the message
 * @param privateKey Recipient's (Bob)  Private key to decrypt the message
 * @throws SodiumLibraryException on error
 * @return Decrypted message as an array of bytes.
 */
public static byte[] cryptoBoxOpenEasy(byte[] cipherText,byte[] nonce,byte[] publicKey,byte[] privateKey) throws SodiumLibraryException {
  NativeLong nonce_len=sodium().crypto_box_noncebytes();
  if (nonce.length != nonce_len.intValue()) {
    throw new SodiumLibraryException(""String_Node_Str"" + nonce.length + ""String_Node_Str""+ nonce_len+ ""String_Node_Str"");
  }
  byte[] decrypted=new byte[(int)(cipherText.length - sodium().crypto_box_macbytes().intValue())];
  int rc=sodium().crypto_box_open_easy(decrypted,cipherText,cipherText.length,nonce,publicKey,privateKey);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return decrypted;
}",0.9875
175647,long crypto_box_sealbytes();,NativeLong crypto_box_sealbytes();,0.8709677419354839
175648,"public static byte[] cryptoPwhashScryptSalsa208Sha256(byte[] passwd,byte[] salt,Long opsLimit,NativeLong memLimit) throws SodiumLibraryException {
  long salt_length=sodium().crypto_pwhash_scryptsalsa208sha256_saltbytes();
  if (salt.length != salt_length) {
    throw new SodiumLibraryException(""String_Node_Str"" + salt.length + ""String_Node_Str""+ salt_length+ ""String_Node_Str"");
  }
  byte[] key=new byte[(int)sodium().crypto_box_seedbytes()];
  int rc=sodium().crypto_pwhash_scryptsalsa208sha256(key,key.length,passwd,passwd.length,salt,opsLimit,memLimit);
  logger.info(""String_Node_Str"" + rc);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return key;
}","public static byte[] cryptoPwhashScryptSalsa208Sha256(byte[] passwd,byte[] salt,Long opsLimit,NativeLong memLimit) throws SodiumLibraryException {
  NativeLong salt_length=sodium().crypto_pwhash_scryptsalsa208sha256_saltbytes();
  if (salt.length != salt_length.intValue()) {
    throw new SodiumLibraryException(""String_Node_Str"" + salt.length + ""String_Node_Str""+ salt_length+ ""String_Node_Str"");
  }
  byte[] key=new byte[sodium().crypto_box_seedbytes().intValue()];
  int rc=sodium().crypto_pwhash_scryptsalsa208sha256(key,key.length,passwd,passwd.length,salt,opsLimit,memLimit);
  logger.info(""String_Node_Str"" + rc);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return key;
}",0.976010966415353
175649,"public static long cryptoPwHashScryptSalsa208Sha256SaltBytes(){
  return sodium().crypto_pwhash_scryptsalsa208sha256_saltbytes();
}","public static NativeLong cryptoPwHashScryptSalsa208Sha256SaltBytes(){
  return sodium().crypto_pwhash_scryptsalsa208sha256_saltbytes();
}",0.9701492537313432
175650,"public static long cryptoSecretBoxNonceBytes(){
  return sodium().crypto_secretbox_noncebytes();
}","public static NativeLong cryptoSecretBoxNonceBytes(){
  return sodium().crypto_secretbox_noncebytes();
}",0.9603960396039604
175651,long crypto_secretbox_keybytes();,NativeLong crypto_secretbox_keybytes();,0.8888888888888888
175652,long crypto_pwhash_scryptsalsa208sha256_saltbytes();,NativeLong crypto_pwhash_scryptsalsa208sha256_saltbytes();,0.9272727272727272
175653,"public static long cryptoSecretBoxMacBytes(){
  return sodium().crypto_secretbox_macbytes();
}","public static NativeLong cryptoSecretBoxMacBytes(){
  return sodium().crypto_secretbox_macbytes();
}",0.9587628865979382
175654,"/** 
 * Derive key from a password using scrypt. <p> Excerpt from libsodium documentation: <blockquote> Scrypt was also designed to make it costly to perform large-scale custom hardware attacks by requiring large  amounts of memory. <p> Even though its memory hardness can be significantly reduced at the cost of extra computations, this function  remains an excellent choice today, provided that its parameters are properly chosen. </p> Scrypt is available in libsodium since version 0.5.0, which makes it a better choice than Argon2 if compatibility with older libsodium versions is a concern. </blockquote>
 * @param passwd Array of bytes of password
 * @param salt Salt to use in key generation. The salt should be unpredictable and can be generated by calling  {@link SodiumLibrary#randomBytes(int)}The salt should be saved by the caller as it will be needed to derive the key again from the  password.
 * @return key as an array of bytes
 * @throws SodiumLibraryException on error
 * @see <a href=""https://download.libsodium.org/doc/password_hashing/"" target=""_blank"">Password hashing</a>
 */
public static byte[] cryptoPwhashScrypt(byte[] passwd,byte[] salt) throws SodiumLibraryException {
  long salt_length=sodium().crypto_pwhash_scryptsalsa208sha256_saltbytes();
  if (salt.length != salt_length) {
    throw new SodiumLibraryException(""String_Node_Str"" + salt.length + ""String_Node_Str""+ salt_length+ ""String_Node_Str"");
  }
  byte[] key=new byte[(int)sodium().crypto_box_seedbytes()];
  int rc=sodium().crypto_pwhash_scryptsalsa208sha256(key,key.length,passwd,passwd.length,salt,sodium().crypto_pwhash_opslimit_interactive(),sodium().crypto_pwhash_memlimit_interactive());
  logger.info(""String_Node_Str"" + rc);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return key;
}","/** 
 * Derive key from a password using scrypt. <p> Excerpt from libsodium documentation: <blockquote> Scrypt was also designed to make it costly to perform large-scale custom hardware attacks by requiring large  amounts of memory. <p> Even though its memory hardness can be significantly reduced at the cost of extra computations, this function  remains an excellent choice today, provided that its parameters are properly chosen. </p> Scrypt is available in libsodium since version 0.5.0, which makes it a better choice than Argon2 if compatibility with older libsodium versions is a concern. </blockquote>
 * @param passwd Array of bytes of password
 * @param salt Salt to use in key generation. The salt should be unpredictable and can be generated by calling  {@link SodiumLibrary#randomBytes(int)}The salt should be saved by the caller as it will be needed to derive the key again from the  password.
 * @return key as an array of bytes
 * @throws SodiumLibraryException on error
 * @see <a href=""https://download.libsodium.org/doc/password_hashing/"" target=""_blank"">Password hashing</a>
 */
public static byte[] cryptoPwhashScrypt(byte[] passwd,byte[] salt) throws SodiumLibraryException {
  NativeLong salt_length=sodium().crypto_pwhash_scryptsalsa208sha256_saltbytes();
  if (salt.length != salt_length.intValue()) {
    throw new SodiumLibraryException(""String_Node_Str"" + salt.length + ""String_Node_Str""+ salt_length+ ""String_Node_Str"");
  }
  byte[] key=new byte[sodium().crypto_box_seedbytes().intValue()];
  int rc=sodium().crypto_pwhash_scryptsalsa208sha256(key,key.length,passwd,passwd.length,salt,sodium().crypto_pwhash_opslimit_interactive(),sodium().crypto_pwhash_memlimit_interactive());
  logger.info(""String_Node_Str"" + rc);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return key;
}",0.9905634942032892
175655,"public static byte[] cryptoSignEdPkTOcurvePk(byte[] edPK) throws SodiumLibraryException {
  byte[] curvePK=new byte[(int)sodium().crypto_box_publickeybytes()];
  int rc=sodium().crypto_sign_ed25519_pk_to_curve25519(curvePK,edPK);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return curvePK;
}","public static byte[] cryptoSignEdPkTOcurvePk(byte[] edPK) throws SodiumLibraryException {
  byte[] curvePK=new byte[sodium().crypto_box_publickeybytes().intValue()];
  int rc=sodium().crypto_sign_ed25519_pk_to_curve25519(curvePK,edPK);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return curvePK;
}",0.9774647887323944
175656,"public static byte[] cryptoPwhash(byte[] passwd,byte[] salt,long opsLimit,NativeLong memLimit,int algorithm) throws SodiumLibraryException {
  byte[] key=new byte[(int)sodium().crypto_box_seedbytes()];
  logger.info(""String_Node_Str"" + NativeLong.SIZE * 8 + ""String_Node_Str"");
  int rc=sodium().crypto_pwhash(key,key.length,passwd,passwd.length,salt,opsLimit,memLimit,algorithm);
  logger.info(""String_Node_Str"" + rc);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return key;
}","public static byte[] cryptoPwhash(byte[] passwd,byte[] salt,long opsLimit,NativeLong memLimit,int algorithm) throws SodiumLibraryException {
  byte[] key=new byte[sodium().crypto_box_seedbytes().intValue()];
  logger.info(""String_Node_Str"" + NativeLong.SIZE * 8 + ""String_Node_Str"");
  int rc=sodium().crypto_pwhash(key,key.length,passwd,passwd.length,salt,opsLimit,memLimit,algorithm);
  logger.info(""String_Node_Str"" + rc);
  if (rc != 0) {
    throw new SodiumLibraryException(""String_Node_Str"" + rc + ""String_Node_Str"");
  }
  return key;
}",0.9852125693160814
175657,long crypto_box_macbytes();,NativeLong crypto_box_macbytes();,0.8666666666666667
175658,"protected boolean isAccountLocked(String userid){
  if (userid == null) {
    return false;
  }
  User admin=userLoginHistory.get(userid);
  return admin != null && admin.getLoginFailedCount() == accountLockCount && (new Date().getTime() - admin.getLastLoginFailedTime().getTime() < accountLockTime);
}","protected boolean isAccountLocked(String userid){
  if (userid == null) {
    return false;
  }
  User admin=userLoginHistory.get(userid);
  return admin != null && admin.getLoginFailedCount() >= accountLockCount && (new Date().getTime() - admin.getLastLoginFailedTime().getTime() < accountLockTime);
}",0.9966887417218544
175659,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public ModelAndView doPost(ModelAndView mav,HttpServletRequest req,HttpServletResponse res,Locale locale) throws IOException {
  String userid=StringUtils.trim(req.getParameter(""String_Node_Str""));
  String password=StringUtils.trim(req.getParameter(""String_Node_Str""));
  HttpSession session=req.getSession(true);
  if (isAccountLocked(userid)) {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    res.sendRedirect(""String_Node_Str"");
  }
 else   if (authUser(userid,password)) {
    resetAccountLock(userid);
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    session.setAttribute(""String_Node_Str"",userid);
    String target=(String)session.getAttribute(""String_Node_Str"");
    if (target == null) {
      res.sendRedirect(""String_Node_Str"");
    }
 else {
      session.removeAttribute(""String_Node_Str"");
      res.sendRedirect(target);
    }
  }
 else {
    incrementAccountLockNum(userid);
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    return doGet(mav,req,res,locale);
  }
  return null;
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public ModelAndView doPost(ModelAndView mav,HttpServletRequest req,HttpServletResponse res,Locale locale) throws IOException {
  String userid=StringUtils.trim(req.getParameter(""String_Node_Str""));
  String password=StringUtils.trim(req.getParameter(""String_Node_Str""));
  HttpSession session=req.getSession(true);
  if (isAccountLocked(userid)) {
    session.setAttribute(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  }
 else   if (authUser(userid,password)) {
    resetAccountLock(userid);
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    session.setAttribute(""String_Node_Str"",userid);
    String target=(String)session.getAttribute(""String_Node_Str"");
    if (target == null) {
      res.sendRedirect(""String_Node_Str"");
      return null;
    }
 else {
      session.removeAttribute(""String_Node_Str"");
      res.sendRedirect(target);
      return null;
    }
  }
 else {
    session.setAttribute(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  }
  incrementLoginFailedCount(userid);
  return doGet(mav,req,res,locale);
}",0.8211453744493392
175660,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView doGet(ModelAndView mav,HttpServletRequest req,HttpServletResponse res,Locale locale){
  setViewAndCommonObjects(mav,locale,""String_Node_Str"");
  HashMap<String,String[]> hiddenMap=new HashMap<>();
  Enumeration<?> paramNames=req.getParameterNames();
  while (paramNames.hasMoreElements()) {
    String paramName=(String)paramNames.nextElement();
    hiddenMap.put(paramName,req.getParameterValues(paramName));
    mav.addObject(""String_Node_Str"",hiddenMap);
  }
  HttpSession session=req.getSession(true);
  if (session.getAttribute(""String_Node_Str"") != null && !""String_Node_Str"".equals(session.getAttribute(""String_Node_Str""))) {
    mav.addObject(""String_Node_Str"",msg.getMessage((String)session.getAttribute(""String_Node_Str""),null,locale));
    session.setAttribute(""String_Node_Str"",null);
  }
  return mav;
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView doGet(ModelAndView mav,HttpServletRequest req,HttpServletResponse res,Locale locale){
  setViewAndCommonObjects(mav,locale,""String_Node_Str"");
  HashMap<String,String[]> hiddenMap=new HashMap<>();
  Enumeration<?> paramNames=req.getParameterNames();
  while (paramNames.hasMoreElements()) {
    String paramName=(String)paramNames.nextElement();
    hiddenMap.put(paramName,req.getParameterValues(paramName));
    mav.addObject(""String_Node_Str"",hiddenMap);
  }
  HttpSession session=req.getSession(true);
  String authNMsg=(String)session.getAttribute(""String_Node_Str"");
  if (authNMsg != null && !""String_Node_Str"".equals(authNMsg)) {
    mav.addObject(""String_Node_Str"",authNMsg);
    session.setAttribute(""String_Node_Str"",null);
  }
  return mav;
}",0.8415614236509759
175661,"/** 
 * Intercept unauthenticated requests for specific URLs and redirect to login page.
 * @see Filter#doFilter(ServletRequest,ServletResponse,FilterChain)
 */
@Override public void doFilter(ServletRequest req,ServletResponse res,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)req;
  HttpServletResponse response=(HttpServletResponse)res;
  String target=request.getRequestURI();
  if (target.startsWith(""String_Node_Str"") || ""String_Node_Str"".equals(target) || ""String_Node_Str"".equals(target)) {
    String loginType=request.getParameter(""String_Node_Str"");
    String queryString=request.getQueryString();
    if (queryString == null) {
      queryString=""String_Node_Str"";
    }
 else {
      queryString=queryString.replace(""String_Node_Str"" + loginType + ""String_Node_Str"",""String_Node_Str"");
      queryString=queryString.replace(""String_Node_Str"" + loginType,""String_Node_Str"");
      queryString=queryString.replace(""String_Node_Str"" + loginType,""String_Node_Str"");
      if (queryString.length() > 0) {
        queryString=""String_Node_Str"" + queryString;
      }
    }
    HttpSession session=request.getSession(false);
    if (session == null || session.getAttribute(""String_Node_Str"") == null || !""String_Node_Str"".equals(session.getAttribute(""String_Node_Str""))) {
      session=request.getSession(true);
      session.setAttribute(""String_Node_Str"",target);
      if (loginType == null) {
        response.sendRedirect(response.encodeRedirectURL(""String_Node_Str"" + queryString));
      }
 else       if (""String_Node_Str"".equals(loginType)) {
        response.sendRedirect(response.encodeRedirectURL(""String_Node_Str"" + loginType + ""String_Node_Str""+ queryString));
      }
 else {
        response.sendRedirect(""String_Node_Str"" + loginType + ""String_Node_Str""+ queryString);
      }
      return;
    }
  }
  chain.doFilter(req,res);
}","/** 
 * Intercept unauthenticated requests for specific URLs and redirect to login page.
 * @see Filter#doFilter(ServletRequest,ServletResponse,FilterChain)
 */
@Override public void doFilter(ServletRequest req,ServletResponse res,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)req;
  HttpServletResponse response=(HttpServletResponse)res;
  String target=request.getRequestURI();
  if (target.startsWith(""String_Node_Str"") || ""String_Node_Str"".equals(target) || ""String_Node_Str"".equals(target)) {
    String loginType=request.getParameter(""String_Node_Str"");
    String queryString=request.getQueryString();
    if (queryString == null) {
      queryString=""String_Node_Str"";
    }
 else {
      queryString=queryString.replace(""String_Node_Str"" + loginType + ""String_Node_Str"",""String_Node_Str"");
      queryString=queryString.replace(""String_Node_Str"" + loginType,""String_Node_Str"");
      queryString=queryString.replace(""String_Node_Str"" + loginType,""String_Node_Str"");
      if (queryString.length() > 0) {
        queryString=""String_Node_Str"" + queryString;
      }
    }
    HttpSession session=request.getSession(false);
    String authNMsg=(String)session.getAttribute(""String_Node_Str"");
    if (session == null || authNMsg == null || !""String_Node_Str"".equals(authNMsg)) {
      session=request.getSession(true);
      session.setAttribute(""String_Node_Str"",target);
      if (loginType == null) {
        response.sendRedirect(response.encodeRedirectURL(""String_Node_Str"" + queryString));
      }
 else       if (""String_Node_Str"".equals(loginType)) {
        response.sendRedirect(response.encodeRedirectURL(""String_Node_Str"" + loginType + ""String_Node_Str""+ queryString));
      }
 else {
        response.sendRedirect(""String_Node_Str"" + loginType + ""String_Node_Str""+ queryString);
      }
      return;
    }
  }
  chain.doFilter(req,res);
}",0.957496740547588
175662,"@Override @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public ModelAndView doPost(ModelAndView mav,HttpServletRequest req,HttpServletResponse res,Locale locale) throws IOException {
  String userid=req.getParameter(""String_Node_Str"");
  String password=req.getParameter(""String_Node_Str"");
  HttpSession session=req.getSession(true);
  if (authUser(userid,password)) {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    session.setAttribute(""String_Node_Str"",userid);
    String target=(String)session.getAttribute(""String_Node_Str"");
    if (target == null) {
      res.sendRedirect(""String_Node_Str"");
    }
 else {
      session.removeAttribute(""String_Node_Str"");
      res.sendRedirect(target);
    }
  }
 else {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    return doGet(mav,req,res,locale);
  }
  return null;
}","@Override @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public ModelAndView doPost(ModelAndView mav,HttpServletRequest req,HttpServletResponse res,Locale locale) throws IOException {
  String userid=req.getParameter(""String_Node_Str"");
  String password=req.getParameter(""String_Node_Str"");
  HttpSession session=req.getSession(true);
  if (authUser(userid,password)) {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    session.setAttribute(""String_Node_Str"",userid);
    String target=(String)session.getAttribute(""String_Node_Str"");
    if (target == null) {
      res.sendRedirect(""String_Node_Str"");
    }
 else {
      session.removeAttribute(""String_Node_Str"");
      res.sendRedirect(target);
    }
  }
 else {
    session.setAttribute(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    return doGet(mav,req,res,locale);
  }
  return null;
}",0.9652076318742986
175663,"@Override @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public ModelAndView doPost(ModelAndView mav,HttpServletRequest req,HttpServletResponse res,Locale locale) throws IOException {
  String userid=req.getParameter(""String_Node_Str"");
  String password=req.getParameter(""String_Node_Str"");
  String loginQueryString=req.getParameter(""String_Node_Str"");
  if (loginQueryString == null) {
    loginQueryString=""String_Node_Str"";
  }
 else {
    loginQueryString=""String_Node_Str"" + loginQueryString;
  }
  HttpSession session=req.getSession(true);
  if (isAccountLocked(userid)) {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    res.sendRedirect(""String_Node_Str"" + loginQueryString);
  }
 else   if (authUser(userid,password)) {
    resetAccountLock(userid);
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    session.setAttribute(""String_Node_Str"",userid);
    String gotoUrl=req.getParameter(""String_Node_Str"");
    if (gotoUrl != null) {
      res.sendRedirect(gotoUrl);
    }
 else {
      String target=(String)session.getAttribute(""String_Node_Str"");
      if (target == null) {
        res.sendRedirect(""String_Node_Str"");
      }
 else {
        session.removeAttribute(""String_Node_Str"");
        res.sendRedirect(target);
      }
    }
  }
 else {
    incrementAccountLockNum(userid);
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    res.sendRedirect(""String_Node_Str"" + loginQueryString);
  }
  return null;
}","@Override @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public ModelAndView doPost(ModelAndView mav,HttpServletRequest req,HttpServletResponse res,Locale locale) throws IOException {
  String userid=req.getParameter(""String_Node_Str"");
  String password=req.getParameter(""String_Node_Str"");
  String loginQueryString=req.getParameter(""String_Node_Str"");
  if (loginQueryString == null) {
    loginQueryString=""String_Node_Str"";
  }
 else {
    loginQueryString=""String_Node_Str"" + loginQueryString;
  }
  HttpSession session=req.getSession(true);
  if (isAccountLocked(userid)) {
    incrementLoginFailedCount(userid);
    session.setAttribute(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    res.sendRedirect(""String_Node_Str"" + loginQueryString);
  }
 else   if (authUser(userid,password)) {
    resetAccountLock(userid);
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    session.setAttribute(""String_Node_Str"",userid);
    String gotoUrl=req.getParameter(""String_Node_Str"");
    if (gotoUrl != null) {
      res.sendRedirect(gotoUrl);
    }
 else {
      String target=(String)session.getAttribute(""String_Node_Str"");
      if (target == null) {
        res.sendRedirect(""String_Node_Str"");
      }
 else {
        session.removeAttribute(""String_Node_Str"");
        res.sendRedirect(target);
      }
    }
  }
 else {
    incrementLoginFailedCount(userid);
    session.setAttribute(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    res.sendRedirect(""String_Node_Str"" + loginQueryString);
  }
  return null;
}",0.9173419773095624
175664,"@Override @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public ModelAndView doPost(ModelAndView mav,HttpServletRequest req,HttpServletResponse res,Locale locale) throws IOException {
  String userid=req.getParameter(""String_Node_Str"");
  String password=req.getParameter(""String_Node_Str"");
  HttpSession session=req.getSession(true);
  if (isAccountLocked(userid)) {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    return doGet(mav,req,res,locale);
  }
 else   if (!isExistUser(userid)) {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    return doGet(mav,req,res,locale);
  }
 else   if (!password.matches(""String_Node_Str"")) {
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    return doGet(mav,req,res,locale);
  }
 else   if (authUser(userid,password)) {
    resetAccountLock(userid);
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    session.setAttribute(""String_Node_Str"",userid);
    String target=(String)session.getAttribute(""String_Node_Str"");
    if (target == null) {
      res.sendRedirect(""String_Node_Str"");
    }
 else {
      session.removeAttribute(""String_Node_Str"");
      res.sendRedirect(target);
    }
  }
 else {
    incrementAccountLockNum(userid);
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    return doGet(mav,req,res,locale);
  }
  return null;
}","@Override @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public ModelAndView doPost(ModelAndView mav,HttpServletRequest req,HttpServletResponse res,Locale locale) throws IOException {
  String userid=req.getParameter(""String_Node_Str"");
  String password=req.getParameter(""String_Node_Str"");
  HttpSession session=req.getSession(true);
  if (isAccountLocked(userid)) {
    session.setAttribute(""String_Node_Str"",msg.getMessage(""String_Node_Str"",new String[]{String.valueOf(accountLockCount)},locale));
  }
 else   if (!isExistUser(userid)) {
    session.setAttribute(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  }
 else   if (!password.matches(""String_Node_Str"")) {
    session.setAttribute(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  }
 else   if (authUser(userid,password)) {
    resetAccountLock(userid);
    session.setAttribute(""String_Node_Str"",""String_Node_Str"");
    session.setAttribute(""String_Node_Str"",userid);
    String target=(String)session.getAttribute(""String_Node_Str"");
    if (target == null) {
      res.sendRedirect(""String_Node_Str"");
      return null;
    }
 else {
      session.removeAttribute(""String_Node_Str"");
      res.sendRedirect(target);
      return null;
    }
  }
 else {
    session.setAttribute(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  }
  incrementLoginFailedCount(userid);
  return doGet(mav,req,res,locale);
}",0.7751500176491352
175665,"private boolean isExistUser(String username){
  try {
    LdapQuery query=LdapQueryBuilder.query().where(""String_Node_Str"").is(username);
    User user=ldapTemplate.findOne(query,User.class);
    if (user != null) {
      return true;
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
  }
  return false;
}","private boolean isExistUser(String username){
  try {
    LdapQuery query=LdapQueryBuilder.query().where(""String_Node_Str"").is(username);
    User user=ldapTemplate.findOne(query,User.class);
    if (user != null) {
      return true;
    }
  }
 catch (  EmptyResultDataAccessException e) {
  }
catch (  Exception e) {
    log.error(""String_Node_Str"",e);
  }
  return false;
}",0.930298719772404
175666,"/** 
 * Intercept unauthenticated requests for specific URLs and redirect to login page.
 * @see Filter#doFilter(ServletRequest,ServletResponse,FilterChain)
 */
@Override public void doFilter(ServletRequest req,ServletResponse res,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)req;
  HttpServletResponse response=(HttpServletResponse)res;
  String target=request.getRequestURI();
  if (target.startsWith(""String_Node_Str"") || ""String_Node_Str"".equals(target)) {
    String loginType=request.getParameter(""String_Node_Str"");
    String queryString=request.getQueryString();
    if (queryString == null) {
      queryString=""String_Node_Str"";
    }
 else {
      queryString=queryString.replace(""String_Node_Str"" + loginType + ""String_Node_Str"",""String_Node_Str"");
      queryString=queryString.replace(""String_Node_Str"" + loginType,""String_Node_Str"");
      queryString=queryString.replace(""String_Node_Str"" + loginType,""String_Node_Str"");
      if (queryString.length() > 0) {
        queryString=""String_Node_Str"" + queryString;
      }
    }
    HttpSession session=request.getSession(false);
    if (session == null || session.getAttribute(""String_Node_Str"") == null || !""String_Node_Str"".equals(session.getAttribute(""String_Node_Str""))) {
      session=request.getSession(true);
      session.setAttribute(""String_Node_Str"",target);
      if (loginType == null) {
        response.sendRedirect(response.encodeRedirectURL(""String_Node_Str"" + queryString));
      }
 else       if (""String_Node_Str"".equals(loginType)) {
        response.sendRedirect(response.encodeRedirectURL(""String_Node_Str"" + loginType + ""String_Node_Str""+ queryString));
      }
 else {
        response.sendRedirect(""String_Node_Str"" + loginType + ""String_Node_Str""+ queryString);
      }
    }
  }
  chain.doFilter(req,res);
}","/** 
 * Intercept unauthenticated requests for specific URLs and redirect to login page.
 * @see Filter#doFilter(ServletRequest,ServletResponse,FilterChain)
 */
@Override public void doFilter(ServletRequest req,ServletResponse res,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)req;
  HttpServletResponse response=(HttpServletResponse)res;
  String target=request.getRequestURI();
  if (target.startsWith(""String_Node_Str"") || ""String_Node_Str"".equals(target) || ""String_Node_Str"".equals(target)) {
    String loginType=request.getParameter(""String_Node_Str"");
    String queryString=request.getQueryString();
    if (queryString == null) {
      queryString=""String_Node_Str"";
    }
 else {
      queryString=queryString.replace(""String_Node_Str"" + loginType + ""String_Node_Str"",""String_Node_Str"");
      queryString=queryString.replace(""String_Node_Str"" + loginType,""String_Node_Str"");
      queryString=queryString.replace(""String_Node_Str"" + loginType,""String_Node_Str"");
      if (queryString.length() > 0) {
        queryString=""String_Node_Str"" + queryString;
      }
    }
    HttpSession session=request.getSession(false);
    if (session == null || session.getAttribute(""String_Node_Str"") == null || !""String_Node_Str"".equals(session.getAttribute(""String_Node_Str""))) {
      session=request.getSession(true);
      session.setAttribute(""String_Node_Str"",target);
      if (loginType == null) {
        response.sendRedirect(response.encodeRedirectURL(""String_Node_Str"" + queryString));
      }
 else       if (""String_Node_Str"".equals(loginType)) {
        response.sendRedirect(response.encodeRedirectURL(""String_Node_Str"" + loginType + ""String_Node_Str""+ queryString));
      }
 else {
        response.sendRedirect(""String_Node_Str"" + loginType + ""String_Node_Str""+ queryString);
      }
      return;
    }
  }
  chain.doFilter(req,res);
}",0.9867654843832716
175667,"@RequestMapping(value=""String_Node_Str"") public void serverinfo(HttpSession ses,HttpServletResponse res,Locale locale) throws IOException {
  StringBuilder sb=new StringBuilder();
  Properties properties=System.getProperties();
  for (  Object key : properties.keySet()) {
    Object value=properties.get(key);
    sb.append(""String_Node_Str"" + key + ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
  Resource resource=new ClassPathResource(""String_Node_Str"");
  String htmlString=IOUtils.toString(resource.getInputStream());
  htmlString=htmlString.replace(""String_Node_Str"",(String)ses.getAttribute(""String_Node_Str""));
  htmlString=htmlString.replace(""String_Node_Str"",sb.toString());
  htmlString=repacLocalizedString(htmlString,locale);
  res.getWriter().write(htmlString);
}","@RequestMapping(value=""String_Node_Str"") public void serverinfo(HttpSession ses,HttpServletResponse res,Locale locale) throws IOException {
  StringBuilder sb=new StringBuilder();
  Properties properties=System.getProperties();
  for (  Object key : properties.keySet()) {
    Object value=properties.get(key);
    sb.append(""String_Node_Str"" + key + ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
  Resource resource=new ClassPathResource(""String_Node_Str"");
  String htmlString=IOUtils.toString(resource.getInputStream());
  String userid=(String)ses.getAttribute(""String_Node_Str"");
  if (userid == null) {
    res.sendRedirect(""String_Node_Str"");
    return;
  }
  htmlString=htmlString.replace(""String_Node_Str"",userid);
  htmlString=htmlString.replace(""String_Node_Str"",sb.toString());
  htmlString=repacLocalizedString(htmlString,locale);
  res.getWriter().write(htmlString);
}",0.7177950868783702
175668,"@Transactional public void updateUsers(List<User> users,Locale locale,ModelAndView mav){
  DefaultTransactionDefinition dtDef=new DefaultTransactionDefinition();
  TransactionStatus trnStatus=txMgr.getTransaction(dtDef);
  int executeUpdate=0;
  try {
    for (    User user : users) {
      executeUpdate=executeUpdate + jdbcTemplate.update(""String_Node_Str"",user.getName(),user.getPhone(),user.getMail(),user.getUserId());
      log.info(user.getUserId() + ""String_Node_Str"");
      Thread.sleep(500);
    }
    txMgr.commit(trnStatus);
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",new Object[]{executeUpdate},null,locale));
  }
 catch (  DeadlockLoserDataAccessException e) {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    log.error(""String_Node_Str"",e);
  }
catch (  DataAccessException e) {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",new String[]{e.getMessage()},null,locale));
    log.error(""String_Node_Str"",e);
  }
catch (  Exception e) {
    txMgr.rollback(trnStatus);
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",new String[]{e.getMessage()},null,locale));
    log.error(""String_Node_Str"",e);
  }
}","private void updateUsers(List<User> users,Locale locale,ModelAndView mav){
  DefaultTransactionDefinition dtDef=new DefaultTransactionDefinition();
  TransactionStatus trnStatus=txMgr.getTransaction(dtDef);
  int executeUpdate=0;
  try {
    for (    User user : users) {
      executeUpdate=executeUpdate + jdbcTemplate.update(""String_Node_Str"",user.getName(),user.getPhone(),user.getMail(),user.getUserId());
      log.info(user.getUserId() + ""String_Node_Str"");
      Thread.sleep(500);
    }
    txMgr.commit(trnStatus);
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",new Object[]{executeUpdate},null,locale));
  }
 catch (  DeadlockLoserDataAccessException e) {
    txMgr.rollback(trnStatus);
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    log.error(""String_Node_Str"",e);
  }
catch (  DataAccessException e) {
    txMgr.rollback(trnStatus);
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",new String[]{e.getMessage()},null,locale));
    log.error(""String_Node_Str"",e);
  }
catch (  Exception e) {
    txMgr.rollback(trnStatus);
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",new String[]{e.getMessage()},null,locale));
    log.error(""String_Node_Str"",e);
  }
}",0.9647153167602244
175669,"/** 
 * Call   {@link #doFilter(HttpServletRequest,HttpServletResponse,FilterChain)}.
 * @see Filter#doFilter(ServletRequest,ServletResponse,FilterChain)
 */
@Override public void doFilter(ServletRequest req,ServletResponse res,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)req;
  HttpServletResponse response=(HttpServletResponse)res;
  String target=request.getRequestURI();
  if (!target.startsWith(""String_Node_Str"")) {
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
  }
  response.addHeader(""String_Node_Str"",""String_Node_Str"");
  if (!target.startsWith(""String_Node_Str"")) {
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
  }
  chain.doFilter(req,res);
}","/** 
 * Call   {@link #doFilter(HttpServletRequest,HttpServletResponse,FilterChain)}.
 * @see Filter#doFilter(ServletRequest,ServletResponse,FilterChain)
 */
@Override public void doFilter(ServletRequest req,ServletResponse res,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)req;
  HttpServletResponse response=(HttpServletResponse)res;
  String target=request.getRequestURI();
  if (target.startsWith(""String_Node_Str"") && request.getMethod().equalsIgnoreCase(""String_Node_Str"")) {
    ServletFileUpload upload=new ServletFileUpload();
    upload.setFileItemFactory(new DiskFileItemFactory());
    upload.setFileSizeMax(1024 * 1024 * 10);
    upload.setSizeMax(1024 * 1024 * 50);
    try {
      upload.parseRequest(new ServletRequestContext(request));
    }
 catch (    FileUploadException e) {
      throw new ServletException(e);
    }
  }
  if (!target.startsWith(""String_Node_Str"")) {
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
  }
  response.addHeader(""String_Node_Str"",""String_Node_Str"");
  if (!target.startsWith(""String_Node_Str"")) {
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
  }
  chain.doFilter(req,res);
}",0.5122199592668024
175670,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public ModelAndView doPost(ModelAndView mav,HttpServletRequest req,HttpServletResponse res,Locale locale) throws IOException {
  mav.setViewName(""String_Node_Str"");
  mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  String appPath=req.getServletContext().getRealPath(""String_Node_Str"");
  String savePath=appPath + File.separator + SAVE_DIR;
  File fileSaveDir=new File(savePath);
  if (!fileSaveDir.exists()) {
    fileSaveDir.mkdir();
  }
  Part filePart=null;
  try {
    filePart=req.getPart(""String_Node_Str"");
  }
 catch (  Exception e) {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    return doGet(mav,req,res,locale);
  }
  String fileName=getFileName(filePart);
  if (StringUtils.isBlank(fileName)) {
    return doGet(mav,req,res,locale);
  }
  boolean isConverted=writeFile(savePath,filePart,fileName);
  if (!isConverted) {
    isConverted=convert2GrayScale(new File(savePath + File.separator + fileName).getAbsolutePath());
  }
  if (isConverted) {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    mav.addObject(""String_Node_Str"",SAVE_DIR + ""String_Node_Str"" + fileName);
  }
 else {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  }
  return mav;
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public ModelAndView doPost(@RequestParam(""String_Node_Str"") MultipartFile file,ModelAndView mav,HttpServletRequest req,HttpServletResponse res,Locale locale) throws IOException {
  mav.setViewName(""String_Node_Str"");
  mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  String appPath=req.getServletContext().getRealPath(""String_Node_Str"");
  String savePath=appPath + File.separator + SAVE_DIR;
  File fileSaveDir=new File(savePath);
  if (!fileSaveDir.exists()) {
    fileSaveDir.mkdir();
  }
  String fileName=file.getOriginalFilename();
  if (StringUtils.isBlank(fileName)) {
    return doGet(mav,req,res,locale);
  }
  boolean isConverted=writeFile(savePath,file,fileName);
  if (!isConverted) {
    isConverted=convert2GrayScale(new File(savePath + File.separator + fileName).getAbsolutePath());
  }
  if (isConverted) {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    mav.addObject(""String_Node_Str"",SAVE_DIR + ""String_Node_Str"" + fileName);
  }
 else {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  }
  return mav;
}",0.5664471135218907
175671,"private boolean writeFile(String savePath,Part filePart,String fileName) throws IOException {
  boolean isConverted=false;
  try (OutputStream out=new FileOutputStream(savePath + File.separator + fileName);InputStream in=filePart.getInputStream()){
    int read=0;
    final byte[] bytes=new byte[1024];
    while ((read=in.read(bytes)) != -1) {
      out.write(bytes,0,read);
    }
  }
 catch (  FileNotFoundException e) {
    isConverted=true;
  }
  return isConverted;
}","private boolean writeFile(String savePath,MultipartFile filePart,String fileName) throws IOException {
  boolean isConverted=false;
  try (OutputStream out=new FileOutputStream(savePath + File.separator + fileName);InputStream in=filePart.getInputStream()){
    int read=0;
    final byte[] bytes=new byte[1024];
    while ((read=in.read(bytes)) != -1) {
      out.write(bytes,0,read);
    }
  }
 catch (  FileNotFoundException e) {
    isConverted=true;
  }
  return isConverted;
}",0.9821989528795813
175672,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public ModelAndView doPost(ModelAndView mav,HttpServletRequest req,HttpServletResponse res,Locale locale) throws IOException {
  mav.setViewName(""String_Node_Str"");
  mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  String appPath=req.getServletContext().getRealPath(""String_Node_Str"");
  String savePath=appPath + File.separator + SAVE_DIR;
  File fileSaveDir=new File(savePath);
  if (!fileSaveDir.exists()) {
    fileSaveDir.mkdir();
  }
  Part filePart=null;
  try {
    filePart=req.getPart(""String_Node_Str"");
  }
 catch (  Exception e) {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    return doGet(mav,req,res,locale);
  }
  String fileName=getFileName(filePart);
  if (StringUtils.isBlank(fileName)) {
    return doGet(mav,req,res,locale);
  }
 else   if (!isImageFile(fileName)) {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    return doGet(mav,req,res,locale);
  }
  boolean isConverted=writeFile(savePath,filePart,fileName);
  if (!isConverted) {
    isConverted=reverseColor(new File(savePath + File.separator + fileName).getAbsolutePath());
  }
  if (isConverted) {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    mav.addObject(""String_Node_Str"",SAVE_DIR + ""String_Node_Str"" + fileName);
  }
 else {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  }
  return mav;
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public ModelAndView doPost(@RequestParam(""String_Node_Str"") MultipartFile file,ModelAndView mav,HttpServletRequest req,HttpServletResponse res,Locale locale) throws IOException {
  mav.setViewName(""String_Node_Str"");
  mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  String appPath=req.getServletContext().getRealPath(""String_Node_Str"");
  String savePath=appPath + File.separator + SAVE_DIR;
  File fileSaveDir=new File(savePath);
  if (!fileSaveDir.exists()) {
    fileSaveDir.mkdir();
  }
  String fileName=file.getOriginalFilename();
  if (StringUtils.isBlank(fileName)) {
    return doGet(mav,req,res,locale);
  }
 else   if (!isImageFile(fileName)) {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    return doGet(mav,req,res,locale);
  }
  boolean isConverted=writeFile(savePath,file,fileName);
  if (!isConverted) {
    isConverted=reverseColor(new File(savePath + File.separator + fileName).getAbsolutePath());
  }
  if (isConverted) {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    mav.addObject(""String_Node_Str"",SAVE_DIR + ""String_Node_Str"" + fileName);
  }
 else {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  }
  return mav;
}",0.6126250431183167
175673,"private boolean writeFile(String savePath,Part filePart,String fileName) throws IOException {
  boolean isConverted=false;
  try (OutputStream out=new FileOutputStream(savePath + File.separator + fileName);InputStream in=filePart.getInputStream()){
    int read=0;
    final byte[] bytes=new byte[1024];
    while ((read=in.read(bytes)) != -1) {
      out.write(bytes,0,read);
    }
  }
 catch (  FileNotFoundException e) {
    isConverted=true;
  }
  return isConverted;
}","private boolean writeFile(String savePath,MultipartFile filePart,String fileName) throws IOException {
  boolean isConverted=false;
  try (OutputStream out=new FileOutputStream(savePath + File.separator + fileName);InputStream in=filePart.getInputStream()){
    int read=0;
    final byte[] bytes=new byte[1024];
    while ((read=in.read(bytes)) != -1) {
      out.write(bytes,0,read);
    }
  }
 catch (  FileNotFoundException e) {
    isConverted=true;
  }
  return isConverted;
}",0.9821989528795813
175674,"@RequestMapping(value=""String_Node_Str"") public ModelAndView process(ModelAndView mav,Locale locale){
  mav.setViewName(""String_Node_Str"");
  mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  if (StringUtils.isBlank(datasourceUrl) || datasourceUrl.startsWith(""String_Node_Str"")) {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    return mav;
  }
 else {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  }
  List<User> users=selectUsers(mav,locale);
  if (users.isEmpty()) {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  }
 else {
    mav.addObject(""String_Node_Str"",users);
  }
  return mav;
}","@RequestMapping(value=""String_Node_Str"") public ModelAndView process(ModelAndView mav,Locale locale){
  mav.setViewName(""String_Node_Str"");
  mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  if (StringUtils.isBlank(datasourceUrl) || datasourceUrl.startsWith(""String_Node_Str"")) {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    return mav;
  }
 else {
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  }
  try {
    List<User> users=selectUsers(mav,locale);
    if (users.isEmpty()) {
      mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
    }
 else {
      mav.addObject(""String_Node_Str"",users);
    }
  }
 catch (  SQLException se) {
    log.error(""String_Node_Str"",se);
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  }
  return mav;
}",0.8783132530120482
175675,"private List<User> selectUsers(ModelAndView mav,Locale locale){
  List<User> users=new ArrayList<>();
  try {
    Connection conn=null;
    Statement stmt=null;
    ResultSet rs=null;
    conn=DriverManager.getConnection(datasourceUrl);
    stmt=conn.createStatement();
    rs=stmt.executeQuery(""String_Node_Str"");
    while (rs.next()) {
      User user=new User();
      user.setUserId(rs.getString(""String_Node_Str""));
      user.setName(rs.getString(""String_Node_Str""));
      user.setPhone(rs.getString(""String_Node_Str""));
      user.setMail(rs.getString(""String_Node_Str""));
      users.add(user);
    }
  }
 catch (  SQLException se) {
    log.error(""String_Node_Str"",se);
    mav.addObject(""String_Node_Str"",msg.getMessage(""String_Node_Str"",null,locale));
  }
  return users;
}","private List<User> selectUsers(ModelAndView mav,Locale locale) throws SQLException {
  List<User> users=new ArrayList<>();
  Connection conn=null;
  Statement stmt=null;
  ResultSet rs=null;
  conn=jdbcTemplate.getDataSource().getConnection();
  stmt=conn.createStatement();
  rs=stmt.executeQuery(""String_Node_Str"");
  while (rs.next()) {
    User user=new User();
    user.setUserId(rs.getString(""String_Node_Str""));
    user.setName(rs.getString(""String_Node_Str""));
    user.setPhone(rs.getString(""String_Node_Str""));
    user.setMail(rs.getString(""String_Node_Str""));
    users.add(user);
  }
  return users;
}",0.2312633832976445
175676,"/** 
 * Call   {@link #doFilter(HttpServletRequest,HttpServletResponse,FilterChain)}.
 * @see Filter#doFilter(ServletRequest,ServletResponse,FilterChain)
 */
@Override public void doFilter(ServletRequest req,ServletResponse res,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)req;
  HttpServletResponse response=(HttpServletResponse)res;
  String target=request.getRequestURI();
  if (!target.startsWith(""String_Node_Str"") && request.getMethod().equalsIgnoreCase(""String_Node_Str"")) {
    ServletFileUpload upload=new ServletFileUpload();
    upload.setFileItemFactory(new DiskFileItemFactory());
    upload.setFileSizeMax(1024 * 1024 * 10);
    upload.setSizeMax(1024 * 1024 * 50);
    try {
      upload.parseRequest(new ServletRequestContext(request));
    }
 catch (    FileUploadException e) {
      throw new ServletException(e);
    }
  }
  if (!target.startsWith(""String_Node_Str"")) {
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
  }
  response.addHeader(""String_Node_Str"",""String_Node_Str"");
  if (!target.startsWith(""String_Node_Str"")) {
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
  }
  chain.doFilter(req,res);
}","/** 
 * Call   {@link #doFilter(HttpServletRequest,HttpServletResponse,FilterChain)}.
 * @see Filter#doFilter(ServletRequest,ServletResponse,FilterChain)
 */
@Override public void doFilter(ServletRequest req,ServletResponse res,FilterChain chain) throws IOException, ServletException {
  HttpServletRequest request=(HttpServletRequest)req;
  HttpServletResponse response=(HttpServletResponse)res;
  String target=request.getRequestURI();
  if ((target.startsWith(""String_Node_Str"") || target.startsWith(""String_Node_Str"") || target.startsWith(""String_Node_Str"")) && request.getMethod().equalsIgnoreCase(""String_Node_Str"")) {
    ServletFileUpload upload=new ServletFileUpload();
    upload.setFileItemFactory(new DiskFileItemFactory());
    upload.setFileSizeMax(1024 * 1024 * 10);
    upload.setSizeMax(1024 * 1024 * 50);
    try {
      upload.parseRequest(new ServletRequestContext(request));
    }
 catch (    FileUploadException e) {
      throw new ServletException(e);
    }
  }
  if (!target.startsWith(""String_Node_Str"")) {
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
  }
  response.addHeader(""String_Node_Str"",""String_Node_Str"");
  if (!target.startsWith(""String_Node_Str"")) {
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
  }
  chain.doFilter(req,res);
}",0.9669717469160366
175677,"@Override public void onEnable(){
  MainThis=this;
  AzureAPI.setPrefix(ChatColor.translateAlternateColorCodes('&',ConfigMain.PluginPrefix) + ChatColor.RESET + ""String_Node_Str"");
  trySetupConfig();
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"" + getDescription().getVersion() + ""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"" + Bukkit.getServer().getVersion());
  AzureAPI.log(""String_Node_Str"" + Bukkit.getServer().getBukkitVersion());
  AzureAPI.log(""String_Node_Str"" + VersionLevel.get() + ""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  if (ConfigOptimize.AutoSetenable == true) {
    try {
      VLagger.AutoSetServer();
    }
 catch (    IOException|InterruptedException e) {
    }
  }
  Ticker.bind(MainThis);
  Perms.bind(""String_Node_Str"");
  AzurePlayerList.bind(new UpgradeNotifier());
  Bukkit.getPluginManager().registerEvents(new AntiInfItem(),this);
  Bukkit.getPluginManager().registerEvents(new AntiPortalInfItem(),this);
  Bukkit.getPluginManager().registerEvents(new AntiNetherHopperInfItem(),this);
  RPGItemPatch.init(this);
  Bukkit.getPluginManager().registerEvents(new ChunkKeeper(),this);
  Bukkit.getPluginManager().registerEvents(new NoCrowdEntity(),this);
  Bukkit.getPluginManager().registerEvents(new AntiCrashSign(),this);
  Bukkit.getPluginManager().registerEvents(new AntiSpam(),this);
  ExplosionController.init(this);
  Bukkit.getPluginManager().registerEvents(new AntiRedstone(),this);
  Bukkit.getPluginManager().registerEvents(new ItemClear(),this);
  Bukkit.getPluginManager().registerEvents(new NoSpawnChunks(),this);
  Bukkit.getPluginManager().registerEvents(new AntiInfRail(),this);
  Bukkit.getPluginManager().registerEvents(new AutoSave(),this);
  DupeLoginPatch.init(this);
  SpawnerController.init(this);
  Bukkit.getPluginManager().registerEvents(new AntiDupeDropItem(),this);
  Bukkit.getPluginManager().registerEvents(new AntiDoorInfItem(),this);
  TeleportPreloader.init(this);
  Bukkit.getPluginManager().registerEvents(new AntiBedExplode(),this);
  Bukkit.getPluginManager().registerEvents(new BlockCommander(),this);
  Bukkit.getPluginManager().registerEvents(new WaterFlowLimitor(),this);
  Bukkit.getPluginManager().registerEvents(new FireLimitor(),this);
  Bukkit.getPluginManager().registerEvents(new FarmProtecter(),this);
  Bukkit.getPluginManager().registerEvents(new AntiBoneBug(),this);
  Bukkit.getPluginManager().registerEvents(new AntiLongStringCrash(),this);
  RespawnAction.init(this);
  EmptyRestart.init(this);
  CheatBookBlocker.init(this);
  OverloadRestart.init(this);
  SkullCrashPatch.init(this);
  RecipeDupePatch.init(this);
  ChunkKeeper.ChunkKeeperofTask();
  getServer().getScheduler().runTaskTimer(this,new ChunkUnloader(),0,ConfigOptimize.ChunkUnloaderInterval * 20);
  TimerGarbageCollect.init(this);
  if (ConfigMain.AutoUpdate)   Bukkit.getScheduler().runTaskAsynchronously(this,new NetWorker());
  Bukkit.getScheduler().runTaskTimer(this,new AntiFakeDeath(),7 * 20,7 * 20);
  AzurePlayerList.bind(this);
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  List<String> devs=getDescription().getAuthors();
  AzureAPI.log(""String_Node_Str"" + devs.get(0) + ""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"" + AzureAPI.contactBetween(devs,1,""String_Node_Str"") + ""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
}","@Override public void onEnable(){
  MainThis=this;
  AzureAPI.bind(this);
  AzureAPI.setPrefix(ChatColor.translateAlternateColorCodes('&',ConfigMain.PluginPrefix) + ChatColor.RESET + ""String_Node_Str"");
  trySetupConfig();
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"" + getDescription().getVersion() + ""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"" + Bukkit.getServer().getVersion());
  AzureAPI.log(""String_Node_Str"" + Bukkit.getServer().getBukkitVersion());
  AzureAPI.log(""String_Node_Str"" + VersionLevel.get() + ""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  if (ConfigOptimize.AutoSetenable == true) {
    try {
      VLagger.AutoSetServer();
    }
 catch (    IOException|InterruptedException e) {
    }
  }
  AzurePlayerList.bind(this);
  AzurePlayerList.bind(new UpgradeNotifier());
  Ticker.bind(MainThis);
  Perms.bind(""String_Node_Str"");
  Bukkit.getPluginManager().registerEvents(new AntiInfItem(),this);
  Bukkit.getPluginManager().registerEvents(new AntiPortalInfItem(),this);
  Bukkit.getPluginManager().registerEvents(new AntiNetherHopperInfItem(),this);
  RPGItemPatch.init(this);
  Bukkit.getPluginManager().registerEvents(new ChunkKeeper(),this);
  Bukkit.getPluginManager().registerEvents(new NoCrowdEntity(),this);
  Bukkit.getPluginManager().registerEvents(new AntiCrashSign(),this);
  Bukkit.getPluginManager().registerEvents(new AntiSpam(),this);
  ExplosionController.init(this);
  Bukkit.getPluginManager().registerEvents(new AntiRedstone(),this);
  Bukkit.getPluginManager().registerEvents(new ItemClear(),this);
  Bukkit.getPluginManager().registerEvents(new NoSpawnChunks(),this);
  Bukkit.getPluginManager().registerEvents(new AntiInfRail(),this);
  Bukkit.getPluginManager().registerEvents(new AutoSave(),this);
  DupeLoginPatch.init(this);
  SpawnerController.init(this);
  Bukkit.getPluginManager().registerEvents(new AntiDupeDropItem(),this);
  Bukkit.getPluginManager().registerEvents(new AntiDoorInfItem(),this);
  TeleportPreloader.init(this);
  Bukkit.getPluginManager().registerEvents(new AntiBedExplode(),this);
  Bukkit.getPluginManager().registerEvents(new BlockCommander(),this);
  Bukkit.getPluginManager().registerEvents(new WaterFlowLimitor(),this);
  Bukkit.getPluginManager().registerEvents(new FireLimitor(),this);
  Bukkit.getPluginManager().registerEvents(new FarmProtecter(),this);
  Bukkit.getPluginManager().registerEvents(new AntiBoneBug(),this);
  Bukkit.getPluginManager().registerEvents(new AntiLongStringCrash(),this);
  RespawnAction.init(this);
  EmptyRestart.init(this);
  CheatBookBlocker.init(this);
  OverloadRestart.init(this);
  SkullCrashPatch.init(this);
  if (VersionLevel.isHigherEquals(Version.MINECRAFT_1_12_R1)) {
    if (Bukkit.getPluginManager().isPluginEnabled(""String_Node_Str"")) {
      Bukkit.getPluginManager().registerEvents(new RecipeDupePatch(),this);
      AzureAPI.log(""String_Node_Str"");
    }
 else {
      AzureAPI.warn(""String_Node_Str"");
      AzureAPI.warn(""String_Node_Str"");
    }
  }
  ChunkKeeper.ChunkKeeperofTask();
  getServer().getScheduler().runTaskTimer(this,new ChunkUnloader(),0,ConfigOptimize.ChunkUnloaderInterval * 20);
  TimerGarbageCollect.init(this);
  if (ConfigMain.AutoUpdate)   Bukkit.getScheduler().runTaskAsynchronously(this,new NetWorker());
  Bukkit.getScheduler().runTaskTimer(this,new AntiFakeDeath(),7 * 20,7 * 20);
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  List<String> devs=getDescription().getAuthors();
  AzureAPI.log(""String_Node_Str"" + devs.get(0) + ""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"" + AzureAPI.contactBetween(devs,1,""String_Node_Str"") + ""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
}",0.9277472527472528
175678,"public AntiSpam(){
  timeRecord=Maps.newHashMap();
  AzurePlayerList.bind(this);
}","public AntiSpam(){
  timeRecord=Maps.newHashMap();
  AzurePlayerList.bind(this);
  Bukkit.getScheduler().runTaskTimer(VLagger.MainThis,new Runnable(){
    @Override public void run(){
      timeRecord.clear();
    }
  }
,(long)ConfigFunction.AntiSpamPeriodPeriod * 10000,(long)ConfigFunction.AntiSpamPeriodPeriod * 10000);
}",0.4039408866995074
175679,"@Override public void run(){
  CheckedTimes.clear();
}","@Override public void run(){
  block.setType(Material.AIR,true);
}",0.6833333333333333
175680,"@EventHandler public void CheckRedstone(BlockRedstoneEvent event){
  if (event.getOldCurrent() > event.getNewCurrent()) {
    return;
  }
  final Block block=event.getBlock();
  Location loc=block.getLocation();
  if (CheckedTimes.get(loc) == null) {
    CheckedTimes.put(loc,0);
  }
  CheckedTimes.put(loc,CheckedTimes.get(loc) + 1);
  if (CheckedTimes.get(loc) > ConfigOptimize.AntiRedstoneTimes) {
    if (AzureAPI.containsIgnoreCase(ConfigOptimize.AntiRedstoneRemoveBlockList,block.getType().name())) {
      block.setType(Material.AIR);
      String message=ConfigOptimize.AntiRedstoneMessage;
      message=StringUtils.replace(message,""String_Node_Str"",loc.toString());
      AzureAPI.bc(message);
    }
  }
}","@EventHandler public void CheckRedstone(BlockRedstoneEvent event){
  if (event.getOldCurrent() > event.getNewCurrent()) {
    return;
  }
  final Block block=event.getBlock();
  Location loc=block.getLocation();
  if (CheckedTimes.get(loc) == null) {
    CheckedTimes.put(loc,0);
  }
  CheckedTimes.put(loc,CheckedTimes.get(loc) + 1);
  if (CheckedTimes.get(loc) > ConfigOptimize.AntiRedstoneTimes) {
    if (AzureAPI.containsIgnoreCase(ConfigOptimize.AntiRedstoneRemoveBlockList,block.getType().name())) {
      Bukkit.getScheduler().runTask(VLagger.MainThis,new Runnable(){
        @Override public void run(){
          block.setType(Material.AIR,true);
        }
      }
);
      String message=ConfigOptimize.AntiRedstoneMessage;
      message=StringUtils.replace(message,""String_Node_Str"",loc.toString());
      AzureAPI.bc(message);
    }
  }
}",0.913154533844189
175681,"private static boolean CheckFast(Chunk chunk){
  if (ChunkLastTime.containsKey(chunk)) {
    return (((Long)ChunkLastTime.get(chunk)).longValue() + 50L > System.currentTimeMillis());
  }
  return false;
}","private static boolean CheckFast(Chunk chunk){
  if (ChunkLastTime.containsKey(chunk)) {
    return (ChunkLastTime.get(chunk).longValue() + 50L > System.currentTimeMillis());
  }
  return false;
}",0.98
175682,"public void run(){
  CheckedTimes.clear();
}","@Override public void run(){
  CheckedTimes.clear();
}",0.8979591836734694
175683,"public WaterFlowLimitor(){
  Bukkit.getScheduler().runTaskTimer(VLagger.MainThis,new Runnable(){
    public void run(){
      CheckedTimes.clear();
    }
  }
,7 * 20,7 * 20);
}","public WaterFlowLimitor(){
  Bukkit.getScheduler().runTaskTimer(VLagger.MainThis,new Runnable(){
    @Override public void run(){
      CheckedTimes.clear();
    }
  }
,7 * 20,7 * 20);
}",0.9723756906077348
175684,"@SuppressWarnings(""String_Node_Str"") @EventHandler public void ClickCheckItem(InventoryClickEvent event){
  if (ConfigPatch.AntiLongStringCrashenable == true) {
    if (event.getWhoClicked().getType() != EntityType.PLAYER) {
      return;
    }
    Player player=(Player)event.getWhoClicked();
    ItemStack item=event.getCursor();
    if (item != null) {
      if (item.hasItemMeta() && item.getItemMeta().getDisplayName() != null) {
        if (item.getItemMeta().getDisplayName().length() > 20) {
          player.setItemInHand(null);
          AzureAPI.log(player,ConfigPatch.AntiLongStringCrashWarnMessage);
        }
      }
    }
  }
}","@EventHandler public void ClickCheckItem(InventoryClickEvent evt){
  if (ConfigPatch.AntiLongStringCrashenable == true) {
    if (evt.getWhoClicked().getType() != EntityType.PLAYER) {
      return;
    }
    Player player=(Player)evt.getWhoClicked();
    ItemStack item=evt.getCursor();
    if (item != null) {
      if (item.hasItemMeta() && item.getItemMeta().getDisplayName() != null) {
        if (item.getItemMeta().getDisplayName().length() > 96) {
          evt.setCancelled(true);
          evt.setCurrentItem(null);
          AzureAPI.log(player,ConfigPatch.AntiLongStringCrashWarnMessage);
        }
      }
    }
  }
}",0.9063729346970888
175685,"@SuppressWarnings(""String_Node_Str"") @EventHandler public void InteractCheck(PlayerInteractEvent event){
  if (ConfigPatch.AntiLongStringCrashenable == true) {
    ItemStack item=event.getItem();
    Player player=event.getPlayer();
    if (item != null) {
      if (item.hasItemMeta() && item.getItemMeta().getDisplayName() != null) {
        if (item.getItemMeta().getDisplayName().length() > 20) {
          player.setItemInHand(null);
          AzureAPI.log(player,ConfigPatch.AntiLongStringCrashWarnMessage);
        }
      }
    }
  }
}","@SuppressWarnings(""String_Node_Str"") @EventHandler public void InteractCheck(PlayerInteractEvent evt){
  if (ConfigPatch.AntiLongStringCrashenable == true) {
    ItemStack item=evt.getItem();
    Player player=evt.getPlayer();
    if (item != null) {
      if (item.hasItemMeta() && item.getItemMeta().getDisplayName() != null) {
        if (item.getItemMeta().getDisplayName().length() > 96) {
          evt.setCancelled(true);
          player.setItemInHand(null);
          AzureAPI.log(player,ConfigPatch.AntiLongStringCrashWarnMessage);
        }
      }
    }
  }
}",0.9605026929982048
175686,"public static void fatal(final String prefix,final String context){
  Bukkit.getLogger().severe(prefix + context);
  Bukkit.shutdown();
}","public static void fatal(final String prefix,final String context){
  Bukkit.getLogger().severe(prefix + context);
  if (plugin == null) {
    Bukkit.shutdown();
  }
 else {
    Bukkit.getPluginManager().disablePlugin(plugin);
  }
}",0.7425474254742548
175687,"@Override public void onEnable(){
}","@Override public void onEnable(){
  optimizeConfiguration=new File(this.getDataFolder(),""String_Node_Str"");
  AntiBugConfigFile=new File(this.getDataFolder(),""String_Node_Str"");
  PluginMainConfigFile=new File(this.getDataFolder(),""String_Node_Str"");
  functionConfiguation=new File(this.getDataFolder(),""String_Node_Str"");
  PluginFile=this.getFile();
  MainThis=this;
  LoadConfig();
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  List<String> devs=getDescription().getAuthors();
  AzureAPI.log(""String_Node_Str"" + devs.get(0) + ""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"" + AzureAPI.contactBetween(devs,1,""String_Node_Str"") + ""String_Node_Str"");
  AzureAPI.log(""String_Node_Str"");
  AzureAPI.setPrefix(ConfigMain.PluginPrefix);
  if (ConfigOptimize.AutoSetenable == true) {
    try {
      VLagger.AutoSetServer();
    }
 catch (    IOException|InterruptedException e) {
    }
  }
  Bukkit.getPluginManager().registerEvents(new AntiInfItem(),this);
  Bukkit.getPluginManager().registerEvents(new AntiPortalInfItem(),this);
  Bukkit.getPluginManager().registerEvents(new AntiNetherHopperInfItem(),this);
  Bukkit.getPluginManager().registerEvents(new RPGItemPatch(),this);
  Bukkit.getPluginManager().registerEvents(new ChunkKeeper(),this);
  Bukkit.getPluginManager().registerEvents(new NoCrowdEntity(),this);
  Bukkit.getPluginManager().registerEvents(new AntiCrashSign(),this);
  Bukkit.getPluginManager().registerEvents(new AntiSpam(),this);
  if (VersionLevel.isHigherEquals(Version.MINECRAFT_1_8_R2))   Bukkit.getPluginManager().registerEvents(new ExplosionController.BlockDetector(),this);
  Bukkit.getPluginManager().registerEvents(new ExplosionController.EntityDetector(),this);
  Bukkit.getPluginManager().registerEvents(new AntiRedstone(),this);
  Bukkit.getPluginManager().registerEvents(new ItemClear(),this);
  Bukkit.getPluginManager().registerEvents(new ChunkUnloaderofListener(),this);
  Bukkit.getPluginManager().registerEvents(new AntiInfRail(),this);
  Bukkit.getPluginManager().registerEvents(new AutoSave(),this);
  Bukkit.getPluginManager().registerEvents(new AntiSkullCrash(),this);
  Bukkit.getPluginManager().registerEvents(new FixDupeLogin(),this);
  Bukkit.getPluginManager().registerEvents(new NoEggChangeSpawner(),this);
  Bukkit.getPluginManager().registerEvents(new AntiDupeDropItem(),this);
  Bukkit.getPluginManager().registerEvents(new AntiDoorInfItem(),this);
  Bukkit.getPluginManager().registerEvents(new TeleportPreloader(),this);
  Bukkit.getPluginManager().registerEvents(new AntiBedExplode(),this);
  Bukkit.getPluginManager().registerEvents(new BlockCommander(),this);
  if (VersionLevel.isSpigot())   Bukkit.getPluginManager().registerEvents(new RespawnAction(),this);
  Bukkit.getPluginManager().registerEvents(new WaterFlowLimiter(),this);
  Bukkit.getPluginManager().registerEvents(new FireLimitor(),this);
  Bukkit.getPluginManager().registerEvents(new AutoUpdateCheck(),this);
  Bukkit.getPluginManager().registerEvents(new NoOneRestart(),this);
  Bukkit.getPluginManager().registerEvents(new FarmProtecter(),this);
  Bukkit.getPluginManager().registerEvents(new AntiBoneBug(),this);
  ChunkKeeper.ChunkKeeperofTask();
  AzurePlayerList.bind(this);
  getServer().getScheduler().runTaskTimer(this,new ChunkUnloader(),0,ConfigOptimize.ChunkUnloaderInterval * 20);
  Bukkit.getScheduler().scheduleSyncRepeatingTask(this,new HeapShut(),1 * 60 * 20,1 * 60 * 20);
  Bukkit.getScheduler().runTaskTimer(this,new TimerGarbageCollect(),ConfigOptimize.HeapClearPeriod * 20,ConfigOptimize.HeapClearPeriod * 20);
  Bukkit.getScheduler().runTaskAsynchronously(this,new NetWorker());
  Bukkit.getScheduler().runTaskTimer(this,new AntiFakeDeath(),7 * 20,7 * 20);
}",0.0146351662136734
175688,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  centerX=getWidth() / 2;
  centerY=getHeight() / 2;
}","@Override @CallSuper protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  centerX=getPaddingLeft() + (getWidth() - getPaddingLeft() - getPaddingRight()) / 2;
  centerY=getPaddingTop() + (getHeight() - getPaddingTop() - getPaddingBottom()) / 2;
}",0.748062015503876
175689,"@Override public void onAnimationUpdate(ValueAnimator animation){
  int value=(int)animation.getAnimatedValue();
  shadowRadius=value;
  invalidate();
}","@Override public void onAnimationUpdate(ValueAnimator animation){
  int value=(int)animation.getAnimatedValue();
  tempShadowRadius=value;
  invalidate();
}",0.9805194805194806
175690,"@Override protected final void onDraw(Canvas canvas){
  canvas.drawARGB(0,0,0,0);
  int sd;
  if (isCreate) {
    sd=1;
    isCreate=false;
  }
 else   sd=shadowRadius;
  paint.setMaskFilter(new BlurMaskFilter(sd,BlurMaskFilter.Blur.SOLID));
  drawOuter(canvas);
  drawInside(canvas);
}","@Override protected final void onDraw(Canvas canvas){
  canvas.drawARGB(0,0,0,0);
  paint.setMaskFilter(new BlurMaskFilter(tempShadowRadius,BlurMaskFilter.Blur.SOLID));
  drawOuter(canvas);
  drawInside(canvas);
}",0.7895791583166333
175691,"@Override protected void onDraw(Canvas canvas){
  canvas.drawARGB(0,0,0,0);
  int sd;
  if (isCreate) {
    sd=1;
    isCreate=false;
  }
 else   sd=shadowRadius;
  paint.setMaskFilter(new BlurMaskFilter(sd,BlurMaskFilter.Blur.SOLID));
  drawOuter(canvas);
  drawInside(canvas);
}","@Override protected final void onDraw(Canvas canvas){
  canvas.drawARGB(0,0,0,0);
  int sd;
  if (isCreate) {
    sd=1;
    isCreate=false;
  }
 else   sd=shadowRadius;
  paint.setMaskFilter(new BlurMaskFilter(sd,BlurMaskFilter.Blur.SOLID));
  drawOuter(canvas);
  drawInside(canvas);
}",0.9893992932862192
175692,"public SkipView(Context context,@Nullable AttributeSet attrs,int defStyleAttr){
  super(context,attrs,defStyleAttr);
  coordinate=new float[9][2];
  TypedArray array=context.getTheme().obtainStyledAttributes(attrs,R.styleable.SkipView,defStyleAttr,0);
  triangleRadius=array.getDimensionPixelSize(R.styleable.SkipView_triangleRadius,0);
  innerLineRadius=array.getDimensionPixelSize(R.styleable.SkipView_innerLineRadius,0);
  distance=array.getDimensionPixelSize(R.styleable.SkipView_distance,0);
  triangleColor=array.getColor(R.styleable.SkipView_triangleColor,defaultColor);
  innerLineWidth=array.getDimensionPixelSize(R.styleable.SkipView_innerLineWidth,2);
  triangleHollow=array.getBoolean(R.styleable.SkipView_triangleHollow,false);
  triangleStroke=array.getDimensionPixelSize(R.styleable.SkipView_triangleStroke,2);
  innerLineHeight=array.getDimensionPixelSize(R.styleable.SkipView_innerLineHeight,0);
  triangleHeight=array.getDimensionPixelSize(R.styleable.SkipView_triangleHeight,0);
  triangleWidth=array.getDimensionPixelSize(R.styleable.SkipView_triangleWidth,0);
  array.recycle();
}","public SkipView(Context context,@Nullable AttributeSet attrs,int defStyleAttr){
  super(context,attrs,defStyleAttr);
  coordinate=new float[9][2];
  TypedArray array=context.getTheme().obtainStyledAttributes(attrs,R.styleable.SkipView,defStyleAttr,0);
  triangleRadius=array.getDimensionPixelSize(R.styleable.SkipView_triangleRadius,0);
  innerLineRadius=array.getDimensionPixelSize(R.styleable.SkipView_innerLineRadius,0);
  distance=array.getDimensionPixelSize(R.styleable.SkipView_distance,0);
  triangleColor=array.getColor(R.styleable.SkipView_triangleColor,defaultColor);
  triangleHollow=array.getBoolean(R.styleable.SkipView_triangleHollow,false);
  triangleStroke=array.getDimensionPixelSize(R.styleable.SkipView_triangleStroke,2);
  innerLineWidth=array.getDimensionPixelSize(R.styleable.SkipView_innerLineWidth,2);
  innerLineHeight=array.getDimensionPixelSize(R.styleable.SkipView_innerLineHeight,radius * 2 / 3);
  triangleHeight=array.getDimensionPixelSize(R.styleable.SkipView_triangleHeight,0);
  triangleWidth=array.getDimensionPixelSize(R.styleable.SkipView_triangleWidth,0);
  array.recycle();
}",0.8063205417607223
175693,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  if (innerLineHeight <= 0) {
    innerLineHeight=radius * 2 / 3;
  }
  if (triangleHeight <= 0)   triangleHeight=innerLineHeight;
  if (triangleWidth <= 0) {
    int t2=triangleHeight * triangleHeight;
    triangleWidth=(int)Math.sqrt(t2 - (t2 / 4));
  }
  if (innerLineHeight >= radius * 2)   innerLineHeight=radius * 2;
  if (innerLineWidth >= radius)   innerLineWidth=radius;
  if (triangleWidth >= radius)   triangleWidth=radius;
  if (triangleHeight > radius * 2)   triangleHeight=radius * 2;
  float ry=triangleRadius / 2;
  float rx=(float)Math.sqrt(triangleRadius * triangleRadius - ry * ry);
  int halfW=triangleWidth / 2;
  coordinate[0][0]=centerX - halfW;
  coordinate[0][1]=centerY;
  coordinate[1][0]=(centerX - halfW) + rx;
  coordinate[1][1]=centerY - ry;
  coordinate[8][0]=coordinate[1][0];
  coordinate[8][1]=centerY + ry;
  coordinate[3][0]=centerX + halfW;
  coordinate[3][1]=centerY - triangleHeight / 2;
  coordinate[2][0]=(centerX + halfW) - rx;
  coordinate[2][1]=centerY - (triangleHeight / 2 - ry);
  coordinate[7][0]=coordinate[2][0];
  coordinate[7][1]=centerY + (triangleHeight / 2 - ry);
  coordinate[6][0]=coordinate[3][0];
  coordinate[6][1]=centerY + triangleHeight / 2;
  coordinate[4][0]=centerX + halfW;
  coordinate[4][1]=centerY - (triangleHeight / 2 - triangleRadius);
  coordinate[5][0]=coordinate[4][0];
  coordinate[5][1]=centerY + (triangleHeight / 2 - triangleRadius);
  double a2=triangleWidth * triangleWidth;
  double c2=triangleHeight * triangleHeight / 4;
  double c=triangleHeight / 2;
  double a=triangleWidth;
  double x=(Math.pow(Math.sqrt(a2 + c2) - c,2) + a2) / (2 * a);
  double tr=(x - halfW) - (distance + innerLineWidth) / 2;
  for (int i=0; i < coordinate.length; i++) {
    coordinate[i][0]-=tr;
  }
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  if (innerLineHeight <= 0 || innerLineWidth <= 0) {
    innerLineHeight=0;
    innerLineWidth=0;
  }
  if (triangleHeight <= 0)   triangleHeight=radius * 2 / 3;
  if (triangleWidth <= 0) {
    int t2=triangleHeight * triangleHeight;
    triangleWidth=(int)Math.sqrt(t2 - (t2 / 4));
  }
  if (innerLineHeight >= radius * 2)   innerLineHeight=radius * 2;
  if (innerLineWidth >= radius)   innerLineWidth=radius;
  if (triangleWidth >= radius)   triangleWidth=radius;
  if (triangleHeight > radius * 2)   triangleHeight=radius * 2;
  float ry=triangleRadius / 2;
  float rx=(float)Math.sqrt(triangleRadius * triangleRadius - ry * ry);
  int halfW=triangleWidth / 2;
  coordinate[0][0]=centerX - halfW;
  coordinate[0][1]=centerY;
  coordinate[1][0]=(centerX - halfW) + rx;
  coordinate[1][1]=centerY - ry;
  coordinate[8][0]=coordinate[1][0];
  coordinate[8][1]=centerY + ry;
  coordinate[3][0]=centerX + halfW;
  coordinate[3][1]=centerY - triangleHeight / 2;
  coordinate[2][0]=(centerX + halfW) - rx;
  coordinate[2][1]=centerY - (triangleHeight / 2 - ry);
  coordinate[7][0]=coordinate[2][0];
  coordinate[7][1]=centerY + (triangleHeight / 2 - ry);
  coordinate[6][0]=coordinate[3][0];
  coordinate[6][1]=centerY + triangleHeight / 2;
  coordinate[4][0]=centerX + halfW;
  coordinate[4][1]=centerY - (triangleHeight / 2 - triangleRadius);
  coordinate[5][0]=coordinate[4][0];
  coordinate[5][1]=centerY + (triangleHeight / 2 - triangleRadius);
  double a2=triangleWidth * triangleWidth;
  double c2=triangleHeight * triangleHeight / 4;
  double c=triangleHeight / 2;
  double a=triangleWidth;
  double x=(Math.pow(Math.sqrt(a2 + c2) - c,2) + a2) / (2 * a);
  double tr=(x - halfW) - (distance + innerLineWidth) / 2;
  for (int i=0; i < coordinate.length; i++) {
    coordinate[i][0]-=tr;
  }
}",0.9580401355225436
175694,"/** 
 * 绘制单竖线
 */
protected void drawLine(Canvas canvas){
  paint.setStyle(Paint.Style.FILL);
  paint.setColor(triangleColor);
  float left=coordinate[0][0] - distance - innerLineWidth;
  float top=coordinate[0][1] - innerLineHeight / 2;
  float right=left + innerLineWidth;
  float bottom=top + innerLineHeight;
  RectF rectF=new RectF(left,top,right,bottom);
  canvas.drawRoundRect(rectF,innerLineRadius,innerLineRadius,paint);
}","/** 
 * 绘制单竖线
 */
protected void drawLine(Canvas canvas){
  if (innerLineHeight <= 0 || innerLineWidth <= 0)   return;
  paint.setStyle(Paint.Style.FILL);
  paint.setColor(triangleColor);
  float left=coordinate[0][0] - distance - innerLineWidth;
  float top=coordinate[0][1] - innerLineHeight / 2;
  float right=left + innerLineWidth;
  float bottom=top + innerLineHeight;
  RectF rectF=new RectF(left,top,right,bottom);
  canvas.drawRoundRect(rectF,innerLineRadius,innerLineRadius,paint);
}",0.933911159263272
175695,"public BrokerMessage.MessageContent read(long offset){
  if (offset >= startOffset + fileSize) {
    LOG.warn(""String_Node_Str"",offset);
    return null;
  }
  try {
    channel.position(offset - startOffset);
    ByteBuffer headerBuffer=ByteBuffer.allocate(MESSAGE_HEADER_LENGTH);
    int readLen=channel.read(headerBuffer);
    if (readLen != MESSAGE_HEADER_LENGTH) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    headerBuffer.flip();
    long crc32=headerBuffer.getLong();
    int messageLen=headerBuffer.getInt();
    LOG.info(""String_Node_Str"",messageLen);
    ByteBuffer messageContentBuffer=ByteBuffer.allocate(messageLen);
    readLen=channel.read(messageContentBuffer);
    if (readLen != messageLen) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    if (BrokerUtils.getCRC32(messageContentBuffer.array()) != crc32) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    BrokerMessage.MessageContent message=BrokerMessage.MessageContent.parseFrom(messageContentBuffer.array());
    BrokerMessage.MessageContent result=BrokerMessage.MessageContent.newBuilder().mergeFrom(message).setSize(MESSAGE_HEADER_LENGTH + messageLen).build();
    return result;
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"",dirName,fileName,offset);
    return null;
  }
}","public BrokerMessage.MessageContent read(long offset){
  if (offset >= startOffset + fileSize) {
    LOG.debug(""String_Node_Str"",offset);
    return null;
  }
  try {
    channel.position(offset - startOffset);
    ByteBuffer headerBuffer=ByteBuffer.allocate(MESSAGE_HEADER_LENGTH);
    int readLen=channel.read(headerBuffer);
    if (readLen != MESSAGE_HEADER_LENGTH) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    headerBuffer.flip();
    long crc32=headerBuffer.getLong();
    int messageLen=headerBuffer.getInt();
    LOG.info(""String_Node_Str"",messageLen);
    ByteBuffer messageContentBuffer=ByteBuffer.allocate(messageLen);
    readLen=channel.read(messageContentBuffer);
    if (readLen != messageLen) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    if (BrokerUtils.getCRC32(messageContentBuffer.array()) != crc32) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    BrokerMessage.MessageContent message=BrokerMessage.MessageContent.parseFrom(messageContentBuffer.array());
    BrokerMessage.MessageContent result=BrokerMessage.MessageContent.newBuilder().mergeFrom(message).setSize(MESSAGE_HEADER_LENGTH + messageLen).build();
    return result;
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"",dirName,fileName,offset);
    return null;
  }
}",0.9965818458032664
175696,"@Override public BrokerMessage.SendMessageResponse sendMessage(BrokerMessage.SendMessageRequest request){
  BrokerMessage.SendMessageResponse.Builder responseBuilder=BrokerMessage.SendMessageResponse.newBuilder();
  BrokerMessage.BaseResponse.Builder baseResBuilder=BrokerMessage.BaseResponse.newBuilder();
  baseResBuilder.setResCode(BrokerMessage.ResCode.RES_CODE_FAIL);
  boolean topicExist=metadataManager.checkTopicExist(request.getTopic());
  if (!topicExist) {
    Map<Integer,Integer> queueMap=metadataManager.readTopicInfo(request.getTopic());
    if (queueMap.size() > 0) {
      topicExist=true;
    }
    metadataManager.updateTopicMap(request.getTopic(),queueMap);
  }
  boolean shardingValid=false;
  GlobalConf conf=GlobalConf.getInstance();
  Integer shardingId=metadataManager.getQueueSharding(request.getTopic(),request.getQueue());
  if (shardingId != null && shardingId.equals(conf.getShardingId())) {
    shardingValid=true;
  }
  if (!topicExist || !shardingValid) {
    String message=""String_Node_Str"";
    baseResBuilder.setResMsg(message);
    responseBuilder.setBaseRes(baseResBuilder.build());
    LOG.info(""String_Node_Str"",request.getTopic(),request.getQueue(),responseBuilder.getBaseRes().getResCode(),responseBuilder.getBaseRes().getResMsg());
    return responseBuilder.build();
  }
  if (raftNode.getLeaderId() <= 0) {
    baseResBuilder.setResMsg(""String_Node_Str"");
    responseBuilder.setBaseRes(baseResBuilder);
  }
 else   if (raftNode.getLeaderId() != raftNode.getLocalServer().getServerId()) {
    RPCClient rpcClient=raftNode.getPeerMap().get(raftNode.getLeaderId()).getRpcClient();
    BrokerAPI brokerAPI=RPCProxy.getProxy(rpcClient,BrokerAPI.class);
    BrokerMessage.SendMessageResponse responseFromLeader=brokerAPI.sendMessage(request);
    if (responseFromLeader == null) {
      baseResBuilder.setResMsg(""String_Node_Str"");
      responseBuilder.setBaseRes(baseResBuilder);
    }
 else {
      responseBuilder.mergeFrom(responseFromLeader);
    }
  }
 else {
    byte[] data=request.toByteArray();
    boolean success=raftNode.replicate(data,RaftMessage.EntryType.ENTRY_TYPE_DATA);
    baseResBuilder.setResCode(success ? BrokerMessage.ResCode.RES_CODE_SUCCESS : BrokerMessage.ResCode.RES_CODE_FAIL);
    responseBuilder.setBaseRes(baseResBuilder);
  }
  BrokerMessage.SendMessageResponse response=responseBuilder.build();
  LOG.info(""String_Node_Str"",request.getTopic(),request.getQueue(),responseBuilder.getBaseRes().getResCode(),responseBuilder.getBaseRes().getResMsg());
  return response;
}","@Override public BrokerMessage.SendMessageResponse sendMessage(BrokerMessage.SendMessageRequest request){
  BrokerMessage.SendMessageResponse.Builder responseBuilder=BrokerMessage.SendMessageResponse.newBuilder();
  BrokerMessage.BaseResponse.Builder baseResBuilder=BrokerMessage.BaseResponse.newBuilder();
  baseResBuilder.setResCode(BrokerMessage.ResCode.RES_CODE_FAIL);
  boolean topicExist=metadataManager.checkTopicExist(request.getTopic());
  if (!topicExist) {
    Map<Integer,Integer> queueMap=metadataManager.readTopicInfo(request.getTopic());
    if (queueMap.size() > 0) {
      topicExist=true;
    }
    metadataManager.updateTopicMap(request.getTopic(),queueMap);
  }
  if (raftNode.getLeaderId() <= 0) {
    baseResBuilder.setResMsg(""String_Node_Str"");
    responseBuilder.setBaseRes(baseResBuilder);
  }
 else   if (raftNode.getLeaderId() != raftNode.getLocalServer().getServerId()) {
    RPCClient rpcClient=raftNode.getPeerMap().get(raftNode.getLeaderId()).getRpcClient();
    BrokerAPI brokerAPI=RPCProxy.getProxy(rpcClient,BrokerAPI.class);
    BrokerMessage.SendMessageResponse responseFromLeader=brokerAPI.sendMessage(request);
    if (responseFromLeader == null) {
      baseResBuilder.setResMsg(""String_Node_Str"");
      responseBuilder.setBaseRes(baseResBuilder);
    }
 else {
      responseBuilder.mergeFrom(responseFromLeader);
    }
  }
 else {
    byte[] data=request.toByteArray();
    boolean success=raftNode.replicate(data,RaftMessage.EntryType.ENTRY_TYPE_DATA);
    baseResBuilder.setResCode(success ? BrokerMessage.ResCode.RES_CODE_SUCCESS : BrokerMessage.ResCode.RES_CODE_FAIL);
    responseBuilder.setBaseRes(baseResBuilder);
  }
  BrokerMessage.SendMessageResponse response=responseBuilder.build();
  LOG.info(""String_Node_Str"",request.getTopic(),request.getQueue(),responseBuilder.getBaseRes().getResCode(),responseBuilder.getBaseRes().getResMsg());
  return response;
}",0.8576560395150427
175697,"public static void main(String[] args){
  GlobalConf conf=GlobalConf.getInstance();
  RaftMessage.Server localServer=conf.getLocalServer();
  List<RaftMessage.Server> servers=conf.getServers();
  String dataDir=conf.getDataDir();
  ZKConf zkConf=conf.getZkConf();
  MetadataManager metadataManager=new MetadataManager(zkConf);
  RPCServer server=new RPCServer(localServer.getEndPoint().getPort());
  BrokerStateMachine stateMachine=new BrokerStateMachine();
  RaftOptions.dataDir=dataDir;
  RaftOptions.snapshotMinLogSize=10 * 1024;
  RaftOptions.snapshotPeriodSeconds=30;
  RaftOptions.maxSegmentFileSize=1024 * 1024;
  RaftNode raftNode=new RaftNode(servers,localServer,stateMachine);
  stateMachine.setRaftNode(raftNode);
  RaftConsensusService raftConsensusService=new RaftConsensusServiceImpl(raftNode);
  server.registerService(raftConsensusService);
  RaftClientService raftClientService=new RaftClientServiceImpl(raftNode);
  server.registerService(raftClientService);
  BrokerAPIImpl brokerAPI=new BrokerAPIImpl(raftNode,stateMachine,metadataManager);
  server.registerService(brokerAPI);
  server.start();
  raftNode.init();
  metadataManager.subscribeTopic();
  while (!ConfigurationUtils.containsServer(raftNode.getConfiguration(),conf.getLocalServer().getServerId())) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException ex) {
      ex.printStackTrace();
    }
  }
  metadataManager.registerBroker(conf.getShardingId(),conf.getLocalServer().getEndPoint().getHost(),conf.getLocalServer().getEndPoint().getPort());
}","public static void main(String[] args){
  GlobalConf conf=GlobalConf.getInstance();
  RaftMessage.Server localServer=conf.getLocalServer();
  List<RaftMessage.Server> servers=conf.getServers();
  String dataDir=System.getProperty(""String_Node_Str"") + File.separator + conf.getDataDir();
  ZKConf zkConf=conf.getZkConf();
  MetadataManager metadataManager=new MetadataManager(zkConf);
  RPCServer server=new RPCServer(localServer.getEndPoint().getPort());
  BrokerStateMachine stateMachine=new BrokerStateMachine(dataDir);
  RaftOptions.dataDir=dataDir;
  RaftOptions.snapshotMinLogSize=10 * 1024;
  RaftOptions.snapshotPeriodSeconds=30;
  RaftOptions.maxSegmentFileSize=1024 * 1024;
  RaftNode raftNode=new RaftNode(servers,localServer,stateMachine);
  stateMachine.setRaftNode(raftNode);
  RaftConsensusService raftConsensusService=new RaftConsensusServiceImpl(raftNode);
  server.registerService(raftConsensusService);
  RaftClientService raftClientService=new RaftClientServiceImpl(raftNode);
  server.registerService(raftClientService);
  BrokerAPIImpl brokerAPI=new BrokerAPIImpl(raftNode,stateMachine,metadataManager);
  server.registerService(brokerAPI);
  server.start();
  raftNode.init();
  metadataManager.subscribeTopic();
  while (!ConfigurationUtils.containsServer(raftNode.getConfiguration(),conf.getLocalServer().getServerId())) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException ex) {
      ex.printStackTrace();
    }
  }
  metadataManager.registerBroker(conf.getShardingId(),conf.getLocalServer().getEndPoint().getHost(),conf.getLocalServer().getEndPoint().getPort());
}",0.9797852179406192
175698,"public BrokerStateMachine(){
  String dataDir=GlobalConf.getInstance().getDataDir();
  this.messageDir=dataDir + File.separator + ""String_Node_Str"";
}","public BrokerStateMachine(String dataDir){
  this.messageDir=dataDir + File.separator + ""String_Node_Str"";
}",0.8294573643410853
175699,"@Override public void readSnapshot(String snapshotDir){
  try {
    isAvailable.compareAndSet(true,false);
    Path link=FileSystems.getDefault().getPath(snapshotDir);
    if (!Files.isSymbolicLink(link)) {
      if (logManager != null) {
        logManager.close();
      }
      File messageDirFile=new File(messageDir);
      if (messageDirFile.exists()) {
        FileUtils.deleteDirectory(messageDirFile);
      }
      File snapshotDirFile=new File(snapshotDir);
      if (snapshotDirFile.exists()) {
        FileUtils.copyDirectory(snapshotDirFile,messageDirFile);
      }
    }
    logManager=new LogManager(messageDir,this);
  }
 catch (  IOException ex) {
    LOG.error(""String_Node_Str"",ex);
    throw new RuntimeException(ex);
  }
 finally {
    isAvailable.compareAndSet(false,true);
  }
}","@Override public void readSnapshot(String snapshotDir){
  try {
    isAvailable.compareAndSet(true,false);
    Path link=FileSystems.getDefault().getPath(snapshotDir);
    if (!Files.isSymbolicLink(link)) {
      if (logManager != null) {
        logManager.close();
      }
      File snapshotDirFile=new File(snapshotDir);
      if (snapshotDirFile.exists() && snapshotDirFile.listFiles().length > 0) {
        File messageDirFile=new File(messageDir);
        if (messageDirFile.exists()) {
          FileUtils.deleteDirectory(messageDirFile);
        }
        FileUtils.copyDirectory(snapshotDirFile,messageDirFile);
      }
    }
    logManager=new LogManager(messageDir,this);
  }
 catch (  IOException ex) {
    LOG.error(""String_Node_Str"",ex);
    throw new RuntimeException(ex);
  }
 finally {
    isAvailable.compareAndSet(false,true);
  }
}",0.837968561064087
175700,"@Override public void run(){
  if (stateMachine.getRaftNode().getSnapshot().getIsInstallSnapshot().get()) {
    LOG.info(""String_Node_Str"");
    return;
  }
  if (!stateMachine.getRaftNode().getSnapshot().getIsTakeSnapshot().compareAndSet(false,true)) {
    LOG.info(""String_Node_Str"");
    return;
  }
  LOG.info(""String_Node_Str"");
  try {
    GlobalConf conf=GlobalConf.getInstance();
    Set<String> topicSet=topicLogMap.keySet();
    for (    String topic : topicSet) {
      ConcurrentMap<Integer,SegmentedLog> queueLogMap=topicLogMap.get(topic);
      if (queueLogMap != null) {
        Set<Integer> queueSet=queueLogMap.keySet();
        for (        Integer queue : queueSet) {
          try {
            SegmentedLog log=topicLogMap.get(topic).get(queue);
            log.getLock().lock();
            try {
              Segment lastSegment=null;
              Iterator<Map.Entry<Long,Segment>> iterator=log.getStartOffsetSegmentMap().entrySet().iterator();
              while (iterator.hasNext()) {
                Segment segment=iterator.next().getValue();
                if (lastSegment == null) {
                  lastSegment=segment;
                  continue;
                }
                BrokerMessage.MessageContent message=segment.read(segment.getStartOffset());
                if (System.currentTimeMillis() / 1000 - message.getCreateTime() / 1000 > conf.getExpiredLogDuration()) {
                  lastSegment.delete();
                  iterator.remove();
                }
 else {
                  break;
                }
                lastSegment=segment;
              }
            }
  finally {
              log.getLock().unlock();
            }
          }
 catch (          Exception ex) {
            LOG.warn(""String_Node_Str"");
          }
        }
      }
    }
  }
  finally {
    stateMachine.getRaftNode().getSnapshot().getIsTakeSnapshot().compareAndSet(true,false);
  }
  LOG.info(""String_Node_Str"");
  stateMachine.getRaftNode().takeSnapshot();
}","@Override public void run(){
  if (stateMachine.getRaftNode().getSnapshot().getIsInstallSnapshot().get()) {
    LOG.info(""String_Node_Str"");
    return;
  }
  if (!stateMachine.getRaftNode().getSnapshot().getIsTakeSnapshot().compareAndSet(false,true)) {
    LOG.info(""String_Node_Str"");
    return;
  }
  LOG.info(""String_Node_Str"");
  try {
    GlobalConf conf=GlobalConf.getInstance();
    Set<String> topicSet=topicLogMap.keySet();
    for (    String topic : topicSet) {
      ConcurrentMap<Integer,SegmentedLog> queueLogMap=topicLogMap.get(topic);
      if (queueLogMap != null) {
        Set<Integer> queueSet=queueLogMap.keySet();
        for (        Integer queue : queueSet) {
          try {
            SegmentedLog log=topicLogMap.get(topic).get(queue);
            log.getLock().lock();
            try {
              List<Long> deletedKeyList=new ArrayList<>();
              Segment lastSegment=null;
              Iterator<Map.Entry<Long,Segment>> iterator=log.getStartOffsetSegmentMap().entrySet().iterator();
              while (iterator.hasNext()) {
                Segment segment=iterator.next().getValue();
                if (lastSegment == null) {
                  lastSegment=segment;
                  continue;
                }
                BrokerMessage.MessageContent message=segment.read(segment.getStartOffset());
                if (System.currentTimeMillis() / 1000 - message.getCreateTime() / 1000 > conf.getExpiredLogDuration()) {
                  lastSegment.delete();
                  deletedKeyList.add(lastSegment.getStartOffset());
                }
 else {
                  break;
                }
                lastSegment=segment;
              }
              for (              Long startOffset : deletedKeyList) {
                log.getStartOffsetSegmentMap().remove(startOffset);
              }
            }
  finally {
              log.getLock().unlock();
            }
          }
 catch (          Exception ex) {
            LOG.warn(""String_Node_Str"");
          }
        }
      }
    }
  }
  finally {
    stateMachine.getRaftNode().getSnapshot().getIsTakeSnapshot().compareAndSet(true,false);
  }
  LOG.info(""String_Node_Str"");
  stateMachine.getRaftNode().takeSnapshot();
}",0.8885230479774224
175701,"public LogManager(String logDir,BrokerStateMachine stateMachine){
  this.stateMachine=stateMachine;
  this.topicLogMap=new ConcurrentHashMap<>();
  this.logDir=logDir;
  File dirFile=new File(logDir);
  if (!dirFile.exists()) {
    dirFile.mkdirs();
  }
  File[] topicDirs=dirFile.listFiles();
  if (topicDirs != null) {
    for (    File topicDir : topicDirs) {
      if (!topicDir.isDirectory()) {
        LOG.warn(""String_Node_Str"",topicDir.getAbsolutePath());
        continue;
      }
      LOG.info(""String_Node_Str"" + topicDir.getAbsolutePath());
      if (!this.topicLogMap.containsKey(topicDir)) {
        this.topicLogMap.put(topicDir.getName(),new ConcurrentHashMap<Integer,SegmentedLog>());
      }
      Map<Integer,SegmentedLog> queueMap=this.topicLogMap.get(topicDir.getName());
      File[] queueDirs=topicDir.listFiles();
      if (queueDirs != null) {
        for (        File queueDir : queueDirs) {
          if (!queueDir.isDirectory()) {
            LOG.warn(""String_Node_Str"",queueDir.getAbsolutePath());
            continue;
          }
          Integer queueId=Integer.valueOf(queueDir.getName());
          String fullQueuePath=logDir + File.separator + topicDir+ File.separator+ queueDir;
          SegmentedLog queueLog=new SegmentedLog(fullQueuePath);
          queueMap.put(queueId,queueLog);
        }
      }
    }
  }
  timer.scheduleWithFixedDelay(this,GlobalConf.getInstance().getExpiredLogCheckInterval(),GlobalConf.getInstance().getExpiredLogCheckInterval(),TimeUnit.SECONDS);
}","public LogManager(String logDir,BrokerStateMachine stateMachine) throws IOException {
  this.stateMachine=stateMachine;
  this.topicLogMap=new ConcurrentHashMap<>();
  this.logDir=logDir;
  File dirFile=new File(logDir);
  if (!dirFile.exists()) {
    dirFile.mkdirs();
  }
  File[] topicDirs=dirFile.listFiles();
  if (topicDirs != null) {
    for (    File topicDir : topicDirs) {
      if (!topicDir.isDirectory()) {
        LOG.warn(""String_Node_Str"",topicDir.getAbsolutePath());
        continue;
      }
      LOG.info(""String_Node_Str"" + topicDir.getAbsolutePath());
      if (!this.topicLogMap.containsKey(topicDir)) {
        this.topicLogMap.put(topicDir.getName(),new ConcurrentHashMap<Integer,SegmentedLog>());
      }
      Map<Integer,SegmentedLog> queueMap=this.topicLogMap.get(topicDir.getName());
      File[] queueDirs=topicDir.listFiles();
      if (queueDirs != null) {
        for (        File queueDir : queueDirs) {
          if (!queueDir.isDirectory()) {
            LOG.warn(""String_Node_Str"",queueDir.getAbsolutePath());
            continue;
          }
          Integer queueId=Integer.valueOf(queueDir.getName());
          String fullQueuePath=queueDir.getCanonicalPath();
          SegmentedLog queueLog=new SegmentedLog(fullQueuePath);
          queueMap.put(queueId,queueLog);
        }
      }
    }
  }
  timer.scheduleWithFixedDelay(this,GlobalConf.getInstance().getExpiredLogCheckInterval(),GlobalConf.getInstance().getExpiredLogCheckInterval(),TimeUnit.SECONDS);
}",0.969897452861396
175702,"public void delete(){
  close();
  String fullFileName=dirName + File.separator + fileName;
  File file=new File(fullFileName);
  file.delete();
  try {
    FileUtils.forceDelete(file);
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"",ex);
  }
}","public void delete(){
  close();
  String fullFileName=dirName + File.separator + fileName;
  File file=new File(fullFileName);
  try {
    FileUtils.forceDelete(file);
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"",ex);
  }
}",0.9660678642714572
175703,"public BrokerMessage.MessageContent read(long offset){
  lock.lock();
  try {
    Map.Entry<Long,Segment> entry=startOffsetSegmentMap.floorEntry(offset);
    if (entry == null) {
      LOG.warn(""String_Node_Str"",offset);
      return null;
    }
    Segment segment=entry.getValue();
    return segment.read(offset);
  }
  finally {
    lock.unlock();
  }
}","public BrokerMessage.MessageContent read(long offset){
  lock.lock();
  try {
    if (startOffsetSegmentMap.size() > 0) {
      long firstOffset=startOffsetSegmentMap.firstKey();
      if (offset < firstOffset) {
        offset=firstOffset;
      }
    }
    Map.Entry<Long,Segment> entry=startOffsetSegmentMap.floorEntry(offset);
    if (entry == null) {
      LOG.warn(""String_Node_Str"",offset);
      return null;
    }
    Segment segment=entry.getValue();
    return segment.read(offset);
  }
  finally {
    lock.unlock();
  }
}",0.8013468013468014
175704,"private void readSegments(){
  try {
    List<String> fileNames=RaftFileUtils.getSortedFilesInDirectory(segmentDir,segmentDir);
    for (    String fileName : fileNames) {
      Segment segment=new Segment(segmentDir,fileName);
      startOffsetSegmentMap.put(segment.getStartOffset(),segment);
    }
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"",ex);
    throw new RuntimeException(""String_Node_Str"",ex);
  }
}","private void readSegments(){
  try {
    List<String> fileNames=RaftFileUtils.getSortedFilesInDirectory(segmentDir,segmentDir);
    for (    String fileName : fileNames) {
      LOG.info(""String_Node_Str"",fileName);
      Segment segment=new Segment(segmentDir,fileName);
      startOffsetSegmentMap.put(segment.getStartOffset(),segment);
    }
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"",ex);
    throw new RuntimeException(""String_Node_Str"",ex);
  }
}",0.9511111111111112
175705,"public boolean append(BrokerMessage.MessageContent.Builder message){
  boolean isNeedNewSegmentFile=false;
  int segmentSize=startOffsetSegmentMap.size();
  lock.lock();
  try {
    if (segmentSize == 0) {
      isNeedNewSegmentFile=true;
    }
 else {
      Segment lastSegment=startOffsetSegmentMap.lastEntry().getValue();
      if (!lastSegment.isCanWrite()) {
        isNeedNewSegmentFile=true;
      }
 else {
        int maxSegmentSize=GlobalConf.getInstance().getMaxSegmentSize();
        if (lastSegment.getFileSize() + message.build().getSerializedSize() > maxSegmentSize) {
          isNeedNewSegmentFile=true;
          lastSegment.close();
          lastSegment.setCanWrite(false);
          String newFileName=String.format(""String_Node_Str"",lastSegment.getStartOffset(),lastSegment.getEndOffset());
          String newFullFileName=segmentDir + File.separator + newFileName;
          File newFile=new File(newFullFileName);
          newFile.createNewFile();
          String oldFullFileName=segmentDir + File.separator + lastSegment.getFileName();
          File oldFile=new File(oldFullFileName);
          oldFile.renameTo(newFile);
          lastSegment.setFileName(newFileName);
          lastSegment.setRandomAccessFile(RaftFileUtils.openFile(segmentDir,newFileName,""String_Node_Str""));
          lastSegment.setChannel(lastSegment.getRandomAccessFile().getChannel());
        }
      }
    }
    Segment newSegment;
    if (isNeedNewSegmentFile) {
      long newStartOffset=getLastEndOffset();
      String newSegmentFileName=String.format(""String_Node_Str"",newStartOffset);
      String newFullFileName=segmentDir + File.separator + newSegmentFileName;
      File newSegmentFile=new File(newFullFileName);
      if (!newSegmentFile.exists()) {
        newSegmentFile.createNewFile();
      }
      newSegment=new Segment(segmentDir,newSegmentFileName);
      startOffsetSegmentMap.put(newSegment.getStartOffset(),newSegment);
    }
 else {
      newSegment=startOffsetSegmentMap.lastEntry().getValue();
    }
    return newSegment.append(message);
  }
 catch (  IOException ex) {
    throw new RuntimeException(""String_Node_Str"" + ex.getMessage());
  }
 finally {
    lock.unlock();
  }
}","public boolean append(BrokerMessage.MessageContent.Builder message){
  boolean isNeedNewSegmentFile=false;
  int segmentSize=startOffsetSegmentMap.size();
  lock.lock();
  try {
    if (segmentSize == 0) {
      isNeedNewSegmentFile=true;
    }
 else {
      Segment lastSegment=startOffsetSegmentMap.lastEntry().getValue();
      if (!lastSegment.isCanWrite()) {
        isNeedNewSegmentFile=true;
      }
 else {
        int maxSegmentSize=GlobalConf.getInstance().getMaxSegmentSize();
        if (lastSegment.getFileSize() + message.build().getSerializedSize() > maxSegmentSize) {
          isNeedNewSegmentFile=true;
          lastSegment.close();
          lastSegment.setCanWrite(false);
          String newFileName=String.format(""String_Node_Str"",lastSegment.getStartOffset(),lastSegment.getEndOffset());
          String newFullFileName=segmentDir + File.separator + newFileName;
          File newFile=new File(newFullFileName);
          String oldFullFileName=segmentDir + File.separator + lastSegment.getFileName();
          File oldFile=new File(oldFullFileName);
          FileUtils.moveFile(oldFile,newFile);
          lastSegment.setFileName(newFileName);
          lastSegment.setRandomAccessFile(RaftFileUtils.openFile(segmentDir,newFileName,""String_Node_Str""));
          lastSegment.setChannel(lastSegment.getRandomAccessFile().getChannel());
        }
      }
    }
    Segment newSegment;
    if (isNeedNewSegmentFile) {
      long newStartOffset=getLastEndOffset();
      String newSegmentFileName=String.format(""String_Node_Str"",newStartOffset);
      String newFullFileName=segmentDir + File.separator + newSegmentFileName;
      File newSegmentFile=new File(newFullFileName);
      if (!newSegmentFile.exists()) {
        newSegmentFile.createNewFile();
      }
      newSegment=new Segment(segmentDir,newSegmentFileName);
      startOffsetSegmentMap.put(newSegment.getStartOffset(),newSegment);
    }
 else {
      newSegment=startOffsetSegmentMap.lastEntry().getValue();
    }
    return newSegment.append(message);
  }
 catch (  IOException ex) {
    throw new RuntimeException(""String_Node_Str"" + ex.getMessage());
  }
 finally {
    lock.unlock();
  }
}",0.9852171935410508
175706,"@Test public void testClearExpiredLog(){
  Snapshot snapshot=Mockito.mock(Snapshot.class);
  Mockito.when(snapshot.getIsInstallSnapshot()).thenReturn(new AtomicBoolean(false));
  Mockito.when(snapshot.getIsTakeSnapshot()).thenReturn(new AtomicBoolean(false));
  RaftNode raftNode=Mockito.mock(RaftNode.class);
  Mockito.when(raftNode.getSnapshot()).thenReturn(snapshot);
  Mockito.doNothing().when(raftNode).takeSnapshot();
  BrokerStateMachine stateMachine=new BrokerStateMachine();
  stateMachine.setRaftNode(raftNode);
  GlobalConf conf=GlobalConf.getInstance();
  conf.setMaxSegmentSize(128);
  conf.setExpiredLogDuration(1);
  LogManager logManager=new LogManager(conf.getDataDir(),stateMachine);
  String topic=""String_Node_Str"";
  Integer queue=0;
  SegmentedLog log=logManager.getOrCreateQueueLog(topic,queue);
  for (int i=0; i < 1000; i++) {
    log.append(createMessage(topic,queue));
  }
  try {
    Thread.sleep(2000);
  }
 catch (  InterruptedException ex) {
    ex.printStackTrace();
  }
  System.out.println(""String_Node_Str"" + log.getStartOffsetSegmentMap().size());
  logManager.run();
  System.out.println(""String_Node_Str"" + log.getStartOffsetSegmentMap().size());
  Assert.assertTrue(log.getStartOffsetSegmentMap().size() == 1);
  File file=new File(conf.getDataDir());
  try {
    FileUtils.deleteDirectory(file);
  }
 catch (  IOException ex) {
    ex.printStackTrace();
  }
}","@Test public void testClearExpiredLog() throws IOException {
  GlobalConf conf=GlobalConf.getInstance();
  conf.setMaxSegmentSize(128);
  conf.setExpiredLogDuration(1);
  Snapshot snapshot=Mockito.mock(Snapshot.class);
  Mockito.when(snapshot.getIsInstallSnapshot()).thenReturn(new AtomicBoolean(false));
  Mockito.when(snapshot.getIsTakeSnapshot()).thenReturn(new AtomicBoolean(false));
  RaftNode raftNode=Mockito.mock(RaftNode.class);
  Mockito.when(raftNode.getSnapshot()).thenReturn(snapshot);
  Mockito.doNothing().when(raftNode).takeSnapshot();
  BrokerStateMachine stateMachine=new BrokerStateMachine(conf.getDataDir());
  stateMachine.setRaftNode(raftNode);
  LogManager logManager=new LogManager(conf.getDataDir(),stateMachine);
  String topic=""String_Node_Str"";
  Integer queue=0;
  SegmentedLog log=logManager.getOrCreateQueueLog(topic,queue);
  for (int i=0; i < 1000; i++) {
    log.append(createMessage(topic,queue));
  }
  try {
    Thread.sleep(2000);
  }
 catch (  InterruptedException ex) {
    ex.printStackTrace();
  }
  System.out.println(""String_Node_Str"" + log.getStartOffsetSegmentMap().size());
  logManager.run();
  System.out.println(""String_Node_Str"" + log.getStartOffsetSegmentMap().size());
  Assert.assertTrue(log.getStartOffsetSegmentMap().size() == 1);
  File file=new File(conf.getDataDir());
  try {
    FileUtils.deleteDirectory(file);
  }
 catch (  IOException ex) {
    ex.printStackTrace();
  }
}",0.6476190476190476
175707,"public Map<Integer,Integer> readTopicInfo(String topic){
  Map<Integer,Integer> queueMap=new HashMap<>();
  String topicPath=zkConf.getZKBasePath() + ""String_Node_Str"" + topic;
  try {
    List<String> queues=zkClient.getChildren().forPath(topicPath);
    for (    String queue : queues) {
      String queuePath=topicPath + ""String_Node_Str"" + queue;
      String queueData=new String(zkClient.getData().forPath(queuePath));
      Integer shardingId=Integer.valueOf(queueData);
      Integer queueId=Integer.valueOf(queue);
      queueMap.put(queueId,shardingId);
    }
  }
 catch (  Exception ex) {
    LOG.info(""String_Node_Str"",ex);
  }
  return queueMap;
}","public Map<Integer,Integer> readTopicInfo(String topic){
  Map<Integer,Integer> queueMap=new HashMap<>();
  String topicPath=zkConf.getZKBasePath() + ""String_Node_Str"" + topic;
  try {
    List<String> queues=zkClient.getChildren().forPath(topicPath);
    for (    String queue : queues) {
      String queuePath=topicPath + ""String_Node_Str"" + queue;
      String queueData=new String(zkClient.getData().forPath(queuePath));
      Integer shardingId=Integer.valueOf(queueData);
      Integer queueId=Integer.valueOf(queue);
      queueMap.put(queueId,shardingId);
    }
  }
 catch (  Exception ex) {
    LOG.warn(""String_Node_Str"",ex);
  }
  return queueMap;
}",0.9939485627836612
175708,"public BrokerAPIImpl(RaftNode raftNode,BrokerStateMachine stateMachine){
  this.raftNode=raftNode;
  this.stateMachine=stateMachine;
}","public BrokerAPIImpl(RaftNode raftNode,BrokerStateMachine stateMachine,ZKClient zkClient){
  this.raftNode=raftNode;
  this.stateMachine=stateMachine;
  this.zkClient=zkClient;
}",0.8589743589743589
175709,"@Override public BrokerMessage.SendMessageResponse sendMessage(BrokerMessage.SendMessageRequest request){
  BrokerMessage.SendMessageResponse.Builder responseBuilder=BrokerMessage.SendMessageResponse.newBuilder();
  BrokerMessage.BaseResponse.Builder baseResBuilder=BrokerMessage.BaseResponse.newBuilder();
  baseResBuilder.setResCode(BrokerMessage.ResCode.RES_CODE_FAIL);
  ZKData zkData=ZKData.getInstance();
  Map<String,Map<Integer,Integer>> topicMap=zkData.getTopicMap();
  Map<Integer,Integer> queueMap=topicMap.get(request.getTopic());
  if (queueMap == null) {
    String message=""String_Node_Str"";
    baseResBuilder.setResMsg(message);
    responseBuilder.setBaseRes(baseResBuilder.build());
    LOG.info(""String_Node_Str"",request.getTopic(),request.getQueue(),responseBuilder.getBaseRes().getResCode(),responseBuilder.getBaseRes().getResMsg());
    return responseBuilder.build();
  }
  GlobalConf conf=GlobalConf.getInstance();
  Integer shardingId=queueMap.get(request.getQueue());
  if (shardingId == null || shardingId != conf.getShardingId()) {
    String message=""String_Node_Str"";
    baseResBuilder.setResMsg(message);
    responseBuilder.setBaseRes(baseResBuilder.build());
    LOG.info(""String_Node_Str"",request.getTopic(),request.getQueue(),responseBuilder.getBaseRes().getResCode(),responseBuilder.getBaseRes().getResMsg());
    return responseBuilder.build();
  }
  if (raftNode.getLeaderId() <= 0) {
    baseResBuilder.setResMsg(""String_Node_Str"");
    responseBuilder.setBaseRes(baseResBuilder);
  }
 else   if (raftNode.getLeaderId() != raftNode.getLocalServer().getServerId()) {
    RPCClient rpcClient=raftNode.getPeerMap().get(raftNode.getLeaderId()).getRpcClient();
    BrokerAPI brokerAPI=RPCProxy.getProxy(rpcClient,BrokerAPI.class);
    BrokerMessage.SendMessageResponse responseFromLeader=brokerAPI.sendMessage(request);
    responseBuilder.mergeFrom(responseFromLeader);
  }
 else {
    byte[] data=request.toByteArray();
    boolean success=raftNode.replicate(data,RaftMessage.EntryType.ENTRY_TYPE_DATA);
    baseResBuilder.setResCode(success ? BrokerMessage.ResCode.RES_CODE_SUCCESS : BrokerMessage.ResCode.RES_CODE_FAIL);
    responseBuilder.setBaseRes(baseResBuilder);
  }
  BrokerMessage.SendMessageResponse response=responseBuilder.build();
  LOG.info(""String_Node_Str"",request.getTopic(),request.getQueue(),responseBuilder.getBaseRes().getResCode(),responseBuilder.getBaseRes().getResMsg());
  return response;
}","@Override public BrokerMessage.SendMessageResponse sendMessage(BrokerMessage.SendMessageRequest request){
  BrokerMessage.SendMessageResponse.Builder responseBuilder=BrokerMessage.SendMessageResponse.newBuilder();
  BrokerMessage.BaseResponse.Builder baseResBuilder=BrokerMessage.BaseResponse.newBuilder();
  baseResBuilder.setResCode(BrokerMessage.ResCode.RES_CODE_FAIL);
  ZKData zkData=ZKData.getInstance();
  GlobalConf conf=GlobalConf.getInstance();
  zkData.getTopicLock().lock();
  Map<String,Map<Integer,Integer>> topicMap=zkData.getTopicMap();
  Map<Integer,Integer> queueMap=topicMap.get(request.getTopic());
  if (queueMap == null || !queueMap.containsKey(request.getQueue()) || queueMap.get(request.getQueue()) != conf.getShardingId()) {
    queueMap=zkClient.readTopicInfo(request.getTopic());
    zkData.getTopicLock().lock();
    try {
      zkData.getTopicMap().put(request.getTopic(),queueMap);
    }
  finally {
      zkData.getTopicLock().unlock();
    }
    if (queueMap == null || !queueMap.containsKey(request.getQueue()) || queueMap.get(request.getQueue()) != conf.getShardingId()) {
      String message=""String_Node_Str"";
      baseResBuilder.setResMsg(message);
      responseBuilder.setBaseRes(baseResBuilder.build());
      LOG.info(""String_Node_Str"",request.getTopic(),request.getQueue(),responseBuilder.getBaseRes().getResCode(),responseBuilder.getBaseRes().getResMsg());
      return responseBuilder.build();
    }
  }
  if (raftNode.getLeaderId() <= 0) {
    baseResBuilder.setResMsg(""String_Node_Str"");
    responseBuilder.setBaseRes(baseResBuilder);
  }
 else   if (raftNode.getLeaderId() != raftNode.getLocalServer().getServerId()) {
    RPCClient rpcClient=raftNode.getPeerMap().get(raftNode.getLeaderId()).getRpcClient();
    BrokerAPI brokerAPI=RPCProxy.getProxy(rpcClient,BrokerAPI.class);
    BrokerMessage.SendMessageResponse responseFromLeader=brokerAPI.sendMessage(request);
    responseBuilder.mergeFrom(responseFromLeader);
  }
 else {
    byte[] data=request.toByteArray();
    boolean success=raftNode.replicate(data,RaftMessage.EntryType.ENTRY_TYPE_DATA);
    baseResBuilder.setResCode(success ? BrokerMessage.ResCode.RES_CODE_SUCCESS : BrokerMessage.ResCode.RES_CODE_FAIL);
    responseBuilder.setBaseRes(baseResBuilder);
  }
  BrokerMessage.SendMessageResponse response=responseBuilder.build();
  LOG.info(""String_Node_Str"",request.getTopic(),request.getQueue(),responseBuilder.getBaseRes().getResCode(),responseBuilder.getBaseRes().getResMsg());
  return response;
}",0.7912308930008045
175710,"public static void main(String[] args){
  GlobalConf conf=GlobalConf.getInstance();
  RaftMessage.Server localServer=conf.getLocalServer();
  List<RaftMessage.Server> servers=conf.getServers();
  String dataDir=conf.getDataDir();
  RPCServer server=new RPCServer(localServer.getEndPoint().getPort());
  BrokerStateMachine stateMachine=new BrokerStateMachine();
  RaftOptions.dataDir=dataDir;
  RaftNode raftNode=new RaftNode(servers,localServer,stateMachine);
  RaftConsensusService raftConsensusService=new RaftConsensusServiceImpl(raftNode);
  server.registerService(raftConsensusService);
  RaftClientService raftClientService=new RaftClientServiceImpl(raftNode);
  server.registerService(raftClientService);
  BrokerAPIImpl brokerAPI=new BrokerAPIImpl(raftNode,stateMachine);
  server.registerService(brokerAPI);
  server.start();
  raftNode.init();
  ZKConf zkConf=conf.getZkConf();
  ZKClient zkClient=new ZKClient(zkConf);
  zkClient.subscribeBroker();
  zkClient.subscribeTopic();
  while (ConfigurationUtils.containsServer(raftNode.getConfiguration(),conf.getLocalServer().getServerId())) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException ex) {
      ex.printStackTrace();
    }
  }
  zkClient.registerBroker(conf.getShardingId(),conf.getLocalServer().getEndPoint().getHost(),conf.getLocalServer().getEndPoint().getPort());
}","public static void main(String[] args){
  GlobalConf conf=GlobalConf.getInstance();
  RaftMessage.Server localServer=conf.getLocalServer();
  List<RaftMessage.Server> servers=conf.getServers();
  String dataDir=conf.getDataDir();
  ZKConf zkConf=conf.getZkConf();
  ZKClient zkClient=new ZKClient(zkConf);
  RPCServer server=new RPCServer(localServer.getEndPoint().getPort());
  BrokerStateMachine stateMachine=new BrokerStateMachine();
  RaftOptions.dataDir=dataDir;
  RaftNode raftNode=new RaftNode(servers,localServer,stateMachine);
  RaftConsensusService raftConsensusService=new RaftConsensusServiceImpl(raftNode);
  server.registerService(raftConsensusService);
  RaftClientService raftClientService=new RaftClientServiceImpl(raftNode);
  server.registerService(raftClientService);
  BrokerAPIImpl brokerAPI=new BrokerAPIImpl(raftNode,stateMachine,zkClient);
  server.registerService(brokerAPI);
  server.start();
  raftNode.init();
  zkClient.subscribeBroker();
  zkClient.subscribeTopic();
  while (!ConfigurationUtils.containsServer(raftNode.getConfiguration(),conf.getLocalServer().getServerId())) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException ex) {
      ex.printStackTrace();
    }
  }
  zkClient.registerBroker(conf.getShardingId(),conf.getLocalServer().getEndPoint().getHost(),conf.getLocalServer().getEndPoint().getPort());
}",0.9407027818448024
175711,"private ZKConf readZKConf(){
  zkConf=new ZKConf();
  zkConf.setServers(toml.getString(""String_Node_Str""));
  zkConf.setConnectTimeoutMs(toml.getLong(""String_Node_Str"").intValue());
  zkConf.setSessionTimeoutMs(toml.getLong(""String_Node_Str"").intValue());
  zkConf.setRetryCount(toml.getLong(""String_Node_Str"").intValue());
  zkConf.setRetryIntervalMs(toml.getLong(""String_Node_Str"").intValue());
  zkConf.setBasePath(toml.getString(""String_Node_Str""));
  return zkConf;
}","private ZKConf readZKConf(){
  Toml zookeeperToml=toml.getTable(""String_Node_Str"");
  zkConf=new ZKConf();
  zkConf.setServers(zookeeperToml.getString(""String_Node_Str""));
  zkConf.setConnectTimeoutMs(zookeeperToml.getLong(""String_Node_Str"").intValue());
  zkConf.setSessionTimeoutMs(zookeeperToml.getLong(""String_Node_Str"").intValue());
  zkConf.setRetryCount(zookeeperToml.getLong(""String_Node_Str"").intValue());
  zkConf.setRetryIntervalMs(zookeeperToml.getLong(""String_Node_Str"").intValue());
  zkConf.setBasePath(zookeeperToml.getString(""String_Node_Str""));
  return zkConf;
}",0.8850902184235517
175712,"public byte[] read(long offset){
  if (offset >= startOffset + fileSize) {
    LOG.warn(""String_Node_Str"",offset);
    return null;
  }
  try {
    channel.position(offset - startOffset);
    ByteBuffer headerBuffer=ByteBuffer.allocate(MESSAGE_HEADER_LENGTH);
    int readLen=channel.read(headerBuffer);
    if (readLen < MESSAGE_HEADER_LENGTH) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    long crc32=headerBuffer.getLong();
    int messageLen=headerBuffer.getInt();
    ByteBuffer messageContentBuffer=ByteBuffer.allocate(messageLen);
    readLen=channel.read(messageContentBuffer);
    if (readLen < messageLen) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    if (BrokerUtils.getCRC32(messageContentBuffer.array()) != crc32) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    return messageContentBuffer.array();
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"",dirName,fileName,offset);
    return null;
  }
}","public byte[] read(long offset){
  if (offset >= startOffset + fileSize) {
    LOG.warn(""String_Node_Str"",offset);
    return null;
  }
  try {
    channel.position(offset - startOffset);
    ByteBuffer headerBuffer=ByteBuffer.allocate(MESSAGE_HEADER_LENGTH);
    int readLen=channel.read(headerBuffer);
    if (readLen < MESSAGE_HEADER_LENGTH) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    headerBuffer.flip();
    long crc32=headerBuffer.getLong();
    int messageLen=headerBuffer.getInt();
    ByteBuffer messageContentBuffer=ByteBuffer.allocate(messageLen);
    readLen=channel.read(messageContentBuffer);
    if (readLen != messageLen) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    if (BrokerUtils.getCRC32(messageContentBuffer.array()) != crc32) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    return messageContentBuffer.array();
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"",dirName,fileName,offset);
    return null;
  }
}",0.9859013091641492
175713,"public long append(byte[] messageContent){
  long offset=0;
  try {
    int writeSize;
    ByteBuffer byteBuffer=ByteBuffer.allocate(Segment.SEGMENT_HEADER_LENGTH + Segment.MESSAGE_HEADER_LENGTH + +messageContent.length);
    if (fileSize == 0) {
      byteBuffer.putLong(System.currentTimeMillis());
      byteBuffer.putLong(BrokerUtils.getCRC32(messageContent));
      byteBuffer.putInt(messageContent.length);
      byteBuffer.put(messageContent);
      writeSize=channel.write(byteBuffer);
      offset=startOffset;
      endOffset=startOffset + writeSize;
    }
 else {
      byteBuffer.putLong(BrokerUtils.getCRC32(messageContent));
      byteBuffer.putInt(messageContent.length);
      byteBuffer.put(messageContent);
      writeSize=channel.write(byteBuffer);
      offset=endOffset;
      endOffset+=writeSize;
    }
    fileSize+=writeSize;
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"",ex);
  }
  return offset;
}","public long append(byte[] messageContent){
  long offset=0;
  try {
    int writeSize;
    ByteBuffer byteBuffer=ByteBuffer.allocate(Segment.SEGMENT_HEADER_LENGTH + Segment.MESSAGE_HEADER_LENGTH + +messageContent.length);
    if (fileSize == 0) {
      byteBuffer.putLong(System.currentTimeMillis());
      byteBuffer.putLong(BrokerUtils.getCRC32(messageContent));
      byteBuffer.putInt(messageContent.length);
      byteBuffer.put(messageContent);
      byteBuffer.flip();
      writeSize=channel.write(byteBuffer);
      channel.force(true);
      offset=startOffset;
      endOffset=startOffset + writeSize;
    }
 else {
      byteBuffer.putLong(BrokerUtils.getCRC32(messageContent));
      byteBuffer.putInt(messageContent.length);
      byteBuffer.put(messageContent);
      byteBuffer.flip();
      channel.position(endOffset);
      writeSize=channel.write(byteBuffer);
      channel.force(true);
      offset=endOffset;
      endOffset+=writeSize;
    }
    fileSize+=writeSize;
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"",ex);
  }
  return offset;
}",0.9312221672439388
175714,"public long append(byte[] messageContent){
  boolean isNeedNewSegmentFile=false;
  int segmentSize=startOffsetSegmentMap.size();
  try {
    if (segmentSize == 0) {
      isNeedNewSegmentFile=true;
    }
 else {
      Segment lastSegment=startOffsetSegmentMap.lastEntry().getValue();
      if (!lastSegment.isCanWrite()) {
        isNeedNewSegmentFile=true;
      }
 else {
        int maxSegmentSize=GlobalConf.getInstance().getMaxSegmentSize();
        if (lastSegment.getFileSize() + messageContent.length > maxSegmentSize) {
          isNeedNewSegmentFile=true;
        }
        lastSegment.close();
        lastSegment.setCanWrite(false);
        String newFileName=String.format(""String_Node_Str"",lastSegment.getStartOffset(),lastSegment.getEndOffset());
        String newFullFileName=segmentDir + File.separator + newFileName;
        File newFile=new File(newFullFileName);
        newFile.createNewFile();
        String oldFullFileName=segmentDir + File.separator + lastSegment.getFileName();
        File oldFile=new File(oldFullFileName);
        oldFile.renameTo(newFile);
        lastSegment.setFileName(newFileName);
        lastSegment.setRandomAccessFile(RaftFileUtils.openFile(segmentDir,newFileName,""String_Node_Str""));
        lastSegment.setChannel(lastSegment.getRandomAccessFile().getChannel());
      }
    }
    Segment newSegment;
    if (isNeedNewSegmentFile) {
      long newStartOffset=getLastEndOffset() + Segment.SEGMENT_HEADER_LENGTH;
      String newSegmentFileName=String.format(""String_Node_Str"",newStartOffset);
      String newFullFileName=segmentDir + File.separator + newSegmentFileName;
      File newSegmentFile=new File(newFullFileName);
      if (!newSegmentFile.exists()) {
        newSegmentFile.createNewFile();
      }
      newSegment=new Segment(segmentDir,newSegmentFileName);
    }
 else {
      newSegment=startOffsetSegmentMap.lastEntry().getValue();
    }
    return newSegment.append(messageContent);
  }
 catch (  IOException ex) {
    throw new RuntimeException(""String_Node_Str"" + ex.getMessage());
  }
}","public long append(byte[] messageContent){
  boolean isNeedNewSegmentFile=false;
  int segmentSize=startOffsetSegmentMap.size();
  try {
    if (segmentSize == 0) {
      isNeedNewSegmentFile=true;
    }
 else {
      Segment lastSegment=startOffsetSegmentMap.lastEntry().getValue();
      if (!lastSegment.isCanWrite()) {
        isNeedNewSegmentFile=true;
      }
 else {
        int maxSegmentSize=GlobalConf.getInstance().getMaxSegmentSize();
        if (lastSegment.getFileSize() + messageContent.length > maxSegmentSize) {
          isNeedNewSegmentFile=true;
          lastSegment.close();
          lastSegment.setCanWrite(false);
          String newFileName=String.format(""String_Node_Str"",lastSegment.getStartOffset(),lastSegment.getEndOffset());
          String newFullFileName=segmentDir + File.separator + newFileName;
          File newFile=new File(newFullFileName);
          newFile.createNewFile();
          String oldFullFileName=segmentDir + File.separator + lastSegment.getFileName();
          File oldFile=new File(oldFullFileName);
          oldFile.renameTo(newFile);
          lastSegment.setFileName(newFileName);
          lastSegment.setRandomAccessFile(RaftFileUtils.openFile(segmentDir,newFileName,""String_Node_Str""));
          lastSegment.setChannel(lastSegment.getRandomAccessFile().getChannel());
        }
      }
    }
    Segment newSegment;
    if (isNeedNewSegmentFile) {
      long newStartOffset=getLastEndOffset();
      String newSegmentFileName=String.format(""String_Node_Str"",newStartOffset);
      String newFullFileName=segmentDir + File.separator + newSegmentFileName;
      File newSegmentFile=new File(newFullFileName);
      if (!newSegmentFile.exists()) {
        newSegmentFile.createNewFile();
      }
      newSegment=new Segment(segmentDir,newSegmentFileName);
      startOffsetSegmentMap.put(newSegment.getStartOffset(),newSegment);
    }
 else {
      newSegment=startOffsetSegmentMap.lastEntry().getValue();
    }
    return newSegment.append(messageContent);
  }
 catch (  IOException ex) {
    throw new RuntimeException(""String_Node_Str"" + ex.getMessage());
  }
}",0.9472931075602194
175715,"@Override public BrokerMessage.SendMessageResponse sendMessage(BrokerMessage.SendMessageRequest request){
  BrokerMessage.SendMessageResponse.Builder responseBuilder=BrokerMessage.SendMessageResponse.newBuilder();
  BrokerMessage.BaseResponse.Builder baseResBuilder=BrokerMessage.BaseResponse.newBuilder();
  baseResBuilder.setResCode(BrokerMessage.ResCode.RES_CODE_FAIL);
  ZKData zkData=ZKData.getInstance();
  GlobalConf conf=GlobalConf.getInstance();
  zkData.getTopicLock().lock();
  Map<String,Map<Integer,Integer>> topicMap=zkData.getTopicMap();
  Map<Integer,Integer> queueMap=topicMap.get(request.getTopic());
  if (queueMap == null || !queueMap.containsKey(request.getQueue()) || queueMap.get(request.getQueue()) != conf.getShardingId()) {
    queueMap=zkClient.readTopicInfo(request.getTopic());
    zkData.getTopicLock().lock();
    try {
      zkData.getTopicMap().put(request.getTopic(),queueMap);
    }
  finally {
      zkData.getTopicLock().unlock();
    }
    if (queueMap == null || !queueMap.containsKey(request.getQueue()) || queueMap.get(request.getQueue()) != conf.getShardingId()) {
      String message=""String_Node_Str"";
      baseResBuilder.setResMsg(message);
      responseBuilder.setBaseRes(baseResBuilder.build());
      LOG.info(""String_Node_Str"",request.getTopic(),request.getQueue(),responseBuilder.getBaseRes().getResCode(),responseBuilder.getBaseRes().getResMsg());
      return responseBuilder.build();
    }
  }
  if (raftNode.getLeaderId() <= 0) {
    baseResBuilder.setResMsg(""String_Node_Str"");
    responseBuilder.setBaseRes(baseResBuilder);
  }
 else   if (raftNode.getLeaderId() != raftNode.getLocalServer().getServerId()) {
    RPCClient rpcClient=raftNode.getPeerMap().get(raftNode.getLeaderId()).getRpcClient();
    BrokerAPI brokerAPI=RPCProxy.getProxy(rpcClient,BrokerAPI.class);
    BrokerMessage.SendMessageResponse responseFromLeader=brokerAPI.sendMessage(request);
    responseBuilder.mergeFrom(responseFromLeader);
  }
 else {
    byte[] data=request.toByteArray();
    boolean success=raftNode.replicate(data,RaftMessage.EntryType.ENTRY_TYPE_DATA);
    baseResBuilder.setResCode(success ? BrokerMessage.ResCode.RES_CODE_SUCCESS : BrokerMessage.ResCode.RES_CODE_FAIL);
    responseBuilder.setBaseRes(baseResBuilder);
  }
  BrokerMessage.SendMessageResponse response=responseBuilder.build();
  LOG.info(""String_Node_Str"",request.getTopic(),request.getQueue(),responseBuilder.getBaseRes().getResCode(),responseBuilder.getBaseRes().getResMsg());
  return response;
}","@Override public BrokerMessage.SendMessageResponse sendMessage(BrokerMessage.SendMessageRequest request){
  BrokerMessage.SendMessageResponse.Builder responseBuilder=BrokerMessage.SendMessageResponse.newBuilder();
  BrokerMessage.BaseResponse.Builder baseResBuilder=BrokerMessage.BaseResponse.newBuilder();
  baseResBuilder.setResCode(BrokerMessage.ResCode.RES_CODE_FAIL);
  ZKData zkData=ZKData.getInstance();
  GlobalConf conf=GlobalConf.getInstance();
  Map<String,Map<Integer,Integer>> topicMap=zkData.getTopicMap();
  Map<Integer,Integer> queueMap=topicMap.get(request.getTopic());
  if (queueMap == null || !queueMap.containsKey(request.getQueue()) || queueMap.get(request.getQueue()) != conf.getShardingId()) {
    queueMap=zkClient.readTopicInfo(request.getTopic());
    zkData.getTopicLock().lock();
    try {
      zkData.getTopicMap().put(request.getTopic(),queueMap);
    }
  finally {
      zkData.getTopicLock().unlock();
    }
    if (queueMap == null || !queueMap.containsKey(request.getQueue()) || queueMap.get(request.getQueue()) != conf.getShardingId()) {
      String message=""String_Node_Str"";
      baseResBuilder.setResMsg(message);
      responseBuilder.setBaseRes(baseResBuilder.build());
      LOG.info(""String_Node_Str"",request.getTopic(),request.getQueue(),responseBuilder.getBaseRes().getResCode(),responseBuilder.getBaseRes().getResMsg());
      return responseBuilder.build();
    }
  }
  if (raftNode.getLeaderId() <= 0) {
    baseResBuilder.setResMsg(""String_Node_Str"");
    responseBuilder.setBaseRes(baseResBuilder);
  }
 else   if (raftNode.getLeaderId() != raftNode.getLocalServer().getServerId()) {
    RPCClient rpcClient=raftNode.getPeerMap().get(raftNode.getLeaderId()).getRpcClient();
    BrokerAPI brokerAPI=RPCProxy.getProxy(rpcClient,BrokerAPI.class);
    BrokerMessage.SendMessageResponse responseFromLeader=brokerAPI.sendMessage(request);
    if (responseFromLeader == null) {
      baseResBuilder.setResMsg(""String_Node_Str"");
      responseBuilder.setBaseRes(baseResBuilder);
    }
 else {
      responseBuilder.mergeFrom(responseFromLeader);
    }
  }
 else {
    byte[] data=request.toByteArray();
    boolean success=raftNode.replicate(data,RaftMessage.EntryType.ENTRY_TYPE_DATA);
    baseResBuilder.setResCode(success ? BrokerMessage.ResCode.RES_CODE_SUCCESS : BrokerMessage.ResCode.RES_CODE_FAIL);
    responseBuilder.setBaseRes(baseResBuilder);
  }
  BrokerMessage.SendMessageResponse response=responseBuilder.build();
  LOG.info(""String_Node_Str"",request.getTopic(),request.getQueue(),responseBuilder.getBaseRes().getResCode(),responseBuilder.getBaseRes().getResMsg());
  return response;
}",0.9521595971334496
175716,"public BrokerMessage.PullMessageResponse pullMessage(BrokerMessage.PullMessageRequest request){
  BrokerMessage.PullMessageResponse.Builder responseBuilder=BrokerMessage.PullMessageResponse.newBuilder();
  SegmentedLog segmentedLog=logManager.getOrCreateQueueLog(request.getTopic(),request.getQueue());
  int readCount=0;
  long offset=request.getOffset();
  if (offset == 0) {
    offset=Segment.SEGMENT_HEADER_LENGTH;
  }
  while (readCount < request.getMessageCount()) {
    byte[] messageBytes=segmentedLog.read(offset);
    if (messageBytes == null) {
      break;
    }
    BrokerMessage.MessageContent message=BrokerMessage.MessageContent.newBuilder().setTopic(request.getTopic()).setQueue(request.getQueue()).setOffset(offset).setContent(ByteString.copyFrom(messageBytes)).build();
    responseBuilder.addContents(message);
    offset+=messageBytes.length + Segment.MESSAGE_HEADER_LENGTH;
  }
  return responseBuilder.build();
}","public BrokerMessage.PullMessageResponse pullMessage(BrokerMessage.PullMessageRequest request){
  BrokerMessage.PullMessageResponse.Builder responseBuilder=BrokerMessage.PullMessageResponse.newBuilder();
  SegmentedLog segmentedLog=logManager.getOrCreateQueueLog(request.getTopic(),request.getQueue());
  int readCount=0;
  long offset=request.getOffset();
  while (readCount < request.getMessageCount()) {
    BrokerMessage.MessageContent message=segmentedLog.read(offset);
    if (message == null) {
      break;
    }
    responseBuilder.addContents(message);
    offset=message.getOffset() + message.getSize();
    readCount++;
  }
  return responseBuilder.build();
}",0.5152457996266335
175717,"@Override public void apply(byte[] dataBytes){
  try {
    BrokerMessage.SendMessageRequest request=BrokerMessage.SendMessageRequest.parseFrom(dataBytes);
    SegmentedLog segmentedLog=logManager.getOrCreateQueueLog(request.getTopic(),request.getQueue());
    segmentedLog.append(request.getContent().toByteArray());
  }
 catch (  Exception ex) {
    LOG.warn(""String_Node_Str"",ex);
  }
}","@Override public void apply(byte[] dataBytes){
  try {
    BrokerMessage.SendMessageRequest request=BrokerMessage.SendMessageRequest.parseFrom(dataBytes);
    BrokerMessage.MessageContent.Builder message=BrokerMessage.MessageContent.newBuilder().setTopic(request.getTopic()).setQueue(request.getQueue()).setContent(request.getContent());
    SegmentedLog segmentedLog=logManager.getOrCreateQueueLog(request.getTopic(),request.getQueue());
    segmentedLog.append(message);
  }
 catch (  Exception ex) {
    LOG.warn(""String_Node_Str"",ex);
  }
}",0.759656652360515
175718,"public byte[] read(long offset){
  if (offset >= startOffset + fileSize) {
    LOG.warn(""String_Node_Str"",offset);
    return null;
  }
  try {
    channel.position(offset - startOffset);
    ByteBuffer headerBuffer=ByteBuffer.allocate(MESSAGE_HEADER_LENGTH);
    int readLen=channel.read(headerBuffer);
    if (readLen < MESSAGE_HEADER_LENGTH) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    headerBuffer.flip();
    long crc32=headerBuffer.getLong();
    int messageLen=headerBuffer.getInt();
    ByteBuffer messageContentBuffer=ByteBuffer.allocate(messageLen);
    readLen=channel.read(messageContentBuffer);
    if (readLen != messageLen) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    if (BrokerUtils.getCRC32(messageContentBuffer.array()) != crc32) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    return messageContentBuffer.array();
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"",dirName,fileName,offset);
    return null;
  }
}","public BrokerMessage.MessageContent read(long offset){
  if (offset >= startOffset + fileSize) {
    LOG.warn(""String_Node_Str"",offset);
    return null;
  }
  try {
    channel.position(offset - startOffset);
    ByteBuffer headerBuffer=ByteBuffer.allocate(MESSAGE_HEADER_LENGTH);
    int readLen=channel.read(headerBuffer);
    if (readLen != MESSAGE_HEADER_LENGTH) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    headerBuffer.flip();
    long crc32=headerBuffer.getLong();
    int messageLen=headerBuffer.getInt();
    LOG.info(""String_Node_Str"",messageLen);
    ByteBuffer messageContentBuffer=ByteBuffer.allocate(messageLen);
    readLen=channel.read(messageContentBuffer);
    if (readLen != messageLen) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    if (BrokerUtils.getCRC32(messageContentBuffer.array()) != crc32) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    BrokerMessage.MessageContent message=BrokerMessage.MessageContent.parseFrom(messageContentBuffer.array());
    BrokerMessage.MessageContent result=BrokerMessage.MessageContent.newBuilder().mergeFrom(message).setSize(MESSAGE_HEADER_LENGTH + messageLen).build();
    return result;
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"",dirName,fileName,offset);
    return null;
  }
}",0.8535745047372955
175719,"public long append(byte[] messageContent){
  long offset=0;
  try {
    int writeSize;
    ByteBuffer byteBuffer=ByteBuffer.allocate(Segment.SEGMENT_HEADER_LENGTH + Segment.MESSAGE_HEADER_LENGTH + +messageContent.length);
    if (fileSize == 0) {
      byteBuffer.putLong(System.currentTimeMillis());
      byteBuffer.putLong(BrokerUtils.getCRC32(messageContent));
      byteBuffer.putInt(messageContent.length);
      byteBuffer.put(messageContent);
      byteBuffer.flip();
      writeSize=channel.write(byteBuffer);
      channel.force(true);
      offset=startOffset;
      endOffset=startOffset + writeSize;
    }
 else {
      byteBuffer.putLong(BrokerUtils.getCRC32(messageContent));
      byteBuffer.putInt(messageContent.length);
      byteBuffer.put(messageContent);
      byteBuffer.flip();
      channel.position(endOffset);
      writeSize=channel.write(byteBuffer);
      channel.force(true);
      offset=endOffset;
      endOffset+=writeSize;
    }
    fileSize+=writeSize;
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"",ex);
  }
  return offset;
}","public boolean append(BrokerMessage.MessageContent.Builder messageBuilder){
  try {
    if (fileSize == 0) {
      messageBuilder.setOffset(startOffset);
    }
 else {
      messageBuilder.setOffset(endOffset);
    }
    messageBuilder.setCreateTime(System.currentTimeMillis());
    BrokerMessage.MessageContent message=messageBuilder.build();
    byte[] messageBytes=message.toByteArray();
    int totalSize=Segment.MESSAGE_HEADER_LENGTH + messageBytes.length;
    ByteBuffer byteBuffer=ByteBuffer.allocate(totalSize);
    byteBuffer.putLong(BrokerUtils.getCRC32(messageBytes));
    byteBuffer.putInt(messageBytes.length);
    byteBuffer.put(messageBytes);
    byteBuffer.flip();
    int writeSize=channel.write(byteBuffer);
    channel.force(true);
    if (writeSize != totalSize) {
      LOG.warn(""String_Node_Str"");
      return false;
    }
    if (fileSize == 0) {
      endOffset=startOffset + writeSize;
    }
 else {
      endOffset+=writeSize;
    }
    fileSize+=writeSize;
  }
 catch (  IOException ex) {
    LOG.warn(""String_Node_Str"",ex);
    return false;
  }
  return true;
}",0.4477199447259327
175720,"public byte[] read(long offset){
  Map.Entry<Long,Segment> entry=startOffsetSegmentMap.floorEntry(offset);
  if (entry == null) {
    LOG.warn(""String_Node_Str"",offset);
    return null;
  }
  Segment segment=entry.getValue();
  return segment.read(offset);
}","public BrokerMessage.MessageContent read(long offset){
  Map.Entry<Long,Segment> entry=startOffsetSegmentMap.floorEntry(offset);
  if (entry == null) {
    LOG.warn(""String_Node_Str"",offset);
    return null;
  }
  Segment segment=entry.getValue();
  return segment.read(offset);
}",0.937037037037037
175721,"private void validateSegments(){
  long lastEndOffset=0;
  for (  Segment segment : startOffsetSegmentMap.values()) {
    if (lastEndOffset > 0 && segment.getStartOffset() != lastEndOffset + Segment.SEGMENT_HEADER_LENGTH) {
      throw new RuntimeException(""String_Node_Str"" + segmentDir);
    }
    lastEndOffset=segment.getEndOffset();
  }
}","private void validateSegments(){
  long lastEndOffset=0;
  for (  Segment segment : startOffsetSegmentMap.values()) {
    if (lastEndOffset > 0 && segment.getStartOffset() != lastEndOffset) {
      throw new RuntimeException(""String_Node_Str"" + segmentDir);
    }
    lastEndOffset=segment.getEndOffset();
  }
}",0.9510703363914372
175722,"public long append(byte[] messageContent){
  boolean isNeedNewSegmentFile=false;
  int segmentSize=startOffsetSegmentMap.size();
  try {
    if (segmentSize == 0) {
      isNeedNewSegmentFile=true;
    }
 else {
      Segment lastSegment=startOffsetSegmentMap.lastEntry().getValue();
      if (!lastSegment.isCanWrite()) {
        isNeedNewSegmentFile=true;
      }
 else {
        int maxSegmentSize=GlobalConf.getInstance().getMaxSegmentSize();
        if (lastSegment.getFileSize() + messageContent.length > maxSegmentSize) {
          isNeedNewSegmentFile=true;
          lastSegment.close();
          lastSegment.setCanWrite(false);
          String newFileName=String.format(""String_Node_Str"",lastSegment.getStartOffset(),lastSegment.getEndOffset());
          String newFullFileName=segmentDir + File.separator + newFileName;
          File newFile=new File(newFullFileName);
          newFile.createNewFile();
          String oldFullFileName=segmentDir + File.separator + lastSegment.getFileName();
          File oldFile=new File(oldFullFileName);
          oldFile.renameTo(newFile);
          lastSegment.setFileName(newFileName);
          lastSegment.setRandomAccessFile(RaftFileUtils.openFile(segmentDir,newFileName,""String_Node_Str""));
          lastSegment.setChannel(lastSegment.getRandomAccessFile().getChannel());
        }
      }
    }
    Segment newSegment;
    if (isNeedNewSegmentFile) {
      long newStartOffset=getLastEndOffset();
      String newSegmentFileName=String.format(""String_Node_Str"",newStartOffset);
      String newFullFileName=segmentDir + File.separator + newSegmentFileName;
      File newSegmentFile=new File(newFullFileName);
      if (!newSegmentFile.exists()) {
        newSegmentFile.createNewFile();
      }
      newSegment=new Segment(segmentDir,newSegmentFileName);
      startOffsetSegmentMap.put(newSegment.getStartOffset(),newSegment);
    }
 else {
      newSegment=startOffsetSegmentMap.lastEntry().getValue();
    }
    return newSegment.append(messageContent);
  }
 catch (  IOException ex) {
    throw new RuntimeException(""String_Node_Str"" + ex.getMessage());
  }
}","public boolean append(BrokerMessage.MessageContent.Builder message){
  boolean isNeedNewSegmentFile=false;
  int segmentSize=startOffsetSegmentMap.size();
  try {
    if (segmentSize == 0) {
      isNeedNewSegmentFile=true;
    }
 else {
      Segment lastSegment=startOffsetSegmentMap.lastEntry().getValue();
      if (!lastSegment.isCanWrite()) {
        isNeedNewSegmentFile=true;
      }
 else {
        int maxSegmentSize=GlobalConf.getInstance().getMaxSegmentSize();
        if (lastSegment.getFileSize() + message.build().getSerializedSize() > maxSegmentSize) {
          isNeedNewSegmentFile=true;
          lastSegment.close();
          lastSegment.setCanWrite(false);
          String newFileName=String.format(""String_Node_Str"",lastSegment.getStartOffset(),lastSegment.getEndOffset());
          String newFullFileName=segmentDir + File.separator + newFileName;
          File newFile=new File(newFullFileName);
          newFile.createNewFile();
          String oldFullFileName=segmentDir + File.separator + lastSegment.getFileName();
          File oldFile=new File(oldFullFileName);
          oldFile.renameTo(newFile);
          lastSegment.setFileName(newFileName);
          lastSegment.setRandomAccessFile(RaftFileUtils.openFile(segmentDir,newFileName,""String_Node_Str""));
          lastSegment.setChannel(lastSegment.getRandomAccessFile().getChannel());
        }
      }
    }
    Segment newSegment;
    if (isNeedNewSegmentFile) {
      long newStartOffset=getLastEndOffset();
      String newSegmentFileName=String.format(""String_Node_Str"",newStartOffset);
      String newFullFileName=segmentDir + File.separator + newSegmentFileName;
      File newSegmentFile=new File(newFullFileName);
      if (!newSegmentFile.exists()) {
        newSegmentFile.createNewFile();
      }
      newSegment=new Segment(segmentDir,newSegmentFileName);
      startOffsetSegmentMap.put(newSegment.getStartOffset(),newSegment);
    }
 else {
      newSegment=startOffsetSegmentMap.lastEntry().getValue();
    }
    return newSegment.append(message);
  }
 catch (  IOException ex) {
    throw new RuntimeException(""String_Node_Str"" + ex.getMessage());
  }
}",0.9769284549056164
175723,"public void setDefaultCameraParameters(Camera camera,Camera.CameraInfo cameraInfo){
  Camera.Parameters parameters=camera.getParameters();
  parameters.setPictureFormat(ImageFormat.JPEG);
  List<Camera.Size> supportedSizes=parameters.getSupportedPictureSizes();
  Camera.Size pictureSize=getBestSize(supportedSizes,0);
  parameters.setPictureSize(pictureSize.width,pictureSize.height);
  float whRatio=(float)pictureSize.width / pictureSize.height;
  List<Camera.Size> previewSupportedSizes=parameters.getSupportedPreviewSizes();
  Camera.Size previewSize=getBestSize(previewSupportedSizes,whRatio);
  parameters.setPreviewSize(previewSize.width,previewSize.height);
  List<String> supportedFocusModes=camera.getParameters().getSupportedFocusModes();
  boolean hasAutoFocus=supportedFocusModes != null && supportedFocusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO);
  if (hasAutoFocus) {
    parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
  }
  if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) {
    parameters.setFlashMode(Camera.Parameters.FLASH_MODE_AUTO);
  }
  List<String> supportedScreenModes=camera.getParameters().getSupportedSceneModes();
  boolean hasAutoScene=supportedScreenModes != null && supportedFocusModes.contains(Camera.Parameters.SCENE_MODE_AUTO);
  if (hasAutoScene) {
    parameters.setSceneMode(Camera.Parameters.SCENE_MODE_AUTO);
  }
  parameters.setColorEffect(Camera.Parameters.EFFECT_NONE);
  int orientation=cameraInfo.orientation;
  parameters.setRotation(orientation);
  camera.setParameters(parameters);
}","public void setDefaultCameraParameters(Camera camera,Camera.CameraInfo cameraInfo){
  Camera.Parameters parameters=camera.getParameters();
  parameters.setPictureFormat(ImageFormat.JPEG);
  int orientation=cameraInfo.orientation;
  parameters.setRotation(orientation);
  List<Camera.Size> supportedSizes=parameters.getSupportedPictureSizes();
  List<Camera.Size> previewSupportedSizes=parameters.getSupportedPreviewSizes();
  Camera.Size previewSize=null, pictureSize=null;
  for (int i=supportedSizes.size() - 1; i >= 0; i--) {
    Camera.Size tempSize=supportedSizes.get(i);
    Camera.Size tempPreviewSize=null;
    float whRatio=(float)tempSize.width / tempSize.height;
    for (int j=previewSupportedSizes.size() - 1; j >= 0; j--) {
      Camera.Size size=previewSupportedSizes.get(j);
      float tempWHRatio=(float)size.width / size.height;
      if (tempWHRatio == whRatio) {
        if (tempPreviewSize == null || isNewSizeLarger(tempPreviewSize,size)) {
          tempPreviewSize=size;
        }
      }
    }
    if (tempPreviewSize != null) {
      if (pictureSize == null || isNewSizeLarger(pictureSize,tempSize)) {
        pictureSize=tempSize;
        previewSize=tempPreviewSize;
      }
    }
  }
  if (pictureSize == null) {
    pictureSize=supportedSizes.get(supportedSizes.size() - 1);
    previewSize=previewSupportedSizes.get(previewSupportedSizes.size() - 1);
  }
  parameters.setPictureSize(pictureSize.width,pictureSize.height);
  parameters.setPreviewSize(previewSize.width,previewSize.height);
  List<String> supportedFocusModes=camera.getParameters().getSupportedFocusModes();
  boolean hasAutoFocus=supportedFocusModes != null && supportedFocusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO);
  if (hasAutoFocus) {
    parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
  }
  if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) {
    parameters.setFlashMode(Camera.Parameters.FLASH_MODE_AUTO);
  }
  List<String> supportedScreenModes=camera.getParameters().getSupportedSceneModes();
  boolean hasAutoScene=supportedScreenModes != null && supportedFocusModes.contains(Camera.Parameters.SCENE_MODE_AUTO);
  if (hasAutoScene) {
    parameters.setSceneMode(Camera.Parameters.SCENE_MODE_AUTO);
  }
  parameters.setColorEffect(Camera.Parameters.EFFECT_NONE);
  camera.setParameters(parameters);
}",0.6262471220260937
175724,"public void setDefaultCameraParameters(Camera camera,Camera.CameraInfo cameraInfo){
  Camera.Parameters parameters=camera.getParameters();
  parameters.setPictureFormat(ImageFormat.JPEG);
  List<Camera.Size> supportedSizes=parameters.getSupportedPictureSizes();
  Camera.Size pictureSize=getBestSize(supportedSizes,0);
  parameters.setPictureSize(pictureSize.width,pictureSize.height);
  float whRatio=(float)pictureSize.width / pictureSize.height;
  List<Camera.Size> previewSupportedSizes=parameters.getSupportedPreviewSizes();
  Camera.Size previewSize=getBestSize(previewSupportedSizes,whRatio);
  parameters.setPreviewSize(previewSize.width,previewSize.height);
  parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
  if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) {
    parameters.setFlashMode(Camera.Parameters.FLASH_MODE_AUTO);
  }
  parameters.setColorEffect(Camera.Parameters.EFFECT_NONE);
  parameters.setSceneMode(Camera.Parameters.SCENE_MODE_AUTO);
  int orientation=cameraInfo.orientation;
  parameters.setRotation(orientation);
  camera.setParameters(parameters);
}","public void setDefaultCameraParameters(Camera camera,Camera.CameraInfo cameraInfo){
  Camera.Parameters parameters=camera.getParameters();
  parameters.setPictureFormat(ImageFormat.JPEG);
  List<Camera.Size> supportedSizes=parameters.getSupportedPictureSizes();
  Camera.Size pictureSize=getBestSize(supportedSizes,0);
  parameters.setPictureSize(pictureSize.width,pictureSize.height);
  float whRatio=(float)pictureSize.width / pictureSize.height;
  List<Camera.Size> previewSupportedSizes=parameters.getSupportedPreviewSizes();
  Camera.Size previewSize=getBestSize(previewSupportedSizes,whRatio);
  parameters.setPreviewSize(previewSize.width,previewSize.height);
  List<String> supportedFocusModes=camera.getParameters().getSupportedFocusModes();
  boolean hasAutoFocus=supportedFocusModes != null && supportedFocusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO);
  if (hasAutoFocus) {
    parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
  }
  if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) {
    parameters.setFlashMode(Camera.Parameters.FLASH_MODE_AUTO);
  }
  List<String> supportedScreenModes=camera.getParameters().getSupportedSceneModes();
  boolean hasAutoScene=supportedScreenModes != null && supportedFocusModes.contains(Camera.Parameters.SCENE_MODE_AUTO);
  if (hasAutoScene) {
    parameters.setSceneMode(Camera.Parameters.SCENE_MODE_AUTO);
  }
  parameters.setColorEffect(Camera.Parameters.EFFECT_NONE);
  int orientation=cameraInfo.orientation;
  parameters.setRotation(orientation);
  camera.setParameters(parameters);
}",0.6526946107784432
175725,"@Override public void onPictureTaken(byte[] data,Camera camera){
  FileOutputStream fos=null;
  try {
    File outputFile=ImageFileUtils.getImageOutputFile();
    Log.d(TAG,outputFile.getAbsolutePath());
    fos=new FileOutputStream(outputFile);
    fos.write(data);
    ImageFileUtils.addToGalleryAndNotify(getReactApplicationContext(),outputFile,promise);
  }
 catch (  IOException e) {
    e.printStackTrace();
    promise.reject(e);
  }
 finally {
    try {
      fos.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}","@Override public void onPictureTaken(byte[] data,Camera camera){
  FileOutputStream fos=null;
  try {
    File outputFile=ImageFileUtils.getImageOutputFile();
    Log.d(TAG,outputFile.getAbsolutePath());
    fos=new FileOutputStream(outputFile);
    fos.write(data);
    ImageFileUtils.addToGalleryAndNotify(getReactApplicationContext(),outputFile,promise);
  }
 catch (  IOException e) {
    e.printStackTrace();
    promise.reject(e);
  }
 finally {
    try {
      fos.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    camera.startPreview();
  }
}",0.9762114537444934
175726,"private void takePicture(Camera camera,final Promise promise){
  if (camera == null) {
    promise.reject(""String_Node_Str"");
  }
  camera.takePicture(null,null,new Camera.PictureCallback(){
    @Override public void onPictureTaken(    byte[] data,    Camera camera){
      FileOutputStream fos=null;
      try {
        File outputFile=ImageFileUtils.getImageOutputFile();
        Log.d(TAG,outputFile.getAbsolutePath());
        fos=new FileOutputStream(outputFile);
        fos.write(data);
        ImageFileUtils.addToGalleryAndNotify(getReactApplicationContext(),outputFile,promise);
      }
 catch (      IOException e) {
        e.printStackTrace();
        promise.reject(e);
      }
 finally {
        try {
          fos.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
  }
);
}","private void takePicture(Camera camera,final Promise promise){
  if (camera == null) {
    promise.reject(""String_Node_Str"");
  }
  camera.takePicture(null,null,new Camera.PictureCallback(){
    @Override public void onPictureTaken(    byte[] data,    Camera camera){
      FileOutputStream fos=null;
      try {
        File outputFile=ImageFileUtils.getImageOutputFile();
        Log.d(TAG,outputFile.getAbsolutePath());
        fos=new FileOutputStream(outputFile);
        fos.write(data);
        ImageFileUtils.addToGalleryAndNotify(getReactApplicationContext(),outputFile,promise);
      }
 catch (      IOException e) {
        e.printStackTrace();
        promise.reject(e);
      }
 finally {
        try {
          fos.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
        camera.startPreview();
      }
    }
  }
);
}",0.9820081253627394
175727,"@Override public void onRender(float partialTicks){
  GL11.glEnable(GL11.GL_BLEND);
  GL11.glBlendFunc(GL11.GL_SRC_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
  GL11.glEnable(GL11.GL_LINE_SMOOTH);
  GL11.glLineWidth(2);
  GL11.glDisable(GL11.GL_TEXTURE_2D);
  GL11.glEnable(GL11.GL_CULL_FACE);
  GL11.glDisable(GL11.GL_DEPTH_TEST);
  GL11.glPushMatrix();
  GL11.glTranslated(-mc.getRenderManager().renderPosX,-mc.getRenderManager().renderPosY,-mc.getRenderManager().renderPosZ);
  float alpha=0.5F + 0.25F * WMath.sin(System.currentTimeMillis() % 1000 / 500F * (float)Math.PI);
  GL11.glColor4f(1,0,0,alpha);
  for (  Entity entity : WMinecraft.getWorld().loadedEntityList) {
    if (!(entity instanceof EntityLiving))     continue;
    if (!entity.isInvisible())     continue;
    if (WMinecraft.getPlayer().getDistanceSqToEntity(entity) < 0.25)     continue;
    GL11.glPushMatrix();
    GL11.glTranslated(entity.posX,entity.posY,entity.posZ);
    RenderUtils.drawOutlinedBox(FAKE_BLOCK_BOX);
    RenderUtils.drawSolidBox(FAKE_BLOCK_BOX);
    GL11.glPopMatrix();
  }
  GL11.glPopMatrix();
  GL11.glEnable(GL11.GL_DEPTH_TEST);
  GL11.glEnable(GL11.GL_TEXTURE_2D);
  GL11.glDisable(GL11.GL_BLEND);
  GL11.glDisable(GL11.GL_LINE_SMOOTH);
}","@Override public void onRender(float partialTicks){
  GL11.glEnable(GL11.GL_BLEND);
  GL11.glBlendFunc(GL11.GL_SRC_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
  GL11.glEnable(GL11.GL_LINE_SMOOTH);
  GL11.glLineWidth(2);
  GL11.glDisable(GL11.GL_TEXTURE_2D);
  GL11.glEnable(GL11.GL_CULL_FACE);
  GL11.glDisable(GL11.GL_DEPTH_TEST);
  GL11.glPushMatrix();
  GL11.glTranslated(-mc.getRenderManager().renderPosX,-mc.getRenderManager().renderPosY,-mc.getRenderManager().renderPosZ);
  float alpha=0.5F + 0.25F * WMath.sin(System.currentTimeMillis() % 1000 / 500F * (float)Math.PI);
  GL11.glColor4f(1,0,0,alpha);
  for (  Entity entity : WMinecraft.getWorld().loadedEntityList) {
    if (!(entity instanceof EntityLiving))     continue;
    if (!entity.isInvisible())     continue;
    if (WMinecraft.getPlayer().getDistanceSqToEntity(entity) < 0.25)     continue;
    GL11.glPushMatrix();
    GL11.glTranslated(entity.posX,entity.posY,entity.posZ);
    RenderUtils.drawOutlinedBox(FAKE_BLOCK_BOX);
    RenderUtils.drawSolidBox(FAKE_BLOCK_BOX);
    GL11.glPopMatrix();
  }
  GL11.glPopMatrix();
  GL11.glColor4f(1,1,1,1);
  GL11.glEnable(GL11.GL_DEPTH_TEST);
  GL11.glEnable(GL11.GL_TEXTURE_2D);
  GL11.glDisable(GL11.GL_BLEND);
  GL11.glDisable(GL11.GL_LINE_SMOOTH);
}",0.9891435464414958
175728,"@Override public void onRender(float partialTicks){
  GL11.glEnable(GL11.GL_BLEND);
  GL11.glBlendFunc(GL11.GL_SRC_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
  GL11.glEnable(GL11.GL_LINE_SMOOTH);
  GL11.glLineWidth(2);
  GL11.glDisable(GL11.GL_TEXTURE_2D);
  GL11.glEnable(GL11.GL_CULL_FACE);
  GL11.glDisable(GL11.GL_DEPTH_TEST);
  GL11.glDisable(GL11.GL_LIGHTING);
  GL11.glPushMatrix();
  GL11.glTranslated(-mc.getRenderManager().renderPosX,-mc.getRenderManager().renderPosY,-mc.getRenderManager().renderPosZ);
  ArrayList<AxisAlignedBB> minecartBoxes=new ArrayList<>(minecarts.size());
  minecarts.forEach(e -> {
    double offsetX=-(e.posX - e.lastTickPosX) + (e.posX - e.lastTickPosX) * partialTicks;
    double offsetY=-(e.posY - e.lastTickPosY) + (e.posY - e.lastTickPosY) * partialTicks;
    double offsetZ=-(e.posZ - e.lastTickPosZ) + (e.posZ - e.lastTickPosZ) * partialTicks;
    minecartBoxes.add(e.boundingBox.offset(offsetX,offsetY,offsetZ));
  }
);
  GL11.glCallList(normalChests);
  GL11.glColor4f(0,1,0,0.25F);
  renderBoxes(minecartBoxes,solidBox);
  GL11.glColor4f(0,1,0,0.5F);
  renderBoxes(minecartBoxes,outlinedBox);
  GL11.glPopMatrix();
  GL11.glColor4f(1,1,1,1);
  GL11.glEnable(GL11.GL_DEPTH_TEST);
  GL11.glEnable(GL11.GL_TEXTURE_2D);
  GL11.glDisable(GL11.GL_BLEND);
  GL11.glDisable(GL11.GL_LINE_SMOOTH);
  GL11.glEnable(GL11.GL_LIGHTING);
}","@Override public void onRender(float partialTicks){
  GL11.glEnable(GL11.GL_BLEND);
  GL11.glBlendFunc(GL11.GL_SRC_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
  GL11.glEnable(GL11.GL_LINE_SMOOTH);
  GL11.glLineWidth(2);
  GL11.glDisable(GL11.GL_TEXTURE_2D);
  GL11.glEnable(GL11.GL_CULL_FACE);
  GL11.glDisable(GL11.GL_DEPTH_TEST);
  GL11.glPushMatrix();
  GL11.glTranslated(-mc.getRenderManager().renderPosX,-mc.getRenderManager().renderPosY,-mc.getRenderManager().renderPosZ);
  ArrayList<AxisAlignedBB> minecartBoxes=new ArrayList<>(minecarts.size());
  minecarts.forEach(e -> {
    double offsetX=-(e.posX - e.lastTickPosX) + (e.posX - e.lastTickPosX) * partialTicks;
    double offsetY=-(e.posY - e.lastTickPosY) + (e.posY - e.lastTickPosY) * partialTicks;
    double offsetZ=-(e.posZ - e.lastTickPosZ) + (e.posZ - e.lastTickPosZ) * partialTicks;
    minecartBoxes.add(e.boundingBox.offset(offsetX,offsetY,offsetZ));
  }
);
  GL11.glCallList(normalChests);
  GL11.glColor4f(0,1,0,0.25F);
  renderBoxes(minecartBoxes,solidBox);
  GL11.glColor4f(0,1,0,0.5F);
  renderBoxes(minecartBoxes,outlinedBox);
  GL11.glPopMatrix();
  GL11.glColor4f(1,1,1,1);
  GL11.glEnable(GL11.GL_DEPTH_TEST);
  GL11.glEnable(GL11.GL_TEXTURE_2D);
  GL11.glDisable(GL11.GL_BLEND);
  GL11.glDisable(GL11.GL_LINE_SMOOTH);
}",0.9732580037664784
175729,"@Override public void onRender(float partialTicks){
  GL11.glBlendFunc(GL11.GL_SRC_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
  GL11.glEnable(GL11.GL_LINE_SMOOTH);
  GL11.glLineWidth(2);
  for (  EntityItem e : items) {
    float x=(float)(e.prevPosX + (e.posX - e.prevPosX) * partialTicks - mc.getRenderManager().renderPosX);
    float y=(float)(e.prevPosY + (e.posY - e.prevPosY) * partialTicks - mc.getRenderManager().renderPosY);
    float z=(float)(e.prevPosZ + (e.posZ - e.prevPosZ) * partialTicks - mc.getRenderManager().renderPosZ);
    GL11.glPushMatrix();
    GL11.glTranslatef(x,y,z);
    GL11.glCallList(itemBox);
    GL11.glPopMatrix();
    if (names != null && names.isChecked()) {
      ItemStack stack=e.getEntityItem();
      WEntityRenderer.drawNameplate(mc.fontRendererObj,WItem.getStackSize(stack) + ""String_Node_Str"" + stack.getDisplayName(),x,y + 1,z,0,mc.getRenderManager().playerViewY,mc.getRenderManager().playerViewX,mc.gameSettings.thirdPersonView == 2,false);
    }
  }
  GL11.glColor4f(1,1,1,1);
  GL11.glEnable(GL11.GL_DEPTH_TEST);
  GL11.glEnable(GL11.GL_TEXTURE_2D);
  GL11.glDisable(GL11.GL_BLEND);
  GL11.glDisable(GL11.GL_LINE_SMOOTH);
}","@Override public void onRender(float partialTicks){
  GL11.glBlendFunc(GL11.GL_SRC_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
  GL11.glEnable(GL11.GL_LINE_SMOOTH);
  GL11.glLineWidth(2);
  for (  EntityItem e : items) {
    float x=(float)(e.prevPosX + (e.posX - e.prevPosX) * partialTicks - mc.getRenderManager().renderPosX);
    float y=(float)(e.prevPosY + (e.posY - e.prevPosY) * partialTicks - mc.getRenderManager().renderPosY);
    float z=(float)(e.prevPosZ + (e.posZ - e.prevPosZ) * partialTicks - mc.getRenderManager().renderPosZ);
    GL11.glPushMatrix();
    GL11.glTranslatef(x,y,z);
    GL11.glCallList(itemBox);
    GL11.glPopMatrix();
    if (names != null && names.isChecked()) {
      ItemStack stack=e.getEntityItem();
      WEntityRenderer.drawNameplate(mc.fontRendererObj,WItem.getStackSize(stack) + ""String_Node_Str"" + stack.getDisplayName(),x,y + 1,z,0,mc.getRenderManager().playerViewY,mc.getRenderManager().playerViewX,mc.gameSettings.thirdPersonView == 2,false);
      GL11.glDisable(GL11.GL_LIGHTING);
    }
  }
  GL11.glColor4f(1,1,1,1);
  GL11.glEnable(GL11.GL_DEPTH_TEST);
  GL11.glEnable(GL11.GL_TEXTURE_2D);
  GL11.glDisable(GL11.GL_BLEND);
  GL11.glDisable(GL11.GL_LINE_SMOOTH);
}",0.9831223628691984
175730,"@SuppressWarnings(""String_Node_Str"") public <T extends Event>void fire(T event){
  if (!WurstClient.INSTANCE.isEnabled())   return;
  try {
    event.fire(listenerMap.get(event.getListenerType()));
  }
 catch (  Throwable e) {
    e.printStackTrace();
    CrashReport report=CrashReport.makeCrashReport(e,""String_Node_Str"");
    CrashReportCategory category=report.makeCategory(""String_Node_Str"");
    category.setDetail(""String_Node_Str"",() -> event.getClass().getName());
    throw new ReportedException(report);
  }
}","@SuppressWarnings(""String_Node_Str"") public <T extends Event>void fire(T event){
  if (!WurstClient.INSTANCE.isEnabled())   return;
  try {
    ArrayList<? extends Listener> listeners=listenerMap.get(event.getListenerType());
    event.fire(new ArrayList<>(listeners));
  }
 catch (  Throwable e) {
    e.printStackTrace();
    CrashReport report=CrashReport.makeCrashReport(e,""String_Node_Str"");
    CrashReportCategory category=report.makeCategory(""String_Node_Str"");
    category.setDetail(""String_Node_Str"",() -> event.getClass().getName());
    throw new ReportedException(report);
  }
}",0.8723021582733813
175731,"@Override public void fire(ArrayList<ChatInputListener> listeners){
  for (int i=0; i < listeners.size(); i++) {
    listeners.get(i).onReceivedMessage(this);
    if (isCancelled())     break;
  }
}","@Override public void fire(ArrayList<ChatInputListener> listeners){
  for (  ChatInputListener listener : listeners) {
    listener.onReceivedMessage(this);
    if (isCancelled())     break;
  }
}",0.8629441624365483
175732,"@Override public void fire(ArrayList<ChatOutputListener> listeners){
  for (int i=0; i < listeners.size(); i++) {
    listeners.get(i).onSentMessage(this);
    if (isCancelled())     break;
  }
}","@Override public void fire(ArrayList<ChatOutputListener> listeners){
  for (  ChatOutputListener listener : listeners) {
    listener.onSentMessage(this);
    if (isCancelled())     break;
  }
}",0.8586118251928021
175733,"@Override public void fire(ArrayList<DeathListener> listeners){
  for (int i=0; i < listeners.size(); i++)   listeners.get(i).onDeath();
}","@Override public void fire(ArrayList<DeathListener> listeners){
  for (  DeathListener listener : listeners)   listener.onDeath();
}",0.8148148148148148
175734,"@Override public void fire(ArrayList<GUIRenderListener> listeners){
  for (int i=0; i < listeners.size(); i++)   listeners.get(i).onRenderGUI();
}","@Override public void fire(ArrayList<GUIRenderListener> listeners){
  for (  GUIRenderListener listener : listeners)   listener.onRenderGUI();
}",0.8137931034482758
175735,"@Override public void fire(ArrayList<LeftClickListener> listeners){
  for (int i=0; i < listeners.size(); i++) {
    listeners.get(i).onLeftClick(this);
    if (isCancelled())     break;
  }
}","@Override public void fire(ArrayList<LeftClickListener> listeners){
  for (  LeftClickListener listener : listeners) {
    listener.onLeftClick(this);
    if (isCancelled())     break;
  }
}",0.8586387434554974
175736,"@Override public void fire(ArrayList<PacketInputListener> listeners){
  for (int i=0; i < listeners.size(); i++) {
    listeners.get(i).onReceivedPacket(this);
    if (isCancelled())     break;
  }
}","@Override public void fire(ArrayList<PacketInputListener> listeners){
  for (  PacketInputListener listener : listeners) {
    listener.onReceivedPacket(this);
    if (isCancelled())     break;
  }
}",0.8592964824120602
175737,"@Override public void fire(ArrayList<PacketOutputListener> listeners){
  for (int i=0; i < listeners.size(); i++) {
    listeners.get(i).onSentPacket(this);
    if (isCancelled())     break;
  }
}","@Override public void fire(ArrayList<PacketOutputListener> listeners){
  for (  PacketOutputListener listener : listeners) {
    listener.onSentPacket(this);
    if (isCancelled())     break;
  }
}",0.8549618320610687
175738,"@Override public void fire(ArrayList<PostUpdateListener> listeners){
  for (int i=0; i < listeners.size(); i++)   listeners.get(i).afterUpdate();
}","@Override public void fire(ArrayList<PostUpdateListener> listeners){
  for (  PostUpdateListener listener : listeners)   listener.afterUpdate();
}",0.8122866894197952
175739,"@Override public void fire(ArrayList<RenderListener> listeners){
  for (int i=0; i < listeners.size(); i++)   listeners.get(i).onRender(partialTicks);
}","@Override public void fire(ArrayList<RenderListener> listeners){
  for (  RenderListener listener : listeners)   listener.onRender(partialTicks);
}",0.8294314381270903
175740,"@Override public void fire(ArrayList<RightClickListener> listeners){
  for (int i=0; i < listeners.size(); i++) {
    listeners.get(i).onRightClick(this);
    if (isCancelled())     break;
  }
}","@Override public void fire(ArrayList<RightClickListener> listeners){
  for (  RightClickListener listener : listeners) {
    listener.onRightClick(this);
    if (isCancelled())     break;
  }
}",0.8578811369509044
175741,"@Override public void fire(ArrayList<UpdateListener> listeners){
  for (int i=0; i < listeners.size(); i++)   listeners.get(i).onUpdate();
}","@Override public void fire(ArrayList<UpdateListener> listeners){
  for (  UpdateListener listener : listeners)   listener.onUpdate();
}",0.8145454545454546
175742,"@Test public void testApply_Basic(){
  int numGames=3;
  int numCards=12;
  int maxCard=numCards;
  Strategy strategy=new NextCard();
  List<Player> players=new ArrayList<>();
  Player p1=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  Player p2=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  Player p3=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  players.add(p1);
  players.add(p2);
  players.add(p3);
  List<Player> newPlayers=new Tourney(numCards,numGames,false).apply(players);
  assertEquals(3,newPlayers.size());
  assertEquals(0,newPlayers.get(0).getNumCardsInHand());
  assertEquals(0,newPlayers.get(1).getNumCardsInHand());
  assertEquals(0,newPlayers.get(2).getNumCardsInHand());
  assertEquals(3,newPlayers.stream().map(p -> p.getPlayerStats().getNumGamesWon()).mapToInt(i -> i).sum());
}","@Test public void testApply_Basic(){
  int numGames=3;
  int numCards=12;
  int maxCard=numCards;
  List<Player> players=new ArrayList<>();
  Player p1=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  Player p2=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  Player p3=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  players.add(p1);
  players.add(p2);
  players.add(p3);
  List<Player> newPlayers=new Tourney(numCards,numGames,false).apply(players);
  assertEquals(3,newPlayers.size());
  assertEquals(0,newPlayers.get(0).getNumCardsInHand());
  assertEquals(0,newPlayers.get(1).getNumCardsInHand());
  assertEquals(0,newPlayers.get(2).getNumCardsInHand());
  assertEquals(3,newPlayers.stream().map(p -> p.getPlayerStats().getNumGamesWon()).mapToInt(i -> i).sum());
}",0.9781553398058253
175743,"@Test public void testApply_Basic(){
  int numCards=12;
  int maxCard=numCards;
  Strategy strategy=new NextCard();
  List<Player> players=new ArrayList<>();
  Player p1=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  Player p2=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  Player p3=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  players.add(p1);
  players.add(p2);
  players.add(p3);
  List<Player> newPlayers=new Game(numCards,false).apply(players);
  assertEquals(3,newPlayers.size());
  assertEquals(0,newPlayers.get(0).getNumCardsInHand());
  assertEquals(0,newPlayers.get(1).getNumCardsInHand());
  assertEquals(0,newPlayers.get(2).getNumCardsInHand());
  assertEquals(1,newPlayers.stream().filter(p -> p.getPlayerStats().getNumGamesWon() == 1).count());
  assertEquals(2,newPlayers.stream().filter(p -> p.getPlayerStats().getNumGamesWon() == 0).count());
  int maxTotal=maxCard + (maxCard - 1) + (maxCard - 2);
  assertEquals(3,newPlayers.stream().filter(p -> p.getPlayerStats().getTotal() <= maxTotal).count());
  assertEquals(3,newPlayers.stream().map(p -> p.getPlayerStats().getNumRoundsWon()).mapToInt(i -> i).sum());
}","@Test public void testApply_Basic(){
  int numCards=12;
  int maxCard=numCards;
  List<Player> players=new ArrayList<>();
  Player p1=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  Player p2=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  Player p3=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  players.add(p1);
  players.add(p2);
  players.add(p3);
  List<Player> newPlayers=new Game(numCards,false).apply(players);
  assertEquals(3,newPlayers.size());
  assertEquals(0,newPlayers.get(0).getNumCardsInHand());
  assertEquals(0,newPlayers.get(1).getNumCardsInHand());
  assertEquals(0,newPlayers.get(2).getNumCardsInHand());
  assertEquals(1,newPlayers.stream().filter(p -> p.getPlayerStats().getNumGamesWon() == 1).count());
  assertEquals(2,newPlayers.stream().filter(p -> p.getPlayerStats().getNumGamesWon() == 0).count());
  int maxTotal=maxCard + (maxCard - 1) + (maxCard - 2);
  assertEquals(3,newPlayers.stream().filter(p -> p.getPlayerStats().getTotal() <= maxTotal).count());
  assertEquals(3,newPlayers.stream().map(p -> p.getPlayerStats().getNumRoundsWon()).mapToInt(i -> i).sum());
}",0.9844155844155844
175744,"@Test public void testPlay_Basic(){
  int numCards=12;
  int maxCard=numCards;
  Strategy strategy=new NextCard();
  List<Player> players=new ArrayList<>();
  Hand h1=new Hand(Arrays.asList(new Integer[]{1,5,9}));
  Player p1=new Player(""String_Node_Str"",strategy,maxCard,h1);
  Hand h2=new Hand(Arrays.asList(new Integer[]{4,8,6}));
  Player p2=new Player(""String_Node_Str"",strategy,maxCard,h2);
  Hand h3=new Hand(Arrays.asList(new Integer[]{7,2,3}));
  Player p3=new Player(""String_Node_Str"",strategy,maxCard,h3);
  players.add(p1);
  players.add(p2);
  players.add(p3);
  Hand kitty=new Hand(Arrays.asList(new Integer[]{10,11,12}));
  List<Player> newPlayers=new Game(numCards,false).play(kitty,players.stream()).collect(toList());
  assertEquals(3,newPlayers.size());
  assertEquals(0,newPlayers.get(0).getNumCardsInHand());
  assertEquals(0,newPlayers.get(1).getNumCardsInHand());
  assertEquals(0,newPlayers.get(2).getNumCardsInHand());
  assertEquals(3,newPlayers.stream().filter(p -> p.getPlayerStats().getNumRoundsWon() == 1).count());
  assertEquals(1,newPlayers.stream().filter(p -> p.getPlayerStats().getTotal() == 10).count());
  assertEquals(1,newPlayers.stream().filter(p -> p.getPlayerStats().getTotal() == 11).count());
  assertEquals(1,newPlayers.stream().filter(p -> p.getPlayerStats().getTotal() == 12).count());
}","@Test public void testPlay_Basic(){
  int numCards=12;
  int maxCard=numCards;
  List<Player> players=new ArrayList<>();
  Hand h1=new Hand(Arrays.asList(new Integer[]{1,5,9}));
  Player p1=new Player(""String_Node_Str"",strategy,maxCard,h1);
  Hand h2=new Hand(Arrays.asList(new Integer[]{4,8,6}));
  Player p2=new Player(""String_Node_Str"",strategy,maxCard,h2);
  Hand h3=new Hand(Arrays.asList(new Integer[]{7,2,3}));
  Player p3=new Player(""String_Node_Str"",strategy,maxCard,h3);
  players.add(p1);
  players.add(p2);
  players.add(p3);
  Hand kitty=new Hand(Arrays.asList(new Integer[]{10,11,12}));
  List<Player> newPlayers=new Game(numCards,false).play(kitty,players.stream()).collect(toList());
  assertEquals(3,newPlayers.size());
  assertEquals(0,newPlayers.get(0).getNumCardsInHand());
  assertEquals(0,newPlayers.get(1).getNumCardsInHand());
  assertEquals(0,newPlayers.get(2).getNumCardsInHand());
  assertEquals(3,newPlayers.stream().filter(p -> p.getPlayerStats().getNumRoundsWon() == 1).count());
  assertEquals(1,newPlayers.stream().filter(p -> p.getPlayerStats().getTotal() == 10).count());
  assertEquals(1,newPlayers.stream().filter(p -> p.getPlayerStats().getTotal() == 11).count());
  assertEquals(1,newPlayers.stream().filter(p -> p.getPlayerStats().getTotal() == 12).count());
}",0.9863325740318908
175745,"@Test public void testApply_Basic(){
  int numCards=12;
  int maxCard=numCards;
  Strategy strategy=new MaxCard();
  List<Player> players=new ArrayList<>();
  Hand h1=new Hand(Arrays.asList(new Integer[]{1,2,3}));
  Player p1=new Player(""String_Node_Str"",strategy,maxCard,h1);
  Hand h2=new Hand(Arrays.asList(new Integer[]{4,5,6}));
  Player p2=new Player(""String_Node_Str"",strategy,maxCard,h2);
  Hand h3=new Hand(Arrays.asList(new Integer[]{7,8,9}));
  Player p3=new Player(""String_Node_Str"",strategy,maxCard,h3);
  players.add(p1);
  players.add(p2);
  players.add(p3);
  int prizeCard=10;
  List<Player> newPlayers=new Round(prizeCard).apply(players.stream()).collect(toList());
  assertEquals(3,newPlayers.size());
  assertEquals(2,newPlayers.get(0).getNumCardsInHand());
  assertEquals(2,newPlayers.get(1).getNumCardsInHand());
  assertEquals(2,newPlayers.get(2).getNumCardsInHand());
  assertEquals(1,newPlayers.stream().filter(p -> p.getPlayerStats().getNumRoundsWon() == 1).count());
  assertEquals(1,newPlayers.stream().filter(p -> p.getPlayerStats().getTotal() == 10).count());
  assertEquals(2,newPlayers.stream().filter(p -> p.getPlayerStats().getNumRoundsWon() == 0).count());
  assertEquals(2,newPlayers.stream().filter(p -> p.getPlayerStats().getTotal() == 0).count());
}","@Test public void testApply_Basic(){
  int numCards=12;
  int maxCard=numCards;
  List<Player> players=new ArrayList<>();
  Hand h1=new Hand(Arrays.asList(new Integer[]{1,2,3}));
  Player p1=new Player(""String_Node_Str"",strategy,maxCard,h1);
  Hand h2=new Hand(Arrays.asList(new Integer[]{4,5,6}));
  Player p2=new Player(""String_Node_Str"",strategy,maxCard,h2);
  Hand h3=new Hand(Arrays.asList(new Integer[]{7,8,9}));
  Player p3=new Player(""String_Node_Str"",strategy,maxCard,h3);
  players.add(p1);
  players.add(p2);
  players.add(p3);
  int prizeCard=10;
  List<Player> newPlayers=new Round(prizeCard).apply(players.stream()).collect(toList());
  assertEquals(3,newPlayers.size());
  assertEquals(2,newPlayers.get(0).getNumCardsInHand());
  assertEquals(2,newPlayers.get(1).getNumCardsInHand());
  assertEquals(2,newPlayers.get(2).getNumCardsInHand());
  assertEquals(1,newPlayers.stream().filter(p -> p.getPlayerStats().getNumRoundsWon() == 1).count());
  assertEquals(1,newPlayers.stream().filter(p -> p.getPlayerStats().getTotal() == 10).count());
  assertEquals(2,newPlayers.stream().filter(p -> p.getPlayerStats().getNumRoundsWon() == 0).count());
  assertEquals(2,newPlayers.stream().filter(p -> p.getPlayerStats().getTotal() == 0).count());
}",0.9862258953168044
175746,"@Test public void testGetAllBids_Basic(){
  Round round=new Round();
  int numCards=12;
  int maxCard=numCards;
  Strategy strategy=new MaxCard();
  List<Player> players=new ArrayList<>();
  Hand h1=new Hand(Arrays.asList(new Integer[]{1,2,3}));
  Player p1=new Player(""String_Node_Str"",strategy,maxCard,h1);
  Hand h2=new Hand(Arrays.asList(new Integer[]{4,5,6}));
  Player p2=new Player(""String_Node_Str"",strategy,maxCard,h2);
  Hand h3=new Hand(Arrays.asList(new Integer[]{7,8,9}));
  Player p3=new Player(""String_Node_Str"",strategy,maxCard,h3);
  players.add(p1);
  players.add(p2);
  players.add(p3);
  List<Bid> result=round.getAllBids(players.stream(),10);
  assertEquals(3,result.size());
}","@Test public void testGetAllBids_Basic(){
  Round round=new Round();
  int numCards=12;
  int maxCard=numCards;
  List<Player> players=new ArrayList<>();
  Hand h1=new Hand(Arrays.asList(new Integer[]{1,2,3}));
  Player p1=new Player(""String_Node_Str"",strategy,maxCard,h1);
  Hand h2=new Hand(Arrays.asList(new Integer[]{4,5,6}));
  Player p2=new Player(""String_Node_Str"",strategy,maxCard,h2);
  Hand h3=new Hand(Arrays.asList(new Integer[]{7,8,9}));
  Player p3=new Player(""String_Node_Str"",strategy,maxCard,h3);
  players.add(p1);
  players.add(p2);
  players.add(p3);
  List<Bid> result=round.getAllBids(players.stream(),10);
  assertEquals(3,result.size());
}",0.9742836149889786
175747,"@Test public void testFindWinningBid_Basic(){
  Round round=new Round();
  int maxCard=50;
  Strategy strategy=new MaxCard();
  Player p1=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  Player p2=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  Player p3=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  int prizeCard=20;
  List<Bid> bids=new ArrayList<>();
  bids.add(new Bid(prizeCard,10,p1));
  bids.add(new Bid(prizeCard,12,p2));
  bids.add(new Bid(prizeCard,14,p3));
  Bid result=round.findWinningBid(bids);
  assertEquals(""String_Node_Str"",result.getBidder().getName());
}","@Test public void testFindWinningBid_Basic(){
  Round round=new Round();
  int maxCard=50;
  Player p1=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  Player p2=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  Player p3=new Player(""String_Node_Str"",strategy,maxCard,new Hand());
  int prizeCard=20;
  List<Bid> bids=new ArrayList<>();
  bids.add(new Bid(prizeCard,10,p1));
  bids.add(new Bid(prizeCard,12,p2));
  bids.add(new Bid(prizeCard,14,p3));
  Bid result=round.findWinningBid(bids);
  assertEquals(""String_Node_Str"",result.getBidder().getName());
}",0.9707112970711296
175748,"@Test public void testDeal_Table_Basic(){
  Dealer dealer=new Dealer();
  int numCards=12;
  int maxCard=numCards;
  Strategy strategy=new MaxCard();
  List<Player> players=new ArrayList<>();
  Hand h1=new Hand(Arrays.asList(new Integer[]{1,2,3}));
  Player p1=new Player(""String_Node_Str"",strategy,maxCard,h1);
  Hand h2=new Hand(Arrays.asList(new Integer[]{4,5,6}));
  Player p2=new Player(""String_Node_Str"",strategy,maxCard,h2);
  Hand h3=new Hand(Arrays.asList(new Integer[]{7,8,9}));
  Player p3=new Player(""String_Node_Str"",strategy,maxCard,h3);
  players.add(p1);
  players.add(p2);
  players.add(p3);
  Table table=dealer.deal(20,players);
  assertEquals(5,table.getKitty().cardsAsIntStream().count());
  assertEquals(5,table.getPlayers().get(0).getNumCardsInHand());
  assertEquals(5,table.getPlayers().get(1).getNumCardsInHand());
  assertEquals(5,table.getPlayers().get(2).getNumCardsInHand());
}","@Test public void testDeal_Table_Basic(){
  Dealer dealer=new Dealer();
  int numCards=12;
  int maxCard=numCards;
  List<Player> players=new ArrayList<>();
  Hand h1=new Hand(Arrays.asList(new Integer[]{1,2,3}));
  Player p1=new Player(""String_Node_Str"",strategy,maxCard,h1);
  Hand h2=new Hand(Arrays.asList(new Integer[]{4,5,6}));
  Player p2=new Player(""String_Node_Str"",strategy,maxCard,h2);
  Hand h3=new Hand(Arrays.asList(new Integer[]{7,8,9}));
  Player p3=new Player(""String_Node_Str"",strategy,maxCard,h3);
  players.add(p1);
  players.add(p2);
  players.add(p3);
  Table table=dealer.deal(20,players);
  assertEquals(5,table.getKitty().cardsAsIntStream().count());
  assertEquals(5,table.getPlayers().get(0).getNumCardsInHand());
  assertEquals(5,table.getPlayers().get(1).getNumCardsInHand());
  assertEquals(5,table.getPlayers().get(2).getNumCardsInHand());
}",0.9803260258572232
175749,"@Override protected void onCreate(Bundle arg0){
  super.onCreate(arg0);
  setContentView(R.layout.activity_friend_info_layout);
  schoolMate=(SchoolMate)params;
  mLayout.bindSchoolMate(schoolMate);
  mLayout.disableButton();
  updateLayout();
}","@Override protected void onCreate(Bundle arg0){
  super.onCreate(arg0);
  setContentView(R.layout.activity_friend_info_layout);
  schoolMate=(SchoolMate)params;
  mLayout.bindSchoolMate(schoolMate);
  mLayout.showButton(false);
  updateLayout();
}",0.967479674796748
175750,"private void updateLayout(){
  HashMap<String,Object> conditions=new HashMap<>();
  conditions.put(AddRequest.TO_USER,UserCacheHelper.getInstance().getCachedAVUser(schoolMate.getUserId()));
  FriendsManager.getInstance().findSendRequests(new FindCallback<AddRequest>(){
    @Override public void done(    List<AddRequest> list,    AVException e){
      if (e == null) {
        if (list != null) {
          if (list.size() > 0) {
            AddRequest addRequest=list.get(0);
            int status=addRequest.getStatus();
            if (status == AddRequest.STATUS_DONE) {
              mLayout.setButtonType(2);
              mLayout.enableButton();
            }
 else {
              mLayout.setButtonType(3);
              mLayout.disableButton();
            }
          }
 else {
            mLayout.setButtonType(1);
            mLayout.enableButton();
          }
        }
 else {
          mLayout.setButtonType(1);
          mLayout.enableButton();
        }
      }
    }
  }
,false,conditions);
}","private void updateLayout(){
  HashMap<String,Object> conditions=new HashMap<>();
  conditions.put(AddRequest.TO_USER,UserCacheHelper.getInstance().getCachedAVUser(schoolMate.getUserId()));
  FriendsManager.getInstance().findSendRequests(new FindCallback<AddRequest>(){
    @Override public void done(    List<AddRequest> list,    AVException e){
      NLog.i(TAG,""String_Node_Str"" + list + ""String_Node_Str""+ Thread.currentThread().getName());
      if (e == null) {
        if (list != null) {
          if (list.size() > 0) {
            AddRequest addRequest=list.get(0);
            int status=addRequest.getStatus();
            NLog.i(TAG,""String_Node_Str"" + status);
            if (status == AddRequest.STATUS_DONE) {
              mLayout.setButtonType(2);
              mLayout.enableButton();
              mLayout.showButton(true);
            }
 else {
              mLayout.setButtonType(3);
              mLayout.disableButton();
              mLayout.showButton(true);
            }
          }
 else {
            mLayout.setButtonType(1);
            mLayout.enableButton();
            mLayout.showButton(true);
          }
        }
 else {
          mLayout.setButtonType(1);
          mLayout.enableButton();
          mLayout.showButton(true);
        }
      }
 else {
        NLog.e(TagUtil.makeTag(FriendInfoActivity.class),""String_Node_Str"",e);
      }
    }
  }
,false,conditions);
}",0.8354639175257732
175751,"@Override public void done(List<AddRequest> list,AVException e){
  if (e == null) {
    if (list != null) {
      if (list.size() > 0) {
        AddRequest addRequest=list.get(0);
        int status=addRequest.getStatus();
        if (status == AddRequest.STATUS_DONE) {
          mLayout.setButtonType(2);
          mLayout.enableButton();
        }
 else {
          mLayout.setButtonType(3);
          mLayout.disableButton();
        }
      }
 else {
        mLayout.setButtonType(1);
        mLayout.enableButton();
      }
    }
 else {
      mLayout.setButtonType(1);
      mLayout.enableButton();
    }
  }
}","@Override public void done(List<AddRequest> list,AVException e){
  NLog.i(TAG,""String_Node_Str"" + list + ""String_Node_Str""+ Thread.currentThread().getName());
  if (e == null) {
    if (list != null) {
      if (list.size() > 0) {
        AddRequest addRequest=list.get(0);
        int status=addRequest.getStatus();
        NLog.i(TAG,""String_Node_Str"" + status);
        if (status == AddRequest.STATUS_DONE) {
          mLayout.setButtonType(2);
          mLayout.enableButton();
          mLayout.showButton(true);
        }
 else {
          mLayout.setButtonType(3);
          mLayout.disableButton();
          mLayout.showButton(true);
        }
      }
 else {
        mLayout.setButtonType(1);
        mLayout.enableButton();
        mLayout.showButton(true);
      }
    }
 else {
      mLayout.setButtonType(1);
      mLayout.enableButton();
      mLayout.showButton(true);
    }
  }
 else {
    NLog.e(TagUtil.makeTag(FriendInfoActivity.class),""String_Node_Str"",e);
  }
}",0.7707682698313554
175752,"public void disableButton(){
  shrinkButton.setEnabled(false);
  shrinkButton.setBackground(mRes.getDrawable(R.drawable.button_rounded_color_grey_background));
}","public void disableButton(){
  addFriendBtn.setEnabled(false);
  addFriendBtn.setBackground(mRes.getDrawable(R.drawable.button_rounded_color_grey_background));
}",0.9254658385093169
175753,"public void enableButton(){
  shrinkButton.setEnabled(true);
  shrinkButton.reset();
  shrinkButton.setBackground(mRes.getDrawable(R.drawable.button_rounded_color_yellow_background));
}","public void enableButton(){
  addFriendBtn.setEnabled(true);
  addFriendBtn.setBackground(mRes.getDrawable(R.drawable.button_rounded_color_yellow_background));
}",0.861271676300578
175754,"/** 
 * @param type type 1:add friend  type 2:talk type 3:wait
 */
public void setButtonType(int type){
  shrinkButton.setTag(R.id.button_type,type);
switch (type) {
case 1:
    shrinkButton.setText(mRes.getString(R.string.sendMessage));
  break;
case 2:
shrinkButton.setText(mRes.getString(R.string.add_friend));
break;
case 3:
shrinkButton.setText(mRes.getString(R.string.wait_for_verfiy));
break;
}
}","/** 
 * @param type type 1:add friend  type 2:talk type 3:wait
 */
public void setButtonType(int type){
  addFriendBtn.setTag(R.id.button_type,type);
switch (type) {
case 2:
    addFriendBtn.setText(mRes.getString(R.string.sendMessage));
  break;
case 1:
addFriendBtn.setText(mRes.getString(R.string.add_friend));
break;
case 3:
addFriendBtn.setText(mRes.getString(R.string.wait_for_verfiy));
break;
}
}",0.7245657568238213
175755,"@Override public void onContentViewCreate(View view){
  super.onContentViewCreate(view);
  LayoutIdBinder.LAYOUT.bindViewToLayout(this);
  titlebar.setDelegate(new BGATitlebar.BGATitlebarDelegate(){
    @Override public void onClickLeftCtv(){
      super.onClickLeftCtv();
      if (onLayoutActionListener != null) {
        onLayoutActionListener.onBack();
      }
    }
  }
);
  shrinkButton.setTag(R.id.button_type,1);
  shrinkButton.setOnClickListener(View -> {
    shrinkButton.setEnabled(false);
    if (onLayoutActionListener != null) {
      int type=(int)shrinkButton.getTag(R.id.button_type);
      if (type == 1) {
        onLayoutActionListener.addFriend();
      }
 else       if (type == 2) {
        onLayoutActionListener.onTalkWithFriend();
      }
    }
 else {
      enableButton();
    }
  }
);
}","@Override public void onContentViewCreate(View view){
  super.onContentViewCreate(view);
  LayoutIdBinder.LAYOUT.bindViewToLayout(this);
  titlebar.setDelegate(new BGATitlebar.BGATitlebarDelegate(){
    @Override public void onClickLeftCtv(){
      super.onClickLeftCtv();
      if (onLayoutActionListener != null) {
        onLayoutActionListener.onBack();
      }
    }
  }
);
  addFriendBtn.setTag(R.id.button_type,1);
  addFriendBtn.setOnClickListener(View -> {
    addFriendBtn.setEnabled(false);
    if (onLayoutActionListener != null) {
      int type=(int)addFriendBtn.getTag(R.id.button_type);
      if (type == 1) {
        onLayoutActionListener.addFriend();
      }
 else       if (type == 2) {
        onLayoutActionListener.onTalkWithFriend();
      }
    }
 else {
      enableButton();
    }
  }
);
}",0.9509803921568628
175756,"public DaoMaster(SQLiteDatabase db){
  super(db,SCHEMA_VERSION);
  registerDaoClass(SchoolmateDao.class);
  registerDaoClass(UserDao.class);
  registerDaoClass(BeanDao.class);
  registerDaoClass(ConversationDao.class);
}","public DaoMaster(SQLiteDatabase db){
  super(db,SCHEMA_VERSION);
  registerDaoClass(BeanDao.class);
  registerDaoClass(ConversationDao.class);
  registerDaoClass(UserDao.class);
  registerDaoClass(SchoolmateDao.class);
}",0.6545454545454545
175757,"/** 
 * Drops underlying database table using DAOs. 
 */
public static void dropAllTables(SQLiteDatabase db,boolean ifExists){
  SchoolmateDao.dropTable(db,ifExists);
  UserDao.dropTable(db,ifExists);
  BeanDao.dropTable(db,ifExists);
  ConversationDao.dropTable(db,ifExists);
}","/** 
 * Drops underlying database table using DAOs. 
 */
public static void dropAllTables(SQLiteDatabase db,boolean ifExists){
  BeanDao.dropTable(db,ifExists);
  ConversationDao.dropTable(db,ifExists);
  UserDao.dropTable(db,ifExists);
  SchoolmateDao.dropTable(db,ifExists);
}",0.60431654676259
175758,"/** 
 * Creates underlying database table using DAOs. 
 */
public static void createAllTables(SQLiteDatabase db,boolean ifNotExists){
  SchoolmateDao.createTable(db,ifNotExists);
  UserDao.createTable(db,ifNotExists);
  BeanDao.createTable(db,ifNotExists);
  ConversationDao.createTable(db,ifNotExists);
}","/** 
 * Creates underlying database table using DAOs. 
 */
public static void createAllTables(SQLiteDatabase db,boolean ifNotExists){
  BeanDao.createTable(db,ifNotExists);
  ConversationDao.createTable(db,ifNotExists);
  UserDao.createTable(db,ifNotExists);
  SchoolmateDao.createTable(db,ifNotExists);
}",0.5901639344262295
175759,"public void clear(){
  schoolmateDaoConfig.getIdentityScope().clear();
  userDaoConfig.getIdentityScope().clear();
  beanDaoConfig.getIdentityScope().clear();
  conversationDaoConfig.getIdentityScope().clear();
}","public void clear(){
  beanDaoConfig.getIdentityScope().clear();
  conversationDaoConfig.getIdentityScope().clear();
  userDaoConfig.getIdentityScope().clear();
  schoolmateDaoConfig.getIdentityScope().clear();
}",0.6981132075471698
175760,"public DaoSession(SQLiteDatabase db,IdentityScopeType type,Map<Class<? extends AbstractDao<?,?>>,DaoConfig> daoConfigMap){
  super(db);
  schoolmateDaoConfig=daoConfigMap.get(SchoolmateDao.class).clone();
  schoolmateDaoConfig.initIdentityScope(type);
  userDaoConfig=daoConfigMap.get(UserDao.class).clone();
  userDaoConfig.initIdentityScope(type);
  beanDaoConfig=daoConfigMap.get(BeanDao.class).clone();
  beanDaoConfig.initIdentityScope(type);
  conversationDaoConfig=daoConfigMap.get(ConversationDao.class).clone();
  conversationDaoConfig.initIdentityScope(type);
  schoolmateDao=new SchoolmateDao(schoolmateDaoConfig,this);
  userDao=new UserDao(userDaoConfig,this);
  beanDao=new BeanDao(beanDaoConfig,this);
  conversationDao=new ConversationDao(conversationDaoConfig,this);
  registerDao(Schoolmate.class,schoolmateDao);
  registerDao(User.class,userDao);
  registerDao(Bean.class,beanDao);
  registerDao(Conversation.class,conversationDao);
}","public DaoSession(SQLiteDatabase db,IdentityScopeType type,Map<Class<? extends AbstractDao<?,?>>,DaoConfig> daoConfigMap){
  super(db);
  beanDaoConfig=daoConfigMap.get(BeanDao.class).clone();
  beanDaoConfig.initIdentityScope(type);
  conversationDaoConfig=daoConfigMap.get(ConversationDao.class).clone();
  conversationDaoConfig.initIdentityScope(type);
  userDaoConfig=daoConfigMap.get(UserDao.class).clone();
  userDaoConfig.initIdentityScope(type);
  schoolmateDaoConfig=daoConfigMap.get(SchoolmateDao.class).clone();
  schoolmateDaoConfig.initIdentityScope(type);
  beanDao=new BeanDao(beanDaoConfig,this);
  conversationDao=new ConversationDao(conversationDaoConfig,this);
  userDao=new UserDao(userDaoConfig,this);
  schoolmateDao=new SchoolmateDao(schoolmateDaoConfig,this);
  registerDao(Bean.class,beanDao);
  registerDao(Conversation.class,conversationDao);
  registerDao(User.class,userDao);
  registerDao(Schoolmate.class,schoolmateDao);
}",0.3326337880377754
175761,"public Schoolmate(String userId,Integer friendState,java.util.Date createAt){
  this.userId=userId;
  this.friendState=friendState;
  this.createAt=createAt;
}","public Schoolmate(String userId,String releatedId,Integer friendState,java.util.Date createAt){
  this.userId=userId;
  this.releatedId=releatedId;
  this.friendState=friendState;
  this.createAt=createAt;
}",0.8688524590163934
175762,"/** 
 * @inheritdoc 
 */
@Override public void readEntity(Cursor cursor,Schoolmate entity,int offset){
  entity.setUserId(cursor.isNull(offset + 0) ? null : cursor.getString(offset + 0));
  entity.setFriendState(cursor.isNull(offset + 1) ? null : cursor.getInt(offset + 1));
  entity.setCreateAt(cursor.isNull(offset + 2) ? null : new java.util.Date(cursor.getLong(offset + 2)));
}","/** 
 * @inheritdoc 
 */
@Override public void readEntity(Cursor cursor,Schoolmate entity,int offset){
  entity.setUserId(cursor.isNull(offset + 0) ? null : cursor.getString(offset + 0));
  entity.setReleatedId(cursor.getString(offset + 1));
  entity.setFriendState(cursor.isNull(offset + 2) ? null : cursor.getInt(offset + 2));
  entity.setCreateAt(cursor.isNull(offset + 3) ? null : new java.util.Date(cursor.getLong(offset + 3)));
}",0.9240196078431372
175763,"/** 
 * Creates the underlying database table. 
 */
public static void createTable(SQLiteDatabase db,boolean ifNotExists){
  String constraint=ifNotExists ? ""String_Node_Str"" : ""String_Node_Str"";
  db.execSQL(""String_Node_Str"" + constraint + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Creates the underlying database table. 
 */
public static void createTable(SQLiteDatabase db,boolean ifNotExists){
  String constraint=ifNotExists ? ""String_Node_Str"" : ""String_Node_Str"";
  db.execSQL(""String_Node_Str"" + constraint + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9711684370257968
175764,"/** 
 * @inheritdoc 
 */
@Override protected void bindValues(SQLiteStatement stmt,Schoolmate entity){
  stmt.clearBindings();
  String userId=entity.getUserId();
  if (userId != null) {
    stmt.bindString(1,userId);
  }
  Integer friendState=entity.getFriendState();
  if (friendState != null) {
    stmt.bindLong(2,friendState);
  }
  java.util.Date createAt=entity.getCreateAt();
  if (createAt != null) {
    stmt.bindLong(3,createAt.getTime());
  }
}","/** 
 * @inheritdoc 
 */
@Override protected void bindValues(SQLiteStatement stmt,Schoolmate entity){
  stmt.clearBindings();
  String userId=entity.getUserId();
  if (userId != null) {
    stmt.bindString(1,userId);
  }
  stmt.bindString(2,entity.getReleatedId());
  Integer friendState=entity.getFriendState();
  if (friendState != null) {
    stmt.bindLong(3,friendState);
  }
  java.util.Date createAt=entity.getCreateAt();
  if (createAt != null) {
    stmt.bindLong(4,createAt.getTime());
  }
}",0.9486910994764398
175765,"@Override public void onRegisterError(int code,final String message){
  runOnUiThread(new Runnable(){
    @Override public void run(){
      NToast.shortToast(RegisterActivity.this,getString(R.string.registerFailed) + message);
      mLayout.resetRegisterButton();
    }
  }
);
}","@Override public void onRegisterError(int code,final String message){
  runOnUiThread(() -> {
    NToast.shortToast(RegisterActivity.this,getString(R.string.registerFailed) + message);
    mLayout.resetRegisterButton();
  }
);
}",0.863905325443787
175766,"private void checkAndInstallEatMark(){
  Class<?>[] declaredClasses=getClass().getDeclaredClasses();
  if (declaredClasses != null) {
    for (    Class<?> declaredClass : declaredClasses) {
      EatMark eatMark=declaredClass.getAnnotation(EatMark.class);
      if (eatMark != null && eatMark.action() != null) {
        IEater iEater=null;
        try {
          Constructor<?> constructor=declaredClass.getConstructor(this.getClass());
          constructor.setAccessible(true);
          iEater=(IEater)constructor.newInstance(this);
        }
 catch (        java.lang.InstantiationException e) {
          e.printStackTrace();
        }
catch (        IllegalAccessException e) {
          e.printStackTrace();
        }
catch (        NoSuchMethodException e) {
          e.printStackTrace();
        }
catch (        InvocationTargetException e) {
          e.printStackTrace();
        }
        if (iEater != null) {
          eater.add(iEater);
          NLog.i(TagUtil.makeTag(getClass()),""String_Node_Str"" + eatMark.action());
          EaterManager.getInstance().registerEater(eatMark.action(),iEater);
        }
      }
    }
  }
}","private void checkAndInstallEatMark(){
  Class<?>[] declaredClasses=getClass().getDeclaredClasses();
  if (declaredClasses != null) {
    for (    Class<?> declaredClass : declaredClasses) {
      EatMark eatMark=declaredClass.getAnnotation(EatMark.class);
      if (eatMark != null && eatMark.action() != null) {
        IEater iEater=null;
        try {
          Constructor<?> constructor=declaredClass.getConstructor(this.getClass());
          constructor.setAccessible(true);
          iEater=(IEater)constructor.newInstance(this);
        }
 catch (        java.lang.InstantiationException e) {
          e.printStackTrace();
        }
catch (        IllegalAccessException e) {
          e.printStackTrace();
        }
catch (        NoSuchMethodException e) {
          e.printStackTrace();
        }
catch (        InvocationTargetException e) {
          e.printStackTrace();
        }
        if (iEater != null) {
          eater.add(iEater);
          EaterManager.getInstance().registerEater(eatMark.action(),iEater);
        }
      }
    }
  }
}",0.9140271493212668
175767,"@Override public void onRefresh(){
  updateSchoolMates(task -> {
    mLayout.notifyFreshDone();
    if (task.getResult() != null) {
      mLayout.setData(task.getResult(),500);
    }
    return null;
  }
);
}","@Override public void onRefresh(){
  updateSchoolMates(task -> {
    mLayout.notifyFreshDone();
    if (task.getResult() != null) {
      mLayout.refresh(task.getResult());
    }
    return null;
  }
);
}",0.9563106796116504
175768,"private void updateSchoolMates(Continuation<List<SchoolMate>,Void> continuation){
  SchoolMatesManager.getInstance().queryAllSchoolMates().continueWith(task -> {
    final List<SchoolMate> result=task.getResult();
    if (result != null) {
      Collections.sort(result,new LetterComparator<SchoolMate>());
      ToolKit.runOnMainThreadAsync(() -> {
        if (continuation != null) {
          Task.<List<SchoolMate>>forResult(result).continueWith(continuation);
        }
      }
);
    }
 else {
      if (continuation != null) {
        Task.<List<SchoolMate>>forResult(null).continueWith(continuation);
      }
    }
    return null;
  }
);
}","private void updateSchoolMates(Continuation<List<SchoolMate>,Void> continuation){
  SchoolMatesManager.getInstance().queryAllSchoolMates().continueWith(task -> {
    final List<SchoolMate> result=task.getResult();
    if (result != null) {
      Collections.sort(result,new LetterComparator<>());
      if (continuation != null) {
        Task.<List<SchoolMate>>forResult(result).continueWith(continuation,Task.UI_THREAD_EXECUTOR);
      }
    }
 else {
      if (continuation != null) {
        Task.<List<SchoolMate>>forResult(null).continueWith(continuation,Task.UI_THREAD_EXECUTOR);
      }
    }
    return null;
  }
);
}",0.9073783359497644
175769,"@Override protected void onViewCreated(){
  super.onViewCreated();
  updateSchoolMates(task -> {
    if (task.getResult() != null) {
      mLayout.setData(task.getResult());
    }
    return null;
  }
);
  mLayout.setOnFreshListener(new SpringView.OnFreshListener(){
    @Override public void onRefresh(){
      updateSchoolMates(task -> {
        mLayout.notifyFreshDone();
        if (task.getResult() != null) {
          mLayout.setData(task.getResult(),500);
        }
        return null;
      }
);
    }
    @Override public void onLoadmore(){
    }
  }
);
}","@Override protected void onViewCreated(){
  super.onViewCreated();
  updateSchoolMates(task -> {
    if (task.getResult() != null) {
      mLayout.setData(task.getResult());
    }
    return null;
  }
);
  mLayout.setOnFreshListener(new SpringView.OnFreshListener(){
    @Override public void onRefresh(){
      updateSchoolMates(task -> {
        mLayout.notifyFreshDone();
        if (task.getResult() != null) {
          mLayout.refresh(task.getResult());
        }
        return null;
      }
);
    }
    @Override public void onLoadmore(){
    }
  }
);
  handler=new Handler();
}",0.9609713790112748
175770,"private void listenToClient(){
  mClientOpenListener=new AbstractHandler<ClientOpenParam>(){
    @Override public boolean isParamAvailable(    LightParam param){
      return param != null && param instanceof ClientOpenParam;
    }
    @Override public void doJobWithParam(    ClientOpenParam param){
      if (param.mOpened) {
        initSquareConversation();
      }
 else {
        NToast.shortToast(mAppCtx,getString(R.string.internet_not_connect_warn));
      }
    }
  }
;
}","private void listenToClient(){
  mClientOpenListener=new AbstractHandler<ClientOpenParam>(){
    @Override public boolean isParamAvailable(    LightParam param){
      return param != null && param instanceof ClientOpenParam;
    }
    @Override public void doJobWithParam(    ClientOpenParam param){
      NLog.i(TagUtil.makeTag(getClass()),""String_Node_Str"" + param.mOpened);
      if (param.mOpened) {
        initSquareConversation();
      }
 else {
        NToast.shortToast(mAppCtx,getString(R.string.internet_not_connect_warn));
      }
    }
  }
;
}",0.9258902791145333
175771,"private void fetchMessages(){
  if (mAvimConversation != null) {
    mAvimConversation.queryMessages(new AVIMMessagesQueryCallback(){
      @Override public void done(      List<AVIMMessage> list,      AVIMException e){
        if (filterException(e)) {
          if (mLayout.getChatLt() != null) {
            mLayout.getChatLt().clear();
            mLayout.pushMessagesAndRefreshToBottom(IMessageWrap.buildFrom(list,false));
          }
        }
      }
    }
);
  }
}","private Task<List<AVIMMessage>> fetchMessages(){
  if (mAvimConversation != null) {
    return Task.callInBackground(new Callable<List<AVIMMessage>>(){
      List<AVIMMessage> queryResult;
      @Override public List<AVIMMessage> call() throws Exception {
        int syncLatch=SyncUtils.getSyncLatch();
        mAvimConversation.queryMessages(new AVIMMessagesQueryCallback(){
          @Override public void done(          List<AVIMMessage> list,          AVIMException e){
            if (filterException(e)) {
              queryResult=list;
            }
            SyncUtils.notify(syncLatch);
          }
        }
);
        SyncUtils.wait(syncLatch);
        NLog.i(TagUtil.makeTag(getClass()),""String_Node_Str"" + queryResult);
        return queryResult;
      }
    }
).continueWith(task -> {
      List<AVIMMessage> result=task.getResult();
      if (result != null && mLayout.getChatLt() != null) {
        mLayout.getChatLt().clear();
        mLayout.pushMessagesAndRefreshToBottom(IMessageWrap.buildFrom(result,false));
        return result;
      }
      return null;
    }
,Task.UI_THREAD_EXECUTOR);
  }
  return Task.forResult(null);
}",0.3124231242312423
175772,"@Override public void onRefresh(){
  if (mLayout != null) {
    IMessageWrap firstMessage=mLayout.getChatLt().getFirstMessage();
    if (firstMessage == null) {
      mLayout.getChatLt().finshRefresh();
    }
 else {
      if (mAvimConversation != null) {
        mAvimConversation.queryMessages(firstMessage.message_.getMessageId(),firstMessage.message_.getTimestamp(),20,new AVIMMessagesQueryCallback(){
          @Override public void done(          List<AVIMMessage> list,          AVIMException e){
            if (e == null && list != null) {
              mLayout.pushMessagesAndRefreshToTop(IMessageWrap.buildFrom(list,true));
            }
            mLayout.getChatLt().finshRefresh();
          }
        }
);
      }
 else {
        mLayout.getChatLt().finshRefresh();
      }
    }
  }
}","@Override public void onRefresh(){
  if (mLayout != null) {
    IMessageWrap firstMessage=mLayout.getChatLt().getFirstMessage();
    if (firstMessage == null) {
      fetchMessages().continueWith(task -> {
        mLayout.getChatLt().finshRefresh();
        return null;
      }
);
    }
 else {
      if (mAvimConversation != null) {
        mAvimConversation.queryMessages(firstMessage.message_.getMessageId(),firstMessage.message_.getTimestamp(),20,new AVIMMessagesQueryCallback(){
          @Override public void done(          List<AVIMMessage> list,          AVIMException e){
            if (e == null && list != null) {
              mLayout.pushMessagesAndRefreshToTop(IMessageWrap.buildFrom(list,true));
            }
            mLayout.getChatLt().finshRefresh();
          }
        }
);
      }
 else {
        mLayout.getChatLt().finshRefresh();
      }
    }
  }
}",0.9530041641879834
175773,"private void initSquareConversation(){
  String currentSquareConversationName=HiTalkHelper.getInstance().getModel().getSquareConversationName();
  if (HiTalkHelper.getInstance().getCurrentUserCollege() != null && ConversationClient.getCollegeSquareConversationName(HiTalkHelper.getInstance().getCurrentUserCollege()).equals(currentSquareConversationName)) {
    mAvimConversation=ClientManager.getInstance().getClient().getConversation(HiTalkHelper.getInstance().getModel().getSquareConversationId());
    updateConversation(mAvimConversation);
    queryInSquare();
  }
 else {
    ConversationClient.getInstance().getSquareConversationByName(ConversationClient.getCollegeSquareConversationName(HiTalkHelper.getInstance().getCurrentUserCollege()),new AVIMConversationQueryCallback(){
      @Override public void done(      List<AVIMConversation> list,      AVIMException e){
        if (e == null && list.size() > 0) {
          final AVIMConversation avimConversation=list.get(0);
          ConversationCacheHelper.getInstance().insertConversation(avimConversation.getConversationId());
          HiTalkHelper.getInstance().getModel().setSquareConversationId(avimConversation.getConversationId());
          HiTalkHelper.getInstance().getModel().setSquareConversationName(avimConversation.getName());
          mAvimConversation=avimConversation;
          updateConversation(mAvimConversation);
          queryInSquare();
        }
 else {
          NToast.shortToast(mAppCtx,getString(R.string.square_not_create));
        }
      }
    }
);
  }
}","private void initSquareConversation(){
  NLog.i(TagUtil.makeTag(getClass()),""String_Node_Str"");
  String currentSquareConversationName=HiTalkHelper.getInstance().getModel().getSquareConversationName();
  if (HiTalkHelper.getInstance().getCurrentUserCollege() != null && ConversationClient.getCollegeSquareConversationName(HiTalkHelper.getInstance().getCurrentUserCollege()).equals(currentSquareConversationName)) {
    mAvimConversation=ClientManager.getInstance().getClient().getConversation(HiTalkHelper.getInstance().getModel().getSquareConversationId());
    updateConversation(mAvimConversation);
    queryInSquare();
  }
 else {
    ConversationClient.getInstance().getSquareConversationByName(ConversationClient.getCollegeSquareConversationName(HiTalkHelper.getInstance().getCurrentUserCollege()),new AVIMConversationQueryCallback(){
      @Override public void done(      List<AVIMConversation> list,      AVIMException e){
        if (e == null && list.size() > 0) {
          final AVIMConversation avimConversation=list.get(0);
          ConversationCacheHelper.getInstance().insertConversation(avimConversation.getConversationId());
          HiTalkHelper.getInstance().getModel().setSquareConversationId(avimConversation.getConversationId());
          HiTalkHelper.getInstance().getModel().setSquareConversationName(avimConversation.getName());
          mAvimConversation=avimConversation;
          updateConversation(mAvimConversation);
          queryInSquare();
        }
 else {
          NToast.shortToast(mAppCtx,getString(R.string.square_not_create));
        }
      }
    }
);
  }
}",0.9819448843839088
175774,"@Override protected void onViewCreated(){
  super.onViewCreated();
  init();
  mLayout.setMessageListFreshListener(new ChatMessageListLayout.IMessageListFreshListener(){
    @Override public void onRefresh(){
      if (mLayout != null) {
        IMessageWrap firstMessage=mLayout.getChatLt().getFirstMessage();
        if (firstMessage == null) {
          mLayout.getChatLt().finshRefresh();
        }
 else {
          if (mAvimConversation != null) {
            mAvimConversation.queryMessages(firstMessage.message_.getMessageId(),firstMessage.message_.getTimestamp(),20,new AVIMMessagesQueryCallback(){
              @Override public void done(              List<AVIMMessage> list,              AVIMException e){
                if (e == null && list != null) {
                  mLayout.pushMessagesAndRefreshToTop(IMessageWrap.buildFrom(list,true));
                }
                mLayout.getChatLt().finshRefresh();
              }
            }
);
          }
 else {
            mLayout.getChatLt().finshRefresh();
          }
        }
      }
    }
    @Override public void onLoadmore(){
    }
  }
);
  if (mRequest.size() > 0) {
    mRequest.poll();
    fetchMessages();
  }
}","@Override protected void onViewCreated(){
  super.onViewCreated();
  init();
  mLayout.setMessageListFreshListener(new ChatMessageListLayout.IMessageListFreshListener(){
    @Override public void onRefresh(){
      if (mLayout != null) {
        IMessageWrap firstMessage=mLayout.getChatLt().getFirstMessage();
        if (firstMessage == null) {
          fetchMessages().continueWith(task -> {
            mLayout.getChatLt().finshRefresh();
            return null;
          }
);
        }
 else {
          if (mAvimConversation != null) {
            mAvimConversation.queryMessages(firstMessage.message_.getMessageId(),firstMessage.message_.getTimestamp(),20,new AVIMMessagesQueryCallback(){
              @Override public void done(              List<AVIMMessage> list,              AVIMException e){
                if (e == null && list != null) {
                  mLayout.pushMessagesAndRefreshToTop(IMessageWrap.buildFrom(list,true));
                }
                mLayout.getChatLt().finshRefresh();
              }
            }
);
          }
 else {
            mLayout.getChatLt().finshRefresh();
          }
        }
      }
    }
    @Override public void onLoadmore(){
    }
  }
);
  if (mRequest.size() > 0) {
    mRequest.poll();
    fetchMessages();
  }
}",0.9632620104965685
175775,"private void init(){
  conditionSearchCi=(CommonItem)findViewById(R.id.conditionSearch);
  fillCommonItem(conditionSearchCi,R.drawable.condif,mRes.getString(R.string.conditionSearch));
  conditionSearchCi.showDivider(true);
  nearByCi=(CommonItem)findViewById(R.id.nearbyp);
  fillCommonItem(nearByCi,R.drawable.nearby,mRes.getString(R.string.nearbyp));
  nearByCi.showDivider(false);
  recyclerView=(SRecyclerView)findViewById(R.id.schoolmateList);
  recyclerView.setHasFixedSize(true);
  int orientation=LinearLayoutManager.VERTICAL;
  final LinearLayoutManager layoutManager=new LinearLayoutManager(mCtx,orientation,false);
  recyclerView.setLayoutManager(layoutManager);
  schoolMatesAdapter=new SchoolMatesAdapter();
  recyclerView.setAdapter(schoolMatesAdapter);
  final StickyRecyclerHeadersDecoration headersDecor=new StickyRecyclerHeadersDecoration(schoolMatesAdapter);
  recyclerView.addItemDecoration(headersDecor);
  recyclerView.addItemDecoration(new DividerDecoration(mCtx));
  recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener(){
    @Override public void onScrolled(    RecyclerView recyclerView,    int dx,    int dy){
      super.onScrolled(recyclerView,dx,dy);
      animateCommonItems(dy);
    }
  }
);
  smSv=(SpringView)findViewById(R.id.smLtSv);
  smSv.setHeader(new AddressRotationHeader(mAppCtx));
}","private void init(){
  conditionSearchCi=(CommonItem)findViewById(R.id.conditionSearch);
  fillCommonItem(conditionSearchCi,R.drawable.condif,mRes.getString(R.string.conditionSearch));
  conditionSearchCi.showDivider(true);
  nearByCi=(CommonItem)findViewById(R.id.nearbyp);
  fillCommonItem(nearByCi,R.drawable.nearby,mRes.getString(R.string.nearbyp));
  nearByCi.showDivider(false);
  recyclerView=(SRecyclerView)findViewById(R.id.schoolmateList);
  recyclerView.setHasFixedSize(true);
  int orientation=LinearLayoutManager.VERTICAL;
  final LinearLayoutManager layoutManager=new LinearLayoutManager(mCtx,orientation,false);
  recyclerView.setLayoutManager(layoutManager);
  schoolMatesAdapter=new SchoolMatesAdapter();
  recyclerView.setAdapter(schoolMatesAdapter);
  final StickyRecyclerHeadersDecoration headersDecor=new StickyRecyclerHeadersDecoration(schoolMatesAdapter);
  recyclerView.addItemDecoration(headersDecor);
  recyclerView.addItemDecoration(new DividerDecoration(mCtx));
  recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener(){
    @Override public void onScrolled(    RecyclerView recyclerView,    int dx,    int dy){
      super.onScrolled(recyclerView,dx,dy);
      animateCommonItems(dy);
    }
  }
);
  smSv=(SpringView)findViewById(R.id.smLtSv);
  smSv.setHeader(new AddressRotationHeader(mAct));
}",0.9973870847331092
175776,"public void setData(List<SchoolMate> result,int i){
  mRootView.postDelayed(() -> schoolMatesAdapter.addAll(result),i);
}","public void setData(List<SchoolMate> result,int i){
  handler.postDelayed(() -> schoolMatesAdapter.addAll(result),i);
}",0.9416666666666668
175777,"@Override public void onViewCreate(View root){
  super.onViewCreate(root);
  init();
}","@Override public void onViewCreate(View root){
  super.onViewCreate(root);
  handler=new Handler();
  init();
}",0.8730964467005076
175778,"@Override public void onBindHeaderViewHolder(RecyclerView.ViewHolder holder,int position){
  TextView textView=(TextView)holder.itemView;
  String showValue=String.valueOf(getItem(position).getSortLetters().charAt(0));
  textView.setText(showValue);
}","@Override public void onBindHeaderViewHolder(RecyclerView.ViewHolder holder,int position){
  NLog.i(TagUtil.makeTag(getClass()),""String_Node_Str"" + position);
  NLog.i(TagUtil.makeTag(getClass()),""String_Node_Str"" + getItem(position));
  TextView textView=(TextView)holder.itemView;
  String showValue=String.valueOf(getItem(position).getSortLetters().charAt(0));
  textView.setText(showValue);
}",0.7758887171561051
175779,"@Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent,int viewType){
  View view=null;
  if (viewType == HEADER) {
    view=LayoutInflater.from(parent.getContext()).inflate(R.layout.schoolmateheader,parent,false);
    return new RecyclerView.ViewHolder(view){
    }
;
  }
  view=LayoutInflater.from(parent.getContext()).inflate(R.layout.schoolmate_item,parent,false);
  return new SchoolMateViewHolder(view);
}","@Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent,int viewType){
  View view;
  if (viewType == HEADER) {
    view=LayoutInflater.from(parent.getContext()).inflate(R.layout.schoolmateheader,parent,false);
    return new RecyclerView.ViewHolder(view){
    }
;
  }
  view=LayoutInflater.from(parent.getContext()).inflate(R.layout.schoolmate_item,parent,false);
  return new SchoolMateViewHolder(view);
}",0.994192799070848
175780,"@Override public SchoolMate getItem(int position){
  if (position == 0) {
    return new SchoolMate();
  }
  return super.getItem(getAdjustPosition(position));
}","@Override public SchoolMate getItem(int position){
  if (position == 0) {
    return null;
  }
  return super.getItem(getAdjustPosition(position));
}",0.9483870967741936
175781,"@Override public void onBindViewHolder(RecyclerView.ViewHolder holder,int position){
  if (holder instanceof SchoolMateViewHolder) {
    ((SchoolMateViewHolder)holder).initWithModel(getItem(position));
  }
}","@Override public void onBindViewHolder(RecyclerView.ViewHolder holder,int position){
  if (position != 0) {
    ((SchoolMateViewHolder)holder).initWithModel(getItem(position));
  }
}",0.884318766066838
175782,"@Override public void notifyDataAddChanged(int position){
  if (position == -1) {
    notifyItemInserted(getItemCount() - 1);
  }
 else   if (position == 0) {
    if (super.getItemCount() > 0) {
      notifyItemRangeChanged(1,super.getItemCount());
    }
  }
 else {
    notifyItemInserted(position);
    notifyItemRangeChanged(position,super.getItemCount() - position);
  }
}","@Override public void notifyDataAddChanged(int position){
  if (position == -1) {
    notifyItemInserted(getItemCount() - 1);
  }
 else   if (position == 0) {
    notifyDataSetChanged();
  }
 else {
    notifyItemInserted(position);
    notifyItemRangeChanged(position,super.getItemCount() - position);
  }
}",0.5614035087719298
175783,"@Override public int getDragLimitHeight(View rootView){
  return rootView.getMeasuredHeight() / 4;
}","@Override public int getDragLimitHeight(View rootView){
  return rootView.getMeasuredHeight() / 3;
}",0.99
175784,"@Override public void onDropAnim(View rootView,int dy){
  int maxY=DisplayUtil.dip2px(context,60);
  float y=maxY * Math.abs(dy) / rootView.getMeasuredHeight();
  if (y > maxY)   return;
  rootView.setTranslationY(y);
  float rota=360 * dy / rootView.getMeasuredHeight();
  progress.setRotation(rota);
}","@Override public void onDropAnim(View rootView,int dy){
  float rota=360 * dy / rootView.getMeasuredHeight();
  progress.setRotation(rota);
}",0.6351351351351351
175785,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_room);
  accessToken=this.getSharedPreferences(""String_Node_Str"",0).getString(""String_Node_Str"",""String_Node_Str"");
  uid=this.getSharedPreferences(""String_Node_Str"",0).getString(""String_Node_Str"",""String_Node_Str"");
  Log.i(""String_Node_Str"",""String_Node_Str"" + uid + accessToken);
  Intent i=getIntent();
  Bundle bundle=i.getExtras();
  roomId=(String)bundle.get(""String_Node_Str"");
  usercount=(int)bundle.get(""String_Node_Str"");
  status=bundle.getString(""String_Node_Str"");
  Log.i(""String_Node_Str"",""String_Node_Str"" + status);
  RoomFragment roomFragment=new RoomFragment();
  roomFragment.setArguments(bundle);
  getSupportFragmentManager().beginTransaction().replace(R.id.room_fragment_holder,roomFragment).commit();
  roomdb=RoomsDatabase.getInstance(this);
  roomsDao=roomdb.roomsDao();
  messagesDatabase=MessagesDatabase.getInstance(this);
  messagesDao=messagesDatabase.messagesDao();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_room);
  accessToken=this.getSharedPreferences(""String_Node_Str"",0).getString(""String_Node_Str"",""String_Node_Str"");
  uid=this.getSharedPreferences(""String_Node_Str"",0).getString(""String_Node_Str"",""String_Node_Str"");
  Log.i(""String_Node_Str"",""String_Node_Str"" + uid + accessToken);
  Intent i=getIntent();
  Bundle bundle=i.getExtras();
  roomId=(String)bundle.get(""String_Node_Str"");
  usercount=(int)bundle.get(""String_Node_Str"");
  status=bundle.getString(""String_Node_Str"");
  Log.i(""String_Node_Str"",""String_Node_Str"" + status);
  RoomFragment roomFragment=new RoomFragment();
  roomFragment.setArguments(bundle);
  getSupportFragmentManager().beginTransaction().replace(R.id.room_fragment_holder,roomFragment).commit();
  roomdb=RoomsDatabase.getInstance(this);
  roomsDao=roomdb.roomsDao();
  messagesDatabase=MessagesDatabase.getInstance(this);
  messagesDao=messagesDatabase.messagesDao();
  ActionBar actionBar=getSupportActionBar();
  actionBar.setDisplayHomeAsUpEnabled(true);
}",0.9583718778908418
175786,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.leaveRoom:
    leaveRoom(roomId);
  break;
case R.id.aboutRoom:
roominfo(roomId);
break;
case R.id.favourite:
addtofav(roomId);
break;
case R.id.markRead:
markRed(roomId);
break;
}
return super.onOptionsItemSelected(item);
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.leaveRoom:
    leaveRoom(roomId);
  break;
case R.id.aboutRoom:
roominfo(roomId);
break;
case R.id.favourite:
addtofav(roomId);
break;
case R.id.markRead:
markRed(roomId);
break;
case android.R.id.home:
onBackPressed();
break;
}
return super.onOptionsItemSelected(item);
}",0.9312320916905444
175787,"@Override public int getItemCount(){
  Log.e(""String_Node_Str"",""String_Node_Str"" + messages.size());
  return messages.size();
}","@Override public int getItemCount(){
  return messages.size();
}",0.6666666666666666
175788,"@Override public void onBindViewHolder(final MessagesAdapter.MyViewHolder myViewHolder,int i){
  MessagesTable message=messages.get(i);
  myViewHolder.username.setText(message.getDisplayName());
  String timestamp=message.getTimestamp();
  Log.e(""String_Node_Str"",""String_Node_Str"" + message.getText());
  if (!timestamp.equals(""String_Node_Str"")) {
    timestamp=timestamp.substring(0,10) + ""String_Node_Str"" + timestamp.substring(11,16);
  }
  Linkify.addLinks(myViewHolder.message,Linkify.WEB_URLS);
  Picasso.get().load(message.getUserAvater()).into(myViewHolder.userImage);
  myViewHolder.time.setText(timestamp);
  myViewHolder.message.setText(message.getText());
}","@Override public void onBindViewHolder(final MessagesAdapter.MyViewHolder myViewHolder,int i){
  MessagesTable message=messages.get(i);
  myViewHolder.username.setText(message.getDisplayName());
  String timestamp=message.getTimestamp();
  if (!timestamp.equals(""String_Node_Str"")) {
    try {
      DateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
      Date date=dateFormat.parse(""String_Node_Str"");
      DateFormat formatter=new SimpleDateFormat(""String_Node_Str"");
      String dateStr=formatter.format(date);
      myViewHolder.time.setText(dateStr);
    }
 catch (    ParseException e) {
      e.printStackTrace();
    }
  }
  Linkify.addLinks(myViewHolder.message,Linkify.WEB_URLS);
  Picasso.get().load(message.getUserAvater()).into(myViewHolder.userImage);
  myViewHolder.message.setText(message.getText());
}",0.6502659574468085
175789,"@SuppressLint(""String_Node_Str"") public void displayRooms(List<RoomsTable> rooms,final String filter){
  if (rooms.size() == 0) {
    getRooms(1);
  }
  new AsyncTask<Void,Void,List<RoomsTable>>(){
    @Override protected List<RoomsTable> doInBackground(    Void... voids){
      Log.i(TAG,""String_Node_Str"" + filter);
switch (filter) {
case ""String_Node_Str"":
        return dao.getAllRooms();
case ""String_Node_Str"":
      return dao.getPeopleRooms();
default :
    return dao.getAllRooms();
}
}
@Override protected void onPostExecute(List<RoomsTable> notes){
Log.i(TAG,""String_Node_Str"" + notes.get(0).getRoomName());
mRooms.clear();
mRooms.addAll(notes);
}
}
.execute();
adapter=new RoomsAdapter(rooms,getContext());
recyclerView.setAdapter(adapter);
getRooms(0);
}","@SuppressLint(""String_Node_Str"") public void displayRooms(List<RoomsTable> rooms,final String filter){
  if (rooms.size() == 0) {
    getRooms(1);
  }
  new AsyncTask<Void,Void,List<RoomsTable>>(){
    @Override protected List<RoomsTable> doInBackground(    Void... voids){
      Log.i(TAG,""String_Node_Str"" + filter);
switch (filter) {
case ""String_Node_Str"":
        return dao.getAllRooms();
case ""String_Node_Str"":
      return dao.getPeopleRooms();
default :
    return dao.getAllRooms();
}
}
@Override protected void onPostExecute(List<RoomsTable> notes){
mRooms.clear();
mRooms.addAll(notes);
}
}
.execute();
adapter=new RoomsAdapter(rooms,getContext());
recyclerView.setAdapter(adapter);
getRooms(0);
}",0.77079107505071
175790,"@Override public boolean onClose(){
  displayRooms(mRooms);
  return false;
}","@Override public boolean onClose(){
  displayRooms(mRooms,filter);
  return false;
}",0.9565217391304348
175791,"@SuppressLint(""String_Node_Str"") public void displayRooms(List<RoomsTable> rooms,final String filter){
  if (rooms.size() == 0) {
    getRooms(1);
  }
  new AsyncTask<Void,Void,List<RoomsTable>>(){
    @Override protected List<RoomsTable> doInBackground(    Void... voids){
      Log.i(TAG,""String_Node_Str"" + filter);
switch (filter) {
case ""String_Node_Str"":
        return dao.getAllRooms();
case ""String_Node_Str"":
      return dao.getPeopleRooms();
default :
    return dao.getAllRooms();
}
}
@Override protected void onPostExecute(List<RoomsTable> notes){
Log.i(TAG,""String_Node_Str"" + notes.get(0).getRoomName());
mRooms.clear();
mRooms.addAll(notes);
}
}
.execute();
adapter=new RoomsAdapter(rooms,getContext());
recyclerView.setAdapter(adapter);
getRooms(0);
}","@SuppressLint(""String_Node_Str"") public void displayRooms(List<RoomsTable> rooms,final String filter){
  if (rooms.size() == 0) {
    getRooms(1);
  }
  new AsyncTask<Void,Void,List<RoomsTable>>(){
    @Override protected List<RoomsTable> doInBackground(    Void... voids){
      Log.i(TAG,""String_Node_Str"" + filter);
switch (filter) {
case ""String_Node_Str"":
        return dao.getAllRooms();
case ""String_Node_Str"":
      return dao.getPeopleRooms();
default :
    return dao.getAllRooms();
}
}
@Override protected void onPostExecute(List<RoomsTable> notes){
mRooms.clear();
mRooms.addAll(notes);
}
}
.execute();
adapter=new RoomsAdapter(rooms,getContext());
recyclerView.setAdapter(adapter);
getRooms(0);
}",0.77079107505071
175792,"@Override public void onCreateOptionsMenu(Menu menu,MenuInflater inflater){
  inflater.inflate(R.menu.my_options_menu,menu);
  MenuItem item=menu.findItem(R.id.search);
  SearchView searchView=(SearchView)item.getActionView();
  searchView.setOnCloseListener(new SearchView.OnCloseListener(){
    @Override public boolean onClose(){
      displayRooms(mRooms);
      return false;
    }
  }
);
  searchView.setOnQueryTextListener(new SearchView.OnQueryTextListener(){
    @Override public boolean onQueryTextSubmit(    String query){
      return false;
    }
    @Override public boolean onQueryTextChange(    String newText){
      mRooms.clear();
      adapter.notifyDataSetChanged();
      searchRooms(newText);
      return true;
    }
  }
);
  super.onCreateOptionsMenu(menu,inflater);
}","@Override public void onCreateOptionsMenu(Menu menu,MenuInflater inflater){
  inflater.inflate(R.menu.my_options_menu,menu);
  MenuItem item=menu.findItem(R.id.search);
  SearchView searchView=(SearchView)item.getActionView();
  searchView.setOnCloseListener(new SearchView.OnCloseListener(){
    @Override public boolean onClose(){
      displayRooms(mRooms,filter);
      return false;
    }
  }
);
  searchView.setOnQueryTextListener(new SearchView.OnQueryTextListener(){
    @Override public boolean onQueryTextSubmit(    String query){
      return false;
    }
    @Override public boolean onQueryTextChange(    String newText){
      mRooms.clear();
      adapter.notifyDataSetChanged();
      searchRooms(newText);
      return true;
    }
  }
);
  super.onCreateOptionsMenu(menu,inflater);
}",0.9956057752667922
175793,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.action_search:
    openSearchFragment();
  break;
case R.id.action_scan_book:
ShowUtils.showToast(""String_Node_Str"");
break;
case R.id.action_theme:
ColorPickerDialog colorPickerDialog=new ColorPickerDialog(this);
colorPickerDialog.setOnColorSelectedListener(themeColor -> {
Colorful.config(this).primaryColor(themeColor).accentColor(themeColor).translucent(false).dark(ThemeUtils.isDarkMode()).apply();
changeTheme();
}
);
colorPickerDialog.show();
break;
case R.id.action_dark_theme:
boolean darkMode;
if (Constant.LIGHT_THEME.equals(item.getTitle())) {
AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO);
darkMode=false;
}
 else {
AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES);
darkMode=true;
}
Colorful.config(this).dark(darkMode).apply();
changeTheme();
break;
}
return super.onOptionsItemSelected(item);
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.action_search:
    openSearchFragment();
  break;
case R.id.action_scan_book:
ShowUtils.showToast(""String_Node_Str"");
break;
case R.id.action_theme:
ColorPickerDialog colorPickerDialog=new ColorPickerDialog(this);
colorPickerDialog.setOnColorSelectedListener(themeColor -> {
Colorful.config(this).primaryColor(themeColor).accentColor(themeColor).translucent(false).dark(ThemeUtils.isDarkMode()).apply();
changeTheme();
}
);
colorPickerDialog.show();
break;
case R.id.action_dark_theme:
boolean darkMode;
if (Constant.LIGHT_THEME.equals(item.getTitle())) {
darkMode=false;
}
 else {
darkMode=true;
}
Colorful.config(this).dark(darkMode).apply();
changeTheme();
break;
}
return super.onOptionsItemSelected(item);
}",0.9181253529079616
175794,"@Override public boolean onCabItemClicked(MenuItem item){
switch (item.getItemId()) {
case R.id.action_select_all:
    if (UIUtils.getString(R.string.select_all).equals(item.getTitle())) {
      item.setTitle(UIUtils.getString(R.string.un_select_all));
      mRecommendAdapter.selectAll();
      mSelectedBooks.clear();
      mSelectedBooks.addAll(mRecommendAdapter.getDataList());
      setMaterialCabTitle();
    }
 else {
      item.setTitle(UIUtils.getString(R.string.select_all));
      mRecommendAdapter.clearSelected();
      mCab.setTitle(UIUtils.getString(R.string.book_manage));
      mSelectedBooks.clear();
    }
  mCab.getMenu().findItem(R.id.action_delete).setEnabled(!mSelectedBooks.isEmpty());
mRecommendAdapter.notifyDataSetChanged();
break;
case R.id.action_delete:
final boolean[] selected={true};
new AlertDialog.Builder(mActivity).setTitle(UIUtils.getString(R.string.remove_selected_book)).setMultiChoiceItems(new String[]{UIUtils.getString(R.string.delete_local_cache)},selected,(dialogInterface,which,isChecked) -> selected[0]=isChecked).setPositiveButton(""String_Node_Str"",(dialogInterface,which) -> new BatchManageTask().execute(mSelectedBooks,selected[0])).setNegativeButton(""String_Node_Str"",null).create().show();
break;
}
return true;
}","@Override public boolean onCabItemClicked(MenuItem item){
switch (item.getItemId()) {
case R.id.action_select_all:
    if (UIUtils.getString(R.string.select_all).equals(item.getTitle())) {
      item.setTitle(UIUtils.getString(R.string.un_select_all));
      mRecommendAdapter.selectAll();
      mSelectedBooks.clear();
      mSelectedBooks.addAll(mRecommendAdapter.getDataList());
      setMaterialCabTitle();
    }
 else {
      item.setTitle(UIUtils.getString(R.string.select_all));
      mRecommendAdapter.clearSelected();
      mCab.setTitle(UIUtils.getString(R.string.book_manage));
      mSelectedBooks.clear();
    }
  mCab.getMenu().findItem(R.id.action_delete).setEnabled(!mSelectedBooks.isEmpty());
mRecommendAdapter.notifyDataSetChanged();
break;
case R.id.action_delete:
batchManage(mSelectedBooks);
break;
}
return true;
}",0.7615421227986673
175795,"@Override protected void initListener(){
  mRefreshLayout.setOnRefreshListener(new RefreshListenerAdapter(){
    @Override public void onRefresh(    TwinklingRefreshLayout refreshLayout){
      UIUtils.getHandler().postDelayed(() -> {
        List<Recommend.BooksBean> recommend=RecommendManager.getInstance().getRecommend();
        if (mRecommendAdapter != null)         mRecommendAdapter.replaceAll(recommend);
        refreshLayout.finishRefreshing();
      }
,250);
    }
    @Override public void onFinishRefresh(){
      checkIsEmpty();
    }
  }
);
  mRecommendAdapter.setOnItemLongClickListener((holder,position,item) -> new BookDialog(mContext).setBookTitle(item.getTitle()).setFromSDCard(item.isFromSD()).setOnDialogItemClickListener((dialog,viewHolder,pos,str) -> {
    dialog.dismissDialog();
    if (dialog.isFromSDCard()) {
switch (pos) {
case 0:
        break;
case 1:
      break;
case 2:
    break;
}
}
 else {
switch (pos) {
case 0:
  NavigationUtils.goToBookDetailPage(mActivity,item.getBookId(),false);
break;
case 1:
break;
case 2:
break;
case 3:
mCab=getActivity(MainActivity.class).openCab(R.menu.menu_book_manage,this);
mRecommendAdapter.longTouchSelectModeEnable(true);
break;
}
}
}
).showDialog());
mRecommendAdapter.setItemSelectedListener(new SelectAdapter.OnItemSelectedListener<Recommend.BooksBean>(){
@Override public void onItemSelected(BaseViewHolder viewHolder,int position,boolean isSelected,Recommend.BooksBean booksBean){
if (isSelected) {
mSelectedBooks.add(booksBean);
}
 else {
mSelectedBooks.remove(booksBean);
}
setMaterialCabTitle();
mCab.getMenu().findItem(R.id.action_delete).setEnabled(!mSelectedBooks.isEmpty());
mCab.getMenu().findItem(R.id.action_select_all).setTitle(mSelectedBooks.size() == mRecommendAdapter.getDataListSize() ? UIUtils.getString(R.string.un_select_all) : UIUtils.getString(R.string.select_all));
}
@Override public void onNothingSelected(){
}
}
);
mRecommendAdapter.setOnItemClickListener((holder,position,item) -> NavigationUtils.goToBookReadPage(mActivity,item));
}","@Override protected void initListener(){
  mRefreshLayout.setOnRefreshListener(new RefreshListenerAdapter(){
    @Override public void onRefresh(    TwinklingRefreshLayout refreshLayout){
      UIUtils.getHandler().postDelayed(() -> {
        List<Recommend.BooksBean> recommend=RecommendManager.getInstance().getRecommend();
        if (mRecommendAdapter != null)         mRecommendAdapter.replaceAll(recommend);
        refreshLayout.finishRefreshing();
      }
,250);
    }
    @Override public void onFinishRefresh(){
      checkIsEmpty();
    }
  }
);
  mRecommendAdapter.setOnItemLongClickListener((holder,position,item) -> new BookDialog(mContext).setBookTitle(item.getTitle()).setFromSDCard(item.isFromSD()).setOnDialogItemClickListener((dialog,viewHolder,pos,str) -> {
    dialog.dismissDialog();
    if (dialog.isFromSDCard()) {
switch (pos) {
case 0:
        break;
case 1:
      break;
case 2:
    break;
}
}
 else {
switch (pos) {
case 0:
  NavigationUtils.goToBookDetailPage(mActivity,item.getBookId(),false);
break;
case 1:
break;
case 2:
List<Recommend.BooksBean> selectedBooks=new ArrayList<>();
selectedBooks.add(mRecommendAdapter.getItem(position));
batchManage(selectedBooks);
break;
case 3:
mCab=getActivity(MainActivity.class).openCab(R.menu.menu_book_manage,this);
mRecommendAdapter.longTouchSelectModeEnable(true);
break;
}
}
}
).showDialog());
mRecommendAdapter.setItemSelectedListener(new SelectAdapter.OnItemSelectedListener<Recommend.BooksBean>(){
@Override public void onItemSelected(BaseViewHolder viewHolder,int position,boolean isSelected,Recommend.BooksBean booksBean){
if (isSelected) {
mSelectedBooks.add(booksBean);
}
 else {
mSelectedBooks.remove(booksBean);
}
setMaterialCabTitle();
mCab.getMenu().findItem(R.id.action_delete).setEnabled(!mSelectedBooks.isEmpty());
mCab.getMenu().findItem(R.id.action_select_all).setTitle(mSelectedBooks.size() == mRecommendAdapter.getDataListSize() ? UIUtils.getString(R.string.un_select_all) : UIUtils.getString(R.string.select_all));
}
@Override public void onNothingSelected(){
}
}
);
mRecommendAdapter.setOnItemClickListener((holder,position,item) -> NavigationUtils.goToBookReadPage(mActivity,item));
}",0.9660896371828314
175796,"public View getView(final int position,View convertView,final ViewGroup parent){
  final Holder holder;
  if (convertView == null) {
    holder=new Holder();
    convertView=context.getLayoutInflater().inflate(R.layout.item,null);
    holder.imgAvator=(SimpleDraweeView)convertView.findViewById(R.id.imgAvator);
    holder.tvAuthor=(TextView)convertView.findViewById(R.id.tvAuthor);
    holder.tvContent=(TextView)convertView.findViewById(R.id.tvContent);
    holder.imgZan=(ImageView)convertView.findViewById(R.id.imgZan);
    holder.tvPreferUserList=(TextView)convertView.findViewById(R.id.tvPreferUserList);
    holder.tvTime=(TextView)convertView.findViewById(R.id.tvTime);
    holder.llComments=(LinearLayout)convertView.findViewById(R.id.llComments);
    convertView.setTag(holder);
  }
 else {
    holder=(Holder)convertView.getTag();
  }
  News news=newsList.get(position);
  holder.tvAuthor.setText(news.author);
  holder.tvContent.setText(news.content);
  holder.tvTime.setText(news.showtime);
  if (news.preferList != null) {
    StringBuilder sb=new StringBuilder();
    for (    String user : news.preferList) {
      sb.append(user);
      sb.append(""String_Node_Str"");
    }
    sb.deleteCharAt(sb.length() - 1);
    holder.tvPreferUserList.setText(sb.toString());
  }
 else {
    holder.imgZan.setVisibility(View.GONE);
    holder.tvPreferUserList.setText(""String_Node_Str"");
  }
  holder.llComments.removeAllViews();
  if (news.commentList != null) {
    for (    Comment comment : news.commentList) {
      TextView tvComment=new TextView(convertView.getContext());
      tvComment.setText(comment.author + ""String_Node_Str"" + comment.content);
      holder.llComments.addView(tvComment);
    }
  }
 else {
  }
  return convertView;
}","public View getView(final int position,View convertView,final ViewGroup parent){
  final Holder holder;
  if (convertView == null) {
    holder=new Holder();
    convertView=context.getLayoutInflater().inflate(R.layout.item,null);
    holder.imgAvator=(SimpleDraweeView)convertView.findViewById(R.id.imgAvator);
    holder.tvAuthor=(TextView)convertView.findViewById(R.id.tvAuthor);
    holder.tvContent=(TextView)convertView.findViewById(R.id.tvContent);
    holder.imgZan=(ImageView)convertView.findViewById(R.id.imgZan);
    holder.tvPreferUserList=(TextView)convertView.findViewById(R.id.tvPreferUserList);
    holder.tvTime=(TextView)convertView.findViewById(R.id.tvTime);
    holder.llComments=(LinearLayout)convertView.findViewById(R.id.llComments);
    convertView.setTag(holder);
  }
 else {
    holder=(Holder)convertView.getTag();
  }
  News news=newsList.get(position);
  holder.tvAuthor.setText(news.author);
  holder.tvContent.setText(news.content);
  holder.tvTime.setText(news.showtime);
  holder.imgAvator.setImageURI(Uri.parse(news.avator));
  if (news.preferList != null) {
    StringBuilder sb=new StringBuilder();
    for (    String user : news.preferList) {
      sb.append(user);
      sb.append(""String_Node_Str"");
    }
    sb.deleteCharAt(sb.length() - 1);
    holder.tvPreferUserList.setText(sb.toString());
  }
 else {
    holder.imgZan.setVisibility(View.GONE);
    holder.tvPreferUserList.setText(""String_Node_Str"");
  }
  holder.llComments.removeAllViews();
  if (news.commentList != null) {
    for (    Comment comment : news.commentList) {
      TextView tvComment=new TextView(convertView.getContext());
      tvComment.setText(comment.author + ""String_Node_Str"" + comment.content);
      holder.llComments.addView(tvComment);
    }
  }
 else {
  }
  return convertView;
}",0.9842696629213484
175797,"public Function<ContainerRequest,T> getValueProvider(final Parameter parameter){
  return (request) -> {
    if (parameter.isAnnotationPresent(FernetSecret.class)) {
      final Collection<? extends Key> keys=getKeySupplier().get();
      final Token xAuthorizationToken=getHeaderUtility().getXAuthorizationToken(request);
      if (xAuthorizationToken != null) {
        return getValidator().validateAndDecrypt(keys,xAuthorizationToken);
      }
      final Token authorizationToken=getHeaderUtility().getAuthorizationToken(request);
      if (authorizationToken != null) {
        return getValidator().validateAndDecrypt(keys,authorizationToken);
      }
      throw new WebApplicationException(status(UNAUTHORIZED).entity(""String_Node_Str"").build());
    }
    throw new IllegalStateException(""String_Node_Str"");
  }
;
}","public Function<ContainerRequest,T> getValueProvider(final Parameter parameter){
  return request -> {
    if (parameter.isAnnotationPresent(FernetSecret.class)) {
      final Collection<? extends Key> keys=getKeySupplier().get();
      final Token xAuthorizationToken=getHeaderUtility().getXAuthorizationToken(request);
      if (xAuthorizationToken != null) {
        return getValidator().validateAndDecrypt(keys,xAuthorizationToken);
      }
      final Token authorizationToken=getHeaderUtility().getAuthorizationToken(request);
      if (authorizationToken != null) {
        return getValidator().validateAndDecrypt(keys,authorizationToken);
      }
      throw new WebApplicationException(status(UNAUTHORIZED).entity(""String_Node_Str"").build());
    }
    throw new IllegalStateException(""String_Node_Str"");
  }
;
}",0.9987864077669902
175798,"public Function<ContainerRequest,Token> getValueProvider(final Parameter parameter){
  return (request) -> {
    if (parameter.getRawType().equals(Token.class) && parameter.isAnnotationPresent(FernetToken.class)) {
      final Token xAuthorizationToken=getTokenHeaderUtility().getXAuthorizationToken(request);
      if (xAuthorizationToken != null) {
        return xAuthorizationToken;
      }
      final Token authorizationToken=getTokenHeaderUtility().getAuthorizationToken(request);
      if (authorizationToken != null) {
        return authorizationToken;
      }
      throw new WebApplicationException(status(UNAUTHORIZED).entity(""String_Node_Str"").build());
    }
    throw new IllegalStateException(""String_Node_Str"");
  }
;
}","public Function<ContainerRequest,Token> getValueProvider(final Parameter parameter){
  return request -> {
    if (parameter.getRawType().equals(Token.class) && parameter.isAnnotationPresent(FernetToken.class)) {
      final Token xAuthorizationToken=getTokenHeaderUtility().getXAuthorizationToken(request);
      if (xAuthorizationToken != null) {
        return xAuthorizationToken;
      }
      final Token authorizationToken=getTokenHeaderUtility().getAuthorizationToken(request);
      if (authorizationToken != null) {
        return authorizationToken;
      }
      throw new WebApplicationException(status(UNAUTHORIZED).entity(""String_Node_Str"").build());
    }
    throw new IllegalStateException(""String_Node_Str"");
  }
;
}",0.998641304347826
175799,"/** 
 * This demonstrates a client who provides the correct credentials, a valid token, but does not pass the business rules required to access the protected resource.
 */
@Test public final void verifyFailedBusinessRuleCheck(){
  final LoginRequest login=new LoginRequest(""String_Node_Str"",""String_Node_Str"");
  final Entity<LoginRequest> entity=Entity.json(login);
  final String tokenString=target(""String_Node_Str"").request().accept(MediaType.TEXT_PLAIN_TYPE).post(entity,String.class);
  thrown.expect(NotAuthorizedException.class);
  target(""String_Node_Str"").request().header(""String_Node_Str"",tokenString).get(String.class);
}","/** 
 * This demonstrates a client who provides the correct credentials, a valid token, but does not pass the business rules required to access the protected resource.
 */
@Test public final void verifyFailedBusinessRuleCheck(){
  final LoginRequest login=new LoginRequest(""String_Node_Str"",""String_Node_Str"");
  final Entity<LoginRequest> entity=Entity.json(login);
  final String tokenString=target(""String_Node_Str"").request().accept(MediaType.TEXT_PLAIN_TYPE).post(entity,String.class);
  thrown.expect(NotAuthorizedException.class);
  target(""String_Node_Str"").request().header(""String_Node_Str"",""String_Node_Str"" + tokenString).get(String.class);
}",0.984472049689441
175800,"/** 
 * This demonstrates a client who provides the correct credentials, a valid token, and passes all of the business rules to access the protected resource.
 */
@Test public final void verifySuccessfulBusinessRuleCheck(){
  final LoginRequest login=new LoginRequest(""String_Node_Str"",""String_Node_Str"");
  final Entity<LoginRequest> entity=Entity.json(login);
  final String tokenString=target(""String_Node_Str"").request().accept(MediaType.TEXT_PLAIN_TYPE).post(entity,String.class);
  final String result=target(""String_Node_Str"").request().header(""String_Node_Str"",tokenString).get(String.class);
  assertEquals(""String_Node_Str"",result);
}","/** 
 * This demonstrates a client who provides the correct credentials, a valid token, and passes all of the business rules to access the protected resource.
 */
@Test public final void verifySuccessfulBusinessRuleCheck(){
  final LoginRequest login=new LoginRequest(""String_Node_Str"",""String_Node_Str"");
  final Entity<LoginRequest> entity=Entity.json(login);
  final String tokenString=target(""String_Node_Str"").request().accept(MediaType.TEXT_PLAIN_TYPE).post(entity,String.class);
  final String result=target(""String_Node_Str"").request().header(""String_Node_Str"",""String_Node_Str"" + tokenString).get(String.class);
  assertEquals(""String_Node_Str"",result);
}",0.9847094801223242
175801,"/** 
 * This demonstrates a client who attempts to forge a Fernet token but cannot do so without knowing the secret key.
 */
@Test public final void verifyFailedForgery(){
  final Random random=new SecureRandom();
  final Key invalidKey=Key.generateKey(random);
  final Token forgedToken=Token.generate(random,invalidKey,""String_Node_Str"");
  final String tokenString=forgedToken.serialise();
  thrown.expect(NotAuthorizedException.class);
  target(""String_Node_Str"").request().header(""String_Node_Str"",tokenString).get(String.class);
}","/** 
 * This demonstrates a client who attempts to forge a Fernet token but cannot do so without knowing the secret key.
 */
@Test public final void verifyFailedForgery(){
  final Random random=new SecureRandom();
  final Key invalidKey=Key.generateKey(random);
  final Token forgedToken=Token.generate(random,invalidKey,""String_Node_Str"");
  final String tokenString=forgedToken.serialise();
  thrown.expect(NotAuthorizedException.class);
  target(""String_Node_Str"").request().header(""String_Node_Str"",""String_Node_Str"" + tokenString).get(String.class);
}",0.9816849816849816
175802,"@Override public void getConnection(ProxyTarget target,HttpServerExchange exchange,ProxyCallback<ProxyConnection> callback,long timeout,TimeUnit timeUnit){
  Realm realm=realmCache.matches(exchange.getRequestPath());
  if (realm != null) {
    parseToken(exchange).ifPresent(token -> {
      Optional<UserPermissionPrincipal> principal=authenticate(realm.getId(),token);
      principal.ifPresent(p -> {
        Map<String,Object> body=new HashMap<>();
        body.put(""String_Node_Str"",p.getName());
        body.put(""String_Node_Str"",p.getPermissions());
        p.getProfiles().forEach((k,v) -> {
          body.put(k,v);
        }
);
        exchange.getRequestHeaders().put(HttpString.tryFromString(config.getBackendHeaderName()),jwt.sign(body,jwtHeader,null));
      }
);
    }
);
  }
 else {
    exchange.setStatusCode(404);
    exchange.endExchange();
    return;
  }
  Application application=realmCache.getApplication(realm);
  ClientConnection existing=exchange.getConnection().getAttachment(clientAttachmentKey);
  if (existing != null) {
    if (existing.isOpen()) {
      String path=exchange.getRequestPath();
      if (path.startsWith(application.getVirtualPath())) {
        String passTo=calculatePathTo(path,application);
        exchange.setRequestPath(passTo);
        exchange.setRequestURI(passTo);
      }
      callback.completed(exchange,new ProxyConnection(existing,""String_Node_Str""));
      return;
    }
 else {
      exchange.getConnection().removeAttachment(clientAttachmentKey);
    }
  }
  try {
    URI uri=application.getUriToPass();
    client.connect(new ConnectNotifier(callback,exchange),new URI(uri.getScheme(),null,uri.getHost(),uri.getPort(),null,null,null),exchange.getIoThread(),exchange.getConnection().getByteBufferPool(),OptionMap.EMPTY);
  }
 catch (  URISyntaxException e) {
    throw new MisconfigurationException(""String_Node_Str"",application.getUriToPass(),e);
  }
}","@Override public void getConnection(ProxyTarget target,HttpServerExchange exchange,ProxyCallback<ProxyConnection> callback,long timeout,TimeUnit timeUnit){
  Realm realm=realmCache.matches(exchange.getRequestPath());
  if (realm != null) {
    parseToken(exchange).ifPresent(token -> {
      Optional<UserPermissionPrincipal> principal=authenticate(realm.getId(),token);
      principal.ifPresent(p -> {
        Map<String,Object> body=new HashMap<>();
        body.put(""String_Node_Str"",p.getName());
        body.put(""String_Node_Str"",p.getPermissions());
        p.getProfiles().forEach((k,v) -> {
          body.put(k,v);
        }
);
        exchange.getRequestHeaders().put(HttpString.tryFromString(config.getBackendHeaderName()),jwt.sign(body,jwtHeader,null));
      }
);
    }
);
  }
 else {
    exchange.setStatusCode(404);
    exchange.endExchange();
    return;
  }
  Application application=realmCache.getApplication(realm);
  ClientConnection existing=exchange.getConnection().getAttachment(clientAttachmentKey);
  if (existing != null) {
    if (existing.isOpen()) {
      String path=exchange.getRequestURI();
      if (path.startsWith(application.getVirtualPath())) {
        String passTo=calculatePathTo(path,application);
        exchange.setRequestPath(passTo);
        exchange.setRequestURI(passTo);
      }
      callback.completed(exchange,new ProxyConnection(existing,""String_Node_Str""));
      return;
    }
 else {
      exchange.getConnection().removeAttachment(clientAttachmentKey);
    }
  }
  try {
    URI uri=application.getUriToPass();
    client.connect(new ConnectNotifier(callback,exchange),new URI(uri.getScheme(),null,uri.getHost(),uri.getPort(),null,null,null),exchange.getIoThread(),exchange.getConnection().getByteBufferPool(),OptionMap.EMPTY);
  }
 catch (  URISyntaxException e) {
    throw new MisconfigurationException(""String_Node_Str"",application.getUriToPass(),e);
  }
}",0.9981766084917948
175803,"@Override public void completed(final ClientConnection connection){
  final ServerConnection serverConnection=exchange.getConnection();
  serverConnection.putAttachment(clientAttachmentKey,connection);
  serverConnection.addCloseListener(serverConnection1 -> IoUtils.safeClose(connection));
  connection.getCloseSetter().set((ChannelListener<Channel>)channel -> serverConnection.removeAttachment(clientAttachmentKey));
  exchange.setRelativePath(""String_Node_Str"");
  Realm realm=realmCache.matches(exchange.getRequestPath());
  Application application=realmCache.getApplication(realm);
  String path=exchange.getRequestPath();
  if (path.startsWith(application.getVirtualPath())) {
    String passTo=calculatePathTo(path,application);
    exchange.setRequestPath(passTo);
    exchange.setRequestURI(passTo);
  }
  callback.completed(exchange,new ProxyConnection(connection,""String_Node_Str""));
}","@Override public void completed(final ClientConnection connection){
  final ServerConnection serverConnection=exchange.getConnection();
  serverConnection.putAttachment(clientAttachmentKey,connection);
  serverConnection.addCloseListener(serverConnection1 -> IoUtils.safeClose(connection));
  connection.getCloseSetter().set((ChannelListener<Channel>)channel -> serverConnection.removeAttachment(clientAttachmentKey));
  exchange.setRelativePath(""String_Node_Str"");
  Realm realm=realmCache.matches(exchange.getRequestPath());
  Application application=realmCache.getApplication(realm);
  String path=exchange.getRequestURI();
  if (path.startsWith(application.getVirtualPath())) {
    String passTo=calculatePathTo(path,application);
    exchange.setRequestPath(passTo);
    exchange.setRequestURI(passTo);
  }
  callback.completed(exchange,new ProxyConnection(connection,""String_Node_Str""));
}",0.8040201005025126
175804,"public static void main(String[] args){
  CommandLineParser parser=new DefaultParser();
  Boolean isDebug=false;
  try {
    CommandLine commandline=parser.parse(opt,args);
    if (commandline.getOptions().length == 0 && commandline.getArgs().length > 0) {
      CmdCaller.main(args);
      return;
    }
    if (commandline.hasOption(""String_Node_Str"")) {
      usage(null);
      return;
    }
    String ak=commandline.getOptionValue(""String_Node_Str"");
    String sk=commandline.getOptionValue(""String_Node_Str"");
    String api=commandline.getOptionValue(""String_Node_Str"");
    String version=commandline.getOptionValue(""String_Node_Str"");
    String method=commandline.getOptionValue(""String_Node_Str"");
    String[] headers=commandline.getOptionValues(""String_Node_Str"");
    String[] params=commandline.getOptionValues(""String_Node_Str"");
    String url=commandline.getOptionValue(""String_Node_Str"");
    String proxy=commandline.getOptionValue(""String_Node_Str"");
    String cbJSON=commandline.getOptionValue(""String_Node_Str"");
    boolean nonce=commandline.hasOption(""String_Node_Str"");
    isDebug=commandline.hasOption(""String_Node_Str"");
    if (isDebug) {
      System.out.println(""String_Node_Str"" + url);
      System.out.println(""String_Node_Str"" + api);
      System.out.println(""String_Node_Str"" + version);
      System.out.println(""String_Node_Str"" + ak);
      System.out.println(""String_Node_Str"" + sk);
      System.out.println(""String_Node_Str"" + proxy);
      System.out.println(""String_Node_Str"" + nonce);
      printKV(""String_Node_Str"",headers);
      printKV(""String_Node_Str"",params);
    }
    if (isEmpty(api)) {
      usage(MessageHelper.getMessage(""String_Node_Str"",""String_Node_Str""));
      return;
    }
    if (isEmpty(version)) {
      usage(MessageHelper.getMessage(""String_Node_Str"",""String_Node_Str""));
      return;
    }
    if (isEmpty(url)) {
      usage(MessageHelper.getMessage(""String_Node_Str"",""String_Node_Str""));
      return;
    }
    if (method == null) {
      method=""String_Node_Str"";
    }
    HttpParameters.Builder builder=HttpParameters.newBuilder();
    builder.api(api).version(version).method(method).requestURL(url).accessKey(ak).secretKey(sk);
    if (headers != null) {
      for (      String header : headers) {
        String[] kv=header.split(""String_Node_Str"",2);
        if (kv == null || kv.length != 2) {
          System.out.println(""String_Node_Str"" + header);
          return;
        }
        builder.putHeaderParamsMap(kv[0],kv[1]);
      }
    }
    if (params != null) {
      for (      String param : params) {
        String[] kv=param.split(""String_Node_Str"",2);
        if (kv == null || kv.length != 2) {
          System.out.println(MessageHelper.getMessage(""String_Node_Str"",param));
          return;
        }
        builder.putParamsMap(kv[0],kv[1]);
      }
    }
    if (cbJSON != null) {
      if (""String_Node_Str"".equalsIgnoreCase(method) || ""String_Node_Str"".equalsIgnoreCase(method)) {
        System.out.println(MessageHelper.getMessage(""String_Node_Str""));
        return;
      }
      if (cbJSON.startsWith(""String_Node_Str"")) {
        System.out.println(MessageHelper.getMessage(""String_Node_Str""));
        return;
      }
      builder.contentBody(new ContentBody(cbJSON));
    }
    builder.nonce(nonce);
    boolean curlOnly=false;
    if (method.toLowerCase().startsWith(""String_Node_Str"")) {
      curlOnly=true;
      HttpCaller.setCurlResponse(true);
    }
    StringBuffer resHttpHeaders=new StringBuffer();
    if (proxy != null) {
      String errMsg=MessageHelper.getMessage(""String_Node_Str"",proxy);
      String[] pcs=proxy.split(""String_Node_Str"");
      if (pcs == null || pcs.length != 2) {
        System.out.println(errMsg);
        return;
      }
      try {
        HttpCaller.setProxyHost(pcs[0],Integer.parseInt(pcs[1]),null);
      }
 catch (      Exception e) {
        System.out.println(errMsg);
        return;
      }
    }
    String ret=HttpCaller.invoke(builder.build(),resHttpHeaders);
    if (curlOnly) {
      System.out.println(""String_Node_Str"" + ret);
    }
 else {
      System.out.println(""String_Node_Str"" + resHttpHeaders.toString());
      System.out.println(""String_Node_Str"" + ret);
      System.out.println(""String_Node_Str"" + HttpCaller.changeCharset(ret));
      int times=Integer.getInteger(""String_Node_Str"",0);
      for (int i=2; i <= times; i++) {
        ret=HttpCaller.invoke(builder.build(),null);
        System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ ret);
      }
    }
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    if (isDebug)     e.printStackTrace(System.out);
  }
}","public static void main(String[] args){
  CommandLineParser parser=new DefaultParser();
  Boolean isDebug=false;
  try {
    CommandLine commandline=parser.parse(opt,args);
    if (commandline.getOptions().length == 0 && commandline.getArgs().length > 0) {
      CmdCaller.main(args);
      return;
    }
    if (commandline.hasOption(""String_Node_Str"")) {
      usage(null);
      return;
    }
    String ak=commandline.getOptionValue(""String_Node_Str"");
    String sk=commandline.getOptionValue(""String_Node_Str"");
    String api=commandline.getOptionValue(""String_Node_Str"");
    String version=commandline.getOptionValue(""String_Node_Str"");
    String method=commandline.getOptionValue(""String_Node_Str"");
    String[] headers=commandline.getOptionValues(""String_Node_Str"");
    String[] params=commandline.getOptionValues(""String_Node_Str"");
    String url=commandline.getOptionValue(""String_Node_Str"");
    String proxy=commandline.getOptionValue(""String_Node_Str"");
    String cbJSON=commandline.getOptionValue(""String_Node_Str"");
    boolean nonce=commandline.hasOption(""String_Node_Str"");
    isDebug=commandline.hasOption(""String_Node_Str"");
    if (isDebug) {
      System.out.println(""String_Node_Str"" + url);
      System.out.println(""String_Node_Str"" + api);
      System.out.println(""String_Node_Str"" + version);
      System.out.println(""String_Node_Str"" + ak);
      System.out.println(""String_Node_Str"" + sk);
      System.out.println(""String_Node_Str"" + proxy);
      System.out.println(""String_Node_Str"" + nonce);
      printKV(""String_Node_Str"",headers);
      printKV(""String_Node_Str"",params);
    }
    if (isEmpty(api)) {
      usage(MessageHelper.getMessage(""String_Node_Str"",""String_Node_Str""));
      return;
    }
    if (isEmpty(version)) {
      usage(MessageHelper.getMessage(""String_Node_Str"",""String_Node_Str""));
      return;
    }
    if (isEmpty(url)) {
      usage(MessageHelper.getMessage(""String_Node_Str"",""String_Node_Str""));
      return;
    }
    if (method == null) {
      method=""String_Node_Str"";
    }
    HttpParameters.Builder builder=HttpParameters.newBuilder();
    builder.api(api).version(version).method(method).requestURL(url).accessKey(ak).secretKey(sk);
    if (headers != null) {
      for (      String header : headers) {
        String[] kv=header.split(""String_Node_Str"",2);
        if (kv == null || kv.length != 2) {
          System.out.println(""String_Node_Str"" + header);
          return;
        }
        builder.putHeaderParamsMap(kv[0],kv[1]);
      }
    }
    if (params != null) {
      for (      String param : params) {
        String[] kv=param.split(""String_Node_Str"",2);
        if (kv == null || kv.length != 2) {
          System.out.println(MessageHelper.getMessage(""String_Node_Str"",param));
          return;
        }
        builder.putParamsMap(kv[0],kv[1]);
      }
    }
    if (cbJSON != null) {
      if (""String_Node_Str"".equalsIgnoreCase(method) || ""String_Node_Str"".equalsIgnoreCase(method)) {
        System.out.println(MessageHelper.getMessage(""String_Node_Str""));
        return;
      }
      if (cbJSON.startsWith(""String_Node_Str"")) {
        System.out.println(MessageHelper.getMessage(""String_Node_Str""));
        return;
      }
      builder.contentBody(new ContentBody(cbJSON));
    }
    builder.nonce(nonce);
    boolean curlOnly=false;
    if (method.toLowerCase().startsWith(""String_Node_Str"")) {
      curlOnly=true;
      HttpCaller.setCurlResponse(true);
    }
    StringBuffer resHttpHeaders=new StringBuffer();
    if (proxy != null) {
      String errMsg=MessageHelper.getMessage(""String_Node_Str"",proxy);
      String[] pcs=proxy.split(""String_Node_Str"");
      if (pcs == null || pcs.length != 2) {
        System.out.println(errMsg);
        return;
      }
      try {
        HttpCaller.setProxyHost(pcs[0],Integer.parseInt(pcs[1]),null);
      }
 catch (      Exception e) {
        System.out.println(errMsg);
        return;
      }
    }
    String ret=HttpCaller.invoke(builder.build(),resHttpHeaders);
    if (curlOnly) {
      System.out.println(""String_Node_Str"" + ret);
    }
 else {
      System.out.println(""String_Node_Str"" + resHttpHeaders.toString());
      System.out.println(""String_Node_Str"" + ret);
      System.out.println(""String_Node_Str"" + HttpCaller.changeCharset(ret));
      int times=Integer.getInteger(""String_Node_Str"",0);
      for (int i=2; i <= times; i++) {
        ret=HttpCaller.invoke(builder.build(),null);
        System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ ret);
      }
    }
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    e.printStackTrace(System.out);
  }
}",0.9981897561495048
175805,"public static void main(String[] args){
  Options opt=new Options();
  opt.addOption(""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  CommandLineParser parser=new DefaultParser();
  Boolean isDebug=false;
  try {
    CommandLine commandline=parser.parse(opt,args);
    if (commandline.hasOption(""String_Node_Str"")) {
      usage(opt);
      return;
    }
    String ak=commandline.getOptionValue(""String_Node_Str"");
    String sk=commandline.getOptionValue(""String_Node_Str"");
    String api=commandline.getOptionValue(""String_Node_Str"");
    String version=commandline.getOptionValue(""String_Node_Str"");
    String wa=commandline.getOptionValue(""String_Node_Str"");
    String ea=commandline.getOptionValue(""String_Node_Str"");
    String ns=commandline.getOptionValue(""String_Node_Str"");
    String sname=commandline.getOptionValue(""String_Node_Str"");
    String pname=commandline.getOptionValue(""String_Node_Str"");
    String rf=commandline.getOptionValue(""String_Node_Str"");
    String rd=commandline.getOptionValue(""String_Node_Str"");
    boolean isSoap12=commandline.hasOption(""String_Node_Str"");
    isDebug=commandline.hasOption(""String_Node_Str"");
    if (isDebug) {
      System.out.println(""String_Node_Str"" + ak);
      System.out.println(""String_Node_Str"" + sk);
      System.out.println(""String_Node_Str"" + api);
      System.out.println(""String_Node_Str"" + version);
      System.out.println(""String_Node_Str"" + isSoap12);
      System.out.println(""String_Node_Str"" + wa);
      System.out.println(""String_Node_Str"" + ea);
      System.out.println(""String_Node_Str"" + ns);
      System.out.println(""String_Node_Str"" + sname);
      System.out.println(""String_Node_Str"" + pname);
      System.out.println(""String_Node_Str"" + rd);
      if (isEmpty(rd)) {
        System.out.println(""String_Node_Str"" + rf);
      }
    }
    if (isEmpty(api) || isEmpty(version) || isEmpty(ea)|| isEmpty(wa)|| isEmpty(ns)|| isEmpty(sname)|| isEmpty(pname)|| (isEmpty(rf) && isEmpty(rd))) {
      usage(opt);
      return;
    }
    String reqData=(isEmpty(rd)) ? FileUtils.readFileToString(new File(rf)) : rd;
    print(isDebug,""String_Node_Str"",reqData);
    if (isEmpty(reqData)) {
      print(true,""String_Node_Str"",rf);
      return;
    }
    invokeWithDispath(ak,sk,api,version,ns,sname,pname,isSoap12,wa,ea,reqData);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    if (isDebug)     e.printStackTrace(System.out);
  }
}","public static void main(String[] args){
  Options opt=new Options();
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  CommandLineParser parser=new DefaultParser();
  Boolean isDebug=false;
  try {
    CommandLine commandline=parser.parse(opt,args);
    if (commandline.hasOption(""String_Node_Str"")) {
      usage(opt);
      return;
    }
    String ak=commandline.getOptionValue(""String_Node_Str"");
    String sk=commandline.getOptionValue(""String_Node_Str"");
    String api=commandline.getOptionValue(""String_Node_Str"");
    String version=commandline.getOptionValue(""String_Node_Str"");
    String wa=commandline.getOptionValue(""String_Node_Str"");
    String ea=commandline.getOptionValue(""String_Node_Str"");
    String ns=commandline.getOptionValue(""String_Node_Str"");
    String sname=commandline.getOptionValue(""String_Node_Str"");
    String pname=commandline.getOptionValue(""String_Node_Str"");
    String rf=commandline.getOptionValue(""String_Node_Str"");
    String rd=commandline.getOptionValue(""String_Node_Str"");
    boolean isSoap12=commandline.hasOption(""String_Node_Str"");
    isDebug=commandline.hasOption(""String_Node_Str"");
    if (isDebug) {
      System.out.println(""String_Node_Str"" + ak);
      System.out.println(""String_Node_Str"" + sk);
      System.out.println(""String_Node_Str"" + api);
      System.out.println(""String_Node_Str"" + version);
      System.out.println(""String_Node_Str"" + isSoap12);
      System.out.println(""String_Node_Str"" + wa);
      System.out.println(""String_Node_Str"" + ea);
      System.out.println(""String_Node_Str"" + ns);
      System.out.println(""String_Node_Str"" + sname);
      System.out.println(""String_Node_Str"" + pname);
      System.out.println(""String_Node_Str"" + rd);
      if (isEmpty(rd)) {
        System.out.println(""String_Node_Str"" + rf);
      }
    }
    if (isEmpty(api) || isEmpty(version) || isEmpty(ea)|| isEmpty(wa)|| isEmpty(ns)|| isEmpty(sname)|| isEmpty(pname)|| (isEmpty(rf) && isEmpty(rd))) {
      usage(opt);
      return;
    }
    String reqData=(isEmpty(rd)) ? FileUtils.readFileToString(new File(rf)) : rd;
    print(isDebug,""String_Node_Str"",reqData);
    if (isEmpty(reqData)) {
      print(true,""String_Node_Str"",rf);
      return;
    }
    invokeWithDispath(ak,sk,api,version,ns,sname,pname,isSoap12,wa,ea,reqData);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    if (isDebug)     e.printStackTrace(System.out);
  }
}",0.9978813559322034
175806,"public static void main(String[] args){
  Options opt=new Options();
  opt.addOption(""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  CommandLineParser parser=new DefaultParser();
  Boolean isDebug=false;
  try {
    CommandLine commandline=parser.parse(opt,args);
    if (commandline.hasOption(""String_Node_Str"")) {
      usage(opt);
      return;
    }
    String ak=commandline.getOptionValue(""String_Node_Str"");
    String sk=commandline.getOptionValue(""String_Node_Str"");
    String api=commandline.getOptionValue(""String_Node_Str"");
    String version=commandline.getOptionValue(""String_Node_Str"");
    String wa=commandline.getOptionValue(""String_Node_Str"");
    String ea=commandline.getOptionValue(""String_Node_Str"");
    String ns=commandline.getOptionValue(""String_Node_Str"");
    String sname=commandline.getOptionValue(""String_Node_Str"");
    String pname=commandline.getOptionValue(""String_Node_Str"");
    String rf=commandline.getOptionValue(""String_Node_Str"");
    String rd=commandline.getOptionValue(""String_Node_Str"");
    boolean isSoap12=commandline.hasOption(""String_Node_Str"");
    isDebug=commandline.hasOption(""String_Node_Str"");
    if (isDebug) {
      System.out.println(""String_Node_Str"" + ak);
      System.out.println(""String_Node_Str"" + sk);
      System.out.println(""String_Node_Str"" + api);
      System.out.println(""String_Node_Str"" + version);
      System.out.println(""String_Node_Str"" + isSoap12);
      System.out.println(""String_Node_Str"" + wa);
      System.out.println(""String_Node_Str"" + ea);
      System.out.println(""String_Node_Str"" + ns);
      System.out.println(""String_Node_Str"" + sname);
      System.out.println(""String_Node_Str"" + pname);
      System.out.println(""String_Node_Str"" + rd);
      if (isEmpty(rd)) {
        System.out.println(""String_Node_Str"" + rf);
      }
    }
    if (isEmpty(api) || isEmpty(version) || isEmpty(ea)|| isEmpty(wa)|| isEmpty(ns)|| isEmpty(sname)|| isEmpty(pname)|| (isEmpty(rf) && isEmpty(rd))) {
      usage(opt);
      return;
    }
    String reqData=(isEmpty(rd)) ? FileUtils.readFileToString(new File(rf)) : rd;
    print(isDebug,""String_Node_Str"",reqData);
    if (isEmpty(reqData)) {
      print(true,""String_Node_Str"",rf);
      return;
    }
    invokeWithDispath(ak,sk,api,version,ns,sname,pname,isSoap12,wa,ea,reqData);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    if (isDebug)     e.printStackTrace(System.out);
  }
}","public static void main(String[] args){
  Options opt=new Options();
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  opt.addOption(""String_Node_Str"",true,""String_Node_Str"");
  CommandLineParser parser=new DefaultParser();
  Boolean isDebug=false;
  try {
    CommandLine commandline=parser.parse(opt,args);
    if (commandline.hasOption(""String_Node_Str"")) {
      usage(opt);
      return;
    }
    String ak=commandline.getOptionValue(""String_Node_Str"");
    String sk=commandline.getOptionValue(""String_Node_Str"");
    String api=commandline.getOptionValue(""String_Node_Str"");
    String version=commandline.getOptionValue(""String_Node_Str"");
    String wa=commandline.getOptionValue(""String_Node_Str"");
    String ea=commandline.getOptionValue(""String_Node_Str"");
    String ns=commandline.getOptionValue(""String_Node_Str"");
    String sname=commandline.getOptionValue(""String_Node_Str"");
    String pname=commandline.getOptionValue(""String_Node_Str"");
    String rf=commandline.getOptionValue(""String_Node_Str"");
    String rd=commandline.getOptionValue(""String_Node_Str"");
    boolean isSoap12=commandline.hasOption(""String_Node_Str"");
    isDebug=commandline.hasOption(""String_Node_Str"");
    if (isDebug) {
      System.out.println(""String_Node_Str"" + ak);
      System.out.println(""String_Node_Str"" + sk);
      System.out.println(""String_Node_Str"" + api);
      System.out.println(""String_Node_Str"" + version);
      System.out.println(""String_Node_Str"" + isSoap12);
      System.out.println(""String_Node_Str"" + wa);
      System.out.println(""String_Node_Str"" + ea);
      System.out.println(""String_Node_Str"" + ns);
      System.out.println(""String_Node_Str"" + sname);
      System.out.println(""String_Node_Str"" + pname);
      System.out.println(""String_Node_Str"" + rd);
      if (isEmpty(rd)) {
        System.out.println(""String_Node_Str"" + rf);
      }
    }
    if (isEmpty(api) || isEmpty(version) || isEmpty(ea)|| isEmpty(wa)|| isEmpty(ns)|| isEmpty(sname)|| isEmpty(pname)|| (isEmpty(rf) && isEmpty(rd))) {
      usage(opt);
      return;
    }
    String reqData=(isEmpty(rd)) ? FileUtils.readFileToString(new File(rf)) : rd;
    print(isDebug,""String_Node_Str"",reqData);
    if (isEmpty(reqData)) {
      print(true,""String_Node_Str"",rf);
      return;
    }
    invokeWithDispath(ak,sk,api,version,ns,sname,pname,isSoap12,wa,ea,reqData);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    if (isDebug)     e.printStackTrace(System.out);
  }
}",0.9978813559322034
175807,"public static Color mean(BufferedImage rgb,List<? extends DRectangle> frects){
  int count=0;
  long[] values=new long[3];
  for (  DRectangle f : frects)   for (int x=(int)f.x; x < f.x + f.width; x++)   for (int y=rgb.getHeight() - (int)(f.y + f.height); y < rgb.getHeight() - (f.y); y++) {
    if (x < 0 || x >= rgb.getWidth() || y < 0 || y >= rgb.getHeight())     continue;
    int val=rgb.getRGB(x,y);
    values[0]+=(val & 0xff0000) >> 16;
    values[1]+=(val & 0x00ff00) >> 8;
    values[2]+=(val & 0x0000ff) >> 0;
    count++;
  }
  if (count > 0) {
    values[0]/=count;
    values[1]/=count;
    values[2]/=count;
  }
  return new Color((int)((values[0] << 16) + (values[1] << 8) + values[2]));
}","public static Color mean(BufferedImage rgb,List<? extends DRectangle> frects){
  int count=0;
  long[] values=new long[3];
  for (  DRectangle f : frects)   for (int x=(int)f.x; x < f.x + f.width; x++)   for (int y=rgb.getHeight() - (int)(f.y + f.height); y < rgb.getHeight() - (f.y); y++) {
    if (x < 0 || x >= rgb.getWidth() || y < 0 || y >= rgb.getHeight())     continue;
    int val=rgb.getRGB(x,y);
    values[0]+=(val & 0xff0000) >> 16;
    values[1]+=(val & 0x00ff00) >> 8;
    values[2]+=(val & 0x0000ff) >> 0;
    count++;
  }
  if (count > 0) {
    values[0]/=count;
    values[1]/=count;
    values[2]/=count;
  }
 else   return Color.lightGray;
  return new Color((int)((values[0] << 16) + (values[1] << 8) + values[2]));
}",0.9778085991678224
175808,"@Override public void finishedBatches(List<App> all){
  super.finishedBatches(all);
  for (  App a : all) {
    PanesTexApp pta=(PanesTexApp)a;
    PanesLabelApp pla=pta.fr.panesLabelApp;
    if (pla.label == null)     continue;
    pla.fr.mf.facadeTexApp.coarseWithWindows=null;
  }
  super.finishedBatches(all);
}","@Override public void finishedBatches(List<App> all){
  super.finishedBatches(all);
  for (  App a : all) {
    PanesTexApp pta=(PanesTexApp)a;
    PanesLabelApp pla=pta.fr.panesLabelApp;
    if (pla.label == null)     continue;
  }
  super.finishedBatches(all);
}",0.911917098445596
175809,"@Override public void drawCoarse(MultiMap<MiniRoof,FacState> todo) throws IOException {
  RoofTexApp rta=mr.roofTexApp;
  BufferedImage src=ImageIO.read(Tweed.toWorkspace(rta.coarse));
  NetInfo ni=NetInfo.get(this);
  int count=0;
  for (  Loop<Point2d> verticalPts : mr.getAllFaces()) {
    TwoRects toPix=new TwoRects(rta.textureRect,new DRectangle(src.getWidth(),src.getHeight()),ni.resolution);
    Loop<Point2d> pixPts=toPix.tranform(verticalPts);
    Color mean=Color.darkGray;
    mean=meanColor(src,mean,pixPts);
    Face origin=mr.origins.get(verticalPts);
    if (origin == null)     continue;
    RoofTag rt=(RoofTag)GreebleHelper.getTag(origin.profile,RoofTag.class);
    Point2d start=toPix.transform(origin.edge.start), end=toPix.transform(origin.edge.end);
    Line startEnd=new Line(start,end);
    AffineTransform toOrigin=AffineTransform.getTranslateInstance(-start.x,-start.y), rot=AffineTransform.getRotateInstance(-startEnd.aTan2()), deslope=AffineTransform.getScaleInstance(1,1 / Math.cos(origin.edge.getAngle()));
    AffineTransform t=AffineTransform.getTranslateInstance(0,0);
    t.preConcatenate(toOrigin);
    t.preConcatenate(rot);
    t.preConcatenate(deslope);
    double[] bounds=Loopz.minMax2d(Loopz.transform(verticalPts,rot));
    double[] pixBounds=Loopz.minMax2d(Loopz.transform(pixPts,t));
    int outWidth=(int)Math.ceil(((bounds[1] - bounds[0]) * scale) / tileWidth) * tileWidth, outHeight=(int)Math.ceil(((bounds[3] - bounds[2]) * scale) / tileWidth) * tileWidth;
    BufferedImage bigCoarse=new BufferedImage(outWidth + overlap * 2,outHeight + overlap * 2,BufferedImage.TYPE_3BYTE_BGR);
    Graphics2D g=bigCoarse.createGraphics();
    g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BICUBIC);
    g.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);
    t.preConcatenate(AffineTransform.getTranslateInstance(-pixBounds[0],0));
    t.preConcatenate(AffineTransform.getScaleInstance(outWidth / (pixBounds[1] - pixBounds[0]),outHeight / (pixBounds[3] - pixBounds[2])));
    t.preConcatenate(AffineTransform.getTranslateInstance(overlap,outHeight + overlap));
    g.setTransform(t);
    g.drawImage(src,0,0,null);
    if (true) {
      g.setColor(mean);
      g.setStroke(new BasicStroke(overlap / 8));
      for (      Loopable<Point2d> lp : pixPts.loopableIterator()) {
        g.drawLine((int)lp.get().x,(int)lp.get().y,(int)lp.next.get().x,(int)lp.next.get().y);
      }
      if (false)       for (      HalfEdge e : mr.superFace) {
        MiniFacade mf=((SuperEdge)e).toEdit;
        for (        FRect f : mf.featureGen.getRects(Feature.WINDOW)) {
          PanesLabelApp pla=f.panesLabelApp;
          if (pla.coveringRoof != null) {
            for (            Loopable<Point2d> pt : pla.coveringRoof.loopableIterator()) {
              g.drawLine((int)pt.get().x,(int)pt.get().y,(int)pt.getNext().get().x,(int)pt.getNext().get().y);
            }
          }
        }
      }
    }
    g.dispose();
    FacState state=new FacState(bigCoarse,mr,new DRectangle(0,0,bounds[1] - bounds[0],bounds[3] - bounds[2]),rt);
    for (int x=0; x <= outWidth / tileWidth; x++)     for (int y=0; y <= outHeight / tileWidth; y++)     state.nextTiles.add(new TileState(state,x,y));
    todo.put(mr,state);
  }
}","@Override public void drawCoarse(MultiMap<MiniRoof,FacState> todo) throws IOException {
  RoofTexApp rta=mr.roofTexApp;
  BufferedImage src=ImageIO.read(Tweed.toWorkspace(rta.coarse));
  NetInfo ni=NetInfo.get(this);
  int count=0;
  for (  Loop<Point2d> verticalPts : mr.getAllFaces()) {
    TwoRects toPix=new TwoRects(rta.textureRect,new DRectangle(src.getWidth(),src.getHeight()),ni.resolution);
    Loop<Point2d> pixPts=toPix.tranform(verticalPts);
    Color mean=Color.darkGray;
    mean=meanColor(src,mean,pixPts);
    Face origin=mr.origins.get(verticalPts);
    if (origin == null)     continue;
    RoofTag rt=(RoofTag)GreebleHelper.getTag(origin.profile,RoofTag.class);
    Point2d start=toPix.transform(origin.edge.start), end=toPix.transform(origin.edge.end);
    Line startEnd=new Line(start,end);
    AffineTransform toOrigin=AffineTransform.getTranslateInstance(-start.x,-start.y), rot=AffineTransform.getRotateInstance(-startEnd.aTan2()), deslope=AffineTransform.getScaleInstance(1,1 / Math.cos(origin.edge.getAngle()));
    AffineTransform t=AffineTransform.getTranslateInstance(0,0);
    double[] bounds=Loopz.minMax2d(Loopz.transform(verticalPts,rot));
    t.preConcatenate(toOrigin);
    t.preConcatenate(rot);
    t.preConcatenate(deslope);
    AffineTransform geom2Big=new AffineTransform(t);
    double[] pixBounds=Loopz.minMax2d(Loopz.transform(pixPts,geom2Big));
    int outWidth=(int)Math.ceil(((bounds[1] - bounds[0]) * scale) / tileWidth) * tileWidth, outHeight=(int)Math.ceil(((bounds[3] - bounds[2]) * scale) / tileWidth) * tileWidth;
    BufferedImage bigCoarse=new BufferedImage(outWidth + overlap * 2,outHeight + overlap * 2,BufferedImage.TYPE_3BYTE_BGR);
    Graphics2D g=bigCoarse.createGraphics();
    g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BICUBIC);
    g.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);
    t.preConcatenate(AffineTransform.getTranslateInstance(-pixBounds[0],0));
    t.preConcatenate(AffineTransform.getScaleInstance(outWidth / (pixBounds[1] - pixBounds[0]),outHeight / (pixBounds[3] - pixBounds[2])));
    t.preConcatenate(AffineTransform.getTranslateInstance(overlap,outHeight + overlap));
    g.setTransform(t);
    g.drawImage(src,0,-256,null);
    if (true) {
      g.setColor(mean);
      g.setStroke(new BasicStroke(overlap / 8));
      for (      Loopable<Point2d> lp : pixPts.loopableIterator()) {
        g.drawLine((int)lp.get().x,(int)lp.get().y,(int)lp.next.get().x,(int)lp.next.get().y);
      }
      g.setColor(Colourz.transparent(mean,128));
      for (      HalfEdge e : mr.superFace) {
        MiniFacade mf=((SuperEdge)e).toEdit;
        for (        FRect f : mf.featureGen.getRects(Feature.WINDOW)) {
          PanesLabelApp pla=f.panesLabelApp;
          if (pla.coveringRoof != null) {
            int c=0;
            for (            Loopable<Point2d> pt : toPix.tranform(pla.coveringRoof).loopableIterator()) {
              if (c++ == 3)               continue;
              g.drawLine((int)pt.get().x,(int)pt.get().y,(int)pt.getNext().get().x,(int)pt.getNext().get().y);
            }
          }
        }
      }
    }
    g.dispose();
    FacState state=new FacState(bigCoarse,mr,new DRectangle(0,0,bounds[1] - bounds[0],bounds[3] - bounds[2]),rt);
    for (int x=0; x <= outWidth / tileWidth; x++)     for (int y=0; y <= outHeight / tileWidth; y++)     state.nextTiles.add(new TileState(state,x,y));
    todo.put(mr,state);
  }
}",0.9428320140721196
175810,"public SkelGen(HalfMesh2 mesh,Tweed tweed,BlockGen blockGen){
  super(""String_Node_Str"",tweed);
  setRender(mesh);
  this.blockGen=blockGen;
  ProgressMonitor m=new ProgressMonitor(tweed.frame(),""String_Node_Str"",""String_Node_Str"",0,100);
  m.setProgress(1);
  m.setMillisToPopup(0);
}","public SkelGen(HalfMesh2 mesh,Tweed tweed,BlockGen blockGen){
  super(""String_Node_Str"",tweed);
  setRender(mesh);
  this.blockGen=blockGen;
}",0.6651053864168618
175811,"public synchronized void setSkel(PlanSkeleton _,SuperFace sft_){
  BlockApp ba=ass.get(BlockApp.class,this);
  if (skirtG != null)   skirtG.removeFromParent();
  if (ba.skirtTexture != null) {
    Quad skirt=new Quad(ba.skirt.widthF(),ba.skirt.heightF());
    skirtG=new Geometry(""String_Node_Str"",skirt);
    skirtG.setMaterial(GreebleGrid.buildTextureMaterial(tweed,ba.skirtTexture));
    skirtG.setLocalTranslation(ba.skirt.xF(),0,ba.skirt.yF() + ba.skirt.heightF());
    skirtG.setLocalRotation(new Quaternion(new float[]{(float)-Math.PI / 2f,0,0}));
    gNode.attachChild(skirtG);
  }
  if (sft_ != null)   ass.get(BuildingApp.class,sft_).isDirty=true;
  for (  HalfFace hf : block) {
    SuperFace sf=(SuperFace)hf;
    BuildingApp sfa=ass.get(BuildingApp.class,sf);
    if (sfa.isDirty) {
      for (      HalfEdge he : sf) {
        SuperEdge se=(SuperEdge)he;
        ensureMF(sf,se);
      }
      sfa.isDirty=false;
      removeGeometryFor(sf);
      Node house;
      OnClick onclick=new OnClick(){
        @Override public void selected(        Output output,        Node house2,        SuperEdge se,        Object ha){
          SkelGen.this.textureSelected(sf.skel,sf,ha);
        }
      }
;
      GreebleSkel greeble=new GreebleSkel(tweed,ass,sf);
      greeble.occluderLookup=lastOccluders;
      house=greeble.showSkeleton(sf.skel.output,onclick,sf.mr);
      gNode.attachChild(house);
      geometry.get(sf).set(house,sf.skel.output,sf.skel);
      tweed.getRootNode().updateGeometricState();
      tweed.getRootNode().updateModelBound();
      tweed.gainFocus();
    }
  }
}","public synchronized void setSkel(PlanSkeleton _,SuperFace sft_){
  BlockApp ba=ass.get(BlockApp.class,this);
  if (skirtG != null)   skirtG.removeFromParent();
  if (ba.skirtTexture != null) {
    Quad skirt=new Quad(ba.skirt.widthF(),ba.skirt.heightF());
    skirtG=new Geometry(""String_Node_Str"",skirt);
    skirtG.setMaterial(GreebleGrid.buildTextureMaterial(tweed,ba.skirtTexture));
    skirtG.setLocalTranslation(ba.skirt.xF(),0,ba.skirt.yF() + ba.skirt.heightF());
    skirtG.setLocalRotation(new Quaternion(new float[]{(float)-Math.PI / 2f,0,0}));
    gNode.attachChild(skirtG);
  }
  if (sft_ != null)   ass.get(BuildingApp.class,sft_).markGeometryDirty(ass);
  for (  HalfFace hf : block) {
    SuperFace sf=(SuperFace)hf;
    BuildingApp sfa=ass.get(BuildingApp.class,sf);
    if (sfa.isGeometryDirty) {
      for (      HalfEdge he : sf) {
        SuperEdge se=(SuperEdge)he;
        ensureMF(sf,se);
      }
      sfa.isGeometryDirty=false;
      removeGeometryFor(sf);
      Node house;
      OnClick onclick=new OnClick(){
        @Override public void selected(        Output output,        Node house2,        SuperEdge se,        Object ha){
          SkelGen.this.textureSelected(sf.skel,sf,ha);
        }
      }
;
      GreebleSkel greeble=new GreebleSkel(tweed,ass,sf);
      greeble.occluderLookup=lastOccluders;
      house=greeble.showSkeleton(sf.skel.output,onclick,sf.mr);
      gNode.attachChild(house);
      geometry.get(sf).set(house,sf.skel.output,sf.skel);
      tweed.getRootNode().updateGeometricState();
      tweed.getRootNode().updateModelBound();
      tweed.gainFocus();
    }
  }
}",0.9166666666666666
175812,"@Override public void actionPerformed(ActionEvent e){
  new SimpleFileChooser(tweed.frame.frame,true,""String_Node_Str"",null,""String_Node_Str""){
    @Override public void heresTheFile(    File f) throws Throwable {
      Map<HalfFace,PlanSkeleton> store=new HashMap<>();
      for (      HalfFace f2 : SkelGen.this.block)       store.put(f2,((SuperFace)f2).skel);
      for (      HalfFace f2 : SkelGen.this.block) {
        SuperFace sf=(SuperFace)f2;
        sf.heights=null;
        sf.maxProfHeights=null;
        sf.colors=new ArrayList<>();
        for (        Bar b : sf.skel.plan.points.eIterator()) {
          SETag set=(SETag)GreebleHelper.getTag(b.tags,SETag.class);
          if (set != null)           set.se.prof=toProf(sf.skel.plan.profiles.get(b));
        }
        sf.skel=null;
        for (        HalfEdge e : f2) {
          SuperEdge se=(SuperEdge)e;
          if (se.profLine != null)           se.profLine.mega=null;
          if (e.over != null && ((SuperEdge)e.over).profLine != null)           ((SuperEdge)e.over).profLine.mega=null;
        }
      }
      blockGen=null;
      new XStream().toXML(SkelGen.this,new FileOutputStream(f));
      for (      HalfFace f2 : SkelGen.this.block)       ((SuperFace)f2).skel=store.get(f2);
    }
  }
;
}","@Override public void actionPerformed(ActionEvent e){
  new SimpleFileChooser(tweed.frame.frame,true,""String_Node_Str"",null,""String_Node_Str""){
    @Override public void heresTheFile(    File f) throws Throwable {
      HalfMesh2 nBlock=new HalfMesh2();
      for (      HalfFace f2 : SkelGen.this.block) {
        SuperFace sf=(SuperFace)f2;
        List<Bar> bars=new ArrayList();
        for (        Bar b : sf.skel.plan.points.eIterator())         bars.add(b);
        Collections.reverse(bars);
        HalfMesh2.Builder builder=new HalfMesh2.Builder(SuperEdge.class,SuperFace.class);
        builder.mesh=nBlock;
        for (        Bar b : bars)         builder.newPoint(b.start);
        SuperFace sf3=(SuperFace)builder.newFace();
        sf3.height=sf.height;
        sf3.maxProfHeights=new ArrayList<>(sf.maxProfHeights);
        HalfEdge h3=sf3.e;
        for (        Bar b : bars) {
          SuperEdge s3=(SuperEdge)h3;
          s3.prof=toProf(sf.skel.plan.profiles.get(b));
          h3=h3.next;
        }
      }
      new XStream().toXML(new SkelGen(nBlock,null,null),new FileOutputStream(f));
    }
  }
;
}",0.3032069970845481
175813,"@Override public JComponent getUI(){
  JPanel ui=new JPanel(new ListDownLayout());
  ui.add(new JLabel(""String_Node_Str""));
  JButton compare=new JButton(""String_Node_Str"");
  compare.addActionListener(l -> new CompareGens(this,blockGen));
  ui.add(compare);
  JButton dec=new JButton(""String_Node_Str"");
  dec.addActionListener(l -> textureSelected(null,null,SkelGen.this));
  ui.add(dec);
  JButton save=new JButton(""String_Node_Str"");
  save.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      new SimpleFileChooser(tweed.frame.frame,true,""String_Node_Str"",null,""String_Node_Str""){
        @Override public void heresTheFile(        File f) throws Throwable {
          Map<HalfFace,PlanSkeleton> store=new HashMap<>();
          for (          HalfFace f2 : SkelGen.this.block)           store.put(f2,((SuperFace)f2).skel);
          for (          HalfFace f2 : SkelGen.this.block) {
            SuperFace sf=(SuperFace)f2;
            sf.heights=null;
            sf.maxProfHeights=null;
            sf.colors=new ArrayList<>();
            for (            Bar b : sf.skel.plan.points.eIterator()) {
              SETag set=(SETag)GreebleHelper.getTag(b.tags,SETag.class);
              if (set != null)               set.se.prof=toProf(sf.skel.plan.profiles.get(b));
            }
            sf.skel=null;
            for (            HalfEdge e : f2) {
              SuperEdge se=(SuperEdge)e;
              if (se.profLine != null)               se.profLine.mega=null;
              if (e.over != null && ((SuperEdge)e.over).profLine != null)               ((SuperEdge)e.over).profLine.mega=null;
            }
          }
          blockGen=null;
          new XStream().toXML(SkelGen.this,new FileOutputStream(f));
          for (          HalfFace f2 : SkelGen.this.block)           ((SuperFace)f2).skel=store.get(f2);
        }
      }
;
    }
  }
);
  ui.add(save);
  return ui;
}","@Override public JComponent getUI(){
  JPanel ui=new JPanel(new ListDownLayout());
  ui.add(new JLabel(""String_Node_Str""));
  JButton compare=new JButton(""String_Node_Str"");
  compare.addActionListener(l -> new CompareGens(this,blockGen));
  ui.add(compare);
  JButton dec=new JButton(""String_Node_Str"");
  dec.addActionListener(l -> textureSelected(null,null,SkelGen.this));
  ui.add(dec);
  JButton save=new JButton(""String_Node_Str"");
  save.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      new SimpleFileChooser(tweed.frame.frame,true,""String_Node_Str"",null,""String_Node_Str""){
        @Override public void heresTheFile(        File f) throws Throwable {
          HalfMesh2 nBlock=new HalfMesh2();
          for (          HalfFace f2 : SkelGen.this.block) {
            SuperFace sf=(SuperFace)f2;
            List<Bar> bars=new ArrayList();
            for (            Bar b : sf.skel.plan.points.eIterator())             bars.add(b);
            Collections.reverse(bars);
            HalfMesh2.Builder builder=new HalfMesh2.Builder(SuperEdge.class,SuperFace.class);
            builder.mesh=nBlock;
            for (            Bar b : bars)             builder.newPoint(b.start);
            SuperFace sf3=(SuperFace)builder.newFace();
            sf3.height=sf.height;
            sf3.maxProfHeights=new ArrayList<>(sf.maxProfHeights);
            HalfEdge h3=sf3.e;
            for (            Bar b : bars) {
              SuperEdge s3=(SuperEdge)h3;
              s3.prof=toProf(sf.skel.plan.profiles.get(b));
              h3=h3.next;
            }
          }
          new XStream().toXML(new SkelGen(nBlock,null,null),new FileOutputStream(f));
        }
      }
;
    }
  }
);
  ui.add(save);
  return ui;
}",0.5001337255950788
175814,"@Override public void heresTheFile(File f) throws Throwable {
  Map<HalfFace,PlanSkeleton> store=new HashMap<>();
  for (  HalfFace f2 : SkelGen.this.block)   store.put(f2,((SuperFace)f2).skel);
  for (  HalfFace f2 : SkelGen.this.block) {
    SuperFace sf=(SuperFace)f2;
    sf.heights=null;
    sf.maxProfHeights=null;
    sf.colors=new ArrayList<>();
    for (    Bar b : sf.skel.plan.points.eIterator()) {
      SETag set=(SETag)GreebleHelper.getTag(b.tags,SETag.class);
      if (set != null)       set.se.prof=toProf(sf.skel.plan.profiles.get(b));
    }
    sf.skel=null;
    for (    HalfEdge e : f2) {
      SuperEdge se=(SuperEdge)e;
      if (se.profLine != null)       se.profLine.mega=null;
      if (e.over != null && ((SuperEdge)e.over).profLine != null)       ((SuperEdge)e.over).profLine.mega=null;
    }
  }
  blockGen=null;
  new XStream().toXML(SkelGen.this,new FileOutputStream(f));
  for (  HalfFace f2 : SkelGen.this.block)   ((SuperFace)f2).skel=store.get(f2);
}","@Override public void heresTheFile(File f) throws Throwable {
  HalfMesh2 nBlock=new HalfMesh2();
  for (  HalfFace f2 : SkelGen.this.block) {
    SuperFace sf=(SuperFace)f2;
    List<Bar> bars=new ArrayList();
    for (    Bar b : sf.skel.plan.points.eIterator())     bars.add(b);
    Collections.reverse(bars);
    HalfMesh2.Builder builder=new HalfMesh2.Builder(SuperEdge.class,SuperFace.class);
    builder.mesh=nBlock;
    for (    Bar b : bars)     builder.newPoint(b.start);
    SuperFace sf3=(SuperFace)builder.newFace();
    sf3.height=sf.height;
    sf3.maxProfHeights=new ArrayList<>(sf.maxProfHeights);
    HalfEdge h3=sf3.e;
    for (    Bar b : bars) {
      SuperEdge s3=(SuperEdge)h3;
      s3.prof=toProf(sf.skel.plan.profiles.get(b));
      h3=h3.next;
    }
  }
  new XStream().toXML(new SkelGen(nBlock,null,null),new FileOutputStream(f));
}",0.2168021680216802
175815,"public App(){
  NetInfo ni=getNetInfo();
  this.name=ni.name;
  this.styleZ=new double[ni.sizeZ];
  this.styleSource=new GaussStyle(NetInfo.get(this));
}","public App(){
  NetInfo ni=getNetInfo();
  this.name=ni.name;
  this.styleZ=new double[ni.sizeZ];
  this.styleSource=new GaussStyle(this.getClass());
}",0.9407894736842104
175816,"public void finishedBatches(List<App> all,AppStore ass){
  for (  App a : all)   a.markDirty(ass);
}","public void finishedBatches(List<App> all,AppStore ass){
  for (  App a : all)   a.markGeometryDirty(ass);
}",0.9615384615384616
175817,"@Override public JComponent createUI(Runnable globalUpdate,SelectedApps sa){
  JPanel out=new JPanel(new ListDownLayout());
  if (styleSource instanceof JointStyle) {
    JButton g=new JButton(""String_Node_Str"");
    g.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        setGauss(Collections.singletonList(BlockApp.this));
        sa.showUI();
      }
      private void setGauss(      List<App> hashSet){
        for (        App a : hashSet) {
          a.styleSource=new GaussStyle(a.getNetInfo());
          a.appMode=AppMode.Net;
          setGauss(a.getDown(sa.ass).valueList());
        }
      }
    }
);
    out.add(g);
    out.add(new AutoCheckbox(this,""String_Node_Str"",""String_Node_Str""){
      public void updated(      boolean selected){
        for (        App a : sa)         ((BlockApp)a).doSkirt=selected;
        globalUpdate.run();
      }
    }
);
  }
 else {
    JButton j=new JButton(""String_Node_Str"");
    j.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        styleSource=new JointStyle(null);
        appMode=AppMode.Net;
        styleSource.install(new SelectedApps((App)BlockApp.this,sa.ass,sa.geometryUpdate));
        sa.showUI();
      }
    }
);
    out.add(j);
  }
  return out;
}","@Override public JComponent createUI(Runnable globalUpdate,SelectedApps sa){
  JPanel out=new JPanel(new ListDownLayout());
  if (styleSource instanceof JointStyle) {
    JButton g=new JButton(""String_Node_Str"");
    g.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        setGauss(Collections.singletonList(BlockApp.this));
        sa.showUI();
      }
      private void setGauss(      List<App> hashSet){
        for (        App a : hashSet) {
          a.styleSource=new GaussStyle(BlockApp.this.getClass());
          a.appMode=AppMode.Net;
          setGauss(a.getDown(sa.ass).valueList());
        }
      }
    }
);
    out.add(g);
    out.add(new AutoCheckbox(this,""String_Node_Str"",""String_Node_Str""){
      public void updated(      boolean selected){
        for (        App a : sa)         ((BlockApp)a).doSkirt=selected;
        globalUpdate.run();
      }
    }
);
  }
 else {
    JButton j=new JButton(""String_Node_Str"");
    j.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        styleSource=new JointStyle(null);
        appMode=AppMode.Net;
        styleSource.install(new SelectedApps((App)BlockApp.this,sa.ass,sa.geometryUpdate));
        sa.showUI();
      }
    }
);
    out.add(j);
  }
  return out;
}",0.9903201787043932
175818,"private void setGauss(List<App> hashSet){
  for (  App a : hashSet) {
    a.styleSource=new GaussStyle(a.getNetInfo());
    a.appMode=AppMode.Net;
    setGauss(a.getDown(sa.ass).valueList());
  }
}","private void setGauss(List<App> hashSet){
  for (  App a : hashSet) {
    a.styleSource=new GaussStyle(BlockApp.this.getClass());
    a.appMode=AppMode.Net;
    setGauss(a.getDown(sa.ass).valueList());
  }
}",0.9356435643564356
175819,"@Override public JComponent createUI(Runnable globalUpdate,SelectedApps apps){
  JPanel out=new JPanel(new ListDownLayout());
  addRemoveButton(globalUpdate,out);
  out.add(new AutoCheckbox(this,""String_Node_Str"",""String_Node_Str""){
    @Override public void updated(    boolean selected){
      updateDormers(selected,apps.ass);
      globalUpdate.run();
    }
  }
);
  JButton siteplan=new JButton(""String_Node_Str"");
  siteplan.addActionListener(e -> new SiteplanDesigner(superFace,parent));
  out.add(siteplan);
  return out;
}","@Override public JComponent createUI(Runnable globalUpdate,SelectedApps apps){
  JPanel out=new JPanel(new ListDownLayout());
  addRemoveButton(globalUpdate,out);
  out.add(new AutoDoubleSlider(this,""String_Node_Str"",""String_Node_Str"",0,1){
    public void updated(    double value){
      updateDormers(new Random());
      globalUpdate.run();
    }
  }
);
  JButton siteplan=new JButton(""String_Node_Str"");
  siteplan.addActionListener(e -> new SiteplanDesigner(superFace,parent));
  out.add(siteplan);
  return out;
}",0.873453853472883
175820,"@Override public void updated(boolean selected){
  updateDormers(selected,apps.ass);
  globalUpdate.run();
}","public void updated(double value){
  updateDormers(new Random());
  globalUpdate.run();
}",0.7309644670050761
175821,"public void updateDormers(boolean dormers,AppStore ac){
  createDormers=dormers;
}","public void updateDormers(Random randy){
  createDormers=randy.nextDouble() < probDormer;
}",0.6936416184971098
175822,"public void markDirty(){
  if (exemplar instanceof BlockApp)   for (  App building : exemplar.getDown(ass).valueList())   ((BuildingApp)building).isDirty=true;
 else   for (  App a : SelectedApps.this)   a.markDirty(ass);
}","public void markDirty(){
  if (exemplar instanceof BlockApp)   for (  App building : exemplar.getDown(ass).valueList())   ((BuildingApp)building).isGeometryDirty=true;
 else   for (  App a : SelectedApps.this)   a.markGeometryDirty(ass);
}",0.9653679653679652
175823,"public SETag(SuperEdge se){
  this.se=se;
}","public SETag(SuperEdge se,SuperFace sf){
  this.se=se;
  this.sf=sf;
}",0.7610619469026548
175824,"public void show(Output output,Skeleton threadKey){
  super.show(output,threadKey);
  tweed.enqueue(new Runnable(){
    @Override public void run(){
      removeGeometryFor(sf);
      tweed.frame.setGenUI(null);
      sf.skel=(PlanSkeleton)threadKey;
      sf.skel.output.addNonSkeletonSharedEdges(new RoofTag(Colourz.toF4(sf.mr.app.color)));
      sf.mr.setOutline(sf.skel.output);
      setSkel((PlanSkeleton)threadKey,sf);
    }
  }
);
}","public void show(Output output,Skeleton threadKey){
  super.show(output,threadKey);
  tweed.enqueue(new Runnable(){
    @Override public void run(){
      removeGeometryFor(sf);
      tweed.frame.setGenUI(null);
      sf.skel=(PlanSkeleton)threadKey;
      for (      Face f : sf.skel.output.faces.values()) {
        WallTag wt=((WallTag)GreebleHelper.getTag(f.profile,WallTag.class));
        if (wt != null && wt.miniFacade == null) {
          wt.miniFacade=new MiniFacade();
          SETag set=(SETag)GreebleHelper.getTag(f.plan,SETag.class);
          if (set != null)           wt.miniFacade.app.parent=(SuperFace)set.se.face;
        }
      }
      sf.skel.output.addNonSkeletonSharedEdges(new RoofTag(Colourz.toF4(sf.mr.app.color)));
      sf.mr.setOutline(sf.skel.output);
      setSkel((PlanSkeleton)threadKey,sf);
    }
  }
);
}",0.6864274570982839
175825,"public void addedBar(Bar bar){
  SETag oldTag=(SETag)bar.tags.iterator().next();
  bar.tags.clear();
  SuperEdge se=new SuperEdge(bar.start,bar.end,null);
  SETag tag=new SETag(se);
  tag.color=Rainbow.random();
  tag.name=Math.random() + ""String_Node_Str"";
  bar.tags.add(tag);
  List<Point2d> defpts=new ArrayList<>();
  defpts.add(new Point2d(0,0));
  defpts.add(new Point2d(0,-10));
  defpts.add(new Point2d(5,-15));
  Profile profile=new Profile(defpts);
  tagWalls(sf,profile,se,bar.start,bar.end);
  plan.addLoop(profile.points.get(0),plan.root,profile);
  plan.profiles.put(bar,profile);
}","public void addedBar(Bar bar){
  SETag oldTag=(SETag)bar.tags.iterator().next();
  bar.tags.clear();
  SuperEdge se=new SuperEdge(bar.start,bar.end,null);
  SETag tag=new SETag(se,sf);
  tag.color=Rainbow.random();
  tag.name=Math.random() + ""String_Node_Str"";
  bar.tags.add(tag);
  List<Point2d> defpts=new ArrayList<>();
  defpts.add(new Point2d(0,0));
  defpts.add(new Point2d(0,-10));
  defpts.add(new Point2d(5,-15));
  Profile profile=new Profile(defpts);
  tagWalls(sf,profile,se,bar.start,bar.end);
  plan.addLoop(profile.points.get(0),plan.root,profile);
  plan.profiles.put(bar,profile);
}",0.9974937343358397
175826,"private void selected(PlanSkeleton skel,Node house,SuperFace sf,SuperEdge se){
  JPanel ui=new JPanel();
  ui.setLayout(new ListDownLayout());
  JButton fac=new JButton(""String_Node_Str"");
  fac.addActionListener(e -> editFacade(skel,sf,se));
  ui.add(fac);
  JButton proc=new JButton(""String_Node_Str"");
  proc.addActionListener(e -> cgaFacade(skel,sf,se));
  ui.add(proc);
  JButton camp=new JButton(""String_Node_Str"");
  camp.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      closeSitePlan();
      Plot.closeLast();
      for (      HalfEdge he : sf) {
        SuperEdge ee=(SuperEdge)he;
        if (ee.toEdit != null)         ee.toEdit.app.appMode=AppMode.Off;
      }
      siteplan=new Siteplan(skel.plan,false){
        public void show(        Output output,        Skeleton threadKey){
          super.show(output,threadKey);
          tweed.enqueue(new Runnable(){
            @Override public void run(){
              removeGeometryFor(sf);
              tweed.frame.setGenUI(null);
              sf.skel=(PlanSkeleton)threadKey;
              sf.skel.output.addNonSkeletonSharedEdges(new RoofTag(Colourz.toF4(sf.mr.app.color)));
              sf.mr.setOutline(sf.skel.output);
              setSkel((PlanSkeleton)threadKey,sf);
            }
          }
);
        }
        public void addedBar(        Bar bar){
          SETag oldTag=(SETag)bar.tags.iterator().next();
          bar.tags.clear();
          SuperEdge se=new SuperEdge(bar.start,bar.end,null);
          SETag tag=new SETag(se);
          tag.color=Rainbow.random();
          tag.name=Math.random() + ""String_Node_Str"";
          bar.tags.add(tag);
          List<Point2d> defpts=new ArrayList<>();
          defpts.add(new Point2d(0,0));
          defpts.add(new Point2d(0,-10));
          defpts.add(new Point2d(5,-15));
          Profile profile=new Profile(defpts);
          tagWalls(sf,profile,se,bar.start,bar.end);
          plan.addLoop(profile.points.get(0),plan.root,profile);
          plan.profiles.put(bar,profile);
        }
      }
;
      siteplan.setVisible(true);
      siteplan.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
    }
  }
);
  ui.add(camp);
  JButton tex=new JButton(""String_Node_Str"");
  tex.addActionListener(x -> {
    tweed.setTool(new TextureTool(tweed));
    SkelGen.this.textureSelected(skel,house,sf,se,se.toEdit);
  }
);
  ui.add(tex);
  JButton remove=new JButton(""String_Node_Str"");
  remove.addActionListener(e -> {
    block.faces.remove(sf);
    calculateOnJmeThread();
  }
);
  ui.add(remove);
  tweed.frame.setGenUI(ui);
}","private void selected(PlanSkeleton skel,Node house,SuperFace sf,SuperEdge se){
  JPanel ui=new JPanel();
  ui.setLayout(new ListDownLayout());
  JButton fac=new JButton(""String_Node_Str"");
  fac.addActionListener(e -> editFacade(skel,sf,se));
  ui.add(fac);
  JButton proc=new JButton(""String_Node_Str"");
  proc.addActionListener(e -> cgaFacade(skel,sf,se));
  ui.add(proc);
  JButton camp=new JButton(""String_Node_Str"");
  camp.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      closeSitePlan();
      Plot.closeLast();
      for (      HalfEdge he : sf) {
        SuperEdge ee=(SuperEdge)he;
        if (ee.toEdit != null)         ee.toEdit.app.appMode=AppMode.Off;
      }
      siteplan=new Siteplan(skel.plan,false){
        public void show(        Output output,        Skeleton threadKey){
          super.show(output,threadKey);
          tweed.enqueue(new Runnable(){
            @Override public void run(){
              removeGeometryFor(sf);
              tweed.frame.setGenUI(null);
              sf.skel=(PlanSkeleton)threadKey;
              for (              Face f : sf.skel.output.faces.values()) {
                WallTag wt=((WallTag)GreebleHelper.getTag(f.profile,WallTag.class));
                if (wt != null && wt.miniFacade == null) {
                  wt.miniFacade=new MiniFacade();
                  SETag set=(SETag)GreebleHelper.getTag(f.plan,SETag.class);
                  if (set != null)                   wt.miniFacade.app.parent=(SuperFace)set.se.face;
                }
              }
              sf.skel.output.addNonSkeletonSharedEdges(new RoofTag(Colourz.toF4(sf.mr.app.color)));
              sf.mr.setOutline(sf.skel.output);
              setSkel((PlanSkeleton)threadKey,sf);
            }
          }
);
        }
        public void addedBar(        Bar bar){
          SETag oldTag=(SETag)bar.tags.iterator().next();
          bar.tags.clear();
          SuperEdge se=new SuperEdge(bar.start,bar.end,null);
          SETag tag=new SETag(se,sf);
          tag.color=Rainbow.random();
          tag.name=Math.random() + ""String_Node_Str"";
          bar.tags.add(tag);
          List<Point2d> defpts=new ArrayList<>();
          defpts.add(new Point2d(0,0));
          defpts.add(new Point2d(0,-10));
          defpts.add(new Point2d(5,-15));
          Profile profile=new Profile(defpts);
          tagWalls(sf,profile,se,bar.start,bar.end);
          plan.addLoop(profile.points.get(0),plan.root,profile);
          plan.profiles.put(bar,profile);
        }
      }
;
      siteplan.setVisible(true);
      siteplan.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
    }
  }
);
  ui.add(camp);
  JButton tex=new JButton(""String_Node_Str"");
  tex.addActionListener(x -> {
    tweed.setTool(new TextureTool(tweed));
    SkelGen.this.textureSelected(skel,house,sf,se,se.toEdit);
  }
);
  ui.add(tex);
  JButton remove=new JButton(""String_Node_Str"");
  remove.addActionListener(e -> {
    block.faces.remove(sf);
    calculateOnJmeThread();
  }
);
  ui.add(remove);
  tweed.frame.setGenUI(ui);
}",0.9154610423566324
175827,"private static PlanSkeleton buildCamp(SuperFace sf,Double cap){
  Plan plan=new Plan();
  LoopL<Bar> loopl=new LoopL();
  Loop<Bar> loop=new Loop();
  loopl.add(loop);
  Cache<Point2d,Point2d> cache=new Cache<Point2d,Point2d>(){
    @Override public Point2d create(    Point2d i){
      return new Point2d(i.x,i.y);
    }
  }
;
  LoopL<HalfEdge> edges=sf.findHoles();
  LoopL<Point2d> lpd=new LoopL();
  for (  Loop<HalfEdge> loopHE : edges) {
    Map<Point2d,SuperEdge> ses=new HashMap();
    Loop<Point2d> lp=new Loop();
    lpd.add(lp);
    for (    HalfEdge he : loopHE) {
      SuperEdge se=(SuperEdge)he;
      lp.append(se.start);
      ses.put(se.start,se);
    }
    lp=Loopz.mergeAdjacentEdges2(lp,0.001);
    for (    Loopable<Point2d> lpb : lp.loopableIterator()) {
      Bar b=new Bar(cache.get(lpb.getNext().get()),cache.get(lpb.get()));
      SuperEdge se=ses.get(lpb.get());
      Profile profile=null;
      if (se.prof == null || se.prof.size() < 2) {
        List<Point2d> defpts=new ArrayList<>();
        defpts.add(new Point2d(0,0));
        defpts.add(new Point2d(0,-sf.height * 1.2));
        profile=new Profile(defpts);
      }
 else {
        profile=toProfile(se.prof);
      }
      tagWalls((SuperFace)se.face,profile,se,lpb.get(),lpb.getNext().get());
      plan.addLoop(profile.points.get(0),plan.root,profile);
      b.tags.add(new SETag(se));
      loop.prepend(b);
      plan.profiles.put(b,profile);
    }
  }
  plan.points=loopl;
  if (cap != null) {
    Ship s=new FlatRoofShip(cap,plan);
    for (    Profile prof : plan.profiles.values()) {
      for (      Loop<Bar> lb : prof.points) {
        boolean addedMarker=false;
        for (        Bar b : lb) {
          if (-b.start.y < cap && -b.end.y > cap || (!addedMarker && b == lb.start.getPrev().get())) {
            Marker m=new Marker();
            m.set(b.toLine().xAtY(-cap),-cap);
            m.bar=b;
            m.bar.mould.create(m,null);
            Instance i=s.newInstance();
            i.anchors[0].setProfileGen(m.generator);
            addedMarker=true;
          }
        }
      }
    }
    plan.ships.add(s);
  }
  PlanSkeleton skel=new PlanSkeleton(plan);
  skel.skeleton();
  return skel;
}","private static PlanSkeleton buildCamp(SuperFace sf,Double cap){
  Plan plan=new Plan();
  LoopL<Bar> loopl=new LoopL();
  Loop<Bar> loop=new Loop();
  loopl.add(loop);
  Cache<Point2d,Point2d> cache=new Cache<Point2d,Point2d>(){
    @Override public Point2d create(    Point2d i){
      return new Point2d(i.x,i.y);
    }
  }
;
  LoopL<HalfEdge> edges=sf.findHoles();
  LoopL<Point2d> lpd=new LoopL();
  for (  Loop<HalfEdge> loopHE : edges) {
    Map<Point2d,SuperEdge> ses=new HashMap();
    Loop<Point2d> lp=new Loop();
    lpd.add(lp);
    for (    HalfEdge he : loopHE) {
      SuperEdge se=(SuperEdge)he;
      lp.append(se.start);
      ses.put(se.start,se);
    }
    lp=Loopz.mergeAdjacentEdges2(lp,0.001);
    for (    Loopable<Point2d> lpb : lp.loopableIterator()) {
      Bar b=new Bar(cache.get(lpb.getNext().get()),cache.get(lpb.get()));
      SuperEdge se=ses.get(lpb.get());
      Profile profile=null;
      if (se.prof == null || se.prof.size() < 2) {
        List<Point2d> defpts=new ArrayList<>();
        defpts.add(new Point2d(0,0));
        defpts.add(new Point2d(0,-sf.height * 1.2));
        profile=new Profile(defpts);
      }
 else {
        profile=toProfile(se.prof);
      }
      tagWalls((SuperFace)se.face,profile,se,lpb.get(),lpb.getNext().get());
      plan.addLoop(profile.points.get(0),plan.root,profile);
      b.tags.add(new SETag(se,sf));
      loop.prepend(b);
      plan.profiles.put(b,profile);
    }
  }
  plan.points=loopl;
  if (cap != null) {
    Ship s=new FlatRoofShip(cap,plan);
    for (    Profile prof : plan.profiles.values()) {
      for (      Loop<Bar> lb : prof.points) {
        boolean addedMarker=false;
        for (        Bar b : lb) {
          if (-b.start.y < cap && -b.end.y > cap || (!addedMarker && b == lb.start.getPrev().get())) {
            Marker m=new Marker();
            m.set(b.toLine().xAtY(-cap),-cap);
            m.bar=b;
            m.bar.mould.create(m,null);
            Instance i=s.newInstance();
            i.anchors[0].setProfileGen(m.generator);
            addedMarker=true;
          }
        }
      }
    }
    plan.ships.add(s);
  }
  PlanSkeleton skel=new PlanSkeleton(plan);
  skel.skeleton();
  return skel;
}",0.9993214204931012
175828,"protected void textureGrid(DRectangle allGeom,DRectangle allUV,Matrix4d to3d,FeatureGenerator filteredFeatures,MiniFacade mf){
  if (mf != null && mf.app.texture != null) {
    Grid g=new Grid(.010,allGeom.x,allGeom.getMaxX(),allGeom.y,allGeom.getMaxY());
    MatMeshBuilder mmb=mbs.getTexture(""String_Node_Str"" + mf.app.texture,mf.app.texture,mf);
    for (    FRect w : filteredFeatures.getRects(Feature.WINDOW,Feature.SHOP)) {
      if (allGeom.contains(w))       g.insert(w,new Griddable(){
        @Override public void instance(        DRectangle rect){
          if (w.app.texture == null)           createInnie(rect,allUV.normalize(rect),to3d,mbs.getTexture(""String_Node_Str"" + mf.app.texture + ""String_Node_Str""+ w.hashCode(),mf.app.texture,w.app.hasA),0.2f,0,MeshBuilder.ALL_BUT_FRONT);
 else           if (w.app.panes == null) {
            createInnie(rect,allUV.normalize(rect),to3d,mmb,0.2f,0,MeshBuilder.NO_FRONT_OR_BACK);
            mbs.getTexture(""String_Node_Str"" + w.app.texture + ""String_Node_Str""+ w.hashCode(),w.app.texture,w.app.hasA).add(rect,ZERO_ONE_UVS,to3d,-0.2);
          }
 else           if (w.app.textureUVs == TextureUVs.ZERO_ONE) {
            createInnie(rect,rect,to3d,mmb,0.2f,0,MeshBuilder.NO_FRONT_OR_BACK);
            createWindowFromPanes(w.app.panes,rect,rect,to3d,mbs.getTexture(""String_Node_Str"" + w.app.texture + ""String_Node_Str""+ w.hashCode(),w.app.texture,w.app.hasA),0.3,0.2);
          }
 else {
            DRectangle uvs=allUV.normalize(rect);
            createInnie(rect,uvs,to3d,mmb,0.2f,0,MeshBuilder.NO_FRONT_OR_BACK);
            createWindowFromPanes(w.app.panes,rect,allUV,to3d,mbs.getTexture(""String_Node_Str"" + mf.app.texture + ""String_Node_Str""+ w.hashCode(),mf.app.texture,w.app.hasA),0.3,0.2);
          }
        }
      }
);
    }
    for (    FRect w : filteredFeatures.get(Feature.DOOR)) {
      if (allGeom.contains(w))       g.insert(w,new Griddable(){
        @Override public void instance(        DRectangle rect){
          if (w.app.texture == null)           createInnie(rect,allUV.normalize(rect),to3d,mmb,0.5f,0,MeshBuilder.ALL_BUT_FRONT);
 else           createInnie(rect,ZERO_ONE_UVS,to3d,mbs.getTexture(""String_Node_Str"" + w.app.texture,w.app.texture,w.app.hasA),0.3f,0,MeshBuilder.ALL_BUT_FRONT);
        }
      }
);
    }
    for (    FRect w : filteredFeatures.getRects(Feature.MOULDING,Feature.SILL)) {
      if (allGeom.contains(w))       g.insert(w,new Griddable(){
        @Override public void instance(        DRectangle rect){
          createInnie(rect,allUV.normalize(rect),to3d,mmb,-0.1f,0,MeshBuilder.ALL_BUT_FRONT);
        }
      }
);
    }
    for (    FRect w : filteredFeatures.getRects(Feature.CORNICE)) {
      if (allGeom.contains(w))       g.insert(w,new Griddable(){
        @Override public void instance(        DRectangle rect){
          createInnie(rect,allUV.normalize(rect),to3d,mmb,-0.1f,0,MeshBuilder.ALL_BUT_FRONT);
        }
      }
);
    }
    for (    FRect b : filteredFeatures.get(Feature.BALCONY)) {
      if (allGeom.contains(b))       g.insert(b,new Griddable(){
        @Override public void instance(        DRectangle rect){
          createBalcony(rect,to3d,mbs.get(""String_Node_Str"" + b.app.color,b.app.color,mf),0.3);
        }
        @Override public boolean noneBehind(){
          return true;
        }
      }
);
    }
    g.instance(new Griddable(){
      @Override public void instance(      DRectangle rect){
        mmb.add(rect,allUV.normalize(rect),to3d);
      }
    }
);
  }
}","protected void textureGrid(DRectangle allGeom,DRectangle allUV,Matrix4d to3d,FeatureGenerator filteredFeatures,MiniFacade mf){
  if (mf != null && mf.app.texture != null) {
    Grid g=new Grid(.010,allGeom.x,allGeom.getMaxX(),allGeom.y,allGeom.getMaxY());
    MatMeshBuilder mmb=mbs.getTexture(""String_Node_Str"" + mf.app.texture,mf.app.texture,mf);
    for (    FRect w : filteredFeatures.getRects(Feature.WINDOW,Feature.SHOP)) {
      if (allGeom.contains(w))       g.insert(w,new Griddable(){
        @Override public void instance(        DRectangle rect){
          if (w.app.texture == null)           createInnie(rect,allUV.normalize(rect),to3d,mbs.getTexture(""String_Node_Str"" + mf.app.texture + ""String_Node_Str""+ w.hashCode(),mf.app.texture,w.app.hasA),0.2f,0,MeshBuilder.ALL_BUT_FRONT);
 else           if (w.app.panes == null) {
            createInnie(rect,allUV.normalize(rect),to3d,mmb,0.2f,0,MeshBuilder.NO_FRONT_OR_BACK);
            mbs.getTexture(""String_Node_Str"" + w.app.texture + ""String_Node_Str""+ w.hashCode(),w.app.texture,w.app.hasA).add(rect,ZERO_ONE_UVS,to3d,-0.2);
          }
 else           if (w.app.textureUVs == TextureUVs.ZERO_ONE) {
            createInnie(rect,rect,to3d,mmb,0.2f,0,MeshBuilder.NO_FRONT_OR_BACK);
            createWindowFromPanes(w.app.panes,rect,rect,to3d,mbs.getTexture(""String_Node_Str"" + w.app.texture + ""String_Node_Str""+ w.hashCode(),w.app.texture,w.app.hasA),0.3,0.2);
          }
 else {
            DRectangle uvs=allUV.normalize(rect);
            createInnie(rect,uvs,to3d,mmb,0.2f,0,MeshBuilder.NO_FRONT_OR_BACK);
            createWindowFromPanes(w.app.panes,rect,allUV,to3d,mbs.getTexture(""String_Node_Str"" + mf.app.texture + ""String_Node_Str""+ w.hashCode(),mf.app.texture,w.app.hasA),0.3,0.2);
          }
        }
      }
);
    }
    for (    FRect w : filteredFeatures.get(Feature.DOOR)) {
      if (allGeom.contains(w))       g.insert(w,new Griddable(){
        @Override public void instance(        DRectangle rect){
          if (w.app.texture == null)           createInnie(rect,allUV.normalize(rect),to3d,mmb,0.5f,0,MeshBuilder.ALL_BUT_FRONT);
 else           createInnie(rect,ZERO_ONE_UVS,to3d,mbs.getTexture(""String_Node_Str"" + w.app.texture,w.app.texture,w.app.hasA),0.3f,0,MeshBuilder.ALL_BUT_FRONT);
        }
      }
);
    }
    for (    FRect w : filteredFeatures.getRects(Feature.MOULDING,Feature.SILL)) {
      if (allGeom.contains(w))       g.insert(w,new Griddable(){
        @Override public void instance(        DRectangle rect){
          if (w.f == Feature.MOULDING)           System.out.println(""String_Node_Str"" + rect);
          createInnie(rect,allUV.normalize(rect),to3d,mmb,-0.1f,0,MeshBuilder.ALL_BUT_FRONT);
        }
      }
);
    }
    for (    FRect w : filteredFeatures.getRects(Feature.CORNICE)) {
      if (allGeom.contains(w))       g.insert(w,new Griddable(){
        @Override public void instance(        DRectangle rect){
          createInnie(rect,allUV.normalize(rect),to3d,mmb,-0.1f,0,MeshBuilder.ALL_BUT_FRONT);
        }
      }
);
    }
    for (    FRect b : filteredFeatures.get(Feature.BALCONY)) {
      if (allGeom.contains(b))       g.insert(b,new Griddable(){
        @Override public void instance(        DRectangle rect){
          createBalcony(rect,to3d,mbs.get(""String_Node_Str"" + b.app.color,b.app.color,mf),0.3);
        }
        @Override public boolean noneBehind(){
          return true;
        }
      }
);
    }
    g.instance(new Griddable(){
      @Override public void instance(      DRectangle rect){
        mmb.add(rect,allUV.normalize(rect),to3d);
      }
    }
);
  }
}",0.9867077095284736
175829,"protected void createDormerWindow(MiniRoof roof,QuadF l,MeshBuilder window,MeshBuilder glass,float sillDepth,float sillHeight,float corniceHeight,double panelWidth,double panelHeight){
  Vector3d along=new Vector3d(l.corners[3]);
  along.sub(l.corners[0]);
  along.normalize();
  Vector3d up=new Vector3d(0,1,0);
  Vector3d out=new Vector3d();
  out.cross(along,up);
  out.scale(1 / out.length());
  Line3d lout;
{
    Point3d away=new Point3d(l.corners[0]);
    away.add(out);
    lout=new Line3d(new Point3d(l.corners[0]),away);
  }
  Vector3d loc=new Vector3d(l.found[0]);
  if (lout.findPPram(l.found[0]) < lout.findPPram(l.found[1])) {
    loc=new Vector3d(up);
    loc.scale(-l.original.height);
    loc.add(l.found[1]);
  }
{
    Vector3d avoidRoof=new Vector3d(out);
    avoidRoof.scale(0.09);
    loc.add(avoidRoof);
  }
  Point3d deepest=Arrays.stream(l.found).map(p -> new Pair<Point3d,Double>(p,lout.findPPram(p))).max((a,b) -> b.second().compareTo(a.second())).get().first();
  double depth=lout.closestPointOn(deepest,false).distance(lout.closestPointOn(new Point3d(loc),false));
  Matrix4d to3d;
  double outset=0.1;
{
    Matrix4d to2dXY=new Matrix4d();
    to2dXY.setRow(2,up.x,up.y,up.z,0);
    to2dXY.setRow(1,-out.x,-out.y,-out.z,0);
    to2dXY.setRow(0,along.x,along.y,along.z,0);
    Vector3d p=new Vector3d(out);
    p.scale(outset / p.length());
    p.add(loc);
    to2dXY.m33=1;
    to2dXY.transform(p);
    to2dXY.m03=-p.x;
    to2dXY.m13=-p.y;
    to2dXY.m23=-p.z;
    to3d=new Matrix4d(to2dXY);
    to3d.invert();
  }
  FRect w=new FRect(l.original,false);
{
    w.app.coveringRoof=new Loop<Point2d>();
    Point2d p=new Point2d(loc.x,loc.z), d=new Point2d(deepest.x,deepest.z);
    p.scaleAdd(outset,new Vector2d(out.x,out.z),p);
    w.app.coveringRoof.append(new Point2d(p));
    w.app.coveringRoof.append(new Point2d(d));
    d.scaleAdd(w.width,new Vector2d(along.x,along.z),d);
    w.app.coveringRoof.append(new Point2d(d));
    p.scaleAdd(w.width,new Vector2d(along.x,along.z),p);
    w.app.coveringRoof.append(new Point2d(p));
  }
  w.x=0;
  w.y=0;
  if (tweed != null)   if (w.app.texture == null)   WindowGen.createWindow(window,glass,new Window(Jme3z.to(loc),Jme3z.to(along),Jme3z.to(up),l.original.width,l.original.height,depth,panelWidth,panelHeight));
 else   if (w.app.panes == null) {
    createInnie(w,ZERO_ONE_UVS,to3d,window,0.2f,0,MeshBuilder.NO_FRONT_OR_BACK);
    mbs.getTexture(""String_Node_Str"" + w.app.texture + ""String_Node_Str""+ w.hashCode(),w.app.texture,w).add(w,ZERO_ONE_UVS,to3d,-0.2);
  }
 else {
    createInnie(w,null,to3d,mbs.GRAY,-depth + outset - 0.5,-depth + outset - 0.5,new boolean[]{true,true,false,true,false,false});
    if (w.app.coveringRoof != null) {
      double height=loc.y + w.height;
      LoopL<Point3d> rp=w.app.coveringRoof.singleton().new Map<Point3d>(){
        @Override public Point3d map(        Loopable<Point2d> input){
          return Pointz.to3(input.get(),height);
        }
      }
.run();
      LoopL<Point2d> uvs=w.app.coveringRoof.singleton().new Map<Point2d>(){
        @Override public Point2d map(        Loopable<Point2d> input){
          if (roof.app.textureRect == null)           return input.get();
 else           return roof.app.textureRect.normalize(input.get());
        }
      }
.run();
      MeshBuilder roofTexture=roof.app.texture == null ? window : mbs.getTexture(""String_Node_Str"" + roof.app.texture,roof.app.texture,roof);
      roofTexture.add(rp,roof.app.texture == null ? null : uvs,true);
    }
 else {
      createInnie(w,null,to3d,window,-depth + outset - 0.5,-depth + outset - 0.5,new boolean[]{false,false,true,false,false,false});
    }
    createWindowFromPanes(w.app.panes,w,w,to3d,mbs.getTexture(""String_Node_Str"" + w.app.texture + ""String_Node_Str""+ w.hashCode(),w.app.texture,w),0.1,0);
  }
}","protected void createDormerWindow(MiniRoof roof,QuadF l,MeshBuilder window,MeshBuilder glass,float sillDepth,float sillHeight,float corniceHeight,double panelWidth,double panelHeight){
  Vector3d along=new Vector3d(l.corners[3]);
  along.sub(l.corners[0]);
  along.normalize();
  Vector3d up=new Vector3d(0,1,0);
  Vector3d out=new Vector3d();
  out.cross(along,up);
  out.scale(1 / out.length());
  Line3d lout;
{
    Point3d away=new Point3d(l.corners[0]);
    away.add(out);
    lout=new Line3d(new Point3d(l.corners[0]),away);
  }
  Vector3d loc=new Vector3d(l.found[0]);
  if (lout.findPPram(l.found[0]) < lout.findPPram(l.found[1])) {
    loc=new Vector3d(up);
    loc.scale(-l.original.height);
    loc.add(l.found[1]);
  }
{
    Vector3d avoidRoof=new Vector3d(out);
    avoidRoof.scale(0.09);
    loc.add(avoidRoof);
  }
  Point3d deepest=Arrays.stream(l.found).map(p -> new Pair<Point3d,Double>(p,lout.findPPram(p))).max((a,b) -> b.second().compareTo(a.second())).get().first();
  double depth=lout.closestPointOn(deepest,false).distance(lout.closestPointOn(new Point3d(loc),false));
  Matrix4d to3d;
  double outset=0.1;
{
    Matrix4d to2dXY=new Matrix4d();
    to2dXY.setRow(2,up.x,up.y,up.z,0);
    to2dXY.setRow(1,-out.x,-out.y,-out.z,0);
    to2dXY.setRow(0,along.x,along.y,along.z,0);
    Vector3d p=new Vector3d(out);
    p.scale(outset / p.length());
    p.add(loc);
    to2dXY.m33=1;
    to2dXY.transform(p);
    to2dXY.m03=-p.x;
    to2dXY.m13=-p.y;
    to2dXY.m23=-p.z;
    to3d=new Matrix4d(to2dXY);
    to3d.invert();
  }
  FRect w=new FRect(l.original,false);
{
    w.app.coveringRoof=new Loop<Point2d>();
    Point2d p=new Point2d(loc.x,loc.z), d=new Point2d();
    d.scaleAdd(-depth,new Vector2d(out.x,out.z),p);
    p.scaleAdd(outset,new Vector2d(out.x,out.z),p);
    w.app.coveringRoof.append(new Point2d(p));
    w.app.coveringRoof.append(new Point2d(d));
    d.scaleAdd(w.width,new Vector2d(along.x,along.z),d);
    w.app.coveringRoof.append(new Point2d(d));
    p.scaleAdd(w.width,new Vector2d(along.x,along.z),p);
    w.app.coveringRoof.append(new Point2d(p));
  }
  w.x=0;
  w.y=0;
  if (tweed != null)   if (w.app.texture == null)   WindowGen.createWindow(window,glass,new Window(Jme3z.to(loc),Jme3z.to(along),Jme3z.to(up),l.original.width,l.original.height,depth,panelWidth,panelHeight));
 else   if (w.app.panes == null) {
    createInnie(w,null,to3d,window,0.2f,0,MeshBuilder.NO_FRONT_OR_BACK);
    mbs.getTexture(""String_Node_Str"" + w.app.texture + ""String_Node_Str""+ w.hashCode(),w.app.texture,w).add(w,ZERO_ONE_UVS,to3d,-0.2);
  }
 else {
    createInnie(w,null,to3d,mbs.GRAY,-depth + outset - 0.5,-depth + outset - 0.5,new boolean[]{true,true,false,true,false,false});
    if (w.app.coveringRoof != null) {
      double height=loc.y + w.height;
      LoopL<Point3d> rp=w.app.coveringRoof.singleton().new Map<Point3d>(){
        @Override public Point3d map(        Loopable<Point2d> input){
          return Pointz.to3(input.get(),height);
        }
      }
.run();
      LoopL<Point2d> uvs=w.app.coveringRoof.singleton().new Map<Point2d>(){
        @Override public Point2d map(        Loopable<Point2d> input){
          if (roof.app.textureRect == null)           return input.get();
 else           return roof.app.textureRect.normalize(input.get());
        }
      }
.run();
      MeshBuilder roofTexture=roof.app.texture == null ? window : mbs.getTexture(""String_Node_Str"" + roof.app.texture,roof.app.texture,roof);
      roofTexture.add(rp,roof.app.texture == null ? null : uvs,true);
    }
 else {
      createInnie(w,null,to3d,window,-depth + outset - 0.5,-depth + outset - 0.5,new boolean[]{false,false,true,false,false,false});
    }
    createWindowFromPanes(w.app.panes,w,w,to3d,mbs.getTexture(""String_Node_Str"" + w.app.texture + ""String_Node_Str""+ w.hashCode(),w.app.texture,w),0.1,0);
  }
}",0.9904836396819188
175830,"public void createMesh(Output output){
  float[] roofColor=BLANK_ROOF;
  if (output.faces == null)   return;
  double bestRoofArea=0;
  roofColor=Colourz.toF4(HasApp.get(miniroof).color);
  Set<MiniFacade> allMFs=new HashSet<>();
  for (  Face f : output.faces.values()) {
    WallTag wt=((WallTag)GreebleHelper.getTag(f.profile,WallTag.class));
    if (wt != null)     if (wt.miniFacade != null)     allMFs.add(wt.miniFacade);
  }
  if (tweed != null)   for (  MiniFacade mf : allMFs) {
    mf.postState=new PostProcessState();
  }
  List<List<Face>> chains=Campz.findChains(output);
  if (tweed != null)   for (  List<Face> chain : chains) {
    Set<WallTag> opt=chain.stream().flatMap(f -> f.profile.stream()).filter(tag -> tag instanceof WallTag).map(t -> (WallTag)t).collect(Collectors.toSet());
    for (    WallTag wt : opt) {
      MiniFacade mf=wt.miniFacade;
      Edge e=chain.get(0).edge;
      Line megafacade=new Line(e.end.x,e.end.y,e.start.x,e.start.y);
      double mfl=megafacade.length();
      Vector2d dir=megafacade.dir();
      LinearForm3D lf=new LinearForm3D(new Vector3d(-dir.y,dir.x,0),e.start);
      for (      Face f : chain)       for (      Loop<Point2d> face : projectTo(megafacade,mfl,lf,f))       if (GreebleHelper.getTag(f.profile,WallTag.class) != null)       mf.postState.wallFaces.add(face);
 else       mf.postState.roofFaces.add(face);
      if (occluderLookup != null)       for (      Object o : wt.occlusions) {
        Face f=occluderLookup.get(o);
        if (f != null)         mf.postState.occluders.addAll(projectTo(megafacade,mfl,lf,f));
      }
      mf.width=chain.get(0).edge.length();
    }
  }
  for (  MiniFacade mf : allMFs) {
    mf.postState.outerWallRect=GreebleHelper.findRect(mf.postState.wallFaces);
    mf.featureGen.update();
  }
  if (tweed != null)   greebleGrid=new GreebleGrid(tweed,new MMeshBuilderCache());
  for (  List<Face> chain : chains) {
    Optional<Tag> opt=chain.stream().flatMap(f -> f.profile.stream()).filter(tag -> tag instanceof WallTag).findAny();
    WallTag wt=null;
    MiniFacade mf2=null;
    Set<QuadF> processedFeatures=new HashSet<>();
    Line megafacade=new Line();
    if (opt.isPresent() && (wt=(WallTag)opt.get()).miniFacade != null) {
      mf2=wt.miniFacade;
{
        Edge e=chain.get(0).edge;
        megafacade.set(e.end.x,e.end.y,e.start.x,e.start.y);
      }
      if (false && TweedSettings.settings.snapFacadeWidth) {
        mf2=new MiniFacade(wt.miniFacade);
        mf2.postState=wt.miniFacade.postState;
        double[] meshSE=findSE(wt.miniFacade,megafacade,chain);
        mf2.scaleX(meshSE[0],meshSE[1]);
      }
      mf2.featureGen.values().stream().flatMap(k -> k.stream()).map(r -> new QuadF(r,megafacade)).forEach(q -> processedFeatures.add(q));
    }
    if (tweed != null) {
      Set<QuadF> allFeatures=new LinkedHashSet<>();
      allFeatures.addAll(processedFeatures);
      for (      Face f : chain)       face(f,mf2,processedFeatures,megafacade);
      allFeatures.removeAll(processedFeatures);
      for (      QuadF q1 : allFeatures) {
        mf2.postState.generatedWindows.add(q1.original);
      }
    }
    if ((wt != null && wt.miniFacade.app.dormer) || TweedSettings.settings.createDormers) {
      Iterator<QuadF> quit=processedFeatures.iterator();
      while (quit.hasNext()) {
        QuadF w=quit.next();
        if ((w.original.f == Feature.WINDOW || w.original.f == Feature.SHOP) && w.foundAll()) {
          mf2.postState.generatedWindows.add(w.original);
          if (greebleGrid != null)           greebleGrid.createDormerWindow(miniroof,w,greebleGrid.mbs.WOOD,greebleGrid.mbs.GLASS,(float)wt.sillDepth,(float)wt.sillHeight,(float)wt.corniceHeight,0.6,0.9);
          quit.remove();
        }
      }
    }
    if (greebleGrid != null) {
      edges(output,roofColor);
      greebleGrid.attachAll(node,chain,output,new ClickMe(){
        @Override public void clicked(        Object data){
          try {
            SwingUtilities.invokeAndWait(new Runnable(){
              @Override public void run(){
                selected(output,node,findSuperEdge(output,chain),data instanceof Spatial ? ((HasApp)((Object[])((Spatial)data).getUserData(Appearance))[0]) : null);
              }
            }
);
          }
 catch (          Throwable th) {
            th.printStackTrace();
          }
        }
      }
);
    }
  }
}","public void createMesh(Output output){
  float[] roofColor=BLANK_ROOF;
  if (output.faces == null)   return;
  double bestRoofArea=0;
  roofColor=Colourz.toF4(HasApp.get(miniroof).color);
  Set<MiniFacade> allMFs=new HashSet<>();
  for (  Face f : output.faces.values()) {
    WallTag wt=((WallTag)GreebleHelper.getTag(f.profile,WallTag.class));
    if (wt != null) {
      if (wt.miniFacade != null)       allMFs.add(wt.miniFacade);
    }
  }
  if (tweed != null)   for (  MiniFacade mf : allMFs) {
    mf.postState=new PostProcessState();
  }
  List<List<Face>> chains=Campz.findChains(output);
  if (tweed != null)   for (  List<Face> chain : chains) {
    Set<WallTag> opt=chain.stream().flatMap(f -> f.profile.stream()).filter(tag -> tag instanceof WallTag).map(t -> (WallTag)t).collect(Collectors.toSet());
    for (    WallTag wt : opt) {
      MiniFacade mf=wt.miniFacade;
      Edge e=chain.get(0).edge;
      Line megafacade=new Line(e.end.x,e.end.y,e.start.x,e.start.y);
      double mfl=megafacade.length();
      Vector2d dir=megafacade.dir();
      LinearForm3D lf=new LinearForm3D(new Vector3d(-dir.y,dir.x,0),e.start);
      for (      Face f : chain)       for (      Loop<Point2d> face : projectTo(megafacade,mfl,lf,f))       if (GreebleHelper.getTag(f.profile,WallTag.class) != null)       mf.postState.wallFaces.add(face);
 else       mf.postState.roofFaces.add(face);
      if (occluderLookup != null)       for (      Object o : wt.occlusions) {
        Face f=occluderLookup.get(o);
        if (f != null)         mf.postState.occluders.addAll(projectTo(megafacade,mfl,lf,f));
      }
      mf.width=chain.get(0).edge.length();
    }
  }
  for (  MiniFacade mf : allMFs) {
    mf.postState.outerWallRect=GreebleHelper.findRect(mf.postState.wallFaces);
    mf.featureGen.update();
  }
  if (tweed != null)   greebleGrid=new GreebleGrid(tweed,new MMeshBuilderCache());
  for (  List<Face> chain : chains) {
    Optional<Tag> opt=chain.stream().flatMap(f -> f.profile.stream()).filter(tag -> tag instanceof WallTag).findAny();
    WallTag wt=null;
    MiniFacade mf2=null;
    Set<QuadF> processedFeatures=new HashSet<>();
    Line megafacade=new Line();
    if (opt.isPresent() && (wt=(WallTag)opt.get()).miniFacade != null) {
      mf2=wt.miniFacade;
{
        Edge e=chain.get(0).edge;
        megafacade.set(e.end.x,e.end.y,e.start.x,e.start.y);
      }
      if (false && TweedSettings.settings.snapFacadeWidth) {
        mf2=new MiniFacade(wt.miniFacade);
        mf2.postState=wt.miniFacade.postState;
        double[] meshSE=findSE(wt.miniFacade,megafacade,chain);
        mf2.scaleX(meshSE[0],meshSE[1]);
      }
      mf2.featureGen.values().stream().flatMap(k -> k.stream()).map(r -> new QuadF(r,megafacade)).forEach(q -> processedFeatures.add(q));
    }
    if (tweed != null) {
      Set<QuadF> allFeatures=new LinkedHashSet<>();
      allFeatures.addAll(processedFeatures);
      for (      Face f : chain)       face(f,mf2,processedFeatures,megafacade);
      allFeatures.removeAll(processedFeatures);
      for (      QuadF q1 : allFeatures) {
        if (q1.original.f == Feature.WINDOW || q1.original.f == Feature.SHOP) {
          mf2.postState.generatedWindows.add(q1.original);
        }
      }
    }
    if ((wt != null && wt.miniFacade.app.dormer) || TweedSettings.settings.createDormers) {
      Iterator<QuadF> quit=processedFeatures.iterator();
      while (quit.hasNext()) {
        QuadF w=quit.next();
        if ((w.original.f == Feature.WINDOW || w.original.f == Feature.SHOP) && w.foundAll()) {
          mf2.postState.generatedWindows.add(w.original);
          if (greebleGrid != null)           greebleGrid.createDormerWindow(miniroof,w,greebleGrid.mbs.WOOD,greebleGrid.mbs.GLASS,(float)wt.sillDepth,(float)wt.sillHeight,(float)wt.corniceHeight,0.6,0.9);
          quit.remove();
        }
      }
    }
    if (greebleGrid != null) {
      edges(output,roofColor);
      greebleGrid.attachAll(node,chain,output,new ClickMe(){
        @Override public void clicked(        Object data){
          try {
            SwingUtilities.invokeAndWait(new Runnable(){
              @Override public void run(){
                selected(output,node,findSuperEdge(output,chain),data instanceof Spatial ? ((HasApp)((Object[])((Spatial)data).getUserData(Appearance))[0]) : null);
              }
            }
);
          }
 catch (          Throwable th) {
            th.printStackTrace();
          }
        }
      }
);
    }
  }
}",0.9243621585007904
175831,"public Map<Griddable,DRectangle> findPositions(){
  Map<Griddable,Double[]> rx=findRange(x), ry=findRange(y);
  Map<Griddable,DRectangle> out=new HashMap<>();
  rx.keySet().stream().forEach(g -> out.put(g,new DRectangle(rx.get(g)[0],ry.get(g)[0],rx.get(g)[1] - rx.get(g)[0],ry.get(g)[1] - ry.get(g)[0])));
  return out;
}","public Map<Griddable,DRectangle> findPositions(){
  Map<Griddable,DRectangle> out=new HashMap<>();
  if (x == null || y == null)   return out;
  Map<Griddable,Double[]> rx=findRange(x), ry=findRange(y);
  rx.keySet().stream().forEach(g -> out.put(g,new DRectangle(rx.get(g)[0],ry.get(g)[0],rx.get(g)[1] - rx.get(g)[0],ry.get(g)[1] - ry.get(g)[0])));
  return out;
}",0.760932944606414
175832,"private void constrainMoulding(MiniFacade mf,FRect d,double alpha){
  final double tol=4;
  if (d.x < mf.left + tol)   set(d,Bounds.XMIN,mf.left + 0.1,alpha * 5);
  if (d.x > mf.left + mf.width - tol)   set(d,Bounds.XMAX,mf.left + mf.width - 0.1,alpha * 5);
}","private void constrainMoulding(MiniFacade mf,FRect d,double alpha){
  for (int j=0; j < d.adjacent.length; j++) {
    FRect n=d.adjacent[j];
    if (n == null)     continue;
    DRectangle u=d.union(n), i=d.intersect(n);
    double ia=i == null ? 0 : i.area();
    if ((n.area() + d.area() - ia) / u.area() > 0.7) {
      d.setFrom(u);
      d.adjacent[j]=null;
      mf.featureGen.remove(n.f,n);
    }
  }
  for (  FRect avoid : mf.featureGen.getRects(Feature.WINDOW,Feature.SHOP)) {
    if (d.intersects(avoid)) {
      for (      Bounds[] b : new Bounds[][]{{Bounds.YMIN,Bounds.YMAX},{Bounds.XMIN,Bounds.XMAX}}) {
        Bounds min=b[0], max=b[1];
        if (d.get(max) > avoid.get(min) && d.get(max) < avoid.get(max)) {
          if (d.get(min) < avoid.get(min))           d.set(max,avoid.get(min));
 else {
            mf.featureGen.remove(d.f,d);
            return;
          }
        }
 else         if (d.get(min) > avoid.get(min) && d.get(min) < avoid.get(max)) {
          if (d.get(max) > avoid.get(max)) {
            d.set(min,avoid.get(max));
          }
 else {
            mf.featureGen.remove(d.f,d);
            return;
          }
        }
      }
    }
  }
  final double tol=4;
  if (d.x < mf.left + tol)   set(d,Bounds.XMIN,mf.left + 0.1,alpha * 5);
  if (d.x > mf.left + mf.width - tol)   set(d,Bounds.XMAX,mf.left + mf.width - 0.1,alpha * 5);
}",0.1642156862745098
175833,"private MiniFacade combine(List<MiniFacade> in){
  MiniFacade out=new MiniFacade();
  out.left=lp;
  out.width=rp - lp;
  out.imageFeatures=in.get(0).imageFeatures;
  double[] color=new double[]{0,0,0,1};
  int gcc=0;
  for (  MiniFacade mf : in)   for (int i=0; i < 3; i++) {
    color[i]+=color[i];
  }
  for (int i=0; i < 3; i++) {
    color[i]/=in.size();
  }
  out.app.color=Colourz.to4(color);
  Cache2<Outer,Integer,List<FRect>> corniceX=new ArrayCache2();
  Cache2<Outer,Integer,List<FRect>> sillX=new ArrayCache2();
  Cache2<Outer,Integer,List<FRect>> balX=new ArrayCache2();
  out.height=in.stream().mapToDouble(mf -> mf.height).average().getAsDouble();
  out.groundFloorHeight=in.stream().mapToDouble(mf -> mf.groundFloorHeight).average().getAsDouble();
  for (int i=0; i < ids; i++) {
    int yay=0, nay=0;
    int ii=i;
    List<FRect> found=in.stream().map(mf -> m2i2r.get(mf,ii)).filter(x -> x != null).flatMap(l -> l.stream()).collect(Collectors.toList());
    Point2d avg=found.stream().map(r -> r.getCenter()).collect(new Point2DMeanCollector());
    for (    MiniFacade mf : in) {
      List<FRect> r=m2i2r.get(mf,i);
      if (mf.contains(avg)) {
        if (r.isEmpty()) {
          if (mf.left + 3 < avg.x && mf.left + mf.width - 3 > avg.x)           nay++;
        }
 else         yay++;
      }
    }
    if (yay >= nay) {
      FRect o;
      if (dimensionSpread(found) > 1.4) {
        o=new FRect(found.get(0),true);
        for (        FRect n : found)         o.setFrom(o.union(n));
      }
 else {
        o=new FRect(average(found.toArray(new FRect[found.size()])),out);
      }
{
        FRect t=found.get(0);
        o.f=t.f;
        o.id=i;
        o.app=t.app;
        o.attached=t.attached;
        o.attachedHeight.get(Feature.SILL).d=averageAttached(o,Feature.SILL,found);
        o.attachedHeight.get(Feature.CORNICE).d=averageAttached(o,Feature.CORNICE,found);
        o.attachedHeight.get(Feature.BALCONY).d=averageAttached(o,Feature.BALCONY,found);
        if (t.f == Feature.WINDOW || t.f == Feature.SHOP) {
          for (          FRect r : found) {
            corniceX.get(r.outer,r.yi).add(o);
            sillX.get(r.outer,r.yi).add(o);
            balX.get(r.outer,r.yi).add(o);
          }
        }
      }
      out.featureGen.put(o.f,o);
    }
  }
  spreadAttachedOverGrid(Feature.SILL,sillX);
  spreadAttachedOverGrid(Feature.CORNICE,corniceX);
  spreadAttachedOverGrid(Feature.BALCONY,balX);
  fixOverlaps(out);
  mergeRemoveSmall(out);
  DRectangle mr=out.getAsRect();
  mr.width-=0.01;
  mr.x+=0.1;
  for (  Feature f : Feature.values()) {
    Iterator<FRect> rit=out.featureGen.get(f).iterator();
    while (rit.hasNext()) {
      FRect r=rit.next();
      DRectangle section=r.intersect(mr);
      if (section == null)       rit.remove();
 else       r.setFrom(section);
    }
  }
{
    Double hf=Double.valueOf(0);
    while (out.groundFloorHeight < 6 && ((hf=horizontalEmpty(out,out.groundFloorHeight)) != null))     out.groundFloorHeight=hf + 0.3;
    if (out.groundFloorHeight >= 6)     out.groundFloorHeight=0;
  }
  return out;
}","private MiniFacade combine(List<MiniFacade> in){
  MiniFacade out=new MiniFacade();
  out.left=lp;
  out.width=rp - lp;
  out.imageFeatures=in.get(0).imageFeatures;
  if (toReg.length == 0)   out.height=in.stream().mapToDouble(mf -> mf.height).average().getAsDouble();
 else   out.height=500;
  double[] color=new double[]{0,0,0,1};
  int gcc=0;
  for (  MiniFacade mf : in)   for (int i=0; i < 3; i++) {
    color[i]+=color[i];
  }
  for (int i=0; i < 3; i++) {
    color[i]/=in.size();
  }
  out.app.color=Colourz.to4(color);
  Cache2<Outer,Integer,List<FRect>> corniceX=new ArrayCache2();
  Cache2<Outer,Integer,List<FRect>> sillX=new ArrayCache2();
  Cache2<Outer,Integer,List<FRect>> balX=new ArrayCache2();
  out.groundFloorHeight=in.stream().mapToDouble(mf -> mf.groundFloorHeight).average().getAsDouble();
  for (int i=0; i < ids; i++) {
    int yay=0, nay=0;
    int ii=i;
    List<FRect> found=in.stream().map(mf -> m2i2r.get(mf,ii)).filter(x -> x != null).flatMap(l -> l.stream()).collect(Collectors.toList());
    Point2d avg=found.stream().map(r -> r.getCenter()).collect(new Point2DMeanCollector());
    for (    MiniFacade mf : in) {
      List<FRect> r=m2i2r.get(mf,i);
      if (mf.contains(avg)) {
        if (r.isEmpty()) {
          if (mf.left + 3 < avg.x && mf.left + mf.width - 3 > avg.x)           nay++;
        }
 else         yay++;
      }
    }
    if (yay >= nay) {
      FRect o;
      if (dimensionSpread(found) > 1.4) {
        o=new FRect(found.get(0),true);
        for (        FRect n : found)         o.setFrom(o.union(n));
      }
 else {
        o=new FRect(average(found.toArray(new FRect[found.size()])),out);
      }
{
        FRect t=found.get(0);
        o.f=t.f;
        o.id=i;
        o.app=t.app;
        o.attached=t.attached;
        o.attachedHeight.get(Feature.SILL).d=averageAttached(o,Feature.SILL,found);
        o.attachedHeight.get(Feature.CORNICE).d=averageAttached(o,Feature.CORNICE,found);
        o.attachedHeight.get(Feature.BALCONY).d=averageAttached(o,Feature.BALCONY,found);
        if (t.f == Feature.WINDOW || t.f == Feature.SHOP) {
          for (          FRect r : found) {
            corniceX.get(r.outer,r.yi).add(o);
            sillX.get(r.outer,r.yi).add(o);
            balX.get(r.outer,r.yi).add(o);
          }
        }
      }
      out.featureGen.put(o.f,o);
    }
  }
  spreadAttachedOverGrid(Feature.SILL,sillX);
  spreadAttachedOverGrid(Feature.CORNICE,corniceX);
  spreadAttachedOverGrid(Feature.BALCONY,balX);
  fixOverlaps(out);
  mergeRemoveSmall(out);
  DRectangle mr=out.getAsRect();
  mr.width-=0.01;
  mr.x+=0.1;
  for (  Feature f : Feature.values()) {
    Iterator<FRect> rit=out.featureGen.get(f).iterator();
    while (rit.hasNext()) {
      FRect r=rit.next();
      DRectangle section=r.intersect(mr);
      if (section == null)       rit.remove();
 else       r.setFrom(section);
    }
  }
{
    Double hf=Double.valueOf(0);
    while (out.groundFloorHeight < 6 && ((hf=horizontalEmpty(out,out.groundFloorHeight)) != null))     out.groundFloorHeight=hf + 0.3;
    if (out.groundFloorHeight >= 6)     out.groundFloorHeight=0;
  }
  return out;
}",0.9668322384233295
175834,"public List<MiniFacade> go(List<MiniFacade> in,double debugFrac,MegaFeatures megaFeatures){
  for (  MiniFacade mf : in)   if (mf.imageFeatures != null)   seenImages.add(mf.imageFeatures.ortho);
  if (in.isEmpty())   return Collections.singletonList(gridMini());
  System.out.println(""String_Node_Str"" + in.size() + ""String_Node_Str"");
  if (megaFeatures != null)   in=augmentWithTween(in,megaFeatures);
  System.out.println(""String_Node_Str"" + in.size() + ""String_Node_Str"");
  List<MiniFacade> out;
  if (true)   out=newFromWindows(in);
 else   out=in.stream().map(mf -> new MiniFacade(mf)).collect(Collectors.toList());
  System.out.println(""String_Node_Str"" + out.size() + ""String_Node_Str"");
  if (debugFrac < 0) {
    out.add(0,new MiniFacade());
    return out;
  }
  if (toReg.length > 0)   alignMFs(out);
 else {
    lp=in.get(0).left;
    rp=in.get(0).width;
  }
  if (debugFrac == 0) {
    out.add(0,new MiniFacade());
    return out;
  }
  for (  MiniFacade mf : out) {
    assignFeaturesToWindows(mf.featureGen.getRects(Feature.WINDOW,Feature.SHOP).stream().collect(Collectors.toList()),mf.featureGen);
    mf.featureGen.get(Feature.CORNICE).clear();
    mf.featureGen.get(Feature.BALCONY).clear();
    mf.featureGen.get(Feature.SILL).clear();
    mf.featureGen.get(Feature.GRID).clear();
  }
  for (  MiniFacade mf : out) {
    mergeRemoveSmall(mf);
    mergeRemoveSimilar(mf);
  }
  for (  Feature f : Feature.values())   for (  MiniFacade mf : out)   mf.featureGen.get(f).stream().forEach(r -> r.f=f);
  for (int i=0; i < 50 * debugFrac; i++) {
    for (    MiniFacade mf : out)     for (    Feature f : toReg)     cluster1(mf.featureGen.getRects(f),1 * scale,alpha,Bounds.XMIN,Bounds.XMAX,Bounds.YMIN,Bounds.YMAX);
    List<FRect> allRects=new ArrayList<>();
    for (    MiniFacade mf : out)     for (    Feature f : toReg)     allRects.addAll(mf.featureGen.get(f));
    for (    Feature f : toReg) {
      List<FRect> allF=out.stream().flatMap(mf -> mf.featureGen.get(f).stream()).collect(Collectors.toList());
      cluster1(allF,0.5 * scale,alpha,Bounds.WIDTH,Bounds.HEIGHT);
    }
    cluster1(allRects,0.2 * scale,alpha,Bounds.XMIN,Bounds.XMAX,Bounds.YMIN,Bounds.YMAX);
    if (i % 5 == 0)     for (    MiniFacade mf : out) {
      findNeighbours(mf.featureGen.getRects(Feature.WINDOW,Feature.SHOP));
      findNeighbours(mf.featureGen.getRects(Feature.MOULDING));
    }
    for (    Dir dir : Dir.values())     clusterDeltas(allRects,0.2 * scale,alpha,dir);
    for (    MiniFacade mf : out) {
      if (toReg.length > 0)       for (      FRect d : mf.featureGen.get(Feature.DOOR))       constrainDoor(mf,d,alpha);
      for (      FRect m : mf.featureGen.get(Feature.MOULDING))       constrainMoulding(mf,m,alpha);
    }
    for (    MiniFacade mf : out) {
      for (      Feature f : toReg) {
        Iterator<FRect> rit=mf.featureGen.get(f).iterator();
        while (rit.hasNext()) {
          FRect r=rit.next();
          if (r.width <= 0.4 * scale || r.height <= 0.4 * scale)           rit.remove();
 else           for (          FRect n : r.adjacent)           if (n != null && similar(n,r)) {
            n.attached.putAll(r.attached);
            rit.remove();
            break;
          }
        }
      }
    }
  }
  for (  MiniFacade mf : out) {
    findOuters(mf);
    mergeRemoveSmall(mf);
  }
  ids=0;
  for (  Feature f : toReg2) {
    List<Pair<MiniFacade,FRect>> allRects=new ArrayList<>();
    for (    MiniFacade mf : out)     for (    FRect r : mf.featureGen.get(f)) {
      r.id=-1;
      allRects.add(new Pair<>(mf,r));
    }
    Collections.sort(allRects,new Comparator<Pair<MiniFacade,FRect>>(){
      @Override public int compare(      Pair<MiniFacade,FRect> a_,      Pair<MiniFacade,FRect> b_){
        FRect a=a_.second(), b=b_.second();
        if (a.gridCoords != null && b.gridCoords == null)         return -1;
        if (b.gridCoords != null && a.gridCoords == null)         return 1;
        if (a.gridCoords != null && b.gridCoords != null) {
          int out=-Integer.compare(countCoords(a.gridCoords),countCoords(b.gridCoords));
          if (out != 0)           return out;
        }
        return Double.compare(a.area(),b.area());
      }
      private int countCoords(      int[] gridCoords){
        int out=0;
        for (        int i : gridCoords)         if (i != -Integer.MAX_VALUE)         out++;
        return out;
      }
    }
);
    for (    Pair<MiniFacade,FRect> pair : allRects) {
      FRect w=pair.second();
      if (w.id == -1)       findId(w,f,out,pair.first(),ids++);
    }
  }
  out.add(0,combine(out));
  System.out.println(""String_Node_Str"");
  return out;
}","public List<MiniFacade> go(List<MiniFacade> in,double debugFrac,MegaFeatures megaFeatures){
  for (  MiniFacade mf : in)   if (mf.imageFeatures != null)   seenImages.add(mf.imageFeatures.ortho);
  if (in.isEmpty())   return Collections.singletonList(gridMini());
  System.out.println(""String_Node_Str"" + in.size() + ""String_Node_Str"");
  if (megaFeatures != null)   in=augmentWithTween(in,megaFeatures);
  System.out.println(""String_Node_Str"" + in.size() + ""String_Node_Str"");
  List<MiniFacade> out;
  if (true)   out=newFromWindows(in);
 else   out=in.stream().map(mf -> new MiniFacade(mf)).collect(Collectors.toList());
  System.out.println(""String_Node_Str"" + out.size() + ""String_Node_Str"");
  if (debugFrac < 0) {
    out.add(0,new MiniFacade());
    return out;
  }
  if (toReg.length > 0)   alignMFs(out);
 else {
    lp=in.get(0).left;
    rp=in.get(0).width;
  }
  if (debugFrac == 0) {
    out.add(0,new MiniFacade());
    return out;
  }
  for (  MiniFacade mf : out) {
    assignFeaturesToWindows(mf.featureGen.getRects(Feature.WINDOW,Feature.SHOP).stream().collect(Collectors.toList()),mf.featureGen);
    mf.featureGen.get(Feature.CORNICE).clear();
    mf.featureGen.get(Feature.BALCONY).clear();
    mf.featureGen.get(Feature.SILL).clear();
    mf.featureGen.get(Feature.GRID).clear();
  }
  for (  MiniFacade mf : out) {
    mergeRemoveSmall(mf);
    mergeRemoveSimilar(mf);
  }
  for (  Feature f : Feature.values())   for (  MiniFacade mf : out)   mf.featureGen.get(f).stream().forEach(r -> r.f=f);
  for (int i=0; i < 50 * debugFrac; i++) {
    for (    MiniFacade mf : out)     for (    Feature f : toReg)     cluster1(mf.featureGen.getRects(f),1 * scale,alpha,Bounds.XMIN,Bounds.XMAX,Bounds.YMIN,Bounds.YMAX);
    List<FRect> allRects=new ArrayList<>();
    for (    MiniFacade mf : out)     for (    Feature f : toReg)     allRects.addAll(mf.featureGen.get(f));
    for (    Feature f : toReg) {
      List<FRect> allF=out.stream().flatMap(mf -> mf.featureGen.get(f).stream()).collect(Collectors.toList());
      cluster1(allF,0.5 * scale,alpha,Bounds.WIDTH,Bounds.HEIGHT);
    }
    cluster1(allRects,0.2 * scale,alpha,Bounds.XMIN,Bounds.XMAX,Bounds.YMIN,Bounds.YMAX);
    if (i % 5 == 0)     for (    MiniFacade mf : out) {
      findNeighbours(mf.featureGen.getRects(Feature.WINDOW,Feature.SHOP));
      findNeighbours(mf.featureGen.getRects(Feature.MOULDING));
    }
    for (    Dir dir : Dir.values())     clusterDeltas(allRects,0.2 * scale,alpha,dir);
    for (    MiniFacade mf : out) {
      if (toReg.length > 0)       for (      FRect d : mf.featureGen.get(Feature.DOOR))       constrainDoor(mf,d,alpha);
      for (      FRect m : new ArrayList<>(mf.featureGen.get(Feature.MOULDING)))       constrainMoulding(mf,m,alpha);
    }
    for (    MiniFacade mf : out) {
      for (      Feature f : toReg) {
        Iterator<FRect> rit=mf.featureGen.get(f).iterator();
        while (rit.hasNext()) {
          FRect r=rit.next();
          if (r.width <= 0.4 * scale || r.height <= 0.4 * scale)           rit.remove();
 else           for (          FRect n : r.adjacent)           if (n != null && similar(n,r)) {
            n.attached.putAll(r.attached);
            rit.remove();
            break;
          }
        }
      }
    }
  }
  for (  MiniFacade mf : out) {
    findOuters(mf);
    mergeRemoveSmall(mf);
  }
  ids=0;
  for (  Feature f : toReg2) {
    List<Pair<MiniFacade,FRect>> allRects=new ArrayList<>();
    for (    MiniFacade mf : out)     for (    FRect r : mf.featureGen.get(f)) {
      r.id=-1;
      allRects.add(new Pair<>(mf,r));
    }
    Collections.sort(allRects,new Comparator<Pair<MiniFacade,FRect>>(){
      @Override public int compare(      Pair<MiniFacade,FRect> a_,      Pair<MiniFacade,FRect> b_){
        FRect a=a_.second(), b=b_.second();
        if (a.gridCoords != null && b.gridCoords == null)         return -1;
        if (b.gridCoords != null && a.gridCoords == null)         return 1;
        if (a.gridCoords != null && b.gridCoords != null) {
          int out=-Integer.compare(countCoords(a.gridCoords),countCoords(b.gridCoords));
          if (out != 0)           return out;
        }
        return Double.compare(a.area(),b.area());
      }
      private int countCoords(      int[] gridCoords){
        int out=0;
        for (        int i : gridCoords)         if (i != -Integer.MAX_VALUE)         out++;
        return out;
      }
    }
);
    for (    Pair<MiniFacade,FRect> pair : allRects) {
      FRect w=pair.second();
      if (w.id == -1)       findId(w,f,out,pair.first(),ids++);
    }
  }
  out.add(0,combine(out));
  System.out.println(""String_Node_Str"");
  return out;
}",0.9981781159575608
175835,"protected void mapTo2d(Face f,Loop<LPoint3d> ll,MiniFacade mf,WallTag wallTag,Set<QuadF> features,MatMeshBuilder faceMaterial,Line megafacade){
  Matrix4d to2dXY=new Matrix4d();
  Vector3d up=f.edge.uphill, along=f.edge.direction(), out=f.edge.getPlaneNormal();
  along.normalize();
  to2dXY.setRow(2,up.x,up.y,up.z,0);
  to2dXY.setRow(1,out.x,out.y,out.z,0);
  to2dXY.setRow(0,-along.x,-along.y,-along.z,0);
  Point3d bottomS=f.definingSE.iterator().next().getStart(f), bottomE=f.definingSE.iterator().next().getEnd(f);
  if (bottomS == null || bottomE == null)   return;
  Point3d start=new Point3d(bottomS);
  Point3d end=new Point3d(bottomE);
  to2dXY.m33=1;
  to2dXY.transform(start);
  to2dXY.m03=-start.x;
  to2dXY.m13=-start.y;
  to2dXY.m23=-start.z;
  start=new Point3d(bottomS);
  to2dXY.transform(start);
  to2dXY.transform(end);
  Loop<LPoint2d> flat=GreebleHelper.to2dLoop(GreebleHelper.transform(ll,to2dXY),1);
  Matrix4d to3d=new Matrix4d(to2dXY);
  to3d.invert();
{
    double[] one=new double[4], two=new double[4];
    to3d.getRow(1,one);
    to3d.getRow(2,two);
    to3d.setRow(1,two);
    to3d.setRow(2,one);
  }
  Matrix4d to2d=new Matrix4d(to3d);
  to2d.invert();
  MiniFacade toRecess=null;
  if (mf != null) {
    toRecess=new MiniFacade(mf);
    toRecess.featureGen=new FeatureGenerator(toRecess);
  }
  LinearForm3D facePlane=new LinearForm3D(new Vector3d(out.x,out.z,out.y),new Point3d(bottomS.x,bottomS.z,bottomS.y));
  LoopL<Point2d> sides=null;
  DRectangle facadeRect=null;
  if (wallTag != null) {
    sides=GreebleHelper.findRectagle(flat,Pointz.to2XZ(start),Pointz.to2XZ(end));
    if (mf != null) {
      if (sides != null)       facadeRect=GreebleHelper.findRect(sides.remove(0));
    }
  }
  DRectangle uvs;
  if (mf != null && mf.app.textureUVs == TextureUVs.SQUARE) {
    uvs=new DRectangle(mf.postState.outerFacadeRect);
{
      Face f2=f;
      while (f2.parent != null)       f2=f2.parent;
      Point3d bottomS2=new Point3d(f2.definingSE.iterator().next().getStart(f2));
      to2dXY.transform(bottomS2);
      uvs.x+=bottomS2.x;
      uvs.y-=bottomS.z;
    }
  }
 else   uvs=GreebleGrid.ZERO_ONE_UVS;
  List<DRectangle> floors=new ArrayList();
  List<MatMeshBuilder> materials=new ArrayList();
  if (wallTag != null && facadeRect != null && mf != null && wallTag.isGroundFloor && mf.groundFloorHeight > 0 && wallTag.groundFloorColor != null && facadeRect.x < mf.groundFloorHeight && facadeRect.getMaxX() > mf.groundFloorHeight) {
    floors.addAll(facadeRect.splitY(mf.groundFloorHeight));
    MatMeshBuilder gfm=greebleGrid.mbs.get(BRICK,wallTag.groundFloorColor);
    for (    Loop<Point2d> loop : sides) {
      Loop<Point2d>[] cut=Loopz.cutConvex(loop,new LinearForm(0,1,mf.groundFloorHeight));
      faceMaterial.add(cut[1].singleton(),to3d);
      LoopL<Point2d> pts=cut[0].singleton();
      gfm.add(pts,GreebleHelper.wallUVs(pts,mf.postState.outerFacadeRect),to3d);
    }
    materials.add(gfm);
    materials.add(faceMaterial);
  }
 else {
    floors.add(facadeRect);
    materials.add(faceMaterial);
    if (sides != null)     faceMaterial.add(sides,GreebleHelper.wallUVs(sides,uvs),to3d);
  }
  for (int j=0; j < floors.size(); j++) {
    DRectangle floorRect=floors.get(j);
    MatMeshBuilder m=materials.get(j);
    Iterator<QuadF> quit=features.iterator();
    while (quit.hasNext()) {
      QuadF n=quit.next();
      if (n.project(to2d,to3d,flat,facePlane,new Vector3d(along.y,0,-along.x)) && wallTag != null && floorRect != null && toRecess != null) {
        FRect bounds=new FRect(n.original);
        n.setBounds(to2d,bounds);
        if (floorRect.contains(bounds)) {
          toRecess.featureGen.put(n.original.f,bounds);
          quit.remove();
        }
      }
    }
    if (wallTag == null || toRecess == null || floorRect == null) {
      LoopL<LPoint2d> loop=flat.singleton();
      LoopL<Point2d> roofUVs;
      RoofTexApp ra=(RoofTexApp)HasApp.get(roofApp);
switch (ra.appMode) {
default :
        roofUVs=null;
      break;
case Net:
    if (ra.textureUVs != TextureUVs.Rectangle)     roofUVs=GreebleHelper.roofPitchUVs(loop,Pointz.to2XZ(start),Pointz.to2XZ(end),TILE_UV_SCALE);
 else     roofUVs=GreebleHelper.wholeRoofUVs(ll.singleton(),ra.textureRect);
  break;
}
m.add(loop,roofUVs,to3d);
return;
}
if (mf.app.appMode == AppMode.Off) greebleGrid.buildGrid(floorRect,to3d,toRecess,m,wallTag);
 else {
greebleGrid.textureGrid(floorRect,uvs,to3d,toRecess);
}
}
}","protected void mapTo2d(Face f,Loop<LPoint3d> ll,MiniFacade mf,WallTag wallTag,Set<QuadF> features,MatMeshBuilder faceMaterial,Line megafacade){
  Matrix4d to2dXY=new Matrix4d();
  Vector3d up=f.edge.uphill, along=f.edge.direction(), out=f.edge.getPlaneNormal();
  along.normalize();
  to2dXY.setRow(2,up.x,up.y,up.z,0);
  to2dXY.setRow(1,out.x,out.y,out.z,0);
  to2dXY.setRow(0,-along.x,-along.y,-along.z,0);
  Point3d bottomS=f.definingSE.iterator().next().getStart(f), bottomE=f.definingSE.iterator().next().getEnd(f);
  if (bottomS == null || bottomE == null)   return;
  Point3d start=new Point3d(bottomS);
  Point3d end=new Point3d(bottomE);
  to2dXY.m33=1;
  to2dXY.transform(start);
  to2dXY.m03=-start.x;
  to2dXY.m13=-start.y;
  to2dXY.m23=-start.z;
  start=new Point3d(bottomS);
  to2dXY.transform(start);
  to2dXY.transform(end);
  Loop<LPoint2d> flat=GreebleHelper.to2dLoop(GreebleHelper.transform(ll,to2dXY),1);
  Matrix4d to3d=new Matrix4d(to2dXY);
  to3d.invert();
{
    double[] one=new double[4], two=new double[4];
    to3d.getRow(1,one);
    to3d.getRow(2,two);
    to3d.setRow(1,two);
    to3d.setRow(2,one);
  }
  Matrix4d to2d=new Matrix4d(to3d);
  to2d.invert();
  MiniFacade toRecess=null;
  if (mf != null) {
    toRecess=new MiniFacade(mf);
    toRecess.featureGen=new FeatureGenerator(toRecess);
  }
  LinearForm3D facePlane=new LinearForm3D(new Vector3d(out.x,out.z,out.y),new Point3d(bottomS.x,bottomS.z,bottomS.y));
  LoopL<Point2d> sides=null;
  DRectangle facadeRect=null;
  if (wallTag != null) {
    sides=GreebleHelper.findRectagle(flat,Pointz.to2XZ(start),Pointz.to2XZ(end));
    if (mf != null) {
      if (sides != null)       facadeRect=GreebleHelper.findRect(sides.remove(0));
    }
  }
  DRectangle uvs;
  if (mf != null && mf.app.textureUVs == TextureUVs.SQUARE) {
    uvs=new DRectangle(mf.postState.outerFacadeRect);
{
      Face f2=f;
      while (f2.parent != null)       f2=f2.parent;
      Point3d bottomS2=new Point3d(f2.definingSE.iterator().next().getStart(f2));
      to2dXY.transform(bottomS2);
      uvs.x+=bottomS2.x;
      uvs.y-=bottomS.z;
    }
  }
 else   uvs=GreebleGrid.ZERO_ONE_UVS;
  List<DRectangle> floors=new ArrayList();
  List<MatMeshBuilder> materials=new ArrayList();
  if (wallTag != null && facadeRect != null && mf != null && wallTag.isGroundFloor && mf.groundFloorHeight > 0 && wallTag.groundFloorColor != null && facadeRect.x < mf.groundFloorHeight && facadeRect.getMaxX() > mf.groundFloorHeight) {
    floors.addAll(facadeRect.splitY(mf.groundFloorHeight));
    MatMeshBuilder gfm=greebleGrid.mbs.get(BRICK,wallTag.groundFloorColor);
    for (    Loop<Point2d> loop : sides) {
      Loop<Point2d>[] cut=Loopz.cutConvex(loop,new LinearForm(0,1,mf.groundFloorHeight));
      faceMaterial.add(cut[1].singleton(),to3d);
      LoopL<Point2d> pts=cut[0].singleton();
      gfm.add(pts,GreebleHelper.wallUVs(pts,mf.postState.outerFacadeRect),to3d);
    }
    materials.add(gfm);
    materials.add(faceMaterial);
  }
 else {
    floors.add(facadeRect);
    materials.add(faceMaterial);
    if (sides != null)     faceMaterial.add(sides,GreebleHelper.wallUVs(sides,uvs),to3d);
  }
  for (int j=0; j < floors.size(); j++) {
    DRectangle floorRect=floors.get(j);
    MatMeshBuilder m=materials.get(j);
    Iterator<QuadF> quit=features.iterator();
    while (quit.hasNext()) {
      QuadF n=quit.next();
      if (n.project(to2d,to3d,flat,facePlane,new Vector3d(along.y,0,-along.x)) && wallTag != null && floorRect != null && toRecess != null) {
        FRect bounds=new FRect(n.original);
        n.setBounds(to2d,bounds);
        if (floorRect.contains(bounds)) {
          toRecess.featureGen.put(n.original.f,bounds);
          quit.remove();
        }
      }
    }
    if (wallTag == null || toRecess == null || floorRect == null) {
      LoopL<LPoint2d> loop=flat.singleton();
      LoopL<Point2d> roofUVs;
      RoofTexApp ra=(RoofTexApp)HasApp.get(roofApp);
switch (ra.appMode) {
default :
        roofUVs=null;
      break;
case Net:
    if (ra.textureUVs != TextureUVs.Rectangle)     roofUVs=GreebleHelper.roofPitchUVs(loop,Pointz.to2XZ(start),Pointz.to2XZ(end),TILE_UV_SCALE);
 else     roofUVs=GreebleHelper.wholeRoofUVs(ll.singleton(),ra.textureRect);
  break;
}
m.add(loop,roofUVs,to3d);
return;
}
if (mf.app.appMode == AppMode.Off || mf.app.texture == null) greebleGrid.buildGrid(floorRect,to3d,toRecess,m,wallTag);
 else {
greebleGrid.textureGrid(floorRect,uvs,to3d,toRecess);
}
}
}",0.9970806198068718
175836,"public static void computeWithChildren(List<App> todo,int first,Runnable globalUpdate){
  if (first >= todo.size()) {
    System.out.println(""String_Node_Str"" + todo.get(0).getClass().getSimpleName());
    globalUpdate.run();
    MultiMap<String,App> downs=new MultiMap<>();
    for (    App a : todo)     downs.putAll(a.getDown());
    for (    String d : downs.keySet())     new Thread(() -> App.computeWithChildren(downs.get(d),0,globalUpdate)).start();
  }
 else {
    List<App> batch=new ArrayList<>();
    for (int i=first; i < Math.min(todo.size(),first + Batch_Size); i++) {
      App app=todo.get(i);
      if (app.appMode == AppMode.Net) {
        if (app.styleSource != null)         app.styleZ=app.styleSource.draw(randy,app);
        batch.add(todo.get(i));
      }
    }
    if (!batch.isEmpty()) {
      System.out.println(""String_Node_Str"" + first + ""String_Node_Str""+ todo.get(0).getClass().getSimpleName());
      batch.get(0).computeBatch(() -> App.computeWithChildren(todo,first + Batch_Size,globalUpdate),batch);
    }
 else     App.computeWithChildren(todo,first + Batch_Size,globalUpdate);
  }
}","public static void computeWithChildren(int first,int stage,MultiMap<Integer,App> todo,Runnable globalUpdate){
  if (todo.get(stage).isEmpty())   return;
  if (first >= todo.size()) {
    System.out.println(""String_Node_Str"" + todo.get(0).getClass().getSimpleName());
    globalUpdate.run();
    for (    App a : new ArrayList<>(todo.get(stage)))     todo.put(NetInfo.evaluationOrder.indexOf(a.getClass()),a);
    App.computeWithChildren(0,stage + 1,todo,globalUpdate);
  }
 else {
    List<App> all=todo.get(stage);
    List<App> batch=new ArrayList<>();
    for (int i=first; i < Math.min(all.size(),first + Batch_Size); i++) {
      App app=all.get(i);
      if (app.appMode == AppMode.Net) {
        if (app.styleSource != null)         app.styleZ=app.styleSource.draw(randy,app);
        batch.add(app);
      }
    }
    if (!batch.isEmpty()) {
      System.out.println(""String_Node_Str"" + first + ""String_Node_Str""+ all.size()+ ""String_Node_Str""+ todo.get(0).getClass().getSimpleName());
      batch.get(0).computeBatch(() -> App.computeWithChildren(first + Batch_Size,stage,todo,globalUpdate),batch);
    }
 else     App.computeWithChildren(0,stage + 1,todo,globalUpdate);
  }
}",0.172818063395571
175837,"public void computeAll(Runnable globaUpdate){
  computeAll_(globaUpdate,0);
}","public void computeAll(Runnable globalUpdate){
  MultiMap<Integer,App> todo=new MultiMap<>();
  int i=NetInfo.evaluationOrder.indexOf(get(0).getClass());
  todo.putAll(i,this);
  App.computeWithChildren(0,i,todo,globalUpdate);
}",0.4262295081967213
175838,"public void setUI(JPanel out,boolean byExample,Runnable update){
  out.removeAll();
  if (byExample) {
    ImageFileDrop drop=new ImageFileDrop(imageFile.getMeanImage()){
      public BufferedImage process(      File f){
        imageFile.setMeanImage(f);
        return new Pix2Pix(netInfo).encode(f,vector,update);
      }
      @Override public void rightClick(){
        super.rightClick();
        method.doClick();
      }
    }
;
    out.add(drop);
  }
 else {
    imageFile.setMeanImage(null);
    NSliders sliders=new NSliders(vector,update,new Runnable(){
      @Override public void run(){
        method.doClick();
      }
      @Override public String toString(){
        return ""String_Node_Str"";
      }
    }
);
    out.add(sliders);
  }
  out.repaint();
  out.revalidate();
}","public void setUI(JPanel out,boolean byExample,Runnable update){
  out.removeAll();
  if (byExample) {
    ImageFileDrop drop=new ImageFileDrop(imageFile.getMeanImage()){
      public BufferedImage process(      File f){
        imageFile.setMeanImage(f);
        return new Pix2Pix(netInfo).encode(f,vector,update);
      }
      @Override public void rightClick(){
        super.rightClick();
        method.doClick();
      }
    }
;
    out.add(drop);
  }
 else {
    NSliders sliders=new NSliders(vector,update,new Runnable(){
      @Override public void run(){
        method.doClick();
      }
      @Override public String toString(){
        return ""String_Node_Str"";
      }
    }
);
    out.add(sliders);
  }
  out.repaint();
  out.revalidate();
}",0.9780645161290322
175839,"public UIVector(double[] vector,MeanImageProvider imageFile,NetInfo netInfo,boolean showManual,Runnable update){
  this.netInfo=netInfo;
  this.vector=vector;
  this.imageFile=imageFile;
  setLayout(new BorderLayout());
  method=new JToggleButton(""String_Node_Str"");
  JPanel options=new JPanel(new ListDownLayout());
  method.addActionListener(e -> setUI(options,!method.isSelected(),update));
  if (showManual)   add(method,BorderLayout.NORTH);
  add(options,BorderLayout.CENTER);
  setUI(options,!method.isSelected(),update);
}","public UIVector(double[] vector,MeanImageProvider imageFile,NetInfo netInfo,boolean showManual,Runnable update){
  this.netInfo=netInfo;
  this.vector=vector;
  this.imageFile=imageFile;
  setLayout(new BorderLayout());
  method=new JToggleButton(""String_Node_Str"");
  method.setSelected(imageFile.getMeanImage() == null);
  JPanel options=new JPanel(new ListDownLayout());
  method.addActionListener(e -> setUI(options,!method.isSelected(),update));
  if (showManual)   add(method,BorderLayout.NORTH);
  add(options,BorderLayout.CENTER);
  setUI(options,!method.isSelected(),update);
}",0.949820788530466
175840,"@Override public void computeBatch(Runnable whenDone,List<App> batch){
  Pix2Pix p2=new Pix2Pix(batch.get(0));
  BufferedImage bi=new BufferedImage(resolution * 2,resolution,BufferedImage.TYPE_3BYTE_BGR);
  Graphics2D g=(Graphics2D)bi.getGraphics();
  List<MiniFacade> mfb=batch.stream().map(x -> (MiniFacade)x.hasA).collect(Collectors.toList());
  for (  MiniFacade mf : mfb) {
    if (mf.featureGen instanceof CGAMini)     mf.featureGen=new FeatureGenerator(mf,mf.featureGen);
    DRectangle bounds=new DRectangle(resolution,0,resolution,resolution);
    DRectangle mini=Pix2Pix.findBounds(mf);
    g.setColor(Color.black);
    g.fillRect(resolution,0,resolution,resolution);
    mini=mf.postState == null ? mf.getAsRect() : mf.postState.outerFacadeRect;
    DRectangle mask=new DRectangle(mini);
{
      mask=mask.scale(resolution / Math.max(mini.height,mini.width));
      mask.x=(resolution - mask.width) * 0.5 + resolution;
      mask.y=0;
    }
    g.setColor(CMPLabel.Facade.rgb);
    if (mf.postState == null) {
      Pix2Pix.cmpRects(mf,g,mask,mini,CMPLabel.Facade.rgb,Collections.singletonList(new FRect(mini,mf)));
      Pix2Pix.cmpRects(mf,g,mask,mini,CMPLabel.Window.rgb,mf.featureGen.getRects(Feature.WINDOW));
    }
 else {
      for (      Loop<? extends Point2d> l : mf.postState.skelFaces)       g.fill(Pix2Pix.toPoly(mf,mask,mini,l));
      g.setColor(CMPLabel.Background.rgb);
      for (      LoopL<Point2d> ll : mf.postState.occluders)       for (      Loop<Point2d> l : ll)       g.fill(Pix2Pix.toPoly(mf,mask,mini,l));
      Pix2Pix.cmpRects(mf,g,mask,mini,CMPLabel.Window.rgb,new ArrayList<>(mf.postState.generatedWindows));
    }
    mask.x-=resolution;
    Meta meta=new Meta(mf,mask);
    p2.addInput(bi,meta,mf.app.styleZ);
  }
  p2.submit(new Job(new JobResult(){
    @Override public void finished(    Map<Object,File> results){
      String dest;
      try {
        for (        Map.Entry<Object,File> e : results.entrySet()) {
          Meta meta=(Meta)e.getKey();
          dest=Pix2Pix.importTexture(e.getValue(),-1,specLookup,meta.mask);
          if (dest != null) {
            meta.mf.app.coarse=meta.mf.app.texture=dest;
          }
        }
      }
 catch (      Throwable e) {
        e.printStackTrace();
      }
      whenDone.run();
    }
  }
));
}","@Override public void computeBatch(Runnable whenDone,List<App> batch){
  Pix2Pix p2=new Pix2Pix(batch.get(0));
  BufferedImage bi=new BufferedImage(resolution * 2,resolution,BufferedImage.TYPE_3BYTE_BGR);
  Graphics2D g=(Graphics2D)bi.getGraphics();
  List<MiniFacade> mfb=batch.stream().map(x -> (MiniFacade)x.hasA).collect(Collectors.toList());
  for (  MiniFacade mf : mfb) {
    if (mf.featureGen instanceof CGAMini)     mf.featureGen=new FeatureGenerator(mf,mf.featureGen);
    DRectangle bounds=new DRectangle(resolution,0,resolution,resolution);
    DRectangle mini=Pix2Pix.findBounds(mf);
    g.setColor(Color.black);
    g.fillRect(resolution,0,resolution,resolution);
    mini=mf.postState == null ? mf.getAsRect() : mf.postState.outerFacadeRect;
    if (mini == null)     continue;
    DRectangle mask=new DRectangle(mini);
{
      mask=mask.scale(resolution / Math.max(mini.height,mini.width));
      mask.x=(resolution - mask.width) * 0.5 + resolution;
      mask.y=0;
    }
    g.setColor(CMPLabel.Facade.rgb);
    if (mf.postState == null) {
      Pix2Pix.cmpRects(mf,g,mask,mini,CMPLabel.Facade.rgb,Collections.singletonList(new FRect(mini,mf)));
      Pix2Pix.cmpRects(mf,g,mask,mini,CMPLabel.Window.rgb,mf.featureGen.getRects(Feature.WINDOW));
    }
 else {
      for (      Loop<? extends Point2d> l : mf.postState.skelFaces)       g.fill(Pix2Pix.toPoly(mf,mask,mini,l));
      g.setColor(CMPLabel.Background.rgb);
      for (      LoopL<Point2d> ll : mf.postState.occluders)       for (      Loop<Point2d> l : ll)       g.fill(Pix2Pix.toPoly(mf,mask,mini,l));
      Pix2Pix.cmpRects(mf,g,mask,mini,CMPLabel.Window.rgb,new ArrayList<>(mf.postState.generatedWindows));
    }
    mask.x-=resolution;
    Meta meta=new Meta(mf,mask);
    p2.addInput(bi,meta,mf.app.styleZ);
  }
  p2.submit(new Job(new JobResult(){
    @Override public void finished(    Map<Object,File> results){
      String dest;
      try {
        for (        Map.Entry<Object,File> e : results.entrySet()) {
          Meta meta=(Meta)e.getKey();
          dest=Pix2Pix.importTexture(e.getValue(),-1,specLookup,meta.mask);
          if (dest != null) {
            meta.mf.app.coarse=meta.mf.app.texture=dest;
          }
        }
      }
 catch (      Throwable e) {
        e.printStackTrace();
      }
      whenDone.run();
    }
  }
));
}",0.9922212618841832
175841,"public JComponent buildUI(){
  JPanel out=new JPanel(new BorderLayout());
  JMenuBar menuBar=new JMenuBar();
  frame.setJMenuBar(menuBar);
  JMenu menu=new JMenu(""String_Node_Str"");
  menuBar.add(menu);
  JMenuItem save=new JMenuItem(""String_Node_Str"",KeyEvent.VK_S);
  save.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,ActionEvent.CTRL_MASK));
  menu.add(save);
  save.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (TweedSettings.folder == null) {
        new SimpleFileChooser(frame){
          @Override public void heresTheFile(          File f) throws Throwable {
            TweedSettings.folder=f;
            TweedSettings.save(false);
          }
        }
;
      }
 else       TweedSettings.save(false);
    }
  }
);
  JMenuItem load=new JMenuItem(""String_Node_Str"",KeyEvent.VK_O);
  load.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O,ActionEvent.CTRL_MASK));
  menu.add(load);
  load.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      new SimpleFileChooser(frame,false,""String_Node_Str"",Tweed.DATA == null ? null : new File(Tweed.DATA),TWEED_XML){
        @Override public void heresTheFile(        File f) throws Throwable {
          TweedSettings.load(f);
        }
      }
;
    }
  }
);
  JMenuItem recent=new JLazyMenu(""String_Node_Str""){
    @Override public List<Runnable> getEntries(){
      List<Runnable> out=new ArrayList();
      for (      File r : TweedSettings.recentFiles.f) {
        out.add(new Runnable(){
          @Override public void run(){
            if (!r.exists())             JOptionPane.showMessageDialog(frame,""String_Node_Str"" + r.getName() + ""String_Node_Str"");
 else             TweedSettings.load(r);
          }
          @Override public String toString(){
            return r.getName();
          }
        }
);
      }
      return out;
    }
  }
;
  menu.add(recent);
  JMenuItem neu=new JMenuItem(""String_Node_Str"",KeyEvent.VK_N);
  neu.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_N,ActionEvent.CTRL_MASK));
  menu.add(neu);
  neu.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      new SimpleFileChooser(frame,false,""String_Node_Str""){
        @Override public void heresTheFile(        File f) throws Throwable {
          TweedSettings.folder=f.getParentFile();
          if (new File(TweedSettings.folder,TWEED_XML).exists()) {
            JOptionPane.showMessageDialog(frame,TWEED_XML + ""String_Node_Str"");
            return;
          }
          TweedSettings.load(TweedSettings.folder);
        }
      }
;
    }
  }
);
  JMenuItem resetCam=new JMenuItem(""String_Node_Str"",KeyEvent.VK_R);
  resetCam.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_R,ActionEvent.CTRL_MASK));
  menu.add(resetCam);
  resetCam.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      tweed.resetCamera();
    }
  }
);
  JMenuItem settings=new JMenuItem(""String_Node_Str"",KeyEvent.VK_R);
  settings.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E,ActionEvent.CTRL_MASK));
  menu.add(settings);
  settings.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      new Auto(TweedSettings.settings).frame();
    }
  }
);
  JMenuItem resetBG=new JMenuItem(""String_Node_Str"",KeyEvent.VK_MINUS);
  resetBG.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_MINUS,ActionEvent.CTRL_MASK));
  menu.add(resetBG);
  resetBG.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      tweed.enqueue(new Runnable(){
        @Override public void run(){
          TweedFrame.this.tweed.clearBackground();
        }
      }
);
    }
  }
);
  JMenuItem obj=new JMenuItem(""String_Node_Str"",KeyEvent.VK_E);
  obj.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E,ActionEvent.CTRL_MASK));
  menu.add(obj);
  obj.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      ObjDump dump=new ObjDump();
      for (      Gen g : genList)       if (g.visible && g instanceof IDumpObjs)       ((IDumpObjs)g).dumpObj(dump);
      new SimpleFileChooser(frame,true,""String_Node_Str"",new File(Tweed.SCRATCH,""String_Node_Str""),""String_Node_Str""){
        @Override public void heresTheFile(        File f) throws Throwable {
          dump.dump(f,new File(Tweed.DATA));
        }
      }
;
    }
  }
);
  layerList=new JPanel(new ListDownLayout());
  JPanel layers=new JPanel();
  layers.setLayout(new BorderLayout());
  layers.add(new JLabel(""String_Node_Str""),BorderLayout.NORTH);
  JScrollPane listScroll=new JScrollPane(layerList);
  listScroll.getVerticalScrollBar().setUnitIncrement(50);
  listScroll.setPreferredSize(new Dimension(200,300));
  layers.add(listScroll,BorderLayout.CENTER);
  JPanel addRemoveLayer=new JPanel();
{
    addRemoveLayer.setLayout(new GridLayout(1,2));
    layers.add(addRemoveLayer,BorderLayout.SOUTH);
    JButton addLayer=new JButton(""String_Node_Str"");
    addLayer.addMouseListener(new MouseAdapter(){
      @Override public void mousePressed(      MouseEvent e){
        addLayer(e);
      }
    }
);
    JButton removeLayer=new JButton(""String_Node_Str"");
    removeLayer.addActionListener(e -> removeGen(selectedGen));
    addRemoveLayer.add(addLayer);
    addRemoveLayer.add(removeLayer);
  }
  JPanel options=new JPanel(new BorderLayout());
{
    options.add(new JLabel(""String_Node_Str""),BorderLayout.NORTH);
    options.add(genUI,BorderLayout.CENTER);
  }
  JSplitPane pane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,layers,options);
  out.add(pane,BorderLayout.CENTER);
  JPanel toolPanel=new JPanel(new ListRightLayout());
  tweed.addUI(toolPanel);
  coordLabel=new JLabel(""String_Node_Str"");
  coordLabel.setHorizontalAlignment(SwingConstants.CENTER);
  worldLabel=new JLabel(""String_Node_Str"");
  worldLabel.setHorizontalAlignment(SwingConstants.CENTER);
  crsLabel=new JLabel(""String_Node_Str"");
  crsLabel.setHorizontalAlignment(SwingConstants.CENTER);
  out.add(toolPanel,BorderLayout.NORTH);
  JPanel coords=new JPanel(new ListDownLayout());
  coords.add(worldLabel);
  coords.add(coordLabel);
  coords.add(crsLabel);
  out.add(coords,BorderLayout.SOUTH);
  out.setPreferredSize(new Dimension(300,frame.getHeight()));
  return out;
}","public JComponent buildUI(){
  JPanel out=new JPanel(new BorderLayout());
  JMenuBar menuBar=new JMenuBar();
  frame.setJMenuBar(menuBar);
  JMenu menu=new JMenu(""String_Node_Str"");
  menuBar.add(menu);
  JMenuItem save=new JMenuItem(""String_Node_Str"",KeyEvent.VK_S);
  save.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,ActionEvent.CTRL_MASK));
  menu.add(save);
  save.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (TweedSettings.folder == null) {
        new SimpleFileChooser(frame){
          @Override public void heresTheFile(          File f) throws Throwable {
            TweedSettings.folder=f;
            TweedSettings.save(false);
          }
        }
;
      }
 else       TweedSettings.save(false);
    }
  }
);
  JMenuItem load=new JMenuItem(""String_Node_Str"",KeyEvent.VK_O);
  load.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O,ActionEvent.CTRL_MASK));
  menu.add(load);
  load.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      new SimpleFileChooser(frame,false,""String_Node_Str"",Tweed.DATA == null ? null : new File(Tweed.DATA),TWEED_XML){
        @Override public void heresTheFile(        File f) throws Throwable {
          TweedSettings.load(f);
        }
      }
;
    }
  }
);
  JMenuItem recent=new JLazyMenu(""String_Node_Str""){
    @Override public List<Runnable> getEntries(){
      List<Runnable> out=new ArrayList();
      for (      File r : TweedSettings.recentFiles.f) {
        out.add(new Runnable(){
          @Override public void run(){
            if (!r.exists())             JOptionPane.showMessageDialog(frame,""String_Node_Str"" + r.getName() + ""String_Node_Str"");
 else             TweedSettings.load(r);
          }
          @Override public String toString(){
            return r.getName();
          }
        }
);
      }
      return out;
    }
  }
;
  menu.add(recent);
  JMenuItem neu=new JMenuItem(""String_Node_Str"",KeyEvent.VK_N);
  neu.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_N,ActionEvent.CTRL_MASK));
  menu.add(neu);
  neu.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      new SimpleFileChooser(frame,false,""String_Node_Str""){
        @Override public void heresTheFile(        File f) throws Throwable {
          TweedSettings.folder=f.getParentFile();
          if (new File(TweedSettings.folder,TWEED_XML).exists()) {
            JOptionPane.showMessageDialog(frame,TWEED_XML + ""String_Node_Str"");
            return;
          }
          TweedSettings.load(TweedSettings.folder);
        }
      }
;
    }
  }
);
  JMenuItem resetCam=new JMenuItem(""String_Node_Str"",KeyEvent.VK_R);
  resetCam.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_R,ActionEvent.CTRL_MASK));
  menu.add(resetCam);
  resetCam.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      tweed.resetCamera();
    }
  }
);
  JMenuItem settings=new JMenuItem(""String_Node_Str"",KeyEvent.VK_R);
  settings.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E,ActionEvent.CTRL_MASK));
  menu.add(settings);
  settings.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      new Auto(TweedSettings.settings).frame();
    }
  }
);
  JMenuItem resetBG=new JMenuItem(""String_Node_Str"",KeyEvent.VK_MINUS);
  resetBG.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_MINUS,ActionEvent.CTRL_MASK));
  menu.add(resetBG);
  resetBG.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      tweed.enqueue(new Runnable(){
        @Override public void run(){
          TweedFrame.this.tweed.clearBackground();
        }
      }
);
    }
  }
);
  JMenuItem obj=new JMenuItem(""String_Node_Str"",KeyEvent.VK_E);
  obj.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E,ActionEvent.CTRL_MASK));
  menu.add(obj);
  obj.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      new SimpleFileChooser(frame,true,""String_Node_Str"",new File(Tweed.SCRATCH,""String_Node_Str""),""String_Node_Str""){
        @Override public void heresTheFile(        File f) throws Throwable {
          ObjDump dump=new ObjDump();
          for (          Gen g : genList)           if (g.visible && g instanceof IDumpObjs)           ((IDumpObjs)g).dumpObj(dump);
          dump.dump(f,new File(Tweed.DATA));
        }
      }
;
    }
  }
);
  layerList=new JPanel(new ListDownLayout());
  JPanel layers=new JPanel();
  layers.setLayout(new BorderLayout());
  layers.add(new JLabel(""String_Node_Str""),BorderLayout.NORTH);
  JScrollPane listScroll=new JScrollPane(layerList);
  listScroll.getVerticalScrollBar().setUnitIncrement(50);
  listScroll.setPreferredSize(new Dimension(200,300));
  layers.add(listScroll,BorderLayout.CENTER);
  JPanel addRemoveLayer=new JPanel();
{
    addRemoveLayer.setLayout(new GridLayout(1,2));
    layers.add(addRemoveLayer,BorderLayout.SOUTH);
    JButton addLayer=new JButton(""String_Node_Str"");
    addLayer.addMouseListener(new MouseAdapter(){
      @Override public void mousePressed(      MouseEvent e){
        addLayer(e);
      }
    }
);
    JButton removeLayer=new JButton(""String_Node_Str"");
    removeLayer.addActionListener(e -> removeGen(selectedGen));
    addRemoveLayer.add(addLayer);
    addRemoveLayer.add(removeLayer);
  }
  JPanel options=new JPanel(new BorderLayout());
{
    options.add(new JLabel(""String_Node_Str""),BorderLayout.NORTH);
    options.add(genUI,BorderLayout.CENTER);
  }
  JSplitPane pane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,layers,options);
  out.add(pane,BorderLayout.CENTER);
  JPanel toolPanel=new JPanel(new ListRightLayout());
  tweed.addUI(toolPanel);
  coordLabel=new JLabel(""String_Node_Str"");
  coordLabel.setHorizontalAlignment(SwingConstants.CENTER);
  worldLabel=new JLabel(""String_Node_Str"");
  worldLabel.setHorizontalAlignment(SwingConstants.CENTER);
  crsLabel=new JLabel(""String_Node_Str"");
  crsLabel.setHorizontalAlignment(SwingConstants.CENTER);
  out.add(toolPanel,BorderLayout.NORTH);
  JPanel coords=new JPanel(new ListDownLayout());
  coords.add(worldLabel);
  coords.add(coordLabel);
  coords.add(crsLabel);
  out.add(coords,BorderLayout.SOUTH);
  out.setPreferredSize(new Dimension(300,frame.getHeight()));
  return out;
}",0.975284003684372
175842,"protected void textureGrid(DRectangle allGeom,DRectangle allUV,Matrix4d to3d,MiniFacade mf){
  if (mf != null && mf.texture != null) {
    Grid g=new Grid(.10,allGeom.x,allGeom.getMaxX(),allGeom.y,allGeom.getMaxY());
    MatMeshBuilder mmb=mbs.get(""String_Node_Str"" + mf.texture,mf.texture);
    for (    FRect w : mf.featureGen.getRects(Feature.WINDOW,Feature.SHOP)) {
      if (allGeom.contains(w))       g.insert(w,new Griddable(){
        @Override public void instance(        DRectangle rect){
          if (w.texture == null)           createInnie(rect,allUV.normalize(rect),to3d,mmb,0.2f);
 else {
            DRectangle r=new DRectangle(ZERO_ONE_UVS);
            double c=(w.height - w.width) / w.height;
            r.x+=c / 2;
            r.width=w.width / w.height;
            createInnie(rect,r,to3d,mbs.get(""String_Node_Str"" + w.texture,w.texture),0.2f);
          }
        }
      }
);
    }
    for (    FRect w : mf.featureGen.get(Feature.DOOR)) {
      if (allGeom.contains(w))       g.insert(w,new Griddable(){
        @Override public void instance(        DRectangle rect){
          if (w.texture == null)           createInnie(rect,allUV.normalize(rect),to3d,mmb,0.5f);
 else {
            DRectangle r=new DRectangle(ZERO_ONE_UVS);
            double c=(w.height - w.width) / w.height;
            r.x+=c / 2;
            r.width=w.width / w.height;
            createInnie(rect,r,to3d,mbs.get(""String_Node_Str"" + w.texture,w.texture),0.5f);
          }
        }
      }
);
    }
    for (    FRect w : mf.featureGen.getRects(Feature.MOULDING,Feature.CORNICE,Feature.SILL)) {
      if (allGeom.contains(w))       g.insert(w,new Griddable(){
        @Override public void instance(        DRectangle rect){
          createInnie(rect,allUV.normalize(rect),to3d,mmb,-0.2f);
        }
      }
);
    }
    for (    DRectangle b : mf.featureGen.get(Feature.BALCONY)) {
      if (allGeom.contains(b))       g.insert(b,new Griddable(){
        @Override public void instance(        DRectangle rect){
          createBalcony(rect,to3d,mbs.BALCONY,0.3);
        }
        @Override public boolean noneBehind(){
          return true;
        }
      }
);
    }
    g.instance(new Griddable(){
      @Override public void instance(      DRectangle rect){
        mmb.add(rect,allUV.normalize(rect),to3d);
      }
    }
);
  }
}","protected void textureGrid(DRectangle allGeom,DRectangle allUV,Matrix4d to3d,MiniFacade mf){
  if (mf != null && mf.texture != null) {
    Grid g=new Grid(.10,allGeom.x,allGeom.getMaxX(),allGeom.y,allGeom.getMaxY());
    MatMeshBuilder mmb=mbs.get(""String_Node_Str"" + mf.texture,mf.texture);
    for (    FRect w : mf.featureGen.getRects(Feature.WINDOW,Feature.SHOP)) {
      if (allGeom.contains(w))       g.insert(w,new Griddable(){
        @Override public void instance(        DRectangle rect){
          if (w.texture == null)           createInnie(rect,allUV.normalize(rect),to3d,mmb,0.2f);
 else           createInnie(rect,normalizeForInset(w),to3d,mbs.get(""String_Node_Str"" + w.texture,w.texture),0.2f);
        }
      }
);
    }
    for (    FRect w : mf.featureGen.get(Feature.DOOR)) {
      if (allGeom.contains(w))       g.insert(w,new Griddable(){
        @Override public void instance(        DRectangle rect){
          if (w.texture == null)           createInnie(rect,allUV.normalize(rect),to3d,mmb,0.5f);
 else           createInnie(rect,normalizeForInset(w),to3d,mbs.get(""String_Node_Str"" + w.texture,w.texture),0.5f);
        }
      }
);
    }
    for (    FRect w : mf.featureGen.getRects(Feature.MOULDING,Feature.CORNICE,Feature.SILL)) {
      if (allGeom.contains(w))       g.insert(w,new Griddable(){
        @Override public void instance(        DRectangle rect){
          createInnie(rect,allUV.normalize(rect),to3d,mmb,-0.2f);
        }
      }
);
    }
    for (    DRectangle b : mf.featureGen.get(Feature.BALCONY)) {
      if (allGeom.contains(b))       g.insert(b,new Griddable(){
        @Override public void instance(        DRectangle rect){
          createBalcony(rect,to3d,mbs.BALCONY,0.3);
        }
        @Override public boolean noneBehind(){
          return true;
        }
      }
);
    }
    g.instance(new Griddable(){
      @Override public void instance(      DRectangle rect){
        mmb.add(rect,allUV.normalize(rect),to3d);
      }
    }
);
  }
}",0.9035369774919614
175843,"public int tile(String s,File result){
  File out=new File(result,s + ""String_Node_Str"");
  if (out.exists())   return 1;
  Matcher m=p.matcher(s);
  if (m.matches()) {
    String panoid=m.group(1);
    BufferedImage mosaic=new BufferedImage(26 * 512,13 * 512,BufferedImage.TYPE_3BYTE_BGR);
    Graphics g=mosaic.getGraphics();
    for (int x=0; x <= 25; x++)     for (int y=0; y <= 12; y++) {
      URL url;
      try {
        url=new URL(""String_Node_Str"" + panoid + ""String_Node_Str""+ x+ ""String_Node_Str""+ y);
        g.drawImage(ImageIO.read(url),x * 512,y * 512,null);
      }
 catch (      Throwable th) {
        th.printStackTrace();
      }
    }
    g.dispose();
    try {
      ImageWriter writer=ImageIO.getImageWritersByFormatName(""String_Node_Str"").next();
      ImageWriteParam param=writer.getDefaultWriteParam();
      param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
      param.setCompressionQuality(1f);
      ImageOutputStream ios=ImageIO.createImageOutputStream(out);
      writer.setOutput(ios);
      writer.write(mosaic);
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  return 1;
}","public int tile(String s,File result){
  File out=new File(result,s + ""String_Node_Str"");
  if (out.exists())   return 1;
  Matcher m=p.matcher(s);
  if (m.matches()) {
    String panoid=m.group(1);
    BufferedImage mosaic=new BufferedImage(26 * 512,13 * 512,BufferedImage.TYPE_3BYTE_BGR);
    Graphics g=mosaic.getGraphics();
    boolean failed=false;
    for (int x=0; x <= 25; x++)     for (int y=0; y <= 12; y++) {
      URL url;
      try {
        url=new URL(""String_Node_Str"" + panoid + ""String_Node_Str""+ x+ ""String_Node_Str""+ y);
        g.drawImage(ImageIO.read(url),x * 512,y * 512,null);
      }
 catch (      Throwable th) {
        th.printStackTrace();
        ongoing.abort();
        failed=true;
      }
    }
    g.dispose();
    if (!failed)     try {
      ImageWriter writer=ImageIO.getImageWritersByFormatName(""String_Node_Str"").next();
      ImageWriteParam param=writer.getDefaultWriteParam();
      param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
      param.setCompressionQuality(1f);
      ImageOutputStream ios=ImageIO.createImageOutputStream(out);
      writer.setOutput(ios);
      writer.write(mosaic);
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  return 1;
}",0.9624947324062368
175844,"public void processLines(List<String> lines,File result){
  System.out.println(lines.size() + ""String_Node_Str"");
  new Parallel<String,Integer>(lines,s -> tile(s,result),s -> System.out.println(""String_Node_Str"" + s.stream().mapToInt(x -> x).sum()),true);
}","public void processLines(List<String> lines,File result){
  System.out.println(lines.size() + ""String_Node_Str"");
  ongoing=new Parallel.ListWF<String>(lines);
  new Parallel<String,Integer>(ongoing,s -> tile(s,result),s -> System.out.println(""String_Node_Str"" + s.stream().mapToInt(x -> x).sum()),true,16);
}",0.892416225749559
175845,"private void renderPanos(){
  if (getInputFolder(FeatureCache.FEATURE_FOLDER).exists()) {
    int result=JOptionPane.showConfirmDialog(tweed.frame(),""String_Node_Str"",""String_Node_Str"",JOptionPane.OK_CANCEL_OPTION);
    if (result == JOptionPane.CANCEL_OPTION)     return;
  }
  FacadeFinder.facadeMode=FacadeMode.PER_CAMERA;
  try {
    new FacadeTool(tweed).renderFacade(polies,null,new BufferedWriter(new FileWriter(Tweed.SCRATCH + ""String_Node_Str"")));
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","private void renderPanos(){
  if (getInputFolder(FeatureCache.FEATURE_FOLDER).exists()) {
    int result=JOptionPane.showConfirmDialog(tweed.frame(),""String_Node_Str"",""String_Node_Str"",JOptionPane.OK_CANCEL_OPTION);
    if (result == JOptionPane.CANCEL_OPTION)     return;
  }
  FacadeFinder.facadeMode=FacadeMode.PER_CAMERA;
  try {
    new FacadeTool(tweed).renderFacade(polies,null,new BufferedWriter(new FileWriter(Tweed.SCRATCH + ""String_Node_Str"")),null);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9951969260326607
175846,"public void startRender(int callbackI){
  LotInfoGen li=tweed.frame.getGenOf(LotInfoGen.class);
  GISGen gis=tweed.frame.getGenOf(GISGen.class);
  AtomicInteger count=new AtomicInteger(0);
  Random randy=new Random();
  WorkFactory<LoopL<Point3d>> b=findBlocks(callbackI,count,randy);
  File description=new File(Tweed.DATA + File.separator + FeatureCache.SINGLE_RENDERED_FOLDER+ File.separator+ ""String_Node_Str"");
  try {
    description.getParentFile().mkdirs();
    BufferedWriter descBW=new BufferedWriter(new FileWriter(description));
    new Parallel<LoopL<Point3d>,Integer>(b,new Work<LoopL<Point3d>,Integer>(){
      public Integer work(      LoopL<Point3d> in){
        double area=Loopz.area(Loopz.toXZLoop(in));
        if (area < 10)         return 0;
        BlockGen.findWidths(in,gis);
        for (        Loop loop : in)         li.fetchOSProperties((SuperLoop<?>)loop);
        System.out.println(""String_Node_Str"" + count + ""String_Node_Str"");
        ((FacadeTool)tweed.tool).renderFacade(in,count,descBW);
        return 1;
      }
    }
,new Complete<Integer>(){
      @Override public void complete(      Set<Integer> dones){
        System.out.print(""String_Node_Str"" + count + ""String_Node_Str"");
        try {
          descBW.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
        System.out.print(""String_Node_Str"");
      }
    }
,false);
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
}","public void startRender(int callbackI){
  LotInfoGen li=tweed.frame.getGenOf(LotInfoGen.class);
  GISGen gis=tweed.frame.getGenOf(GISGen.class);
  AtomicInteger count=new AtomicInteger(0);
  Random randy=new Random();
  WorkFactory<LoopL<Point3d>> b=findBlocks(callbackI,count,randy);
  File description=new File(Tweed.DATA + File.separator + FeatureCache.SINGLE_RENDERED_FOLDER+ File.separator+ ""String_Node_Str"");
  try {
    description.getParentFile().mkdirs();
    BufferedWriter descBW=new BufferedWriter(new FileWriter(description));
    PanoGen feedback=new PanoGen(tweed){
      protected void createPanoGens(){
      }
    }
;
    tweed.frame.addGen(feedback,true);
    new Parallel<LoopL<Point3d>,Integer>(b,new Work<LoopL<Point3d>,Integer>(){
      public Integer work(      LoopL<Point3d> in){
        double area=Loopz.area(Loopz.toXZLoop(in));
        if (area < 10)         return 0;
        BlockGen.findWidths(in,gis);
        for (        Loop loop : in)         li.fetchOSProperties((SuperLoop<?>)loop);
        System.out.println(""String_Node_Str"" + count + ""String_Node_Str"");
        ((FacadeTool)tweed.tool).renderFacade(in,count,descBW,feedback);
        try {
          descBW.flush();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
        return 1;
      }
    }
,new Complete<Integer>(){
      @Override public void complete(      Set<Integer> dones){
        System.out.print(""String_Node_Str"" + count + ""String_Node_Str"");
        try {
          descBW.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
        System.out.print(""String_Node_Str"");
      }
    }
,false,-1);
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
}",0.7778122094824915
175847,"public Integer work(LoopL<Point3d> in){
  double area=Loopz.area(Loopz.toXZLoop(in));
  if (area < 10)   return 0;
  BlockGen.findWidths(in,gis);
  for (  Loop loop : in)   li.fetchOSProperties((SuperLoop<?>)loop);
  System.out.println(""String_Node_Str"" + count + ""String_Node_Str"");
  ((FacadeTool)tweed.tool).renderFacade(in,count,descBW);
  return 1;
}","public Integer work(LoopL<Point3d> in){
  double area=Loopz.area(Loopz.toXZLoop(in));
  if (area < 10)   return 0;
  BlockGen.findWidths(in,gis);
  for (  Loop loop : in)   li.fetchOSProperties((SuperLoop<?>)loop);
  System.out.println(""String_Node_Str"" + count + ""String_Node_Str"");
  ((FacadeTool)tweed.tool).renderFacade(in,count,descBW,feedback);
  try {
    descBW.flush();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return 1;
}",0.8748451053283767
175848,"private WorkFactory<LoopL<Point3d>> findBlocks(int callbackI,AtomicInteger count,Random randy){
  WorkFactory<LoopL<Point3d>> b;
  int TOGET=10000000;
  if (callbackI >= 0)   b=new Parallel.ListWF<LoopL<Point3d>>(Collections.singletonList(blocks.get(callbackI)));
 else {
    if (FacadeFinder.facadeMode == FacadeMode.PER_FETCH)     b=new WorkFactory<LoopL<Point3d>>(){
      @Override public LoopL<Point3d> generateWork(){
        int i=count.get();
        if (i > TOGET)         return null;
 else {
          LoopL<Point3d> ll=lot2block.get(lots.get(randy.nextInt(lots.size())));
          return ll;
        }
      }
    }
;
 else     b=new Parallel.ListWF<LoopL<Point3d>>(new ArrayList(blocks.values()));
  }
  return b;
}","private WorkFactory<LoopL<Point3d>> findBlocks(int callbackI,AtomicInteger count,Random randy){
  WorkFactory<LoopL<Point3d>> b;
  int TOGET=Integer.MAX_VALUE;
  if (callbackI >= 0)   b=new Parallel.ListWF<LoopL<Point3d>>(Collections.singletonList(blocks.get(callbackI)));
 else {
    if (FacadeFinder.facadeMode == FacadeMode.KANGAROO)     b=new WorkFactory<LoopL<Point3d>>(){
      @Override public LoopL<Point3d> generateWork(){
        int i=count.get();
        if (i > TOGET)         return null;
 else {
          LoopL<Point3d> ll=lot2block.get(lots.get(randy.nextInt(lots.size())));
          return ll;
        }
      }
      @Override public boolean shouldAbort(){
        return false;
      }
    }
;
 else     b=new Parallel.ListWF<LoopL<Point3d>>(new ArrayList(blocks.values()));
  }
  return b;
}",0.9247730220492868
175849,"private void createPanoGens(){
  File meta=getMetaFile();
  panos=null;
{
    panos=new ArrayList<>();
    for (    File f : Tweed.toWorkspace(folder).listFiles()) {
      String extn=Filez.getExtn(f.getName());
      if (extn.equals(""String_Node_Str"") || extn.equals(""String_Node_Str""))       createPanoGen(f,panos);
    }
    try {
      for (      Pano p : panos) {
        if (p.orig.isAbsolute())         p.orig=tweed.makeWorkspaceRelative(p.orig);
      }
      if (!panos.isEmpty())       new XStream().toXML(panos,new FileOutputStream(meta));
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
  }
}","protected void createPanoGens(){
  panos.clear();
  File meta=getMetaFile();
  panos=null;
  if (meta.exists()) {
    try {
      panos=(List<Pano>)new XStream().fromXML(meta);
    }
 catch (    Throwable th) {
      th.printStackTrace();
    }
  }
  if (panos == null || panos.isEmpty()) {
    panos=new ArrayList<>();
    for (    File f : Tweed.toWorkspace(folder).listFiles()) {
      String extn=Filez.getExtn(f.getName());
      if (extn.equals(""String_Node_Str"") || extn.equals(""String_Node_Str""))       createPanoGen(f,panos);
    }
    try {
      for (      Pano p : panos) {
        if (p.orig.isAbsolute())         p.orig=tweed.makeWorkspaceRelative(p.orig);
      }
      if (!panos.isEmpty())       new XStream().toXML(panos,new FileOutputStream(meta));
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
  }
}",0.8457912457912458
175850,"public PanoGen(File folder,Tweed tweed,String sourceCRS){
  super(""String_Node_Str"" + folder.getName(),tweed);
  this.folder=folder;
  this.sourceCRS=sourceCRS;
}","public PanoGen(Tweed tweed){
  super(""String_Node_Str"",tweed);
  this.tweed=tweed;
  this.folder=null;
}",0.6541353383458647
175851,"public static Pano createPanoGen(File f,String sourceCRS){
  String name=f.getName().substring(0,f.getName().length() - 4);
  try {
    String[] sVals=name.split(""String_Node_Str"",10);
    if (sVals.length < 6)     return null;
    List<Double> pos=Arrays.asList(Arrays.copyOfRange(sVals,0,6)).stream().map(z -> Double.parseDouble(z)).collect(Collectors.toList());
    double[] trans=new double[]{pos.get(0),pos.get(1),0};
    double[] north=new double[]{pos.get(0),pos.get(1) + 1e-6,0};
    MathTransform latLong2Country=CRS.findMathTransform(CRS.decode(sourceCRS),CRS.decode(TweedSettings.settings.gmlCoordSystem),true);
    latLong2Country.transform(trans,0,trans,0,1);
    latLong2Country.transform(north,0,north,0,1);
    if (TweedSettings.settings.gmlCoordSystem.equals(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      double tmp=trans[0];
      trans[0]=trans[1];
      trans[1]=tmp;
    }
    MathTransform country2Cartesian=CRS.findMathTransform(CRS.decode(TweedSettings.settings.gmlCoordSystem),DefaultGeocentricCRS.CARTESIAN,true);
    country2Cartesian.transform(trans,0,trans,0,1);
    country2Cartesian.transform(north,0,north,0,1);
{
      Point3d tmp=new Point3d(trans);
      TweedSettings.settings.toOrigin.transform(tmp);
      tmp.get(trans);
      tmp=new Point3d(north);
      TweedSettings.settings.toOrigin.transform(tmp);
      tmp.get(north);
    }
    if (TweedSettings.settings.gmlCoordSystem.equals(""String_Node_Str"")) {
      trans[2]-=258;
      north[2]-=258;
      trans[0]+=3;
      trans[0]+=3;
    }
    Vector3d location=new Vector3d(trans[0],2.5f,trans[2]);
    System.out.println(""String_Node_Str"" + location);
    return new Pano(name,location,(pos.get(3).floatValue() + 180),pos.get(4).floatValue(),pos.get(5).floatValue());
  }
 catch (  IndexOutOfBoundsException e) {
    e.printStackTrace();
  }
catch (  NoSuchAuthorityCodeException e) {
    e.printStackTrace();
  }
catch (  FactoryException e) {
    e.printStackTrace();
  }
catch (  TransformException e) {
    e.printStackTrace();
  }
  return null;
}","public static Pano createPanoGen(File f,String sourceCRS){
  String name=f.getName().substring(0,f.getName().length() - 4);
  try {
    String[] sVals=name.split(""String_Node_Str"",10);
    if (sVals.length < 6)     return null;
    List<Double> pos=Arrays.asList(Arrays.copyOfRange(sVals,0,6)).stream().map(z -> Double.parseDouble(z)).collect(Collectors.toList());
    double[] trans=new double[]{pos.get(0),pos.get(1),0};
    double[] north=new double[]{pos.get(0),pos.get(1) + 1e-6,0};
    MathTransform latLong2Country=CRS.findMathTransform(CRS.decode(sourceCRS),CRS.decode(TweedSettings.settings.gmlCoordSystem),true);
    latLong2Country.transform(trans,0,trans,0,1);
    latLong2Country.transform(north,0,north,0,1);
    if (TweedSettings.settings.gmlCoordSystem.equals(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      double tmp=trans[0];
      trans[0]=trans[1];
      trans[1]=tmp;
    }
    MathTransform country2Cartesian=CRS.findMathTransform(CRS.decode(TweedSettings.settings.gmlCoordSystem),DefaultGeocentricCRS.CARTESIAN,true);
    country2Cartesian.transform(trans,0,trans,0,1);
    country2Cartesian.transform(north,0,north,0,1);
{
      Point3d tmp=new Point3d(trans);
      TweedSettings.settings.toOrigin.transform(tmp);
      tmp.get(trans);
      tmp=new Point3d(north);
      TweedSettings.settings.toOrigin.transform(tmp);
      tmp.get(north);
    }
    if (TweedSettings.settings.gmlCoordSystem.equals(""String_Node_Str"")) {
      trans[2]-=258;
      north[2]-=258;
      trans[0]+=3;
      trans[0]+=3;
    }
    Vector3d location=new Vector3d(trans[0],2.5f,trans[2]);
    return new Pano(name,location,(pos.get(3).floatValue() + 180),pos.get(4).floatValue(),pos.get(5).floatValue());
  }
 catch (  IndexOutOfBoundsException e) {
    e.printStackTrace();
  }
catch (  NoSuchAuthorityCodeException e) {
    e.printStackTrace();
  }
catch (  FactoryException e) {
    e.printStackTrace();
  }
catch (  TransformException e) {
    e.printStackTrace();
  }
  return null;
}",0.986809965803615
175852,"@Override public JComponent getUI(){
  ui.removeAll();
  ui.setLayout(new ListDownLayout());
  if (new File(Tweed.toWorkspace(folder),TO_DOWNLOAD).exists()) {
    JButton download=new JButton(""String_Node_Str"");
    download.addActionListener(e -> downloadPanos());
    ui.add(download);
  }
  JButton align=new JButton(""String_Node_Str"");
  align.addActionListener(e -> tweed.setTool(new FacadeTool(tweed)));
  ui.add(align);
  JButton plane=new JButton(""String_Node_Str"");
  plane.addActionListener(e -> tweed.setTool(new PlaneTool(tweed)));
  ui.add(plane);
  return ui;
}","@Override public JComponent getUI(){
  ui.removeAll();
  ui.setLayout(new ListDownLayout());
  if (folder != null && folder.exists())   if (new File(Tweed.toWorkspace(folder),TO_DOWNLOAD).exists()) {
    JButton download=new JButton(""String_Node_Str"");
    download.addActionListener(e -> downloadPanos());
    ui.add(download);
  }
  JButton align=new JButton(""String_Node_Str"");
  align.addActionListener(e -> tweed.setTool(new FacadeTool(tweed)));
  ui.add(align);
  JButton plane=new JButton(""String_Node_Str"");
  plane.addActionListener(e -> tweed.setTool(new PlaneTool(tweed)));
  ui.add(plane);
  return ui;
}",0.9655751469353484
175853,"@Override public void calculate(){
  File absFolder=Tweed.toWorkspace(PanoGen.this.folder);
  if (!absFolder.exists())   throw new Error(""String_Node_Str"" + this.folder);
  for (  Spatial s : gNode.getChildren())   s.removeFromParent();
  panos.clear();
  createPanoGens();
  Iterator<Pano> pit=panos.iterator();
  while (pit.hasNext()) {
    Pano p=pit.next();
    if (p.rx == 0 && Math.abs(p.rz - Mathz.TwoPI) < 1e-6)     pit.remove();
  }
  Random randy=new Random(0xdeadbeef);
  for (  Pano p : panos) {
    if (p.geom == null) {
      Box box1=new Box(1f,1f,1f);
      p.geom=new Geometry(""String_Node_Str"",box1);
      p.geom.setUserData(EventMoveHandle.class.getSimpleName(),new Object[]{new EventMoveHandle(){
        @Override public void posChanged(){
          p.location=new Vector3d(Jme3z.from(p.geom.getLocalTranslation()));
          calculate();
        }
      }
});
      ColorRGBA col=new ColorRGBA(color.getRed() * (0.2f + randy.nextFloat() * 0.8f) / 255f,color.getGreen() * (0.2f + randy.nextFloat() * 0.8f) / 255f,color.getBlue() * (0.2f + randy.nextFloat() * 0.8f) / 255f,1f);
      Material mat=new Material(tweed.getAssetManager(),""String_Node_Str"");
      mat.setColor(""String_Node_Str"",col);
      mat.setColor(""String_Node_Str"",col);
      mat.setBoolean(""String_Node_Str"",true);
      p.geom.setMaterial(mat);
    }
    p.geom.setLocalTranslation((float)p.location.x,(float)p.location.y,(float)p.location.z);
    p.geom.setLocalRotation(p.geomRot);
    p.geom.setUserData(ClickMe.class.getSimpleName(),new Object[]{new ClickMe(){
      @Override public void clicked(      Object data){
        tweed.frame.setSelected(PanoGen.this);
        selected(p);
      }
    }
});
    gNode.attachChild(p.geom);
  }
  super.calculate();
}","@Override public void calculate(){
  if (folder != null) {
    File absFolder=Tweed.toWorkspace(folder);
    if (!absFolder.exists())     throw new Error(""String_Node_Str"" + this.folder);
  }
  for (  Spatial s : gNode.getChildren())   s.removeFromParent();
  createPanoGens();
  Iterator<Pano> pit=panos.iterator();
  while (pit.hasNext()) {
    Pano p=pit.next();
    if (p.rx == 0 && Math.abs(p.rz - Mathz.TwoPI) < 1e-6)     pit.remove();
  }
  Random randy=new Random(0xdeadbeef);
  for (  Pano p : panos) {
    if (p.geom == null) {
      Box box1=new Box(1f,1f,1f);
      p.geom=new Geometry(""String_Node_Str"",box1);
      p.geom.setUserData(EventMoveHandle.class.getSimpleName(),new Object[]{new EventMoveHandle(){
        @Override public void posChanged(){
          p.location=new Vector3d(Jme3z.from(p.geom.getLocalTranslation()));
          calculate();
        }
      }
});
      ColorRGBA col=new ColorRGBA(color.getRed() * (0.2f + randy.nextFloat() * 0.8f) / 255f,color.getGreen() * (0.2f + randy.nextFloat() * 0.8f) / 255f,color.getBlue() * (0.2f + randy.nextFloat() * 0.8f) / 255f,1f);
      Material mat=new Material(tweed.getAssetManager(),""String_Node_Str"");
      mat.setColor(""String_Node_Str"",col);
      mat.setColor(""String_Node_Str"",col);
      mat.setBoolean(""String_Node_Str"",true);
      p.geom.setMaterial(mat);
    }
    p.geom.setLocalTranslation((float)p.location.x,(float)p.location.y,(float)p.location.z);
    p.geom.setLocalRotation(p.geomRot);
    p.geom.setUserData(ClickMe.class.getSimpleName(),new Object[]{new ClickMe(){
      @Override public void clicked(      Object data){
        tweed.frame.setSelected(PanoGen.this);
        selected(p);
      }
    }
});
    gNode.attachChild(p.geom);
  }
  for (  ImagePlaneGen ipg : planes) {
    ipg.calculate();
    gNode.attachChild(ipg.gNode);
  }
  super.calculate();
}",0.945273631840796
175854,"@Override public void getUI(JPanel panel){
  panel.setLayout(new ListDownLayout());
  JComboBox<FacadeFinder.FacadeMode> granularity=new JComboBox<>();
  granularity.addItem(FacadeMode.PER_GIS);
  granularity.addItem(FacadeMode.PER_MEGA);
  granularity.addItem(FacadeMode.PER_CAMERA);
  granularity.addItem(FacadeMode.PER_CAMERA_CROPPED);
  granularity.addItem(FacadeMode.PER_FETCH);
  granularity.setSelectedItem(FacadeFinder.facadeMode);
  granularity.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      FacadeFinder.facadeMode=(FacadeMode)granularity.getSelectedItem();
    }
  }
);
  JCheckBox singleFolderCheck=new JCheckBox(""String_Node_Str"");
  singleFolderCheck.setSelected(FacadeTool.this.singleFolder);
  singleFolderCheck.addActionListener(e -> FacadeTool.this.singleFolder=singleFolderCheck.isSelected());
  JButton forAll=new JButton(""String_Node_Str"");
  forAll.addActionListener(l -> tweed.frame.getGenOf(GISGen.class).startRender(-1));
  panel.add(granularity);
  panel.add(singleFolderCheck);
  panel.add(forAll);
  panel.add(new JLabel(""String_Node_Str""));
}","@Override public void getUI(JPanel panel){
  panel.setLayout(new ListDownLayout());
  JComboBox<FacadeFinder.FacadeMode> granularity=new JComboBox<>();
  granularity.addItem(FacadeMode.PER_GIS);
  granularity.addItem(FacadeMode.PER_MEGA);
  granularity.addItem(FacadeMode.PER_CAMERA);
  granularity.addItem(FacadeMode.PER_CAMERA_CROPPED);
  granularity.addItem(FacadeMode.KANGAROO);
  granularity.setSelectedItem(FacadeFinder.facadeMode);
  granularity.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      FacadeFinder.facadeMode=(FacadeMode)granularity.getSelectedItem();
    }
  }
);
  JCheckBox singleFolderCheck=new JCheckBox(""String_Node_Str"");
  singleFolderCheck.setSelected(FacadeTool.this.singleFolder);
  singleFolderCheck.addActionListener(e -> FacadeTool.this.singleFolder=singleFolderCheck.isSelected());
  JButton forAll=new JButton(""String_Node_Str"");
  forAll.addActionListener(l -> tweed.frame.getGenOf(GISGen.class).startRender(-1));
  panel.add(granularity);
  panel.add(singleFolderCheck);
  panel.add(forAll);
  panel.add(new JLabel(""String_Node_Str""));
}",0.9933716305788776
175855,"public void renderFacade(LoopL<Point3d> list,AtomicInteger count,BufferedWriter description){
  double[] minMax=Loopz.minMax(list);
  Loopz.expand(minMax,30);
  Map<Point2d,Pano> panos=new HashMap<>();
  for (  Gen gen : tweed.frame.gens(PanoGen.class))   for (  Pano pg : ((PanoGen)gen).getPanos()) {
    Point2d pt=new Point2d(pg.location.x,pg.location.z);
    if (pt.x > minMax[0] && pt.x < minMax[1] && pt.y > minMax[4] && pt.y < minMax[5])     panos.put(pt,pg);
  }
  FacadeFinder ff=new FacadeFinder(Loopz.toXZLoop(list),panos,tweed.frame.getGenOf(PlanesGen.class));
  Point2d cen=Loopz.average(Loopz.to2dLoop(list,1,null));
  renderFacades(cen.x + ""String_Node_Str"" + cen.y,ff,count,description);
}","public void renderFacade(LoopL<Point3d> list,AtomicInteger count,BufferedWriter description,PanoGen feedback){
  double[] minMax=Loopz.minMax(list);
  Loopz.expand(minMax,30);
  Map<Point2d,Pano> panos=new HashMap<>();
  for (  Gen gen : tweed.frame.gens(PanoGen.class))   for (  Pano pg : ((PanoGen)gen).getPanos()) {
    Point2d pt=new Point2d(pg.location.x,pg.location.z);
    if (pt.x > minMax[0] && pt.x < minMax[1] && pt.y > minMax[4] && pt.y < minMax[5])     panos.put(pt,pg);
  }
  FacadeFinder ff=new FacadeFinder(Loopz.toXZLoop(list),panos,tweed.frame.getGenOf(PlanesGen.class));
  Point2d cen=Loopz.average(Loopz.to2dLoop(list,1,null));
  renderFacades(cen.x + ""String_Node_Str"" + cen.y,ff,count,description,feedback);
}",0.9818941504178272
175856,"private void renderFacades(String blockName,FacadeFinder ff,AtomicInteger count,BufferedWriter description){
  Thread thread=new Thread(){
    @Override public void run(){
      File blockFile=singleFolder ? new File(Tweed.DATA + File.separator + FeatureCache.SINGLE_RENDERED_FOLDER) : new File(Tweed.DATA + File.separator + FeatureCache.FEATURE_FOLDER+ File.separator+ blockName);
      for (int mfi=0; mfi < ff.results.size(); mfi++) {
        ToProjMega tpm=ff.results.get(mfi);
        if (tpm.size() == 0 || tpm.stream().mapToInt(x -> tpm.size()).sum() == 0)         continue;
        File megaFolder=singleFolder ? blockFile : new File(blockFile,""String_Node_Str"" + mfi);
        megaFolder.mkdirs();
        try {
          new XStream().toXML(tpm.megafacade,new FileOutputStream(new File(megaFolder,LINE_XML)));
        }
 catch (        FileNotFoundException e) {
          e.printStackTrace();
        }
        double rot=0;
        List<BufferedImage> images=new ArrayList<>();
        for (int fc=0; fc < tpm.size(); fc++) {
          ToProject tp=tpm.get(fc);
          System.out.println(""String_Node_Str"" + mfi + ""String_Node_Str""+ fc);
          File imageFolder;
          imageFolder=singleFolder ? megaFolder : new File(megaFolder,""String_Node_Str"" + fc);
          imageFolder.mkdirs();
          ImagePlaneGen pg=new ImagePlaneGen(tweed,(float)tp.e.x,(float)tp.e.y,(float)tp.s.x,(float)tp.s.y,(float)tp.minHeight,(float)tp.maxHeight,tp.toProject);
          if (false)           tweed.frame.addGen(pg,true);
          for (          Pano pano_ : tp.toProject) {
            int c=count.getAndIncrement();
            String imageFilename=singleFolder ? String.format(""String_Node_Str"",c) : FeatureCache.RENDERED_IMAGE;
            try {
              description.write(String.format(""String_Node_Str"",c) + tp.description + ""String_Node_Str"");
            }
 catch (            IOException e) {
              e.printStackTrace();
            }
            Pano pano=new Pano(pano_);
            pano.set(pano.oa1 - (float)rot,pano.oa2,pano.oa3);
            if (imageFilename == null)             imageFilename=new File(pano.name).getName() + ""String_Node_Str"" + tpm.megafacade.start+ ""String_Node_Str""+ tpm.megafacade.end;
            BufferedImage bi=pg.render(imageFolder,pixelsPerMeter,pano,tpm.megafacade,imageFilename);
            if (!singleFolder) {
              images.add(bi);
              try {
                FileWriter out=new FileWriter(new File(imageFolder,""String_Node_Str""));
                out.write(pixelsPerMeter * 10 + ""String_Node_Str"" + (tp.s.distance(tp.e) * pixelsPerMeter - pixelsPerMeter * 20) + ""String_Node_Str"" + (tp.maxHeight - tp.minHeight) * pixelsPerMeter + ""String_Node_Str"");
                out.write(pg.toString() + ""String_Node_Str"");
                out.write(pano.orig.getName() + ""String_Node_Str"");
                Point2d cen=tpm.megafacade.project(new Point2d(pano.location.x,pano.location.z),false);
                out.write(tp.s.x + ""String_Node_Str"" + tp.s.y+ ""String_Node_Str""+ tp.e.x+ ""String_Node_Str""+ tp.e.y+ ""String_Node_Str""+ cen.x+ ""String_Node_Str""+ cen.y+ ""String_Node_Str""+ pano.location.x+ ""String_Node_Str""+ pano.location.z+ ""String_Node_Str"");
                out.close();
              }
 catch (              Throwable th) {
                th.printStackTrace();
              }
            }
          }
        }
        if (!singleFolder)         Imagez.writeSummary(new File(megaFolder,""String_Node_Str""),images);
      }
    }
  }
;
  thread.run();
}","private void renderFacades(String blockName,FacadeFinder ff,AtomicInteger count,BufferedWriter description,PanoGen feedback){
  Thread thread=new Thread(){
    @Override public void run(){
      File blockFile=singleFolder ? new File(Tweed.DATA + File.separator + FeatureCache.SINGLE_RENDERED_FOLDER) : new File(Tweed.DATA + File.separator + FeatureCache.FEATURE_FOLDER+ File.separator+ blockName);
      for (int mfi=0; mfi < ff.results.size(); mfi++) {
        ToProjMega tpm=ff.results.get(mfi);
        if (tpm.size() == 0 || tpm.stream().mapToInt(x -> tpm.size()).sum() == 0)         continue;
        File megaFolder=singleFolder ? blockFile : new File(blockFile,""String_Node_Str"" + mfi);
        megaFolder.mkdirs();
        if (!singleFolder)         try {
          new XStream().toXML(tpm.megafacade,new FileOutputStream(new File(megaFolder,LINE_XML)));
        }
 catch (        FileNotFoundException e) {
          e.printStackTrace();
        }
        double rot=0;
        List<BufferedImage> images=new ArrayList<>();
        for (int fc=0; fc < tpm.size(); fc++) {
          ToProject tp=tpm.get(fc);
          System.out.println(""String_Node_Str"" + mfi + ""String_Node_Str""+ fc);
          File imageFolder;
          imageFolder=singleFolder ? megaFolder : new File(megaFolder,""String_Node_Str"" + fc);
          imageFolder.mkdirs();
          ImagePlaneGen pg=new ImagePlaneGen(tweed,(float)tp.e.x,(float)tp.e.y,(float)tp.s.x,(float)tp.s.y,(float)tp.minHeight,(float)tp.maxHeight,tp.toProject);
          if (feedback != null)           feedback.planes.add(pg);
          for (          Pano pano_ : tp.toProject) {
            int c=count.getAndIncrement();
            String imageFilename=singleFolder ? String.format(""String_Node_Str"",c) : FeatureCache.RENDERED_IMAGE;
            try {
              description.write(String.format(""String_Node_Str"",c) + tp.description + ""String_Node_Str"");
            }
 catch (            IOException e) {
              e.printStackTrace();
            }
            Pano pano=new Pano(pano_);
            pano.set(pano.oa1 - (float)rot,pano.oa2,pano.oa3);
            if (imageFilename == null)             imageFilename=new File(pano.name).getName() + ""String_Node_Str"" + tpm.megafacade.start+ ""String_Node_Str""+ tpm.megafacade.end;
            BufferedImage bi=pg.render(imageFolder,pixelsPerMeter,pano,tpm.megafacade,imageFilename);
            if (feedback != null) {
              feedback.panos.add(pano);
              feedback.calculateOnJmeThread();
            }
            if (!singleFolder) {
              images.add(bi);
              try {
                FileWriter out=new FileWriter(new File(imageFolder,""String_Node_Str""));
                out.write(pixelsPerMeter * 10 + ""String_Node_Str"" + (tp.s.distance(tp.e) * pixelsPerMeter - pixelsPerMeter * 20) + ""String_Node_Str"" + (tp.maxHeight - tp.minHeight) * pixelsPerMeter + ""String_Node_Str"");
                out.write(pg.toString() + ""String_Node_Str"");
                out.write(pano.orig.getName() + ""String_Node_Str"");
                Point2d cen=tpm.megafacade.project(new Point2d(pano.location.x,pano.location.z),false);
                out.write(tp.s.x + ""String_Node_Str"" + tp.s.y+ ""String_Node_Str""+ tp.e.x+ ""String_Node_Str""+ tp.e.y+ ""String_Node_Str""+ cen.x+ ""String_Node_Str""+ cen.y+ ""String_Node_Str""+ pano.location.x+ ""String_Node_Str""+ pano.location.z+ ""String_Node_Str"");
                out.close();
              }
 catch (              Throwable th) {
                th.printStackTrace();
              }
            }
          }
        }
        if (!singleFolder)         Imagez.writeSummary(new File(megaFolder,""String_Node_Str""),images);
      }
    }
  }
;
  thread.run();
}",0.962912087912088
175857,"@Override public void run(){
  File blockFile=singleFolder ? new File(Tweed.DATA + File.separator + FeatureCache.SINGLE_RENDERED_FOLDER) : new File(Tweed.DATA + File.separator + FeatureCache.FEATURE_FOLDER+ File.separator+ blockName);
  for (int mfi=0; mfi < ff.results.size(); mfi++) {
    ToProjMega tpm=ff.results.get(mfi);
    if (tpm.size() == 0 || tpm.stream().mapToInt(x -> tpm.size()).sum() == 0)     continue;
    File megaFolder=singleFolder ? blockFile : new File(blockFile,""String_Node_Str"" + mfi);
    megaFolder.mkdirs();
    try {
      new XStream().toXML(tpm.megafacade,new FileOutputStream(new File(megaFolder,LINE_XML)));
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
    double rot=0;
    List<BufferedImage> images=new ArrayList<>();
    for (int fc=0; fc < tpm.size(); fc++) {
      ToProject tp=tpm.get(fc);
      System.out.println(""String_Node_Str"" + mfi + ""String_Node_Str""+ fc);
      File imageFolder;
      imageFolder=singleFolder ? megaFolder : new File(megaFolder,""String_Node_Str"" + fc);
      imageFolder.mkdirs();
      ImagePlaneGen pg=new ImagePlaneGen(tweed,(float)tp.e.x,(float)tp.e.y,(float)tp.s.x,(float)tp.s.y,(float)tp.minHeight,(float)tp.maxHeight,tp.toProject);
      if (false)       tweed.frame.addGen(pg,true);
      for (      Pano pano_ : tp.toProject) {
        int c=count.getAndIncrement();
        String imageFilename=singleFolder ? String.format(""String_Node_Str"",c) : FeatureCache.RENDERED_IMAGE;
        try {
          description.write(String.format(""String_Node_Str"",c) + tp.description + ""String_Node_Str"");
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
        Pano pano=new Pano(pano_);
        pano.set(pano.oa1 - (float)rot,pano.oa2,pano.oa3);
        if (imageFilename == null)         imageFilename=new File(pano.name).getName() + ""String_Node_Str"" + tpm.megafacade.start+ ""String_Node_Str""+ tpm.megafacade.end;
        BufferedImage bi=pg.render(imageFolder,pixelsPerMeter,pano,tpm.megafacade,imageFilename);
        if (!singleFolder) {
          images.add(bi);
          try {
            FileWriter out=new FileWriter(new File(imageFolder,""String_Node_Str""));
            out.write(pixelsPerMeter * 10 + ""String_Node_Str"" + (tp.s.distance(tp.e) * pixelsPerMeter - pixelsPerMeter * 20) + ""String_Node_Str"" + (tp.maxHeight - tp.minHeight) * pixelsPerMeter + ""String_Node_Str"");
            out.write(pg.toString() + ""String_Node_Str"");
            out.write(pano.orig.getName() + ""String_Node_Str"");
            Point2d cen=tpm.megafacade.project(new Point2d(pano.location.x,pano.location.z),false);
            out.write(tp.s.x + ""String_Node_Str"" + tp.s.y+ ""String_Node_Str""+ tp.e.x+ ""String_Node_Str""+ tp.e.y+ ""String_Node_Str""+ cen.x+ ""String_Node_Str""+ cen.y+ ""String_Node_Str""+ pano.location.x+ ""String_Node_Str""+ pano.location.z+ ""String_Node_Str"");
            out.close();
          }
 catch (          Throwable th) {
            th.printStackTrace();
          }
        }
      }
    }
    if (!singleFolder)     Imagez.writeSummary(new File(megaFolder,""String_Node_Str""),images);
  }
}","@Override public void run(){
  File blockFile=singleFolder ? new File(Tweed.DATA + File.separator + FeatureCache.SINGLE_RENDERED_FOLDER) : new File(Tweed.DATA + File.separator + FeatureCache.FEATURE_FOLDER+ File.separator+ blockName);
  for (int mfi=0; mfi < ff.results.size(); mfi++) {
    ToProjMega tpm=ff.results.get(mfi);
    if (tpm.size() == 0 || tpm.stream().mapToInt(x -> tpm.size()).sum() == 0)     continue;
    File megaFolder=singleFolder ? blockFile : new File(blockFile,""String_Node_Str"" + mfi);
    megaFolder.mkdirs();
    if (!singleFolder)     try {
      new XStream().toXML(tpm.megafacade,new FileOutputStream(new File(megaFolder,LINE_XML)));
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
    double rot=0;
    List<BufferedImage> images=new ArrayList<>();
    for (int fc=0; fc < tpm.size(); fc++) {
      ToProject tp=tpm.get(fc);
      System.out.println(""String_Node_Str"" + mfi + ""String_Node_Str""+ fc);
      File imageFolder;
      imageFolder=singleFolder ? megaFolder : new File(megaFolder,""String_Node_Str"" + fc);
      imageFolder.mkdirs();
      ImagePlaneGen pg=new ImagePlaneGen(tweed,(float)tp.e.x,(float)tp.e.y,(float)tp.s.x,(float)tp.s.y,(float)tp.minHeight,(float)tp.maxHeight,tp.toProject);
      if (feedback != null)       feedback.planes.add(pg);
      for (      Pano pano_ : tp.toProject) {
        int c=count.getAndIncrement();
        String imageFilename=singleFolder ? String.format(""String_Node_Str"",c) : FeatureCache.RENDERED_IMAGE;
        try {
          description.write(String.format(""String_Node_Str"",c) + tp.description + ""String_Node_Str"");
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
        Pano pano=new Pano(pano_);
        pano.set(pano.oa1 - (float)rot,pano.oa2,pano.oa3);
        if (imageFilename == null)         imageFilename=new File(pano.name).getName() + ""String_Node_Str"" + tpm.megafacade.start+ ""String_Node_Str""+ tpm.megafacade.end;
        BufferedImage bi=pg.render(imageFolder,pixelsPerMeter,pano,tpm.megafacade,imageFilename);
        if (feedback != null) {
          feedback.panos.add(pano);
          feedback.calculateOnJmeThread();
        }
        if (!singleFolder) {
          images.add(bi);
          try {
            FileWriter out=new FileWriter(new File(imageFolder,""String_Node_Str""));
            out.write(pixelsPerMeter * 10 + ""String_Node_Str"" + (tp.s.distance(tp.e) * pixelsPerMeter - pixelsPerMeter * 20) + ""String_Node_Str"" + (tp.maxHeight - tp.minHeight) * pixelsPerMeter + ""String_Node_Str"");
            out.write(pg.toString() + ""String_Node_Str"");
            out.write(pano.orig.getName() + ""String_Node_Str"");
            Point2d cen=tpm.megafacade.project(new Point2d(pano.location.x,pano.location.z),false);
            out.write(tp.s.x + ""String_Node_Str"" + tp.s.y+ ""String_Node_Str""+ tp.e.x+ ""String_Node_Str""+ tp.e.y+ ""String_Node_Str""+ cen.x+ ""String_Node_Str""+ cen.y+ ""String_Node_Str""+ pano.location.x+ ""String_Node_Str""+ pano.location.z+ ""String_Node_Str"");
            out.close();
          }
 catch (          Throwable th) {
            th.printStackTrace();
          }
        }
      }
    }
    if (!singleFolder)     Imagez.writeSummary(new File(megaFolder,""String_Node_Str""),images);
  }
}",0.9650023331777882
175858,"public void startRender(int callbackI){
  LotInfoGen li=tweed.frame.getGenOf(LotInfoGen.class);
  GISGen gis=tweed.frame.getGenOf(GISGen.class);
  AtomicInteger count=new AtomicInteger(0);
  Random randy=new Random();
  WorkFactory<LoopL<Point3d>> b=findBlocks(callbackI,count,randy);
  File description=new File(Tweed.DATA + File.separator + FeatureCache.SINGLE_RENDERED_FOLDER+ File.separator+ ""String_Node_Str"");
  try {
    description.getParentFile().mkdirs();
    BufferedWriter descBW=new BufferedWriter(new FileWriter(description));
    PanoGen feedback=new PanoGen(tweed){
      protected void createPanoGens(){
      }
    }
;
    tweed.frame.addGen(feedback,true);
    new Parallel<LoopL<Point3d>,Integer>(b,new Work<LoopL<Point3d>,Integer>(){
      public Integer work(      LoopL<Point3d> in){
        double area=Loopz.area(Loopz.toXZLoop(in));
        if (area < 10)         return 0;
        BlockGen.findWidths(in,gis);
        for (        Loop loop : in)         li.fetchOSProperties((SuperLoop<?>)loop);
        System.out.println(""String_Node_Str"" + count + ""String_Node_Str"");
        ((FacadeTool)tweed.tool).renderFacade(in,count,descBW,feedback);
        try {
          descBW.flush();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
        return 1;
      }
    }
,new Complete<Integer>(){
      @Override public void complete(      Set<Integer> dones){
        System.out.print(""String_Node_Str"" + count + ""String_Node_Str"");
        try {
          descBW.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
        System.out.print(""String_Node_Str"");
      }
    }
,false,-1);
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
}","public void startRender(int callbackI){
  LotInfoGen li=tweed.frame.getGenOf(LotInfoGen.class);
  GISGen gis=tweed.frame.getGenOf(GISGen.class);
  AtomicInteger count=new AtomicInteger(0);
  Random randy=new Random();
  WorkFactory<LoopL<Point3d>> b=findBlocks(callbackI,count,randy);
  File description=new File(Tweed.DATA + File.separator + FeatureCache.SINGLE_RENDERED_FOLDER+ File.separator+ ""String_Node_Str"");
  try {
    description.getParentFile().mkdirs();
    BufferedWriter descBW=new BufferedWriter(new FileWriter(description));
    PanoGen feedback=null;
    new Parallel<LoopL<Point3d>,Integer>(b,new Work<LoopL<Point3d>,Integer>(){
      public Integer work(      LoopL<Point3d> in){
        double area=Loopz.area(Loopz.toXZLoop(in));
        if (area < 10)         return 0;
        BlockGen.findWidths(in,gis);
        for (        Loop loop : in)         li.fetchOSProperties((SuperLoop<?>)loop);
        System.out.println(""String_Node_Str"" + count + ""String_Node_Str"");
        ((FacadeTool)tweed.tool).renderFacade(in,count,descBW,feedback);
        try {
          descBW.flush();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
        return 1;
      }
    }
,new Complete<Integer>(){
      @Override public void complete(      Set<Integer> dones){
        System.out.print(""String_Node_Str"" + count + ""String_Node_Str"");
        try {
          descBW.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
        System.out.print(""String_Node_Str"");
      }
    }
,false,16);
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
}",0.9657817109144544
175859,"public FacadeFinder(LoopL<Point2d> _edges,Map<Point2d,Pano> panos,PlanesGen drawnPlanes){
  MultiMap<Point2d,Integer> whichPoly=new MultiMap<>();
  LoopL<Point2d> edges=simplify(_edges,whichPoly);
  List<FacadeDirection> fs=new ArrayList<>();
  List<Loopable<Point2d>> longestFirst=edges.stream().flatMap(x -> Streamz.stream(x.loopableIterator())).sorted((b,a) -> Double.compare(a.get().distanceSquared(a.getNext().get()),b.get().distanceSquared(b.getNext().get()))).collect(Collectors.toList());
  for (  Loopable<Point2d> lp : longestFirst) {
    Point2d s=lp.get(), e=lp.getNext().get();
    Line l=new SuperLine(s,e);
    boolean found=false;
    for (    FacadeDirection f : fs)     if (f.addIfMatches(l)) {
      found=true;
      break;
    }
    if (!found)     fs.add(new FacadeDirection(l));
  }
  for (  FacadeDirection f : fs) {
    if (f.length < 2)     continue;
    Line drawnPlane=null;
    if (drawnPlanes != null) {
      Line outl=f.getExtent();
      Optional<Plane> op=drawnPlanes.planes.stream().filter(p -> {
        Line pl=new Line(Jme3z.to2(p.a),Jme3z.to2(p.b));
        double angle=pl.absAngle(outl);
        return pl.distance(outl) < 5 && (angle < 0.3 || angle > Math.PI - 0.3);
      }
).findAny();
      if (op.isPresent()) {
        drawnPlane=new Line(Jme3z.to2(op.get().a),Jme3z.to2(op.get().b));
      }
      if (drawnPlane == null)       continue;
    }
    ToProjMega megaResults=new ToProjMega(f.getExtent().reverse());
    results.add(megaResults);
    if (facadeMode == FacadeMode.PER_GIS) {
      for (      Line l : f.facades) {
        if (l.lengthSquared() < 5 * 5)         continue;
        String description=createDescription(l,(SuperLoop<Point2d>)_edges.get(findOrigPoly(whichPoly,l.start,l.end)),new double[1]);
        if (description == null)         continue;
        double height=10;
        System.out.println(""String_Node_Str"" + height);
        Line ex=new Line(l);
        ex=ex.reverse();
        Vector2d dir=ex.dir();
        dir.scale(5 / dir.length());
        Point2d mid=ex.fromPPram(0.5);
        ex.start.set(mid);
        ex.start.sub(dir);
        ex.end.set(mid);
        ex.end.add(dir);
        ToProject out=new ToProject(ex.start,ex.end,0,height);
        out.description=description;
        for (        Point2d p : panos.keySet()) {
          if (ex.isOnLeft(p))           if (Mathz.inRange(ex.findPPram(p),0,1))           out.toProject.add(panos.get(p));
        }
        if (out.toProject.size() > 0)         megaResults.add(out);
      }
    }
 else     if (facadeMode == FacadeMode.KANGAROO) {
      List<Line> filtered=f.facades.stream().filter(l -> l.lengthSquared() > 3 * 3).collect(Collectors.toList());
      Collections.shuffle(filtered);
      for (      Line l : filtered) {
        SuperLoop<Point2d> orig=(SuperLoop<Point2d>)_edges.get(findOrigPoly(whichPoly,l.start,l.end));
        double[] ho=new double[1];
        String description=createDescription(l,orig,ho);
        if (description == null)         continue;
        double height=ho[0];
        System.out.println(""String_Node_Str"" + height);
        Line ex=new Line(l);
        ex.reverseLocal();
        Point2d mid=ex.fromPPram(0.5);
{
          Vector2d dir=ex.dir();
          dir.scale(2 / dir.length());
          ex.start.sub(dir);
          ex.end.add(dir);
        }
        Pano pano=new SVLatLongQuery(TweedFrame.instance.tweed.worldToLatLong(Pointz.to3(mid))).query(new Score(){
          @Override public double score(          Pano query){
            Point2d p=new Point2d(query.location.x,query.location.z);
            double d2=ex.distance(p);
            if (ex.isOnLeft(p) && d2 < 25)             if (ex.distance(ex.project(p,false)) < 3)             return -d2;
            return -Double.MAX_VALUE;
          }
        }
);
        if (pano == null)         continue;
        ToProject out=new ToProject(ex.start,ex.end,0,height);
        out.description=description;
        out.toProject.add(pano);
        megaResults.add(out);
        break;
      }
    }
 else     if (facadeMode == FacadeMode.PER_MEGA) {
      Line mega=f.getExtent();
      Vector2d dir=mega.dir();
      dir.scale(7 / dir.length());
      Point2d s=new Point2d(mega.start), e=new Point2d(mega.end);
      e.add(dir);
      s.sub(dir);
      for (      Point2d p : panos.keySet()) {
        Point2d cen=mega.project(p,false);
        if (mega.isOnLeft(p) && mega.distance(p,true) < 20 && Mathz.inRange(mega.findPPram(cen),0,1)) {
          double height=panos.get(p).location.y;
          ToProject out=new ToProject(s,e,0,height + 30);
          megaResults.add(out);
          out.toProject.add(panos.get(p));
        }
      }
    }
 else     if (facadeMode == FacadeMode.PER_CAMERA || facadeMode == FacadeMode.PER_CAMERA_CROPPED) {
      Line l=f.getExtent();
      double lLength=l.length();
      for (      Point2d p : panos.keySet()) {
        if (l.isOnLeft(p) && l.distance(p,true) < 20) {
          double fovX2=Math.PI / 3;
          Point2d cen=l.project(p,false);
          double dist=cen.distance(p), frac=l.findPPram(cen);
          if (dist > 20 || !Mathz.inRange(frac * lLength,-2,lLength + 2))           continue;
          double xLen=dist * Math.tan(fovX2);
          Vector2d dirX=l.dir();
          dirX.normalize();
          Point2d left=new Point2d(dirX);
          left.scaleAdd(xLen,cen);
          Point2d right=new Point2d(dirX);
          right.scaleAdd(-xLen,cen);
          if (facadeMode == FacadeMode.PER_CAMERA_CROPPED) {
            double beyond=6;
            double min=-beyond / l.length(), max=1 + (beyond / l.length());
            if (drawnPlane != null) {
              double s=l.findPPram(drawnPlane.start), e=l.findPPram(drawnPlane.end);
              if (s > e) {
                double tmp=e;
                e=s;
                s=tmp;
              }
              min=Mathz.clamp(min,s,e);
              max=Mathz.clamp(max,s,e);
            }
            if (l.findPPram(right) < min)             right=l.fromPPram(min);
            if (l.findPPram(left) > max)             left=l.fromPPram(max);
          }
          double height=panos.get(p).location.y;
          ToProject out=new ToProject(right,left,0,height + 30);
          if (left.distance(right) > 3) {
            out.toProject.add(panos.get(p));
            megaResults.add(out);
          }
        }
      }
    }
    Collections.sort(megaResults,new Comparator<ToProject>(){
      @Override public int compare(      ToProject o1,      ToProject o2){
        return Double.compare(pram(o1),pram(o2));
      }
      private double pram(      ToProject o1){
        Vector3d pt=o1.toProject.iterator().next().location;
        return megaResults.megafacade.findPPram(new Point2d(pt.x,pt.z));
      }
    }
);
  }
}","public FacadeFinder(LoopL<Point2d> _edges,Map<Point2d,Pano> panos,PlanesGen drawnPlanes){
}",0.0264650283553875
175860,"public Pano query(Score score){
  URL url;
  BufferedReader in=null;
  try {
    url=new URL(""String_Node_Str"" + ""String_Node_Str"" + ll[0] + ""String_Node_Str""+ ll[1]+ ""String_Node_Str"");
    URLConnection urlConnection=url.openConnection();
    urlConnection.setDoInput(true);
    urlConnection.connect();
    in=new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));
    String inputLine;
    StringBuffer sb=new StringBuffer();
    while ((inputLine=in.readLine()) != null)     sb.append(inputLine);
    Pattern pat=Pattern.compile(""String_Node_Str"");
    Matcher m=pat.matcher(sb.toString());
    File panoLoc=new File(Tweed.DATA + File.separator + ""String_Node_Str"");
    double bestScore=-Double.MAX_VALUE;
    Pano bestPano=null;
    while (m.find()) {
      String meta=m.group(0);
      meta=meta.replaceAll(""String_Node_Str"",""String_Node_Str"");
      meta=meta.replaceAll(""String_Node_Str"",""String_Node_Str"");
      meta=meta.replaceAll(""String_Node_Str"",""String_Node_Str"");
      String[] parts=meta.trim().split(""String_Node_Str"");
      String name=""String_Node_Str"";
      for (int i=1; i < parts.length; i++) {
        name+=parts[i] + ""String_Node_Str"";
      }
      name+=parts[0];
      Pano pano=PanoGen.createPanoGen(new File(panoLoc,name + ""String_Node_Str""),""String_Node_Str"");
      double s=score.score(pano);
      if (s > bestScore) {
        bestScore=s;
        bestPano=pano;
      }
    }
    if (bestPano == null)     return null;
    new Mosaic(Collections.singletonList(bestPano.name),panoLoc);
    if (!new File(panoLoc,bestPano.name + ""String_Node_Str"").exists())     return null;
    return bestPano;
  }
 catch (  Throwable th) {
    th.printStackTrace();
  }
 finally {
    if (in != null)     try {
      in.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  return null;
}","public Pano query(Score score){
  URL url;
  BufferedReader in=null;
  try {
    url=new URL(""String_Node_Str"" + ""String_Node_Str"" + ll[0] + ""String_Node_Str""+ ll[1]+ ""String_Node_Str"");
    URLConnection urlConnection=url.openConnection();
    urlConnection.setDoInput(true);
    urlConnection.connect();
    in=new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));
    String inputLine;
    StringBuffer sb=new StringBuffer();
    while ((inputLine=in.readLine()) != null)     sb.append(inputLine);
    Pattern pat=Pattern.compile(""String_Node_Str"");
    Matcher m=pat.matcher(sb.toString());
    File panoLoc=new File(Tweed.DATA + File.separator + ""String_Node_Str"");
    double bestScore=-Double.MAX_VALUE;
    Pano bestPano=null;
    while (m.find()) {
      String meta=m.group(0);
      meta=meta.replaceAll(""String_Node_Str"",""String_Node_Str"");
      meta=meta.replaceAll(""String_Node_Str"",""String_Node_Str"");
      meta=meta.replaceAll(""String_Node_Str"",""String_Node_Str"");
      String[] parts=meta.trim().split(""String_Node_Str"");
      String name=""String_Node_Str"";
      for (int i=1; i < parts.length; i++) {
        name+=parts[i] + ""String_Node_Str"";
      }
      name+=parts[0];
      if (parts[0].length() > 25) {
        System.out.println(""String_Node_Str"");
        continue;
      }
      Pano pano=PanoGen.createPanoGen(new File(panoLoc,name + ""String_Node_Str""),""String_Node_Str"");
      double s=score.score(pano);
      if (s > bestScore) {
        bestScore=s;
        bestPano=pano;
      }
    }
    if (bestPano == null)     return null;
    if (!new File(panoLoc,bestPano.name + ""String_Node_Str"").exists())     return null;
    return bestPano;
  }
 catch (  Throwable th) {
    th.printStackTrace();
  }
 finally {
    if (in != null)     try {
      in.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  return null;
}",0.9535932113497746
175861,"public void simpleUpdate(float tpf){
  if (oldWidth != cam.getWidth() || oldHeight != cam.getHeight()) {
    buildBackground();
    clearBackground();
    oldWidth=cam.getWidth();
    oldHeight=cam.getHeight();
  }
  if (checkForEnd)   if (tool.isDragging()) {
    tool.dragEnd();
  }
  checkForEnd=true;
  TweedSettings.settings.cameraLocation=cam.getLocation();
  TweedSettings.settings.cameraOrientation=cam.getRotation();
}","public void simpleUpdate(float tpf){
  if (oldWidth != cam.getWidth() || oldHeight != cam.getHeight()) {
    buildBackground();
    clearBackground();
    oldWidth=cam.getWidth();
    oldHeight=cam.getHeight();
  }
  if (checkForEnd)   if (tool.isDragging()) {
    tool.dragEnd();
  }
  checkForEnd=true;
  oldCameraLoc=cam.getLocation();
  oldCameraRot=cam.getRotation();
}",0.8739076154806492
175862,"public static void save(boolean backup){
  if (folder != null) {
    settings.genList=TweedFrame.instance.genList.stream().filter(g -> g instanceof ICanSave).collect(Collectors.toList());
    FileOutputStream fos=null;
    try {
      fos=new FileOutputStream(new File(folder,""String_Node_Str"" + (backup ? ""String_Node_Str"" : ""String_Node_Str"")));
      TweedSettings.settings.badGeomAngle=-0.1;
      new XStream(new PureJavaReflectionProvider()).toXML(TweedSettings.settings,fos);
    }
 catch (    Throwable e) {
      e.printStackTrace();
    }
 finally {
      if (fos != null)       try {
        fos.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    if (!backup)     writeRecentFiles();
  }
 else   if (!backup)   JOptionPane.showMessageDialog(null,""String_Node_Str"");
}","public static void save(boolean backup){
  if (folder != null) {
    settings.genList=TweedFrame.instance.genList.stream().filter(g -> g instanceof ICanSave).collect(Collectors.toList());
    FileOutputStream fos=null;
    settings.cameraOrientation=TweedFrame.instance.tweed.oldCameraRot;
    settings.cameraLocation=TweedFrame.instance.tweed.oldCameraLoc;
    try {
      fos=new FileOutputStream(new File(folder,""String_Node_Str"" + (backup ? ""String_Node_Str"" : ""String_Node_Str"")));
      TweedSettings.settings.badGeomAngle=-0.1;
      new XStream(new PureJavaReflectionProvider()).toXML(TweedSettings.settings,fos);
    }
 catch (    Throwable e) {
      e.printStackTrace();
    }
 finally {
      if (fos != null)       try {
        fos.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    if (!backup)     writeRecentFiles();
  }
 else   if (!backup)   JOptionPane.showMessageDialog(null,""String_Node_Str"");
}",0.9220415030846888
175863,"private static void findOcclusions(HalfMesh2 mesh){
  int count=0;
  Set<HalfFace> fc=new HashSet<>();
  for (  HalfFace hf : mesh.faces)   for (  HalfEdge e1 : hf.edges()) {
    Line el1=e1.line();
    for (    HalfFace hf2 : mesh.faces) {
      for (      HalfEdge e2 : hf2.edges())       if (e1 != e2) {
        Line e2l=e2.line();
        if (el1.distance(e2l) < 1 && e2l.absAngle(el1) > Math.PI * 0.7) {
          ((SuperEdge)e1).occlusions.add(e2);
          count++;
          fc.add(hf);
        }
      }
    }
  }
  System.out.println(""String_Node_Str"" + count + ""String_Node_Str""+ fc.size()+ ""String_Node_Str"");
}","private static void findOcclusions(HalfMesh2 mesh){
  for (  HalfFace hf : mesh.faces)   for (  HalfEdge e1 : hf.edges()) {
    Line el1=e1.line();
    for (    HalfFace hf2 : mesh.faces) {
      for (      HalfEdge e2 : hf2.edges())       if (e1 != e2) {
        Line e2l=e2.line();
        if (el1.distance(e2l) < 1 && e2l.absAngle(el1) > Math.PI * 0.7)         ((SuperEdge)e1).occlusions.add(e2);
      }
    }
  }
}",0.8034515819750719
175864,"private void mergeOnProfiles(HalfMesh2 mesh,List<Line> footprint){
  System.out.println(""String_Node_Str"");
  TreeSet<HalfFace> togo=new TreeSet<>((  HalfFace o1,  HalfFace o2) -> Double.compare(o1.area(),o2.area()));
  togo.addAll(mesh.faces);
  int count=0;
  while (!togo.isEmpty()) {
    HalfFace f=togo.pollFirst();
    Cache<HalfEdge,MutableDouble> crossedBy=new Cach<>(e -> new MutableDouble(0));
    for (    HalfEdge e : f) {
      SuperEdge se=(SuperEdge)e;
      if (se.profLine != null) {
        MegaFacade mf=((SuperLine)se.profLine).mega;
        if (mf != null)         for (        Prof p : mf.getTween(se.start,se.end,0)) {
          Line proj=new Line(Pointz.to2(p.to3d(p.get(0))),Pointz.to2(p.to3d(p.get(p.size() - 1))));
          for (          HalfEdge e2 : f) {
            SuperEdge se2=(SuperEdge)e2;
            if (se2.profLine == null && (se2.over == null || ((SuperEdge)se2.over).profLine == null) && e2.over != null && e2.line().intersects(proj) != null && Mathz.inRange(e2.line().absAngle(proj),0.25 * Math.PI,0.75 * Math.PI)) {
              crossedBy.get(e2).d+=TweedSettings.settings.profileHSampleDist;
            }
          }
        }
      }
    }
    count+=crossedBy.cache.size();
    Optional<Map.Entry<HalfEdge,MutableDouble>> longestO=crossedBy.cache.entrySet().stream().filter(e1 -> ((SuperEdge)e1.getKey()).profLine == null && e1.getValue().d > 0).max((e1,e2) -> Double.compare(e1.getValue().d,e2.getValue().d));
    if (longestO.isPresent()) {
      Map.Entry<HalfEdge,MutableDouble> longest=longestO.get();
      if (longest.getValue().d > 0.6 * longest.getKey().length()) {
        HalfFace tgf=longest.getKey().over.face;
        togo.remove(tgf);
        longest.getKey().face.merge(mesh,tgf);
        ((SuperFace)longest.getKey().face).mergeFrom((SuperFace)tgf);
        togo.add(f);
      }
    }
  }
  System.out.println(""String_Node_Str"" + count);
  killDoubleEdges(mesh);
}","private void mergeOnProfiles(HalfMesh2 mesh,List<Line> footprint){
  System.out.println(""String_Node_Str"");
  TreeSet<HalfFace> togo=new TreeSet<>((  HalfFace o1,  HalfFace o2) -> Double.compare(o1.area(),o2.area()));
  togo.addAll(mesh.faces);
  int count=0;
  while (!togo.isEmpty()) {
    HalfFace f=togo.pollFirst();
    Cache<HalfEdge,MutableDouble> crossedBy=new Cach<>(e -> new MutableDouble(0));
    for (    HalfEdge e : f) {
      SuperEdge se=(SuperEdge)e;
      if (se.profLine != null) {
        MegaFacade mf=((SuperLine)se.profLine).mega;
        if (mf != null)         for (        Prof p : mf.getTween(se.start,se.end,0)) {
          Line proj=new Line(Pointz.to2(p.to3d(p.get(0))),Pointz.to2(p.to3d(p.get(p.size() - 1))));
          for (          HalfEdge e2 : f) {
            SuperEdge se2=(SuperEdge)e2;
            if (se2.profLine == null && (se2.over == null || ((SuperEdge)se2.over).profLine == null) && e2.over != null && e2.line().intersects(proj) != null && Mathz.inRange(e2.line().absAngle(proj),0.25 * Math.PI,0.75 * Math.PI)) {
              crossedBy.get(e2).d+=TweedSettings.settings.profileHSampleDist;
            }
          }
        }
      }
    }
    count+=crossedBy.cache.size();
    Optional<Map.Entry<HalfEdge,MutableDouble>> longestO=crossedBy.cache.entrySet().stream().filter(e1 -> ((SuperEdge)e1.getKey()).profLine == null && e1.getValue().d > 0).max((e1,e2) -> Double.compare(e1.getValue().d,e2.getValue().d));
    if (longestO.isPresent()) {
      Map.Entry<HalfEdge,MutableDouble> longest=longestO.get();
      if (longest.getValue().d > 0.6 * longest.getKey().length()) {
        HalfFace tgf=longest.getKey().over.face;
        togo.remove(tgf);
        longest.getKey().face.merge(mesh,tgf);
        ((SuperFace)longest.getKey().face).mergeFrom((SuperFace)tgf);
        togo.add(f);
      }
    }
  }
  killDoubleEdges(mesh);
}",0.987149226330973
175865,"@Override public void calculate(){
  for (  Spatial s : gNode.getChildren())   s.removeFromParent();
  SuperFace sf;
  if (mode == Mode.Extrude) {
    sf=toHalf(Loopz.to3d(Loopz.removeInnerEdges(Loopz.toXZLoop(blockGen.polies)).get(0),0,1));
    PlanSkeleton skel=calc(sf);
    setSkel(skel,skel.output,sf);
  }
 else   for (  Loop<Point3d> loop : blockGen.polies) {
    sf=toHalf(loop);
    PlanSkeleton skel=calc(sf);
    setSkel(skel,skel.output,sf);
  }
  gNode.updateModelBound();
  gNode.updateGeometricState();
  setVisible(visible);
}","@Override public void calculate(){
  for (  Spatial s : gNode.getChildren())   s.removeFromParent();
  SuperFace sf;
  if (mode == Mode.Extrude) {
    sf=toHalf(Loopz.to3d(Loopz.removeInnerEdges(Loopz.toXZLoop(blockGen.polies)).get(0),0,1));
    PlanSkeleton skel=calc(sf);
    setSkel(skel,sf,null);
  }
 else   for (  Loop<Point3d> loop : blockGen.polies) {
    sf=toHalf(loop);
    PlanSkeleton skel=calc(sf);
    setSkel(skel,sf,null);
  }
  gNode.updateModelBound();
  gNode.updateGeometricState();
  setVisible(visible);
}",0.9682242990654204
175866,"public void show(Output output,Skeleton threadKey){
  super.show(output,threadKey);
  tweed.enqueue(new Runnable(){
    @Override public void run(){
      removeGeometryFor(workon);
      tweed.frame.setGenUI(null);
      setSkel((PlanSkeleton)threadKey,output,workon);
    }
  }
);
}","public void show(Output output,Skeleton threadKey){
  super.show(output,threadKey);
  tweed.enqueue(new Runnable(){
    @Override public void run(){
      removeGeometryFor(workon);
      tweed.frame.setGenUI(null);
      setSkel((PlanSkeleton)threadKey,workon,lastOccluders);
    }
  }
);
}",0.942608695652174
175867,"public synchronized void setSkel(PlanSkeleton skel,Output output,SuperFace sf){
  removeGeometryFor(sf);
  Node house;
  OnClick onclick=new OnClick(){
    @Override public void selected(    Output output,    Node house2,    SuperEdge se){
      SkelGen.this.selected(skel,house2,sf,se);
    }
  }
;
  GreebleSkel greeble=new GreebleSkel(tweed);
  house=greeble.showSkeleton(output,onclick);
  gNode.attachChild(house);
  geometry.get(sf).set(house,output,skel);
  tweed.getRootNode().updateGeometricState();
  tweed.getRootNode().updateModelBound();
  tweed.gainFocus();
}","public synchronized void setSkel(PlanSkeleton skel,SuperFace sf,Map<Object,Face> occluderLookup){
  removeGeometryFor(sf);
  Node house;
  OnClick onclick=new OnClick(){
    @Override public void selected(    Output output,    Node house2,    SuperEdge se){
      SkelGen.this.selected(skel,house2,sf,se);
    }
  }
;
  GreebleSkel greeble=new GreebleSkel(tweed);
  house=greeble.showSkeleton(skel.output,onclick,occluderLookup);
  gNode.attachChild(house);
  geometry.get(sf).set(house,skel.output,skel);
  tweed.getRootNode().updateGeometricState();
  tweed.getRootNode().updateModelBound();
  tweed.gainFocus();
}",0.9049621530698064
175868,"@Override public void actionPerformed(ActionEvent e){
  closeSitePlan();
  Plot.closeLast();
  for (  HalfEdge he : sf) {
    SuperEdge ee=(SuperEdge)he;
    if (ee.toEdit != null)     ee.toEdit.texture=null;
  }
  siteplan=new Siteplan(skel.plan,false){
    SuperFace workon=sf;
    public void show(    Output output,    Skeleton threadKey){
      super.show(output,threadKey);
      tweed.enqueue(new Runnable(){
        @Override public void run(){
          removeGeometryFor(workon);
          tweed.frame.setGenUI(null);
          setSkel((PlanSkeleton)threadKey,output,workon);
        }
      }
);
    }
  }
;
  siteplan.setVisible(true);
  siteplan.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
}","@Override public void actionPerformed(ActionEvent e){
  closeSitePlan();
  Plot.closeLast();
  for (  HalfEdge he : sf) {
    SuperEdge ee=(SuperEdge)he;
    if (ee.toEdit != null)     ee.toEdit.texture=null;
  }
  siteplan=new Siteplan(skel.plan,false){
    SuperFace workon=sf;
    public void show(    Output output,    Skeleton threadKey){
      super.show(output,threadKey);
      tweed.enqueue(new Runnable(){
        @Override public void run(){
          removeGeometryFor(workon);
          tweed.frame.setGenUI(null);
          setSkel((PlanSkeleton)threadKey,workon,lastOccluders);
        }
      }
);
    }
  }
;
  siteplan.setVisible(true);
  siteplan.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
}",0.9785763648928818
175869,"@Override public void calculate(){
  for (  Spatial s : gNode.getChildren())   s.removeFromParent();
  Node pNode=new Node();
  if (toRender != null)   for (int i=0; i < toRender.faces.size(); i++)   try {
    HalfFace f=toRender.faces.get(i);
    SuperFace sf=(SuperFace)f;
    Rendered previouslyRendered=geometry.get(sf);
    if (previouslyRendered.skel != null) {
      setSkel(previouslyRendered.skel,previouslyRendered.output,sf);
    }
 else {
      PlanSkeleton skel=calc(sf);
      if (skel != null)       setSkel(skel,skel.output,sf);
    }
  }
 catch (  Throwable th) {
    th.printStackTrace();
  }
  if (!pNode.getChildren().isEmpty())   tweed.frame.addGen(new JmeGen(""String_Node_Str"",tweed,pNode),false);
  gNode.updateModelBound();
  gNode.updateGeometricState();
  super.calculate();
}","@Override public void calculate(){
  for (  Spatial s : gNode.getChildren())   s.removeFromParent();
  Node pNode=new Node();
  if (toRender != null) {
    Map<Object,Face> occluderLookup=lastOccluders=new HashMap<>();
    for (int i=0; i < toRender.faces.size(); i++)     try {
      HalfFace f=toRender.faces.get(i);
      SuperFace sf=(SuperFace)f;
      Rendered previouslyRendered=geometry.get(sf);
      if (previouslyRendered.skel == null)       previouslyRendered.skel=calc(sf);
      if (previouslyRendered.skel != null)       for (      Face ff : previouslyRendered.skel.output.faces.values()) {
        WallTag wt=(WallTag)GreebleHelper.getTag(ff.profile,WallTag.class);
        if (wt != null && ff.parent == null) {
          occluderLookup.put(wt.occlusionID,ff);
        }
      }
    }
 catch (    Throwable th) {
      th.printStackTrace();
    }
    for (int i=0; i < toRender.faces.size(); i++)     try {
      SuperFace sf=(SuperFace)toRender.faces.get(i);
      Rendered previouslyRendered=geometry.get(sf);
      if (previouslyRendered.skel != null)       setSkel(previouslyRendered.skel,sf,occluderLookup);
    }
 catch (    Throwable th) {
      th.printStackTrace();
    }
  }
  if (!pNode.getChildren().isEmpty())   tweed.frame.addGen(new JmeGen(""String_Node_Str"",tweed,pNode),false);
  gNode.updateModelBound();
  gNode.updateGeometricState();
  super.calculate();
}",0.6041002277904328
175870,"private void selected(PlanSkeleton skel,Node house,SuperFace sf,SuperEdge se){
  JPanel ui=new JPanel();
  ui.setLayout(new ListDownLayout());
  JButton fac=new JButton(""String_Node_Str"");
  fac.addActionListener(e -> editFacade(skel,sf,se));
  ui.add(fac);
  JButton proc=new JButton(""String_Node_Str"");
  proc.addActionListener(e -> cgaFacade(skel,sf,se));
  ui.add(proc);
  JButton camp=new JButton(""String_Node_Str"");
  camp.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      closeSitePlan();
      Plot.closeLast();
      for (      HalfEdge he : sf) {
        SuperEdge ee=(SuperEdge)he;
        if (ee.toEdit != null)         ee.toEdit.texture=null;
      }
      siteplan=new Siteplan(skel.plan,false){
        SuperFace workon=sf;
        public void show(        Output output,        Skeleton threadKey){
          super.show(output,threadKey);
          tweed.enqueue(new Runnable(){
            @Override public void run(){
              removeGeometryFor(workon);
              tweed.frame.setGenUI(null);
              setSkel((PlanSkeleton)threadKey,output,workon);
            }
          }
);
        }
      }
;
      siteplan.setVisible(true);
      siteplan.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
    }
  }
);
  ui.add(camp);
  JButton plan=new JButton(""String_Node_Str"");
  plan.addActionListener(e -> new Plot(toRender,footprint));
  ui.add(plan);
  JButton b=new JButton(""String_Node_Str"");
  b.addActionListener(e -> SkelFootprint.debugFindCleanProfiles(footprint,this,new ProgressMonitor(null,""String_Node_Str"",""String_Node_Str"",0,100),tweed));
  ui.add(b);
  JButton c=new JButton(""String_Node_Str"");
  c.addActionListener(e -> skelFootprint.debugCompareProfs(skelFootprint.globalProfs));
  ui.add(c);
  JButton mini=new JButton(""String_Node_Str"");
  mini.addActionListener(e -> new MiniViewer(se));
  if (sf != null)   ui.add(mini);
  JButton prof=new JButton(""String_Node_Str"");
  prof.addActionListener(e -> new ProfileAssignmentViewer(sf,skelFootprint == null ? null : skelFootprint.globalProfs));
  ui.add(prof);
  JButton remove=new JButton(""String_Node_Str"");
  remove.addActionListener(e -> {
    visible=false;
    calculateOnJmeThread();
    tweed.frame.removeGen(SkelGen.this);
  }
);
  ui.add(remove);
  tweed.frame.setGenUI(ui);
}","private void selected(PlanSkeleton skel,Node house,SuperFace sf,SuperEdge se){
  JPanel ui=new JPanel();
  ui.setLayout(new ListDownLayout());
  JButton fac=new JButton(""String_Node_Str"");
  fac.addActionListener(e -> editFacade(skel,sf,se));
  ui.add(fac);
  JButton proc=new JButton(""String_Node_Str"");
  proc.addActionListener(e -> cgaFacade(skel,sf,se));
  ui.add(proc);
  JButton camp=new JButton(""String_Node_Str"");
  camp.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      closeSitePlan();
      Plot.closeLast();
      for (      HalfEdge he : sf) {
        SuperEdge ee=(SuperEdge)he;
        if (ee.toEdit != null)         ee.toEdit.texture=null;
      }
      siteplan=new Siteplan(skel.plan,false){
        SuperFace workon=sf;
        public void show(        Output output,        Skeleton threadKey){
          super.show(output,threadKey);
          tweed.enqueue(new Runnable(){
            @Override public void run(){
              removeGeometryFor(workon);
              tweed.frame.setGenUI(null);
              setSkel((PlanSkeleton)threadKey,workon,lastOccluders);
            }
          }
);
        }
      }
;
      siteplan.setVisible(true);
      siteplan.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
    }
  }
);
  ui.add(camp);
  JButton plan=new JButton(""String_Node_Str"");
  plan.addActionListener(e -> new Plot(toRender,footprint));
  ui.add(plan);
  JButton b=new JButton(""String_Node_Str"");
  b.addActionListener(e -> SkelFootprint.debugFindCleanProfiles(footprint,this,new ProgressMonitor(null,""String_Node_Str"",""String_Node_Str"",0,100),tweed));
  ui.add(b);
  JButton c=new JButton(""String_Node_Str"");
  c.addActionListener(e -> skelFootprint.debugCompareProfs(skelFootprint.globalProfs));
  ui.add(c);
  JButton mini=new JButton(""String_Node_Str"");
  mini.addActionListener(e -> new MiniViewer(se));
  if (sf != null)   ui.add(mini);
  JButton prof=new JButton(""String_Node_Str"");
  prof.addActionListener(e -> new ProfileAssignmentViewer(sf,skelFootprint == null ? null : skelFootprint.globalProfs));
  ui.add(prof);
  JButton remove=new JButton(""String_Node_Str"");
  remove.addActionListener(e -> {
    visible=false;
    calculateOnJmeThread();
    tweed.frame.removeGen(SkelGen.this);
  }
);
  ui.add(remove);
  tweed.frame.setGenUI(ui);
}",0.9934084626833936
175871,"public void editFacade(PlanSkeleton skel,SuperFace sf,SuperEdge se){
  closeSitePlan();
  JToggleButton texture=new JToggleButton(""String_Node_Str"");
  texture.setSelected(se.toEdit != null && se.toEdit.texture != null);
  if (se.toEdit == null) {
    ensureMF(sf,se);
    if (!texture.isSelected())     se.toEdit.groundFloorHeight=2;
  }
  if (texture.isSelected()) {
    patchWallTag(skel,se,se.toEdit);
    se.toEdit.width=se.length();
  }
 else   se.toEdit.texture=null;
  if (se.toEdit.featureGen instanceof CGAMini) {
    ((CGAMini)se.toEdit.featureGen).update();
    se.toEdit.featureGen=new FeatureGenerator(se.toEdit,se.toEdit.featureGen);
  }
  Plot p=new Plot(se.toEdit,texture);
  Changed c=new Changed(){
    @Override public void changed(){
      PaintThing.debug.clear();
      if (texture.isSelected())       new Thread(new Runnable(){
        @Override public void run(){
          Pix2Pix.pix2pix(Collections.singletonList(se.toEdit),new Runnable(){
            public void run(){
              tweed.enqueue(new Runnable(){
                @Override public void run(){
                  setSkel(skel,skel.output,sf);
                  tweed.getRootNode().updateGeometricState();
                }
              }
);
            }
          }
);
        }
      }
).start();
 else {
        se.toEdit.texture=null;
        tweed.enqueue(new Runnable(){
          @Override public void run(){
            setSkel(skel,skel.output,sf);
          }
        }
);
      }
    }
  }
;
  texture.addActionListener(l -> c.changed());
  c.changed();
  p.addEditListener(c);
}","public void editFacade(PlanSkeleton skel,SuperFace sf,SuperEdge se){
  closeSitePlan();
  JToggleButton texture=new JToggleButton(""String_Node_Str"");
  texture.setSelected(se.toEdit != null && se.toEdit.texture != null);
  if (se.toEdit == null) {
    ensureMF(sf,se);
    if (!texture.isSelected())     se.toEdit.groundFloorHeight=2;
  }
  if (texture.isSelected()) {
    patchWallTag(skel,se,se.toEdit);
    se.toEdit.width=se.length();
  }
 else   se.toEdit.texture=null;
  if (se.toEdit.featureGen instanceof CGAMini) {
    ((CGAMini)se.toEdit.featureGen).update();
    se.toEdit.featureGen=new FeatureGenerator(se.toEdit,se.toEdit.featureGen);
  }
  Plot p=new Plot(se.toEdit,texture);
  Changed c=new Changed(){
    @Override public void changed(){
      PaintThing.debug.clear();
      if (texture.isSelected())       new Thread(new Runnable(){
        @Override public void run(){
          Pix2Pix.pix2pix(Collections.singletonList(se.toEdit),new Runnable(){
            public void run(){
              tweed.enqueue(new Runnable(){
                @Override public void run(){
                  setSkel(skel,sf,lastOccluders);
                  tweed.getRootNode().updateGeometricState();
                }
              }
);
            }
          }
);
        }
      }
).start();
 else {
        se.toEdit.texture=null;
        tweed.enqueue(new Runnable(){
          @Override public void run(){
            setSkel(skel,sf,lastOccluders);
          }
        }
);
      }
    }
  }
;
  texture.addActionListener(l -> c.changed());
  c.changed();
  p.addEditListener(c);
}",0.9836065573770492
175872,"private static PlanSkeleton buildCamp(SuperFace sf,Double cap){
  Plan plan=new Plan();
  LoopL<Bar> loopl=new LoopL();
  Loop<Bar> loop=new Loop();
  loopl.add(loop);
  Cache<Point2d,Point2d> cache=new Cache<Point2d,Point2d>(){
    @Override public Point2d create(    Point2d i){
      return new Point2d(i.x,i.y);
    }
  }
;
  LoopL<HalfEdge> edges=sf.findHoles();
  LoopL<Point2d> lpd=new LoopL();
  for (  Loop<HalfEdge> loopHE : edges) {
    Map<Point2d,SuperEdge> ses=new HashMap();
    Loop<Point2d> lp=new Loop();
    lpd.add(lp);
    for (    HalfEdge he : loopHE) {
      SuperEdge se=(SuperEdge)he;
      lp.append(se.start);
      ses.put(se.start,se);
    }
    for (    Loopable<Point2d> lpb : lp.loopableIterator()) {
      Bar b=new Bar(cache.get(lpb.getNext().get()),cache.get(lpb.get()));
      SuperEdge se=ses.get(lpb.get());
      Profile profile=null;
      if (se.prof == null || se.prof.size() < 2) {
        List<Point2d> defpts=new ArrayList<>();
        defpts.add(new Point2d(0,0));
        defpts.add(new Point2d(0,-sf.height * 1.2));
        profile=new Profile(defpts);
      }
 else {
        profile=toProfile(se.prof);
      }
      tagWalls((SuperFace)se.face,profile,se,lpb.get(),lpb.getNext().get());
      plan.addLoop(profile.points.get(0),plan.root,profile);
      b.tags.add(new SETag(se));
      loop.prepend(b);
      plan.profiles.put(b,profile);
    }
  }
  plan.points=loopl;
  if (cap != null) {
    Ship s=new FlatRoofShip(cap,plan);
    for (    Profile prof : plan.profiles.values()) {
      for (      Loop<Bar> lb : prof.points) {
        boolean addedMarker=false;
        for (        Bar b : lb) {
          if (-b.start.y < cap && -b.end.y > cap || (!addedMarker && b == lb.start.getPrev().get())) {
            Marker m=new Marker();
            m.set(b.toLine().xAtY(-cap),-cap);
            m.bar=b;
            m.bar.mould.create(m,null);
            Instance i=s.newInstance();
            i.anchors[0].setProfileGen(m.generator);
            addedMarker=true;
          }
        }
      }
    }
    plan.ships.add(s);
  }
  PlanSkeleton skel=new PlanSkeleton(plan);
  skel.skeleton();
  return skel;
}","private static PlanSkeleton buildCamp(SuperFace sf,Double cap){
  Plan plan=new Plan();
  LoopL<Bar> loopl=new LoopL();
  Loop<Bar> loop=new Loop();
  loopl.add(loop);
  Cache<Point2d,Point2d> cache=new Cache<Point2d,Point2d>(){
    @Override public Point2d create(    Point2d i){
      return new Point2d(i.x,i.y);
    }
  }
;
  LoopL<HalfEdge> edges=sf.findHoles();
  LoopL<Point2d> lpd=new LoopL();
  for (  Loop<HalfEdge> loopHE : edges) {
    Map<Point2d,SuperEdge> ses=new HashMap();
    Loop<Point2d> lp=new Loop();
    lpd.add(lp);
    for (    HalfEdge he : loopHE) {
      SuperEdge se=(SuperEdge)he;
      lp.append(se.start);
      ses.put(se.start,se);
    }
    lp=Loopz.mergeAdjacentEdges2(lp,0.001);
    for (    Loopable<Point2d> lpb : lp.loopableIterator()) {
      Bar b=new Bar(cache.get(lpb.getNext().get()),cache.get(lpb.get()));
      SuperEdge se=ses.get(lpb.get());
      Profile profile=null;
      if (se.prof == null || se.prof.size() < 2) {
        List<Point2d> defpts=new ArrayList<>();
        defpts.add(new Point2d(0,0));
        defpts.add(new Point2d(0,-sf.height * 1.2));
        profile=new Profile(defpts);
      }
 else {
        profile=toProfile(se.prof);
      }
      tagWalls((SuperFace)se.face,profile,se,lpb.get(),lpb.getNext().get());
      plan.addLoop(profile.points.get(0),plan.root,profile);
      b.tags.add(new SETag(se));
      loop.prepend(b);
      plan.profiles.put(b,profile);
    }
  }
  plan.points=loopl;
  if (cap != null) {
    Ship s=new FlatRoofShip(cap,plan);
    for (    Profile prof : plan.profiles.values()) {
      for (      Loop<Bar> lb : prof.points) {
        boolean addedMarker=false;
        for (        Bar b : lb) {
          if (-b.start.y < cap && -b.end.y > cap || (!addedMarker && b == lb.start.getPrev().get())) {
            Marker m=new Marker();
            m.set(b.toLine().xAtY(-cap),-cap);
            m.bar=b;
            m.bar.mould.create(m,null);
            Instance i=s.newInstance();
            i.anchors[0].setProfileGen(m.generator);
            addedMarker=true;
          }
        }
      }
    }
    plan.ships.add(s);
  }
  PlanSkeleton skel=new PlanSkeleton(plan);
  skel.skeleton();
  return skel;
}",0.9899405578417924
175873,"@Override public void changed(){
  PaintThing.debug.clear();
  if (texture.isSelected())   new Thread(new Runnable(){
    @Override public void run(){
      Pix2Pix.pix2pix(Collections.singletonList(se.toEdit),new Runnable(){
        public void run(){
          tweed.enqueue(new Runnable(){
            @Override public void run(){
              setSkel(skel,skel.output,sf);
              tweed.getRootNode().updateGeometricState();
            }
          }
);
        }
      }
);
    }
  }
).start();
 else {
    se.toEdit.texture=null;
    tweed.enqueue(new Runnable(){
      @Override public void run(){
        setSkel(skel,skel.output,sf);
      }
    }
);
  }
}","@Override public void changed(){
  PaintThing.debug.clear();
  if (texture.isSelected())   new Thread(new Runnable(){
    @Override public void run(){
      Pix2Pix.pix2pix(Collections.singletonList(se.toEdit),new Runnable(){
        public void run(){
          tweed.enqueue(new Runnable(){
            @Override public void run(){
              setSkel(skel,sf,lastOccluders);
              tweed.getRootNode().updateGeometricState();
            }
          }
);
        }
      }
);
    }
  }
).start();
 else {
    se.toEdit.texture=null;
    tweed.enqueue(new Runnable(){
      @Override public void run(){
        setSkel(skel,sf,lastOccluders);
      }
    }
);
  }
}",0.9243323442136498
175874,"public void createMesh(Output output){
  float[] roofColor=BLANK_ROOF, wallColor=BLANK_WALL;
  if (output.faces == null)   return;
  double bestWallArea=0, bestRoofArea=0;
  isTextured=false;
  Map<Object,Face> occluderIDs=new HashMap<>();
  for (  Face f : output.faces.values()) {
    double area=Loopz.area3(f.getLoopL());
    Tag t=GreebleHelper.getTag(f.profile,RoofTag.class);
    if (t != null && area > bestRoofArea && ((RoofTag)t).color != null) {
      roofColor=((RoofTag)t).color;
      bestRoofArea=area;
    }
    t=GreebleHelper.getTag(f.profile,WallTag.class);
    WallTag wt=((WallTag)t);
    if (t != null) {
      if (f.parent == null)       for (      Object o : wt.occlusions)       occluderIDs.put(wt.occlusionID,f);
      isTextured|=wt.miniFacade != null && wt.miniFacade.texture != null;
      wt.miniFacade.postState=null;
      if (area > bestWallArea && wt != null) {
        if (wt.color != null)         wallColor=wt.color;
        bestWallArea=area;
      }
    }
  }
  output.addNonSkeletonSharedEdges(new RoofTag(roofColor));
  List<List<Face>> chains=Campz.findChains(output);
  int count=0;
  for (  List<Face> chain : chains) {
    Set<WallTag> opt=chain.stream().flatMap(f -> f.profile.stream()).filter(tag -> tag instanceof WallTag).map(t -> (WallTag)t).collect(Collectors.toSet());
    for (    WallTag wt : opt) {
      MiniFacade mf=wt.miniFacade;
      mf.postState=new PostProcessState();
      Edge e=chain.get(0).edge;
      Line megafacade=new Line(e.end.x,e.end.y,e.start.x,e.start.y);
      double mfl=megafacade.length();
      Vector2d dir=megafacade.dir();
      LinearForm3D lf=new LinearForm3D(new Vector3d(-dir.y,dir.x,0),e.start);
      for (      Face f : chain)       if (GreebleHelper.getTag(f.profile,WallTag.class) != null)       for (      Loop<Point2d> face : projectTo(megafacade,mfl,lf,f))       mf.postState.skelFaces.add(face);
      for (      Object o : wt.occlusions) {
        Face f=occluderIDs.get(o);
        if (f != null) {
          count++;
          mf.postState.occluders.add(projectTo(megafacade,mfl,lf,f));
        }
      }
      mf.postState.outerFacadeRect=GreebleHelper.findRect(mf.postState.skelFaces);
      mf.featureGen.update();
    }
  }
  System.out.println(""String_Node_Str"" + count);
  greebleGrid=new GreebleGrid(tweed,new MMeshBuilderCache());
  edges(output,roofColor);
  for (  List<Face> chain : chains) {
    Optional<Tag> opt=chain.stream().flatMap(f -> f.profile.stream()).filter(tag -> tag instanceof WallTag).findAny();
    WallTag wt=null;
    MiniFacade mf2=null;
    Set<QuadF> features=new HashSet<>();
    Line megafacade=new Line();
    if (opt.isPresent() && (wt=(WallTag)opt.get()).miniFacade != null) {
      mf2=wt.miniFacade;
{
        Edge e=chain.get(0).edge;
        megafacade.set(e.end.x,e.end.y,e.start.x,e.start.y);
      }
      if (TweedSettings.settings.snapFacadeWidth) {
        mf2=new MiniFacade(wt.miniFacade);
        mf2.postState=wt.miniFacade.postState;
        double[] meshSE=findSE(wt.miniFacade,megafacade,chain);
        mf2.scaleX(meshSE[0],meshSE[1]);
      }
      mf2.featureGen.values().stream().flatMap(k -> k.stream()).map(r -> new QuadF(r,megafacade)).forEach(q -> features.add(q));
    }
    for (    Face f : chain) {
      face(f,mf2,features,roofColor,wallColor,megafacade);
    }
    for (    QuadF w : features)     if ((w.original.f == Feature.WINDOW || w.original.f == Feature.SHOP) && w.foundAll()) {
      greebleGrid.createDormerWindow(w,greebleGrid.mbs.WOOD,greebleGrid.mbs.GLASS,(float)wt.sillDepth,(float)wt.sillHeight,(float)wt.corniceHeight,0.6,0.9);
    }
    greebleGrid.attachAll(node,chain,output,new ClickMe(){
      @Override public void clicked(      Object data){
        try {
          SwingUtilities.invokeAndWait(new Runnable(){
            @Override public void run(){
              selected(output,node,findSuperEdge(output,chain));
            }
          }
);
        }
 catch (        Throwable th) {
          th.printStackTrace();
        }
      }
    }
);
  }
}","public void createMesh(Output output,java.util.Map<Object,Face> occluderLookup){
  float[] roofColor=BLANK_ROOF, wallColor=BLANK_WALL;
  if (output.faces == null)   return;
  double bestWallArea=0, bestRoofArea=0;
  isTextured=false;
  for (  Face f : output.faces.values()) {
    double area=Loopz.area3(f.getLoopL());
    Tag t=GreebleHelper.getTag(f.profile,RoofTag.class);
    if (t != null && area > bestRoofArea && ((RoofTag)t).color != null) {
      roofColor=((RoofTag)t).color;
      bestRoofArea=area;
    }
    t=GreebleHelper.getTag(f.profile,WallTag.class);
    WallTag wt=((WallTag)t);
    if (t != null) {
      isTextured|=wt.miniFacade != null && wt.miniFacade.texture != null;
      wt.miniFacade.postState=null;
      if (area > bestWallArea && wt != null) {
        if (wt.color != null)         wallColor=wt.color;
        bestWallArea=area;
      }
    }
  }
  output.addNonSkeletonSharedEdges(new RoofTag(roofColor));
  List<List<Face>> chains=Campz.findChains(output);
  for (  List<Face> chain : chains) {
    Set<WallTag> opt=chain.stream().flatMap(f -> f.profile.stream()).filter(tag -> tag instanceof WallTag).map(t -> (WallTag)t).collect(Collectors.toSet());
    for (    WallTag wt : opt) {
      MiniFacade mf=wt.miniFacade;
      mf.postState=new PostProcessState();
      Edge e=chain.get(0).edge;
      Line megafacade=new Line(e.end.x,e.end.y,e.start.x,e.start.y);
      double mfl=megafacade.length();
      Vector2d dir=megafacade.dir();
      LinearForm3D lf=new LinearForm3D(new Vector3d(-dir.y,dir.x,0),e.start);
      for (      Face f : chain)       if (GreebleHelper.getTag(f.profile,WallTag.class) != null)       for (      Loop<Point2d> face : projectTo(megafacade,mfl,lf,f))       mf.postState.skelFaces.add(face);
      if (occluderLookup != null)       for (      Object o : wt.occlusions) {
        Face f=occluderLookup.get(o);
        if (f != null)         mf.postState.occluders.add(projectTo(megafacade,mfl,lf,f));
      }
      mf.postState.outerFacadeRect=GreebleHelper.findRect(mf.postState.skelFaces);
      mf.featureGen.update();
    }
  }
  greebleGrid=new GreebleGrid(tweed,new MMeshBuilderCache());
  edges(output,roofColor);
  for (  List<Face> chain : chains) {
    Optional<Tag> opt=chain.stream().flatMap(f -> f.profile.stream()).filter(tag -> tag instanceof WallTag).findAny();
    WallTag wt=null;
    MiniFacade mf2=null;
    Set<QuadF> features=new HashSet<>();
    Line megafacade=new Line();
    if (opt.isPresent() && (wt=(WallTag)opt.get()).miniFacade != null) {
      mf2=wt.miniFacade;
{
        Edge e=chain.get(0).edge;
        megafacade.set(e.end.x,e.end.y,e.start.x,e.start.y);
      }
      if (TweedSettings.settings.snapFacadeWidth) {
        mf2=new MiniFacade(wt.miniFacade);
        mf2.postState=wt.miniFacade.postState;
        double[] meshSE=findSE(wt.miniFacade,megafacade,chain);
        mf2.scaleX(meshSE[0],meshSE[1]);
      }
      mf2.featureGen.values().stream().flatMap(k -> k.stream()).map(r -> new QuadF(r,megafacade)).forEach(q -> features.add(q));
    }
    for (    Face f : chain) {
      face(f,mf2,features,roofColor,wallColor,megafacade);
    }
    for (    QuadF w : features)     if ((w.original.f == Feature.WINDOW || w.original.f == Feature.SHOP) && w.foundAll()) {
      greebleGrid.createDormerWindow(w,greebleGrid.mbs.WOOD,greebleGrid.mbs.GLASS,(float)wt.sillDepth,(float)wt.sillHeight,(float)wt.corniceHeight,0.6,0.9);
    }
    greebleGrid.attachAll(node,chain,output,new ClickMe(){
      @Override public void clicked(      Object data){
        try {
          SwingUtilities.invokeAndWait(new Runnable(){
            @Override public void run(){
              selected(output,node,findSuperEdge(output,chain));
            }
          }
);
        }
 catch (        Throwable th) {
          th.printStackTrace();
        }
      }
    }
);
  }
}",0.5037917087967644
175875,"public Node showSkeleton(Output output,OnClick onClick){
  this.onClick=onClick;
  createMesh(output);
  return node;
}","public Node showSkeleton(Output output,OnClick onClick,java.util.Map<Object,Face> occluderLookup){
  this.onClick=onClick;
  createMesh(output,occluderLookup);
  return node;
}",0.8067796610169492
175876,"public void show(Output output,Skeleton threadKey){
  super.show(output,threadKey);
  Plot.closeLast();
  tweed.enqueue(new Runnable(){
    @Override public void run(){
      removeGeometryFor(workon);
      tweed.frame.setGenUI(null);
      setSkel((PlanSkeleton)threadKey,output,workon);
    }
  }
);
}","public void show(Output output,Skeleton threadKey){
  super.show(output,threadKey);
  tweed.enqueue(new Runnable(){
    @Override public void run(){
      removeGeometryFor(workon);
      tweed.frame.setGenUI(null);
      setSkel((PlanSkeleton)threadKey,output,workon);
    }
  }
);
}",0.9659863945578232
175877,"public synchronized void setSkel(PlanSkeleton skel,Output output,SuperFace sf){
  removeGeometryFor(sf);
  Node house;
  OnClick onclick=new OnClick(){
    @Override public void selected(    Output output,    Node house2,    SuperEdge se){
      SkelGen.this.selected(skel,house2,sf,se);
    }
  }
;
  GreebleSkel greeble=new GreebleSkel(tweed);
  house=greeble.showSkeleton(output,onclick);
  gNode.attachChild(house);
  geometry.put(sf,house);
  tweed.getRootNode().updateGeometricState();
  tweed.getRootNode().updateModelBound();
  tweed.gainFocus();
}","public synchronized void setSkel(PlanSkeleton skel,Output output,SuperFace sf){
  removeGeometryFor(sf);
  Node house;
  OnClick onclick=new OnClick(){
    @Override public void selected(    Output output,    Node house2,    SuperEdge se){
      SkelGen.this.selected(skel,house2,sf,se);
    }
  }
;
  GreebleSkel greeble=new GreebleSkel(tweed);
  house=greeble.showSkeleton(output,onclick);
  gNode.attachChild(house);
  geometry.get(sf).set(house,output,skel);
  tweed.getRootNode().updateGeometricState();
  tweed.getRootNode().updateModelBound();
  tweed.gainFocus();
}",0.970770593445527
175878,"@Override public void actionPerformed(ActionEvent e){
  closeSitePlan();
  siteplan=new Siteplan(skel.plan,false){
    SuperFace workon=sf;
    public void show(    Output output,    Skeleton threadKey){
      super.show(output,threadKey);
      Plot.closeLast();
      tweed.enqueue(new Runnable(){
        @Override public void run(){
          removeGeometryFor(workon);
          tweed.frame.setGenUI(null);
          setSkel((PlanSkeleton)threadKey,output,workon);
        }
      }
);
    }
  }
;
  siteplan.setVisible(true);
  siteplan.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
}","@Override public void actionPerformed(ActionEvent e){
  closeSitePlan();
  Plot.closeLast();
  for (  HalfEdge he : sf) {
    SuperEdge ee=(SuperEdge)he;
    if (ee.toEdit != null)     ee.toEdit.texture=null;
  }
  siteplan=new Siteplan(skel.plan,false){
    SuperFace workon=sf;
    public void show(    Output output,    Skeleton threadKey){
      super.show(output,threadKey);
      tweed.enqueue(new Runnable(){
        @Override public void run(){
          removeGeometryFor(workon);
          tweed.frame.setGenUI(null);
          setSkel((PlanSkeleton)threadKey,output,workon);
        }
      }
);
    }
  }
;
  siteplan.setVisible(true);
  siteplan.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
}",0.8640483383685801
175879,"@Override public void calculate(){
  for (  Spatial s : gNode.getChildren())   s.removeFromParent();
  Node pNode=new Node();
  if (toRender != null)   for (int i=0; i < toRender.faces.size(); i++)   try {
    HalfFace f=toRender.faces.get(i);
    SuperFace sf=(SuperFace)f;
    PlanSkeleton skel=calc(sf);
    if (skel != null)     setSkel(skel,skel.output,sf);
  }
 catch (  Throwable th) {
    th.printStackTrace();
  }
  if (!pNode.getChildren().isEmpty())   tweed.frame.addGen(new JmeGen(""String_Node_Str"",tweed,pNode),false);
  gNode.updateModelBound();
  gNode.updateGeometricState();
  super.calculate();
}","@Override public void calculate(){
  for (  Spatial s : gNode.getChildren())   s.removeFromParent();
  Node pNode=new Node();
  if (toRender != null)   for (int i=0; i < toRender.faces.size(); i++)   try {
    HalfFace f=toRender.faces.get(i);
    SuperFace sf=(SuperFace)f;
    Rendered previouslyRendered=geometry.get(sf);
    if (previouslyRendered.skel != null) {
      setSkel(previouslyRendered.skel,previouslyRendered.output,sf);
    }
 else {
      PlanSkeleton skel=calc(sf);
      if (skel != null)       setSkel(skel,skel.output,sf);
    }
  }
 catch (  Throwable th) {
    th.printStackTrace();
  }
  if (!pNode.getChildren().isEmpty())   tweed.frame.addGen(new JmeGen(""String_Node_Str"",tweed,pNode),false);
  gNode.updateModelBound();
  gNode.updateGeometricState();
  super.calculate();
}",0.7951977401129944
175880,"private void selected(PlanSkeleton skel,Node house,SuperFace sf,SuperEdge se){
  JPanel ui=new JPanel();
  ui.setLayout(new ListDownLayout());
  JButton fac=new JButton(""String_Node_Str"");
  fac.addActionListener(e -> editFacade(skel,sf,se,false));
  ui.add(fac);
  JButton tex=new JButton(""String_Node_Str"");
  tex.addActionListener(e -> editFacade(skel,sf,se,true));
  ui.add(tex);
  JButton proc=new JButton(""String_Node_Str"");
  proc.addActionListener(e -> cgaFacade(skel,sf,se));
  ui.add(proc);
  JButton camp=new JButton(""String_Node_Str"");
  camp.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      closeSitePlan();
      siteplan=new Siteplan(skel.plan,false){
        SuperFace workon=sf;
        public void show(        Output output,        Skeleton threadKey){
          super.show(output,threadKey);
          Plot.closeLast();
          tweed.enqueue(new Runnable(){
            @Override public void run(){
              removeGeometryFor(workon);
              tweed.frame.setGenUI(null);
              setSkel((PlanSkeleton)threadKey,output,workon);
            }
          }
);
        }
      }
;
      siteplan.setVisible(true);
      siteplan.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
    }
  }
);
  ui.add(camp);
  JButton plan=new JButton(""String_Node_Str"");
  plan.addActionListener(e -> new Plot(toRender,footprint));
  ui.add(plan);
  JButton b=new JButton(""String_Node_Str"");
  b.addActionListener(e -> SkelFootprint.debugFindCleanProfiles(footprint,this,new ProgressMonitor(null,""String_Node_Str"",""String_Node_Str"",0,100),tweed));
  ui.add(b);
  JButton c=new JButton(""String_Node_Str"");
  c.addActionListener(e -> skelFootprint.debugCompareProfs(skelFootprint.globalProfs));
  ui.add(c);
  JButton mini=new JButton(""String_Node_Str"");
  mini.addActionListener(e -> new MiniViewer(se));
  if (sf != null)   ui.add(mini);
  JButton prof=new JButton(""String_Node_Str"");
  prof.addActionListener(e -> new ProfileAssignmentViewer(sf,skelFootprint == null ? null : skelFootprint.globalProfs));
  ui.add(prof);
  JButton remove=new JButton(""String_Node_Str"");
  remove.addActionListener(e -> {
    visible=false;
    calculateOnJmeThread();
    tweed.frame.removeGen(SkelGen.this);
  }
);
  ui.add(remove);
  tweed.frame.setGenUI(ui);
}","private void selected(PlanSkeleton skel,Node house,SuperFace sf,SuperEdge se){
  JPanel ui=new JPanel();
  ui.setLayout(new ListDownLayout());
  JButton fac=new JButton(""String_Node_Str"");
  fac.addActionListener(e -> editFacade(skel,sf,se));
  ui.add(fac);
  JButton proc=new JButton(""String_Node_Str"");
  proc.addActionListener(e -> cgaFacade(skel,sf,se));
  ui.add(proc);
  JButton camp=new JButton(""String_Node_Str"");
  camp.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      closeSitePlan();
      Plot.closeLast();
      for (      HalfEdge he : sf) {
        SuperEdge ee=(SuperEdge)he;
        if (ee.toEdit != null)         ee.toEdit.texture=null;
      }
      siteplan=new Siteplan(skel.plan,false){
        SuperFace workon=sf;
        public void show(        Output output,        Skeleton threadKey){
          super.show(output,threadKey);
          tweed.enqueue(new Runnable(){
            @Override public void run(){
              removeGeometryFor(workon);
              tweed.frame.setGenUI(null);
              setSkel((PlanSkeleton)threadKey,output,workon);
            }
          }
);
        }
      }
;
      siteplan.setVisible(true);
      siteplan.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
    }
  }
);
  ui.add(camp);
  JButton plan=new JButton(""String_Node_Str"");
  plan.addActionListener(e -> new Plot(toRender,footprint));
  ui.add(plan);
  JButton b=new JButton(""String_Node_Str"");
  b.addActionListener(e -> SkelFootprint.debugFindCleanProfiles(footprint,this,new ProgressMonitor(null,""String_Node_Str"",""String_Node_Str"",0,100),tweed));
  ui.add(b);
  JButton c=new JButton(""String_Node_Str"");
  c.addActionListener(e -> skelFootprint.debugCompareProfs(skelFootprint.globalProfs));
  ui.add(c);
  JButton mini=new JButton(""String_Node_Str"");
  mini.addActionListener(e -> new MiniViewer(se));
  if (sf != null)   ui.add(mini);
  JButton prof=new JButton(""String_Node_Str"");
  prof.addActionListener(e -> new ProfileAssignmentViewer(sf,skelFootprint == null ? null : skelFootprint.globalProfs));
  ui.add(prof);
  JButton remove=new JButton(""String_Node_Str"");
  remove.addActionListener(e -> {
    visible=false;
    calculateOnJmeThread();
    tweed.frame.removeGen(SkelGen.this);
  }
);
  ui.add(remove);
  tweed.frame.setGenUI(ui);
}",0.914139256727894
175881,"public void editFacade(PlanSkeleton skel,SuperFace sf,SuperEdge se,boolean texture){
  closeSitePlan();
  if (se.toEdit == null) {
    ensureMF(sf,se);
    if (!texture)     se.toEdit.groundFloorHeight=2;
  }
  if (texture) {
    patchWallTag(skel,se,se.toEdit);
    se.toEdit.width=se.length();
  }
 else   se.toEdit.texture=null;
  Plot p=new Plot(se.toEdit);
  Changed c=new Changed(){
    @Override public void changed(){
      PaintThing.debug.clear();
      if (texture)       new Thread(new Runnable(){
        @Override public void run(){
          Pix2Pix.pix2pix(Collections.singletonList(se.toEdit),new Runnable(){
            public void run(){
              tweed.enqueue(new Runnable(){
                @Override public void run(){
                  setSkel(skel,skel.output,sf);
                  tweed.getRootNode().updateGeometricState();
                }
              }
);
            }
          }
);
        }
      }
).start();
 else       tweed.enqueue(new Runnable(){
        @Override public void run(){
          setSkel(skel,skel.output,sf);
        }
      }
);
    }
  }
;
  c.changed();
  p.addEditListener(c);
}","public void editFacade(PlanSkeleton skel,SuperFace sf,SuperEdge se){
  closeSitePlan();
  JToggleButton texture=new JToggleButton(""String_Node_Str"");
  texture.setSelected(se.toEdit != null && se.toEdit.texture != null);
  if (se.toEdit == null) {
    ensureMF(sf,se);
    if (!texture.isSelected())     se.toEdit.groundFloorHeight=2;
  }
  if (texture.isSelected()) {
    patchWallTag(skel,se,se.toEdit);
    se.toEdit.width=se.length();
  }
 else   se.toEdit.texture=null;
  if (se.toEdit.featureGen instanceof CGAMini) {
    ((CGAMini)se.toEdit.featureGen).update();
    se.toEdit.featureGen=new FeatureGenerator(se.toEdit,se.toEdit.featureGen);
  }
  Plot p=new Plot(se.toEdit,texture);
  Changed c=new Changed(){
    @Override public void changed(){
      PaintThing.debug.clear();
      if (texture.isSelected())       new Thread(new Runnable(){
        @Override public void run(){
          Pix2Pix.pix2pix(Collections.singletonList(se.toEdit),new Runnable(){
            public void run(){
              tweed.enqueue(new Runnable(){
                @Override public void run(){
                  setSkel(skel,skel.output,sf);
                  tweed.getRootNode().updateGeometricState();
                }
              }
);
            }
          }
);
        }
      }
).start();
 else {
        se.toEdit.texture=null;
        tweed.enqueue(new Runnable(){
          @Override public void run(){
            setSkel(skel,skel.output,sf);
          }
        }
);
      }
    }
  }
;
  texture.addActionListener(l -> c.changed());
  c.changed();
  p.addEditListener(c);
}",0.8177484415108177
175882,"private void cgaAll(){
  List<MiniFacade> mfs=new ArrayList<>();
  for (  HalfFace hf : toRender)   for (  HalfEdge he : hf) {
    SuperEdge se=(SuperEdge)he;
    ensureMF((SuperFace)hf,se);
    mfs.add(se.toEdit);
    se.toEdit.featureGen=new CGAMini(se.toEdit);
  }
  new Thread(new Runnable(){
    @Override public void run(){
      Pix2Pix.pix2pix(mfs,new Runnable(){
        public void run(){
          tweed.enqueue(new Runnable(){
            @Override public void run(){
              calculateOnJmeThread();
            }
          }
);
        }
      }
);
    }
  }
).start();
}","private void cgaAll(){
  for (  HalfFace hf : toRender)   for (  HalfEdge he : hf) {
    SuperEdge se=(SuperEdge)he;
    ensureMF((SuperFace)hf,se);
    se.toEdit.featureGen=new CGAMini(se.toEdit);
    se.toEdit.featureGen.update();
  }
  calculateOnJmeThread();
}",0.5362997658079626
175883,"private void removeGeometryFor(SuperFace sf){
  if (geometry.get(sf) != null) {
    geometry.get(sf).removeFromParent();
    geometry.remove(sf);
  }
}","private void removeGeometryFor(SuperFace sf){
  Rendered rd=geometry.get(sf);
  if (rd != null) {
    if (rd.node != null) {
      rd.node.removeFromParent();
      rd.node=null;
    }
  }
}",0.6862170087976539
175884,"@Override public JComponent getUI(){
  JPanel ui=new JPanel(new ListDownLayout());
  ui.add(new JLabel(""String_Node_Str""));
  JButton compare=new JButton(""String_Node_Str"");
  compare.addActionListener(l -> new CompareGens(this,blockGen));
  ui.add(compare);
  JButton pf=new JButton(""String_Node_Str"");
  pf.addActionListener(l -> cgaAll());
  ui.add(pf);
  return ui;
}","@Override public JComponent getUI(){
  JPanel ui=new JPanel(new ListDownLayout());
  ui.add(new JLabel(""String_Node_Str""));
  JButton compare=new JButton(""String_Node_Str"");
  compare.addActionListener(l -> new CompareGens(this,blockGen));
  ui.add(compare);
  JButton pf=new JButton(""String_Node_Str"");
  pf.addActionListener(l -> cgaAll());
  ui.add(pf);
  JButton tf=new JButton(""String_Node_Str"");
  tf.addActionListener(l -> textureAll());
  ui.add(tf);
  return ui;
}",0.8791469194312796
175885,"private void cgaFacade(PlanSkeleton skel,SuperFace sf,SuperEdge se){
  ensureMF(sf,se);
  se.toEdit.featureGen=new CGAMini(se.toEdit);
  patchWallTag(skel,se,se.toEdit);
}","private void cgaFacade(PlanSkeleton skel,SuperFace sf,SuperEdge se){
  ensureMF(sf,se);
  se.toEdit.featureGen=new CGAMini(se.toEdit);
  se.toEdit.featureGen.update();
  patchWallTag(skel,se,se.toEdit);
  calculateOnJmeThread();
}",0.8528678304239401
175886,"@Override public void changed(){
  PaintThing.debug.clear();
  if (texture)   new Thread(new Runnable(){
    @Override public void run(){
      Pix2Pix.pix2pix(Collections.singletonList(se.toEdit),new Runnable(){
        public void run(){
          tweed.enqueue(new Runnable(){
            @Override public void run(){
              setSkel(skel,skel.output,sf);
              tweed.getRootNode().updateGeometricState();
            }
          }
);
        }
      }
);
    }
  }
).start();
 else   tweed.enqueue(new Runnable(){
    @Override public void run(){
      setSkel(skel,skel.output,sf);
    }
  }
);
}","@Override public void changed(){
  PaintThing.debug.clear();
  if (texture.isSelected())   new Thread(new Runnable(){
    @Override public void run(){
      Pix2Pix.pix2pix(Collections.singletonList(se.toEdit),new Runnable(){
        public void run(){
          tweed.enqueue(new Runnable(){
            @Override public void run(){
              setSkel(skel,skel.output,sf);
              tweed.getRootNode().updateGeometricState();
            }
          }
);
        }
      }
);
    }
  }
).start();
 else {
    se.toEdit.texture=null;
    tweed.enqueue(new Runnable(){
      @Override public void run(){
        setSkel(skel,skel.output,sf);
      }
    }
);
  }
}",0.9401709401709402
175887,"public void simpleUpdate(float tpf){
  if (oldWidth != cam.getWidth() || oldHeight != cam.getHeight()) {
    buildBackground();
    oldWidth=cam.getWidth();
    oldHeight=cam.getHeight();
  }
  if (checkForEnd)   if (tool.isDragging()) {
    tool.dragEnd();
  }
  checkForEnd=true;
  TweedSettings.settings.cameraLocation=cam.getLocation();
  TweedSettings.settings.cameraOrientation=cam.getRotation();
}","public void simpleUpdate(float tpf){
  if (oldWidth != cam.getWidth() || oldHeight != cam.getHeight()) {
    buildBackground();
    clearBackground();
    oldWidth=cam.getWidth();
    oldHeight=cam.getHeight();
  }
  if (checkForEnd)   if (tool.isDragging()) {
    tool.dragEnd();
  }
  checkForEnd=true;
  TweedSettings.settings.cameraLocation=cam.getLocation();
  TweedSettings.settings.cameraOrientation=cam.getRotation();
}",0.9723225030084236
175888,"public static void loadDefault(){
  if (recentFiles == null) {
    try {
      recentFiles=(RecentFiles)new XStream().fromXML(RECENT_FILE_LOCATION);
    }
 catch (    Throwable th) {
      System.out.println(""String_Node_Str"");
      recentFiles=new RecentFiles();
    }
  }
  if (!recentFiles.f.isEmpty()) {
    File last=recentFiles.f.get(0);
    if (last.exists())     load(last);
 else {
      JOptionPane.showMessageDialog(null,""String_Node_Str"" + last.getName());
      recentFiles.f.remove(0);
    }
  }
}","public static void loadDefault(){
  if (recentFiles == null) {
    try {
      recentFiles=(RecentFiles)new XStream().fromXML(RECENT_FILE_LOCATION);
    }
 catch (    Throwable th) {
      System.out.println(""String_Node_Str"");
      recentFiles=new RecentFiles();
    }
  }
  if (!recentFiles.f.isEmpty()) {
    File last=recentFiles.f.get(0);
    if (last.exists())     load(last);
 else {
      JOptionPane.showMessageDialog(null,""String_Node_Str"" + last.getName() + ""String_Node_Str"");
      recentFiles.f.remove(0);
    }
  }
}",0.9808429118773946
175889,"public static ImageFeatures readFeatures(File fFolder,MegaFeatures megaFeatures){
  Line mega=new Line(megaFeatures.megafacade);
  ImageFeatures out=new ImageFeatures();
  out.mega=megaFeatures;
  Line imageL=null;
  out.miniFacades=new ArrayList();
  double ppm=40;
{
    if (Tweed.DATA == null)     out.ortho=new File(fFolder,RENDERED_IMAGE_PNG);
 else     out.ortho=Paths.get(Tweed.DATA).relativize(new File(fFolder,RENDERED_IMAGE_PNG).toPath()).toFile();
    File rectFile=new File(fFolder,""String_Node_Str"");
    if (rectFile.exists()) {
      if (Tweed.DATA == null)       out.rectified=rectFile;
 else       out.rectified=Paths.get(Tweed.DATA).relativize(rectFile.toPath()).toFile();
    }
 else     out.rectified=out.ortho;
  }
  int imageWidth=out.getRectified().getWidth(), imageHeight=out.getRectified().getHeight();
  double rectifiedToOrtho=out.getRectified().getWidth() / (double)out.getOrtho().getWidth();
{
    List<String> lines=null;
    try {
      lines=Files.readAllLines(new File(fFolder,""String_Node_Str"").toPath());
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"");
    }
    if (lines == null) {
      System.out.println(""String_Node_Str"" + fFolder);
      imageL=new Line(0,0,out.getRectified().getWidth() / ppm,0);
    }
 else {
      String plane=lines.get(1);
      String[] pVals=plane.split(""String_Node_Str"");
      Point2d a=new Point2d(Float.parseFloat(pVals[0]),Float.parseFloat(pVals[1]));
      Point2d b=new Point2d(Float.parseFloat(pVals[2]),Float.parseFloat(pVals[3]));
      imageL=new Line(a,b);
    }
  }
  out.start=mega.findPPram(imageL.start) * mega.length();
  out.end=mega.findPPram(imageL.end) * mega.length();
  try {
    File yFile=new File(fFolder,PARAMETERS_YML);
    if (yFile.exists()) {
      YamlReader fromVision=new YamlReader(new FileReader(yFile));
      Map m=(Map)fromVision.read();
      List yamlFac=(List)m.get(""String_Node_Str"");
      double maxW=0;
      if (yamlFac != null) {
        for (        Object o : yamlFac)         try {
          MiniFacade mf=new MiniFacade(out,(Map)o,imageWidth / (rectifiedToOrtho * ppm),imageHeight / ppm,rectifiedToOrtho * ppm,out.start);
          if (!mf.invalid())           out.miniFacades.add(mf);
          maxW=Math.max(maxW,(mf.left + mf.width - out.start));
        }
 catch (        Throwable th) {
          System.out.println(""String_Node_Str"" + yFile);
          th.printStackTrace();
        }
      }
    }
 else     System.out.println(""String_Node_Str"" + fFolder);
  }
 catch (  Throwable e) {
    e.printStackTrace();
  }
  return out;
}","public static ImageFeatures readFeatures(File fFolder,MegaFeatures megaFeatures){
  Line mega=new Line(megaFeatures.megafacade);
  ImageFeatures out=new ImageFeatures();
  out.mega=megaFeatures;
  Line imageL=null;
  out.miniFacades=new ArrayList();
{
    if (Tweed.DATA == null)     out.ortho=new File(fFolder,RENDERED_IMAGE_PNG);
 else     out.ortho=Paths.get(Tweed.DATA).relativize(new File(fFolder,RENDERED_IMAGE_PNG).toPath()).toFile();
    File rectFile=new File(fFolder,""String_Node_Str"");
    if (rectFile.exists()) {
      if (Tweed.DATA == null)       out.rectified=rectFile;
 else       out.rectified=Paths.get(Tweed.DATA).relativize(rectFile.toPath()).toFile();
    }
 else     out.rectified=out.ortho;
  }
  int imageWidth=out.getRectified().getWidth(), imageHeight=out.getRectified().getHeight();
  double rectifiedToOrtho=out.getRectified().getWidth() / (double)out.getOrtho().getWidth();
{
    List<String> lines=null;
    try {
      lines=Files.readAllLines(new File(fFolder,""String_Node_Str"").toPath());
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"");
    }
    if (lines == null) {
      System.out.println(""String_Node_Str"" + fFolder);
      imageL=new Line(0,0,out.getRectified().getWidth() / FacadeTool.pixelsPerMeter,0);
    }
 else {
      String plane=lines.get(1);
      String[] pVals=plane.split(""String_Node_Str"");
      Point2d a=new Point2d(Float.parseFloat(pVals[0]),Float.parseFloat(pVals[1]));
      Point2d b=new Point2d(Float.parseFloat(pVals[2]),Float.parseFloat(pVals[3]));
      imageL=new Line(a,b);
    }
  }
  out.start=mega.findPPram(imageL.start) * mega.length();
  out.end=mega.findPPram(imageL.end) * mega.length();
  try {
    File yFile=new File(fFolder,PARAMETERS_YML);
    if (yFile.exists()) {
      YamlReader fromVision=new YamlReader(new FileReader(yFile));
      Map m=(Map)fromVision.read();
      List yamlFac=(List)m.get(""String_Node_Str"");
      double maxW=0;
      if (yamlFac != null) {
        for (        Object o : yamlFac)         try {
          MiniFacade mf=new MiniFacade(out,(Map)o,imageWidth / (rectifiedToOrtho * FacadeTool.pixelsPerMeter),imageHeight / FacadeTool.pixelsPerMeter,rectifiedToOrtho * FacadeTool.pixelsPerMeter,out.start);
          if (!mf.invalid())           out.miniFacades.add(mf);
          maxW=Math.max(maxW,(mf.left + mf.width - out.start));
        }
 catch (        Throwable th) {
          System.out.println(""String_Node_Str"" + yFile);
          th.printStackTrace();
        }
      }
    }
 else     System.out.println(""String_Node_Str"" + fFolder);
  }
 catch (  Throwable e) {
    e.printStackTrace();
  }
  return out;
}",0.9635982466171146
175890,"@Override public void accept(String line){
  if (line.startsWith(""String_Node_Str""))   return;
  double ppm=40;
  String[] vals=line.split(""String_Node_Str"");
  try {
    windows.add(new Window(30 - Double.parseDouble(vals[0]) / ppm,Double.parseDouble(vals[1]) / ppm,30 - Double.parseDouble(vals[2]) / ppm,Double.parseDouble(vals[3]) / ppm));
  }
 catch (  Throwable th) {
    System.err.println(""String_Node_Str"" + line + ""String_Node_Str"");
    th.printStackTrace();
  }
}","@Override public void accept(String line){
  if (line.startsWith(""String_Node_Str""))   return;
  String[] vals=line.split(""String_Node_Str"");
  try {
    windows.add(new Window(30 - Double.parseDouble(vals[0]) / FacadeTool.pixelsPerMeter,Double.parseDouble(vals[1]) / FacadeTool.pixelsPerMeter,30 - Double.parseDouble(vals[2]) / FacadeTool.pixelsPerMeter,Double.parseDouble(vals[3]) / FacadeTool.pixelsPerMeter));
  }
 catch (  Throwable th) {
    System.err.println(""String_Node_Str"" + line + ""String_Node_Str"");
    th.printStackTrace();
  }
}",0.873405299313052
175891,"@Override public JComponent getUI(){
  JPanel out=new JPanel(new ListDownLayout());
  JButton render=new JButton(""String_Node_Str"");
  render.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      int c=0;
      for (      Pano pg : nearby)       render(new File(Tweed.DATA + ""String_Node_Str"" + (c++)),40f,pg,null,FeatureCache.RENDERED_IMAGE);
    }
  }
);
  out.add(render);
  JButton load=new JButton(""String_Node_Str"");
  load.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      JFileChooser fileChooser=new JFileChooser(lastLocation == null ? new File((System.getProperty(""String_Node_Str"") + ""String_Node_Str"")) : lastLocation);
      fileChooser.setFileFilter(new FileFilter(){
        @Override public String getDescription(){
          return ""String_Node_Str"";
        }
        @Override public boolean accept(        File f){
          return f.isDirectory() || f.getName().toLowerCase().endsWith(""String_Node_Str"");
        }
      }
);
      if (fileChooser.showOpenDialog(out) == JFileChooser.APPROVE_OPTION) {
        windows.clear();
        File csv=fileChooser.getSelectedFile();
        lastLocation=csv.getParentFile();
        try (Stream<String> stream=Files.lines(csv.toPath())){
          stream.forEach(new Consumer<String>(){
            @Override public void accept(            String line){
              if (line.startsWith(""String_Node_Str""))               return;
              double ppm=40;
              String[] vals=line.split(""String_Node_Str"");
              try {
                windows.add(new Window(30 - Double.parseDouble(vals[0]) / ppm,Double.parseDouble(vals[1]) / ppm,30 - Double.parseDouble(vals[2]) / ppm,Double.parseDouble(vals[3]) / ppm));
              }
 catch (              Throwable th) {
                System.err.println(""String_Node_Str"" + line + ""String_Node_Str"");
                th.printStackTrace();
              }
            }
          }
);
        }
 catch (        Throwable th) {
          th.printStackTrace();
        }
      }
      calculateOnJmeThread();
    }
  }
);
  out.add(load);
  return out;
}","@Override public JComponent getUI(){
  JPanel out=new JPanel(new ListDownLayout());
  JButton render=new JButton(""String_Node_Str"");
  render.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      int c=0;
      for (      Pano pg : nearby)       render(new File(Tweed.DATA + ""String_Node_Str"" + (c++)),FacadeTool.pixelsPerMeter,pg,null,FeatureCache.RENDERED_IMAGE);
    }
  }
);
  out.add(render);
  JButton load=new JButton(""String_Node_Str"");
  load.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      JFileChooser fileChooser=new JFileChooser(lastLocation == null ? new File((System.getProperty(""String_Node_Str"") + ""String_Node_Str"")) : lastLocation);
      fileChooser.setFileFilter(new FileFilter(){
        @Override public String getDescription(){
          return ""String_Node_Str"";
        }
        @Override public boolean accept(        File f){
          return f.isDirectory() || f.getName().toLowerCase().endsWith(""String_Node_Str"");
        }
      }
);
      if (fileChooser.showOpenDialog(out) == JFileChooser.APPROVE_OPTION) {
        windows.clear();
        File csv=fileChooser.getSelectedFile();
        lastLocation=csv.getParentFile();
        try (Stream<String> stream=Files.lines(csv.toPath())){
          stream.forEach(new Consumer<String>(){
            @Override public void accept(            String line){
              if (line.startsWith(""String_Node_Str""))               return;
              String[] vals=line.split(""String_Node_Str"");
              try {
                windows.add(new Window(30 - Double.parseDouble(vals[0]) / FacadeTool.pixelsPerMeter,Double.parseDouble(vals[1]) / FacadeTool.pixelsPerMeter,30 - Double.parseDouble(vals[2]) / FacadeTool.pixelsPerMeter,Double.parseDouble(vals[3]) / FacadeTool.pixelsPerMeter));
              }
 catch (              Throwable th) {
                System.err.println(""String_Node_Str"" + line + ""String_Node_Str"");
                th.printStackTrace();
              }
            }
          }
);
        }
 catch (        Throwable th) {
          th.printStackTrace();
        }
      }
      calculateOnJmeThread();
    }
  }
);
  out.add(load);
  return out;
}",0.9620650953984288
175892,"@Override public void actionPerformed(ActionEvent e){
  JFileChooser fileChooser=new JFileChooser(lastLocation == null ? new File((System.getProperty(""String_Node_Str"") + ""String_Node_Str"")) : lastLocation);
  fileChooser.setFileFilter(new FileFilter(){
    @Override public String getDescription(){
      return ""String_Node_Str"";
    }
    @Override public boolean accept(    File f){
      return f.isDirectory() || f.getName().toLowerCase().endsWith(""String_Node_Str"");
    }
  }
);
  if (fileChooser.showOpenDialog(out) == JFileChooser.APPROVE_OPTION) {
    windows.clear();
    File csv=fileChooser.getSelectedFile();
    lastLocation=csv.getParentFile();
    try (Stream<String> stream=Files.lines(csv.toPath())){
      stream.forEach(new Consumer<String>(){
        @Override public void accept(        String line){
          if (line.startsWith(""String_Node_Str""))           return;
          double ppm=40;
          String[] vals=line.split(""String_Node_Str"");
          try {
            windows.add(new Window(30 - Double.parseDouble(vals[0]) / ppm,Double.parseDouble(vals[1]) / ppm,30 - Double.parseDouble(vals[2]) / ppm,Double.parseDouble(vals[3]) / ppm));
          }
 catch (          Throwable th) {
            System.err.println(""String_Node_Str"" + line + ""String_Node_Str"");
            th.printStackTrace();
          }
        }
      }
);
    }
 catch (    Throwable th) {
      th.printStackTrace();
    }
  }
  calculateOnJmeThread();
}","@Override public void actionPerformed(ActionEvent e){
  JFileChooser fileChooser=new JFileChooser(lastLocation == null ? new File((System.getProperty(""String_Node_Str"") + ""String_Node_Str"")) : lastLocation);
  fileChooser.setFileFilter(new FileFilter(){
    @Override public String getDescription(){
      return ""String_Node_Str"";
    }
    @Override public boolean accept(    File f){
      return f.isDirectory() || f.getName().toLowerCase().endsWith(""String_Node_Str"");
    }
  }
);
  if (fileChooser.showOpenDialog(out) == JFileChooser.APPROVE_OPTION) {
    windows.clear();
    File csv=fileChooser.getSelectedFile();
    lastLocation=csv.getParentFile();
    try (Stream<String> stream=Files.lines(csv.toPath())){
      stream.forEach(new Consumer<String>(){
        @Override public void accept(        String line){
          if (line.startsWith(""String_Node_Str""))           return;
          String[] vals=line.split(""String_Node_Str"");
          try {
            windows.add(new Window(30 - Double.parseDouble(vals[0]) / FacadeTool.pixelsPerMeter,Double.parseDouble(vals[1]) / FacadeTool.pixelsPerMeter,30 - Double.parseDouble(vals[2]) / FacadeTool.pixelsPerMeter,Double.parseDouble(vals[3]) / FacadeTool.pixelsPerMeter));
          }
 catch (          Throwable th) {
            System.err.println(""String_Node_Str"" + line + ""String_Node_Str"");
            th.printStackTrace();
          }
        }
      }
);
    }
 catch (    Throwable th) {
      th.printStackTrace();
    }
  }
  calculateOnJmeThread();
}",0.9541652726664436
175893,"public AlignStandalone2d(String folder){
  super(new BorderLayout());
  TweedSettings.load(new File(folder).getParentFile());
  this.folder=folder;
  add(plot,BorderLayout.CENTER);
  JPanel controls=new JPanel(new ListDownLayout());
  add(controls,BorderLayout.EAST);
  facadeFolders=new ArrayList(Arrays.asList(new File(folder).listFiles()));
  Collections.sort(facadeFolders,FILE_COMPARATOR);
  facadeSlide=new JSlider(0,facadeFolders.size() - 1,0);
  controls.add(facadeSlide);
  facadeSlide.addChangeListener(new ChangeListener(){
    @Override public void stateChanged(    ChangeEvent e){
      setFolder(facadeFolders.get(facadeSlide.getValue()));
    }
  }
);
  imageSlide=new JSlider(-1,1);
  controls.add(imageSlide);
  imageSlide.addChangeListener(new ChangeListener(){
    @Override public void stateChanged(    ChangeEvent e){
      plot();
    }
  }
);
}","public AlignStandalone2d(String folder){
  super(new BorderLayout());
  this.folder=folder;
  add(plot,BorderLayout.CENTER);
  JPanel controls=new JPanel(new ListDownLayout());
  add(controls,BorderLayout.EAST);
  facadeFolders=new ArrayList(Arrays.asList(new File(folder).listFiles()));
  Collections.sort(facadeFolders,FILE_COMPARATOR);
  facadeSlide=new JSlider(0,facadeFolders.size() - 1,0);
  controls.add(facadeSlide);
  facadeSlide.addChangeListener(new ChangeListener(){
    @Override public void stateChanged(    ChangeEvent e){
      setFolder(facadeFolders.get(facadeSlide.getValue()));
    }
  }
);
  imageSlide=new JSlider(-1,1);
  controls.add(imageSlide);
  imageSlide.addChangeListener(new ChangeListener(){
    @Override public void stateChanged(    ChangeEvent e){
      plot();
    }
  }
);
  setFolder(facadeFolders.get(facadeSlide.getValue()));
}",0.9354094579008074
175894,"private void importMesh(int index){
  LoopL<Point3d> polies=blocks.get(index);
  List<Vector2D> verts=polies.stream().flatMap(ll -> ll.streamAble()).map(x -> {
    Line3d l=new Line3d(x.get(),x.getNext().get());
    l.move(perp(l.dir(),EXPAND_MESH));
    return new Vector2D(l.start.x,l.start.z);
  }
).collect(Collectors.toList());
  ConvexHull2D chull=new MonotoneChain(false,0.0001).generate(verts);
  Loop<Point3d> hull=new Loop<Point3d>((Arrays.stream(chull.getLineSegments()).map(x -> new Point3d(x.getStart().getX(),0,x.getStart().getY())).collect(Collectors.toList())));
  File root=new File(Tweed.SCRATCH + ""String_Node_Str"" + File.separator);
  int i=0;
  File l;
  while ((l=new File(root,""String_Node_Str"" + i)).exists())   i++;
  l.mkdirs();
  File croppedFile=new File(l,CROPPED_OBJ);
  boolean found=false;
  for (  Gen gen : tweed.frame.gens(MiniGen.class)) {
    ((MiniGen)gen).clip(hull,croppedFile);
    found=true;
  }
  if (!found)   for (  Gen gen : tweed.frame.gens(ObjGen.class)) {
    ObjGen objg=(ObjGen)gen;
    try {
      Files.asByteSource(objg.getFile()).copyTo(Files.asByteSink(croppedFile));
      objg.setVisible(false);
      found=true;
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  if (found) {
    Graph2D g2=new Graph2D();
    polies.stream().flatMap(ll -> ll.streamAble()).forEach(x -> g2.add(new Point2d(x.get().x,x.get().z),new Point2d(x.getNext().get().x,x.getNext().get().z)));
    g2.removeInnerEdges();
    UnionWalker uw=new UnionWalker();
    for (    Point2d p : g2.map.keySet())     for (    Line line : g2.map.get(p))     uw.addEdge(line.end,line.start);
    Loopz.writeXZObj(uw.findAll(),new File(l,""String_Node_Str""),true);
    Loopz.writeXZObj(Loopz.to2dLoop(polies,1,null),new File(l,""String_Node_Str""),false);
    BlockGen bg=new BlockGen(l,tweed,polies);
    lastMesh.put(index,bg);
    tweed.frame.addGen(bg,true);
  }
 else   JOptionPane.showMessageDialog(tweed.frame(),""String_Node_Str"");
}","private void importMesh(int index){
  LoopL<Point3d> polies=blocks.get(index);
  List<Vector2D> verts=polies.stream().flatMap(ll -> ll.streamAble()).map(x -> {
    Line3d l=new Line3d(x.get(),x.getNext().get());
    l.move(perp(l.dir(),EXPAND_MESH));
    return new Vector2D(l.start.x,l.start.z);
  }
).collect(Collectors.toList());
  ConvexHull2D chull=new MonotoneChain(false,0.0001).generate(verts);
  Loop<Point3d> hull=new Loop<Point3d>((Arrays.stream(chull.getLineSegments()).map(x -> new Point3d(x.getStart().getX(),0,x.getStart().getY())).collect(Collectors.toList())));
  File root=new File(Tweed.SCRATCH + ""String_Node_Str"" + File.separator);
  int i=0;
  File l;
  while ((l=new File(root,""String_Node_Str"" + i)).exists())   i++;
  l.mkdirs();
  File croppedFile=new File(l,CROPPED_OBJ);
  boolean found=false;
  for (  Gen gen : tweed.frame.gens(MiniGen.class)) {
    ((MiniGen)gen).clip(hull,croppedFile);
    found=true;
  }
  if (!found)   for (  Gen gen : tweed.frame.gens(MeshGen.class)) {
    ObjGen objg=(ObjGen)gen;
    try {
      Files.asByteSource(objg.getFile()).copyTo(Files.asByteSink(croppedFile));
      objg.setVisible(false);
      found=true;
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  if (found) {
    Graph2D g2=new Graph2D();
    polies.stream().flatMap(ll -> ll.streamAble()).forEach(x -> g2.add(new Point2d(x.get().x,x.get().z),new Point2d(x.getNext().get().x,x.getNext().get().z)));
    g2.removeInnerEdges();
    UnionWalker uw=new UnionWalker();
    for (    Point2d p : g2.map.keySet())     for (    Line line : g2.map.get(p))     uw.addEdge(line.end,line.start);
    Loopz.writeXZObj(uw.findAll(),new File(l,""String_Node_Str""),true);
    Loopz.writeXZObj(Loopz.to2dLoop(polies,1,null),new File(l,""String_Node_Str""),false);
    BlockGen bg=new BlockGen(l,tweed,polies);
    lastMesh.put(index,bg);
    tweed.frame.addGen(bg,true);
  }
 else   JOptionPane.showMessageDialog(tweed.frame(),""String_Node_Str"");
}",0.9982309830679807
175895,"@Override public JComponent getUI(){
  JPanel ui=new JPanel(new ListDownLayout());
  JButton b=new JButton(""String_Node_Str"");
  b.addActionListener(e -> SkelFootprint.debugFindCleanProfiles(footprint,this,new ProgressMonitor(null,""String_Node_Str"",""String_Node_Str"",0,100),tweed));
  JButton c=new JButton(""String_Node_Str"");
  c.addActionListener(e -> skelFootprint.debugCompareProfs(skelFootprint.globalProfs));
  ui.add(b);
  ui.add(c);
  return ui;
}","@Override public JComponent getUI(){
  JPanel ui=new JPanel(new ListDownLayout());
  JButton b=new JButton(""String_Node_Str"");
  b.addActionListener(e -> SkelFootprint.debugFindCleanProfiles(footprint,this,new ProgressMonitor(null,""String_Node_Str"",""String_Node_Str"",0,100),tweed));
  JButton c=new JButton(""String_Node_Str"");
  c.addActionListener(e -> skelFootprint.debugCompareProfs(skelFootprint.globalProfs));
  ui.add(new JLabel(""String_Node_Str""));
  ui.add(b);
  ui.add(c);
  return ui;
}",0.9568874868559412
175896,"private void selected(PlanSkeleton skel,Node house,SuperFace sf,SuperEdge se){
  JPanel ui=new JPanel();
  ui.setLayout(new ListDownLayout());
  JButton fac=new JButton(""String_Node_Str"");
  fac.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (se.toEdit == null) {
        se.toEdit=new MiniFacade();
        se.toEdit.left=0;
        se.toEdit.width=se.length();
        se.toEdit.height=30;
        se.toEdit.groundFloorHeight=2;
      }
      Plot p=new Plot(se.toEdit);
      p.addEditListener(new Changed(){
        @Override public void changed(){
          tweed.enqueue(new Runnable(){
            @Override public void run(){
              PlanSkeleton skel=calc(sf);
              setSkel(skel,skel.output,sf);
            }
          }
);
        }
      }
);
    }
  }
);
  ui.add(fac);
  JButton camp=new JButton(""String_Node_Str"");
  camp.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Siteplan cs=new Siteplan(skel.plan,false){
        public void show(        Output output,        Skeleton threadKey){
          super.show(output,threadKey);
          tweed.enqueue(new Runnable(){
            @Override public void run(){
              setSkel(skel,output,sf);
            }
          }
);
        }
      }
;
      cs.setVisible(true);
      cs.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
    }
  }
);
  ui.add(camp);
  JButton mmg=new JButton(""String_Node_Str"");
  mmg.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      MOgram mg=buildMOGram(sf,se);
      MOgramEditor.quitOnLastClosed=false;
      new MOgramEditor(mg).setVisible(true);
    }
  }
);
  ui.add(mmg);
  JButton mini=new JButton(""String_Node_Str"");
  mini.addActionListener(e -> new MiniViewer(se));
  if (sf != null)   ui.add(mini);
  JButton prof=new JButton(""String_Node_Str"");
  prof.addActionListener(e -> new ProfileAssignmentViewer(sf,skelFootprint.globalProfs));
  ui.add(prof);
  JButton plan=new JButton(""String_Node_Str"");
  plan.addActionListener(e -> new Plot(toRender,footprint));
  ui.add(plan);
  JButton remove=new JButton(""String_Node_Str"");
  remove.addActionListener(e -> {
    visible=false;
    calculateOnJmeThread();
    tweed.frame.removeGen(SkelGen.this);
  }
);
  ui.add(plan);
  tweed.frame.setGenUI(ui);
}","private void selected(PlanSkeleton skel,Node house,SuperFace sf,SuperEdge se){
  JPanel ui=new JPanel();
  ui.setLayout(new ListDownLayout());
  JButton fac=new JButton(""String_Node_Str"");
  fac.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (se.toEdit == null) {
        se.toEdit=new MiniFacade();
        se.toEdit.left=0;
        se.toEdit.width=se.length();
        se.toEdit.height=30;
        se.toEdit.groundFloorHeight=2;
      }
      Plot p=new Plot(se.toEdit);
      PaintThing.debug.clear();
      p.addEditListener(new Changed(){
        @Override public void changed(){
          PaintThing.debug.clear();
          tweed.enqueue(new Runnable(){
            @Override public void run(){
              PlanSkeleton skel=calc(sf);
              setSkel(skel,skel.output,sf);
            }
          }
);
        }
      }
);
    }
  }
);
  ui.add(fac);
  JButton camp=new JButton(""String_Node_Str"");
  camp.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Siteplan cs=new Siteplan(skel.plan,false){
        public void show(        Output output,        Skeleton threadKey){
          super.show(output,threadKey);
          tweed.enqueue(new Runnable(){
            @Override public void run(){
              setSkel(skel,output,sf);
            }
          }
);
        }
      }
;
      cs.setVisible(true);
      cs.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
    }
  }
);
  ui.add(camp);
  JButton mmg=new JButton(""String_Node_Str"");
  mmg.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      MOgram mg=buildMOGram(sf,se);
      MOgramEditor.quitOnLastClosed=false;
      new MOgramEditor(mg).setVisible(true);
    }
  }
);
  ui.add(mmg);
  JButton mini=new JButton(""String_Node_Str"");
  mini.addActionListener(e -> new MiniViewer(se));
  if (sf != null)   ui.add(mini);
  JButton prof=new JButton(""String_Node_Str"");
  prof.addActionListener(e -> new ProfileAssignmentViewer(sf,skelFootprint.globalProfs));
  ui.add(prof);
  JButton plan=new JButton(""String_Node_Str"");
  plan.addActionListener(e -> new Plot(toRender,footprint));
  ui.add(plan);
  JButton remove=new JButton(""String_Node_Str"");
  remove.addActionListener(e -> {
    visible=false;
    calculateOnJmeThread();
    tweed.frame.removeGen(SkelGen.this);
  }
);
  ui.add(plan);
  tweed.frame.setGenUI(ui);
}",0.986116782360147
175897,"@Override public void changed(){
  tweed.enqueue(new Runnable(){
    @Override public void run(){
      PlanSkeleton skel=calc(sf);
      setSkel(skel,skel.output,sf);
    }
  }
);
}","@Override public void changed(){
  PaintThing.debug.clear();
  tweed.enqueue(new Runnable(){
    @Override public void run(){
      PlanSkeleton skel=calc(sf);
      setSkel(skel,skel.output,sf);
    }
  }
);
}",0.9285714285714286
175898,"@Override public void dumpObj(ObjDump dump){
  dump.setCurrentTexture(filename,1,1);
  dump.addAll(getCroppedMesh());
}","@Override public void dumpObj(ObjDump dump){
  dump.setCurrentMaterial(Color.blue,0.5);
  dump.addAll(getCroppedMesh());
}",0.8547717842323651
175899,"@Override public void dumpObj(ObjDump dump){
  dump.setCurrentTexture(filename,1,1);
  dump.addAll(new ObjRead(new File(Tweed.JME + filename)));
}","@Override public void dumpObj(ObjDump dump){
  dump.setCurrentMaterial(Color.pink,0.5);
  dump.addAll(new ObjRead(new File(Tweed.JME + filename)));
}",0.8949152542372881
175900,"@Override public void dumpObj(ObjDump dump){
  dump.setCurrentTexture(""String_Node_Str"",1,1);
  Jme3z.dump(dump,gNode,0);
}","@Override public void dumpObj(ObjDump dump){
  dump.setCurrentMaterial(Color.orange,0.5);
  Jme3z.dump(dump,gNode,0);
}",0.8347107438016529
175901,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mTextView=(TextView)findViewById(R.id.text_view);
  WebkioskCredentials credentials=new WebkioskCredentials(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  kioskApi=JKiosk.getSubjectFacultyApi();
  kioskApi.getSubjectFaculty(credentials,""String_Node_Str"").addResultCallback(new ResultCallbackContract<SubjectFacultyResult>(){
    @Override public void onResult(    SubjectFacultyResult result){
      for (      SubjectFaculty subjectFaculty : result.getSubjectFaculties()) {
        mTextView.append(subjectFaculty.getSubjectName() + ""String_Node_Str"");
      }
    }
    @Override public void onError(    Exception e){
      Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
    }
  }
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mTextView=(TextView)findViewById(R.id.text_view);
  WebkioskCredentials credentials=new WebkioskCredentials(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  kioskApi=JKiosk.getLoginApi();
  kioskApi.login(credentials).addResultCallback(new ResultCallbackContract<LoginResult>(){
    @Override public void onResult(    LoginResult result){
      Toast.makeText(getApplicationContext(),String.valueOf(result.isValidCredentials()),Toast.LENGTH_SHORT).show();
    }
    @Override public void onError(    Exception e){
    }
  }
);
}",0.5893657911595132
175902,"@Override public void onError(Exception e){
  Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}","@Override public void onError(Exception e){
}",0.5084745762711864
175903,"@Override public void onResult(SubjectFacultyResult result){
  for (  SubjectFaculty subjectFaculty : result.getSubjectFaculties()) {
    mTextView.append(subjectFaculty.getSubjectName() + ""String_Node_Str"");
  }
}","@Override public void onResult(LoginResult result){
  Toast.makeText(getApplicationContext(),String.valueOf(result.isValidCredentials()),Toast.LENGTH_SHORT).show();
}",0.4
175904,"/** 
 * It returns a   {@link Calendar} objects complying with Java bean validationannotations. {@inheritDoc}
 */
public Object getValue(Class<?> attrType,List<Annotation> annotations) throws PodamMockeryException {
  if (null != findTypeFromList(annotations,AssertTrue.class)) {
    return Boolean.TRUE;
  }
  if (null != findTypeFromList(annotations,AssertFalse.class)) {
    return Boolean.FALSE;
  }
  if (null != findTypeFromList(annotations,Past.class)) {
    int days=PodamUtils.getIntegerInRange(1,365);
    long timestamp=System.currentTimeMillis() - TimeUnit.DAYS.toSeconds(days);
    return timestampToReturnType(timestamp);
  }
  if (null != findTypeFromList(annotations,Future.class)) {
    int days=PodamUtils.getIntegerInRange(1,365);
    long timestamp=System.currentTimeMillis() + TimeUnit.DAYS.toSeconds(days);
    return timestampToReturnType(timestamp);
  }
  Size size=findTypeFromList(annotations,Size.class);
  if (null != size) {
    int minValue=size.min();
    int maxValue=size.max();
    if (maxValue == Integer.MAX_VALUE) {
      maxValue=PodamConstants.STR_DEFAULT_LENGTH;
    }
    long length=PodamUtils.getLongInRange(minValue,maxValue);
    StringBuilder sb=new StringBuilder();
    while (sb.length() < length) {
      sb.append(PodamUtils.getNiceCharacter());
    }
    return sb.toString();
  }
  Pattern pattern=findTypeFromList(annotations,Pattern.class);
  if (null != pattern) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"",pattern.regexp());
    return null;
  }
  boolean isRound=false;
  boolean isFloat=false;
  BigDecimal min=new BigDecimal(-Double.MAX_VALUE);
  BigDecimal max=new BigDecimal(Double.MAX_VALUE);
  DecimalMin decimalMin=findTypeFromList(annotations,DecimalMin.class);
  if (null != decimalMin) {
    isFloat=true;
    min=new BigDecimal(decimalMin.value());
  }
  DecimalMax decimalMax=findTypeFromList(annotations,DecimalMax.class);
  if (null != decimalMax) {
    isFloat=true;
    max=new BigDecimal(decimalMax.value());
  }
  Min minAnno=findTypeFromList(annotations,Min.class);
  if (null != minAnno) {
    isRound=true;
    min=new BigDecimal(minAnno.value()).max(min);
  }
  Max maxAnno=findTypeFromList(annotations,Max.class);
  if (null != maxAnno) {
    isRound=true;
    max=new BigDecimal(maxAnno.value()).min(max);
  }
  Digits digits=findTypeFromList(annotations,Digits.class);
  BigDecimal divisor=null;
  if (null != digits) {
    isRound=true;
    divisor=BigDecimal.TEN.pow(digits.fraction());
    BigDecimal limit=BigDecimal.TEN.pow(digits.integer());
    max=limit.min(max).multiply(divisor);
    min=limit.negate().max(min).multiply(divisor);
  }
  if (isRound || isFloat) {
    BigDecimal value=getValueInRange(min,max);
    if (isRound) {
      BigInteger intValue=value.toBigInteger();
      value=new BigDecimal(intValue);
    }
    if (null != divisor) {
      value=value.divide(divisor);
    }
    return decimalToReturnType(value);
  }
  return null;
}","/** 
 * It returns a   {@link Calendar} objects complying with Java bean validationannotations. {@inheritDoc}
 */
public Object getValue(Class<?> attrType,List<Annotation> annotations) throws PodamMockeryException {
  if (null != findTypeFromList(annotations,AssertTrue.class)) {
    return Boolean.TRUE;
  }
  if (null != findTypeFromList(annotations,AssertFalse.class)) {
    return Boolean.FALSE;
  }
  if (null != findTypeFromList(annotations,Past.class)) {
    int days=PodamUtils.getIntegerInRange(1,365);
    long timestamp=System.currentTimeMillis() - TimeUnit.DAYS.toSeconds(days);
    return timestampToReturnType(timestamp);
  }
  if (null != findTypeFromList(annotations,Future.class)) {
    int days=PodamUtils.getIntegerInRange(1,365);
    long timestamp=System.currentTimeMillis() + TimeUnit.DAYS.toSeconds(days);
    return timestampToReturnType(timestamp);
  }
  Size size=findTypeFromList(annotations,Size.class);
  if (null != size) {
    int minValue=size.min();
    int maxValue=size.max();
    if (minValue < 1 && maxValue > 0) {
      minValue=1;
    }
    if (maxValue == Integer.MAX_VALUE) {
      maxValue=PodamConstants.STR_DEFAULT_LENGTH;
    }
    long length=PodamUtils.getLongInRange(minValue,maxValue);
    StringBuilder sb=new StringBuilder();
    while (sb.length() < length) {
      sb.append(PodamUtils.getNiceCharacter());
    }
    return sb.toString();
  }
  Pattern pattern=findTypeFromList(annotations,Pattern.class);
  if (null != pattern) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"",pattern.regexp());
    return null;
  }
  boolean isRound=false;
  boolean isFloat=false;
  BigDecimal min=new BigDecimal(-Double.MAX_VALUE);
  BigDecimal max=new BigDecimal(Double.MAX_VALUE);
  DecimalMin decimalMin=findTypeFromList(annotations,DecimalMin.class);
  if (null != decimalMin) {
    isFloat=true;
    min=new BigDecimal(decimalMin.value());
  }
  DecimalMax decimalMax=findTypeFromList(annotations,DecimalMax.class);
  if (null != decimalMax) {
    isFloat=true;
    max=new BigDecimal(decimalMax.value());
  }
  Min minAnno=findTypeFromList(annotations,Min.class);
  if (null != minAnno) {
    isRound=true;
    min=new BigDecimal(minAnno.value()).max(min);
  }
  Max maxAnno=findTypeFromList(annotations,Max.class);
  if (null != maxAnno) {
    isRound=true;
    max=new BigDecimal(maxAnno.value()).min(max);
  }
  Digits digits=findTypeFromList(annotations,Digits.class);
  BigDecimal divisor=null;
  if (null != digits) {
    isRound=true;
    divisor=BigDecimal.TEN.pow(digits.fraction());
    BigDecimal limit=BigDecimal.TEN.pow(digits.integer());
    max=limit.min(max).multiply(divisor);
    min=limit.negate().max(min).multiply(divisor);
  }
  if (isRound || isFloat) {
    BigDecimal value=getValueInRange(min,max);
    if (isRound) {
      BigInteger intValue=value.toBigInteger();
      value=new BigDecimal(intValue);
    }
    if (null != divisor) {
      value=value.divide(divisor);
    }
    return decimalToReturnType(value);
  }
  return null;
}",0.9892653471989266
175905,"/** 
 * It manufactures and returns the value for a POJO attribute.
 * @param pojo The POJO being filled with values
 * @param manufacturingCtx the manufacturing context
 * @param attributeType The type of the attribute for which a value is being manufactured
 * @param genericAttributeType The generic type of the attribute for which a value is being manufactured
 * @param annotations The annotations for the attribute being considered
 * @param attributeName The attribute name
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return The value for an attribute
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws IllegalArgumentException <ul> <li>If an illegal argument was passed</li> <li>If an invalid value was set for a precise value in an annotation and such value could not be converted to the desired type</li> </ul>
 * @throws ClassNotFoundException If class being manufactured cannot be loaded
 */
private Object manufactureAttributeValue(Object pojo,ManufacturingContext manufacturingCtx,Class<?> attributeType,Type genericAttributeType,List<Annotation> annotations,String attributeName,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Object attributeValue=null;
  Class<?> pojoClass=(pojo instanceof Class ? (Class<?>)pojo : pojo.getClass());
  Class<?> realAttributeType;
  if (attributeType != genericAttributeType && Object.class.equals(attributeType) && genericAttributeType instanceof TypeVariable) {
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    realAttributeType=TypeManufacturerUtil.resolveGenericParameter(genericAttributeType,typeArgsMap,elementGenericTypeArgs);
  }
 else {
    realAttributeType=attributeType;
  }
  Type[] genericTypeArgsAll=TypeManufacturerUtil.mergeActualAndSuppliedGenericTypes(attributeType,genericAttributeType,genericTypeArgs,typeArgsMap);
  AttributeMetadata attributeMetadata=new AttributeMetadata(attributeName,realAttributeType,genericAttributeType,genericTypeArgsAll,annotations,pojoClass,pojo);
  if (realAttributeType.isArray()) {
    attributeValue=resolveArrayElementValue(pojo,manufacturingCtx,attributeMetadata,typeArgsMap);
  }
 else   if (Collection.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveCollectionValueWhenCollectionIsPojoAttribute(pojo,manufacturingCtx,attributeMetadata,typeArgsMap);
  }
 else   if (Map.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveMapValueWhenMapIsPojoAttribute(pojo,manufacturingCtx,attributeMetadata,typeArgsMap);
  }
  if (attributeValue == null) {
    Integer depth=manufacturingCtx.getPojos().get(realAttributeType);
    if (depth == null) {
      depth=-1;
    }
    if (depth <= strategy.getMaxDepth(pojoClass)) {
      manufacturingCtx.getPojos().put(realAttributeType,depth + 1);
      attributeValue=this.manufacturePojoInternal(realAttributeType,attributeMetadata,manufacturingCtx,genericTypeArgsAll);
      manufacturingCtx.getPojos().put(realAttributeType,depth);
    }
 else {
      attributeValue=resortToExternalFactory(manufacturingCtx,""String_Node_Str"" + depth + ""String_Node_Str"",realAttributeType,genericTypeArgsAll);
    }
  }
  return attributeValue;
}","/** 
 * It manufactures and returns the value for a POJO attribute.
 * @param pojo The POJO being filled with values
 * @param manufacturingCtx the manufacturing context
 * @param attributeType The type of the attribute for which a value is being manufactured
 * @param genericAttributeType The generic type of the attribute for which a value is being manufactured
 * @param annotations The annotations for the attribute being considered
 * @param attributeName The attribute name
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return The value for an attribute
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws IllegalArgumentException <ul> <li>If an illegal argument was passed</li> <li>If an invalid value was set for a precise value in an annotation and such value could not be converted to the desired type</li> </ul>
 * @throws ClassNotFoundException If class being manufactured cannot be loaded
 */
private Object manufactureAttributeValue(Object pojo,ManufacturingContext manufacturingCtx,Class<?> attributeType,Type genericAttributeType,List<Annotation> annotations,String attributeName,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Object attributeValue=null;
  Class<?> pojoClass=(pojo instanceof Class ? (Class<?>)pojo : pojo.getClass());
  Class<?> realAttributeType;
  if (attributeType != genericAttributeType && Object.class.equals(attributeType) && genericAttributeType instanceof TypeVariable) {
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    realAttributeType=TypeManufacturerUtil.resolveGenericParameter(genericAttributeType,typeArgsMap,elementGenericTypeArgs);
  }
 else {
    realAttributeType=attributeType;
  }
  Type[] genericTypeArgsAll=TypeManufacturerUtil.mergeActualAndSuppliedGenericTypes(attributeType,genericAttributeType,genericTypeArgs,typeArgsMap);
  AttributeMetadata attributeMetadata=new AttributeMetadata(attributeName,realAttributeType,genericAttributeType,genericTypeArgsAll,annotations,pojoClass,pojo);
  if (realAttributeType.isArray()) {
    attributeValue=resolveArrayElementValue(pojo,manufacturingCtx,attributeMetadata,typeArgsMap);
  }
 else   if (Collection.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveCollectionValueWhenCollectionIsPojoAttribute(pojo,manufacturingCtx,attributeMetadata,typeArgsMap);
  }
 else   if (Map.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveMapValueWhenMapIsPojoAttribute(pojo,manufacturingCtx,attributeMetadata,typeArgsMap);
  }
  if (attributeValue == null) {
    Integer depth=manufacturingCtx.getPojos().get(realAttributeType);
    if (depth == null) {
      depth=0;
    }
    if (depth < strategy.getMaxDepth(pojoClass)) {
      manufacturingCtx.getPojos().put(realAttributeType,depth + 1);
      attributeValue=this.manufacturePojoInternal(realAttributeType,attributeMetadata,manufacturingCtx,genericTypeArgsAll);
      manufacturingCtx.getPojos().put(realAttributeType,depth);
    }
 else {
      attributeValue=resortToExternalFactory(manufacturingCtx,""String_Node_Str"" + depth + ""String_Node_Str"",realAttributeType,genericTypeArgsAll);
    }
  }
  return attributeValue;
}",0.999458434876794
175906,"/** 
 * {@inheritDoc}
 */
@Override public <T>T populatePojo(T pojo,Type... genericTypeArgs){
  ManufacturingContext manufacturingCtx=new ManufacturingContext();
  manufacturingCtx.getPojos().put(pojo.getClass(),0);
  final Map<String,Type> typeArgsMap=new HashMap<String,Type>();
  Type[] genericTypeArgsExtra=TypeManufacturerUtil.fillTypeArgMap(typeArgsMap,pojo.getClass(),genericTypeArgs);
  try {
    List<Annotation> annotations=null;
    return this.populatePojoInternal(pojo,annotations,manufacturingCtx,typeArgsMap,genericTypeArgsExtra);
  }
 catch (  InstantiationException e) {
    throw new PodamMockeryException(e.getMessage(),e);
  }
catch (  IllegalAccessException e) {
    throw new PodamMockeryException(e.getMessage(),e);
  }
catch (  InvocationTargetException e) {
    throw new PodamMockeryException(e.getMessage(),e);
  }
catch (  ClassNotFoundException e) {
    throw new PodamMockeryException(e.getMessage(),e);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public <T>T populatePojo(T pojo,Type... genericTypeArgs){
  ManufacturingContext manufacturingCtx=new ManufacturingContext();
  manufacturingCtx.getPojos().put(pojo.getClass(),1);
  final Map<String,Type> typeArgsMap=new HashMap<String,Type>();
  Type[] genericTypeArgsExtra=TypeManufacturerUtil.fillTypeArgMap(typeArgsMap,pojo.getClass(),genericTypeArgs);
  try {
    List<Annotation> annotations=null;
    return this.populatePojoInternal(pojo,annotations,manufacturingCtx,typeArgsMap,genericTypeArgsExtra);
  }
 catch (  InstantiationException e) {
    throw new PodamMockeryException(e.getMessage(),e);
  }
catch (  IllegalAccessException e) {
    throw new PodamMockeryException(e.getMessage(),e);
  }
catch (  InvocationTargetException e) {
    throw new PodamMockeryException(e.getMessage(),e);
  }
catch (  ClassNotFoundException e) {
    throw new PodamMockeryException(e.getMessage(),e);
  }
}",0.9989350372736954
175907,"/** 
 * {@inheritDoc}
 */
@Override public <T>T manufacturePojoWithFullData(Class<T> pojoClass,Type... genericTypeArgs){
  ManufacturingContext manufacturingCtx=new ManufacturingContext();
  manufacturingCtx.getPojos().put(pojoClass,0);
  manufacturingCtx.setConstructorOrdering(Order.HEAVY_FIRST);
  return doManufacturePojo(pojoClass,manufacturingCtx,genericTypeArgs);
}","/** 
 * {@inheritDoc}
 */
@Override public <T>T manufacturePojoWithFullData(Class<T> pojoClass,Type... genericTypeArgs){
  ManufacturingContext manufacturingCtx=new ManufacturingContext();
  manufacturingCtx.getPojos().put(pojoClass,1);
  manufacturingCtx.setConstructorOrdering(Order.HEAVY_FIRST);
  return doManufacturePojo(pojoClass,manufacturingCtx,genericTypeArgs);
}",0.9973118279569892
175908,"/** 
 * Fills a field with a getter
 * @param < T > The type for which should be populated
 * @param pojo The POJO being filled with values
 * @param attribute a attribute we are filling
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @param manufacturingCtx the manufacturing context
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return true, if attribute was found and populated
 * @throws ClassNotFoundException If class being manufactured cannot be loaded
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 */
private <T>boolean populateReadOnlyField(T pojo,ClassAttribute attribute,Map<String,Type> typeArgsMap,ManufacturingContext manufacturingCtx,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Method getter=PodamUtils.selectLatestMethod(attribute.getGetters());
  if (getter == null) {
    return false;
  }
  if (getter.getGenericParameterTypes().length > 0) {
    LOG.warn(""String_Node_Str"",getter);
    return false;
  }
  if (getter.getReturnType().isPrimitive()) {
    return false;
  }
  Object fieldValue=null;
  try {
    fieldValue=getter.invoke(pojo,PodamConstants.NO_ARGS);
  }
 catch (  Exception e) {
    LOG.debug(""String_Node_Str"",getter);
  }
  if (fieldValue != null) {
    LOG.debug(""String_Node_Str"",getter);
    Type[] genericTypeArgsAll;
    Map<String,Type> paramTypeArgsMap;
    if (getter.getGenericReturnType() instanceof ParameterizedType) {
      paramTypeArgsMap=new HashMap<String,Type>(typeArgsMap);
      ParameterizedType paramType=(ParameterizedType)getter.getGenericReturnType();
      Type[] actualTypes=paramType.getActualTypeArguments();
      TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),actualTypes);
      genericTypeArgsAll=TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),genericTypeArgs);
    }
 else {
      paramTypeArgsMap=typeArgsMap;
      genericTypeArgsAll=genericTypeArgs;
    }
    List<Annotation> pojoAttributeAnnotations=PodamUtils.getAttributeAnnotations(attribute.getAttribute(),getter);
    Class<?> fieldClass=fieldValue.getClass();
    Integer depth=manufacturingCtx.getPojos().get(fieldClass);
    if (depth == null) {
      depth=-1;
    }
    if (depth <= strategy.getMaxDepth(fieldClass)) {
      manufacturingCtx.getPojos().put(fieldClass,depth + 1);
      populatePojoInternal(fieldValue,pojoAttributeAnnotations,manufacturingCtx,paramTypeArgsMap,genericTypeArgsAll);
      manufacturingCtx.getPojos().put(fieldClass,depth);
    }
 else {
      LOG.warn(""String_Node_Str"" + depth + ""String_Node_Str"",getter);
    }
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Fills a field with a getter
 * @param < T > The type for which should be populated
 * @param pojo The POJO being filled with values
 * @param attribute a attribute we are filling
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @param manufacturingCtx the manufacturing context
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return true, if attribute was found and populated
 * @throws ClassNotFoundException If class being manufactured cannot be loaded
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 */
private <T>boolean populateReadOnlyField(T pojo,ClassAttribute attribute,Map<String,Type> typeArgsMap,ManufacturingContext manufacturingCtx,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Method getter=PodamUtils.selectLatestMethod(attribute.getGetters());
  if (getter == null) {
    return false;
  }
  if (getter.getGenericParameterTypes().length > 0) {
    LOG.warn(""String_Node_Str"",getter);
    return false;
  }
  if (getter.getReturnType().isPrimitive()) {
    return false;
  }
  Object fieldValue=null;
  try {
    fieldValue=getter.invoke(pojo,PodamConstants.NO_ARGS);
  }
 catch (  Exception e) {
    LOG.debug(""String_Node_Str"",getter);
  }
  if (fieldValue != null) {
    LOG.debug(""String_Node_Str"",getter);
    Type[] genericTypeArgsAll;
    Map<String,Type> paramTypeArgsMap;
    if (getter.getGenericReturnType() instanceof ParameterizedType) {
      paramTypeArgsMap=new HashMap<String,Type>(typeArgsMap);
      ParameterizedType paramType=(ParameterizedType)getter.getGenericReturnType();
      Type[] actualTypes=paramType.getActualTypeArguments();
      TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),actualTypes);
      genericTypeArgsAll=TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),genericTypeArgs);
    }
 else {
      paramTypeArgsMap=typeArgsMap;
      genericTypeArgsAll=genericTypeArgs;
    }
    List<Annotation> pojoAttributeAnnotations=PodamUtils.getAttributeAnnotations(attribute.getAttribute(),getter);
    Class<?> fieldClass=fieldValue.getClass();
    Integer depth=manufacturingCtx.getPojos().get(fieldClass);
    if (depth == null) {
      depth=0;
    }
    if (depth < strategy.getMaxDepth(fieldClass)) {
      manufacturingCtx.getPojos().put(fieldClass,depth + 1);
      populatePojoInternal(fieldValue,pojoAttributeAnnotations,manufacturingCtx,paramTypeArgsMap,genericTypeArgsAll);
      manufacturingCtx.getPojos().put(fieldClass,depth);
    }
 else {
      LOG.warn(""String_Node_Str"" + depth + ""String_Node_Str"",getter);
    }
    return true;
  }
 else {
    return false;
  }
}",0.999340804218853
175909,"/** 
 * {@inheritDoc}
 */
@Override public <T>T manufacturePojo(Class<T> pojoClass,Type... genericTypeArgs){
  ManufacturingContext manufacturingCtx=new ManufacturingContext();
  manufacturingCtx.getPojos().put(pojoClass,0);
  return doManufacturePojo(pojoClass,manufacturingCtx,genericTypeArgs);
}","/** 
 * {@inheritDoc}
 */
@Override public <T>T manufacturePojo(Class<T> pojoClass,Type... genericTypeArgs){
  ManufacturingContext manufacturingCtx=new ManufacturingContext();
  manufacturingCtx.getPojos().put(pojoClass,1);
  return doManufacturePojo(pojoClass,manufacturingCtx,genericTypeArgs);
}",0.9966442953020134
175910,"/** 
 * {@inheritDoc}
 */
@Override public int getMaxDepth(Class<?> type){
  return -1;
}","/** 
 * {@inheritDoc}
 */
@Override public int getMaxDepth(Class<?> type){
  return 1;
}",0.9943502824858758
175911,"private void createPojoWithCircularDependencies(PodamFactory podamFactory) throws Exception {
  Parent parent=podamInvocationSteps.whenIInvokeTheFactoryForClass(Parent.class,podamFactory);
  int depth=0;
  while (null != parent) {
    podamValidationSteps.thePojoMustBeOfTheType(parent,Parent.class);
    Child child=parent.getChild();
    podamValidationSteps.thePojoMustBeOfTheType(child,Child.class);
    parent=child.getParent();
    depth++;
  }
  podamValidationSteps.theIntFieldShouldHaveThePreciseValueOf(depth,podamFactory.getStrategy().getMaxDepth(Parent.class) + 2);
}","private void createPojoWithCircularDependencies(PodamFactory podamFactory) throws Exception {
  Parent parent=podamInvocationSteps.whenIInvokeTheFactoryForClass(Parent.class,podamFactory);
  int depth=0;
  while (null != parent) {
    podamValidationSteps.thePojoMustBeOfTheType(parent,Parent.class);
    Child child=parent.getChild();
    podamValidationSteps.thePojoMustBeOfTheType(child,Child.class);
    parent=child.getParent();
    depth++;
  }
  podamValidationSteps.theIntFieldShouldHaveThePreciseValueOf(depth,podamFactory.getStrategy().getMaxDepth(Parent.class));
}",0.9965337954939342
175912,"public AbstractRandomDataProviderStrategy(int nbrOfCollectionElements){
  this.nbrOfCollectionElements.set(nbrOfCollectionElements);
  TypeManufacturer<?> byteManufacturer=new ByteTypeManufacturerImpl();
  typeManufacturers.put(byte.class,byteManufacturer);
  typeManufacturers.put(Byte.class,byteManufacturer);
  TypeManufacturer<?> booleanManufacturer=new BooleanTypeManufacturerImpl();
  typeManufacturers.put(boolean.class,booleanManufacturer);
  typeManufacturers.put(Boolean.class,booleanManufacturer);
  TypeManufacturer<?> charManufacturer=new CharTypeManufacturerImpl();
  typeManufacturers.put(char.class,charManufacturer);
  typeManufacturers.put(Character.class,charManufacturer);
  TypeManufacturer<?> shortManufacturer=new ShortTypeManufacturerImpl();
  typeManufacturers.put(short.class,shortManufacturer);
  typeManufacturers.put(Short.class,shortManufacturer);
  TypeManufacturer<?> intManufacturer=new IntTypeManufacturerImpl();
  typeManufacturers.put(int.class,intManufacturer);
  typeManufacturers.put(Integer.class,intManufacturer);
  TypeManufacturer<?> longManufacturer=new LongTypeManufacturerImpl();
  typeManufacturers.put(long.class,longManufacturer);
  typeManufacturers.put(Long.class,longManufacturer);
  TypeManufacturer<?> floatManufacturer=new FloatTypeManufacturerImpl();
  typeManufacturers.put(float.class,floatManufacturer);
  typeManufacturers.put(Float.class,floatManufacturer);
  TypeManufacturer<?> doubleManufacturer=new DoubleTypeManufacturerImpl();
  typeManufacturers.put(double.class,doubleManufacturer);
  typeManufacturers.put(Double.class,doubleManufacturer);
  TypeManufacturer<?> stringManufacturer=new StringTypeManufacturerImpl();
  typeManufacturers.put(String.class,stringManufacturer);
  TypeManufacturer<?> enumManufacturer=new EnumTypeManufacturerImpl();
  typeManufacturers.put(Enum.class,enumManufacturer);
  TypeManufacturer<?> typeManufacturer=new TypeTypeManufacturerImpl();
  typeManufacturers.put(Type.class,typeManufacturer);
  TypeManufacturer<?> collectionManufacturer=new CollectionTypeManufacturerImpl();
  typeManufacturers.put(Collection.class,collectionManufacturer);
  TypeManufacturer<?> mapManufacturer=new MapTypeManufacturerImpl();
  typeManufacturers.put(Map.class,mapManufacturer);
  TypeManufacturer<?> arrayManufacturer=new ArrayTypeManufacturerImpl();
  typeManufacturers.put(Cloneable.class,arrayManufacturer);
}","public AbstractRandomDataProviderStrategy(int nbrOfCollectionElements){
  this.nbrOfCollectionElements.set(nbrOfCollectionElements);
  TypeManufacturer<?> byteManufacturer=new ByteTypeManufacturerImpl();
  typeManufacturers.put(byte.class,byteManufacturer);
  typeManufacturers.put(Byte.class,byteManufacturer);
  TypeManufacturer<?> booleanManufacturer=new BooleanTypeManufacturerImpl();
  typeManufacturers.put(boolean.class,booleanManufacturer);
  typeManufacturers.put(Boolean.class,booleanManufacturer);
  TypeManufacturer<?> charManufacturer=new CharTypeManufacturerImpl();
  typeManufacturers.put(char.class,charManufacturer);
  typeManufacturers.put(Character.class,charManufacturer);
  TypeManufacturer<?> shortManufacturer=new ShortTypeManufacturerImpl();
  typeManufacturers.put(short.class,shortManufacturer);
  typeManufacturers.put(Short.class,shortManufacturer);
  TypeManufacturer<?> intManufacturer=new IntTypeManufacturerImpl();
  typeManufacturers.put(int.class,intManufacturer);
  typeManufacturers.put(Integer.class,intManufacturer);
  TypeManufacturer<?> longManufacturer=new LongTypeManufacturerImpl();
  typeManufacturers.put(long.class,longManufacturer);
  typeManufacturers.put(Long.class,longManufacturer);
  TypeManufacturer<?> floatManufacturer=new FloatTypeManufacturerImpl();
  typeManufacturers.put(float.class,floatManufacturer);
  typeManufacturers.put(Float.class,floatManufacturer);
  TypeManufacturer<?> doubleManufacturer=new DoubleTypeManufacturerImpl();
  typeManufacturers.put(double.class,doubleManufacturer);
  typeManufacturers.put(Double.class,doubleManufacturer);
  TypeManufacturer<?> stringManufacturer=new StringTypeManufacturerImpl();
  typeManufacturers.put(String.class,stringManufacturer);
  TypeManufacturer<?> enumManufacturer=new EnumTypeManufacturerImpl();
  typeManufacturers.put(Enum.class,enumManufacturer);
  TypeManufacturer<?> typeManufacturer=new TypeTypeManufacturerImpl();
  typeManufacturers.put(Type.class,typeManufacturer);
  TypeManufacturer<?> collectionManufacturer=new CollectionTypeManufacturerImpl();
  typeManufacturers.put(List.class,collectionManufacturer);
  typeManufacturers.put(Collection.class,collectionManufacturer);
  TypeManufacturer<?> mapManufacturer=new MapTypeManufacturerImpl();
  typeManufacturers.put(Map.class,mapManufacturer);
  TypeManufacturer<?> arrayManufacturer=new ArrayTypeManufacturerImpl();
  typeManufacturers.put(Cloneable.class,arrayManufacturer);
}",0.9876390605686032
175913,"/** 
 * Fills given class filled with values dictated by the strategy
 * @param < T > The type for which should be populated
 * @param pojo An instance to be filled with dummy values
 * @param annotations a list of annotations attached to this POJO defined elsewhere 
 * @param manufacturingCtx the manufacturing context
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return An instance of &lt;T&gt; filled with dummy values
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If manufactured class cannot be loaded
 */
private <T>T populatePojoInternal(T pojo,List<Annotation> annotations,ManufacturingContext manufacturingCtx,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Class<?> pojoClass=pojo.getClass();
  if (pojo instanceof Collection && ((Collection<?>)pojo).isEmpty()) {
    @SuppressWarnings(""String_Node_Str"") Collection<Object> collection=(Collection<Object>)pojo;
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    Class<?> elementTypeClass=findInheretedCollectionElementType(collection,manufacturingCtx,elementGenericTypeArgs,typeArgsMap,genericTypeArgs);
    String attributeName=null;
    if (null == annotations) {
      annotations=new ArrayList<Annotation>();
    }
    for (    Annotation annotation : collection.getClass().getAnnotations()) {
      annotations.add(annotation);
    }
    fillCollection(manufacturingCtx,annotations,attributeName,collection,elementTypeClass,elementGenericTypeArgs.get());
  }
 else   if (pojo instanceof Map && ((Map<?,?>)pojo).isEmpty()) {
    @SuppressWarnings(""String_Node_Str"") Map<Object,Object> map=(Map<Object,Object>)pojo;
    MapArguments mapArguments=findInheretedMapElementType(map,manufacturingCtx,typeArgsMap,genericTypeArgs);
    fillMap(mapArguments,manufacturingCtx);
  }
  Class<?>[] parameterTypes=null;
  Class<?> attributeType=null;
  ClassInfo classInfo=classInfoStrategy.getClassInfo(pojo.getClass());
  Set<ClassAttribute> classAttributes=classInfo.getClassAttributes();
  Object setterArg=null;
  Iterator<ClassAttribute> iter=classAttributes.iterator();
  while (iter.hasNext()) {
    ClassAttribute attribute=iter.next();
    Set<Method> setters=attribute.getSetters();
    if (setters.isEmpty()) {
      if (attribute.getGetters().isEmpty()) {
        iter.remove();
      }
      continue;
    }
 else {
      iter.remove();
    }
    Method setter=PodamUtils.selectLatestMethod(setters);
    parameterTypes=setter.getParameterTypes();
    if (parameterTypes.length != 1) {
      LOG.warn(""String_Node_Str"",setter);
      continue;
    }
    attributeType=parameterTypes[0];
    List<Annotation> pojoAttributeAnnotations=PodamUtils.getAttributeAnnotations(attribute.getAttribute(),setter);
    AttributeStrategy<?> attributeStrategy=TypeManufacturerUtil.findAttributeStrategy(strategy,pojoAttributeAnnotations,attributeType);
    if (null != attributeStrategy) {
      setterArg=TypeManufacturerUtil.returnAttributeDataStrategyValue(attributeType,attributeStrategy);
    }
 else {
      AtomicReference<Type[]> typeGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
      Type genericType=setter.getGenericParameterTypes()[0];
      final Type[] typeArguments;
      if (!(genericType instanceof GenericArrayType)) {
        attributeType=TypeManufacturerUtil.resolveGenericParameter(genericType,typeArgsMap,typeGenericTypeArgs);
        typeArguments=typeGenericTypeArgs.get();
      }
 else {
        typeArguments=PodamConstants.NO_TYPES;
      }
      for (int i=0; i < typeArguments.length; i++) {
        if (typeArguments[i] instanceof TypeVariable) {
          Class<?> resolvedType=TypeManufacturerUtil.resolveGenericParameter(typeArguments[i],typeArgsMap,typeGenericTypeArgs);
          if (!Collection.class.isAssignableFrom(resolvedType) && !Map.class.isAssignableFrom(resolvedType)) {
            typeArguments[i]=resolvedType;
          }
        }
      }
      setterArg=manufactureAttributeValue(pojo,manufacturingCtx,attributeType,genericType,pojoAttributeAnnotations,attribute.getName(),typeArgsMap,typeArguments);
    }
    try {
      setter.invoke(pojo,setterArg);
    }
 catch (    IllegalAccessException e) {
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",setter.toString());
      setter.setAccessible(true);
      setter.invoke(pojo,setterArg);
    }
  }
  for (  ClassAttribute readOnlyAttribute : classAttributes) {
    Method getter=PodamUtils.selectLatestMethod(readOnlyAttribute.getGetters());
    if (getter != null && !getter.getReturnType().isPrimitive()) {
      if (getter.getGenericParameterTypes().length == 0) {
        Object fieldValue=null;
        try {
          fieldValue=getter.invoke(pojo,PodamConstants.NO_ARGS);
        }
 catch (        Exception e) {
          LOG.debug(""String_Node_Str"",getter);
        }
        if (fieldValue != null) {
          LOG.debug(""String_Node_Str"",getter);
          Type[] genericTypeArgsAll;
          Map<String,Type> paramTypeArgsMap;
          if (getter.getGenericReturnType() instanceof ParameterizedType) {
            paramTypeArgsMap=new HashMap<String,Type>(typeArgsMap);
            ParameterizedType paramType=(ParameterizedType)getter.getGenericReturnType();
            Type[] actualTypes=paramType.getActualTypeArguments();
            TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),actualTypes);
            genericTypeArgsAll=TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),genericTypeArgs);
          }
 else {
            paramTypeArgsMap=typeArgsMap;
            genericTypeArgsAll=genericTypeArgs;
          }
          List<Annotation> pojoAttributeAnnotations=PodamUtils.getAttributeAnnotations(readOnlyAttribute.getAttribute(),getter);
          Class<?> fieldClass=fieldValue.getClass();
          Integer depth=manufacturingCtx.getPojos().get(fieldClass);
          if (depth == null) {
            depth=-1;
          }
          if (depth <= strategy.getMaxDepth(fieldClass)) {
            manufacturingCtx.getPojos().put(fieldClass,depth + 1);
            populatePojoInternal(fieldValue,pojoAttributeAnnotations,manufacturingCtx,paramTypeArgsMap,genericTypeArgsAll);
            manufacturingCtx.getPojos().put(fieldClass,depth);
          }
 else {
            LOG.warn(""String_Node_Str"",getter);
          }
        }
      }
 else {
        LOG.warn(""String_Node_Str"",getter);
      }
    }
  }
  Collection<Method> extraMethods=classInfoStrategy.getExtraMethods(pojoClass);
  if (null != extraMethods) {
    for (    Method extraMethod : extraMethods) {
      Object[] args=getParameterValuesForMethod(extraMethod,pojoClass,manufacturingCtx,typeArgsMap,genericTypeArgs);
      extraMethod.invoke(pojo,args);
    }
  }
  return pojo;
}","/** 
 * Fills given class filled with values dictated by the strategy
 * @param < T > The type for which should be populated
 * @param pojo An instance to be filled with dummy values
 * @param annotations a list of annotations attached to this POJO defined elsewhere 
 * @param manufacturingCtx the manufacturing context
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return An instance of &lt;T&gt; filled with dummy values
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If manufactured class cannot be loaded
 */
private <T>T populatePojoInternal(T pojo,List<Annotation> annotations,ManufacturingContext manufacturingCtx,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Class<?> pojoClass=pojo.getClass();
  if (pojo instanceof Collection && ((Collection<?>)pojo).isEmpty()) {
    @SuppressWarnings(""String_Node_Str"") Collection<Object> collection=(Collection<Object>)pojo;
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    Class<?> elementTypeClass=findInheretedCollectionElementType(collection,manufacturingCtx,elementGenericTypeArgs,typeArgsMap,genericTypeArgs);
    if (null == annotations) {
      annotations=new ArrayList<Annotation>();
    }
    for (    Annotation annotation : collection.getClass().getAnnotations()) {
      annotations.add(annotation);
    }
    String attributeName=null;
    fillCollection(manufacturingCtx,annotations,attributeName,collection,elementTypeClass,elementGenericTypeArgs.get());
  }
 else   if (pojo instanceof Map && ((Map<?,?>)pojo).isEmpty()) {
    @SuppressWarnings(""String_Node_Str"") Map<Object,Object> map=(Map<Object,Object>)pojo;
    MapArguments mapArguments=findInheretedMapElementType(map,manufacturingCtx,typeArgsMap,genericTypeArgs);
    if (null != annotations) {
      mapArguments.getAnnotations().addAll(annotations);
    }
    fillMap(mapArguments,manufacturingCtx);
  }
  Class<?>[] parameterTypes=null;
  Class<?> attributeType=null;
  ClassInfo classInfo=classInfoStrategy.getClassInfo(pojo.getClass());
  Set<ClassAttribute> classAttributes=classInfo.getClassAttributes();
  Object setterArg=null;
  Iterator<ClassAttribute> iter=classAttributes.iterator();
  while (iter.hasNext()) {
    ClassAttribute attribute=iter.next();
    Set<Method> setters=attribute.getSetters();
    if (setters.isEmpty()) {
      if (attribute.getGetters().isEmpty()) {
        iter.remove();
      }
      continue;
    }
 else {
      iter.remove();
    }
    Method setter=PodamUtils.selectLatestMethod(setters);
    parameterTypes=setter.getParameterTypes();
    if (parameterTypes.length != 1) {
      LOG.warn(""String_Node_Str"",setter);
      continue;
    }
    attributeType=parameterTypes[0];
    List<Annotation> pojoAttributeAnnotations=PodamUtils.getAttributeAnnotations(attribute.getAttribute(),setter);
    AttributeStrategy<?> attributeStrategy=TypeManufacturerUtil.findAttributeStrategy(strategy,pojoAttributeAnnotations,attributeType);
    if (null != attributeStrategy) {
      setterArg=TypeManufacturerUtil.returnAttributeDataStrategyValue(attributeType,attributeStrategy);
    }
 else {
      AtomicReference<Type[]> typeGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
      Type genericType=setter.getGenericParameterTypes()[0];
      final Type[] typeArguments;
      if (!(genericType instanceof GenericArrayType)) {
        attributeType=TypeManufacturerUtil.resolveGenericParameter(genericType,typeArgsMap,typeGenericTypeArgs);
        typeArguments=typeGenericTypeArgs.get();
      }
 else {
        typeArguments=PodamConstants.NO_TYPES;
      }
      for (int i=0; i < typeArguments.length; i++) {
        if (typeArguments[i] instanceof TypeVariable) {
          Class<?> resolvedType=TypeManufacturerUtil.resolveGenericParameter(typeArguments[i],typeArgsMap,typeGenericTypeArgs);
          if (!Collection.class.isAssignableFrom(resolvedType) && !Map.class.isAssignableFrom(resolvedType)) {
            typeArguments[i]=resolvedType;
          }
        }
      }
      setterArg=manufactureAttributeValue(pojo,manufacturingCtx,attributeType,genericType,pojoAttributeAnnotations,attribute.getName(),typeArgsMap,typeArguments);
    }
    try {
      setter.invoke(pojo,setterArg);
    }
 catch (    IllegalAccessException e) {
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",setter.toString());
      setter.setAccessible(true);
      setter.invoke(pojo,setterArg);
    }
  }
  for (  ClassAttribute readOnlyAttribute : classAttributes) {
    Method getter=PodamUtils.selectLatestMethod(readOnlyAttribute.getGetters());
    if (getter != null && !getter.getReturnType().isPrimitive()) {
      if (getter.getGenericParameterTypes().length == 0) {
        Object fieldValue=null;
        try {
          fieldValue=getter.invoke(pojo,PodamConstants.NO_ARGS);
        }
 catch (        Exception e) {
          LOG.debug(""String_Node_Str"",getter);
        }
        if (fieldValue != null) {
          LOG.debug(""String_Node_Str"",getter);
          Type[] genericTypeArgsAll;
          Map<String,Type> paramTypeArgsMap;
          if (getter.getGenericReturnType() instanceof ParameterizedType) {
            paramTypeArgsMap=new HashMap<String,Type>(typeArgsMap);
            ParameterizedType paramType=(ParameterizedType)getter.getGenericReturnType();
            Type[] actualTypes=paramType.getActualTypeArguments();
            TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),actualTypes);
            genericTypeArgsAll=TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),genericTypeArgs);
          }
 else {
            paramTypeArgsMap=typeArgsMap;
            genericTypeArgsAll=genericTypeArgs;
          }
          List<Annotation> pojoAttributeAnnotations=PodamUtils.getAttributeAnnotations(readOnlyAttribute.getAttribute(),getter);
          Class<?> fieldClass=fieldValue.getClass();
          Integer depth=manufacturingCtx.getPojos().get(fieldClass);
          if (depth == null) {
            depth=-1;
          }
          if (depth <= strategy.getMaxDepth(fieldClass)) {
            manufacturingCtx.getPojos().put(fieldClass,depth + 1);
            populatePojoInternal(fieldValue,pojoAttributeAnnotations,manufacturingCtx,paramTypeArgsMap,genericTypeArgsAll);
            manufacturingCtx.getPojos().put(fieldClass,depth);
          }
 else {
            LOG.warn(""String_Node_Str"",getter);
          }
        }
      }
 else {
        LOG.warn(""String_Node_Str"",getter);
      }
    }
  }
  Collection<Method> extraMethods=classInfoStrategy.getExtraMethods(pojoClass);
  if (null != extraMethods) {
    for (    Method extraMethod : extraMethods) {
      Object[] args=getParameterValuesForMethod(extraMethod,pojoClass,manufacturingCtx,typeArgsMap,genericTypeArgs);
      extraMethod.invoke(pojo,args);
    }
  }
  return pojo;
}",0.9894380501015572
175914,"/** 
 * It fills an Array with the required number of elements of the required type. <p> This method has a so-called side-effect. It updates the Map given as argument. </p>
 * @param array The array POJO
 * @param attributeName The attribute name of collection in enclosing POJO class 
 * @param elementType The generic type of the collection element
 * @param genericElementType The generic type of the collection element
 * @param annotations The annotations for this attribute
 * @param manufacturingCtx Manufacturing context
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If it was not possible to create a class from a string
 */
private void fillArray(Object array,String attributeName,Class<?> elementType,Type genericElementType,List<Annotation> annotations,ManufacturingContext manufacturingCtx,Map<String,Type> typeArgsMap) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Class<?> componentType=array.getClass().getComponentType();
  Type genericComponentType;
  AtomicReference<Type[]> genericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
  if (genericElementType instanceof GenericArrayType) {
    genericComponentType=((GenericArrayType)genericElementType).getGenericComponentType();
    if (genericComponentType instanceof TypeVariable) {
      TypeVariable<?> componentTypeVariable=(TypeVariable<?>)genericComponentType;
      final Type resolvedType=typeArgsMap.get(componentTypeVariable.getName());
      componentType=TypeManufacturerUtil.resolveGenericParameter(resolvedType,typeArgsMap,genericTypeArgs);
    }
  }
 else {
    genericComponentType=componentType;
  }
  Holder<AttributeStrategy<?>> elementStrategyHolder=new Holder<AttributeStrategy<?>>();
  Holder<AttributeStrategy<?>> keyStrategyHolder=null;
  Integer nbrElements=TypeManufacturerUtil.findCollectionSize(strategy,annotations,elementType,elementStrategyHolder,keyStrategyHolder);
  AttributeStrategy<?> elementStrategy=elementStrategyHolder.value;
  for (int i=0; i < nbrElements; i++) {
    Object arrayElement=Array.get(array,i);
    if (null == arrayElement || arrayElement.getClass().isPrimitive() || arrayElement instanceof Number) {
      arrayElement=TypeManufacturerUtil.returnAttributeDataStrategyValue(componentType,elementStrategy);
      if (null == arrayElement) {
        arrayElement=manufactureAttributeValue(array,manufacturingCtx,componentType,genericComponentType,annotations,attributeName,typeArgsMap,genericTypeArgs.get());
      }
      Array.set(array,i,arrayElement);
    }
  }
}","/** 
 * It fills an Array with the required number of elements of the required type. <p> This method has a so-called side-effect. It updates the Map given as argument. </p>
 * @param array The array POJO
 * @param attributeName The attribute name of collection in enclosing POJO class 
 * @param elementType The generic type of the collection element
 * @param genericElementType The generic type of the collection element
 * @param annotations The annotations for this attribute
 * @param manufacturingCtx Manufacturing context
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If it was not possible to create a class from a string
 */
private void fillArray(Object array,String attributeName,Class<?> elementType,Type genericElementType,List<Annotation> annotations,ManufacturingContext manufacturingCtx,Map<String,Type> typeArgsMap) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Class<?> componentType=array.getClass().getComponentType();
  Type genericComponentType;
  AtomicReference<Type[]> genericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
  if (genericElementType instanceof GenericArrayType) {
    genericComponentType=((GenericArrayType)genericElementType).getGenericComponentType();
    if (genericComponentType instanceof TypeVariable) {
      TypeVariable<?> componentTypeVariable=(TypeVariable<?>)genericComponentType;
      final Type resolvedType=typeArgsMap.get(componentTypeVariable.getName());
      componentType=TypeManufacturerUtil.resolveGenericParameter(resolvedType,typeArgsMap,genericTypeArgs);
    }
  }
 else {
    genericComponentType=componentType;
  }
  Holder<AttributeStrategy<?>> elementStrategyHolder=new Holder<AttributeStrategy<?>>();
  Holder<AttributeStrategy<?>> keyStrategyHolder=null;
  TypeManufacturerUtil.findCollectionSize(strategy,annotations,elementType,elementStrategyHolder,keyStrategyHolder);
  AttributeStrategy<?> elementStrategy=elementStrategyHolder.value;
  int nbrElements=Array.getLength(array);
  for (int i=0; i < nbrElements; i++) {
    Object arrayElement=Array.get(array,i);
    if (null == arrayElement || arrayElement.getClass().isPrimitive() || arrayElement instanceof Number) {
      arrayElement=TypeManufacturerUtil.returnAttributeDataStrategyValue(componentType,elementStrategy);
      if (null == arrayElement) {
        arrayElement=manufactureAttributeValue(array,manufacturingCtx,componentType,genericComponentType,annotations,attributeName,typeArgsMap,genericTypeArgs.get());
      }
      Array.set(array,i,arrayElement);
    }
  }
}",0.989527027027027
175915,"/** 
 * Fills given class filled with values dictated by the strategy
 * @param < T > The type for which should be populated
 * @param pojo An instance to be filled with dummy values
 * @param annotations a list of annotations attached to this POJO defined elsewhere 
 * @param manufacturingCtx the manufacturing context
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return An instance of &lt;T&gt; filled with dummy values
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If manufactured class cannot be loaded
 */
private <T>T populatePojoInternal(T pojo,List<Annotation> annotations,ManufacturingContext manufacturingCtx,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Class<?> pojoClass=pojo.getClass();
  if (pojo instanceof Collection && ((Collection<?>)pojo).isEmpty()) {
    @SuppressWarnings(""String_Node_Str"") Collection<Object> collection=(Collection<Object>)pojo;
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    Class<?> elementTypeClass=findInheretedCollectionElementType(collection,manufacturingCtx,elementGenericTypeArgs,typeArgsMap,genericTypeArgs);
    if (null == annotations) {
      annotations=new ArrayList<Annotation>();
    }
    for (    Annotation annotation : collection.getClass().getAnnotations()) {
      annotations.add(annotation);
    }
    String attributeName=null;
    fillCollection(manufacturingCtx,annotations,attributeName,collection,elementTypeClass,elementGenericTypeArgs.get());
  }
 else   if (pojo instanceof Map && ((Map<?,?>)pojo).isEmpty()) {
    @SuppressWarnings(""String_Node_Str"") Map<Object,Object> map=(Map<Object,Object>)pojo;
    MapArguments mapArguments=findInheretedMapElementType(map,manufacturingCtx,typeArgsMap,genericTypeArgs);
    if (null != annotations) {
      mapArguments.getAnnotations().addAll(annotations);
    }
    fillMap(mapArguments,manufacturingCtx);
  }
  Class<?>[] parameterTypes=null;
  Class<?> attributeType=null;
  ClassInfo classInfo=classInfoStrategy.getClassInfo(pojo.getClass());
  Set<ClassAttribute> classAttributes=classInfo.getClassAttributes();
  Object setterArg=null;
  Iterator<ClassAttribute> iter=classAttributes.iterator();
  while (iter.hasNext()) {
    ClassAttribute attribute=iter.next();
    Set<Method> setters=attribute.getSetters();
    if (setters.isEmpty()) {
      if (attribute.getGetters().isEmpty()) {
        iter.remove();
      }
      continue;
    }
 else {
      iter.remove();
    }
    Method setter=PodamUtils.selectLatestMethod(setters);
    parameterTypes=setter.getParameterTypes();
    if (parameterTypes.length != 1) {
      LOG.warn(""String_Node_Str"",setter);
      continue;
    }
    attributeType=parameterTypes[0];
    List<Annotation> pojoAttributeAnnotations=PodamUtils.getAttributeAnnotations(attribute.getAttribute(),setter);
    AttributeStrategy<?> attributeStrategy=TypeManufacturerUtil.findAttributeStrategy(strategy,pojoAttributeAnnotations,attributeType);
    if (null != attributeStrategy) {
      setterArg=TypeManufacturerUtil.returnAttributeDataStrategyValue(attributeType,attributeStrategy);
    }
 else {
      AtomicReference<Type[]> typeGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
      Type genericType=setter.getGenericParameterTypes()[0];
      final Type[] typeArguments;
      if (!(genericType instanceof GenericArrayType)) {
        attributeType=TypeManufacturerUtil.resolveGenericParameter(genericType,typeArgsMap,typeGenericTypeArgs);
        typeArguments=typeGenericTypeArgs.get();
      }
 else {
        typeArguments=PodamConstants.NO_TYPES;
      }
      for (int i=0; i < typeArguments.length; i++) {
        if (typeArguments[i] instanceof TypeVariable) {
          Class<?> resolvedType=TypeManufacturerUtil.resolveGenericParameter(typeArguments[i],typeArgsMap,typeGenericTypeArgs);
          if (!Collection.class.isAssignableFrom(resolvedType) && !Map.class.isAssignableFrom(resolvedType)) {
            typeArguments[i]=resolvedType;
          }
        }
      }
      setterArg=manufactureAttributeValue(pojo,manufacturingCtx,attributeType,genericType,pojoAttributeAnnotations,attribute.getName(),typeArgsMap,typeArguments);
    }
    try {
      setter.invoke(pojo,setterArg);
    }
 catch (    IllegalAccessException e) {
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",setter.toString());
      setter.setAccessible(true);
      setter.invoke(pojo,setterArg);
    }
  }
  for (  ClassAttribute readOnlyAttribute : classAttributes) {
    Method getter=PodamUtils.selectLatestMethod(readOnlyAttribute.getGetters());
    if (getter != null && !getter.getReturnType().isPrimitive()) {
      if (getter.getGenericParameterTypes().length == 0) {
        Object fieldValue=null;
        try {
          fieldValue=getter.invoke(pojo,PodamConstants.NO_ARGS);
        }
 catch (        Exception e) {
          LOG.debug(""String_Node_Str"",getter);
        }
        if (fieldValue != null) {
          LOG.debug(""String_Node_Str"",getter);
          Type[] genericTypeArgsAll;
          Map<String,Type> paramTypeArgsMap;
          if (getter.getGenericReturnType() instanceof ParameterizedType) {
            paramTypeArgsMap=new HashMap<String,Type>(typeArgsMap);
            ParameterizedType paramType=(ParameterizedType)getter.getGenericReturnType();
            Type[] actualTypes=paramType.getActualTypeArguments();
            TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),actualTypes);
            genericTypeArgsAll=TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),genericTypeArgs);
          }
 else {
            paramTypeArgsMap=typeArgsMap;
            genericTypeArgsAll=genericTypeArgs;
          }
          List<Annotation> pojoAttributeAnnotations=PodamUtils.getAttributeAnnotations(readOnlyAttribute.getAttribute(),getter);
          Class<?> fieldClass=fieldValue.getClass();
          Integer depth=manufacturingCtx.getPojos().get(fieldClass);
          if (depth == null) {
            depth=-1;
          }
          if (depth <= strategy.getMaxDepth(fieldClass)) {
            manufacturingCtx.getPojos().put(fieldClass,depth + 1);
            populatePojoInternal(fieldValue,pojoAttributeAnnotations,manufacturingCtx,paramTypeArgsMap,genericTypeArgsAll);
            manufacturingCtx.getPojos().put(fieldClass,depth);
          }
 else {
            LOG.warn(""String_Node_Str"",getter);
          }
        }
      }
 else {
        LOG.warn(""String_Node_Str"",getter);
      }
    }
  }
  Collection<Method> extraMethods=classInfoStrategy.getExtraMethods(pojoClass);
  if (null != extraMethods) {
    for (    Method extraMethod : extraMethods) {
      Object[] args=getParameterValuesForMethod(extraMethod,pojoClass,manufacturingCtx,typeArgsMap,genericTypeArgs);
      extraMethod.invoke(pojo,args);
    }
  }
  return pojo;
}","/** 
 * Fills given class filled with values dictated by the strategy
 * @param < T > The type for which should be populated
 * @param pojo An instance to be filled with dummy values
 * @param annotations a list of annotations attached to this POJO defined elsewhere 
 * @param manufacturingCtx the manufacturing context
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return An instance of &lt;T&gt; filled with dummy values
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If manufactured class cannot be loaded
 */
private <T>T populatePojoInternal(T pojo,List<Annotation> annotations,ManufacturingContext manufacturingCtx,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Class<?> pojoClass=pojo.getClass();
  if (pojoClass.isArray()) {
    if (null == annotations) {
      annotations=new ArrayList<Annotation>();
    }
    String attributeName=null;
    fillArray(pojo,attributeName,pojoClass.getClass().getComponentType(),pojoClass.getClass().getComponentType(),annotations,manufacturingCtx,typeArgsMap);
  }
  if (pojo instanceof Collection && ((Collection<?>)pojo).isEmpty()) {
    @SuppressWarnings(""String_Node_Str"") Collection<Object> collection=(Collection<Object>)pojo;
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    Class<?> elementTypeClass=findInheretedCollectionElementType(collection,manufacturingCtx,elementGenericTypeArgs,typeArgsMap,genericTypeArgs);
    if (null == annotations) {
      annotations=new ArrayList<Annotation>();
    }
    for (    Annotation annotation : collection.getClass().getAnnotations()) {
      annotations.add(annotation);
    }
    String attributeName=null;
    fillCollection(manufacturingCtx,annotations,attributeName,collection,elementTypeClass,elementGenericTypeArgs.get());
  }
 else   if (pojo instanceof Map && ((Map<?,?>)pojo).isEmpty()) {
    @SuppressWarnings(""String_Node_Str"") Map<Object,Object> map=(Map<Object,Object>)pojo;
    MapArguments mapArguments=findInheretedMapElementType(map,manufacturingCtx,typeArgsMap,genericTypeArgs);
    if (null != annotations) {
      mapArguments.getAnnotations().addAll(annotations);
    }
    fillMap(mapArguments,manufacturingCtx);
  }
  Class<?>[] parameterTypes=null;
  Class<?> attributeType=null;
  ClassInfo classInfo=classInfoStrategy.getClassInfo(pojo.getClass());
  Set<ClassAttribute> classAttributes=classInfo.getClassAttributes();
  Object setterArg=null;
  Iterator<ClassAttribute> iter=classAttributes.iterator();
  while (iter.hasNext()) {
    ClassAttribute attribute=iter.next();
    Set<Method> setters=attribute.getSetters();
    if (setters.isEmpty()) {
      if (attribute.getGetters().isEmpty()) {
        iter.remove();
      }
      continue;
    }
 else {
      iter.remove();
    }
    Method setter=PodamUtils.selectLatestMethod(setters);
    parameterTypes=setter.getParameterTypes();
    if (parameterTypes.length != 1) {
      LOG.warn(""String_Node_Str"",setter);
      continue;
    }
    attributeType=parameterTypes[0];
    List<Annotation> pojoAttributeAnnotations=PodamUtils.getAttributeAnnotations(attribute.getAttribute(),setter);
    AttributeStrategy<?> attributeStrategy=TypeManufacturerUtil.findAttributeStrategy(strategy,pojoAttributeAnnotations,attributeType);
    if (null != attributeStrategy) {
      setterArg=TypeManufacturerUtil.returnAttributeDataStrategyValue(attributeType,attributeStrategy);
    }
 else {
      AtomicReference<Type[]> typeGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
      Type genericType=setter.getGenericParameterTypes()[0];
      final Type[] typeArguments;
      if (!(genericType instanceof GenericArrayType)) {
        attributeType=TypeManufacturerUtil.resolveGenericParameter(genericType,typeArgsMap,typeGenericTypeArgs);
        typeArguments=typeGenericTypeArgs.get();
      }
 else {
        typeArguments=PodamConstants.NO_TYPES;
      }
      for (int i=0; i < typeArguments.length; i++) {
        if (typeArguments[i] instanceof TypeVariable) {
          Class<?> resolvedType=TypeManufacturerUtil.resolveGenericParameter(typeArguments[i],typeArgsMap,typeGenericTypeArgs);
          if (!Collection.class.isAssignableFrom(resolvedType) && !Map.class.isAssignableFrom(resolvedType)) {
            typeArguments[i]=resolvedType;
          }
        }
      }
      setterArg=manufactureAttributeValue(pojo,manufacturingCtx,attributeType,genericType,pojoAttributeAnnotations,attribute.getName(),typeArgsMap,typeArguments);
    }
    try {
      setter.invoke(pojo,setterArg);
    }
 catch (    IllegalAccessException e) {
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",setter.toString());
      setter.setAccessible(true);
      setter.invoke(pojo,setterArg);
    }
  }
  for (  ClassAttribute readOnlyAttribute : classAttributes) {
    Method getter=PodamUtils.selectLatestMethod(readOnlyAttribute.getGetters());
    if (getter != null && !getter.getReturnType().isPrimitive()) {
      if (getter.getGenericParameterTypes().length == 0) {
        Object fieldValue=null;
        try {
          fieldValue=getter.invoke(pojo,PodamConstants.NO_ARGS);
        }
 catch (        Exception e) {
          LOG.debug(""String_Node_Str"",getter);
        }
        if (fieldValue != null) {
          LOG.debug(""String_Node_Str"",getter);
          Type[] genericTypeArgsAll;
          Map<String,Type> paramTypeArgsMap;
          if (getter.getGenericReturnType() instanceof ParameterizedType) {
            paramTypeArgsMap=new HashMap<String,Type>(typeArgsMap);
            ParameterizedType paramType=(ParameterizedType)getter.getGenericReturnType();
            Type[] actualTypes=paramType.getActualTypeArguments();
            TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),actualTypes);
            genericTypeArgsAll=TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),genericTypeArgs);
          }
 else {
            paramTypeArgsMap=typeArgsMap;
            genericTypeArgsAll=genericTypeArgs;
          }
          List<Annotation> pojoAttributeAnnotations=PodamUtils.getAttributeAnnotations(readOnlyAttribute.getAttribute(),getter);
          Class<?> fieldClass=fieldValue.getClass();
          Integer depth=manufacturingCtx.getPojos().get(fieldClass);
          if (depth == null) {
            depth=-1;
          }
          if (depth <= strategy.getMaxDepth(fieldClass)) {
            manufacturingCtx.getPojos().put(fieldClass,depth + 1);
            populatePojoInternal(fieldValue,pojoAttributeAnnotations,manufacturingCtx,paramTypeArgsMap,genericTypeArgsAll);
            manufacturingCtx.getPojos().put(fieldClass,depth);
          }
 else {
            LOG.warn(""String_Node_Str"",getter);
          }
        }
      }
 else {
        LOG.warn(""String_Node_Str"",getter);
      }
    }
  }
  Collection<Method> extraMethods=classInfoStrategy.getExtraMethods(pojoClass);
  if (null != extraMethods) {
    for (    Method extraMethod : extraMethods) {
      Object[] args=getParameterValuesForMethod(extraMethod,pojoClass,manufacturingCtx,typeArgsMap,genericTypeArgs);
      extraMethod.invoke(pojo,args);
    }
  }
  return pojo;
}",0.979957805907173
175916,"/** 
 * It resolves generic parameter type
 * @param paramType The generic parameter type
 * @param typeArgsMap A map of resolved types
 * @param methodGenericTypeArgs Return value posible generic types of the generic parameter type
 * @return value for class representing the generic parameter type
 */
public static Class<?> resolveGenericParameter(Type paramType,Map<String,Type> typeArgsMap,AtomicReference<Type[]> methodGenericTypeArgs){
  Class<?> parameterType=null;
  Map<String,Type> localMap=new HashMap<String,Type>(typeArgsMap);
  methodGenericTypeArgs.set(PodamConstants.NO_TYPES);
  if (paramType instanceof TypeVariable<?>) {
    final TypeVariable<?> typeVariable=(TypeVariable<?>)paramType;
    final Type type=localMap.get(typeVariable.getName());
    if (type != null) {
      parameterType=resolveGenericParameter(type,localMap,methodGenericTypeArgs);
    }
  }
 else   if (paramType instanceof ParameterizedType) {
    ParameterizedType pType=(ParameterizedType)paramType;
    parameterType=(Class<?>)pType.getRawType();
    methodGenericTypeArgs.set(pType.getActualTypeArguments());
  }
 else   if (paramType instanceof WildcardType) {
    WildcardType wType=(WildcardType)paramType;
    Type[] bounds=wType.getLowerBounds();
    String msg;
    if (bounds != null && bounds.length > 0) {
      msg=""String_Node_Str"";
    }
 else {
      bounds=wType.getUpperBounds();
      msg=""String_Node_Str"";
    }
    if (bounds != null && bounds.length > 0) {
      LOG.debug(msg + Arrays.toString(bounds));
      parameterType=resolveGenericParameter(bounds[0],localMap,methodGenericTypeArgs);
    }
  }
 else   if (paramType instanceof Class) {
    parameterType=(Class<?>)paramType;
  }
  if (parameterType == null) {
    LOG.warn(""String_Node_Str"",paramType);
    parameterType=Object.class;
  }
  return parameterType;
}","/** 
 * It resolves generic parameter type
 * @param paramType The generic parameter type
 * @param typeArgsMap A map of resolved types
 * @param methodGenericTypeArgs Return value posible generic types of the generic parameter type
 * @return value for class representing the generic parameter type
 */
public static Class<?> resolveGenericParameter(Type paramType,Map<String,Type> typeArgsMap,AtomicReference<Type[]> methodGenericTypeArgs){
  Class<?> parameterType=null;
  Map<String,Type> localMap=new HashMap<String,Type>(typeArgsMap);
  methodGenericTypeArgs.set(PodamConstants.NO_TYPES);
  if (paramType instanceof Class) {
    parameterType=(Class<?>)paramType;
  }
 else   if (paramType instanceof TypeVariable<?>) {
    final TypeVariable<?> typeVariable=(TypeVariable<?>)paramType;
    final Type type=localMap.get(typeVariable.getName());
    if (type != null) {
      parameterType=resolveGenericParameter(type,localMap,methodGenericTypeArgs);
    }
  }
 else   if (paramType instanceof ParameterizedType) {
    ParameterizedType pType=(ParameterizedType)paramType;
    parameterType=(Class<?>)pType.getRawType();
    Type[] actualTypeArgs=pType.getActualTypeArguments();
    if (!typeArgsMap.isEmpty()) {
      for (int i=0; i < actualTypeArgs.length; i++) {
        Class<?> tmp=resolveGenericParameter(actualTypeArgs[i],localMap,methodGenericTypeArgs);
        if (tmp != actualTypeArgs[i]) {
          if (ArrayUtils.isEmpty(methodGenericTypeArgs.get())) {
            actualTypeArgs[i]=tmp;
          }
        }
      }
    }
    methodGenericTypeArgs.set(actualTypeArgs);
  }
 else   if (paramType instanceof WildcardType) {
    WildcardType wType=(WildcardType)paramType;
    Type[] bounds=wType.getLowerBounds();
    String msg;
    if (bounds != null && bounds.length > 0) {
      msg=""String_Node_Str"";
    }
 else {
      bounds=wType.getUpperBounds();
      msg=""String_Node_Str"";
    }
    if (bounds != null && bounds.length > 0) {
      LOG.debug(msg + Arrays.toString(bounds));
      parameterType=resolveGenericParameter(bounds[0],localMap,methodGenericTypeArgs);
    }
  }
  if (parameterType == null) {
    LOG.warn(""String_Node_Str"",paramType);
    parameterType=Object.class;
  }
  return parameterType;
}",0.6669936243256498
175917,"/** 
 * It returns a   {@link Calendar} objects complying with Java bean validationannotations. {@inheritDoc}
 */
public Object getValue() throws PodamMockeryException {
  if (null != findTypeFromList(annotations,AssertTrue.class)) {
    return Boolean.TRUE;
  }
  if (null != findTypeFromList(annotations,AssertFalse.class)) {
    return Boolean.FALSE;
  }
  if (null != findTypeFromList(annotations,Past.class)) {
    int days=RANDOM.nextInt(365) + 1;
    long timestamp=System.currentTimeMillis() - TimeUnit.DAYS.toSeconds(days);
    return timestampToReturnType(timestamp);
  }
  if (null != findTypeFromList(annotations,Future.class)) {
    int days=RANDOM.nextInt(365) + 1;
    long timestamp=System.currentTimeMillis() + TimeUnit.DAYS.toSeconds(days);
    return timestampToReturnType(timestamp);
  }
  Size size=findTypeFromList(annotations,Size.class);
  if (null != size) {
    int minValue=size.min();
    int maxValue=size.max();
    if (maxValue == Integer.MAX_VALUE) {
      maxValue=PodamConstants.STR_DEFAULT_LENGTH;
    }
    long length=PodamUtils.getLongInRange(minValue,maxValue);
    StringBuilder sb=new StringBuilder();
    while (sb.length() < length) {
      sb.append(PodamUtils.getNiceCharacter());
    }
    return sb.toString();
  }
  Pattern pattern=findTypeFromList(annotations,Pattern.class);
  if (null != pattern) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"",pattern.regexp());
    return null;
  }
  boolean isRound=false;
  boolean isFloat=false;
  BigDecimal min=new BigDecimal(Double.MIN_VALUE);
  BigDecimal max=new BigDecimal(Double.MAX_VALUE);
  DecimalMin decimalMin=findTypeFromList(annotations,DecimalMin.class);
  if (null != decimalMin) {
    isFloat=true;
    min=new BigDecimal(decimalMin.value());
  }
  DecimalMax decimalMax=findTypeFromList(annotations,DecimalMax.class);
  if (null != decimalMax) {
    isFloat=true;
    max=new BigDecimal(decimalMax.value());
  }
  Min minAnno=findTypeFromList(annotations,Min.class);
  if (null != minAnno) {
    isRound=true;
    min=new BigDecimal(minAnno.value()).max(min);
  }
  Max maxAnno=findTypeFromList(annotations,Max.class);
  if (null != maxAnno) {
    isRound=true;
    max=new BigDecimal(maxAnno.value()).min(max);
  }
  Digits digits=findTypeFromList(annotations,Digits.class);
  BigDecimal divisor=null;
  if (null != digits) {
    isRound=true;
    divisor=BigDecimal.TEN.pow(digits.fraction());
    max=BigDecimal.TEN.pow(digits.integer()).min(max).multiply(divisor);
    min=max.negate().max(min);
  }
  if (isRound || isFloat) {
    BigDecimal value=getValueInRange(min,max);
    if (isRound) {
      BigInteger intValue=value.toBigInteger();
      value=new BigDecimal(intValue);
    }
    if (null != divisor) {
      value=value.divide(divisor);
    }
    return decimalToReturnType(value);
  }
  return null;
}","/** 
 * It returns a   {@link Calendar} objects complying with Java bean validationannotations. {@inheritDoc}
 */
public Object getValue() throws PodamMockeryException {
  if (null != findTypeFromList(annotations,AssertTrue.class)) {
    return Boolean.TRUE;
  }
  if (null != findTypeFromList(annotations,AssertFalse.class)) {
    return Boolean.FALSE;
  }
  if (null != findTypeFromList(annotations,Past.class)) {
    int days=RANDOM.nextInt(365) + 1;
    long timestamp=System.currentTimeMillis() - TimeUnit.DAYS.toSeconds(days);
    return timestampToReturnType(timestamp);
  }
  if (null != findTypeFromList(annotations,Future.class)) {
    int days=RANDOM.nextInt(365) + 1;
    long timestamp=System.currentTimeMillis() + TimeUnit.DAYS.toSeconds(days);
    return timestampToReturnType(timestamp);
  }
  Size size=findTypeFromList(annotations,Size.class);
  if (null != size) {
    int minValue=size.min();
    int maxValue=size.max();
    if (maxValue == Integer.MAX_VALUE) {
      maxValue=PodamConstants.STR_DEFAULT_LENGTH;
    }
    long length=PodamUtils.getLongInRange(minValue,maxValue);
    StringBuilder sb=new StringBuilder();
    while (sb.length() < length) {
      sb.append(PodamUtils.getNiceCharacter());
    }
    return sb.toString();
  }
  Pattern pattern=findTypeFromList(annotations,Pattern.class);
  if (null != pattern) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"",pattern.regexp());
    return null;
  }
  boolean isRound=false;
  boolean isFloat=false;
  BigDecimal min=new BigDecimal(-Double.MAX_VALUE);
  BigDecimal max=new BigDecimal(Double.MAX_VALUE);
  DecimalMin decimalMin=findTypeFromList(annotations,DecimalMin.class);
  if (null != decimalMin) {
    isFloat=true;
    min=new BigDecimal(decimalMin.value());
  }
  DecimalMax decimalMax=findTypeFromList(annotations,DecimalMax.class);
  if (null != decimalMax) {
    isFloat=true;
    max=new BigDecimal(decimalMax.value());
  }
  Min minAnno=findTypeFromList(annotations,Min.class);
  if (null != minAnno) {
    isRound=true;
    min=new BigDecimal(minAnno.value()).max(min);
  }
  Max maxAnno=findTypeFromList(annotations,Max.class);
  if (null != maxAnno) {
    isRound=true;
    max=new BigDecimal(maxAnno.value()).min(max);
  }
  Digits digits=findTypeFromList(annotations,Digits.class);
  BigDecimal divisor=null;
  if (null != digits) {
    isRound=true;
    divisor=BigDecimal.TEN.pow(digits.fraction());
    BigDecimal limit=BigDecimal.TEN.pow(digits.integer());
    max=limit.min(max).multiply(divisor);
    min=limit.negate().max(min).multiply(divisor);
  }
  if (isRound || isFloat) {
    BigDecimal value=getValueInRange(min,max);
    if (isRound) {
      BigInteger intValue=value.toBigInteger();
      value=new BigDecimal(intValue);
    }
    if (null != divisor) {
      value=value.divide(divisor);
    }
    return decimalToReturnType(value);
  }
  return null;
}",0.9647924330005256
175918,"/** 
 * It returns a collection of some sort with some data in it.
 * @param pojo The POJO being analyzed
 * @param manufacturingCtx the manufacturing context
 * @param attributeMetadata The attribute's metadata
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @return a collection of some sort with some data in it
 * @throws PodamMockeryException An exception occurred while resolving the collection
 * @throws IllegalArgumentException If the field name is null or empty
 */
private Collection<? super Object> resolveCollectionValueWhenCollectionIsPojoAttribute(Object pojo,ManufacturingContext manufacturingCtx,AttributeMetadata attributeMetadata,Map<String,Type> typeArgsMap){
  String attributeName=attributeMetadata.getAttributeName();
  Collection<Object> defaultValue=null;
  if (null != pojo && null != attributeName) {
    defaultValue=PodamUtils.getFieldValue(pojo,attributeName);
  }
  Collection<Object> retValue=null;
  if (null != defaultValue && (defaultValue.getClass().getModifiers() & Modifier.PRIVATE) == 0) {
    retValue=defaultValue;
  }
 else {
    @SuppressWarnings(""String_Node_Str"") Class<Collection<Object>> collectionType=(Class<Collection<Object>>)attributeMetadata.getAttributeType();
    retValue=strategy.getTypeValue(attributeMetadata,typeArgsMap,collectionType);
    if (null != retValue && null != defaultValue) {
      retValue.addAll(defaultValue);
    }
  }
  if (null == retValue) {
    return null;
  }
  try {
    Class<?> typeClass=null;
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    if (ArrayUtils.isEmpty(attributeMetadata.getAttrGenericArgs())) {
      typeClass=findInheretedCollectionElementType(retValue,manufacturingCtx,elementGenericTypeArgs,typeArgsMap,attributeMetadata.getAttrGenericArgs());
    }
 else {
      Type actualTypeArgument=attributeMetadata.getAttrGenericArgs()[0];
      typeClass=TypeManufacturerUtil.resolveGenericParameter(actualTypeArgument,typeArgsMap,elementGenericTypeArgs);
    }
    fillCollection(manufacturingCtx,attributeMetadata.getAttributeAnnotations(),attributeName,retValue,typeClass,elementGenericTypeArgs.get());
  }
 catch (  SecurityException e) {
    throw new PodamMockeryException(RESOLVING_COLLECTION_EXCEPTION_STR,e);
  }
catch (  IllegalArgumentException e) {
    throw new PodamMockeryException(RESOLVING_COLLECTION_EXCEPTION_STR,e);
  }
catch (  InstantiationException e) {
    throw new PodamMockeryException(RESOLVING_COLLECTION_EXCEPTION_STR,e);
  }
catch (  IllegalAccessException e) {
    throw new PodamMockeryException(RESOLVING_COLLECTION_EXCEPTION_STR,e);
  }
catch (  ClassNotFoundException e) {
    throw new PodamMockeryException(RESOLVING_COLLECTION_EXCEPTION_STR,e);
  }
catch (  InvocationTargetException e) {
    throw new PodamMockeryException(RESOLVING_COLLECTION_EXCEPTION_STR,e);
  }
  return retValue;
}","/** 
 * It returns a collection of some sort with some data in it.
 * @param pojo The POJO being analyzed
 * @param manufacturingCtx the manufacturing context
 * @param attributeMetadata The attribute's metadata
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @return a collection of some sort with some data in it
 * @throws PodamMockeryException An exception occurred while resolving the collection
 * @throws IllegalArgumentException If the field name is null or empty
 */
private Collection<? super Object> resolveCollectionValueWhenCollectionIsPojoAttribute(Object pojo,ManufacturingContext manufacturingCtx,AttributeMetadata attributeMetadata,Map<String,Type> typeArgsMap){
  String attributeName=attributeMetadata.getAttributeName();
  Collection<Object> defaultValue=null;
  if (null != pojo && !Character.isDigit(attributeName.charAt(0))) {
    defaultValue=PodamUtils.getFieldValue(pojo,attributeName);
  }
  Collection<Object> retValue=null;
  if (null != defaultValue && (defaultValue.getClass().getModifiers() & Modifier.PRIVATE) == 0) {
    retValue=defaultValue;
  }
 else {
    @SuppressWarnings(""String_Node_Str"") Class<Collection<Object>> collectionType=(Class<Collection<Object>>)attributeMetadata.getAttributeType();
    retValue=strategy.getTypeValue(attributeMetadata,typeArgsMap,collectionType);
    if (null != retValue && null != defaultValue) {
      retValue.addAll(defaultValue);
    }
  }
  if (null == retValue) {
    return null;
  }
  try {
    Class<?> typeClass=null;
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    if (ArrayUtils.isEmpty(attributeMetadata.getAttrGenericArgs())) {
      typeClass=findInheretedCollectionElementType(retValue,manufacturingCtx,elementGenericTypeArgs,typeArgsMap,attributeMetadata.getAttrGenericArgs());
    }
 else {
      Type actualTypeArgument=attributeMetadata.getAttrGenericArgs()[0];
      typeClass=TypeManufacturerUtil.resolveGenericParameter(actualTypeArgument,typeArgsMap,elementGenericTypeArgs);
    }
    fillCollection(manufacturingCtx,attributeMetadata.getAttributeAnnotations(),attributeName,retValue,typeClass,elementGenericTypeArgs.get());
  }
 catch (  SecurityException e) {
    throw new PodamMockeryException(RESOLVING_COLLECTION_EXCEPTION_STR,e);
  }
catch (  IllegalArgumentException e) {
    throw new PodamMockeryException(RESOLVING_COLLECTION_EXCEPTION_STR,e);
  }
catch (  InstantiationException e) {
    throw new PodamMockeryException(RESOLVING_COLLECTION_EXCEPTION_STR,e);
  }
catch (  IllegalAccessException e) {
    throw new PodamMockeryException(RESOLVING_COLLECTION_EXCEPTION_STR,e);
  }
catch (  ClassNotFoundException e) {
    throw new PodamMockeryException(RESOLVING_COLLECTION_EXCEPTION_STR,e);
  }
catch (  InvocationTargetException e) {
    throw new PodamMockeryException(RESOLVING_COLLECTION_EXCEPTION_STR,e);
  }
  return retValue;
}",0.993933265925177
175919,"/** 
 * It manufactures and returns a Map with at least one element in it
 * @param pojo The POJO being initialized
 * @param manufacturingCtx the manufacturing context
 * @param attributeMetadata The attribute's metadata
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @return Map with at least one element in it
 * @throws IllegalArgumentException <ul> <li>If the attribute name is null or empty</li> <li>If the array of types of the Map has length different from 2</li> </ul>
 * @throws PodamMockeryException If an error occurred while creating the Map object
 */
private Map<? super Object,? super Object> resolveMapValueWhenMapIsPojoAttribute(Object pojo,ManufacturingContext manufacturingCtx,AttributeMetadata attributeMetadata,Map<String,Type> typeArgsMap){
  String attributeName=attributeMetadata.getAttributeName();
  Map<Object,Object> defaultValue=null;
  if (null != pojo && null != attributeName) {
    defaultValue=PodamUtils.getFieldValue(pojo,attributeName);
  }
  Map<Object,Object> retValue;
  if (null != defaultValue && (defaultValue.getClass().getModifiers() & Modifier.PRIVATE) == 0) {
    retValue=defaultValue;
  }
 else {
    @SuppressWarnings(""String_Node_Str"") Class<Map<Object,Object>> mapType=(Class<Map<Object,Object>>)attributeMetadata.getAttributeType();
    retValue=strategy.getTypeValue(attributeMetadata,typeArgsMap,mapType);
    if (null != retValue && null != defaultValue) {
      retValue.putAll(defaultValue);
    }
  }
  if (null == retValue) {
    return null;
  }
  try {
    Class<?> keyClass=null;
    Class<?> elementClass=null;
    AtomicReference<Type[]> keyGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    if (ArrayUtils.isEmpty(attributeMetadata.getAttrGenericArgs())) {
      MapArguments mapArgs=findInheretedMapElementType(retValue,manufacturingCtx,typeArgsMap,attributeMetadata.getAttrGenericArgs());
      keyClass=mapArgs.getKeyClass();
      elementClass=mapArgs.getElementClass();
    }
 else {
      if (attributeMetadata.getAttrGenericArgs().length != 2) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + Arrays.toString(attributeMetadata.getAttrGenericArgs()));
      }
      Type[] actualTypeArguments=attributeMetadata.getAttrGenericArgs();
      keyClass=TypeManufacturerUtil.resolveGenericParameter(actualTypeArguments[0],typeArgsMap,keyGenericTypeArgs);
      elementClass=TypeManufacturerUtil.resolveGenericParameter(actualTypeArguments[1],typeArgsMap,elementGenericTypeArgs);
    }
    MapArguments mapArguments=new MapArguments();
    mapArguments.setAttributeName(attributeName);
    mapArguments.setAnnotations(attributeMetadata.getAttributeAnnotations());
    mapArguments.setMapToBeFilled(retValue);
    mapArguments.setKeyClass(keyClass);
    mapArguments.setElementClass(elementClass);
    mapArguments.setKeyGenericTypeArgs(keyGenericTypeArgs.get());
    mapArguments.setElementGenericTypeArgs(elementGenericTypeArgs.get());
    fillMap(mapArguments,manufacturingCtx);
  }
 catch (  InstantiationException e) {
    throw new PodamMockeryException(MAP_CREATION_EXCEPTION_STR,e);
  }
catch (  IllegalAccessException e) {
    throw new PodamMockeryException(MAP_CREATION_EXCEPTION_STR,e);
  }
catch (  SecurityException e) {
    throw new PodamMockeryException(MAP_CREATION_EXCEPTION_STR,e);
  }
catch (  ClassNotFoundException e) {
    throw new PodamMockeryException(MAP_CREATION_EXCEPTION_STR,e);
  }
catch (  InvocationTargetException e) {
    throw new PodamMockeryException(MAP_CREATION_EXCEPTION_STR,e);
  }
  return retValue;
}","/** 
 * It manufactures and returns a Map with at least one element in it
 * @param pojo The POJO being initialized
 * @param manufacturingCtx the manufacturing context
 * @param attributeMetadata The attribute's metadata
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @return Map with at least one element in it
 * @throws IllegalArgumentException <ul> <li>If the attribute name is null or empty</li> <li>If the array of types of the Map has length different from 2</li> </ul>
 * @throws PodamMockeryException If an error occurred while creating the Map object
 */
private Map<? super Object,? super Object> resolveMapValueWhenMapIsPojoAttribute(Object pojo,ManufacturingContext manufacturingCtx,AttributeMetadata attributeMetadata,Map<String,Type> typeArgsMap){
  String attributeName=attributeMetadata.getAttributeName();
  Map<Object,Object> defaultValue=null;
  if (null != pojo && !Character.isDigit(attributeName.charAt(0))) {
    defaultValue=PodamUtils.getFieldValue(pojo,attributeName);
  }
  Map<Object,Object> retValue;
  if (null != defaultValue && (defaultValue.getClass().getModifiers() & Modifier.PRIVATE) == 0) {
    retValue=defaultValue;
  }
 else {
    @SuppressWarnings(""String_Node_Str"") Class<Map<Object,Object>> mapType=(Class<Map<Object,Object>>)attributeMetadata.getAttributeType();
    retValue=strategy.getTypeValue(attributeMetadata,typeArgsMap,mapType);
    if (null != retValue && null != defaultValue) {
      retValue.putAll(defaultValue);
    }
  }
  if (null == retValue) {
    return null;
  }
  try {
    Class<?> keyClass=null;
    Class<?> elementClass=null;
    AtomicReference<Type[]> keyGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    if (ArrayUtils.isEmpty(attributeMetadata.getAttrGenericArgs())) {
      MapArguments mapArgs=findInheretedMapElementType(retValue,manufacturingCtx,typeArgsMap,attributeMetadata.getAttrGenericArgs());
      keyClass=mapArgs.getKeyClass();
      elementClass=mapArgs.getElementClass();
    }
 else {
      if (attributeMetadata.getAttrGenericArgs().length != 2) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + Arrays.toString(attributeMetadata.getAttrGenericArgs()));
      }
      Type[] actualTypeArguments=attributeMetadata.getAttrGenericArgs();
      keyClass=TypeManufacturerUtil.resolveGenericParameter(actualTypeArguments[0],typeArgsMap,keyGenericTypeArgs);
      elementClass=TypeManufacturerUtil.resolveGenericParameter(actualTypeArguments[1],typeArgsMap,elementGenericTypeArgs);
    }
    MapArguments mapArguments=new MapArguments();
    mapArguments.setAttributeName(attributeName);
    mapArguments.setAnnotations(attributeMetadata.getAttributeAnnotations());
    mapArguments.setMapToBeFilled(retValue);
    mapArguments.setKeyClass(keyClass);
    mapArguments.setElementClass(elementClass);
    mapArguments.setKeyGenericTypeArgs(keyGenericTypeArgs.get());
    mapArguments.setElementGenericTypeArgs(elementGenericTypeArgs.get());
    fillMap(mapArguments,manufacturingCtx);
  }
 catch (  InstantiationException e) {
    throw new PodamMockeryException(MAP_CREATION_EXCEPTION_STR,e);
  }
catch (  IllegalAccessException e) {
    throw new PodamMockeryException(MAP_CREATION_EXCEPTION_STR,e);
  }
catch (  SecurityException e) {
    throw new PodamMockeryException(MAP_CREATION_EXCEPTION_STR,e);
  }
catch (  ClassNotFoundException e) {
    throw new PodamMockeryException(MAP_CREATION_EXCEPTION_STR,e);
  }
catch (  InvocationTargetException e) {
    throw new PodamMockeryException(MAP_CREATION_EXCEPTION_STR,e);
  }
  return retValue;
}",0.9952076677316294
175920,"/** 
 * It returns a   {@link Field} matching the attribute name or null if a fieldwas not found.
 * @param pojoClass The class supposed to contain the field
 * @param attributeName The field name
 * @return a {@link Field} matching the attribute name or null if a fieldwas not found.
 */
public static Field getField(Class<?> pojoClass,String attributeName){
  Field field=null;
  Class<?> clazz=pojoClass;
  while (clazz != null) {
    try {
      field=clazz.getDeclaredField(attributeName);
      break;
    }
 catch (    NoSuchFieldException e) {
      clazz=clazz.getSuperclass();
    }
  }
  if (field == null) {
    LOG.warn(""String_Node_Str"",pojoClass,attributeName);
  }
  return field;
}","/** 
 * It returns a   {@link Field} matching the attribute name or null if a fieldwas not found.
 * @param pojoClass The class supposed to contain the field
 * @param attributeName The field name
 * @return a {@link Field} matching the attribute name or null if a fieldwas not found.
 */
public static Field getField(Class<?> pojoClass,String attributeName){
  Class<?> clazz=pojoClass;
  while (clazz != null) {
    try {
      return clazz.getDeclaredField(attributeName);
    }
 catch (    NoSuchFieldException e) {
      clazz=clazz.getSuperclass();
    }
  }
  LOG.warn(""String_Node_Str"",pojoClass,attributeName);
  return null;
}",0.9235382308845578
175921,"/** 
 * Fills given class filled with values dictated by the strategy
 * @param < T > The type for which should be populated
 * @param pojo An instance to be filled with dummy values
 * @param manufacturingCtx the manufacturing context
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return An instance of &lt;T&gt; filled with dummy values
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If manufactured class cannot be loaded
 */
private <T>T populatePojoInternal(T pojo,ManufacturingContext manufacturingCtx,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Class<?> pojoClass=pojo.getClass();
  if (pojo instanceof Collection && ((Collection<?>)pojo).isEmpty()) {
    @SuppressWarnings(""String_Node_Str"") Collection<Object> collection=(Collection<Object>)pojo;
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    Class<?> elementTypeClass=findInheretedCollectionElementType(collection,manufacturingCtx,elementGenericTypeArgs,typeArgsMap,genericTypeArgs);
    String attributeName=null;
    Annotation[] annotations=collection.getClass().getAnnotations();
    fillCollection(manufacturingCtx,Arrays.asList(annotations),attributeName,collection,elementTypeClass,elementGenericTypeArgs.get());
  }
 else   if (pojo instanceof Map && ((Map<?,?>)pojo).isEmpty()) {
    @SuppressWarnings(""String_Node_Str"") Map<Object,Object> map=(Map<Object,Object>)pojo;
    MapArguments mapArguments=findInheretedMapElementType(map,manufacturingCtx,typeArgsMap,genericTypeArgs);
    fillMap(mapArguments,manufacturingCtx);
  }
  Class<?>[] parameterTypes=null;
  Class<?> attributeType=null;
  ClassInfo classInfo=classInfoStrategy.getClassInfo(pojo.getClass());
  Set<ClassAttribute> classAttributes=classInfo.getClassAttributes();
  Object setterArg=null;
  Iterator<ClassAttribute> iter=classAttributes.iterator();
  while (iter.hasNext()) {
    ClassAttribute attribute=iter.next();
    Set<Method> setters=attribute.getSetters();
    if (setters.isEmpty()) {
      if (attribute.getGetters().isEmpty()) {
        iter.remove();
      }
      continue;
    }
 else {
      iter.remove();
    }
    Method setter=null;
    for (    Method current : setters) {
      if (setter == null || setter.getDeclaringClass().isAssignableFrom(current.getDeclaringClass())) {
        setter=current;
      }
    }
    parameterTypes=setter.getParameterTypes();
    if (parameterTypes.length != 1) {
      LOG.warn(""String_Node_Str"",setter);
      continue;
    }
    attributeType=parameterTypes[0];
    String attributeName=PodamUtils.extractFieldNameFromSetterMethod(setter);
    List<Annotation> pojoAttributeAnnotations=PodamUtils.getAttributeAnnotations(attribute.getAttribute(),setter);
    AttributeStrategy<?> attributeStrategy=TypeManufacturerUtil.findAttributeStrategy(strategy,pojoAttributeAnnotations,attributeType);
    if (null != attributeStrategy) {
      LOG.debug(""String_Node_Str"" + attributeName + ""String_Node_Str""+ attributeStrategy);
      setterArg=TypeManufacturerUtil.returnAttributeDataStrategyValue(attributeType,attributeStrategy);
    }
 else {
      Type[] typeArguments=PodamConstants.NO_TYPES;
      Type genericType=setter.getGenericParameterTypes()[0];
      if (genericType instanceof ParameterizedType) {
        final ParameterizedType attributeParameterizedType=(ParameterizedType)genericType;
        typeArguments=attributeParameterizedType.getActualTypeArguments();
      }
 else       if (genericType instanceof TypeVariable) {
        final TypeVariable<?> typeVariable=(TypeVariable<?>)genericType;
        Type type=typeArgsMap.get(typeVariable.getName());
        if (type instanceof ParameterizedType) {
          final ParameterizedType attributeParameterizedType=(ParameterizedType)type;
          typeArguments=attributeParameterizedType.getActualTypeArguments();
          attributeType=(Class<?>)attributeParameterizedType.getRawType();
        }
 else {
          attributeType=(Class<?>)type;
        }
      }
      AtomicReference<Type[]> typeGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
      for (int i=0; i < typeArguments.length; i++) {
        if (typeArguments[i] instanceof TypeVariable) {
          Class<?> resolvedType=TypeManufacturerUtil.resolveGenericParameter(typeArguments[i],typeArgsMap,typeGenericTypeArgs);
          if (!Collection.class.isAssignableFrom(resolvedType) && !Map.class.isAssignableFrom(resolvedType)) {
            typeArguments[i]=resolvedType;
          }
        }
      }
      setterArg=manufactureAttributeValue(pojo,manufacturingCtx,attributeType,genericType,pojoAttributeAnnotations,attributeName,typeArgsMap,typeArguments);
    }
    try {
      setter.invoke(pojo,setterArg);
    }
 catch (    IllegalAccessException e) {
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",setter.toString());
      setter.setAccessible(true);
      setter.invoke(pojo,setterArg);
    }
  }
  for (  ClassAttribute readOnlyAttribute : classAttributes) {
    Method getter=readOnlyAttribute.getGetters().iterator().next();
    if (getter != null && !getter.getReturnType().isPrimitive()) {
      if (getter.getGenericParameterTypes().length == 0) {
        Object fieldValue=null;
        try {
          fieldValue=getter.invoke(pojo,PodamConstants.NO_ARGS);
        }
 catch (        Exception e) {
          LOG.debug(""String_Node_Str"",getter);
        }
        if (fieldValue != null) {
          LOG.debug(""String_Node_Str"",getter);
          Type[] genericTypeArgsAll;
          Map<String,Type> paramTypeArgsMap;
          if (getter.getGenericReturnType() instanceof ParameterizedType) {
            paramTypeArgsMap=new HashMap<String,Type>(typeArgsMap);
            ParameterizedType paramType=(ParameterizedType)getter.getGenericReturnType();
            Type[] actualTypes=paramType.getActualTypeArguments();
            TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),actualTypes);
            genericTypeArgsAll=TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),genericTypeArgs);
          }
 else {
            paramTypeArgsMap=typeArgsMap;
            genericTypeArgsAll=genericTypeArgs;
          }
          Class<?> fieldClass=fieldValue.getClass();
          Integer depth=manufacturingCtx.getPojos().get(fieldClass);
          if (depth == null) {
            depth=-1;
          }
          if (depth <= strategy.getMaxDepth(fieldClass)) {
            manufacturingCtx.getPojos().put(fieldClass,depth + 1);
            populatePojoInternal(fieldValue,manufacturingCtx,paramTypeArgsMap,genericTypeArgsAll);
            manufacturingCtx.getPojos().put(fieldClass,depth);
          }
 else {
            LOG.warn(""String_Node_Str"",getter);
          }
        }
      }
 else {
        LOG.warn(""String_Node_Str"",getter);
      }
    }
  }
  Collection<Method> extraMethods=classInfoStrategy.getExtraMethods(pojoClass);
  if (null != extraMethods) {
    for (    Method extraMethod : extraMethods) {
      Object[] args=getParameterValuesForMethod(extraMethod,pojoClass,manufacturingCtx,typeArgsMap,genericTypeArgs);
      extraMethod.invoke(pojo,args);
    }
  }
  return pojo;
}","/** 
 * Fills given class filled with values dictated by the strategy
 * @param < T > The type for which should be populated
 * @param pojo An instance to be filled with dummy values
 * @param manufacturingCtx the manufacturing context
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return An instance of &lt;T&gt; filled with dummy values
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If manufactured class cannot be loaded
 */
private <T>T populatePojoInternal(T pojo,ManufacturingContext manufacturingCtx,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Class<?> pojoClass=pojo.getClass();
  if (pojo instanceof Collection && ((Collection<?>)pojo).isEmpty()) {
    @SuppressWarnings(""String_Node_Str"") Collection<Object> collection=(Collection<Object>)pojo;
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    Class<?> elementTypeClass=findInheretedCollectionElementType(collection,manufacturingCtx,elementGenericTypeArgs,typeArgsMap,genericTypeArgs);
    String attributeName=null;
    Annotation[] annotations=collection.getClass().getAnnotations();
    fillCollection(manufacturingCtx,Arrays.asList(annotations),attributeName,collection,elementTypeClass,elementGenericTypeArgs.get());
  }
 else   if (pojo instanceof Map && ((Map<?,?>)pojo).isEmpty()) {
    @SuppressWarnings(""String_Node_Str"") Map<Object,Object> map=(Map<Object,Object>)pojo;
    MapArguments mapArguments=findInheretedMapElementType(map,manufacturingCtx,typeArgsMap,genericTypeArgs);
    fillMap(mapArguments,manufacturingCtx);
  }
  Class<?>[] parameterTypes=null;
  Class<?> attributeType=null;
  ClassInfo classInfo=classInfoStrategy.getClassInfo(pojo.getClass());
  Set<ClassAttribute> classAttributes=classInfo.getClassAttributes();
  Object setterArg=null;
  Iterator<ClassAttribute> iter=classAttributes.iterator();
  while (iter.hasNext()) {
    ClassAttribute attribute=iter.next();
    Set<Method> setters=attribute.getSetters();
    if (setters.isEmpty()) {
      if (attribute.getGetters().isEmpty()) {
        iter.remove();
      }
      continue;
    }
 else {
      iter.remove();
    }
    Method setter=null;
    for (    Method current : setters) {
      if (setter == null || setter.getDeclaringClass().isAssignableFrom(current.getDeclaringClass())) {
        setter=current;
      }
    }
    parameterTypes=setter.getParameterTypes();
    if (parameterTypes.length != 1) {
      LOG.warn(""String_Node_Str"",setter);
      continue;
    }
    attributeType=parameterTypes[0];
    String attributeName=PodamUtils.extractFieldNameFromSetterMethod(setter);
    List<Annotation> pojoAttributeAnnotations=PodamUtils.getAttributeAnnotations(attribute.getAttribute(),setter);
    AttributeStrategy<?> attributeStrategy=TypeManufacturerUtil.findAttributeStrategy(strategy,pojoAttributeAnnotations,attributeType);
    if (null != attributeStrategy) {
      LOG.debug(""String_Node_Str"" + attributeName + ""String_Node_Str""+ attributeStrategy);
      setterArg=TypeManufacturerUtil.returnAttributeDataStrategyValue(attributeType,attributeStrategy);
    }
 else {
      AtomicReference<Type[]> typeGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
      Type genericType=setter.getGenericParameterTypes()[0];
      final Type[] typeArguments;
      if (!(genericType instanceof GenericArrayType)) {
        attributeType=TypeManufacturerUtil.resolveGenericParameter(genericType,typeArgsMap,typeGenericTypeArgs);
        typeArguments=typeGenericTypeArgs.get();
      }
 else {
        typeArguments=PodamConstants.NO_TYPES;
      }
      for (int i=0; i < typeArguments.length; i++) {
        if (typeArguments[i] instanceof TypeVariable) {
          Class<?> resolvedType=TypeManufacturerUtil.resolveGenericParameter(typeArguments[i],typeArgsMap,typeGenericTypeArgs);
          if (!Collection.class.isAssignableFrom(resolvedType) && !Map.class.isAssignableFrom(resolvedType)) {
            typeArguments[i]=resolvedType;
          }
        }
      }
      setterArg=manufactureAttributeValue(pojo,manufacturingCtx,attributeType,genericType,pojoAttributeAnnotations,attributeName,typeArgsMap,typeArguments);
    }
    try {
      setter.invoke(pojo,setterArg);
    }
 catch (    IllegalAccessException e) {
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",setter.toString());
      setter.setAccessible(true);
      setter.invoke(pojo,setterArg);
    }
  }
  for (  ClassAttribute readOnlyAttribute : classAttributes) {
    Method getter=readOnlyAttribute.getGetters().iterator().next();
    if (getter != null && !getter.getReturnType().isPrimitive()) {
      if (getter.getGenericParameterTypes().length == 0) {
        Object fieldValue=null;
        try {
          fieldValue=getter.invoke(pojo,PodamConstants.NO_ARGS);
        }
 catch (        Exception e) {
          LOG.debug(""String_Node_Str"",getter);
        }
        if (fieldValue != null) {
          LOG.debug(""String_Node_Str"",getter);
          Type[] genericTypeArgsAll;
          Map<String,Type> paramTypeArgsMap;
          if (getter.getGenericReturnType() instanceof ParameterizedType) {
            paramTypeArgsMap=new HashMap<String,Type>(typeArgsMap);
            ParameterizedType paramType=(ParameterizedType)getter.getGenericReturnType();
            Type[] actualTypes=paramType.getActualTypeArguments();
            TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),actualTypes);
            genericTypeArgsAll=TypeManufacturerUtil.fillTypeArgMap(paramTypeArgsMap,getter.getReturnType(),genericTypeArgs);
          }
 else {
            paramTypeArgsMap=typeArgsMap;
            genericTypeArgsAll=genericTypeArgs;
          }
          Class<?> fieldClass=fieldValue.getClass();
          Integer depth=manufacturingCtx.getPojos().get(fieldClass);
          if (depth == null) {
            depth=-1;
          }
          if (depth <= strategy.getMaxDepth(fieldClass)) {
            manufacturingCtx.getPojos().put(fieldClass,depth + 1);
            populatePojoInternal(fieldValue,manufacturingCtx,paramTypeArgsMap,genericTypeArgsAll);
            manufacturingCtx.getPojos().put(fieldClass,depth);
          }
 else {
            LOG.warn(""String_Node_Str"",getter);
          }
        }
      }
 else {
        LOG.warn(""String_Node_Str"",getter);
      }
    }
  }
  Collection<Method> extraMethods=classInfoStrategy.getExtraMethods(pojoClass);
  if (null != extraMethods) {
    for (    Method extraMethod : extraMethods) {
      Object[] args=getParameterValuesForMethod(extraMethod,pojoClass,manufacturingCtx,typeArgsMap,genericTypeArgs);
      extraMethod.invoke(pojo,args);
    }
  }
  return pojo;
}",0.9203598800399868
175922,"private void log(AttributeMetadata attributeMetadata){
  LOG.trace(""String_Node_Str"",attributeMetadata.getPojoClass().getName(),attributeMetadata.getAttributeName() != null ? attributeMetadata.getAttributeName() : ""String_Node_Str"");
}","private void log(AttributeMetadata attributeMetadata){
  LOG.trace(""String_Node_Str"",attributeMetadata.getPojoClass() != null ? attributeMetadata.getPojoClass().getName() : ""String_Node_Str"",attributeMetadata.getAttributeName() != null ? attributeMetadata.getAttributeName() : ""String_Node_Str"");
}",0.8818011257035647
175923,"/** 
 * It manufactures and returns the value for a POJO attribute.
 * @param pojo The POJO being filled with values
 * @param manufacturingCtx the manufacturing context
 * @param attributeType The type of the attribute for which a value is being manufactured
 * @param genericAttributeType The generic type of the attribute for which a value is being manufactured
 * @param annotations The annotations for the attribute being considered
 * @param attributeName The attribute name
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return The value for an attribute
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws IllegalArgumentException <ul> <li>If an illegal argument was passed</li> <li>If an invalid value was set for a precise value in an annotation and such value could not be converted to the desired type</li> </ul>
 * @throws ClassNotFoundException If class being manufactured cannot be loaded
 */
private Object manufactureAttributeValue(Object pojo,ManufacturingContext manufacturingCtx,Class<?> attributeType,Type genericAttributeType,List<Annotation> annotations,String attributeName,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Object attributeValue=null;
  Class<?> pojoClass=(pojo instanceof Class ? (Class<?>)pojo : pojo.getClass());
  Class<?> realAttributeType;
  if (attributeType != genericAttributeType && Object.class.equals(attributeType) && genericAttributeType instanceof TypeVariable) {
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    realAttributeType=TypeManufacturerUtil.resolveGenericParameter(genericAttributeType,typeArgsMap,elementGenericTypeArgs);
  }
 else {
    realAttributeType=attributeType;
  }
  TypeVariable<?>[] typeParams=attributeType.getTypeParameters();
  Type[] genericTypeArgsAll;
  if (typeParams.length > genericTypeArgs.length) {
    genericTypeArgsAll=TypeManufacturerUtil.mergeActualAndSuppliedGenericTypes(typeParams,genericAttributeType,genericTypeArgs,typeArgsMap);
  }
 else {
    genericTypeArgsAll=genericTypeArgs;
  }
  AttributeMetadata attributeMetadata=new AttributeMetadata(attributeName,realAttributeType,genericAttributeType,genericTypeArgsAll,annotations,pojoClass);
  if (realAttributeType.isPrimitive() || TypeManufacturerUtil.isWrapper(realAttributeType) || realAttributeType.equals(String.class)) {
    attributeValue=typeMultiplexer.getTypeValue(strategy,attributeMetadata,typeArgsMap,realAttributeType.getName());
  }
 else   if (realAttributeType.isArray()) {
    attributeValue=resolveArrayElementValue(realAttributeType,genericAttributeType,attributeName,manufacturingCtx,annotations,pojo,typeArgsMap);
  }
 else   if (Collection.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveCollectionValueWhenCollectionIsPojoAttribute(pojo,manufacturingCtx,realAttributeType,attributeName,annotations,typeArgsMap,genericTypeArgsAll);
  }
 else   if (Map.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveMapValueWhenMapIsPojoAttribute(pojo,manufacturingCtx,realAttributeType,attributeName,annotations,typeArgsMap,genericTypeArgsAll);
  }
 else   if (realAttributeType.isEnum()) {
    attributeValue=typeMultiplexer.getTypeValue(strategy,attributeMetadata,typeArgsMap,PodamConstants.ENUMERATION_QUALIFIER);
  }
 else   if (Type.class.isAssignableFrom(realAttributeType)) {
    attributeValue=typeMultiplexer.getTypeValue(strategy,attributeMetadata,typeArgsMap,PodamConstants.GENERIC_TYPE_QUALIFIER);
  }
  if (attributeValue == null) {
    Integer depth=manufacturingCtx.getPojos().get(realAttributeType);
    if (depth == null) {
      depth=-1;
    }
    if (depth <= strategy.getMaxDepth(pojoClass)) {
      manufacturingCtx.getPojos().put(realAttributeType,depth + 1);
      attributeValue=this.manufacturePojoInternal(realAttributeType,attributeMetadata,manufacturingCtx,genericTypeArgsAll);
      manufacturingCtx.getPojos().put(realAttributeType,depth);
    }
 else {
      attributeValue=resortToExternalFactory(manufacturingCtx,""String_Node_Str"",realAttributeType,genericTypeArgsAll);
    }
  }
  return attributeValue;
}","/** 
 * It manufactures and returns the value for a POJO attribute.
 * @param pojo The POJO being filled with values
 * @param manufacturingCtx the manufacturing context
 * @param attributeType The type of the attribute for which a value is being manufactured
 * @param genericAttributeType The generic type of the attribute for which a value is being manufactured
 * @param annotations The annotations for the attribute being considered
 * @param attributeName The attribute name
 * @param typeArgsMap a map relating the generic class arguments (""&lt;T, V&gt;"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return The value for an attribute
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws IllegalArgumentException <ul> <li>If an illegal argument was passed</li> <li>If an invalid value was set for a precise value in an annotation and such value could not be converted to the desired type</li> </ul>
 * @throws ClassNotFoundException If class being manufactured cannot be loaded
 */
private Object manufactureAttributeValue(Object pojo,ManufacturingContext manufacturingCtx,Class<?> attributeType,Type genericAttributeType,List<Annotation> annotations,String attributeName,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Object attributeValue=null;
  Class<?> pojoClass=(pojo instanceof Class ? (Class<?>)pojo : pojo.getClass());
  Class<?> realAttributeType;
  if (attributeType != genericAttributeType && Object.class.equals(attributeType) && genericAttributeType instanceof TypeVariable) {
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(PodamConstants.NO_TYPES);
    realAttributeType=TypeManufacturerUtil.resolveGenericParameter(genericAttributeType,typeArgsMap,elementGenericTypeArgs);
  }
 else {
    realAttributeType=attributeType;
  }
  TypeVariable<?>[] typeParams=attributeType.getTypeParameters();
  Type[] genericTypeArgsAll;
  if (typeParams.length > genericTypeArgs.length) {
    genericTypeArgsAll=TypeManufacturerUtil.mergeActualAndSuppliedGenericTypes(typeParams,genericAttributeType,genericTypeArgs,typeArgsMap);
  }
 else {
    genericTypeArgsAll=genericTypeArgs;
  }
  AttributeMetadata attributeMetadata=new AttributeMetadata(attributeName,realAttributeType,genericAttributeType,genericTypeArgsAll,annotations,pojoClass);
  if (realAttributeType.isArray()) {
    attributeValue=resolveArrayElementValue(realAttributeType,genericAttributeType,attributeName,manufacturingCtx,annotations,pojo,typeArgsMap);
  }
 else   if (Collection.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveCollectionValueWhenCollectionIsPojoAttribute(pojo,manufacturingCtx,realAttributeType,attributeName,annotations,typeArgsMap,genericTypeArgsAll);
  }
 else   if (Map.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveMapValueWhenMapIsPojoAttribute(pojo,manufacturingCtx,realAttributeType,attributeName,annotations,typeArgsMap,genericTypeArgsAll);
  }
 else   if (Type.class.isAssignableFrom(realAttributeType)) {
    attributeValue=typeMultiplexer.getTypeValue(strategy,attributeMetadata,typeArgsMap,PodamConstants.GENERIC_TYPE_QUALIFIER);
  }
  if (attributeValue == null) {
    Integer depth=manufacturingCtx.getPojos().get(realAttributeType);
    if (depth == null) {
      depth=-1;
    }
    if (depth <= strategy.getMaxDepth(pojoClass)) {
      manufacturingCtx.getPojos().put(realAttributeType,depth + 1);
      attributeValue=this.manufacturePojoInternal(realAttributeType,attributeMetadata,manufacturingCtx,genericTypeArgsAll);
      manufacturingCtx.getPojos().put(realAttributeType,depth);
    }
 else {
      attributeValue=resortToExternalFactory(manufacturingCtx,""String_Node_Str"",realAttributeType,genericTypeArgsAll);
    }
  }
  return attributeValue;
}",0.8718065175428636
175924,"/** 
 * Generic method which returns an instance of the given class filled with values dictated by the strategy
 * @param < T > The type for which a filled instance is required
 * @param pojoClass The name of the class for which an instance filled with values is required
 * @param pojoMetadata attribute metadata for POJOs produced recursively
 * @param manufacturingCtx the manufacturing context
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return An instance of &lt;T&gt; filled with dummy values
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If manufactured class cannot be loaded
 * @throws PodamMockeryException if a problem occurred while creating a POJO instance or while setting its state
 */
private <T>T manufacturePojoInternal(Class<T> pojoClass,AttributeMetadata pojoMetadata,ManufacturingContext manufacturingCtx,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  @SuppressWarnings(""String_Node_Str"") T objectToReuse=(T)strategy.getMemoizedObject(pojoMetadata);
  if (objectToReuse != null) {
    LOG.debug(""String_Node_Str"",pojoClass,Arrays.toString(genericTypeArgs));
    return objectToReuse;
  }
 else {
    LOG.debug(""String_Node_Str"",pojoClass,Arrays.toString(genericTypeArgs));
  }
  final Map<String,Type> typeArgsMap=new HashMap<String,Type>();
  if (pojoClass.isEnum()) {
    @SuppressWarnings(""String_Node_Str"") T tmp=(T)typeMultiplexer.getTypeValue(strategy,pojoMetadata,typeArgsMap,PodamConstants.ENUMERATION_QUALIFIER);
    return tmp;
  }
  if (pojoClass.isPrimitive()) {
    @SuppressWarnings(""String_Node_Str"") T tmp=(T)typeMultiplexer.getTypeValue(strategy,pojoMetadata,typeArgsMap,pojoClass.getName());
    return tmp;
  }
  Type[] genericTypeArgsExtra=TypeManufacturerUtil.fillTypeArgMap(typeArgsMap,pojoClass,genericTypeArgs);
  if (pojoClass.isInterface()) {
    return getValueForAbstractType(pojoClass,pojoMetadata,manufacturingCtx,typeArgsMap,genericTypeArgs);
  }
  T retValue=null;
  try {
    retValue=instantiatePojo(pojoClass,manufacturingCtx,typeArgsMap,genericTypeArgsExtra);
  }
 catch (  SecurityException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
  if (retValue == null) {
    return getValueForAbstractType(pojoClass,pojoMetadata,manufacturingCtx,typeArgsMap,genericTypeArgs);
  }
 else {
    strategy.cacheMemoizedObject(pojoMetadata,retValue);
    populatePojoInternal(retValue,manufacturingCtx,typeArgsMap,genericTypeArgsExtra);
  }
  return retValue;
}","/** 
 * Generic method which returns an instance of the given class filled with values dictated by the strategy
 * @param < T > The type for which a filled instance is required
 * @param pojoClass The name of the class for which an instance filled with values is required
 * @param pojoMetadata attribute metadata for POJOs produced recursively
 * @param manufacturingCtx the manufacturing context
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return An instance of &lt;T&gt; filled with dummy values
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If manufactured class cannot be loaded
 * @throws PodamMockeryException if a problem occurred while creating a POJO instance or while setting its state
 */
private <T>T manufacturePojoInternal(Class<T> pojoClass,AttributeMetadata pojoMetadata,ManufacturingContext manufacturingCtx,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  @SuppressWarnings(""String_Node_Str"") T objectToReuse=(T)strategy.getMemoizedObject(pojoMetadata);
  if (objectToReuse != null) {
    LOG.debug(""String_Node_Str"",pojoClass,Arrays.toString(genericTypeArgs));
    return objectToReuse;
  }
 else {
    LOG.debug(""String_Node_Str"",pojoClass,Arrays.toString(genericTypeArgs));
  }
  final Map<String,Type> typeArgsMap=new HashMap<String,Type>();
  if (pojoClass.isEnum()) {
    @SuppressWarnings(""String_Node_Str"") T tmp=(T)typeMultiplexer.getTypeValue(strategy,pojoMetadata,typeArgsMap,PodamConstants.ENUMERATION_QUALIFIER);
    return tmp;
  }
  if (pojoClass.isPrimitive() || pojoClass.equals(String.class) || TypeManufacturerUtil.isWrapper(pojoClass)) {
    @SuppressWarnings(""String_Node_Str"") T tmp=(T)typeMultiplexer.getTypeValue(strategy,pojoMetadata,typeArgsMap,pojoClass.getName());
    return tmp;
  }
  Type[] genericTypeArgsExtra=TypeManufacturerUtil.fillTypeArgMap(typeArgsMap,pojoClass,genericTypeArgs);
  if (pojoClass.isInterface()) {
    return getValueForAbstractType(pojoClass,pojoMetadata,manufacturingCtx,typeArgsMap,genericTypeArgs);
  }
  T retValue=null;
  try {
    retValue=instantiatePojo(pojoClass,manufacturingCtx,typeArgsMap,genericTypeArgsExtra);
  }
 catch (  SecurityException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
  if (retValue == null) {
    return getValueForAbstractType(pojoClass,pojoMetadata,manufacturingCtx,typeArgsMap,genericTypeArgs);
  }
 else {
    strategy.cacheMemoizedObject(pojoMetadata,retValue);
    populatePojoInternal(retValue,manufacturingCtx,typeArgsMap,genericTypeArgsExtra);
  }
  return retValue;
}",0.9862297367962348
175925,"/** 
 * Full constructor
 * @param list1 First List
 * @param list2 Second List
 */
public GenericCollectionsConstructorPojo(List<Long> list1,List<String> list2){
  this.list1=new ArrayList<Long>(list1);
  this.list2=new ArrayList<String>(list2);
}","/** 
 * Full constructor
 * @param list1 First List
 * @param list2 Second List
 */
public GenericCollectionsConstructorPojo(List<Long> list1,List<String> list2,List<?> list3){
  this.list1=new Vector<Long>(list1);
  this.list2=new Vector<String>(list2);
  this.list3=new Vector<Object>(list3);
}",0.8455882352941176
175926,"@Override public String toString(){
  final StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(list1);
  sb.append(""String_Node_Str"").append(list2);
  sb.append('}');
  return sb.toString();
}","@Override public String toString(){
  final StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(list1);
  sb.append(""String_Node_Str"").append(list2);
  sb.append(""String_Node_Str"").append(list3);
  sb.append('}');
  return sb.toString();
}",0.9105058365758756
175927,"@Test @Title(""String_Node_Str"") public void podamShouldHandleGenericCollectionsInConstructorWithMemoizationDisabled() throws Exception {
  PodamFactory podamFactory=podamFactorySteps.givenAStandardPodamFactory();
  GenericCollectionsConstructorPojo pojo=podamInvocationSteps.whenIInvokeTheFactoryForClass(GenericCollectionsConstructorPojo.class,podamFactory);
  podamValidationSteps.theObjectShouldNotBeNull(pojo);
  podamValidationSteps.theCollectionShouldNotBeNullOrEmptyAndContainElementsOfType(pojo.getList1(),Long.class);
  podamValidationSteps.theCollectionShouldNotBeNullOrEmptyAndContainElementsOfType(pojo.getList2(),String.class);
}","@Test @Title(""String_Node_Str"") public void podamShouldHandleGenericCollectionsInConstructorWithMemoizationDisabled() throws Exception {
  PodamFactory podamFactory=podamFactorySteps.givenAStandardPodamFactory();
  GenericCollectionsConstructorPojo pojo=podamInvocationSteps.whenIInvokeTheFactoryForClass(GenericCollectionsConstructorPojo.class,podamFactory);
  podamValidationSteps.theObjectShouldNotBeNull(pojo);
  podamValidationSteps.theCollectionShouldNotBeNullOrEmptyAndContainElementsOfType(pojo.getList1(),Long.class);
  podamValidationSteps.theCollectionShouldNotBeNullOrEmptyAndContainElementsOfType(pojo.getList2(),String.class);
  podamValidationSteps.theCollectionShouldNotBeNullOrEmptyAndContainElementsOfType(pojo.getList3(),Object.class);
}",0.9184549356223176
175928,"@Test @Title(""String_Node_Str"") public void podamShouldHandleGenericCollectionsInConstructorWithMemoizationEnabled() throws Exception {
  PodamFactory podamFactory=podamFactorySteps.givenAStandardPodamFactoryWithMemoizationEnabled();
  GenericCollectionsConstructorPojo pojo=podamInvocationSteps.whenIInvokeTheFactoryForClass(GenericCollectionsConstructorPojo.class,podamFactory);
  podamValidationSteps.theObjectShouldNotBeNull(pojo);
  podamValidationSteps.theCollectionShouldNotBeNullOrEmptyAndContainElementsOfType(pojo.getList1(),Long.class);
  podamValidationSteps.theCollectionShouldNotBeNullOrEmptyAndContainElementsOfType(pojo.getList2(),String.class);
}","@Test @Title(""String_Node_Str"") public void podamShouldHandleGenericCollectionsInConstructorWithMemoizationEnabled() throws Exception {
  PodamFactory podamFactory=podamFactorySteps.givenAStandardPodamFactoryWithMemoizationEnabled();
  GenericCollectionsConstructorPojo pojo=podamInvocationSteps.whenIInvokeTheFactoryForClass(GenericCollectionsConstructorPojo.class,podamFactory);
  podamValidationSteps.theObjectShouldNotBeNull(pojo);
  podamValidationSteps.theCollectionShouldNotBeNullOrEmptyAndContainElementsOfType(pojo.getList1(),Long.class);
  podamValidationSteps.theCollectionShouldNotBeNullOrEmptyAndContainElementsOfType(pojo.getList2(),String.class);
  podamValidationSteps.theCollectionShouldNotBeNullOrEmptyAndContainElementsOfType(pojo.getList3(),Object.class);
}",0.9208333333333332
175929,"@Step(""String_Node_Str"") public boolean theObjectShouldNotBeNull(Object pojo){
  return pojo == null;
}","@Step(""String_Node_Str"") public void theObjectShouldNotBeNull(Object pojo){
  assertThat(pojo,is(notNullValue()));
}",0.8036529680365296
175930,"/** 
 * Full constructor.
 * @param dataProviderStrategy The DataProviderStrategy
 * @param attributeMetadata    The AttributeMetadata
 * @param typeArgumentsMap The map of type arguments
 */
public TypeManufacturerParamsWrapperForGenericTypes(DataProviderStrategy dataProviderStrategy,AttributeMetadata attributeMetadata,Map<String,Type> typeArgumentsMap,Type attributeGenericType){
  super(dataProviderStrategy,attributeMetadata);
  this.typeArgumentsMap=new HashMap<String,Type>(typeArgumentsMap);
  this.attributeGenericType=attributeGenericType;
}","/** 
 * Full constructor.
 * @param dataProviderStrategy The DataProviderStrategy
 * @param attributeMetadata    The AttributeMetadata
 * @param typeArgumentsMap The map of type arguments
 * @param attributeGenericType The attribute generic type
 */
public TypeManufacturerParamsWrapperForGenericTypes(DataProviderStrategy dataProviderStrategy,AttributeMetadata attributeMetadata,Map<String,Type> typeArgumentsMap,Type attributeGenericType){
  super(dataProviderStrategy,attributeMetadata);
  this.typeArgumentsMap=new HashMap<String,Type>(typeArgumentsMap);
  this.attributeGenericType=attributeGenericType;
}",0.9500860585197934
175931,"/** 
 * It returns a   {@link Calendar} objects complying with Java bean validationannotations. {@inheritDoc}
 */
public Object getValue() throws PodamMockeryException {
  if (null != findTypeFromList(annotations,AssertTrue.class)) {
    return Boolean.TRUE;
  }
  if (null != findTypeFromList(annotations,AssertFalse.class)) {
    return Boolean.FALSE;
  }
  if (null != findTypeFromList(annotations,Past.class)) {
    int days=RANDOM.nextInt(365) + 1;
    long timestamp=System.currentTimeMillis() - TimeUnit.DAYS.toSeconds(days);
    return timestampToReturnType(timestamp);
  }
  if (null != findTypeFromList(annotations,Future.class)) {
    int days=RANDOM.nextInt(365) + 1;
    long timestamp=System.currentTimeMillis() + TimeUnit.DAYS.toSeconds(days);
    return timestampToReturnType(timestamp);
  }
  Annotation minAnno=null;
  Annotation maxAnno=null;
  minAnno=findTypeFromList(annotations,DecimalMin.class);
  maxAnno=findTypeFromList(annotations,DecimalMax.class);
  if ((null != minAnno) || (null != maxAnno)) {
    BigDecimal min;
    if (null != minAnno) {
      DecimalMin tmp=(DecimalMin)minAnno;
      min=new BigDecimal(tmp.value());
    }
 else {
      min=new BigDecimal(Double.MIN_VALUE);
    }
    BigDecimal max;
    if (null != maxAnno) {
      DecimalMax tmp=(DecimalMax)maxAnno;
      max=new BigDecimal(tmp.value());
    }
 else {
      max=new BigDecimal(Double.MAX_VALUE);
    }
    return decimalToReturnType(getValueInRange(min,max));
  }
  minAnno=findTypeFromList(annotations,Min.class);
  maxAnno=findTypeFromList(annotations,Max.class);
  if ((null != minAnno) || (null != maxAnno)) {
    BigDecimal min;
    if (null != minAnno) {
      Min tmp=(Min)minAnno;
      min=new BigDecimal(tmp.value());
    }
 else {
      min=new BigDecimal(Double.MIN_VALUE);
    }
    BigDecimal max;
    if (null != maxAnno) {
      Max tmp=(Max)maxAnno;
      max=new BigDecimal(tmp.value());
    }
 else {
      max=new BigDecimal(Double.MAX_VALUE);
    }
    BigInteger intValue=getValueInRange(min,max).toBigInteger();
    BigDecimal value=new BigDecimal(intValue);
    return decimalToReturnType(value);
  }
  if (null != (minAnno=findTypeFromList(annotations,Digits.class))) {
    Digits digits=(Digits)minAnno;
    BigDecimal divisor=BigDecimal.TEN.pow(digits.fraction());
    BigDecimal max=BigDecimal.TEN.pow(digits.integer()).multiply(divisor);
    BigDecimal min=max.negate();
    BigInteger intValue=getValueInRange(min,max).toBigInteger();
    BigDecimal value=new BigDecimal(intValue).divide(divisor);
    return decimalToReturnType(value);
  }
  if (null != (minAnno=findTypeFromList(annotations,Size.class))) {
    Size size=(Size)minAnno;
    long length=PodamUtils.getLongInRange(size.min(),size.max());
    StringBuilder sb=new StringBuilder();
    while (sb.length() < length) {
      sb.append(PodamUtils.getNiceCharacter());
    }
    return sb.toString();
  }
  if (null != (minAnno=findTypeFromList(annotations,Pattern.class))) {
    Pattern pattern=(Pattern)minAnno;
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"",pattern.regexp());
    return null;
  }
  return null;
}","/** 
 * It returns a   {@link Calendar} objects complying with Java bean validationannotations. {@inheritDoc}
 */
public Object getValue() throws PodamMockeryException {
  if (null != findTypeFromList(annotations,AssertTrue.class)) {
    return Boolean.TRUE;
  }
  if (null != findTypeFromList(annotations,AssertFalse.class)) {
    return Boolean.FALSE;
  }
  if (null != findTypeFromList(annotations,Past.class)) {
    int days=RANDOM.nextInt(365) + 1;
    long timestamp=System.currentTimeMillis() - TimeUnit.DAYS.toSeconds(days);
    return timestampToReturnType(timestamp);
  }
  if (null != findTypeFromList(annotations,Future.class)) {
    int days=RANDOM.nextInt(365) + 1;
    long timestamp=System.currentTimeMillis() + TimeUnit.DAYS.toSeconds(days);
    return timestampToReturnType(timestamp);
  }
  Annotation minAnno=null;
  Annotation maxAnno=null;
  minAnno=findTypeFromList(annotations,DecimalMin.class);
  maxAnno=findTypeFromList(annotations,DecimalMax.class);
  if ((null != minAnno) || (null != maxAnno)) {
    BigDecimal min;
    if (null != minAnno) {
      DecimalMin tmp=(DecimalMin)minAnno;
      min=new BigDecimal(tmp.value());
    }
 else {
      min=new BigDecimal(Double.MIN_VALUE);
    }
    BigDecimal max;
    if (null != maxAnno) {
      DecimalMax tmp=(DecimalMax)maxAnno;
      max=new BigDecimal(tmp.value());
    }
 else {
      max=new BigDecimal(Double.MAX_VALUE);
    }
    return decimalToReturnType(getValueInRange(min,max));
  }
  minAnno=findTypeFromList(annotations,Min.class);
  maxAnno=findTypeFromList(annotations,Max.class);
  if ((null != minAnno) || (null != maxAnno)) {
    BigDecimal min;
    if (null != minAnno) {
      Min tmp=(Min)minAnno;
      min=new BigDecimal(tmp.value());
    }
 else {
      min=new BigDecimal(Double.MIN_VALUE);
    }
    BigDecimal max;
    if (null != maxAnno) {
      Max tmp=(Max)maxAnno;
      max=new BigDecimal(tmp.value());
    }
 else {
      max=new BigDecimal(Double.MAX_VALUE);
    }
    BigInteger intValue=getValueInRange(min,max).toBigInteger();
    BigDecimal value=new BigDecimal(intValue);
    return decimalToReturnType(value);
  }
  if (null != (minAnno=findTypeFromList(annotations,Digits.class))) {
    Digits digits=(Digits)minAnno;
    BigDecimal divisor=BigDecimal.TEN.pow(digits.fraction());
    BigDecimal max=BigDecimal.TEN.pow(digits.integer()).multiply(divisor);
    BigDecimal min=max.negate();
    BigInteger intValue=getValueInRange(min,max).toBigInteger();
    BigDecimal value=new BigDecimal(intValue).divide(divisor);
    return decimalToReturnType(value);
  }
  if (null != (minAnno=findTypeFromList(annotations,Size.class))) {
    Size size=(Size)minAnno;
    int minValue=size.min();
    int maxValue=size.max();
    if (maxValue == Integer.MAX_VALUE) {
      maxValue=PodamConstants.STR_DEFAULT_LENGTH;
    }
    long length=PodamUtils.getLongInRange(minValue,maxValue);
    StringBuilder sb=new StringBuilder();
    while (sb.length() < length) {
      sb.append(PodamUtils.getNiceCharacter());
    }
    return sb.toString();
  }
  if (null != (minAnno=findTypeFromList(annotations,Pattern.class))) {
    Pattern pattern=(Pattern)minAnno;
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"",pattern.regexp());
    return null;
  }
  return null;
}",0.9701048677414306
175932,"@Test @Title(""String_Node_Str"") public void podamShouldFulfillMostOfTheJavaxValidationFramework() throws Exception {
  PodamFactory podamFactory=podamFactorySteps.givenAPodamFactoryWithEmailStrategy();
  ValidatedPojo pojo=podamInvocationSteps.whenIInvokeTheFactoryForClass(ValidatedPojo.class,podamFactory);
  podamValidationSteps.theObjectShouldNotBeNull(pojo);
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getBoolFalse());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getBoolTrue());
  podamValidationSteps.theStringFieldCannotBeNullOrEmpty(pojo.getFilledString());
  podamValidationSteps.theObjectShouldBeNull(pojo.getEmptyString());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getDecimalDouble());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getDecimalFloat());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getDecimalString());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getLongNumber());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getIntNumber());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getBigIntNumber());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getShortNumber());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getByteNumber());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getIntString());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getFractionDecimal());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getFractionString());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getPastDate());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getFutureCalendar());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getSizedString());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getMaxCollection());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getMinCollection());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getEmail());
  podamValidationSteps.theObjectShouldBeNull(pojo.getIdentifier());
  Validator validator=podamFactorySteps.givenAJavaxValidator();
  validatorSteps.thePojoShouldNotViolateAnyValidations(validator,pojo);
}","@Test @Title(""String_Node_Str"") public void podamShouldFulfillMostOfTheJavaxValidationFramework() throws Exception {
  PodamFactory podamFactory=podamFactorySteps.givenAPodamFactoryWithEmailStrategy();
  ValidatedPojo pojo=podamInvocationSteps.whenIInvokeTheFactoryForClass(ValidatedPojo.class,podamFactory);
  podamValidationSteps.theObjectShouldNotBeNull(pojo);
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getBoolFalse());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getBoolTrue());
  podamValidationSteps.theStringFieldCannotBeNullOrEmpty(pojo.getFilledString());
  podamValidationSteps.theObjectShouldBeNull(pojo.getEmptyString());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getDecimalDouble());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getDecimalFloat());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getDecimalString());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getLongNumber());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getIntNumber());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getBigIntNumber());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getShortNumber());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getByteNumber());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getIntString());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getFractionDecimal());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getFractionString());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getPastDate());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getFutureCalendar());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getSizedString());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getMaxCollection());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getMinCollection());
  podamValidationSteps.theObjectShouldNotBeNull(pojo.getEmail());
  podamValidationSteps.theObjectShouldBeNull(pojo.getIdentifier());
  Validator validator=podamFactorySteps.givenAJavaxValidator();
  validatorSteps.thePojoShouldNotViolateAnyValidationsOnValidatedPojo(validator,pojo);
}",0.9964209019327128
175933,"/** 
 * Bind an interface/abstract class to a specific implementation. If the strategy previously contained a binding for the interface/abstract class, the old value is replaced by the new value. If you want to implement more sophisticated binding strategy, override this class.
 * @param < T > return type
 * @param abstractClass the interface/abstract class to bind
 * @param specificClass the specific class implementing or extending {@code abstractClass}.
 * @return itself
 */
public <T>AbstractRandomDataProviderStrategy addSpecific(final Class<T> abstractClass,final Class<? extends T> specificClass){
  Class<?> aClass=specificTypes.putIfAbsent(abstractClass,specificClass);
  if (aClass == null) {
    aClass=specificClass;
  }
  return this;
}","/** 
 * Bind an interface/abstract class to a specific implementation. If the strategy previously contained a binding for the interface/abstract class, the old value is replaced by the new value. If you want to implement more sophisticated binding strategy, override this class.
 * @param < T > return type
 * @param abstractClass the interface/abstract class to bind
 * @param specificClass the specific class implementing or extending {@code abstractClass}.
 * @return itself
 */
public <T>AbstractRandomDataProviderStrategy addSpecific(final Class<T> abstractClass,final Class<? extends T> specificClass){
  Class<? extends T> aClass=(Class<? extends T>)specificTypes.putIfAbsent(abstractClass,specificClass);
  if (aClass == null) {
    aClass=specificClass;
  }
  return this;
}",0.98046875
175934,"/** 
 * Given the attribute and setter it combines annotations from them or an empty collection if no custom annotations were found
 * @param attribute The class attribute
 * @param attributeName The class attribute's setter
 * @return all annotations for the attribute
 */
public static List<Annotation> getAttributeAnnotations(final Field attribute,final Method setter){
  Annotation[] annotations=(attribute != null ? attribute.getAnnotations() : null);
  List<Annotation> retValue;
  if (annotations != null && annotations.length != 0) {
    retValue=Arrays.asList(annotations);
  }
 else {
    retValue=new ArrayList<Annotation>();
  }
  for (  Annotation annotation : setter.getParameterAnnotations()[0]) {
    retValue.add(annotation);
  }
  return retValue;
}","/** 
 * Given the attribute and setter it combines annotations from them or an empty collection if no custom annotations were found
 * @param attribute The class attribute
 * @param setter The class attribute's setter
 * @return all annotations for the attribute
 */
public static List<Annotation> getAttributeAnnotations(final Field attribute,final Method setter){
  Annotation[] annotations=(attribute != null ? attribute.getAnnotations() : null);
  List<Annotation> retValue;
  if (annotations != null && annotations.length != 0) {
    retValue=Arrays.asList(annotations);
  }
 else {
    retValue=new ArrayList<Annotation>();
  }
  for (  Annotation annotation : setter.getParameterAnnotations()[0]) {
    retValue.add(annotation);
  }
  return retValue;
}",0.9875573018991488
175935,"/** 
 * It manufactures and returns the value for a POJO attribute.
 * @param pojo The POJO being filled with values
 * @param pojos Set of manufactured pojos' types
 * @param attributeType The type of the attribute for which a value is being manufactured
 * @param genericAttributeType The generic type of the attribute for which a value is being manufactured
 * @param annotations The annotations for the attribute being considered
 * @param attributeName The attribute name
 * @param typeArgsMap a map relating the generic class arguments (""<T, V>"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return The value for an attribute
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If it was not possible to create a class from a string
 * @throws IllegalArgumentException <ul> <li>If an illegal argument was passed</li> <li>If an invalid value was set for a precise value in an annotation and such value could not be converted to the desired type</li> </ul>
 */
private Object manufactureAttributeValue(Object pojo,Map<Class<?>,Integer> pojos,Class<?> attributeType,Type genericAttributeType,List<Annotation> annotations,String attributeName,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Object attributeValue=null;
  Class<?> realAttributeType;
  if (Object.class.equals(attributeType) && attributeType != genericAttributeType) {
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(NO_TYPES);
    realAttributeType=resolveGenericParameter(genericAttributeType,typeArgsMap,elementGenericTypeArgs);
  }
 else {
    realAttributeType=attributeType;
  }
  AttributeMetadata attributeMetadata=new AttributeMetadata(attributeName,realAttributeType,annotations,pojo.getClass());
  if (realAttributeType.isPrimitive()) {
    attributeValue=resolvePrimitiveValue(realAttributeType,annotations,attributeMetadata);
  }
 else   if (isWrapper(realAttributeType)) {
    attributeValue=resolveWrapperValue(realAttributeType,annotations,attributeMetadata);
  }
 else   if (realAttributeType.equals(String.class)) {
    attributeValue=resolveStringValue(annotations,attributeMetadata);
  }
 else   if (realAttributeType.isArray()) {
    attributeValue=resolveArrayElementValue(realAttributeType,genericAttributeType,pojos,annotations,pojo,attributeName,typeArgsMap);
  }
 else   if (Collection.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveCollectionValueWhenCollectionIsPojoAttribute(pojo,pojos,realAttributeType,attributeName,annotations,typeArgsMap,genericTypeArgs);
  }
 else   if (Map.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveMapValueWhenMapIsPojoAttribute(pojo,pojos,realAttributeType,attributeName,annotations,typeArgsMap,genericTypeArgs);
  }
 else   if (realAttributeType.isEnum()) {
    int enumConstantsLength=realAttributeType.getEnumConstants().length;
    if (enumConstantsLength > 0) {
      int enumIndex=strategy.getIntegerInRange(0,enumConstantsLength,attributeMetadata) % enumConstantsLength;
      attributeValue=realAttributeType.getEnumConstants()[enumIndex];
    }
  }
 else   if (Type.class.isAssignableFrom(realAttributeType)) {
    if (genericTypeArgs.length > 0 && genericTypeArgs[0] != null) {
      AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(NO_TYPES);
      attributeValue=resolveGenericParameter(genericTypeArgs[0],typeArgsMap,elementGenericTypeArgs);
    }
 else {
      LOG.error(""String_Node_Str"",genericAttributeType,typeArgsMap,Arrays.toString(genericTypeArgs));
    }
  }
  if (attributeValue == null) {
    TypeVariable<?>[] typeParams=attributeType.getTypeParameters();
    List<Type> resolvedTypes=new ArrayList<Type>();
    for (int i=0; i < typeParams.length; i++) {
      Type type=typeArgsMap.get(typeParams[i].getName());
      if (type != null) {
        resolvedTypes.add(type);
      }
    }
    Type[] genericTypeArgsAll=mergeTypeArrays(resolvedTypes.toArray(new Type[resolvedTypes.size()]),genericTypeArgs);
    Integer depth=pojos.get(realAttributeType);
    if (depth == null) {
      depth=-1;
    }
    if (depth <= strategy.getMaxDepth(pojo.getClass())) {
      pojos.put(realAttributeType,depth + 1);
      attributeValue=this.manufacturePojoInternal(realAttributeType,pojos,genericTypeArgsAll);
      pojos.put(realAttributeType,depth);
    }
 else {
      LOG.warn(""String_Node_Str"",realAttributeType);
      attributeValue=externalFactory.manufacturePojo(realAttributeType,genericTypeArgsAll);
    }
  }
  return attributeValue;
}","/** 
 * It manufactures and returns the value for a POJO attribute.
 * @param pojo The POJO being filled with values
 * @param pojos Set of manufactured pojos' types
 * @param attributeType The type of the attribute for which a value is being manufactured
 * @param genericAttributeType The generic type of the attribute for which a value is being manufactured
 * @param annotations The annotations for the attribute being considered
 * @param attributeName The attribute name
 * @param typeArgsMap a map relating the generic class arguments (""<T, V>"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return The value for an attribute
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If it was not possible to create a class from a string
 * @throws IllegalArgumentException <ul> <li>If an illegal argument was passed</li> <li>If an invalid value was set for a precise value in an annotation and such value could not be converted to the desired type</li> </ul>
 */
private Object manufactureAttributeValue(Object pojo,Map<Class<?>,Integer> pojos,Class<?> attributeType,Type genericAttributeType,List<Annotation> annotations,String attributeName,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Object attributeValue=null;
  Class<?> realAttributeType;
  if (Object.class.equals(attributeType) && attributeType != genericAttributeType) {
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(NO_TYPES);
    realAttributeType=resolveGenericParameter(genericAttributeType,typeArgsMap,elementGenericTypeArgs);
  }
 else {
    realAttributeType=attributeType;
  }
  AttributeMetadata attributeMetadata=new AttributeMetadata(attributeName,realAttributeType,annotations,pojo.getClass());
  if (realAttributeType.isPrimitive()) {
    attributeValue=resolvePrimitiveValue(realAttributeType,annotations,attributeMetadata);
  }
 else   if (isWrapper(realAttributeType)) {
    attributeValue=resolveWrapperValue(realAttributeType,annotations,attributeMetadata);
  }
 else   if (realAttributeType.equals(String.class)) {
    attributeValue=resolveStringValue(annotations,attributeMetadata);
  }
 else   if (realAttributeType.isArray()) {
    attributeValue=resolveArrayElementValue(realAttributeType,genericAttributeType,pojos,annotations,pojo,attributeName,typeArgsMap);
  }
 else   if (Collection.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveCollectionValueWhenCollectionIsPojoAttribute(pojo,pojos,realAttributeType,attributeName,annotations,typeArgsMap,genericTypeArgs);
  }
 else   if (Map.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveMapValueWhenMapIsPojoAttribute(pojo,pojos,realAttributeType,attributeName,annotations,typeArgsMap,genericTypeArgs);
  }
 else   if (realAttributeType.isEnum()) {
    int enumConstantsLength=realAttributeType.getEnumConstants().length;
    if (enumConstantsLength > 0) {
      int enumIndex=strategy.getIntegerInRange(0,enumConstantsLength,attributeMetadata) % enumConstantsLength;
      attributeValue=realAttributeType.getEnumConstants()[enumIndex];
    }
  }
 else   if (Type.class.isAssignableFrom(realAttributeType)) {
    if (genericTypeArgs.length > 0 && genericTypeArgs[0] != null) {
      AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(NO_TYPES);
      attributeValue=resolveGenericParameter(genericTypeArgs[0],typeArgsMap,elementGenericTypeArgs);
    }
 else {
      LOG.error(""String_Node_Str"",genericAttributeType,typeArgsMap,Arrays.toString(genericTypeArgs));
    }
  }
  if (attributeValue == null) {
    TypeVariable<?>[] typeParams=attributeType.getTypeParameters();
    Type[] genericTypeArgsAll=mergeActualAndSuppliedGenericTypes(typeParams,genericTypeArgs,typeArgsMap);
    Integer depth=pojos.get(realAttributeType);
    if (depth == null) {
      depth=-1;
    }
    if (depth <= strategy.getMaxDepth(pojo.getClass())) {
      pojos.put(realAttributeType,depth + 1);
      attributeValue=this.manufacturePojoInternal(realAttributeType,pojos,genericTypeArgsAll);
      pojos.put(realAttributeType,depth);
    }
 else {
      LOG.warn(""String_Node_Str"",realAttributeType);
      attributeValue=externalFactory.manufacturePojo(realAttributeType,genericTypeArgsAll);
    }
  }
  return attributeValue;
}",0.961391160335369
175936,"/** 
 * It manufactures and returns the value for a POJO attribute.
 * @param pojo The POJO being filled with values
 * @param pojos Set of manufactured pojos' types
 * @param attributeType The type of the attribute for which a value is being manufactured
 * @param genericAttributeType The generic type of the attribute for which a value is being manufactured
 * @param annotations The annotations for the attribute being considered
 * @param attributeName The attribute name
 * @param typeArgsMap a map relating the generic class arguments (""<T, V>"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return The value for an attribute
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If it was not possible to create a class from a string
 * @throws IllegalArgumentException <ul> <li>If an illegal argument was passed</li> <li>If an invalid value was set for a precise value in an annotation and such value could not be converted to the desired type</li> </ul>
 */
private Object manufactureAttributeValue(Object pojo,Map<Class<?>,Integer> pojos,Class<?> attributeType,Type genericAttributeType,List<Annotation> annotations,String attributeName,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Object attributeValue=null;
  Class<?> realAttributeType;
  if (Object.class.equals(attributeType) && attributeType != genericAttributeType) {
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(NO_TYPES);
    realAttributeType=resolveGenericParameter(genericAttributeType,typeArgsMap,elementGenericTypeArgs);
  }
 else {
    realAttributeType=attributeType;
  }
  AttributeMetadata attributeMetadata=new AttributeMetadata(attributeName,realAttributeType,annotations,pojo.getClass());
  if (realAttributeType.isPrimitive()) {
    attributeValue=resolvePrimitiveValue(realAttributeType,annotations,attributeMetadata);
  }
 else   if (isWrapper(realAttributeType)) {
    attributeValue=resolveWrapperValue(realAttributeType,annotations,attributeMetadata);
  }
 else   if (realAttributeType.equals(String.class)) {
    attributeValue=resolveStringValue(annotations,attributeMetadata);
  }
 else   if (realAttributeType.isArray()) {
    attributeValue=resolveArrayElementValue(realAttributeType,genericAttributeType,pojos,annotations,pojo,attributeName,typeArgsMap);
  }
 else   if (Collection.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveCollectionValueWhenCollectionIsPojoAttribute(pojo,pojos,realAttributeType,attributeName,annotations,typeArgsMap,genericTypeArgs);
  }
 else   if (Map.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveMapValueWhenMapIsPojoAttribute(pojo,pojos,realAttributeType,attributeName,annotations,typeArgsMap,genericTypeArgs);
  }
 else   if (realAttributeType.isEnum()) {
    int enumConstantsLength=realAttributeType.getEnumConstants().length;
    if (enumConstantsLength > 0) {
      int enumIndex=strategy.getIntegerInRange(0,enumConstantsLength,attributeMetadata) % enumConstantsLength;
      attributeValue=realAttributeType.getEnumConstants()[enumIndex];
    }
  }
 else   if (Type.class.isAssignableFrom(realAttributeType)) {
    if (genericTypeArgs.length > 0 && genericTypeArgs[0] != null) {
      AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(NO_TYPES);
      attributeValue=resolveGenericParameter(genericTypeArgs[0],typeArgsMap,elementGenericTypeArgs);
    }
 else {
      LOG.error(""String_Node_Str"",genericAttributeType,typeArgsMap,Arrays.toString(genericTypeArgs));
    }
  }
  if (attributeValue == null) {
    TypeVariable<?>[] typeParams=attributeType.getTypeParameters();
    Type[] genericTypeArgsAll=mergeActualAndSuppliedGenericTypes(typeParams,genericTypeArgs,typeArgsMap);
    Integer depth=pojos.get(realAttributeType);
    if (depth == null) {
      depth=-1;
    }
    if (depth <= strategy.getMaxDepth(pojo.getClass())) {
      pojos.put(realAttributeType,depth + 1);
      attributeValue=this.manufacturePojoInternal(realAttributeType,pojos,genericTypeArgsAll);
      pojos.put(realAttributeType,depth);
    }
 else {
      LOG.warn(""String_Node_Str"",realAttributeType);
      attributeValue=externalFactory.manufacturePojo(realAttributeType,genericTypeArgsAll);
    }
  }
  return attributeValue;
}","/** 
 * It manufactures and returns the value for a POJO attribute.
 * @param pojo The POJO being filled with values
 * @param pojos Set of manufactured pojos' types
 * @param attributeType The type of the attribute for which a value is being manufactured
 * @param genericAttributeType The generic type of the attribute for which a value is being manufactured
 * @param annotations The annotations for the attribute being considered
 * @param attributeName The attribute name
 * @param typeArgsMap a map relating the generic class arguments (""<T, V>"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return The value for an attribute
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If it was not possible to create a class from a string
 * @throws IllegalArgumentException <ul> <li>If an illegal argument was passed</li> <li>If an invalid value was set for a precise value in an annotation and such value could not be converted to the desired type</li> </ul>
 */
private Object manufactureAttributeValue(Object pojo,Map<Class<?>,Integer> pojos,Class<?> attributeType,Type genericAttributeType,List<Annotation> annotations,String attributeName,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Object attributeValue=null;
  Class<?> realAttributeType;
  if (Object.class.equals(attributeType) && attributeType != genericAttributeType) {
    AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(NO_TYPES);
    realAttributeType=resolveGenericParameter(genericAttributeType,typeArgsMap,elementGenericTypeArgs);
  }
 else {
    realAttributeType=attributeType;
  }
  AttributeMetadata attributeMetadata=new AttributeMetadata(attributeName,realAttributeType,annotations,pojo.getClass());
  if (realAttributeType.isPrimitive()) {
    attributeValue=resolvePrimitiveValue(realAttributeType,annotations,attributeMetadata);
  }
 else   if (isWrapper(realAttributeType)) {
    attributeValue=resolveWrapperValue(realAttributeType,annotations,attributeMetadata);
  }
 else   if (realAttributeType.equals(String.class)) {
    attributeValue=resolveStringValue(annotations,attributeMetadata);
  }
 else   if (realAttributeType.isArray()) {
    attributeValue=resolveArrayElementValue(realAttributeType,genericAttributeType,pojos,annotations,pojo,attributeName,typeArgsMap);
  }
 else   if (Collection.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveCollectionValueWhenCollectionIsPojoAttribute(pojo,pojos,realAttributeType,attributeName,annotations,typeArgsMap,genericTypeArgs);
  }
 else   if (Map.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveMapValueWhenMapIsPojoAttribute(pojo,pojos,realAttributeType,attributeName,annotations,typeArgsMap,genericTypeArgs);
  }
 else   if (realAttributeType.isEnum()) {
    int enumConstantsLength=realAttributeType.getEnumConstants().length;
    if (enumConstantsLength > 0) {
      int enumIndex=strategy.getIntegerInRange(0,enumConstantsLength,attributeMetadata) % enumConstantsLength;
      attributeValue=realAttributeType.getEnumConstants()[enumIndex];
    }
  }
 else   if (Type.class.isAssignableFrom(realAttributeType)) {
    Type paremeterType=null;
    if (genericAttributeType instanceof ParameterizedType) {
      ParameterizedType parametrized=(ParameterizedType)genericAttributeType;
      Type[] arguments=parametrized.getActualTypeArguments();
      if (arguments.length > 0) {
        paremeterType=arguments[0];
      }
    }
 else     if (realAttributeType.getTypeParameters().length > 0) {
      paremeterType=realAttributeType.getTypeParameters()[0];
    }
    if (paremeterType != null) {
      AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(NO_TYPES);
      attributeValue=resolveGenericParameter(paremeterType,typeArgsMap,elementGenericTypeArgs);
    }
 else {
      LOG.error(""String_Node_Str"",genericAttributeType,typeArgsMap,Arrays.toString(genericTypeArgs));
    }
  }
  if (attributeValue == null) {
    TypeVariable<?>[] typeParams=attributeType.getTypeParameters();
    Type[] genericTypeArgsAll=mergeActualAndSuppliedGenericTypes(typeParams,genericTypeArgs,typeArgsMap);
    Integer depth=pojos.get(realAttributeType);
    if (depth == null) {
      depth=-1;
    }
    if (depth <= strategy.getMaxDepth(pojo.getClass())) {
      pojos.put(realAttributeType,depth + 1);
      attributeValue=this.manufacturePojoInternal(realAttributeType,pojos,genericTypeArgsAll);
      pojos.put(realAttributeType,depth);
    }
 else {
      LOG.warn(""String_Node_Str"",realAttributeType);
      attributeValue=externalFactory.manufacturePojo(realAttributeType,genericTypeArgsAll);
    }
  }
  return attributeValue;
}",0.949521677182984
175937,"/** 
 * Manufactures and returns the parameter value for method required to invoke it
 * @param parameterType type of parameter
 * @param genericType generic type of parameter
 * @param annotations parameter annotations
 * @param typeArgsMap map for resolving generic types
 * @param genericTypeArgsExtra extra generic types for chaining
 * @param pojos Set of manufactured pojos' types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return The parameter values required to invoke the constructor
 * @throws IllegalArgumentException If an illegal argument was passed to the constructor
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If it was not possible to create a class from a string
 */
private Object manufactureParameterValue(Class<?> parameterType,Type genericType,List<Annotation> annotations,final Map<String,Type> typeArgsMap,final Type[] genericTypeArgsExtra,Map<Class<?>,Integer> pojos,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Object parameterValue=null;
  if (Collection.class.isAssignableFrom(parameterType)) {
    Collection<? super Object> defaultValue=null;
    Collection<? super Object> collection=resolveCollectionType(parameterType,defaultValue);
    if (collection != null) {
      Class<?> collectionElementType;
      AtomicReference<Type[]> collectionGenericTypeArgs=new AtomicReference<Type[]>(NO_TYPES);
      if (genericType instanceof ParameterizedType) {
        ParameterizedType pType=(ParameterizedType)genericType;
        Type actualTypeArgument=pType.getActualTypeArguments()[0];
        collectionElementType=resolveGenericParameter(actualTypeArgument,typeArgsMap,collectionGenericTypeArgs);
      }
 else {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"",genericType);
        collectionElementType=Object.class;
      }
      Type[] genericTypeArgsAll=mergeTypeArrays(collectionGenericTypeArgs.get(),genericTypeArgsExtra);
      fillCollection(pojos,annotations,collection,collectionElementType,genericTypeArgsAll);
      parameterValue=collection;
    }
  }
 else   if (Map.class.isAssignableFrom(parameterType)) {
    Map<? super Object,? super Object> defaultValue=null;
    Map<? super Object,? super Object> map=resolveMapType(parameterType,defaultValue);
    if (map != null) {
      Class<?> keyClass;
      Class<?> elementClass;
      AtomicReference<Type[]> keyGenericTypeArgs=new AtomicReference<Type[]>(NO_TYPES);
      AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(NO_TYPES);
      if (genericType instanceof ParameterizedType) {
        ParameterizedType pType=(ParameterizedType)genericType;
        Type[] actualTypeArguments=pType.getActualTypeArguments();
        keyClass=resolveGenericParameter(actualTypeArguments[0],typeArgsMap,keyGenericTypeArgs);
        elementClass=resolveGenericParameter(actualTypeArguments[1],typeArgsMap,elementGenericTypeArgs);
      }
 else {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"",genericType);
        keyClass=Object.class;
        elementClass=Object.class;
      }
      Type[] genericTypeArgsAll=mergeTypeArrays(elementGenericTypeArgs.get(),genericTypeArgsExtra);
      MapArguments mapArguments=new MapArguments();
      mapArguments.setPojos(pojos);
      mapArguments.setAnnotations(annotations);
      mapArguments.setMapToBeFilled(map);
      mapArguments.setKeyClass(keyClass);
      mapArguments.setElementClass(elementClass);
      mapArguments.setKeyGenericTypeArgs(keyGenericTypeArgs.get());
      mapArguments.setElementGenericTypeArgs(genericTypeArgsAll);
      fillMap(mapArguments);
      parameterValue=map;
    }
  }
  if (parameterValue == null) {
    Map<String,Type> typeArgsMapForParam;
    if (genericType instanceof ParameterizedType) {
      typeArgsMapForParam=new HashMap<String,Type>(typeArgsMap);
      ParameterizedType parametrizedType=(ParameterizedType)genericType;
      TypeVariable<?>[] argumentTypes=parameterType.getTypeParameters();
      Type[] argumentGenericTypes=parametrizedType.getActualTypeArguments();
      for (int k=0; k < argumentTypes.length; k++) {
        if (argumentGenericTypes[k] instanceof Class) {
          Class<?> genericParam=(Class<?>)argumentGenericTypes[k];
          typeArgsMapForParam.put(argumentTypes[k].getName(),genericParam);
        }
      }
    }
 else {
      typeArgsMapForParam=typeArgsMap;
    }
    parameterValue=manufactureParameterValue(pojos,parameterType,genericType,annotations,typeArgsMapForParam,genericTypeArgs);
  }
  return parameterValue;
}","/** 
 * Manufactures and returns the parameter value for method required to invoke it
 * @param parameterType type of parameter
 * @param genericType generic type of parameter
 * @param annotations parameter annotations
 * @param typeArgsMap map for resolving generic types
 * @param genericTypeArgsExtra extra generic types for chaining
 * @param pojos Set of manufactured pojos' types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return The parameter values required to invoke the constructor
 * @throws IllegalArgumentException If an illegal argument was passed to the constructor
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If it was not possible to create a class from a string
 */
private Object manufactureParameterValue(Class<?> parameterType,Type genericType,List<Annotation> annotations,final Map<String,Type> typeArgsMap,Map<Class<?>,Integer> pojos,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Object parameterValue=null;
  if (Collection.class.isAssignableFrom(parameterType)) {
    Collection<? super Object> defaultValue=null;
    Collection<? super Object> collection=resolveCollectionType(parameterType,defaultValue);
    if (collection != null) {
      Class<?> collectionElementType;
      AtomicReference<Type[]> collectionGenericTypeArgs=new AtomicReference<Type[]>(NO_TYPES);
      if (genericType instanceof ParameterizedType) {
        ParameterizedType pType=(ParameterizedType)genericType;
        Type actualTypeArgument=pType.getActualTypeArguments()[0];
        collectionElementType=resolveGenericParameter(actualTypeArgument,typeArgsMap,collectionGenericTypeArgs);
      }
 else {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"",genericType);
        collectionElementType=Object.class;
      }
      Type[] genericTypeArgsAll=mergeTypeArrays(collectionGenericTypeArgs.get(),genericTypeArgs);
      fillCollection(pojos,annotations,collection,collectionElementType,genericTypeArgsAll);
      parameterValue=collection;
    }
  }
 else   if (Map.class.isAssignableFrom(parameterType)) {
    Map<? super Object,? super Object> defaultValue=null;
    Map<? super Object,? super Object> map=resolveMapType(parameterType,defaultValue);
    if (map != null) {
      Class<?> keyClass;
      Class<?> elementClass;
      AtomicReference<Type[]> keyGenericTypeArgs=new AtomicReference<Type[]>(NO_TYPES);
      AtomicReference<Type[]> elementGenericTypeArgs=new AtomicReference<Type[]>(NO_TYPES);
      if (genericType instanceof ParameterizedType) {
        ParameterizedType pType=(ParameterizedType)genericType;
        Type[] actualTypeArguments=pType.getActualTypeArguments();
        keyClass=resolveGenericParameter(actualTypeArguments[0],typeArgsMap,keyGenericTypeArgs);
        elementClass=resolveGenericParameter(actualTypeArguments[1],typeArgsMap,elementGenericTypeArgs);
      }
 else {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"",genericType);
        keyClass=Object.class;
        elementClass=Object.class;
      }
      Type[] genericTypeArgsAll=mergeTypeArrays(elementGenericTypeArgs.get(),genericTypeArgs);
      MapArguments mapArguments=new MapArguments();
      mapArguments.setPojos(pojos);
      mapArguments.setAnnotations(annotations);
      mapArguments.setMapToBeFilled(map);
      mapArguments.setKeyClass(keyClass);
      mapArguments.setElementClass(elementClass);
      mapArguments.setKeyGenericTypeArgs(keyGenericTypeArgs.get());
      mapArguments.setElementGenericTypeArgs(genericTypeArgsAll);
      fillMap(mapArguments);
      parameterValue=map;
    }
  }
  if (parameterValue == null) {
    Map<String,Type> typeArgsMapForParam;
    if (genericType instanceof ParameterizedType) {
      typeArgsMapForParam=new HashMap<String,Type>(typeArgsMap);
      ParameterizedType parametrizedType=(ParameterizedType)genericType;
      TypeVariable<?>[] argumentTypes=parameterType.getTypeParameters();
      Type[] argumentGenericTypes=parametrizedType.getActualTypeArguments();
      for (int k=0; k < argumentTypes.length; k++) {
        if (argumentGenericTypes[k] instanceof Class) {
          Class<?> genericParam=(Class<?>)argumentGenericTypes[k];
          typeArgsMapForParam.put(argumentTypes[k].getName(),genericParam);
        }
      }
    }
 else {
      typeArgsMapForParam=typeArgsMap;
    }
    parameterValue=manufactureParameterValue(pojos,parameterType,genericType,annotations,typeArgsMapForParam,genericTypeArgs);
  }
  return parameterValue;
}",0.995476043594489
175938,"/** 
 * It attempts to create an instance of the given class <p> This method attempts to create an instance of the given argument for classes without setters. These may be either immutable classes (e.g. with final attributes and no setters) or Java classes (e.g. belonging to the java / javax namespace). In case the class does not provide a public, no-arg constructor (e.g. Calendar), this method attempts to find a , no-args, factory method (e.g. getInstance()) and it invokes it </p>
 * @param pojoClass The name of the class for which an instance filled with values is required
 * @param pojos Set of manufactured pojos' types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return An instance of the given class
 * @throws IllegalArgumentException If an illegal argument was passed to the constructor
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If it was not possible to create a class from a string
 */
private Object instantiatePojoWithoutConstructors(Class<?> pojoClass,Map<Class<?>,Integer> pojos,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Object retValue=null;
  final Map<String,Type> typeArgsMap=new HashMap<String,Type>();
  Type[] genericTypeArgsExtra=fillTypeArgMap(typeArgsMap,pojoClass,genericTypeArgs);
  Method[] declaredMethods=pojoClass.getDeclaredMethods();
  strategy.sort(declaredMethods);
  Object[] parameterValues=null;
  Object[] noParams=new Object[]{};
  for (  Method candidateConstructor : declaredMethods) {
    if (!Modifier.isStatic(candidateConstructor.getModifiers()) || !candidateConstructor.getReturnType().equals(pojoClass) || retValue != null) {
      continue;
    }
    parameterValues=new Object[candidateConstructor.getParameterTypes().length];
    Class<?>[] parameterTypes=candidateConstructor.getParameterTypes();
    if (parameterTypes.length == 0) {
      parameterValues=noParams;
    }
 else {
      Annotation[][] parameterAnnotations=candidateConstructor.getParameterAnnotations();
      int idx=0;
      for (      Class<?> parameterType : parameterTypes) {
        List<Annotation> annotations=Arrays.asList(parameterAnnotations[idx]);
        Type genericType=candidateConstructor.getGenericParameterTypes()[idx];
        parameterValues[idx]=manufactureParameterValue(parameterType,genericType,annotations,typeArgsMap,genericTypeArgsExtra,pojos,genericTypeArgs);
        idx++;
      }
    }
    try {
      retValue=candidateConstructor.invoke(pojoClass,parameterValues);
      LOG.debug(""String_Node_Str"" + candidateConstructor);
    }
 catch (    Exception t) {
      LOG.debug(""String_Node_Str"" + candidateConstructor + ""String_Node_Str"",t);
    }
  }
  if (retValue == null) {
    retValue=externalFactory.manufacturePojo(pojoClass,genericTypeArgs);
  }
  if (retValue == null) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"",pojoClass);
  }
  return retValue;
}","/** 
 * It attempts to create an instance of the given class <p> This method attempts to create an instance of the given argument for classes without setters. These may be either immutable classes (e.g. with final attributes and no setters) or Java classes (e.g. belonging to the java / javax namespace). In case the class does not provide a public, no-arg constructor (e.g. Calendar), this method attempts to find a , no-args, factory method (e.g. getInstance()) and it invokes it </p>
 * @param pojoClass The name of the class for which an instance filled with values is required
 * @param pojos Set of manufactured pojos' types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return An instance of the given class
 * @throws IllegalArgumentException If an illegal argument was passed to the constructor
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If it was not possible to create a class from a string
 */
private Object instantiatePojoWithoutConstructors(Class<?> pojoClass,Map<Class<?>,Integer> pojos,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  Object retValue=null;
  final Map<String,Type> typeArgsMap=new HashMap<String,Type>();
  Type[] genericTypeArgsExtra=fillTypeArgMap(typeArgsMap,pojoClass,genericTypeArgs);
  Method[] declaredMethods=pojoClass.getDeclaredMethods();
  strategy.sort(declaredMethods);
  Object[] parameterValues=null;
  Object[] noParams=new Object[]{};
  for (  Method candidateConstructor : declaredMethods) {
    if (!Modifier.isStatic(candidateConstructor.getModifiers()) || !candidateConstructor.getReturnType().equals(pojoClass) || retValue != null) {
      continue;
    }
    parameterValues=new Object[candidateConstructor.getParameterTypes().length];
    Class<?>[] parameterTypes=candidateConstructor.getParameterTypes();
    if (parameterTypes.length == 0) {
      parameterValues=noParams;
    }
 else {
      Annotation[][] parameterAnnotations=candidateConstructor.getParameterAnnotations();
      int idx=0;
      for (      Class<?> parameterType : parameterTypes) {
        List<Annotation> annotations=Arrays.asList(parameterAnnotations[idx]);
        Type genericType=candidateConstructor.getGenericParameterTypes()[idx];
        parameterValues[idx]=manufactureParameterValue(parameterType,genericType,annotations,typeArgsMap,pojos,genericTypeArgsExtra == null ? NO_TYPES : genericTypeArgsExtra);
        idx++;
      }
    }
    try {
      retValue=candidateConstructor.invoke(pojoClass,parameterValues);
      LOG.debug(""String_Node_Str"" + candidateConstructor);
    }
 catch (    Exception t) {
      LOG.debug(""String_Node_Str"" + candidateConstructor + ""String_Node_Str"",t);
    }
  }
  if (retValue == null) {
    retValue=externalFactory.manufacturePojo(pojoClass,genericTypeArgs);
  }
  if (retValue == null) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"",pojoClass);
  }
  return retValue;
}",0.9916871921182266
175939,"/** 
 * Given a constructor it manufactures and returns the parameter values required to invoke it
 * @param constructor The constructor for which parameter values are required
 * @param pojoClass The POJO class containing the constructor
 * @param pojos Set of manufactured pojos' types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return The parameter values required to invoke the constructor
 * @throws IllegalArgumentException If an illegal argument was passed to the constructor
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If it was not possible to create a class from a string
 */
private Object[] getParameterValuesForConstructor(Constructor<?> constructor,Class<?> pojoClass,Map<Class<?>,Integer> pojos,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  final Map<String,Type> typeArgsMap=new HashMap<String,Type>();
  final Type[] genericTypeArgsExtra=fillTypeArgMap(typeArgsMap,pojoClass,genericTypeArgs);
  Annotation[][] parameterAnnotations=constructor.getParameterAnnotations();
  Class<?>[] parameterTypes=constructor.getParameterTypes();
  Object[] parameterValues=new Object[parameterTypes.length];
  int idx=0;
  for (  Class<?> parameterType : parameterTypes) {
    List<Annotation> annotations=Arrays.asList(parameterAnnotations[idx]);
    Type genericType=constructor.getGenericParameterTypes()[idx];
    parameterValues[idx]=manufactureParameterValue(parameterType,genericType,annotations,typeArgsMap,genericTypeArgsExtra,pojos,genericTypeArgs);
    idx++;
  }
  return parameterValues;
}","/** 
 * Given a constructor it manufactures and returns the parameter values required to invoke it
 * @param constructor The constructor for which parameter values are required
 * @param pojoClass The POJO class containing the constructor
 * @param pojos Set of manufactured pojos' types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return The parameter values required to invoke the constructor
 * @throws IllegalArgumentException If an illegal argument was passed to the constructor
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If it was not possible to create a class from a string
 */
private Object[] getParameterValuesForConstructor(Constructor<?> constructor,Class<?> pojoClass,Map<Class<?>,Integer> pojos,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, ClassNotFoundException {
  final Map<String,Type> typeArgsMap=new HashMap<String,Type>();
  final Type[] genericTypeArgsExtra=fillTypeArgMap(typeArgsMap,pojoClass,genericTypeArgs);
  Annotation[][] parameterAnnotations=constructor.getParameterAnnotations();
  Class<?>[] parameterTypes=constructor.getParameterTypes();
  Object[] parameterValues=new Object[parameterTypes.length];
  int idx=0;
  for (  Class<?> parameterType : parameterTypes) {
    List<Annotation> annotations=Arrays.asList(parameterAnnotations[idx]);
    Type genericType=constructor.getGenericParameterTypes()[idx];
    parameterValues[idx]=manufactureParameterValue(parameterType,genericType,annotations,typeArgsMap,pojos,genericTypeArgsExtra == null ? NO_TYPES : genericTypeArgsExtra);
    idx++;
  }
  return parameterValues;
}",0.9896049896049895
175940,"/** 
 * It manufactures and returns the value for a POJO attribute.
 * @param pojoClass The POJO class being filled with values
 * @param attributeType The type of the attribute for which a value is being manufactured
 * @param annotations The annotations for the attribute being considered
 * @param attributeName The attribute name
 * @param typeArgsMap a map relating the generic class arguments (""<T, V>"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return The value for an attribute
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If it was not possible to create a class from a string
 * @throws IllegalArgumentException <ul> <li>If an illegal argument was passed</li> <li>If an invalid value was set for a precise value in an annotation and such value could not be converted to the desired type</li> </ul>
 */
@SuppressWarnings(""String_Node_Str"") private Object manufactureAttributeValue(Class<?> pojoClass,Class<?> attributeType,List<Annotation> annotations,String attributeName,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, IllegalArgumentException, ClassNotFoundException {
  Object attributeValue=null;
  Class<?> realAttributeType;
  if (genericTypeArgs.length > 0 && genericTypeArgs[0] instanceof Class && attributeType.isAssignableFrom((Class)genericTypeArgs[0])) {
    realAttributeType=(Class)genericTypeArgs[0];
  }
 else {
    realAttributeType=attributeType;
  }
  AttributeMetadata attributeMetadata=new AttributeMetadata(attributeName,realAttributeType,annotations);
  if (realAttributeType.isPrimitive()) {
    attributeValue=resolvePrimitiveValue(realAttributeType,annotations,attributeMetadata);
  }
 else   if (isWrapper(realAttributeType)) {
    attributeValue=resolveWrapperValue(realAttributeType,annotations,attributeMetadata);
  }
 else   if (realAttributeType.equals(String.class)) {
    attributeValue=resolveStringValue(annotations,attributeMetadata);
  }
 else   if (realAttributeType.getName().startsWith(""String_Node_Str"")) {
    attributeValue=resolveArrayElementValue(realAttributeType,annotations,pojoClass,attributeName,typeArgsMap);
  }
 else   if (Collection.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveCollectionValueWhenCollectionIsPojoAttribute(pojoClass,realAttributeType,attributeName,annotations,typeArgsMap,genericTypeArgs);
  }
 else   if (Map.class.isAssignableFrom(realAttributeType)) {
    attributeValue=resolveMapValueWhenMapIsPojoAttribute(pojoClass,realAttributeType,attributeName,annotations,typeArgsMap,genericTypeArgs);
  }
 else   if (realAttributeType.getName().startsWith(""String_Node_Str"") || realAttributeType.getName().startsWith(""String_Node_Str"")) {
    attributeValue=createNewInstanceForClassWithoutConstructors(pojoClass,realAttributeType,genericTypeArgs);
  }
 else   if (realAttributeType.isEnum()) {
    int enumConstantsLength=realAttributeType.getEnumConstants().length;
    if (enumConstantsLength > 0) {
      int enumIndex=strategy.getIntegerInRange(0,enumConstantsLength,attributeMetadata) % enumConstantsLength;
      attributeValue=realAttributeType.getEnumConstants()[enumIndex];
    }
  }
 else {
    attributeValue=this.manufacturePojo(realAttributeType,genericTypeArgs);
  }
  return attributeValue;
}","/** 
 * It manufactures and returns the value for a POJO attribute.
 * @param pojoClass The POJO class being filled with values
 * @param attributeType The type of the attribute for which a value is being manufactured
 * @param annotations The annotations for the attribute being considered
 * @param attributeName The attribute name
 * @param typeArgsMap a map relating the generic class arguments (""<T, V>"" for example) with their actual types
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return The value for an attribute
 * @throws InstantiationException If an exception occurred during instantiation
 * @throws IllegalAccessException If security was violated while creating the object
 * @throws InvocationTargetException If an exception occurred while invoking the constructor or factory method
 * @throws ClassNotFoundException If it was not possible to create a class from a string
 * @throws IllegalArgumentException <ul> <li>If an illegal argument was passed</li> <li>If an invalid value was set for a precise value in an annotation and such value could not be converted to the desired type</li> </ul>
 */
@SuppressWarnings(""String_Node_Str"") private Object manufactureAttributeValue(Class<?> pojoClass,Class<?> attributeType,List<Annotation> annotations,String attributeName,Map<String,Type> typeArgsMap,Type... genericTypeArgs) throws InstantiationException, IllegalAccessException, InvocationTargetException, IllegalArgumentException, ClassNotFoundException {
  int depth=0;
  return manufactureAttributeValueInternal(pojoClass,depth,attributeType,annotations,attributeName,typeArgsMap,genericTypeArgs);
}",0.5872628217170769
175941,"/** 
 * Generic method which returns an instance of the given class filled with values dictated by the strategy
 * @param < T > The type for which a filled instance is required
 * @param pojoClass The name of the class for which an instance filled with values is required
 * @param depth How many times  {@code pojoClass} has been found. This will beused for reentrant objects
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return An instance of <T> filled with dummy values
 * @throws PodamMockeryException if a problem occurred while creating a POJO instance or while setting its state
 */
@SuppressWarnings(""String_Node_Str"") private <T>T manufacturePojoInternal(Class<T> pojoClass,int depth,Type... genericTypeArgs){
  try {
    T retValue=null;
    final TypeVariable<?>[] typeParameters=pojoClass.getTypeParameters();
    if (typeParameters.length > genericTypeArgs.length) {
      LOG.info(pojoClass.getCanonicalName() + ""String_Node_Str"" + typeParameters.length+ ""String_Node_Str""+ genericTypeArgs.length+ ""String_Node_Str"");
      return retValue;
    }
    if (pojoClass.isPrimitive()) {
      ArrayList<Annotation> annotations=new ArrayList<Annotation>();
      String noName=null;
      return (T)resolvePrimitiveValue(pojoClass,annotations,new AttributeMetadata(noName,pojoClass,annotations));
    }
    if (pojoClass.isInterface() || Modifier.isAbstract(pojoClass.getModifiers())) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    ClassInfo classInfo=PodamUtils.getClassInfo(pojoClass,excludeAnnotations);
    try {
      Constructor<?>[] constructors=pojoClass.getConstructors();
      if (constructors == null || constructors.length == 0) {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"");
        Constructor<T> defaultConstructor=pojoClass.getDeclaredConstructor(new Class[]{});
        LOG.info(""String_Node_Str"" + defaultConstructor);
        defaultConstructor.setAccessible(true);
        retValue=defaultConstructor.newInstance();
      }
 else {
        retValue=resolvePojoWithoutSetters(pojoClass,depth,genericTypeArgs);
      }
    }
 catch (    SecurityException e) {
      throw new PodamMockeryException(""String_Node_Str"",e);
    }
catch (    NoSuchMethodException e1) {
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      Constructor<?>[] constructors=pojoClass.getDeclaredConstructors();
      if (constructors == null || constructors.length == 0) {
        throw new IllegalStateException(""String_Node_Str"" + pojoClass + ""String_Node_Str"");
      }
      LOG.info(""String_Node_Str"" + constructors[0]);
      Object[] parameterValuesForConstructor=getParameterValuesForConstructor(constructors[0],pojoClass,genericTypeArgs);
      constructors[0].setAccessible(true);
      retValue=(T)constructors[0].newInstance(parameterValuesForConstructor);
    }
    Class<?>[] parameterTypes=null;
    Class<?> attributeType=null;
    Object setterArg=null;
    for (    Method setter : classInfo.getClassSetters()) {
      List<Annotation> pojoAttributeAnnotations=retrieveFieldAnnotations(pojoClass,setter);
      String attributeName=PodamUtils.extractFieldNameFromSetterMethod(setter);
      parameterTypes=setter.getParameterTypes();
      if (parameterTypes.length != 1) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      attributeType=parameterTypes[0];
      PodamStrategyValue attributeStrategyAnnotation=containsAttributeStrategyAnnotation(pojoAttributeAnnotations);
      if (null != attributeStrategyAnnotation) {
        AttributeStrategy<?> attributeStrategy=attributeStrategyAnnotation.value().newInstance();
        if (LOG.isDebugEnabled()) {
          LOG.debug(""String_Node_Str"" + attributeName + ""String_Node_Str""+ attributeStrategy);
        }
        setterArg=returnAttributeDataStrategyValue(attributeType,attributeStrategy);
      }
 else {
        final Map<String,Type> typeArgsMap=new HashMap<String,Type>();
        Type[] genericTypeArgsExtra=fillTypeArgMap(typeArgsMap,typeParameters,genericTypeArgs);
        if (genericTypeArgsExtra != null) {
          LOG.warn(String.format(""String_Node_Str"",genericTypeArgsExtra.length));
        }
        if (attributeType.equals(pojoClass)) {
          if (depth < strategy.getMaxDepth(pojoClass)) {
            depth++;
            setterArg=this.manufacturePojoInternal(attributeType,depth);
            setter.invoke(retValue,setterArg);
            continue;
          }
 else {
            setterArg=createNewInstanceForClassWithoutConstructors(pojoClass,pojoClass);
            setter.invoke(retValue,setterArg);
            depth=0;
            continue;
          }
        }
        Type[] typeArguments=new Type[]{};
        if (setter.getGenericParameterTypes()[0] instanceof ParameterizedType) {
          final ParameterizedType attributeParameterizedType=(ParameterizedType)setter.getGenericParameterTypes()[0];
          typeArguments=attributeParameterizedType.getActualTypeArguments();
        }
 else         if (setter.getGenericParameterTypes()[0] instanceof TypeVariable) {
          final TypeVariable<?> typeVariable=(TypeVariable<?>)setter.getGenericParameterTypes()[0];
          Type type=typeArgsMap.get(typeVariable.getName());
          if (type instanceof ParameterizedType) {
            final ParameterizedType attributeParameterizedType=(ParameterizedType)type;
            typeArguments=attributeParameterizedType.getActualTypeArguments();
            attributeType=(Class<?>)attributeParameterizedType.getRawType();
          }
 else {
            attributeType=(Class<?>)type;
          }
        }
        setterArg=manufactureAttributeValue(pojoClass,attributeType,pojoAttributeAnnotations,attributeName,typeArgsMap,typeArguments);
      }
      if (setterArg != null) {
        if (!Modifier.isPublic(setter.getModifiers())) {
          LOG.warn(""String_Node_Str"" + setter.getName() + ""String_Node_Str""+ ""String_Node_Str"");
          setter.setAccessible(true);
        }
        setter.invoke(retValue,setterArg);
      }
 else {
        LOG.warn(""String_Node_Str"" + attributeName + ""String_Node_Str"");
      }
    }
    return retValue;
  }
 catch (  InstantiationException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  IllegalArgumentException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  InvocationTargetException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  ClassNotFoundException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
}","/** 
 * Generic method which returns an instance of the given class filled with values dictated by the strategy
 * @param < T > The type for which a filled instance is required
 * @param pojoClass The name of the class for which an instance filled with values is required
 * @param depth How many times  {@code pojoClass} has been found. This will beused for reentrant objects
 * @param genericTypeArgs The generic type arguments for the current generic class instance
 * @return An instance of <T> filled with dummy values
 * @throws PodamMockeryException if a problem occurred while creating a POJO instance or while setting its state
 */
@SuppressWarnings(""String_Node_Str"") private <T>T manufacturePojoInternal(Class<T> pojoClass,int depth,Type... genericTypeArgs){
  try {
    T retValue=null;
    final TypeVariable<?>[] typeParameters=pojoClass.getTypeParameters();
    if (typeParameters.length > genericTypeArgs.length) {
      LOG.info(pojoClass.getCanonicalName() + ""String_Node_Str"" + typeParameters.length+ ""String_Node_Str""+ genericTypeArgs.length+ ""String_Node_Str"");
      return retValue;
    }
    if (pojoClass.isPrimitive()) {
      ArrayList<Annotation> annotations=new ArrayList<Annotation>();
      String noName=null;
      return (T)resolvePrimitiveValue(pojoClass,annotations,new AttributeMetadata(noName,pojoClass,annotations));
    }
    if (pojoClass.isInterface() || Modifier.isAbstract(pojoClass.getModifiers())) {
      LOG.warn(""String_Node_Str"");
      return null;
    }
    ClassInfo classInfo=PodamUtils.getClassInfo(pojoClass,excludeAnnotations);
    try {
      Constructor<?>[] constructors=pojoClass.getConstructors();
      if (constructors == null || constructors.length == 0) {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"");
        Constructor<T> defaultConstructor=pojoClass.getDeclaredConstructor(new Class[]{});
        LOG.info(""String_Node_Str"" + defaultConstructor);
        defaultConstructor.setAccessible(true);
        retValue=defaultConstructor.newInstance();
      }
 else {
        retValue=resolvePojoWithoutSetters(pojoClass,depth,genericTypeArgs);
      }
    }
 catch (    SecurityException e) {
      throw new PodamMockeryException(""String_Node_Str"",e);
    }
catch (    NoSuchMethodException e1) {
      LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      Constructor<?>[] constructors=pojoClass.getDeclaredConstructors();
      if (constructors == null || constructors.length == 0) {
        throw new IllegalStateException(""String_Node_Str"" + pojoClass + ""String_Node_Str"");
      }
      LOG.info(""String_Node_Str"" + constructors[0]);
      Object[] parameterValuesForConstructor=getParameterValuesForConstructor(constructors[0],pojoClass,genericTypeArgs);
      constructors[0].setAccessible(true);
      retValue=(T)constructors[0].newInstance(parameterValuesForConstructor);
    }
    Class<?>[] parameterTypes=null;
    Class<?> attributeType=null;
    Object setterArg=null;
    for (    Method setter : classInfo.getClassSetters()) {
      List<Annotation> pojoAttributeAnnotations=retrieveFieldAnnotations(pojoClass,setter);
      String attributeName=PodamUtils.extractFieldNameFromSetterMethod(setter);
      parameterTypes=setter.getParameterTypes();
      if (parameterTypes.length != 1) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      attributeType=parameterTypes[0];
      PodamStrategyValue attributeStrategyAnnotation=containsAttributeStrategyAnnotation(pojoAttributeAnnotations);
      if (null != attributeStrategyAnnotation) {
        AttributeStrategy<?> attributeStrategy=attributeStrategyAnnotation.value().newInstance();
        if (LOG.isDebugEnabled()) {
          LOG.debug(""String_Node_Str"" + attributeName + ""String_Node_Str""+ attributeStrategy);
        }
        setterArg=returnAttributeDataStrategyValue(attributeType,attributeStrategy);
      }
 else {
        final Map<String,Type> typeArgsMap=new HashMap<String,Type>();
        Type[] genericTypeArgsExtra=fillTypeArgMap(typeArgsMap,typeParameters,genericTypeArgs);
        if (genericTypeArgsExtra != null) {
          LOG.warn(String.format(""String_Node_Str"",genericTypeArgsExtra.length));
        }
        if (depth >= strategy.getMaxDepth(pojoClass)) {
          setterArg=createNewInstanceForClassWithoutConstructors(attributeType,attributeType);
        }
 else {
          Type[] typeArguments=new Type[]{};
          if (setter.getGenericParameterTypes()[0] instanceof ParameterizedType) {
            final ParameterizedType attributeParameterizedType=(ParameterizedType)setter.getGenericParameterTypes()[0];
            typeArguments=attributeParameterizedType.getActualTypeArguments();
          }
 else           if (setter.getGenericParameterTypes()[0] instanceof TypeVariable) {
            final TypeVariable<?> typeVariable=(TypeVariable<?>)setter.getGenericParameterTypes()[0];
            Type type=typeArgsMap.get(typeVariable.getName());
            if (type instanceof ParameterizedType) {
              final ParameterizedType attributeParameterizedType=(ParameterizedType)type;
              typeArguments=attributeParameterizedType.getActualTypeArguments();
              attributeType=(Class<?>)attributeParameterizedType.getRawType();
            }
 else {
              attributeType=(Class<?>)type;
            }
          }
          setterArg=manufactureAttributeValueInternal(pojoClass,depth,attributeType,pojoAttributeAnnotations,attributeName,typeArgsMap,typeArguments);
        }
      }
      if (setterArg != null) {
        if (!Modifier.isPublic(setter.getModifiers())) {
          LOG.warn(""String_Node_Str"" + setter.getName() + ""String_Node_Str""+ ""String_Node_Str"");
          setter.setAccessible(true);
        }
        setter.invoke(retValue,setterArg);
      }
 else {
        LOG.warn(""String_Node_Str"" + attributeName + ""String_Node_Str"");
      }
    }
    return retValue;
  }
 catch (  InstantiationException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  IllegalArgumentException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  InvocationTargetException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  ClassNotFoundException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
}",0.9660101893392138
175942,"/** 
 * It returns a collection of some sort with some data in it.
 * @param pojoClass The POJO being analysed
 * @param collectionType The type of the attribute being evaluated
 * @param annotations The set of annotations for the annotated attribute. It might be empty
 * @param attributeName The name of the field being set
 * @return a collection of some sort with some data in it
 * @throws PodamMockeryException An exception occurred while resolving the collection
 * @throws IllegalArgumentException If the field name is null or empty
 */
@SuppressWarnings({""String_Node_Str""}) private Collection<? super Object> resolveCollectionValueWhenCollectionIsPojoAttribute(Class<?> pojoClass,Class<?> collectionType,String attributeName,List<Annotation> annotations){
  this.validateAttributeName(attributeName);
  Collection<? super Object> retValue=null;
  try {
    Object newInstance=pojoClass.newInstance();
    Field field=pojoClass.getDeclaredField(attributeName);
    field.setAccessible(true);
    Collection<? super Object> coll=(Collection<? super Object>)field.get(newInstance);
    if (null != coll) {
      retValue=coll;
    }
 else {
      retValue=this.resolveCollectionType(collectionType);
    }
    Class<?> typeClass=null;
    Type genericType=field.getGenericType();
    if (!(genericType instanceof ParameterizedType)) {
      LOG.warn(""String_Node_Str"" + attributeName + ""String_Node_Str"");
      typeClass=Object.class;
    }
 else {
      ParameterizedType pType=(ParameterizedType)genericType;
      Type actualTypeArguments=pType.getActualTypeArguments()[0];
      typeClass=Class.forName(PodamUtils.extractClassNameFromParameterisedTypeInField(actualTypeArguments));
    }
    this.fillCollection(pojoClass,attributeName,annotations,retValue,typeClass);
  }
 catch (  SecurityException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  NoSuchFieldException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  IllegalArgumentException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  InstantiationException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  ClassNotFoundException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  InvocationTargetException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
  return retValue;
}","/** 
 * It returns a collection of some sort with some data in it.
 * @param pojoClass The POJO being analysed
 * @param collectionType The type of the attribute being evaluated
 * @param annotations The set of annotations for the annotated attribute. It might be empty
 * @param attributeName The name of the field being set
 * @return a collection of some sort with some data in it
 * @throws PodamMockeryException An exception occurred while resolving the collection
 * @throws IllegalArgumentException If the field name is null or empty
 */
@SuppressWarnings({""String_Node_Str""}) private Collection<? super Object> resolveCollectionValueWhenCollectionIsPojoAttribute(Class<?> pojoClass,Class<?> collectionType,String attributeName,List<Annotation> annotations){
  this.validateAttributeName(attributeName);
  Collection<? super Object> retValue=null;
  try {
    Object newInstance=pojoClass.newInstance();
    Field field=null;
    Class<?> clazz=pojoClass;
    while (clazz != null) {
      try {
        field=clazz.getDeclaredField(attributeName);
        break;
      }
 catch (      NoSuchFieldException e) {
        clazz=clazz.getSuperclass();
      }
catch (      SecurityException e) {
        throw e;
      }
    }
    if (field == null) {
      throw new NoSuchFieldException();
    }
    field.setAccessible(true);
    Collection<? super Object> coll=(Collection<? super Object>)field.get(newInstance);
    if (null != coll) {
      retValue=coll;
    }
 else {
      retValue=this.resolveCollectionType(collectionType);
    }
    Class<?> typeClass=null;
    Type genericType=field.getGenericType();
    if (!(genericType instanceof ParameterizedType)) {
      LOG.warn(""String_Node_Str"" + attributeName + ""String_Node_Str"");
      typeClass=Object.class;
    }
 else {
      ParameterizedType pType=(ParameterizedType)genericType;
      Type actualTypeArguments=pType.getActualTypeArguments()[0];
      typeClass=Class.forName(PodamUtils.extractClassNameFromParameterisedTypeInField(actualTypeArguments));
    }
    this.fillCollection(pojoClass,attributeName,annotations,retValue,typeClass);
  }
 catch (  SecurityException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  NoSuchFieldException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  IllegalArgumentException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  InstantiationException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  ClassNotFoundException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
catch (  InvocationTargetException e) {
    throw new PodamMockeryException(""String_Node_Str"",e);
  }
  return retValue;
}",0.9376642883965453
175943,"public JenkinsWindowManager(Project project){
  this.project=project;
  final BrowserPanel browserPanel=BrowserPanel.getInstance(project);
  Content content=ContentFactory.SERVICE.getInstance().createContent(browserPanel,null,false);
  ToolWindowManager toolWindowManager=ToolWindowManager.getInstance(project);
  ToolWindow toolWindow=toolWindowManager.registerToolWindow(JENKINS_BROWSER,false,ToolWindowAnchor.RIGHT);
  toolWindow.setIcon(JENKINS_ICON);
  ContentManager contentManager=toolWindow.getContentManager();
  contentManager.addContent(content);
  final StatusBar statusBar=WindowManager.getInstance().getStatusBar(project);
  JenkinsWidget jenkinsWidget=JenkinsWidget.getInstance(project);
  statusBar.addWidget(jenkinsWidget);
  jenkinsWidget.install(statusBar);
  final RssLogic rssLogic=RssLogic.getInstance(project);
  StartupManager.getInstance(project).registerPostStartupActivity(new DumbAwareRunnable(){
    @Override public void run(){
      browserPanel.init();
      rssLogic.init();
    }
  }
);
}","public JenkinsWindowManager(Project project){
  this.project=project;
  final BrowserPanel browserPanel=BrowserPanel.getInstance(project);
  Content content=ContentFactory.SERVICE.getInstance().createContent(browserPanel,null,false);
  ToolWindowManager toolWindowManager=ToolWindowManager.getInstance(project);
  ToolWindow toolWindow=toolWindowManager.registerToolWindow(JENKINS_BROWSER,false,ToolWindowAnchor.RIGHT);
  toolWindow.setIcon(JENKINS_ICON);
  ContentManager contentManager=toolWindow.getContentManager();
  contentManager.addContent(content);
  final StatusBar statusBar=WindowManager.getInstance().getStatusBar(project);
  final JenkinsWidget jenkinsWidget=JenkinsWidget.getInstance(project);
  statusBar.addWidget(jenkinsWidget);
  jenkinsWidget.install(statusBar);
  final RssLogic rssLogic=RssLogic.getInstance(project);
  StartupManager.getInstance(project).registerPostStartupActivity(new DumbAwareRunnable(){
    @Override public void run(){
      browserPanel.init();
      rssLogic.init();
    }
  }
);
}",0.9970731707317072
175944,"public void reloadConfiguration(){
  if (!SwingUtilities.isEventDispatchThread()) {
    logger.warn(""String_Node_Str"");
  }
  if (!jenkinsAppSettings.isServerUrlSet()) {
    JenkinsWidget.getInstance(project).updateStatusIcon(BuildStatusAggregator.EMPTY);
    DefaultTreeModel model=(DefaultTreeModel)jobTree.getModel();
    DefaultMutableTreeNode root=(DefaultMutableTreeNode)model.getRoot();
    root.removeAllChildren();
    model.nodeStructureChanged(root);
    jobTree.setRootVisible(false);
    jenkins.update(Jenkins.byDefault());
    currentSelectedView=null;
    jobTree.getEmptyText().setText(UNAVAILABLE);
    return;
  }
  new Task.Backgroundable(project,""String_Node_Str"",false,JenkinsLoadingTaskOption.INSTANCE){
    private Jenkins jenkinsWorkspace;
    @Override public void onSuccess(){
      jenkins.update(jenkinsWorkspace);
    }
    @Override public void onCancel(){
      jobTree.getEmptyText().setText(UNAVAILABLE);
    }
    @Override public void run(    @NotNull ProgressIndicator indicator){
      indicator.setIndeterminate(true);
      requestManager.authenticate(jenkinsAppSettings,jenkinsSettings);
      jenkinsWorkspace=requestManager.loadJenkinsWorkspace(jenkinsAppSettings);
    }
  }
.queue();
  if (!jenkinsSettings.getFavoriteJobs().isEmpty()) {
    createFavoriteViewIfNecessary();
  }
  String lastSelectedViewName=jenkinsSettings.getLastSelectedView();
  View viewToLoad;
  if (StringUtils.isEmpty(lastSelectedViewName)) {
    viewToLoad=jenkins.getPrimaryView();
  }
 else   if (favoriteView != null && lastSelectedViewName.equals(favoriteView.getName())) {
    viewToLoad=favoriteView;
  }
 else {
    viewToLoad=jenkins.getViewByName(lastSelectedViewName);
  }
  loadView(viewToLoad);
}","public void reloadConfiguration(){
  if (!SwingUtilities.isEventDispatchThread()) {
    logger.warn(""String_Node_Str"");
  }
  if (!jenkinsAppSettings.isServerUrlSet()) {
    JenkinsWidget.getInstance(project).updateStatusIcon(BuildStatusAggregator.EMPTY);
    DefaultTreeModel model=(DefaultTreeModel)jobTree.getModel();
    DefaultMutableTreeNode root=(DefaultMutableTreeNode)model.getRoot();
    root.removeAllChildren();
    model.nodeStructureChanged(root);
    jobTree.setRootVisible(false);
    jenkins.update(Jenkins.byDefault());
    currentSelectedView=null;
    jobTree.getEmptyText().setText(UNAVAILABLE);
    return;
  }
  new Task.Backgroundable(project,""String_Node_Str"",false,JenkinsLoadingTaskOption.INSTANCE){
    private Jenkins jenkinsWorkspace;
    @Override public void onSuccess(){
      jenkins.update(jenkinsWorkspace);
      BrowserPanel.this.refreshCurrentView();
    }
    @Override public void onCancel(){
      jobTree.getEmptyText().setText(UNAVAILABLE);
    }
    @Override public void run(    @NotNull ProgressIndicator indicator){
      indicator.setIndeterminate(true);
      requestManager.authenticate(jenkinsAppSettings,jenkinsSettings);
      jenkinsWorkspace=requestManager.loadJenkinsWorkspace(jenkinsAppSettings);
    }
  }
.queue();
  if (!jenkinsSettings.getFavoriteJobs().isEmpty()) {
    createFavoriteViewIfNecessary();
  }
  String lastSelectedViewName=jenkinsSettings.getLastSelectedView();
  View viewToLoad;
  if (StringUtils.isEmpty(lastSelectedViewName)) {
    viewToLoad=jenkins.getPrimaryView();
  }
 else   if (favoriteView != null && lastSelectedViewName.equals(favoriteView.getName())) {
    viewToLoad=favoriteView;
  }
 else {
    viewToLoad=jenkins.getViewByName(lastSelectedViewName);
  }
  loadView(viewToLoad);
}",0.9868721461187214
175945,"/** 
 * Set the IP address that Spark should listen on. If not called the default address is '0.0.0.0'. This has to be called before any route mapping is done.
 * @param port The port number
 */
public synchronized static void setIpAddress(String ipAddress){
  if (initialized) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Spark.ipAddress=ipAddress;
}","/** 
 * Set the IP address that Spark should listen on. If not called the default address is '0.0.0.0'. This has to be called before any route mapping is done.
 * @param port The ipAddress
 */
public synchronized static void setIpAddress(String ipAddress){
  if (initialized) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Spark.ipAddress=ipAddress;
}",0.97289972899729
175946,"/** 
 * Ignites the spark server listening on the provided address and port
 * @param port The port to listen on
 * @param host The address to listen on
 */
void ignite(String host,int port);","/** 
 * Ignites the spark server listening on the provided address and port
 * @param host The address to listen on
 * @param port The port to listen on
 */
void ignite(String host,int port);",0.9319371727748692
175947,"synchronized static void stop(){
  if (server != null) {
    server.stop();
    initialized=false;
  }
}","synchronized static void stop(){
  if (server != null) {
    server.stop();
  }
  initialized=false;
}",0.970873786407767
175948,"/** 
 * The contructor used with an inflater
 * @param context
 * @param attrs
 */
public TitleFlowIndicator(Context context,AttributeSet attrs){
  super(context,attrs);
  int typefaceIndex=attrs.getAttributeIntValue(""String_Node_Str"",""String_Node_Str"",0);
  int textStyleIndex=attrs.getAttributeIntValue(""String_Node_Str"",""String_Node_Str"",0);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.TitleFlowIndicator);
  String customTypeface=a.getString(R.styleable.TitleFlowIndicator_customTypeface);
  int footerColor=a.getColor(R.styleable.TitleFlowIndicator_footerColor,FOOTER_COLOR);
  footerLineHeight=a.getDimension(R.styleable.TitleFlowIndicator_footerLineHeight,FOOTER_LINE_HEIGHT);
  footerTriangleHeight=a.getDimension(R.styleable.TitleFlowIndicator_footerTriangleHeight,FOOTER_TRIANGLE_HEIGHT);
  int selectedColor=a.getColor(R.styleable.TitleFlowIndicator_selectedColor,SELECTED_COLOR);
  boolean selectedBold=a.getBoolean(R.styleable.TitleFlowIndicator_selectedColor,SELECTED_BOLD);
  int textColor=a.getColor(R.styleable.TitleFlowIndicator_textColor,TEXT_COLOR);
  float textSize=a.getDimension(R.styleable.TitleFlowIndicator_textSize,TEXT_SIZE);
  float selectedSize=a.getDimension(R.styleable.TitleFlowIndicator_selectedSize,textSize);
  titlePadding=a.getDimension(R.styleable.TitleFlowIndicator_titlePadding,TITLE_PADDING);
  clipPadding=a.getDimension(R.styleable.TitleFlowIndicator_clipPadding,CLIP_PADDING);
  initDraw(textColor,textSize,selectedColor,selectedBold,selectedSize,footerLineHeight,footerColor);
  if (customTypeface != null)   typeface=Typeface.createFromAsset(context.getAssets(),customTypeface);
 else   typeface=getTypefaceByIndex(typefaceIndex);
  typeface=Typeface.create(typeface,textStyleIndex);
}","/** 
 * The contructor used with an inflater
 * @param context
 * @param attrs
 */
public TitleFlowIndicator(Context context,AttributeSet attrs){
  super(context,attrs);
  int typefaceIndex=attrs.getAttributeIntValue(""String_Node_Str"",""String_Node_Str"",0);
  int textStyleIndex=attrs.getAttributeIntValue(""String_Node_Str"",""String_Node_Str"",0);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.TitleFlowIndicator);
  String customTypeface=a.getString(R.styleable.TitleFlowIndicator_customTypeface);
  int footerColor=a.getColor(R.styleable.TitleFlowIndicator_footerColor,FOOTER_COLOR);
  footerLineHeight=a.getDimension(R.styleable.TitleFlowIndicator_footerLineHeight,FOOTER_LINE_HEIGHT);
  footerTriangleHeight=a.getDimension(R.styleable.TitleFlowIndicator_footerTriangleHeight,FOOTER_TRIANGLE_HEIGHT);
  int selectedColor=a.getColor(R.styleable.TitleFlowIndicator_selectedColor,SELECTED_COLOR);
  boolean selectedBold=a.getBoolean(R.styleable.TitleFlowIndicator_selectedBold,SELECTED_BOLD);
  int textColor=a.getColor(R.styleable.TitleFlowIndicator_textColor,TEXT_COLOR);
  float textSize=a.getDimension(R.styleable.TitleFlowIndicator_textSize,TEXT_SIZE);
  float selectedSize=a.getDimension(R.styleable.TitleFlowIndicator_selectedSize,textSize);
  titlePadding=a.getDimension(R.styleable.TitleFlowIndicator_titlePadding,TITLE_PADDING);
  clipPadding=a.getDimension(R.styleable.TitleFlowIndicator_clipPadding,CLIP_PADDING);
  initDraw(textColor,textSize,selectedColor,selectedBold,selectedSize,footerLineHeight,footerColor);
  if (customTypeface != null)   typeface=Typeface.createFromAsset(context.getAssets(),customTypeface);
 else   typeface=getTypefaceByIndex(typefaceIndex);
  typeface=Typeface.create(typeface,textStyleIndex);
}",0.9974307736226092
175949,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  ArrayList<Rect> bounds=calculateAllBounds(paintText);
  int count=(viewFlow != null && viewFlow.getAdapter() != null) ? viewFlow.getAdapter().getCount() : 1;
  Rect curViewBound=bounds.get(currentPosition);
  int curViewWidth=curViewBound.right - curViewBound.left;
  if (curViewBound.left < 0) {
    clipViewOnTheLeft(curViewBound,curViewWidth);
  }
  if (curViewBound.right > getLeft() + getWidth()) {
    clipViewOnTheRight(curViewBound,curViewWidth);
  }
  if (currentPosition > 0) {
    for (int iLoop=currentPosition - 1; iLoop >= 0; iLoop--) {
      Rect bound=bounds.get(iLoop);
      int w=bound.right - bound.left;
      if (bound.left < 0) {
        clipViewOnTheLeft(bound,w);
        if (iLoop < count - 1 && currentPosition != iLoop) {
          Rect rightBound=bounds.get(iLoop + 1);
          if (bound.right + TITLE_PADDING > rightBound.left) {
            bound.left=rightBound.left - (w + (int)titlePadding);
          }
        }
      }
    }
  }
  if (currentPosition < count - 1) {
    for (int iLoop=currentPosition + 1; iLoop < count; iLoop++) {
      Rect bound=bounds.get(iLoop);
      int w=bound.right - bound.left;
      if (bound.right > getLeft() + getWidth()) {
        clipViewOnTheRight(bound,w);
        if (iLoop > 0 && currentPosition != iLoop) {
          Rect leftBound=bounds.get(iLoop - 1);
          if (bound.left - TITLE_PADDING < leftBound.right) {
            bound.left=leftBound.right + (int)titlePadding;
          }
        }
      }
    }
  }
  for (int iLoop=0; iLoop < count; iLoop++) {
    String title=getTitle(iLoop);
    Rect bound=bounds.get(iLoop);
    if ((bound.left > getLeft() && bound.left < getLeft() + getWidth()) || (bound.right > getLeft() && bound.right < getLeft() + getWidth())) {
      Paint paint=paintText;
      int middle=(bound.left + bound.right) / 2;
      if (Math.abs(middle - (getWidth() / 2)) < 20) {
        paint=paintSelected;
      }
      canvas.drawText(title,bound.left,bound.bottom,paint);
    }
  }
  path=new Path();
  path.moveTo(0,getHeight() - footerLineHeight);
  path.lineTo(getWidth(),getHeight() - footerLineHeight);
  path.close();
  canvas.drawPath(path,paintFooterLine);
  path=new Path();
  path.moveTo(getWidth() / 2,getHeight() - footerLineHeight - footerTriangleHeight);
  path.lineTo(getWidth() / 2 + footerTriangleHeight,getHeight() - footerLineHeight);
  path.lineTo(getWidth() / 2 - footerTriangleHeight,getHeight() - footerLineHeight);
  path.close();
  canvas.drawPath(path,paintFooterTriangle);
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  ArrayList<Rect> bounds=calculateAllBounds(paintText);
  int count=(viewFlow != null && viewFlow.getAdapter() != null) ? viewFlow.getAdapter().getCount() : 1;
  Rect curViewBound=bounds.get(currentPosition);
  int curViewWidth=curViewBound.right - curViewBound.left;
  if (curViewBound.left < 0) {
    clipViewOnTheLeft(curViewBound,curViewWidth);
  }
  if (curViewBound.right > getLeft() + getWidth()) {
    clipViewOnTheRight(curViewBound,curViewWidth);
  }
  if (currentPosition > 0) {
    for (int iLoop=currentPosition - 1; iLoop >= 0; iLoop--) {
      Rect bound=bounds.get(iLoop);
      int w=bound.right - bound.left;
      if (bound.left < 0) {
        clipViewOnTheLeft(bound,w);
        if (iLoop < count - 1 && currentPosition != iLoop) {
          Rect rightBound=bounds.get(iLoop + 1);
          if (bound.right + TITLE_PADDING > rightBound.left) {
            bound.left=rightBound.left - (w + (int)titlePadding);
          }
        }
      }
    }
  }
  if (currentPosition < count - 1) {
    for (int iLoop=currentPosition + 1; iLoop < count; iLoop++) {
      Rect bound=bounds.get(iLoop);
      int w=bound.right - bound.left;
      if (bound.right > getLeft() + getWidth()) {
        clipViewOnTheRight(bound,w);
        if (iLoop > 0 && currentPosition != iLoop) {
          Rect leftBound=bounds.get(iLoop - 1);
          if (bound.left - TITLE_PADDING < leftBound.right) {
            bound.left=leftBound.right + (int)titlePadding;
          }
        }
      }
    }
  }
  for (int iLoop=0; iLoop < count; iLoop++) {
    String title=getTitle(iLoop);
    Rect bound=bounds.get(iLoop);
    if ((bound.left > getLeft() && bound.left < getLeft() + getWidth()) || (bound.right > getLeft() && bound.right < getLeft() + getWidth())) {
      Paint paint=paintText;
      int middle=(bound.left + bound.right) / 2;
      if (Math.abs(middle - (getWidth() / 2)) < 20) {
        paint=paintSelected;
      }
      canvas.drawText(title,bound.left,bound.bottom,paint);
    }
  }
  path=new Path();
  int coordY=getHeight() - 1;
  coordY-=(footerLineHeight % 2 == 1) ? footerLineHeight / 2 : footerLineHeight / 2 - 1;
  path.moveTo(0,coordY);
  path.lineTo(getWidth(),coordY);
  path.close();
  canvas.drawPath(path,paintFooterLine);
  path=new Path();
  path.moveTo(getWidth() / 2,getHeight() - footerLineHeight - footerTriangleHeight);
  path.lineTo(getWidth() / 2 + footerTriangleHeight,getHeight() - footerLineHeight);
  path.lineTo(getWidth() / 2 - footerTriangleHeight,getHeight() - footerLineHeight);
  path.close();
  canvas.drawPath(path,paintFooterTriangle);
}",0.9635565731730584
175950,"/** 
 * Initialize draw objects
 */
private void initDraw(int textColor,float textSize,int selectedColor,int footerLineHeight,int footerColor){
  paintText=new Paint();
  paintText.setColor(textColor);
  paintText.setTextSize(textSize);
  paintText.setAntiAlias(true);
  paintSelected=new Paint();
  paintSelected.setColor(selectedColor);
  paintSelected.setTextSize(textSize);
  paintSelected.setAntiAlias(true);
  paintFooterLine=new Paint();
  paintFooterLine.setStyle(Paint.Style.FILL_AND_STROKE);
  paintFooterLine.setStrokeWidth(footerLineHeight);
  paintFooterLine.setColor(FOOTER_COLOR);
  paintFooterTriangle=new Paint();
  paintFooterTriangle.setStyle(Paint.Style.FILL_AND_STROKE);
  paintFooterTriangle.setColor(footerColor);
}","/** 
 * Initialize draw objects
 */
private void initDraw(int textColor,float textSize,int selectedColor,int footerLineHeight,int footerColor){
  paintText=new Paint();
  paintText.setColor(textColor);
  paintText.setTextSize(textSize);
  paintText.setAntiAlias(true);
  paintSelected=new Paint();
  paintSelected.setColor(selectedColor);
  paintSelected.setTextSize(textSize);
  paintSelected.setAntiAlias(true);
  paintFooterLine=new Paint();
  paintFooterLine.setStyle(Paint.Style.FILL_AND_STROKE);
  paintFooterLine.setStrokeWidth(footerLineHeight);
  paintFooterLine.setColor(footerColor);
  paintFooterTriangle=new Paint();
  paintFooterTriangle.setStyle(Paint.Style.FILL_AND_STROKE);
  paintFooterTriangle.setColor(footerColor);
}",0.984406779661017
175951,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  return onTouchEvent(ev);
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  if (getChildCount() == 0)   return false;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
  final float x=ev.getX();
switch (action) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  mLastMotionX=x;
mTouchState=mScroller.isFinished() ? TOUCH_STATE_REST : TOUCH_STATE_SCROLLING;
break;
case MotionEvent.ACTION_MOVE:
final int xDiff=(int)Math.abs(x - mLastMotionX);
boolean xMoved=xDiff > mTouchSlop;
if (xMoved) {
mTouchState=TOUCH_STATE_SCROLLING;
}
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int deltaX=(int)(mLastMotionX - x);
mLastMotionX=x;
final int scrollX=getScrollX();
if (deltaX < 0) {
if (scrollX > 0) {
scrollBy(Math.max(-scrollX,deltaX),0);
}
}
 else if (deltaX > 0) {
final int availableToScroll=getChildAt(getChildCount() - 1).getRight() - scrollX - getWidth();
if (availableToScroll > 0) {
scrollBy(Math.min(availableToScroll,deltaX),0);
}
}
return true;
}
break;
case MotionEvent.ACTION_UP:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int velocityX=(int)velocityTracker.getXVelocity();
if (velocityX > SNAP_VELOCITY && mCurrentScreen > 0) {
snapToScreen(mCurrentScreen - 1);
}
 else if (velocityX < -SNAP_VELOCITY && mCurrentScreen < getChildCount() - 1) {
snapToScreen(mCurrentScreen + 1);
}
 else {
snapToDestination();
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
mTouchState=TOUCH_STATE_REST;
break;
case MotionEvent.ACTION_CANCEL:
mTouchState=TOUCH_STATE_REST;
}
return false;
}",0.0707497360084477
175952,"private void logBuffer(){
  int index=0;
  for (  View view : mLoadedViews) {
    if (view instanceof LinearLayout) {
      LinearLayout ll=((LinearLayout)view);
      for (int i=0; i < ll.getChildCount(); i++) {
        View v=ll.getChildAt(i);
        if (v instanceof TextView) {
          Log.d(""String_Node_Str"",""String_Node_Str"" + index + ""String_Node_Str""+ ((TextView)v).getText());
          break;
        }
      }
    }
    index++;
  }
  Log.d(""String_Node_Str"",""String_Node_Str"" + mScroller.getCurrX() + ""String_Node_Str""+ mScroller.getCurrY());
  Log.d(""String_Node_Str"",""String_Node_Str"" + mCurrentAdapterIndex + ""String_Node_Str""+ mCurrentBufferIndex);
}","private void logBuffer(){
  Log.d(""String_Node_Str"",""String_Node_Str"" + mLoadedViews.size() + ""String_Node_Str""+ mScroller.getCurrX()+ ""String_Node_Str""+ mScroller.getCurrY());
  Log.d(""String_Node_Str"",""String_Node_Str"" + mCurrentAdapterIndex + ""String_Node_Str""+ mCurrentBufferIndex);
}",0.4488517745302714
175953,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (getChildCount() == 0)   return false;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
  final float x=ev.getX();
switch (action) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  mLastMotionX=x;
mTouchState=mScroller.isFinished() ? TOUCH_STATE_REST : TOUCH_STATE_SCROLLING;
break;
case MotionEvent.ACTION_MOVE:
final int xDiff=(int)Math.abs(x - mLastMotionX);
boolean xMoved=xDiff > mTouchSlop;
if (xMoved) {
mTouchState=TOUCH_STATE_SCROLLING;
}
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int deltaX=(int)(mLastMotionX - x);
mLastMotionX=x;
final int scrollX=getScrollX();
if (deltaX < 0) {
if (scrollX > 0) {
scrollBy(Math.max(-scrollX,deltaX),0);
}
}
 else if (deltaX > 0) {
final int availableToScroll=getChildAt(getChildCount() - 1).getRight() - scrollX - getWidth();
if (availableToScroll > 0) {
scrollBy(Math.min(availableToScroll,deltaX),0);
}
}
return true;
}
break;
case MotionEvent.ACTION_UP:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int velocityX=(int)velocityTracker.getXVelocity();
if (velocityX > SNAP_VELOCITY && mCurrentScreen > 0) {
snapToScreen(mCurrentScreen - 1);
}
 else if (velocityX < -SNAP_VELOCITY && mCurrentScreen < getChildCount() - 1) {
snapToScreen(mCurrentScreen + 1);
}
 else {
snapToDestination();
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
mTouchState=TOUCH_STATE_REST;
break;
case MotionEvent.ACTION_CANCEL:
mTouchState=TOUCH_STATE_REST;
}
return false;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (getChildCount() == 0)   return false;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
  final float x=ev.getX();
switch (action) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  mLastMotionX=x;
mTouchState=mScroller.isFinished() ? TOUCH_STATE_REST : TOUCH_STATE_SCROLLING;
break;
case MotionEvent.ACTION_MOVE:
final int xDiff=(int)Math.abs(x - mLastMotionX);
boolean xMoved=xDiff > mTouchSlop;
if (xMoved) {
mTouchState=TOUCH_STATE_SCROLLING;
}
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int deltaX=(int)(mLastMotionX - x);
mLastMotionX=x;
final int scrollX=getScrollX();
if (deltaX < 0) {
if (scrollX > 0) {
scrollBy(Math.max(-scrollX,deltaX),0);
}
}
 else if (deltaX > 0) {
final int availableToScroll=getChildAt(getChildCount() - 1).getRight() - scrollX - getWidth();
if (availableToScroll > 0) {
scrollBy(Math.min(availableToScroll,deltaX),0);
}
}
return true;
}
break;
case MotionEvent.ACTION_UP:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int velocityX=(int)velocityTracker.getXVelocity();
if (velocityX > SNAP_VELOCITY && mCurrentScreen > 0) {
snapToScreen(mCurrentScreen - 1);
}
 else if (velocityX < -SNAP_VELOCITY && mCurrentScreen < getChildCount() - 1) {
snapToScreen(mCurrentScreen + 1);
}
 else {
snapToDestination();
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
mTouchState=TOUCH_STATE_REST;
break;
case MotionEvent.ACTION_CANCEL:
mTouchState=TOUCH_STATE_REST;
}
return true;
}",0.998047419804742
175954,"@Override protected void create(List<TableInfo> tableInfos){
  List listTables=r.db(databaseName).tableList().run(connection);
  for (  TableInfo tableInfo : tableInfos) {
    try {
      if (listTables.contains(tableInfo.getTableName())) {
        r.db(databaseName).tableDrop(tableInfo.getTableName()).run(connection);
      }
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"" + tableInfo.getTableName() + ""String_Node_Str""+ e);
      throw new KunderaException(""String_Node_Str"" + tableInfo.getTableName() + ""String_Node_Str""+ e);
    }
    r.db(databaseName).tableCreate(tableInfo.getTableName()).run(connection);
  }
}","@Override protected void create(List<TableInfo> tableInfos){
  List dbList=r.dbList().run(connection);
  if (!dbList.contains(databaseName)) {
    r.dbCreate(databaseName).run(connection);
  }
  List listTables=r.db(databaseName).tableList().run(connection);
  for (  TableInfo tableInfo : tableInfos) {
    try {
      if (listTables.contains(tableInfo.getTableName())) {
        r.db(databaseName).tableDrop(tableInfo.getTableName()).run(connection);
      }
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"" + tableInfo.getTableName() + ""String_Node_Str""+ e);
      throw new KunderaException(""String_Node_Str"" + tableInfo.getTableName() + ""String_Node_Str""+ e);
    }
    r.db(databaseName).tableCreate(tableInfo.getTableName()).run(connection);
  }
}",0.9069111424541608
175955,"@Override public void dropSchema(){
  try {
    r.dbDrop(databaseName);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw new SchemaGenerationException(e,""String_Node_Str"");
  }
}","@Override public void dropSchema(){
  try {
    if (operation != null && (""String_Node_Str"").equalsIgnoreCase(operation)) {
      r.dbDrop(databaseName);
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw new SchemaGenerationException(e,""String_Node_Str"");
  }
}",0.8247011952191236
175956,"/** 
 * Gets the validation serializer class instance.
 * @param dataType the data type
 * @param isCql3Enabled the is cql3 enabled
 * @return the validation serializer class instance
 */
public static TypeSerializer<?> getValidationSerializerClassInstance(Class<?> dataType,boolean isCql3Enabled){
  resetMapperForCQL3(isCql3Enabled);
  TypeSerializer<?> validation_class;
  validation_class=validationSerializerClassMapper.get(dataType);
  if (!(validation_class != null)) {
    validation_class=BytesSerializer.instance;
  }
  resetMapperForThrift(isCql3Enabled);
  return validation_class;
}","/** 
 * Gets the validation serializer class instance.
 * @param dataType the data type
 * @param isCql3Enabled the is cql3 enabled
 * @return the validation serializer class instance
 */
public static TypeSerializer<?> getValidationSerializerClassInstance(Class<?> dataType,boolean isCql3Enabled){
  resetMapperForCQL3(isCql3Enabled);
  TypeSerializer<?> validation_class;
  validation_class=validationSerializerClassMapper.get(dataType);
  if (validation_class == null) {
    if (dataType.isEnum()) {
      validation_class=UTF8Serializer.instance;
    }
 else {
      validation_class=BytesSerializer.instance;
    }
  }
  resetMapperForThrift(isCql3Enabled);
  return validation_class;
}",0.8895800933125972
175957,"/** 
 * On cql3 create keyspace.
 * @throws InvalidRequestException the invalid request exception
 * @throws UnavailableException the unavailable exception
 * @throws TimedOutException the timed out exception
 * @throws SchemaDisagreementException the schema disagreement exception
 * @throws TException the t exception
 * @throws UnsupportedEncodingException the unsupported encoding exception
 */
private void onCql3CreateKeyspace() throws InvalidRequestException, UnavailableException, TimedOutException, SchemaDisagreementException, TException, UnsupportedEncodingException {
  String createKeyspace=CQLTranslator.CREATE_KEYSPACE;
  String placement_strategy=csmd.getPlacement_strategy(databaseName);
  String replication_conf=CQLTranslator.SIMPLE_REPLICATION;
  createKeyspace=createKeyspace.replace(""String_Node_Str"",Constants.ESCAPE_QUOTE + databaseName + Constants.ESCAPE_QUOTE);
  Schema schema=CassandraPropertyReader.csmd.getSchema(databaseName);
  if (schema != null && schema.getName() != null && schema.getName().equalsIgnoreCase(databaseName) && schema.getSchemaProperties() != null) {
    Properties schemaProperties=schema.getSchemaProperties();
    if (placement_strategy.equalsIgnoreCase(SimpleStrategy.class.getSimpleName()) || placement_strategy.equalsIgnoreCase(SimpleStrategy.class.getName())) {
      String replicationFactor=schemaProperties.getProperty(CassandraConstants.REPLICATION_FACTOR,CassandraConstants.DEFAULT_REPLICATION_FACTOR);
      replication_conf=replication_conf.replace(""String_Node_Str"",replicationFactor);
      createKeyspace=createKeyspace.replace(""String_Node_Str"",placement_strategy);
    }
 else     if (placement_strategy.equalsIgnoreCase(NetworkTopologyStrategy.class.getSimpleName()) || placement_strategy.equalsIgnoreCase(NetworkTopologyStrategy.class.getName())) {
      if (schema.getDataCenters() != null && !schema.getDataCenters().isEmpty()) {
        StringBuilder builder=new StringBuilder();
        for (        DataCenter dc : schema.getDataCenters()) {
          builder.append(CQLTranslator.QUOTE_STR);
          builder.append(dc.getName());
          builder.append(CQLTranslator.QUOTE_STR);
          builder.append(""String_Node_Str"");
          builder.append(dc.getValue());
          builder.append(CQLTranslator.COMMA_STR);
        }
        builder.delete(builder.lastIndexOf(CQLTranslator.COMMA_STR),builder.length());
        replication_conf=builder.toString();
      }
    }
    createKeyspace=createKeyspace.replace(""String_Node_Str"",placement_strategy);
    createKeyspace=createKeyspace.replace(""String_Node_Str"",replication_conf);
    boolean isDurableWrites=Boolean.parseBoolean(schemaProperties.getProperty(CassandraConstants.DURABLE_WRITES,""String_Node_Str""));
    createKeyspace=createKeyspace.replace(""String_Node_Str"",isDurableWrites + ""String_Node_Str"");
  }
 else {
    createKeyspace=createKeyspace.replace(""String_Node_Str"",placement_strategy);
    replication_conf=replication_conf.replace(""String_Node_Str"",CassandraConstants.DEFAULT_REPLICATION_FACTOR);
    createKeyspace=createKeyspace.replace(""String_Node_Str"",replication_conf);
    createKeyspace=createKeyspace.replace(""String_Node_Str"",""String_Node_Str"");
  }
  cassandra_client.execute_cql3_query(ByteBuffer.wrap(createKeyspace.getBytes(Constants.CHARSET_UTF8)),Compression.NONE,ConsistencyLevel.ONE);
  KunderaCoreUtils.printQuery(createKeyspace,showQuery);
}","/** 
 * On cql3 create keyspace.
 * @throws InvalidRequestException the invalid request exception
 * @throws UnavailableException the unavailable exception
 * @throws TimedOutException the timed out exception
 * @throws SchemaDisagreementException the schema disagreement exception
 * @throws TException the t exception
 * @throws UnsupportedEncodingException the unsupported encoding exception
 */
private void onCql3CreateKeyspace() throws InvalidRequestException, UnavailableException, TimedOutException, SchemaDisagreementException, TException, UnsupportedEncodingException {
  String createKeyspace=CQLTranslator.CREATE_KEYSPACE;
  String placement_strategy=csmd.getPlacement_strategy(databaseName);
  String replication_conf=CQLTranslator.SIMPLE_REPLICATION;
  createKeyspace=createKeyspace.replace(""String_Node_Str"",Constants.ESCAPE_QUOTE + databaseName + Constants.ESCAPE_QUOTE);
  Schema schema=CassandraPropertyReader.csmd.getSchema(databaseName);
  if (schema != null && schema.getName() != null && schema.getName().equalsIgnoreCase(databaseName) && schema.getSchemaProperties() != null) {
    Properties schemaProperties=schema.getSchemaProperties();
    if (placement_strategy.equalsIgnoreCase(SimpleStrategy.class.getSimpleName()) || placement_strategy.equalsIgnoreCase(SimpleStrategy.class.getName())) {
      String replicationFactor=schemaProperties.getProperty(CassandraConstants.REPLICATION_FACTOR,CassandraConstants.DEFAULT_REPLICATION_FACTOR);
      replication_conf=replication_conf.replace(""String_Node_Str"",replicationFactor);
      createKeyspace=createKeyspace.replace(""String_Node_Str"",placement_strategy);
    }
 else     if (placement_strategy.equalsIgnoreCase(NetworkTopologyStrategy.class.getSimpleName()) || placement_strategy.equalsIgnoreCase(NetworkTopologyStrategy.class.getName())) {
      if (schema.getDataCenters() != null && !schema.getDataCenters().isEmpty()) {
        StringBuilder builder=new StringBuilder();
        for (        DataCenter dc : schema.getDataCenters()) {
          builder.append(CQLTranslator.QUOTE_STR);
          builder.append(dc.getName());
          builder.append(CQLTranslator.QUOTE_STR);
          builder.append(""String_Node_Str"");
          builder.append(dc.getValue());
          builder.append(CQLTranslator.COMMA_STR);
        }
        builder.delete(builder.lastIndexOf(CQLTranslator.COMMA_STR),builder.length());
        replication_conf=builder.toString();
      }
    }
    createKeyspace=createKeyspace.replace(""String_Node_Str"",placement_strategy);
    createKeyspace=createKeyspace.replace(""String_Node_Str"",replication_conf);
    boolean isDurableWrites=Boolean.parseBoolean(schemaProperties.getProperty(CassandraConstants.DURABLE_WRITES,""String_Node_Str""));
    createKeyspace=createKeyspace.replace(""String_Node_Str"",isDurableWrites + ""String_Node_Str"");
  }
 else {
    createKeyspace=createKeyspace.replace(""String_Node_Str"",placement_strategy);
    replication_conf=replication_conf.replace(""String_Node_Str"",(CharSequence)externalProperties.getOrDefault(CassandraConstants.REPLICATION_FACTOR,CassandraConstants.DEFAULT_REPLICATION_FACTOR));
    createKeyspace=createKeyspace.replace(""String_Node_Str"",replication_conf);
    createKeyspace=createKeyspace.replace(""String_Node_Str"",""String_Node_Str"");
  }
  cassandra_client.execute_cql3_query(ByteBuffer.wrap(createKeyspace.getBytes(Constants.CHARSET_UTF8)),Compression.NONE,ConsistencyLevel.ONE);
  KunderaCoreUtils.printQuery(createKeyspace,showQuery);
}",0.9877007668933584
175958,"/** 
 * Populate via thrift.
 * @param m the m
 * @param entity the entity
 * @param entityType the entity type
 * @param relationNames the relation names
 * @param relations the relations
 * @param thriftColumnName the thrift column name
 * @param thriftColumnValue the thrift column value
 * @param isCql3Enabled the is cql3 enabled
 * @return the object
 * @throws InstantiationException the instantiation exception
 * @throws IllegalAccessException the illegal access exception
 */
private Object populateViaThrift(EntityMetadata m,Object entity,EntityType entityType,List<String> relationNames,Map<String,Object> relations,String thriftColumnName,Object thriftColumnValue,boolean isCql3Enabled) throws InstantiationException, IllegalAccessException {
  if (relationNames == null || !relationNames.contains(thriftColumnName)) {
    if (thriftColumnValue != null) {
      MetamodelImpl metaModel=(MetamodelImpl)kunderaMetadata.getApplicationMetadata().getMetamodel(m.getPersistenceUnit());
      String fieldName=m.getFieldName(thriftColumnName);
      Attribute attribute=fieldName != null ? entityType.getAttribute(fieldName) : null;
      if (attribute != null) {
        entity=KunderaCoreUtils.initialize(m,entity,null);
        if (!attribute.isAssociation()) {
          String idColumnName=((AbstractAttribute)m.getIdAttribute()).getJPAColumnName();
          if (!metaModel.isEmbeddable(m.getIdAttribute().getBindableJavaType()) && thriftColumnName.equals(idColumnName)) {
            setId(m,entity,thriftColumnValue,isCql3Enabled);
            PropertyAccessorHelper.setId(entity,m,(byte[])thriftColumnValue);
          }
          if (isCql3Enabled && !m.isCounterColumnType()) {
            if (metaModel.isEmbeddable(((AbstractAttribute)attribute).getBindableJavaType())) {
              if (attribute.isCollection()) {
                entity=setElementCollection(entity,thriftColumnValue,metaModel,attribute);
              }
 else {
                entity=setUdtValue(entity,thriftColumnValue,metaModel,attribute);
              }
            }
 else {
              setFieldValueViaCQL(entity,thriftColumnValue,attribute);
            }
          }
 else {
            setFieldValue(entity,thriftColumnValue,attribute);
          }
        }
      }
 else       if (metaModel.isEmbeddable(((AbstractAttribute)m.getIdAttribute()).getBindableJavaType())) {
        entity=populateCompositeId(m,entity,thriftColumnName,thriftColumnValue,metaModel,m.getIdAttribute(),m.getEntityClazz());
      }
 else       if (clientBase.getCqlMetadata() != null) {
        if (entity == null) {
          entity=new HashMap();
        }
        if (entity instanceof HashMap) {
          composeAndAdd((HashMap)entity,clientBase.getCqlMetadata(),thriftColumnValue,thriftColumnName);
        }
      }
    }
  }
 else {
    if (relationNames != null && relationNames.contains(thriftColumnName) && thriftColumnValue != null) {
      String fieldName=m.getFieldName(thriftColumnName);
      Attribute attribute=fieldName != null ? entityType.getAttribute(fieldName) : null;
      EntityMetadata relationMetadata=KunderaMetadataManager.getEntityMetadata(kunderaMetadata,((AbstractAttribute)attribute).getBindableJavaType());
      Object value;
      if (isCql3Enabled && !m.getType().equals(Type.SUPER_COLUMN_FAMILY)) {
        value=getFieldValueViaCQL(thriftColumnValue,relationMetadata.getIdAttribute());
      }
 else {
        value=PropertyAccessorHelper.getObject(relationMetadata.getIdAttribute().getJavaType(),(byte[])thriftColumnValue);
      }
      relations.put(thriftColumnName,value);
      if (entity == null) {
        entity=KunderaCoreUtils.initialize(m,entity,null);
      }
    }
  }
  return entity;
}","/** 
 * Populate via thrift.
 * @param m the m
 * @param entity the entity
 * @param entityType the entity type
 * @param relationNames the relation names
 * @param relations the relations
 * @param thriftColumnName the thrift column name
 * @param thriftColumnValue the thrift column value
 * @param isCql3Enabled the is cql3 enabled
 * @return the object
 * @throws InstantiationException the instantiation exception
 * @throws IllegalAccessException the illegal access exception
 */
private Object populateViaThrift(EntityMetadata m,Object entity,EntityType entityType,List<String> relationNames,Map<String,Object> relations,String thriftColumnName,Object thriftColumnValue,boolean isCql3Enabled) throws InstantiationException, IllegalAccessException {
  if (relationNames == null || !relationNames.contains(thriftColumnName)) {
    if (thriftColumnValue != null) {
      MetamodelImpl metaModel=(MetamodelImpl)kunderaMetadata.getApplicationMetadata().getMetamodel(m.getPersistenceUnit());
      String fieldName=m.getFieldName(thriftColumnName);
      Attribute attribute=fieldName != null ? entityType.getAttribute(fieldName) : null;
      if (attribute != null) {
        entity=KunderaCoreUtils.initialize(m,entity,null);
        if (!attribute.isAssociation()) {
          String idColumnName=((AbstractAttribute)m.getIdAttribute()).getJPAColumnName();
          if (!metaModel.isEmbeddable(m.getIdAttribute().getBindableJavaType()) && thriftColumnName.equals(idColumnName)) {
            setId(m,entity,thriftColumnValue,isCql3Enabled);
            PropertyAccessorHelper.setId(entity,m,(byte[])thriftColumnValue);
          }
          if (isCql3Enabled && !m.isCounterColumnType()) {
            if (metaModel.isEmbeddable(((AbstractAttribute)attribute).getBindableJavaType())) {
              if (attribute.isCollection()) {
                entity=setElementCollection(entity,thriftColumnValue,metaModel,attribute);
              }
 else {
                entity=setUdtValue(entity,thriftColumnValue,metaModel,attribute);
              }
            }
 else {
              setFieldValueViaCQL(entity,thriftColumnValue,attribute);
            }
          }
 else {
            setFieldValue(entity,thriftColumnValue,attribute);
          }
        }
      }
 else       if (metaModel.isEmbeddable(((AbstractAttribute)m.getIdAttribute()).getBindableJavaType()) && !isAggregate(thriftColumnName)) {
        entity=populateCompositeId(m,entity,thriftColumnName,thriftColumnValue,metaModel,m.getIdAttribute(),m.getEntityClazz());
      }
 else       if (clientBase.getCqlMetadata() != null) {
        if (entity == null) {
          entity=new HashMap();
        }
        if (entity instanceof HashMap) {
          composeAndAdd((HashMap)entity,clientBase.getCqlMetadata(),thriftColumnValue,thriftColumnName);
        }
      }
    }
  }
 else {
    if (relationNames != null && relationNames.contains(thriftColumnName) && thriftColumnValue != null) {
      String fieldName=m.getFieldName(thriftColumnName);
      Attribute attribute=fieldName != null ? entityType.getAttribute(fieldName) : null;
      EntityMetadata relationMetadata=KunderaMetadataManager.getEntityMetadata(kunderaMetadata,((AbstractAttribute)attribute).getBindableJavaType());
      Object value;
      if (isCql3Enabled && !m.getType().equals(Type.SUPER_COLUMN_FAMILY)) {
        value=getFieldValueViaCQL(thriftColumnValue,relationMetadata.getIdAttribute());
      }
 else {
        value=PropertyAccessorHelper.getObject(relationMetadata.getIdAttribute().getJavaType(),(byte[])thriftColumnValue);
      }
      relations.put(thriftColumnName,value);
      if (entity == null) {
        entity=KunderaCoreUtils.initialize(m,entity,null);
      }
    }
  }
  return entity;
}",0.9954533297673176
175959,"/** 
 * Sets the element collection list.
 * @param listType the cql column metadata
 * @param thriftColumnValue the thrift column value
 * @param entity the entity
 * @param field the field
 * @param metaModel the meta model
 * @param embeddedObject the embedded object
 * @return the object
 */
private Object setElementCollectionList(ListType listType,ByteBuffer thriftColumnValue,Object entity,Field field,MetamodelImpl metaModel,Class embeddedClass,boolean useNativeProtocol2){
  ListSerializer listSerializer=listType.getSerializer();
  Collection outputCollection=new ArrayList();
  if (useNativeProtocol2) {
    outputCollection.addAll((Collection)listSerializer.deserializeForNativeProtocol(thriftColumnValue,2));
  }
 else {
    outputCollection.addAll((Collection)listSerializer.deserialize(thriftColumnValue));
  }
  UserType usertype=(UserType)listType.getElementsType();
  Collection result=new ArrayList();
  Iterator collectionItems=outputCollection.iterator();
  while (collectionItems.hasNext()) {
    Object embeddedObject=KunderaCoreUtils.createNewInstance(embeddedClass);
    Object value=populateEmbeddedRecursive((ByteBuffer)collectionItems.next(),usertype.allTypes(),usertype.fieldNames(),embeddedObject,metaModel);
    result.add(value);
  }
  PropertyAccessorHelper.set(entity,field,result);
  return entity;
}","/** 
 * Sets the element collection list.
 * @param listType the cql column metadata
 * @param thriftColumnValue the thrift column value
 * @param entity the entity
 * @param field the field
 * @param metaModel the meta model
 * @param embeddedClass the embedded class
 * @param useNativeProtocol2 the use native protocol2
 * @return the object
 */
private Object setElementCollectionList(ListType listType,ByteBuffer thriftColumnValue,Object entity,Field field,MetamodelImpl metaModel,Class embeddedClass,boolean useNativeProtocol2){
  ListSerializer listSerializer=listType.getSerializer();
  Collection outputCollection=new ArrayList();
  if (useNativeProtocol2) {
    outputCollection.addAll((Collection)listSerializer.deserializeForNativeProtocol(thriftColumnValue,2));
  }
 else {
    outputCollection.addAll((Collection)listSerializer.deserialize(thriftColumnValue));
  }
  UserType usertype=(UserType)listType.getElementsType();
  Collection result=new ArrayList();
  Iterator collectionItems=outputCollection.iterator();
  while (collectionItems.hasNext()) {
    Object embeddedObject=KunderaCoreUtils.createNewInstance(embeddedClass);
    Object value=populateEmbeddedRecursive((ByteBuffer)collectionItems.next(),usertype.allTypes(),usertype.fieldNames(),embeddedObject,metaModel);
    result.add(value);
  }
  PropertyAccessorHelper.set(entity,field,result);
  return entity;
}",0.9618208516886932
175960,"/** 
 * Sets the element collection set.
 * @param setType the cql column metadata
 * @param thriftColumnValue the thrift column value
 * @param entity the entity
 * @param field the field
 * @param metaModel the meta model
 * @param embeddedObject the embedded object
 * @return the object
 */
private Object setElementCollectionSet(SetType setType,ByteBuffer thriftColumnValue,Object entity,Field field,MetamodelImpl metaModel,Class embeddedClass,boolean useNativeProtocol2){
  SetSerializer setSerializer=setType.getSerializer();
  Collection outputCollection=new ArrayList();
  if (useNativeProtocol2) {
    outputCollection.addAll((Collection)setSerializer.deserializeForNativeProtocol(thriftColumnValue,2));
  }
 else {
    outputCollection.addAll((Collection)setSerializer.deserialize(thriftColumnValue));
  }
  UserType usertype=(UserType)setType.getElementsType();
  Collection result=new HashSet();
  Iterator collectionItems=outputCollection.iterator();
  while (collectionItems.hasNext()) {
    Object embeddedObject=KunderaCoreUtils.createNewInstance(embeddedClass);
    Object value=populateEmbeddedRecursive((ByteBuffer)collectionItems.next(),usertype.allTypes(),usertype.fieldNames(),embeddedObject,metaModel);
    result.add(value);
  }
  PropertyAccessorHelper.set(entity,field,result);
  return entity;
}","/** 
 * Sets the element collection set.
 * @param setType the cql column metadata
 * @param thriftColumnValue the thrift column value
 * @param entity the entity
 * @param field the field
 * @param metaModel the meta model
 * @param embeddedClass the embedded class
 * @param useNativeProtocol2 the use native protocol2
 * @return the object
 */
private Object setElementCollectionSet(SetType setType,ByteBuffer thriftColumnValue,Object entity,Field field,MetamodelImpl metaModel,Class embeddedClass,boolean useNativeProtocol2){
  SetSerializer setSerializer=setType.getSerializer();
  Collection outputCollection=new ArrayList();
  if (useNativeProtocol2) {
    outputCollection.addAll((Collection)setSerializer.deserializeForNativeProtocol(thriftColumnValue,2));
  }
 else {
    outputCollection.addAll((Collection)setSerializer.deserialize(thriftColumnValue));
  }
  UserType usertype=(UserType)setType.getElementsType();
  Collection result=new HashSet();
  Iterator collectionItems=outputCollection.iterator();
  while (collectionItems.hasNext()) {
    Object embeddedObject=KunderaCoreUtils.createNewInstance(embeddedClass);
    Object value=populateEmbeddedRecursive((ByteBuffer)collectionItems.next(),usertype.allTypes(),usertype.fieldNames(),embeddedObject,metaModel);
    result.add(value);
  }
  PropertyAccessorHelper.set(entity,field,result);
  return entity;
}",0.9614529280948853
175961,"/** 
 * Sets the element collection map.
 * @param mapType the cql column metadata
 * @param thriftColumnValue the thrift column value
 * @param entity the entity
 * @param field the field
 * @param metaModel the meta model
 * @param embeddedObject the embedded object
 * @return the object
 */
private Object setElementCollectionMap(MapType mapType,ByteBuffer thriftColumnValue,Object entity,Field field,MetamodelImpl metaModel,Class embeddedClass,boolean useNativeProtocol2){
  Map result=new HashMap();
  MapSerializer mapSerializer=mapType.getSerializer();
  Map outputCollection=new HashMap();
  if (useNativeProtocol2) {
    outputCollection.putAll(mapSerializer.deserializeForNativeProtocol(thriftColumnValue,2));
  }
 else {
    outputCollection.putAll((Map)mapSerializer.deserialize(thriftColumnValue));
  }
  UserType usertype=(UserType)mapType.getValuesType();
  for (  Object key : outputCollection.keySet()) {
    Object embeddedObject=KunderaCoreUtils.createNewInstance(embeddedClass);
    Object value=populateEmbeddedRecursive((ByteBuffer)outputCollection.get(key),usertype.allTypes(),usertype.fieldNames(),embeddedObject,metaModel);
    result.put(key,value);
  }
  PropertyAccessorHelper.set(entity,field,result);
  return entity;
}","/** 
 * Sets the element collection map.
 * @param mapType the cql column metadata
 * @param thriftColumnValue the thrift column value
 * @param entity the entity
 * @param field the field
 * @param metaModel the meta model
 * @param embeddedClass the embedded class
 * @param useNativeProtocol2 the use native protocol2
 * @return the object
 */
private Object setElementCollectionMap(MapType mapType,ByteBuffer thriftColumnValue,Object entity,Field field,MetamodelImpl metaModel,Class embeddedClass,boolean useNativeProtocol2){
  Map result=new HashMap();
  MapSerializer mapSerializer=mapType.getSerializer();
  Map outputCollection=new HashMap();
  if (useNativeProtocol2) {
    outputCollection.putAll(mapSerializer.deserializeForNativeProtocol(thriftColumnValue,2));
  }
 else {
    outputCollection.putAll((Map)mapSerializer.deserialize(thriftColumnValue));
  }
  UserType usertype=(UserType)mapType.getValuesType();
  for (  Object key : outputCollection.keySet()) {
    Object embeddedObject=KunderaCoreUtils.createNewInstance(embeddedClass);
    Object value=populateEmbeddedRecursive((ByteBuffer)outputCollection.get(key),usertype.allTypes(),usertype.fieldNames(),embeddedObject,metaModel);
    result.put(key,value);
  }
  PropertyAccessorHelper.set(entity,field,result);
  return entity;
}",0.9592476489028212
175962,"/** 
 * Gets the column list.
 * @param m the m
 * @param metamodel the metamodel
 * @param results the results
 * @param compoundKey the compound key
 * @return the column list
 */
List<String> getColumnList(EntityMetadata m,MetamodelImpl metamodel,String[] results,EmbeddableType compoundKey){
  List<String> columns=new ArrayList<String>();
  if (results != null && results.length > 0) {
    MetamodelImpl metaModel=(MetamodelImpl)kunderaMetadata.getApplicationMetadata().getMetamodel(m.getPersistenceUnit());
    EntityType entity=metaModel.entity(m.getEntityClazz());
    String keyFieldName=CassandraUtilities.getIdColumnName(kunderaMetadata,m,externalProperties,((CassandraClientBase)persistenceDelegeator.getClient(m)).isCql3Enabled(m));
    for (int i=1; i < results.length; i++) {
      if (results[i] != null) {
        if (results[i].indexOf(""String_Node_Str"") > 0) {
          String fieldName=results[i].substring(0,results[i].indexOf(""String_Node_Str""));
          String embeddedFieldName=results[i].substring(results[i].indexOf(""String_Node_Str"") + 1,results[i].length());
          AbstractAttribute attribute=(AbstractAttribute)entity.getAttribute(fieldName);
          EmbeddableType embeddable=metamodel.embeddable(attribute.getBindableJavaType());
          Attribute embeddableAttribute=embeddable.getAttribute(embeddedFieldName);
          columns.add(((AbstractAttribute)embeddableAttribute).getJPAColumnName());
        }
 else {
          Attribute attribute=entity.getAttribute(results[i]);
          if (attribute == null) {
            throw new QueryHandlerException(""String_Node_Str"" + results);
          }
 else           if (m.getIdAttribute().equals(attribute) && compoundKey != null) {
            Field[] fields=m.getIdAttribute().getBindableJavaType().getDeclaredFields();
            for (            Field field : fields) {
              if (!ReflectUtils.isTransientOrStatic(field)) {
                Attribute compositeColumn=compoundKey.getAttribute(field.getName());
                columns.add(((AbstractAttribute)compositeColumn).getJPAColumnName());
              }
            }
          }
 else           if (m.getIdAttribute().equals(attribute) && compoundKey == null) {
            columns.add(keyFieldName);
          }
 else {
            columns.add(((AbstractAttribute)attribute).getJPAColumnName());
          }
        }
      }
    }
    return columns;
  }
  if (log.isInfoEnabled()) {
    log.info(""String_Node_Str"");
  }
  return null;
}","/** 
 * Gets the column list.
 * @param m the m
 * @param metamodel the metamodel
 * @param results the results
 * @param compoundKey the compound key
 * @return the column list
 */
List<String> getColumnList(EntityMetadata m,MetamodelImpl metamodel,String[] results,EmbeddableType compoundKey){
  List<String> columns=new ArrayList<String>();
  if (results != null && results.length > 0) {
    MetamodelImpl metaModel=(MetamodelImpl)kunderaMetadata.getApplicationMetadata().getMetamodel(m.getPersistenceUnit());
    EntityType entity=metaModel.entity(m.getEntityClazz());
    String keyFieldName=CassandraUtilities.getIdColumnName(kunderaMetadata,m,externalProperties,((CassandraClientBase)persistenceDelegeator.getClient(m)).isCql3Enabled(m));
    for (int i=1; i < results.length; i++) {
      if (results[i] != null) {
        if (results[i].indexOf(""String_Node_Str"") > 0) {
          String fieldName=results[i].substring(0,results[i].indexOf(""String_Node_Str""));
          String embeddedFieldName=results[i].substring(results[i].indexOf(""String_Node_Str"") + 1,results[i].length());
          AbstractAttribute attribute=(AbstractAttribute)entity.getAttribute(fieldName);
          EmbeddableType embeddable=metamodel.embeddable(attribute.getBindableJavaType());
          Attribute embeddableAttribute=embeddable.getAttribute(embeddedFieldName);
          columns.add(((AbstractAttribute)embeddableAttribute).getJPAColumnName());
        }
 else {
          Attribute attribute=entity.getAttribute(results[i]);
          if (attribute == null) {
            throw new QueryHandlerException(""String_Node_Str"" + results);
          }
 else           if (m.getIdAttribute().equals(attribute) && compoundKey != null) {
            Field[] fields=m.getIdAttribute().getBindableJavaType().getDeclaredFields();
            for (            Field field : fields) {
              addCompositeIdToColumns(metamodel,compoundKey,columns,field);
            }
          }
 else           if (m.getIdAttribute().equals(attribute) && compoundKey == null) {
            columns.add(keyFieldName);
          }
 else {
            columns.add(((AbstractAttribute)attribute).getJPAColumnName());
          }
        }
      }
    }
    return columns;
  }
  if (log.isInfoEnabled()) {
    log.info(""String_Node_Str"");
  }
  return null;
}",0.8597472550238243
175963,"/** 
 * Build the aggregation parameters.
 * @param group
 * @param expression
 * @param metadata
 * @param entityType
 */
private void buildAggregation(DBObject group,Expression expression,EntityMetadata metadata,EntityType entityType,boolean hasLob){
  if (expression instanceof AggregateFunction) {
    AggregateFunction aggregateFunction=(AggregateFunction)expression;
    String identifier=aggregateFunction.getIdentifier().toLowerCase();
    Expression child=aggregateFunction.getExpression();
    if (child instanceof StateFieldPathExpression) {
      StateFieldPathExpression sfpExp=(StateFieldPathExpression)child;
      String columnName=getColumnName(metadata,entityType,sfpExp.toActualText());
      String actualColumnName=columnName;
      if (hasLob) {
        actualColumnName=""String_Node_Str"" + columnName;
      }
 else       if (metadata.getIdAttribute().equals(entityType.getAttribute(columnName))) {
        actualColumnName=""String_Node_Str"";
      }
      BasicDBObject item=new BasicDBObject(""String_Node_Str"" + identifier,""String_Node_Str"" + actualColumnName);
      group.put(identifier + ""String_Node_Str"" + columnName,item);
    }
 else     if (expression instanceof CountFunction) {
      group.put(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",1));
    }
  }
 else   if (expression instanceof CollectionExpression) {
    for (    Expression child : expression.children()) {
      buildAggregation(group,child,metadata,entityType,hasLob);
    }
  }
 else   if (expression instanceof StateFieldPathExpression) {
    StateFieldPathExpression sfpExp=(StateFieldPathExpression)expression;
    BasicDBObject idObject;
    Object existing=group.get(""String_Node_Str"");
    if (existing != null) {
      idObject=(BasicDBObject)existing;
    }
 else {
      idObject=new BasicDBObject();
      group.put(""String_Node_Str"",idObject);
    }
    String columnName=getColumnName(metadata,entityType,sfpExp.toActualText());
    String actualColumnName=columnName;
    if (hasLob) {
      actualColumnName=""String_Node_Str"" + columnName;
    }
    idObject.put(columnName,""String_Node_Str"" + actualColumnName);
  }
}","/** 
 * Build the aggregation parameters.
 * @param group
 * @param expression
 * @param metadata
 * @param entityType
 */
private void buildAggregation(DBObject group,Expression expression,EntityMetadata metadata,EntityType entityType,boolean hasLob){
  if (expression instanceof AggregateFunction) {
    AggregateFunction aggregateFunction=(AggregateFunction)expression;
    String identifier=aggregateFunction.getIdentifier().toLowerCase();
    Expression child=aggregateFunction.getExpression();
    if (child instanceof StateFieldPathExpression) {
      StateFieldPathExpression sfpExp=(StateFieldPathExpression)child;
      String columnName=getColumnName(metadata,entityType,sfpExp.toActualText());
      String actualColumnName=columnName;
      if (hasLob) {
        actualColumnName=""String_Node_Str"" + columnName;
      }
 else       if (metadata.getIdAttribute().equals(entityType.getAttribute(metadata.getFieldName(columnName)))) {
        actualColumnName=""String_Node_Str"";
      }
      BasicDBObject item=new BasicDBObject(""String_Node_Str"" + identifier,""String_Node_Str"" + actualColumnName);
      group.put(identifier + ""String_Node_Str"" + columnName,item);
    }
 else     if (expression instanceof CountFunction) {
      group.put(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",1));
    }
  }
 else   if (expression instanceof CollectionExpression) {
    for (    Expression child : expression.children()) {
      buildAggregation(group,child,metadata,entityType,hasLob);
    }
  }
 else   if (expression instanceof StateFieldPathExpression) {
    StateFieldPathExpression sfpExp=(StateFieldPathExpression)expression;
    BasicDBObject idObject;
    Object existing=group.get(""String_Node_Str"");
    if (existing != null) {
      idObject=(BasicDBObject)existing;
    }
 else {
      idObject=new BasicDBObject();
      group.put(""String_Node_Str"",idObject);
    }
    String columnName=getColumnName(metadata,entityType,sfpExp.toActualText());
    String actualColumnName=columnName;
    if (hasLob) {
      actualColumnName=""String_Node_Str"" + columnName;
    }
    idObject.put(columnName,""String_Node_Str"" + actualColumnName);
  }
}",0.9900116144018584
175964,"/** 
 * Compile group.
 */
private void compileGroup(){
  GroupByClause groupByClause=null;
  if (query.isSelectStatement()) {
    groupByClause=(GroupByClause)query.getSelectStatement().getGroupByClause();
  }
  if (groupByClause == null && groupByClause.toActualText().length() == 0) {
    throw new JPQLParseException(""String_Node_Str"");
  }
  groupingClause=groupByClause.toActualText();
}","/** 
 * Compile group.
 */
private void compileGroup(){
  GroupByClause groupByClause=null;
  if (query.isSelectStatement()) {
    groupByClause=(GroupByClause)query.getSelectStatement().getGroupByClause();
  }
  if (groupByClause == null || groupByClause.toActualText().length() == 0) {
    throw new JPQLParseException(""String_Node_Str"");
  }
  groupingClause=groupByClause.toActualText();
}",0.9949109414758268
175965,"/** 
 * Compile having.
 */
private void compileHaving(){
  HavingClause havingClause=null;
  if (query.isSelectStatement()) {
    havingClause=(HavingClause)query.getSelectStatement().getHavingClause();
  }
  if (havingClause == null && havingClause.toActualText().length() == 0) {
    throw new JPQLParseException(""String_Node_Str"");
  }
  if (groupingClause != null) {
    groupingClause=groupingClause.trim() + havingClause.toActualText();
  }
 else {
    groupingClause=havingClause.toActualText();
  }
}","/** 
 * Compile having.
 */
private void compileHaving(){
  HavingClause havingClause=null;
  if (query.isSelectStatement()) {
    havingClause=(HavingClause)query.getSelectStatement().getHavingClause();
  }
  if (havingClause == null || havingClause.toActualText().length() == 0) {
    throw new JPQLParseException(""String_Node_Str"");
  }
  if (groupingClause != null) {
    groupingClause=groupingClause.trim() + havingClause.toActualText();
  }
 else {
    groupingClause=havingClause.toActualText();
  }
}",0.9960707269155208
175966,"/** 
 * Creates MongoDB Query object from filterClauseQueue.
 * @param m the m
 * @param filterClauseQueue the filter clause queue
 * @param columns
 * @return the basic db object
 */
public BasicDBObject createSubMongoQuery(EntityMetadata m,Queue filterClauseQueue){
  BasicDBObject query=new BasicDBObject();
  BasicDBObject compositeColumns=new BasicDBObject();
  MetamodelImpl metaModel=(MetamodelImpl)kunderaMetadata.getApplicationMetadata().getMetamodel(m.getPersistenceUnit());
  AbstractManagedType managedType=(AbstractManagedType)metaModel.entity(m.getEntityClazz());
  for (  Object object : filterClauseQueue) {
    boolean isCompositeColumn=false;
    boolean isSubCondition=false;
    if (object instanceof FilterClause) {
      FilterClause filter=(FilterClause)object;
      String property=filter.getProperty();
      String condition=filter.getCondition();
      Object value=filter.getValue().get(0);
      Field f=null;
      if (managedType.hasLobAttribute()) {
        EntityType entity=metaModel.entity(m.getEntityClazz());
        String fieldName=m.getFieldName(property);
        f=(Field)entity.getAttribute(fieldName).getJavaMember();
        if (value.getClass().isAssignableFrom(String.class) && f != null && !f.getType().equals(value.getClass())) {
          value=PropertyAccessorFactory.getPropertyAccessor(f).fromString(f.getType().getClass(),value.toString());
        }
        value=MongoDBUtils.populateValue(value,value.getClass());
        property=""String_Node_Str"" + property;
      }
 else {
        if (((AbstractAttribute)m.getIdAttribute()).getJPAColumnName().equalsIgnoreCase(property)) {
          property=""String_Node_Str"";
          f=(Field)m.getIdAttribute().getJavaMember();
          if (metaModel.isEmbeddable(m.getIdAttribute().getBindableJavaType()) && value.getClass().isAssignableFrom(f.getType())) {
            EmbeddableType compoundKey=metaModel.embeddable(m.getIdAttribute().getBindableJavaType());
            compositeColumns=MongoDBUtils.getCompoundKeyColumns(m,value,compoundKey);
            isCompositeColumn=true;
            continue;
          }
        }
 else         if (metaModel.isEmbeddable(m.getIdAttribute().getBindableJavaType()) && StringUtils.contains(property,'.')) {
          property=property.substring(property.indexOf(""String_Node_Str"") + 1);
          isCompositeColumn=true;
        }
 else         if (StringUtils.contains(property,'.')) {
          EntityType entity=metaModel.entity(m.getEntityClazz());
          StringTokenizer tokenizer=new StringTokenizer(property,""String_Node_Str"");
          String embeddedAttributeAsStr=tokenizer.nextToken();
          String embeddableAttributeAsStr=tokenizer.nextToken();
          Attribute embeddedAttribute=entity.getAttribute(embeddedAttributeAsStr);
          EmbeddableType embeddableEntity=metaModel.embeddable(((AbstractAttribute)embeddedAttribute).getBindableJavaType());
          f=(Field)embeddableEntity.getAttribute(embeddableAttributeAsStr).getJavaMember();
          property=((AbstractAttribute)embeddedAttribute).getJPAColumnName() + ""String_Node_Str"" + ((AbstractAttribute)embeddableEntity.getAttribute(embeddableAttributeAsStr)).getJPAColumnName();
        }
 else {
          EntityType entity=metaModel.entity(m.getEntityClazz());
          String discriminatorColumn=((AbstractManagedType)entity).getDiscriminatorColumn();
          if (!property.equals(discriminatorColumn)) {
            String fieldName=m.getFieldName(property);
            f=(Field)entity.getAttribute(fieldName).getJavaMember();
          }
        }
        if (value.getClass().isAssignableFrom(String.class) && f != null && !f.getType().equals(value.getClass())) {
          value=PropertyAccessorFactory.getPropertyAccessor(f).fromString(f.getType().getClass(),value.toString());
        }
        value=MongoDBUtils.populateValue(value,value.getClass());
      }
      if (f != null && f.getType().equals(Point.class)) {
        GeospatialQuery geospatialQueryimpl=GeospatialQueryFactory.getGeospatialQueryImplementor(condition,value);
        query=(BasicDBObject)geospatialQueryimpl.createGeospatialQuery(property,value,query);
      }
 else {
        if (isCompositeColumn) {
          property=new StringBuffer(""String_Node_Str"").append(property).toString();
        }
        if (condition.equals(""String_Node_Str"")) {
          query.append(property,value);
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",createLikeRegex((String)value)));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",createLikeRegex((String)value)));
          }
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",value));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",value));
          }
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",value));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",value));
          }
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",value));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",value));
          }
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",value));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",value));
          }
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",filter.getValue()));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",filter.getValue()));
          }
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",filter.getValue()));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",filter.getValue()));
          }
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",value));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",value));
          }
        }
      }
    }
  }
  if (!compositeColumns.isEmpty()) {
    query.append(""String_Node_Str"",compositeColumns);
  }
  return query;
}","/** 
 * Creates MongoDB Query object from filterClauseQueue.
 * @param m the m
 * @param filterClauseQueue the filter clause queue
 * @param columns
 * @return the basic db object
 */
public BasicDBObject createSubMongoQuery(EntityMetadata m,Queue filterClauseQueue){
  BasicDBObject query=new BasicDBObject();
  BasicDBObject compositeColumns=new BasicDBObject();
  MetamodelImpl metaModel=(MetamodelImpl)kunderaMetadata.getApplicationMetadata().getMetamodel(m.getPersistenceUnit());
  AbstractManagedType managedType=(AbstractManagedType)metaModel.entity(m.getEntityClazz());
  for (  Object object : filterClauseQueue) {
    boolean isCompositeColumn=false;
    boolean isSubCondition=false;
    if (object instanceof FilterClause) {
      FilterClause filter=(FilterClause)object;
      String property=filter.getProperty();
      String condition=filter.getCondition();
      Object value=filter.getValue().get(0);
      Field f=null;
      if (managedType.hasLobAttribute()) {
        EntityType entity=metaModel.entity(m.getEntityClazz());
        String fieldName=m.getFieldName(property);
        f=(Field)entity.getAttribute(fieldName).getJavaMember();
        if (value.getClass().isAssignableFrom(String.class) && f != null && !f.getType().equals(value.getClass())) {
          value=PropertyAccessorFactory.getPropertyAccessor(f).fromString(f.getType().getClass(),value.toString());
        }
        value=MongoDBUtils.populateValue(value,value.getClass());
        property=""String_Node_Str"" + property;
      }
 else {
        if (((AbstractAttribute)m.getIdAttribute()).getJPAColumnName().equalsIgnoreCase(property)) {
          property=""String_Node_Str"";
          f=(Field)m.getIdAttribute().getJavaMember();
          if (metaModel.isEmbeddable(m.getIdAttribute().getBindableJavaType()) && value.getClass().isAssignableFrom(f.getType())) {
            EmbeddableType compoundKey=metaModel.embeddable(m.getIdAttribute().getBindableJavaType());
            compositeColumns=MongoDBUtils.getCompoundKeyColumns(m,value,compoundKey);
            isCompositeColumn=true;
            continue;
          }
        }
 else         if (metaModel.isEmbeddable(m.getIdAttribute().getBindableJavaType()) && StringUtils.contains(property,'.')) {
          property=property.substring(property.indexOf(""String_Node_Str"") + 1);
          isCompositeColumn=true;
        }
 else         if (StringUtils.contains(property,'.')) {
          EntityType entity=metaModel.entity(m.getEntityClazz());
          StringTokenizer tokenizer=new StringTokenizer(property,""String_Node_Str"");
          String embeddedAttributeAsStr=tokenizer.nextToken();
          String embeddableAttributeAsStr=tokenizer.nextToken();
          Attribute embeddedAttribute=entity.getAttribute(embeddedAttributeAsStr);
          EmbeddableType embeddableEntity=metaModel.embeddable(((AbstractAttribute)embeddedAttribute).getBindableJavaType());
          f=(Field)embeddableEntity.getAttribute(embeddableAttributeAsStr).getJavaMember();
          property=((AbstractAttribute)embeddedAttribute).getJPAColumnName() + ""String_Node_Str"" + ((AbstractAttribute)embeddableEntity.getAttribute(embeddableAttributeAsStr)).getJPAColumnName();
        }
 else {
          EntityType entity=metaModel.entity(m.getEntityClazz());
          String discriminatorColumn=((AbstractManagedType)entity).getDiscriminatorColumn();
          if (!property.equals(discriminatorColumn)) {
            String fieldName=m.getFieldName(property);
            f=(Field)entity.getAttribute(fieldName).getJavaMember();
          }
        }
        if (value.getClass().isAssignableFrom(String.class) && f != null && !f.getType().equals(value.getClass())) {
          value=PropertyAccessorFactory.getPropertyAccessor(f).fromString(f.getType().getClass(),value.toString());
        }
        value=MongoDBUtils.populateValue(value,value.getClass());
      }
      if (f != null && f.getType().equals(Point.class)) {
        GeospatialQuery geospatialQueryimpl=GeospatialQueryFactory.getGeospatialQueryImplementor(condition,value);
        query=(BasicDBObject)geospatialQueryimpl.createGeospatialQuery(property,value,query);
      }
 else {
        if (isCompositeColumn) {
          EmbeddableType embeddableType=metaModel.embeddable(m.getIdAttribute().getBindableJavaType());
          AbstractAttribute attribute=(AbstractAttribute)embeddableType.getAttribute(property);
          property=new StringBuffer(""String_Node_Str"").append(attribute.getJPAColumnName()).toString();
        }
        if (condition.equals(""String_Node_Str"")) {
          query.append(property,value);
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",createLikeRegex((String)value)));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",createLikeRegex((String)value)));
          }
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",value));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",value));
          }
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",value));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",value));
          }
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",value));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",value));
          }
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",value));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",value));
          }
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",filter.getValue()));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",filter.getValue()));
          }
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",filter.getValue()));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",filter.getValue()));
          }
        }
 else         if (condition.equalsIgnoreCase(""String_Node_Str"")) {
          if (query.containsField(property)) {
            query.get(property);
            query.put(property,((BasicDBObject)query.get(property)).append(""String_Node_Str"",value));
          }
 else {
            query.append(property,new BasicDBObject(""String_Node_Str"",value));
          }
        }
      }
    }
  }
  if (!compositeColumns.isEmpty()) {
    query.append(""String_Node_Str"",compositeColumns);
  }
  return query;
}",0.984703137153228
175967,"@Override public final void process(final Class<?> entityClass,EntityMetadata metadata){
  EntityListeners entityListeners=(EntityListeners)entityClass.getAnnotation(EntityListeners.class);
  if (entityListeners != null) {
    Class<?>[] entityListenerClasses=entityListeners.value();
    if (entityListenerClasses != null) {
      for (      Class<?> entityListener : entityListenerClasses) {
        try {
          entityListener.getConstructor();
        }
 catch (        NoSuchMethodException nsme) {
          throw new MetamodelLoaderException(""String_Node_Str"" + entityListener.getName() + ""String_Node_Str"");
        }
        for (        Method method : entityListener.getDeclaredMethods()) {
          List<Class<?>> jpaAnnotations=getValidJPAAnnotationsFromMethod(entityListener,method,1,entityClass);
          for (          Class<?> jpaAnnotation : jpaAnnotations) {
            CallbackMethod callBackMethod=new ExternalCallbackMethod(entityListener,method);
            addCallBackMethod(metadata,jpaAnnotation,callBackMethod);
          }
        }
      }
    }
  }
  for (  Method method : entityClass.getMethods()) {
    List<Class<?>> jpaAnnotations=getValidJPAAnnotationsFromMethod(entityClass,method,0,entityClass);
    for (    Class<?> jpaAnnotation : jpaAnnotations) {
      CallbackMethod callbackMethod=new InternalCallbackMethod(metadata,method);
      addCallBackMethod(metadata,jpaAnnotation,callbackMethod);
    }
  }
}","@Override public final void process(final Class<?> entityClass,EntityMetadata metadata){
  EntityListeners entityListeners=(EntityListeners)entityClass.getAnnotation(EntityListeners.class);
  if (entityListeners == null && entityClass.getSuperclass() != null) {
    entityListeners=entityClass.getSuperclass().getAnnotation(EntityListeners.class);
  }
  if (entityListeners != null) {
    Class<?>[] entityListenerClasses=entityListeners.value();
    if (entityListenerClasses != null) {
      for (      Class<?> entityListener : entityListenerClasses) {
        try {
          entityListener.getConstructor();
        }
 catch (        NoSuchMethodException nsme) {
          throw new MetamodelLoaderException(""String_Node_Str"" + entityListener.getName() + ""String_Node_Str"");
        }
        for (        Method method : entityListener.getDeclaredMethods()) {
          List<Class<?>> jpaAnnotations=getValidJPAAnnotationsFromMethod(entityListener,method,1,entityClass);
          for (          Class<?> jpaAnnotation : jpaAnnotations) {
            CallbackMethod callBackMethod=new ExternalCallbackMethod(entityListener,method);
            addCallBackMethod(metadata,jpaAnnotation,callBackMethod);
          }
        }
      }
    }
  }
  for (  Method method : entityClass.getMethods()) {
    List<Class<?>> jpaAnnotations=getValidJPAAnnotationsFromMethod(entityClass,method,0,entityClass);
    for (    Class<?> jpaAnnotation : jpaAnnotations) {
      CallbackMethod callbackMethod=new InternalCallbackMethod(metadata,method);
      addCallBackMethod(metadata,jpaAnnotation,callbackMethod);
    }
  }
}",0.9472312703583062
175968,"/** 
 * On query over composite columns.
 * @param m the m
 * @param client the client
 * @param metaModel the meta model
 * @param relations the relations
 * @return the list
 */
String onQueryOverCQL3(EntityMetadata m,Client client,MetamodelImpl metaModel,List<String> relations){
  Class compoundKeyClass=m.getIdAttribute().getBindableJavaType();
  EmbeddableType compoundKey=null;
  String idColumn;
  if (metaModel.isEmbeddable(compoundKeyClass)) {
    compoundKey=metaModel.embeddable(compoundKeyClass);
    idColumn=((AbstractAttribute)m.getIdAttribute()).getJPAColumnName();
  }
 else {
    idColumn=((AbstractAttribute)m.getIdAttribute()).getJPAColumnName();
  }
  StringBuilder builder=new StringBuilder();
  boolean isPresent=false;
  List<String> columns=getColumnList(m,metaModel,getKunderaQuery().getResult(),compoundKey);
  String selectQuery=setSelectQuery(columns);
  CQLTranslator translator=new CQLTranslator();
  selectQuery=StringUtils.replace(selectQuery,CQLTranslator.COLUMN_FAMILY,translator.ensureCase(new StringBuilder(),m.getTableName(),false).toString());
  builder=CassandraUtilities.appendColumns(builder,columns,selectQuery,translator);
  addWhereClause(builder);
  onCondition(m,metaModel,compoundKey,idColumn,builder,isPresent,translator,true);
  return builder.toString();
}","/** 
 * On query over composite columns.
 * @param m the m
 * @param client the client
 * @param metaModel the meta model
 * @param relations the relations
 * @return the list
 */
public String onQueryOverCQL3(EntityMetadata m,Client client,MetamodelImpl metaModel,List<String> relations){
  Class compoundKeyClass=m.getIdAttribute().getBindableJavaType();
  EmbeddableType compoundKey=null;
  String idColumn;
  if (metaModel.isEmbeddable(compoundKeyClass)) {
    compoundKey=metaModel.embeddable(compoundKeyClass);
    idColumn=((AbstractAttribute)m.getIdAttribute()).getJPAColumnName();
  }
 else {
    idColumn=((AbstractAttribute)m.getIdAttribute()).getJPAColumnName();
  }
  StringBuilder builder=new StringBuilder();
  boolean isPresent=false;
  List<String> columns=getColumnList(m,metaModel,getKunderaQuery().getResult(),compoundKey);
  String selectQuery=setSelectQuery(columns);
  CQLTranslator translator=new CQLTranslator();
  selectQuery=StringUtils.replace(selectQuery,CQLTranslator.COLUMN_FAMILY,translator.ensureCase(new StringBuilder(),m.getTableName(),false).toString());
  builder=CassandraUtilities.appendColumns(builder,columns,selectQuery,translator);
  addWhereClause(builder);
  onCondition(m,metaModel,compoundKey,idColumn,builder,isPresent,translator,true);
  return builder.toString();
}",0.9973313000381244
175969,"/** 
 * Sets the relational entities.
 * @param enhanceEntities the enhance entities
 * @param client the client
 * @param m the m
 */
void setRelationalEntities(List enhanceEntities,Client client,EntityMetadata m){
  super.setRelationEntities(enhanceEntities,client,m);
}","/** 
 * Sets the relational entities.
 * @param enhanceEntities the enhance entities
 * @param client the client
 * @param m the m
 */
public void setRelationalEntities(List enhanceEntities,Client client,EntityMetadata m){
  super.setRelationEntities(enhanceEntities,client,m);
}",0.9872958257713248
175970,"/** 
 * Parse and append cql3 token function for iter.next() call.
 * @param translator            cql translator.
 * @param query the query
 * @return parsed/append cql3 query.
 */
private String prepareNext(CQLTranslator translator,String query){
  if (checkOnEmptyResult()) {
    String idName=((AbstractAttribute)entityMetadata.getIdAttribute()).getJPAColumnName();
    Map<Boolean,String> filterOnId=getConditionOnIdColumn(idName);
    if (filterOnId.get(true) != null) {
      String condition=filterOnId.get(true);
      if (condition.equals(""String_Node_Str"")) {
        return null;
      }
 else       if (condition.endsWith(""String_Node_Str"") || condition.equals(""String_Node_Str"")) {
        query=replaceAppliedToken(query);
        return query;
      }
    }
    Object entity=results.get(results.size() - 1);
    Class idClazz=((AbstractAttribute)entityMetadata.getIdAttribute()).getBindableJavaType();
    Object id=PropertyAccessorHelper.getId(entity,entityMetadata);
    StringBuilder builder=new StringBuilder(CQLTranslator.TOKEN);
    MetamodelImpl metaModel=(MetamodelImpl)kunderaMetadata.getApplicationMetadata().getMetamodel(entityMetadata.getPersistenceUnit());
    EmbeddableType keyObj=null;
    String columnName;
    if (metaModel.isEmbeddable(entityMetadata.getIdAttribute().getBindableJavaType())) {
      keyObj=metaModel.embeddable(entityMetadata.getIdAttribute().getBindableJavaType());
      Field embeddedField=getPartitionKeyField();
      Attribute partitionKey=keyObj.getAttribute(embeddedField.getName());
      Object partitionKeyValue=PropertyAccessorHelper.getObject(id,(Field)partitionKey.getJavaMember());
      columnName=((AbstractAttribute)partitionKey).getJPAColumnName();
      id=partitionKeyValue;
      idClazz=((AbstractAttribute)partitionKey).getBindableJavaType();
    }
 else {
      columnName=CassandraUtilities.getIdColumnName(kunderaMetadata,entityMetadata,externalProperties,((CassandraClientBase)client).isCql3Enabled(entityMetadata));
    }
    translator.appendColumnName(builder,columnName);
    builder.append(CQLTranslator.CLOSE_BRACKET);
    builder.append(""String_Node_Str"");
    builder.append(CQLTranslator.TOKEN);
    translator.appendValue(builder,idClazz,id,false,false);
    builder.append(CQLTranslator.CLOSE_BRACKET);
    return builder.toString();
  }
  return null;
}","/** 
 * Parse and append cql3 token function for iter.next() call.
 * @param translator cql translator.
 * @param query the query
 * @return parsed/append cql3 query.
 */
private String prepareNext(CQLTranslator translator,String query){
  if (checkOnEmptyResult()) {
    String idName=((AbstractAttribute)entityMetadata.getIdAttribute()).getJPAColumnName();
    Map<Boolean,String> filterOnId=getConditionOnIdColumn(idName);
    if (filterOnId.get(true) != null) {
      String condition=filterOnId.get(true);
      if (condition.equals(""String_Node_Str"")) {
        return null;
      }
 else       if (condition.endsWith(""String_Node_Str"") || condition.equals(""String_Node_Str"")) {
        query=replaceAppliedToken(query);
        return query;
      }
    }
    Object entity=results.get(results.size() - 1);
    Class idClazz=((AbstractAttribute)entityMetadata.getIdAttribute()).getBindableJavaType();
    Object id=PropertyAccessorHelper.getId(entity,entityMetadata);
    StringBuilder builder=new StringBuilder(CQLTranslator.TOKEN);
    MetamodelImpl metaModel=(MetamodelImpl)kunderaMetadata.getApplicationMetadata().getMetamodel(entityMetadata.getPersistenceUnit());
    EmbeddableType keyObj=null;
    String columnName=null;
    if (metaModel.isEmbeddable(entityMetadata.getIdAttribute().getBindableJavaType())) {
      keyObj=metaModel.embeddable(entityMetadata.getIdAttribute().getBindableJavaType());
      Field embeddedField=getPartitionKeyField();
      Attribute partitionKey=keyObj.getAttribute(embeddedField.getName());
      Object partitionKeyValue=PropertyAccessorHelper.getObject(id,(Field)partitionKey.getJavaMember());
      columnName=((AbstractAttribute)partitionKey).getJPAColumnName();
      id=partitionKeyValue;
      idClazz=((AbstractAttribute)partitionKey).getBindableJavaType();
    }
 else {
      columnName=CassandraUtilities.getIdColumnName(kunderaMetadata,entityMetadata,externalProperties,((CassandraClientBase)client).isCql3Enabled(entityMetadata));
    }
    translator.appendColumnName(builder,columnName);
    builder.append(CQLTranslator.CLOSE_BRACKET);
    builder.append(""String_Node_Str"");
    builder.append(CQLTranslator.TOKEN);
    translator.appendValue(builder,idClazz,id,false,false);
    builder.append(CQLTranslator.CLOSE_BRACKET);
    return builder.toString();
  }
  return null;
}",0.9965870307167236
175971,"/** 
 * Method parse provided JPQL query into: 1. CQL3 query, in case cql3 is enabled or is a native query. 2. list of index clause, if cql2 is enabled. Then executes query for given min & max values for scrolling over results.
 * @param m entity metadata
 * @param client client
 * @return list of database values wrapped into entities.
 * @throws Exception throws exception, in case of run time error.
 */
private List<E> populateEntities(EntityMetadata m,Client client) throws Exception {
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"",((QueryImpl)query).getJPAQuery());
  }
  List<E> result=new ArrayList<E>();
  ApplicationMetadata appMetadata=kunderaMetadata.getApplicationMetadata();
  externalProperties=((CassandraClientBase)client).getExternalProperties();
  MetamodelImpl metaModel=(MetamodelImpl)kunderaMetadata.getApplicationMetadata().getMetamodel(m.getPersistenceUnit());
  String queryString=appMetadata.getQuery(((QueryImpl)query).getJPAQuery());
  boolean isNative=((CassQuery)query).isNative();
  if (((CassandraClientBase)client).isCql3Enabled(m)) {
    String parsedQuery=query.onQueryOverCQL3(m,client,metaModel,null);
    parsedQuery=appendWhereClauseWithScroll(parsedQuery);
    results=parsedQuery != null ? ((CassandraClientBase)client).executeQuery(m.getEntityClazz(),m.getRelationNames(),isNative,parsedQuery) : null;
  }
 else {
    boolean useInvertedIndex=CassandraIndexHelper.isInvertedIndexingApplicable(m,MetadataUtils.useSecondryIndex(((ClientBase)client).getClientMetadata()));
    Map<Boolean,List<IndexClause>> ixClause=query.prepareIndexClause(m,useInvertedIndex);
    if (useInvertedIndex && !((QueryImpl)query).getKunderaQuery().getFilterClauseQueue().isEmpty()) {
      result=(List)((CassandraEntityReader)this.reader).readFromIndexTable(m,client,ixClause);
    }
 else {
      boolean isRowKeyQuery=ixClause.keySet().iterator().next();
      List<IndexExpression> expressions=!ixClause.get(isRowKeyQuery).isEmpty() ? ixClause.get(isRowKeyQuery).get(0).getExpressions() : null;
      Map<String,byte[]> rowKeys=((CassandraEntityReader)this.reader).getRowKeyValue(expressions,((AbstractAttribute)m.getIdAttribute()).getJPAColumnName());
      byte[] minValue=start == null ? rowKeys.get(MIN_) : start;
      byte[] maxVal=rowKeys.get(MAX_);
      results=((CassandraClientBase)client).findByRange(minValue,maxVal,m,m.getRelationNames() != null && !m.getRelationNames().isEmpty(),m.getRelationNames(),query.getColumnList(m,metaModel,((QueryImpl)query).getKunderaQuery().getResult(),null),expressions,maxResult);
      if (maxResult == 1) {
        maxResult++;
      }
 else       if (maxResult > 1 && checkOnEmptyResult() && maxResult != results.size()) {
        results=null;
      }
    }
  }
  return results;
}","/** 
 * Method parse provided JPQL query into: 1. CQL3 query, in case cql3 is enabled or is a native query. 2. list of index clause, if cql2 is enabled. Then executes query for given min & max values for scrolling over results.
 * @param m entity metadata
 * @param client client
 * @return list of database values wrapped into entities.
 * @throws Exception throws exception, in case of run time error.
 */
protected List<E> populateEntities(EntityMetadata m,Client client) throws Exception {
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"",((QueryImpl)query).getJPAQuery());
  }
  List<E> result=new ArrayList<E>();
  ApplicationMetadata appMetadata=kunderaMetadata.getApplicationMetadata();
  externalProperties=((CassandraClientBase)client).getExternalProperties();
  MetamodelImpl metaModel=(MetamodelImpl)kunderaMetadata.getApplicationMetadata().getMetamodel(m.getPersistenceUnit());
  String queryString=appMetadata.getQuery(((QueryImpl)query).getJPAQuery());
  boolean isNative=((CassQuery)query).isNative();
  if (((CassandraClientBase)client).isCql3Enabled(m)) {
    String parsedQuery=query.onQueryOverCQL3(m,client,metaModel,null);
    parsedQuery=appendWhereClauseWithScroll(parsedQuery);
    results=parsedQuery != null ? ((CassandraClientBase)client).executeQuery(m.getEntityClazz(),m.getRelationNames(),isNative,parsedQuery) : null;
  }
 else {
    boolean useInvertedIndex=CassandraIndexHelper.isInvertedIndexingApplicable(m,MetadataUtils.useSecondryIndex(((ClientBase)client).getClientMetadata()));
    Map<Boolean,List<IndexClause>> ixClause=query.prepareIndexClause(m,useInvertedIndex);
    if (useInvertedIndex && !((QueryImpl)query).getKunderaQuery().getFilterClauseQueue().isEmpty()) {
      result=(List)((CassandraEntityReader)this.reader).readFromIndexTable(m,client,ixClause);
    }
 else {
      boolean isRowKeyQuery=ixClause.keySet().iterator().next();
      List<IndexExpression> expressions=!ixClause.get(isRowKeyQuery).isEmpty() ? ixClause.get(isRowKeyQuery).get(0).getExpressions() : null;
      Map<String,byte[]> rowKeys=((CassandraEntityReader)this.reader).getRowKeyValue(expressions,((AbstractAttribute)m.getIdAttribute()).getJPAColumnName());
      byte[] minValue=start == null ? rowKeys.get(MIN_) : start;
      byte[] maxVal=rowKeys.get(MAX_);
      results=((CassandraClientBase)client).findByRange(minValue,maxVal,m,m.getRelationNames() != null && !m.getRelationNames().isEmpty(),m.getRelationNames(),query.getColumnList(m,metaModel,((QueryImpl)query).getKunderaQuery().getResult(),null),expressions,maxResult);
      if (maxResult == 1) {
        maxResult++;
      }
 else       if (maxResult > 1 && checkOnEmptyResult() && maxResult != results.size()) {
        results=null;
      }
    }
  }
  return results;
}",0.997836278398846
175972,"/** 
 * Constructor with parameters.
 * @param query the query
 * @param m the m
 * @param client the client
 * @param reader the reader
 * @param fetchSize the fetch size
 * @param kunderaMetadata the kundera metadata
 */
ResultIterator(final Query query,final EntityMetadata m,final Client client,final EntityReader reader,final int fetchSize,final KunderaMetadata kunderaMetadata){
  this.client=client;
  this.query=(CassQuery)query;
  this.entityMetadata=m;
  this.reader=reader;
  this.scrollComplete=false;
  this.fetchSize=fetchSize;
  this.kunderaMetadata=kunderaMetadata;
}","/** 
 * Constructor with parameters.
 * @param query the query
 * @param m the m
 * @param client the client
 * @param reader the reader
 * @param fetchSize the fetch size
 * @param kunderaMetadata the kundera metadata
 */
protected ResultIterator(final Query query,final EntityMetadata m,final Client client,final EntityReader reader,final int fetchSize,final KunderaMetadata kunderaMetadata){
  this.client=client;
  this.query=(CassQuery)query;
  this.entityMetadata=m;
  this.reader=reader;
  this.scrollComplete=false;
  this.fetchSize=fetchSize;
  this.kunderaMetadata=kunderaMetadata;
}",0.9914965986394558
175973,"@Before public void setUp() throws Exception {
  emf=Persistence.createEntityManagerFactory(""String_Node_Str"");
}","@Before public void setUp() throws Exception {
  emf=Persistence.createEntityManagerFactory(""String_Node_Str"");
  em=emf.createEntityManager();
}",0.875968992248062
175974,"@Test public void testPersist(){
  EntityManager em=emf.createEntityManager();
  em.clear();
  RedisGeneratedIdDefault idDefault=new RedisGeneratedIdDefault();
  idDefault.setName(""String_Node_Str"");
  try {
    em.persist(idDefault);
    Assert.fail();
  }
 catch (  KunderaException e) {
    Assert.assertEquals(""String_Node_Str"" + GenerationType.class.getSimpleName() + ""String_Node_Str""+ GenerationType.AUTO+ ""String_Node_Str""+ RedisClient.class.getName(),e.getMessage());
  }
  RedisGeneratedIdStrategyAuto strategyAuto=new RedisGeneratedIdStrategyAuto();
  strategyAuto.setName(""String_Node_Str"");
  em.clear();
  try {
    em.persist(strategyAuto);
    Assert.fail();
  }
 catch (  KunderaException e) {
    Assert.assertEquals(""String_Node_Str"" + GenerationType.class.getSimpleName() + ""String_Node_Str""+ GenerationType.AUTO+ ""String_Node_Str""+ RedisClient.class.getName(),e.getMessage());
  }
  em.clear();
  RedisGeneratedIdStrategyIdentity strategyIdentity=new RedisGeneratedIdStrategyIdentity();
  strategyIdentity.setName(""String_Node_Str"");
  try {
    em.persist(strategyIdentity);
    Assert.fail();
  }
 catch (  KunderaException e) {
    Assert.assertEquals(""String_Node_Str"" + GenerationType.class.getSimpleName() + ""String_Node_Str""+ GenerationType.IDENTITY+ ""String_Node_Str""+ RedisClient.class.getName(),e.getMessage());
  }
  em.clear();
  RedisGeneratedIdStrategySequence strategySequence=new RedisGeneratedIdStrategySequence();
  strategySequence.setName(""String_Node_Str"");
  try {
    em.persist(strategySequence);
    List<RedisGeneratedIdStrategySequence> list=em.createQuery(""String_Node_Str"").getResultList();
    Assert.assertNotNull(list);
    Assert.assertEquals(1,list.size());
    Assert.assertEquals(""String_Node_Str"",list.get(0).getName());
    Object id=list.get(0).getId();
    em.clear();
    strategySequence=em.find(RedisGeneratedIdStrategySequence.class,id);
    Assert.assertNotNull(strategySequence);
    Assert.assertEquals(""String_Node_Str"",strategySequence.getName());
  }
 catch (  KunderaException e) {
    Assert.fail();
  }
  em.clear();
  RedisGeneratedIdStrategyTable strategyTable=new RedisGeneratedIdStrategyTable();
  strategyTable.setName(""String_Node_Str"");
  try {
    em.persist(strategyTable);
    Assert.fail();
  }
 catch (  KunderaException e) {
    Assert.assertEquals(""String_Node_Str"" + GenerationType.class.getSimpleName() + ""String_Node_Str""+ GenerationType.TABLE+ ""String_Node_Str""+ RedisClient.class.getName(),e.getMessage());
  }
  em.clear();
  RedisGeneratedIdWithOutSequenceGenerator withOutSequenceGenerator=new RedisGeneratedIdWithOutSequenceGenerator();
  withOutSequenceGenerator.setName(""String_Node_Str"");
  try {
    em.persist(withOutSequenceGenerator);
    List<RedisGeneratedIdWithOutSequenceGenerator> list=em.createQuery(""String_Node_Str"").getResultList();
    Assert.assertNotNull(list);
    Assert.assertEquals(1,list.size());
    Assert.assertEquals(""String_Node_Str"",list.get(0).getName());
    Object id=list.get(0).getId();
    em.clear();
    withOutSequenceGenerator=em.find(RedisGeneratedIdWithOutSequenceGenerator.class,id);
    Assert.assertNotNull(withOutSequenceGenerator);
    Assert.assertEquals(""String_Node_Str"",withOutSequenceGenerator.getName());
  }
 catch (  KunderaException e) {
    Assert.fail();
  }
  em.clear();
  RedisGeneratedIdWithOutTableGenerator withOutTableGenerator=new RedisGeneratedIdWithOutTableGenerator();
  withOutTableGenerator.setName(""String_Node_Str"");
  try {
    em.persist(withOutTableGenerator);
    Assert.fail();
  }
 catch (  KunderaException e) {
    Assert.assertEquals(""String_Node_Str"" + GenerationType.class.getSimpleName() + ""String_Node_Str""+ GenerationType.TABLE+ ""String_Node_Str""+ RedisClient.class.getName(),e.getMessage());
  }
  em.clear();
  RedisGeneratedIdWithSequenceGenerator withSequenceGenerator=new RedisGeneratedIdWithSequenceGenerator();
  withSequenceGenerator.setName(""String_Node_Str"");
  try {
    em.persist(withSequenceGenerator);
    List<RedisGeneratedIdWithSequenceGenerator> list=em.createQuery(""String_Node_Str"").getResultList();
    Assert.assertNotNull(list);
    Assert.assertEquals(1,list.size());
    Assert.assertEquals(""String_Node_Str"",list.get(0).getName());
    Object id=list.get(0).getId();
    em.clear();
    withSequenceGenerator=em.find(RedisGeneratedIdWithSequenceGenerator.class,id);
    Assert.assertNotNull(withSequenceGenerator);
    Assert.assertEquals(""String_Node_Str"",withSequenceGenerator.getName());
  }
 catch (  KunderaException e) {
    Assert.fail();
  }
  em.clear();
  RedisGeneratedIdWithTableGenerator withTableGenerator=new RedisGeneratedIdWithTableGenerator();
  withTableGenerator.setName(""String_Node_Str"");
  try {
    em.persist(withTableGenerator);
    Assert.fail();
  }
 catch (  KunderaException e) {
    Assert.assertEquals(""String_Node_Str"" + GenerationType.class.getSimpleName() + ""String_Node_Str""+ GenerationType.TABLE+ ""String_Node_Str""+ RedisClient.class.getName(),e.getMessage());
  }
}","@Test public void testPersist(){
  purge();
  RedisGeneratedIdDefault idDefault=new RedisGeneratedIdDefault();
  idDefault.setName(""String_Node_Str"");
  try {
    em.persist(idDefault);
    Assert.fail();
  }
 catch (  KunderaException e) {
    Assert.assertEquals(""String_Node_Str"" + GenerationType.class.getSimpleName() + ""String_Node_Str""+ GenerationType.AUTO+ ""String_Node_Str""+ RedisClient.class.getName(),e.getMessage());
  }
  RedisGeneratedIdStrategyAuto strategyAuto=new RedisGeneratedIdStrategyAuto();
  strategyAuto.setName(""String_Node_Str"");
  em.clear();
  try {
    em.persist(strategyAuto);
    Assert.fail();
  }
 catch (  KunderaException e) {
    Assert.assertEquals(""String_Node_Str"" + GenerationType.class.getSimpleName() + ""String_Node_Str""+ GenerationType.AUTO+ ""String_Node_Str""+ RedisClient.class.getName(),e.getMessage());
  }
  em.clear();
  RedisGeneratedIdStrategyIdentity strategyIdentity=new RedisGeneratedIdStrategyIdentity();
  strategyIdentity.setName(""String_Node_Str"");
  try {
    em.persist(strategyIdentity);
    Assert.fail();
  }
 catch (  KunderaException e) {
    Assert.assertEquals(""String_Node_Str"" + GenerationType.class.getSimpleName() + ""String_Node_Str""+ GenerationType.IDENTITY+ ""String_Node_Str""+ RedisClient.class.getName(),e.getMessage());
  }
  em.clear();
  RedisGeneratedIdStrategySequence strategySequence=new RedisGeneratedIdStrategySequence();
  strategySequence.setName(""String_Node_Str"");
  try {
    em.persist(strategySequence);
    List<RedisGeneratedIdStrategySequence> list=em.createQuery(""String_Node_Str"").getResultList();
    Assert.assertNotNull(list);
    Assert.assertEquals(1,list.size());
    Assert.assertEquals(""String_Node_Str"",list.get(0).getName());
    Object id=list.get(0).getId();
    em.clear();
    strategySequence=em.find(RedisGeneratedIdStrategySequence.class,id);
    Assert.assertNotNull(strategySequence);
    Assert.assertEquals(""String_Node_Str"",strategySequence.getName());
  }
 catch (  KunderaException e) {
    Assert.fail();
  }
  em.clear();
  RedisGeneratedIdStrategyTable strategyTable=new RedisGeneratedIdStrategyTable();
  strategyTable.setName(""String_Node_Str"");
  try {
    em.persist(strategyTable);
    Assert.fail();
  }
 catch (  KunderaException e) {
    Assert.assertEquals(""String_Node_Str"" + GenerationType.class.getSimpleName() + ""String_Node_Str""+ GenerationType.TABLE+ ""String_Node_Str""+ RedisClient.class.getName(),e.getMessage());
  }
  em.clear();
  RedisGeneratedIdWithOutSequenceGenerator withOutSequenceGenerator=new RedisGeneratedIdWithOutSequenceGenerator();
  withOutSequenceGenerator.setName(""String_Node_Str"");
  try {
    em.persist(withOutSequenceGenerator);
    List<RedisGeneratedIdWithOutSequenceGenerator> list=em.createQuery(""String_Node_Str"").getResultList();
    Assert.assertNotNull(list);
    Assert.assertEquals(1,list.size());
    Assert.assertEquals(""String_Node_Str"",list.get(0).getName());
    Object id=list.get(0).getId();
    em.clear();
    withOutSequenceGenerator=em.find(RedisGeneratedIdWithOutSequenceGenerator.class,id);
    Assert.assertNotNull(withOutSequenceGenerator);
    Assert.assertEquals(""String_Node_Str"",withOutSequenceGenerator.getName());
  }
 catch (  KunderaException e) {
    Assert.fail();
  }
  em.clear();
  RedisGeneratedIdWithOutTableGenerator withOutTableGenerator=new RedisGeneratedIdWithOutTableGenerator();
  withOutTableGenerator.setName(""String_Node_Str"");
  try {
    em.persist(withOutTableGenerator);
    Assert.fail();
  }
 catch (  KunderaException e) {
    Assert.assertEquals(""String_Node_Str"" + GenerationType.class.getSimpleName() + ""String_Node_Str""+ GenerationType.TABLE+ ""String_Node_Str""+ RedisClient.class.getName(),e.getMessage());
  }
  em.clear();
  RedisGeneratedIdWithSequenceGenerator withSequenceGenerator=new RedisGeneratedIdWithSequenceGenerator();
  withSequenceGenerator.setName(""String_Node_Str"");
  try {
    em.persist(withSequenceGenerator);
    List<RedisGeneratedIdWithSequenceGenerator> list=em.createQuery(""String_Node_Str"").getResultList();
    Assert.assertNotNull(list);
    Assert.assertEquals(1,list.size());
    Assert.assertEquals(""String_Node_Str"",list.get(0).getName());
    Object id=list.get(0).getId();
    em.clear();
    withSequenceGenerator=em.find(RedisGeneratedIdWithSequenceGenerator.class,id);
    Assert.assertNotNull(withSequenceGenerator);
    Assert.assertEquals(""String_Node_Str"",withSequenceGenerator.getName());
  }
 catch (  KunderaException e) {
    Assert.fail();
  }
  em.clear();
  RedisGeneratedIdWithTableGenerator withTableGenerator=new RedisGeneratedIdWithTableGenerator();
  withTableGenerator.setName(""String_Node_Str"");
  try {
    em.persist(withTableGenerator);
    Assert.fail();
  }
 catch (  KunderaException e) {
    Assert.assertEquals(""String_Node_Str"" + GenerationType.class.getSimpleName() + ""String_Node_Str""+ GenerationType.TABLE+ ""String_Node_Str""+ RedisClient.class.getName(),e.getMessage());
  }
}",0.9940875839262452
175975,"@After public void tearDown() throws Exception {
  EntityManager em=emf.createEntityManager();
  String deleteQuery=""String_Node_Str"";
  Query query=em.createQuery(deleteQuery);
  query.executeUpdate();
  deleteQuery=""String_Node_Str"";
  query=em.createQuery(deleteQuery);
  query.executeUpdate();
  deleteQuery=""String_Node_Str"";
  query=em.createQuery(deleteQuery);
  query.executeUpdate();
  em.close();
  emf.close();
}","@After public void tearDown() throws Exception {
  purge();
  em.close();
  emf.close();
}",0.3391812865497076
175976,"/** 
 * Fetch entity.
 * @param entityClass the entity class
 * @param rowId the row id
 * @param entityMetadata the entity metadata
 * @param relationNames the relation names
 * @param tableName the table name
 * @param results the results
 * @param filter the filter
 * @param filterClausequeue the filter clausequeue
 * @param columns the columns
 * @return the list
 * @throws IOException Signals that an I/O exception has occurred.
 */
private List fetchEntity(Class entityClass,Object rowId,EntityMetadata entityMetadata,List<String> relationNames,String tableName,List results,FilterList filter,Queue filterClausequeue,String... columns) throws IOException {
  List<AbstractManagedType> subManagedType=getSubManagedType(entityClass,entityMetadata);
  if (!subManagedType.isEmpty()) {
    for (    AbstractManagedType subEntity : subManagedType) {
      EntityMetadata subEntityMetadata=KunderaMetadataManager.getEntityMetadata(kunderaMetadata,subEntity.getJavaType());
      results=handler.readData(tableName,subEntityMetadata.getEntityClazz(),subEntityMetadata,rowId,subEntityMetadata.getRelationNames(),filter,columns);
      if (!results.isEmpty()) {
        break;
      }
    }
  }
 else {
    results=handler.readData(tableName,entityMetadata.getEntityClazz(),entityMetadata,rowId,relationNames,filter,columns);
  }
  if (rowId != null) {
    KunderaCoreUtils.printQuery(""String_Node_Str"" + entityMetadata.getTableName() + ""String_Node_Str""+ rowId,showQuery);
  }
 else   if (showQuery && filterClausequeue.size() > 0) {
    KunderaCoreUtils.printQueryWithFilterClause(filterClausequeue,entityMetadata.getTableName());
  }
  return results;
}","/** 
 * Fetch entity.
 * @param entityClass the entity class
 * @param rowId the row id
 * @param entityMetadata the entity metadata
 * @param relationNames the relation names
 * @param tableName the table name
 * @param results the results
 * @param filter the filter
 * @param filterClausequeue the filter clausequeue
 * @param columns the columns
 * @return the list
 * @throws IOException Signals that an I/O exception has occurred.
 */
private List fetchEntity(Class entityClass,Object rowId,EntityMetadata entityMetadata,List<String> relationNames,String tableName,List results,FilterList filter,Queue filterClausequeue,String... columns) throws IOException {
  results=new ArrayList();
  List<AbstractManagedType> subManagedType=getSubManagedType(entityClass,entityMetadata);
  if (!subManagedType.isEmpty()) {
    for (    AbstractManagedType subEntity : subManagedType) {
      EntityMetadata subEntityMetadata=KunderaMetadataManager.getEntityMetadata(kunderaMetadata,subEntity.getJavaType());
      List tempResults=handler.readData(tableName,subEntityMetadata.getEntityClazz(),subEntityMetadata,rowId,subEntityMetadata.getRelationNames(),filter,columns);
      if (tempResults != null && !tempResults.isEmpty()) {
        results.addAll(tempResults);
      }
    }
  }
 else {
    results=handler.readData(tableName,entityMetadata.getEntityClazz(),entityMetadata,rowId,relationNames,filter,columns);
  }
  if (rowId != null) {
    KunderaCoreUtils.printQuery(""String_Node_Str"" + entityMetadata.getTableName() + ""String_Node_Str""+ rowId,showQuery);
  }
 else   if (showQuery && filterClausequeue.size() > 0) {
    KunderaCoreUtils.printQueryWithFilterClause(filterClausequeue,entityMetadata.getTableName());
  }
  return results;
}",0.9708566382101854
175977,"/** 
 * Returns collection of parsed filter.
 * @return map.
 */
Filter getFilter(){
  FilterList filters=new FilterList(new PageFilter(getMaxResults()));
  if (filterList != null) {
    if (this.isORQuery) {
      filters.addFilter(new FilterList(FilterList.Operator.MUST_PASS_ONE,filterList));
    }
 else {
      filters.addFilter(new FilterList(filterList));
    }
  }
  return filters;
}","/** 
 * Returns collection of parsed filter.
 * @return map.
 */
Filter getFilter(){
  FilterList filters=new FilterList(new PageFilter(getMaxResults()));
  if (filterList != null) {
    this.setWhereQuery(true);
    if (this.isORQuery) {
      filters.addFilter(new FilterList(FilterList.Operator.MUST_PASS_ONE,filterList));
    }
 else {
      filters.addFilter(new FilterList(filterList));
    }
  }
  return filters;
}",0.9631449631449632
175978,"/** 
 * Parses and translates query into HBase filter and invokes client's method to return list of entities.
 * @param m Entity metadata
 * @param client hbase client
 * @return list of entities.
 */
private List onQuery(EntityMetadata m,Client client){
  QueryTranslator translator=new QueryTranslator();
  translator.translate(getKunderaQuery(),m,((ClientBase)client).getClientMetadata());
  List<String> columns=getTranslatedColumns(m,getKunderaQuery().getResult(),1);
  Filter filter=translator.getFilter();
  if (translator.rowList != null && !translator.rowList.isEmpty()) {
    return ((HBaseClient)client).findAll(m.getEntityClazz(),columns.toArray(new String[columns.size()]),translator.getRowList());
  }
  if (filter == null && columns != null) {
    return ((HBaseClient)client).findByRange(m.getEntityClazz(),m,translator.getStartRow(),translator.getEndRow(),columns.toArray(new String[columns.size()]),null,getKunderaQuery().getFilterClauseQueue());
  }
  if (MetadataUtils.useSecondryIndex(((ClientBase)client).getClientMetadata())) {
    if (filter == null) {
      if (translator.isRangeScan()) {
        return ((HBaseClient)client).findByRange(m.getEntityClazz(),m,translator.getStartRow(),translator.getEndRow(),columns.toArray(new String[columns.size()]),null,getKunderaQuery().getFilterClauseQueue());
      }
 else {
        return ((HBaseClient)client).findByRange(m.getEntityClazz(),m,null,null,columns.toArray(new String[columns.size()]),null,getKunderaQuery().getFilterClauseQueue());
      }
    }
 else {
      if (translator.isRangeScan()) {
        return ((HBaseClient)client).findByRange(m.getEntityClazz(),m,translator.getStartRow(),translator.getEndRow(),columns.toArray(new String[columns.size()]),filter,getKunderaQuery().getFilterClauseQueue());
      }
 else {
        return ((HBaseClient)client).findByQuery(m.getEntityClazz(),m,filter,getKunderaQuery().getFilterClauseQueue(),columns.toArray(new String[columns.size()]));
      }
    }
  }
 else {
    List results=null;
    return populateUsingLucene(m,client,results,null);
  }
}","/** 
 * Parses and translates query into HBase filter and invokes client's method to return list of entities.
 * @param m Entity metadata
 * @param client hbase client
 * @return list of entities.
 */
private List onQuery(EntityMetadata m,Client client){
  QueryTranslator translator=new QueryTranslator();
  translator.translate(getKunderaQuery(),m,((ClientBase)client).getClientMetadata());
  List<String> columns=getTranslatedColumns(m,getKunderaQuery().getResult(),1);
  Filter filter=translator.getFilter();
  if (translator.rowList != null && !translator.rowList.isEmpty()) {
    return ((HBaseClient)client).findAll(m.getEntityClazz(),columns.toArray(new String[columns.size()]),translator.getRowList());
  }
  if (!translator.isWhereQuery() && columns != null) {
    return ((HBaseClient)client).findByRange(m.getEntityClazz(),m,translator.getStartRow(),translator.getEndRow(),columns.toArray(new String[columns.size()]),null,getKunderaQuery().getFilterClauseQueue());
  }
  if (MetadataUtils.useSecondryIndex(((ClientBase)client).getClientMetadata())) {
    if (translator.isWhereQuery() && !translator.isRangeScan()) {
      return ((HBaseClient)client).findByQuery(m.getEntityClazz(),m,filter,getKunderaQuery().getFilterClauseQueue(),columns.toArray(new String[columns.size()]));
    }
 else {
      return ((HBaseClient)client).findByRange(m.getEntityClazz(),m,translator.getStartRow(),translator.getEndRow(),columns.toArray(new String[columns.size()]),filter,getKunderaQuery().getFilterClauseQueue());
    }
  }
 else {
    return populateUsingLucene(m,client,null,null);
  }
}",0.7308951965065502
175979,"/** 
 * Find persistence meta data. Loads configured persistence.xml and load all provided configurations within persistence meta data as per @see JPA 2.0 specifications.
 * @return the list configure persistence unit meta data.
 */
private Map<String,PersistenceUnitMetadata> findPersistenceMetadatas() throws InvalidConfigurationException {
  String puLocation=(String)(externalPropertyMap != null && externalPropertyMap.get(Constants.PERSISTENCE_UNIT_LOCATIION) != null ? externalPropertyMap.get(Constants.PERSISTENCE_UNIT_LOCATIION) : Constants.DEFAULT_PERSISTENCE_UNIT_LOCATIION);
  Enumeration<URL> xmls=null;
  try {
    xmls=this.getClass().getClassLoader().getResources(puLocation);
  }
 catch (  IOException ioex) {
    log.warn(""String_Node_Str"",ioex);
  }
  if (xmls == null || !xmls.hasMoreElements()) {
    log.error(""String_Node_Str"");
    throw new InvalidConfigurationException(""String_Node_Str"");
  }
  Set<String> persistenceUnitNames=new HashSet<String>();
  Map<String,PersistenceUnitMetadata> persistenceUnitMap=new HashMap<String,PersistenceUnitMetadata>();
  while (xmls.hasMoreElements()) {
    URL url=xmls.nextElement();
    log.trace(""String_Node_Str"" + url);
    List<PersistenceUnitMetadata> metadataFiles=PersistenceXMLLoader.findPersistenceUnits(url,PersistenceUnitTransactionType.RESOURCE_LOCAL);
    for (    PersistenceUnitMetadata metadata : metadataFiles) {
      if (persistenceUnitNames.contains(metadata.getPersistenceUnitName())) {
        if (log.isWarnEnabled()) {
          log.warn(""String_Node_Str"" + metadata.getPersistenceUnitName() + ""String_Node_Str"");
        }
      }
      if (metadata.getPersistenceProviderClassName() == null || PROVIDER_IMPLEMENTATION_NAME.equalsIgnoreCase(metadata.getPersistenceProviderClassName())) {
        persistenceUnitMap.put(metadata.getPersistenceUnitName(),metadata);
      }
      persistenceUnitNames.add(metadata.getPersistenceUnitName());
    }
  }
  return persistenceUnitMap;
}","/** 
 * Find persistence meta data. Loads configured persistence.xml and load all provided configurations within persistence meta data as per @see JPA 2.0 specifications.
 * @return the list configure persistence unit meta data.
 */
private Map<String,PersistenceUnitMetadata> findPersistenceMetadatas() throws InvalidConfigurationException {
  String puLocation=(String)(externalPropertyMap != null && externalPropertyMap.get(Constants.PERSISTENCE_UNIT_LOCATIION) != null ? externalPropertyMap.get(Constants.PERSISTENCE_UNIT_LOCATIION) : Constants.DEFAULT_PERSISTENCE_UNIT_LOCATIION);
  Enumeration<URL> xmls=null;
  try {
    xmls=this.getClass().getClassLoader().getResources(puLocation);
  }
 catch (  IOException ioex) {
    log.warn(""String_Node_Str"",ioex);
  }
  if (xmls == null || !xmls.hasMoreElements()) {
    log.error(""String_Node_Str"");
    throw new InvalidConfigurationException(""String_Node_Str"");
  }
  Set<String> persistenceUnitNames=new HashSet<String>();
  Map<String,PersistenceUnitMetadata> persistenceUnitMap=new HashMap<String,PersistenceUnitMetadata>();
  while (xmls.hasMoreElements()) {
    URL url=xmls.nextElement();
    log.trace(""String_Node_Str"" + url);
    List<PersistenceUnitMetadata> metadataFiles=PersistenceXMLLoader.findPersistenceUnits(url,persistenceUnits,PersistenceUnitTransactionType.RESOURCE_LOCAL);
    for (    PersistenceUnitMetadata metadata : metadataFiles) {
      if (persistenceUnitNames.contains(metadata.getPersistenceUnitName())) {
        if (log.isWarnEnabled()) {
          log.warn(""String_Node_Str"" + metadata.getPersistenceUnitName() + ""String_Node_Str"");
        }
      }
      if (metadata.getPersistenceProviderClassName() == null || PROVIDER_IMPLEMENTATION_NAME.equalsIgnoreCase(metadata.getPersistenceProviderClassName())) {
        persistenceUnitMap.put(metadata.getPersistenceUnitName(),metadata);
      }
      persistenceUnitNames.add(metadata.getPersistenceUnitName());
    }
  }
  return persistenceUnitMap;
}",0.9957016434892542
175980,"public final void process(final Class<?> clazz,EntityMetadata metadata){
  if (clazz != null) {
    metadata.setIndexName(clazz.getSimpleName());
  }
  Index idx=clazz.getAnnotation(Index.class);
  IndexCollection indexes=clazz.getAnnotation(IndexCollection.class);
  EntityType entityType=(EntityType)kunderaMetadata.getApplicationMetadata().getMetaModelBuilder(metadata.getPersistenceUnit()).getManagedTypes().get(clazz);
  List<String> columnsNameToBeIndexed=new ArrayList<String>();
  Map<String,com.impetus.kundera.index.Index> indexedColumnsMap=new HashMap<String,com.impetus.kundera.index.Index>();
  if (null != indexes) {
    if (indexes.columns() != null && indexes.columns().length != 0) {
      metadata.setIndexable(true);
      for (      com.impetus.kundera.index.Index indexedColumn : indexes.columns()) {
        if (indexedColumn.type().equals(""String_Node_Str"")) {
          metadata.addIndexProperty(prepareCompositeIndexName(indexedColumn.name(),entityType),populatePropertyIndex(indexedColumn.indexName(),indexedColumn.type(),null,null,null));
        }
 else {
          indexedColumnsMap.put(indexedColumn.name(),indexedColumn);
        }
      }
    }
  }
 else   if (null != idx) {
    boolean isIndexable=idx.index();
    if (isIndexable) {
      metadata.setIndexable(isIndexable);
      String indexName=idx.name();
      if (indexName != null && !indexName.isEmpty()) {
        metadata.setIndexName(indexName);
      }
      if (idx.columns() != null && idx.columns().length != 0) {
        for (        String indexedColumn : idx.columns()) {
          columnsNameToBeIndexed.add(indexedColumn);
        }
      }
    }
  }
 else {
    log.debug(""String_Node_Str"" + clazz.getName() + ""String_Node_Str""+ (indexedColumnsMap.isEmpty() ? ""String_Node_Str"" : indexedColumnsMap));
    return;
  }
  log.debug(""String_Node_Str"" + clazz.getName() + ""String_Node_Str"");
  Set<Attribute> attributes=entityType.getAttributes();
  for (  Attribute attrib : attributes) {
    if (!attrib.isAssociation()) {
      String colName=attrib.getName();
      String columnName=((AbstractAttribute)attrib).getJPAColumnName();
      if (indexedColumnsMap != null && !indexedColumnsMap.isEmpty() && indexedColumnsMap.containsKey(colName)) {
        com.impetus.kundera.index.Index indexedColumn=indexedColumnsMap.get(colName);
        String indexName=StringUtils.isBlank(indexedColumn.indexName()) ? columnName : indexedColumn.indexName();
        metadata.addIndexProperty(columnName,populatePropertyIndex(indexName,indexedColumn.type(),indexedColumn.max(),indexedColumn.min(),(Field)attrib.getJavaMember()));
      }
 else       if (columnsNameToBeIndexed != null && !columnsNameToBeIndexed.isEmpty() && columnsNameToBeIndexed.contains(colName)) {
        metadata.addIndexProperty(columnName,populatePropertyIndex(columnName,null,null,null,(Field)attrib.getJavaMember()));
      }
    }
  }
}","public final void process(final Class<?> clazz,EntityMetadata metadata){
  if (clazz != null) {
    metadata.setIndexName(clazz.getSimpleName());
  }
  Index idx=clazz.getAnnotation(Index.class);
  IndexCollection indexes=clazz.getAnnotation(IndexCollection.class);
  EntityType entityType=(EntityType)kunderaMetadata.getApplicationMetadata().getMetaModelBuilder(metadata.getPersistenceUnit()).getManagedTypes().get(clazz);
  List<String> columnsNameToBeIndexed=new ArrayList<String>();
  Map<String,com.impetus.kundera.index.Index> indexedColumnsMap=new HashMap<String,com.impetus.kundera.index.Index>();
  if (null != indexes) {
    if (indexes.columns() != null && indexes.columns().length != 0) {
      metadata.setIndexable(true);
      for (      com.impetus.kundera.index.Index indexedColumn : indexes.columns()) {
        if (indexedColumn.type().equals(""String_Node_Str"")) {
          metadata.addIndexProperty(prepareCompositeIndexName(indexedColumn.name(),entityType,metadata),populatePropertyIndex(indexedColumn.indexName(),indexedColumn.type(),null,null,null));
        }
 else {
          indexedColumnsMap.put(indexedColumn.name(),indexedColumn);
        }
      }
    }
  }
 else   if (null != idx) {
    boolean isIndexable=idx.index();
    if (isIndexable) {
      metadata.setIndexable(isIndexable);
      String indexName=idx.name();
      if (indexName != null && !indexName.isEmpty()) {
        metadata.setIndexName(indexName);
      }
      if (idx.columns() != null && idx.columns().length != 0) {
        for (        String indexedColumn : idx.columns()) {
          columnsNameToBeIndexed.add(indexedColumn);
        }
      }
    }
  }
 else {
    log.debug(""String_Node_Str"" + clazz.getName() + ""String_Node_Str""+ (indexedColumnsMap.isEmpty() ? ""String_Node_Str"" : indexedColumnsMap));
    return;
  }
  log.debug(""String_Node_Str"" + clazz.getName() + ""String_Node_Str"");
  Set<Attribute> attributes=entityType.getAttributes();
  for (  Attribute attrib : attributes) {
    if (!attrib.isAssociation()) {
      String colName=attrib.getName();
      String columnName=((AbstractAttribute)attrib).getJPAColumnName();
      if (indexedColumnsMap != null && !indexedColumnsMap.isEmpty() && indexedColumnsMap.containsKey(colName)) {
        com.impetus.kundera.index.Index indexedColumn=indexedColumnsMap.get(colName);
        String indexName=StringUtils.isBlank(indexedColumn.indexName()) ? columnName : indexedColumn.indexName();
        metadata.addIndexProperty(columnName,populatePropertyIndex(indexName,indexedColumn.type(),indexedColumn.max(),indexedColumn.min(),(Field)attrib.getJavaMember()));
      }
 else       if (columnsNameToBeIndexed != null && !columnsNameToBeIndexed.isEmpty() && columnsNameToBeIndexed.contains(colName)) {
        metadata.addIndexProperty(columnName,populatePropertyIndex(columnName,null,null,null,(Field)attrib.getJavaMember()));
      }
    }
  }
}",0.9984533424987112
175981,"/** 
 * prepare composite index.
 * @param indexedColumns
 * @param entityType
 * @return
 */
private String prepareCompositeIndexName(String indexedColumns,final EntityType entityType){
  StringTokenizer tokenizer=new StringTokenizer(indexedColumns,""String_Node_Str"");
  StringBuilder builder=new StringBuilder();
  while (tokenizer.hasMoreTokens()) {
    String fieldName=(String)tokenizer.nextElement();
    builder.append(((AbstractAttribute)entityType.getAttribute(fieldName)).getJPAColumnName());
    builder.append(""String_Node_Str"");
  }
  builder.deleteCharAt(builder.length() - 1);
  return builder.toString();
}","/** 
 * prepare composite index.
 * @param indexedColumns
 * @param entityType
 * @return
 */
private String prepareCompositeIndexName(String indexedColumns,final EntityType entityType,EntityMetadata metadata){
  StringTokenizer tokenizer=new StringTokenizer(indexedColumns,""String_Node_Str"");
  StringBuilder builder=new StringBuilder();
  while (tokenizer.hasMoreTokens()) {
    String fieldName=(String)tokenizer.nextElement();
    StringTokenizer stringTokenizer=new StringTokenizer(fieldName,""String_Node_Str"");
    if (stringTokenizer.countTokens() > 1) {
      fieldName=stringTokenizer.nextToken();
      String embeddedFieldName=stringTokenizer.nextToken();
      Attribute embeddable=entityType.getAttribute(fieldName);
      EmbeddableType embeddedEntity=(EmbeddableType)kunderaMetadata.getApplicationMetadata().getMetaModelBuilder(metadata.getPersistenceUnit()).getEmbeddables().get(((AbstractAttribute)embeddable).getBindableJavaType());
      Attribute embeddedAttribute=embeddedEntity.getAttribute(embeddedFieldName);
      builder.append(((AbstractAttribute)embeddedAttribute).getJPAColumnName());
    }
 else {
      builder.append(((AbstractAttribute)entityType.getAttribute(fieldName)).getJPAColumnName());
    }
    builder.append(""String_Node_Str"");
  }
  builder.deleteCharAt(builder.length() - 1);
  return builder.toString();
}",0.570704510897111
175982,"/** 
 * Delete by primary key.
 */
@Override public void delete(Object entity,Object pKey){
  EntityMetadata entityMetadata=KunderaMetadataManager.getEntityMetadata(kunderaMetadata,entity.getClass());
  MetamodelImpl metamodel=(MetamodelImpl)KunderaMetadataManager.getMetamodel(kunderaMetadata,entityMetadata.getPersistenceUnit());
  String idColumnName=((AbstractAttribute)entityMetadata.getIdAttribute()).getJPAColumnName();
  Table schemaTable=tableAPI.getTable(entityMetadata.getTableName());
  PrimaryKey key=schemaTable.createPrimaryKey();
  if (metamodel.isEmbeddable(entityMetadata.getIdAttribute().getBindableJavaType())) {
    EmbeddableType embeddableId=metamodel.embeddable(entityMetadata.getIdAttribute().getBindableJavaType());
    Set<Attribute> embeddedAttributes=embeddableId.getAttributes();
    for (    Attribute embeddedAttrib : embeddedAttributes) {
      String columnName=((AbstractAttribute)embeddedAttrib).getJPAColumnName();
      Object embeddedColumn=PropertyAccessorHelper.getObject(key,(Field)embeddedAttrib.getJavaMember());
      NoSqlDBUtils.add(schemaTable.getField(columnName),key,embeddedColumn,columnName);
    }
  }
 else {
    NoSqlDBUtils.add(schemaTable.getField(idColumnName),key,pKey,idColumnName);
  }
  tableAPI.delete(key,null,null);
  getIndexManager().remove(entityMetadata,entity,pKey.toString());
}","/** 
 * Delete by primary key.
 */
@Override public void delete(Object entity,Object pKey){
  EntityMetadata entityMetadata=KunderaMetadataManager.getEntityMetadata(kunderaMetadata,entity.getClass());
  MetamodelImpl metamodel=(MetamodelImpl)KunderaMetadataManager.getMetamodel(kunderaMetadata,entityMetadata.getPersistenceUnit());
  String idColumnName=((AbstractAttribute)entityMetadata.getIdAttribute()).getJPAColumnName();
  Table schemaTable=tableAPI.getTable(entityMetadata.getTableName());
  PrimaryKey key=schemaTable.createPrimaryKey();
  if (metamodel.isEmbeddable(entityMetadata.getIdAttribute().getBindableJavaType())) {
    EmbeddableType embeddableId=metamodel.embeddable(entityMetadata.getIdAttribute().getBindableJavaType());
    Set<Attribute> embeddedAttributes=embeddableId.getAttributes();
    for (    Attribute embeddedAttrib : embeddedAttributes) {
      String columnName=((AbstractAttribute)embeddedAttrib).getJPAColumnName();
      Object embeddedColumn=PropertyAccessorHelper.getObject(pKey,(Field)embeddedAttrib.getJavaMember());
      NoSqlDBUtils.add(schemaTable.getField(columnName),key,embeddedColumn,columnName);
    }
  }
 else {
    NoSqlDBUtils.add(schemaTable.getField(idColumnName),key,pKey,idColumnName);
  }
  tableAPI.delete(key,null,null);
  getIndexManager().remove(entityMetadata,entity,pKey.toString());
}",0.9988884772137828
175983,"private <E>List<E> onIndexSearch(OracleNoSQLQueryInterpreter interpreter,EntityMetadata entityMetadata,MetamodelImpl metamodel,List<E> results,List<String> columnsToSelect){
  Map<String,List> indexes=new HashMap<String,List>();
  StringBuilder indexNamebuilder=new StringBuilder();
  for (  Object clause : interpreter.getClauseQueue()) {
    if (clause.getClass().isAssignableFrom(FilterClause.class)) {
      String fieldName=((FilterClause)clause).getProperty();
      Object value=((FilterClause)clause).getValue();
      if (!indexes.containsKey(fieldName)) {
        indexNamebuilder.append(fieldName);
        indexNamebuilder.append(""String_Node_Str"");
      }
      indexes.put(fieldName,(List)value);
    }
 else {
      if (clause.toString().equalsIgnoreCase(""String_Node_Str"")) {
        throw new QueryHandlerException(""String_Node_Str"");
      }
    }
  }
  Table schemaTable=tableAPI.getTable(entityMetadata.getTableName());
  String indexKeyName=indexNamebuilder.deleteCharAt(indexNamebuilder.length() - 1).toString();
  Index index=schemaTable.getIndex(entityMetadata.getIndexProperties().get(indexKeyName).getName());
  IndexKey indexKey=index.createIndexKey();
  for (  String indexName : indexes.keySet()) {
    NoSqlDBUtils.add(schemaTable.getField(indexName),indexKey,indexes.get(indexName).get(0),indexName);
  }
  Iterator<Row> rowsIter=tableAPI.tableIterator(indexKey,null,null);
  Map<String,Object> relationMap=initialize(entityMetadata);
  try {
    results=scrollAndPopulate(null,entityMetadata,metamodel,schemaTable,rowsIter,relationMap,columnsToSelect);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e + ""String_Node_Str"");
    throw new PersistenceException(e);
  }
  return results;
}","private <E>List<E> onIndexSearch(OracleNoSQLQueryInterpreter interpreter,EntityMetadata entityMetadata,MetamodelImpl metamodel,List<E> results,List<String> columnsToSelect){
  Map<String,List> indexes=new HashMap<String,List>();
  StringBuilder indexNamebuilder=new StringBuilder();
  for (  Object clause : interpreter.getClauseQueue()) {
    if (clause.getClass().isAssignableFrom(FilterClause.class)) {
      String fieldName=null;
      String clauseName=((FilterClause)clause).getProperty();
      StringTokenizer stringTokenizer=new StringTokenizer(clauseName,""String_Node_Str"");
      if (stringTokenizer.countTokens() > 1) {
        fieldName=stringTokenizer.nextToken();
      }
      fieldName=stringTokenizer.nextToken();
      Object value=((FilterClause)clause).getValue();
      if (!indexes.containsKey(fieldName)) {
        indexNamebuilder.append(fieldName);
        indexNamebuilder.append(""String_Node_Str"");
      }
      indexes.put(fieldName,(List)value);
    }
 else {
      if (clause.toString().equalsIgnoreCase(""String_Node_Str"")) {
        throw new QueryHandlerException(""String_Node_Str"");
      }
    }
  }
  Table schemaTable=tableAPI.getTable(entityMetadata.getTableName());
  String indexKeyName=indexNamebuilder.deleteCharAt(indexNamebuilder.length() - 1).toString();
  Index index=schemaTable.getIndex(entityMetadata.getIndexProperties().get(indexKeyName).getName());
  IndexKey indexKey=index.createIndexKey();
  for (  String indexName : indexes.keySet()) {
    NoSqlDBUtils.add(schemaTable.getField(indexName),indexKey,indexes.get(indexName).get(0),indexName);
  }
  Iterator<Row> rowsIter=tableAPI.tableIterator(indexKey,null,null);
  Map<String,Object> relationMap=initialize(entityMetadata);
  try {
    results=scrollAndPopulate(null,entityMetadata,metamodel,schemaTable,rowsIter,relationMap,columnsToSelect);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e + ""String_Node_Str"");
    throw new PersistenceException(e);
  }
  return results;
}",0.9288008565310492
175984,"private OracleNoSQLQueryInterpreter translateQuery(Queue clauseQueue,EntityMetadata entityMetadata){
  OracleNoSQLQueryInterpreter interpreter=new OracleNoSQLQueryInterpreter(getColumns(getKunderaQuery().getResult(),entityMetadata));
  interpreter.setClauseQueue(clauseQueue);
  String operatorWithIdClause=null;
  boolean idClauseFound=false;
  for (  Object clause : clauseQueue) {
    if (clause.getClass().isAssignableFrom(FilterClause.class) && !idClauseFound) {
      String columnName=((FilterClause)clause).getProperty();
      SingularAttribute idAttribute=entityMetadata.getIdAttribute();
      if (columnName.equals(((AbstractAttribute)idAttribute).getJPAColumnName())) {
        interpreter.setFindById(true);
        Object keyObj=PropertyAccessorHelper.fromSourceToTargetClass(((AbstractAttribute)idAttribute).getBindableJavaType(),String.class,((FilterClause)clause).getValue().get(0));
        interpreter.setRowKey((keyObj));
        idClauseFound=true;
      }
    }
 else     if (clause instanceof String) {
      operatorWithIdClause=clause.toString().trim();
    }
    if (idClauseFound && operatorWithIdClause != null) {
      break;
    }
  }
  interpreter.setOperatorWithRowKey(operatorWithIdClause);
  return interpreter;
}","private OracleNoSQLQueryInterpreter translateQuery(Queue clauseQueue,EntityMetadata entityMetadata){
  OracleNoSQLQueryInterpreter interpreter=new OracleNoSQLQueryInterpreter(getColumns(getKunderaQuery().getResult(),entityMetadata));
  interpreter.setClauseQueue(clauseQueue);
  String operatorWithIdClause=null;
  boolean idClauseFound=false;
  for (  Object clause : clauseQueue) {
    if (clause.getClass().isAssignableFrom(FilterClause.class) && !idClauseFound) {
      String columnName=((FilterClause)clause).getProperty();
      SingularAttribute idAttribute=entityMetadata.getIdAttribute();
      if (columnName.equals(((AbstractAttribute)idAttribute).getJPAColumnName())) {
        interpreter.setFindById(true);
        interpreter.setRowKey((((FilterClause)clause).getValue().get(0)));
        idClauseFound=true;
      }
    }
 else     if (clause instanceof String) {
      operatorWithIdClause=clause.toString().trim();
    }
    if (idClauseFound && operatorWithIdClause != null) {
      break;
    }
  }
  interpreter.setOperatorWithRowKey(operatorWithIdClause);
  return interpreter;
}",0.9038297872340424
175985,"@Test public void executeJPAQueriesTest(){
  persistPerson(""String_Node_Str"",""String_Node_Str"",10,new Office(1,""String_Node_Str"",""String_Node_Str""));
  persistPerson(""String_Node_Str"",""String_Node_Str"",20,new Office(2,""String_Node_Str"",""String_Node_Str""));
  persistPerson(""String_Node_Str"",""String_Node_Str"",30,new Office(3,""String_Node_Str"",""String_Node_Str""));
  persistPerson(""String_Node_Str"",""String_Node_Str"",40,new Office(4,""String_Node_Str"",""String_Node_Str""));
  clearEm();
  String findWithOutWhereClause=""String_Node_Str"";
  List<PersonEmbeddedKVStore> results=executeSelectQuery(findWithOutWhereClause);
  Assert.assertEquals(4,results.size());
  clearEm();
  String findByName=""String_Node_Str"";
  Map<Object,Object> params=new HashMap<Object,Object>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  results=executeSelectQuery(findByName,params);
  Assert.assertEquals(1,results.size());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getPersonId());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getPersonName());
  Assert.assertEquals(10,results.get(0).getAge());
  clearEm();
  String findById=""String_Node_Str"";
  params=new HashMap<Object,Object>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  results=executeSelectQuery(findById,params);
  Assert.assertEquals(1,results.size());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getPersonId());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getPersonName());
  Assert.assertEquals(20,results.get(0).getAge());
  clearEm();
  String findByIdAndAge=""String_Node_Str"";
  params=new HashMap<Object,Object>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",30);
  results=executeSelectQuery(findByIdAndAge,params);
  Assert.assertEquals(1,results.size());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getPersonId());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getPersonName());
  Assert.assertEquals(30,results.get(0).getAge());
  clearEm();
  params=new HashMap<Object,Object>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",30);
  results=executeSelectQuery(findByIdAndAge,params);
  Assert.assertEquals(0,results.size());
  if (!isLuceneIndexingEnabled()) {
    clearEm();
  }
  clearEm();
  String findSelective=""String_Node_Str"";
  results=executeSelectQuery(findSelective);
  Assert.assertEquals(4,results.size());
  Assert.assertNull(results.get(0).getPersonName());
  Assert.assertNotNull(results.get(0).getAge());
  clearEm();
  String deleteQuery=""String_Node_Str"";
  int updateCount=executeDMLQuery(deleteQuery);
  Assert.assertEquals(4,updateCount);
  clearEm();
  Assert.assertEquals(null,findById(""String_Node_Str""));
  Assert.assertEquals(null,findById(""String_Node_Str""));
  Assert.assertEquals(null,findById(""String_Node_Str""));
  Assert.assertEquals(null,findById(""String_Node_Str""));
}","@Test public void executeJPAQueriesTest(){
  persistPerson(""String_Node_Str"",""String_Node_Str"",10,new Office(1,""String_Node_Str"",""String_Node_Str""));
  persistPerson(""String_Node_Str"",""String_Node_Str"",20,new Office(2,""String_Node_Str"",""String_Node_Str""));
  persistPerson(""String_Node_Str"",""String_Node_Str"",30,new Office(3,""String_Node_Str"",""String_Node_Str""));
  persistPerson(""String_Node_Str"",""String_Node_Str"",40,new Office(4,""String_Node_Str"",""String_Node_Str""));
  clearEm();
  String findWithOutWhereClause=""String_Node_Str"";
  List<PersonEmbeddedKVStore> results=executeSelectQuery(findWithOutWhereClause);
  Assert.assertEquals(4,results.size());
  clearEm();
  String findByName=""String_Node_Str"";
  Map<Object,Object> params=new HashMap<Object,Object>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  results=executeSelectQuery(findByName,params);
  Assert.assertEquals(1,results.size());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getPersonId());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getPersonName());
  Assert.assertEquals(10,results.get(0).getAge());
  clearEm();
  String findById=""String_Node_Str"";
  params=new HashMap<Object,Object>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  results=executeSelectQuery(findById,params);
  Assert.assertEquals(1,results.size());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getPersonId());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getPersonName());
  Assert.assertEquals(20,results.get(0).getAge());
  clearEm();
  String findByIdAndAge=""String_Node_Str"";
  params=new HashMap<Object,Object>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",30);
  results=executeSelectQuery(findByIdAndAge,params);
  Assert.assertEquals(1,results.size());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getPersonId());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getPersonName());
  Assert.assertEquals(30,results.get(0).getAge());
  clearEm();
  params=new HashMap<Object,Object>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  params.put(""String_Node_Str"",30);
  results=executeSelectQuery(findByIdAndAge,params);
  Assert.assertEquals(0,results.size());
  if (!isLuceneIndexingEnabled()) {
    clearEm();
  }
  clearEm();
  String findSelective=""String_Node_Str"";
  results=executeSelectQuery(findSelective);
  Assert.assertEquals(4,results.size());
  Assert.assertNull(results.get(0).getPersonName());
  Assert.assertNotNull(results.get(0).getAge());
  clearEm();
  String findByCompanyName=""String_Node_Str"";
  params=new HashMap<Object,Object>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  results=executeSelectQuery(findByCompanyName,params);
  Assert.assertEquals(1,results.size());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getPersonId());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getPersonName());
  Assert.assertEquals(30,results.get(0).getAge());
  Assert.assertEquals(3,results.get(0).getOffice().getOfficeId());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getOffice().getCompanyName());
  Assert.assertEquals(""String_Node_Str"",results.get(0).getOffice().getLocation());
  String deleteQuery=""String_Node_Str"";
  int updateCount=executeDMLQuery(deleteQuery);
  Assert.assertEquals(4,updateCount);
  clearEm();
  Assert.assertEquals(null,findById(""String_Node_Str""));
  Assert.assertEquals(null,findById(""String_Node_Str""));
  Assert.assertEquals(null,findById(""String_Node_Str""));
  Assert.assertEquals(null,findById(""String_Node_Str""));
}",0.8975940777297964
175986,"public static boolean columnFamilyExist(String columnfamilyName,String keyspaceName){
  try {
    client.set_keyspace(keyspaceName);
    client.system_add_column_family(new CfDef(keyspaceName,columnfamilyName));
  }
 catch (  InvalidRequestException irex) {
    StringBuilder builder=new StringBuilder(""String_Node_Str"");
    if (irex.getWhy() != null && irex.getWhy().contains(builder.toString())) {
      return true;
    }
    return false;
  }
catch (  SchemaDisagreementException e) {
    return false;
  }
catch (  TException e) {
    return false;
  }
  return false;
}","public static boolean columnFamilyExist(String columnfamilyName,String keyspaceName){
  try {
    client.set_keyspace(keyspaceName);
    client.system_add_column_family(new CfDef(keyspaceName,columnfamilyName));
  }
 catch (  InvalidRequestException irex) {
    StringBuilder builder=new StringBuilder(""String_Node_Str"");
    if (irex.getWhy() != null && irex.getWhy().contains(builder.toString())) {
      return true;
    }
    return false;
  }
catch (  SchemaDisagreementException e) {
    return false;
  }
catch (  TException e) {
    return false;
  }
  return true;
}",0.9939183318853172
175987,"public static boolean dropColumnFamily(String columnFamilyName,String keyspaceName){
  try {
    if (columnFamilyExist(columnFamilyName,keyspaceName)) {
      client.system_drop_column_family(columnFamilyName);
    }
  }
 catch (  InvalidRequestException e) {
    return true;
  }
catch (  SchemaDisagreementException e) {
    return false;
  }
catch (  TException e) {
    return false;
  }
  return true;
}","public static boolean dropColumnFamily(String columnFamilyName,String keyspaceName){
  try {
    if (columnFamilyExist(columnFamilyName,keyspaceName)) {
      client.system_drop_column_family(columnFamilyName);
    }
  }
 catch (  InvalidRequestException e) {
    return true;
  }
catch (  SchemaDisagreementException e) {
    return false;
  }
catch (  TException e) {
    return false;
  }
  return false;
}",0.9914320685434516
175988,"public static boolean columnFamilyExist(String columnfamilyName,String keyspaceName){
  try {
    client.set_keyspace(keyspaceName);
    client.system_add_column_family(new CfDef(keyspaceName,columnfamilyName));
  }
 catch (  InvalidRequestException irex) {
    StringBuilder builder=new StringBuilder(""String_Node_Str"");
    if (irex.getWhy() != null && irex.getWhy().contains(builder.toString())) {
      return true;
    }
    return false;
  }
catch (  SchemaDisagreementException e) {
    return false;
  }
catch (  TException e) {
    return false;
  }
  return false;
}","public static boolean columnFamilyExist(String columnfamilyName,String keyspaceName){
  try {
    client.set_keyspace(keyspaceName);
    client.system_add_column_family(new CfDef(keyspaceName,columnfamilyName));
  }
 catch (  InvalidRequestException irex) {
    StringBuilder builder=new StringBuilder(""String_Node_Str"");
    if (irex.getWhy() != null && irex.getWhy().contains(builder.toString())) {
      return true;
    }
    return false;
  }
catch (  SchemaDisagreementException e) {
    return false;
  }
catch (  TException e) {
    return false;
  }
  return true;
}",0.9939183318853172
175989,"private void findByRange(){
  EntityManager em;
  String query;
  Query q;
  List<StudentHBaseCharacter> students;
  em=emf.createEntityManager();
  query=""String_Node_Str"";
  q=em.createQuery(query);
  q.setParameter(1,getMinValue(Character.class));
  q.setParameter(2,getMaxValue(Character.class));
  students=q.getResultList();
  q=em.createQuery(query);
  students=q.getResultList();
  Assert.assertNotNull(students);
  Assert.assertEquals(2,students.size());
  int count=0;
  for (  StudentHBaseCharacter student : students) {
    if (student.getId().equals(getMinValue(Character.class))) {
      Assert.assertEquals(getPartialValue(short.class),student.getAge());
      Assert.assertEquals(getMinValue(String.class),student.getName());
      count++;
    }
 else {
      Assert.assertEquals(getRandomValue(Character.class),student.getId());
      Assert.assertEquals(getRandomValue(short.class),student.getAge());
      Assert.assertEquals(getRandomValue(String.class),student.getName());
      count++;
    }
  }
  Assert.assertEquals(2,count);
  em.close();
}","private void findByRange(){
  EntityManager em;
  String query;
  Query q;
  List<StudentHBaseCharacter> students;
  em=emf.createEntityManager();
  query=""String_Node_Str"";
  q=em.createQuery(query);
  q.setParameter(1,getMinValue(Character.class));
  q.setParameter(2,getMaxValue(Character.class));
  students=q.getResultList();
  Assert.assertNotNull(students);
  Assert.assertEquals(2,students.size());
  int count=0;
  for (  StudentHBaseCharacter student : students) {
    if (student.getId().equals(getMinValue(Character.class))) {
      Assert.assertEquals(getPartialValue(short.class),student.getAge());
      Assert.assertEquals(getMinValue(String.class),student.getName());
      count++;
    }
 else {
      Assert.assertEquals(getRandomValue(Character.class),student.getId());
      Assert.assertEquals(getRandomValue(short.class),student.getAge());
      Assert.assertEquals(getRandomValue(String.class),student.getName());
      count++;
    }
  }
  Assert.assertEquals(2,count);
  em.close();
}",0.9725565719788156
175990,"/** 
 * Create Update CQL query from a given JPA query.
 * @param kunderaQuery
 * @return
 */
public String createUpdateQuery(KunderaQuery kunderaQuery){
  EntityMetadata metadata=kunderaQuery.getEntityMetadata();
  MetamodelImpl metaModel=(MetamodelImpl)kunderaMetadata.getApplicationMetadata().getMetamodel(metadata.getPersistenceUnit());
  CQLTranslator translator=new CQLTranslator();
  String update_Query=translator.UPDATE_QUERY;
  String tableName=metadata.getTableName();
  update_Query=StringUtils.replace(update_Query,CQLTranslator.COLUMN_FAMILY,translator.ensureCase(new StringBuilder(),tableName,false).toString());
  StringBuilder builder=new StringBuilder(update_Query);
  Object ttlColumns=((CassandraClientBase)persistenceDelegeator.getClient(metadata)).getTtlValues().get(metadata.getTableName());
  if (ttlColumns != null && ttlColumns instanceof Integer) {
    int ttl=((Integer)ttlColumns).intValue();
    if (ttl != 0) {
      builder.append(""String_Node_Str"");
      builder.append(ttl);
      builder.append(""String_Node_Str"");
    }
  }
  builder.append(CQLTranslator.ADD_SET_CLAUSE);
  for (  UpdateClause updateClause : kunderaQuery.getUpdateClauseQueue()) {
    String property=updateClause.getProperty();
    String jpaColumnName=getColumnName(metadata,property);
    Object value=updateClause.getValue();
    translator.buildSetClause(metadata,builder,jpaColumnName,value);
  }
  builder.delete(builder.lastIndexOf(CQLTranslator.COMMA_STR),builder.length());
  builder.append(CQLTranslator.ADD_WHERE_CLAUSE);
  Class compoundKeyClass=metadata.getIdAttribute().getBindableJavaType();
  EmbeddableType compoundKey=null;
  String idColumn;
  if (metaModel.isEmbeddable(compoundKeyClass)) {
    compoundKey=metaModel.embeddable(compoundKeyClass);
    idColumn=((AbstractAttribute)metadata.getIdAttribute()).getJPAColumnName();
  }
 else {
    idColumn=((AbstractAttribute)metadata.getIdAttribute()).getJPAColumnName();
  }
  onCondition(metadata,metaModel,compoundKey,idColumn,builder,false,translator,false);
  return builder.toString();
}","/** 
 * Create Update CQL query from a given JPA query.
 * @param kunderaQuery
 * @return
 */
public String createUpdateQuery(KunderaQuery kunderaQuery){
  EntityMetadata metadata=kunderaQuery.getEntityMetadata();
  MetamodelImpl metaModel=(MetamodelImpl)kunderaMetadata.getApplicationMetadata().getMetamodel(metadata.getPersistenceUnit());
  CQLTranslator translator=new CQLTranslator();
  String update_Query=translator.UPDATE_QUERY;
  String tableName=metadata.getTableName();
  update_Query=StringUtils.replace(update_Query,CQLTranslator.COLUMN_FAMILY,translator.ensureCase(new StringBuilder(),tableName,false).toString());
  StringBuilder builder=new StringBuilder(update_Query);
  Object ttlColumns=((CassandraClientBase)persistenceDelegeator.getClient(metadata)).getTtlValues().get(metadata.getTableName());
  if ((ttlColumns != null && ttlColumns instanceof Integer) || this.ttl != null) {
    int ttl=this.ttl != null ? this.ttl : ((Integer)ttlColumns).intValue();
    if (ttl != 0) {
      builder.append(""String_Node_Str"");
      builder.append(ttl);
      builder.append(""String_Node_Str"");
    }
  }
  builder.append(CQLTranslator.ADD_SET_CLAUSE);
  for (  UpdateClause updateClause : kunderaQuery.getUpdateClauseQueue()) {
    String property=updateClause.getProperty();
    String jpaColumnName=getColumnName(metadata,property);
    Object value=updateClause.getValue();
    translator.buildSetClause(metadata,builder,jpaColumnName,value);
  }
  builder.delete(builder.lastIndexOf(CQLTranslator.COMMA_STR),builder.length());
  builder.append(CQLTranslator.ADD_WHERE_CLAUSE);
  Class compoundKeyClass=metadata.getIdAttribute().getBindableJavaType();
  EmbeddableType compoundKey=null;
  String idColumn;
  if (metaModel.isEmbeddable(compoundKeyClass)) {
    compoundKey=metaModel.embeddable(compoundKeyClass);
    idColumn=((AbstractAttribute)metadata.getIdAttribute()).getJPAColumnName();
  }
 else {
    idColumn=((AbstractAttribute)metadata.getIdAttribute()).getJPAColumnName();
  }
  onCondition(metadata,metaModel,compoundKey,idColumn,builder,false,translator,false);
  return builder.toString();
}",0.9875657580105212
175991,"/** 
 * Test method for  {@link com.impetus.client.cassandra.query.CassQuery#onQueryOverCQL3(com.impetus.kundera.metadata.model.EntityMetadata,com.impetus.kundera.client.Client,com.impetus.kundera.metadata.model.MetamodelImpl,java.util.List)}.
 * @throws InvocationTargetException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 */
@Test public void testUpdateDeleteQueryEmbeddedEntity() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  CassandraCli.createKeySpace(""String_Node_Str"");
  String pu=""String_Node_Str"";
  EntityManagerFactory emf=Persistence.createEntityManagerFactory(pu);
  EntityManager em=emf.createEntityManager();
  String queryString=""String_Node_Str"";
  String cqlQuery=parseAndCreateUpdateQuery(getQueryObject(queryString,emf),emf,em,pu,CassandraPrimeUser.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateUpdateQuery(getQueryObject(queryString,emf),emf,em,pu,CassandraPrimeUser.class,400);
  Assert.assertNotNull(cqlQuery);
  System.out.println(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  List<String> userIdList=new ArrayList<String>();
  userIdList.add(""String_Node_Str"");
  userIdList.add(""String_Node_Str"");
  userIdList.add(""String_Node_Str"");
  KunderaQuery kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",userIdList);
  cqlQuery=parseAndCreateUpdateQuery(kunderaQuery,emf,em,pu,CassandraPrimeUser.class,Integer.MAX_VALUE);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateDeleteQuery(getQueryObject(queryString,emf),emf,em,pu,CassandraPrimeUser.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateDeleteQuery(getQueryObject(queryString,emf),emf,em,pu,CassandraPrimeUser.class,400);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",userIdList);
  cqlQuery=parseAndCreateDeleteQuery(kunderaQuery,emf,em,pu,CassandraPrimeUser.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  em.close();
  emf.close();
  CassandraCli.dropKeySpace(""String_Node_Str"");
}","/** 
 * Test method for  {@link com.impetus.client.cassandra.query.CassQuery#onQueryOverCQL3(com.impetus.kundera.metadata.model.EntityMetadata,com.impetus.kundera.client.Client,com.impetus.kundera.metadata.model.MetamodelImpl,java.util.List)}.
 * @throws InvocationTargetException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 */
@Test public void testUpdateDeleteQueryEmbeddedEntity() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  CassandraCli.createKeySpace(""String_Node_Str"");
  String pu=""String_Node_Str"";
  EntityManagerFactory emf=Persistence.createEntityManagerFactory(pu);
  EntityManager em=emf.createEntityManager();
  String queryString=""String_Node_Str"";
  String cqlQuery=parseAndCreateUpdateQuery(getQueryObject(queryString,emf),emf,em,pu,CassandraPrimeUser.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateUpdateQuery(getQueryObject(queryString,emf),emf,em,pu,CassandraPrimeUser.class,400);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  List<String> userIdList=new ArrayList<String>();
  userIdList.add(""String_Node_Str"");
  userIdList.add(""String_Node_Str"");
  userIdList.add(""String_Node_Str"");
  KunderaQuery kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",userIdList);
  cqlQuery=parseAndCreateUpdateQuery(kunderaQuery,emf,em,pu,CassandraPrimeUser.class,Integer.MAX_VALUE);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateDeleteQuery(getQueryObject(queryString,emf),emf,em,pu,CassandraPrimeUser.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateDeleteQuery(getQueryObject(queryString,emf),emf,em,pu,CassandraPrimeUser.class,400);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",userIdList);
  cqlQuery=parseAndCreateDeleteQuery(kunderaQuery,emf,em,pu,CassandraPrimeUser.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  em.close();
  emf.close();
  CassandraCli.dropKeySpace(""String_Node_Str"");
}",0.993688362919132
175992,"/** 
 * Test method for  {@link com.impetus.client.cassandra.query.CassQuery#onQueryOverCQL3(com.impetus.kundera.metadata.model.EntityMetadata,com.impetus.kundera.client.Client,com.impetus.kundera.metadata.model.MetamodelImpl,java.util.List)}.
 * @throws InvocationTargetException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 */
@Test public void testOnQueryOverCQL3ForEmbeddedEntity() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  CassandraCli.createKeySpace(""String_Node_Str"");
  String pu=""String_Node_Str"";
  EntityManagerFactory emf=Persistence.createEntityManagerFactory(pu);
  EntityManager em=emf.createEntityManager();
  String queryString=""String_Node_Str"";
  String cqlQuery=parseAndCreateCqlQuery(getQueryObject(queryString,emf),emf,em,pu,CassandraPrimeUser.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateCqlQuery(getQueryObject(queryString,emf),emf,em,pu,CassandraPrimeUser.class,400);
  Assert.assertNotNull(cqlQuery);
  System.out.println(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  List<String> userIdList=new ArrayList<String>();
  userIdList.add(""String_Node_Str"");
  userIdList.add(""String_Node_Str"");
  userIdList.add(""String_Node_Str"");
  KunderaQuery kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",userIdList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,CassandraPrimeUser.class,Integer.MAX_VALUE);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",userIdList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,CassandraPrimeUser.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  List<CassandraCompoundKey> keyList=new ArrayList<CassandraCompoundKey>();
  UUID timeLineId1=UUID.randomUUID();
  keyList.add(new CassandraCompoundKey(""String_Node_Str"",1,timeLineId1));
  keyList.add(new CassandraCompoundKey(""String_Node_Str"",2,timeLineId1));
  keyList.add(new CassandraCompoundKey(""String_Node_Str"",3,timeLineId1));
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",keyList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,CassandraPrimeUser.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str"" + timeLineId1 + ""String_Node_Str""+ timeLineId1+ ""String_Node_Str""+ timeLineId1+ ""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.indexOf(""String_Node_Str"") > 0);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",keyList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,CassandraPrimeUser.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str"" + timeLineId1 + ""String_Node_Str""+ timeLineId1+ ""String_Node_Str""+ timeLineId1+ ""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.indexOf(""String_Node_Str"") > 0);
  em.close();
  emf.close();
  CassandraCli.dropKeySpace(""String_Node_Str"");
}","/** 
 * Test method for  {@link com.impetus.client.cassandra.query.CassQuery#onQueryOverCQL3(com.impetus.kundera.metadata.model.EntityMetadata,com.impetus.kundera.client.Client,com.impetus.kundera.metadata.model.MetamodelImpl,java.util.List)}.
 * @throws InvocationTargetException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 */
@Test public void testOnQueryOverCQL3ForEmbeddedEntity() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  CassandraCli.createKeySpace(""String_Node_Str"");
  String pu=""String_Node_Str"";
  EntityManagerFactory emf=Persistence.createEntityManagerFactory(pu);
  EntityManager em=emf.createEntityManager();
  String queryString=""String_Node_Str"";
  String cqlQuery=parseAndCreateCqlQuery(getQueryObject(queryString,emf),emf,em,pu,CassandraPrimeUser.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateCqlQuery(getQueryObject(queryString,emf),emf,em,pu,CassandraPrimeUser.class,400);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  List<String> userIdList=new ArrayList<String>();
  userIdList.add(""String_Node_Str"");
  userIdList.add(""String_Node_Str"");
  userIdList.add(""String_Node_Str"");
  KunderaQuery kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",userIdList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,CassandraPrimeUser.class,Integer.MAX_VALUE);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",userIdList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,CassandraPrimeUser.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  List<CassandraCompoundKey> keyList=new ArrayList<CassandraCompoundKey>();
  UUID timeLineId1=UUID.randomUUID();
  keyList.add(new CassandraCompoundKey(""String_Node_Str"",1,timeLineId1));
  keyList.add(new CassandraCompoundKey(""String_Node_Str"",2,timeLineId1));
  keyList.add(new CassandraCompoundKey(""String_Node_Str"",3,timeLineId1));
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",keyList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,CassandraPrimeUser.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str"" + timeLineId1 + ""String_Node_Str""+ timeLineId1+ ""String_Node_Str""+ timeLineId1+ ""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.indexOf(""String_Node_Str"") > 0);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",keyList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,CassandraPrimeUser.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str"" + timeLineId1 + ""String_Node_Str""+ timeLineId1+ ""String_Node_Str""+ timeLineId1+ ""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.contains(""String_Node_Str""));
  Assert.assertTrue(cqlQuery.indexOf(""String_Node_Str"") > 0);
  em.close();
  emf.close();
  CassandraCli.dropKeySpace(""String_Node_Str"");
}",0.9960089797954602
175993,"/** 
 * @param kunderaQuery
 * @return
 */
private String parseAndCreateUpdateQuery(KunderaQuery kunderaQuery,EntityManagerFactory emf,EntityManager em,String puName,Class entityClass,Integer maxResult){
  Method getpd=null;
  try {
    getpd=EntityManagerImpl.class.getDeclaredMethod(""String_Node_Str"");
  }
 catch (  SecurityException e) {
    e.printStackTrace();
  }
catch (  NoSuchMethodException e) {
    e.printStackTrace();
  }
  getpd.setAccessible(true);
  PersistenceDelegator pd=null;
  try {
    pd=(PersistenceDelegator)getpd.invoke(em);
  }
 catch (  IllegalArgumentException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
  }
  KunderaMetadata kunderaMetadata=((EntityManagerFactoryImpl)emf).getKunderaMetadataInstance();
  CassQuery query=new CassQuery(kunderaQuery,pd,kunderaMetadata);
  query.setMaxResults(maxResult);
  String cqlQuery=query.createUpdateQuery(kunderaQuery);
  return cqlQuery;
}","/** 
 * @param kunderaQuery
 * @return
 */
private String parseAndCreateUpdateQuery(KunderaQuery kunderaQuery,EntityManagerFactory emf,EntityManager em,String puName,Class entityClass,Integer maxResult,Integer ttl){
  Method getpd=null;
  try {
    getpd=EntityManagerImpl.class.getDeclaredMethod(""String_Node_Str"");
  }
 catch (  SecurityException e) {
    e.printStackTrace();
  }
catch (  NoSuchMethodException e) {
    e.printStackTrace();
  }
  getpd.setAccessible(true);
  PersistenceDelegator pd=getPersistenceDelegator(em,getpd);
  KunderaMetadata kunderaMetadata=((EntityManagerFactoryImpl)emf).getKunderaMetadataInstance();
  CassQuery query=new CassQuery(kunderaQuery,pd,kunderaMetadata);
  query.setMaxResults(maxResult);
  if (ttl != null) {
    query.applyTTL(ttl);
  }
  String cqlQuery=query.createUpdateQuery(kunderaQuery);
  return cqlQuery;
}",0.8289334741288279
175994,"/** 
 * Test method for  {@link com.impetus.client.cassandra.query.CassQuery#onQueryOverCQL3(com.impetus.kundera.metadata.model.EntityMetadata,com.impetus.kundera.client.Client,com.impetus.kundera.metadata.model.MetamodelImpl,java.util.List)}.
 * @throws InvocationTargetException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 */
@Test public void testOnQueryOverCQL3ForSimpleEntity() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  CassandraCli.createKeySpace(""String_Node_Str"");
  String pu=""String_Node_Str"";
  EntityManagerFactory emf=Persistence.createEntityManagerFactory(pu);
  EntityManager em=emf.createEntityManager();
  String queryString=""String_Node_Str"";
  String cqlQuery=parseAndCreateCqlQuery(getQueryObject(queryString,emf),emf,em,pu,PersonCassandra.class,200);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateCqlQuery(getQueryObject(queryString,emf),emf,em,pu,PersonCassandra.class,400);
  Assert.assertNotNull(cqlQuery);
  System.out.println(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  List<String> nameList=new ArrayList<String>();
  nameList.add(""String_Node_Str"");
  nameList.add(""String_Node_Str"");
  nameList.add(""String_Node_Str"");
  KunderaQuery kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",nameList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,Integer.MAX_VALUE);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",nameList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,Integer.MAX_VALUE);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",nameList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,5);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  List<Integer> ageList=new ArrayList<Integer>();
  ageList.add(10);
  ageList.add(20);
  ageList.add(30);
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",ageList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  em.close();
  emf.close();
  CassandraCli.dropKeySpace(""String_Node_Str"");
}","/** 
 * Test method for  {@link com.impetus.client.cassandra.query.CassQuery#onQueryOverCQL3(com.impetus.kundera.metadata.model.EntityMetadata,com.impetus.kundera.client.Client,com.impetus.kundera.metadata.model.MetamodelImpl,java.util.List)}.
 * @throws InvocationTargetException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 */
@Test public void testOnQueryOverCQL3ForSimpleEntity() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  CassandraCli.createKeySpace(""String_Node_Str"");
  String pu=""String_Node_Str"";
  EntityManagerFactory emf=Persistence.createEntityManagerFactory(pu);
  EntityManager em=emf.createEntityManager();
  String queryString=""String_Node_Str"";
  String cqlQuery=parseAndCreateCqlQuery(getQueryObject(queryString,emf),emf,em,pu,PersonCassandra.class,200);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateCqlQuery(getQueryObject(queryString,emf),emf,em,pu,PersonCassandra.class,400);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  List<String> nameList=new ArrayList<String>();
  nameList.add(""String_Node_Str"");
  nameList.add(""String_Node_Str"");
  nameList.add(""String_Node_Str"");
  KunderaQuery kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",nameList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,Integer.MAX_VALUE);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",nameList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,Integer.MAX_VALUE);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",nameList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,5);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  List<Integer> ageList=new ArrayList<Integer>();
  ageList.add(10);
  ageList.add(20);
  ageList.add(30);
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",ageList);
  cqlQuery=parseAndCreateCqlQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  em.close();
  emf.close();
  CassandraCli.dropKeySpace(""String_Node_Str"");
}",0.9942363112391932
175995,"/** 
 * Test method for  {@link com.impetus.client.cassandra.query.CassQuery#onQueryOverCQL3(com.impetus.kundera.metadata.model.EntityMetadata,com.impetus.kundera.client.Client,com.impetus.kundera.metadata.model.MetamodelImpl,java.util.List)}.
 * @throws InvocationTargetException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 */
@Test public void testUpdateDeleteQuerySimpleEntity() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  CassandraCli.createKeySpace(""String_Node_Str"");
  String pu=""String_Node_Str"";
  EntityManagerFactory emf=Persistence.createEntityManagerFactory(pu);
  EntityManager em=emf.createEntityManager();
  String queryString=""String_Node_Str"";
  String cqlQuery=parseAndCreateUpdateQuery(getQueryObject(queryString,emf),emf,em,pu,PersonCassandra.class,200);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateUpdateQuery(getQueryObject(queryString,emf),emf,em,pu,PersonCassandra.class,400);
  Assert.assertNotNull(cqlQuery);
  System.out.println(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  List<String> id=new ArrayList<String>();
  id.add(""String_Node_Str"");
  id.add(""String_Node_Str"");
  id.add(""String_Node_Str"");
  KunderaQuery kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",id);
  cqlQuery=parseAndCreateUpdateQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,Integer.MAX_VALUE);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",id);
  cqlQuery=parseAndCreateUpdateQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,Integer.MAX_VALUE);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateDeleteQuery(getQueryObject(queryString,emf),emf,em,pu,PersonCassandra.class,400);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateDeleteQuery(getQueryObject(queryString,emf),emf,em,pu,PersonCassandra.class,400);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",id);
  cqlQuery=parseAndCreateDeleteQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,Integer.MAX_VALUE);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",id);
  cqlQuery=parseAndCreateDeleteQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  em.close();
  emf.close();
  CassandraCli.dropKeySpace(""String_Node_Str"");
}","/** 
 * Test method for  {@link com.impetus.client.cassandra.query.CassQuery#onQueryOverCQL3(com.impetus.kundera.metadata.model.EntityMetadata,com.impetus.kundera.client.Client,com.impetus.kundera.metadata.model.MetamodelImpl,java.util.List)}.
 * @throws InvocationTargetException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 */
@Test public void testUpdateDeleteQuerySimpleEntity() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  CassandraCli.createKeySpace(""String_Node_Str"");
  String pu=""String_Node_Str"";
  EntityManagerFactory emf=Persistence.createEntityManagerFactory(pu);
  EntityManager em=emf.createEntityManager();
  String queryString=""String_Node_Str"";
  String cqlQuery=parseAndCreateUpdateQuery(getQueryObject(queryString,emf),emf,em,pu,PersonCassandra.class,200);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateUpdateQuery(getQueryObject(queryString,emf),emf,em,pu,PersonCassandra.class,400);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  List<String> id=new ArrayList<String>();
  id.add(""String_Node_Str"");
  id.add(""String_Node_Str"");
  id.add(""String_Node_Str"");
  KunderaQuery kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",id);
  cqlQuery=parseAndCreateUpdateQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,Integer.MAX_VALUE);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",id);
  cqlQuery=parseAndCreateUpdateQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,Integer.MAX_VALUE);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateDeleteQuery(getQueryObject(queryString,emf),emf,em,pu,PersonCassandra.class,400);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  cqlQuery=parseAndCreateDeleteQuery(getQueryObject(queryString,emf),emf,em,pu,PersonCassandra.class,400);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",id);
  cqlQuery=parseAndCreateDeleteQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,Integer.MAX_VALUE);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  queryString=""String_Node_Str"";
  kunderaQuery=getQueryObject(queryString,emf);
  kunderaQuery.setParameter(""String_Node_Str"",id);
  cqlQuery=parseAndCreateDeleteQuery(kunderaQuery,emf,em,pu,PersonCassandra.class,100);
  Assert.assertNotNull(cqlQuery);
  Assert.assertEquals(""String_Node_Str"",cqlQuery);
  em.close();
  emf.close();
  CassandraCli.dropKeySpace(""String_Node_Str"");
}",0.9948470209339776
175996,"/** 
 * @param kunderaQuery
 * @return
 */
private String parseAndCreateCqlQuery(KunderaQuery kunderaQuery,EntityManagerFactory emf,EntityManager em,String puName,Class entityClass,Integer maxResult){
  Method getpd=null;
  try {
    getpd=EntityManagerImpl.class.getDeclaredMethod(""String_Node_Str"");
  }
 catch (  SecurityException e) {
    e.printStackTrace();
  }
catch (  NoSuchMethodException e) {
    e.printStackTrace();
  }
  getpd.setAccessible(true);
  PersistenceDelegator pd=null;
  try {
    pd=(PersistenceDelegator)getpd.invoke(em);
  }
 catch (  IllegalArgumentException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
  }
  KunderaMetadata kunderaMetadata=((EntityManagerFactoryImpl)emf).getKunderaMetadataInstance();
  CassQuery query=new CassQuery(kunderaQuery,pd,kunderaMetadata);
  query.setMaxResults(maxResult);
  EntityMetadata metadata=KunderaMetadataManager.getEntityMetadata(kunderaMetadata,entityClass);
  Metamodel metaModel=KunderaMetadataManager.getMetamodel(kunderaMetadata,puName);
  Client<CassQuery> client=pd.getClient(metadata);
  String cqlQuery=query.onQueryOverCQL3(metadata,client,(MetamodelImpl)metaModel,metadata.getRelationNames());
  return cqlQuery;
}","/** 
 * @param kunderaQuery
 * @return
 */
private String parseAndCreateCqlQuery(KunderaQuery kunderaQuery,EntityManagerFactory emf,EntityManager em,String puName,Class entityClass,Integer maxResult){
  Method getpd=null;
  try {
    getpd=EntityManagerImpl.class.getDeclaredMethod(""String_Node_Str"");
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e.getMessage());
  }
  getpd.setAccessible(true);
  PersistenceDelegator pd=getPersistenceDelegator(em,getpd);
  KunderaMetadata kunderaMetadata=((EntityManagerFactoryImpl)emf).getKunderaMetadataInstance();
  CassQuery query=new CassQuery(kunderaQuery,pd,kunderaMetadata);
  query.setMaxResults(maxResult);
  EntityMetadata metadata=KunderaMetadataManager.getEntityMetadata(kunderaMetadata,entityClass);
  Metamodel metaModel=KunderaMetadataManager.getMetamodel(kunderaMetadata,puName);
  Client<CassQuery> client=pd.getClient(metadata);
  String cqlQuery=query.onQueryOverCQL3(metadata,client,(MetamodelImpl)metaModel,metadata.getRelationNames());
  return cqlQuery;
}",0.8334043459735833
175997,"/** 
 * Tokenize.
 * @param where the where
 * @param pattern the pattern
 * @return the list
 */
private static List<String> tokenize(String where,Pattern pattern,boolean isInterClause){
  List<String> split=new ArrayList<String>();
  Matcher matcher=pattern.matcher(where);
  int lastIndex=0;
  String s;
  while (matcher.find()) {
    s=where.substring(lastIndex,matcher.start()).trim();
    addSplit(isInterClause,split,s);
    s=matcher.group();
    split.add(s.toUpperCase());
    lastIndex=matcher.end();
    if (!isInterClause)     break;
  }
  s=where.substring(lastIndex).trim();
  if (!s.equals(""String_Node_Str"")) {
    if (isInterClause) {
      if (s.startsWith(""String_Node_Str"") && s.endsWith(""String_Node_Str"")) {
        split.add(""String_Node_Str"");
        split.add(s.substring(s.indexOf(""String_Node_Str"") + 1,s.lastIndexOf(""String_Node_Str"")));
        split.add(""String_Node_Str"");
      }
 else {
        split.add(s);
      }
    }
 else {
      split.add(s);
    }
  }
  return split;
}","/** 
 * Tokenize.
 * @param where the where
 * @param pattern the pattern
 * @return the list
 */
private static List<String> tokenize(String where,Pattern pattern,boolean isInterClause){
  List<String> split=new ArrayList<String>();
  Matcher matcher=pattern.matcher(where);
  int lastIndex=0;
  String s;
  while (matcher.find()) {
    s=where.substring(lastIndex,matcher.start()).trim();
    addSplit(isInterClause,split,s);
    s=matcher.group();
    if (s.equalsIgnoreCase(""String_Node_Str"") || s.equalsIgnoreCase(""String_Node_Str"") || s.equalsIgnoreCase(""String_Node_Str""))     s=""String_Node_Str"" + s + ""String_Node_Str"";
    split.add(s.toUpperCase());
    lastIndex=matcher.end();
    if (!isInterClause)     break;
  }
  s=where.substring(lastIndex).trim();
  if (!s.equals(""String_Node_Str"")) {
    if (isInterClause) {
      if (s.startsWith(""String_Node_Str"") && s.endsWith(""String_Node_Str"")) {
        split.add(""String_Node_Str"");
        split.add(s.substring(s.indexOf(""String_Node_Str"") + 1,s.lastIndexOf(""String_Node_Str"")));
        split.add(""String_Node_Str"");
      }
 else {
        split.add(s);
      }
    }
 else {
      split.add(s);
    }
  }
  return split;
}",0.9192377495462796
175998,"public static boolean dropColumnFamily(String columnFamilyName,String keyspaceName){
  try {
    if (columnFamilyExist(columnFamilyName,keyspaceName)) {
      client.system_drop_column_family(columnFamilyName);
    }
  }
 catch (  InvalidRequestException e) {
    return true;
  }
catch (  SchemaDisagreementException e) {
    return false;
  }
catch (  TException e) {
    return false;
  }
  return false;
}","public static boolean dropColumnFamily(String columnFamilyName,String keyspaceName){
  try {
    if (columnFamilyExist(columnFamilyName,keyspaceName)) {
      client.system_drop_column_family(columnFamilyName);
    }
  }
 catch (  InvalidRequestException e) {
    return true;
  }
catch (  SchemaDisagreementException e) {
    return false;
  }
catch (  TException e) {
    return false;
  }
  return true;
}",0.9914320685434516
175999,"@Override public void delete(Object entity,Object pKey){
  Object connection=getConnection();
  Pipeline pipeLine=null;
  try {
    if (resource == null) {
      pipeLine=((Jedis)connection).pipelined();
      onDelete(entity,pKey,pipeLine);
    }
 else {
      onDelete(entity,pKey,connection);
    }
  }
  finally {
    if (pipeLine != null) {
      pipeLine.sync();
    }
    onCleanup(connection);
  }
}","@Override public void delete(Object entity,Object pKey){
  Object connection=getConnection();
  Pipeline pipeLine=null;
  try {
    if (isBoundTransaction()) {
      pipeLine=((Jedis)connection).pipelined();
      onDelete(entity,pKey,pipeLine);
    }
 else {
      onDelete(entity,pKey,connection);
    }
  }
  finally {
    if (pipeLine != null) {
      pipeLine.sync();
    }
    onCleanup(connection);
  }
}",0.960880195599022
176000,"/** 
 * Returns jedis connection.
 * @return jedis resource.
 */
private Object getConnection(){
  if (resource == null && this.connection != null) {
    return this.connection;
  }
  Jedis conn=factory.getConnection();
  if (settings != null) {
    for (    String key : settings.keySet()) {
      conn.configSet(key,settings.get(key).toString());
    }
  }
  if (resource != null && resource.isActive()) {
    return ((RedisTransaction)resource).bindResource(conn);
  }
 else {
    this.connection=conn;
    return conn;
  }
}","/** 
 * Returns jedis connection.
 * @return jedis resource.
 */
private Object getConnection(){
  if (isBoundTransaction() && this.connection != null) {
    return this.connection;
  }
  if (resource != null && resource.isActive()) {
    if (((RedisTransaction)resource).isResourceBound()) {
      return ((RedisTransaction)resource).getResource();
    }
 else {
      Jedis conn=getAndSetConnection();
      return ((RedisTransaction)resource).bindResource(conn);
    }
  }
 else {
    Jedis conn=getAndSetConnection();
    return conn;
  }
}",0.2406716417910447
